{
    "Shader": {
        "info": {
            "date": "1534787321",
            "description": "Backend of [url=http://pouet.net/prod.php?which=76627]The Emoji Demo[/url]. The C code contained a table of 64 emojis, the shader simply wrote a single-channel framebuffer containing an index into that table for each pixel - this is what the C code saw.",
            "flags": 64,
            "hasliked": 0,
            "id": "4tycRz",
            "likes": 6,
            "name": "The Emoji Demo Behind The Scenes",
            "published": 3,
            "tags": [
                "emoji",
                "behindthescenes"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 698
        },
        "renderpass": [
            {
                "code": "// hack to show what the demo was *really* running at\n#define LOW_RES\n\n// show the actual gradient values, unaffected by the table remapping\n//#define JUST_GRADIENT\n\n// in the real demo this was fed from the C side, here's a hack for shadertoy\n#define iBeat ((iTime-5.5)*2.9)\n\n#define R iResolution\n#define PI (acos(-1.))\n//uniform sampler2D texCreds;\nconst vec2 rangeRainbow  = vec2(0, 9);\nconst vec2 rangeSkintone = vec2(16, 20);\nconst vec2 rangeMoon     = vec2(21, 28);\nconst vec2 rangeHalfMoon = vec2(21, 25);\nconst vec2 rangeBlack    = vec2(32, 32);\nconst vec2 rangeReds     = vec2(32, 35);\nconst vec2 rangeBooks    = vec2(40, 44);\nconst vec2 rangePinks    = vec2(52, 55);\n\nvec2 rotate(vec2 p,float a){return cos(a)*p+sin(a)*vec2(-p.y,p.x);}\n\n// custom emoji range encoder\nfloat encode(vec3 params)\n{\n\t// x = gradient value\n\t// y = range min\n\t// z = range max\n\treturn (floor(mix(params.y, params.z + .99, clamp(params.x,0.,1.))) + .5) / 64.;\n}\n\nfloat sdDonut(vec3 p)\n{\n\tfloat angle = iBeat * .5;\n\tp.xy = rotate(p.xy, angle);\n\tp.xz = rotate(p.xz, angle);\n\tp.yz = rotate(p.yz, angle);\n\tvec2 t = vec2(1.5,.5);\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat hash(float seed)\n{\n\treturn fract(sin(seed)*43758.5453 );\n}\n\nfloat hash2(vec2 seed)\n{\n\treturn hash(seed.x+seed.y*137.31);\n}\n\nvec2 hash12(float seed)\n{\n\treturn vec2(hash(seed),hash(seed+1.));\n}\n\nvec3 fizzer(vec2 fragCoord,vec3 params, float weight)\n{\n\tvec3 ran = fract(vec3((fragCoord.xy)+iBeat*8.,hash2(fragCoord.xy+iBeat*8.)));\n\tran = vec3(ran.z,29,31);\n\treturn hash2(fragCoord.yx) < weight ? ran : params;\n}\n\nfloat mlength(vec2 a)\n{\n\ta=abs(a);\n\treturn (a.x+a.y);\n}\n\nfloat cube(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdGrid(vec3 p)\n{\n\tvec3 c = vec3(3.);\n\tp = mod(p,c)-0.5*c;\n\t\n\tfloat cyx = cube(p, vec3(0.15, 0.15, 2.5));\n\tfloat cyy = cube(p, vec3(0.15, 2.5, 0.15));\n\tfloat cyz = cube(p, vec3(2.5, 0.15, 0.15));\n\n\treturn min(min(cyx,cyy),cyz);\n\n\tfloat d = length(p)-1.2;\n}\n\nfloat sdCube(vec3 p)\n{\n\tfloat angle = iBeat * .5;\n\tp.xy = rotate(p.xy, angle);\n\tp.xz = rotate(p.xz, angle);\n\tp.yz = rotate(p.yz, angle);\n\treturn cube(p, vec3(.9))-.3;\n}\n\nvec3 stereographic(vec2 uv)\n{\n\treturn vec3(\n\t\t(uv.xy*2.)/(1.+dot(uv.xy,uv.xy)),\n\t\t(-1.+uv.x*uv.x+uv.y*uv.y)/(1.+uv.x*uv.x+uv.y*uv.y)\n\t);\n}\n\nvoid sceneDualCircles(vec2 uv, out vec3 params)\n{\n\tuv *= .1+fract(iBeat*.0625*.5)*3.5;\n\tvec3 p=stereographic(uv);\n\t\n\tparams = vec3(fract(p.x*2.+iBeat),rangeMoon);\n}\n\nvoid sceneDualCircles2(vec2 uv, out vec3 params)\n{\n\tvec3 p=stereographic(uv*3.);\n\n\tp.xz=mod(rotate(p.xz,iBeat*.5),1.)-.5;\n\n\tparams= vec3(\n\t\tsign(p.x*p.y*p.z),\n\t\tvec2(29,31)\n\t);\n}\n\nvoid sceneOutrunGrid(vec2 uv, out vec3 params)\n{\n\tuv.y = -abs(uv.y);\n\tuv.y-=.25;\n\tvec3 cam = vec3(0,1,0);\n\tvec3 dir = normalize(vec3(uv,1));\n\n\tdir.xz = rotate(dir.xz,sin(iBeat*.2)*2.);\n\tcam.x += iBeat;\n\n\tfloat t = cam.y / -dir.y;\n\tvec3 hit = cam+dir*t;\n\n\thit = floor(hit);\n\n\tfloat a = clamp(1.3/t+.1,0.,1.);\n\tparams.x = mod(hit.x+hit.z,2.)<1.?a:0.;\n\tparams.yz = rangePinks;\n}\n\nvoid sceneRoad(vec2 uv, out vec3 params)\n{\n\tuv.y -= .4;\n\n\tvec3 cam = vec3(0,1,0);\n\tvec3 dir = normalize(vec3(uv,1));\n\tfloat t = cam.y / -dir.y;\n\tvec3 hit = cam+dir*t;\n\t\n\thit.x += sin(hit.z+iBeat)*.3;\n\thit.x += sin(iBeat-1.9)*.3;\n\thit.z *= 2.;\n\thit.z += iBeat*2.;\n\n\tvec3 grass = vec3(1.-length(sin(hit.xz*2.))/sqrt(2.), 56,57);\n\tvec3 road = vec3(.5+normalize(sin(hit.z*PI))*.5, 58, 59);\n\tvec3 redwhite = vec3(.5+normalize(sin(hit.z*PI*2.))*.5, 31, 35);\n\tvec2 skyUv = uv*2.+vec2(1,0.37);\n\tfloat skyr = length(skyUv);\n\tvec3 sky = vec3(\n\t\tclamp(skyr*1.4-.1,0.,1.),\n\t\t60,\n\t\t62\n\t);\n\tif (skyr < .16)\n\t\tsky = vec3(0,63,63);\n\n\n\tif(uv.y > -.2)\n\t\tparams = sky;\n\telse if(abs(hit.x)<.8)\n\t\tparams = road;\n\telse if(abs(hit.x)<.9)\n\t\tparams = redwhite;\n\telse\n\t\tparams = grass;\n}\n\nvoid sceneRainbowPlasma(vec2 uv, vec2 screenUv, out vec3 params)\n{\n\tfloat b = iBeat * .25;\n\tfloat scale = cos(b)*.5+1.;\n\tuv *= scale;\n\tparams.x = fract(length(sin(rotate(uv*5.,b)))/sqrt(2.)+b);\n\tparams.yz = rangeRainbow;\n\t\n\tif(iBeat >= 95.5\n\t||(iBeat >= 95. && screenUv.x < .83)\n\t||(iBeat >= 94.5 && screenUv.x < .67)\n\t||(iBeat >= 93.5 && screenUv.x < .5)\n\t||(iBeat >= 92.5 && screenUv.x < .33)\n\t||(iBeat >= 92. && screenUv.x < .17))\n\t\tparams.yz = rangeBlack;\n}\n\nvoid sceneSquareTunnel(vec2 uv, out vec3 params)\n{\n\tif (iBeat >= 48.){\n\t\tuv = abs(uv);\n\t\tuv=vec2(max(uv.x,uv.y),min(uv.x,uv.y));\n\t}\n\t\n\tuv = rotate(uv,iBeat*.125);\n\tparams.x = fract(1./mlength(uv*2.)+iBeat);\n\tparams.yz = iBeat < 48. ? vec2(29,31) : rangeBooks;\n\tif(mlength(uv)<.2)\n\t\tparams.yz = rangeBlack;\n}\n\nvoid sceneCredits(vec2 uv, vec2 screenUv, out vec3 params)\n{\n\tparams = vec3(\n\t\tclamp(sin(uv.x*16. - 12.*uv.y - 2.*iBeat*sign(uv.y))*uv.y+.3,0.,1.),\n\t\t52,53\n\t);\n\n\tparams.x = sin(mlength(uv)*15.+iBeat*2.*sign(uv.x*uv.y))*.5+.5;\n\n\tfloat cw = -cos((mod(iBeat-32.,64.)/32.)*PI);\n\tcw = min(cw * 3., 1.);\n    \n    // removed this because I can't put the credits texture on shadertoy\n\t//if(texture2D(texCreds,screenUv).r < .5 && hash2(gl_FragCoord.xy) < cw)\n\t//{\n\t//\tparams=vec3(0,39,39);\n\t//}\n}\n\nvoid sceneCube(vec2 fragCoord, vec2 uv, out vec3 params)\n{\n\tvec3 dir = normalize(vec3(uv.x, uv.y, 1.));\n\tvec3 ray=vec3(0,0,-5.);\n\tfloat t=0.0;\n\tfloat k = 0.;\n\tfor(int i=0;i<32;i++)\n\t{\n\t\tk=sdCube(ray+dir*t);\n\t\tt+=k*0.75;\n\t}\n\tvec3 hit=ray+dir*t;\n\tvec2 h=vec2(-0.002,0.0);\n\tvec3 n=normalize(vec3(sdCube(hit+h.xyy),sdCube(hit+h.yxy),sdCube(hit+h.yyx)));\n\tfloat color = .0;\n\tparams = vec3(0,rangeBlack);\n\tif(abs(k)<.001)\n\t{\n\t\tvec2 range = rangeSkintone;\n\t\tif(iBeat >= 158.) {\n\t\t\trange = hash12(floor(iBeat*4.))*63.;\n\t\t}\n\t\tvec3 light = vec3(-.5,-.5,1);\n\t\tcolor = max(0.,dot(n,normalize(light)));\n\t\tparams = vec3(\n\t\t\tcolor*color + hash2(fragCoord.xy)*.3,\n\t\t\trange\n\t\t);\n\t}\n}\n\nvoid sceneFirePlasma(vec2 fragCoord, vec2 uv, out vec3 params)\n{\n\tuv.x=abs(uv.x);\n\tfloat t = iBeat*.4;\n\tfloat a = sin(dot(uv,vec2(cos(t),sin(t)))*5.);\n\tfloat b = sin(length(uv+sin(t)*.3)*8.-t*2.);\n\tparams = vec3(\n\t\t((a+b)*.25+.5)*.85+hash2(fragCoord.xy)*.15,\n\t\t10,15\n\t);\n}\n\nvoid sceneRedSDF(vec2 uv, out vec3 params)\n{\n\t// biggest hack in the prod ;D\n\tfloat moontoggle = iBeat > 256. ? 0. : 10000.;\n\tvec3 dir = normalize(vec3(uv.xy, 1.));\n\tdir.xy=rotate(dir.xy,-iBeat*0.15);\n\tdir.zx=rotate(dir.zx,-iBeat*0.15);\n\tvec3 ray=vec3(1.,1.,iBeat);\n\tfloat t=0.0;\n\tfloat k = 0.;\n\tfor(int i=0;i<32;i++)\n\t{\n\t\tk=min(sdGrid(ray+dir*t),sdGrid(ray+dir*t+1.5)+moontoggle);\n\t\tt+=k*0.75;\n\t}\n\tvec3 hit=ray+dir*t;\n\tvec2 h=vec2(-0.002,0.);\n\tvec3 n=normalize(vec3(\n\t\tmin(sdGrid(hit+h.xyy),sdGrid(hit+h.xyy+1.5)+moontoggle),\n\t\tmin(sdGrid(hit+h.yxy),sdGrid(hit+h.yxy+1.5)+moontoggle),\n\t\tmin(sdGrid(hit+h.yyx),sdGrid(hit+h.yyx+1.5)+moontoggle)\n\t));\n\tfloat distanc = length(hit-ray);\n\tfloat attenDist = 12.0;\n\tfloat atten = max(0.0, attenDist-distanc)/attenDist;\n\tvec3 light = ray;\n\tfloat color = atten * dot(n, normalize(hit-light));\n\tparams.x = clamp(color*1.5,0.,1.);\n\tparams.yz = sdGrid(hit+1.5)+moontoggle < .1 ? rangeHalfMoon : rangeReds;\n}\n\n// recycle from last demo lol\nvec2 checker_checkerboard(vec2 uv){\n\tuv=floor(abs(uv)*1.-.5);\n\tif(mod(uv.x+uv.y,2.)<1.)\n\t\treturn vec2(0.);\n\treturn vec2(1.);\n}\nvec2 checker_uvs(vec2 uv, float z){\n\tuv.x+=sin(iTime+z*.3)*.2;\n\tuv.x-=sin(iTime+.0)*.2;\n\tuv.y+=cos(iTime*.7+z*.2)*.2;\n\tuv.y-=cos(iTime*.7+.0)*.2;\n\treturn uv*pow(2.,z);\n}\n\nvoid sceneChecker(vec2 uv, out vec3 params)\n{\n\tfor(int I=0;I<20;I++){\n\t\tfloat z=float(I)-fract(iBeat);\n\t\tvec2 d=checker_checkerboard(checker_uvs(uv,z));\n\t\tif(d.y>.5)\n\t\t{\n\t\t\tparams=vec3(fract((float(I)+floor(iBeat))/5.),rangeRainbow);\n\t\t\treturn;\n\t\t}\n\t}\n\tparams = vec3(0, rangeBlack);\n}\n\nvoid sceneMatrix(vec2 screenUv, out vec3 params)\n{\n\tfloat speed = hash(screenUv.x)*.5+.2;\n\tfloat y = fract(screenUv.y + speed*iBeat);\n\tparams = vec3(.05/y,36,38);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    #if defined(LOW_RES)\n    fragCoord /= R.xy;\n    fragCoord = (floor(fragCoord * vec2(40,24)) + .5)/vec2(40,24);\n    fragCoord *= R.xy;\n    #endif\n    \n    vec2 screenUv = fragCoord.xy / R.xy;\n    vec2 uv = screenUv - .5;\n\tuv.x *= R.x/R.y;\n\n\tvec3 params=vec3(0);\n\tif (iBeat < 32.)\n\t{\n\t\tfloat d = length(uv)-.5;\n\t\tif(iBeat > 1.)\n\t\t{\n\t\t\tfloat sm = max(\n\t\t\t\tlength(uv)-.35,\n\t\t\t\t.39-length(uv-vec2(0,.1))\n\t\t\t);\n\t\t\td=max(d,-sm);\n\t\t}\n\t\tif(iBeat > 2.)\n\t\t{\n\t\t\tfloat e = length(uv-vec2(-.19,.15))-.08;\n\t\t\td = max(d,-e);\n\t\t}\n\t\tif(iBeat > 3.)\n\t\t{\n\t\t\tfloat e = length(uv-vec2(.19,.15))-.08;\n\t\t\td = max(d,-e);\n\t\t}\n\n\t\tparams = vec3(-d*10.+.4,36,38);\n\n\t\tfloat w= clamp((iBeat-16.)/14.,0.,1.);\n\t\tparams = fizzer(fragCoord,params,w*w);\n\t}\n\telse if (iBeat < 64.)\n\t{\n\t\tsceneSquareTunnel(uv, params);\n\t}\n\telse if (iBeat < 96.)\n\t{\n\t\tsceneRainbowPlasma(uv, screenUv, params);\n\t}\n\telse if (iBeat < 128.)\n\t{\n\t\tsceneRoad(uv, params);\n\t}\n\telse if (iBeat < 160.)\n\t{\n\t\tsceneCube(fragCoord, uv, params);\n\t}\n\telse if (iBeat < 192.)\n\t{\n\t\tsceneMatrix(screenUv, params);\n\t}\n\telse if (iBeat < 224.)\n\t{\n\t\tsceneDualCircles(uv, params);\n\t}\n\telse if (iBeat < 288.)\n\t{\n\t\tsceneRedSDF(uv, params);\n\t}\n\telse if (iBeat < 352.)\n\t{\n\t\tsceneCredits(uv, screenUv, params);\n\t\tfloat w= clamp((iBeat-340.)/10.,0.,1.);\n\t\tparams = fizzer(fragCoord,params,w*w);\n\t}\n\telse if (iBeat < 384.)\n\t{\n\t\tsceneOutrunGrid(uv, params);\n\t}\n\telse if (iBeat < 416.)\n\t{\n\t\tsceneDualCircles2(uv, params);\n\t}\n\telse if (iBeat < 448.)\n\t{\n\t\tsceneChecker(uv, params);\n\t}\n\telse if (iBeat < 480.)\n\t{\n\t\tsceneFirePlasma(fragCoord,uv,params);\n\t}\n\telse\n\t{\n\t\tparams.yz = rangeBlack;\n\t}\n\t\n\n\t//fragColor.r = encode(params);\n    #if defined(JUST_GRADIENT)\n    fragColor.rgb = params.rrr;\n    #else\n    fragColor.rgb = vec3(encode(params));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 15879,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/subi211/the-emoji-demo-tune"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}