{
    "Shader": {
        "info": {
            "date": "1471052512",
            "description": "A collection of 18 experiments in creating objects using domain operations, now divided into three parts because the earlier version was causing webgl crashes for some viewers. Shader begins in auto mode, 10 seconds per object.  ",
            "flags": 48,
            "hasliked": 0,
            "id": "lttGzs",
            "likes": 6,
            "name": "DomainManipMenagerie part one",
            "published": 3,
            "tags": [
                "3d",
                "domainmanipulation",
                "keyboardiinput"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "/*\n\t\"Domain Manipulation Menagerie\" by wjbgrafx\n\t\n\tA collection of experiments in creating objects using domain operations.\n\t\n\tCode based on :\n\t---------------\t\n\tPlaying with symmetries - Torus\t   by @paulofalcao\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n\tCode for saving and updating data in a buffer :\n\t-----------------------------------------------\n\thttps://www.shadertoy.com/view/MscGDS\n\tState Demo     Uploaded by sixstring982 in 2016-Jan-4\n\t\"RAM in Shadertoy\" tutorial by Trent Small ( sixstring982 ) :\n\thttp://lunagameserve.com/articles/shadertoy_ram.html\n\t\n\tAdditional sources:\n\t-------------------\n\t\"Raymarching Primitives\"  Created by inigo quilez\n\thttps://www.shadertoy.com/view/Xds3zN\n\t\n\tHG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n\thttp://mercury.sexy/hg_sdf\n\t\n\tpyramid function :\n\thttps://www.shadertoy.com/view/lsBGzG\n\tpyramids    Uploaded by avix in 2014-Jan-16\n\t\n\tkeyToggle and keyPress functions :\n\thttps://www.shadertoy.com/view/MdKGRw\n    digits/sliders/kbd widgets - 2    Uploaded by FabriceNeyret2 in 2016-Jan-26\n\n\tScreen transition technique ( blend ) :\n\thttps://www.shadertoy.com/view/4tS3Rw\n    Preparations    Uploaded by movAX13h in 2015-Mar-27\n    \n    repeat function :\n    Ruslan Shestopalyuk\n    http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n    \t\t\n*/\n//==============================================================================\n\n#define PI\t\t\t\t\t3.1415926535897932384626433832795\n\nconst int NUM_DISPLAYS = 6;\nconst float DISPLAY_PERIOD = 10.0,\n            TOTAL_TIME = DISPLAY_PERIOD * float( NUM_DISPLAYS );\n\n//------------------------------------------------------------------------------\n// Function declarations\n\nfloat sdPlane( vec3 p );\nfloat sdSphere( vec3 p, float s );\nfloat sdBox( vec3 p, vec3 b );\nfloat sdEllipsoid( in vec3 p, in vec3 r );\nfloat sdTorus( vec3 p, vec2 t );\n\nvec3 sim( vec3 p, float s );\nvec2 rot( vec2 p, float r );\nvec2 rotsim( vec2 p, float s );\n\nfloat pMirror (inout float p, float dist); \nvec2 pMirrorOctant (inout vec2 p, vec2 dist); \nfloat fCylinder(vec3 p, float r, float height); \nfloat fCone(vec3 p, float radius, float height); \n \nfloat pyramid( vec3 p, float h);  \nfloat modPyramid( vec3 p, float h, float baseScale ); \nfloat cutoutPyramid( vec3 p, float height );\n\nfloat repeat( float coord, float spacing ); \n\nvec3 getObjectColor( float id );\nfloat read( in float index );\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n// Returns vec2( distance, objID )\n\nvec2 map( vec3 p, bool autoMode, float choice )\n{\t\n\tvec2 closest = vec2( 0.0 );\n\tif ( autoMode )\n    {\n        choice = mod( iTime, TOTAL_TIME ) / DISPLAY_PERIOD;\n    }\n\n\t//========================================================\n\tif ( choice < 1.0 )\t// SIMPLE SILVER SPHERE\n\t{\n\t\t// Animation\n\t\t//---------------------------------------\n\t\t// Animate object rotating around x-axis:\n\t\tp.yz = rot( p.yz, iTime * 0.19 );\n\t\n\t\t// Animate object rotating around y-axis:\n\t\tp.xz = rot( p.xz, iTime * 0.25 );\n\t\n\t\t// Animate object rotating around z-axis:\n\t\tp.xy = rot( p.xy, iTime * 0.17 );\n\t\n\t\t// Domain repetitions\n\t\t// ---------------------------------------------------\t\n\t\tp.xz = rotsim( p.xz, 30.0 );\n\t\tp.z -= 1.5 + 0.5 * sin( iTime * 0.23 );\n\t\t\n\t\tp.yz = rotsim( p.yz, 32.0 );\n\t\tp.z -= 18.0 + 0.5 * sin( iTime * 0.29 );\n\t\t\n\t\tp.xy = rotsim( p.xy, 9.0 );\n\t\tp.y -= 1.0 + 0.5 * sin( iTime * 0.31 );\n\t\t\n\t\tp = sim( p, 22.0 );\n\t\t\n\t\t// Objects\n\t\t//--------\t\t\n\t\tfloat objID = 1.0;\n\t\tfloat d1 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d2 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d3 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d4 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d5 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d6 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d7 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t\n\t\tp.xy = rot( p.xy, PI * -0.25 );\t\n\t\tfloat d8 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );\n\t\t      \n\t\tvec2 obj1 = vec2( min( min( min( min( min( min( min( d1, d2 ), d3 ), \n\t\t                                 d4 ), d5 ), d6 ), d7 ), d8 ), objID );\n                                           \t      \t\t\n\t\t// Distance comparisons to find closest object\n\t\t//--------------------------------------------\n\t\tclosest = obj1;\t\n\t\t\n\t} // end if ( choice < 1.0 )\t\t\n\t//========================================================\n\telse if ( choice < 2.0 )\t// SILVER SPIKED SPHERE\n\t{\n\t\tp.x -= 7.0 * sin( iTime * 0.23 );\n        p.z -= 3.0 + 2.5 * sin( iTime * 0.17 );\n        \n        vec3 p2 = p;\n\t\t\n\t\tp.yz = p2.yz = rot( p.yz, iTime * 0.29 );\n\t\tp.xz = p2.xz = rot( p.xz, iTime * 0.31 );\n\t\tp.xy = rot( p.xy, iTime * 0.23 );\n\t\n\t\tp2.yz = rotsim( p2.yz, 9.0 );\n\t\tp2.z -= 0.1;\n\t\t\n\t\tp2.xz = rotsim( p2.xz, 80.0 );\n\t\tp2.z -= 5.0;\n\t\t\n\t\tp = sim( p, 24.0 );\n\t\t\n\t\tfloat objID = 2.0;\n\t\tfloat d1 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d2 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d3 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d4 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d5 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d6 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d7 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d8 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d9 = fCone( p2, 0.1, 1.0 );\n\t\t\n\t\tp2.yz = rot( p2.yz, PI * -0.1111 );\t\n\t\tfloat d10 = fCone( p2, 0.1, 1.0 );\n\t\t      \n\t\tvec2 obj1 = \n\t\tvec2( min( min( min( min( min( min( min( min( min( d1, d2 ), d3 ), \n\t\t                    d4 ), d5 ), d6 ), d7 ), d8 ), d9 ), d10 ), objID );\n\t\t\t\t\n\t\tobjID = 3.0;\n\t\tvec2 obj2 = vec2( sdSphere( p, 4.9 ), objID );\n\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\t\n\t} // end else if ( choice < 2.0 )\n\t//========================================================\n\telse if ( choice < 3.0 )\t// CUBED SPHERE FIREWORKS\n\t{\n\t\tp.yz = rot( p.yz, iTime * 0.79 );\n\t\tp.xz = rot( p.xz, iTime * 0.61 );\n\t\tp.xy = rot( p.xy, iTime * 0.87 );\n\t\n\t\tpMirror( p.x, 2.0 );\n\t\tpMirror( p.y, 2.0 );\n\t\tpMirror( p.z, 2.0 );\n\t\n\t\tpMirrorOctant( p.xz, vec2( 2.0 ) );\n\t\t\n\t\tp.yz = rotsim( p.yz, 10.0 + 9.0 * sin( iTime * 0.83 ) );\n\t\tp.z -= 1.0;\n\t\t\n\t\tp.xz = rotsim( p.xz, 10.0 + 9.0 * sin( iTime * 0.67 ) );\n\t\tp.z -= 2.0;\n\t\t\n\t\tp.xy = rotsim( p.xy, 10.0 + 9.0 * sin( iTime * 0.53 ) );\n\t\tp.y -= 0.1;\n\t\n\t\tp = sim( p, 6.0 );\n\t\n\t\tfloat objID = 4.0;\n\t\tvec2 obj1 = vec2( sdBox( p - vec3( 0.0, 0.0, 0.0 ), \n\t\t                                      vec3( 1.0, 0.1, 0.1 ) ), objID );\n\t\tclosest = obj1;\t\n\t\t\n\t} // end else if ( choice < 3.0 )\n\t//========================================================\t\n\telse if ( choice < 4.0 )\t// UFO\n\t{\n\t\tp.x -= 12.0 * sin( iTime * 0.9 );\n\t\tp.z -= 8.0 * sin( iTime * 0.23 );\n\t\tp.y -= 1.5 * ( 1.0 + sin( iTime * 0.7 ) );\n\t\t\n\t\tvec3 p2 = p,\n\t\t     p3 = p,\n\t\t     p4 = p,\n\t\t     p5 = p;\n\t\n\t\tp.xz = p2.xz = rotsim( p.xz, 4.5 );\n\t\tp2.z -= 4.0;\n\t\tp.z -= 4.0;\n\t\t\n\t\tp.xz = p2.xz = rotsim( p.xz, 4.5 );\n\t\tp2.z -= 2.925;\n\t\tp.z -= 2.925;\n\n\t\tp3.x = repeat( p3.x, 25.0 );\n\t\tp3.y = repeat( p3.y, 15.0 );\n\t\tp3.z = repeat( p3.z, 30.0 );\n\t\n\t\tp4.x = repeat( p4.x, 25.0 );\n\t\tp4.y = repeat( p4.y, 15.0 );\n\t\tp4.z = repeat( p4.z, 30.0 );\n\t\n\t\tp5.x = repeat( p5.x, 25.0 );\n\t\tp5.y = repeat( p5.y, 15.0 );\n\t\tp5.z = repeat( p5.z, 30.0 );\n\t\n\t\tfloat objID = 5.0;\n\t\tvec2 obj1 = vec2( sdPlane( p - vec3( 0.0, -10.0, 0.0 ) ), objID );\n\t\t\n\t\tobjID = 6.0;\t\n\t\t// Rotate pyramid so flat face is facing screen.\n\t\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\tfloat d1 = pyramid( p2, 1.5 ),\n\t\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ), 1.35, 1.35 );\n\t\tvec2 obj2 = vec2( max( d1, -d2 ), objID );\n\t\t\n\t\tobjID = 7.0;\n\t\td1 = sdSphere( p - vec3( 0.0, 1.25, 0.0 ), 2.0 );\n\t\td2 = sdSphere( p - vec3( 0.0, 1.25, 0.0 ), 1.9 );\n\t\tfloat d3 = fCylinder( p.xzy - vec3( 0.0, 0.0, 1.2 ), 1.15, 3.25 ),\n\t\t      d4 = fCylinder( p.zxy - vec3( 0.0, 0.0, 1.2 ), 1.15, 3.25 );\n\t\tvec2 obj3 = vec2( max( d1, max( max( -d2, -d3 ), -d4 ) ), objID ) ;\t      \n\t\t      \t\t\n\t\tobjID = 8.0;\n\t\tvec2 obj4 = vec2( sdSphere( p - vec3( 0.0, 0.5 + 0.75 * \n\t\t                           -sin( iTime ), 0.0 ), 0.25 ), objID );\n\t\t\n\t\tp.xz = rot( p.xz, -3.0 * iTime );\t\t\t\n\t\tobjID = 9.0;\n\t\tvec2 obj5 = vec2( pyramid( p - vec3( 0.0, 2.0, 0.0 ), 0.25 ), objID );\n\t\t\n\t\tobjID = 10.0;\n\t\tvec2 obj6 = \n        vec2( sdTorus( p - vec3( 0.0, 0.9375 + 0.9375 * sin( iTime ), \n               0.0 ), vec2( 0.8 + 0.7 * -sin( iTime ), 0.05 ) ), objID );\t\n\t\t\n\t\tobjID = 6.0; \n\t\tp3.xy = rot( p3.xy, iTime * 0.37 );\n\t\tp3.xz = rot( p3.xz, iTime * 0.51 );\n\t\tp3.yz = rot( p3.yz, iTime * 0.71 );\n\t\tvec2 obj7 = \n\t\t\t\t  vec2( sdSphere( p3 - vec3( 16.0, 0.0, 0.0 ), 0.07 ), objID );\n\t\t\n\t\tobjID = 8.0;\n\t\tp4.xy = rot( p4.xy, iTime * 0.57 );\n\t\tp4.xz = rot( p4.xz, iTime * 0.71 );\n\t\tp4.yz = rot( p4.yz, iTime * 0.83 );\n\t\tvec2 obj8 = \n\t\t         vec2( sdSphere( p4 - vec3( -16.0, 0.0, 0.0 ), 0.08 ), objID );\n\t\t\n\t\tobjID = 9.0;\n\t\tp5.xy = rot( p5.xy, iTime * 0.47 );\n\t\tp5.xz = rot( p5.xz, iTime * 0.87 );\n\t\tp5.yz = rot( p5.yz, iTime * 0.67 );\n\t\tvec2 obj9 = \n\t\t           vec2( sdSphere( p5 - vec3( 8.0, 8.0, 0.0 ), 0.06 ), objID );\n\t\t\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t\tclosest = closest.s < obj4.s ? closest : obj4;\n\t\tclosest = closest.s < obj5.s ? closest : obj5;\n\t\tclosest = closest.s < obj6.s ? closest : obj6;\n\t\tclosest = closest.s < obj7.s ? closest : obj7;\n\t\tclosest = closest.s < obj8.s ? closest : obj8;\n\t\tclosest = closest.s < obj9.s ? closest : obj9;\n\t\t\n\t} // end else if ( choice < 4.0 )\n\t//========================================================\t\n\telse if ( choice < 5.0 )\t// SPACE STATION\n\t{\n\t\tp.x -= 10.0 * sin( iTime * 0.19 );\n\t\tvec3 p2 = p,\n\t\t     p3 = p;\n\t\t\n\t\tp.yz = p2.yz = rot( p.yz, iTime * 0.19 );\n\t\tp.xz = p2.xz = rot( p.xz, iTime * 0.29 );\n\t\tp.xy = p2.xy = rot( p.xy, iTime * 0.13 );\n\t\n\t\tp.xz = rotsim( p.xz, 8.0 );\n\t\tp.z -= 8.0 + 2.0 * sin( iTime * 0.23);\n\t\t\n\t\tp.yz = rotsim( p.yz, 8.0 );                    \n\t\tp.z -= 3.0 + 1.25 * sin( iTime * 0.19 );\n\t\t\n\t\tp.xy = rotsim( p.xy, 2.0 );\n\t\n\t\tfloat objID = 11.0; \n\t\tvec2 obj1 = vec2( fCone( p, 0.25, 1.0 ), objID );\n\t\t                                         \t\n\t\tobjID = 12.0; \n\t\tvec2 obj2 = \n\t\t      vec2( fCone( p.xzy - vec3( 0.0, 0.2, 0.0 ), 0.25, 1.0 ), objID );\n\t\t                                                            \n\t\tp.xz = rot( p.xz, PI );\n\t\tobjID = 13.0;\n\t\tvec2 obj3 = \n\t\t      vec2( fCone( p.xzy - vec3( 0.0, 0.2, 0.0 ), 0.25, 1.0 ), objID );\n\t\t                                                            \t\t\n\t\tobjID = 14.0;\n\t\tvec2 obj4 = vec2( sdSphere( p - vec3( 0.0, 1.0, 1.5 ), 0.1 ), objID );\t\t             \n\t\t                                                            \t\t\t\n\t\tobjID = 15.0;\n\t\tvec2 obj5 = vec2( sdSphere( p - vec3( 0.0, 0.0, 3.0 ), 0.15 ), objID ); \n\t\t                                                            \t\t\t\n\t\tobjID = 16.0;\n\t\tvec2 obj6 = vec2( sdSphere( p - vec3( 0.0, 0.0, -1.5 ), 0.05 ), objID );\n\t\t                                                            \t\t\t\n\t\tobjID = 17.0;\n\t\t   vec2 obj7 = vec2( sdEllipsoid( p2, vec3( 1.5, 3.0, 1.5 ) ), objID );\n\n\t\tobjID = 18.0;\n\t\t    vec2 obj8 = vec2( sdPlane( p3 - vec3( 0.0, -13.0, 0.0 ) ), objID );\n\n\t\tclosest = obj1.s < obj2.s ? obj1 : obj2;\n\t\tclosest = closest.s < obj3.s ? closest : obj3;\n\t\tclosest = closest.s < obj4.s ? closest : obj4;\n\t\tclosest = closest.s < obj5.s ? closest : obj5;\n\t\tclosest = closest.s < obj6.s ? closest : obj6;\n\t\tclosest = closest.s < obj7.s ? closest : obj7;\n\t\tclosest = closest.s < obj8.s ? closest : obj8;\n\t\t\n\t} // end else if ( choice < 5.0 )\n\t//========================================================\t\n\telse if ( choice < 6.0 )\t// SILVER SOCKET STARS\n\t{\n\t\tp.yz = rot( p.yz, iTime * 0.11 );\n\t\tp.xz = rot( p.xz, iTime * 0.13 );\n\t\tp.xy = rot( p.xy, iTime * 0.07 );\n\t\n\t\tp.yz = rotsim( p.yz, 8.0 );\n\t\tp.z -= 1.0;\n\t\n\t\tp.xz = rotsim( p.xz, 8.0 );\n\t\tp.z -= 18.0;\n\t\n\t\tp.xy = rotsim( p.xy, 3.0 );\n\t\tp.y -= 0.5;\n\t\t\n\t\tp = sim( p, 15.0 );\n\t\n\t\tfloat objID = 19.0;\n\t\tvec2 obj1 = vec2( cutoutPyramid( p, 3.0 ), objID );\n\t\t\n\t\tclosest = obj1;\t\n\t\t\n\t} // end else if ( choice < 6.0 )\n\t//========================================================\t\n\t\t\n\treturn closest;\t\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// MAIN IMAGE\n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat viewDist = 0.0,\n\t      maxDist = 0.0,\n\t      brightness = 0.0;\n\t      \n\tfloat choice = 0.0;\t      \n\t\n\tbool autoMode = true;\n\t\n\t//-----------------------------------------------------\n    // Test for autoMode status : keyboard check\n    // Keys are either keyboard or numpad\n    \n    float temp = read( 345.0 );\n    \n    if ( temp == 0.0 ) // key 0\n    {\n\t\tautoMode = true;\n\t}    \t\n    else if (temp == 0.1 ) //  key 1\n    {\n\t\tautoMode = false;\n        choice = 0.0;\t// display 1 \n    }\n    else if ( temp == 0.2 ) //  key 2\n    {\n\t\tautoMode = false;\n\t\tchoice = 1.0;\t// display 2 \n    }\n    else if ( temp == 0.3 ) //  key 3\n    {\n\t\tautoMode = false;\n\t\tchoice = 2.0; \n    }\n    else if ( temp == 0.4 ) //  key 4\n    {\n\t\tautoMode = false;\n\t\tchoice = 3.0; \n    }\n    else if ( temp == 0.5 ) //  key 5\n    {\n\t\tautoMode = false;\n\t\tchoice = 4.0; \n    }\n    else if ( temp == 0.6 ) //  key 6\n    {\n\t\tautoMode = false;\n\t\tchoice = 5.0; \n    }\n \t//--------------------------------------------------------\n    \n\tif ( autoMode )\n\t{\n\t\tchoice = mod( iTime, TOTAL_TIME ) / DISPLAY_PERIOD;\n\t} \n\n\t//-----------------------\n\t// Assign values for each display.\n\tif ( choice < 1.0 )\n\t{\n\t\tviewDist = -40.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 100.0;    \t\t\n\t}\n\telse if ( choice < 2.0 )\n\t{\t\n\t\tviewDist = -12.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 100.0;    \n\t}\n\telse if ( choice < 3.0 )\n\t{\n\t\tviewDist = -15.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 50.0;\n\t}\n\telse if ( choice < 4.0 )\n\t{\n\t\tviewDist = 25.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 500.0;\n\t}\n\telse if ( choice < 5.0 )\n\t{\n\t\tviewDist = -28.0;\n\t\tbrightness = 0.01;\n\t\tmaxDist = 60.0;\n\t}\n\telse if ( choice < 6.0 )\n\t{\n\t\tviewDist = -47.0;\n\t\tbrightness = 0.0075;\n\t\tmaxDist = 100.0;\n\t}\n\t//-----------------------\n\t\n\t// Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 curPix = ( -iResolution.xy + 2.0 * gl_FragCoord.xy ) / iResolution.y;\n\t\n\tvec3 camUpVec = vec3( 0.0, 1.0, 0.0 );\n\tvec3 camView = vec3( 0.0, 0.0, 0.0 ); // Look-at\n\tvec3 camPos = vec3( 0.0, 0.0, viewDist ); \n\n\tif ( choice >= 3.0 && choice < 4.0 )\n\t{\n\t\tcamPos = vec3( cos( iTime * 0.25 ), 0.3 + 0.25 * \n\t\t     sin( iTime * 0.35 ), sin( iTime * 0.25 ) ) * viewDist;\n\t}\n\t\t\n\t//Camera setup\n\tfloat fov = 1.5;  \n\tvec3 forwardVec = normalize( camView - camPos ); // camera view direction\n\tvec3 rightVec = normalize( cross( camUpVec, forwardVec ) );\n\tvec3 upVec = cross( forwardVec, rightVec );\n\t\n\tvec3 scrCoord = camPos + forwardVec * fov + \n\t                                    curPix.x * rightVec + curPix.y * upVec;\n\t\n\tvec3 rayDir = normalize( scrCoord - camPos );\n\t\n\t//-----------\n\t//Raymarching\n\tconst vec3 e = vec3( 0.1, 0.0, 0.0 );\t\n\t\n\tvec2 distID = vec2( 0.1, 0.0 );\n\t\n\tvec3 clr = vec3( 0.0 ), \n\t     curRayPos = vec3( 0.0 ), \n\t     n = vec3( 0.0 ); // normal vector to hit position on object\n\t\n\tfloat dist = 1.0;\n\t\n\tfor ( int i = 0; i < 256; i++ )\n\t{\n\t\tif ( abs( distID.s ) < 0.001 || dist > maxDist ) break;\n\t\tdist += distID.s;\n\t\tcurRayPos = camPos + rayDir * dist;\n\t\tdistID = map( curRayPos, autoMode, choice );\n\t}\n\t\n\tif ( dist < maxDist )\n\t{\n\t\tclr = getObjectColor( distID.t );\n\t\t\n\t\t//tetrahedron normal\n\t\tconst float n_er = 0.01;\n\t\tfloat v1 =\n\t\tmap(vec3(curRayPos.x+n_er,curRayPos.y-n_er,curRayPos.z-n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tfloat v2 =\n\t\tmap(vec3(curRayPos.x-n_er,curRayPos.y-n_er,curRayPos.z+n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tfloat v3 = \n\t\tmap(vec3(curRayPos.x-n_er,curRayPos.y+n_er,curRayPos.z-n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tfloat v4 = \n\t\tmap(vec3(curRayPos.x+n_er,curRayPos.y+n_er,curRayPos.z+n_er),\n\t\t                                                  autoMode, choice ).x;\n\t\tn=normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n\t\t\t\t\n        //simple phong LightPosition=CameraPosition\n        float b = dot( n, normalize( camPos - curRayPos ) );\n        clr = ( b * clr + pow( b,8.0 ) ) * ( 1.0 - dist * brightness );\n\t\t\n\t\t//--------------------------------------------------\n\t\t// blend, from https://www.shadertoy.com/view/4tS3Rw\n\t\t//             Preparations    Uploaded by movAX13h in 2015-Mar-27\n\t\t\n\t\t// Affects how quickly the out-to-black then in-to-scene fade occurs.\n\t\t// Smaller number = longer fade time.\n\t\tfloat fadeVal = 1.6;\n\t\t\n\t\t// Measures the cycle time between all-black screens, i.e., within 5 \n\t\t// seconds, the screen starts black, fades into a scene, then fades \n\t\t// back to all black.\n\t\tfloat cycleLength = DISPLAY_PERIOD;\n\n\t\tif ( autoMode )\n        {\n        \tclr *= min( 1.0, \n\t\t              abs( fadeVal * sin( PI * iTime / cycleLength ) ) );\n        }\n\t\t//-----------------------------------------------------------------\n\t\t\n\t\tfragColor = vec4( clr, 1.0 );\n\t}\n\telse \n\t{\n\t\tfragColor = vec4( 0, 0, 0, 1.0 ); // background color\n\t}\n}\n\n// end mainImage()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( float id )\n{\n    vec3 clr = vec3( 1.0 );\n\n    // Simple Silver Sphere\n    if ( id == 1.0 )\n    {\n    \tclr = vec3( 0.8, 0.8, 0.95 );\t\n    }\n    // Silver Spike Sphere\n    else if ( id == 2.0 )\n    {\n    \tclr = vec3( 0.6, 0.6, 0.75 );\t\n    }\n    else if ( id == 3.0 )\n    {\n\t\tclr = vec3( 0.1 + 0.1 * sin( iTime * 0.07 ), 0.0, \n                    0.4 + 0.2 * sin( iTime * 0.11 ) );\t  \t\n    }\n\t// Cubed Sphere Fireworks\n    else if ( id == 4.0 )\n    {\n    \tclr = vec3( 1.0, 0.7, 0.0 );\t\n    }\n    // UFO\n    else if ( id == 5.0 )\n    {\n    \tclr = vec3( 0.0, 0.0, 1.0 );\t\n    }\n    else if ( id == 6.0 )\n    {\n    \tclr = vec3( 1.0, 0.75, 0.0 );\t\n    }\n    else if ( id == 7.0 )\n    {\n    \tclr = vec3( 0.7, 0.8, 0.9 );\t\n    }\n    else if ( id == 8.0 )\n    {\n    \tclr = vec3( 1.0, 1.0, 0.0 );\t\n    }\n    else if ( id == 9.0 )\n    {\n    \tclr = vec3( 1.0, 0.25, 0.0 );\t\n    }\n    else if ( id == 10.0 )\n    {\n    \tclr = vec3( 1.0, 0.5, 0.0 );\t\n    }\n\t// Space Station\n    else if ( id == 11.0 )\n    {\n    \tclr = vec3( 0.0, 0.0, 1.0 );\t\n    }\n    else if ( id == 12.0 )\n    {\n    \tclr = vec3( 0.7, 0.8, 1.0 );\t  \t\n    }\n    else if ( id == 13.0 )\n    {\n    \tclr = vec3( 1.0, 0.8, 0.4 );\t  \t\n    }\n    else if ( id == 14.0 )\n    {\n    \tclr = vec3( 0.5, 0.0, 1.0 );\t  \t\n    }\n    else if ( id == 15.0 )\n    {\n    \tclr = vec3( 1.0, 0.0, 0.5 );\t  \t\n    }\n    else if ( id == 16.0 )\n    {\n    \tclr = vec3( 1.0, 0.0, 0.5 );\t  \t\n    }\n    else if ( id == 17.0 )\n    {\n    \tclr = vec3( 0.7, 0.8, 1.0 );\t  \t\n    }\n    else if ( id == 18.0 )\n    {\n    \tclr = vec3( 0.0, 0.2, 0.6 );\t  \t\n    }\n    // Silver Socket Stars\n    else if ( id == 19.0 )\n    {\n    \tclr = vec3( 0.8, 1.0, 0.9 );\t\n    }\n\n\treturn clr;\t\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\n// Based on\n// https://www.shadertoy.com/view/MscGDS\n// State Demo     Uploaded by sixstring982 in 2016-Jan-4\n\n#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex(float idx) \n{\n    return vec2( floor( idx / RAM_SIZE ), floor( mod( idx, RAM_SIZE ) ) ) / \n                                                      iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nfloat read( in float index ) \n{\n    return texture( iChannel0, cellFromIndex( index ) ).r;\n}\n//------------------------------------------------------------------------------\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\n// xz-plane at y = 0 when p.y = 0\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// b = vec3( halfWidth, halfHeight, halfDepth )\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Horizontal torus lying in xz plane at y = 0; t = vec2( lg. diam, sm. diam )\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//------------------------------------------------------------------------------\n\n// From \"Playing with symmetries - Torus\"\t   by @paulofalcao\t\n// http://glslsandbox.com/e#29755.0\n\nvec3 sim(vec3 p,float s)\n{\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n\n// HG_SDF : GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n// http://mercury.sexy/hg_sdf\n\n// Sign function that doesn't return 0\nfloat sgn(float x) \n{\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) \n{                           \n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> \n// from the origin.\nfloat pMirror (inout float p, float dist) \n{\n\tfloat s = sgn(p); \n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the \n// space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) \n{\n\tvec2 s = sgn(p);\t\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) \n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Cone with correct distances to tip and base circle. \n// Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) \n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/lsBGzG\n// pyramids    Uploaded by avix in 2014-Jan-16\n\n// Pyramid with base on xz-plane at y=0.0, h = height, width, and depth\nfloat pyramid( vec3 p, float h) \n{\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x+q.y+q.z-h)/3.0 );\n}\n\n//------------------------------------------------------------------------------\n// From Ruslan Shestopalyuk\n// http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n\n// Example : p.x = repeat(clamp(p.x, -3.0, 0.0), 1.0);\n\n// Repetition in one axis at a time\nfloat repeat( float coord, float spacing ) \n{\n    return mod( coord, spacing ) - spacing * 0.5;\n}\n\n//------------------------------------------------------------------------------\n// wjb : Modified from pyramid(), above.\n// Pyramid with base on xz-plane at y=0.0, h = height, s = scaling factor for\n// length of an edge of the square pyramid base, where edge length = s * h, \n// i.e., h = 2.0, s = 0.5, base edge = 1.0; or h = 2.0, s = 2.0, base edge = 4.0\n// s MUST BE >= 0.5\n                        \nfloat modPyramid( vec3 p, float h, float s ) \n{\n\tvec3 q = abs( p );\n\tfloat scale = 1.0 / s;\n\treturn max( -p.y, ( q.x * scale + q.y + q.z * scale - h ) / 3.0 );\n}\n\n//------------------------------------------------------------------------------\n// wjb : works for pyramid height of 0.5 and greater.\n\nfloat cutoutPyramid( vec3 p, float height )\n{\n\tfloat scaleVal = 1.3;\n\tif ( height < 1.0 )\t{\tscaleVal = 1.1;\t}\n\t\t\n\tvec3 p2 = p;\n\tp2.xz = rot( p2.xz, PI * 0.25 );\n\t\n\tfloat d1 = pyramid( p2, height ),\n\t      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ),  \n\t                                       height * ( scaleVal / 1.5 ), 1.35 );\n\treturn max( d1, -d2 );\n}\n//------------------------------------------------------------------------------\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n *\tBUF_A \n *\n *\tContains Buf A in iChannel0 and keyboard in iChannel3\n *\n */\n//========================================================================= \n\n// https://www.shadertoy.com/view/MdKGRw\n// digits/sliders/kbd widgets - 2    Uploaded by FabriceNeyret2 in 2016-Jan-26\n\nbool keyToggle( int ascii ) \n{\n\treturn ( texture( iChannel3, \n\t                vec2( ( 0.5 + float( ascii ) ) / 256.0, 0.75 ) ).x > 0.0 );\t                                                        \n}\nbool keyPress( int ascii ) \n{\n\treturn ( texture( iChannel3, \n\t                vec2( ( 0.5 + float( ascii ) ) / 256.0, 0.25 ) ).x > 0.0 );\n}\n//------------------------------------------------------------------------------\n\n// https://www.shadertoy.com/view/MscGDS\n// State Demo     Uploaded by sixstring982 in 2016-Jan-4\n\n#define RAM_SIZE 128.0\n\n// Convert a linear index to a vec2 used to \n// index into the 128 * 128 virtual \"RAM\".\nvec2 cellFromIndex( float idx ) \n{\n    return vec2( floor( idx / RAM_SIZE ), floor( mod( idx, RAM_SIZE ) ) ) / \n                                                      iChannelResolution[0].xy;\n}\n\n// Read a value from \"RAM\", given an index.\n// This assumes that \"RAM\" is a 128 * 128 region,\n// which gives 128 * 128 = 16384 floats of memory.\n// This function assumes that this is indexed linearly,\n// sort of like RAM would be indexed in C.\nfloat read( in float index ) \n{\n    return texture( iChannel0, cellFromIndex( index ) ).r;\n}\n\n// Checks to see if the current fragCoord is in a \n// target RAM cell. This allows checking for each\n// cell in parallel.\nbool isCell( in vec2 uv, in float index ) \n{\n    vec2 target = cellFromIndex( index );\n    return uv.x >= target.x - 0.005 &&\n           uv.x <= target.x + 0.005 &&\n           uv.y >= target.y - 0.005 &&\n           uv.y <= target.y + 0.005;\n}\n\n// This function, if you're used to game development,\n// is a little like the \"update\" function. This is\n// where updating of all variables should be done.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // See if this particular fragment is the RAM cell\n    // we want to update\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if ( isCell( uv, 345.0 ) ) \n    {\n        // Initialize variable\n    \tif ( iFrame == 0 ) \n        {\n\t        fragColor = vec4( 0.0 );\n            return;\n        }\t\n        \n\t    // Check condition. Keys are either keyboard or numpad\n\t    if ( keyPress( 48 ) || keyPress( 96 ) ) //  key 0\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.0 ), 1.0 );   \t\n\t    }\n\t    else if ( keyPress( 49 ) || keyPress( 97 )  ) //  key 1\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.1 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 50 ) || keyPress( 98 )  ) //  key 2\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.2 ), 1.0  );  \n\t    }\n \t    else if ( keyPress( 51 ) || keyPress( 99 )  ) //  key 3\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.3 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 52 ) || keyPress( 100 )  ) //  key 4\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.4 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 53 ) || keyPress( 101 )  ) //  key 5\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.5 ), 1.0  );  \n\t    }\n\t    else if ( keyPress( 54 ) || keyPress( 102 )  ) //  key 6\t\n\t    {\n\t\t\tfragColor = vec4( vec3( 0.6 ), 1.0  );  \n\t    }\n       else // State remains unchanged\n        {\n            fragColor = vec4( read( 345.0 ) );\n        }\n    }\n        \n    // Set variable to previous state\n    else \n    {\n        fragColor = vec4( read( 345.0 ) );\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}