{
    "Shader": {
        "info": {
            "date": "1625010789",
            "description": "A hello-world-tier first shader which mimics PPSSPP's default background animation. I just eyeballed the PPSSPP default background to make this, so the shape proportions and sway duration likely aren't accurate, but you can modify them using the #defines.",
            "flags": 0,
            "hasliked": 0,
            "id": "slB3Dc",
            "likes": 9,
            "name": "Floating Playstation Shapes",
            "published": 3,
            "tags": [
                "blue",
                "shapes",
                "playstation",
                "sony",
                "ppsspp"
            ],
            "usePreview": 0,
            "username": "will7007",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "// Common parameters:\n#define SHAPE_SIZE 0.06\n#define BLUR 0.001\n#define VERTICAL_TRAVEL 0.1\n#define SPEED_TRAVEL 0.6\n#define SPEED_ROTATION 1.\n#define ALPHA .7\n\n// Colors\n#define DARK_BLUE vec3(16./255.,50./255.,66./255.)\n#define LIGHT_BLUE vec3(34./255.,76./255.,114./255.)\n#define SHAPE_GRAY vec3(93./255.,119./255.,137./255.)\n\n// Only applies to the circle and square\n#define INNER_CUTOUT_SCALE 0.7\n\n// The taper-off point for the triangle to be equilateral\nconst float EQUILATERAL_HEIGHT =\n        sqrt(pow(SHAPE_SIZE,2.) - pow(SHAPE_SIZE/2.,2.))\n        - SHAPE_SIZE/2.;\n\n// NEW on Jul-24-2021: grid based rendering to improve performance\n// the old way is pretty terrible in hindsight\n#define NEW_RENDERER 1\n\n// Old renderer parameter:\n// set to an ammount similar to density 12 on the new renderer\n// so you can see the performance improvement\n// (at least I can see the difference on my 6 year old Macbook Air)\n#define SHAPE_AMOUNT 300.\n\n// New renderer parameters:\n#define DENSITY 12.\n// see the note in the main function\n#define PRESERVE_VERTICAL_TRAVEL 1\n\n// Helper functions grabbed from the internet\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233)))\n        *43758.5453);\n}\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\n// https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map(float value, float min1, float max1,\n        float min2, float max2) {\n    return min2 + (value - min1)*(max2 -min2)\n        /(max1 - min1);\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle),-sin(angle),\n        sin(angle),cos(angle));\n}\n\n// Background gradient\nvec3 background(vec2 uv) {\n    const float GRAD_START = 0.25, GRAD_STOP = 0.95;\n    return mix(LIGHT_BLUE,DARK_BLUE,\n        smoothstep(GRAD_START,GRAD_STOP,uv.y));\n}\n\n// Solid helper shapes\nfloat box(vec2 uv, float left, float right,\n        float down, float up, float blur) {\n    return smoothstep(left,left+blur,uv.x)\n        *smoothstep(right,right-blur,uv.x)\n        *smoothstep(down,down+blur,uv.y)\n        *smoothstep(up,up-blur,uv.y);\n}\n\nfloat box(vec2 uv, float lowerBound, float upperBound,\n        float blur) {\n    return box(uv,lowerBound,upperBound,\n               lowerBound,upperBound,blur);\n}\n\nfloat triangleSolid(vec2 uv, float size, float height,\n        float blur) {\n    float sides = map(uv.y,-size/2.,height,size/2.,0.);\n    return box(uv,-sides,sides,-size/2.,size/2.,blur);    \n}\n\n// Main shapes\nfloat circle(vec2 uv, float size, float blur, float alpha) {\n    float radius = size/2.;\n    return alpha*(smoothstep(radius+blur,radius,length(uv))\n        - smoothstep(INNER_CUTOUT_SCALE*radius+blur,\n                     INNER_CUTOUT_SCALE*radius,\n                     length(uv)));\n}\n\nfloat X(vec2 uv, float size, float blur, float alpha) {\n    float lower = -size/2., upper = size/2.;\n    return alpha*(box(uv,lower,upper,lower/5.,upper/5.,blur)\n        + box(uv,lower/5.,upper/5.,lower,upper,blur)\n        - box(uv,lower/5.,upper/5.,blur));\n}\n\nfloat triangle(vec2 uv, float size, float height,\n        float blur, float alpha) {\n    vec2 innerCoord = uv*2.;\n    const float BASE_SIZE = 0.05, SCALING_FACTOR = 0.01;\n    innerCoord.y += SHAPE_SIZE/BASE_SIZE*SCALING_FACTOR;\n    return alpha*(triangleSolid(uv,size,height,blur)\n        - triangleSolid(innerCoord,size,height,blur));\n}\n\nfloat square(vec2 uv, float size, float blur, float alpha) {\n    return alpha*(box(uv,-size/2.,size/2.,blur)\n        - box(uv,-INNER_CUTOUT_SCALE*size/2.,\n              INNER_CUTOUT_SCALE*size/2.,blur));\n}\n\nvec2 sway(vec2 uv, vec2 start, float vertTravel,\n        float timeShift) {\n    return vec2(uv.x-start.x,uv.y-start.y\n                - vertTravel*sin(SPEED_TRAVEL\n                                 *iTime-timeShift));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float ASPECT_RATIO = iResolution.x/iResolution.y;\n    uv.x *= ASPECT_RATIO;\n\n    vec3 col = background(uv);\n    \n    #if NEW_RENDERER\n    uv *= DENSITY;\n    vec2 xy = fract(uv)-.5,  // point within a grid cell\n         id = floor(uv),     // the grid cell we are in\n         cid = vec2(0.);     // the id adjusted for the actual location of the cell\n    \n    /*\n    Here we see which shapes are in this cell and the surrounding\n    cells (the shapes nearby) and draw their value for this pixel.\n    Unfortunately we cannot increase the shape density\n    while maintaining the vertical travel of the shapes\n    without having shapes from far-away grid cells \"come into\"\n    our grid cell and not being being drawn since we only check\n    nearby cells for shapes.\n    This introduces clipping on the shapes which can only be fixed by\n    increasing the number of neighboring grid cells checked\n    per iteration, which unfortunately hurts performance.\n    We already need slightly more vertical grid cells with the\n    default settings because the shapes were already traveling\n    too far.\n    */\n    #if PRESERVE_VERTICAL_TRAVEL\n    // I did a quick check at density ~30 with default size\n    // with these start/end values but they aren't perfect\n    const vec2 startValue = vec2(-1.-DENSITY/30.,-2.-DENSITY/14.),\n               endValue = vec2(1.+DENSITY/60.,1.+DENSITY/10.);\n    #else\n    const vec2 startValue = vec2(-1.,-2.),\n               endValue = vec2(1.);\n    #endif\n    for(float yCell=startValue.y; yCell <= endValue.y; yCell++) {\n        for(float xCell=startValue.x; xCell <= endValue.x; xCell++) {\n            vec2 off = vec2(xCell,yCell);\n            cid = id+off;\n            vec2 origin = off+N22(cid);\n            \n            // big/random multipliers to spread out shape types\n            float shapeID = 400.*rand(cid)+2.526*cid.y;\n            \n            origin = sway(origin,vec2(0.),\n                          #if PRESERVE_VERTICAL_TRAVEL \n                          DENSITY*\n                          #endif\n                          VERTICAL_TRAVEL,shapeID);\n            \n\n            // rotate and scale the coordinate system for the shape\n            // which we previously moved vertically based on time\n            vec2 pointRotated = 1./DENSITY*(origin-xy)*rotate(sin(SPEED_ROTATION*iTime-shapeID));\n            switch(int(mod(shapeID,4.))) {\n            case 0:\n            default:\n                col = mix(col,SHAPE_GRAY,\n                          X(pointRotated,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 1:\n                col = mix(col,SHAPE_GRAY,\n                          circle(pointRotated,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 2:\n                col = mix(col,SHAPE_GRAY,\n                          triangle(pointRotated,SHAPE_SIZE,\n                                   EQUILATERAL_HEIGHT,\n                                   BLUR,ALPHA));\n                break;\n            case 3:\n                col = mix(col,SHAPE_GRAY,\n                          square(pointRotated,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            }\n        }\n    }\n    #else\n    for(float i = 0.; i < SHAPE_AMOUNT; i++) {\n        vec2 seed = vec2(i,i);\n        vec2 cord = vec2(rand(seed),rand(-.5*seed));\n        cord.x *= ASPECT_RATIO;\n        vec2 xy = sway(uv,cord,VERTICAL_TRAVEL,i);\n        switch(int(mod(i,4.))) {\n            case 0:\n                xy *= rotate(sin(SPEED_ROTATION*iTime-i));\n                col = mix(col,SHAPE_GRAY,\n                          X(xy,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 1:\n                col = mix(col,SHAPE_GRAY,\n                          circle(xy,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 2:\n                xy *= rotate(sin(SPEED_ROTATION*iTime-i));\n                col = mix(col,SHAPE_GRAY,\n                          triangle(xy,SHAPE_SIZE,\n                                   EQUILATERAL_HEIGHT,\n                                   BLUR,ALPHA));\n                break;\n            case 3:\n            default:\n                xy *= rotate(sin(SPEED_ROTATION*iTime-i));\n                col = mix(col,SHAPE_GRAY,\n                          square(xy,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n        }\n    }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}