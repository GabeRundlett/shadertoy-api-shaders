{
    "Shader": {
        "info": {
            "date": "1724102919",
            "description": "Now everything works as intended. Shadows and reflections.",
            "flags": 0,
            "hasliked": 0,
            "id": "MfXfRX",
            "likes": 1,
            "name": "Three raymarched spheres",
            "published": 3,
            "tags": [
                "raymarching",
                "aliasing",
                "spheres",
                "checkerboard"
            ],
            "usePreview": 0,
            "username": "randomOrder",
            "viewed": 105
        },
        "renderpass": [
            {
                "code": "// First feature complete raymarcher with shadows\n// reflections and normal based ambient lighting\n// Made by Marcus Dicander\n\nconst float pi = 3.1415926535897932;\nconst float epsilon = 0.0001;\nconst float fieldOfView = 90.0;\nconst float max_distance = 32.0;\n\nfloat sdf_sphere(vec3 origin, vec3 center, float radius) {\n    return length(center-origin) - radius;\n}\n\nfloat sdf_surface(vec3 origin) {\n    return abs(origin.y + 1.0);\n}\n\n\nvec3 center = vec3(0.0, 0.0, 0.0);\nvec3 red_center = vec3(1.0, 0.0, 1.1);\nvec3 blue_center = vec3(-1.2, 0.0, -0.3);\nvec3 green_center = vec3(1.0, 0.0, -1.2);\nvec3 light_1 = vec3(-3.0, 3.0, -3.0);\nvec3 light_2 = vec3(3.0, 3.0, 3.0);\nvec3 background = vec3(0.6, 0.7, 0.8);\nvec3 black = vec3(0.0, 0.0, 0.0);\nvec3 red = vec3(1.0, 0.0, 0.0);\nvec3 blue = vec3(0.0, 0.0, 1.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\nvec3 white = vec3(1.0, 1.0, 1.0);\nfloat red_size = 1.0;\nfloat blue_size = 1.0;\nfloat green_size = 1.0;\n\n// Function to define the scene.\nfloat sceneSDF(vec3 p) {\n  float d1 = sdf_sphere(p, red_center, red_size);\n  float d2 = sdf_sphere(p, blue_center, blue_size);\n  float d3 = sdf_sphere(p, green_center, green_size);\n  float d4 = sdf_surface(p); // A surface that will soon be checkered\n  return min(d1, min(d2, min(d3, d4))); \n}\n\nstruct RayHitInfo {\n  bool hit;          // Did the ray hit something?\n  vec3 position;     // Position of the hit\n  vec3 color;        // Immediate color of the object. No shadows or reflections.\n  vec3 normal;       // Direction of the normal for the surface that was hit  \n  float distance;    // Distance from the ray origin to the hit\n  float avoid;\n};\n\n// Ray marching function\nRayHitInfo rayMarch(vec3 ro, vec3 rd, float maxDist, float avoid) {\n  float t = 0.0;\n  vec3 surface_normal = black;\n  vec3 reflected_ray_dir = black;\n  bool hit_something = false;\n  float next_avoid = 0.0;\n  for (int i = 0; i < 1000; i++) { // Adjust max iterations if needed\n    vec3 p = ro + t * rd;\n    float dist = sceneSDF(p);\n    if (dist < epsilon) { \n      // We hit a surface!\n      vec3 color = black;\n      float candidate = sdf_surface(p);\n      float distance_from_origin = length(vec3(0, 0, 0)- p);\n      if(candidate < epsilon && avoid != 1.0) {\n        hit_something = true;\n        if (((fract(p.x) < 0.5 && fract(p.z) < 0.5) ||\n            (fract(p.x) >= 0.5 && fract(p.z) >= 0.5)) &&\n            distance_from_origin < 16.0) {\n            color = white*(16.0-distance_from_origin)/16.0;\n            surface_normal = vec3(0., 1., 0.);\n        }\n        next_avoid = 1.0;\n      }\n      candidate = sdf_sphere(p, blue_center, blue_size);\n      if (candidate < epsilon && avoid != 2.0) {\n        hit_something = true;\n        color = blue;\n        surface_normal = normalize(p - blue_center);\n        next_avoid = 2.0;\n      }\n      candidate = sdf_sphere(p, red_center, red_size);\n      if (candidate < epsilon && avoid != 3.0) {\n        hit_something = true;\n        color = red;\n        surface_normal = normalize(p - red_center);\n        next_avoid = 3.0;\n      }\n      candidate = sdf_sphere(p, green_center, green_size);\n      if (candidate < epsilon && avoid != 4.0) {\n        hit_something = true;\n        color = green;\n        surface_normal = normalize(p - green_center);\n        next_avoid = 4.0;\n      }\n      if(!hit_something) {\n          continue;\n      }\n      //reflected_ray_dir = normalize(rd - 2.0 * dot(rd, surface_normal) * surface_normal);\n      return RayHitInfo(true, p, color, surface_normal, dist, next_avoid);\n        \n    }\n    t += dist;\n    if (t > maxDist) break; \n  }\n  return RayHitInfo(false, center, background, black, 0.0, 0.0); // Background\n}\n\nvec3 normalLighting( vec3 p, vec3 surface_normal, vec3 color) {\n  vec3 lightDir1 = normalize(light_1 - p);\n  vec3 lightDir2 = normalize(light_2 - p);\n  // Diffuse shading\n  float diff1 = max(dot(surface_normal, lightDir1), 0.0);\n  float diff2 = max(dot(surface_normal, lightDir2), 0.0);\n  // Combine lighting with base color\n  //vec3 diffuseColor = (diff1 + diff2) * white * 0.7; // Scale to prevent over-brightening\n  color = max(color * diff1 * white, color * diff2 * white);\n  return color;\n}\n\nvec3 shadowRays( vec3 p, float avoid, vec3 color) {\n  vec3 shadowDirection = normalize(light_1 - p);\n  float bias = 0.001 * length(p - light_1); // Adjust 0.01 as needed \n  RayHitInfo shadow1 = rayMarch(p + shadowDirection*bias, shadowDirection, max_distance, avoid);\n  if(shadow1.hit) {\n    color*=0.4;\n  }\n  shadowDirection = normalize(light_2 - p);\n  bias = 0.001 * length(p - light_2);\n  RayHitInfo shadow2 = rayMarch(p + shadowDirection*bias, shadowDirection, max_distance, avoid);\n  if(shadow2.hit) {\n    color*=0.4;\n  }\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy - 0.5; // Center and scale UV\n  uv.x *= iResolution.x / iResolution.y; // Adjust aspect ratio\n  vec3 camPos = vec3(4.0*cos(iTime*0.25), 0.0, 4.0*sin(iTime*0.25)); // Camera position \n  vec3 forward = normalize(center - camPos); // Start by shooting rays towards the center\n  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)); // Approximate 'right' vector\n  vec3 up = cross(forward, right); // Approximate 'up' vector\n  float aspectRatio = iResolution.x / iResolution.y;\n  vec3 rayDir = normalize(forward +  // Thinking about this, up and right serve as getters here\n    (uv.x * aspectRatio) * right + \n    uv.y * up * tan(fieldOfView * 0.5));\n  RayHitInfo ray = rayMarch(camPos, rayDir, max_distance, 0.0); \n  vec3 color = background; //background;\n  if (ray.hit) {\n    color = ray.color;\n    vec3 surface_normal = ray.normal;\n    vec3 p = ray.position;\n    if(surface_normal != black) {\n      float mix_factor = 0.2;\n      \n      color = normalLighting(p, surface_normal, color);\n      color = shadowRays(p, ray.avoid, color);\n        // Calculate reflection direction\n      for(int i=0; i<5; i+=1) {\n        vec3 reflected_ray_dir = normalize(rayDir - 2.0 * dot(rayDir, surface_normal) * surface_normal);\n  \n        // Handle reflections\n        float reflection_bias = epsilon*1.1;\n        RayHitInfo reflection = rayMarch(p+reflected_ray_dir*reflection_bias, reflected_ray_dir, max_distance, ray.avoid);\n        vec3 reflection_color = reflection.color; // Combine the reflected color with the current color\n        p = reflection.position;\n        surface_normal = reflection.normal;\n        reflection_color = normalLighting(p, surface_normal, reflection_color);\n        reflection_color = shadowRays(p, reflection.avoid, reflection_color);\n        color = mix(color, reflection.color, mix_factor);\n        mix_factor *= mix_factor;\n        \n        if (!reflection.hit) {\n          break;\n        }\n        rayDir = reflected_ray_dir;\n        ray = reflection;\n      }\n    }\n  }\n  fragColor = vec4(color, 1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}