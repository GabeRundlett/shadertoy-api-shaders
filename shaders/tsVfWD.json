{
    "Shader": {
        "info": {
            "date": "1607198166",
            "description": "Effect of ~30 min Shader Livecoding session at https://thehacksummit.com, Thanks for stopping by and watching pixels bouncing to music",
            "flags": 64,
            "hasliked": 0,
            "id": "tsVfWD",
            "likes": 14,
            "name": "THS Shader Livecoding",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "music",
                "reflections",
                "livecoding",
                "klos"
            ],
            "usePreview": 0,
            "username": "spolsh",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n#define F gl_FragCoord\n// #define R v2Resolution\n// #define T fGlobalTime\n#define R iResolution\n#define T iTime\n#define N normalize\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v)  (texture(texFFT, v).x)\n\n// fake beat accumulation, next time I will save it in buffer\n#define BI(v) (0.05*T+0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define BS(v) (0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define B(v)  (0.01*texture(iChannel0, v2(v, 0.5)).x)\n\nf gB = 10e8;\n\nv3 colA = v3(0.2, 0.5, 1.4);\n\nmat2 rot(f a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nf box(v3 p, v3 b) {\n  v3 q = abs(p) -b;\n  return length( max(q, v3(0.))) + min( max(max(q.x, q.y), q.z), 0.);\n}\n\nf plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  vec4 p = vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n\treturn dot(p.xyz, p.xyz);\n}\n\nf map(v3 p) {\n  f s = min( p.y +1.5 + plas(0.1*p.xz - 0.1*T, 0.1*BI(0.0)), -p.y + 6.);\n  \n  v3 p0 = p; \n  p0.z -= 10.0*T;  \n  p0.x  = abs(p0.x);  \n  p0.xy *= rot( -0.7);  \n  p0.x -= 8.;  \n  p0.z = mod(p0.z + 2.0, 4.0) - 2.0;\n  s = min(s, box(p0, v3(1.0, 100.0, 1.0)));\n  \n  p -= v3(0, 2., 12. -100.0*BS(0.0));\n  \n  for (f i = 0.; i < 4.; ++i) {\n    p -= v3(0.2, 0.6 + 0.5*abs(sin(BI(0.0))), 0.6);\n    p.xy *= rot(  10.0*BI(0.0));\n    p.yz *= rot( -20.0*BI(0.0));\n    p = abs(p);\n    \n    f sl = box(p, v3(0.01, 100.0, 0.01));\n    s = min(s, sl);\n    gB = min(gB, sl);\n  }\n  \n  s = min(s , \n    mix(\n      length(p) -0.3 -200.0*B(0.0),\n      box(p, v3(0.3)),\n      abs(sin(T))\n)  );\n  \n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{    \t\n  v3 c = v3(0);\n  \n  vec2 q = (2.0*F.xy - R.xy) / R.y;\n  out_color = vec4(0.);\n  if (abs(q.y) > 0.75) return;\n  \n  v3 ro = v3( 2.0*sin(20.0*BI(0.0)), 2. + 20.0*B(0.0), 0);\n  v3 rd = N(v3(q, 2.));\n  rd.xy *= rot( 0.4*sin(20.0*BI(0.0)) );\n  \n  // c = v3(q, 0.);\n  c = v3(0.);\n  f t = 0.2;\n  f tt = 10e8;\n  for (f bi = 0.; bi < 4.; ++bi) {\n    for (f i = 0.; i < 64.; ++i) {\n      f d = map(ro + rd * t);    \n      if (d < 0.0001 || t > 40.) break;\n      t += d;\n    }  \n     tt = bi == 0. ? t : tt;\n      if (t > 0.1 && t < 40.0) {\n          v3 p = ro + rd * t;\n          f str0 = smoothstep(.5, .51, fract(2.33*p.x));\n          f str1 = smoothstep(.5, .51, fract(0.1*p.x));\n          \n          v2 e = 0.001 * v2(-1., 1);\n          v3 n = N(\n                e.xxx * map(p + e.xxx)\n              + e.yxx * map(p + e.yxx)\n              + e.xyx * map(p + e.xyx)\n              + e.xxy * map(p + e.xxy)\n          );\n          // c = n;\n          f fre = pow(dot(rd, n) + 1., 6.);\n          c += colA.zyx * (0.5+0.5*fre) * (str0+str1);\n        \n          rd = N(reflect(rd, n) + 0.01 * fract(sin(100.0*p) * 43758.5453));\n          ro = p;\n      }  \n  } \n  // c = v3(1.0 - (t / 32.));\n  // c = mix(c, N(mix(colA, colA.zyx, sin(20.0*(t / 32.)))), sin(T));\n  \n  c = mix(c, 0.01*colA, 1.0 - exp(-0.01 *tt*tt));\n  \n  f sb = 1. + 50.0*BS(0.0) + 20.0*B(0.0);\n  c += sb * colA * exp(gB * -20.0);\n  c += sb * colA * exp(gB * -10.0);\n  c += sb * colA * exp(gB * -2.0);\n  c += sb * colA * exp(gB * -1.0);\n  c += 20.0*B(0.0);\n  \n  c = c / (1. + c);\n  c = pow(c, v3(0.4545));\n  out_color = c.xyzz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 24810,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/inzynier/01-rec-2020-04-23"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}