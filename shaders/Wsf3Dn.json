{
    "Shader": {
        "info": {
            "date": "1545607082",
            "description": "gloopy",
            "flags": 0,
            "hasliked": 0,
            "id": "Wsf3Dn",
            "likes": 3,
            "name": "gloopy",
            "published": 3,
            "tags": [
                "gloopy"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 485
        },
        "renderpass": [
            {
                "code": "// GLOOPY\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n    \n#define\tTAU 6.28318\n#define CHS 0.35\nfloat sdBox2(in vec2 p,in vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);}\nfloat line2(float d,vec2 p,vec4 l){vec2 pa=p-l.xy;vec2 ba=l.zw-l.xy;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return min(d,length(pa-ba*h));}\nfloat LR(vec2 p, float d){p.x=abs(p.x);return line2(d,p,vec4(2,-3.25,2,3.25)*CHS);}\nfloat TB(vec2 p, float d){p.y=abs(p.y);return line2(d,p,vec4(2,3.25,-2,3.25)*CHS);}\nfloat TBLR(vec2 p, float d){return min(d,abs(sdBox2(p,vec2(2,3.25)*CHS)));}\nfloat G(vec2 p,float d){d=TB(p,d);d=line2(d,p,vec4(-2,-3.25,-2,3.25)*CHS);d=line2(d,p,vec4(2,2.25,2,3.25)*CHS);d=line2(d,p,vec4(2,-3.25,2,-0.25)*CHS);return line2(d,p,vec4(2,-0.25,0.5,-0.25)*CHS);}\nfloat L(vec2 p,float d){d=line2(d,p,vec4(2,-3.25,-2,-3.25)*CHS);return line2(d,p,vec4(-2,3.25,-2,-3.25)*CHS);}\nfloat O(vec2 p,float d){return TBLR(p,d);}\nfloat P(vec2 p,float d){d=line2(d,p,vec4(-2,-3.25,-2,0.0)*CHS);p.y-=1.5*CHS;return min(d,abs(sdBox2(p,vec2(2.0,1.75)*CHS)));}\nfloat Y(vec2 p,float d){d=line2(d,p,vec4(0,-0.25,0,-3.25)*CHS);p.x=abs(p.x);return line2(d,p,vec4(0,-0.25,2,3.25)*CHS);}\n\nfloat message(vec3 p)\n{\n\tfloat d = 1.0;\n\tfloat cw = 5.8*CHS;\n\tfloat gap = (cw*2.0)+40.0;\n\tfloat width = (16.0*cw);\n\tfloat xmod = width+gap;\n    \n\tfloat c = pMod1(p.z,9.0);\n\tp.z -= 0.2+sin(p.x*1.3+fract(iTime*0.05)*TAU)*0.08;\n\tp.x += fract(iTime*0.075)*xmod+c*16.0;\n\tpMod1(p.x, xmod);\n\tvec2 uv = p.xy;\n\tfloat x = -((width*0.5+gap*0.5)-cw);\n\tfloat t1 = fract(iTime*0.5) * TAU;\n\tfloat y = -1.0+sin(t1+p.x*0.25)*0.5;\n\tuv-=vec2(x,y);\n\td = G(uv,d); uv.x -= cw;\n\td = L(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = O(uv,d); uv.x -= cw;\n\td = P(uv,d); uv.x -= cw;\n\td = Y(uv,d);\n\td -= 0.1;\n\tif (d<1.0)\n\t{\n\t\tfloat dep = 0.025;\n\t\tvec2 e = vec2( d, abs(p.z) - dep );\n\t\td = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n\t\td -= 0.325*CHS;\n\t}\n\treturn d;\n}\n\nmat2 rot(float a)\n{\n\tfloat c = cos(a),\n\t\ts = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p)\n{\n\tfloat t2 = fract(iTime*0.05) * TAU;\n\tp.xy *= rot(p.y*0.02+p.x*0.04-p.z * .05 + t2);\n\tfloat k = dot(sin(p.z+2. * p - cos(p.yxz)), vec3(.233));\n\tk-=sin(p.x*p.y+p.z)*0.14;\n\tk*=0.7+sin(fract(iTime*0.54)*TAU+p.z*1.4)*0.35;\n\tfloat d = 2.5 -abs(p.y) - k*k;\n\tfloat dm = message(p);\n\td = smin(d,dm,0.75);\n\treturn d;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.001, 0.);\n\tvec3 n;\n\tn.x = map(p + e.xyy) - map(p - e.xyy);\n\tn.y = map(p + e.yxy) - map(p - e.yxy);\n\tn.z = map(p + e.yyx) - map(p - e.yyx);\n\treturn normalize(n);\n}\n\nvec3 render(vec2 uv) {\n\t\n\tvec3 ro = vec3(sin(iTime)*0.15, cos(iTime*0.5)*0.2, iTime*0.75);\n\tvec3 rd = normalize(vec3(uv, .8));\n\tvec3 p = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n\tvec3 l = ro;\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = .5 * max(dot(lp, n), 0.);\n\treturn vec3(diff*0.65,diff*1.49,diff*0.65) / (1. + t * t * .01);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tfragColor = vec4(render(uv), 1.);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}