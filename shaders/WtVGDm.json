{
    "Shader": {
        "info": {
            "date": "1579126350",
            "description": "It's a sewer.\nTakes a while to converge",
            "flags": 32,
            "hasliked": 0,
            "id": "WtVGDm",
            "likes": 7,
            "name": "Day 27 - A Sewer",
            "published": 3,
            "tags": [
                "pathtracer",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U / iResolution.xy;\n    \n    C = T(U);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nMaterial materials[7] = Material[](\n\tMaterial(vec3(1.,0.4,1)*1.1,0.,1., 0.), // wall\n\tMaterial(vec3(0.9,1.,0.9)*1.0,0.1,1., 0.), // Wall\n\tMaterial(vec3(1.07,1.05,1)*1.,0.0,1., 60.), \t\t// Light\n\tMaterial(vec3(0.9,0.8,0.8)*1.0,0.6,0.2, 0.), // Red Rust\n\tMaterial(vec3(1.,1.,1.)*0.4,0.7,0.14, 0.), // Wires\n\tMaterial(vec3(0.9,1.,0.9)*1.0,0.6,0.9, 0.), //\n\tMaterial(vec3(0.4,0.5,0.7)*1.0,1.,0.3, 0.) // \n);  \n\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    uv += (hash(uv.x + uv.y + float(iFrame)) - 0.5  )*0.002;\t\t\t// thx slerpy\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\n// ----------------- SDFs ----------------- //\nfloat sdBox (vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}    \nfloat sdSphere (vec3 p, float s){\n\treturn length(p) - s;\n}\nfloat sdFloorA (vec3 p){\n    return p.y;\n}\nfloat sdWall (vec3 p){\n    return -p.x;\n}\nfloat sdBackWall (vec3 p){\n    return -p.z;\n}\n\n#define pmod(p, x) mod(p, x) - x*0.5\n\n#define outerW 17.\n\n \n\nvec2 sdMain(vec3 p){\n\tvec2 d = vec2(10e10);\n    \n    float repDistY = 8.;\n    float qRepDistY = 30.;\n    float idY = floor(p.y/repDistY);\n    float rA = r11(idY);\n    float rB = r11(idY + 0.2);\n    float rC = r11(idY + 0.6);    \n\n    float repsXZ = 2. + floor(rA*1.99);\n\n    vec3 q = p;\n    q.y = pmod(q.y, qRepDistY);\n        \n    p.xz *= rot(rA*PI*30.);\n    \n    \n    q = abs(q);\n    q.x -= outerW;\n    vec3 v = q;\n    vec3 s = vec3(0.9, 10., 1.6);\n    // WallBox\n    \n    q.x += 0.5;\n    \n    d = dmin(d, sdBox(q, s), 5.);\n    q = abs(q);\n    for(int i = 0; i < 4; i++){\n    \tq = abs(q);\n    \tq.xz *= rot(0.25*PI);\n    }\n    q.xy *= rot(0.1*PI);    \n    q.x += 1.4;\n    // WallBox\n    d = dmax(d, -sdBox(q, s*0.9), 1.);\n    \n    d = dmin(d, sdBox(v, s*0.9), 2.);\n\n    vec3 polarQ = vec3(\n        length(q),\n    \tatan(q.y,q.x),\n        acos(p.z/length(p))\n    );\n     \n    // Outer\n    d = dmin(d, -(length(p.xz) - outerW) - T1(vec2(p.y*.5, 5.*atan(p.z, p.x)/tau)).x*7.95, 1.)  ;\n   \n    // Center\n    d = dmin(d,   max(abs(p.x)-1.,abs(p.z) -1.), 3.);\n    //d.x = min(d.x, length(p.xz) - 1.);\n    \n    vec3 n = p;\n    float pId = floor(3.*atan(p.x,p.z)/tau);\n    pModPolar(p.xz, repsXZ);\n    pModPolar(n.xz, repsXZ);\n    p.y = pmod(p.y, repDistY);\n    \n    p.xz *= rot(0.5*PI);\n    \n    // Lines\n    p.y -= repDistY*0.5;\n    p.y += (1. + 3.*sin(pId*5214.))*sin((length(p.xz)/outerW)*PI);\n    d = dmin(d, length(p.yx) - 0.1, 4.) ;\n    \n    // Pipes\n    q.y -= 9.6;\n    q.x += 19.5;\n    \n    q.xz *= rot(0.2);\n    //q.y -= 2.*sin((length(q.xz)/outerW)*PI);\n    d = dmin(d, length(q.yx) - 0.5, 6.) ;\n    \n    d.x *= 0.74;\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\n\n// ----------------- MAP ----------------- //\n#define HEIGHT\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n    vec2 dMain = sdMain(p);\n    \n\tObject mainScene = Object(\n    \tdMain.x,\n        true,\n        materials[int(dMain.y)]\n    );\n    \n    o = omin(o, mainScene);\n    //o = omin(o, length(p) - 4., materials[2]);\n\t\n    glow += exp(-o.d*1.);    \n    o.didHit = true;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.2;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS; i++) {\n    \tObject obj = map(p);\n        \n        if (obj.d < 0.001) {\n            obj.d = t;\n        \treturn obj;\n            break;\n        }\n        \n        if (t > 300.) {\n            obj.didHit = false;\n            return obj;\n        \tbreak;\n        }\n    \n        t += obj.d;\n        p = ro + rd*t;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.001,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n// ----------------- MAIN ----------------- //\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    uv -= normalize(uv)*pow(length(uv)*0.34,3.);\n    vec2 uvs = (U/R);\n\n    vec4 col = T(U);\n\t\n    vec3 accum = vec3(0);\n    vec3 attenuation = vec3(1.);\n    \n    vec3 ro = vec3(3.,-0.09,0.);\n    float r = 2.2;\n    ro.xz -= vec2(sin(r), cos(r)) * zoom;\n\n    vec3 lookAt = vec3(1.0,24,0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xy *= rot(0.2);\n    vec3 dir = rd;\n    float seed = hash(float(iFrame) + uv.x*243.124 + uv.y*212.512);\n    \n    float dFirst = 0.;\n    bool hitBg = false;\n    int i = 0;\n    for (; i < BOUNCES; i++){\n    \tObject obj = trace(ro, rd);\n        if (obj.didHit) {       \n            if (i == 0){\n                dFirst = obj.d;\n            }\n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p);\n            accum += obj.material.albedo*obj.material.emissiveness*attenuation;\n\t\t\t//accum += ;\n            attenuation *= obj.material.albedo;\n            attenuation *= 1./PI; // thx slerpy\n            //accum += obj.material.albedo * attenuation;\n            //seed += 14.5;\n            seed = hash22(float(iFrame) + vec2(uv) + float(i)*1. ).x;\n            ro = p;\n                        \n            rd = mix(cosineDirection(seed, N),N,obj.material.metalness);\n            \n        } else {\n            hitBg = true;\n            break;\n        }\n        \n    }\n    float light = 1.5*step(.7,dot(rd,normalize(vec3(0.01,-1,0.01))));\n    //accum *= light;\n    //col.xyz += accum;\n\n    //col.xyz -= glow*0.001;\n    if (iFrame == 0) {\n        col.w = 0.;\n        col.xyz = vec3(0.);\n    }\n\n    col.w += 1.;\n    //col.xyz = vec3(dFirst);\n    col.xyz += accum;    \n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RAND 2\n\n#define fov 0.7\n#define BOUNCES 4\n#define MARCH_ITERATIONS 160\n#define zoom 9.\n\n\n#define bdist 0.00\n#define PI 3.14159265359\n\n#define R (iResolution.xy)\n#define T(UV) texture(iChannel0, UV/R)\n#define T1(UV) texture(iChannel1, UV/R)\n#define tau (2.*PI)\n\n\nfloat r11(float i){return fract(sin(i*8124.124124)*123.2412);}\nvec3 r13(float i){return vec3(r11(i),r11(i + 0.2),r11(i + 0.4));}\nfloat r11c(float i){return fract(sin(i*8124.124124));} // cheaper\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define BLUR_AMT (1.)\n//#define FOCUS_DISTANCE (0.1 + (0.5 + sin(iTime)*0.5))\n#define FOCUS_DIV 3.\n//#define FOCUS_DIdSTANCE (0.1 + (FOCUS_DIV + sin(iTime)*FOCUS_DIV))\n#define FOCUS_DISTANCE (2.5)\n#define SRGBLIN\n\n#define dmin(a, b, mat) a.x < b ? a : vec2(b, mat)\n#define dmax(a, b, mat) a.x > b ? a : vec2(b, mat)\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// hg_sdf\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nstruct Material {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness; \n\tfloat emissiveness;\n};\n\nstruct Light {\n\tvec3 colour;\n    vec3 pos;\n\tfloat intensity;\n};\nLight lights[1] = Light[](\n    Light(vec3(1.2,1.2,1), vec3(-0.,10.,0.), 0.)\n);    \n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tMaterial material;\n};\nObject omin(Object a, float bdistance, Material bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, Material bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,materials[0])\n\n\n\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define C fragColor\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 uv = U/R;\n    uv.y -= 0.5;\n\n    vec4 tex = T(U);\n    fragColor = tex;\n    fragColor.xyz /= fragColor.w;\n    \n    fragColor *= 1.;\n    fragColor = 1.*fragColor/(1.0+max(fragColor.x,max(fragColor.y,fragColor.z)));\n    //vec3 fogColor =  mix(vec3(0.6,.26,0.119)*0.05, vec3(0.5,.16,0.319)*0.09, uv.y)*0.2;\n    //fragColor.xyz = mix(fragColor.xyz,fogColor, pow(smoothstep(0.,1.,fragColor.w*0.19 - 0.9), 1.04));\n    //fragColor.xyz = clamp(fragColor.xyz, 0.03,1.);\n    \n    C = smoothstep(0.05,0.8,C);\n    C.xyz*= vec3(0.96,0.9,0.95);\n    //C = smoothstep(0.01,1.,C);\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n    \n    C *= 1. - mix(0.,1., pow(smoothstep(0.,1.,length(uv))*0.8, 3.6));\n    C *= 2.6;\n    //fragColor.xyz = smoothstep(0.,1.,fragColor.xyz); // thx to yx for smoothstep col\n    \n    //fragColor.xyz = smoothstep(0.,1.,pow(fragColor.xyz, vec3(0.8)));\n}   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Texture generation\n\nfloat sdBox(vec2 p, vec2 s){\n\t p = abs(p) - s;\n\treturn max(p.x, p.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    // thx alkama for giving idea for similar texture\n\tvec2 p = (U - 0.5*R)/R.y;\n    if (iFrame < 4){\n        for (float i = 0.; i < 10.; i++){\n            vec3 r = r13(i);\n            vec2 z = p - (r.xy*2. - 1.)*1.; \n            vec2 s = r.yz + 0.2; \n        \tC += smoothstep(0.11,0.1, sdBox(z, s));\n        }\n        C /= 10.;\n    } else {\n    \tC = T(U);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}