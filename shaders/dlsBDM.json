{
    "Shader": {
        "info": {
            "date": "1693112135",
            "description": "0 = Input\n1 = 2D FFT\n2 = Inverse FFT\n\nSee use_sq at the top of Common.",
            "flags": 32,
            "hasliked": 0,
            "id": "dlsBDM",
            "likes": 3,
            "name": "Inverse Square Fourier Transform",
            "published": 3,
            "tags": [
                "fft",
                "square",
                "fourier",
                "transform",
                "dft"
            ],
            "usePreview": 0,
            "username": "beans_please",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "vec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = (2.0 * frag_coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // What to render at this time?\n    int mode = int(floor(3. * iTime / sec_per_shape)) % 3;\n    \n    // UV for text\n    vec2 uv2 = frag_coord / min(iResolution.x, iResolution.y);\n    uv2 -= .1;\n    uv2 /= 1.5;\n    const vec2 uv2max = vec2(64. / 1024.) - .001;\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (all(greaterThan(uv2, vec2(.001))) && all(lessThan(uv2, uv2max)))\n    {\n        // Text\n        col = vec3(texture(iChannel2, vec2(0., .75) + vec2(float(mode) * 64. / 1024., 0.) + uv2).x);\n    }\n    else if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        float v = 0.;\n        switch (mode)\n        {\n        case 0:\n            // Input\n            ft_input_init(iTime);\n            v = ft_input(vec2(uv * 0.5 + 0.5), iTime);\n            break;\n        case 1:\n            // FFT\n            v = length(texelFetch(iChannel0, ivec2(vec2(uv * 0.5 + 0.5) * vec2(ft_res)), 0).rg);\n            break;\n        case 2:\n            // Inverse FFT\n            v = length(texelFetch(iChannel1, ivec2(vec2(uv * 0.5 + 0.5) * vec2(ft_res)), 0).rg);\n            break;\n        }\n        col = vec3(v);\n    }\n    else\n    {\n        col = vec3(0);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Use square sin/cos?\nconst bool use_sq = true;\n\n// FT resolution\nconst ivec2 ft_res = ivec2(100);\n\n// FT multiplier. Do not modify\nconst float ft_mul = 1. / sqrt(float(ft_res.x * ft_res.y));\n\n// Seconds per shape\nconst float sec_per_shape = 6.;\n\n\n\n/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\n/*____________________ End ____________________*/\n\n\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return remap01(x - center, -half_width - fade_width, -half_width)\n        * remap01(x - center, half_width + fade_width, half_width);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n\n// FT input variables\nfloat ft_input_shape0_radius;\nfloat ft_input_shape1_slit1_half_width;\nfloat ft_input_shape1_slit2_center;\nfloat ft_input_shape1_slit2_fade;\nfloat ft_input_shape1_cutout_radius;\n\n// Initialize FT input variables\nvoid ft_input_init(float time)\n{\n    float t = TAU * time;\n    ft_input_shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    ft_input_shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    ft_input_shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    ft_input_shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    ft_input_shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n}\n\n// Evaluate FT input at uv and time\nfloat ft_input(vec2 uv, float time)\n{\n    int shape = int(floor(time / sec_per_shape)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return remap01(distance(uv, vec2(0.5, 0.5)), ft_input_shape0_radius, ft_input_shape0_radius - 0.02);\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, ft_input_shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, ft_input_shape1_slit2_center, 0.02, ft_input_shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= remap01(d, ft_input_shape1_cutout_radius, ft_input_shape1_cutout_radius - 0.01);\n        v *= remap01(d, 0.3, 0.01) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return remap01(sd_npoly(5.0, 0.15, time * 0.25, uv - 0.5), 0.01, 0.0);\n    }\n    return 0.;\n}\n\n// Square sin\nfloat sqsin(float x)\n{\n    if (use_sq)\n        return mod(x / TAU, 1.) < .5 ? 1. : -1.;\n    else\n        return sin(x);\n}\n\n// Square cos\nfloat sqcos(float x)\n{\n    if (use_sq)\n        return mod((x / TAU) + .25, 1.) < .5 ? 1. : -1.;\n    else\n        return cos(x);\n}\n\n// Multiply two complex numbers\nvec2 complex_mul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// FT is performed in this buffer.\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0);\n    for (int y = 0; y < ft_res.y; y++)\n    {\n        for (int x = 0; x < ft_res.x; x++)\n        {\n            vec2 uv = (vec2(x, y) + .5) / vec2(ft_res);\n            float a = dot(uv, f2);\n            v += ft_input(uv, iTime) * vec2(sqcos(a), sqsin(a));\n            // Same thing:\n            //v += complex_mul(vec2(ft_input(uv, iTime), 0.), vec2(sqcos(a), sqsin(a)));\n        }\n    }\n    return v * ft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < ft_res.x || int(floor(iResolution.y)) < ft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // If outside the region of interest\n    if (icoord.x >= ft_res.x || icoord.y >= ft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for ft_input\n    ft_input_init(iTime);\n    \n    // What 2D frequency to check\n    ivec2 freq = icoord - (ft_res / 2);\n    \n    // How much of the frequency is present\n    frag_col = vec4(freq_amount(freq), 0., 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Inverse FT is performed in this buffer.\n\n// How much of this frequency is present in the input?\nvec2 freq_amount(ivec2 freq)\n{\n    vec2 f2 = vec2(freq) * -TAU;\n    vec2 v = vec2(0);\n    for (int y = 0; y < ft_res.y; y++)\n    {\n        for (int x = 0; x < ft_res.x; x++)\n        {\n            vec2 uv = (vec2(x, y) + .5) / vec2(ft_res);\n            float a = dot(uv, f2);\n            v += complex_mul(texelFetch(iChannel0, ivec2(x, y), 0).xy, vec2(sqcos(a), sqsin(a)));\n        }\n    }\n    return v * ft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < ft_res.x || int(floor(iResolution.y)) < ft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // If outside the region of interest\n    if (icoord.x >= ft_res.x || icoord.y >= ft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // What 2D frequency to check\n    ivec2 freq = icoord;\n    \n    // How much of the frequency is present\n    frag_col = vec4(freq_amount(freq), 0., 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}