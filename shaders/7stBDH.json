{
    "Shader": {
        "info": {
            "date": "1656445601",
            "description": "Experimenting with different types of noise.",
            "flags": 0,
            "hasliked": 0,
            "id": "7stBDH",
            "likes": 3,
            "name": "Noise Types Experiment",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "random"
            ],
            "usePreview": 0,
            "username": "cra_manning_w",
            "viewed": 217
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float BORDER_DROPOFF = 20.0,\n                BORDER_SIZE = 0.5;\n    const int N_SEGMENTS_ON_SIDE = 3;\n    const float SEGMENT_SIZE = 1.0 / float(N_SEGMENTS_ON_SIDE);\n    vec2 segmentPointer = uv;\n    if (iMouse.z > 0.5)\n        segmentPointer = iMouse.xy / iResolution.xy;\n    vec2 segmentPos = fract(segmentPointer / SEGMENT_SIZE);\n    vec2 segmentBorder2D = abs(segmentPos - 0.5);\n    float segmentBorder = 1.0 - max(border(segmentBorder2D.x, 0.5, BORDER_SIZE, BORDER_DROPOFF),\n                                    border(segmentBorder2D.y, 0.5, BORDER_SIZE, BORDER_DROPOFF));\n    \n    ivec2 segment = ivec2(segmentPointer / SEGMENT_SIZE);\n    vec2 panning = iTime * vec2(0.4, 0.2);\n    vec2 noisePos = uv * 10.0 + panning;\n    \n    //Note that segment's Y index increases as you go upwards.\n    float noise = 0.0;\n    //Column 1: plain noise.\n    if (segment == ivec2(0, 0))\n    {\n        noise = perlinNoise(noisePos, 1.430);\n    }\n    else if (segment == ivec2(0, 1))\n    {\n        noise = perlinNoise(noisePos, 1.430);\n        noise = pow(2.0 * abs(noise - 0.5), 0.75);\n    }\n    else if (segment == ivec2(0, 2))\n    {\n        noise = perlinNoise(noisePos, 1.430);\n        noise *= noise;\n    }\n    //Column 2: octave noise.\n    else if (segment == ivec2(1, 0))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            octaveNoise,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            \n        );\n        noise = octaveNoise;\n    }\n    else if (segment == ivec2(1, 1))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            octaveNoise,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        noise = octaveNoise;\n    }\n    else if (segment == ivec2(1, 2))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            octaveNoise,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        noise = octaveNoise;\n    }\n    //Column 3: Interesting experiments.\n    else if (segment == ivec2(2, 0))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseA,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseB,\n            2.0, 0.825, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        noise = pow(noiseA, noiseB);\n    }\n    else if (segment == ivec2(2, 1))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseA,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseB,\n            2.0, 0.825, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        noise = min(noiseA, noiseB) / max(noiseA, noiseB);\n        noise = 1.0 - noise;\n    }\n    else if (segment == ivec2(2, 2))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos * 0.25,\n            noiseA,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        IMPL_OCTAVE_NOISE(\n            noisePos / pow(noiseA, 0.01),\n            noiseB,\n            2.0, 0.825, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        noise = noiseB;\n    }\n\n    float saturation = step(segmentPos.x, 0.5);\n    vec3 col = mix(vec3(noise),\n                   texture(iChannel0, vec2(0.5 + (noise * 0.0625))).rgb,\n                   saturation);\n    fragColor = vec4(col * segmentBorder, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n////////////////////\n//    Hashing     //\n////////////////////\n\n// A modified version of this: https://www.shadertoy.com/view/4djSRW\n//Works best with seed values in the hundreds.\n\n//Hash 1D from 1D-3D data\nfloat hashTo1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hashTo1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hashTo1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Hash 2D from 1D-3D data\nvec2 hashTo2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Hash 3D from 1D-3D data\nvec3 hashTo3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hashTo3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hashTo3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//Hash 4D from 1D-4D data\nvec4 hashTo4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nvec4 hashTo4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nvec4 hashTo4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hashTo4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n#define OSCILLATE(a, b, input) (mix(a, b, 0.5 + (0.5 * sin(2.0 * 3.14159265 * (input)))))\n\n#define INV_LERP(a, b, x) ((x-a) / (b-a))\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define SHARPEN(t) smoothstep(0.0, 1.0, t)\n#define SHARPENER(t) SMOOTHERSTEP(t)\n\n#define COMMA ,\n\n#define RAND_IN_ARRAY(array, t) array[int(mix(0.0, float(array.length()) - 0.00001, t))]\n\n//A higher-quality smoothstep(), with a zero second-derivative at the edges.\n#define SMOOTHERSTEP(t) clamp(t * t * t * (t * (t*6.0 - 15.0) + 10.0), \\\n                              0.0, 1.0)\n\n//Returns a value that increases towards 1 as it gets closer to some target.\nfloat border(float x, float target, float thickness, float dropoff)\n{\n    float dist = abs(x - target);\n    float closeness = 1.0 - min(1.0, dist / thickness);\n    return pow(closeness, dropoff);\n}\n\n//Distance-squared is faster to compute in 2D+, but not in 1D.\n//Some noise is defined with the help of macros to work with any dimensionality,\n//    and so is agnostic to the dimensionality.\nfloat efficientDist(float a, float b) { return abs(b - a); }\nfloat efficientDist(vec2 a, vec2 b) { vec2 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec3 a, vec3 b) { vec3 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec4 a, vec4 b) { vec4 delta = b - a; return dot(delta, delta); }\nfloat realDist(float efficientDist, float posType) { return efficientDist; }\nfloat realDist(float efficientDist, vec2 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec3 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec4 posType) { return sqrt(efficientDist); }\n\nfloat sumComponents(float f) { return f; }\nfloat sumComponents(vec2 v) { return v.x + v.y; }\nfloat sumComponents(vec3 v) { return v.x + v.y + v.z; }\nfloat sumComponents(vec4 v) { return v.x + v.y + v.z + v.w; }\n\n//Gets the angle of the given vector, in the range 0-1.\nfloat angleT(vec2 dir) { return 0.5 + (0.5 * atan(dir.y, dir.x)/3.14159265); }\n\n//Given a uniformly-distributed value, and another target value,\n//    biases the uniform value towards the target.\n//The \"biasStrength\" should be between 0 and 1.\nfloat applyBias(float x, float target, float biasStrength)\n{\n    //Degenerative case if x=0.\n    if (x == 0.0)\n        return mix(x, target, biasStrength);\n    \n    //Get the \"scale\" of the target relative to x.\n    //Multiplying x by this number would give exactly the target.\n    float scale = target / x;\n    \n    //Weaken the \"scale\" by pushing it towards 1.0, then apply it to 'x'.\n    //Make sure to respect the sign, in case 'x' or 'target' is negative.\n    return x * sign(scale) * pow(abs(scale), biasStrength);\n}\n\n//Linearly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleLerp(float a, float b, float c, float t)\n{\n    vec3 lerpArgs = (t < 0.5) ?\n                        vec3(a, b, INV_LERP(0.0, 0.5, t)) :\n                        vec3(b, c, INV_LERP(0.5, 1.0, t));\n    return mix(lerpArgs.x, lerpArgs.y, lerpArgs.z);\n}\nvec3 tripleLerp(vec3 a, vec3 b, vec3 c, float t)\n{\n    bool isFirstHalf = (t < 0.5);\n    return isFirstHalf ?\n               mix(a, b, INV_LERP(0.0, 0.5, t)) :\n               mix(b, c, INV_LERP(0.5, 1.0, t));\n    \n}\n//Smoothly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(lerpArgs.z, lerpArgs.w, t));\n}\n//Interpolates between a beginning, midpoint, and endpoint, with aggressive smoothing.\nfloat tripleSmoothSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(0.0, 1.0, smoothstep(lerpArgs.z, lerpArgs.w, t)));\n}\n\nvec2 randUnitVector(float uniformRandom)\n{\n    float theta = uniformRandom * 2.0 * 3.14159265;\n    return vec2(cos(theta), sin(theta));\n}\n\n///////////////////////////////\n//    Value/Octave Noise     //\n///////////////////////////////\n\nfloat valueNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x);\n\n    float noiseMin = hashTo1(vec2(xMin, seed) * 450.0),\n          noiseMax = hashTo1(vec2(xMax, seed) * 450.0);\n\n    float t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    return mix(noiseMin, noiseMax, t);\n}\nfloat valueNoise(vec2 x, float seed)\n{\n    vec2 xMin = floor(x),\n         xMax = ceil(x);\n    vec4 xMinMax = vec4(xMin, xMax);\n\n    vec2 t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    #define VALUE_NOISE_2D(pos) hashTo1(vec3(pos, seed) * 450.0)\n    return mix(mix(VALUE_NOISE_2D(xMinMax.xy),\n                   VALUE_NOISE_2D(xMinMax.zy),\n                   t.x),\n               mix(VALUE_NOISE_2D(xMinMax.xw),\n                   VALUE_NOISE_2D(xMinMax.zw),\n                   t.x),\n               t.y);\n}\n\n//Octave noise behaves the same regardless of dimension.\n#define IMPL_OCTAVE_NOISE(x, outputVar, persistence, seed, nOctaves, noiseFunc, noiseMidArg, octaveValueMod) \\\n    float outputVar; { \\\n    float sum = 0.0,                                                 \\\n          scale = 1.0,                                               \\\n          nextWeight = 1.0,                                          \\\n          totalWeight = 0.0;                                         \\\n    for (int i = 0; i < nOctaves; ++i)                               \\\n    {                                                                \\\n        float octaveValue = noiseFunc((x) * scale,                   \\\n                                      noiseMidArg                    \\\n                                      (seed) + float(i));            \\\n        octaveValueMod;                                              \\\n        sum += octaveValue * nextWeight;                             \\\n        totalWeight += nextWeight;                                   \\\n                                                                     \\\n        nextWeight /= (persistence);                                 \\\n        scale *= (persistence);                                      \\\n    }                                                                \\\n    outputVar = sum / totalWeight;                                   \\\n}\nfloat octaveNoise(float x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, valueNoise, ,); return outNoise; }\nfloat octaveNoise(vec2 x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, valueNoise, ,); return outNoise; }\n\n#define PERLIN_MAX(nDimensions) (sqrt(float(nDimensions)) / 2.0)\nfloat perlinNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x),\n          t = x - xMin;\n\n    float value = mix(t         * sign(hashTo1(vec2(xMin, seed) * 450.0) - 0.5),\n                      (1.0 - t) * sign(hashTo1(vec2(xMax, seed) * 450.0) - 0.5),\n                      SHARPENER(t));\n    return INV_LERP(-PERLIN_MAX(1), PERLIN_MAX(1), value);\n}\n\nvec2 perlinGradient2(float t)\n{\n    return randUnitVector(t);\n}\nfloat perlinNoise(vec2 p, float seed)\n{\n    vec2 pMin = floor(p),\n         pMax = pMin + 1.0,\n         t = p - pMin;\n    vec4 pMinMax = vec4(pMin, pMax),\n         tMinMax = vec4(t, p - pMax);\n\n    #define PERLIN2_POINT(ab) dot(tMinMax.ab, \\\n                                  perlinGradient2(hashTo1(vec3(pMinMax.ab, seed) * 450.0)))\n    float noiseMinXMinY = PERLIN2_POINT(xy),\n          noiseMaxXMinY = PERLIN2_POINT(zy),\n          noiseMinXMaxY = PERLIN2_POINT(xw),\n          noiseMaxXMaxY = PERLIN2_POINT(zw);\n\n    t = SHARPENER(t);\n    float value = mix(mix(noiseMinXMinY, noiseMaxXMinY, t.x),\n                      mix(noiseMinXMaxY, noiseMaxXMaxY, t.x),\n                      t.y);\n    return INV_LERP(-PERLIN_MAX(2), PERLIN_MAX(2), value);\n}\n\n\n\n/////////////////////////\n//    Worley Noise     //\n/////////////////////////\n\n//Helper function for worley noise that finds the point in a cell.\n//Outputs its position, and returns whether or not it really exists.\nbool getWorleyPoint(float cell, float chanceOfPoint, float seed, out float pos)\n{\n    vec2 rng = hashTo2(vec2(cell * 450.0, seed)).xy;\n    \n    pos = cell + rng.x;\n    return (rng.y < chanceOfPoint);\n}\nbool getWorleyPoint(vec2 cell, float chanceOfPoint, float seed, out vec2 pos)\n{\n    vec3 rng = hashTo3(vec3(cell, seed) * 450.0).xyz;\n    \n    pos = cell + rng.xy;\n    return (rng.z < chanceOfPoint);\n}\n\n//Generates worley-noise points that might influence the given position.\n//See the below functions for common use-cases.\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\n//Implementation below:\n#define IMPL_WORLEY_START(T)                                    \\\n    T xCenter = floor(x),                                       \\\n      xMin = xCenter - 1.0,                                     \\\n      xMax = xCenter + 1.0;                                     \\\n    nPoints = 0;                                                \\\n    T nextPoint\n//end #define\n#define IMPL_WORLEY_POINT(cellPos)                                  \\\n    if (getWorleyPoint(cellPos, chanceOfPoint, seed, nextPoint))    \\\n        points[nPoints++] = nextPoint\n//end #define\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int nPoints, out float points[3])\n{\n    IMPL_WORLEY_START(float);\n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n}\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int nPoints, out vec2 points[9])\n{\n    IMPL_WORLEY_START(vec2);\n    \n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n    \n    IMPL_WORLEY_POINT(vec2(xMin.x, xCenter.y));\n    IMPL_WORLEY_POINT(vec2(xMin.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xMax.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xMax.x, xCenter.y));\n}\n\n//Variant 1: straight-line distance, to the nearest point.\nfloat worley1(float x, float chanceOfPoint, float seed);\nfloat worley1(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY1(T, nMaxPoints)                                              \\\nfloat worley1(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /*Specify a hard-coded cap,  */            \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, efficientDist(points[i], x));                     \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                \\\n}\n//end #define\nIMPL_WORLEY1(float, 3)\nIMPL_WORLEY1(vec2,  9)\n\n//Variant 2: manhattan distance, to the nearest point.\nfloat worley2(float x, float chanceOfPoint, float seed);\nfloat worley2(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY2(T, nMaxPoints)                                              \\\nfloat worley2(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, sumComponents(abs(points[i] - x)));               \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                               \\\n}\n//end #define\nIMPL_WORLEY2(float, 3)\nIMPL_WORLEY2(vec2,  9)\n\n//Variant 3: straight-line distance, to the second- nearest point.\nfloat worley3(float x, float chanceOfPoint, float seed);\nfloat worley3(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY3(T, nMaxPoints)                                              \\\nfloat worley3(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist1 = 9999999.9,                                                  \\\n          minDist2 = 9999999.9;                                                  \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        float newD = efficientDist(points[i], x);                                \\\n        if (newD < minDist1) {                                                   \\\n            minDist2 = minDist1; minDist1 = newD;                                \\\n        } else if (newD < minDist2) {                                            \\\n            minDist2 = newD;                                                     \\\n        }                                                                        \\\n    }                                                                            \\\n    return SATURATE(min(realDist(minDist2, points[0]) / 1.5, 1.0));                    \\\n}\n//end #define\nIMPL_WORLEY3(float, 3)\nIMPL_WORLEY3(vec2,  9)\n\n//TODO: More variants\n\n//Octave worley noise:\nfloat octaveWorley1Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley1, chanceOfCell COMMA, ); return outNoise; }\nfloat octaveWorley1Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley1, chanceOfCell COMMA, ); return outNoise; }\nfloat octaveWorley2Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley2, chanceOfCell COMMA, ); return outNoise; }\nfloat octaveWorley2Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley2, chanceOfCell COMMA, ); return outNoise; }\n\n//TODO: Profile worley noise compared to a more hard-coded implementation.",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}