{
    "Shader": {
        "info": {
            "date": "1525336268",
            "description": "Applying my 2D human silhouettes to billboards to put them in 3D space.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtfDN",
            "likes": 18,
            "name": "Humanoid Silhouettes 3D",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "billboard",
                "human",
                "figure",
                "people"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1337
        },
        "renderpass": [
            {
                "code": "// Cheap 2D humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nfloat RoundMax( float a, float b, float r )\n{\n    a += r; b += r;\n    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);\n    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r )\n{\n    return -RoundMax(-a,-b,r);\n}\n\n// Humanoid, feet placed at <0,0>, with height of ~1.8 units on y\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    //torso += .2*(1.-cos((uv.y-1.)*3.));\n    //torso = RoundMax( torso, abs(uv.y-1.1)-.4, .2*(uv.y-.7)/.8 );\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.2*Rand(2));\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    return max( f, -uv.y );\n}\n\n\n// return: distance to intersection, sdf value (negative = solid)\nvec2 StandIn( in vec3 footPos, in float seed, in vec3 rayStart, in vec3 rayDir )\n{\n    footPos -= rayStart; // do everything relative to rayStart\n    \n    // construct a vertical plane through footPos, facing the camera\n    vec3 n = normalize( vec3(1,0,1)*footPos );\n    float d = dot(n,footPos);\n    \n    float intersectionDistance = d/dot(n,rayDir);\n    \n    vec3 pos = rayDir*intersectionDistance;\n    pos -= footPos;\n    vec2 uv = vec2( dot(pos,normalize(cross(vec3(0,1,0),rayDir))), pos.y );\n    float sdfValue = Humanoid( uv, seed );\n    \n    return vec2( intersectionDistance, sdfValue );\n}\n\n\nstruct Camera {\n    vec3 pos;\n    vec3 target;\n    float zoom;\n};\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tCamera cam;\n    cam.pos = vec3(sin(iTime/4.)*4.,3.+1.*sin(iTime*1.618/5.),-6.+2.*cos(iTime*.618/2.));\n    cam.target = vec3(1,1,6.);//-4.*cos(iTime/4.));\n    cam.zoom = 1.7;\n    \n    vec3 ray = vec3( ( fragCoord-iResolution.xy*.5 ) / iResolution.y, cam.zoom );\n    \n    vec3 k = normalize( cam.target - cam.pos );\n    vec3 i = normalize( cross( vec3(0,1,0), k ) );\n    vec3 j = cross(k,i);\n    \n    ray = ray.x*i + ray.y*j + ray.z*k;\n\n    vec3 standIns[] = vec3[](\n        vec3(7,1,11),\n        vec3(6.5,1,10.8),\n        vec3(8,1,10),\n        vec3(-1.7,1,5),\n        vec3(-1.2,1,4.5),\n        vec3(-2,1,4),\n        vec3(-2.5,.5,3),\n        vec3(2,1,3),\n        vec3(1,1,2),\n        vec3(0,1,2),\n        vec3(4,0,3),\n        vec3(4,0,1.5),\n        vec3(3,0,2),\n        vec3(3,0,1),\n        vec3(1,0,.5),\n        vec3(0)\n    );\n    \n    fragColour = vec4(1);\n    for ( int i=0; i < standIns.length(); i++ )\n    {\n    \tvec2 hit = StandIn( standIns[i], float(i), cam.pos, ray );\n\t    float aa = hit.x*2./(iResolution.x*cam.zoom); // soften the edges proportional to pixel size\n        // this blend assumes we've depth-sorted the things, because I'm being lazy\n        fragColour = mix( fragColour, vec4(1.-exp2(-hit.x/12.)), smoothstep(aa,-aa,hit.y) );// .5-.5*(hit.y/(abs(hit.y)+.002)) );\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}