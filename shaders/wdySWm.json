{
    "Shader": {
        "info": {
            "date": "1574165922",
            "description": "An extension of my previous shader here: https://www.shadertoy.com/view/wsKSWD with a demonstration on how to make the pattern tile and let little cars run along it at no extra cost!",
            "flags": 32,
            "hasliked": 0,
            "id": "wdySWm",
            "likes": 19,
            "name": "Self-Avoiding Random Road",
            "published": 3,
            "tags": [
                "random",
                "curve",
                "saw",
                "walk",
                "avoid",
                "spacefill"
            ],
            "usePreview": 0,
            "username": "mathmasterzach",
            "viewed": 699
        },
        "renderpass": [
            {
                "code": "//Self-Avoiding Random Road\n//Author: @mathmasterzach\n//Feel free to ask any questions about the code or suggest improvements\n//Try changing the GRID_SIZE and GRID_ZOOM in the common tab\n\n//Big thanks to FabriceNeyret2 for suggestions, optimizations, and bug fixes!\n\nvoid mainImage(out vec4 O,in vec2 U){\n    vec2  R=iResolution.xy,\n          p=iTime*vec2(.5,.25)+GRID_SIZE*(GRID_ZOOM*(2.*U-R)/R.y+.5),\n    \t  q=2.*fract(2.*p)-1.,\n          s=sign(.5-fract(p)); \n    float e=4.*GRID_ZOOM*GRID_SIZE/R.y,\n          c=-1.,\n          m=.5*iTime;\n    \n    int flags=int(texelFetch(iChannel0,ivec2(mod(p,GRID_SIZE)),0).x),\n           gx=flags&(s.x>0.?1:4), \n           gy=flags&(s.y>0.?2:8);\n    if(gx>0) if(gy>0) c=1.-length(q+=s),m-=atan(q.y,q.x)/3.14;\n              else    c=q.y,m+=s.y*p.x; \n    else     if(gy>0) c=q.x,m-=s.x*p.y; \n              else    c=1.-length(q-=s),m+=atan(q.y,q.x)/3.14;\n \n    c=.5-abs(c);\n    c=max(.2-abs(c),min(c,.4-abs(2.*fract(2.*m)-1.)));\n    O=vec4(smoothstep(-e,e,c));\n}\n\n\n/*My original code without optimizations and suggestions and bug fixes\nbvec4 getFlags(vec2 p){\n    int a=int(texture(iChannel0,p).x);\n    return bvec4(a&1,a&2,a&4,a&8);\n}\n\nconst float PI=3.14;\n\n//Selector for what sdf to use for that part of the road\n#define d(a,b,g) if(g.x){if(g.y){c=1.-length(q+vec2(a,b));m-=atan(q.y+b,q.x+a)/PI;}else{c=q.y;m+=b*p.x;}}\\\n                    else{if(g.y){c=q.x;m-=a*p.y;}else{c=1.-length(q-vec2(a,b));m+=atan(q.y-b,q.x-a)/PI;}}\n\nvoid mainImage(out vec4 O,in vec2 U){\n    vec2 R=iResolution.xy,\n         p=iTime*vec2(.5,.25)+((GRID_ZOOM*GRID_SIZE*(2.*U-R)/R.y)+.5*GRID_SIZE),\n    \t q=2.*fract(2.*p)-1.;\n    ivec2 s=ivec2(2.*fract(p));\n    float c=-1.;\n    float m=.5*iTime;\n    bvec4 f=getFlags(floor(fract(p/GRID_SIZE)*GRID_SIZE)/R);\n    if(s==ivec2(0,0)){d( 1., 1.,f.xy);}\n    if(s==ivec2(1,0)){d(-1., 1.,f.zy);}\n    if(s==ivec2(1,1)){d(-1.,-1.,f.zw);}\n    if(s==ivec2(0,1)){d( 1.,-1.,f.xw);}\n    c=.5-abs(c);\n    c=max(.2-abs(c),min(c,.4-abs(2.*fract(2.*m)-1.)));\n    float e=4.*GRID_ZOOM*GRID_SIZE/R.y;\n    O=vec4(smoothstep(-e,e,c));\n}*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Maze Generation Tab\n//Uses the lowest 4 bits to represent the 4 directions\n#define P(x,y) ivec2(mod(vec2(x,y)+U,GRID_SIZE))\n#define g(x,y) texelFetch(iChannel0,P(x,y),0).r\n#define r(x,y) int(4.*hash13(vec3(P(x,y),iTime+iDate.a)))\n#define V(i) g((1-i&1)*(i-1),(i&1)*(i-2))\n#define W(i) int(r((1-i&1)*(i-1),(i&1)*(i-2)))\n\n//Thanks to Dave_Hoskins for the fantastic hash functions!\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n\tp3=fract(p3*.1031);\n    p3+=dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\nvec2 hash21(float p){\n\tvec3 p3=fract(vec3(p)*vec3(.1031,.1030,.0973));\n\tp3+=dot(p3,p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//Proper Looping Maze Generation (on a torus)\n//Based on an older project of mine, but now much faster and with guaranteed correctness\n//With optimizations and simplifications by FabriceNeyret2\nvoid mainImage(out vec4 O,in vec2 U){\n    if(iFrame==0||iMouse.z>0.){\n        O=.1*vec4(U-.5==ceil(hash21(iTime)*(GRID_SIZE-2.)));\n        return; \n    }\n    vec2 R=iResolution.xy;\n    float a=g(0,0);\n    ivec4 V=ivec4(g(-1, 0),\n                  g( 0,-1),\n                  g( 1, 0),\n                  g( 0, 1));\n    if(a==0.){\n        int i=(r(0,0)+2)%4;\n        if(V(i)>0.){a=float(1<<i);}\n    }else{\n        for(int i=0;i<4;i++){\n            if(V(i)==0.&&W(i)==i){a+=float(1<<i);}\n        }\n    }\n    O.x=a;\n}\n\n/*Original Code\nvoid mainImage(out vec4 O,vec2 U){\n    if(iFrame==0||iMouse.z>0.){\n        //This is a sneaky bit of code:\n        //.1 is small enough to be discarded by the floored bit checks\n        //But large enough to trigger the float compares\n        O=.1*vec4(U-.5==vec2(floor(1.+hash21(iTime)*(GRID_SIZE-2.))));\n    }else{\n        vec2 R=iResolution.xy;\n        float a=g(0,0),\n              b=g(1,0),\n              c=g(0,1),\n              d=g(-1,0),\n              e=g(0,-1);\n        if(a==0.){\n            int r=r(0,0);\n            if(r==0&&b>0.){a=4.;}\n            if(r==1&&c>0.){a=8.;}\n            if(r==2&&d>0.){a=1.;}\n            if(r==3&&e>0.){a=2.;}\n        }else{\n            if(b==0.&&r(1,0)==2){a+=4.;}\n            if(c==0.&&r(0,1)==3){a+=8.;}\n            if(d==0.&&r(-1,0)==0){a+=1.;}\n            if(e==0.&&r(0,-1)==1){a+=2.;}\n        }\n        O.x=a;\n    }\n}*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRID_SIZE 20.\n#define GRID_ZOOM .3",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}