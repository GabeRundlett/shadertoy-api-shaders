{
    "Shader": {
        "info": {
            "date": "1626716365",
            "description": "jujutsu kaisen",
            "flags": 0,
            "hasliked": 0,
            "id": "sllSWX",
            "likes": 3,
            "name": "Domain expansion:Unlimited Void ",
            "published": 3,
            "tags": [
                "cubemap",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 329
        },
        "renderpass": [
            {
                "code": "#define USE_MOUSE 0\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 tex(in vec2 p)\n{\n    vec2 prevP = p;\n    p+=iTime*0.15;\n    \n    float n = fbm(p*2.7)*0.6;\n    vec3 col = vec3(0.0,0.0,0.2)+n*0.7;\n    \n    p = prevP;\n    float d = length(p)-0.35;\n    \n    d = length(p)-0.35;\n    col = mix(col,vec3(1.2),S(abs(d*(n*3.0))-0.15,-0.3));\n    \n    d = length(p)-0.35;\n    col = mix(col,vec3(0.7),S(abs(d)-0.07,-0.2));\n    \n    p = prevP;\n    p.y=-abs(p.y);\n    col = mix(col,vec3(1,0.9,0.6),S(abs(d)-0.01+sin(p.y*3.0)*0.02,-0.05));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*30.0));\n    p.y=abs(p.y);\n    col = mix(col,vec3(1),S(abs(d)-0.005+sin(p.y*3.0)*0.005,-0.005));\n    \n    p = prevP;\n    p*=Rot(radians(iTime*25.0));\n    p.x+=iTime*0.1;\n    float n2 = fbm(p*4.0)*0.15;\n    p = prevP;\n    d = length(p)-0.16;\n    col = mix(col,vec3(1.0),S(d*n2*0.3,0.0));\n    \n    p = prevP;\n    d = length(p)-0.15;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    \n    p+=iTime*0.1;\n    \n    float n1 = noise2d(p*0.6)+fbm(p*5.5);\n    col = mix(col,col*vec3(2.7),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    p-=vec2(0.8);\n    n1 = noise2d(p*0.7)+fbm(p*7.5);\n    col = mix(col,col*vec3(2.85),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    p+=vec2(2.8);\n    n1 = noise2d(p*0.8)+fbm(p*9.5);\n    col = mix(col,col*vec3(2.675),S(n1,0.0));\n    col = mix(col,col*vec3(1.5),S(abs(n1)-0.01,0.0));\n    \n    p = prevP;\n    p*=20.0;\n    vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p);\n    float line = min(grid.x, grid.y);\n    float gridd = 1.0 - min(line, 1.0);\n    col = mix(col,col*vec3(0.675),S(gridd,0.0));\n\n    return col;\n}\n\n// cube mapping technique from @nimitz https://www.shadertoy.com/view/4sjXW1\nvec3 cubeproj(in vec3 p)\n{\n    vec3 x = tex(p.zy/p.x);\n    vec3 y = tex(p.xz/p.y);\n    vec3 z = tex(p.xy/p.z);\n    \n    //select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \n    vec3 ro = vec3(0, 0, -1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(sin(-iTime*.2)*0.3);\n    ro.xz *= Rot(-iTime*.3+1.0);\n    #endif\n   \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec3 col = cubeproj(rd);\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}