{
    "Shader": {
        "info": {
            "date": "1640247790",
            "description": "trying out rayleigh scattering from sebastian lagues videos\ni know all the code is messy but I am learning everything rn",
            "flags": 32,
            "hasliked": 0,
            "id": "NlGXRW",
            "likes": 5,
            "name": "worlds worst planet shader",
            "published": 3,
            "tags": [
                "light",
                "planet",
                "scattering"
            ],
            "usePreview": 0,
            "username": "incription",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "#define F(x,y) col = mix(x, col, smoothstep(0., fwidth(y), y))\n\n#define LIGHT_POS vec3(sin(iTime/2.)*10., -3., cos(iTime/2.)*10.)\n#define MOON_POS vec3(-sin(iTime/5.)*3., 0, -cos(iTime/5.)*3.)\n#define WAVES vec3(.7, .53, .34)\n\n#define KM 0.00007848061\n\n#define SCATTER_STR 3.\n#define MAX_STEPS 100\n#define MAX_DIST  100.\n#define SURF_DIST    .00001\n\n#define ATM_WIDTH    .07848061\n#define ATM_POINTS 10.\n#define OPT_POINTS 10.\n#define DENSITY_F  15.\n\nfloat scene(vec3 p) {\n    \n    vec3 pp = R(Q(vec3(0, -iTime / 2., 0)), p);\n    float ocean = length(pp) - .5;\n    float surface = sdFbm(pp + .5, length(pp)-(.5 + KM * 10.)).x;\n    surface = max(surface, length(p) - (.50 + KM));\n    float box = sdBox(p - vec3(.5, 0., 0.0), vec3(0.1));\n    float moon = length(p - MOON_POS) - .1;\n    float sun  = length(p - LIGHT_POS) - .05;\n    \n    return min(surface, min(sun, min(ocean, moon)));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = scene(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = scene(p);\n    vec2  e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 rd) {\n    vec3 l = normalize(LIGHT_POS - p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n        float d = rayMarch(p + n*SURF_DIST*2., l);\n    if(d<length(LIGHT_POS-p)) dif *= 0.1;\n    \n    vec3 direction_to_view = rd;\n    vec3 direction_to_light = normalize(LIGHT_POS - p);\n    vec3 light_reflection_unit_vector =\n                \t reflect(direction_to_light , n);\n    float specular_intensity = \n        1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 50.0);\n    return dif + .3 * specular_intensity;\n}\n\n\nfloat densityAtPoint(vec3 p) {\n    float height = length(p - vec3(0)) - .5;\n    float height01 = height / (ATM_WIDTH);\n    \n    float localDensity = exp(-height01 * DENSITY_F) * (1. - height01);\n    return localDensity;\n}\n\nfloat opticalDepth(vec3 ro, vec3 rd, float dO) {\n    vec3 point = ro; \n    float stepSize = dO / (OPT_POINTS - 1.);\n    float depth = 0.;\n    \n    for(float i = 0.; i < OPT_POINTS; i++) {\n        float density = densityAtPoint(point);\n        depth += density * stepSize;\n        point += rd * stepSize;\n    }\n    \n    return depth;\n}\n\nvec3 atmScattering(vec3 ro, vec3 rd, float dO, vec3 col) {\n    vec3 scatterPoint = ro;\n    float stepSize = dO / (ATM_POINTS - 1.);\n    vec3 light = vec3(0);\n    vec3 scatter = pow3(.4 / WAVES, 4.) * SCATTER_STR;\n    float viewRayOpticalDepth = 0.;\n    vec3 sunDir = normalize(LIGHT_POS);\n    \n    for(float i = 0.; i < ATM_POINTS; i++) {\n        vec2 sph = raySphere(scatterPoint, sunDir, vec3(0), .5 + ATM_WIDTH);\n        float sunRayLength = sph.y;\n        float sunRayOpticalDepth = opticalDepth(scatterPoint, sunDir, sunRayLength);\n        viewRayOpticalDepth = opticalDepth(scatterPoint, -rd, stepSize * i);\n        vec3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * scatter);\n        float density = densityAtPoint(scatterPoint);\n        \n        light += density * transmittance * scatter * stepSize;\n        scatterPoint += rd * stepSize;\n        \n    }\n    \n    float originalTransmittance = exp(-viewRayOpticalDepth);\n    return col * originalTransmittance + light;\n}\n\nvec3 planetCol(float l) {\n    if(l < SURF_DIST + .5) return vec3(0.071,0.141,0.431);\n    if(l < .5 + ATM_WIDTH) return vec3(0.192,0.749,0.231);\n    return vec3(0);\n}\n\nvec3 view(vec3 v)\n{\n    float t = 0.;\n    #if PRESET == 1\n    \tt = iTime * 1.0; // rotate\n        //t = iTime * 0.0;\n    #elif PRESET == 2\n    \t//t = iTime * 0.3; // shockwave\n    \t//t = iTime * 0.1; // blob\n        t = iTime * 0.0; // stationary\n    #elif PRESET == 3\n    \tt = iTime * 0.3;\n    #elif PRESET == 4\n    \tt = iTime * 1.0;\n    #endif\n    v = R(Q(vec3(0, t / 2., 0)), v);\n    return v;\n}\n\nfloat map(vec3 p)\n{\n    float r = length(p);\n    float planet = r - .5;\n    float background = 200. - r;\n    return min(planet, background);\n}\n\nvec3 flowColor(vec3 col)\n{\n    return vec3(col.z) / 2.;\n}\n\n\nvec3 renderSphere(vec2 fragCoord)\n{\n\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec3 p = view(vec3(0, 0, -9));\n    vec3 v = view(normalize(vec3(uv*.22, 1)));\n\n\tfor (int i=0 ; i<60 ; i++)\n        p += v * map(p);\n    \n    //vec3 col = vec3(length(T(p).xyz) + .5);\n    vec3 col = vec3(abs(min(0., T(p).w/1. - .3)));\n    if (length(p) > 1.5)\n        col = vec3(0);\n    col *= T(p).w * .5 + .9;\n    //col = vec3(polar(normalize(p)),0);\n    //col = topolar(polar(normalize(p)));\n    //col = normalize(p);\n    //col = texture(iChannel0, fragCoord/iResolution.xy).w;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy / iResolution.xy;\n         muv -= .5;\n         muv *= 50.;\n         \n   \n    \n    vec3 ro = texelFetch(iChannel2, ivec2(0, 0), 0).xyz;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 sph = raySphere(ro, rd, vec3(0), 100.);\n    vec3 col = vec3(0);\n    //sun\n    sph = raySphere(ro, rd, LIGHT_POS, .5);\n    if(sph != vec2(-1.)) col *= 1. - vec3(1., 1., 0.);\n    \n    sph = raySphere(ro, rd, vec3(0), .5 + ATM_WIDTH);\n    if(sph != vec2(-1.))\n    {\n        //set ray to surface\n        ro += rd * sph.x; }\n        \n        float d = rayMarch(ro, rd);\n        vec3 p = ro + rd * d;\n        \n        //sph = raySphere(ro, rd, vec3(0), .5);\n        //float dstPlanet = min(d, sph.x);\n        float dif = getLight(p, rd);\n        col += planetCol(length(p)) * dif;\n        col += renderSphere(fragCoord) * dif;\n        sph = raySphere(ro, rd, vec3(0), .5 + ATM_WIDTH);\n        float l = min(sph.y, d - sph.x);\n        //l -= d;\n        if(l > 0.) {\n            //vec3 pointInAtmosphere = ro + rd * l;\n            vec3 scatter = atmScattering(ro, rd, l - SURF_DIST * 2., col);\n            col += scatter;\n        }\n    \n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 raySphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 pow3(vec3 x, float p) {\n    return vec3(pow(x.x, p), pow(x.y, p), pow(x.z, p));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opCheapBend( in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nvec3 opRotate( in vec3 p, float theta ) {\n\n    float c = cos(theta);\n    float s = sin(theta);\n    return p * mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sdMandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n    // iterate\n    float di =  1.0;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<300; i++ )\n    {\n        if( m2>1024.0 ) { di=0.0; break; }\n\n\t\t// Z' -> 2·Z·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if( di>0.5 ) d=0.0;\n\t\n    return d;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat sph( ivec3 i, vec3 f, ivec3 c )\n{\n   // random radius at grid vertex i+c\n   float rad = 0.5*hash(vec3(i));\n   // distance to sphere at grid vertex i+c\n   return length(f-vec3(c)) - rad; \n}\n\nfloat sdBase( vec3 p )\n{\n   ivec3 i = ivec3(floor(p));\n    vec3 f =       fract(p);\n   // distance to the 8 corners spheres\n   return min(min(min(sph(i,f,ivec3(0,0,0)),\n                      sph(i,f,ivec3(0,0,1))),\n                  min(sph(i,f,ivec3(0,1,0)),\n                      sph(i,f,ivec3(0,1,1)))),\n              min(min(sph(i,f,ivec3(1,0,0)),\n                      sph(i,f,ivec3(1,0,1))),\n                  min(sph(i,f,ivec3(1,1,0)),\n                      sph(i,f,ivec3(1,1,1)))));\n}\n\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\n// 1..4\n#define PRESET 1\n\nconst float PI = 3.141592653589793;\n\n// converts point U (that sits on a sphere with arbitrary radius) to two polar angles uv for texture lookup\nvec2 polar(vec3 U)\n{\n    return fract(vec2(\n        atan(U.x, U.z) / 2.,\n        atan(U.y, length(U.xz))\n    ) / PI + .5);\n}\n\n// converts two polar angles uv from texture to point U on a sphere with radius 1\nvec3 topolar(vec2 uv)\n{\n    uv = vec2(2, 1) * (uv - .5) * PI;\n    return vec3(sin(uv.x), 0, cos(uv.x)) * cos(uv.y) + vec3(0, sin(uv.y), 0);\n}\n\n#define T(U) texture(iChannel0, polar(U))\n\n// convert v to a quaternion\n//  - direction of v: axis of rotation (ccw when viewed from above)\n//  - length of v: angle in radians\nvec4 Q(vec3 v)\n{\n    float a = length(v);\n    return vec4(v / (a + 1e-9) * sin(a * .5), cos(a * .5));\n}\n\n// quaternion rotation: rotates the direction v by the quaternion q\nvec3 R(vec4 q, vec3 v)\n{\n    vec3 t = 2. * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    if(iFrame == 0) p = vec3(0., 0., 2.);\n    fragColor = vec4(p, 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// https://www.shadertoy.com/view/4lGcWc\n// placeholder fluid sim curtesy of @pyBlob\n\n\n// calculate an arbitrary tangent vector at point U on the surface a sphere\nvec3 getv1(vec3 U)\n{\n    vec3 u = abs(U);\n    float m = max(u.x, max(u.y, u.z));\n    if (u.x == m)\n        return cross(U, vec3(0,1,0));\n    return cross(U, vec3(1,0,0));\n}\n\nvoid mainCubemap(out vec4 q, in vec2 _fc, in vec3 _ro, in vec3 U);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // simulate a cubemap by mapping planar coordinates uv to points U on surface of a sphere\n    mainCubemap(fragColor, fragCoord, vec3(0), topolar(fragCoord / iResolution.xy));\n    //fragColor.xyz = topolar(fragCoord / iResolution.xy);\n}\n\n// radius of the sphere [pixels]\nconst float RA = 1000.;\n// convert surface displacement v [pixels] (the direction is still the rotation axis)\n// 1. to v / RA [radians] (-> angular displacement)\n// 2. to quaternion Q(v / RA)\nvec4 QRA(vec3 v) { return Q(v / RA); }\n\n// read iChannel0\nvec4 t(vec3 U) {\n    return T(U);\n    //return vec4(vec3(1,0,0), T(U).w);\n}\n\nvoid mainCubemap(\n    // q.xyz contains the angular velocity of the fluid at the current position.\n    //   angular velocity is a vector with two components:\n    //     - its direction is the axis of rotation (like for rigidbodies)\n    //       when viewing this axis from above, rotation is always counter-clockwise\n    //     - its length is proportional to the surface speed [pixels/tick]\n    //   e.g. preset=2\n    //      blob has angular velocity vec3(0,10,0) -> points up (\"+y/up\" axis).\n    //      when looking at the \"+y/up\"-axis from above, the blob is at the bottom edge.\n    //      ccw rotation means the that blob will move in the \"-x/left\"-direction.\n    //   e.g. preset=1\n    //      the central ring has angular velocity vec3(0,10,0) -> points up (\"+y/up\" axis).\n    //      when looking at the \"+y/up\"-axis from above, the ring is all around the edge/equator.\n    //      ccw rotation means the whole ring rotates along this edge (like the blob from preset=2).\n    //   e.g. preset=3\n    //      blob has angular velocity vec3(10,0,0) -> points to right (\"+x/right\" axis).\n    //      when looking at the \"+x/right\"-axis from above, the blob is at the left edge.\n    //      ccw rotation means the that blob will move in the \"+y/up\"-direction.\n    // q.w contains the pressure.\n    out vec4 q,\n    // _fc is not used - fragCoord\n    in vec2 _fc,\n    // _ro is not used - 0\n    in vec3 _ro,\n    // point on the surface of the sphere.\n    // normalize(U) is the normal at that point and points out.\n    in vec3 U\n    )\n{\n    // tangent vector that is perpendicular to the normal direction U\n    vec3 _v1 = normalize(getv1(U));\n    // cotangent vector that is perpendicular to both _v1 and U\n    vec3 _v2 = normalize(cross(_v1, U));\n\n    // offsets for the particles (see shader from wyatt)\n    // these are quaternions (rotation instead of displacement)\n    vec4 va = QRA(_v1);\n    vec4 vb = QRA(_v2);\n    vec4 vc = QRA(-_v1);\n    vec4 vd = QRA(-_v2);\n    \n    // particle locations, uses R instead of + (see shader from wyatt)\n    vec3 O = U, A = R(va, U), B = R(vb, U), C = R(-vc, U), D = R(-vd, U);\n    // particle states (see shader from wyatt)\n    vec4 u = t(U), a = t(A), b = t(B), c = t(C), d = t(D);\n\n    vec4 p;\n    vec2 g = vec2(0);\n    \n    #define I 2\n    for (int i=0 ; i<I ; i++)\n    {\n        // move particles R(QRA(-angular_surface_velocity), position) instead of (pos + velocity)\n        U = R(QRA(-u.xyz), U);\n        A = R(QRA(-a.xyz), A);\n        B = R(QRA(-b.xyz), B);\n        C = R(QRA(-c.xyz), C);\n        D = R(QRA(-d.xyz), D);\n        \n        // U and A,B,C,D are close, so we can approximate surface distance by spatial 3d distance.\n        //   -> this is the same as in shader from wyatt\n        p += vec4(\n            // approximately arc length for small velocities\n            length(U-A),\n            length(U-B),\n            length(U-C),\n            length(U-D)\n        ) * RA - 1.;\n        \n        g += vec2(a.w-c.w, b.w-d.w);\n        \n        u = t(U); a = t(A); b = t(B); c = t(C); d = t(D);\n    }\n    \n    q = T(U);\n    vec4 N = (a+b+c+d) / 4.;\n    q = mix(q, N, vec4(0,0,0,1));\n    q.xyz -= (_v1 * g.x + _v2 * g.y) / 10. / float(I);\n    q.w += (p.x + p.y + p.z + p.w) / 10.;\n\n    q.w *= 0.9999;\n\n    //q.xyz = U;\n\n    if (iFrame < 1) q = vec4(0);\n \t#if PRESET == 1\n    \tif (iFrame < 14 && abs(O.y)<.1) q.xyzw = vec4(sin(atan(U.x,U.z)*8.)*.2,4,0,0);\n    #elif PRESET == 2\n    \tif (iFrame < 14 && -O.z>0.99) q.xyzw = vec4(0,10,0,0);\n    #elif PRESET == 3\n    \tif (iFrame < 14 && -O.z>0.999) q.xyzw = vec4(10,0,0,0);\n    #elif PRESET == 4\n    \tU = cos(U * 30.); if (iFrame < 14) q.xyzw = vec4(0, 0, 0, U.x*U.y*U.z);\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}