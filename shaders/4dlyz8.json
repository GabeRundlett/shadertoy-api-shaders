{
    "Shader": {
        "info": {
            "date": "1487030951",
            "description": "Trying to copy https://twitter.com/RealSardonicus/status/831219737661231104 for a bit of fun / figuring out how the font texture works :)\n\nWhat is Hookland? See https://twitter.com/HooklandGuide ",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlyz8",
            "likes": 5,
            "name": "Hookland brutalist logo",
            "published": 3,
            "tags": [
                "raymarching",
                "text"
            ],
            "usePreview": 0,
            "username": "psonice",
            "viewed": 745
        },
        "renderpass": [
            {
                "code": "\n\n//#define DEBUG\n#ifdef DEBUG\nint debugStep = 0;\nfloat debugValue = 0.0;\n#endif\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 100\n#define kEPSILON 0.001\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kFLOORMATERIAL 0\n#define kGLASSMATERIAL 1\n#define kMIRRORMATERIAL 2\n#define kGLOWMATERIAL 3\n#define kMATTEMATERIAL 4\n#define kTEXTMATERIAL 5\n#define kBKGMATERIAL 6\n\n#define kFLOORCOLOUR vec3(0.7, 0.65, 0.6)\n#define kGLASSCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR vec3(0.9)\n#define kMIRRORCOLOUR2 vec3(0.5)\n#define kGLOWCOLOUR vec3(0.5)\n\n#define kZENITHCOLOUR vec3(0.3, 0.7, 1.0)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.95)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// random value based on texture channel 2\nvec3 texrand(in vec2 n, in float mipLevel) {\n    return textureLod(iChannel2, n, mipLevel).xyz;\n}\n\n// returns a hash value for a fixed size cell\nfloat hashForCell(in vec3 pos, in float cellSize) {\n    float hash = nrand(floor(pos.xz / cellSize) + 68.0);\n    return hash;\n}\n\n// returns a random colour based on the cell hash\nvec3 randomColourForCell(in vec3 pos, in float cellSize) {\n\tfloat hash = hashForCell(pos, cellSize); \n    return vec3(\n        nrand(vec2(hash * 2.0, hash * 4.0)),\n        nrand(vec2(hash * 4.0, hash * 8.0)),\n        nrand(vec2(hash * 8.0, hash * 16.0))\n\t);\n\tvec3 c = vec3(hash, mod(hash + 0.15, 1.0), mod(hash + 0.3, 1.0)) * 0.75;\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\t\n// from https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1); \nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/*\n---- Scene rendering ----\n*/\n\nfloat textDist(in Ray ray, in Box box) {\n    // Hookland 8x1 16x16\n    vec2 coords[8];\n    \n    float d = boxDist(ray, box);\n    // pos in area\n    vec2 c = ray.origin.xy - (box.pos.xy - box.size.xy * 0.5);\n    c /= box.size.xy; // 0..1\n    c = 1.-c;\n    c.x *= 8.0; // 0..8x1\n    int l = int(floor(c.x));\n    c.x = (fract(c.x) - 0.5) * 0.7 + 0.5;\n    \n    if (l==0) {\n        c+= vec2(8,4);\n    } else if (l==1) {\n        c+= vec2(15,6);\n    } else if (l==2) {\n        c+= vec2(15,6);\n    } else if (l==3) {\n        c+= vec2(11,6);\n    } else if (l==4) {\n        c+= vec2(12,6);\n    } else if (l==5) {\n        c+= vec2(1,6);\n    } else if (l==6) {\n        c+= vec2(14,6);\n    } else {\n        c+= vec2(4,6);\n    }\n    c /= 16.0;\n    vec3 a = textureLod(iChannel0, c, 0.0).rgb;\n    float charD = textureLod(iChannel0, c, 0.0).a -0.55;\n    d = max(\n        d,\n        -charD\n    );\n    return d;\n}\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    float floorDist = abs(ray.origin.z);\n    Box textBox = Box(vec3(0,0,-0.5), vec3(20, 4, 2), 0.0);\n    float boxD = boxDist(ray, Box(vec3(0,0.05,-0.5), vec3(18.5, 2.2, 2.0), 0.0));\n    float textD = textDist(ray, textBox);\n    \n    float text = intersectOp(boxD, textD);\n    result.d = unionOp(floorDist, text);\n    \n    if (result.d == text) {\n        result.material = kTEXTMATERIAL;\n    } else {\n        result.material = kBKGMATERIAL;\n    }\n    \n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n    for (int i=0; i<5; i++) {\n \t\tray.origin += n * d*0.5;\n \t\td = sceneDist(ray).d;\n \t\tn = normal(ray);\n    }\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    return vec3(1);\n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texturev;\n    float x = smoothstep(0.0,1.0,abs(ray.dir.y));\n   // base = mix(vec3(0.05, 0.1, 0.2), vec3(0.0), x);\n    \n    if (ray.dir.y >= 0.0) {\n        // sky: fake as hell clouds\n    \tbase = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n        texturev = vec3(1);\n        float cloudFactor = 0.0;\n        \n        vec2 coord = ray.dir.xz / 8.0;\n        float scale = 1.0;\n        for (int i=0; i<4; i++) {\n            float offset = iTime * 0.03 / scale;\n            cloudFactor += texrand(coord + vec2(0, -offset), 3.0).r * scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n        cloudFactor /= 1.5;\n        vec3 cloud = mix(vec3(0.4), vec3(1), cloudFactor);\n        base = mix(base, cloud, cloudFactor * ray.dir.y * ray.dir.y);\n        \n    } else {\n        // ground: fake as hell desert\n        texturev = kNADIRCOLOUR * 0.5;\n        vec2 floorCoord = floorPos(ray, -30.0) + vec2(0, iTime * 100.0);\n        texturev *= (sin(floorCoord.x * .183 + floorCoord.y * 0.183 + sin(floorCoord.y * 0.3) * 0.5) \n                    + sin(floorCoord.x * .15 + floorCoord.y * 0.22 + sin(floorCoord.x * 0.26) * 0.5))\n            * 0.25 + 0.5;\n\t\tbase = mix(kHORIZONCOLOUR, kNADIRCOLOUR + texturev, x);\n        \n    }\n    \n    \n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    vec3 origin = ray.origin;\n    float o = 0.0;\n    ray.dir = n;\n    float x = eps*4.0;\n    origin += n * x;\n    for (float i=1.0; i<7.0; i++) {\n    \tray.origin = origin + ray.dir * x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0) / x / i;\n        \n        x *= 4.0;\n    }\n \treturn 1.0 - o;\n}\n\nvec3 highlight(in Ray ray, in vec3 n) {\n    // sun\n\tvec3 sunDir = normalize(vec3(1,0.3,1));\n\tfloat sunDist = distance(sunDir, ray.dir)-0.00;\n\treturn mix(vec3(10,10,8), vec3(0), smoothstep(0.0, 0.2, sunDist));\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(0); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    //float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        //glow += result.material == kGLOWMATERIAL ? \n        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01\n        //    : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = (inside ? abs(result.d) : result.d) * 1.;\n        ray.origin += ray.dir * stepDistance;\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\n//debugColour = n;\n//break;\n#endif\n            \n                float o = occlusion(ray, n);\n            if (result.material == kTEXTMATERIAL) {\n                \n                vec3 coords = ray.origin * 0.1;\n    \t\t\tn = abs(n);// - 0.5;\n    \t\t\t//n *= 2.0;\n    \t\t\t//n += 0.5;\n    \t\t\t//n = clamp(n, 0., 1.);\n                //n *= n;\n                vec3 c = (texture(iChannel1, coords.xy).rgb * n.z)\n        \t\t\t+ (texture(iChannel1, coords.xz).rgb * n.y)\n        \t\t\t+ (texture(iChannel1, coords.yz).rgb * n.x);\n                \n                \n             \tcolour.rgb += c * o;\n                    //texture(iChannel1, ray.origin.xy*.1).rgb * o;\n                impact *= 0.0;\n                break;\n            }\n            if (result.material == kBKGMATERIAL) {\n             \tcolour.rgb += texture(iChannel2, ray.origin.xy*.1).rgb*.5 * o;\n                impact *= 0.0;\n                break;\n            }\n            if ( result.material == kFLOORMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.3);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if ( result.material == kMATTEMATERIAL ) {\n                // ray hit floor\n                \n                // Add some noise to the normal, since this is pretending to be grit...\n                vec3 randomNoise = texrand(n.xz * 0.5 + 0.5, 0.0);\n                randomNoise.xz = randomNoise.xz * 2. - 1.;\n               // n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.1);\n                \n                // Colour is just grey with crappy fake lighting...\n                float o = occlusion(ray, n);\n                colour += vec3(1) * o * impact;\n                impact *= 0.;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kMIRRORMATERIAL) {\n                \n                // handle interior glass / other intersecion\n                if (inside) {\n                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \t\t\t\tglassStartPos = ray.origin;\n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n                }\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                colour += highlight(ray, n);\n                impact *= kMIRRORCOLOUR;\n                float o = occlusion(ray, n);\n                impact *= o;\n#ifdef DEBUG\ndebugColour = vec3(o);\nbreak;\n#endif\n                \n            } else {\n                // glass material\n            \n                if (inside) {\n                \t// refract glass -> air\n                \tray.dir = refract(ray.dir, -n, 1.0/kREFRACT);\n                    \n                    // Find out how much to tint (how far through the glass did we go?)\n                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);\n    \n                    // mix in the colour\n                \timpact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);\n                    \n#ifdef DEBUG\ndebugValue += glassTravelDist / 2.0;\n#endif\n      \n                \n              \t} else {\n               \t\t// refract air -> glass\n                \tglassStartPos = ray.origin;\n                    \n              \t  \t// Mix the reflection in, according to the fresnel term\n                \tfloat fresnel = fresnelTerm(ray, n, 1.0);\n                    fresnel = fresnel;\n    \t\t\t\t/*\n                    colour = mix(\n                    \tcolour, \n                    \ttexture(iChannel1, reflect(ray.dir, n)), \n                    \tvec4(fresnel) * impact);\n*/\n                    colour = mix(\n                        colour,\n                        backgroundColour(ray, 0.0),\n                        vec3(fresnel) * impact);\n                \tcolour += n.x * 0.1;//highlight(ray, n);\n                    impact *= 1.0 - fresnel;\n    \t\t\t\n                \t// refract the ray\n            \t\tray.dir = refract(ray.dir, n, kREFRACT);\n                    \n#ifdef DEBUG\n//debugValue += 0.5;\n#endif\n                }\n            \n            \t// Step 2x epsilon into object along normal to ensure we're beyond the surface\n                ray.origin += (inside ? n : -n) * eps * 2.0;\n                \n                // Flip in/out status\n                inside = !inside;\n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n   // colour += texture(iChannel0, ray.dir) * impact;\n    ray.origin = startpoint;\n    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;\n    \n#ifdef DEBUG\n//debugColour.rgb = ray.dir;\n//debugColour = vec3(float(debugStep)/2.0);\ncolour = debugColour;\n#endif\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nvec3 camPath(in float time) {\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * kPI * 2.0 + kPI;\n    \n    vec3 camPos = vec3(sin(time * 0.3) * 2.0, sin(time * 0.13) * 2.0 + 4.5, time);\n\t\n    //R(camPos.xz, time + mouse.x);\n    //R(camPos.zy, sin(time) * kPI * 0.1 + 0.2);\n    \n    return camPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime;\n    vec3 camPos = vec3(cos(iTime*0.2) * 10.0, sin(iTime*0.17) * 3., -5);//camPath(camTime);\n    vec3 camTarget = vec3(cos(iTime*0.2) * 7., 0,0);//camPath(camTime + 1.0);\n    Camera cam = setupCam(camPos, camTarget, 0.3, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}