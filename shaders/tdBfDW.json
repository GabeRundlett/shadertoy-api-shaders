{
    "Shader": {
        "info": {
            "date": "1590347836",
            "description": "Turn off the lights.",
            "flags": 8,
            "hasliked": 0,
            "id": "tdBfDW",
            "likes": 22,
            "name": "The neon demo",
            "published": 3,
            "tags": [
                "neon"
            ],
            "usePreview": 1,
            "username": "friol",
            "viewed": 1482
        },
        "renderpass": [
            {
                "code": "\n// \n// friol 2o2o\n// a night-ish trip into flashing neon lights\n// music is generated\n// sdf functions by iq\n// pModPolar by mercury\n// beware of nicolas winding refn inner jokes\n// 25.05.2020: the bassline was going nuts after the first measures. Should be fixed.\n// 25.05.2020: same thing for the saw synth\n//\n\n\nconst int sdfIterationsAmount=256;\nfloat baryyy=0.0;\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions, int mode) {\n\tfloat angle = TAU/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = mode==0?length(p):length(cos(p.x)*sin(p.y));\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\treturn c;\n}\n\n// noby\nfloat spacehash(vec3 p3)\n{\n    p3 = fract(p3*.1031);\n\tp3 += dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// starts at 48.0, ends at 64.0\nvec3 SDFNeonGeometry(vec3 r) // triangles, quads, etc., water below\n{\n    float t=10000.0;\n    const float attenuation=15.2;\n\n    vec3 cellId=floor(vec3(r.x-3.0,0.0,r.z-3.0)/12.0);\n    float hsh=spacehash(cellId);\n    \n    vec3 c=vec3(6.0,0.0,6.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n    //r=r-vec3(0.0,.0,0.0);\n    r=rotz(r,iTime*2.0*(-0.5+hsh));\n    \n    pModPolar(r.xy,abs(cellId.x)+3.0,0);\n    \n    float neonBar=sdRoundedCylinder(r-vec3(0.8,0.0,0.0),0.012,0.035,1.4);\n    //float neonBar=sdTorus(r-vec3(0.0,.4,0.0),vec2(1.1,0.05));\n    t=min(t,neonBar);\n    \n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\n// triangle scene with rainbow neon - 64.0 - 80.0\nvec3 SDFNeonRainbowTriangles(vec3 r)\n{\n    float t=10000.0;\n    const float attenuation=150.0;\n\n    baryyy=atan(r.z,r.y);\n    \n    vec3 cellId=floor(vec3(r.x-6.0,0.0,r.z-6.0)/12.0);\n    float hsh=spacehash(cellId);\n    \n    vec3 c=vec3(0.0,0.0,12.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n    r=r-vec3(0.0,1.0,0.0);\n    r=rotz(r,3.141592/2.0+(iTime*(hsh-0.5)));\n    \n    pModPolar(r.xy,3.0,0);\n    \n    float neonBar=sdRoundedCylinder(r-vec3(0.8,0.0,0.0),0.012,0.035,1.5);\n    t=min(t,neonBar);\n    \n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\n// a shitload of circles\nvec3 SDFNeonCircles(vec3 r)\n{\n    const float attenuation=350.2;\n\n    vec3 cellId=floor(vec3(r.x-3.0,0.0,r.z-3.0)/12.0);\n    float hsh=spacehash(cellId);\n    \n    vec3 c=vec3(0.0,0.0,6.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n    r=rotz(r,iTime*(-0.5+hsh));\n    \n    pModPolar(r.xy,17.0,2);\n    \n    // change 0.8 to 0.1 for squares\n    float neonBar=sdRoundedCylinder(r-vec3(0.8,.0,0.0),0.012,0.035,1.4);\n    \n    float t=min(10000.0,neonBar);\n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\n// flying birds/waveforms scene\nvec3 SDFNeon(vec3 r)\n{\n    float t=10000.0;\n    float attenuation=85.0-80.0*sin(iTime*13.0);\n\n    vec3 cellId=floor(vec3((r.x-2.0)*8.0,0.0,r.z-4.0)/8.0);\n    float hsh=spacehash(cellId);\n\n    if (iTime<16.0) r.y*=0.5;\n    vec3 c=vec3((iTime<16.0)?1.0:8.0,0.0,16.0);\n    r = mod(r+0.5*c,c)-0.5*c;\n\n    float period=(iTime<16.0)?(hsh+iTime)*6.5:iTime*2.0;\n    vec3 r1=r-vec3(0.0,0.0,1.0);\n    r1=rotz(r,3.141592/2.0+sin(period));\n    vec3 r2=r-vec3(0.0,0.0,-1.0);\n    r2=rotz(r,3.141592/2.0-sin(period));\n    \n    // birds/waves\n\n    float neonBar=sdRoundedCylinder(r1-vec3(0.0,.5,0.0),0.012,0.035,.5);\n    t=min(t,neonBar);\n    float neonBar2=sdRoundedCylinder(r2-vec3(0.0,-.5,0.0),0.012,0.035,.5);\n    t=min(t,neonBar2);\n    \n    float glow = 1. / ( 1.0 + pow(abs(t*attenuation),.63));\n    return vec3(t,2.0,glow);\n}\n\nvec3 SDFMainScene(vec3 r)\n{\n    float t=10000.0;\n\n    if (iTime>80.0) return vec3(-1.0);\n    \n    float basePlane=(iTime>48.0)?sdPlane(r-vec3(0.0,-0.1*sin(r.x*10.0)*0.1*cos(r.z*10.0),0.0),vec4(0.0,1.0,0.0,1.0)):sdPlane(r-vec3(0.0,-0.9,0.0),vec4(0.0,1.0,0.0,1.0));\n    t=min(t,basePlane);\n    \n    // for birds scene\n    float sphere=((iTime>=8.0)&&(iTime<48.0))?sdSphere(r-vec3(0.0,(iTime<16.0)?1.0:0.0,.0+(iTime*8.0)+((iTime-22.0)/2.0)),1.0):10000.0;\n    t=min(t,sphere);\n\n    if (t==basePlane) return vec3(t,1.0,0.0);\n    if (t==sphere) return vec3(t,2.0,0.0);\n    \n    return vec3(-1.0);\n}\n\n//\n//\n//\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float fogAmount = 1.0 - exp(-dist * 0.035);\n    return mix(c, fxcol, fogAmount);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFMainScene(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float glow=0.0;\n    float t=0.0;\n    \n    // neon bars\n    vec3 curPoint = rayOrigin+rayDir ;\n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        vec3 sdfRes = (iTime<48.0)?SDFNeon(curPoint):(iTime<64.0)?SDFNeonGeometry(curPoint):(iTime<80.0)?SDFNeonRainbowTriangles(curPoint):SDFNeonCircles(curPoint);\n        float d=distance(curPoint,rayOrigin);\n        glow+=sdfRes[2]/((d*0.08+1.0)*(d*0.08+1.0));\n        curPoint+=rayDir*sdfRes[0];\n    }\n\n    // main scene part\n    vec3 res;\n    curPoint = rayOrigin+rayDir ;\n    for (int i=0;i<sdfIterationsAmount;i++)\n    {\n        res = SDFMainScene(curPoint);\n        if (res[0] < (0.00001*t))\n        {\n    \t\treturn vec4(t,res[1],glow,0.0);\n        }\n        \n        curPoint+=rayDir*res[0];\n        t+=res[0];\n    }\n    \n    return vec4(-1.0,-1.0,glow,0.0);\n}\n\nvec3 reflekt(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col=vec3(0.);\n    vec4 rayHit = rayMarch(rayOrigin, rayDir);\n\n    float glowIntensity=rayHit[2];\n    if ((iTime>=64.0)&&(glowIntensity!=0.0))\n    {\n\t\tvec3 barColor = palette(1.0-baryyy, \n                           vec3(0.5),\n                           vec3(0.5),\n                          vec3(0.5),\n                          vec3(0.,0.3+iTime*0.5,0.7));        \n\t\tcol+= vec3(glowIntensity)*barColor;\n    }\n    else if (glowIntensity!=0.0) // blue-purple neon \n    {\n        vec3 barColor=mix(vec3(.3,.1,.3),vec3(.1,.1,.3),1.0-abs(sin(iTime)));\n\t\tcol+= vec3(glowIntensity)*barColor;\n    }\n    \n    //if (iTime<2.0) col.xyz*=(iTime/2.0);\n    //col=pow(col,vec3(0.78));\n    return col;\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 fogColor=vec3(0.02,0.1,0.2);\n    vec3 col=fogColor;\n    vec3 L=normalize(vec3(0.0,.7,-5.0));\n    \n    vec4 rayHit = rayMarch(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n\n    vec3 N=calcNormal(pHit);\n    float dotprod=max(dot(N,L),0.0);\n\n    vec3 refcol=reflekt(pHit,normalize(reflect(rayDir,N)));\n    \n    if (mat==1.0) // floor\n    {\n        col=mix(col,refcol,0.5)*0.1;\n        col=fog(col,distance(rayOrigin,pHit),fogColor);\n    }\n    else if (mat==2.0)\n    {\n        col=refcol.xyz*pow(dotprod,256.0)*8.0;\n    }\n\n    float glowIntensity=rayHit[2];\n    if ((iTime>64.0)&&(glowIntensity!=0.0)) // rainbow neon bar\n    {\n        //vec3 pBar=rayOrigin+rayDir*rayHit[3];\n\t\tvec3 barColor = palette((baryyy), \n                           vec3(0.5),\n                           vec3(0.5),\n                          vec3(0.5),\n                          vec3(0.,0.3+iTime*0.5,0.7));        \n\t\tcol+= vec3(glowIntensity)*barColor;\n        //col=fog(col,distance(rayOrigin,pBar),fogColor);\n    }\n    else if (glowIntensity!=0.0) // neon bar\n    {\n        vec3 barColor=(iTime<48.0)?mix(vec3(.5,.3,.5),vec3(.3,.3,.5),1.0-abs(sin(iTime))):mix(vec3(.3,.1,.3),vec3(.1,.1,.3),1.0-abs(sin(iTime)));\n\t\tcol+= 1.4*vec3(glowIntensity)*barColor;\n    }\n    \n    col=pow(col,vec3(0.78));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime*8.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    if (iTime<16.0) // intro, waveforms\n    {\n        camPos=vec3(8.0*sin(2.0),0.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,1.0+myTime);\n    }\n    else if ((iTime>=16.0)&&(iTime<24.0)) // sphere entering\n    {\n        camPos=vec3(0.0,2.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,1.0+myTime);\n    }\n    else if ((iTime>=24.0)&&(iTime<32.0)) // sphere from above\n    {\n        camPos=vec3(8.0*sin(-2.0),8.0*sin(2.0)-1.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,1.0+myTime);\n    }\n    else if ((iTime>=32.0)&&(iTime<48.0)) // rotate\n    {\n        camPos=vec3(0.0,8.0*sin((iTime-32.0)/8.0)+1.0,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,3.0+myTime);\n    }\n    else if ((iTime>=48.0)&&(iTime<52.0)) // center square\n    {\n        camPos=vec3(0.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(0.0,0.0,3.0+myTime*1.52);\n    }\n    else if ((iTime>=52.0)&&(iTime<56.0)) // center triangle\n    {\n        camPos=vec3(6.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(6.0,0.0,3.0+myTime*1.52);\n    }\n    else if ((iTime>=56.0)&&(iTime<60.0)) // center pentagon\n    {\n        camPos=vec3(-12.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(-12.0,0.0,3.0+myTime*1.52);\n    }\n    else if ((iTime>=60.0)&&(iTime<64.0)) // center square\n    {\n        camPos=vec3(0.0,0.0,-5.5+myTime*1.52);\n        camTarget=vec3(0.0,0.0,3.0+myTime*1.52);\n    }\n    else\n    {\n        camPos=vec3(0.0,2.5,-5.5+myTime);\n        camTarget=vec3(0.0,0.0,myTime);\n    }\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4((render(camPos, rayDir,uv,fragCoord).xyz),1.0);\n\n    if (iTime<2.0) finalCol.xyz*=(iTime/2.0);\n    if (iTime>=88.0) finalCol.xyz*=max((4.0-(iTime-88.0))/4.0,0.0);\n    fragColor=finalCol;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.1415926535\n#define TAU 6.2831853071\n\n// rainbow function\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos(TAU*(c*t+d));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n//\n// hand-written music.\n//\n\n// notes\nconst float nC  = 261.63;\nconst float nCs  = 277.18;\nconst float nD  = 293.66;\nconst float nDs  = 311.13;\nconst float nE  = 329.63;\nconst float nF  = 349.23;\nconst float nFs = 369.99;\nconst float nG  = 392.0;\nconst float nGs  = 415.30;\nconst float nA  = 440.0;\nconst float nAs  = 466.16;\nconst float nB  = 493.88;\n\n//\n// and's reverb\n//\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, tt);\n}\n\nfloat sine(float x)\n{\n    return sin(TAU * x);\n}\n\nvec2 sine(vec2 v) { return vec2(sine(v.x), sine(v.y)); }\n\nvec2 andBell(float t,float freq,float panning)\n{\n    vec2 w = vec2(sine(t * freq) * exp(-t * 2.5));\n    \n    vec2 r = lpnoise(t,  100.0)\n        + lpnoise(t,  550.0) * 0.2\n        + lpnoise(t, 1050.0) * 0.1 * exp(-t * 5.0);\n\n    w += sine(t * freq + r * 0.1) * exp(-t * 2.0);\n    w -= sine(t * freq          ) * exp(-t * 2.0);\n\n    w *= 1.0 - exp(-t * 800.0);\n\n    return vec2(w.x*panning,w.y*(1.0-panning))*0.25;\n}\n\n//\n// kick\n//\n\nfloat modfix(float phase) {\n    return mod(phase, TAU);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(TAU * t * freq));\n}\n\nfloat kick(float t) \n{\n    return clamp(1.25 * sinf(t, 90. * exp(-t * 5.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\n\n//\n// 303-ish bass\n//\n\nfloat sinharm(float freq,float t,int nHarmonics)\n{\n    float s0 = sin(TAU*freq*t);\n    for(int i = 0; i < nHarmonics; ++i)\n    {\n        float harm = float(1 + i);\n        s0 += sin(TAU*(0.61 + freq * harm)*t) / harm;\n    }\n\n    return s0;\n}\n\n//\n// saw\n//\n\nfloat sawpitch(float p) {\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nfloat saw(float phase) \n{\n    float s = 0.0;\n    for (int k=1; k < 17; k++) {\n        s += (sin(TAU*float(k)*phase) / float(k));\n    }\n    return -(1.0/PI)*s;\n}\n\nfloat sawSynth(float t,vec3 notes)\n{\n    // good triads: 0,2,7 0,3,7 0,3,2\n    float s = 0.0;\n    float semitones[3];\n    semitones[0] = notes.x;\n    semitones[1] = notes.y;\n    semitones[2] = notes.z;\n    \n    for (int i=0;i<3;i++) \n    {\n        float f = sawpitch(semitones[i]);\n        \n        for (int u=0;u<3;u++) {\n            float fu = float(u);\n            float new_f = f + fu*sin(fu);\n    \t\ts += saw(t * new_f)*0.11111111111111;\n        }\n    }\n    \n    return s;    \n}\n\nvec2 reverbChannelS(float t,vec3 notes) \n{\n    return vec2(sawSynth(t,notes)*0.8);\n}\n\n// hi-hat\n\nvec2 hihat(float time,float panning,float triplets)\n{\n    float tb = mod(time * 2.0, 8.);\n    float hihat=(fract(cos(time * 234.523) * 7862134.) * exp(mod(tb, 1. / triplets) / 2.0 * -120.)*(fract(tb) + .2));\n    return vec2(hihat*triplets,hihat*(1.0-triplets))*0.05;\n}\n\n//\n//\n//\n\n#define bassSequence1(starttime,endtime) if ((time>=starttime)&&(time<endtime)) finalSound+=sinharm((float[](nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0,nA/8.0,0.0)[int(mod(time,16.0)*8.0) % 16]), mod(time-starttime,16.0),16+int(8.0*sin(time)))*0.02;\n#define bassSequence2(starttime,endtime) if ((time>=starttime)&&(time<endtime)) finalSound+=sinharm((float[](nE/8.0,0.0,nE/4.0,0.0,nE/8.0,0.0,nE/4.0,0.0,nE/8.0,0.0,nE/4.0,0.0,nE/8.0,0.0,nE/4.0,0.0)[int(mod(time,16.0)*8.0) % 16]), mod(time-starttime,16.0),16+int(8.0*sin(time)))*0.02;\n#define bassSequence3(starttime,endtime) if ((time>=starttime)&&(time<endtime)) finalSound+=sinharm((float[](nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0,nF/8.0,0.0)[int(mod(time,16.0)*8.0) % 16]), mod(time-starttime,16.0),16+int(8.0*sin(time)))*0.02;\n\n#define vibratoSynth1(starttime,endtime,notes) if ((time>=starttime)&&(time<endtime)) finalSound+=reverbChannelS(mod(time-starttime,16.0),notes)*(0.1*abs(sin((time-starttime)*36.0)))*(0.05+sin((time-starttime)/2.5));\n\n#define hihatsss(starttime,endtime,panning,triplets) if ((time>=starttime)&&(time<endtime)) finalSound+=hihat(time,panning,triplets);\n\n#define bells(starttime,pitch,panning,volume) if (time>=starttime) finalSound+=andBell(time-starttime,pitch,panning)*volume;\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 finalSound=vec2(0.0);\n    \n    //time+=48.0;\n    \n    vec4 snotes[40];\n    snotes[0]=vec4(48.0,nA*2.0,0.75,0.8);\n\n    snotes[24]=vec4(48.0,nA*1.0,0.50,0.3);\n    snotes[25]=vec4(48.25,nE*2.0,0.50,0.3);\n    snotes[26]=vec4(48.50,nA*4.0,0.50,0.2);\n    snotes[27]=vec4(48.75,nE*8.0,0.50,0.2);\n    \n    snotes[1]=vec4(49.0,nA*2.0,0.55,0.25);\n    snotes[2]=vec4(50.0,nA*2.0,0.35,0.05);\n    \n    snotes[3]=vec4(51.0,nE*2.0,0.75,0.8);\n    snotes[4]=vec4(52.0,nF*2.0,0.25,0.8);\n\n    snotes[28]=vec4(52.0,nA*1.0,0.50,0.3);\n    snotes[29]=vec4(52.25,nF*2.0,0.50,0.3);\n    snotes[30]=vec4(52.50,nC*4.0,0.50,0.2);\n    snotes[31]=vec4(52.75,nG*8.0,0.50,0.2);\n    \n    \n    snotes[5]=vec4(56.0,nC*4.0,0.75,0.8);\n\n    snotes[32]=vec4(56.0,nA*1.0,0.50,0.3);\n    snotes[33]=vec4(56.25,nG*2.0,0.50,0.3);\n    snotes[34]=vec4(56.50,nD*4.0,0.50,0.2);\n    snotes[35]=vec4(56.75,nA*8.0,0.50,0.2);\n    \n    snotes[6]=vec4(59.0,nE*4.0,0.25,0.8);\n    snotes[7]=vec4(60.0,nF*2.0,0.50,0.8);\n\n    snotes[36]=vec4(60.0,nA*1.0,0.50,0.3);\n    snotes[37]=vec4(60.25,nF*2.0,0.50,0.3);\n    snotes[38]=vec4(60.50,nC*4.0,0.50,0.2);\n    snotes[39]=vec4(60.75,nG*8.0,0.50,0.2);\n    \n    // 4 final arpeggios\n    snotes[8]=vec4(64.0,nA*1.0,0.50,0.3);\n    snotes[9]=vec4(64.25,nE*2.0,0.50,0.3);\n    snotes[10]=vec4(64.50,nA*4.0,0.50,0.2);\n    snotes[11]=vec4(64.75,nE*8.0,0.50,0.2);\n\n    snotes[12]=vec4(68.0,nA*1.0,0.50,0.3);\n    snotes[13]=vec4(68.25,nF*2.0,0.50,0.3);\n    snotes[14]=vec4(68.50,nC*4.0,0.50,0.2);\n    snotes[15]=vec4(68.75,nG*8.0,0.50,0.2);\n\n    snotes[16]=vec4(72.0,nA*1.0,0.50,0.3);\n    snotes[17]=vec4(72.25,nG*2.0,0.50,0.3);\n    snotes[18]=vec4(72.50,nD*4.0,0.50,0.2);\n    snotes[19]=vec4(72.75,nA*8.0,0.50,0.2);\n\n    snotes[20]=vec4(76.0,nA*1.0,0.50,0.3);\n    snotes[21]=vec4(76.25,nE*2.0,0.50,0.3);\n    snotes[22]=vec4(76.50,nA*4.0,0.50,0.2);\n    snotes[23]=vec4(76.75,nA*8.0,0.50,0.2);\n    \n    for (int i=0;i<40;i++)\n    {\n    \tbells(snotes[i].x,snotes[i].y,snotes[i].z,snotes[i].w);\n    }\n    \n    vibratoSynth1(16.0,16.0+8.0,vec3(0.0,3.0,7.0));\n    vibratoSynth1(16.0+8.0,16.0+16.0,vec3(0.0,3.0,10.0));\n    vibratoSynth1(16.0+16.0,16.0+16.0+8.0,vec3(0.0,3.0,2.0));\n    vibratoSynth1(16.0+24.0,16.0+31.0,vec3(0.0,3.0,7.0));\n\n    //finalSound += reverbChannelK(mod(time,0.5))*2.5;\n    finalSound += kick(mod(time,0.5))*2.5*0.12;\n    \n\thihatsss(8.0,16.0,0.50,2.0);\n\thihatsss(16.0,48.0,0.50+0.10*sin(time),2.0);\n\t//hihatsss(48.0,64.0,0.50,4.0+sin(time)*2.0); // hihat roll\n\thihatsss(48.0,64.0,0.50,4.0);\n\thihatsss(64.0,64.0+16.0,0.50,4.0);\n    \n    bassSequence1(8.0,8.0+8.0);\n    bassSequence1(16.0,16.0+8.0);\n    bassSequence2(16.0+8.0,16.0+8.0+8.0);\n    bassSequence3(16.0+16.0,16.0+16.0+8.0);\n    bassSequence1(16.0+24.0,16.0+24.0+8.0);\n\n    // bell apart\n    bassSequence1(48.0,48.0+4.0);\n    bassSequence3(52.0,52.0+4.0);\n    bassSequence1(56.0,56.0+4.0);\n    bassSequence3(60.0,60.0+4.0);\n    bassSequence1(64.0,80.0);\n    \n    if (time<8.0) finalSound*=(time)/8.0; // initial fadein\n    if (time>=88.0) finalSound*=max((4.0-(time-88.0))/4.0,0.0); // fadeout\n    return finalSound*2.2;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}