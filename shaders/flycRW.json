{
    "Shader": {
        "info": {
            "date": "1660986138",
            "description": "A simple ray-tracing doodle I did as a coding test.",
            "flags": 0,
            "hasliked": 0,
            "id": "flycRW",
            "likes": 29,
            "name": "Imp in glass",
            "published": 3,
            "tags": [
                "raytracing",
                "sphere",
                "glass"
            ],
            "usePreview": 0,
            "username": "Maurogik",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "const float kPI = 3.14159265359;\n\n// WebGL sometimes likes to force unroll things, even if the iteration count is very large\n// This stops it from unrolling. (Can massively reduce shader compilation times)\n#define NON_CONST_ZERO min(0, iFrame)\n\nconst int kMatSky = -1;\nconst int kMatSphereAirToGlass = 0;\nconst int kMatSphereGlassToAir = 1;\nconst int kMatTable = 2;\nconst int kMatImpBody = 3;\nconst int kMatImpEye = 4;\nconst int kMatImpGlow = 5;\n\nconst vec3 kSpherePosWs = vec3(0.0, 1.0, 0.0);\nconst float kFocalLengthWs = 1.0;\n\n// Path tracer rays\nconst int kMaxRayCount = 10;\nstruct Ray\n{\n    vec3 originWs;\n    vec3 directionWs;\n    float weight;\n};\n\nconst float kGlassIoR = 1.5;\nconst float kAirIoR = 1.0;\n\n// Returns outside and inside intersections\nvec2 rayVsSphere(vec3 ray_origin, vec3 ray_dir, vec3 sphere_pos, float sphere_radius)\n{\n    vec3 e = ray_origin - sphere_pos;\n    vec3 d = ray_dir;\n    \n    float a = 1.0;\n    float b = 2.0 * dot(d,e);\n    float c = dot(e,e) - sphere_radius*sphere_radius;\n    \n    float det = b*b - 4.0*a*c;\n    \n    if (det <= 0.0) {\n        return vec2(0.0);\n    }\n    \n    return vec2(-b - sqrt(det), -b + sqrt(det)) / (2.0 * a) ;\n}\n\nfloat rayVsTable(vec3 rayOriginWs, vec3 rayDirWs)\n{\n    if (rayDirWs.y >= 0.0 || rayOriginWs.y <= 0.0) {\n        return 0.0;\n    }\n    float distWs = (0.0 - rayOriginWs.y) / rayDirWs.y;\n    \n    vec3 hitWs = rayOriginWs + rayDirWs * distWs;\n    if(max(abs(hitWs.x), abs(hitWs.z)) < 4.0)\n    {   \n        return distWs;\n    }\n            \n    return 0.0;\n}\n\nfloat fSphere(vec3 vecToCentreWs, float radiusWs)\n{\n    return length(vecToCentreWs) - radiusWs;\n}\n\nfloat fVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 rotate2D(vec2 vec, float rotRadians)\n{\n    float cosR = cos(rotRadians);\n    float sinR = sin(rotRadians);\n    return vec2(cosR * vec.x + sinR * vec.y,\n                -sinR * vec.x + cosR * vec.y);\n}\n\nfloat fSDF(vec3 positionWs, out int material)\n{\n    // SDF for a little Dreams imp thingy.\n    \n    float minDistWs = 999999.0;\n    \n    vec3 impCentreWs = vec3(0.0, 0.9 - sin(iTime * 1.0) * 0.035, 0.0);\n    \n    // Eyes\n    vec3 mirrorPositionWs = positionWs;\n    mirrorPositionWs.x = abs(mirrorPositionWs.x);\n    vec3 eyeOffsetWs = vec3(0.12, 0.05, -0.18);\n    float squint = 0.5 + 0.5*sin(iTime * 4.0);\n    float eyeDistWs = fSphere(mirrorPositionWs - (impCentreWs + eyeOffsetWs)\n        + squint * vec3(0.0, 0.005, 0.0), 0.05);\n        \n    // Cutout bottom to make smilling eyes\n    eyeOffsetWs += vec3(0.0, -0.08, -0.05);\n    float antiEyeDistWs = fSphere(mirrorPositionWs - (impCentreWs + eyeOffsetWs), 0.08);\n    eyeDistWs = max(eyeDistWs, -antiEyeDistWs);\n    \n    if(eyeDistWs < minDistWs)\n    {\n        material = kMatImpEye;\n        minDistWs = eyeDistWs;\n    }\n    \n    // Mouth\n    float mouthDistWs = fSphere(positionWs - (impCentreWs + vec3(0.0, -0.01, -0.18)), 0.1);\n    float breath = 0.5 + 0.5 * sin(iTime * 0.6 * kPI);\n    float antiMouthDistWs = fSphere(positionWs - (impCentreWs + vec3(0.0, 0.04 + breath * 0.015, -0.25)), 0.11);\n    mouthDistWs = max(mouthDistWs, -antiMouthDistWs);\n    if(mouthDistWs < minDistWs)\n    {\n        minDistWs = mouthDistWs;\n        material = kMatImpEye;\n    }\n    \n    // Body\n    vec3 vecToImp = impCentreWs - positionWs;\n    float bodyDistWs = fSphere(vecToImp, 0.25);\n    vec3 disp = sin(vecToImp * 30.0 + vec3(0.0, 1.0, 1.0) * iTime);\n    bodyDistWs -= min(min(mouthDistWs, eyeDistWs) * 6.0, 1.0) * 0.025 * \n        disp.x * disp.y * disp.z;\n    \n    // Tail ? (The thing at the top)\n    vec3 tailStartWs = impCentreWs + vec3(0.0, 0.25, 0.0);\n    float tailStartToEnd = (positionWs.y - tailStartWs.y)/0.25;\n    float tailRadiusWs = 0.04 - tailStartToEnd * 0.03;\n    \n    //tailStartWs.x += (1.0 + breath) * tailStartToEnd * tailStartToEnd * 0.05;\n    vec3 vecToTailWs = positionWs - tailStartWs;\n    float wag = 0.8 * sin(iTime * 2.0);\n    vecToTailWs.xy = rotate2D(vecToTailWs.xy, vecToTailWs.y * wag);\n    bodyDistWs = min(bodyDistWs, fVerticalCapsule(vecToTailWs, 0.25, tailRadiusWs));\n    \n    if(bodyDistWs < minDistWs)\n    {\n        material = kMatImpBody;\n        minDistWs = bodyDistWs;\n    }\n    \n    // Glowing bit at the top\n    vec3 tailToGlowWs = vec3(0.0, 0.25, 0.0);\n    tailToGlowWs.xy = rotate2D(tailToGlowWs.xy, -0.25 * wag);\n    vec3 glowPosWs = tailStartWs + tailToGlowWs;\n    float glowDistWs = fSphere(positionWs - glowPosWs, 0.03);\n    if(glowDistWs < minDistWs)\n    {\n        minDistWs = glowDistWs;\n        material = kMatImpGlow;\n    }    \n    \n    return minDistWs;\n}\n\n// From https://iquilezles.org/articles/normalsSDF\nvec3 getNormalWS(vec3 p, float dt)\n{\n    int material;\n    vec3 normalWS = vec3(0.0);\n    for( int i = NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        float dist = fSDF(p + e * dt, material);\n        normalWS += e*dist;\n    }\n    return normalize(normalWS);\n}\n\nvec3 getBackgroundLight(vec3 directionWs, float blur)\n{\n    vec3 colourSrgb = textureLod(iChannel0, directionWs, blur * 10.0).rgb;\n    return pow(colourSrgb, vec3(2.2));\n}\n\n// Ambient diffuse approximation, use the cubemap at the highest mip\n// Also sneak in some table lighting\nvec3 getDiffuseLight(vec3 directionWs)\n{\n    vec3 light = pow(textureLod(iChannel0, directionWs, 10.0).rgb, vec3(2.2));\n    \n    // Do approximated table diffuse lighting\n    vec3 upLight = pow(textureLod(iChannel0, directionWs, 10.0).rgb, vec3(2.2));\n    vec3 tableAlbedo = pow(textureLod(iChannel1, vec2(0.5), 10.0).rgb, vec3(2.2));\n    light = mix(light, tableAlbedo * upLight, clamp(-directionWs.y + 0.4, 0.0, 1.0));\n    \n    return light;\n}\n\n// Add a ray to the ray list, unless we're out of rays, in which case return the background light\nvec3 addRayOrGetBackground(vec3 originWs, vec3 directionWs, float weight,\n    inout Ray[kMaxRayCount] rays, inout int rayCount)\n{\n    if(rayCount < kMaxRayCount)\n    {\n        rays[rayCount].directionWs = directionWs;\n        rays[rayCount].originWs = originWs;         \n        rays[rayCount].weight = weight;\n        ++rayCount;\n        return vec3(0.0);\n    }\n    else\n    {\n        return abs(weight) * getBackgroundLight(directionWs, 0.0);\n    }\n}\n\nconst float kSurfaceSkipDtWs = 0.0025;\n\n// Do lighting or add new rays to trace (for bounce reflection/refraction)\nvec3 processRay(vec3 rayOriginWs, vec3 rayDirectionWs, float rayLengthWs, float totalRayLengthWs,\n    int material, float incomingWeight,\n    inout Ray[kMaxRayCount] rays, inout int rayCount)\n{\n    vec3 hitPosWs = rayOriginWs + rayDirectionWs * rayLengthWs;\n    float fresnelF0 = 0.04;\n    if(material == kMatSky)\n    {\n        return incomingWeight * getBackgroundLight(rayDirectionWs, 0.0);\n    }\n    else\n    {\n        vec3 normalWs, albedo;\n        if(material == kMatSphereAirToGlass) \n        {\n            normalWs = normalize(hitPosWs - kSpherePosWs);   \n        }\n        else if(material == kMatSphereGlassToAir) \n        {\n            normalWs = -normalize(hitPosWs - kSpherePosWs);   \n        }\n        else if(material == kMatTable)\n        {\n            // Compute (approximated) pixel derivative\n            float uvDt = 1.0/iResolution.x;\n            float rayConeWidthAtUnitLength = uvDt / kFocalLengthWs;\n            \n            float rayConeProjectedSizeWs = rayConeWidthAtUnitLength * totalRayLengthWs\n                / max(0.0001, -rayDirectionWs.y);\n            \n            vec2 der = vec2(rayConeProjectedSizeWs) / 4.0;\n            vec3 texColourSrgb = textureGrad(iChannel1, hitPosWs.xz / 4.0, der, der).rgb;\n            albedo = pow(texColourSrgb, vec3(2.2));\n            normalWs = normalize(vec3(0.0, 1.0, 0.0) + 0.2 * vec3(1.0, 0.0, 1.0) * (albedo.g - 0.075));\n        }\n        else if(material >= kMatImpBody) // All imp materials\n        {\n            normalWs = getNormalWS(hitPosWs, 0.01);\n            albedo = (material == kMatImpBody) ? vec3(1.0, 0.025, 0.15) : vec3(0.0);\n            albedo = (material == kMatImpEye) ? vec3(0.0) : albedo;\n            albedo = (material == kMatImpGlow) ? vec3(1.0) : albedo;\n        }\n        \n        float NoR = max(-dot(normalWs, rayDirectionWs), 0.0);\n        float fresnelReflectance = fresnelF0 + (1.0 - fresnelF0) * pow(1.0 - NoR, 5.0);\n        \n        vec3 reflectedDirWs = reflect(rayDirectionWs, normalWs);        \n        vec3 lighting = vec3(0.0);\n        vec3 diffuseLight = (material == kMatImpGlow) ? vec3(2.) : getDiffuseLight(normalWs);\n        \n        if(material == kMatSphereAirToGlass || material == kMatSphereGlassToAir) \n        { \n            float eta = (material == kMatSphereAirToGlass) ? kAirIoR / kGlassIoR : kGlassIoR / kAirIoR;\n            vec3 refractedRayDirWs = refract(rayDirectionWs, normalWs, eta);\n            // refract returns vec3(0.0) if internal reflection\n            // in this case, there is no refraction, only reflection\n            if(dot(refractedRayDirWs, refractedRayDirWs) > 0.01)\n            {\n                vec3 refractedOriginWs = hitPosWs + refractedRayDirWs * kSurfaceSkipDtWs; \n                // Try to add a refraction ray\n                float newWeight = incomingWeight * (1.0 - fresnelReflectance);\n                newWeight = (material == kMatSphereAirToGlass) ? -newWeight : newWeight;\n                lighting += addRayOrGetBackground(refractedOriginWs, refractedRayDirWs,\n                    newWeight, rays, rayCount);\n            }\n            else\n            {\n                // total internal reflection, no refracted ray\n                // the reflected ray (added below) is all we need\n                fresnelReflectance = 1.0;\n            }\n        }\n        else if(material >= kMatTable) // All opaque materials\n        {\n            if(material == kMatTable)\n            {\n                // Do FAKE diffuse caustics from the sphere\n                // Tracing diffuse rays sampled from a cosine distribution would be better\n                // but without temporal accumulation, that's just too noisy.\n                vec3 vecToSphereWs  = kSpherePosWs - hitPosWs;\n                float sqSphereDistWs = dot(vecToSphereWs, vecToSphereWs);\n                vec3 dirToSphereWs = normalize(vecToSphereWs);\n                \n                vec3 causticsLight = getBackgroundLight(dirToSphereWs, 0.15 + sqSphereDistWs * 0.15);\n                causticsLight *= causticsLight * 2.0;\n                \n                // Fake caustic occlusion from the imp\n                float impShadow = smoothstep(0.02, 0.2, 1.0 - dirToSphereWs.y);\n                causticsLight *= impShadow;\n                \n                diffuseLight += causticsLight * pow(max(0.0, dirToSphereWs.y), 4.0);\n            }\n            \n            lighting += incomingWeight * (1.0 - fresnelReflectance) * albedo.rgb * diffuseLight;\n        }\n        \n        vec3 reflectedRayOriginWs = hitPosWs + reflectedDirWs * kSurfaceSkipDtWs;\n        \n        // Try to add a reflection ray\n        float newWeight = incomingWeight * fresnelReflectance;\n        newWeight = (material == kMatSphereGlassToAir) ? -newWeight : newWeight;\n        lighting += addRayOrGetBackground(reflectedRayOriginWs, reflectedDirWs,\n               newWeight, rays, rayCount);\n        \n        \n        return lighting;\n    }\n}\n\n// March to find the intersection with the imp\nfloat marchSdfDepth(vec3 rayOriginWs, vec3 rayDirectionWs, out int outMaterial)\n{    \n    float rayLengthWs = 0.0;\n    \n    for(int i = NON_CONST_ZERO; i < 32; ++i)\n    {\n        vec3 positionWs = rayOriginWs + rayDirectionWs * rayLengthWs;\n        float distWs = fSDF(positionWs, outMaterial);\n        rayLengthWs += distWs;\n        \n        if(abs(distWs) < 0.001)\n        {\n            return rayLengthWs;\n        }\n    }\n    \n    outMaterial = kMatSky;\n    return 999999.0;\n}\n\n// Trace the sphere and table\nfloat traceSceneDepth(vec3 rayOriginWs, vec3 rayDirectionWs, out int outMaterial)\n{\n    vec2 sphereDistsWs = rayVsSphere(rayOriginWs, rayDirectionWs, kSpherePosWs, 1.0);\n    \n    outMaterial = kMatSky;\n    \n    if(sphereDistsWs.x > 0.0)\n    {\n        outMaterial = kMatSphereAirToGlass;\n        return sphereDistsWs.x;\n    }\n    else if(sphereDistsWs.y > 0.0)\n    {\n        outMaterial = kMatSphereGlassToAir;\n        return sphereDistsWs.y;\n    } \n    else\n    {\n        float tableDistWs = rayVsTable(rayOriginWs, rayDirectionWs);\n        if(tableDistWs > 0.0)\n        {\n            outMaterial = kMatTable;\n            return tableDistWs;   \n        }\n    }\n}\n\n// The main ray tracing\nvec3 traceLighting(vec3 rayOriginWs, vec3 rayDirectionWs)\n{\n    Ray rays[kMaxRayCount];\n    int rayCount = 1;\n    rays[0].originWs = rayOriginWs;\n    rays[0].directionWs = rayDirectionWs;\n    rays[0].weight = 1.0;\n    \n    vec3 lighting = vec3(0.0);\n    \n    float totalRayLengthWs = 0.0;\n    \n    for(int rayIndex = NON_CONST_ZERO; rayIndex < rayCount; ++rayIndex)\n    {\n        // Trace sphere & table\n        int material;\n        float rayLengthWs = traceSceneDepth(rays[rayIndex].originWs, rays[rayIndex].directionWs, \n            /*out*/material);    \n        \n        // March sdf inside sphere\n        int sdfMaterial;\n        float sdfRayLengthWs = marchSdfDepth(rays[rayIndex].originWs,rays[rayIndex].directionWs, \n            /*out*/sdfMaterial);            \n        if(rayLengthWs == 0.0 || rayLengthWs > sdfRayLengthWs)\n        {\n            material = sdfMaterial;\n            rayLengthWs = sdfRayLengthWs;\n        }\n        \n        totalRayLengthWs += rayLengthWs;\n        lighting += processRay(rays[rayIndex].originWs,rays[rayIndex].directionWs, rayLengthWs,\n            totalRayLengthWs, material, abs(rays[rayIndex].weight), rays, rayCount);\n    }    \n    \n    return lighting;\n}\n\n// Basic x/(1+x) tomemapping\nvec3 reinhard(vec3 value)\n{\n    return value / (vec3(1.0) + value);\n}\n\n// A twist on the plain reinhard tonemapping that doesn't suck out the light as much\nvec3 poweredReinhard(vec3 value)\n{\n    float maxRange = 1.0;\n    vec3 power = vec3(2.0);\n    return pow(reinhard(pow(value / maxRange, power)), 1.0 / power) * maxRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseSnorm = ((iMouse.xy / iResolution.xy) * 2.0 - vec2(1.0, 1.0));\n    if(iMouse.xy == vec2(0)) // Centre the camera by default\n    {\n        mouseSnorm *= 0.0;\n    }\n    \n    vec3 cameraPosWs = vec3(0.0, 0.25, -4.0);\n    vec3 cameraTargetWs = vec3(0.0, 1.0, 0.0);\n    \n    // Mouse rotation\n    cameraPosWs.yz = rotate2D(cameraPosWs.yz, -(1.0 + mouseSnorm.y) * kPI * 0.15);\n    cameraPosWs.xz = rotate2D(cameraPosWs.xz, mouseSnorm.x * kPI * 0.5);\n\n    // Screen\n    vec3 cameraForwardWs = normalize(cameraTargetWs - cameraPosWs);\n    vec3 cameraRightWs = normalize(cross(vec3(0.0, 1.0, 0.0), cameraForwardWs));\n    vec3 cameraUpWs = cross(cameraForwardWs, cameraRightWs);\n\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 posNdc = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n    vec3 posOnCameraPlaneWs = cameraPosWs + kFocalLengthWs * cameraForwardWs\n        + cameraRightWs * posNdc.x + cameraUpWs * posNdc.y * aspectRatio;\n    \n    vec3 rayDirectionWs = normalize(posOnCameraPlaneWs - cameraPosWs);\n    vec3 rayOriginWs = cameraPosWs;\n    \n    vec3 lighting = traceLighting(rayOriginWs, rayDirectionWs);\n    \n    //Tonemap\n    vec3 colour = poweredReinhard(2.5 * lighting);\n    \n    // Shadertoy needs to output an srgb colour\n    fragColor.rgb = pow(colour, vec3(1.0/2.2));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}