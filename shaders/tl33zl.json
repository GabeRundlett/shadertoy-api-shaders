{
    "Shader": {
        "info": {
            "date": "1577217923",
            "description": "Tribute to MC Escher: http://ajo.tabletoptelephone.com/~hopspage/EschrDys.html\nEheeey, merry xmas, check other shaders for links, too lazy to write them now.",
            "flags": 0,
            "hasliked": 0,
            "id": "tl33zl",
            "likes": 6,
            "name": "[twitch] Day 6 of MDTMJVM",
            "published": 3,
            "tags": [
                "potato",
                "twitch",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 431
        },
        "renderpass": [
            {
                "code": "\n#define iTime (iTime + 15. + 50.*(iMouse.x/iResolution.x))\n#define dmin(a, b) (a.x < b.x) ? a : b\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*0.3 + up*uv.y*0.3;\n}\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define pi acos(-1.)\n\n\nfloat sdHalo(vec3 p, float r, float w) {\n  \n  //float d = max(length(p) - r, -(length(p) - r)*0.9 );  \n  float d = length(p) - r;\n  d = max(d, -p.x - w);\n  d = max(d, p.x - w);\n  d = max(d, -(length(p) - r*0.99));\n  return d;\n  \n} \n#define tau (2.*pi)\n\nfloat r11(float x) {return fract(sin(x*1412.512)*12412.1215);}\n\nvec2 sdSphereyThingie(vec3 p, float r, float copies, float iteration){  \n  vec2 d = vec2(10e3); // d.x = distance, d.y = id\n  \n  //float t = mod(iTime, 1. + iteration/0.4);\n  float t = iTime*0.12 + iteration*0.04;\n  float tId = floor(t/ 0.8);\n  float tFr = fract(t/ 0.8);\n  \n  tFr = smoothstep(0.,1.,tFr); \n  tFr = smoothstep(0.,1.,tFr);\n  tFr = smoothstep(0.,1.,tFr);\n  tFr = smoothstep(0.,1.,tFr);\n  tFr = smoothstep(0.,1.,tFr);\n  tFr = smoothstep(0.,1.,tFr);\n\n  float rA = r11(tId);\n  float rB = r11(tId*1.1);\n\n  float phase = 0.;\n  float phases = 5.;\n  \n  if (rA < 0.53) {\n    if (rB < 1./phases ) {\n      phase = 1.;\n      //tFr = pow(tFr, 1.2);\n      p.xz *= rot(tau*tFr);\n      \n    } else if (rB < 2./phases ) {\n      \n      phase = 2.;\n      \n    } else if (rB < 3./phases ) {\n      \n      phase = 3.;\n      \n    } else if (rB < 4./phases ) {\n      \n      phase = 4.;\n      \n    }\n    else {\n      phase = 5.;\n      \n    }\n    \n  }\n  \n  //phase = 0.;\n  float rotations = 3.;\n  \n  p.yx *= rot(.25*pi);\n  for (float i = 0.; i < rotations; i++) {\n    p.xz *= rot(tau*i/rotations);  \n    \n    if (phase == 5.) {\n      p.xy *= rot(tFr*tau);\n      p.zy *= rot(-sin(tFr*tau)*0.1);\n      //p.z += sin(tFr*tau*4.)*0.01;\n      //p.x += sin(tFr*tau*40.)*0.01;\n    }\n    if (phase == 1.) {\n      p.zy *= rot(-sin(tFr*tau)*0.1);\n      //p.z += sin(tFr*tau*4.)*0.01;\n      p.x += sin(tFr*tau*40.)*0.01;\n    }\n    if (phase == 2.) {\n      p.xy *= rot(tFr*tau);\n    }\n      if (phase == 3.) {\n          p.zy *= rot(-sin(tFr*tau)*0.5);\n          p.xy *= rot(sin(tFr*tau)*0.5);\n      }\n      if (phase == 4.) {\n      \tp -= normalize(p)*sin(tFr*tau)*0.04;\n      }\n    //p.xz *= rot(0.1);\n    \n    p = abs(p);\n  }\n  for (float j = 0.; j < rotations; j++) {\n    p.xy *= rot(0.04  +tau*j/rotations);  \n    //p.xz *= rot(0.1);\n    \n    p = abs(p);\n  }\n  \n  d = min(d, sdHalo(p, r, 0.01));\n  \n  return d;\n}\n\nvec2 sdMainSphereThingie(vec3 p, float r){\n  vec2 d = vec2(10e3);\n  \n  float rotationsXZ = 1.;\n  float rotationsYZ = 1.;\n  \n  float copies = 4.;\n  float distBetween = 1.6;\n  \n  vec3 dir = normalize(p);\n\n  \n  vec3 z = p;\n  \n  \n  for (float i = 0.; i < copies ; i++) {\n    \n      d = dmin(d, sdSphereyThingie(p, 1.5 - ( i/copies) *distBetween, copies, i ));\n  }\n  \n    \n  \n  d.x *= 1.;\n  d.y = 1.;\n  return d;\n}\n\n#define dmin(a, b) (a.x < b.x) ? a : b // takes 2 vec2, does a minimum of them \nvec2 map(vec3 p){ // gets distance to everything\n  vec2 d = vec2(10e3); // d.x = distance, d.y = id\n  \n  d = dmin(d, sdMainSphereThingie(p, 1.));\n  \n  d = dmin(d, vec2(-(length(p) - 8.),2.));\n  //d.x = length(p) - 1.;\n  \n  return d;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001, 0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n}\n\n\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    //return j;\n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec3 p){\n\n    float n = 0.;\n    //p *= 0.1;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*1.4);\n    \n    float z = valueNoise(p*f*q*2.);\n    float i = valueNoise(p*f*q*4.5);\n    \n    n += f*1.8 + q*0.5 + z*0. + i*0.;\n    \n\treturn n;\n}\n\n\nvec3 r13(float t) {\n  float r = fract(sin(t*554.1515)*124124.123);\n  return vec3(\n    r,\n    fract(r*124.425),\n    fract(r*424.525)\n  );  \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float s = 1.0;\n    float t = 0.5;\n    for( float i=0.; i<100.; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        s = min( s, 0.5+0.5*h/(w*t) );\n        if( s<0.0 ) break;\n        t += h;\n    }\n    s = max(s,0.0);\n    return s*s*(3.0-2.0*s); // smoothstep\n}\n\nvec3 glow = vec3(0);\n\n#define rotSpeed 0.1\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n  \n  float rThis = r11(floor(iTime*0.6));\n  float rNext = r11(ceil(iTime*0.6));\n  float zoom = 6. + pow(mix(rThis,rNext, smoothstep(0.,1.,fract(iTime*0.6))),2.);\n    \n    \n  vec3 ro = vec3(sin(iTime*rotSpeed)*zoom,0,cos(iTime*rotSpeed) * zoom);\n  vec3 lookAt = vec3(0);\n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  \n  vec3 p = ro; \n  float t = 0.;\n  \n  for (int i = 0; i < 60; i++) {\n      vec2 d = map(p);\n      \n      glow += exp(-length(p)*6.5 + r11(iTime + uv.x + uv.y)*sin(iTime)*0.4);\n      \n      if (d.x < 0.001) {\n        vec3 r = r13(floor(iTime/ 1.))*10.;\n        //vec3 dirLight = normalize(r + vec3(sin(iTime)*10., 0.,0.))*10.;\n        vec3 dirLight = normalize(-p);\n        vec3 n = getNormal(p);\n        vec3 h = normalize(dirLight + -rd);\n          \n\n        float fres = pow(1.-max(dot(-rd, n),0.), 5.);\n        n += fbm(p*50.)*0.4;\n        \n        float diff = max(dot(dirLight, n), 0.);\n        float spec = max(dot(h, n), 0.);\n        \n          \n        col += fres*spec + diff;\n          \n          if (d.y == 2.) {\n              col = vec3(0.04);\n              //col *= shad;\n          } else {\n              //col *= 0.2;\n              col = pow(col, vec3(1.6));\n              //col -= softshadow( p, dirLight,0.01, 100., 0.1/240. );\n              //col *= shad*0.2;\n          } \n        //col = vec3(1);\n        \n        //col += diff * vec3(0.2)*fres;\n        //col = ec3(1);\n          break;\n      }\n      \n      if (d.x > 10.) {\n        //col = vec3(0.01);\n          // background\n          vec3 l = rd;\n\t\t//col += 1.;\n          //col += drawBackground(rd);\n          \n        break;\n      }\n      \n      t += d.x;\n      p = ro + rd * t;\n  }\n  \n  col -= pow(length(uv)*0.6, 5.);\n    \n  col += glow*3.;\n  col *= 0.2;\n  //col *= 0.2;\n  col = pow(col, vec3(0.45));\n  \n  return vec4(col, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    fragColor = render(uv);\n\n    //fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return max(vec3(.0), min(vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e) ) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}