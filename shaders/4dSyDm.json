{
    "Shader": {
        "info": {
            "date": "1492768243",
            "description": "yet another shader inspired by an album cover, this time it's [url=http://bit.ly/2owVY2y]The Raven That Refused to Sing (And Other Stories)[/url] by Steven Wilson\n\nmusic: [url=https://youtu.be/n8sLcvWG1M4]the last song of the album[/url]",
            "flags": 64,
            "hasliked": 0,
            "id": "4dSyDm",
            "likes": 13,
            "name": "The Raven That Refused To Sing",
            "published": 3,
            "tags": [
                "2d",
                "stars",
                "moon",
                "albumcover",
                "stevenwilson",
                "theraventhatrefusedtosing"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 921
        },
        "renderpass": [
            {
                "code": "#define saturate(x) clamp(x, 0., 1.)\n\n// width of the blur when rendering SDFs\nfloat _blur = .01;\n\n// distortion matrix for FBM function\nconst mat2 mat = mat2(.8, -.6, .6, .8);\n\n// simple 2D hash\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(.009123898, .00231233))) * 1e5);\n}\n\n// 2D noise (lerp between grid point noise values\nfloat noise(vec2 uv) {\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        hash(fuv + vec2(0, 0)),\n        hash(fuv + vec2(0, 1)),\n        hash(fuv + vec2(1, 0)),\n        hash(fuv + vec2(1, 1))\n    );\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n}\n\n// 2D fractional Brownian motion\nfloat fbm(vec2 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        uv *= mat;\n        f += noise((uv += 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// function that tries going up and down with a tangent of 1,\n// but the gaps and the bumps grow exponentially\nfloat logSaw(float x) {\n    return (abs(fract(log(x + 1.) * 4.) - .5) - .25) * (x + 1.) / 4.;\n}\n\n// rectangle distance function (used for the nose\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// render an array of shaking distorted concentric circles\nfloat shakyCircles(vec2 uv, float offset, float time) {\n    float l = length(uv);\n    uv += (vec2(fbm(vec2(uv.x * .5, time)), fbm(vec2(uv.y * .5, time + 10.))) - .5) * 1. * (.05 + l);\n    l = length(uv);\n    float d = abs(logSaw(l + offset * l));\n    d += (l - .75) * .15;\n    \n    return smoothstep(_blur, -_blur, d);\n}\n\n// layer shaky circles on top of each other\nfloat hole(vec2 uv, float time) {\n    float f = 0.;\n    for (float i = .0; i <= .5; i += .25) {\n    \tf += shakyCircles(uv, i, time * 2. + i * 55.) / 3.;\n    }\n    return saturate(1.- f);\n}\n\n// same as above, only this time we use rounded rectangles, and only render the bottom half\nfloat shakyHalfCircles(vec2 uv, float offset, float time) {\n    float l = sdRect(uv, vec2(.05, .3));\n    uv += (vec2(fbm(vec2(uv.x * .5, time)), fbm(vec2(uv.y * .5, time + 10.))) - .5) * 1. * (.05 + l);\n    l = sdRect(uv, vec2(.05, .3));\n    float d = abs(logSaw(l + offset * l));\n    d += ((abs(l - .3) - .3) + smoothstep(-.6, 2., uv.y)) * .15;\n    \n    return smoothstep(_blur, -_blur, d);\n}\n\n// render a nose, just like a hole, but layering t\nfloat nose(vec2 uv, float time) {\n    float f = 0.;\n    for (float i = .0; i <= .5; i += .25) {\n    \tf += shakyHalfCircles(uv, i, time * 2. + i * 55.) / 3.;\n    }\n    return saturate(1.- f);\n}\n\n// render a circle with radius r\nfloat circle(vec2 uv, float r) {\n    float d = length(uv) - r;\n    return smoothstep(_blur, -_blur, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.3;\n    \n    // get some frequencies from the fft\n    float speed = texture(iChannel0, vec2(.1, .25)).x * .1;\n    float bgspeed = texture(iChannel0, vec2(.3, .25)).x;\n    float mouthSize = texture(iChannel0, vec2(.7, .25)).x;\n \t\n    // add a distortion (blur + zoom)\n    // that comes in waves and reacts to high frequencies\n    float s = sin(uv.y * .8 + uv.x * .4 + iTime * 2.);\n    s = texture(iChannel0, vec2(.8, .25)).x * saturate(4. - length(uv)) * s * s * s * s;\n    _blur = .01 + .1 * s;\n    uv /= 1. + s * .1;\n    \n    vec3 color = vec3(0);\n    float f = 1.;\n    \n    float time = iTime;\n    \n    // uv for head shape/stars/pupils\n    vec2 puv = uv + (vec2(fbm(vec2(uv.x * 2., time)), fbm(vec2(uv.y * 2., time + 10.))) - .5) * .1;\n    \n    // shade on head\n    f += hole(uv / 3. + vec2(0, .1), time * .1 + bgspeed) * .6;\n    f -= hole(uv * 1.5 + vec2(0, .3), time * .1 + bgspeed) * .4;\n    // head\n    f *= circle(puv, 2.);\n    // shade behind\n    f  = max(f,.25- hole(uv / 4. + vec2(0, .1), time * .01) * .25);\n    // mouth\n    vec2 muv = (uv + vec2(0, 1.2)) * vec2(1.2 - mouthSize * .2, 1.2 - mouthSize * .8);\n    f *= hole(muv, time * (1. + speed * 2.));\n    // nose\n    f *= nose(uv + vec2(0, -.1), iTime * (1. + speed * 2.));\n    // eyes\n    f *= hole(uv - vec2(-.9, .2), iTime * (1. + speed * 5.)) * hole(uv - vec2(.9, .2), iTime * (1. + speed * 5.) + 3.);\n    // pupils\n    f += circle(puv - vec2(-.9, .2), .18) + circle(uv - vec2(.9, .2), .15);\n    \n    // render some stars with hard coded dimensions\n    f += circle(puv - vec2(-3., 1.4), .1) + circle(puv - vec2(3, 1), .13)\n       + circle(puv - vec2(2.5, -1), .05) + circle(puv - vec2(-3.6, -1.5), .05)\n       + circle(puv - vec2(3.6, -1.7), .06) + circle(puv - vec2(-2.2, .2), .05)\n       + circle(puv - vec2(3.4, 1.7), .07) + circle(puv - vec2(-2.2, -1.6), .1);\n    \n    // add some noise\n    f = saturate(f * .8 + (fbm(uv * 4.) - .5) * .2);\n    color = mix(vec3(.08, .1, .06), vec3(.95, .85, .75), f);\n    \n\tfragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 8052,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/kscopemusic/steven-wilson-the-raven-that"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}