{
    "Shader": {
        "info": {
            "date": "1617659007",
            "description": "An egg.",
            "flags": 0,
            "hasliked": 0,
            "id": "ss2GRG",
            "likes": 12,
            "name": "Ray-Egg Intersect",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "ray",
                "raycasting",
                "intersect",
                "egg"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 141
        },
        "renderpass": [
            {
                "code": "// Hide unwanted bits (just a huge plane with a hole in it)\n#define HIDE_EXCESS\n\n// RGB to decimal conversion\n#define rgb(r, g, b) vec3(r, g, b) / 255.0\n\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d, minCplx = 1.0;\n\n    float d0 = b * b - 3.0 * a * c;\n    float d1 = (2.0 * b * b - 9.0 * a * c) * b + 27.0 * a * a * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n    a *= 3.0;\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = q < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    C = sin(atan(C.y, C.x) / 3.0 + vec2(1.57079632679, 0.0)) * pow(0.25 * dot(C, C), 1.0 / 6.0);\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, h < 0.0 ? 1 : 3);\n    vec2 e = vec2(1.0, 0.0);\n    for (int k=0; k < (h < 0.0 ? 2 : 3); k++) {\n        vec2 m = e * mat2(C.x, -C.y, C.yx); // Complex multiplication\n        e *= mat2(-0.5, -0.86602540378, 0.86602540378, -0.5); // Raise cube root of unity to next power\n        vec2 root = (vec2(-d0, d0) * m / dot(m, m) - vec2(b, 0.0) - m) / a;\n        if (h < 0.0 ? (abs(root.y) < minCplx) : true) roots[h < 0.0 ? 0 : k] = root.x, minCplx = abs(root.y);\n    }\n\n    return roots;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Intersection\n// Implicit equation: (y + 2)(x^2 + z^2) + y^2 - 1\nvec4 iEgg(in vec3 ro, in vec3 rd) {\n    float xxzz = dot(ro.xz, ro.xz);\n    float uuww = dot(rd.xz, rd.xz);\n    float xuzw = dot(ro.xz, rd.xz);\n    float y2 = ro.y + 2.0;\n\n    float a = uuww * rd.y;\n    float b = 2.0 * (rd.y * xuzw + uuww) + uuww * ro.y + rd.y * rd.y;\n    float c = 2.0 * (y2 * xuzw + ro.y * rd.y) + xxzz * rd.y;\n    float d = y2 * xxzz + ro.y * ro.y - 1.0;\n\n    return solveCubic2(a, b, c, d);\n}\n\n// Normal\nvec3 nEgg(in vec3 p) {\n    return normalize(vec3(2.0 * p.xz + p.xy * p.yz, 0.5 * dot(p.xz, p.xz) + p.y).xzy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Find the closest hit\n    vec4 hit = iEgg(ro, rd);\n    float t = 1000000000.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit[3]); n++) {\n        vec3 hitCandid = ro + rd * hit[n];\n        bool notExcess = true;\n\n        #ifdef HIDE_EXCESS\n        notExcess = hitCandid.y > -1.0;\n        #endif\n\n        if (hit[n] > 0.0 && hit[n] < t && notExcess) {\n            t = hit[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t < 1000000000.0) {\n        vec3 n = nEgg(hitPos);\n        float diff = abs(dot(n, -rd));\n        fragColor.rgb = rgb(64, 224, 208);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}