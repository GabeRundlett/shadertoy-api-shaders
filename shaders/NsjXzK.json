{
    "Shader": {
        "info": {
            "date": "1620587172",
            "description": "Bosque poly-2d",
            "flags": 0,
            "hasliked": 0,
            "id": "NsjXzK",
            "likes": 2,
            "name": "Bosque poly-2d",
            "published": 3,
            "tags": [
                "2d",
                "draw",
                "poly",
                "bosquepoly2d",
                "polygono"
            ],
            "usePreview": 0,
            "username": "jorge2017a1",
            "viewed": 218
        },
        "renderpass": [
            {
                "code": "//por jorge2017a1 ----jorgeFloresP---9/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.13,.01),vec2(.12,.19),vec2(.15,.28),vec2(.15,.20),vec2(.16,.13),\nvec2(.16,.07),vec2(.17,.03),vec2(.18,.01),vec2(.13,.01) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.29,.00),vec2(.30,.17),vec2(.29,.28),vec2(.26,.36),vec2(.32,.26),\nvec2(.35,.13),vec2(.35,.07),vec2(.36,.01),vec2(.29,.00) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.47,.01),vec2(.47,.03),vec2(.50,.03),vec2(.52,.03),vec2(.57,.03),\nvec2(.58,.04),vec2(.62,.04),vec2(.65,.03),vec2(.68,.03),vec2(.69,.03),\nvec2(.70,.01),vec2(.47,.01) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.57,.03),vec2(.56,.24),vec2(.52,.30),vec2(.53,.32),vec2(.56,.29),\nvec2(.59,.32),vec2(.61,.32),vec2(.60,.27),vec2(.62,.26),vec2(.67,.31),\nvec2(.67,.29),vec2(.62,.21),vec2(.62,.03),vec2(.57,.03) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.52,.29),vec2(.47,.30),vec2(.42,.36),vec2(.38,.46),vec2(.43,.66),\nvec2(.56,.72),vec2(.72,.64),vec2(.79,.42),vec2(.75,.31),vec2(.66,.28),\nvec2(.52,.29) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.00,.45),vec2(.99,.46),vec2(.83,.70),vec2(.77,.58),vec2(.52,.90),\nvec2(.34,.64),vec2(.19,.83),vec2(.08,.56),vec2(.04,.62),vec2(.00,.45) );\n\n\nfloat sdPoly12b POLY(12)\nvec2 pt12b[ 12]=vec2[](  \nvec2(.83,.24),vec2(.77,.20),vec2(.69,.18),vec2(.66,.13),vec2(.70,.10),\nvec2(.82,.05),vec2(.93,.06),vec2(.99,.12),vec2(.98,.19),vec2(.92,.22),\nvec2(.86,.21),vec2(.83,.24) );\n\n\n//***------------****-----------****------------******-------\nvec3 Bosque1(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n   pr1.x= opRep1D(pr1.x, 0.4 ); pr1.y-=0.04;\n   pr2.x= opRep1D(pr2.x, 0.7 ); pr2.y+=0.04;\n   \n   float sd9 = sdPoly9(pr1, pt9);\n   float sd9b = sdPoly9b(pr2, pt9b);\n   float sd12 = sdPoly12(p, pt12);\n   float sd14 = sdPoly14(p, pt14);\n   float sd11 = sdPoly11(p, pt11);\n   float sd10 = sdPoly10(p, pt10);\n   float sd10b = sdPoly10(p-vec2(0.5,0.2), pt10);\n   float sd10c = sdPoly10(p-vec2(-0.5,0.1), pt10);\n   float sd12b = sdPoly12b(p, pt12b);\n   float sdcielo=-p.y+0.68;\n   \n   vec3 colsky1=mix(colAzul,vec3(1.0),p.y*.75);\n   \n   col= ponerBorde(colsky1,col,sdcielo); //\n   col= ponerBorde(col4,col,sd10c); //montana\n   col= ponerBorde(col4,col,sd10b); //montana\n   col= ponerBorde(colrojoObs,col,sd10); //montana\n   col= ponerBorde(colAzul,col,sd12b);\n    col= ponerBorde(colVerde,col,sd9); //\n   col= ponerBorde(colVerde,col,sd9b);\n   col= ponerBorde(colVerde2,col,sd12);\n   col= ponerBorde(colVerde2,col,sd11); //arbol ramas\n   col= ponerBorde(colrojoObs,col,sd14); //tronco\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.5;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    float tt=mod(iTime,10.0);\n    p.x= opRep1D(p.x+tt, 3.0 );\n    col=Bosque1(p, col);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}