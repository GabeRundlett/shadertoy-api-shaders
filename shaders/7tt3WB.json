{
    "Shader": {
        "info": {
            "date": "1636749220",
            "description": "Overhaul of an one of my early shaders, going back to update marching loop/normals/refraction etc. (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "7tt3WB",
            "likes": 14,
            "name": "Refraction Truchets",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "truchet",
                "pattern",
                "tiles"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 374
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Refraction Truchets [015] (mouseable)\n    11/12/21 @byt3_m3chanic\n    \n    An update to one of my earlier shaders, where I could barely do\n    2 bounce reflections - now sporting the refraction and some \n    smooth movement.\n    \n    I'd like to figure out chromatic aberration for the refraction\n    or maybe I should just get into ray tracing?!\n\n    original https://www.shadertoy.com/view/sdXSW4\n\n*/\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq sdf's\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cyl(vec3 p, float h, float r ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cap( vec3 p, vec2 hr ){\n    p.y -= clamp( p.y, 0.0, hr.x );\n    return length( p ) - hr.y;\n}\nfloat torus( vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy)-t.x,p.z);   \n    return length(q)-t.y;\n}\n//@iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 mod2(inout vec3 p, float scale){\n    float hlf = scale*.5;\n    vec2 id=floor((p.xy+hlf)/scale);\n    p.xy = mod(p.xy+hlf,scale)-hlf;\n    return id;\n}\n\nvec3 hit,hitPoint;\nvec2 id,tileId;\nmat2 turn,trs;\nfloat zIndex=0.,zid=0.;\nfloat tmod=0.,ga2=0.,ga5=0.;\n\n// sdf scene\nconst float size = 4.;\nconst float hlf = size*.5;\nconst float hzf = hlf*.5;\nconst float sp  = 15.;\nconst float hsp = sp*.5;\n\nvec2 map(vec3 p) {\n\n    vec3 ip = p-vec3(0,0,ga2*sp);\n    p.z+=4.25;\n    p.z-=ga5*sp;\n\n    zid = floor((ip.z+hsp)/sp)-.5;\n    p.xy*=rot(zid*.198);\n\n    p.z = mod(p.z+hsp,sp)-hsp;\n\n    vec2 res = vec2(1e5,0.);\n\n    float d = 1e5, t = 1e5;\n    vec3 q = p;\n    vec3 s = p-vec3(hlf,hlf,-hlf);\n    vec2 cid = mod2(q,size);\n    vec2 sid = mod2(s,size);\n    float ht = hash21(cid+zid); \n\n    // build parts\n    float thx = (.08+.055*sin(p.y*1.25) ) *size;\n    if(ht>.5) q.x *= -1.;\n\n    vec2 t2 = vec2(length(q.xy-hlf),length(q.xy+hlf));\n    vec2 q2 = t2.x<t2.y?vec2(q.xy-hlf):vec2(q.xy+hlf);\n    vec3 q3 = vec3(q2,q.z);\n    \n    float ti = torus(q3,vec2(hlf,thx));\n\n    // truchet\n    if(ti<res.x) {\n        res = vec2(ti*.8,2.);\n        hit = q;\n        id = cid;\n    }\n\n    vec2 bfm = vec2(hlf*.825,hlf+.1);\n\n    vec3 nq = cid!=vec2(0) ? q-vec3(0,0,.5) : q;\n    float b = box(nq,bfm.xxy);\n\n    b = min(box(q,bfm.yxx),b);\n    b = min(box(q,bfm.xyx),b);\n\n    float c = box(q,vec3(hlf)*.975);\n    float di = max(c,-b);\n\n    float sp = cap(s.xzy,vec2(size+.25,.675));\n    di=smin(di,sp,.125);\n\n    // box\n    if(di<res.x) {\n        res = vec2(di,3.);\n        hit = q;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n   \nvec3 hue(float t){ \n    return .65 + .35*cos(232.+PI2*t*(vec3(0.989,0.977,0.989)*vec3(0.925,0.722,0.435))); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout float fresnel, inout vec3 h) {\n\n    n = normal(p,d,1.);\n\n    vec3 l = normalize(vec3(5.,30,10)-p);\n    float diff = clamp(dot(n,l),.1,.8);\n    //@Shane specular highlights!\n    float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.);\n        \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .95, fresnel);\n    // doin a second fill light\n    l = normalize(vec3(-2.,020,-25)-p);\n    float diff2 = clamp(dot(n,l),.0,.8)*.65;\n    float spec2 = pow(max(dot(reflect(l, n), rd ), .2), 64.)*.65;\n\n    h = vec3(.075);\n\n    if(m==2.) {   \n        hitPoint/=size;\n        float dir = mod(tileId.x + tileId.y,2.) * 2. - 1.; \n        vec2 uv = hitPoint.xy-sign(hitPoint.x+hitPoint.y+.001)*.5;\n\n        float angle = atan(uv.x, uv.y);\n        float a = sin( dir * angle * 4. + T * .75);\n        a = abs(a)-.45;a = abs(a)-.35;\n        vec3 nz = hue(floor(a*3.5)+zIndex*2.);\n        h = mix(nz, vec3(.0001), smoothstep(.1, .11, a));  \n    }\n\n    return h*diff*vec3(0.933,0.984,0.984)+spec*diff2+spec2;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    trs = rot(PI*4.5);\n    turn = rot(-.1);\n    // movment and timing\n    float tt = T*.85;\n    tmod = mod(tt, 10.);\n    float t9 = lsp(0.0, 9.0, tmod);\n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga5 = t9;\n    ga2 = t9+floor(tt*.1);\n    \n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,1.),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.z<0.||M.xy == vec2(0) ? 0. :  (M.y/R.y * .25 - .125) * PI;\n    float y = M.z<0.||M.xy == vec2(0) ? 0. : -(M.x/R.x * .5 - .25) * PI;\n\n    mat2 rx = rot(x),ry = rot(y);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3  p = ro + rd * .1;\n    float atten = .95,k = 1.;\n    float bt =2.;// cheat to break for reflection bounce\n    float ct =6.;// cheat to break for refraction bounce\n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<134;i++)\n    {\n        vec2 ray = map(p);\n        float d = ray.x*.9;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n            hitPoint=hit; tileId=id, zIndex= zid;\n            \n            vec3 n=vec3(0);\n            float fresnel= 0.;\n            vec3 h=vec3(0);\n\n            C+=shade(p,rd,d,ray.y,n,fresnel,h)*atten;\n            if(bt<1.||ct<1.)break;\n\n            p += rd*.002;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n            // use h value and material to decide to reflect or refract\n            if(m==2.&&(h.r>.175||h.g>.175||h.b>.175)) {\n                atten *=.25;\n                rd=reflect(-rd,n);\n                p+=n*.02;\n                bt--;\n            }else{\n                ct--;\n                atten *= .6;\n                rr = refract(rd,n,.95);\n                rd=mix(rd,rr,.95-fresnel);\n            }\n        }  \n        if(distance(p,rd)>55.) { break; }\n    }\n\n    // Output to screen\n    C = sqrt(smoothstep(0.,1.,C));\n    O = vec4(C,1.);\n}\n\n//end\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}