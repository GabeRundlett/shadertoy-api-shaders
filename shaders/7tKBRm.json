{
    "Shader": {
        "info": {
            "date": "1664282045",
            "description": "You can see here sinusoidal circle and a few shapes unioned smoothly.",
            "flags": 0,
            "hasliked": 0,
            "id": "7tKBRm",
            "likes": 4,
            "name": "Sinusoidal dish and smoothies",
            "published": 3,
            "tags": [
                "raymarching",
                "sinusoidal",
                "smoothunion"
            ],
            "usePreview": 0,
            "username": "Visiware",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "// License: MIT\n// This shader was ported to shadertoy from my GLSL experiments on PC for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// There is many roughs\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 (PI*2.)\n\n#define CirclePart(angle) (angle*PI2)\n\n#define FOV 1.309\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\nfloat smoothIntersectSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distA - distB)/k,0.0,1.0);\n\treturn mix(distA,distB,h) + k*h*(1.0 - h); \n}\n\nfloat smoothUnionSDF(float distA,float distB,float k) {\n\tfloat h = clamp(0.5 + 0.5*(distA - distB)/k,0.0,1.0);\n \treturn mix(distA,distB,h) - k*h*(1.0 - h); \n}\n\nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distB + distA)/k,0.0,1.0);\n\treturn mix(distA,-distB,h) + k*h*(1.0 - h); \n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\nmat4 RotMatrixX(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][1] = sin(angle);\n\tm[1][0] = -sin(angle);\n\tm[1][1] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\nstruct MarchRet_t {\n\tfloat d;\n\tint i;\n};\n\n\nstruct CastRet_t {\n\tvec3 intersect;\n\tvec3 normal;\n\tbool casted;\n\t\n\tMarchRet_t march;\n};\n\n#define SMALLADD 0.004\n\n#define DISTMAX 3000.0\n\n\n\n\n\nMarchRet_t marchSmoothUnionSDF(MarchRet_t a,MarchRet_t b,float k) {\n\tint i = 0;\n\tif (a.d < b.d) {\n\t\ti = a.i;\n\t}\n\telse {\n\t\ti = b.i;\n\t}\n\t\n\treturn MarchRet_t(smoothUnionSDF(a.d,b.d,k),i);\n}\n\n\nMarchRet_t marchIntersectSDF(MarchRet_t a,MarchRet_t b) {\n\treturn MarchRet_t(max(a.d,b.d),a.i);\n}\n\nMarchRet_t marchUnionSDF(MarchRet_t a,MarchRet_t b) {\n\tif (a.d < b.d) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n\nMarchRet_t marchDifferenceSDF(MarchRet_t a,MarchRet_t b) {\n\tint i = 0;\n\tif (a.d > 0.) {\n\t\ti = a.i;\n\t}\n\telse {\n\t\ti = b.i;\n\t}\n\t\n\treturn MarchRet_t(max(a.d,-b.d),i);\n}\n\n\n\n\nMarchRet_t RoomSDF(vec3 o) {\n\tfloat cube0 = max(max(abs(o.x) - 5.,abs(o.z) - 8.),abs(o.y) - 5.);\n\to.x -= 8.9;\n\t\n\tfloat cube1 = max(max(abs(o.x) - 4.,abs(o.z) - 4.),abs(o.y) - 2.);\n\t\n\tfloat d = smoothUnionSDF(cube0,cube1,(sin(CirclePart(float(iFrame%80)/80.0)) + 1.0)/8.0 + 0.25);\n\t\n\treturn MarchRet_t(-d,0);\n}\n\n\n\nvec3 obj0_pos() {\n    return vec3(8,1.0 + cos(iTime*2.3)*1.2,1.0 + sin(iTime*3.0)*2.0);\n}\nvec3 obj1_pos() {\n    return vec3(8,-1.0 + cos(iTime*4.3)*1.5,2.0 + sin(iTime*2.1)*2.0);\n}\nvec3 obj2_pos() {\n    return vec3(8,-1.2 + cos(iTime*7.3)*1.1,-3.0 + sin(iTime*1.3)*1.5);\n}\nvec3 obj3_pos() {\n    return vec3(8,0.3 + cos(iTime*1.5)*0.7,-2.5 + sin(iTime*2.2)*2.2);\n}\nvec3 obj4_pos() {\n    return vec3(8,0.0 + cos(iTime*2.1)*1.1,1.2 + sin(iTime*1.3)*3.0);\n}\n\nMarchRet_t shapesSDF(vec3 o) {\n\tfloat t = CirclePart(float(iFrame%200)/200.0);\n\t\n\tfloat sphere0 = length(o - obj0_pos()) - 0.7;\n\t\n\tfloat sphere1 = length(o - obj1_pos()) - 0.5;\n\t\n\tfloat sphere2 = length(o - obj2_pos()) - 0.25;\n\t\n\tvec3 cbo = o - obj3_pos();\n\tfloat sphere3 = max(max(abs(cbo.x) - 0.7,abs(cbo.z) - 0.7),abs(cbo.y) - 0.5);\n\t\n\tfloat sphere4 = length(o - obj4_pos()) - 0.8;\n\t\n\tfloat d = smoothUnionSDF(sphere0,sphere1,1.5);\n\td = smoothUnionSDF(d,sphere2,1.5);\n\td = smoothUnionSDF(d,sphere3,1.5);\n\td = smoothUnionSDF(d,sphere4,1.5);\n\t\n\treturn MarchRet_t(d,1);\n}\n\n\nMarchRet_t effectSDF(vec3 o) {\n\tfloat tangle = CirclePart(float(iFrame%30)/30.0);\n\t\n\tfloat powbase = cos(CirclePart(float(iFrame%70)/70.0))/2.0 + 2.8;\n\t\n\tfloat d = intersectSDF(length(o.yz) - 1.2,abs(o.x) - ((cos(length(o.yz*(pow(powbase,length(o.yz) + 1.5))) - tangle) + 1.2)*0.05));\n\t\n\treturn MarchRet_t(d,2);\n}\n\n\nMarchRet_t SceneSDF(vec3 ori,vec3 dir) {\n\tMarchRet_t ret;\n\tret.i = 0;\n\t\n\tret = RoomSDF(ori);\n\t\n\tret = marchUnionSDF(ret,shapesSDF(ori));\n\t\n\tret = marchUnionSDF(ret,effectSDF(ori));\n\t\n\treturn ret;\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON),vec3(0,1,0)).d));\n}\n\n\n\n#define ITERMAX 300\n\n#define EPSILON 0.008\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir,float outmax) {\n\tCastRet_t maincast;\n\t\n\tmaincast.intersect = pos;\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\t\n\t\n\t\n\t\n\t\n\tvec3 ori = pos;\n\tfloat l = 0.;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tMarchRet_t march = SceneSDF(ori,dir);\n\t\t\n\t\tfloat d = march.d/1.5;\n\t\t\n\t\t\n\t\tif (l > outmax) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl += d;\n\t\t\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.intersect = epspos;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tmaincast.march = march;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n\t\n\treturn maincast;\n}\n\nvec3 ColorByMaterial(int index) {\n\tif (index == 0) {\n        return vec3(1.0,1.0,0.95);\n    }\n    else if (index == 1) {\n        return vec3(1.0,0.9,0.0);\n    }\n    else if (index == 2) {\n        return vec3(0.1,0.8,0.95);\n    }\n    else if (index == 3) {\n        return vec3(0.0,0.7,0.8);\n    }\n    return vec3(0);\n}\n\n\n\nbool mat_traceshadow(int index) {\n    return index == 1;\n}\n\nfloat mat_specular(int index) {\n    if (index == 0) {\n        return 900.0;\n    }\n    else if (index == 1) {\n        return 30.0;\n    }\n    else if (index == 2) {\n        return 80.0;\n    }\n    else if (index == 3) {\n        return 75.0;\n    }\n    return 0.0;\n}\n\n\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir,vec3 camera_pos) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tCastRet_t maincast = TraceObjects(pos,dir,DISTMAX);\n\t\n\tif (maincast.casted) {\n\t\tcolor = ColorByMaterial(maincast.march.i);\n\t\t\n\t\tvec3 lightpos = vec3(-2.7,0,-2.0);\n\t\tvec3 lightvecfull = lightpos - maincast.intersect;\n\t\tvec3 lightvec = normalize(lightvecfull);\n\t\t\n\t\tfloat cval = dot(maincast.normal,lightvec);\n\t\t\n\t\tbool shadowcasted = false;\n\t\t\n\t\tif (mat_traceshadow(maincast.march.i)) {\n\t\t\tvec3 shadow_pos = maincast.intersect + lightvec*SMALLADD;\n\t\t\t\n\t\t\t\n\t\t\tCastRet_t shadowcast = TraceObjects(shadow_pos,lightvec,length(lightvecfull));\n\t\t\tshadowcasted = shadowcast.casted;\n\t\t\t\n\t\t\t\n\t\t\tfloat spec = mat_specular(maincast.march.i);\n\t\t\t\n\t\t\tvec3 refl = normalize(maincast.normal*2.*dot(maincast.normal,lightvec) - lightvec);\n\t\t\t\n\t\t\tvec3 tocam = normalize(camera_pos - maincast.intersect);\n\t\t\t\n\t\t\tfloat cosangle = clamp(dot(tocam,refl),0.,1.);\n\t\t\tcval += pow(cosangle,spec);\n\t\t}\n\t\t\n\t\tif (cval < 0.0) {\n\t\t\tcolor = color*MINCOLOR;\n\t\t}\n\t\telse {\n\t\t\tif (shadowcasted) {\n\t\t\t\tcolor = color*MINCOLOR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = color*max(MINCOLOR,cval);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    \n    mat4 camera = RotMatrixY(-PI/2. + iMouse.x/iResolution.x - 0.3)*TransMatrix(-3.0 + iMouse.y/iResolution.y*3.0,0.0,4.0);\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir,vec3(camera[3][0],camera[3][1],camera[3][2])),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}