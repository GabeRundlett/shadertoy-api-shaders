{
    "Shader": {
        "info": {
            "date": "1513263479",
            "description": "An itteration of this: https://www.shadertoy.com/view/4llfDS\n\nHope you like it! :D",
            "flags": 0,
            "hasliked": 0,
            "id": "XlXBD2",
            "likes": 20,
            "name": "Sky with clouds",
            "published": 3,
            "tags": [
                "clouds",
                "scattering",
                "rayleigh",
                "mie",
                "atmospheric",
                "robobo1221"
            ],
            "usePreview": 0,
            "username": "robobo1221",
            "viewed": 2477
        },
        "renderpass": [
            {
                "code": "const vec3 rayleighCoeff = vec3(0.27, 0.5, 1.0) * 1e-5;\nconst float mieCoeff = 1e-6;\n\n#define pi 3.14159265359\n#define d0(x) abs(x) + 1e-8\n\nvec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth){\n\treturn coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth){\n\treturn exp2(scatter(coeff, -depth));\n}\n\nfloat calculateSceneDepth(float depth){\n\tdepth = depth * 2.0 - 0.1;\n    depth = max(depth + 0.01, 0.01);\n    \n    return depth * depth * (3.0 - 2.0 * depth);\n}\n\nfloat calcParticleThickness(float depth){\n   \t\n\tdepth = calculateSceneDepth(depth);\n    depth = 1.0 / depth;\n    \n\treturn 50000.0 * depth;   \n}\n\nfloat rayleighPhase(vec2 p, vec2 lp){\n\treturn 0.375 * (1.0 + pow(1.0 - distance(p, lp), 2.0) / log(2.0));\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    \n    float time = iTime * 0.075;\n    \n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x + time);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n        x += time;\n\t}\n\treturn v;\n}\n\nvec3 calcClouds(vec2 p, vec2 lp, vec3 background, vec3 scatteredSunlight, vec3 scatteredSkylight, float depth, float rawDepthLight)\n{\n    const int steps = 10;\n    const float invSteps = 1.0 / float(steps);\n    \n    float stepsize = 1.0;\n    \n    p = p * 2.0 - 1.0;\n    p *= 5.0;\n    p /= depth;\n    \n    lp = lp * 2.0 - 1.0;\n    lp *= 5.0;\n    lp /= rawDepthLight;\n\n    vec2 deltaPos = normalize(p - lp) * invSteps * stepsize;\n    float transmittance = 1.0;\n    float scattering = 0.0;\n    \n    const float cloudDensity = 800000.0;\n    \n    #define cloud clamp((fbm(p) - 0.25) * 10.0, 0.0, 1.0)\n    \n    float oldOD = cloud * cloudDensity;\n    \n    for (int i = 0; i < steps; i++){\n\t\tp -= deltaPos;\n        \n        float opticalDepth = cloud * cloudDensity;\n        \n        transmittance += opticalDepth;\n        \n    }\n    \n    const float anisatropicCoeff = 1.0 / (pi * 4.0);\n    \n    vec3 cloudAbsorb = absorb(vec3(mieCoeff), transmittance * stepsize);\n    \n    vec3 scatterCloud = scatter(vec3(mieCoeff), oldOD);\n    vec3 sunScatter = scatterCloud * scatteredSunlight * pi;\n    vec3 skyScatter = scatterCloud * scatteredSkylight * anisatropicCoeff;\n    \n    vec3 viewAbsorb = absorb(vec3(mieCoeff), oldOD);\n    \n    return background * viewAbsorb + (sunScatter * cloudAbsorb + skyScatter);\n}\n\nvec3 calcAtmosphericScatter(vec2 p, vec2 lp){\n    const float ln2 = log(2.0);\n    \n    const float up = 0.6;\n    \n\tfloat opticalDepth = calcParticleThickness(p.y);\n    float opticalDepthLight = calcParticleThickness(lp.y);\n    float opticalDepthUp = calcParticleThickness(up);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 scatterUp = scatter(totalCoeff, opticalDepthUp);\n    vec3 absorbUp = absorb(totalCoeff, opticalDepthUp); \n    \n    vec3 absorbSun = abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    vec3 scatterSun = scatterView * rayleighPhase(p, lp);\n    vec3 absorbUpv = abs(absorbLight - absorbUp) / d0((scatterLight - scatterUp) * ln2);\n    vec3 scatterUpv = scatterUp * rayleighPhase(vec2(up), lp);\n    \n    vec3 skylight = scatterUpv * absorbUpv;\n    \n    vec3 sunSpot = smoothstep(0.01, 0.009, distance(p, lp)) * absorbView * pi;\n    \n    float rawDepth = calculateSceneDepth(p.y);\n    float rawDepthLight = calculateSceneDepth(lp.y);\n    float cloudMult = rawDepth <= 0.05 ? 0.0 : clamp((rawDepth - 0.05) * pi * 2.0, 0.0, 1.0);\n    \n    vec3 color = (scatterSun * absorbSun + sunSpot);\n    vec3 clouds = calcClouds(p, lp, color, absorbLight, skylight, rawDepth, rawDepthLight);\n    \n    color = mix(color, clouds, cloudMult);\n    \n    return color * pi;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / max(iResolution.x, iResolution.y);\n    vec2 lp = iMouse.xy / max(iResolution.x, iResolution.y);\n         lp = lp.x == 0.0 ? vec2(0.2, 0.15) : lp;\n    \n    vec3 color = vec3(0.0);\n    color = calcAtmosphericScatter(uv, lp);\n    color = jodieReinhardTonemap(color);\n    \n\tfragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}