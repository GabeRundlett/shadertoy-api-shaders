{
    "Shader": {
        "info": {
            "date": "1665484630",
            "description": "This is a 4D mandelbrot set of sorts, but not the quaternion version.\nThis maps the four dimensions of the iterated function zₙ₊₁ = zₙ² + c .\nSee https://www.shadertoy.com/view/7tVBWt for an alternative rendering.",
            "flags": 32,
            "hasliked": 0,
            "id": "stVBWt",
            "likes": 5,
            "name": "Juliabrot 4D: Raymarched",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "mandelbrot",
                "sdf",
                "4d"
            ],
            "usePreview": 0,
            "username": "mmnz",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "// This is a 4D mandelbrot set of sorts, but not the quaternion version.\n// Each point on the mandelbrot set corresponds to some julia set.\n// Both sets map the places where zₙ₊₁ = zₙ² + c converges,\n// but the mandelbrot set varies the real and imaginary components of c,\n// and the julia sets vary the real and imaginary components of z₀.\n// Over all, there are four varying dimensions,\n// and the mandelbrot set and the julia sets are 2D slices of this 4D shape.\n// To view the whole 4D shape, I map one dimension to time and take 3D slices of the rest.\n// Even though julia sets with c outside the mandelbrot set are disconnected,\n// I would be pretty confident that the entirety of this 4D shape is connected.\n\n// I'm still a Shadertoy beginner, so this hasn't got the quality I want.\n// This is pretty much the same as 'Orbit Controls', but with the fractal.\n// https://www.shadertoy.com/view/flVfWt\n// TODOs:\n// - Fix the weird FOV problem at the extremes\n// - No amount of tuning the escape distance, iteration counts, or maxt and mint,\n//   seems to create the 'internal' distance estimate that I somehow got for\n//   https://www.shadertoy.com/view/7tVBWt\n\n// Slice can be 0, 1, 2, 3. Controls which plane varies over time.\n#define SLICE 0\n\n// Slice 0 and 1 plot Re(c) and Im(c) over x and y, so the z=0 plane at t=0 is the mandelbrot set.\n// Slice 2 and 3 plot Re(z₀) and Im(z₀) over x and y, so they are always stacks of julia sets.\n// Slice 2 plots Re(c) over z, so at t=0 it is a stack of all purely real julia sets.\n// Slice 3 plots Im(c) over z, so at t=0 it is a stack of all purely imaginary julia sets.\n\n// Pause the script when the fractal is most voluminous to see t=0.\n// Dragging with the mouse seems to work even when paused.\n\n\n// SDF of the fractal\nfloat juliabrot(in vec4 p) {\n\n    vec2 c = p.xy;\n    vec2 z = p.zw;\n    \n    // The piecewise derivative\n    // d.xy represents dzₙ/dc, used in the mandelbrot SDF\n    // d.zw represents dzₙ/dz, used in the julia SDF\n    vec4 d = vec4(0, 0, 1, 0);\n    \n    // Swap all the dimensions based on slice\n    #if SLICE == 1\n        z = p.wz;\n    #elif SLICE == 2\n        c = p.zw;\n        z = p.xy;\n        z.x += 1.0;\n    #elif SLICE == 3\n        c = p.wz;\n        z = p.xy;\n        z.x += 1.0;\n    #endif\n    \n    for (int i = 0; length(z) < 16.0 && i < 128; i++) {\n        // New derivative based on previous (dzₙ/dc = 2zₙ₋₁dzₙ₋₁/dc + 1, dzₙ/dz = 2zₙ₋₁dzₙ₋₁/dz)\n        d = 2.0 * vec4(\n            (z.x * d.x - z.y * d.y) + 1.0,\n            (z.x * d.y + z.y * d.x),\n            (z.x * d.z - z.y * d.w),\n            (z.x * d.w + z.y * d.z)\n        );\n        // New z based on previous (zₙ = zₙ₋₁² + c)\n        z = vec2(z.x * z.x - z.y * z.y + c.x, (z.x + z.x) * z.y + c.y);\n    }\n    // Distance from p to fractal\n    return 0.5 * length(z) * log(length(z)) / length(d);\n}\n\n// Returns distance, material\nvec2 map(in vec3 position) {\n    vec4 adjustedPosition = vec4(\n        // Position with shifted centre\n        position - vec3(1.0, 1.25, 0.0),\n        // Fourth dimension varies over time (slowing down at -2.25, 0, 2.25)\n        2.25 * cos(iTime / 2.0) * abs(cos(iTime / 2.0))\n    );\n    float fractal = juliabrot(adjustedPosition);\n    float terrain = position.y;\n    return (fractal < terrain) ? vec2(fractal, 1.0) : vec2(terrain, 2.0);\n}\n\n// Returns t, material shadow\nvec3 castRay(in vec3 rayOrigin, in vec3 rayDirection) {\n    float t = 0.0;\n    float material = -1.0;\n    float shadow = 1.0;\n    float mint = 0.001;\n    float maxt = 20.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        vec2 h = map(position);\n        material = h.y;\n        shadow = min(shadow, 8.0 * h.x / t);\n        if (h.x < mint) { break; }\n        t += h.x;\n        if (t > maxt) { break; }\n    }\n    if (t > maxt) { t = material = -1.0; }\n    shadow = clamp(shadow, 0.0, 1.0);\n    return vec3(t, material, shadow);\n}\n\n// Returns normal\nvec3 calcNormal(in vec3 position) {\n    vec2 e = vec2(1, -1) * inversesqrt(12000000.0);\n    return normalize(\n        e.xyy * map(position + e.xyy).x + \n\t\te.yyx * map(position + e.yyx).x + \n\t\te.yxy * map(position + e.yxy).x + \n\t\te.xxx * map(position + e.xxx).x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float pi = acos(-1.0);\n    // Customisable\n    float thetaOffset = 0.0; // 0.1 * iTime; // Extra rotation\n    float ymin = 0.1; // 0.0 = 0deg, facing the horizon\n    float ymax = 0.9; // 1.0 = 90deg, facing the ground\n    float orbitRadius = 4.0; // Distance from center\n    // Always the same\n    vec2 storedMouse = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    float theta = -2.0 * pi * storedMouse.x + thetaOffset;\n    float phi = 0.5 * pi * (1.0 - storedMouse.y) * (ymax - ymin) + ymin;\n    vec3 rayOrigin = orbitRadius * vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n    // Standard camera stuff\n    vec3 target = vec3(0, 1, 0);\n    float focalLength = 1.5;\n    vec3 ww = normalize(target - rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rayDirection = normalize(p.x * uu + p.y * vv + focalLength * ww);\n\n    // Sky colour, fading to grey at the horizon\n    vec3 color = vec3(0.4, 0.7, 1.0) - 0.7 * rayDirection.y;\n    color = mix(color, vec3(0.7, 0.75, 0.8), clamp(exp(-10.0 * rayDirection.y), 0.0, 1.0));\n    \n    vec3 ray = castRay(rayOrigin, rayDirection);\n    \n    if (ray.y > 0.0) {\n        vec3 position = rayOrigin + ray.x * rayDirection;\n        vec3 normal = calcNormal(position);\n        \n        // Material colour\n        vec3 material = vec3(0);\n        if (ray.y < 1.5) {\n            material = vec3(0.01, 0.02, 0.18); // Fractal: blue\n        } else {\n            material = vec3(0.05, 0.1, 0.02); // Terrain: green checkerboard\n            material += 0.05 * smoothstep(-0.1, 0.1, sin(18.0 * position.x) + cos(18.0 * position.z));\n        }\n        \n        // Lighting colours\n        vec3 sun_direction = normalize(vec3(1.0, 1.0, 1.0));\n        float sun_diffuse = clamp(dot(normal, sun_direction), 0.0, 1.0);\n        float sun_shadow = castRay(position + normal * 0.001, sun_direction).z;\n        float sky_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, 1, 0)), 0.0, 1.0);\n        float ground_diffuse = clamp(0.5 + 0.5 * dot(normal, vec3(0, -1, 0)), 0.0, 1.0);\n        color  = material * vec3(7.0, 4.5, 3.0) * sun_diffuse * sun_shadow;\n        color += material * vec3(0.5, 0.8, 0.9) * sky_diffuse;\n        color += material * vec3(0.7, 0.3, 0.2) * ground_diffuse;\n        \n        // Check the normals of the fractal\n        // if (ray.y < 1.5) { color = normal; }\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.4545)), 1.0);\n    \n    // Test first 2px of Buffer A:\n    // fragColor = texture(iChannel0, (2.0 * fragCoord - iResolution.xy) / iResolution.y);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Save mouse position.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialise buffer to white (buffer is unused if alpha is empty).\n    if (texelFetch(iChannel0, ivec2(0,0), 0).a < 1.0) {\n        fragColor = vec4(1);\n        return;\n    }\n    // Fetch old values\n    vec2 current = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 previous = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    // Fix for Shadertoy ignoring mouseup outside canvas. Reset previous on click.\n    // Fix removed because it breaks things on iOS (where iMouse.w is positive until mouseup).\n    // if (mouse.w > 0.0) {\n    //     previous = current;\n    // }\n    // When mouse down, add the mouse position to the previous position minus starting offset.\n    // Otherwise, save the current position to be used for the next time the mouse is dragged.\n    if (mouse.z > 0.0) {\n        vec2 next = previous + mouse.xy - abs(mouse.zw);\n        current = vec2(fract(next.x), clamp(next.y, 0.0, 1.0)); // wrap x, clamp y\n    } else {\n        previous = current;\n    }\n    // Save current to (0,0) and previous to (1,0)\n    fragColor = vec4(fragCoord.x < 1.0 ? current : previous, 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}