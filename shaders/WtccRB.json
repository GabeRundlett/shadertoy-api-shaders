{
    "Shader": {
        "info": {
            "date": "1609315236",
            "description": "The based algorithm is referred from [url]https://github.com/CiaccoDavide/Alchemy-Circles-Generator[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WtccRB",
            "likes": 8,
            "name": "Alchemy Circles Generator",
            "published": 3,
            "tags": [
                "alchemy"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2020 IWBTShyGuy\n\nconst float PI = 3.141592653;\n\nconst float THICK = 0.015;\nconst float RADIUS = 0.75;\n\nconst vec3 LINE_COLOR = vec3(1.0);\nconst vec3 BACK_COLOR = vec3(0.0);\n\nconst int GEN_LENGTH = 8;\nvec2[GEN_LENGTH] generators() {\n    float year = floor(iDate.x + iTime);\n    float month = floor(iDate.y + iTime);\n    float day = floor(iDate.z + iTime);\n    float hour = floor(floor(iDate.w / 3600.0) + iTime);\n    float minute = floor(floor((iDate.w - hour * 3600.0) / 60.0) + iTime);\n\n    return vec2[](\n        vec2(year, day),\n        vec2(month, year),\n        vec2(month, day),\n        vec2(hour, minute),\n        vec2(year, minute),\n        vec2(month, hour),\n        vec2(minute, month),\n        vec2(year, hour)\n    );\n}\n\nfloat random(in vec2 c) {\n    const vec3 gen = vec3(114.514, 191.9810, 334.8040);\n    return fract(gen.x * sin(dot(gen.yz, c)));\n}\n\nvec4 drawLine(in vec2 p, in vec2 q, in vec2 uv, in vec4 fragColor) {\n    vec2 a = q - p;\n    vec2 b = uv - p;\n    float t = dot(b, a) / dot(a, a);\n    if (t < 0.0 || 1.0 < t) return fragColor;\n    vec2 h = b - t * a;\n    float irr = clamp(1.0 - dot(h, h) / (THICK * THICK), 0.0, 1.0);\n    return max(fragColor, vec4(irr * LINE_COLOR, 1.0));\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nCircle newCircle(in vec2 center, in float radius) {\n    Circle c;\n    c.center = center;\n    c.radius = radius;\n    return c;\n}\n\nvec4 drawCircle(in Circle circle, in vec2 uv, in vec4 fragColor) {\n    float dist = distance(uv, circle.center);\n    float irr = (dist - circle.radius) / THICK;\n    irr *= irr;\n    irr = clamp(1.0 - irr, 0.0, 1.0);\n    return max(fragColor, vec4(LINE_COLOR * irr, 1.0));\n}\n\nvec4 fillCircle(in Circle circle, in vec2 uv, in vec4 fragColor) {\n    float dist = distance(uv, circle.center);\n    if (dist < circle.radius) return vec4(BACK_COLOR, 1.0);\n    else return fragColor;\n}\n\nstruct Polygon {\n    vec2 center;\n    float radius;\n    float rotation;\n    int n_gon;\n};\n\nPolygon newPolygon(vec2 center, float radius, float rotation, int n_gon) {\n    Polygon poly;\n    poly.center = center;\n    poly.radius = radius;\n    poly.rotation = rotation;\n    poly.n_gon = n_gon;\n    return poly;\n}\n\nvec4 drawPolygon(in Polygon poly, in vec2 uv, in vec4 fragColor) {\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t0 = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p0 = poly.center + poly.radius * vec2(cos(t0), sin(t0));\n        float t1 = poly.rotation + float(i + 1) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p1 = poly.center + poly.radius * vec2(cos(t1), sin(t1));\n        fragColor = drawLine(p0, p1, uv, fragColor);\n    }\n    return fragColor;\n}\n\nvec4 fillPolygon(in Polygon poly, in vec2 uv, in vec4 fragColor) {\n    int counter = 0;\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t0 = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p0 = poly.center + poly.radius * vec2(cos(t0), sin(t0));\n        float t1 = poly.rotation + float(i + 1) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p1 = poly.center + poly.radius * vec2(cos(t1), sin(t1));\n        vec2 a = p0 - uv;\n        vec2 b = p1 - uv;\n        if (a.y >= 0.0 && b.y < 0.0) {\n            float x = a.x - a.y / b.y * b.x;\n            if (x > 0.0) counter -= 1;\n        } else if (a.y <= 0.0 && b.y > 0.0) {\n            float x = a.x - a.y / b.y * b.x;\n            if (x > 0.0) counter += 1;\n        }\n    }\n    if (counter > 0) return vec4(BACK_COLOR, 1.0);\n    else return fragColor;\n}\n\nvec4 drawRadial(in Polygon poly, in vec2 uv, in vec4 fragColor) {\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p = poly.center + poly.radius * vec2(cos(t), sin(t));\n        fragColor = drawLine(poly.center, p, uv, fragColor);\n    }\n    return fragColor;\n}\n\nvec4 drawPartialRadial(in Polygon poly, in float inner_radius, in vec2 uv, in vec4 fragColor) {\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p = poly.center + inner_radius * vec2(cos(t), sin(t));\n        vec2 q = poly.center + poly.radius * vec2(cos(t), sin(t));\n        fragColor = drawLine(p, q, uv, fragColor);\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 generators[GEN_LENGTH] = generators();\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    fragColor = vec4(BACK_COLOR, 1.0);\n\n    Circle c0 = newCircle(vec2(0.0), RADIUS);\n    fragColor = drawCircle(c0, uv, fragColor);\n    \n    int n = int(4.0 + 4.999 * random(generators[0])), n0;\n    Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n);\n    fragColor = drawPolygon(poly, uv, fragColor);\n    fragColor = drawRadial(poly, uv, fragColor);\n\n    float r = random(generators[1]);\n    if (poly.n_gon % 2 == 0) {\n        n0 = 0.6 < r ? 6 : 0.2 < r ? 4 : 2;\n        Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n0);\n        fragColor = fillPolygon(poly, uv, fragColor);\n        fragColor = drawPolygon(poly, uv, fragColor);\n        fragColor = drawRadial(poly, uv, fragColor);\n    } else {\n        n0 = r < 0.5 ? 4 : 6;\n        Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n0);\n        fragColor = fillPolygon(poly, uv, fragColor);\n        fragColor = drawPolygon(poly, uv, fragColor);\n    }\n\n    r = random(generators[2]);\n    if (r < 0.5) {\n        float r = random(generators[3]);\n        if (r < 0.5) {\n            Polygon poly = newPolygon(vec2(0.0), RADIUS * 0.625, 0.0, n + 4);\n            fragColor = drawRadial(poly, uv, fragColor);\n            poly.radius = RADIUS * 0.5;\n            fragColor = fillPolygon(poly, uv, fragColor);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        } else if (n > 5) {\n            Polygon poly = newPolygon(vec2(0.0), RADIUS * 0.625, 0.0, n - 2);\n            fragColor = drawRadial(poly, uv, fragColor);\n            poly.radius = RADIUS * 0.25;\n            fragColor = fillPolygon(poly, uv, fragColor);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        }\n    }\n\n    r = random(generators[4]);\n    if (r < 0.6) {\n        Circle c = newCircle(vec2(0.0), RADIUS * 0.6875);\n        fragColor = drawCircle(c, uv, fragColor);\n        float r = random(generators[5]);\n        if (n % 2 == 0) {\n            float r7 = 7.0 * r;\n            n0 = 5.0 < r7 ? 8 : 3.0 < r ? 6 : 1.0 < r7 ? 4 : 2;\n            Polygon poly = newPolygon(vec2(0.0), RADIUS / 1.5, 0.0, n0);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        } else {\n            float r3 = 3.0 * r;\n            n0 = 2.0 < r3 ? 3 : 1.0 < r3 ? 5 : 7;\n            Polygon poly = newPolygon(vec2(0.0), RADIUS / 1.5, PI, n0);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        }\n    }\n\n    r = random(generators[6]);\n    if (r < 0.25) {\n        for (int i = 0; i < n0; i++) {\n            float theta = float(i) / float(n0) * 2.0 * PI;\n            vec2 center = vec2(cos(theta), sin(theta)) * 11.0 / 18.0 * RADIUS;\n            Circle c = newCircle(center, RADIUS * 3.0 / 22.0);\n            fragColor = fillCircle(c, uv, fragColor);\n            fragColor = drawCircle(c, uv, fragColor);\n        }\n    } else if (r < 0.5) {\n        for (int i = 0; i < n0; i++) {\n            float theta = float(i) / float(n0) * 2.0 * PI;\n            vec2 center = vec2(cos(theta), sin(theta)) * RADIUS;\n            Circle c = newCircle(center, RADIUS * 3.0 / 22.0);\n            fragColor = fillCircle(c, uv, fragColor);\n            fragColor = drawCircle(c, uv, fragColor);\n        }\n    } else if (r < 0.75) {\n        Circle c = newCircle(vec2(0.0), RADIUS / 3.0);\n        fragColor = drawCircle(c, uv, fragColor);\n        c.radius = 3.0 / 11.0 * RADIUS;\n        fragColor = fillCircle(c, uv, fragColor);\n        fragColor = drawCircle(c, uv, fragColor);\n    } else {\n        Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n0);\n        fragColor = drawPartialRadial(poly, RADIUS / 1.5, uv, fragColor);\n        if (n != n0) {\n            Circle c = newCircle(vec2(0.0), RADIUS / 1.5);\n            fragColor = fillCircle(c, uv, fragColor);\n            fragColor = drawCircle(c, uv, fragColor);\n            r = random(generators[7]);\n            int n = r < 0.25 ? 3 : r < 0.5 ? 4 : r < 0.75 ? 5 : 6;\n            Polygon poly = newPolygon(vec2(0.0), RADIUS * 1.25, 0.0, n);\n            fragColor = drawPolygon(poly, uv, fragColor);\n            poly = newPolygon(vec2(0.0), RADIUS / 1.5, PI, n);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        }\n    }\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}