{
    "Shader": {
        "info": {
            "date": "1709904359",
            "description": "Some shader practice related to Voronoi.\n\nThanks to Inigo Quilez",
            "flags": 0,
            "hasliked": 0,
            "id": "43fSWB",
            "likes": 2,
            "name": "Shader Practice - Voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "practice"
            ],
            "usePreview": 0,
            "username": "TheHarmacist",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "float r21(vec2 seed)\n{\n  return fract(sin(dot(seed.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 r22(vec2 seed)\n{\n    float x = r21(seed);\n    float y = r21(seed+x);\n    return vec2(x,y);\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n\n\nvec2 Voronoi(vec2 uv, float angleOffset, float scale)\n{\n    uv*=scale;\n    vec2 gridUV = fract(uv);\n    vec2 gridID = floor(uv);\n    \n    float minDist = 500.0;\n    \n    vec3 minDistance = vec3( 8.0 );\n    \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  neighborIndex = vec2( float(i), float(j) );\n        vec2  neighborSeedPos = hash( gridID + neighborIndex );\n        \n\t    vec2  pixelToSeed = 0.5+0.5*sin(angleOffset+6.2831*neighborSeedPos) \n        + neighborIndex - gridUV; //vector from current pixel to seedPos of neighbor cell\n        \n\t\tfloat dotPTS = dot(pixelToSeed, pixelToSeed);  //getting sqrMag here\n        \n        if( dotPTS<minDistance.x )\n            minDistance = vec3( dotPTS, neighborSeedPos );\n    }\n\n    return vec2( sqrt(minDistance.x), minDistance.y*minDistance.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    float warpFactor = max(dot(uv, uv)*10.0, 0.01);\n    uv/= warpFactor;\n    uv *= sin(t*0.2)*2.8+4.75;\n     \n    float bump = Voronoi(uv, t*0.6, 75.).x;\n    vec2 check = Voronoi(uv, t*0.6-bump, 8.);\n    \n    vec3 col = vec3(0.0);\n    col = mix(vec3(0.04, 0.01, 0.23), vec3(0.55, 0.45, 0.9), vec3(check.y));\n    col = mix(vec3(0.04, 0.01, 0.23), col, clamp((warpFactor)-0.005, 0.0, 2.0));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}