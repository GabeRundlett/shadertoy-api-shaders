{
    "Shader": {
        "info": {
            "date": "1395743430",
            "description": "A bunch of diamonds. Just because a friend asked me :).",
            "flags": 0,
            "hasliked": 0,
            "id": "ldfXzn",
            "likes": 50,
            "name": "Diamonds are Forever",
            "published": 3,
            "tags": [
                "raymarching",
                "transparency"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 3109
        },
        "renderpass": [
            {
                "code": "#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t5\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.2 // 2.417 for real diamonds... but it would require RAY_COUNT to be increased (because of total internal reflections)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t0.5\n#define LUMINOSITY_FACTOR\t2.0\n\n//#define ATAN2 // Comment this to use the original atan function\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n#ifndef ATAN2\n#define atan2 atan\n#else\nfloat atan2 (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_nobranch (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tfloat t4 = M_PI / 2.0 - t3;\n\tt3 = step (0.0, t2 - t1) * (t3 - t4) + t4;\n\tt4 = M_PI - t3;\n\tt3 = step (0.0, x) * (t3 - t4) + t4;\n\tt3 = step (0.0, y) * (t3 + t3) - t3;\n\treturn t3;\n}\n#endif\n\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.8));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.6));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 2.0));\nvec3 k;\nfloat getDistance (in vec3 p) {\n\tfloat repeat = 20.0;\n\tvec3 q = p + repeat * 0.5;\n\tk = floor (q / repeat);\n\tq -= repeat * (k + 0.5);\n\tp = mRotate (k + iTime) * q;\n\n\tfloat topCut = p.y - 1.1;\n\tfloat angleStep = M_PI / max (1.0, abs (4.0 + k.x + 2.0 * k.y + 4.0 * k.z));\n\tfloat angle = angleStep * (0.5 + floor (atan2 (p.x, p.z) / angleStep));\n\tq = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat bottomA = dot (q, normalBottomA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.8;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan2 (q.x, q.z) / angleStep);\n\tq = vRotateY (p, angle);\n\tfloat bottomB = dot (q, normalBottomB) - 1.95;\n\tfloat topB = dot (q, normalTopB) - 1.92;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}