{
    "Shader": {
        "info": {
            "date": "1703148175",
            "description": "This demo features Alligator noise with bubbly texture resembling alligator skin. Enhanced with octaves and tiling for versatility, this algorithm originates from Side Effects. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4fX3D8",
            "likes": 6,
            "name": "Alligator Noise +Octaves +Tiling",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "voronoi",
                "noise",
                "volume",
                "random",
                "tiling",
                "procedual",
                "octave",
                "alligator",
                "persistance",
                "lacunarity"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 449
        },
        "renderpass": [
            {
                "code": "/*\nThis shader showcases Alligator noise, resembling the distinctive pattern \nfound on the skin of an alligator. It is particularly well-suited as detail \nnoise for volumetric clouds but can be applied in various scenarios. \n\nThe shader offers several controls: the mouse's x-axis adjusts the height in \nthis 3D noise, while the y-axis controls the zoom. Additional settings can \nbe found in the global parameters below the header.\n\nThis shader is an adaptation of the original Alligator Noise shader from \nSide Effects Software's Houdini Development Kit. The original copyright \nnotice from Side Effects Software has been preserved below.\n\nThe original source code is available on the Side Effects website:\nhttps://www.sidefx.com/docs/hdk/alligator_2alligator_8_c-example.html\n\nAdditional reading material: \n\nSebastian Lague explains Voronoi Noise, which works similar to Alligator noise:\nhttps://youtu.be/4QOcCGI6xOU?si=nadKunwxoVDgCWD6&t=56\n\nCatlike Coding has a nice guide on Fractal and Tiling Noise:\nhttps://catlikecoding.com/unity/tutorials/pseudorandom-noise/noise-variants/\n\n____________________________________________________________________________\nCopyright (c) 2023\n    Side Effects Software Inc.  All rights reserved.\n    Adapted for GLSL by GehtSieGarNixAn in 2023\n\nRedistribution and use of Houdini Development Kit samples in source and\nbinary forms, with or without modification, are permitted provided that the\nfollowing conditions are met:\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n2. The name of Side Effects Software may not be used to endorse or\n   promote products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY SIDE EFFECTS SOFTWARE `AS IS' AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN\nNO EVENT SHALL SIDE EFFECTS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nAlligator Noise is provided by Side Effects Software Inc. and is licensed\nunder a Creative Commons Attribution-ShareAlike 4.0 International License.\n*/\n\n// Size of the noise cells, value range 1-inf\n#define GRIDSIZE 8.0\n\n// Number of noise Layers, value range 1-inf\n#define OCTAVES 5\n\n// Scaling of successive octaves, value range 1-inf\n#define LACUNARITY 2.0\n\n// Amplitude reduction of each successive octave, value range 0-1\n#define PERSISTENCE 0.5\n\n// Enable repeating Tiling.\n#define TILING\n\n// Add lines for the grid outlines\n#define SHOWGRID\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Alligator Noise, originally from Side Effects:\n// https://www.sidefx.com/docs/hdk/alligator_2alligator_8_c-example.html\nfloat alligator(vec3 position, uint gridsize, uvec3 seed) {\n    // scale the position\n    position *= float(gridsize);\n    \n    vec3 id = floor(position); // Integer coordinates\n    vec3 grid = position - id; // Fractional coordinates\n    \n    // Initialize results\n    float densest;\n    float secondDensest;\n    \n    // compare to 3x3x3 neighbor cells\n    for (int ix = -1; ix <= 1; ++ix) {\n        for (int iy = -1; iy <= 1; ++iy) {\n            for (int iz = -1; iz <= 1; ++iz) {\n            \n                // Offset to the neighbor cell\n                vec3 offset = vec3(ix, iy, iz);\n            \n                // Current Cell coordinates\n                vec3 cell = id + offset;\n                \n                #ifdef TILING\n                    // makes the noise repeat at pos 0-1\n                    cell = mod(cell, float(gridsize));\n                #endif\n                                \n                // Modify the result with some Offset\n                // This hash doesn't like 0 so plus 1\n                cell += vec3(seed);\n                \n                // Get random center of the Cell\n                vec3 center = hash33(cell) + offset;\n                \n                // Distance from center\n                float dist = distance(grid, center);\n\n                // 'if(dist < 1.0)' doesn't have any effect and doesn't improve\n                // performance. See: https://www.shadertoy.com/view/MflGWM\n\n                // Get random density scaled by the distance to the random point          \n                float density = hash13(cell) * smoothValue(1.0 - dist);\n              \n                // find largest values\n                if (densest < density) {\n                    // move previous highest to second place\n                    secondDensest = densest;\n                    // update highest to current height\n                    densest = density;\n\n                } else if (secondDensest < density) {\n                    // update second highest to current height\n                    secondDensest = density;\n                }\n            }\n        }\n    }\n    // Subtract two largest density values for the result\n    return densest - secondDensest;\n}\n\n// Alligator noise with Octaves\nfloat alligator(vec3 position, float gridsize, \n                int octaves, float lacunarity, float persistence) {\n    \n    // Initialize the constants    \n    // For Amplitude math see: https://www.desmos.com/calculator/xgqeepapwn\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    uvec3 seed = uvec3(421); // can be any positive integer\n    \n    // For each Octave\n    for(int i = 0; i < octaves; ++i) {\n        // sample noise and apply amplitude\n        result += alligator(position, uint(gridsize), seed) * amplitude;\n        \n        // add up amplitude to normalize result later\n        amplitudeSum += amplitude;\n        \n        // increase frequency for the next octave\n        gridsize *= lacunarity;\n        \n        // decrease amplitude for the next octave\n        amplitude *= persistence; \n        \n        // change seed/offset noise so it is unique for the next octave\n        seed += uvec3(gridsize);\n    }\n    \n    // normalize the result to 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    float height;\n    float zoom;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomsteps = 15.0;\n        zoom = mix(1.75, 0.1, pow(floor(mouse.y * zoomsteps) / zoomsteps, 0.5));\n    \n        // Mouse controls the height of the noise slice\n        height = mix(-0.1, 1.1, mouse.x);\n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(1.1, 0.5, -cos(zoomTime) * 0.5 + 0.5);\n    \n        // Animated height of the noise slice\n        height = iTime * 0.01;\n    } \n    \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;\n    \n    // Generate position from UV and height\n    vec3 position = vec3(uv, height);\n    \n    // Sample alligator noise\n    float noise = alligator(position, GRIDSIZE, OCTAVES, LACUNARITY, PERSISTENCE);\n    \n    #if OCTAVES != 1\n        // Aristic increase of the gamma, so the noise is not so dark\n        noise = clamp(noise *1.5,0.,1.);\n        noise = pow(noise, 0.7);\n    #endif\n    \n    // Apply colormap for better readability\n    vec3 color = viridis(noise);\n\n    #ifdef SHOWGRID\n        // Add lines on the edges of the grid\n        float thickness = 0.01;\n        vec3 grid = abs(fract(position) * 2.0 - 1.0);\n        color *= smoothstep(thickness*0.1, thickness, 1.-max(grid.x, grid.y));  \n    #endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//_____________________GENERIC FUNCTIONS______________________________\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//_____________________HASH FUNCTIONS_________________________________\n// These are particularly fast hash functions, but any hash should work fine \n\n// my reworked version of Dave_Hoskins https://www.shadertoy.com/view/XdGfRR\n#define FPRIME 1317666547U\n#define VPRIME uvec3(3480082861U, 2420690917U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nfloat hash13(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * VPRIME;\n\tuint n = (q.x & q.y ^ q.z) * FPRIME;\n\treturn float(n) * SMALLESTFLOAT;\n}\n\n// 3 in 3 out hash from \n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}