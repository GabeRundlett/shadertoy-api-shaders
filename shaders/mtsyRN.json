{
    "Shader": {
        "info": {
            "date": "1690504128",
            "description": "Molten metal (Fire 3d)",
            "flags": 32,
            "hasliked": 0,
            "id": "mtsyRN",
            "likes": 18,
            "name": "Fire 3d",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "fractal",
                "cloud",
                "fire",
                "generated"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n// This is a fork of two other shaders: https://www.shadertoy.com/view/7sjyRD and https://www.shadertoy.com/view/mlXyR4\n\n// At lease some of these must be 1:\n#define PLOT_AVG       0\n#define PLOT_MAX       1\n\n#define START_DIST   2.5\n#define FOV          5.\n\nvec3 col(float x) {\n  return vec3(\n      clamp(x, 0., 1./3.),\n      clamp(x-1./3., 0., 1./3.),\n      clamp(x-2./3., 0., 1./3.)\n   ) * 3.;\n}\n\nvec3 col2(float x) {\n  return vec3(\n      clamp(x, 0., 1.)\n   );\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if (sdBox(I - BUTTON_ORIGIN, BUTTON_SZ) <= 0.) {\n        O = vec4(0,0,1. - step(0.5, iMouse.z)*step(0., -sdButton)*0.5,1);\n        vec2 inner_sz = BUTTON_SZ - 2.;\n        float sdf = min(sdEquilateralTriangle(-(I - BUTTON_ORIGIN - vec2(3,0)).yx/inner_sz.y)*inner_sz.y,\n                        sdBox(I - BUTTON_ORIGIN + vec2(inner_sz.y,0), vec2(2,inner_sz.y)));\n        O.rgb = mix(O.rgb, vec3(1,1,1), smoothstep(1., -1., sdf));\n        return;\n    }\n\n    O = vec4(0,0,0,1);\n    mat2 rot_yz, rot_xy;            // rotations\n    if (iMouse.x < 0.5 || sdButton <= 0.) {\n      // https://graphtoy.com/?f1(x,t)=(floor(x/5)+smoothstep(0,1,fract(x/5)*10))*0.5&v1=true&f2(x,t)=&v2=false&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,7.451055876709886\n      rot_xy = rot(-iTime/2.);\n      //rot_xy = rot(float(-iFrame)/70.);\n      rot_yz = rot(1.2);\n    } else {\n      vec2 M = (iMouse.xy / R2.xy * vec2(1., -0.7) + vec2(0.5, 0.1)) * 2. * PI;\n      rot_yz = rot(-M.y);\n      rot_xy = rot(-M.x);\n    }\n    vec3 p = vec3(0,0,START_DIST);                                       // current ray pos\n    p.yz *= rot_yz;  p.xy *= rot_xy;\n\n    vec3 D = normalize(vec3(I+I, -FOV*R2.y) - vec3(R2.xy, 0.));    // ray direction\n    D.yz *= rot_yz;  D.xy *= rot_xy;\n\n    vec3 R3 = Res2to3(R2.xy);\n    float scale2 = R3.x;\n    float c = 0.;\n    float n_c = 0.;\n    float cmax = 0.;\n    float st = 0.5/R3.z;\n    int n_steps = int(3./st);\n    vec3 st1 = st * D;\n    int n;\n    float axis = 99.;\n    for (p += D*(START_DIST - 1.5), n = 0; n < n_steps; n++, p += st1) {\n        vec3 coord = (p + 0.5) * scale2;\n        if (coord.x >= 0. && coord.y >= 0. && coord.z >= 0. &&\n            coord.x < R3.x && coord.y < R3.y && coord.z < R3.z) {\n#if PLOT_AVG\n            c += T(coord).x;\n            n_c++;\n#endif\n#if PLOT_MAX\n            cmax = max(cmax, T(coord).x);\n#endif\n#define SDF_AXIS(XX)   distance(coord.XX + coord.XX, R3.XX)\n            axis = min(\n                    min(axis, SDF_AXIS(xy)),\n                    min(SDF_AXIS(yz), SDF_AXIS(xz)));\n#define SDF_EDGE(XX)   distance(mod(coord.XX+coord.XX + R3.XX, R3.XX+R3.XX), R3.XX)\n            axis = min(\n                    min(axis, SDF_EDGE(xy)),\n                    min(SDF_EDGE(yz), SDF_EDGE(zx)));\n        }\n    }\n\n#if PLOT_AVG\n\tif (n_c > 0.) {\n        c = log(max(1., c*c*10000.)/n_c)/15.;\n        //c += c*2.2/n_c;\n        //c = pow(c*20., 0.5)*1.5/n_c;\n    }\n#endif\n    //O.rgb = col(c + cmax);\n    O.rgb = col(cmax) + col2(c)/2.;\n    if (iMouse.z > 0.5) O.rgb = mix(O.rgb, vec3(1), smoothstep(1., 0., axis)/2.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        1     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n#define RAND            (hash13(uv3, iTime/10000.)-0.5)/100.\n//#define RAND            (hash13(uv3, iTime/10000.)-0.4-uv3.z*0.5)/100.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n//#define COORD (1.-pow(distance(vec3(0.5,0.5,0),uv3), 4.)/1.)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RANGE          5.\n#define BOUNDS         1   // 1 = cube  2 = cylinder  3 = sphere\n\nconst vec2 BUTTON_SZ = vec2(25, 12);\nconst vec2 BUTTON_ORIGIN = BUTTON_SZ + 1.;\n\n#define R2       iResolution\n#define T(P)     texelFetch(iChannel0, ivec2(I3to2(P, R3, R2.xy)), 0)\n#define PI       3.14159265359\n\n#define INIT1 \\\n    float d = clamp(distance(uv3, vec3(0.5))*2., 0., 1.); \\\n    O = vec4(pow(1. - d, 4.), 1. - pow(d, 10.), 0., 0.); \\\n//EOM\n#define INIT2 \\\n    float d = clamp(distance(uv3, vec3(0.5, 0.5, 0.))*2., 0., 1.); \\\n    O = vec4(pow(1. - d, 4.), 1. - pow(d, 10.), 0., 0.); \\\n//EOM\n\n#define INIT INIT2\n\n#if BOUNDS == 1\n#define OUT_OF_BOUND       any(lessThan(I3, vec3(1.0))) || any(greaterThan(I3, R3-vec3(2.0)))\n#elif BOUNDS == 2\n#define OUT_OF_BOUND       distance(uv3.xy, vec2(0.5)) >= (0.5-1./R3.x)\n#elif BOUNDS == 3\n#define OUT_OF_BOUND       distance(uv3, vec3(0.5)) >= (0.5-1./R3.x)\n#endif\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position, float iTime)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 position, float iTime)\n{\n    vec3 p3 = vec3(position) + iTime * 500. + 50.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Res2to3(in vec2 R2) {\n    return vec3(floor(pow(R2.x*R2.y, 1./3.)));  // 1200 / 80 = 13\n}\n\nvec2 I3to2(in vec3 I3, in vec3 R3, in vec2 R2) {\n    I3 = floor(clamp(I3, vec3(0), R3-1.));\n    float offset = I3.x + I3.y*R3.x + I3.z*R3.x*R3.y;\n    vec2 I2;\n    I2.x = mod(offset, R2.x);\n    I2.y = floor(offset/R2.x);\n    return I2;\n}\n\nvoid I2to3(out vec3 I3, in vec2 I, in vec3 R3, in vec2 R2) {\n    I = floor(I);\n    //I -= 0.5;\n    float offset = I.x + I.y*R2.x;\n    I3.x = mod(offset, R3.x);\n    I3.y = mod(floor(offset/R3.x), R3.y);\n    I3.z = min(floor(offset/R3.x/R3.y), R3.z-1.);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p ) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c,-s,s,c); }\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//#define RAND            (hash13(uv3, iTime/10010.)-0.5)/100.\n//#define RAND            (hash13(uv3, iTime/10010.)-0.3-distance(vec3(0.5,0.5,0),uv3)*1.2)/100.\n#define RAND            (hash13(uv3, iTime/10010.)-0.5+pow(1.-distance(vec3(0.5,0.5,0),uv3), 10.)/1.)/100.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime*1.15) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//#define RAND            (hash13(uv3, iTime/10020.)-0.5)/100.\n//#define RAND            (hash13(uv3, iTime/10020.)-0.2-distance(vec3(0.5,0.5,0),uv3)*1.5)/100.\n#define RAND            (hash13(uv3, iTime/10020.)-0.5+pow(1.-distance(vec3(0.5,0.5,0),uv3), 10.)/2.)/100.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime*1.25) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// (C) Copyright 2021-2023 by Yury Ershov\n\n#define LOOKUP_DIST     2     // 1 => 1; 2 => 2, no corners; 3 => 2 with corners.\n#define AVG_EVERY_N     0     // Average every THIS frame; 0 => none\n#define FLARE_UP        0     // Cause the fire to flare up\n#define SPEED           1.\n//https://graphtoy.com/?f1(x,t)=4&v1=false&f2(x,t)=pow(1-x,f1())&v2=true&f3(x,t)=pow(1-x,1/f1())&v3=true&f4(x,t)=1-pow(x,f1())&v4=true&f5(x,t)=1-pow(x,1/f1())&v5=true&f6(x,t)=&v6=true&grid=1&coords=0.5,0.5,0.6666666666666666\n//#define RAND            (hash13(uv3, iTime/10030.)-0.5)/100.\n#define RAND            (hash13(uv3, iTime/10030.)-0.4-uv3.z*1.0)/30.\n\n#if FLARE_UP\n#define COORD (1.-uv3.z)*SPEED\n#else\n#define COORD 1.*SPEED\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I2)\n{\n    vec3 I3, R3;\n    I2to3(I3, I2, R3 = Res2to3(R2.xy), R2.xy);\n    vec3 uv3 = I3 / R3;\n    if (OUT_OF_BOUND) { O=vec4(0.); return; }\n\n    float sdButton = sdBox(iMouse.xy -  BUTTON_ORIGIN, BUTTON_SZ);\n    if(iFrame < 2 || (iMouse.z > 0. && sdButton <= 0.)) {\n        INIT\n        return;\n    }\n\n    vec4 pt0 = texelFetch(iChannel0, ivec2(I2), 0);\n\n    if (hash13(uv3, iTime*1.35) > 0.05*COORD) {\n        O = pt0; // texture(iChannel0,uv);\n        return;\n    }\n\n    vec3 d = I3;\n    float v = pt0.y;\n    float vv; vec3 dd;\n#define TEST(DX, DY, DZ) \\\n    dd = I3 + vec3(DX, DY, DZ); \\\n    vv = T(dd).y; \\\n    if (vv > v) { v = vv; d = dd; } \\\n// EOM\n    TEST( 0., 0.,-1.);\n    TEST( 0., 0., 1.);\n    TEST(-1., 0., 0.);\n    TEST( 1., 0., 0.);\n    TEST( 0.,-1., 0.);\n    TEST( 0., 1., 0.);\n\n    TEST(-1., 1., 0.);\n    TEST( 1.,-1., 0.);\n    TEST(-1.,-1., 0.);\n    TEST( 1., 1., 0.);\n    TEST( 1., 0.,-1.);\n    TEST(-1., 0., 1.);\n    TEST(-1., 0.,-1.);\n    TEST( 1., 0., 1.);\n    TEST( 0.,-1.,-1.);\n    TEST( 0., 1., 1.);\n    TEST( 0., 1.,-1.);\n    TEST( 0.,-1., 1.);\n\n    TEST(-1.,-1.,-1.);\n    TEST( 1., 1., 1.);\n    TEST( 1., 1.,-1.);\n    TEST(-1.,-1., 1.);\n    TEST(-1., 1.,-1.);\n    TEST( 1.,-1., 1.);\n    TEST( 1.,-1.,-1.);\n    TEST(-1., 1., 1.);\n\n    float c = clamp(T(d).x + RAND, 0., 1.);\n    O = vec4(c, v+0.0001, 0., 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}