{
    "Shader": {
        "info": {
            "date": "1705404574",
            "description": "purely educational purposes",
            "flags": 0,
            "hasliked": 0,
            "id": "XcsXD4",
            "likes": 0,
            "name": "Newlinespaws",
            "published": 3,
            "tags": [
                "newlinespaws"
            ],
            "usePreview": 0,
            "username": "psaws",
            "viewed": 169
        },
        "renderpass": [
            {
                "code": "vec2 DirectionInvert(vec2 linePoint0, vec2 linePoint1)\n{\n    vec2 a = linePoint0;\n    vec2 b = linePoint1;\n    vec2 dir =(linePoint1 - linePoint0);\n    dir /= length(dir);\n   \n\n  vec2 result =vec2(dir.y, -dir.x);\n  return result;\n}\n\nfloat DrawLine(vec2 point, vec2 dir, vec2 uv, float dist)\n{\n    vec2 a = point;\n    vec2 b = point + dir * dist;\n    vec2 c = uv;\n\n  float result =  (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);\n  \n  return result / distance(a,b);\n}\n\nfloat DrawLine(vec2 linePoint0, vec2 linePoint1,vec2 uvPoint)\n{\n    vec2 a = linePoint0;\n    vec2 b = linePoint1;\n    vec2 c = uvPoint;\n\n  float result =  (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);\n  \n  return result  / distance(a,b);\n}\n\nfloat easeInExpo(float x) {\nreturn 1.0 - ( x == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * x))  ; \n}\n\nfloat DistanceToLine(vec2 point0, vec2 point1,vec2 point2)\n{\n   vec2 dir0 = point0 -point1;\n   dir0/= length(dir0);\n   vec2 dir1 = point0 -point2;\n   dir1/= length(dir1);\n   \n   float angle0 = tan(dir0).y/tan(dir0).y;  \n   float angle1 = tan(dir1).y/tan(dir1).y;\n   angle0 -= angle1;\n   vec2 newPoint = vec2(cos(0.9), sin(0.0)) * angle0;\n\n  \n    return newPoint.y;\n}\n\n///Poo rendering\n\nvec2 FadingLine(vec2 Point, float lineLength, float animationLoop, float offset)\n{\n    animationLoop = animationLoop * 2.0;\n    if(animationLoop > 1.0)\n    animationLoop =1.0;\n    vec2 currentPos = Point;\n    currentPos.x -= lineLength * animationLoop + offset;\n    return currentPos;\n}\n\nvec4 RenderPooLine(vec2 startPoint,vec4 fragColor, vec2 uv, float offset)\n{\n\n      float iTimeInt = float(int(iTime + offset)); \n      float pooAnimationLoop = (iTime + offset - iTimeInt) * 2.0;\n      float particleLength =1.0;\n      vec2 fadingPoint =FadingLine(startPoint, particleLength ,pooAnimationLoop,0.0);\n      \n       vec2 linePoint0 = fadingPoint - vec2(0.01,0);\n       vec2 linePoint1 = fadingPoint + vec2(0.01,0);\n    \n       float distanceTo0 = distance(uv,startPoint) / distance(startPoint, startPoint + vec2(-particleLength + 0.3, 0));  \n       \n        float colorCoeff = distanceTo0;\n        float colorCoeffInvert = (1.0 - distanceTo0) ;\n       \n        if(colorCoeff  > 1.0)\n        colorCoeffInvert= 0.0;\n       \n        vec4 targetColor = (vec4(fragColor.x * colorCoeff + colorCoeffInvert, fragColor.y * colorCoeff +  colorCoeffInvert,fragColor.z * colorCoeff + colorCoeffInvert,0) + fragColor)/ 2.0;\n  \n    \n        if(abs(DrawLine(linePoint0, linePoint1, uv)) < 0.01 && distance(fadingPoint, uv) < 0.1)\n              fragColor = targetColor; \n       return fragColor;\n}\n\n\nvec4 RenderAChunkOfPoo(vec4 fragColor, vec2 uv, vec2 Pos, float offset)\n{\n  fragColor =  RenderPooLine(Pos + vec2(0,0.01) ,  fragColor,  uv, 1.3+offset);\n  fragColor =  RenderPooLine(Pos + vec2(0,0.08) ,  fragColor,  uv, 1.2+offset);\n  fragColor =  RenderPooLine(Pos + vec2(0,0.06) ,  fragColor,  uv, 1.5 +offset);\n  fragColor =  RenderPooLine(Pos + vec2(0,0.04) ,  fragColor,  uv, 1.7+offset);\n  fragColor =  RenderPooLine(Pos + vec2(0,0.02) ,  fragColor,  uv, 1.1+offset);\n  fragColor =  RenderPooLine(Pos + vec2(0,0) ,  fragColor,  uv, 1.4+offset);\n  fragColor =  RenderPooLine(Pos +vec2(0,-0.02) ,  fragColor,  uv, 1.8+offset);\n  fragColor =  RenderPooLine(Pos +vec2(0,-0.02) ,  fragColor,  uv, 2.0+offset);\n  fragColor =  RenderPooLine(Pos +vec2(0,-0.04) ,  fragColor,  uv, 1.6+offset);\n  fragColor =  RenderPooLine(Pos +vec2(0,-0.06) ,  fragColor,  uv,1.7 +offset);\n  fragColor =  RenderPooLine(Pos +vec2(0,-0.08) ,  fragColor,  uv, 1.9+offset);\n   return fragColor;\n}\n\nvec4 RenderBigChunkOfPoo(vec4 fragColor, vec2 uv, vec2 Pos, float timeOffset)\n{\n  fragColor = RenderAChunkOfPoo(fragColor, uv,Pos+ vec2(0.0,0), timeOffset+.0);\n  fragColor = RenderAChunkOfPoo(fragColor, uv,Pos+ vec2(0.0,.05),timeOffset+-0.1);\n  fragColor = RenderAChunkOfPoo(fragColor, uv,Pos+ vec2(0.0,.05),timeOffset+0.1);\n  fragColor = RenderAChunkOfPoo(fragColor, uv,Pos+ vec2(0.0,-.05),timeOffset+-0.15);\n  fragColor = RenderAChunkOfPoo(fragColor, uv,Pos+ vec2(0.0,-.05),timeOffset+0.15);\n  return fragColor;\n}\n\nvec4 RenderPoo(vec4 fragColor, vec2 uv)\n{\n    // Particles rendering\n  \n  fragColor = RenderBigChunkOfPoo(fragColor, uv, vec2(1.2,0), 0.0);\n  fragColor = RenderBigChunkOfPoo(fragColor, uv, vec2(1.2,.05),-0.1);\n  fragColor = RenderBigChunkOfPoo(fragColor, uv, vec2(1.2,-.05),0.15);\n\n  \n  return fragColor;\n}\n\n\nfloat sqrPow(float f)\n{\n    return f*f;\n}\n\n///Poo rendering\n\n\n//CheecksRendering\n\n\n\nvec4 RenderCheeks(vec4 fragColor, vec2 uv, bool animate)\n{\n    vec2 cheeck0Position = vec2(1.5, 0.5);\n    vec2 cheeck1Position = vec2(1.5,-.5);\n    \n    float diffX0 = cheeck0Position.x-uv.x;\n    float diffY0 =( cheeck0Position.y-uv.y) ;\n     \n    float diffX1 = cheeck1Position.x-uv.x;\n    float diffY1 =( cheeck1Position.y-uv.y) ;\n   \n    float animation = 1.0;\n    if(animate)\n    animation= 1.0- cos(iTime*12.0) /6.0; \n   \n    \n    \n    float dist0 = sqrt(sqrPow(diffX0) / (animation) + sqrPow(diffY0) *(animation));\n        float dist1 = sqrt(sqrPow(diffX1) / (animation) + sqrPow(diffY1) *(animation));\n\n    float defDist =   0.6;\n if(dist0 <defDist)\n       fragColor =vec4(0);\n                  \n     \n if(dist1 < defDist)\n       fragColor =vec4(0);\n                  \n       \n    return fragColor;\n}\n//CheecksRendering\n\n/////////////////////////////////////////Add Cheecks Jiggling !!!!!\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 mouse = vec2( iMouse.x / iResolution.x,iMouse.y / iResolution.y) * 2.0 - 1.0;\n    mouse.x *=iResolution.x/iResolution.y;\n    float d = length(uv);\n\n     float animationSpeed = 4.0;\n     float animationLoop  = ((cos(iTime * animationSpeed) + 1.0) /2.0);\n      \n     vec3 col =vec3(1.0,0,.5);\n    float lineThickness = 0.1;\n    \n    fragColor = vec4(col,1.0);\n  \n    vec2 point0 = vec2(0,0);\n    \n    float dist = distance(mouse, point0);\n     vec2 dir = (point0 - mouse);\n     dir /= length(dir);\n     vec2 invertDir = DirectionInvert(point0, mouse);\n     \n\n       \n    if(abs(DrawLine(point0, dir,uv,dist)) < lineThickness && distance(mouse, uv) <= dist && distance(point0, uv) <= dist)\n        fragColor =vec4(0.0);   \n       \n       if(distance(uv, mouse) < 0.12)\n                  fragColor =vec4(1,.51,0,0);\n                  \n\n\n    float ballsRadius = 0.3;\n    vec2 ball0Position = vec2(0,.2);\n    vec2 ball1Position = vec2(0,-.2);\n    \n     if(distance(uv, ball0Position) < ballsRadius)\n       fragColor =vec4(0);\n                  \n    if(distance(uv, ball1Position) < ballsRadius)\n       fragColor =vec4(0);\n                  \n                  \n  //cheecks \n \n      bool onTarget =mouse.x > 1.2 && abs(mouse.y) < 0.1;     \n     if(onTarget)\n      fragColor = RenderPoo(fragColor, uv );\n    \n    fragColor = RenderCheeks(fragColor,uv,onTarget);    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}