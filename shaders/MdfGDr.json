{
    "Shader": {
        "info": {
            "date": "1367274822",
            "description": "I tried to see if I could make a more randomized distance field, but in the end I think this is a failure. It's too slow and not quite interesting enough. Feel free to steal it if you think you can come up with something better, though.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdfGDr",
            "likes": 18,
            "name": "Bubblefield.",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefield",
                "bubbles"
            ],
            "usePreview": 0,
            "username": "WAHa_06x36",
            "viewed": 1415
        },
        "renderpass": [
            {
                "code": "#define Iterations 64\n\nfloat rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nvec3 camera;\n\nfloat celldist(vec3 ipos,vec3 pos)\n{\n\tvec3 c=ipos+vec3(rand(ipos),rand(ipos+0.1),rand(ipos+0.2));\n\tfloat dist=length(c-pos);\n\tfloat radius=(rand(ipos+0.3)*0.3+0.2);\n\tfloat shrink=1.0-(1.0+cos(c.x))*(1.0+cos(c.y))*(1.0+cos(c.z))/8.0;\n\tfloat avoid=max(0.0,0.5-length(c-camera));\n\treturn dist-radius*shrink+avoid;\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 ipos=floor(pos)-0.5;\n\n\tfloat d1=celldist(ipos+vec3(0.0,0.0,0.0),pos);\n\tfloat d2=celldist(ipos+vec3(0.0,0.0,1.0),pos);\n\tfloat d3=celldist(ipos+vec3(0.0,1.0,0.0),pos);\n\tfloat d4=celldist(ipos+vec3(0.0,1.0,1.0),pos);\n\tfloat d5=celldist(ipos+vec3(1.0,0.0,0.0),pos);\n\tfloat d6=celldist(ipos+vec3(1.0,0.0,1.0),pos);\n\tfloat d7=celldist(ipos+vec3(1.0,1.0,0.0),pos);\n\tfloat d8=celldist(ipos+vec3(1.0,1.0,1.0),pos);\n\n\treturn min(0.5,min(min(min(d1,d2),min(d3,d4)),min(min(d5,d6),min(d7,d8))));\n}\n\nvec3 gradient(vec3 pos)\n{\n\tconst float eps=0.001;\n\tfloat mid=distfunc(pos);\n\treturn vec3(\n\tdistfunc(pos+vec3(eps,0.0,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,eps,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,0.0,eps))-mid);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float pi=3.141592;\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tvec3 ray_dir=normalize(vec3(coords,1.0));\n\tvec3 ray_pos=vec3(0.0,-3.0*iTime,0.0);\n\tcamera=ray_pos;\n\n\tfloat a=iTime/4.0;\n\tray_dir=ray_dir*mat3(\n\t\tcos(a),0.0,sin(a),\n\t\t0.0,1.0,0.0,\n\t\t-sin(a),0.0,cos(a)\n\t);\n\n\tfloat i=float(Iterations);\n\tfor(int j=0;j<Iterations;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*ray_dir;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n\n\tvec3 normal=normalize(gradient(ray_pos));\n\n\tfloat ao=1.0-i/float(Iterations);\n\tfloat what=pow(max(0.0,dot(normal,-ray_dir)),0.5);\n\t//float vignette=pow(1.0-length(coords),0.3);\n\tfloat light=ao*what*1.0;\n\n\tfloat z=length(ray_pos.xz);\n//\tvec3 col=(sin(vec3(z,z+pi/3.0,z+pi*2.0/3.0))+2.0)/3.0;\n\tvec3 col=exp(-vec3(z/5.0+0.1,z/30.0,z/10.0+0.1));\n\n\tvec3 reflected=reflect(ray_dir,normal);\n\tvec3 env=vec3(clamp(reflected.y*4.0,0.0,1.0));\n\n\tfragColor=vec4(col*light+0.1*env*ao,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}