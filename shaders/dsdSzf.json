{
    "Shader": {
        "info": {
            "date": "1713104018",
            "description": "Autobahn crossing as a 2D signed distance field",
            "flags": 0,
            "hasliked": 0,
            "id": "dsdSzf",
            "likes": 4,
            "name": "Autobahn",
            "published": 3,
            "tags": [
                "2dsdf"
            ],
            "usePreview": 0,
            "username": "cfrezksa",
            "viewed": 104
        },
        "renderpass": [
            {
                "code": "\n#define LANEWIDTH 0.1\n#define LANESEP 0.02\n#define DIRSEP 0.01\n\n#define N (32.0)\n#define R (0.3)\nfloat dLine( vec2 p, vec2 a, vec2 b )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec2 qspline(vec2 p0, vec2 p1, vec2 p2, float t) {\n    float t0 = (1.0-t);\n    return t0*t0 * p0 + 2.0 * t *t0 * p1 + t*t*p2;\n}\n\nvec2 cspline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float t0 = (1.0-t);\n    vec2 q = t0 * t0 * t0 * p0;\n    q += 3.0 * t * t0* t0 * p1;\n    q += 3.0 * t * t * t0 * p2;\n    q += t * t * t * p3;\n    return q;\n}\n\n\nfloat dqspline(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n    float d = 100000.0;\n    vec2 a = p0;\n    for(float i = 1.0; i < N; i+= 1.0) {\n        vec2 b = qspline(p0, p1, p2, i / (N-1.0));\n        d = min(d, dLine(uv, a,b));\n        a = b;\n    }\n    return d;\n}\n\nfloat dcspline(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    float d = 100000.0;\n    vec2 a = p0;\n    for(float i = 1.0; i < N; i+= 1.0) {\n        vec2 b = cspline(p0, p1, p2, p3, i / (N-1.0));\n        d = min(d, dLine(uv, a,b));\n        a = b;\n    }\n    return d;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTurnLane(vec2 uv, vec2 x0, vec2 dir0, vec2 dir1) {\n\n    float lw2 =LANEWIDTH/2.0;\n\n    vec2 m0 = normalize(x0);\n    vec2 m01 = dir1 * sign(dot(dir1,m0));\n    float cosA = dot(m0, m01);\n    float sinA = sqrt(1.0 - cosA*cosA);\n    \n    vec2 cc = x0 + m0 *  R / sinA;\n    float circle0 = length(uv-cc) - R - lw2;\n    float circle1 = length(uv-cc) - R + lw2;\n    \n    float a = R * cosA/sinA;\n    vec2 p0 = x0 + dir0 * a;\n    vec2 p1 = x0 + dir1 * a;\n   \n    float d1 = sdTriangle(uv, cc, 100.0 * (p0 - cc) + cc, 100.0 * (p1 - cc) + cc);\n    float turn = max(-circle1, max(circle0, -d1));\n    float lineA = sdCapsule(uv, 2.0 *(x0-p0)+p0, p0, lw2);\n    float lineB = sdCapsule(uv, 2.0 *(x0-p1)+p1, p1, lw2);\n    \n    float d = min(min(lineA, lineB), turn);\n    //float d = turn;\n    vec2 dirM = normalize(dir0 + dir1);\n    vec2 tp = cc + dirM * (R + LANESEP + LANEWIDTH);\n    float td = length(tp - x0);\n    float R2 = td *sinA/(1.0-sinA);\n    vec2 c2 = tp + dirM * R2;\n    \n    float cL = length(c2 - uv)-R2 - lw2;\n    float cS = length(c2 - uv)-R2 + lw2;\n    float b = R2 * cosA/sinA;\n    vec2 q0 = x0 + dir0 * b;\n    vec2 q1 = x0 + dir1 * b;\n    float clip = sdTriangle(uv, c2, 100.0 * (q0-c2)+c2, 100.0 * (q1-c2)+c2);\n    float crim = max(max(cL, -cS), clip);\n    d = min(d, crim);\n    d = min(d, sdCapsule(uv, q0, q0 + 10.0 * dir0, lw2));\n    d = min(d, sdCapsule(uv, q1, q1 + 10.0 * dir1, lw2));\n    return d;\n}\n\n\nvec4 dTurnLanes(vec2 uv, vec2 dirA, vec2 dirB) {\n\n    vec2 dirM = normalize(dirA + dirB);\n    float rw = 3.0 * LANESEP + 2.5 * LANEWIDTH;\n\n    float cosPhi = dot(dirA, dirM);\n    float sinPhi = sqrt(1.0 - cosPhi * cosPhi);\n    \n    vec2 corner = dirM * rw / sinPhi;\n    float d = sdTurnLane(uv, corner, dirA, dirB);\n    \n    float d0 = 1.0 -smoothstep(-0.02, 0.00, d);\n    \n    return vec4(d0,0,d0, d);\n}\n\nvec4 allTurnLanes(vec2 uv, vec2 d0, vec2 d1) {\n\n    float cosA = dot(d0,d1);\n    vec4 road0 = dTurnLanes(uv, d0, -d1);\n    vec4 road1 = dTurnLanes(uv,-d1,-d0);\n    vec4 road2 = dTurnLanes(uv,-d0, d1);\n    vec4 road3 = dTurnLanes(uv, d1, d0);\n    float r = min(min(road0.w, road1.w), min(road2.w, road3.w));\n    float s0 = smoothstep(0.0,-LANESEP,r);\n    vec3 col = mix(vec3(1.0), vec3(0.7), s0);\n    return vec4(col,r);\n\n}\n\nvec4 dLanes(vec2 uv, vec2 dirA) {\n\n    vec2 pA = 10.0 * dirA;\n    vec2 roA = vec2(dirA.y, -dirA.x);\n    float rw = DIRSEP + 2.0 * LANESEP + 2.0 * LANEWIDTH;\n    \n    float r = sdCapsule(uv, pA, -pA, rw);\n    \n    float s0 = smoothstep(0.0,-LANESEP,r);\n    float s1 = smoothstep(-rw/2.0-LANESEP, -rw/2.0, r);\n    float s2 = smoothstep(-rw/2.0+LANESEP, -rw/2.0, r);\n    float s3 = smoothstep(-rw+DIRSEP/2.0, -rw+DIRSEP/2.0+0.004, r);\n    vec3 col = mix(vec3(1), vec3(0.7), s0 * s3* (1.0-s1*s2));\n    return vec4(col,r);\n    \n}\n\nvec3 image(vec2 uv) {\n    \n    float t0 = 0.1231 * iTime + 0.32;\n    float t1 = t0 + (0.8 + 0.2 * sin(iTime)) * 3.1415/2.0;\n    vec2 dir0 = vec2(cos(t0),sin(t0));\n    vec2 dir1 = vec2(cos(t1),sin(t1));\n    \n    vec4 d0 = allTurnLanes(uv, dir0, dir1);\n    float a0 = smoothstep(0.01,0.0, d0.w);\n    //return mix(vec3(0),d0.rgb, a0);\n    \n    vec4 d1 = dLanes(uv, dir0);\n    float a1 = smoothstep(0.01,0.0, d1.w);\n    \n    vec4 d2 = dLanes(uv, dir1);\n    float a2 = smoothstep(0.01,0.0, d2.w);\n    \n    vec3 c2 = mix(vec3(0), vec3(0.8*d2.rgb),a2);\n    vec3 c0 = mix(c2, vec3(0.9*d0.rgb), a0);\n   \n    return mix(c0, vec3(d1.rgb), a1);\n    //return vec3(a2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy/2.0;\n    vec2 uv = (fragCoord - center) / min(center.x, center.y);\n    \n    // Output to screen\n    fragColor = vec4(image(2.0 * uv),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}