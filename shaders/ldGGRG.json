{
    "Shader": {
        "info": {
            "date": "1454988540",
            "description": "Experimenting with bergi's Interactive Evolutionary Framework but probably a bad example since there is no smooth transition between types. They are hypercomplex fractals Z=Z*Z+C where each has its own multiplication table.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldGGRG",
            "likes": 48,
            "name": "toggle evolution",
            "published": 3,
            "tags": [
                "fail",
                "evolutioninchunks"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 1995
        },
        "renderpass": [
            {
                "code": "//toggle evolution by eiffie (a kind of failed use bergi's interactive evolution)\n\n//framework taken from interactive evolution by bergi https://www.shadertoy.com/view/XdyGWw\n\n/*  Interactive Evolutionary Framework\n\n    (c) 0x7e Stefan Berke\n   \tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tVersion 0.1\n*/\n\n//#define SHOW_MORE_TYPES\n#define AA 0\t\t\t\t\t\t// anti-aliasing > 1\nconst int NUM_PARAM_ROWS = 1;\t\t// Number of rows of parameters for one 'tile'\nconst int NUM_TILES = 4;\t\t\t// Number of 'tiles' per screen height\n\nint cur_tile; // (initialized in main)\n\n// returns the parameters for the current 'tile' \nvec4 parameter(in int column, in int row) \n{ \n    vec2 uv = (vec2(column, row + cur_tile * NUM_PARAM_ROWS)+.5) / iResolution.xy;\n    return (texture(iChannel0, uv) - .5) * 4.;\n    // some slight varying in time\n    //    + 0.006 * sin(float(column) + iTime) * vec4(1., -1., -1., 1.);\n    //    ;    \n}\n// wrapper, if you don't use rows\nvec4 parameter(in int column) { return parameter(column, 0); }\n\n// 8<---------8<---------8<--------8<--\n// plug in your favorite algorithm here\n// and use the parameter function above\n\n//here is eiffie stuff (hypercomplex fractals with the signs coming from parameters)\nvec4 p1,p2,p3;//the parameters\nfloat DE(vec3 z0){\n\tvec4 Z=vec4(z0,0.0),C = Z;\n\tfloat dr = 1.0,r = length(Z);\n\tif(p3.z<0.0){Z.xyzw=Z.wzyx;C.xyzw=C.wzyx;}\n\tif(p3.w<0.0){Z.ywxz=Z.wyzx;C.ywxz=C.wyzx;}\n\tfor (int n = 0; n < 6; n++) {\n\t\tif(r>2.0)break;\n\t\tdr = dr * r * 2.0 + 1.0;\n\t\tvec4 zz=Z*Z,zs=2.0*Z*Z.yzwx;//like a mandelbrot Z=Z*Z+C in 4D\n\t\tvec2 zss=2.0*Z.xy*Z.zw;\n#ifdef SHOW_MORE_TYPES\n        vec4 p4=parameter(3);\n        if(p4.w<-0.5){\n        \tif(p4.x<0.0){vec2 t=zz.zw;zz.zw=zs.zw;zs.zw=t;}\n        \tif(p4.y<0.0){vec2 t=zz.xy;zz.xy=zs.xy;zs.xy=t;}\n        \tif(p4.z<0.0){vec2 t=zz.xz;zz.xz=zss;zss=t;}\n        }\n#endif\n\t\tZ=vec4(dot(p1,zz),dot(p2.xz,zs.xz),dot(p3.xy,zss),dot(p2.yw,zs.yw))+C;//just applying the signs\n\t\tr = length(Z);\n\t}\n\treturn 0.5 * log(r) * r / dr;\n}\n\nfloat rand(vec2 c){return fract(sin(dot(c*423.143,vec2(13.235,121.23)))*2342.45);}\n/* uv is in [-1, 1] */\nvec3 theImage(in vec2 uv)\n{\n\tuv=-uv.yx;//may favorite fractal was on its side\n\tp1=sign(parameter(0));p2=sign(parameter(1));p3=sign(parameter(2));//just toggle switches\n\tvec3 ro=vec3(0.0,0.0,-4.0),rd=normalize(vec3(uv,2.0));\n\tfloat tim=iTime*0.2+float(cur_tile);\n\tmat2 mx=mat2(cos(tim),-sin(tim),sin(tim),cos(tim));\n\tro.xz=ro.xz*mx*mx;rd.xz=rd.xz*mx*mx;\n\tro.xy=ro.xy*mx;rd.xy=rd.xy*mx;\n\tfloat t=2.0+DE(ro+rd*2.0)*0.1,d,od=1.0,px=0.002;\n\tvec4 e=vec4(0.0);\n\tfor(int i=0;i<64;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<px*t && e.w==0.0)e=vec4(t-d,e.xyz);\n\t\tod=d;\n\t\tif(d<0.00001 || t>6.0)break;\n\t}\n\tvec3 col=vec3(1.0),L=normalize(vec3(0.4,-0.7,-0.6));L.xz=L.xz*mx*mx;L.xy=L.xy*mx;\n\tfor(int i=0;i<4;i++){//I can't make these little bugs look good\n\t\tif(e.x==0.0)break;\n\t\tvec3 so=ro+rd*e.x;\n\t\tvec2 v=vec2(0.01,0.0);\n\t\tvec3 N=normalize(vec3(DE(so+v.xyy)-DE(so-v.xyy),DE(so+v.yxy)-DE(so-v.yxy),DE(so+v.yyx)-DE(so-v.yyx)));\n\t\tif(N!=N)N=-rd;\n\t\tfloat dif=0.1+0.6*dot(N,L);\n\t\tcol=mix(vec3(dif),col,clamp(DE(so)/(px*e.x),0.0,1.0));\n\t\te=e.yzwx;\n\t}\n\treturn col.rgb;\n}\n\n// 8<---------8<---------8<--------8<--\n\n#define BLUR 0.1\nfloat segment(vec2 uv){//from Andre https://www.shadertoy.com/view/Xsy3zG\n\tuv = abs(uv);return (1.0-smoothstep(0.07-BLUR,0.07+BLUR,uv.x)) * (1.0-smoothstep(0.46-BLUR,0.46+BLUR,uv.y+uv.x)) ;//* (1.25 - length(uv*vec2(3.8,1.3)))\n\t//uv = abs(uv);return (1.0-smoothstep(udef[6]-udef[8],udef[6]+udef[8],uv.x)) * (1.0-smoothstep(udef[7]-udef[8],udef[7]+udef[8],uv.y+uv.x)) ;//* (1.25 - length(uv*vec2(3.8,1.3)))\n}\nfloat sevenSegment(vec2 uv,int num){\n\tuv=(uv-0.5)*vec2(1.5,2.2);\n\tfloat seg=0.0;if(num>=2 && num!=7 || num==-2)seg+=segment(uv.yx);\n\tif (num==0 || (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):(uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))seg += segment(abs(uv)-0.5); \n\tif (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))seg += segment(vec2(abs(uv.y)-1.0,uv.x)); \n\treturn seg;\n}\n//prints a \"num\" filling the \"rect\" with \"spaces\" # of digits including minus sign\nfloat formatNum(vec2 uv, vec2 rect, float num, int spaces){//only good up to 6 spaces!\n\tuv/=rect;if(uv.x<0.0 || uv.y<0.0 || uv.x>1.0 || uv.y>1.0)return 0.0;\n\tuv.x*=float(spaces);\n\tfloat place=floor(uv.x);\n\tif(num<0.0){if(place==0.0)return segment((uv.yx-0.5)*vec2(2.2,1.5));else {num=-num;place-=1.0;uv.x-=1.0;spaces-=1;}}\n\tfloat decpnt=floor(max(log(num)/log(10.0),0.0));//how many digits before the decimal place\n\tif(decpnt==0.0 && num<1.0){place+=1.0;uv.x+=1.0;spaces+=1;}\n\tfloat period=(decpnt==float(spaces-1)?0.0:1.0-smoothstep(0.06-BLUR/2.,0.06+BLUR/2.,length(uv-vec2(decpnt+1.0,0.1))));\n\tuv.x=fract(uv.x);\n\tnum+=0.000001*pow(10.,decpnt);\n\tnum /= pow(10.,decpnt-place);\n\tnum = mod(floor(num),10.0);\n\treturn period+sevenSegment(uv,int(num));\n}\n\n//x=sel_tile, y=last mouse z\nvec4 state(){\n    float maxRow=floor(float(NUM_PARAM_ROWS*NUM_TILES*NUM_TILES)*iResolution.x/iResolution.y)+float(NUM_PARAM_ROWS*NUM_TILES);\n    return texture(iChannel0,vec2(0.5,maxRow+0.5)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // reset dot\n    if (uv.x < 0.05 && uv.y >= 0.95)\n    {\n        fragColor = vec4(1., 0., 0., 1.);\n    }\n    else\n    { \n        int sel_tile=int(state().x+0.1);\n        \n        // determine the rendered tile index\n        cur_tile = int(uv.y * float(NUM_TILES))\n                 + int(uv.x * float(NUM_TILES)) * NUM_TILES;\n\n        // get per-tile uv\n        float width = iResolution.y / float(NUM_TILES);\n        vec2 tileuv = vec2(mod(fragCoord.x, width), mod(fragCoord.y, width)) \n                        / iResolution.y * float(NUM_TILES) * 2.  - 1.;\n\n        if(iMouse.z>0.0){//left mouse down so show full view\n\t\t\ttileuv=(uv-0.5)*2.0;cur_tile=sel_tile;\n\t\t}\n#if AA <= 1\n\t\tvec3 col = theImage(tileuv);\n#else\n        vec2 sc = vec2(2.) / width / float(AA);\n        vec3 col = vec3(0.);\n        for (int j=0; j<AA; ++j)\n        for (int i=0; i<AA; ++i)\n        {\n            col += theImage(tileuv + sc * vec2(float(i), float(j)));\n        }\n        col /= float(AA * AA);\n#endif\n        \n        // vignette\n        col *= 1. - pow(max(abs(tileuv.x), abs(tileuv.y)), 20.);\n        col=clamp(col,0.0,1.0);\n        if(iMouse.z>0.0){//left mouse down - print params\n\t\t\tuv.x-=1.1;uv.y-=0.9;\n\t\t\tvec2 rc=vec2(0.1,0.05);\n\t\t\tfloat f=0.0;\n\t\t\tfor(int i=0;i<4;i++){//this doesn't need to be a loop fragCoord.y tells you which to print\n\t\t\t\tf+=formatNum(uv, rc, p1.x, 4);uv.y+=0.06;\n\t\t\t\tf+=formatNum(uv, rc, p2.x, 4);uv.y+=0.06;\n\t\t\t\tf+=formatNum(uv, rc, p3.x, 4);uv.y+=0.06;\n\t\t\t\tp1=p1.yzwx;p2=p2.yzwx;p3=p3.yzwx;\n\t\t\t}\n\t\t\tcol+=vec3(f);\n\t\t}\n        fragColor = vec4(col, 1.);\n    }\n\n    //fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//interactive evolution by bergi https://www.shadertoy.com/view/XdyGWw\n\n/* Interactive Evolutionary Framework\n\n   This buffer renders a set of parameters and applies mutation on mouse-click\n*/\n\nconst int NUM_PARAM_ROWS = 1;\t\t// Number of rows of parameters for one 'tile'\nconst int NUM_TILES = 4;\t\t\t// Number of 'tiles' per screen height\nconst float MUTATION_PROB = .95;\t\t// Probability of mutating one parameter\nconst float MUTATION_AMT = 0.5; \t// Maximum amount of mutation +/-\n\n// scales mutation amount by distance to clicked tile\n#define DO_SCALE\n\n\n\n// hashes by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n// uniform random vec4 [-1,1]\n// (this is not state-of-the-art hashing)\nvec4 rndVec(in vec2 seed)\n{\n    return vec4(hash(seed), hash(seed+.1), hash(seed+.2), hash(seed+.3)) * 2. - 1.;\n}\n\n\n// returns the parameters for the given 'tile' \nvec4 parameter(in int column, in int row, in int cur_tile) \n{ \n    vec2 uv = (vec2(column, row + cur_tile * NUM_PARAM_ROWS)+.5) / iResolution.xy;\n    return (texture(iChannel0, uv) - .5) * 4.;    \n}\n\n\n// sets random parameters\nvoid reset(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 seed = fragCoord + iDate.zw; \n    fragColor = .5 + .25 * rndVec(seed);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tfloat maxRow=floor(float(NUM_PARAM_ROWS*NUM_TILES*NUM_TILES)*iResolution.x/iResolution.y)+float(NUM_PARAM_ROWS*NUM_TILES);\n    if(fragCoord.y>maxRow+1.)discard;\n         \n    //x=sel_tile, y=last mouse z\n    vec4 state=texture(iChannel0,vec2(0.5,maxRow+0.5)/iResolution.xy);\n    \n    // init parameters\n    if (iFrame < 2)\n    {\n        reset(fragColor, fragCoord);\n    }\n\telse if (iMouse.z > 0. && state.y<=0.)\n    {\n        vec2 muv = iMouse.xy / iResolution.y;\n        \n        // clicked on reset-square?\n        if (muv.x < 0.05 && muv.y >= 0.95)\n        {\n            reset(fragColor, fragCoord);\n        }\n        else\n        {\n            // find 'tile' that was clicked\n            float width = iResolution.y / float(NUM_TILES);\n            int sel_tile = int(iMouse.y / width)\n                         + int(iMouse.x / width) * NUM_TILES;\n            //set state\n            if(fragCoord.y>=maxRow){fragColor=vec4(sel_tile,iMouse.z,0.0,1.0);return;}\n            \n            // init random mutation \n            vec2 seed = fragCoord + iDate.zw;\n            vec4 mutate = vec4(0.);\n\n            // don't mutate clicked tile\n            if (int(fragCoord.y) / NUM_PARAM_ROWS != sel_tile)\n            {\n#ifdef DO_SCALE\n                // scale mutation amount by tile distance\n\t\t\t\tfloat amt = clamp( abs(float(sel_tile) - fragCoord.y / float(NUM_PARAM_ROWS))\n                    \t\t\t   / float(NUM_TILES * NUM_TILES), 0.1, 1.);\n#else\n                float amt = 1.;\n#endif\n            \t// mutate with probability\n            \tif (hash(seed*0.12345) < MUTATION_PROB * max(.5, amt))\n                \tmutate = MUTATION_AMT * amt * rndVec(seed);\n            }\n            \n            // copy weights from 'sel_tile' slot to all others + mutation\n            fragColor = .5 + .25 * parameter(int(fragCoord.x), \n                                             int(mod(fragCoord.y, float(NUM_PARAM_ROWS))), \n                                             sel_tile)\n                        + mutate;\n        }\n    }\n    else\n    {\n        // simply copy previous frame \n    \tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n        if(fragCoord.y>=maxRow){fragColor.y=iMouse.z;}//state\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}