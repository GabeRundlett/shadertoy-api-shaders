{
    "Shader": {
        "info": {
            "date": "1510701971",
            "description": "Control the spot with mouse. \nWe take N radiographies around the sceen.\nTo reconstruct the data, we backproject each projection in the volume.\nThis gives a blurry reconstruction, but since we know its impulse response it can be deconvolved.\n(optimizable!)",
            "flags": 0,
            "hasliked": 0,
            "id": "XtXBRn",
            "likes": 9,
            "name": "tomography setup",
            "published": 3,
            "tags": [
                "demo",
                "loopless",
                "scanner",
                "reconstruction",
                "backprojection"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 824
        },
        "renderpass": [
            {
                "code": "const float N = 9.;   vec2 R;\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))     // rotation\n#define S(v)   smoothstep( 3./R.y, 0., v )            // for antialiasing\n\nvec4 proj(vec2 U, vec2 P, float N, float I) {         // --- draw a projection screen\n    vec4 O = vec4(0);\n    float r = 3.14/N*.85, t = mod(iTime,4.);\n    O += S(abs(U.y-.9)) * S(abs(U.x)-r);                                   // screen\n    O += S(abs(U.y-.9)-.02) * S(abs(mod(U.x,2.*r/N)-r/N)) * S(abs(U.x)-r); // ticks\n    if (t>2.) O.r += S(length(vec2(P.x,.9)-U)-.03);                        // pulse projection\n    P -= U;\n    if (t>1.) \n      t < 3.  \n        ? O.rg += 2.*I * S(abs(P.x)) * S(P.y)                              // measure ray\n        : O.gb += I * sqrt(max(0.,1.-P.x*P.x*1e3)) * S(-U.y-.7) * S(U.y-1.); // recons backproj\n\n    return O;\n}\n             \nvoid mainImage( out vec4 O, vec2 U )\n{\n\tR = iResolution.xy;\n    vec2 P = iMouse.xy, U0;                             // P: pulse position (mouse-controled)\n    if (length(P)<10.) P = .5*R + .12*R.y* vec2( cos(iTime), sin(1.3*iTime) );\n    U = ( U+U - R ) / R.y;\n    P = ( P+P - R ) / R.y;\n\tO -= O; \n    O.r += S(length(P-U)-.03);                        // draw pulse\n    U0 = U + vec2(1.4,0);\n    \n    for (float i=0.; i<N; i++) {                      // --- draw projs & reconstruction\n        O += proj(U, P,N, .3);                        //    projection\n        O += proj(U0,P,N, 0.);                        //    sinogram slice\n        U *= rot( 6.28/N);\n        P *= rot( 6.28/N);\n        U0.y += 1./N;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}