{
    "Shader": {
        "info": {
            "date": "1621593919",
            "description": "A better physics engine based on https://en.m.wikipedia.org/wiki/Collision_response#  and many shadertoy inputs\n",
            "flags": 32,
            "hasliked": 0,
            "id": "slXGRH",
            "likes": 42,
            "name": "Shadertoy 2021",
            "published": 3,
            "tags": [
                "sdf",
                "physics",
                "pbr",
                "rigidbody",
                "impulse"
            ],
            "usePreview": 1,
            "username": "iapafoto",
            "viewed": 744
        },
        "renderpass": [
            {
                "code": "//-----------------------------------------------------\n// Created by sebastien durand - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n// [PMalin]         Shader Rally             - https://www.shadertoy.com/view/XdcGWS\n// [ThomasSchander] Interactive Bunny Physics- https://www.shadertoy.com/view/XlfyzN\n// [iq]             Capsule - soft shadow    - https://www.shadertoy.com/view/MlGczG\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [Shane]          Desert Canyon            - https://www.shadertoy.com/view/Xs33Df\n//-----------------------------------------------------\n\n\n#define WITH_AO\n\n// -----------------------------------------------------------\n\nconst vec3 light = normalize( vec3(-.4, .3, -1.5) );\nconst float dstFar = 200.;\n\nvec3 vnBall;\nint idBall;\n\nint[] txt = int[] (83,104,97,100,101,114,0);\n\nfloat sample_dist_gaussian(vec2 uv) {\n    const int nstep = 3;\n    const float w[3] = float[3](1., 2., 1.);\n    float d, wij, dsum = 0., wsum = 0.;    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            vec2 delta = vec2(float(i-1), float(j-1))/1024.;\n            d = textureLod(iChannel3, uv-delta, 0.).w - 127./255.;\n            wij = w[i]*w[j];\n            dsum += wij * d;\n            wsum += wij;\n        }\n    }\n    return dsum / wsum;\n}\n\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), sample_dist_gaussian(uv));\n}\n\n\n//----------------------------------------------------------\n// Adapted from\n//  [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\n//----------------------------------------------------------\nfloat sdMessage(vec2 p, int[7] text, int start, float scale, float bold, float italic) { // --- to alter in the icon with the alter message\n    p /= scale;\n    p.x += p.y*italic;\n    float d = 9999.;\n    for (int i=min(iFrame,0)+start; i<text.length(); i++) { // COompile time 2s [Thanks iq :)]   \n        if (text[i] == 0) break;\n        d = min(d, sdFont(p, text[i]));\n        p.x-=.5;\n\n    }\n    return d*scale - bold;\n}\n\n\n// +-------------------------------------+\n// |         Geometric tools             |\n// +-------------------------------------+\n\n// Distance to point\nfloat dista(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n// dean_the_code - Inception totem - https://www.shadertoy.com/view/wl3czM\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nfloat n11(float p) {\n\tfloat ip = floor(p);\n\tp = fract(p);\n\tvec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n\treturn mix(h.x, h.y, p * p * (3. - 2. * p));\n}\n\nfloat wood(vec2 p) {\n\tp.x *= 71.;\n\tp.y *= 1.9;\n\treturn n11(n21(p) * 30.);\n}\n\nvec3 woodColor(vec3 p) {\n    return mix(mix(vec3(.17, .1, .05), vec3(.08, .05, .03), wood(p.xz)), vec3(.5, .4, .2) * .4, .3 * wood(p.xz * .2));\n}\n\n//-------------------------------------------------------------------------------------------\n// Capsules related functions\n//-------------------------------------------------------------------------------------------\n// [iq] Capsule - soft shadow - https://www.shadertoy.com/view/MlGczG\n//-------------------------------------------------------------------------------------------\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k ) {\n    vec3 ba =  b - a, oa = ro - a;\n    // closest distance between ray and segment\n\tfloat oad  = dot( oa, rd ), dba  = dot( rd, ba ),\n\t\t  baba = dot( ba, ba ), oaba = dot( oa, ba );\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\tth.x = max(   th.x, .0001 );\n\tth.y = clamp( th.y, .0, 1. );\n\tvec3  p =  a + ba*th.y, q = ro + rd*th.x;\n    float d = length( p-q )-r;\n    // fake shadow\n    float s = clamp( k*d/th.x, 0., 1. );\n    return s*s*(3.-2.*s);\n}\n\n// Intersection avec la mine\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb ) {\n    vec3  ba = pb - pa, oa = ro - pa;\n    float m0 = dot(ba,ba), m1 = dot(oa,ba)*.942, m3 = dot(rd,ba)*.942,\n          m4 = dot(rd,oa), m5 = dot(oa,oa),\n          rr = ra - rb,\n          hy = m0 + rr*rr,   \n          k2 = m0*m0    - m3*m3*hy,\n          k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.),\n          k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2. - m0*ra),\n          h = k1*k1 - k2*k0;\n    if( h<0. ) return vec4(-1);\n    float t = (-k1-sqrt(h))/k2;\n    float y = m1 + t*m3;\n    return y>0. && y<m0 ?\n            vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y)) :\n            vec4(-1);\n}\n\n\n// compute normal\nvec3 capNormal(in vec3 pos, in vec3 a, in vec3 b, in float r ) {\n    vec3  ba = b - a, pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return (pa - h*ba)/r;\n}\n\n// intersect capsule\nvec4 capIntersect( in vec3 ro, in vec3 rd, in vec3 pa0, in vec3 pb0, in float r ) {\n    vec3  n = normalize(pb0 - pa0);\n    vec3  pa = pa0 + n*.12, pb = pb0;\n    vec3  ba = pb - pa, oa = ro - pa;\n    float baba = dot(ba,ba), bard = dot(ba,rd),\n    \t  baoa = dot(ba,oa), rdoa = dot(rd,oa), oaoa = dot(oa,oa);\n    float a = baba - bard*bard,\n          b = baba*rdoa - baoa*bard,\n          c = baba*oaoa - baoa*baoa - r*r*baba,\n          h = b*b - a*c;          \n    if( h>=0.) {\n        float t = (-b-sqrt(h))/a,\n              y = baoa + t*bard;\n        // body\n        if (y>0. && y<baba) return vec4(t, capNormal(ro+rd*t, pa0, pb0, r));\n        // caps\n        if (y>0.) {\n            vec3 oc = y<=0. ? oa : ro - pb;\n            b = dot(rd,oc);\n            h = b*b - dot(oc,oc) + r*r;\n            if (h>0.) {\n                t = -b - sqrt(h);\n                return vec4(t, capNormal(ro+rd*t, pa0, pb0, r));\n            }\n        } else {\n            return iCappedCone(ro, rd, pa, pa0-n*.1, r, r*.65);\n        }\n    }\n    return vec4(-1);\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r ) {\n    vec3 ba = b - a, pa = p - a,\n         d = pa - ba * clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    float l = length(d), o = 1. - max(0.,dot(-d,n))*r*r/(l*l*l);\n    return o;\n}\n\nfloat occlusion(in vec3 pos, in vec3 nor ) {\n\tfloat res = 1.;\n    float r = 0.;\n    vec3 p=vec3(0), p0=vec3(0), p1=vec3(0);\n    for (int n =min(iFrame,0); n<NB_BODY; n++) {\n        loadBSphere(iChannel0, n, p, r);\n        if (distance(pos, p) < 1.5*r) {\n            loadBodyPosFromC(iChannel0, n, p, p0, p1, r);\n            res *= capOcclusion(pos, nor, p0, p1, r);  \n        }\n    }\n    return res;\t\t\t\t\t  \n}\n\nfloat PencilHit(vec3 ro, vec3 rd, float maxDist) {\n    vec4 d;\n    float dMin = maxDist;\n\tfloat res = 1.;\n    float r = 0.;\n    vec3 nor=vec3(0),p=vec3(0), p0=vec3(0), p1=vec3(0);\n    for (int n =min(iFrame,0); n<NB_BODY; n++) {\n        loadBSphere(iChannel0, n, p, r);\n        if (dista(ro,rd,p) < r) {\n            loadBodyPosFromC(iChannel0, n, p, p0, p1, r);\n            d = capIntersect(ro, rd, p0, p1, r);\n            if (d.x > 0. && d.x < dMin) {\n                dMin = d.x;\n                vnBall = d.yzw;\n                idBall = n;\n            }\n        }\n    }\n    return dMin;\n}\n\n\n// +--------------------------------+\n// |          Rendering             |\n// +--------------------------------+\n\n// iq- Palettes - https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 rainbow(float x) {\n    return sqrt(pal( x, vec3(.5),vec3(.5),vec3(1),vec3(0.0,0.33,0.67) ));\n}\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps;             \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in int id, in float dis ) {    \n    // Color\n    vec3 col;\n    float kspe = 2.;\n    if (id<0) {\n         col = pow(2.*woodColor(.1*pos),vec3(.5));\n         nor = doBumpMap(iChannel1, vec3(.3,.3,.3)*pos, nor, .003);\n    } else {\n        Body body = loadBody(iChannel0, id);\n        vec3 uvw  = worldPtToBody(body, pos);\n        float zstart = uvw.z + body.h_2;\n        float zend = uvw.z - body.h_2-.08;\n        vec3 col0 = rainbow(mod(float(id)*.101,1.));\n        col = col0;\n        if (uvw.y > 0.) {\n            float dTxt = sdMessage(uvw.zx+vec2(body.h_2-.28,.02), txt, 0, .14, 0., -.3);\n            col = mix(col, vec3(0), .8*smoothstep(.005,.0, abs(dTxt-.008)-.0025)); \n        }\n        col = mix(col, sqrt(.43+2.*woodColor(.5*uvw)), smoothstep(.0,.02, zend+.2));        \n        col *= .4 + .6* smoothstep(.10,.11, abs(zstart-.07));    \n        col *= .2+.8*smoothstep(.0,.01, abs(zstart-.2)-.005);    \n        col *= .2+.8*smoothstep(.0,.01, zstart+.05);    \n        col *= .9+.1*(wood(.5*uvw.yz) + wood(.5*uvw.xz));\n\n        // mine\n        float end = mix(.055,.095, hash(float(id)))-.03;\n        col = mix(col, pow(col0,vec3(1.2)), smoothstep(.0,.01, zend + end ));    \n        col = mix(col, vec3(0),.2*smoothstep(.02,.0, abs(zend + end)+.005 ));    \n        // todo specularity\n        if (zend < -.2) {\n            nor = doBumpMap(iChannel2, .3*uvw, nor, .0005);\n            kspe = 2.;\n        } else {\n            kspe = .5;\n        }\n    }\n    \n#ifdef WITH_AO\n    float occ = occlusion( pos, nor );\n    occ = occ*.5 + .5*occ*occ;\n#else\n    float occ = 1.f;\n#endif\n    vec3  ref = reflect(rd,nor);\n    float dif = max( dot( light, nor ), 0.), // Diffuse term.\n    \t  spe = pow(max(dot( reflect(-light, nor), -rd ), 0.), 29.), // Specular term.\n    \t  fre = clamp(1. + dot(rd, nor), 0., 1.); \n    float Schlick = pow( 1. - max(dot(rd, normalize(rd + light)), 0.), 5.);\n    float fre2 = mix(.2, 1., Schlick);\n    // Overal global ambience.\n    float amb = .6*fre*fre2 + .2*occ;\n    float h = dot(pos,vec3(127.1,311.7,758.5453123));\t\n    return (col*(dif + .1) + fre2*spe*kspe)*occ + amb*col;\n}    \n\n// Render scene using raytracing (to save gpu)\nvec4 ShowScene (vec3 ro, vec3 rd, vec3 backColor) {\n    // Intersection with ground\n    float dMin = -ro.y/rd.y;\n    idBall = -2;\n    vnBall = vec3(0,1,0);        \n    // Intersection with pencils\n    float d = PencilHit(ro, rd, dMin);\n    // Shading\n    return vec4(shade(rd, ro + d*rd, vnBall, idBall, d), d);\n}\n\n\n// Create camera base matrix\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n    cr = .1*cos(.11*iTime);\n\tvec3 w = normalize(ta-ro),\n\t \t p = vec3(0., cos(cr), -sin(cr)),\n         u = normalize( cross(w,p) ),\n         v = normalize( cross(u,w) );\n    return mat3(u,v,w);\n}\n\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord) {\n    vnBall=vec3(0,1,0);\n    idBall=-1;;\n\n\n    // Normalize pixels\n    vec2 canvas = iResolution.xy,\n         uv = 2. * fragCoord.xy/canvas - 1.;\n    uv.x *= canvas.x / canvas.y;\n    \n\t// Camera      \n    float gAnim = mod(iTime,35.);\n\n    // Distance\n    float camDist;\n    camDist = mix(3.5,4.5, smoothstep(9.,11.,gAnim));\n    camDist = mix(camDist,6., smoothstep(17.,23.,gAnim));\n    camDist = mix(camDist,3.5, smoothstep(34.,35.,gAnim));\n    \n    // Target\n    vec3 ta = vec3(-.25,.2,.5);\n    \n    // Camera position\n    vec3 a = mix(vec3(cos(.5*iTime), .6, sin(.5*iTime)), vec3(1,.5,1), smoothstep(1.,0.,iTime)); \n    vec3 ro = ta + mix(5.,mix(10.,20.,smoothstep(30.,60.,iTime)),.75+.5*sin(-1.5+.1*iTime))*a;\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 1.);\n    \n    // current ray direction\n    vec3 rd = ca * normalize( vec3(uv.xy, 4.5) );\n\n    // Background color\n    vec2 q = fragCoord.xy/canvas;\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453123));\t\n\tvec3 backColor = vec3(.2) + .05*fract(sin(h)*43758.5453123);\n    \n    // Render scene (xyz = color, w = distance)\n    vec4 result = ShowScene (ro, rd, backColor);\n    \n    // Post traitment\n   \tvec3 col = pow(1.2*result.xyz,vec3(.6));\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .5);\n        \n    fragColor = vec4(col, result.w);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord, iChannel0, iFrame, iTimeDelta*.4);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define PI 3.141592653589\n\n#define NB_BODY 300\n\n#define NB_STEP 5.\n#define DT0 .006\n#define DT (DT0/NB_STEP)\n\n\n#define DENSITY_WOOD    350. // wood   kg/m³\n#define DENSITY_WOOD2   700. // wood   kg/m³  // little hack for big DT\n#define DENSITY_WATER   997. // water  kg/m³\n#define DENSITY_MARBLE 2650. // marble kg/m³\n#define DENSITY_STEEL  7860. // acier  kg/m³\n\n\n#define SPHERE 0.\n#define CAPS   1.\n\n#define SIZEOF_BODY 6\n\n\n#define txRow 256\n\n\n#define fAccel_MpS   -9.81   // meter per seconds\n\n#define FLOOR_RESTITUTION_COEFF   .2\n#define PENCIL_RESTITUTION_COEFF  .5\n\n// Friction\n// https://en.m.wikipedia.org/wiki/Friction\n#define staticFrictionPencil  .25   // must be > dynamic  \n#define dynamicFrictionPencil .2 \n\n#define staticFrictionFloor  .35   // must be > dynamic\n#define dynamicFrictionFloor .32  \n\n#define MAX_IMPULSE 1000.\n#define MAX_VEL 100.\n#define MAX_AVEL 100.\n\n\nfloat hash(float h) {\n    return fract(sin(h)*43758.5453123);\n}\n\n\n// project vector on plane\nvec3 projVecOnPlane(vec3 u, vec3 n) {\n    return u - dot(u,n)*n;\n}\n\n// project point on plane\nvec3 projPtOnPlane(vec3 p, vec3 pPlane, vec3 nPlane) {\n    return pPlane + projVecOnPlane(p-pPlane, nPlane) ;\n}\n\n// add thickness\nbool removeThickness(float e0, float e1, inout vec3 out0, inout vec3 out1, inout vec3 n) {\n    float d = length(out0 - out1);\n    n = normalize(out1 - out0);\n    out0 += e0*n;\n    out1 -= e1*n;\n    return d < e0+e1;\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between two segments\n//---------------------------------------------------------\nvoid closestSegmentSegment(vec3 p00, vec3 p01, vec3 p10, vec3 p11, inout vec3 inout0, inout vec3 inout1) {\n    vec3   u = p01 - p00, v = p11 - p10, w = p00 - p10;\n    float  a = dot(u,u), b = dot(u,v), c = dot(v,v),\n           k0, k1, k = a*c - b*b;\n    if (k < 1e-6) { \n        // the lines are almost parallel\n        k0 = dot(u,p10-p00) / a;\n        k1 = dot(u,p11-p00) / a;\n             if (max(k1,k0)<0.) { inout0 = p00; inout1 = k1>k0 ? p11 : p10;}\n        else if (min(k1,k0)>1.) { inout0 = p01; inout1 = k1>k0 ? p10 : p11;}\n        else { inout0 = p00 + u * clamp(k1, 0., 1.);\n               inout1 = inout0 + (p10 - (p00 + k0*u)); \n        }\n        return;\n    } else {\n        float e = dot(v,w), d = dot(u,w); \n        k0 = b*e - c*d;\n        k1 = k0 > k ? (e+b)/c : k0 < 0. ? e/c : (a*e - b*d)/k;\n        k0 = k1 < 0. ? -d/a : k1 > 1. ? (b-d)/a : clamp(k0/k, 0., 1.);\n    }\n    inout0 = p00 + u * clamp(k0, 0., 1.);\n    inout1 = p10 + v * clamp(k1, 0., 1.);\n}\n\n//---------------------------------------------------------\n// Find the closest points between two caps\n//---------------------------------------------------------\n\nbool closestCapsCaps(vec3 p00, vec3 p01, float e0, vec3 p10, vec3 p11, float e1, inout vec3 inout0, inout vec3 inout1, inout vec3 n) {\n    closestSegmentSegment(p00, p01, p10, p11, inout0, inout1);\n    return removeThickness(e0, e1, inout0, inout1, n);\n}\n\nbool closestCapsPlane(vec3 p1Line, vec3 p2Line, float ep, vec3 pPlane0, vec3 nPlane, inout vec3 out0, inout vec3 out1, inout vec3 n) {\n //   closestSegmentPlane(p1Line, p2Line, pPlane-nPlane*10., nPlane, out0, out1);\n    vec3 rd = normalize(p2Line - p1Line),\n         pdk, pPlane = pPlane0 - nPlane*10.;\n    float a = dot(rd, nPlane),\n          d = -(dot(p1Line, nPlane)-dot(nPlane,pPlane))/a;\n    // Just project sommets of line on plane and select the closest\n    vec3 p1OnPlane = projPtOnPlane(p1Line, pPlane, nPlane),\n         p2OnPlane = projPtOnPlane(p2Line, pPlane, nPlane);   \n    if (distance(p1Line, p1OnPlane) < 10. && distance(p2Line, p2OnPlane) < 10.) {\n        out0 = (p1Line+p2Line)*.5;\n        out1 =projPtOnPlane(out0, pPlane, nPlane);\n    } else if (distance(p1Line, p1OnPlane) < distance(p2Line, p2OnPlane)) {\n        out0 = p1Line;\n        out1 = p1OnPlane;\n    } else {\n        out0 = p2Line;\n        out1 = p2OnPlane;\n    }\n    return removeThickness(ep, 10., out0, out1, n);\n}\n\n//---------------------------------------------------------\n/*\nvec4 QuatMul(vec4 a, vec4 b) {\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n*/\n\nvec4 QuatMul (vec4 q1, vec4 q2) {\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 QuatFromVec3( vec3 vRot ) {\n    float l = length( vRot );\n    return l <= 0. ? vec4(0,0,0,1) : vec4(vRot * sin(l) / l, cos(l));\n}\n\n\n// PMalin\nmat3 QuatToMat3(vec4 q ) {\n\tvec4 s = q * q;\n\tfloat xy = q.x * q.y * 2.,\n          xz = q.x * q.z * 2.,\n          yz = q.y * q.z * 2.,\n          wx = q.w * q.x * 2.,\n          wy = q.w * q.y * 2.,\n          wz = q.w * q.z * 2.;\n\treturn mat3( \n\t\t s.w+s.x-s.y-s.z, xy-wz,           xz+wy,\n\t\t xy+wz,           s.w-s.x+s.y-s.z, yz-wx,\n\t\t xz-wy,           yz+wx,           s.w-s.x-s.y+s.z);\n}\n\n// r: m\n// h: m\n// density: kg/m³\nfloat massCaps(float r, float h, float density) {\n    float vcy = h*r*r*PI,        // volume cylinder m³\n          vhs = 4.*r*r*r*PI/3.;  // volume sphere m³\n    return (vhs + vcy) * density; // masse \n}\n\nfloat massSphere(float r, float density) {\n    float v = 4.*r*r*r*PI/3.;  // volume sphere m³\n    return v * density; // masse \n}\n\n// https://www.gamedev.net/tutorials/programming/math-and-physics/capsule-inertia-tensor-r3856/\nmat3 inverseInertiaTensorCaps(float r, float h, float density) {\n    float vcy = PI*h*r*r,       // volume cylinder\n          vhs = 4.*r*r*r*PI/3., // volume sphere\n          mcy = density*vcy, mhs = density*vhs; // masses des elements\n    float ix = mcy*(3.*r*r + h*h)/12. + mhs*(r*r*.4 + h*h*.25 + 3.*h*r/8.),\n          iz = mcy*r*r*.5             + mhs*(r*r*.4);\n\treturn mat3(1./ix,0,0, 0,1./ix,0, 0,0,1./iz);\n}\n\n// for sphere Rayon: meter, Density: kg/m³\nmat3 inverseInertiaTensorSphere(float r, float density) {\n    float v = 4.*r*r*r*PI/3.; // m³\n    float m = v*density;      // kg\n    float it = 5./(2.*m*r*r); \n\treturn mat3(it,0,0,  0,it,0, 0,0,it);\n}\n\n\n// --------------------------------------------------\n//                Load Save Datas\n// --------------------------------------------------\nvec4 Loadv4(sampler2D txBuf, int fi) {\n  return texelFetch(txBuf, ivec2(fi%txRow, fi/txRow),0);\n}\n\nvec3 Loadv3(sampler2D txBuf, int fi) {\n  return texelFetch(txBuf, ivec2(fi%txRow, fi/txRow),0).xyz;\n}\n\nvoid Savev4(int fi, vec4 val, inout vec4 fCol, vec2 fCoord) {\n  vec2 d = abs(fCoord - vec2(fi%txRow, fi/txRow) - .5);\n  if (max(d.x, d.y) < .5) fCol = val;\n}\n\nvoid Savev3(int fi, vec3 val, inout vec4 fCol, vec2 fCoord) {\n  vec2 d = abs(fCoord - vec2(fi%txRow, fi/txRow) - .5);\n  if (max(d.x, d.y) < .5) fCol = vec4(val,1);\n}\n\n\n// ---------------------------\n// Mecanic Body\n// PMalin - https://www.shadertoy.com/view/XdcGWS\n// ---------------------------\nstruct Body {\n    // Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    float h_2; // half length meter\n    float r;   // radius meter\n    float type;\n    float density; // km/m³\n  // Derived\n    mat3 mRot;\n    // Constant\n    mat3 invI;  // inverse inertia tensor 1./kg·m2\n    float invM; // 1/kg\n    // Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\n\nvoid finalizeBody(inout Body body) {\n\t// Calculate \n\tbody.mRot = QuatToMat3(body.qRot);\n    if (body.type == SPHERE) {\n        body.invM = 1./massSphere(body.r, body.density);\n        body.invI = inverseInertiaTensorSphere(body.r, body.density);\n    } else {\n        // fake r on intertia tensor gives better results!\n        body.invM = 1./massCaps(body.r, 2.*body.h_2, DENSITY_WOOD); \n        body.invI = inverseInertiaTensorCaps(2.*body.r, 2.*body.h_2, DENSITY_WOOD);\n    }\n    // invI in world coordinates\n    body.invI = transpose(body.mRot) * body.invI * body.mRot;\n}\n\nBody loadBody(sampler2D txBuf, int idBody) {\n    int p = idBody*SIZEOF_BODY;\n    Body body;\t\n    vec4 bSphere          = Loadv4(txBuf, p+0);\n    body.vPos             = bSphere.xyz;\n    body.qRot             = Loadv4(txBuf, p+1);\n    body.vMomentum        = Loadv3(txBuf, p+2);\n    body.vAngularMomentum = Loadv3(txBuf, p+3);\n    vec4 geom             = Loadv4(txBuf, p+4);\n    body.h_2 = geom.x;\n    body.r = geom.y;\n    body.type = geom.z;\n    body.density = DENSITY_WOOD;\n    finalizeBody(body);\n    return body;\n}\n\n\nvoid loadBodyPos(sampler2D txBuf, int idBody, inout vec3 pos1, inout vec3 pos2, inout float r) {\n    int p = idBody*SIZEOF_BODY;\n    vec4 pc = Loadv4(txBuf, p+0),\n         pe = Loadv4(txBuf, p+5);\n    r = pe.w;\n    pos1 = pe.xyz;\n    pos2 = 2.*pc.xyz - pos1;\n}\n\nvoid loadBSphere(sampler2D txBuf, int idBody, inout vec3 c, inout float r) {\n    vec4 pc = Loadv4(txBuf, idBody*SIZEOF_BODY);\n    r = pc.w;\n    c = pc.xyz;\n}\n\nvoid loadBodyPosFromC(sampler2D txBuf, int idBody, vec3 pc, inout vec3 pos1, inout vec3 pos2, inout float r) {\n    vec4 pe = Loadv4(txBuf, idBody*SIZEOF_BODY + 5);\n    r = pe.w;\n    pos1 = pe.xyz;\n    pos2 = 2.*pc.xyz - pos1;\n}\n\nvoid saveBody(int idBody, Body body, inout vec4 fc, in vec2 uv) {\n    int p = idBody*SIZEOF_BODY;\n    float rbSph = body.h_2 + body.r;\n    Savev4(p+0, vec4(body.vPos, rbSph),fc, uv);  // gives bounding sphere \n    Savev4(p+1, body.qRot,             fc, uv); \n    Savev3(p+2, body.vMomentum,        fc, uv);\n    Savev3(p+3, body.vAngularMomentum, fc, uv);\n    Savev4(p+4, vec4(body.h_2, body.r, body.type, body.density),  fc, uv);\n    Savev4(p+5, vec4(body.vPos + vec3(0,0,body.h_2)*body.mRot, body.r), fc, uv);\n}\n\n// Accessor\nvec3 getAngularVelocityWorld(Body body) {\n    return body.vAngularMomentum*body.invI;\n}\n\nvec3 BodyPointVelocity(Body body, vec3 vWorldPos ) {\n    vec3 vVel = body.vMomentum * body.invM;\n    vec3 vAngVel = getAngularVelocityWorld(body);\n    return vVel + cross(vAngVel, vWorldPos - body.vPos);\n}\n\nvec3 bodyPtToWorld(Body body, vec3 pt) {\n    return body.vPos + pt*body.mRot;       \n}\n\nvec3 worldPtToBody(Body body, vec3 pt) {\n    return body.mRot*(pt-body.vPos);       \n}\n\nvoid BodyIntegrate(inout Body body, float dt ) {\n    body.vMomentum += body.vForce * dt; \n    body.vAngularMomentum += body.vTorque*dt;\n    \n    vec3 vVel = body.vMomentum * body.invM;\n    vec3 vAngVel = getAngularVelocityWorld(body);\n    \n    if (length(vVel) > MAX_VEL) {\n        vVel = normalize(vVel)*MAX_VEL;\n    }\n    if (length(vAngVel) > MAX_AVEL) {\n        vAngVel = normalize(vAngVel)*MAX_AVEL;\n    }\n    body.vPos += vVel * dt;\n    vec4 qAngDelta = QuatFromVec3(vAngVel * dt);\n    body.qRot = normalize(QuatMul(qAngDelta, body.qRot));\n    body.mRot = QuatToMat3(body.qRot);  // update rot\n    body.vMomentum *= pow(.91,10.*DT);\n    body.vAngularMomentum *= pow(.93,10.*DT); \n}\n\nvoid BodyResetForFrame(inout Body body ) {\n    body.vForce = body.vTorque = vec3(0);\n}\n\nvoid BodyApplyForce(inout Body body, vec3 vPos, vec3 vForce) {    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);   \n}\n\nvoid BodyApplyImpulse(inout Body body, vec3 vPos, vec3 vImpulse) {    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);    \n}\n\n\nvec3 getCoulombFriction(Body body, vec3 vr, vec3 n, float jr, float sf, float df) {\n    vec3 t = vec3(0);\n    if (abs(dot(vr,n)) > 1e-4) {\n        t = normalize(projVecOnPlane(vr, n));\n    } else if (abs(dot(body.vForce,n)) > 1e-4) {\n        t = normalize(projVecOnPlane(body.vForce, n));\n    }\n    if (length(t) >0.) {\n        float js = sf * abs(jr),\n              jd = df * abs(jr), \n              jf = -jd;\n        if (abs(dot(vr,t)) < 1e-4 && dot(vr/body.invM,t) <= js) {\n            jf = -dot(vr/body.invM,t);\n        }\n        return t*min(jf, MAX_IMPULSE);\n    }\n    return vec3(0);\n}\n\n\n        \n        \n// https://en.m.wikipedia.org/wiki/Collision_response#\n#define VEPS 1e-3\nvoid mainLoop( inout vec4 fragColor, in vec2 fragCoord , sampler2D txBuf, int frameId, float dt) {\n    \n    vec2 iFrag = floor(fragCoord); \n    int bodyId = int((iFrag.y*256.) + iFrag.x)/SIZEOF_BODY;\n    \n    if (bodyId>NB_BODY) {\n        fragColor = vec4(0);\n\n    } else {\n    \n        Body body;\n\n        if (frameId < 30) {\n        // ------------------------------\n        // initialisation\n        // ------------------------------\n            body.vPos = vec3( .5+hash(43.6*float(bodyId)), 1.+mix(32.,6.,smoothstep(10.,40.,float(bodyId)))*float(bodyId), .5-hash(4.6*float(bodyId)) );\n            body.vMomentum = vec3( 0 );\n            body.qRot = normalize(vec4(hash(41.6*float(bodyId)),hash(1.27*float(bodyId)),hash(float(bodyId)), 1 ));\n            body.vAngularMomentum = vec3( .25, 3, .25 );  \n            body.h_2 = (.9+.45*cos(float(bodyId)));\n            body.r = .12;\n            body.type = CAPS;\n            body.density = DENSITY_WOOD;\n            finalizeBody(body);\n\n        } else {\n            body = loadBody(txBuf, bodyId);\n          \n            // The coefficient of restitution e       \n            float e = 0.5;\n            // normal at contact point\n  \n            for (float st=0.; st<NB_STEP; st++) { \n                 \n                BodyResetForFrame(body);\n                // Add gravity force\n                body.vForce.y += fAccel_MpS/body.invM;\n\n                vec3 p00 = bodyPtToWorld(body, vec3(0,0, body.h_2)),\n                     p01 = bodyPtToWorld(body, vec3(0,0,-body.h_2));\n                float r0 = body.h_2+body.r;\n                // contact with others\n                e = PENCIL_RESTITUTION_COEFF;\n                vec3 c = vec3(0);\n                vec3 p10 = vec3(0), p11 = vec3(0); \n                vec3 n = vec3(0,1,0), inout0 = vec3(0), inout1 = vec3(0);\n                float r = 0.;\n\n                for(int id = min(0,frameId); id<NB_BODY; id++) {\n                    if (id == bodyId) continue; // self\n\n                    loadBSphere(txBuf, id, c, r);\n                    if (distance(c,body.vPos) < r0+r) {\n\n                        loadBodyPosFromC(txBuf, id, c, p10, p11, r);\n        // ------------------------------\n        // contact with other pencils\n        // ------------------------------\n                        if (closestCapsCaps(p00, p01, body.r, p10, p11, r, inout0, inout1, n)) {\n                            // Intersection : on charge completement la shape \n                            Body body2 = loadBody(txBuf, id);\n                            //vec3 pContact = (inout0 + inout1) *.5;\n                            // Caps are in contact\n                            vec3 vp1 = BodyPointVelocity(body,  inout0),\n                                 vp2 = BodyPointVelocity(body2, inout1),\n                                 r1 = inout0 - body.vPos,  // offset of the shared contact point from the centre of mass\n                                 r2 = inout1 - body2.vPos, // offset of the shared contact point from the centre of mass\n                                 vr = vp1-vp2;\n                            float vrn = dot(vr,n);\n                            if (vrn < VEPS) { \n                               // moving away\n                            } else if (vrn < -VEPS) { \n                               // resting contact\n                            } else if (vrn > 0.) { \n                                // collision impulse magnitude jr\n                                float jr = -(1.+e)*vrn / \n                                           (body.invM + body2.invM + dot(\n                                               body .invI*cross(cross(r1,n),r1) + \n                                               body2.invI*cross(cross(r2,n),r2), n));\n                                vec3 impulse = max(jr, -MAX_IMPULSE)*n;\n                                BodyApplyImpulse(body, inout0, impulse); \n\n                                // Coulomb friction\n                                vec3 jft = getCoulombFriction(body, vr, n, jr, staticFrictionPencil, dynamicFrictionPencil);\n                                if (length(jft) > 0.) {\n                                    BodyApplyImpulse(body, inout0, jft);\n                                }\n                            }\n                            body.vPos -= .5*n*length(inout0-inout1);\n                        }\n                    }\n                }\n// ------------------------------\n// contact with ground\n// ------------------------------\n                // The coefficient of restitution e       \n                e = FLOOR_RESTITUTION_COEFF;\n                float maxPenetration = 0.;\n            \n                n = vec3(0, 1, 0);\n            \n                if (closestCapsPlane(p00, p01, body.r, vec3(0), n, inout0, inout1, n)) {\n                    vec3 vr = BodyPointVelocity(body, inout0),\n                         r1 = inout0 - body.vPos;\n                    float vrn = dot(vr,n);\n                    if(vrn > VEPS) { // if moving into the surface             \n                        float jr = -(1.+e)*vrn / \n                                   (body.invM + dot(body.invI*cross(cross(r1,n),r1), n));\n                        vec3 impulse = max(jr, -MAX_IMPULSE)*n;\n                        BodyApplyImpulse(body, inout0, impulse); \n\n                        // Coulomb friction\n                        vec3 jft = getCoulombFriction(body, vr, n, jr, staticFrictionFloor, dynamicFrictionFloor);\n                        if (length(jft) > 0.) {\n                            BodyApplyImpulse(body, inout0, jft);\n                        }\n                    }\n                    body.vPos -= n*length(inout0-inout1);\n                }\n\n                BodyIntegrate(body, DT); //min(dt,DT));\n            }\n\n        }\n        \n        saveBody(bodyId, body, fragColor, fragCoord);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord , iChannel0, iFrame, iTimeDelta*.54);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord , iChannel0, iFrame, iTimeDelta*.4);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord , iChannel0, iFrame, iTimeDelta*.4);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}