{
    "Shader": {
        "info": {
            "date": "1543945974",
            "description": "improved ballpoint sketch - now also realtime in fragment shader\nold non realtime here [url]https://www.shadertoy.com/view/ldtcWS[/url]\npress rewind if video not running at start.\ndon't forget to enable mipmaps if you change video texture (in Buffer A)",
            "flags": 32,
            "hasliked": 0,
            "id": "XlKBzc",
            "likes": 82,
            "name": "ballpoint sketch frag",
            "published": 3,
            "tags": [
                "effect",
                "ballpoint"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 2879
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// old non realtime verison: https://www.shadertoy.com/view/ldtcWS\n// realtime with geomtry version: https://www.shaderoo.org/?shader=yMP3J7\n// this one is derived from the above, but includes some improvements \n// to work on different detail scalings in content\n\n// some particles (the actual ballpoint tips)\n\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n#define Res3 vec2(textureSize(iChannel3,0))\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres = vec2(textureSize(iChannel1,0));\n    vec4 r=texture(iChannel1,pos/tres/sqrt(iResolution.x/600.)*vec2(1,1));\n    return r;\n}\n\nvec4 getCol(vec2 pos, float lod)\n{\n    vec2 tres = Res2;\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res.xy)*min(tres.y/Res.y,tres.x/Res.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n    //vec2 mask = step(vec2(-.5),-abs(uv-.5));\n    return textureLod(iChannel2,uv,lod)/**mask.x*mask.y*/;\n}\n\nvec4 getCol2(vec2 pos, float lod)\n{\n    vec2 tres = Res2;\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res.xy)*min(tres.y/Res.y,tres.x/Res.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n    //vec2 mask = step(vec2(-.5),-abs(uv-.5));\n    return textureLod(iChannel2,uv,lod)/**mask.x*mask.y*/;\n}\n\nfloat paperBump(vec2 c)\n{\n    return (texture(iChannel0,c/Res,.7).x\n          \t+ 4.*texture(iChannel0,c/Res,2.5).x\n    \t\t+16.*texture(iChannel0,c/Res,4.5).x\n    \t\t+64.*texture(iChannel0,c/Res,6.5).x)/20.;\n}\n\nvec2 paperBumpG(vec2 c)\n{\n    vec2 g=vec2(0);\n    vec2 d=vec2(.8,0);\n\tg+=vec2( texture(iChannel0,(c-d.xy*1.)/Res,.8).x-texture(iChannel0,(c+d.xy*1.)/Res,.8).x,\n       \t     texture(iChannel0,(c-d.yx*1.)/Res,.8).x-texture(iChannel0,(c+d.yx*1.)/Res,.8).x );\n\tg+=vec2( texture(iChannel0,(c-d.xy*4.)/Res,2.8).x-texture(iChannel0,(c+d.xy*4.)/Res,2.8).x,\n       \t     texture(iChannel0,(c-d.yx*4.)/Res,2.8).x-texture(iChannel0,(c+d.yx*4.)/Res,2.8).x );\n\tg+=vec2( texture(iChannel0,(c-d.xy*16.)/Res,4.8).x-texture(iChannel0,(c+d.xy*16.)/Res,4.8).x,\n       \t     texture(iChannel0,(c-d.yx*16.)/Res,4.8).x-texture(iChannel0,(c+d.yx*16.)/Res,4.8).x );\n\tg+=vec2( texture(iChannel0,(c-d.xy*64.)/Res,6.8).x-texture(iChannel0,(c+d.xy*64.)/Res,6.8).x,\n       \t     texture(iChannel0,(c-d.yx*64.)/Res,6.8).x-texture(iChannel0,(c+d.yx*64.)/Res,6.8).x );\n    return g/20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec4 r = getRand(fragCoord*1.3)-.5;\n    vec4 r = getRand(fragCoord*1.1)-getRand(fragCoord*1.1+vec2(1,-1)*1.5);\n    vec4 r2 = getRand(fragCoord*.015)-.5+getRand(fragCoord*.008)-.5;\n    vec4 c = 1.-.3*texture(iChannel0,fragCoord/iResolution.xy,0.);\n    //float s=sin(fragCoord.y/iResolution.y*3.1416*15.);\n    //c-=.15*exp(-s*s*300.);\n\tfloat paperbump = paperBump(fragCoord);\n    //vec2 n = -vec2(dFdx(paperbump),dFdy(paperbump));\n    vec2 n = paperBumpG(fragCoord);\n    float paper = .95+2.*(dot(n,vec2(1,-1)));\n    vec2 s=sin((fragCoord)*.1/sqrt(iResolution.y/400.));\n    fragColor = c*paper*(.95+.06*r.x-.0*r2.x);\n    //fragColor = c;\n    vec2 sc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.-.3*dot(sc,sc);\n    //vign-=dot(exp(-sin(fragCoord/iResolution.xy*3.14)*vec2(20,10)),vec2(1,1));\n    vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*40.);\n    vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*20.);\n    fragColor *= vign;\n    \n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// precomputing detail, gradient\n\n#define PI2 6.28318530718\n#define CS(x) cos(x-vec2(0,PI2/4.))\n#define N(v) (v.yx*vec2(-1,1))\n#define ROT2(x) mat2(CS(x),N(CS(x)))\n#define MAP2PI(ang) ((ang<PI2/2.)?PI2-ang:ang)\n\n//#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n\n\nuniform float SrcContrast;\nuniform float SrcBright;\n\nvec4 getRand(vec2 pos)\n{\n    return textureLod(iChannel1,pos/Res1,0.);\n}\n\nvec4 getRand(int idx)\n{\n    ivec2 rres=textureSize(iChannel1,0);\n    idx=idx%(rres.x*rres.y);\n    return texelFetch(iChannel1,ivec2(idx%rres.x,idx/rres.x),0);\n}\n\nvec4 getCol(vec2 pos, float lod)\n{\n    vec2 tres = Res0;\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res2)*min(tres.y/Res2.y,tres.x/Res2.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n    vec4 bg=textureLod(iChannel3,uv+.0*sin(iTime*vec2(1,.7)+vec2(0,1.6)),lod).xxxx*.5+.2;\n    //bg=vec4(0,0,0,1);\n    vec4 fg=textureLod(iChannel0,uv,lod);\n    return mix(fg,bg,dot(fg.xyz,vec3(-.7,1.4,-.7)));\n}\n\nfloat getVal(vec2 pos)\n{\n    return dot(getCol(pos,0.).xyz,vec3(1)/3.);\n}\n\nvec3 getValCol(vec2 pos, float lod)\n{\n    return getCol(pos,lod).xyz;\n}\n\nfloat compsignedmax(vec3 c)\n{\n    vec3 s=sign(c);\n    vec3 a=abs(c);\n    if (a.x>a.y && a.x>a.z) return c.x;\n    if (a.y>a.x && a.y>a.z) return c.y;\n    return c.z;\n}\n\nvec2 getGradMax(vec2 pos, float eps, float lod)\n{\n    eps*=Res2.x/Res0.x*pow(2.,lod);\n    vec2 d=vec2(eps,0);\n    //float lod = log2(2.*eps*Res0.x/Res.x);\n    //lod=0.;\n    return vec2(\n        compsignedmax(getValCol(pos+d.xy,lod)-getValCol(pos-d.xy,lod)),\n        compsignedmax(getValCol(pos+d.yx,lod)-getValCol(pos-d.yx,lod))\n        )/eps/2.;\n}\n\nvec2 getGradBr(vec2 pos, float eps, float lod)\n{\n    eps*=Res2.x/Res0.x*pow(2.,lod);\n    vec2 d=vec2(eps,0);\n    //float lod = log2(2.*eps*Res0.x/Res.x);\n    //lod=0.;\n    return vec2(\n        dot(getValCol(pos+d.xy,lod)-getValCol(pos-d.xy,lod),vec3(.333)),\n        dot(getValCol(pos+d.yx,lod)-getValCol(pos-d.yx,lod),vec3(.333))\n        )/eps/2.;\n}\n\nvec2 getGrad(vec2 pos, float eps, float lod) \n{\n    return getGradMax(pos,eps,lod);\n}\n\nfloat getDetail(vec2 pos, float lod)\n{\n    float d = \n    (length(getGrad(pos,1.,lod-.5))\n    -length(getGrad(pos,1.,lod+.5)))*Res2.x/600.*pow(2.,lod);\n    return d;\n    return smoothstep(.04,.05,d)*.25;\n}\n\nfloat quant(float x, float num)\n{\n    return floor(x*(num-.0001))/(num-1.);\n}\n\nfloat getDetailAll(vec2 pos)\n{\n    float d = 0.\n    +getDetail(pos,0.)\n    +getDetail(pos,1.)\n    +getDetail(pos,2.)\n    +getDetail(pos,3.)\n    +getDetail(pos,4.)\n    +getDetail(pos,5.)\n    //+getDetail(pos,6.)\n    ;\n    return d;\n}\n\nfloat getCurl(vec2 pos, float eps)\n{\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec2 g = getGrad(pos,1.4,0.);\n    float curl = getCurl(pos,1.4);\n    float detail = getDetailAll(pos);\n    fragColor = vec4(g,detail,curl);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ballpoint line drawing\n\n// calculating and drawing drawing line segments\n\n#define XNUM 100\n#define YNUM 70\n#define Res (iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define SC (Res.x/800.)\n\n#define LNUM 8\n#define ImageTex iChannel0\n\n#define PI 3.1415927\n\n#define N(v) (v.yx*vec2(1,-1))\n\nstruct Particle {\n    vec2 pos;\n    vec2 vel;\n    int idx;\n};\n\nvec4 getRand(vec2 pos)\n{\n    vec2 rres=vec2(textureSize(iChannel1,0));\n    return textureLod(iChannel1,pos/rres,0.);\n}\n\nvec4 getRand(int idx)\n{\n    ivec2 rres=textureSize(iChannel1,0);\n    idx=idx%(rres.x*rres.y);\n    return texelFetch(iChannel1,ivec2(idx%rres.x,idx/rres.x),0);\n}\n\nvoid initParticle(inout Particle p, int xIdx, int yIdx)\n{\n    float xnum = float(XNUM);\n    float ynum = float(YNUM);\n    vec2 delta = vec2(Res.x/xnum,Res.y/ynum);\n    p.pos.xy=vec2(xIdx,yIdx)*delta;\n    // trigonal grid offs\n    p.pos.x+=(float(yIdx%2)-.5)*delta.x*.5;\n    p.vel = (getRand(p.pos).xy-.5)*0.;\n}\n\nvec4 getCol(vec2 pos, float lod)\n{\n    vec2 tres = vec2(textureSize(ImageTex,0));\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res)*min(tres.y/Res.y,tres.x/Res.x);\n    vec2 uv = (tpos+tres*.5)/tres/*-(iMouse.xy/iResolution.xy-.5)*/;\n    return textureLod(ImageTex,uv,0.);\n}\n\nfloat getVal(vec2 pos)\n{\n    return getCol(pos,0.).z;\n    return dot(getCol(pos,0.).xyz,vec3(1)/3.);\n}\n\nvec2 getGradLkp(vec2 pos, float eps)\n{\n    float d = getCol(pos,0.).z;\n    vec2 g = .1*pow(2.,(1.-d)*4.)*getCol(pos,(1.-d)*4.).xy;\n    //vec2 g=getCol(pos).xy;\n    return g;\n}\nvec2 getGradDet(vec2 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    return vec2(\n        getVal(pos+d.xy)-getVal(pos-d.xy),\n        getVal(pos+d.yx)-getVal(pos-d.yx)\n        )/eps/2.;\n}\nvec2 getGrad(vec2 pos, float eps)\n{\n    return -getGradDet(pos,eps);\n}\n\nvoid propagate(inout Particle p, float dt)\n{\n    //float dt=.02;\n    p.pos+=p.vel*dt;\n    float sc=SC;\n    \n    // gradient, its length, and unit vector\n    vec2 g = 1.0*getGrad(p.pos,2.5*sc)*sc;\n    // add some noise to gradient so plain areas get some texture\n    //g += (getRand(p.pos/sc).xy-.5)*.003;  //getRand is pixel based so we divide arg by sc so that it looks the same on all scales\n    //g+=normalize(p.pos-Res*.5)*.001;\n    float gl=length(g);\n    vec2 gu=normalize(g);\n    \n    // calculate velocity change\n    vec2 dvel=vec2(0);\n    \n    float dir = (float(p.idx%2)*2.-1.); // every 2nd particle is bent left/right\n    float dir2 = (float((p.idx/8)%2)*2.-1.);\n    //dir2=1.;\n    \n    // apply some randomness to velocity\n    //dvel += .7*(getRand(p.pos/sc).xy-.5)/(.03+gl*gl)*sc;\n\n    // vel tends towards gradient\n    dvel -= 10.*gu*(1.+sqrt(gl*2.))*sc;\n    \n    // vel tends towards/away from normal to gradient (every second particle)\n    dvel += dir2*30.*N(gu)/(1.+1.*sqrt(gl*100.))*sc*dir;\n    \n    // vel bends right/left (every second particle)\n    //dvel += p.vel.yx*vec2(1,-1)*.06;\n    dvel += .06*N(p.vel)/(1.+gl*10.)*dir;\n    \n    p.vel += dvel;\n    \n    // minimum vel\n    //p.vel = normalize(p.vel)*max(length(p.vel),40.*sc);\n    \n    // vel damping\n    p.vel-=gu*dot(p.vel,gu)*(.05+5.*gl)*.75;\n    //p.vel-=N(gu)*dot(p.vel,N(gu))*-.035;\n    //p.vel*=.95;\n}\n\nfloat getDetail(vec2 pos)\n{\n    return getCol(pos, 0.).z;\n}\n\nfloat sdLine( vec2 pos, vec2 p1, vec2 p2, float crop, inout float f)\n{\n    pos-=p1; p2-=p1;\n    float l=length(p2);\n    vec2 t=p2/l;\n  \tfloat pp = dot(pos,t);\n  \tfloat pn = dot(pos,t.yx*vec2(1,-1));\n    f=(l<.001)?0.:pp/l;\n  \treturn (l<.001)?100000.:max(max(pp-l+crop,-pp+crop),abs(pn));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    int xIdx0=int(fragCoord.x/(Res.x/float(XNUM))+.5);\n    int yIdx0=int(fragCoord.y/(Res.y/float(YNUM))+.5);\n    vec3 col=vec3(0);\n    int idelta = 4;\n    int iw=idelta*2+1;\n    for(int dIdx=0;dIdx<iw*iw;dIdx++)\n    {\n        int dxIdx=(dIdx%iw)-iw/2;\n        int dyIdx=(dIdx/iw)-iw/2;\n        int xIdx=xIdx0+dxIdx;\n        int yIdx=yIdx0+dyIdx;\n        int pIdx=(xIdx+yIdx*XNUM);\n    \tParticle p;\n    \tp.idx=xIdx+yIdx*XNUM;\n    \tinitParticle(p,xIdx,yIdx);\n    \tParticle pp;\n    \n    \t// make a little pre propagation, so particles start already near a bigger gradient\n    \tp.pos -= .04*mix(1.,2.*getRand(pIdx).x,.8)/(getGrad(p.pos,2.5*SC));\n        \n    \t// calc the actual stroke\n    \t// here every segment calculates its whole previous stroke points\n    \t// could be done more effctive by precomputing to a buffer i guess,\n    \t// but my gpu is eager for work anyway ;-)\n    \tfor(int i=0;i<LNUM;i++)\n    \t{\n\t        pp=p;\n\t        for(int j=0;j<4;j++) propagate(p,.01);\n\t        //dist=min(dist,sdLine(fragCoord,p.pos,pp.pos,0.));\n            float f=0.;\n\t        float dist=sdLine(fragCoord,p.pos,pp.pos,.75*sqrt(SC),f);\n\t\t    col+=(1.-vec3(.0,.2,.65))*clamp(1.2*sqrt(SC)-dist,0.,1.)\n\t\t\t\t *clamp((float(i+1)-f)/4.,0.,1.)*clamp((float(LNUM-i)+f)/2.,0.,1.)\n                 //* (.3+1.4*texture(iChannel1,fragCoord/Res1*.7).x)\n\t            ;\n\t    }\n    }\n    fragColor = vec4(col,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}