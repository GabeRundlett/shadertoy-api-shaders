{
    "Shader": {
        "info": {
            "date": "1548001708",
            "description": "Goursat quartic surfaces, raytraced with analytic solution to quartic equation.\n\n[url]http://mathworld.wolfram.com/GoursatsSurface.html[/url]\n[url]https://www.mathcurve.com/surfaces/goursat/goursat.shtml[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "wsXGWS",
            "likes": 23,
            "name": "Goursat Quartic Surface",
            "published": 3,
            "tags": [
                "surface",
                "quartic",
                "analytic",
                "goursat"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1135
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Goursat Quartic Surfaces\n//\n// http://mathworld.wolfram.com/GoursatsSurface.html\n// https://www.mathcurve.com/surfaces/goursat/goursat.shtml\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting parameters\n// 'c': clip at z = 0\n// 'g': show grid\n// 'r': do rotation\n//\n// Quartic surfaces with octahedral symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos and Kahan.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// PARAMS\nconst float PI =  3.141592654;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n#if __VERSION__ < 300\n#define texelFetch(a,b,c) (vec4(0))\n#endif\n\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n// Utilities\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81; // Dodgy approximation\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nint quadratic(vec3 coeffs, out vec2 res) {\n  return quadratic(coeffs[0],coeffs[1],coeffs[2],res);\n}\n  \nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      for (int i = 0; i < 6; i++) {\n        X = x0;\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        x0 -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\nint cubic(vec4 coeffs, out vec3 res) {\n  float A = coeffs[0], B = coeffs[1], C = coeffs[2], D = coeffs[3];\n  return cubic(A,B,C,D,res);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat qcubic(float a, float b, float c) {\n  // c is always <= 0, but may be very\n  // small, in which case we return an\n  // approximation. Never return < 0.\n  assert(c <= 0.0);\n  if (c == 0.0) return 0.0;\n  if (keypress(CHAR_Q)) {\n    // This helps with double roots, but sometimes is\n    // completely the wrong thing to do.\n    // Further investigation required.\n    if (c > -1e-6) {\n      //assert(false);\n      if (b > 1e-10) return -c/b;\n      //if (b > 0.0) return -c/b; // Keep it simple.\n      if (b > -1e-4) return 0.0;\n    }\n  }\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nint quartic(vec4 coeffs, out vec4 res) {\n  float c1 = coeffs[0];\n  float c2 = coeffs[1];\n  float c3 = coeffs[2];\n  float c4 = coeffs[3];\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  //assert(!isnan(psi));\n  //assert(!isinf(psi));\n  assert(psi >= 0.0);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // There may be a better heuristic for this.\n  // but this avoids the worst glitches.\n  if (keypress(CHAR_A) || !keypress(CHAR_B) && abs(E) < 10.0*abs(A)) {\n    vec4 coeffs = vec4(B,C,D,E)/A;\n    nroots = quartic(coeffs,roots);\n  } else {\n    // It can be advantageous to use the coefficients in the\n    // opposite order, thus solving for the reciprocal.\n    vec4 coeffs = vec4(D,C,B,A)/E;\n    nroots = quartic(coeffs,roots);\n    for (int i = 0; i < 4; i++) {\n      if (i == nroots) break;\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n  int colorscheme;\n};\n\n// Equation: pp.pp + k(p.p)^2 + k'a^2(p.p) + k''a^4 = 0\n// Derivative: 4ppp + 4k(p.p)p + 2k'a^2p\n// Expansion with p => p+tr:\n// pp => (p+tr)(p+tr) = pp + 2tpr + t^2rr\n// pp.pp => (pp + 2tpr + t^2rr).(pp + 2tpr + t^2rr)\n//  = pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr \n// p.p  => (p+tr).(p+tr) = p.p + 2tp.r + t^2r.r = p.p + 2tp.r + t^2\n// (p.p)^2 = (p.p + 2tp.r + t^2)(p.p + 2tp.r + t^2) =\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 2(2t(p.p)(p.r) + (p.p)t^2 + 2t^3(p.r))\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 4t(p.p)(p.r) + 2(p.p)t^2 + 4t^3(p.r))\n// ie.\n// pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr +\n// k(p.p^2 + t4[(p.p)(p.r)] + t^2[4(p.r)^2 + 2(p.p)] + t^3[4(p.r)] + t^4) +\n// k'a^2(p.p + 2tp.r + t^2) +\n// k''a^4\n// collecting terms:\n// t^0: pp.pp +   k(p.p)^2 +             k'a^2(p.p) + k''a^4\n// t^1: 4pp.pr + 4k(p.p)(p.r) +         2k'a^2(p.r)\n// t^2: 6pp.rr +  k[4(p.r)^2 + 2(p.p)] + k'a^2\n// t^3: 4pr.rr + 4k(p.r)\n// t^4: rr.rr +   k\n\nint goursatsurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float k2 = surface.params[2];\n  float a = surface.params[3];\n  vec3 pp = p*p;\n  vec3 pr = p*r;\n  vec3 rr = r*r;\n  float p2 = dot(p,p);\n  float a2 = a*a;\n  float a4 = a2*a2;\n  // Check we have adjusted p so that p.r = 0!\n  assert(eq(dot(p,r),0.0));\n  assert(eq(dot(r,r),1.0));\n#if 0\n  float pdr = dot(p,r);\n  float A = dot(rr,rr) + k;\n  float B = 4.0*dot(pr,rr) + 4.0*k*pdr;\n  float C = 6.0*dot(pp,rr) +     k*(4.0*pdr*pdr + 2.0*p2) + k1*a2;\n  float D = 4.0*dot(pp,pr) + 4.0*k*(p2*pdr)           + 2.0*k1*a2*pdr;\n  float E = dot(pp,pp)         + k*p2*p2 + k1*a2*p2 + k2*a4;\n#else\n  float A =     dot(rr,rr) +     k;\n  float B = 4.0*dot(pr,rr);\n  float C = 6.0*dot(pp,rr) + 2.0*k*p2    + k1*a2;\n  float D = 4.0*dot(pp,pr);\n  float E =     dot(pp,pp) +     k*p2*p2 + k1*a2*p2 + k2*a4;\n#endif\n  return quartic(A,B,C,D,E,roots);\n}\n\nvec3 goursatnormal(Surface surface, vec3 p) {\n  // 4ppp + 4k(p.p)p + 2k'a^2p\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float a = surface.params[3];\n  return 4.0*p*p*p + 4.0*k*dot(p,p)*p + 2.0*k1*a*a*p;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 basecolor;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  return goursatsurface(surface,p0,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  return goursatnormal(surface,p);\n}\n  \nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!keypress(CHAR_C) || p.z > 0.0) {\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  if (surface.colorscheme == 1 && !keypress(CHAR_G)) {\n    basecolor *= gridline(p);\n  }\n  result = Result(p,n,basecolor,t);\n  return true;\n}\n\n// Interesting parameters from:\n// https://www.mathcurve.com/surfaces.gb/goursat/goursat.shtml\nvec4 goursatparams(int i) {\n  if (i == 0) return vec4(0,-1,0,1);\n  if (i == 1) return vec4(-1,-0.25,0.25,1);\n  if (i == 2) return vec4(-1,1,1,1);\n  if (i == 3) return vec4(0,-2,2,1);\n  if (i == 4) return vec4(-0.5,-1,0.5,1);\n  if (i == 5) return vec4(-0.5,1,-1.5,1);\n  if (i == 6) return vec4(-1,4,-6,1);\n  if (i == 7) return vec4(-1,1,1,1);\n  if (i == 8) return vec4(-1,2,-2,1);\n  else return vec4(-0.333,-0.666,0.666,1);\n}\n\nint nparams = 10;\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\nvec3 scene(vec3 p0, vec3 r) {\n  // Solve from closest point to origin.\n  // This make p0.r = 0.\n  float tmin = -dot(p0,r);\n  p0 += tmin*r;\n  Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n  float ttime = 0.5*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  vec4 params;\n#if __VERSION__ < 300\n    params = mix(goursatparams(imod(int(rtime),nparams)),\n                 goursatparams(imod(int(rtime)+1,nparams)),\n                 ttime);\n#else\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nparams+1;\n  if (isurface == 0) {\n    params = mix(goursatparams(int(rtime)%nparams),\n                 goursatparams(int(rtime+1.0)%nparams),\n                 ttime);\n  } else {\n    params = goursatparams(isurface-1);\n  }\n#endif\n  Surface surface = Surface(params,vec3(0),1);\n  if (!solve(surface,p0,r,-tmin,res)) return vec3(0);\n  return applylighting(res.basecolor,res.p,res.n,r);\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!keypress(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  int AA = 2;\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n  \t    vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n  \t\tvec3 r = normalize(vec3(uv, 2.0));\n        r = transform(r);\n        r = normalize(r);\n        color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}