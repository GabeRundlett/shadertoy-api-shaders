{
    "Shader": {
        "info": {
            "date": "1632162488",
            "description": "I liked @jorge's shader - so wanted to make my version of the MTV Logo! https://www.shadertoy.com/view/NsKGWy\n",
            "flags": 32,
            "hasliked": 0,
            "id": "fdVGWy",
            "likes": 13,
            "name": "I Want My MTV",
            "published": 3,
            "tags": [
                "raymarching",
                "reflections",
                "letter",
                "reproduction",
                "mtv"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 367
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    I want My MTV \n    09/20/21 | byt3_m3chanic\n\n    Was inspired after seeing @jorge's MTV Logo shader \n    https://www.shadertoy.com/view/NsKGWy\n    \n    had fun playing with the 80's textures and stuff\n    need to tweak a few things but enjoy!\n    \n    technical inspiration for reflections @jeyko \n    https://www.shadertoy.com/view/tdXcWM\n    liked the setup of loop/marcher in main\n\n*/\n\n#define COLOR(COORD) texture(iChannel0,(COORD))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n    vec3 color = COLOR(uv).rgb;\n    // effect sammple\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - 1.75);\n    fgclr.x = COLOR(uv - vec2(f*0.001,0.)).x;\n    fgclr.y = COLOR(uv + vec2(f*0.001,.002)).y;\n    fgclr.z = COLOR(uv + vec2(f*0.002,.001)).z;\n \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*2.15;\n    dt = smoothstep(0.,.8,1.-dt);\n    vec3 C = mix(fgclr,color,dt);\n    // output -gamma correct\n    fragColor = vec4(pow(C, vec3(0.4545)),1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n\n    I want My MTV \n    09/20/21 | byt3_m3chanic\n\n    Was inspired after seeing @jorge's MTV Logo shader \n    https://www.shadertoy.com/view/NsKGWy\n    \n    technical inspiration for reflections @jeyko's \n    https://www.shadertoy.com/view/tdXcWM\n    liked the setup of loop/marcher in main\n\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .001\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// noise is buggy in \n// @morgan3d https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1., 0.));\n    float c = hash21(i + vec2(0., 1.));\n    float d = hash21(i + vec2(1., 1.));\n    vec2 u = f;// * f * (3.-2.*f);  @Shane's tip for polygonized look..\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b)* u.x * u.y;\n}\n\n//generate terrain using above noise algorithm\nfloat fBm( vec2 p, float freq ) {\t\n\tfloat h = -1.5;\n\tfloat w = 2.50;\n\tfloat m = 0.25;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noise((p * m));\n\t\tw *= 0.5; m *= 2.0;\n\t}\n\treturn h;\n}\n\n//@iq sdf shapes & extrude\nfloat triangle( in vec2 p, in vec2 q ){\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat cap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat cylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n//global\nvec3 hp,hitPoint;\nvec2 gid,sid;\nfloat gtime,stime,ftime;\nmat2 r45,r95,r4;\n\nfloat getM(vec2 p) {\n    vec2 q = vec2(abs(p.x),p.y);\n    float b=box(q-vec2(.7,0),vec2(.35,1.));\n    q-=vec2(.175,.32);\n    q*=r45;\n    return min(box(q,vec2(.35,.6)), b);\n}\n\nfloat getTV(vec3 p, float ns) {\n    vec3 tp = p-vec3(.55,-.45,.35)-ns;\n    vec3 tt = p-vec3(.175,.05-ns,.35)-ns;\n    vec3 tv = p-vec3(.85,-.45-ns,.35-ns)-ns;\n    float t=cap(tp,.95,.045+tt.y*.035);\n    tt.xy*=r95;\n    t=smin(cap(tt,1.15,.075-tt.y*.055),t,.175);\n    t=smin(cap(tv,.65,.075),t,.22);\n    tv.xy*=r4;\n    t=smin(cap(tv,.95,.075-tt.y*.045),t,.15);\n    return t;\n}\nconst float sz = 5.5;\nconst float hf = sz/2.;\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p.y+=.25;\n    if(stime<1.) p.zx-=T*.73;\n    \n    float ns = fBm(p.xy*2.+T,4.)*.115;\n    gid=floor((p.xz+hf)/sz);\n    if(stime>1.) gid += floor(gtime); \n    if(stime<1.) p.xz=mod(p.xz+hf,sz)-hf;\n    \n    float outline=getM(p.xy);\n    \n    float bigM = opx(outline,p.z,.35)-.015;\n    if(bigM<res.x) {\n        res = vec2(bigM,2.);\n        hp=p;\n    }\n    \n    float bigTV = getTV(p,ns);\n    if(bigTV<res.x) {\n        res = vec2(bigTV,1.);\n        hp=p;\n    }\n    \n    float fx = cylinder(p+vec3(0,1.45,0),2.,.25);\n    if(fx<res.x) {\n        res = vec2(fx,3.);\n        hp=p;\n    }\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        t.x *= .8;\n        if(t.x<.001) hit = true;\n        d += t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>30.&&steps>100||d>325.) break;\n    } \n    return vec2(d,m);\n}\n\n// compact sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(0.914,0.502,0.184);\n    return .45+.4*cos( .2*T+PI2*t*vec3(.95,.97,.88)*d ); \n}\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, bool ison) { \n    rd.y+=.1;\n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n    \n    float sun = clamp(dot(rd, ld), 0., 1.);\n    \n    vec3 Rayleigh = vec3(1);\n    vec3 Mie = vec3(1); \n\n    const float RayleighAtt = .2;\n\tconst float MieAtt = 1.; \n    float zAng = max(.1, rd.y);\n\n    // Haze particles and Mie scattering: \n    // Henyey-Greenstein phase function.\n\tconst float g = .95;\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1);\n    vec3 betaM = vec3(4e-2);\n    Mie *= betaM/betaR/(4.*3.14159)*(1. - g*g)/pow(1. + g*g - 2.*g*sun, 1.5);\n    \n    // In-scatter - Klassen's model.\n    vec3 inScatter = (Mie + Rayleigh)*(1. + sun*sun);\n    vec3 extinction = exp(-(betaR*RayleighAtt + betaM*MieAtt)/zAng);\t\n    vec3 col = inScatter*(1. - extinction);\n          \n    // Sun & haze\n    col += vec3(1.6, 1.4, 1)*pow(sun, 250.)*extinction*.5;\n    col += vec3(.1, .3, 1)*pow(sun, 2.)*extinction*.4;\n    col = clamp(ACESFilm(col), 0., 1.);\n    \n    // Clouds\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 uv = (ro + t*rd).xz;\n\tif(t>0.&&ison) {\n        col = mix(col, vec3(2), smoothstep(1., .45, fBm(vec2(4.*uv/1e5),6.))*\n                       smoothstep(.45, .65, (rd.y+.25)*.5 + .5)*.4);  \n    }\n    return col;\n} \n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float speed = .1375;\n    r45 = rot(-.78539816339);\n    //r15 = rot(.15);\n    r4  = rot(-.45);\n    r95 = rot(-.95);\n    gtime = T*speed;\n    stime = mod(gtime,2.);\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0, stime<1.?.25:-.25, 3.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // camera //\n    mat2 rx =stime<1.? rot((.08*sin(T*.18))-.4) : rot((.08*sin(T*.18))-.1);\n    mat2 ry =rot((.38*sin(T*.33)));\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 sky = getSky(ro,rd,vec3(.9,.15,stime<1.? -.42:.45),true);\n    vec3 fog = getSky(ro,rd,vec3(.9,.15,-.42),false);\n    \n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m=0., d=0., a=0., fA=0., f=0.;\n    bool hit = false;\n\n    int bnc = 3;\n    for(int i = 0; i < bnc + min(iFrame, 0); i++){\n    \n        vec2 ray = marcher(ro,rd,p, hit, i==0?132:i>2?99:72);\n        d = ray.x; m = ray.y;\n        \n        hitPoint = hp;\n        sid=gid;\n        if(i == 0) f = d;\n        fA = max(d, fA);\n\n        if(hit)\n        {\n            a=1.;\n            vec3 n = normal(p,d);\n            vec3 lpos =  vec3(15.5,11,stime<1.? -11.5: 11.5);\n            vec3 l = normalize(lpos-p);\n\n            float diff = clamp(dot(n,l),0.,1.);\n            \n            float shdw = 1.0,t=.025;\n            for( int i =0; i<40; i++ ) {\n                float h = map(p + l*t).x;\n                if( h<MIN_DIST ) { shdw = 0.; break; }\n                shdw = min(shdw, 18.*h/t);\n                t += h;\n                if( shdw<MIN_DIST || t>32. ) break;\n            }\n            diff = mix(diff,min(diff*shdw,shdw),.65);\n\n            float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 8.);\n            fresnel = mix(.0, .9, fresnel);\n        \n            vec3 view = normalize(p - ro);\n            vec3 ret = reflect(normalize(lpos), n);\n            float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n            vec3 h = vec3(.5);\n\n            if(m==1.) {\n                h=hue((mod(sid.x,12.)*.15)+(sid.y*.12));\n                ref = clamp(h-fresnel,vec3(0),vec3(.4));  \n            }\n            \n            if(m==2.) {\n                h=vec3(0.141,0.141,0.141);\n                float hs = hash21(sid);\n                \n                if(hs<.33) {\n                    vec3 qr = hitPoint;\n                    vec3 uv = qr*9.;\n\n                    vec3 uvu = fract(uv*.5)-.5;\n                    vec3 id = floor(uv*.5)-.5;\n\n                    float chk = mod(id.y + id.x + id.z,2.) * 2. - 1.;\n                    float px = fwidth(qr.x);\n                    float sw = .575+.600*sin(id.x*.25*id.z*.15-id.y*.15+T*.75+sid.y);\n                    float cl = length(uvu)-sw;\n                    cl=smoothstep(px,-px,cl);\n                    h=mix(h,stime<1.?vec3(.6):hue(hash21(sid)),cl);\n                }\n                if(hs>.33 && hs<.66) {\n                    h=hue(hs);\n                }\n                if(hs>.66) {\n                    vec3 uvu = fract(hitPoint*4.)-.5;\n                    vec3 id = floor(hitPoint*4.)-.5;\n                    if(hitPoint.y<.25) {\n                        if(uvu.x*uvu.y*uvu.z>0.) h=hue(hs);\n                            \n                    }\n                    float px = fwidth(hitPoint.x*.5);\n                    float b1 = box(hitPoint.xy-vec2(0,.27+.075*sin(hitPoint.x*8.)),vec2(5.25,.1));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,vec3(.75),b1);\n                }\n                ref = (h*.3)-fresnel;\n            }\n            \n            if(m==3.) {\n                vec2 hp = hitPoint.xz*4.;\n    \n                float px = fwidth(hitPoint.x*.5);\n                float hs = hash21(sid);\n                h=hue(hs);\n                \n                if(hs<.33) {\n                    vec2 lv = fract(hp)-.5;\n                    vec2 id = floor(hp)-.5;\n                    vec2 lx = fract(hp*.75)-.5;\n                    vec2 fd = floor(hp*.75)-.5;\n                    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n                    float fhk = mod(fd.y + fd.x,2.) * 2. - 1.;\n                    float fw = .075*sin(hitPoint.x*10.5+T*5.);\n                    if(hitPoint.z<fw) {\n                        if(lv.x*lv.y>0.) h=vec3(.03);\n                    \n                    } else {\n                        float c1 = length(lx)-.45;\n                        c1=smoothstep(px,-px,c1);\n                        if(fhk>.5) h = mix(h,hue((mod(sid.y,12.)*.25)+(sid.x*.22)),c1);\n                    }\n\n                    float b1 = box(hitPoint.xz-vec2(0,fw),vec2(5.25,.1));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,vec3(.03),b1);\n                }\n                \n                if(hs>.33 && hs<.66) {\n                \n                    vec2 lv = fract(hp*.5)-.5;\n                    vec2 id = floor(hp*.5)-.5;\n                    vec2 lx = fract(hp*.25)-.5;\n                    vec2 fd = floor(hp*.25)-.5;\n                    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n                    float fhk = mod(fd.y + fd.x,2.) * 2. - 1.;\n                \n                    vec2 tx = lx;\n                    if(fhk>.5) {tx.y*=-1.;tx.y+=.45;}\n                    float t1 = triangle(tx,vec2(.25,.5));\n                    t1=smoothstep(px,-px,t1);\n                    h = mix(h,vec3(.03),t1);\n\n                    float c1 = length(lx-vec2(.25,.25))-.25;\n                    c1=smoothstep(px,-px,c1);\n                    if(fhk>.5) h = mix(h,vec3(1),c1);\n\n                    float c2 = length(lv)-.145;\n                    c2=smoothstep(px,-px,abs(abs(c2)-.024)-.012);\n                    if(chk<.5) h = mix(h,vec3(.9),c2);\n\n                    if(fhk>.5) lx*=rot(.78531);\n                    lx.y+=.0125*sin(lx.x*45.+T*5.5);\n                    lx.y=abs(lx.y)-.1;\n                    float b1 = box(lx-vec2(0,0),vec2(.25,.05));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,hue((mod(sid.x,12.)*.15)+(sid.y*.12)),b1);\n                }\n                \n                if(hs>.66) {\n                    vec3 bh = h;\n                    h=vec3(.9,.91,.94);\n                    \n                    vec2 lv = fract(hp*.45)-.5;\n                    vec2 id = floor(hp*.45)-.5;\n                    vec2 lx = fract(hp*.15)-.5;\n                    vec2 fd = floor(hp*.15)-.5;\n                    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n                    float fhk = mod(fd.y + fd.x,2.) * 2. - 1.;\n                    \n                    float c2 = length(lv)-.35;\n                    c2=smoothstep(px,-px,abs(abs(c2)-.024)-.012);\n                    if(chk<.5) h = mix(h,vec3(.3),c2);\n                    \n                    vec2 tx = lx*rot(.53+fd.x+fd.y);\n                    float t1 = triangle(tx,vec2(.225,.4));\n                    t1=smoothstep(px,-px,t1);\n                    h = mix(h,bh,t1);\n                    \n                    if(fhk>.5) lx*=rot(.78531);\n                    lx.y+=.0125*sin(lx.x*85.+T*5.5);\n                    float b1 = box(lx-vec2(.24,-.2),vec2(.25,.025));\n                    b1=smoothstep(px,-px,b1);\n                    h = mix(h,hue((mod(sid.y,12.)*.15)+(sid.x*.22)),b1);\n                }\n                \n                if(hitPoint.y<-1.21)h=vec3(.65);\n                \n                ref=vec3(.2);\n            }\n\n            RC += h * diff + min(spec,shdw);\n            sky = getSky(ro,rd,vec3(.9,.15,-.42),true);\n            ro = p+n*.01;\n            rd = reflect(rd,n);\n\n        } else {\n            RC = sky;\n        } \n        \n        if(i!=0) RC = mix(RC,sky,smoothstep(0.,1.,fA*0.025));\n       \n        C += RC*fill;\n        fill *= ref;\n            \n    }\n    if(a==1.) C = mix(C,fog,smoothstep(0.,1.,f*0.025));\n    C = clamp(C,vec3(.03),vec3(1));\n    //C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}