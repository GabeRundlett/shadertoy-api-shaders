{
    "Shader": {
        "info": {
            "date": "1718034696",
            "description": "A simple cube surrounding a sphere that has some metallic properties bouncing off key, fill, and rim lights.",
            "flags": 0,
            "hasliked": 0,
            "id": "X3GGRt",
            "likes": 0,
            "name": "My First Raytracer With Reflect",
            "published": 3,
            "tags": [
                "raytracer",
                "math",
                "reflections",
                "metallic"
            ],
            "usePreview": 0,
            "username": "spenceryonce",
            "viewed": 108
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n#define EPSILON 0.001\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    float metallic;\n};\n\nstruct Box {\n    vec3 min;\n    vec3 max;\n    vec3 color;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nbool intersectSphere(Ray ray, Sphere sphere, out float t, out vec3 hitPoint, out vec3 normal) {\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return false;\n    } else {\n        t = (-b - sqrt(discriminant)) / (2.0 * a);\n        hitPoint = ray.origin + t * ray.direction;\n        normal = normalize(hitPoint - sphere.center);\n        return true;\n    }\n}\n\nbool intersectBox(Ray ray, Box box, out float t, out vec3 hitPoint, out vec3 normal) {\n    vec3 invDir = 1.0 / ray.direction;\n    vec3 tMin = (box.min - ray.origin) * invDir;\n    vec3 tMax = (box.max - ray.origin) * invDir;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if (tNear > 0.0 && tNear < tFar) {\n        t = tNear;\n        hitPoint = ray.origin + t * ray.direction;\n\n        if (tNear == tMin.x) normal = vec3(-sign(ray.direction.x), 0.0, 0.0);\n        else if (tNear == tMax.x) normal = vec3(sign(ray.direction.x), 0.0, 0.0);\n        else if (tNear == tMin.y) normal = vec3(0.0, -sign(ray.direction.y), 0.0);\n        else if (tNear == tMax.y) normal = vec3(0.0, sign(ray.direction.y), 0.0);\n        else if (tNear == tMin.z) normal = vec3(0.0, 0.0, -sign(ray.direction.z));\n        else if (tNear == tMax.z) normal = vec3(0.0, 0.0, sign(ray.direction.z));\n        \n        return true;\n    }\n    return false;\n}\n\nvec3 phongIllumination(vec3 point, vec3 normal, vec3 viewDir, vec3 materialColor, Light light) {\n    vec3 lightDir = normalize(light.position - point);\n    vec3 reflectDir = reflect(-lightDir, normal);\n\n    // Ambient component\n    vec3 ambient = 0.1 * materialColor;\n\n    // Diffuse component\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * materialColor * light.color;\n\n    // Specular component\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = spec * light.color;\n\n    return ambient + diffuse + specular;\n}\n\nvec3 traceRay(Ray ray) {\n    float t;\n    vec3 hitPoint, normal;\n    vec3 color = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.1412, 0.5647, 0.8667), 0.5);\n    Box box = Box(vec3(-2.0, -2.0, -2.0), vec3(2.0, 2.0, 2.0), vec3(0.031,0.031,0.031));\n\n    Light keyLight = Light(vec3(2.0, 4.0, 3.0), vec3(1.000,1.000,1.000));\n    Light fillLight = Light(vec3(-5.0, 1.0, -1.0), vec3(1.0, 1.0, 1.0));\n    Light rimLight = Light(vec3(0.0, 5.0, -5.0), vec3(0.9176, 0.3922, 0.8118));\n\n    for (int i = 0; i < 3; i++) { // Limit reflections to 3 iterations\n        if (intersectSphere(ray, sphere, t, hitPoint, normal)) {\n            vec3 viewDir = normalize(ray.origin - hitPoint);\n            color += attenuation * phongIllumination(hitPoint, normal, viewDir, sphere.color, keyLight);\n            color += attenuation * phongIllumination(hitPoint, normal, viewDir, sphere.color, fillLight);\n            color += attenuation * phongIllumination(hitPoint, normal, viewDir, sphere.color, rimLight);\n\n            if (sphere.metallic > 0.0) {\n                vec3 reflectDir = reflect(ray.direction, normal);\n                ray = Ray(hitPoint + normal * EPSILON, reflectDir);\n                attenuation *= sphere.metallic;\n            } else {\n                break;\n            }\n        } else if (intersectBox(ray, box, t, hitPoint, normal)) {\n            vec3 viewDir = normalize(ray.origin - hitPoint);\n            color += attenuation * phongIllumination(hitPoint, normal, viewDir, box.color, keyLight);\n            color += attenuation * phongIllumination(hitPoint, normal, viewDir, box.color, fillLight);\n            color += attenuation * phongIllumination(hitPoint, normal, viewDir, box.color, rimLight);\n\n            vec3 reflectDir = reflect(ray.direction, normal);\n            ray = Ray(hitPoint + normal * EPSILON, reflectDir);\n            attenuation *= 0.5; // Box with fixed reflectivity\n        } else {\n            break;\n        }\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cameraPos = vec3(0.0, 0.0, 3.0);\n    vec3 rayDir = normalize(vec3(uv, -1.0));\n    Ray ray = Ray(cameraPos, rayDir);\n\n    vec3 color = traceRay(ray);\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}