{
    "Shader": {
        "info": {
            "date": "1697739836",
            "description": "My submission for the JFIG 2023 Shadertoy contest.",
            "flags": 32,
            "hasliked": 0,
            "id": "mdcfDj",
            "likes": 5,
            "name": "[ConcoursJFIG2023] Toriversaire",
            "published": 3,
            "tags": [
                "torus",
                "pathtracer",
                "svgf",
                "concoursjfig2023",
                "jfig23"
            ],
            "usePreview": 1,
            "username": "PlathC",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "// Based on Single-pass gaussian blur - fast \n// By FabriceNeyret2 \n// Reference: https://www.shadertoy.com/view/ltScRG\nconst int   Samples  = 8; // Actual sample count is Samples / (2^(LODLevel))\nconst int   LODLevel = 1;\nconst float Sigma    = float(Samples) * .25;\n\nfloat gaussian(vec2 i) \n{\n    i /= Sigma;\n    return exp(-.5 * dot(i, i) ) / (Tau * Sigma * Sigma);\n}\n\nvec4 bloom(sampler2D channel, vec2 uv) \n{\n    vec4 color    = vec4(0.);\n    int  sampleNb = Samples / (1 << LODLevel);\n    vec2 stepSize = 1. / iChannelResolution[1].xy;\n    float sLOD    = float(1 << LODLevel);\n    for(int i = 0; i < sampleNb; i++)\n    {\n        for(int j = 0; j < sampleNb; j++)\n        {\n            vec2 delta       = vec2(i, j) * sLOD - float(Samples) * .5;\n            vec2 coordinates = uv + stepSize * delta;\n            \n            vec4 sampleData  = textureLod(channel, coordinates , float(LODLevel) );\n            vec3 sampleColor = sampleData.rgb * float(sampleData.w < 0.);\n            \n            color += gaussian(delta) * vec4(sampleColor, 1.);\n        }\n    }\n    \n    return color / color.a;\n}\n\n// ACES tonemapping from romainguy's shader\n// Reference: https://www.shadertoy.com/view/llXyWr\nvec3 ACESFilm( vec3 x )\n{\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn clamp( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ), vec3( 0.f ), vec3( 1.f ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec4 color = vec4(0.);\n    \n    vec2 uv = fragCoord + .5;\n    uv = uv - iResolution.xy * .5;\n    uv = uv / iResolution.y;\n\n    // Chromatic aberration on sides of the image while preserving candles\n    vec3 offset = max(0., length(uv - vec2(.25, 0.1)) - .2) * (vec3(8.5, 5.9, .8) / 1280. * iResolution.x);\n    color.r = texture(iChannel0, (fragCoord + offset.x) / iResolution.xy).r;\n    color.g = texture(iChannel0, (fragCoord + offset.y) / iResolution.xy).g;\n    color.b = texture(iChannel0, (fragCoord + offset.z) / iResolution.xy).b;\n    \n    // Apply bloom only if pixel is non emissive\n    vec4 bloom = bloom(iChannel0, fragCoord / iResolution.xy);\n    color     += bloom * 1.1;\n    color.rgb *= 1.5;\n    \n    // Tonemapping & Gamma Correction\n    fragColor = vec4(pow(ACESFilm(color.rgb), vec3(1. / 2.2)), 1.f);\n    \n    uv = (fragCoord / iResolution.xy - .5) * 2.;\n    bool startAnimation = abs(uv.y) > min(iTime * .6, .8) || abs(uv.x) > min(iTime * .75, 1.);\n    bool endAnimation   = (1. - abs(uv.x)) <= clamp(iTime * .25 - 39. / 4., 0., 1.)\n                       || (1. - abs(uv.y)) <= clamp(iTime * .25 - 39. / 4., 0., 1.);\n    if(startAnimation || endAnimation) \n    {\n        fragColor = vec4(vec3(0.), 1.f);\n        return;\n    }\n    \n    // Vignette\n    fragColor *= 1. - .2 * dot(uv, uv); \n    \n    // Overlay\n    vec4 overlay  = texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb, overlay.rgb, overlay.w);\n    fragColor.w = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float Pi  = 3.1415;\nconst float Tau = 2. * Pi;\n\n// Override iTime to make the shader loop\nfloat getTime(float time) {\n    return mod(time, 43.); \n}\n#define iTime getTime(iTime)\n#define rgb(c1, c2, c3) vec3(c1, c2, c3) / 255.\n\nfloat length2(vec3 v) {return dot(v,v);}\n\nvec4 quat(float angle, vec3 axis) \n{\n\tfloat halfAngle = angle / 2.;\n\treturn vec4(\n\t\taxis.x * sin(halfAngle),\n\t\taxis.y * sin(halfAngle),\n\t\taxis.z * sin(halfAngle),\n\t\tcos(halfAngle)\n\t);\n}\n\n// Based on GLM implementation\nvec3 mul(vec4 quat, vec3 point)\n{\n\tvec3 quatVector = vec3(quat.x, quat.y, quat.z);\n\tvec3 uv = cross(quatVector, point);\n\tvec3 uuv = cross(quatVector, uv);\n\n\treturn point + ((uv * quat.w) + uuv) * 2.;\n}\n\nvec4 conjugate(vec4 quat) { return vec4(-quat.x, -quat.y, -quat.z, quat.w); }\n\nvoid rotate(inout vec2 v, float angle) \n{\n    mat2 matrix = mat2(\n        cos(angle),  sin(angle),\n        -sin(angle), cos(angle)\n    );\n    \n    v = v * matrix;\n}\n\n// Both n and ref must be normalized\nvec4 toLocal(vec3 n, vec3 ref)\n{\n    if (dot(n, ref) < -1.f + 1e-4f)\n        return vec4(1.f, 0.f, 0.f, 0.f);\n\n    float angle = 1.f + dot(n, ref); // sqrt(length2(n) * length2(ref)) + dot( input, up );\n    vec3  axis  = cross(n, ref);\n    return normalize(vec4(axis, angle));\n}\n\nvec4 toLocalZ(vec3 n) { return toLocal(n, vec3(0., 0., 1.)); }\n\n// Ref: https://en.wikipedia.org/wiki/Relative_luminance\nfloat getLuminance(vec3 rgb)\n{\n    return rgb.x * 0.2126f + rgb.y * 0.7152f + rgb.z * 0.0722f;\n}\n\nfloat getDiskArea(float radius) \n{\n    return Pi * radius * radius;\n}\n\nvec3 polarToCartesian(vec2 angles) \n{\n    return vec3(\n        sin(angles.x) * cos(angles.y),\n        sin(angles.x) * sin(angles.y),\n        sin(angles.x)\n    );\n}\n\n// Mod polar from HG_SDF: A glsl library for building signed distance functions\n// By Korndörfer Johann, Keinert Benjamin, Ganse Urs, Sänger Michael, Ley Simon, \n// Burkhardt Konstanze, Spuler Mario and Heusipp Jörn\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*Pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n    \n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n//-- Geometric primitives\n\n// Primitives from Inigo Quilez's library\n// Reference: https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n    return normalize( pos*(dot(pos,pos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// GLSL Torus Knot from Syntopia and DarkBeam\n// Reference: https://www.fractalforums.com/new-theories-and-research/not-fractal-but-funny-trefoil-knot-routine/15/\nfloat deTorusKnot(vec3 p, vec3 r, vec2 c, float polyfoldOrder) \n{\n\tfloat mobius = (c.x + c.y/polyfoldOrder) * atan(p.y,p.x);\n\tp.x = length( p.xy ) - r.x;\n\trotate(p.xz, mobius);\t\n\t\n    float m     = polyfoldOrder / Tau;\n\tfloat angle = floor(.5 + m * (Pi/2. - atan(p.x,p.z))) / m;\n    \n\trotate(p.xz, angle);\n\tp.x = p.x - r.z;\n\t\n    return (length(p.xz)-r.y) * .8; // Slightly overestimated when radius is small\n}\n\n//-- Random\n// Reference: https://www.shadertoy.com/view/XlGcRh\n// Hash Functions for GPU Rendering. Mark Jarzynski, & Marc Olano (2020).\n// Journal of Computer Graphics Techniques (JCGT), 9(3), 20–38.\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    return v;\n}\n\nvec4 prng(inout uvec4 p)\n{\n    p.w++;\n    return vec4(pcg4d(p)) * (1.0/float(0xffffffffu));\n}\n\n//-- Hashes\n// From: Quality hashes collection WebGL2 by nimitz \n// Reference: https://www.shadertoy.com/view/Xt3cDn\n// Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash11(uint x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 getBlueNoise(vec2 fragCoord, int frame, sampler2D sampler) \n{\n    // Reference: https://www.shadertoy.com/view/tlySzR\n    ivec2 p = ivec2(fragCoord);\n    p = (p+frame*ivec2(113,127)) & 1023;\n    return texelFetch(sampler, p, 0);\n}\n\n//-- Sampling utils\n// Sampling Transformations Zoo\n// Peter Shirley, Samuli Laine, David Hart, Matt Pharr, Petrik Clarberg,\n// Eric Haines, Matthias Raab, and David Cline\n// NVIDIA\nvec3 sampleCosine(vec2 u)\n{\n    // 16.6.1 COSINE-WEIGHTED HEMISPHERE ORIENTED TO THE Z-AXIS\n    float a = sqrt(u.x);\n    float b = 2. * Pi * u.y;\n\n    return vec3(a * cos(b), a * sin(b), sqrt(1.0f - u.x));\n}\nvec3 sampleCone(float cosThetaMax, vec2 u, inout float pdf)\n{\n    // 16.6.3 DIRECTIONS IN A CONE\n    float cosTheta = (1. - u.x) + u.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u.y * 2. * Pi;\n    \n    pdf = 1. / (Tau * (1. - cosThetaMax));\n    return vec3( \n        cos(phi) * sinTheta,\n        sin(phi) * sinTheta,\n        cosTheta\n    );\n}\n\n// Stratified Sampling of 2-Manifolds, Jim Arvo\n// SIGGRAPH Course Notes 2001\n// Found: https://twitter.com/keenanisalive/status/1529490555893428226?s=20&t=mxRju6YioMmlMOJ1fDVBpw\nvec2 sampleCircle(vec2 u)\n{\n    float  r     = u.x;\n    float  theta = u.y * 2. * Pi;\n    return sqrt(r) * vec2(cos(theta), sin(theta));\n}\nvec3 sampleDisk(float height, float radius, vec2 u) \n{\n    vec2 pd = sampleCircle(u);\n    return vec3(pd.x * radius, height, pd.y * radius);\n}\n\n//-- Ray\nstruct Material\n{\n    vec3 baseColor;\n    vec3 emission;\n};\n\nMaterial defaultMaterial() \n{\n    Material material;\n    material.baseColor = vec3(1., 0., 1.);\n    material.baseColor = vec3(0.);\n    \n    return material;\n}\n\nMaterial getMaterial(uint hashOffset)\n{\n    float hash = hash11(hashOffset);\n\n    Material material  = defaultMaterial();\n    material.baseColor = hash31(hashOffset);\n    material.emission  = float(mod(hash * 6., 6.) > 5.) * hash31(hashOffset + 2u);\n    \n    return material;\n}\n\nstruct HitInfo\n{\n    float    t;\n    vec3     normal;\n};\n\nHitInfo defaultHitInfo() \n{\n    return HitInfo(-1., vec3(0.));\n}\n\nstruct LightSample \n{\n    vec3  position;\n    vec3  wi;\n    vec3  intensity;\n    float pdf;\n};\n\n// A Fast and Robust Method for Avoiding Self-Intersection, Carsten Wächter and Nikolaus Binder, NVIDIA\n// Reference: https://github.com/Apress/ray-tracing-gems/blob/master/Ch_06_A_Fast_and_Robust_Method_for_Avoiding_Self-Intersection/offset_ray.cu\nvec3 offsetRay(vec3 p, vec3 n)\n{\n    const float origin      = 1.0f / 32.0f;\n    const float float_scale = 1.0f / 65536.0f;\n    const float int_scale   = 256.0f;\n\n    ivec3 of_i = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);\n\n    vec3 p_i = vec3(intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0.) ? -of_i.x : of_i.x)),\n                    intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0.) ? -of_i.y : of_i.y)),\n                    intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0.) ? -of_i.z : of_i.z)));\n\n    return vec3(abs(p.x) < origin ? p.x + float_scale * n.x : p_i.x,\n                abs(p.y) < origin ? p.y + float_scale * n.y : p_i.y,\n                abs(p.z) < origin ? p.z + float_scale * n.z : p_i.z);\n}\n\n//-- Materials\n// For all functions, ro and rd are transformed s.t. n = (0., 0., 1.)\nvec3 evalLambertian(const Material material)\n{\n    return material.baseColor / Pi;\n}\n\nvec3 sampleLambertian(const vec3 wo, const vec2 u)\n{\n    vec3 wi = sampleCosine(u);\n    if (wo.z < 0.)\n        wi.z *= -1.;\n    return wi;\n}\n\nfloat getPdfLambertian(const vec3 wo, const vec3 wi) { return wo.z * wi.z > 0. ? abs(wi.z) / Pi : 0.; }\n\n//-- RGB to XYZ to LAB by mattatz\n// Reference: https://gist.github.com/mattatz/44f081cac87e2f7c8980\nvec3 rgb2xyz( vec3 c ) {\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    const mat3 mat = mat3(\n\t\t0.4124, 0.3576, 0.1805,\n        0.2126, 0.7152, 0.0722,\n        0.0193, 0.1192, 0.9505 \n\t);\n    return 100.0 * (tmp * mat);\n}\n\nvec3 xyz2lab( vec3 c ) {\n    vec3 n = c / vec3(95.047, 100, 108.883);\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgb2lab( vec3 c ) {\n    vec3 lab = xyz2lab( rgb2xyz( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 lab2xyz( vec3 c ) {\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 xyz2rgb( vec3 c ) {\n\tconst mat3 mat = mat3(\n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n\t);\n    vec3 v = (c / 100.0 * mat);\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 lab2rgb( vec3 c ) {\n    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// RGB to HSV by anastadunbar\n// Reference: https://www.shadertoy.com/view/XljGzV\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Random color in HSV color space to keep a uniform palette\nvec3 rndColor(uint s) \n{\n    vec3 rnd = hash31(s);\n    return hsv2rgb(vec3(.5 + mod(rnd.x, .5), .8, .7 ));\n}\n\n//-- Text rendering utils based on FabriceNeyret2's shader\n// Reference: https://www.shadertoy.com/view/llySRh\n#define letter(id) (64 + id)\n#define number(id) (48 + id)\n#define space(uv)  uv.x -= .5;\n\nstruct DrawChar {\n    int  id;\n    vec2 position;\n    vec2 dx;\n    vec2 dy;\n};\n\nDrawChar defaultDrawChar() { return DrawChar(-1, vec2(-1.), vec2(-1.), vec2(-1.)); }\n\nvoid writeChar( int id, inout vec2 uv, inout DrawChar char ) \n{\n    uv.x -= .5;\n\n    vec2 dFdx = dFdx( uv / 16. ), dFdy = dFdy( uv / 16. );\n    if ( uv.x > .25 && uv.x < .75 && uv.y > .1 && uv.y < .85 )\n        char = DrawChar( id, uv, dFdx, dFdy );\n}\n\nvec4 drawChar( DrawChar char, sampler2D charTexture ) \n{\n    if( char.id < 0 )\n        return vec4(0,0,0,1e5);\n        \n    vec2 uv = char.position / 16. + fract( vec2(char.id, 15 - char.id / 16) / 16. );\n    return textureGrad( charTexture, uv, char.dx, char.dy );\n}\n\n//-- Textures utils\nvec2 toroidalMapping(vec3 p, vec2 r, float k) \n{\n    // Toroidal mapping\n    // Reference: https://www.shadertoy.com/view/sdd3R4\n    float a = atan(p.z, p.x + 1e-15);\n    float b = atan(p.y, (length(p.xz) - r.x) + 1e-15);\n    return vec2(mod(k * r.x * a / Pi, r.x), mod(1. + k * r.y * b / Tau, r.y));\n}\n\nfloat draw(float d, float w) { return smoothstep(.15, -.15, (length(w - d) - 2.5e-2)); }\nfloat truchetLabyrinth(vec2 uv) \n{\n    float Width = 11.;\n    \n    const float Radius    = .5;\n    const float LineWidth = 1e-2;\n    \n    vec2 id = uv * Width;\n    uv      = mod(uv, vec2(1. / Width)) * Width ;\n    \n    // Random tile orientation\n    float angle = Pi*.5 * floor(hash13(uvec3(id.x, id.y, 1)) * 3.);\n    uv -= .5;\n    rotate(uv, angle);\n    uv += .5;\n    \n    // [0, 1] -> [-1, 1]\n    uv *= 2.;\n    uv -= 1.;\n    \n    // Draw middle line\n    float l = abs(dot(uv, vec2(1.))) ;\n    return draw(abs(l * .5) - 1e-1, LineWidth);\n}\n\nfloat truchetArcs(vec2 uv) \n{       \n    float Width           = 9.;\n    const float Radius    = .5;\n    const float LineWidth = 1e-1;\n\n    // Tiling\n    vec2 id = uv * Width;\n    uv      = mod(uv, vec2(1. / Width)) * Width ;\n\n    // Random tile orientation\n    float angle = Pi*.5 * floor(hash13(uvec3(id.x, id.y, 2)) * 3.);\n    uv -= .5;\n    uv  = mat2(\n        cos(angle), -sin(angle), \n        sin(angle), cos(angle)\n    ) * uv;\n    uv += .5;\n    \n    // Draw circle parts\n    float l = length(uv - vec2(1.)) - Radius;\n    l = min(l, length(uv - vec2(0.)) - Radius);\n    \n    return draw(abs(l * 2.5), LineWidth);\n}\n\nvec3 jfig(vec2 uv, sampler2D charTexture) \n{\n    const vec3 MainColor      = vec3( 0.67, 0.81, 0.34 );\n    const vec3 SecondaryColor = vec3( .5 );\n    const vec3 Background     = vec3( 0. );\n    \n    // [0, 1] -> [-1, 1] & Scale\n    uv = uv * 2. - 1.;\n    uv *= 1.8;\n    \n    // Logo\n    float d  = length(uv) - 1.;    \n    float d2 = length(uv - vec2(.7, -.5)) - .25;\n    float d3 = length(uv - vec2(1.1, -.75)) - .125;\n    \n    vec3 color = Background;\n    if(-.3 < d && d < 0. && abs(-uv.x + uv.y) > 0.1 && abs(-uv.x - uv.y) > 0.1)\n        color = mix(MainColor, SecondaryColor, float(-uv.x + uv.y > 0.));\n    \n    if(d2 < 0.05)\n        color = mix(MainColor, Background, float(d2 > 0.));\n    else if(d3 < 0.)\n        color = MainColor;\n\n    // Text part: \"AFIG 30 ANS\"\n    DrawChar char  = defaultDrawChar();\n    vec2 textStart = uv * .81 - vec2(-1.05, 0.2);\n    vec2 charUv    = textStart * 0.78 - vec2(1.01, -.32);\n    \n#define writeLetter( id ) writeChar( letter( id ), charUv, char ) \n#define writeNumber( id ) writeChar( number( id ), charUv, char ) \n    writeLetter( 1 ); writeLetter( 6 ); writeLetter( 9 ); writeLetter( 7 );\n    \n    charUv = ( textStart * 1.07 - vec2(1.65, -1.2) );\n    writeNumber(3); writeNumber(0); charUv.x -= .2; writeLetter( 1 ); writeLetter( 14 ); writeLetter( 19 );\n#undef writeLetter\n#undef writeNumber\n    \n    color += float(drawChar(char, charTexture).x > 0.5) * MainColor;\n    return color;\n}\n\n//-- Reprojection utils\nvec2 getUV(vec3 position, vec2 resolution, vec3 mouse, int frame, float time, sampler2D noiseTexture)\n{\n    vec4 rotation = normalize(quat( time * .2, vec3(0., 1., 0.)));\n    vec3 ro = vec3( 5.75, 0., sin(time) * .2);\n    ro      = mul(rotation, ro);\n    \n    vec3 rd  = normalize(position - ro);\n    \n    if( mouse.z > 0. )\n    {\n        float moveSize = -mouse.x / resolution.x;\n        rotation = normalize(quat(Pi - moveSize * Tau, vec3(0., 1., 0.)));\n        rd       = mul(conjugate(rotation), rd);\n    }\n    \n    rotation = normalize(quat(1.15 * Pi + time * .2, vec3(0., 1., 0.)));\n    rd       = mul(conjugate(rotation), rd);\n    \n    const float focalLength = tan(Pi * .25);\n    \n    // Reference: https://www.shadertoy.com/view/wtcXz4\n    vec2 uv2 = rd.xy * focalLength / rd.z;\n    \n    // 4. [ -.5, .5 ] -> [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5] \n    uv2 = uv2 * resolution.y;\n    \n    // 3. [vec2(.5), iResolution.xy + .5] -> [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5]\n    uv2 = uv2 + resolution.xy * .5;\n    \n    // 2. Apply jittering [vec2(0), iResolution.xy]  \n    vec2 jitter = getBlueNoise(uv2, frame, noiseTexture).xy;\n    uv2         = uv2 - (jitter * .5 - .5);\n    \n    // 1. Center of pixels [vec2(0), iResolution.xy] -> [vec2(0.5), iResolution.xy + .5] \n    uv2 = uv2 - .5;\n        \n    return uv2;\n}\n\nvoid getCamera(vec2 fragCoord, vec2 resolution, vec3 mouse, int frame, float time, sampler2D noiseTexture, out vec3 ro, out vec3 rd) \n{    \n    // 1. Center of pixels [vec2(0), iResolution.xy] -> [vec2(0.5), iResolution.xy + .5] \n    vec2 uv = fragCoord + .5;\n    \n    // 2. Apply jittering [vec2(0), iResolution.xy]  \n    vec2 jitter = getBlueNoise(fragCoord, frame, noiseTexture).xy;\n    uv = fragCoord + (jitter * .5 - .5);\n\n    // 3. [vec2(.5), iResolution.xy + .5] -> [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5]\n    uv = uv - resolution.xy * .5;\n    \n    // 4. [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5] -> [ -.5, .5 ]\n    uv = uv / resolution.y;\n    \n    const float focalLength = tan(Pi * .25);\n    \n    rd = normalize(vec3(uv, focalLength));\n    ro = vec3( 5.75, 0., sin(time) * .2);\n    \n    vec4 rotation = normalize(quat(time * .2, vec3(0., 1., 0.)));\n    ro = mul(rotation, ro);\n    \n    rotation = normalize(quat(1.15 * Pi + time * .2, vec3(0., 1., 0.)));\n    rd = mul(rotation, rd);\n    \n    if( mouse.z > 0. )\n    {\n        float moveSize = -mouse.x / resolution.x;\n        rotation = normalize(quat(Pi - moveSize * Tau, vec3(0., 1., 0.)));\n        rd       = mul(rotation, rd);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// -- Pathtracing pass\n\nconst float SampleNb = 1.;\nconst int   BounceNb = 2;\n\nconst float ReprojectionRadius       = 2.;\nconst float ReprojectionWeightMoving = .1;\nconst float ReprojectionMaxDistance  = 25.;\n\n// The scene evaluation is split into two parts: Candles and Neons. \n// These evaluations are themselves defined by three functions: light sampling, \n// distance estimation, and material evaluation.\n\n// Neons part\nLightSample sampleLightNeon(vec3 p, vec4 u) \n{\n    vec3  position, wi, strength;\n    float pdf;\n    if( u.x > 0.5 ) \n    {\n        // Fake candle's fire light with spherical light above them\n        const float repetitions = 30.;\n        const float start       = -6. * Pi;\n        float stepSize          = 2.*Pi/repetitions;\n\n        // pModPolar id and sample neighborhing lights\n        float angle = atan(p.z, p.x + 1e-15) + stepSize * .5 + stepSize * .5 * (2. * u.y - 1.);\n        float r     = length(p);\n        float id    = floor(angle/stepSize);\n        if (abs(id) >= (repetitions/2.)) id = abs(id);\n\n        strength = 100. * rndColor(floatBitsToUint(id) + 10u);\n\n        position      = vec3(cos(angle) * 4.5, .65, sin(angle) * 4.5);\n        vec3 n        = normalize(position - p);\n        vec4 rotation = toLocalZ(n);\n\n        const float Radius = .1;\n        float sinThetaMax2 = Radius * Radius / max(1e-4, length2(p - position));\n        float cosThetaMax  = sqrt(max(0., 1. - sinThetaMax2));\n\n        wi = mul(conjugate(rotation), sampleCone(cosThetaMax,  u.zw, pdf));\n    }\n    else \n    {\n        const float Radius = 1.;\n        \n        vec4 rotation = normalize(quat( Pi/3. + iTime * .2, vec3(0., 1., 0.)));\n        position      = vec3( 6., 0., 0.);\n        position      = mul(rotation, position);\n        vec3 n        = normalize(position - p);\n        rotation      = toLocalZ(n);\n        strength      = 5. * normalize(p - position);\n\n        // Spherical light sampling from PBRT\n        // By: Matt Pharr, Wenzel Jakob, Greg Humphreys\n        // Reference: https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#fragment-Computecoordinatesystemforspheresampling-0\n        float sinThetaMax2 = Radius * Radius / max(1e-4, length2(p - position));\n        float cosThetaMax  = sqrt(max(0., 1. - sinThetaMax2));\n\n        wi = mul(conjugate(rotation), sampleCone(cosThetaMax,  u.zw, pdf));\n    }\n                        \n    return LightSample(position, wi, strength, pdf);\n}\n\nfloat sdSceneNeon(vec3 position) \n{\n    vec3  r = vec3(5., (abs(sin(iTime)) * 1. + 2.) * 0.02, 2.);\n    vec2  c = vec2(3. + 1. * abs(sin(iTime  * .5)), 5.);\n    float t = 45.;\n    float d = deTorusKnot(position.xzy, r, c, t);\n    \n    // Toroidal mapping\n    // Reference: https://www.shadertoy.com/view/sdd3R4\n    float R0 = 5., R1 = 2., k = 5.;\n    float a  = atan(position.z, position.x + 1e-15);\n    float dr = length(position.xz)-R0;\n    float b  = atan(position.y, dr + 1e-15);\n\n    float u = mod( k * R0 * a / Tau, Pi * .5);\n    float v = k * R1 * b/6.283;\n    vec2 uv = vec2( 1. - (.1 + u), .25 +v);\n    if(abs(position.y) < .45 && dr > 1.) \n        d = abs(sdTorus(position, vec2(5., 2.)));\n        \n    // Candles repetition\n    const float repetitions = 30.;\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    rotate(position.xz, iTime);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.03;\n    \n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n        \n    return min(d, d1);\n}\n\nMaterial sceneMaterialNeon(vec3 position) \n{\n    Material material = defaultMaterial();\n\n    vec3 pp = position;\n    \n    vec3  r = vec3(5., (abs(sin(iTime)) * 2. + 2.) * 0.02, 2.);\n    vec2  c = vec2(2. + 2. * abs(sin(iTime  * .5)), 5.);\n    float t = 45.;\n    float d = deTorusKnot(pp.xzy, r, c, t);\n    \n    material.baseColor = vec3(.7, .5, .5);\n    material.emission  = vec3(.0);\n    \n    // Toroidal mapping\n    // Reference: https://www.shadertoy.com/view/sdd3R4\n    float R0 = 5., R1 = 2., k = 5.;\n    float a  = atan(pp.z, pp.x + 1e-15);\n    float dr = length(pp.xz) - R0;\n    float b  = atan(pp.y, dr + 1e-15);\n\n    float u = mod( k * R0 * a / Tau, Pi );\n    float v = k * R1 * b / Tau;\n    vec2 uv = vec2( 2. - (.1 + u), .25 +v);\n    if(abs(pp.y) < .45 && dr > 1.) \n    {\n        d = abs(sdTorus(pp, vec2(5., 2.)));\n        \n        vec3 color         = jfig(uv + .25, iChannel3);\n        material.baseColor = color;\n        material.emission  = .5 * color;\n    }\n    \n    // Candles repetition\n    const float repetitions = 30.;\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    rotate(position.xz, iTime);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.03 + .3 * (hash11(floatBitsToUint(17. + id)) * 2. - 1.);\n    \n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n    if(d1 < d)\n    {\n        d = d1;\n        \n        material.baseColor = rndColor(floatBitsToUint(id) + 10u);\n        material.emission  = float(position.y > 0.1) * rndColor(floatBitsToUint(id) + 10u);\n    }\n        \n    return material;\n}\n\nLightSample sampleLightCandles(vec3 p, vec4 u) \n{\n    vec3  position, wi, strength;\n    float pdf;\n\n    // Fake candle's fire light with spherical light above them\n    const float repetitions = 30.;\n    const float start       = -6. * Pi;\n    float stepSize          = 2.*Pi/repetitions;\n\n    // pModPolar id and sample neighborhing lights\n    float angle    = atan(p.z, p.x + 1e-15) + stepSize/2. + stepSize * (u.y * 2. - 1.);\n    float r        = length(p);\n    float id       = floor(angle/stepSize);\n    if (abs(id) >= (repetitions/2.)) id = abs(id);\n\n    strength = 300. * rndColor(floatBitsToUint(id) + 10u);\n\n    position      = vec3(cos(angle) * 4., .5 + .5 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.) + .2 * sin(iTime + 2. * hash11(floatBitsToUint(id))), sin(angle) * 4.25);\n    vec3 n        = normalize(position - p);\n    vec4 rotation = toLocalZ(n);\n\n    // Spherical light sampling from PBRT\n    // By: Matt Pharr, Wenzel Jakob, Greg Humphreys\n    // Reference: https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#fragment-Computecoordinatesystemforspheresampling-0\n    const float Radius = .05;\n    float sinThetaMax2 = Radius * Radius / max(1e-4, length2(p - position));\n    float cosThetaMax  = sqrt(max(0., 1. - sinThetaMax2));\n\n    wi = mul(conjugate(rotation), sampleCone(cosThetaMax,  u.zw, pdf));\n                        \n    return LightSample(position, wi, strength, pdf);\n}\n\n// Truchet Candles\nfloat sdSceneCandles(vec3 position)\n{\n    // Environment\n    vec2 torusDimensions = vec2(5., 2.);\n    float d = abs(sdTorus(position, torusDimensions));\n    \n    // Logo rolling sphere from torus parametrization\n    float sphereRadius = .5;\n    float phi          = -.75 * (iTime - 10.);\n    float theta        = 2. * (iTime - 10.);\n    vec3 spherePosition = vec3(\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n        (torusDimensions.y - sphereRadius) * sin(theta),\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n    );\n\n    d = min(d, length(position - spherePosition) - sphereRadius);\n\n    for(float i = 0.; i < 3.; i++) \n    {\n        sphereRadius = .2;\n        phi          = -.75 * (iTime - 10. - i * .3);\n        theta        = 2. * (iTime - 10. - i * .3);\n        spherePosition = vec3(\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n            (torusDimensions.y - sphereRadius) * sin(theta),\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n        );\n\n        d = min(d, length(position - spherePosition) - sphereRadius);\n    }\n\n    // Candles repetition\n    const float repetitions = 30.;\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    rotate(position.xz, iTime);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.005;\n    \n    // Holder\n    float holderRadius = radius * hash11(floatBitsToUint(id));\n    float holderHeight = .06 * hash11(floatBitsToUint(id));\n    float holder = sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    );\n        \n    holderRadius = radius + .1;\n    holderHeight = .01;\n    d = min(d, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    ));\n    d = min(d, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight * 6., \n        holderRadius * .5\n    ));\n    \n    // Candle\n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n    \n    // Twisted effect from a box\n    vec4 qq = quat( 15. * position.y, vec3(0., 1., 0.));\n    vec3 q  = mul(qq, position);\n    \n    radius *= 5. + 4. * (hash11(floatBitsToUint(15. + id)) * 2. - 1.);\n    float d2 = sdBox(q, vec3(radius, height - .07, radius));\n    d2 -= .02; // Smoothen corners\n    \n    float candle = opSmoothUnion(d1, d2, .1);\n    d            = min(d, candle);\n    \n    // Flame\n    position.xz += .002 * sin(position.y * 2. + 10. * iTime + 10. * id);\n    float oscillatingSphere = length(position - vec3(0., height, 0.)) - 0.015 - sin(iTime) * 0.005;\n    float dFire             = opSmoothUnion(\n        sdCappedCylinder(position - vec3(0., height, 0.), .05, .005 ), \n        oscillatingSphere, \n        0.05\n    );\n    \n    return min(d, dFire);\n}\n\nMaterial sceneMaterialCandles(vec3 position) \n{\n    vec2 torusDimensions = vec2(5., 2.);\n    float d = abs(sdTorus(position, torusDimensions));\n    \n    Material material  = defaultMaterial();\n    material.baseColor = vec3(.7, .5, .5);\n    material.emission  = vec3(.0);\n    \n    vec2 uv = toroidalMapping(position, torusDimensions, 1.);\n    \n    // Angular repetition\n    const float repetitions = 30.;\n    float stepSize = 2. * Pi / repetitions;\n    float angle    = atan(position.z, position.x + 1e-15) + stepSize *.5;\n\n    // Rotating textures\n    const float start = -5.5 * Pi;\n    float generalTransition = sin((start + angle + iTime) * .2);\n    float textureTransition = (sin(start + angle + iTime) * 2. ) * 2. - 2.;\n\n    float s = smoothstep( -3.,  3., textureTransition );\n    uv = vec2(uv.x, s + uv.y) * 2.;\n    \n    // Procedural texturing\n    float t = mix(\n        truchetLabyrinth(uv),\n        truchetArcs(uv),\n        float(textureTransition < 0.)\n    );\n    \n    vec3 color1 = mix(\n        rgb(205,   3,  6),\n        rgb(155,   3, 175.),\n        float(textureTransition < 0.)\n    );\n\n    vec3 color2 = rgb(231, 167, 30);\n    if(generalTransition < 0.) \n    {\n        // Transition between textures\n        t = mix(t, 1., float(abs(textureTransition) < 0.05));\n\n        material.baseColor = mix(color1, color2, t);\n        material.emission  = abs(sin(iTime)) * .5 * mix(vec3(0.), color2, t);\n\n    }\n    else if(generalTransition < 0.001) // Transition between textures\n    {\n        material.baseColor = color2;\n        material.emission  = color2;\n    }\n    \n    // Logo rolling sphere from torus parametrization\n    float sphereRadius  = .5;\n    float phi           = -.75 * (iTime - 10.);\n    float theta         = 2. * (iTime - 10.);\n    vec3 spherePosition = vec3(\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n        (torusDimensions.y - sphereRadius) * sin(theta),\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n    );\n\n    float dSphere = length(position - spherePosition) - sphereRadius;\n    if(dSphere < d)\n    {\n        d = dSphere;\n        \n        material.baseColor = vec3(.5);\n        material.emission  = vec3(.5);\n    }\n\n    for(float i = 0.; i < 3.; i++) \n    {\n        sphereRadius = .2;\n        phi          = -.75 * (iTime - 10. - i * .3);\n        theta        = 2. * (iTime - 10. - i * .3);\n        spherePosition = vec3(\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n            (torusDimensions.y - sphereRadius) * sin(theta),\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n        );\n\n        dSphere = min(dSphere, length(position - spherePosition) - sphereRadius);\n    }\n\n    if(dSphere < d)\n    {\n        d = dSphere;\n        \n        material.baseColor = vec3(0.67, 0.81, 0.34);\n        material.emission  = vec3(0.1, 0.8, 0.1);\n    }\n    \n    // Candles repetition\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.005;\n    \n    // Holder\n    float holderRadius = radius * hash11(floatBitsToUint(id));\n    float holderHeight = .06 * hash11(floatBitsToUint(id));\n    float holder = sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    );\n    \n    holderRadius = radius + .1;\n    holderHeight = .01;\n    holder = min(holder, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    ));\n    holder = min(holder, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight * 6., \n        holderRadius * .5\n    ));\n    if( holder < d )\n    {\n        d = holder;\n        material.baseColor = rndColor(floatBitsToUint(id) + 10u);\n        material.emission  = vec3(0.);\n    }\n    \n    // Candle\n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n    \n    // Twisted effect from a box\n    vec4 qq = quat( 15. * position.y, vec3(0., 1., 0.));\n    vec3 q  = mul(qq, position);\n    \n    radius *= 5. + 4. * (hash11(floatBitsToUint(15. + id)) * 2. - 1.);\n    float d2 = sdBox(q, vec3(radius, height - .07, radius));\n    d2 -= .02; // Smoothen corners\n    \n    float candle = opSmoothUnion(d1, d2, .1);\n    if(candle < d)\n    {\n        d = candle;\n        material.baseColor = vec3(1.);\n        material.emission  = vec3(0.);\n    }\n    \n    position.xz += .002 * sin(position.y * 2. + 10. * iTime + 10. * id);\n    float oscillatingSphere = length(position - vec3(0., height, 0.)) - 0.015;\n    float dFire             = opSmoothUnion(\n        sdCappedCylinder(position - vec3(0., height, 0.), .05, .005 ), \n        oscillatingSphere, \n        0.05\n    );\n    if(dFire < d)\n    {\n        d = dFire;\n        material.baseColor = rndColor(floatBitsToUint(id) + 10u);\n        material.emission  = .5 * rndColor(floatBitsToUint(id) + 10u);\n    }\n    \n    return material;\n}\n\n// Mixup geometry\nbool isNeon(vec3 position) \n{\n    const float repetitions = 30.;\n    float stepSize = 2. * Pi / repetitions;\n    float angle    = atan(position.z, position.x + 1e-15) + stepSize *.5;\n    \n    const float start = -7. * Pi;\n    return sin((start + angle + max(iTime, 15.)) * .3) > 0.;\n}\n\nbool isBound(vec3 position) {\n    const float repetitions = 30.;\n    float stepSize = 2. * Pi / repetitions;\n    float angle    = atan(position.z, position.x + 1e-15) + stepSize *.5;\n    \n    const float start = -7. * Pi;\n    return abs(sin((start + angle + max(iTime, 15.)) * .3)) < 1e-2;\n}\n\n// General scene functions\nLightSample sampleLight(vec3 position, vec4 u)\n{\n    if(isNeon(position))\n        return sampleLightNeon(position, u);\n\n    return sampleLightCandles(position, u);\n}\n\nfloat sdScene(vec3 position) \n{\n    if(isNeon(position))\n        return sdSceneNeon(position);\n    return sdSceneCandles(position);\n}\n\nMaterial sceneMaterial(vec3 position) \n{    \n    Material material;\n    if(isNeon(position))\n        material = sceneMaterialNeon(position);\n    else \n        material = sceneMaterialCandles(position);\n\n    if(isBound(position))\n        material.emission = vec3(0.6, 1., 1.);\n        \n    return material;\n}\n\n// Map normal estimation\n// by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nconst float stepSize = 0.00001;\nvec3 normal(vec3 pos)\n{\n    const vec2 e = vec2(1.0, -1.0) * 0.5773 * stepSize;\n    return normalize( e.xyy*sdScene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdScene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdScene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sdScene( pos + e.xxx ) );\n}\n\n// Sphere tracing\nHitInfo trace(vec3 ro, vec3 rd, float tMax) \n{\n    HitInfo hitInfo   = defaultHitInfo();\n    bool  hit         = false;\n    float t           = 0.;\n    vec3  p           = vec3(0.);\n    for(int i = 0; i < 150 && t < tMax; i++)\n    {\n        float d = sdScene(p = ro + rd * t);\n        t      += max(abs(d), stepSize);\n        \n        // Hit offset depending on depth. Less precision when far away\n        if(d < 2e-3 * t) \n        {\n            hitInfo.t = t;\n            break;\n        }\n    }\n    \n    if( hitInfo.t > 0. )\n        hitInfo.normal = normal(p);        \n    \n    return hitInfo;\n}\n\n// Pathtracing integrator\nvec3 render(vec2 fragCoord, int frame, inout HitInfo firstHit)\n{\n    vec4 alea = getBlueNoise(fragCoord, frame, iChannel2);\n\n    vec3 ro, rd;\n    getCamera(fragCoord, iResolution.xy, iMouse.xyz, frame, iTime, iChannel2, ro, rd);\n\n    vec3 throughput = vec3(1.);\n    vec3 finalColor = vec3(0.);\n    firstHit.t = -1.;\n    \n    float bound = 15.;\n    for(int b = 0; b < BounceNb; b++) \n    {\n        HitInfo hit = trace(ro, rd, bound);\n        if(hit.t < 0.) \n            break;\n        \n        if( b == 0 ) \n            firstHit = hit;\n        \n        vec3 position = ro + rd * hit.t;\n        vec3 n        = hit.normal;\n        n            *= sign(dot(n, -rd));\n\n        Material material = sceneMaterial(position);\n        finalColor += throughput * material.emission;\n        \n\n        vec3 pposition = offsetRay(position, hit.normal);\n        vec4 transform = toLocalZ(hit.normal);\n        hit.normal     = vec3(0., 0., 1.);\n        \n        vec3 woLocal   = normalize(mul(transform, -rd));\n        vec3 direct    = vec3( 0. );\n\n        // Direct lighting\n        {\n            LightSample lightSample = sampleLight(pposition, alea);\n            \n            vec3  wiLocal  = normalize(mul(transform, lightSample.wi));\n            float cosTheta = wiLocal.z;\n            if(lightSample.pdf > 0. && cosTheta > 0.) \n            {\n                if(trace(pposition + lightSample.wi * 1e-1, lightSample.wi, length(pposition - lightSample.position)).t < 0.) \n                {\n                    vec3 brdf = min(evalLambertian(material) * cosTheta, vec3(1.));\n                    direct   += brdf * lightSample.intensity / max(1e-4, lightSample.pdf);\n                }\n            }            \n        }\n        finalColor += throughput * direct;\n\n        vec3  weight        = evalLambertian( material );\n        vec3  wiLocal       = sampleLambertian( woLocal, alea.wx );\n        float scatteringPdf = getPdfLambertian( woLocal, wiLocal );\n                \n        float cosTheta = abs(woLocal.z);\n        throughput    *= clamp(weight * cosTheta / max(1e-4, scatteringPdf), vec3(0.), vec3(1.));\n\n        if(any(isinf(throughput)) || any(isnan(throughput)) )\n            return vec3(0., 0., 0.);\n    \n        float luminance = getLuminance(throughput);\n        if(luminance == 0. )\n            return vec3(0.);\n\n        rd   = normalize(mul(conjugate(transform), wiLocal));\n        ro   = offsetRay(position, n);\n        alea = getBlueNoise(fragCoord, frame, iChannel2);\n    }\n\n    return clamp(finalColor, vec3(0.), vec3(1.));\n}\n\nfloat sampleDistance(vec3 position, vec3 color, vec3 position2, vec3 color2) \n{\n    vec3 colorDistance = rgb2lab(color) - rgb2lab(color2);\n    return .001*length(position - position2) + .01*dot(colorDistance, colorDistance);\n}\n\n// #define DEBUG\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    \n#ifdef DEBUG\n    int frame = 0 * int(iFrame);\n\n    vec3 ro, rd;\n    getCamera(fragCoord, iResolution.xy, iMouse.xyz, frame, iTime, iChannel2, ro, rd);\n\n    HitInfo hit = trace(ro, rd, 100.);\n    \n    fragColor.rgb = hit.normal * .5 + .5;\n    fragColor.w   = 1.;\n    return;\n#else    \n    vec4 data = vec4(0.);\n    HitInfo hit = defaultHitInfo();\n    for (float i = 0.; i < SampleNb; i++) \n        data.rgb += render(fragCoord, int(float(iFrame) * SampleNb + i), hit) / SampleNb;\n    data.rgb = clamp(data.rgb, vec3(0.), vec3(1.));\n    \n    int currentFrame = int(float(iFrame) * SampleNb + SampleNb - 1.);\n\n    vec3 ro, rd;\n    getCamera(fragCoord, iResolution.xy, iMouse.xyz, currentFrame, iTime, iChannel2, ro, rd);\n    \n    vec3 position     = ro + rd * hit.t;\n    Material material = sceneMaterial(position);\n    \n    vec2 mouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 1), 0).w,\n        texelFetch(iChannel0, ivec2(0, 2), 0).w\n    );\n    int previousFrame = int(float(iFrame - 1) * SampleNb + SampleNb - 1.);\n    vec2 fragCoord2   = getUV( position, iResolution.xy, iMouse.xyz, previousFrame, iTime, iChannel2 );\n    \n    float type       = (any(greaterThan(material.emission, vec3(0.))) ? -1. : 1.);\n    bool wasRendered = all(lessThan(fragCoord2, iResolution.xy)) \n                    && all(greaterThan(fragCoord2, vec2(0.)));\n    \n    \n    vec2 lastResolution  = texelFetch(iChannel0, ivec2(1), 0).rg;\n    bool lastBufferValid = iFrame > 0 && all(equal(lastResolution, iResolution.xy));\n    if(hit.t > 0. && wasRendered) \n    {\n        // Reproject from best sample in neighboring pixels\n        vec2  coordinates     = vec2(0.);\n        float closestDistance = 1000000.;\n        vec3  closestSample   = vec3(0.);\n        \n        vec3 minColor = vec3( 1000.);\n        vec3 maxColor = vec3(-1000.);\n        \n        float radius = max(4., (ReprojectionRadius / 1280.) * iResolution.x);\n        for(float x = -radius; x <= radius; x++)\n        {\n            for(float y = -radius; y <= radius; y++)\n            {\n                vec2 sampleUv = fragCoord2 + vec2(x, y);\n\n                vec3 rro, rrd;\n                getCamera(sampleUv, iResolution.xy, iMouse.xyz, previousFrame, iTime, iChannel2, rro, rrd);\n                \n                vec4  cSample      = texelFetch( iChannel1, ivec2(sampleUv), 0 );\n                vec3  sampleColor  = cSample.rgb;\n                float previousT    = cSample.w;\n                float previousType = sign(cSample.w);\n                previousT          = abs(previousT);\n                vec3  previousP    = rro + rrd * previousT;\n                \n                float currentDistance = sampleDistance(position, data.rgb, previousP, sampleColor);\n                if(currentDistance < closestDistance)\n                {\n                    coordinates     = sampleUv;\n                    closestDistance = currentDistance; \n                    closestSample   = sampleColor;\n                }\n                \n                minColor = min(minColor, sampleColor);\n                maxColor = max(maxColor, sampleColor);\n            }\n        }\n        \n        // Do not reproject if closest sample is too far away\n        //if(closestDistance < ReprojectionMaxDistance)\n        {\n            // Limit ghosting\n            closestSample = clamp(closestSample, minColor, maxColor);\n            \n            // Moving average\n            vec4  cSample     = texelFetch( iChannel1, ivec2(coordinates), 0 );\n            vec3  sampleColor = clamp(cSample.rgb, minColor, maxColor);\n            data.rgb = mix((closestSample*.7+sampleColor*.3), data.rgb, ReprojectionWeightMoving);\n        }\n    }\n\n    // Tag emissive materials for denoise pass\n    data.w = hit.t > 0. ? hit.t * type : 0.;\n    fragColor = data;\n    \n    if(dot(fragCoord, fragCoord) < 1e-4)\n        fragColor.rg = iResolution.xy;\n\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// -- Denoising pass \n// Mostly combining the following papers\n\n// Edge-Avoiding À-Trous Wavelet Transform for fast Global Illumination Filtering\n// High Performance Graphics 2010,  Holger Dammertz, Daniel Sewtz, Johannes Hanika, Hendrik P.A. Lensch\n\n// SPATIOTEMPORAL VARIANCE - RECONSTRUCTION FOR PATH REAL GLOBAL ILLUMINATION\n// https://www.highperformancegraphics.org/wp-content/uploads/2017/Papers-Session1/HPG2017_SpatiotemporalVarianceGuidedFiltering.pdf\n\n// Nice additional reference from Lesley Lay: https://www.youtube.com/watch?v=_NwJd0pg4Fo\n\n// Evaluation weights from ASVGF implementation\n// Gradient Estimation for Real-Time Adaptive Temporal Filtering\n// Christoph Schied, Christoph Peters, and Carsten Dachsbacher\n// Reference: https://cg.ivd.kit.edu/atf.php\nvec2  offsets[24] = vec2[](vec2(-2, -2), vec2(-2, -1), vec2(-2,  0), vec2(-2,  1), vec2(-2,  2), vec2(-1, -2), vec2(-1, -1), vec2(-1,  0), vec2(-1,  1), vec2(-1,  2), vec2( 0, -2), vec2( 0, -1), vec2( 0,  1), vec2( 0,  2), vec2( 1, -2), vec2( 1, -1), vec2( 1,  0), vec2( 1,  1), vec2( 1,  2), vec2( 2, -2), vec2( 2, -1), vec2( 2,  0), vec2( 2,  1), vec2( 2,  2));\nfloat weights[24] = float[](1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 6.0, 2.0 / 3.0, 2.0 / 3.0, 1.0 / 6.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0);\n\n// Reprojection\nvec3 getPosition(ivec2 fragCoord, float frameId, float depth) \n{\n    vec2 mouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 1), 0).w,\n        texelFetch(iChannel0, ivec2(0, 2), 0).w\n    );\n    \n    vec3 ro, rd;\n    getCamera(vec2(fragCoord), iResolution.xy, iMouse.xyz, int(frameId), iTime, iChannel1, ro, rd);\n    \n    return ro + rd * depth;\n}\n\n// Filtering\nvoid evaluate(inout vec3 sum, inout float cumW, vec3 color, vec3 position, float type, float frameId, float stepWidth, vec2 fragCoord, vec2 offset, float kernelValue)\n{\n    vec2 uv = fragCoord + offset * stepWidth; \n    \n    vec4  sampleData  = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3  sampleColor = sampleData.rgb;\n    \n    float sampleDepth = sampleData.w;\n    float sampleType  = sign(sampleDepth);\n    \n    sampleDepth = abs(sampleDepth);\n        \n    // Weights from cornusammonis's shader\n    // Reference: https://www.shadertoy.com/view/ldKBRV\n    float cPhi = 0.5;\n    float pPhi = 0.25;\n\n    vec3 samplePosition = getPosition(ivec2(fragCoord), frameId, sampleDepth);\n    vec3  positionDiff  = position - samplePosition;\n    float positionDist  = dot(positionDiff, positionDiff);\n    if(sampleDepth == 0. || sampleType != type)\n        return;\n\n    vec3  colorDiff = rgb2lab(color) - rgb2lab(sampleColor);\n    float colorDist = dot(colorDiff, colorDiff);\n    float wc        = min(exp(-colorDist / cPhi), 1.);\n\n    float wp           = min(exp(-positionDist / pPhi ), 1.);\n    float weight       = wc * wp; \n\n    sum  += sampleColor * weight * kernelValue; \n    cumW += weight * kernelValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    int   seed    = iFrame;\n    float frameId = float(iFrame);\n    vec4  buffer  = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n    float depth   = buffer.w;\n    float type    = sign(depth);\n    depth         = abs(depth);\n    \n    // Only filter pixels with an intersection\n    if(depth > 0.)\n    {\n        vec3  sum  = vec3(0.0);\n        float cumW = 0.0;\n        \n        vec3 position = getPosition(ivec2(fragCoord), frameId, depth);\n        vec3 color    = buffer.rgb;\n\n        // Random step width from: https://www.shadertoy.com/view/ldKBRV\n        float size   = (2. / 1280.) * iResolution.x;\n        float offset = (0. / 1280.) * iResolution.x;\n        float stepWidth = getBlueNoise(vec2( fragCoord.x + 3. + iTime * 2., fragCoord.y * 4. + iTime), seed, iChannel1).x * size + offset;\n        for(int i = 0; i < 24; i++)\n        {\n            vec2  offset = offsets[i];\n            float weight = weights[i];\n            evaluate(sum, cumW, color, position, type, frameId, stepWidth, fragCoord, offset, weight);\n        }\n\n        buffer.rgb = clamp(sum / cumW, vec3(0.), vec3(1.));\n    }\n    \n    fragColor = buffer;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// -- Denoising pass \n// Mostly combining the following papers\n\n// Edge-Avoiding À-Trous Wavelet Transform for fast Global Illumination Filtering\n// High Performance Graphics 2010,  Holger Dammertz, Daniel Sewtz, Johannes Hanika, Hendrik P.A. Lensch\n// https://github.com/LWJGL/lwjgl3-demos/blob/main/src/org/lwjgl/demo/opengl/raytracing/tutorial/Tutorial8.java#L899\n\n// SPATIOTEMPORAL VARIANCE - RECONSTRUCTION FOR PATH REAL GLOBAL ILLUMINATION\n// https://www.highperformancegraphics.org/wp-content/uploads/2017/Papers-Session1/HPG2017_SpatiotemporalVarianceGuidedFiltering.pdf\n\n// Nice additional reference from Lesley Lay: https://www.youtube.com/watch?v=_NwJd0pg4Fo\n\n// Evaluation weights from ASVGF implementation\n// Gradient Estimation for Real-Time Adaptive Temporal Filtering\n// Christoph Schied, Christoph Peters, and Carsten Dachsbacher\n// Reference: https://cg.ivd.kit.edu/atf.php\nvec2  offsets[24] = vec2[](vec2(-2, -2), vec2(-2, -1), vec2(-2,  0), vec2(-2,  1), vec2(-2,  2), vec2(-1, -2), vec2(-1, -1), vec2(-1,  0), vec2(-1,  1), vec2(-1,  2), vec2( 0, -2), vec2( 0, -1), vec2( 0,  1), vec2( 0,  2), vec2( 1, -2), vec2( 1, -1), vec2( 1,  0), vec2( 1,  1), vec2( 1,  2), vec2( 2, -2), vec2( 2, -1), vec2( 2,  0), vec2( 2,  1), vec2( 2,  2));\nfloat weights[24] = float[](1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 6.0, 2.0 / 3.0, 2.0 / 3.0, 1.0 / 6.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0);\n\n// Reprojection\nvec3 getPosition(ivec2 fragCoord, float frameId, float depth) \n{\n    vec2 mouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 1), 0).w,\n        texelFetch(iChannel0, ivec2(0, 2), 0).w\n    );\n    \n    vec3 ro, rd;\n    getCamera(vec2(fragCoord), iResolution.xy, iMouse.xyz, int(frameId), iTime, iChannel1, ro, rd);\n    \n    return ro + rd * depth;\n}\n\n// Filtering\nvoid evaluate(inout vec3 sum, inout float cumW, vec3 color, vec3 position, float type, float frameId, float stepWidth, vec2 fragCoord, vec2 offset, float kernelValue)\n{\n    vec2 uv = fragCoord + offset * stepWidth; \n    \n    vec4  sampleData  = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3  sampleColor = sampleData.rgb;\n    \n    float sampleDepth = sampleData.w;\n    float sampleType  = sign(sampleDepth);\n    \n    sampleDepth = abs(sampleDepth);\n    \n    vec3 samplePosition = getPosition(ivec2(fragCoord), frameId, sampleDepth);\n    vec3  positionDiff  = position - samplePosition;\n    float positionDist  = dot(positionDiff, positionDiff);\n\n    if(sampleDepth == 0. || sampleType != type)\n        return;\n        \n    // Weights from cornusammonis's shader\n    // Reference: https://www.shadertoy.com/view/ldKBRV\n    float cPhi = 0.5;\n    float pPhi = 0.25;\n\n    vec3  colorDiff = rgb2lab(color) - rgb2lab(sampleColor);\n    float colorDist = dot(colorDiff, colorDiff);\n    float wc        = min(exp(-colorDist / cPhi), 1.);\n\n    float wp           = min(exp(-positionDist / pPhi ), 1.);\n    float weight       = wc * wp; \n\n    sum  += sampleColor * weight * kernelValue; \n    cumW += weight * kernelValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    int   seed    = iFrame;\n    float frameId = float(iFrame);\n    vec4  buffer  = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n    float depth   = buffer.w;\n    float type    = sign(depth);\n    depth         = abs(depth);\n    \n    // Only filter pixels with an intersection\n    if(depth > 0.)\n    {\n        vec3  sum  = vec3(0.0);\n        float cumW = 0.0;\n        \n        vec3 position = getPosition(ivec2(fragCoord), frameId, depth);\n        vec3 color    = buffer.rgb;\n\n        // Random step width from: https://www.shadertoy.com/view/ldKBRV\n        float size   = (4. / 1280.) * iResolution.x;\n        float offset = (0. / 1280.) * iResolution.x;\n        float stepWidth = 2.;//getBlueNoise(vec2( fragCoord.x + 3. + iTime * 2., fragCoord.y * 5. + iTime), seed, iChannel1).x * size + offset;        \n        for(int i = 0; i < 24; i++)\n        {\n            vec2  offset = offsets[i];\n            float weight = weights[i];\n            evaluate(sum, cumW, color, position, type, frameId, stepWidth, fragCoord, offset, weight);\n        }\n\n        buffer.rgb = clamp(sum / cumW, vec3(0.), vec3(1.));\n    }\n    \n    fragColor = buffer;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// -- 2D Pass for first screen display\nfloat draw(float x, float x0, float r) { return smoothstep( .01, .0,  abs(x-x0)-r/2.); }\n\nfloat artDecoStraight(vec2 uv)\n{\n    const float Width = 4.;\n    \n    // Rhomb\n    vec2 o = uv;\n    uv.x = o.y + 2. * o.x; \n    uv.y = o.y - 2. * o.x; \n\n    // Repeat\n    vec2 id = floor(uv * Width); \n    uv      = mod(uv * Width, 1.);\n            \n    // Angular repetition\n    uv = uv * 2.;\n    float Repetitions = 36.;\n    float angle = Tau / Repetitions;\n\n    float a  = atan(uv.y, uv.x) + angle/2.;\n\tfloat r  = length(uv);\n\tfloat c  = floor(a/angle);\n\ta        = mod(a,angle) - angle/2.;\n\tvec2 uv2 = vec2(cos(a), sin(a))*r;\n    \n    // The line is drawn for every section of the disk\n    float d = 1. - draw(abs(a) - .05, .1, .2);\n    return d * clamp(length(uv) - .5, 0., 2.);\n\n}\n\n#define rgb(c1, c2, c3) vec3(c1, c2, c3) / 255.\nconst vec3 MainColor      = rgb(251, 217, 130);\nconst vec3 SecondaryColor = rgb(195,  90, 76);\nconst vec3 ThirdColor     = rgb(255, 255, 190);\n\nconst float ReprojectionWeight = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    int  seed            = int(iFrame);\n    vec2 lastResolution  = texelFetch(iChannel0, ivec2(0), 0).xy;\n    bool lastBufferValid = length(lastResolution - iResolution.xy) < 1e-1;\n    vec4 previous        = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    vec2 uv  = ((fragCoord + .5) / iResolution.y);\n    vec2 uuv = ((fragCoord + .5) / iResolution.xy);\n    vec4 alea      = getBlueNoise(vec2(fragCoord), seed, iChannel2);\n    vec2 jittering = (alea.xy * 1.5 - 1.) / iResolution.xy;\n    uv            += jittering;\n    uuv           += jittering;\n    \n    // Top and bottom parts\n    float slider = max(iTime * .5 - 3., 0.);\n    if( abs( uuv.y - .5 ) - ( .18 + slider ) > 0.)\n        fragColor.rgb = mix(SecondaryColor, ThirdColor, artDecoStraight(uv));\n    \n    // Centered lines \n    fragColor.rgb = mix(fragColor.rgb, SecondaryColor, float(abs(abs(uv.y - .5 ) - (.16 + slider) ) < 5e-3));\n    fragColor.rgb = mix(fragColor.rgb, SecondaryColor, float(abs(abs(uv.y - .5 ) - (.18 + slider) ) < 5e-3));\n\n    // Temporal accumulation + smooth apparition effect\n    if(abs(uuv.y - .5) - (.15 + slider) > 0. && iTime > 0.1 && lastBufferValid)\n        fragColor = mix(previous, fragColor, ReprojectionWeight);\n\n    // Tag rendered pixels\n    fragColor.w = float(dot(fragColor.rgb, fragColor.rgb) > 0.);\n\n    // Text\n    #define writeLetter( id ) writeChar( letter( id ), charUv, char ) \n    #define writeNumber( id ) writeChar( number( id ), charUv, char ) \n    \n    DrawChar char = defaultDrawChar();\n    float text1 = uv.x * uv.y * .5 + iTime * .5 - 1.;\n    float text2 = uv.x * uv.y * .5 + iTime * .5 - 2.1;\n    if(text1 < 1.)\n    {\n        // \"JFIG 2023\"\n        vec2 charUv = ( uv - vec2(-.03, .345)) * 3.25; writeLetter(10); writeLetter(6); writeLetter(9); writeLetter(7); \n        charUv.x -= .5;                                writeNumber(2); writeNumber(0); writeNumber(2); writeNumber(3);\n    }\n    else if(text2 > 0. && text2 < 1.2)\n    {\n        // \"AFIG 30 ANS\"  \n        vec2 charUv = (uv - vec2(.055, .42) ) * 4.; writeLetter(1); writeLetter(6); writeLetter(9); writeLetter(7);\n        charUv      = (uv - vec2(.665, .32) ) * 4.; writeNumber(3); writeNumber(0); charUv.x-=.25;  writeLetter(1); writeLetter(14); writeLetter(19);\n    }\n    \n    // Render text\n    vec4 text = drawChar(char, iChannel1);\n    if(text.x > 0.)\n    {\n        // Normalization of the text sdf from Marble Marcher: SE\n        // Reference: https://www.shadertoy.com/view/3lKyDR\n        float sdf = (text.w - .5 + 1. / 256.) * 75.;\n                \n        fragColor.rgb = MainColor;\n        fragColor.w   = smoothstep(.1, .0, sdf );\n        \n        if(iTime > 0.1 && lastBufferValid) \n        {\n            fragColor.rgb = mix(previous.rgb, fragColor.rgb, ReprojectionWeight);\n            fragColor.w   = mix(previous.w,   fragColor.w,   ReprojectionWeight);\n        }\n    }\n    \n    slider = clamp(iTime * .25 - 36. / 4., 0., 1.);\n    if( abs( uuv.y - .5 ) - (1. - slider) >= 0. ){\n        fragColor.rgb = mix(SecondaryColor, ThirdColor, artDecoStraight(uv) * 1.5);\n        fragColor.w   = 1.;\n        \n        if(iTime > 0.1 && lastBufferValid)\n            fragColor = mix(previous, fragColor, ReprojectionWeight);\n    }\n    \n    if(fragCoord.x < 1. && fragCoord.y < 1.)\n        fragColor.rg = iResolution.xy;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}