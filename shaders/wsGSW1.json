{
    "Shader": {
        "info": {
            "date": "1573874414",
            "description": "Created by iq in 2013-10\n\nhttps://www.shadertoy.com/view/4s23zz",
            "flags": 0,
            "hasliked": 0,
            "id": "wsGSW1",
            "likes": 5,
            "name": "Warping - procedural test3",
            "published": 3,
            "tags": [
                "warping"
            ],
            "usePreview": 0,
            "username": "RaduBT",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See https://iquilezles.org/articles/warp for details\n\n// https://www.shadertoy.com/view/4s23zz\n\n// undefine this on old/slow computers\n#define SLOW_NORMAL\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,1.1459123));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  1.60, -0.60,  0.90 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*3.02;\n    f += 0.250000*noise( p ); p = mtx*p*4.03;\n    f += 0.125000*noise( p ); p = mtx*p*5.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*5.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2( fbm4(p+vec2(1.0)), fbm4(p+vec2(6.2)) );\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2( fbm6(p+vec2(9.2)), fbm6(p+vec2(5.7)) );\n}\n\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    q += 0.05*sin(vec2(0.11,0.13)*iTime + length( q )*4.0);\n    \n    q *= 0.7 + 0.2*cos(0.15*iTime);\n\n    o = 0.5 + 0.5*fbm4_2( q );\n    \n    o += 0.02*sin(vec2(0.11,0.13)*iTime*length( o ));\n\n    n = fbm6_2( 4.0*o );\n\n    vec2 p = q + 2.0*n + 1.0;\n\n    float f = 0.5 + 0.5*fbm4( 2.0*p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 of = vec2(0.0);//hash2( float(iTime)*1113.1 + fragCoord.x + fragCoord.y*119.1 );\n\n    \n\tvec2 p = fragCoord / iResolution.xy;\n\tvec2 q = (-iResolution.xy + 2.0*(fragCoord+of)) /iResolution.y;\n\t\n    vec2 o, n;\n    float f = func(q, o, n);\n    vec3 col = vec3(0.0);\n\n\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n    col = mix( col, vec3(0.5,0.2,0.2), 0.5*o.y*o.y );\n\n\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n\n    col *= f*2.0;\n    \n#ifdef SLOW_NORMAL\n    vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n    vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n\tvec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n#else\n    vec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 1.7, dFdy(f)*iResolution.y ) );\t\n#endif\n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 bdrf;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n\n    col *= bdrf;\n\n    col = vec3(1.0)-col;\n\n    col = col*col;\n\n    col *= vec3(1.2,1.25,1.2);\n\t\n\tcol *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}