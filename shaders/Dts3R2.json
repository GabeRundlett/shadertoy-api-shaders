{
    "Shader": {
        "info": {
            "date": "1703442664",
            "description": "A simple Christmas Tree made from 2D points. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Dts3R2",
            "likes": 51,
            "name": "Christmas Tree 2023",
            "published": 3,
            "tags": [
                "2d",
                "christmas",
                "sdf",
                "points"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 1863
        },
        "renderpass": [
            {
                "code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A simple christmas tree made from 2D points.\n*\n*/\n\n#define PI 3.1415926535\n#define TAU 6.2831853071\n#define ROTATE(v, x) mat2(cos(x), sin(x), -sin(x), cos(x)) * v\n#define REMAP_HALF_NDC(x, c, d) (((x + 0.5) * (d - c)) + c) // Remap from [-0.5, 0.5] domain to [c, d]\n\n#define N 512.0\n#define N_ONE_QUARTER N * 0.25\n// This is mostly to cull any points at the bottom that are too close to the \"camera\".\n#define N_OFFSET 1.0\n#define STAR_N 7.0\n#define STAR_BEAM_THICKNESS 3.0\n\nconst vec3 LIGHT_COLORS[3] = vec3[3](\n                                        vec3(1.0,  0.05,  0.05), \n                                        vec3(0.05, 1.0,   0.05), \n                                        vec3(1.0,  0.25,  0.05)\n                                    );\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Signed distance to an n-star polygon with external angle en by iq: https://www.shadertoy.com/view/3tSGDy\nfloat SignedDistanceNStar2D(in vec2 p, in float r, in float an, in float bn, in vec2 acs, in float m) // m=[2,n]\n{\n    float en = PI / m;\n    vec2  ecs = vec2(cos(en), sin(en));\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nvoid DrawStar(in vec2 uv, in float time, inout vec3 outColor)\n{\n    uv -= vec2(0.001, 0.225);\n    uv = ROTATE(uv, time * 0.75);\n    // Some common pre-calculation in order to avoid duplication\n    float an = PI / STAR_N;\n    float bn = mod(atan(uv.x, uv.y), 2.0 * an) - an;\n    vec2 acs = vec2(cos(an), sin(an));\n    // Top star\n    outColor += 5e-4 / pow(abs(SignedDistanceNStar2D(uv, 0.01, an, bn, acs, STAR_N * 0.5)), 1.23) * LIGHT_COLORS[2];\n    // Star beams\n    outColor += smoothstep(STAR_BEAM_THICKNESS / max(iResolution.x, iResolution.y), 0.0, SignedDistanceNStar2D(uv, 1.5, an, bn, acs, STAR_N)) * \n        LIGHT_COLORS[2] * smoothstep(0.75, -5.0, length(uv));\n}\n\nvoid DrawTree(in vec2 uv, in float time, inout vec3 outColor)\n{\n    float u, theta, pointHeight, invN = 1.0 / N;\n    vec2 st, hash, layer;\n    vec3 pointOnCone, pointColor = vec3(1.0);\n    const vec2 radius = vec2(1.5, 3.2);\n    uvec3 colorThreshold;\n    for (float i = N_OFFSET; i < N; ++i)\n    {\n        // Modify this to change the tree pattern\n        hash = Hash21(2.0 * TAU * i);\n        \n        // Some basic light color based on hash\n        colorThreshold.x = uint(hash.x < 0.45); // red;\n        colorThreshold.y = 1u - colorThreshold.x; // green\n        colorThreshold.z = uint(hash.x > 0.9); // white;\n        pointColor = vec3(colorThreshold | colorThreshold.z);\n        \n        // Calculate point on cone based on: https://mathworld.wolfram.com/Cone.html\n        u = i * invN;\n        theta = 1609.0 * hash.x + time * 0.5;\n        pointHeight = 1.0 - u;\n        \n        // Split the cone into layers to make it look more like a christmas tree\n        layer = vec2(3.2 * mod(i, N_ONE_QUARTER) * invN, 0.0);\n        pointOnCone = 0.5 * (radius.xyx - layer.xyx) * vec3(pointHeight * cos(theta), u - 0.5, pointHeight * sin(theta)); // [-0.5, 0.5]\n        \n        // Scale uv based on depth of the point\n        st = uv * (REMAP_HALF_NDC(pointOnCone.z, 0.5, 1.0) + hash.y) * 4.5;\n        \n        // outColor += smoothstep(0.01, 0.0, length(st - pointOnCone.xy));\n        outColor += REMAP_HALF_NDC(pointOnCone.z, 3.0, 0.6) * // Slightly adjust the size of the point based on distance to \"camera\" \n            2e-5 / pow(length(st - pointOnCone.xy), 1.7) * pointColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y; // [-0.5, 0.5] adjusted for aspect ratio\n    vec3 outColor = vec3(0.005, 0.01, 0.03); // Background color\n    vec4 m = iMouse / iResolution.yyyy;\n    float t = 0.0;\n    \n    if (m.z > 0.0)\n    {\n        t = m.x * TAU;\n    }\n    else\n    {\n        t = iTime * 0.5;\n    }\n    \n    DrawTree(uv, t, outColor);\n    DrawStar(uv, t, outColor);\n    \n    float vignette = dot(uv, uv);\n    vignette *= vignette;\n    vignette = 1.0 / (vignette * vignette + 1.0);\n    \n    fragColor = vec4(pow(outColor * vignette, vec3(0.4545)), 1.0) - Hash12(fragCoord.xy * t + iResolution.yy) * 0.04;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}