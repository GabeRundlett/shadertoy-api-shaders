{
    "Shader": {
        "info": {
            "date": "1565313785",
            "description": "more explicitly vectorized fork of \nhttps://www.shadertoy.com/view/WlSXRW\nIn search of some symmetry to utilize, i sure found parallel processing alternatives, but the resulting difference is very neglible.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tSSzw",
            "likes": 2,
            "name": " Rounded Box trace fork",
            "published": 3,
            "tags": [
                "3d",
                "intersection",
                "min",
                "roundedcube",
                "branchlessed",
                "cull"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 624
        },
        "renderpass": [
            {
                "code": "//some code more explicitly vectorized by ollj, which adds extra substractions (done as vectors anyways) \n//and it adds some min() and mix(step)) to removes 3 sequential/culling if() conditions, that obviously can be done in parallel instead.\n\n// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray with a rounded cube, testing a single\n// corner (sphere) instead of 8, and only 3 edges (cylinders)\n// instead of 12. There might be a better (more compact and\n// efficient) way to do it, but this is where I landed. However\n// the code to compute the surface normal is particularly\n// elegant.\n\n// Other intersectors: https://iquilezles.org/articles/intersectors\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n    \n#define AA 2  // reduce this to 1 if you have a slow machine\n\n#define BoundOr(a,b,c) (abs(b-.5*a)*2. c a)\n#define BoundAnd(a,b,c) (a c abs(b-.5*a)*2. ) \n//(0.<a&&a<b) === boundAnd(a,b,<) === boundOr (a,b,>=) \n//(0.>a||a>b) === boundOr (a,b,>) === boundAnd(a,b,<=) \n//(0.<a&&a<b) === (0.<a&&a-b<0.) === (0.<a&&0<b-a) === (0.<max(a,b-a)) ???\n//(0.<a||a<b) === (0.<a||a-b<0.) === (0.<a||0<b-a) === (0.<min(a,b-a)) ???\n\n//original code by iq, vectorized by ollj, parent code is in: https://www.shadertoy.com/view/WlSXRW\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad){\n\t// bounding box\n    vec3 m=1./rd;//assert nonzero RayDirection, seems fair.\n    vec3 n=m*ro;\n    vec3 d=abs(m)*(size+rad);\n    vec3 p=-d-n;d=d-n;\n\tfloat t =max(max(p.x,p.y),p.z);\n\tfloat tF=min(min(d.x,d.y),d.z);\n    if (0.<min(tF,t-tF)) return -1.; \t//if( tN > tF || tF < 0.0) //ollj edit\n    //end of bounding box\n    // convert to first octant\n    //7 intersection cases (3planes+3roundedSides+1RoundedCorner) planes first:\n    p=ro+t*rd;//p and d change meaning (short scope vars)\n    d=sign(p);\n    ro*=d;\n    rd*=d;    \n    p *=d;p-=size;p=max(p,p.yzx);if(min(min(p.x,p.y),p.z)<0.)return t;//type bvec3 not needed, replaced if(any()) with min() by ollj\n    //planar intersections done, roundedCorners are trickier, 3 sides +1 corner.\n    p=ro-size;//p and d change meaning (short scope vars)\n    d=p*rd;\n\tp*=p;//some wars renamed or reapropriated (p&&d have had a short scope, now means something else)\n    t =1e20; \n    // some precomputation\n    //of the vec4 types below,\n    //.xyz tests 3 rounded sides intersections\n    //.w   tests rounded corner intersection\n    vec4 a=vec4(rd*rd,1);\n    a.xyz=a.yzx+a.zxy;\n    vec4 b=d.yzxx+d.zxyy+vec4(0,0,0,d.z);\n    vec4 c=p.yzxx+p.zxyy+vec4(0,0,0,p.z)-rad*rad;\n    vec4 h=b*b-a*c;//vectorization requires more precalculation (all cases are precalculated in vectors at once, instead of just one at a time, this needs more minimum memory)\n    h.xyz=(-b.xyz-sqrt(h.xyz))/a.xyz;\n    a.xyz=size.xyz-abs(ro+rd*h.xyz); //note that [a] is negated to simplify conditionals below.\n\tif(h.w>0.0)t=-b.w-sqrt(h.w);//rounded corner(s) must be done before 3 sides \n    //because of culling order, sides go over inside-intersections of spheres in corners.\n    a=min(a,h);  //this line simplifies conditionals a lot\n    if(a.x>0.)t=min(t,h.x);    //   t=mix(min(t,h.x),t,step(a.x,0.));\n    if(a.y>0.)t=min(t,h.y);\n    if(a.z>0.)t=min(t,h.z);    //these 3 if() lines CAN BE substituted by the 2 lines below.\n //vec3 r=mix(min(vec3(t),h.xyz),vec3(t),step(a.xyz,vec3(0)));//this line can likely be simplified\n    //a branchlessing mix(step()) is indeed likely slower\n    //,except it maybe faster where you can handle multiple domains at once, instead of a list of if():\n//t=min(min(t,r.x),min(r.y,r.z));    \n    //this should end in a min(min(),min()) and not be a list of 4 conditions\n    //i leave the benchmarking of this to others    \n    if( t>1e19 )t=-1.;//>zFar error case.  \n\treturn t;} //end of vectorization by ollj\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\n\n//======================================================\n\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nvec3 pconvert( in mat4 mat, in vec3 v ) { return (mat*vec4(v,1.0)).xyz; }\nvec3 nconvert( in mat4 mat, in vec3 v ) { return (mat*vec4(v,0.0)).xyz; }\n\n//======================================================\n\n\nstruct\n{\n   mat4  world_to_obj;\n   mat4  obj_to_world;\n   vec3  size;\n   float radius;\n}box;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n    float t = (0.0-ro.y)/rd.y;\n    if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    // rounded box\n    {\n    \n    // convert from ray to box space\n    vec3 rdd = nconvert(box.world_to_obj, rd );\n    vec3 roo = pconvert(box.world_to_obj, ro );\n    // intersect in box space\n    float t = roundedboxIntersect(roo,rdd,box.size,box.radius);\n    if( t>0.0 && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\n// texture sampling\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an = 0.15*(iTime-10.0);\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ro = ta + vec3( 2.0*cos(an), 0.2, 2.0*sin(an) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.6,8.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n\n    // rounded box animation\n    box.obj_to_world = translate( 0.0, 1.0, 0.0 ) * \n                       rotate( normalize(vec3(1.0,1.0,0.1)), iTime ); \n    box.world_to_obj = inverse( box.obj_to_world );\n    box.size = vec3(0.5,0.4,0.3);\n    box.radius = 0.2;\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n    \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 )\n        {\n            // shading\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor;\n            vec3 mate;\n            \n            if( tm.y<1.5 ) // floor\n            {\n                nor = vec3(0.0,1.0,0.0);\n                mate = 0.35*texture( iChannel0, 0.2*pos.xz ).xyz;\n            }\n            else // rounded cube\n            {\n                // convert position from world to box space\n                vec3 bpos = pconvert(box.world_to_obj,pos);\n                // compute normal in box space\n                vec3 bnor = roundedboxNormal(bpos,box.size,box.radius);\n                // convert normal from box to world space\n                nor = nconvert(box.obj_to_world,bnor);\n                \n                mate = 0.35*boxmap( iChannel0, bpos, bnor, 8.0 ).xyz;\n            }\n            \n            // lighting\n            vec3 lig = normalize(vec3(0.8,0.4,-0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = step( intersect( pos+0.01*nor, lig ).y, 0.0 );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 4.0*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 2.0*vec3(0.20,0.30,0.40)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n\t\t\tcol *= mate;            \n            col += 0.3*pow(spe,8.0)*dif*sha*(0.04+0.96*pow(clamp(dot(lig,hal),0.0,1.0),5.0));\n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n        \n        // vignetting        \n        col *= 1.0 - 0.1*dot(p,p);\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n\t// grading\n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}