{
    "Shader": {
        "info": {
            "date": "1540159822",
            "description": "drag with mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "MltBzB",
            "likes": 4,
            "name": "3xMSAA halfspace square rooms",
            "published": 3,
            "tags": [
                "windows",
                "square",
                "truchet",
                "hash",
                "msaa",
                "lattice",
                "doors",
                "highway",
                "hgsdf",
                "continuity",
                "halfspace",
                "neighborhood",
                "3xaa"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 849
        },
        "renderpass": [
            {
                "code": "//klick the common tab above\n\nvoid mainImage( out vec4 o, in vec2 u\n ){o=imageEntry(iTime,u,iResolution.xy,iMouse);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nblue is fract() tile borders, square lattice\n,red is hashed connections beetween tiles, imagine them as tunnels//windows\n- these are scaled by x=x*.8+.2 to stay away from tile corners\n- green visualizes paths (for pathfinding or highways)\nor just use all red dots to define the music sheet for a player-piano.\n\nA hash defines the .xy position for the top and left \"tunnel\"\n, that connects 2 adjacent tiles\"\n, a tile gets these, and also the 2 values from the tiles below and to its right.\n- for a lack of better term, i name this 3xFSAA\n- ,because its pretty close to being 4xfsaa\n- ,but it only taps 4 parameters from 3 lattice-locales \n- ,and not from 4 lattice-locales.\n\nno noise interpolation, just 3xAA over a cract(dot()) hash [== semiHalfspace]\n// https://en.wikipedia.org/wiki/Multisample_anti-aliasing#Sample_patterns\n\n//new lesson learned:\n//#define maab(a)ma(abs(a))\n//WILL cause some fatal compiler errors, but only in some contexts (eg: too many iterations within a julia set fractal)\n//whereas \n//#define maab(a) ma(abs(a))\n//will compile just fine\n//the SHIT is that both compile just fineWHILE without a (juliaset) fractal context\n*/\n\n//zoom,FoV (t=time)\n#define ViewZoom mix(2.,256.,u5(-cos(sin(t))))\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(u)(u-.5*r.xy)*ViewZoom/r.y//usually first function of mainImage(),not typecast.\n\n//namespace hogs for a quck compatibility fix:\n#define sq sqrt\n#define dt dot\n\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\nvec1 ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec2 ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec3 ss(vec3 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec4 ss(vec4 a,vec2 b){return smoothstep(b.x,b.y,a);}\n\n//very explicit aliases for min() max() (diominishes cognitive load)\nvec1 mi(vec1 a,vec1 b){return min(a,b);}\nvec2 mi(vec2 a,vec2 b){return min(a,b);}\nvec3 mi(vec3 a,vec3 b){return min(a,b);}\nvec4 mi(vec4 a,vec4 b){return min(a,b);}\nvec1 mi(vec1 a,vec1 b,vec1 c){return mi(mi(a,b),c);}\nvec2 mi(vec2 a,vec2 b,vec2 c){return mi(mi(a,b),c);}\nvec3 mi(vec3 a,vec3 b,vec3 c){return mi(mi(a,b),c);}\nvec4 mi(vec4 a,vec4 b,vec4 c){return mi(mi(a,b),c);}\nvec1 mi(vec2 a){return mi(a.x,a.y);}\nvec1 mi(vec3 a){return mi(mi(a.xy),a.z);}\nvec1 mi(vec4 a){return mi(mi(a.xy),mi(a.zw));}\nvec1 ma(vec1 a,vec1 b){return max(a,b);}\nvec2 ma(vec2 a,vec2 b){return max(a,b);}\nvec3 ma(vec3 a,vec3 b){return max(a,b);}\nvec4 ma(vec4 a,vec4 b){return max(a,b);}\nvec1 ma(vec1 a,vec1 b,vec1 c){return ma(ma(a,b),c);}\nvec2 ma(vec2 a,vec2 b,vec2 c){return ma(ma(a,b),c);}\nvec3 ma(vec3 a,vec3 b,vec3 c){return ma(ma(a,b),c);}\nvec4 ma(vec4 a,vec4 b,vec4 c){return ma(ma(a,b),c);}\nvec1 ma(vec1 a){return a;}\nvec1 ma(vec2 a){return ma(a.x,a.y);}\nvec1 ma(vec3 a){return ma(ma(a.xy),a.z);}\nvec1 ma(vec4 a){return ma(ma(a.xy),ma(a.zw));}\n//and then you can do shit like:\nfloat barbara(vec3 a){return mi(ma(a.y,-a.z),ma(a.x,-a.y),ma(a.x,-a.z));}\nfloat cesare(vec3 a){return mi(ma(-a.y,a.x),ma(a.z,a.x),ma(a.z,a.y));}\n\nvec1 ad(vec1 a){return a;}\nvec1 ad(vec2 a){return a.x+a.y;}\nvec1 ad(vec3 a){return a.x+a.y+a.z;}\nvec1 ad(vec4 a){return a.x+a.y+a.z+a.w;}\nvec1 su(vec1 a){return a;}\nvec1 su(vec2 a){return a.x-a.y;}\nvec1 su(vec3 a){return a.x-a.y-a.z;}\nvec1 su(vec4 a){return a.x-a.y-a.z-a.w;}\n\n//same for full adders:\nvec1 di(vec1 a,vec1 b){return a/b;}\nvec1 mu(vec1 a,vec1 b){return a*b;}\nvec1 su(vec1 a,vec1 b){return a-b;}\nvec2 di(vec2 a,vec2 b){return a/b;}\nvec2 mu(vec2 a,vec2 b){return a*b;}\nvec2 su(vec2 a,vec2 b){return a-b;}\nvec2 mu(vec1 a,vec2 b){return a*b;}\nvec2 su(vec1 a,vec2 b){return a-b;}\nvec2 mu(vec2 a,vec1 b){return a*b;}\nvec2 su(vec2 a,vec1 b){return a-b;}\n\n//fm synth (audiovisual Starguitar)\n//[le] is any label of a \"distance field\" to a point with as many domains as [u]\n//#define seq4(u,s,le) mi(vec4(le(u-vec2(0,s.x)),le(u-vec2(1,s.y)),le(u-vec2(2,s.z)),le(u-vec2(3,s.w))))\n//#define seq4(u,s,le)mi(vec4(le(u-vec2(0,s.x)),le(u-vec2(1,s.y)),le(u-vec2(2,s.z)),le(u-vec2(3,s.w))))\n\n\n//---hg_sdf\nconst float _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=normalize(PHI.xy);\nfloat Blob(vec3 p){p=abs(p);if(p.x<max(p.y,p.z))p=p.yzx;if(p.x<max(p.y,p.z))p=p.yzx;float l=length(p),b=max(max(max(dot(p,vec3(_1)),dot(p.xz,normalize(PHI.zx))),dot(p.yx,_B)),dot(p.xz,_B));return l-1.5-.15*cos(min(sqrt(1.01-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n#define fPlane(p,n,d) ad(dt(p,n),d)\n#define abm(a,b) su(ab(a),b)//ditance taxicap   -b\n#define lbm(a,b) su(le(a),b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-a)))//==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(p))\n#define box(a,b) roundit(abm(a,b))\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define segment2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,segment()sub ,is squared distance\n#define segment(a,b,c) sq(segment2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n#define segmentY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\n#define torus(a,b) le(vec2(lbm(p.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(abs(p),le(vec2(p,l)),st(l,0.))//disc()sub\n#define disc(p,b) disc(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b], but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon, set by circumcircle radius b.x, with height b.x\n//2-distance input unions\n//note, for higher dimensions, i may prefer; input (a,b); over; input (a.x,a.y)\n#define miChamfer(a,b,r) mi(mi(a,b),(a-r+b)*sq(.5))\n#define maChamfer(a,b,r) ma(ma(a,b),(a+r+b)*sq(.5))\n#define meChamfer(a,b,r) maChamfer(a,-b,r)\n//above chamfer are worse around 90deg; below chamfer is worse near 180deg. both are still good upper bounds. below is \"smoother\"\n#define chamfer1802(a,b,r,e) mi(a,b)-(e)*(e)*.25/(r)\n#define chamfer180(a,b,r) chamfer1802(a,b,r,ma0(r-abs(a-(b))))\n//a is 2 distances, b is a radius //todo, compare with mima()\n#define miRound(a,b) mi(ma(a),-b)+le(ma0(b+a))\n#define maRound(a,b) -fOpRoundMin(-a,b)\n#define meRound(a,b) fOpRoundMin(a*vec2(1,-1),r);}\n//i am not too sure about these stair functions\n#define miStairs2(a,r,n,s,u) mi(mi(a),mu(.5,(u+a.x+abs(mo(ad(su(u,a).x,s),mu(2.,s))-s))))//miStairs()sub\n#define miStairs(a,r,n) miStairs2(a,r,n,di(r,n),su(a.y,r))//distance to mi(a.x,a.y), with n number of steps within distance r\n#define maStairs(a,r,n) -miStairs(-a,r,n)\n#define meStairs(a,r,n) -miStairs(a*vec2(1,-1),r,n)\n#define pipe(a,b,r) lbm(vec2(a,b)),r) //pipe of radius R around the places where a=b=0, wherever both surfaces intersect.\n//what, no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))\n#define tongue(a,b,r,h) mi(a,ma(su(a,r),su(ab(b),h)))\n//dodo replace old pmod code with my new pmod code.\n//my pmod code has the issue od addinf +1 domain, which still may just not be good style, not sure, need to overthing pros and cons...\n//my new variant sure does not extend as well into N-domains, or does it?\n//i dont even like the label pMod() pmod() anymore.\n\n//https://en.wikipedia.org/wiki/Chebyshev_distance   ==box\n#define maab(a)ma(abs(a))\n//https://en.wikipedia.org/wiki/Taxicab_geometry    ==diagonalBox (scale by sqrt(2.))\n#define adab(a)ad(abs(a))\nfloat le(vec2 a){return length(a);}\n\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\n//one origin of these hashes is:  https://www.shadertoy.com/view/4djSRW \nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//hashes are named by output type,NEVER by input type\n//hash1 mirrors at y=x and has strong banding on diagonals.\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hash1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hash2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hash3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hash4(a)hout4(h4mid(hs*g4(a)))\n//fract(dot()) hashes;\n//- have strog fiagonal hyperplane periods, easily visible (by zooming out enough)\n//- - but its worst offender near [x=-y] can easily be avoided. (and you just should not zoom out far here)\n//- are sensetive to scaling, they break iff scaled too much, because dot()==skewedSquaresLengths.\n//- slower than hash(cos()) hashes, but more consistent between implementations (no trigonometry estimation)\n//- still slightly better hashes/performance than all other hashes.\n//iff (you want a fast first derivative noise) use hash(cos()) instead, like [dr2]!\n//iff you want faster (short period fbm) noise for dust/rock/strucco, try\n//- https://www.shadertoy.com/view/4ts3z2\n//if you want slow as fuck noise with \"higher quality\", use any voronoi or simplex\n//if you want the same, but smarter/faster (using type uing and bitwise operands) use a [permuted linear congruential generator]\n//- within an n-dimensional z-order-curve (hilbert space), hilbert curve for c0 continuity.\n//if you want crepustularity/RADiosity/bokeh, a bayer matrix is likely most efficient: https://www.shadertoy.com/view/Xtcfzj\n\nvec4 getHighways(vec2 i//insert any hash function\n){return hash4(i/16.);}\n\nvec4 TileHighway(vec2 u,vec2 i,vec4 m,vec2 r,float t//i=floor(tileID) u=fract(uv)\n//a tile has a highway crossing connect across its 4 sides\n//the highway connection to bottom and left is set the tile.this()\n//by a hashed vec4, whos .xz sets connection to bottom, and its height.z\n//and tho the top by the .yw values just alike.\n//the tile also taps the values of its upper and and its right neiggor \n//for a 3x tap AA-overlap/typesetting\n//, the cheapest \"anti aliasing\" of connecting highways.\n//first version of this just draws the highways of a tiles to its top and left.\n//4th color is 1.\n//last step converts that into a texture of a 3d sdf, via subroutine\n){vec4 c=vec4(0,0,0,1)\n ;i=floor(i)\n ;vec4 g=getHighways(i)//.zw are ignored here, planned to define heights/diameter of portals\n     //fract(vec4(1,2,3,4)/5.) //to replave with a fract(hash4()) output)\n ;vec4 h=vec4(0)//.zw are ignored here, planned to define heights/diameter of portals\n ;h.x=getHighways(i-vec2(0,1)).x\n ;h.y=getHighways(i-vec2(1,0)).y\n ;//g.y=getHighways(i-vec2(1,0)).x\n     //fract(vec4(22,54,78,24)/1.62)//to replace with what we get from tapping top and right neibhors\n ;//optional debug override, mouse sets highway connections of tile i=vec2(0)\n ;//tap right neighbor\n ;//if(i==vec2(0)){h.xy=fract(m.xy);g.xy=fract(m.zw);}\n ;//highways must not get too close to the tile corner (evade discontinuity)\n ;h.xy=h.xy*.8+.2\n ;g.xy=g.xy*.8+.2//=(g.xy)*.5+.25\n ;c.z=maab(u-.5)-.5\n ;c.x=maab(u-vec2(h.x,0))//left conenction\n ;c.x=mi(c.x,maab(u-vec2(0,h.y)))//bottom conenction\n ;c.x=mi(c.x,maab(u-vec2(g.x,1)))//top conenction\n ;c.x=mi(c.x,maab(u-vec2(1,g.y)))//right conenction\n ;//float s=maab(u-mix(h.xy,g.xy,.5))//intersection point, not really, too lazy to even calculate lineLineIntersection here\n ;//c.x=mi(c.x,s)\n ;c.y=       segment(u,vec2(0,h.y),vec2(1,g.y))     \n ;c.y=mi(c.y,segment(u,vec2(h.x,0),vec2(g.x,1)))\n //todo, only 2 straight connections are lazy, should likely be 4 quadratic beziers...\n ;c.x-=.1//highway -connection-width\n ;c.y-=.033//road width\n ;//c.y=le(u-1.)-.1//top right\n ;c=ss(c,vec2(1.,-1.)*2./aa(r))\n ;c.z=1.-c.z\n ;c.z-=c.y\n     \n ;return c;}\n\nvec4 imageEntry(vec1 t,vec2 u,vec2 r,vec4 m\n){float u5cot=u5(cos(t))\n ;m.xy=fra(m.xy)\n ;m.zw=fra(m.zw)\n ,u=fra(u)\n ;u-=m.xy//drag camera with mouse (intuitice as in Black&white game\n //, or good VR games, where you drag the floow below you to move)\n ;vec4 c=vec4(1)\n ;vec2 i=floor(u)\n ;u=fract(u)\n ;c=TileHighway(u,i,m,r,t)\n ;//c.w=barbara(c.xyz)-.05 //green tinted syllogism\n ;//c.w=cesare(c.xyz)//green tinted syllogism\n ;//c.xyz=abs(c.xyz)\n //;c.w=fract(c.w)\n ;//c.xyz=ss(c.xyz,vec2(1.,-1.)*2./aa(r))\n ;//c.w=mix(ss(c.w,vec2(1.,-1.)*2./aa(r)),fract(c.w*4.),.5)\n\n ;c.w=1.\n ;return c\n ;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}