{
    "Shader": {
        "info": {
            "date": "1675951511",
            "description": "hi",
            "flags": 32,
            "hasliked": 0,
            "id": "mljXDz",
            "likes": 14,
            "name": "sea adventure",
            "published": 3,
            "tags": [
                "sdf",
                "water"
            ],
            "usePreview": 0,
            "username": "rcargou",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n\n    color += GetBloom(uv) * 0.12;\n    \n    //color *= 2.0;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n    \n    //fragColor = texture(iChannel0, uv);\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nvec3 getDis() {\n    return vec3(0., 0., iTime * 3.);\n}\n\nvec3 getTrailDis() {\n    return vec3(0., 0., iTime * 35.);\n}\n\nvec3 getLightPos() {\n    return getDis() + vec3(.0, 10, 100.);\n}\n\nvec3 getLightCol() {\n    vec3 col1=vec3(.22,.22,.4);\n    vec3 col2=vec3(.62,.22,.1);\n    return mix(col1, col2, (sin(iTime) +1.) / 2.);\n}\n\nfloat mapStarFish(in vec3 pos, out vec3 id, vec3 ro) {\n    float rep = 5.;\n     // vec3 pp = ro + d * (dot(pos-ro, ) / dot(pos-ro,pos-ro) )\n    if (length( ( ro.x -pos.x) )> 60. || length(ro.z-pos.z) >100.)\n        return 1e10;\n    float l_id = hash21(floor(pos.xz/rep));\n        id.x = hash11( l_id );\n    if(l_id < .85)\n        return 3.;\n  \n    vec3 mp = mod(pos.xxz, rep) - rep / 2.;\n  //  mp.xz = rotate2d(.3) * mp.xz;\n\n     \n    // return length(vec3(mp.x, mp.z,pos.y+9.))-.5;\n    return opExtrusionT(vec3(mp.x, mp.z, pos.y + 9.), .03); \n}\n\nfloat mapTrails(vec3 p) {\n\n//    p.y += sin(p.z) / 20.;\n    p.x -= cos( ( p.z + 20.) / 40.) * 10.;\n    if ( length (p.x -getDis().x) > 20. || abs(p.z - getDis().z) >90.)\n        return 1e10;\n        \n    float r = .1;\n    p.xz -= getTrailDis().xz * rotate2d(r);\n    p.xz *= rotate2d(-r);\n\n    p.y += sin(p.z) / 20.;\n    p.y += sin(iTime * 2. + p.z / 10.);\n    p.y -= 2.;\n    \n    float repz = 30.;\n    float repxy = 8.;\n    float id = hash31(vec3(floor( p.z / repz ) , floor( p.x / repxy), floor( abs( p.y) / repxy) ) );\n\n    p.z = mod(p.z, repz) - repz/2.;\n    \n    p.xy = mod(p.xy, repxy) - vec2(repxy/2.);\n    if (id < .6)\n        return 10.;\n    float s = sdCappedCylinder(p.xzy, 8., .02);\n    return s;\n}\n\nfloat mapSea(vec3 p) {\n\n    return p.y  + 0.1;\n}\n\nfloat mapMoon(vec3 p, out vec3 id) {\n    float l = length(p - getLightPos());\n    vec3 lp = p - vec3(0., 5.,20.);\n\n    p-=getLightPos();\n    float s = length(p) - 5.;\n    \n    vec3 o = getLightPos();\n //   lp/=5.;\n    id = vec3(atan(-lp.y, lp.x) );\n    lp = p;\n    float a =  1. - ((atan(lp.z/lp.x)))/(2.*3.14);\n    float b =  1. - ((acos(lp.y/length(lp))))/3.14;\n    id = vec3(a*2., b*2., 0.);\n    return s;\n}\n\nfloat getWind() {\n    \n    return .4 + ( pow(sin(iTime / 2.), 2.)) * .6;\n    return  (sin(iTime) + 1. ) / 2.;\n}\n\nfloat mapBoat(vec3 p, out vec3 id) {\n\n    p -= getDis();\n    p.z -= (getWind()-.4)  * 2.;\n    p.z-= 2.;\n    p.y += log(sin(iTime * 2.) + 1.5) / 15.;\n\n    p.x -= 1.5;\n    float c1 = sdCappedCylinder(p.xzy, 2., .2);\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(.5, 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(1., 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(1.5, 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(2., 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(2.5, 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xzy + vec3(3., 0., 0.), 2., .2));\n    c1 = min(c1, sdCappedCylinder(p.xyz + vec3(1.5, 0., 0.), 3., .1));\n     \n     p.x += 1.5;\n     p.y -= 1.8;\n     \n     p.z += .8 * abs(p.y*p.y * getWind() ) - 1. * getWind();\n    float v = max(p.z -.1, p.x - 1.);\n    v =  max(v, p.y - 1.);\n    v = abs( p.z - .3);\n    v = max(v, abs( p.x) - 1.2 );\n    v = max(v, abs( p.y) - 1.2 );\n    if (v < c1) {\n        c1 = v;\n        id.y = 1.;\n    } else {\n        id.y = 2.;\n    }\n    return c1;\n}\n\nvec2 map( in vec3 pos, vec3 ro, float mask_water, out vec3 id )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    float d = 1e10;\n    vec3 tmp_id;\n    if (mask_water == 0. && (res.x = mapBoat(pos, tmp_id)) < 1e10) {\n        res.y = 1.0f;\n        id = tmp_id;\n    }\n    if (mask_water == 0. && ( d = mapSea(pos) ) < res.x ) {\n        res.x = d;\n        res.y = 2.;\n        id.x = 1.;\n    } if ( (d = mapStarFish(pos, tmp_id, ro) ) < res.x ) {\n        id = tmp_id;\n        res.x = d;\n        res.y = 3.;\n    } if ( (d = mapTrails(pos)) < res.x ) {\n        res.x = d;\n        res.y = 4.;\n    }\n     if (mask_water==0. && (d = mapMoon(pos, tmp_id)) < res.x ) {\n        res.x = d;\n        res.y = 5.;\n        id = tmp_id;\n    }\n     if ( (d = mapMoon(pos - vec3(0., -25., 0.), tmp_id)) < res.x ) {\n        res.x = d;\n        res.y = 5.;\n        id = tmp_id;\n    }\n    return res;\n}\n\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 id;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy,pos, 0., id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, pos,0. , id).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, pos,0. , id).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, pos,0. , id).x );\n \n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 id , float maskSea, float s)\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 2.0;\n    float tmax = 110.0;\n    int m = 120;\n    if (maskSea > 0.)\n        m = 80;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<m && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t,ro, maskSea , id);\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x*s;// * (1.+ t / 100.);\n        }\n    }\n    \n    return res;\n}\n\nfloat backStars(vec2 uv) {\n\n    uv.y+=cos(uv.x * 1. +0.) / 4.;\n    float ret = 0.;\n    uv.x -= iTime / 16.;\n    \n    for (int i = 0; i < 2; ++i) {\n        uv *= 3.;\n        float rep = .2;\n\n        vec2 m_uv = mod(uv, rep) - rep / 2.;\n        vec2 m_id = floor( uv / rep);\n        \n        float id1 = hash21(m_id / 123.321);\n     //   float id2 = hash22(m_id / 123.321); \n        float star = smoothstep(0.02, 0.01, length(m_uv) );\n        if (id1 > 0.98)\n            ret = star + ret;\n    }\n    return ret;\n}\n\nvec3 sky(vec2 uv) {\n    vec3 k_bottom = vec3(0.05,0.05,.9);\n    vec3 k_sky = vec3(0.4,0.15,.6);\n   \n    float interpolator = max( 0., uv.y -.18);\n    vec3 ret = mix(k_bottom, k_sky, interpolator);\n    ret += vec3(backStars(uv));\n    return ret;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 uv, out float lum )\n{ \n    vec3 col = vec3(.0f);\n    vec3 id;\n    vec3 id_u;\n    vec2 res = castRay(ro,rd,id, 0.,.9);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + rd * res.x;\n    vec3 albedo = vec3(0.);\n    float dis = res.x;\n    if (res.y == 1.) {\n        vec3 k_wood = vec3(.3, .1, .05) / 1.5;\n        col = k_wood;\n        vec3 ldir = normalize( getLightPos() - p );\n        vec3 n = calcNormal(p);\n        float ndotl = max(0., dot(n, ldir) );\n        col = k_wood * .2 + .8 * k_wood * ndotl;\n        if (id.y == 1.) {\n            col = mix(vec3(.3, .3, .8), sky(uv), .5);\n        }\n    } else if (res.y == 2.) {\n        float v = voronoi(p * .8);\n        vec3 k_sea = vec3(.05, .1, .2) / .7;\n        col = k_sea;\n        col -= v * .08;\n        col *= .5;\n        vec3 t  = pow( texture(iChannel0, p.xz / 100.).xxx * .5, vec3(5.));\n        t += texture(iChannel0, p.xz / 10.).xxx * 0.01;\n        col+=t;\n        v-=t.x * 20.;\n        v = clamp(1., 0., v);\n        rd = normalize(rd + vec3(v*.02, 0., 0.));\n        res = castRay(ro, rd, id, 1.,1.);\n       // float shadow = calcSoftshadow( p, normalize(getLightPos()-p), 1., 10. );\n        if (res.y >= 0.) {\n            if (res.y == 1.) {\n                col = vec3(.3, .1, .05) / 1.5;\n            } else if (res.y == 5.) {\n                col = getLightCol();\n                lum = 4.;\n             } else if (res.y  != 4.){ \n                col = mix( pow( hash13(id.x), vec3(1.)) * 2., col, min(1., v * 2.));\n                lum = 5.;\n            } else {\n                col = vec3(.1);\n            }\n        }\n        col = mix(col, sky(vec2(uv.x + v / 10., -uv.y) ), .1);// * shadow;\n        float d = ( length(p - getLightPos()) );\n        \n       // d *= d*d*d*0.0000001;\n        d = pow(d * .017, 9.);\n  \n        vec3 tot = col * getLightCol() * 200. / d;\n        col += tot;\n        dis = max( min(1., dis/30.), 0.);\n        dis = smoothstep(0.2, 1., dis);\n        dis *= dis*dis;\n        col = mix(col, sky(uv), dis );\n        //col = vec3(1./d);\n    } else if (res.y == 4.) {\n        col = mix( vec3(.5), sky(uv),.5);\n    } else if (res.y == 5.) {\n        col = id;\n        col = texture(iChannel1, vec2(id.xy)).xxx * getLightCol();\n        lum = 20.;\n    } else {\n        col = sky(uv);\n    }\n   \treturn vec3(col);\n}\n\n\nvec3 camAnim() {\n    return vec3(0., log(2.+sin(iTime * 3.)) / 8., 1.0*pow( 2.+sin(iTime / 2.) * 2., .5));\n}\nvec3 cellShade(vec3 c) {\n    float s = 30.;\n    return floor(c*s)/s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n    vec3 dis = getDis();\n    // camera\n    \n    vec3 ro = dis + vec3(6.0f, 1.5f, -5.0f) + camAnim();//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = dis + vec3( 3., 1. + camAnim().y , .5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    float lum = 0.;\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        // ray direction\n        p.y -= cos(p.x) / 40.;\n        vec3 rd = normalize( vec3(p.xy,2.) );\n\n        rd = ca * rd;\n        // render\t\n        vec3 col = render( ro, rd, p , lum);\n\n\t\t// gamma\n        col = pow( col*1.5, vec3(0.9045) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    tot = max(tot, vec3(0.));\n    tot = min(tot, vec3(1.));\n   // tot = cellShade(tot);\n    fragColor = vec4( tot, lum  );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb * texture(iChannel0, coord).w;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 1.12)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nconst float maxHei = 0.8;\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat hash11( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash31(vec3 p) {\n   \tfloat h = dot(p,vec3(127.1,311.7, 21.));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat hash21( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec3 hash13(float n) {\n    float n1 = n;\n    float n2 = hash11(n);\n    float n3 = hash11(n2);\n    return vec3(hash11(n1),hash11(n2),hash11(n3));\n}\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\t\n\t// Maximum value: I think outliers could get as high as \"3,\" the squared diagonal length \n\t// of the unit cube, with the mid point being \"0.75.\" Is that right? Either way, for this \n\t// example, the maximum is set to one, which would cover a good part of the range, whilst \n\t// dispensing with the need to clamp the final result.\n\tfloat d = 1.; \n     \n    // I've unrolled one of the loops. GPU architecture is a mystery to me, but I'm aware \n    // they're not fond of nesting, branching, etc. My laptop GPU seems to hate everything, \n    // including multiple loops. If it were a person, we wouldn't hang out. \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat starfish(vec2 uv) {\n    vec3 col = vec3(0.);\n     vec2 l = uv;\n \n     float it = 5.;\n     for(int i = 0; i < int(it); ++i) {\n        uv.xy = rotate2d(6.28/it + cos(length(uv) * 2.) / 80. ) * uv;\n        float h = 1.;\n\n        float u = smoothstep(.2, .1, uv.y);\n        float d = min(10.,  max(0., h - ((uv.y) / h) ));\n        d = .5 * (d + pow(d, .3));\n        float l = abs(uv.x + sin(0.)/3.) / d + u;\n        float c = smoothstep(.5, .32, l);\n        col += vec3(c);\n    }\n    col += smoothstep(.3, .2, length(uv) );\n   // col = normalize(col);\n    col.x = smoothstep(.0, .1, col.x);\n   // col.x = 1.;\n    //col /= 1.+length(l)*2.;\n    return .1-col.x;\n}\n\n\nfloat opExtrusionT( in vec3 p, in float h )\n{\n    float d = starfish(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}