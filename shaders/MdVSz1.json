{
    "Shader": {
        "info": {
            "date": "1463308798",
            "description": "My demo includes the following features:\n\n* ambient, diffuse and specular lighting;\n* hard and soft shadows;\n* ambient occlusion;\n* sun colored fog;",
            "flags": 0,
            "hasliked": 0,
            "id": "MdVSz1",
            "likes": 4,
            "name": "Raymarching with distance fields",
            "published": 3,
            "tags": [
                "raymarching",
                "distancefields",
                "distance",
                "field"
            ],
            "usePreview": 0,
            "username": "Rikstar",
            "viewed": 1328
        },
        "renderpass": [
            {
                "code": "// Created by Rik Hendriks - Rikstar/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Changes to be made:\n//--------------------------------------------------------------------------------------------------------------------//\n// * Add a feature to the shadow functions such that it begins to calculate for shadows when it isn't in the object.\n// * Add a better shadow combiner. If the ambient occlusion is in a hard shadow right now, then it can't be seen.\n// * Give an id with the map function, such that the id tells which object is the closest to the vector p.\n// * Give objects different lighting parameters via the id system, this also includes different ambient occlusions.\n//--------------------------------------------------------------------------------------------------------------------//\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Rotation functions\n//--------------------------------------------------------------------------------------------------------------------//\n\nvec3 rotX(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x, p.z*s + p.y*c, p.z*c - p.y*s);\n}\n\nvec3 rotY(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c - p.z*s, p.y, p.x*s + p.z*c);\n}\n\nvec3 rotZ(vec3 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec3(p.x*c - p.y*s, p.x*s + p.y*c, p.z);\n}\n\nvec3 rotXYZ(vec3 p, vec3 a)\n{\n    return rotZ(rotY(rotX(p, radians(a.x)), radians(a.y)), radians(a.z));\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Distance functions\n//--------------------------------------------------------------------------------------------------------------------//\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p, c) - (0.5 * c);\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Map function\n//--------------------------------------------------------------------------------------------------------------------//\n\nfloat Map(vec3 p)\n{\n    vec3 c = vec3(5.0, 0.0, 5.0);\n    \n    vec3 prim = opRep(p, c);\n    float d1 = sdSphere(prim, 1.5);\n    \n    prim = opRep(p - vec3(0.0, 0.5, 1.5), c);\n    float d2 = sdSphere(prim, 1.0);\n    \n    prim = opRep(p - vec3(1.5, 0.5, 0.0), c);\n    float d3 = sdSphere(prim, 1.0);\n    \n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float p1 = dot(p, n / length(n));\n    return min(min(min(d1, d2), d3), p1);\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// After effect funtions\n//--------------------------------------------------------------------------------------------------------------------//\n\nvec3 Gradient(vec3 p)\n{\n\tfloat d = Map(p);\n    \n    vec3 r = vec3(0.0, 0.0, 0.0);\n    float f = 0.00001;\n    \n    r.x = (Map(p + vec3(f, 0.0, 0.0)) - d) / f;\n    r.y = (Map(p + vec3(0.0, f, 0.0)) - d) / f;\n    r.z = (Map(p + vec3(0.0, 0.0, f)) - d) / f;\n    \n    return r / length(r);\n}\n\nfloat Shadow(vec3 p, vec3 lDir, float minT, float maxT, float k)\n{\n    float r = 1.0;\n    float t = minT;\n    float d = 0.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        d = Map(p + (lDir * t));\n\t\t\n        if(t > maxT) break;\n        if(d < minT) return 0.0;\n\n        r = min(r, (k * d) / t);\n              \n        t += d;\n    }\n    return r;\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 normal, float stepSize, float k)\n{\n    float r = 0.0;\n    float t = 0.0;\n  \n    for(int i = 0; i < 5; i++)\n    {\n        t += stepSize;\n        r += (1.0 / pow(2.0, t)) * (t - Map(p + (normal * t)));\n    }\n    return max(0.0, 1.0 - (k * r));\n}\n\nvec3 Fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering)\n{\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0.5, 0.6, 0.7), vec3(1.0, 0.9, 0.7), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Renderer function\n//--------------------------------------------------------------------------------------------------------------------//\n\nvec4 Renderer(vec2 uv)\n{\n    vec3 cameraPoint = vec3(0.0, 3.0, -20.0);\n    \n    vec3 eye = vec3(0.0, 0.0, -1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    \n    vec3 lightDir = rotXYZ(vec3(0.0, 0.0, 1.0), vec3(-30.0, 135.0, 0.0));\n    \n    vec3 planePoint = uv.x * right + uv.y * up;\n    \n    vec3 rot = vec3(0.0, 0.0, 0.0);\n    \n    float breakLength = 0.001;\n    \n    float maxLength = 1000.0;\n    \n    planePoint = rotXYZ(planePoint, rot);\n    eye = rotXYZ(eye, rot);\n    \n    planePoint += cameraPoint;\n    eye += cameraPoint;\n    \n    rot = vec3(-15.0 + (10.0 * sin(iTime * 0.7)), iTime * 30.0, 0.0);\n    \n    planePoint = rotXYZ(planePoint, rot);\n    eye = rotXYZ(eye, rot);\n    \n    vec3 forward = normalize(planePoint - eye);\n    \n    float t = 0.0;\n    \n    vec3 objectDiffuseColor = vec3(1.0, 1.0, 1.0);\n    vec3 objectSpecularColor = vec3(1.0, 1.0, 1.0);\n    \n    float ambientReflectance = 0.1;\n    vec3 ambientColor = vec3(1.0, 1.0, 1.0);\n    \n    float diffuseIntensity = 0.8;\n    vec3 diffuseColor = vec3(1.0, 1.0, 1.0);\n    \n    float specularIntensity = 0.3;\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 5.0;\n    \n    float shadowIntensity = 0.4;\n    \n    float ambientOcclusionIntensity = 0.5;\n    float ambientOcclusionStepSize = 0.2;\n    \n    float fogExtintion = 0.02;\n    float fogInscattering = 0.01;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 ambient = vec3(0.0, 0.0, 0.0);\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    \n    float shadowC = 0.0;\n    float ambientO = 0.0;\n    vec3 gradient = vec3(0.0, 0.0, 0.0);\n    float fogC = 0.0;\n    \n    float d = 0.;\n    vec3 p = vec3(0.);\n    \n    // Main loop\n    for(int a = 0; a < 200; a++)\n    {\n        p = planePoint + (forward * t);\n        d = Map(p);\n        if(d < breakLength || t > maxLength) break;\n        t += d;\n    }\n    \n    t = min(t, maxLength);\n    \n    if(t < maxLength)\n    {\n        // Do the after effect functions\n        ambient = ambientReflectance * ambientColor;\n        shadowC = Shadow(p - (forward * breakLength), -lightDir, breakLength, 100.0, 10.0);\n        gradient = Gradient(p);\n        ambientO = AmbientOcclusion(p - (forward * breakLength), gradient, ambientOcclusionStepSize, ambientOcclusionIntensity);\n        \n        // Apply lighting\n        float dP = dot(gradient, -lightDir);\n        diffuse = diffuseColor * diffuseColor * diffuseIntensity * ((dP + 1.0) / 2.0);\n        if(dP >= 0.0)\n        {\n            vec3 h = - lightDir - forward;\n            h /= length(h);\n            specular = specularIntensity * specularColor * specularColor * pow(max(dot(gradient, h), 0.0), shininess);\n        }\n        \n        color = ambient + diffuse + specular;\n    }\n\t\n    float totalShadowC = min(shadowC, ambientO);\n    color = (color * shadowIntensity * (1.0 - totalShadowC)) + (color * totalShadowC);\n    \n    color = Fog(color, t, forward, -lightDir, fogExtintion, fogInscattering);\n    \n    color = pow(color.xyz, vec3(1.0 / 2.2));\n    \n    return vec4(color.x, color.y, color.z, 1.0);\n}\n\n//--------------------------------------------------------------------------------------------------------------------//\n// Main image function\n//--------------------------------------------------------------------------------------------------------------------//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = ((fragCoord.xy * 2.0) / iResolution.xy) - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    fragColor = Renderer(uv * 2.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}