{
    "Shader": {
        "info": {
            "date": "1678966300",
            "description": "Ships, waves, clouds, sunbeams, etc (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "mdKGzd",
            "likes": 35,
            "name": "Barque Fleet",
            "published": 3,
            "tags": [
                "wave",
                "sunbeam",
                "ship",
                "sail"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "// \"Barque Fleet\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  (Bits from \"Sailing\" and \"Franky and the Drakettes\")\n\n  No. 9 in \"Sailing Ship\" series\n    \"Ship in a Shell\"          (XlBfRR)\n    \"Sailing\"                  (MtBBRR)\n    \"Tempting the Mariner\"     (ll2BzR)\n    \"Lighthouse with Ship\"     (MtSBR1)\n    \"Ship of Mirrors\"          (4ljfzw)\n    \"Refractable Ship\"         (MtjBRm)\n    \"Ship in a Bottle\"         (wlXXzf)\n    \"Not The Ship Stamp\"       (ftsSWS)\n*/\n\n#define AA    0  // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEVCapsDf (vec3 p, vec4 u, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\n\nvec4 vum[4], vur[5];\nvec3 qHit, sunDir, shipConf, bDeck, cloudDisp, vim[4], vir[5];\nvec2 cId, bGrid, grLim, shipOff;\nfloat tCur, dstFar, dstWat, szFac, tWav;\nint idObj;\nconst int idHull = 1, idRud = 2, idStruc = 3, idMast = 4, idSparT = 5, idSparL = 6, idSailT = 7,\n   idSailA = 8, idSailF = 9, idFlag = 10, idRig = 11;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.2 * p - vec2 (0., tCur);\n  h = 0.59 + 0.25 * sin (0.5 * q.y + 0.5) + 0.12 * sin (dot (q, vec2 (0.1, 1.2))) +\n     0.12 * sin (dot (q, vec2 (-0.2, 1.4)));\n  q = p;\n  wFreq = 0.25;\n  wAmp = 0.05;\n  tw = tWav * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= qRot;\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (6., h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 7; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec3 h;\n  vec2 e, ee[3];\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  ee[0] = e.yy;\n  ee[1] = e.xy;\n  ee[2] = e.yx;\n  for (int j = VAR_ZERO; j < 3; j ++) h[j] = WaveHt (p.xz + ee[j]);\n  return vec4 (normalize (vec3 (h.x - h.yz, e.x)).xzy, h.x);\n}\n\nfloat ShipHullDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, fy, fz, gz;\n  q = p;\n  d = abs (p.z) - 4.5;\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  q.yz -= vec2 (-3.4, -0.4);\n  d = max (d, PrBoxDf (q, vec3 (0.3, 0.1, 0.5)));\n  DMINQ (idStruc);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (-3.8, 0.5);\n  fz = q.z / 5. + 0.3;\n  fz *= fz;\n  fy = 1. - smoothstep (-1.3, -0.1, q.y);\n  gz = smoothstep (2., 5., q.z);\n  bDeck = vec3 ((1. - 0.45 * fz * fz) * (1.1 - 0.5 * fy * fy) *\n     (1. - 0.5 * smoothstep (-5., -2., q.y) * smoothstep (2., 5., q.z)),\n     0.78 - 0.8 * gz * gz - 0.2 * (1. - smoothstep (-5.2, -4., q.z)), 5. * (1. + 0. * 0.02 * q.y));\n  d = min (PrBoxDf (vec3 (q.x, q.y + bDeck.y - 0.6, q.z), bDeck),\n     max (PrBoxDf (q - vec3 (0., 0.72, -4.6), vec3 (bDeck.x, 0.12, 0.4)),\n     - PrBox2Df (vec2 (abs (q.x) - 0.4, q.y - 0.65), vec2 (0.2, 0.08))));\n  d = max (d, - PrBoxDf (vec3 (q.x, q.y - 0.58 - 0.1 * fz, q.z),\n     vec3 (bDeck.x - 0.07, 0.3, bDeck.z - 0.1)));\n  q = p;\n  d = max (d, - max (PrBox2Df (vec2 (q.y + 3.35, mod (q.z + 0.25, 0.5) - 0.25), vec2 (0.08, 0.1)),\n     abs (q.z + 0.5) - 3.75));\n  DMINQ (idHull);\n  q = p;\n  d = PrBoxDf (q + vec3 (0., 4.4, 4.05), vec3 (0.03, 0.35, 0.5));\n  DMINQ (idRud);\n  return dMin;\n}\n\nfloat ShipMastDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, fy, fz, s, rSpar, yLim, zLim;\n  rSpar = 0.05;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  zLim = abs (p.z) - 4.5;\n  q = p;\n  d = zLim;\n  q.z = mod (q.z + 1.4, 2.8) - 1.2;\n  d = max (d, PrCapsDf ((q - vec3 (0., 3.7 * (fz - 1.), 0.)).xzy, 0.1 * fy, 3.7 * fz));\n  DMINQ (idMast);\n  q = p;\n  yLim = abs (q.y - 0.2 * fz) - 3. * fz;\n  qq = q;\n  qq.y = mod (qq.y - 3.3 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.1 * fz;\n  d = max (max (min (d, PrCylDf (vec3 (qq - vec3 (0., 0.05 * fy * fz, 0.1 * fz - 0.23)).xzy,\n     0.15 * fy, 0.11 * fy * fz)), yLim), zLim);\n  DMINQ (idMast);\n  d = max (max (PrCapsDf (qq.yzx, 0.05, 1.23 * fy * fz), yLim), zLim);\n  DMINQ (idSparT);\n  q = p;\n  for (int k = 0; k <= 3; k ++) d = min (d, PrEVCapsDf (q - vim[k], vum[k], rSpar));\n  DMINQ (idSparL);\n  return dMin;\n}\n\nfloat ShipSailDf (vec3 p, float dMin)\n{\n  vec3 q, qq, w;\n  float d, fy, fz;\n  fy = 1. - 0.07 * p.y;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  qq = q;\n  qq.y = mod (qq.y - 3.1 * (fz - 1.), 2. * fz) - fz;\n  qq.z = mod (qq.z + 1.4, 2.8) - 1.4 + 0.2 * (fz - abs (qq.y)) * (fz - abs (qq.y)) - 0.1 * fz;\n  d = max (max (max (PrBoxDf (qq, vec3 ((1.2 - 0.07 * q.y) * fz, fz, 0.01)),\n     min (qq.y, 1.5 * fy * fz - length (vec2 (qq.x, qq.y + 0.9 * fy * fz)))),\n     abs (q.y - 3. * (fz - 1.)) - 2.95 * fz), - PrBox2Df (qq.yz, vec2 (0.01 * fz)));\n  d = max (d, abs (p.z) - 4.5);\n  DMINQ (idSailT);\n  q = p;\n  q.z -= -3.8;\n  q.y -= -1.75 - 0.2 * q.z;\n  d = PrBoxDf (q, vec3 (0.01, 0.9 - 0.2 * q.z, 0.6));\n  DMINQ (idSailA);\n  q = p;\n  q.yz -= vec2 (-1., 4.5);\n  w = vec3 (1., q.yz);\n  d = max (max (max (abs (q.x) - 0.01, - dot (w, vec3 (2.3, 1., -0.35))),\n     - dot (w, vec3 (0.68, -0.74, -1.))), - dot (w, vec3 (0.41, 0.4, 1.)));\n  DMINQ (idSailF);\n  q = p;\n  q.yz -= vec2 (3.4, 0.18);\n  d = PrBoxDf (q, vec3 (0.01, 0.2, 0.3));\n  DMINQ (idFlag);\n  return dMin;\n}\n\nfloat ShipRigDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rRig, d, fz, gz, s;\n  rRig = 0.02;\n  fz = 1. - 0.14 * step (1., abs (p.z));\n  q = p;\n  d = abs (p.z) - 4.5;\n  gz = (q.z - 0.5) / 5. + 0.3;\n  gz *= gz;\n  gz = 1.05 * (1. - 0.45 * gz * gz);\n  q.x = abs (q.x);\n  q.z = mod (q.z + 1.4, 2.8) - 1.4;\n  d = max (d, min (PrEECapsDf (q, vec3 (1.05 * gz, -3.25, -0.5),\n     vec3 (1.4 * fz, -2.95, -0.05), 0.7 * rRig),\n     PrEECapsDf (vec3 (q.xy, abs (q.z + 0.2) - 0.01 * (0.3 - 2. * q.y)), vec3 (gz, -3.2, 0.),\n     vec3 (0.05, -0.9 + 2. * (fz - 1.), 0.), rRig)));\n  q = p;\n  d = min (d, PrEVCapsDf (q - vir[0], vur[0], 0.8 * rRig));\n  for (int k = 1; k <= 3; k ++) d = min (d, PrEVCapsDf (q - vir[k], vur[k], rRig));\n  q.x = abs (q.x);\n  d = min (d, PrEVCapsDf (q - vir[4], vur[4], rRig));\n  s = step (1.8, q.y) - step (q.y, -0.2);\n  d = min (min (d, min (PrEECapsDf (q, vec3 (0.95, 0.4, 2.7) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 1.1, -0.15) + vec3 (0., 2., 0.) * s, rRig),\n     PrEECapsDf (q, vec3 (1.05, 1., -0.1) + vec3 (-0.1, 2., 0.) * s,\n     vec3 (0.05, 0.5, -2.95) + vec3 (0., 1.7, 0.) * s, rRig))),\n     PrEECapsDf (q, vec3 (0.95, 0.4, -2.9) + vec3 (-0.1, 1.7, 0.) * s,\n     vec3 (0.05, 0.9, -0.25) + vec3 (0., 2., 0.) * s, rRig));\n  DMINQ (idRig);\n  return dMin;\n}\n\n#define VL(x) vec4 (normalize (x), length (x))\n\nvoid SRigConsts ()\n{\n  vim[0] = vec3 (0., -3.5, 4.3);    vum[0] = VL (vec3 (0., -2.6, 6.7) - vim[0]);\n  vim[1] = vec3 (0., -4., 4.1);     vum[1] = VL (vec3 (0., -2.9, 6.) - vim[1]);\n  vim[2] = vec3 (0., -1.2, -3.);    vum[2] = VL (vec3 (0., -0.5, -4.5) - vim[2]);\n  vim[3] = vec3 (0., -2.7, -3.);    vum[3] = VL (vec3 (0., -2.7, -4.5) - vim[3]);\n  vir[0] = vec3 (0., -3., -4.45);   vur[0] = VL (vec3 (0., -2.7, -4.5) - vir[0]);\n  vir[1] = vec3 (0., 2.45, 2.65);   vur[1] = VL (vec3 (0., -2.7, 6.5) - vir[1]);\n  vir[2] = vec3 (0., 2.5, 2.65);    vur[2] = VL (vec3 (0., -3.2, 4.9) - vir[2]);\n  vir[3] = vec3 (0., 2.6, -3.);     vur[3] = VL (vec3 (0., -0.5, -4.5) - vir[3]);\n  vir[4] = vec3 (0.65, -3.5, 3.5);  vur[4] = VL (vec3 (0.05, -2.7, 6.4) - vir[4]);\n}\n\nvoid ShipState ()\n{\n  vec4 h;\n  vec2 g, e, ee[4];\n  szFac = (length (cId) == 0.) ? 1. : 0.7;\n  shipOff = 2. * sin (0.01 * pi * (Hashfv2 (cId + 0.5) - 0.5) * (tCur + 100.) +\n     vec2 (0.5 * pi, 0.));\n  g = bGrid * (cId + 0.5) + shipOff;\n  e = vec2 (2.5 * szFac, 0.);\n  ee[0] = - e;\n  ee[1] = e;\n  ee[2] = - e.yx;\n  ee[3] = e.yx;\n  for (int j = VAR_ZERO; j < 4; j ++) h[j] = WaveHt (g + ee[j]);\n  shipConf = vec3 (0.25 * dot (h, vec4 (1.)), vec2 (h.xz - h.yw) / (2. * e.x));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  p.xz -= bGrid * (cId + 0.5) + shipOff;\n  p.yz = Rot2D (p.yz, -0.4 * shipConf.z);\n  p.xy = Rot2D (p.xy, 3. * shipConf.y);\n  p.y -= shipConf.x + 4.2 * szFac;\n  p.xz *= -1.;\n  q = p;\n  q /= szFac;\n  dMin = dstFar / szFac;\n  dMin = ShipHullDf (q, dMin);\n  dMin = ShipMastDf (q, dMin);\n  dMin = ShipSailDf (q, dMin);\n  dMin = ShipRigDf (q, dMin);\n  return 0.7 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ShipState ();\n      cIdP = cId;\n    }\n    d = (Maxv2 (abs (cId) - grLim) <= 0.) ? ObjDf (p) : dstFar;\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (Minv2 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat MSymCol (vec2 s)\n{\n  return min (abs (length (s) - 0.1) - 0.02, PrBox2Df (Rot2D (s, 2. * pi * floor (3. *\n     atan (s.y, - s.x) / (2. * pi) + 0.5) / 3.) + vec2 (0.05, 0.), vec2 (0.05, 0.02)));\n}\n\nvec4 ShipCol ()\n{\n  vec4 col4;\n  vec3 cSym;\n  vec2 cg;\n  cSym = (length (cId) > 0.) ? HsvToRgb (vec3 (Hashfv2 (17.11 * cId), 0.8, 1.)) : vec3 (0.1);\n  if (idObj == idHull) {\n    if (abs (qHit.x) < bDeck.x - 0.08 && qHit.y > -3.6 && qHit.z > - bDeck.z + 0.62) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, fract (8. * qHit.x)));\n    } else if (qHit.y > -4.) {\n      col4 = vec4 (0.7, 0.5, 0.1, 0.1);\n      if (abs (qHit.z - 4.) < 0.25 && abs (qHit.y + 3.55) < 0.05) col4 *= 1.2;\n      else if (qHit.z < -4. && abs (qHit.x) < 0.84 && abs (qHit.y + 3.62) < 0.125) {\n        cg = step (0.1, abs (fract (vec2 (6. * qHit.x, 8. * (qHit.y + 3.62)) + 0.5) - 0.5));\n        if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n        else col4 *= 0.8;\n      } else {\n        col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.02, fract (8. * qHit.y));\n      } \n    } else if (qHit.y > -4.05) {\n      col4 = vec4 (0.8, 0.8, 0.8, 0.1);\n    } else if (qHit.y < -4.7) {\n      col4 = vec4 (0.8, 0., 0., 0.1);\n    } else {\n      col4 = vec4 (0.3, 0.2, 0.1, 0.);\n    }\n  } else if (idObj == idRud) {\n    col4 = vec4 (0.5, 0.3, 0., 0.);\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.4, 0.3, 0.1, 0.1);\n    if (max (abs (qHit.x), abs (qHit.z + 0.22)) < 0.2) {\n      cg = step (0.1, abs (fract (vec2 (10. * vec2 (qHit.x, qHit.z + 0.22)) + 0.5) - 0.5));\n      if (cg.x * cg.y == 1.) col4 = vec4 (0.8, 0.8, 0.2, -1.);\n    }\n  } else if (idObj == idSailT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (1., 1., 1., 0.) * (0.8 + 0.2 * SmoothBump (0.08, 0.92, 0.02, fract (4. * qHit.x)));\n    if (abs (qHit.z) < 0.2) col4.rgb = mix (cSym, col4.rgb,\n       smoothstep (-0.01, 0., MSymCol (0.3 * vec2 (0.25 - qHit.y, qHit.x))));\n  } else if (idObj == idSailA) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.8 + 0.2 * SmoothBump (0.08, 0.92, 0.02, fract (5. * qHit.z)));\n  } else if (idObj == idSailF) {\n    col4 = vec4 (1., 1., 1., 0.) * (0.8 + 0.2 * SmoothBump (0.08, 0.92, 0.02,\n       fract (2.95 * qHit.y + 4. * qHit.z - 0.5)));\n  } else if (idObj == idFlag) {\n    col4 = vec4 (1., 1., 0.5, 0.1);\n    col4.rgb = mix (cSym, col4.rgb, smoothstep (-0.01, 0., MSymCol (-0.7 * qHit.yz)));\n  } else if (idObj == idMast) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (length (qHit.xz) < 0.16 * (1. - 0.07 * qHit.y))\n       col4 *= 0.6 + 0.4 * SmoothBump (0.03, 0.97, 0.01, fract (2. * qHit.y /\n       (1. + 0.14 * step (1., abs (qHit.z)))));\n    if (qHit.y > 3.65) col4 = vec4 (1., 0., 0., -1.);\n  } else if (idObj == idSparT) {\n    qHit.x *= (1. + 0.07 * qHit.y) * (1. + 0.14 * step (1., abs (qHit.z)));\n    col4 = vec4 (0.7, 0.4, 0., 0.1) *  (0.6 + 0.4 * SmoothBump (0.08, 0.92, 0.01,\n       fract (4. * qHit.x)));\n  } else if (idObj == idSparL) {\n    col4 = vec4 (0.7, 0.4, 0., 0.1);\n    if (qHit.z > 6.65) col4 = vec4 (1., 1., 0.3, -1.);\n  } else if (idObj == idRig) {\n    col4 = vec4 (0.2, 0.15, 0.1, 0.);\n  }\n  return col4;\n}\n\nvec3 CloudCol (vec3 ro, vec3 rd)\n{\n  vec4 cSum, c;\n  vec3 s1, s2;\n  float sd, sd2, sd4, sd16, t;\n  s1 = 0.003 * (ro + cloudDisp + rd * (300. - ro.y) / rd.y);\n  s2 = 0.003 * (rd * 10. / rd.y);\n  cSum = vec4 (0.);\n  for (float ns = float (VAR_ZERO); ns < 100.; ns ++) {\n    c.a = 0.8 * smoothstep (0.5, 1., Fbm3 (s1 + s2 * ns));\n    c = vec4 (1., 0.95, 0.9, c.a) - vec4 (0.7, 0.65, 0.7, cSum.a) * c.a;\n    cSum += vec4 (c.rgb * c.a, c.a);\n    if (cSum.a > 0.99) break;\n  }\n  cSum.rgb /= cSum.a + 0.001;\n  sd = max (dot (rd, sunDir), 0.);\n  sd2 = sd * sd;\n  sd4 = sd2 * sd2;\n  sd16 = sd4 * sd4;\n  sd16 *= sd16;\n  cSum.rgb += vec3 (0.5) * mix (sd4, - sd16, smoothstep (0.8, 1., cSum.a));\n  t = pow (1. - 0.7 * rd.y, 16.);\n  return mix (vec3 (0.05, 0.2, 0.5) + t * vec3 (0.45, 0.4, 0.3) +\n     0.3 * vec3 (1., 0.9, 0.8) * (sd2 + 4. * pow (sd16, 16.)), cSum.rgb, cSum.a * (1. - t));\n}\n\nfloat CloudDens (vec3 ro, vec3 rd)\n{\n  vec3 s1, s2;\n  float attSum;\n  s1 = 0.003 * (ro + cloudDisp + rd * (300. - ro.y) / rd.y);\n  s2 = 0.003 * (rd * 10. / rd.y);\n  attSum = 0.;\n  for (float ns = float (VAR_ZERO); ns < 100.; ns += 10.) {\n    attSum += 0.8 * (1. - attSum) * smoothstep (0.5, 1., Fbm3 (s1 + s2 * ns));\n    if (attSum > 0.99) break;\n  }\n  return clamp (1. - attSum, 0., 1.);\n}\n\nfloat GRayDens (vec3 ro, vec3 rd)\n{\n  vec3 p, s1, s2;\n  float d, sd, gDens;\n  sd = 0.08 * max (dot (rd, sunDir), 0.);\n  gDens = 0.;\n  if (sd > 0.01) {\n    s1 = ro + 200. * rd;\n    s2 = 40. * rd;\n    for (float ns = float (VAR_ZERO); ns < 32.; ns ++) {\n      p = s1 + s2 * ns;\n      gDens += sd * (1. - gDens) * smoothstep (0.8, 1., CloudDens (p, sunDir));\n      if (p.y > 400. || gDens > 0.95) break;\n    }\n  }\n  return gDens;\n}\n\nvec3 WaveCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, sd2, sd4;\n  sd = max (dot (rd, sunDir), 0.);\n  sd2 = sd * sd;\n  sd4 = sd2 * sd2;\n  col = vec3 (0.15, 0.2, 0.2) * (0.7 * ro.y + 1.) +\n     CloudDens (ro + 300. * rd, rd) * (mix (vec3 (0., 0.1, 0.2), vec3 (0.2, 0.2, 0.3), rd.y) +\n     (1. - rd.y) * vec3 (0.6, 0.6, 0.5) * sd4);\n  col = mix (col * (0.7 + 0.3 * sd2), vec3 (0.6, 0.8, 0.9) + vec3 (0.2, 0.2, 0.1) * sd4,\n     1. - exp (- pow (0.005 * dstWat, 1.5)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, roo, row, rdo, vn, vnw;\n  float dstObj, reflFac;\n  tWav = 0.5 * tCur;\n  cloudDisp = vec3 (0., 0., -20. * tCur);\n  SRigConsts ();\n  roo = ro;\n  rdo = rd;\n  reflFac = 1.;\n  col = vec3 (0.);\n  dstWat = (rd.y < 0.) ? WaveRay (ro, rd) : dstFar;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k == 0 && dstWat < min (dstObj, dstFar)) {\n      ro += dstWat * rd;\n      row = ro;\n      vnw = WaveNf (ro, dstWat).xyz;\n      rd = reflect (rd, vnw);\n      reflFac = 0.25;\n    } else break;\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ShipCol ();\n    if (col4.a >= 0.) col = col4.rgb * (0.3 + \n       0.7 * max (dot (vn, vec3 (sunDir * vec3 (-1., 1., -1.))), 0.) +\n       0.7 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n  } else if (dstWat < dstFar) {\n    reflFac = 0.;\n  } else {\n    col = CloudCol (roo, rdo) + 0.9 * vec3 (1., 0.8, 0.6) * GRayDens (roo, rdo);\n  }\n  if (reflFac < 1.) col = mix (WaveCol (row, reflect (rdo, vnw)), col, reflFac);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col, u;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bGrid = vec2 (12., 16.);\n  grLim = vec2 (1., 1.);\n  ro = vec3 (20., 8.6, -40.);\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    ro.x += 30. * mPtr.x;\n    zmFac += 2. * (mPtr.y + 0.5);\n  } else {\n    ro.x += 8. * sin (0.015 * pi * tCur);\n  }\n  vd = normalize (vec3 (6., 3., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (0.5, 0.25, 1.));\n  dstFar = 300.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}