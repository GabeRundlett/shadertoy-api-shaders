{
    "Shader": {
        "info": {
            "date": "1687341971",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! (mouseable)\n\nvery linux / openGL screensaver looking",
            "flags": 0,
            "hasliked": 0,
            "id": "cdfyR2",
            "likes": 21,
            "name": "Year of Truchets #041",
            "published": 3,
            "tags": [
                "raymarching",
                "truchet",
                "trippy",
                "circuit"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 264
        },
        "renderpass": [
            {
                "code": "/**\n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #041\n    06/21/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MIN_DIST    1e-3\n#define MAX_DIST    55.\n\n// constants\nconst float size = 1.35;\nconst float hlf = size*.5;\nconst float xlf = hlf*.5;\n\nvec3 hit,hitPoint;\nvec2 gid,sid;\nmat2 r90,r45;\nfloat speed,glowa,glowb;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq sdfs & extrude\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat box(vec2 p, vec2 a) {\n    vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\nfloat cap( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat opx(in float sdf, in float pz, in float h) {\n    vec2 w = vec2( sdf, abs(pz) - h );return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos, float sg){\n    vec2 res = vec2(1e5,0);\n\n    pos-=vec3(0,0,speed);\n\n    float sw = .2+.2*sin(pos.z*.63);\n    sw -= .3+.2*cos(pos.x*.73);\n    pos.y-=sw;\n    \n    vec2 uv = pos.xz;\n    vec2 id = floor((uv+hlf)/size);\n    vec2 q = mod(uv+hlf,size)-hlf;\n    \n    vec3 pp = vec3(q.x,pos.y,q.y);\n\n    float rnd = hash21(id);\n    float rdm = fract(rnd*42.79);\n    \n    if (rnd>.5) {q.x = -q.x; pp.xz*=r90;}\n    rnd = fract(rnd*32.781);\n    \n    float mv = .02, mx = mv*3.5;\n    const vec3 b2 = vec3(1.,.15,hlf);\n\n    vec2 spc = vec2(-hlf,.0);\n    vec2 p2 = vec2(length(q+spc),length(q-spc));\n    vec2 pq = p2.x<p2.y? q+spc : q-spc;\n\n    pq *= r45;\n\n    float d = length(pq.x);\n    if(rnd>.85) d = min(length(q.x),length(q.y));\n\n    d = abs(d)-mv;\n\n    float pl = length(vec2(abs(q.x)-hlf,q.y))-(mx);\n          pl = min(length(vec2(q.x,abs(q.y)-hlf))-(mx),pl);\n\n    float d3 = opx(d,pos.y,.05);\n    float ct = box(pp,vec3(hlf,5,hlf));\n    d3=max(max(d3,ct),-(pl));\n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit = pos-vec3(0,sw,0);\n    }\n\n    float pole = opx(abs(pl)-.01,pos.y, .055);\n    if(pole<res.x) {\n        res = vec2(pole,3.);\n        hit = pos;\n    }\n    \n    float bx=1e5,rx=1e5,cx=1e5,lx=1e5;\n    if(rnd<.675 && rdm>.75){\n        pp.xz*=r45;\n        bx = box(pp,vec3(xlf,.05,xlf*.5))-.01;\n    }else if(rnd<.675 && rdm>.5){\n        pp.xz*=r45;\n        pp = vec3(abs(abs(pp.x)-(.125*size))-(.0625*size),pp.yz);\n        rx = cap(pp.yzx,.74*xlf,.01*size)-.03;\n    }else if(rnd<.675 && rdm<.2){\n        pp.y-=.2;\n        cx = cap(pp,.2,.15)-.01;\n    }else if(rnd<.675) {\n        lx = cap(pp,.1,.001)-.05;\n        bx=min(bx,cap(pp+vec3(0,.05,0),.03,.075));\n    }\n    rdm = fract(rnd*42.79);\n    if(bx<res.x) {\n        res = vec2(bx,4.);\n        hit = pp;\n    }\n    if(rx<res.x) {\n        res = vec2(rx,7.);\n        hit = pp;\n    }\n    if(cx<res.x) {\n        res = vec2(cx,8.);\n        hit = pp;\n    }  \n    if(lx<res.x) {\n        res = vec2(lx,9.);\n        hit = pp;\n    } \n    float flr =pos.y+.05;\n    if(flr<res.x) {\n        res = vec2(flr,1.);\n        hit = pos;\n    }\n           \n    if(sg==1.&&lx<bx) { \n        if(rdm>.5) {glowa += .0005/(.0001+lx*lx);}else{glowb += .0005/(.0001+lx*lx);}\n    }\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e,0. ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e,0. ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e,0. ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e,0. ).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd,float cnt) {\n    float d = 0., m = 0.;\n    for(int i=0;i<128;i++){\n        vec2 ray = map(ro + rd * d,cnt>0.?0.:1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<64?ray.x*.4:ray.x*.8;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv, float cnt) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd,cnt);\n    d=ray.x;m=ray.y;\n    \n    // save globals post march\n    hitPoint = hit;  \n    sid = gid;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST)\n    {\n             p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-6.,12.,12.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 16.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.5);\n\n        if(m==1.) {\n            float px = 2./R.x; \n            vec2 dp = p.xz;\n            dp.y-=speed;\n            vec3 k = vec3(0.012,0.149,0.047);\n            vec2 id = floor(dp.xy*6.), q = fract(dp.xy*6.)-.5;\n            float hs = hash21(id.xy);\n\n            if(hs>.5)  q.xy *= rot(1.5707);\n            hs = fract(hs*575.913);\n\n            float mv = .1;\n\n            vec2 spc = vec2(-.5,.0);\n            vec2 p2 = vec2(length(q+spc),length(q-spc));\n            vec2 pq = p2.x<p2.y? q+spc : q-spc;\n\n            pq *= r45;\n\n            float td = length(pq.x);\n            td=abs(td)-mv;\n\n            if(hs>.85) td = min(length(q.x)-mv,length(q.y)-mv);\n            float b = length(vec2(abs(q.x)-.5,q.y))-(mv*1.75);\n            b = min(length(vec2(q.x,abs(q.y)-.5))-(mv*1.75),b);\n            td = min(b,td);\n            h = mix(k,k*.75,smoothstep(px,-px,td));\n            ref = vec3(td);\n        }\n        if(m==2.) { \n            h = hsv2rgb(vec3(hitPoint.z*.02,1.,.3)); \n            ref = h; \n        }\n        if(m==3.) { h = vec3(.1); ref = h; }\n        if(m==4.) { h = vec3(.05); ref = vec3(.35); }\n        if(m==5.) { \n            h = hsv2rgb(vec3(-hitPoint.z*.02,.75,.3)); \n            ref = h; \n        }\n        if(m==6.) { \n            vec2 f = fract(hitPoint.xz*.5)-.5;\n            h = vec3(.01);\n            if(f.x*f.y>.0)h=vec3(.1);\n            ref = h; \n        }\n        if(m==7.) { \n            h = vec3(0.255,0.161,0.086); \n            float ft = fract((hitPoint.z+.4)*8.)-.5;\n            float fmod = mod(floor(ft),3.);\n            if(hitPoint.z>-.15) h = mix(h,hsv2rgb(vec3((p.z-speed)*.5,.8,.1)),fmod==0.?1.:0.);\n            \n            ref = h*.5; \n        }\n        if(m==8.) { \n            vec2 hp = hitPoint.xz;\n            float d = length(hp)-.1;\n            float b = box(hp-vec2(.5,0),vec2(.5,.05));\n            float px = 4./R.x;\n            h = vec3(.012,.227,.427); \n            h = mix(h,vec3(0.349,0.506,0.651),smoothstep(px,-px,b));\n            h = mix(h,vec3(.1),smoothstep(px,-px,d));\n            ref = h*.5; \n        }\n        \n        C = (diff*h);\n\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } \n\n    return vec4(C,d);\n}\n\nmat2 rx,ry;\nvec3 FC = vec3(0.114,0.227,0.137);\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    r45 = rot(.7853981634);\n    r90 = rot(1.5707);\n    speed = T*2.05;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,5.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z <0. ? .0 : (M.y/R.y * .24-.12)*PI;\n    float y = M.xy==vec2(0) || M.z <0. ? .0 : (M.x/R.x * 1.0-.50)*PI;\n\n    float ff = .45+.25*cos(T*.065), fx = .55*sin(T*.113);\n\n    rx = rot(-(.28+ff)-x), ry = rot(-fx-y);\n    \n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n    \n    // up to 4 is good - 2 average bounce\n    for(float i=0.; i<2.; i++) {   \n        //glowa=0.;glowb=0.;\n        vec4 pass = render(ro, rd, ref, d, uv, i);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n     \n    }\n      \n    C = mix(C,vec3(0.941,0.459,0.459),clamp(glowa*.5,0.,1.));\n    C = mix(C,vec3(0.420,0.749,0.353),clamp(glowb*.5,0.,1.));\n    \n    C = mix(FC,C,exp(-.00025*a*a*a));\n  \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}