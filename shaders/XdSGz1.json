{
    "Shader": {
        "info": {
            "date": "1383304177",
            "description": "Little shader art.",
            "flags": 8,
            "hasliked": 0,
            "id": "XdSGz1",
            "likes": 19,
            "name": "noir et blanc (sound)",
            "published": 3,
            "tags": [
                "art",
                "stylish"
            ],
            "usePreview": 0,
            "username": "srtuss",
            "viewed": 663
        },
        "renderpass": [
            {
                "code": "// srtuss, 2013\n\n#define ITER 20\n\nvec2 circuit(vec2 p)\n{\n\tp = fract(p);\n\tfloat r = 0.123;\n\tfloat v = 0.0, g = 0.0;\n\tfloat test = 0.0;\n\tr = fract(r * 9184.928);\n\tfloat cp, d;\n\t\n\td = p.x;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\td = p.y;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\td = p.x - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\td = p.y - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\t\n\tfor(int i = 0; i < ITER; i ++)\n\t{\n\t\tcp = 0.5 + (r - 0.5) * 0.9;\n\t\td = p.x - cp;\n\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);\n\t\tif(d > 0.0)\n\t\t{\n\t\t\tr = fract(r * 4829.013);\n\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\tv += 1.0;\n\t\t\ttest = r;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr = fract(r * 1239.528);\n\t\t\tp.x = p.x / cp;\n\t\t\ttest = r;\n\t\t}\n\t\tp = p.yx;\n\t}\n\t\n\tv /= float(ITER);\n\t\n\treturn vec2(v, g);\n}\n\nfloat rand12(vec2 p)\n{\n\tvec2 r = (456.789 * sin(789.123 * p.xy));\n\treturn fract(r.x * r.y);\n}\n\nvec2 rand22(vec2 p)\n{\n\tvec2 ra = (456.789 * sin(789.123 * p.xy));\n\tvec2 rb = (456.789 * cos(789.123 * p.xy));\n\treturn vec2(fract(ra.x * ra.y + p.x), fract(rb.x * rb.y + p.y));\n}\n\nfloat noise12(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\tfr = smoothstep(0.0, 1.0, fr);\n\treturn mix(\n\t\tmix(rand12(fl),                  rand12(fl + vec2(1.0, 0.0)), fr.x),\n\t\tmix(rand12(fl + vec2(0.0, 1.0)), rand12(fl + vec2(1.0, 1.0)), fr.x), fr.y);\n}\n\nfloat fbm12(vec2 p)\n{\n\treturn noise12(p) * 0.5 + noise12(p * 2.0 + vec2(11.93, 0.41)) * 0.25 + noise12(p * 4.0 + vec2(1.93, -17.41)) * 0.125 + noise12(p * 8.0 + vec2(-19.93, 11.41)) * 0.0625;\n}\n\t\nvec3 voronoi(in vec2 x)\n{\n\tvec2 n = floor(x); // grid cell id\n\tvec2 f = fract(x); // grid internal position\n\tvec2 mg; // shortest distance...\n\tvec2 mr; // ..and second shortest distance\n\tfloat md = 8.0, md2 = 8.0;\n\t\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 g = vec2(float(i), float(j)); // cell id\n\t\t\tvec2 o = rand22(n + g); // offset to edge point\n\t\t\tvec2 r = g + o - f;\n\t\t\t\n\t\t\tfloat d = max(abs(r.x), abs(r.y)); // distance to the edge\n\t\t\t\n\t\t\tif(d < md)\n\t\t\t\t{md2 = md; md = d; mr = r; mg = g;}\n\t\t\telse if(d < md2)\n\t\t\t\t{md2 = d;}\n\t\t}\n\t}\n\treturn vec3(n + mg, md2 - md);\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat xor(float a, float b)\n{\n    return min(max(-a, b), max(a, -b));\n}\n\nfloat fr2(vec2 uv)\n{\n    float v = 1e38, dfscl = 1.0;\n    \n    vec4 rnd = vec4(0.1, 0.3, 0.7, 0.8);\n    \n    #define RNDA rnd = fract(sin(rnd * 11.1111) * 2986.3971)\n    #define RNDB rnd = fract(cos(rnd * 11.1111) * 2986.3971)\n    \n    RNDA;\n    \n    for(int i = 0; i < 8; i++)\n    {\n        vec2 p = uv;\n        \n        //p.x += iTime;\n        \n        float si = 1.0 + rnd.x;\n        p = (abs(fract(p / si) - 0.5)) * si;\n        vec2 q = p;\n        float w = max(q.x - rnd.y * 0.7, q.y - rnd.z * 0.7);\n        w /= dfscl;\n        v = xor(v, w);\n        \n        if(w < 0.0)\n        {\n        \tRNDA;\n        }\n        else\n        {\n            RNDB;\n        }\n        \n        float sii = 1.2;\n        \n        uv *= sii;\n        uv -= rnd.xz;\n        dfscl *= sii;\n    }\n    return v;\n}\n\n\nvec3 pixel(vec2 uv)\n{\n\tuv /= iResolution.xy;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tfloat t = iTime * 0.5;\n\t\n\tuv = rotate(uv, sin(t) * 0.1);\n\tuv += t * vec2(0.5, 1.0);\n\t\n\tvec2 ci = circuit(uv * 0.1);\n\t\n\tvec3 vo, vo2, vo3;\n\tvo = voronoi(uv);\n\t\n\tfloat f = 80.0;\n\t\n\tfloat cf = 0.1;\n\tvec2 fr = (fract(uv / cf) - 0.5) * cf;\n\tvec2 fl = (floor(uv / cf) - 0.5) * cf;\n\tfloat cir = length(fr /*+ normalize(rand22(fl) * 2.0 - 1.0) * 0.2*/) - 0.03;\n\t\n    float v;\n    v = min(cos(vo.z * f), cir * 50.0) + ci.y;\n\t\n    float ww = fr2(uv / 1.5) * 1.5;\n    v = max(v, smoothstep(0.0, 0.01, ww - ci.y * 0.03));\n    \n    v = smoothstep(0.2, 0.0, v);\n    \n\t//v = mix(v, 0.0, );\n    //v = mix(v, 1.0, smoothstep(0.02, 0.0, abs(ww)));\n\t\n\t//v += smoothstep(0.01, 0.0, length(fr) - 0.1);\n\t\n\treturn vec3(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col;\n\t\n\tvec2 h = vec2(0.5, 0.0);\n\tcol = pixel(fragCoord.xy + h.yy);\n\tcol += pixel(fragCoord.xy + h.xy);\n\tcol += pixel(fragCoord.xy + h.yx);\n\tcol += pixel(fragCoord.xy + h.xx);\n\t\n\tcol /= 4.0;\n\t\n\t//col = vec3(1.0);\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tcol *= ((1.0 - pow(abs(uv.x), 2.1)) * (1.0 - pow(abs(uv.y), 2.1)));\n\t\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// srtuss, 2013\n\n#define pi2 6.283185307179586476925286766559\n\nfloat hash(float x)\n{\n    return fract(sin(11.42 * x) * 298251.5762);\n}\n\nvec2 s(float time)\n{\n    // -4 -2 0 2 4 7 9 10;\n    \n    float t = time * 8.0;\n    float tt = t;\n    \n    //t = mod(t, 8.0);\n    \n    t = floor(t);\n    \n    //t = t * (t - 5.0);\n    //t *= 2.0;\n    //t = mod(t, 8.0);\n    t *= 5.0;//315.0;\n    t = mod(t, 8.0);\n    \n    t += floor(tt / 4.0) * 1.0;\n    \n    \n    t = mod(t, 8.0);\n    \n    \n    float f = -4.0; // -4\n    f += step(1.0, t) * 2.; // -2\n    f += step(2.0, t) * 1.; // 0\n    f += step(3.0, t) * 2.; // -2\n    f += step(4.0, t) * 2.; // 4\n    f += step(5.0, t) * 1.; // 7\n    f += step(6.0, t) * 2.; // 9\n    f += step(7.0, t) * 2.; // 10\n    \n    float ch = floor(tt / 64.0) * 40.0;\n    ch = mod(ch, 6.0);\n    ch = floor(ch);\n    f += ch;\n    \n    float fa = 440.0 * pow(2.0, (f + 10.0) / 12.0);\n    \n    t = fract(tt);\n    \n    float adsr = smoothstep(1.0, 0.5, t) * smoothstep(0.0, 0.1, t);\n    vec2 v = sin(vec2(fa, fa * 1.001) * time * pi2) * adsr * vec2(1.0);\n    \n    float adsr2 = smoothstep(1.0, 0.99, t) * smoothstep(0.0, 0.005, t);\n    \n    v += sin(time * pi2 * fa * 0.5) * adsr2 * 0.4;\n    v += sin(time * pi2 * fa * 4.0) * adsr * 0.1;\n    \n    //v = vec2(0.0);\n    \n    \n    tt = mod(tt, 32.0);\n    float ttx = mod(tt - 4.0, 4.0);\n    float n = ch + 2.0 - step(6.0, tt) * 8.0 + step(16.0, tt) * 3.0 + step(22.0, tt) * -7.0;\n    tt = mod(tt, 5.0);\n    tt = fract(tt / 3.0) * 3.0;\n    float bn = n - 12.0 * step(tt, 1.0);\n    fa = 440.0 * pow(2.0, bn / 12.0);\n    \n    float s = (1.1 + sin(time)) * 0.2;\n    float pw = sin(time * 17.0) * 0.4;\n    v += (smoothstep(-s + pw, s + pw, sin(time * pi2 * vec2(fa, fa * 1.01) / 4.0)) - 0.5) * 2.4;\n    v *= smoothstep(1.0, 0.9, t) * smoothstep(0.0, 0.01, t);\n    \n    v += sin(fa * pi2 * time * 2.0) * adsr * 0.4;\n    fa = 440.0 * pow(2.0, n / 12.0);\n    //v = vec2(0.0);\n    v += sin(fa * pi2 * time * 0.125) * 0.55 * (1.0 - exp(ttx * ttx * -0.4));\n    \n    //fa = pow(2.0, hash(floor(time * 16.0)) * 24.0) + 200.0;\n    //v += sin(fa * t * pi2) * vec2(0.4);\n    \n    return v;\n}\n\nvec2 echo(float t)\n{\n    vec2 v;\n    \n    float a = 0.2, et = 0.1, fb = 0.6;\n    v = vec2(s(t));\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.2;\n    v = v.yx + s(t - et) * a * vec2(0.5, 1.0); a *= -fb; et += 0.2;\n    v = v    + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.3;\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= -fb; et += 0.2;\n    v = v    + s(t - et) * a * vec2(0.5, 1.0); a *= fb; et += 0.3;\n    v = v    + s(t - et) * a * vec2(1.0, 0.5); a *= -fb; et += 0.3;\n    v = v.yx + s(t - et) * a * vec2(0.5, 1.0); a *= fb; et += 0.2;\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= -fb; et += 0.3;\n    v = v    + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.4;\n    v = v.yx + s(t - et) * a * vec2(0.5, 1.0); a *= -fb; et += 0.3;\n    v = v.yx + s(t - et) * a * vec2(1.0, 0.5); a *= fb; et += 0.2;\n    \n    return v * 0.3;\n}\n\n\nvec2 mainSound( in int samp,float time)\n{\n   \n    return vec2(echo(time) * .4);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}