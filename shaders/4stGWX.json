{
    "Shader": {
        "info": {
            "date": "1453452987",
            "description": "Testing anti-aliasing with coverage estimated with Gaussian. No multisampling. Click to show the render without anti-aliasing. Based on eiffie's shader: https://www.shadertoy.com/view/ldSGRz",
            "flags": 0,
            "hasliked": 0,
            "id": "4stGWX",
            "likes": 15,
            "name": "Gaussian AA Test",
            "published": 3,
            "tags": [
                "antialias",
                "gaussian"
            ],
            "usePreview": 0,
            "username": "tsone",
            "viewed": 845
        },
        "renderpass": [
            {
                "code": "/*\n\nCopyright 2016 Valtteri \"tsone\" HeikkilÃ¤\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\n#define SQRT2    1.414213562373095\n#define SQRT3    1.732050807568877\n\n// Number of edges to record (=size of \"edge stack\"). Possible values: 1,2\n#define AA_EDGES 2\n\n// Define for static marching threshold (useful for older GPUs...)\n//#define MARCH_THRESHOLD  .000001\n#ifdef MARCH_THRESHOLD\n#define MARCH_ITERATIONS 96\n#else\n#define MARCH_ITERATIONS 128\n#endif\n\n#define FISHEYE_AMOUNT   (-.3 - .3*sin(.3*iTime))\n#define MAX_DEPTH 220.\n\n\nfloat sqr(float x) { return x*x; }\n\n\nmat3 rot_mat;\n\nfloat pxg; // Pixel cone radius coeff for Gaussian coverage.\nfloat pxn; // -\"- for normal/gradient calculation.\nfloat pxm; // -\"- for dynamic threshold for marching.\n\n\nmat3 rot_y(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\tca,0.0,sa,\n\t\t0.0,1.0,0.0,\n\t\t-sa,0.0,ca\n\t);\n}\n\nmat3 rot_x(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,ca,sa,\n\t\t0.0,-sa,ca\n\t);\n}\n\nfloat BoxRounded(in vec3 p, in vec3 s, float r)\n{\n    p = max(abs(p) - s, 0.);\n\treturn length(p) - r;\n}\n\nfloat Map(in vec3 p)\n{\n    p = mod(p + 6., 12.) - 6.;\n    p = abs(p);\n\tfloat d0 = BoxRounded(p, vec3(2.7), .1);\n\tfloat d1 = BoxRounded(p+vec3(-2.8), vec3(1.7), .1);\n    return max(d0, -d1);\n}\n\nvec3 CameraRayDir(in vec2 fragCoord)\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / length(iResolution.xy);\n\treturn normalize(vec3(SQRT2 * uv, 1. + FISHEYE_AMOUNT * dot(uv, uv)));\n}\n\nvoid Camera(out vec3 P, out vec3 D, in vec2 fragCoord)\n{\n    D = CameraRayDir(fragCoord);\n    \n    // Calc 'px' as delta of D (=ray direction) to neighboring farthest pixel.\n    vec3 D2 = CameraRayDir(fragCoord + sign(D.xy));\n    float px = length(D2 - D);\n    // SQRT3 scale distance to cover a sphere around px cube.\n    pxn = SQRT3 * px;\n    // SQRT2 is from 1/2 scaler in the exponent in Gaussian distribution.\n    // See: https://en.wikipedia.org/wiki/Gaussian_filter\n    pxg = SQRT2 * px;\n    // Ad-hoc, scaler should be small to eliminate surface peeling artefacts.\n    pxm = .0375 * px;\n    \n    // Position and rotate camera.\n    P = rot_mat * vec3(0.0,-.5,-10.);\n\tD = rot_mat * D;\n}\n\nvec3 Normal(in vec3 p, float t)\n{\n    vec2 v = vec2(t * pxn, 0.);\n\tfloat d1 = Map(p-v.xyy), d2 = Map(p+v.xyy);\n\tfloat d3 = Map(p-v.yxy), d4 = Map(p+v.yxy);\n\tfloat d5 = Map(p-v.yyx), d6 = Map(p+v.yyx);\n\treturn normalize(vec3(-d1+d2,-d3+d4,-d5+d6));\n}\n\nstruct MarchResult\n{\n#if AA_EDGES == 1\n    vec2 edge;\n#elif AA_EDGES == 2\n    vec4 edge;\n#endif\n    float t;\n    float d;\n};\n    \nvec3 Shade(in vec3 P, in vec3 D, float t, in vec3 L)\n{\n    P += t * D;\n\tvec3 N = Normal(P, t);\n    float NdotL = max(dot(N, L), 0.);\n    return vec3(NdotL);\n}\n\nvec3 SampleGauss(in vec3 srccolor, in vec3 dstcolor, float t, float d)\n{\n    // Divisor 3 sets the distribution cover 99% of the value inside px distance.\n    // See: https://en.wikipedia.org/wiki/Gaussian_filter\n    return mix(srccolor, dstcolor, exp(-sqr(d) / sqr(t*pxg / 3.)));\n}\n\nvec3 Color(in vec3 P, in vec3 D, in vec3 L, in MarchResult r, bool disable_aa)\n{\n    vec3 color = vec3(sqr(.5*D.y + .5));\n#ifdef MARCH_THRESHOLD\n    if (disable_aa && r.d < MARCH_THRESHOLD) {\n#else\n    if (disable_aa && r.d < pxm*r.t) {\n#endif\n    \tcolor = Shade(P, D, r.t, L);\n    } else {\n        color = SampleGauss(color, Shade(P, D, r.t, L), r.t, r.d);\n#if AA_EDGES == 1\n\t    color = SampleGauss(color, Shade(P, D, r.edge.y, L), r.edge.y, r.edge.x);\n#elif AA_EDGES == 2\n\t    color = SampleGauss(color, Shade(P, D, r.edge.w, L), r.edge.w, r.edge.z);\n\t    color = SampleGauss(color, Shade(P, D, r.edge.y, L), r.edge.y, r.edge.x);\n#endif\n    }\n    return color;\n}\n\nMarchResult March(in vec3 ro, in vec3 rd, float rnd)\n{\n    float t = Map(ro) * (1. - .25*rnd);\n    float t2 = t;\n    float d = t;\n    float od = MAX_DEPTH;\n\n#if AA_EDGES == 1\n    vec2 edge = vec2(MAX_DEPTH);\n#elif AA_EDGES == 2\n    vec4 edge = vec4(MAX_DEPTH);\n#endif\n    \n\tfor (int j = 0; j < MARCH_ITERATIONS; ++j) {\n\t\td = Map(ro + t*rd);\n        \n#if AA_EDGES == 1\n        if (od < d && od < edge.x && od < t2*pxg) {\n            edge = vec2(od, t2);\n        }\n#elif AA_EDGES == 2\n        if (od < d && od < edge.z && od < t2*pxg) {\n            edge = vec4(edge.zw, od, t2);\n        }\n#endif\n        t2 = t;\n        t += d;\n        od = d;\n#ifdef MARCH_THRESHOLD\n\t\tif (d < MARCH_THRESHOLD || t > MAX_DEPTH) {\n#else\n\t\tif (d < pxm*t || t > MAX_DEPTH) {\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n    return MarchResult(edge, t, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 P, D;\n\tint i;\n    \n    float rnd = texture(iChannel0, fragCoord / iChannelResolution[0].xy).r;\n\n    float time = .1 * iTime;\n    rot_mat = rot_y(time) * rot_x(.75);\n    \n\tCamera(P, D, fragCoord);\n\tMarchResult r = March(P, D, rnd);\n    vec3 L = rot_mat * normalize(vec3(-.15,.3,-1.));\n    \n    vec3 final = Color(P, D, L, r, iMouse.z > 0.);\n    // Reduce banding by adding noise.\n    final += rnd / 512.0;\n    // Gamma encode.\n    final = pow(final, vec3(1./2.2));\n\tfragColor = vec4(final, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}