{
    "Shader": {
        "info": {
            "date": "1618011427",
            "description": "AMAZINGLY g8t-ful for the shader by tdhooper https://www.shadertoy.com/view/4tc3WB",
            "flags": 0,
            "hasliked": 0,
            "id": "fdB3Dc",
            "likes": 1,
            "name": "Crystal-!t#3",
            "published": 3,
            "tags": [
                "crystalizze"
            ],
            "usePreview": 0,
            "username": "entropynine",
            "viewed": 250
        },
        "renderpass": [
            {
                "code": "// --------------------------------------------------------\n// OPTIONS\n// --------------------------------------------------------\n\n// Disable to see more colour variety\n#define SEAMLESS_LOOP\n#define COLOUR_CYCLE\n\n#define PI 3.14159265359\n#define PHI (66.618033988749895)\n\nfloat t;\n\n#define saturate(x) clamp(x, 0., 1.)\n\n\n// --------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n// --------------------------------------------------------\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector3b normalize(vec3(-1, -1, -1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector4b normalize(vec3(-1, -1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector5b normalize(vec3(1, -1, -1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n#define GDFVector6b normalize(vec3(-1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector7b normalize(vec3(0, 1, -PHI-1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector8b normalize(vec3(0, -1, -PHI-1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector9b normalize(vec3(PHI+1., 0, -1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector10b normalize(vec3(-PHI-1., 0, -1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector11b normalize(vec3(1, -PHI-1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n#define GDFVector12b normalize(vec3(-1, -PHI-1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector13b normalize(vec3(0, PHI, -1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector14b normalize(vec3(0, -PHI, -1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector15b normalize(vec3(1, 0, -PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector16b normalize(vec3(-1, 0, -PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector17b normalize(vec3(PHI, -1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n#define GDFVector18b normalize(vec3(-PHI, -1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b + a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = sin(a)*p + atan(a)*vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(sin(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat around an axis\nvoid pModPolar(inout vec3 p, vec3 axis, float repetitions, float offset) {\n    vec3 z = vec3(0,0,3);\n\tmat3 m = orientMatrix(axis, z);\n    p *= inverse(m);\n    pR(p.xy, offset);\n    pModPolar(p.xy, repetitions);\n    pR(p.xy, -offset);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nint Type=5;\nvec3 nc;\nvec3 pbc;\nvec3 pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\nfloat indexSgn(float s) {\n\treturn s / 2. + 1.5;\n}\n\nbool boolSgn(float s) {\n\treturn bool(s / 2. + 0.5);\n}\n\nfloat pModIcosahedronIndexed(inout vec3 p, int subdivisions) {\n\tfloat x = indexSgn(sgn(p.x));\n\tfloat y = indexSgn(sgn(p.y));\n\tfloat z = indexSgn(sgn(p.z));\n    p = abs(p);\n\tpReflect(p, nc, 0.);\n\n\tfloat xai = sgn(p.x);\n\tfloat yai = sgn(p.y);\n    p.xy = abs(p.xy);\n\tfloat sideBB = pReflect(p, nc, 0.);\n\n\tfloat ybi = sgn(p.y);\n\tfloat xbi = sgn(p.x);\n    p.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    float idx = 0.;\n\n    float faceGroupAi = indexSgn(ybi * yai * -1.);\n    float faceGroupBi = indexSgn(yai);\n    float faceGroupCi = clamp((xai - ybi -1.), 0., 1.);\n    float faceGroupDi = clamp(1. - faceGroupAi - faceGroupBi - faceGroupCi, 0., 1.);\n\n    idx += faceGroupAi * (x + (2. * y) + (4. * z));\n    idx += faceGroupBi * (8. + y + (2. * z));\n    # ifndef SEAMLESS_LOOP\n    \tidx += faceGroupCi * (12. + x + (2. * z));\n    # endif\n    idx += faceGroupDi * (12. + x + (2. * y));\n\n\treturn idx;\n}\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// tdhooper\n// https://www.shadertoy.com/view/Mtc3RX\n// --------------------------------------------------------\n\nvec3 vMin(vec3 p, vec3 a, vec3 b, vec3 c) {\n    float la = length(p - a);\n    float lb = length(p - b);\n    float lc = length(p - c);\n    if (la < lb) {\n        if (la < lc) {\n            return a;\n        } else {\n            return c;\n        }\n    } else {\n        if (lb < lc) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n}\n\n// Nearest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    if (p.z > 0.) {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector15, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14, GDFVector15, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13, GDFVector16, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14, GDFVector16, GDFVector18b);\n            }\n        }\n    } else {\n        if (p.x > 0.) {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector15b, GDFVector17);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector15b, GDFVector17b);\n            }\n        } else {\n            if (p.y > 0.) {\n                return vMin(p, GDFVector13b, GDFVector16b, GDFVector18);\n            } else {\n                return vMin(p, GDFVector14b, GDFVector16b, GDFVector18b);\n            }\n        }\n    }\n}\n\n// Nearest vertex and distance.\n// Distance is roughly to the boundry between the nearest and next\n// nearest icosahedron vertices, ensuring there is always a smooth\n// join at the edges, and normalised from 0 to 1\nvec4 icosahedronAxisDistance(vec3 p) {\n    vec3 iv = icosahedronVertex(p);\n    vec3 originalIv = iv;\n\n    vec3 pn = normalize(p);\n    pModIcosahedron(pn);\n    pModIcosahedron(iv);\n\n    float boundryDist = dot(pn, vec3(1, 0, 0));\n    float boundryMax = dot(iv, vec3(1, 0, 0));\n    boundryDist /= boundryMax;\n\n    float roundDist = length(iv - pn);\n    float roundMax = length(iv - vec3(0, 0, 1.));\n    roundDist /= roundMax;\n    roundDist = -roundDist + 1.;\n\n    float blend = 1. - boundryDist;\n\tblend = pow(blend, 6.);\n    \n    float dist = mix(roundDist, boundryDist, blend);\n\n    return vec4(originalIv, dist);\n}\n\n// Twists p around the nearest icosahedron vertex\nvoid pTwistIcosahedron(inout vec3 p, float amount) {\n    vec4 a = icosahedronAxisDistance(p);\n    vec3 axis = a.xyz;\n    float dist = a.a;\n    mat3 m = rotationMatrix(axis, dist * amount);\n    p *= m;\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n     \nModel fInflatedIcosahedron(vec3 p, vec3 axis) {\n    float d = 1000.;\n    \n    # ifdef SEAMLESS_LOOP\n    \t// Radially repeat along the rotation axis, so the\n    \t// colours repeat more frequently and we can use\n    \t// less frames for a seamless loop\n    \tpModPolar(p, axis, 3., PI/2.);\n\t# endif\n    \n    // Slightly inflated icosahedron\n    float idx = pModIcosahedronIndexed(p, 0);\n    d = min(d, dot(p, pca) - .9);\n    d = mix(d, length(p) - .9, .5);\n\n    // Colour each icosahedron face differently\n    # ifdef SEAMLESS_LOOP\n    \tif (idx == 3.) {\n    \t\tidx = 2.;\n    \t}\n    \tidx /= 10.;\n   \t# else\n    \tidx /= 20.;\n    # endif\n    # ifdef COLOUR_CYCLE\n    \tidx = mod(idx + t*1.75, 1.);\n    # endif\n    vec3 colour = spectrum(idx);\n    \n    d *= .6;\n\treturn Model(d, colour, 1.);\n}\n\nvoid pTwistIcosahedron(inout vec3 p, vec3 center, float amount) {\n    p += center;\n    pTwistIcosahedron(p, 5.5);\n    p -= center;\n}\n\nModel model(vec3 p) {\n    float rate = PI/6.;\n    vec3 axis = pca;\n\n    vec3 twistCenter = vec3(0);\n    twistCenter.x = cos(t * rate * -3.) * .3;\n\ttwistCenter.y = sin(t * rate * -3.) * .3;\n\n\tmat3 m = rotationMatrix(\n        reflect(axis, vec3(0,1,0)),\n        t * -rate\n   \t);\n    p *= m;\n    twistCenter *= m;\n\n    pTwistIcosahedron(p, twistCenter, 5.5);\n\n\treturn fInflatedIcosahedron(p, axis);\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--------------------------------\n// Modelling\n//--------------------------------\nModel map( vec3 p ){\n    return model(p);\n}\n\n// LIGHTING\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n\n    // lighitng        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    //float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    //float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    //lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n\n    return col;\n}\n\nstruct Hit {\n    float len;\n    vec3 colour;\n    float id;\n};\n\nHit calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n        if( abs(h) < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = m.dist;\n        t += h;\n        id = m.id;\n        colour = m.colour;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return Hit( res , colour , id );\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n\n    float x = mouse.x;\n    float y = mouse.y;\n    \n    x = .65;\n    y = .44;\n    \n    float dist = 3.3;\n    float height = 0.;\n    camPos = vec3(0,0,-dist);\n    vec3 axisY = vec3(0,1,0);\n    vec3 axisX = vec3(1,0,0);\n    mat3 m = rotationMatrix(axisY, -x * PI * 2.);\n    axisX *= m;\n    camPos *= m;\n    m = rotationMatrix(axisX, -(y -.5) * PI*2.);\n    camPos *= m;\n    camPos.y += height;\n    camTar = -camPos + vec3(.0001);\n    camTar.y += height;\n    camRoll = 0.;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nvec2 ffragCoord;\n\nvec3 render( Hit hit , vec3 ro , vec3 rd ){\n\n    vec3 pos = ro + rd * hit.len;\n\n    vec3 color = vec3(.04,.045,.05);\n    color = vec3(.35, .5, .65);\n    vec3 colorB = vec3(.8, .8, .9);\n    \n    vec2 pp = (-iResolution.xy + 2.0*ffragCoord.xy)/iResolution.y;\n    \n    color = mix(colorB, color, length(pp)/1.5);\n\n\n    if (hit.id == 1.){\n        vec3 norm = calcNormal( pos );\n        vec3 ref = reflect(rd, norm);\n        color = doLighting(hit.colour, pos, norm, ref, rd);\n    }\n\n  return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initIcosahedron();\n    t = iTime - .25;\n    //t = mod(t, 4.);\n    \n    ffragCoord = fragCoord;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n\n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    Hit hit = calcIntersection( camPos , rd  );\n\n\n    vec3 color = render( hit , camPos , rd );\n\tcolor = linearToScreen(color);\n    \n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}