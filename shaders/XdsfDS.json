{
    "Shader": {
        "info": {
            "date": "1498046840",
            "description": "ray v plane/billboard testing",
            "flags": 0,
            "hasliked": 0,
            "id": "XdsfDS",
            "likes": 1,
            "name": "ray v plane/billboard testing",
            "published": 3,
            "tags": [
                "ray",
                "testing",
                "plane",
                "billboard",
                "v"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 842
        },
        "renderpass": [
            {
                "code": "\n#define MAX_DISTANCE 1e5\n#define PI 3.14\n\n//returns distance to triangle or MAX_DISTANCE if triangle wasn't hit and outputs uv\nfloat rayTriangle(vec3 rayPos, vec3 rayDir, vec3 p1, vec3 p2, vec3 p3, out vec2 uv) {\n    const float EPSILON = 1e-5;\n    vec3 edge1 = p2-p1,\n        edge2 = p3-p1,\n        pdir = cross(rayDir,edge2);\n    float a = dot(edge1,pdir);\n    if (a > -EPSILON && a < EPSILON) return MAX_DISTANCE;\n    \n    float f = 1./a;\n    vec3 s = rayPos-p1;\n    float u = f*dot(s,pdir);\n    if (u < 0. || u > 1.) return MAX_DISTANCE;\n    \n    s = cross(s,edge1);\n    float v = f*dot(rayDir,s);\n    if (v < 0. || u+v > 1.) return MAX_DISTANCE;\n    \n    float dst = f*dot(edge2,s);\n    if (dst < EPSILON) dst = MAX_DISTANCE;\n    \n    uv = vec2(u,v);\n    return dst;\n}\n\n//returns distance to plane or MAX_DISTANCE if plane wasn't hit and outputs uv\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeDir, vec3 planeRight, vec3 planeUp, vec2 planeSize, out vec2 uv) {\n    float dst = dot(planePos-rayPos, planeDir)/dot(rayDir,planeDir);\n    \n    if (dst < 0.) {\n        dst = MAX_DISTANCE;\n    } else {\n        vec3 hp = (rayPos+rayDir*dst)-planePos;\n        uv = vec2(dot(hp,planeRight),dot(hp,planeUp))/planeSize*0.5+0.5;\n        if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) dst = MAX_DISTANCE;\n    }\n\n\treturn dst;\n}\n\n//return distance to billboard or MAX_DISTANCE if billboard wasn't hit and outputs uv\nfloat rayBillboard(vec3 rayPos, vec3 rayDir, vec3 billboardPos, vec2 billboardSize, out vec2 uv) {\n    vec3 dvec = billboardPos-rayPos;\n    float dst = dot(dvec, rayDir);\n    \n    if (dst < 0.) {\n        dst = MAX_DISTANCE;\n    } else {\n    \t//uv through reprojection\n\t\tvec2 screenUv = (rayPos+rayDir*dst).xy,\n             screenPos = billboardPos.xy;\n\n        uv = screenUv;\n        uv = (screenUv-screenPos)/(billboardSize/length(dvec))*.5+.5;\n        if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) dst = MAX_DISTANCE;\n    }\n        \n    return dst;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n   \tvec3 rp = vec3(0.,0.,-30.),\n         rd = normalize(vec3((u*2.-iResolution.xy)/iResolution.x, 1.));\n    \n    vec2 planeUv, billboardUv;\n    vec3 planeDir = vec3(sin(iTime), 0., cos(iTime));\n    float dst = rayPlane(rp, rd, vec3(0.), \n                              planeDir, \n                              vec3(sin(iTime+PI*.5),0.,cos(iTime+PI*.5)), \n                              vec3(0.,1.,0.),\n                              vec2(1.,8.), planeUv);  \n\n\tfloat bdst = rayBillboard(rp, rd, planeDir*15., vec2(20.,10.), billboardUv);\n    if (bdst < dst) {\n        planeUv = billboardUv;\n        dst = bdst;\n    }\n    \n    \n    if (dst < MAX_DISTANCE) {\n    \to = vec4(planeUv, 0., 1.);\n    } else {\n        o = vec4(0.);   \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}