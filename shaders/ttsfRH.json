{
    "Shader": {
        "info": {
            "date": "1596090375",
            "description": "Took a break and decided to do another Beeple Shadertoy cover :D!\nThis one actually raymarches/raycasts against a triangular height field.\nReference: https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/e4bb9677562593.5c8adf0c5fd1d.jpg",
            "flags": 32,
            "hasliked": 0,
            "id": "ttsfRH",
            "likes": 12,
            "name": "BEEPLE COVER: WORKSPACE",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "raycast",
                "heightfield",
                "triangle",
                "raytrace",
                "beeple",
                "workspace"
            ],
            "usePreview": 0,
            "username": "toomuchvoltage",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   Got kinda tired, so decided to do another Beeple Shadertoy cover :D!\n   Reference: https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/e4bb9677562593.5c8adf0c5fd1d.jpg\n   All value noise is modified iq noise from : https://www.shadertoy.com/view/lsf3WH\n   FXAA is the FXAAv2 that's commonly passed around, Shadertoy'd by Dave_Hoskins: https://www.shadertoy.com/view/4dfGDj\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define FXAA_SPAN_MAX\t8.0\n#define FXAA_REDUCE_MUL 1.0/8.0\n#define FXAA_REDUCE_MIN 1.0/128.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 add = vec2(1.0) / iResolution.xy;\n\t\t\t\n\tvec3 rgbNW = texture(iChannel0, uv+vec2(-add.x, -add.y)).rgb;\n\tvec3 rgbNE = texture(iChannel0, uv+vec2( add.x, -add.y)).rgb;\n\tvec3 rgbSW = texture(iChannel0, uv+vec2(-add.x,  add.y)).rgb;\n\tvec3 rgbSE = texture(iChannel0, uv+vec2( add.x,  add.y)).rgb;\n\tvec3 rgbM  = texture(iChannel0, uv).rgb;\n\t\n\tvec3 luma\t = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\t\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\n\t\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\t\t  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\t\t  dir * rcpDirMin)) * add;\n\n\t\t\n\tvec3 rgbA = (1.0/2.0) * (texture(iChannel0, uv + dir * (1.0/3.0 - 0.5)).rgb +\n\t\t\t\t\t\t\t texture(iChannel0, uv + dir * (2.0/2.0 - 0.5)).rgb);\n\t\n\tvec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) *\n\t\t(texture(iChannel0, uv.xy + dir * (0.0/3.0 - 0.5)).rgb +\n\t\t texture(iChannel0, uv.xy + dir * (3.0/3.0 - 0.5)).rgb);\n\t\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))\n\t{\n\t\tfragColor.xyz=rgbA;\n\t}else\n\t{\n\t\tfragColor.xyz=rgbB;\n\t}\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/***********************************************************\n\n   Got kinda tired, so decided to do another Beeple Shadertoy cover :D!\n   Reference: https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/e4bb9677562593.5c8adf0c5fd1d.jpg\n   All value noise is modified iq noise from : https://www.shadertoy.com/view/lsf3WH\n   FXAA is the FXAAv2 that's commonly passed around, Shadertoy'd by Dave_Hoskins: https://www.shadertoy.com/view/4dfGDj\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\nfloat hash3(vec3 p)\n{\n    p = ceil (p);\n    p = 50.0*fract( p*0.3183099 + vec3(0.71,0.113, -0.57231));\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 cubeMapStars(vec3 dir)\n{\n    vec3 skyVal = vec3 (0.0);\n    dir = normalize (dir);\n    float noiseEval = hash3 (dir * 300.0);\n    if ( noiseEval > 0.99 ) skyVal += vec3 ((noiseEval - 0.99) * 100.0);\n    return skyVal;\n}\n\nvec3 cubeMap(vec3 dir)\n{\n    vec3 skyVal = vec3 (0.0);\n    dir = normalize (dir);\n    float noiseEval = hash3 (dir * 300.0);\n    if ( noiseEval > 0.99 ) skyVal += vec3 ((noiseEval - 0.99) * 100.0);\n    vec3 skyBlueValues = vec3 (0.0);\n    if ( dir.y < 0.0 ) skyBlueValues += vec3 (0.529, 0.808, 0.922) * min (abs (dir.y) * 6.0, 1.0);\n    vec3 skyRedValues = vec3 (0.0, 0.0, 0.65) * (1.0 - clamp (abs (dir.y - 0.5) * 5.0, 0.0, 1.0));\n    skyRedValues += vec3 (0.75, 0.0, 0.0) * (1.0 - clamp (abs (dir.y + 0.1), 0.0, 1.0));\n    skyRedValues += vec3 (0.25, 0.0, 0.0) * (1.0 - clamp (abs (dir.y - 0.25) * 3.0, 0.0, 1.0));\n    skyRedValues += vec3 (1.0, 0.0, 1.0) * (1.0 - clamp (abs (dir.y + 0.4), 0.0, 1.0));\n    return skyVal + mix (skyRedValues, skyBlueValues, clamp (-dir.y * 2.0, 0.0, 1.0));\n}\n\n\nfloat hash(vec2 p)\n{\n    p = ceil (p);\n    float heightFac = min (abs(p.x) * 0.005, 6.0);\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) ) * heightFac;\n}\n\nbool lineSegTri(vec3 orig, vec3 dir, vec3 p1, vec3 p2, vec3 p3, inout float curK)\n{\n\tvec3 e1, e2;\n\tvec3 P, Q, T;\n\tfloat det, inv_det, u, v;\n\tfloat t;\n\te1 = p2 - p1;\n\te2 = p3 - p1;\n\tP = cross(dir, e2);\n\tdet = dot(e1, P);\n\tif (det > -0.0001 && det < 0.0001) return false;\n\tinv_det = 1.0 / det;\n\tT = orig - p1;\n\tu = dot(T, P) * inv_det;\n\tif (u < 0.0 || u > 1.0) return false;\n\tQ = cross(T, e1);\n\tv = dot(dir, Q) * inv_det;\n\tif (v < 0.0 || (u + v) > 1.0) return false;\n\tt = dot(e2, Q) * inv_det;\n\tif (t > 0.0 && t < curK)\n\t{\n\t\tcurK = t;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec3 barycentricCoords(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 v0 = b - a, v1 = c - a, v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float invDenom = 1.0 / (d00 * d11 - d01 * d01);\n    float v = (d11 * d20 - d01 * d21) * invDenom;\n    float w = (d00 * d21 - d01 * d20) * invDenom;\n    float u = 1.0 - v - w;\n\treturn vec3 (u,v,w);\n}\n\nbool lineWater (vec3 rayStart, vec3 rayDir, inout float outK)\n{\n    float D = -0.5;\n    if ( rayDir.y >= 0.0 ) return false;\n    float curK = (- (D + rayStart.y)) / (rayDir.y);\n    if ( curK < 0.0 || curK > 1.0 ) return false;\n    outK = curK;\n    return true;\n}\n\nbool linePortalPlane (vec3 rayStart, vec3 rayDir, vec3 quadCent, inout float outK)\n{\n    float D = -quadCent.z;\n    if ( rayDir.z >= 0.0 ) return false;\n    float curK = (- (D + rayStart.z)) / (rayDir.z);\n    if ( curK < 0.0 || curK > 1.0 ) return false;\n    outK = curK;\n    return true;\n}\n\nbool intersectBox(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, inout float finalK, inout vec3 norm)\n{\n    bool retVal = false;\n    vec3 maxODiff = boxMax - rayOrigin;\n    vec3 minODiff = boxMin - rayOrigin;\n    vec3 invDir = vec3 (1.0) / rayDir;\n    if ( rayDir.x != 0.0 )\n    {\n        float k1 = maxODiff.x * invDir.x;\n        float k2 = minODiff.x * invDir.x;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.yz, boxMin.yz, boxMax.yz) == hitPt.yz )\n            {\n                norm = vec3 (-1.0, 0.0, 0.0);\n\t\t        finalK = k1;\n                retVal = true;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.yz, boxMin.yz, boxMax.yz) == hitPt.yz )\n            {\n                norm = vec3 (1.0, 0.0, 0.0);\n\t\t        finalK = k2;\n                retVal = true;\n            }\n        }\n    }\n    if ( rayDir.y != 0.0 )\n    {\n        float k1 = maxODiff.y * invDir.y;\n        float k2 = minODiff.y * invDir.y;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.xz, boxMin.xz, boxMax.xz) == hitPt.xz )\n            {\n                norm = vec3 (0.0, -1.0, 0.0);\n\t\t        finalK = k1;\n                retVal = true;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.xz, boxMin.xz, boxMax.xz) == hitPt.xz )\n            {\n                norm = vec3 (0.0, 1.0, 0.0);\n\t\t        finalK = k2;\n                retVal = true;\n            }\n        }\n    }\n    if ( rayDir.z != 0.0 )\n    {\n        float k1 = maxODiff.z * invDir.z;\n        float k2 = minODiff.z * invDir.z;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.xy, boxMin.xy, boxMax.xy) == hitPt.xy )\n            {\n                norm = vec3 (0.0, 0.0, -1.0);\n\t\t        finalK = k1;\n                retVal = true;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.xy, boxMin.xy, boxMax.xy) == hitPt.xy )\n            {\n                norm = vec3 (0.0, 0.0, 1.0);\n\t\t        finalK = k2;\n                retVal = true;\n            }\n        }\n    }\n    return retVal;\n}\n\nbool lineSegLandscape (vec3 orig, vec3 dir, vec3 eyeLoc, inout float outK, inout float material, inout vec3 outN)\n{\n    vec3 triP1, triP2, triP3;\n   \n    float curK = 1.0;\n    vec3 l1 = orig;\n    vec3 l2 = orig + dir;\n    \n    eyeLoc += vec3 (0.0, 0.0, -5.0);\n    vec3 frameAABBMax = eyeLoc + vec3 (1.0, 1.8, 0.1);\n    vec3 frameAABBMin = eyeLoc - vec3 (1.0, 1.8, 0.1);\n    \n    vec3 lMin = min (l1, l2);\n    vec3 lMax = max (l1, l2);\n    \n    if ( lineWater (orig, dir, curK) )\n    {\n        outN = vec3 (0.0, 1.0, 0.0);\n        material = 2.0;\n    }\n    \n    if ( any(lessThan(frameAABBMin, lMax)) || any(greaterThan(frameAABBMax, lMin)) )\n    {\n        float saveCurK = curK;\n        if ( linePortalPlane(orig, dir, eyeLoc, saveCurK) )\n        {\n            vec3 hitPt = orig + curK * dir;\n            if ( hitPt.x > -1.1 && hitPt.x < 1.1 && hitPt.y > 0.0 && hitPt.y < 6.2 )\n            {\n                material = 4.0;\n                curK = saveCurK;\n                outN = vec3 (0.0, 0.0, 1.0);\n            }\n        }\n        eyeLoc += vec3 (1.0, 0.0, 0.0);\n        if ( intersectBox (orig, dir, eyeLoc - vec3 (0.1, 5.0, 0.1), eyeLoc + vec3 (0.1, 5.0, 0.1), curK, outN) ) material = 3.0;\n        eyeLoc -= vec3 (2.0, 0.0, 0.0);\n        if ( intersectBox (orig, dir, eyeLoc - vec3 (0.1, 5.0, 0.1), eyeLoc + vec3 (0.1, 5.0, 0.1), curK, outN) ) material = 3.0;\n        eyeLoc += vec3 (1.0, 4.9, 0.0);\n        if ( intersectBox (orig, dir, eyeLoc - vec3 (1.0, 0.1, 0.1), eyeLoc + vec3 (1.0, 0.1, 0.1), curK, outN) ) material = 3.0;\n        eyeLoc += vec3 (0.0, -5.6, 0.0);\n        if ( intersectBox (orig, dir, eyeLoc - vec3 (1.0, 0.1, 0.1), eyeLoc + vec3 (1.0, 0.1, 0.1), curK, outN) ) material = 3.0;\n        if ( material == 3.0 ) return true;\n    }\n\n    int minX = int (floor (min(l1.x, l2.x)));\n    int maxX = int (floor (max(l1.x, l2.x)) + 1.0);\n    int minZ = int (floor (min(l1.z, l2.z)));\n    int maxZ = int (floor (max(l1.z, l2.z)) + 1.0);\n\n    for (int i = minX; i != maxX; i++)\n\t    for (int j = minZ; j != maxZ; j++)\n        {\n            triP1 = vec3 (float(i), hash(vec2(float(i), float(j)) * 100.0), float(j));\n            triP2 = vec3 (float(i + 1), hash(vec2(float(i + 1), float(j)) * 100.0), float(j));\n            triP3 = vec3 (float(i), hash(vec2(float(i), float(j + 1)) * 100.0), float(j + 1));\n            \n            if ( lineSegTri (orig, dir, triP1, triP2, triP3, curK) )\n\t\t\t{\n                vec3 baryCoords = barycentricCoords (orig + curK * dir, triP1, triP2, triP3);\n                outN = normalize (cross (triP1 - triP2, triP3 - triP2));\n                if ( outN.y < 0.0 ) outN = -outN;\n                if ( baryCoords.x < 0.04 || baryCoords.y < 0.04 || baryCoords.z < 0.04 )\n                    material = 1.0;\n                else\n                    material = 0.0;\n            }\n\n            triP1 = vec3 (float(i + 1), hash(vec2(float(i + 1), float(j)) * 100.0), float(j));\n            triP2 = vec3 (float(i + 1), hash(vec2(float(i + 1), float(j + 1)) * 100.0), float(j + 1));\n            triP3 = vec3 (float(i), hash(vec2(float(i), float(j + 1)) * 100.0), float(j + 1));\n            \n\t\t\tif ( lineSegTri (orig, dir, triP1, triP2, triP3, curK) )\n            {\n                vec3 baryCoords = barycentricCoords (orig + curK * dir, triP1, triP2, triP3);\n                outN = normalize (cross (triP1 - triP2, triP3 - triP2));\n                if ( outN.y < 0.0 ) outN = -outN;\n                if ( baryCoords.x < 0.04 || baryCoords.y < 0.04 || baryCoords.z < 0.04 )\n                    material = 1.0;\n                else\n                    material = 0.0;\n            }\n\t\t}\n    outK = curK;\n   \tif ( curK < 1.0 ) return true;\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    vec3 eyeLoc = vec3 (0.0, 1.25, -iTime * 10.0);\n    vec3 lookDir = normalize (vec3 (0.0, 0.0, -1.0) + vec3 (sin(iTime), cos(iTime), 0.0) * 0.25);\n    vec3 upDir = vec3 (0.0, 1.0, 0.0);\n    vec3 sideDir = normalize (cross (lookDir, upDir));\n    upDir = cross (lookDir, sideDir);\n    if ( upDir.y < 0.0 ) upDir = -upDir;\n    \n    vec3 rayDir = normalize (lookDir + upDir * uv.y + sideDir * uv.x);\n    \n    vec3 rayStart = eyeLoc;\n    \n    float curK = 1.0;\n    float material = 0.0;\n    vec3 hitN = vec3 (0.0, 1.0, 0.0);\n    vec3 modColor = vec3 (1.0);\n    \n    for (int i = 0; i != 25; i++)\n    {\n        if ( lineSegLandscape (rayStart, rayDir, eyeLoc, curK, material, hitN) )\n        {\n            if ( material == 4.0 )\n            {\n                rayDir.y -= 0.4;\n                break;\n            }\n            else if ( material == 3.0 )\n            {\n                rayDir = reflect (rayDir, hitN);\n                modColor = texture (iChannel0, rayDir.xz + rayDir.y).rgb;\n                break;\n            }\n            else if ( material == 2.0 )\n            {\n                rayStart = rayStart + curK * rayDir;\n                rayDir = reflect (rayDir, vec3(0.0, 1.0, 0.0));\n                modColor = texture (iChannel0, rayStart.xz * 0.1).rgb;\n                rayDir = normalize (rayDir + (modColor - vec3 (0.5)) * 0.2);\n                continue;\n            }\n            else\n            {\n                if ( material == 1.0 )\n                    fragColor = vec4 (0.45, 0.83, 0.97, 1.0);\n                else\n                    fragColor = vec4 (cubeMapStars (reflect (rayDir,hitN)), 1.0);\n                fragColor.rgb *= modColor;\n                return;\n            }\n        }\n        rayStart += rayDir;\n    }\n\n    fragColor = vec4 (cubeMap (rayDir), 1.0);\n\tfragColor.rgb *= modColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}