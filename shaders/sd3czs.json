{
    "Shader": {
        "info": {
            "date": "1653943198",
            "description": "The first one doesn't load for some reason - click reset or wait 4 seconds\n\nHere's a messier but maybe nicer looking version:\nhttps://www.shadertoy.com/view/7scczf",
            "flags": 32,
            "hasliked": 0,
            "id": "sd3czs",
            "likes": 16,
            "name": "Pixel Staff Generator 2",
            "published": 3,
            "tags": [
                "feedback",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 655
        },
        "renderpass": [
            {
                "code": "#define pi 3.14159\n\nvec3 pal(float t, vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\n// Notes:\n// This is a bit ad hoc, will do colors properly later\n\n// Detailing = gold bits where col.r == 1. in buffer A\n// Interior = brown bits where col.r == 0. in buffer A\n// Outline = outline\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Zoom + coords + flipped coords etc.\n    float zm = 0.225; \n    vec2 res = 0.5 * floor( iResolution.xy);    \n    vec2 f = fragCoord;\n    vec2 f2 = vec2(abs(f.x - res.x) + res.x, f.y);\n    \n    vec4 col = texelFetch( iChannel0, ivec2(zm * f2 + (1.-zm) * res), 0);\n\n    \n    // Hide green\n    col.g *= col.r;\n    \n    // Only show blue above threshold\n    col.b *= step(thb, col.b);\n\n    // Is col == 0? Used for background\n    float s = step(col.r + col.g + col.b, 0.);\n         \n    // Set outline color (gets changed)\n    if (col.a == 1.)\n        col.rgb = vec3(0.1);\n    \n    // Darken left interior + detailing\n    if (f.x < res.x && col.a == 0. && col.rgb != vec3(1))\n        col *= 0.625;\n    \n    // Remove blues on the detailing\n    if (col.r > 0.)\n        col.b = 0.;\n    // Replace interior with another color\n    else if (col.rgb != vec3(1))\n        col.rgb = 0.44 * vec3(1,1,0.5) * col.bbb;\n    \n    // Add a red-ish color to detailing + outline\n    col.rgb += 1.5 * col.r * pal(0.45, 0.5 * vec3(0,1,2)/3.);\n    \n    // Lighten interior + outline\n    col.rgb += (1.-col.r) * vec3(0.15,0.075,0.15);\n    \n    // White background \n    col.rgb = mix(col.rgb, vec3(0.98), s * (1.-col.a));\n    \n    // Lighten right outline\n    if (f.x > res.x && col.a == 1.)\n        col.rgb /= 0.625;\n\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Dimensions of staff (change me)\n#define w 16.\n#define h 36.\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    col = vec4(0);\n\n    ivec2 px = ivec2(f);\n    int fr = int(2. * max(w, h));\n    int maxFr = fr + 240;\n    int frame = iFrame % maxFr;\n    \n    // \"random\" value from texture, used for green \"texture\"\n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel1, g, 0).r;\n    \n    vec2 res = floor(0.5 * iResolution.xy);\n    \n    // Centre abs coords, used for checking dimensions etc.\n    vec2 v = abs(f - res - 0.5);\n    \n    if (frame == 0) {   \n        col.a = 0.;\n        \n        // Pole for reds to traverse from\n        if (v.x < 1. && v.y <= h)\n            col.r = 1.;\n        \n        // Pixel for greens to expand from\n        if (v.x < 1. && v.y < 1.)\n            col.g = 1.;\n            \n        return;\n    }\n           \n    // Center cell\n    col = cell(px);\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 sum = b + t + l + r + bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n\n    // Traversal threshold [0,1], lower value -> more pixels\n    float th = 0.5;\n    \n    if (frame < fr) {\n        // Clamp to bounds\n        if (v.x > w || v.y > h)\n            col.g = 0.;\n        // Expand greens\n        else if (col.g == 0. && rand >= th && abs(sum.g-1.) <= 0.5)\n            col.g = (rand - th) / (1.-th);\n        // I don't think this does much\n        else if (abs(dif.g - sum.g) < 0.5) \n            col.g = 0.;\n            \n        // Traverse greens with red\n        if (sum.r > 0. && col.g > 0.55)\n            col.r = 1.;\n    }\n    else {  \n        if (frame == fr) {\n            // Can do this here, or in Image\n            col.g *= col.r;\n             \n            // Outline the blues in alpha channel\n            // Alpha pushes back against the blues when blues expand\n            if (step(thb, col.b) == 0. && step(thb, t.b) + step(thb, r.b) + step(thb, l.b) + step(thb, b.b) > 0.)\n                col.a = 1.;\n            else\n                col.a = 0.;\n        }\n        else if (frame == fr + 100) {\n            // Shift everything to remove red bar + make thinner\n            col = r; //mix(col, r, 0.75);\n            \n            // Guarantee a pole so it doesn't disconnect\n            if (v.x < 1. && v.y < h && col.b < th)\n                col.b = 1.;\n            \n            // Remove isolated reds (not perfect)\n            if (col.r == 1. && col.g == 0.) // or col.r = 0.;\n                col.g = 1.;\n        }\n        else if (frame == fr + 100 + 1) { \n            // Make an outline for col.a:\n            // col.a = 0. everywhere\n            // col.a = 1. where col.b < threshold and blue neighbours > thr\n            col.a = 0.;\n            \n            float s = step(thb, t.b) + step(thb, b.b) + step(thb, l.b) + step(thb, r.b);\n            if (col.b < thb && s > 0.)\n                col.a = 1.;\n        }      \n    }  \n    \n    \n    // Expand outwards from reds so blue channel can provide outline\n    \n    // Original idea was: \n    // -> expand blues from reds\n    // -> set some alpha values to 1 at fr + N \n    // -> alphas expand inwards from that \"outline\"\n    // -> remove alphas from blues, \"pressure\" from alpha and blue expansions\n    //    makes blue > thb where the staff outline will be\n    \n    // Currently: \n    // alpha \"outline\" happens at fr, still pushes inwards and mostly works\n    // idk\n    \n    if (frame < fr + 100) {\n        if (sum.r > 0.)\n            col.b = sum.r / 8.;\n        else\n           col.b = 0. * sum.b / 8.;    \n               \n        if (col.a < 1. && col.r < 1.)\n            col.a = sum.a / 8.;\n                \n        col.b -= col.a;   \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Blue threshold. Used for expanding away from shape and choosing a \"distance\"\n// to draw a boundary at <- allegedly\n#define thb 0.08\n\n// Buffer A:\n// Greens expand into a texture\n// Reds traverse that texture to provide detailing (yellow parts)\n// Blues expand away from the reds to provide a mask sort of thing\n// Alphas provide an outline based on the blue mask\n\n// Image:\n// Recolors stuff from buffer A\n\n\n\n\n// Todo:\n// Use more colors\n// Maybe split fragCoord into a grid, draw many at the same time\n// Remove spiky outlines\n// Shade from bottom to top\n// Lighten bits which touch the outline from below\n// Remove dark inner colors which touch the outline\n// Cut a bit out for a handle?\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}