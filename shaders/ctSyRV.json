{
    "Shader": {
        "info": {
            "date": "1691974509",
            "description": "Fork of \"Simple flame shader\" with some tweeks to center flame and enhance darker parts of flame.  Also removed most bad coding habits from code (0.0 for floats not 0. or .0 and delimit all code blocks with {}, when practical multiply rather than divide)",
            "flags": 0,
            "hasliked": 0,
            "id": "ctSyRV",
            "likes": 8,
            "name": "Fork Pixel Flame",
            "published": 3,
            "tags": [
                "voronoi",
                "flame",
                "perlin",
                "pixelart"
            ],
            "usePreview": 0,
            "username": "Blindman67",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "#define TIME_RATE 1.25\n#define PIXEL_SIZE 8.0\n#define PIXEL_RES iResolution.y / PIXEL_SIZE\n/* CHAOS float must be > 0.0. Larger values have more chaotic flame, smaller creates more regular flame */\n#define CHAOS 0.8\n/* From dark to light */\n#define FLAME_COL_1 vec3(0.769, 0.153, 0.153)\n#define FLAME_COL_2 vec3(0.886, 0.345, 0.133)\n#define FLAME_COL_3 vec3(0.914, 0.475, 0.102)\n#define FLAME_COL_4 vec3(0.945, 0.604, 0.067)\n#define FLAME_COL_5 vec3(0.973, 0.729, 0.035)\n#define FLAME_COL_6 vec3(1.0,   0.85,   0.4)  \n/* Flame noise thresholds */\n#define FLAME_THRES_1 0.000001 \n#define FLAME_THRES_2 0.01\n#define FLAME_THRES_3 0.3\n#define FLAME_THRES_4 0.6\n#define FLAME_THRES_5 0.8\n#define FLAME_THRES_6 0.95\n\n\nfloat Step(float a, float threshold) { return (a < threshold) ? 0.0 : 1.0; }\nvec4 MixAlpha(vec4 a, vec4 b) { return mix(a, b, b.a); }\nfloat Noise21(vec2 uv) {\n    const int w = 64;\n    const int s = 32;\n    int a = int(uv.x);\n    int b = int(uv.y);\n    a *= 3284157443; \n    b ^= a << s | a >> w - s;\n    b *= 1911520717; \n    a ^= b << s | b >> w - s;\n    a *= 2048419325;\n    float rand = float(a) * (3.14159265 / float(~(~0u >> 1)));\n    return cos(rand) * 0.5 + 0.5;\n}\nvec2 Noise22(vec2 uv) {\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\nfloat SmoothNoise(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    float tl = Noise21(id + vec2(0, 1)); \n    float bl = Noise21(id);              \n    float tr = Noise21(id + vec2(1, 1)); \n    float br = Noise21(id + vec2(1, 0)); \n    float t = mix(tl, tr, lv.x); \n    float b = mix(bl, br, lv.x); \n    return mix(b, t, lv.y);\n}\nfloat LayerNoise(vec2 uv) {\n    float result = 0.0;\n    float delta = 0.0;\n    float freq = 10.0; \n    float amp = 1.0;  \n    for (float i = 0.0; i < 4.0; i++) {\n        result += SmoothNoise(uv * freq) * amp;\n        delta += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return result / delta;\n}\nfloat VoronoiNoise(vec2 uv, float t) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv) - 0.5;\n    float minDist = 100.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            vec2 offs = vec2(x, y);\n            vec2 n = Noise22(id + offs);\n            vec2 p = offs + sin(n * t) * 0.5;\n            float d = length(lv - p);\n            minDist = min(minDist, d);\n        }\n    }\n    return smoothstep(0.0, 1.0, minDist);\n}\nvec4 FlameLayer(vec2 uv, vec3 col, float threshold) {\n    float t = iTime * TIME_RATE;\n    float fromCenter = abs(uv.x);\n    uv.y = 1.0 - pow(1.0 - uv.y, 1.1 + sin(iTime * (pow(fromCenter, 4.0) * 0.00325)));\n    float layerNoise = LayerNoise(uv + vec2(0.25, -0.5) * t);\n    float voronoiNoise = VoronoiNoise(uv * 3.0 + vec2(0.0, -0.25) * t, t);\n    float res = layerNoise;\n    res *= mix(res, voronoiNoise, 0.7);\n    res = pow(res, 0.8);\n    res *= pow(1.0 - fromCenter, 5.0);\n    res = smoothstep(res, 0.0, uv.y);\n    res = Step(res, threshold);\n    return vec4(col, res);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv.y += 0.5; \n    uv -= mod(uv, 1.0 / vec2(PIXEL_RES));    \n    vec4 col;\n    col =       MixAlpha(vec4(0), FlameLayer(uv, FLAME_COL_1, FLAME_THRES_1));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_2, FLAME_THRES_2));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_3, FLAME_THRES_3));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_4, FLAME_THRES_4));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_5, FLAME_THRES_5));\n    fragColor = MixAlpha(col,     FlameLayer(uv, FLAME_COL_6, FLAME_THRES_6));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}