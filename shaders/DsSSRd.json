{
    "Shader": {
        "info": {
            "date": "1680940578",
            "description": "A falling sand cellular automata example which uses an improved cyclic Margolus neighborhood to remove bias.\n\nArrow keys to move camera\nPlus (+) / Minus (-) to zoom in/out",
            "flags": 48,
            "hasliked": 0,
            "id": "DsSSRd",
            "likes": 12,
            "name": "Falling Sand CA v2",
            "published": 3,
            "tags": [
                "automata",
                "falling",
                "cellular",
                "sand",
                "margolus"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 445
        },
        "renderpass": [
            {
                "code": "// Fork of \"Falling Sand CA\" by gelami. https://shadertoy.com/view/DsjSzc\n// 2022-12-10 15:20:43\n\n// Falling Sand CA v2 by gelami\n// https://www.shadertoy.com/view/DsSSRd\n\n/*\n * A falling sand cellular automata example which uses an improved cyclic\n * Margolus neighborhood to remove bias.\n * Also has the rules randomly applied to create more interesting behaviors.\n * The simulation is then run 4 times in Buffer A-D for a 4x faster speed.\n * Plus some shading and shadows for the look\n * \n * Arrow keys to move camera\n * Plus (+) / Minus (-) to zoom in/out\n *\n * This is one of 4 shaders that explores falling sand cellular automata in the GPU\n * \n * Previous entry:\n * Falling Sand CA v1 - gelami\n * https://www.shadertoy.com/view/DsjSzc\n * \n * Next entry:\n * Falling Sand CA Ultimate - gelami\n * https://www.shadertoy.com/view/msBSWK\n *\n */\n\nfloat scale;\nvec2 getCoordsAA(vec2 uv)\n{\n    float w = 1.0; // 1.5\n    vec2 fl = floor(uv + 0.5);\n    vec2 fr = fract(uv + 0.5);\n    vec2 aa = fwidth(uv) * w * 0.5;\n    fr = smoothstep(0.5 - aa, 0.5 + aa, fr);\n    \n    return fl + fr - 0.5;\n}\n\nvec4 sampleTexAA(sampler2D ch, vec2 uv, vec2 res)\n{\n    return texture(ch, getCoordsAA(uv) / res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+4);\n    vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n    scale = scene.x;\n    vec2 center = scene.zw;\n    \n    fragCoord -= RES * 0.5;\n    fragCoord /= scale;\n    fragCoord += center;\n\n    vec4 h = sampleTexAA(iChannel0, fragCoord, RES);\n\n    vec4 r = sampleTexAA(iChannel1, mod(fragCoord, vec2(256)), vec2(256));\n    \n    vec3 bg = vec3(26, 29, 33) / 255.0;\n    \n    #ifndef CHEESE\n    vec3 col = vec3(225, 177, 89) / 255.0;\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x + (r.z - 0.5) * 5.0 / 255.0;\n    hsl.y = hsl.y + (r.x - 0.5) * 20.0 / 255.0;\n    hsl.z = hsl.z + (r.y - 0.5) * 40.0 / 255.0;\n    \n    #else\n    \n    vec3 col = vec3(0.957,0.714,0.184);\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x - r.y * 3.0 / 255.0;\n    hsl.y = hsl.y + r.z * 0.4;\n    hsl.z = mix(hsl.z, 0.9, pow(r.z, 6.0));\n    #endif\n    \n    vec2 n = vec2(0);\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            if (x == 0 && y == 0)\n                continue;\n            float b = sampleTexAA(iChannel0, fragCoord + vec2(x, y), RES).x;\n            \n            n += vec2(x, y) * (1.0 - b) * (abs(x) + abs(y) < 2 ? 1.0 : sqrt(2.0) / 2.0);\n        }\n    }\n    \n    n = normalize(n);\n    \n    col = HSLtoRGB(hsl);\n    \n    col *= 0.9 + 0.1 * r.w;\n    \n    vec2 ldir = normalize(vec2(0, 1));\n    \n    //float dif = max(dot(n, ldir), 0.0);\n    //float sha = max(dot(n, -ldir), 0.0);\n    float dif = 1.0 - sampleTexAA(iChannel0, fragCoord + vec2(0, 1), RES).x;\n    float sha = 1.0 - sampleTexAA(iChannel0, fragCoord - vec2(0, 1), RES).x;\n    \n    vec2 fr = fract(fragCoord);\n    float t = fract(getCoordsAA(fragCoord).y);\n    \n    float ao = 0.0;\n    #define DIST 16\n    for (int i = 1; i <= DIST; i++)\n    {\n       ao += sampleTexAA(iChannel0, fragCoord + ldir * float(i), RES).x;\n    }\n    //if (ao > 0.0)\n    //    ao += 1.0 - mix(fr.y, fr.y - 1.0, t);\n    ao /= float(DIST);\n    ao = min(ao, 1.0);\n    ao = sqrt(ao);\n    \n    col *= 0.2 + 0.8 * min(1.0 - ao, 1.0 - sha * 0.5);\n    col += col * 0.2 * dif;\n    \n    col = mix(bg, col, h.x);\n    \n    vec4 r2 = hash4(state);\n    \n    //col = vec3(ao);\n    \n    //col = vec3(h.x * HSLtoRGB(r2.xyz));\n    \n    // Output to screen\n    fragColor = vec4(col, 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define BUFFER_OFFSET 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    // Keyboard functions\n    if (p == IRES-1)\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(SCALE, 0, ZOOM_POINT);\n            return;\n        }\n        \n        const int KEY_LEFT  = 37;\n        const int KEY_UP    = 38;\n        const int KEY_RIGHT = 39;\n        const int KEY_DOWN  = 40;\n\n        const int KEY_PLUS = 187;\n        const int KEY_MINUS = 189;\n        \n        vec4 prev = texelFetch(iChannel0, p, 0);\n    \n        float up = texelFetch(iChannel3, ivec2(KEY_UP, 0), 0).r;\n        float down = texelFetch(iChannel3, ivec2(KEY_DOWN, 0), 0).r;\n        float left = texelFetch(iChannel3, ivec2(KEY_LEFT, 0), 0).r;\n        float right = texelFetch(iChannel3, ivec2(KEY_RIGHT, 0), 0).r;\n    \n        float zoomin = texelFetch(iChannel3, ivec2(KEY_PLUS, 0), 0).r;\n        float zoomout = texelFetch(iChannel3, ivec2(KEY_MINUS, 0), 0).r;\n    \n        vec2 speed = vec2(15.0 / prev.x);\n        float zoom = 0.08;\n        \n        if (zoomin > 0.0)\n            prev.x += zoom;\n        if (zoomout > 0.0)\n            prev.x -= zoom;\n        \n        prev.x = max(prev.x, 1.0);\n    \n        prev.w += up * speed.y;\n        prev.w -= down * speed.y;\n        prev.z -= left * speed.x;\n        prev.z += right * speed.x;\n        \n        prev.zw = clamp(prev.zw, RES * 0.5 / prev.x, RES - RES * 0.5 / prev.x);\n        \n        fragColor = prev;\n        return;\n    }\n    \n    if (iFrame < 2)\n    {\n        if (fragCoord.y == 0.5)\n        {\n            fragColor = vec4(1, 15, fragCoord);\n            return;\n        }\n        \n        bool v = sampleTex1(p % 256).x < 0.05;\n        fragColor = vec4(v, 0, fragCoord);\n        return;\n    }\n\n    // Mouse interaction\n    if (iMouse.z > 0.0)\n    {\n        vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n        float scale = scene.x;\n        vec2 center = scene.zw;\n\n        vec2 m = (iMouse.xy - RES * 0.5) / scale + center;\n        float d = length(fragCoord - m);\n        \n        bool v = sampleTex1((ivec2(fragCoord) + ivec2(313, 713) * iFrame) % 256).x < 0.2;\n        if (d < MOUSE_RADIUS && v)\n        {\n            fragColor = vec4(1, 0, fragCoord);\n            return;\n        }\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define SCALE 4.0\n\n#define MOUSE_RADIUS 8.0\n\n//#define CHEESE\n\n#define ZOOM_POINT vec2(RES * 0.5 / SCALE)\n\n#define EPSILON 1e-4\n\n#define RES iResolution.xy\n#define IRES ivec2(iResolution.xy)\n\n#define sampleTex0(p) texelFetch(iChannel0, ivec2(p) % IRES, 0)\n#define sampleTex1(p) texelFetch(iChannel1, ivec2(p), 0)\n\nvec4 sampleCells(sampler2D ch, ivec2 p, ivec2 res)\n{\n    if (p.y < 0)\n        return vec4(1, 15, 0, 0);\n\n    //if (p.x < 0 || p.x >= res.x || p.y >= res.y)\n    //    return vec4(0);\n    \n    if (p.x >= res.x-1 && p.y >= res.y-1)\n        return vec4(0);\n    \n    p = clamp(p, ivec2(0), res-1);  \n    \n    vec4 tex = texelFetch(ch, ivec2(p), 0);\n    \n    return tex;\n}\n\nivec2 getMargolusOffset(int frame)\n{\n#if 0\n    frame = frame % 2;\n    if (frame == 1)\n        return ivec2(1, 1);\n    return ivec2(0, 0);\n#else\n    frame = frame % 4;\n\n    if (frame == 1)\n        return ivec2(1, 1);\n    else if (frame == 2)\n       return ivec2(0, 1);\n    else if (frame == 3)\n        return ivec2(1, 0);\n    return ivec2(0, 0);\n#endif\n}\n\nint cellToID(vec4 p)\n{\n    return int(dot(p, vec4(1, 2, 4, 8)));\n}\n\nvec4 IDToCell(int id)\n{\n    return vec4(id%2, (id/2)%2, (id/4)%2, (id/8)%2);\n}\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec4 hash4i(inout uint y)\n{\n    uvec4 x = y * uvec4(213u, 2131u, 21313u, 213132u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 simulate(sampler2D ch, ivec2 p, ivec2 res, int frame, int bof)\n{\n    // Cyclic update order fixes 2 high ledge not updating\n    ivec2 of = getMargolusOffset(frame + bof);\n        \n    p += of;\n    \n    ivec2 fp = (p / 2) * 2;\n    \n    ivec2 fr = p & 1;\n    \n    int x = fr.x + (fr.y) * 2;\n    \n    fp -= of;\n    p -= of;\n    \n    vec4 t00 = sampleCells(ch, fp + ivec2(0, 0), res);\n    vec4 t10 = sampleCells(ch, fp + ivec2(1, 0), res);\n    vec4 t01 = sampleCells(ch, fp + ivec2(0, 1), res);\n    vec4 t11 = sampleCells(ch, fp + ivec2(1, 1), res);\n    \n    int id = cellToID(vec4(t00.x, t10.x, t01.x, t11.x));\n    \n    const int rules[16] = int[](\n    \n        // http://www.mirekw.com/ca/rullex_marg.html\n        // Note: Values assume Y Down\n        // Sand (Y up)\n        0, 1, 2, 3, 1, 3, 3, 7, 2, 3, 3, 11, 3, 7, 11, 15\n        \n    );\n    \n    const int sideToSide[16] = int[](\n        // Move side to side\n        0, 2, 1, 3, 8, 5, 6, 7, 4, 10, 9, 11, 12, 13, 14, 15\n    );\n    \n    \n    int r = rules[id];\n    \n    ivec2 o = ivec2(fr.x, fr.y);\n    \n    vec4 v = hash43(uvec3(fp, frame));\n    \n    if (v.y < 0.4)\n        r = id;\n    \n    int b = int(sampleCells(ch, ivec2(fp) - ivec2(0, 2), res).y);\n    \n    if (v.x < 0.2 && b < 4)\n    {\n        r = sideToSide[r];\n    }\n    \n    vec4 d = sampleCells(ch, fp + o, res);\n    \n    vec4 cell = IDToCell(r);\n    \n    return vec4(cell[x], id, d.zw);\n}\n\n// https://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n  \nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + EPSILON);\n    return vec3(HCV.x, S, HCV.z);\n}\n\nvec3 RGBtoHSL(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define BUFFER_OFFSET 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+1);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define BUFFER_OFFSET 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+2);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define BUFFER_OFFSET 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+3);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}