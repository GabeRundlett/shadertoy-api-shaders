{
    "Shader": {
        "info": {
            "date": "1578915345",
            "description": "a monolite. still incomplete, I'd like to improve sky and add light reflections, but I haven't figured out how yet.\nthe ground is smth I came up on my own, mix of clamped fbm and a sine wave, generating more variationsl.\ncomments are welcome.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlGGWh",
            "likes": 5,
            "name": "dali",
            "published": 3,
            "tags": [
                "raymarch",
                "ground",
                "fractures"
            ],
            "usePreview": 0,
            "username": "omis",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "#define AA 1\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm5( vec3 p )\n{\n\t//p += vec3(1.0,1.0,0.8);\n    float f;\n    f  = 0.5000*noise( p); p = p*2.04;\n    f += 0.2500*noise( p); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    //f += 0.0625*noise( p ); p = p*2.02;\n    //f += 0.03125*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\n\nvec2 map(in vec3 p)\n{   \n    // monolite\n    vec3 pm = p; pm.z-=75.0; pm.y+=0.2;\n    pm.z+=iTime;\n    \n    pm.yz *= rot(-2.4)*noise(pm*0.15);\n    //pm.xz+=noise(pm);\n    pm.x = mod(pm.x, 5.0)-2.5;\n    pm.z = mod(pm.z, 10.0)-5.0;\n    \n    vec2 res = vec2(sdCube((pm), vec3(0.25, 5.0+noise(pm*0.1), 0.15)*2.0), 0.1);\n    \n    // monolite fractures\n    // inspired by iq's https://www.shadertoy.com/view/3lsSzf\n    float yy = p.y-0.62+0.45+noise(p*14.0)*1.0*p.x*p.x;\n    res.x += 0.01*(1.0-smoothstep(0.0,0.02,abs(yy)));\n    yy = p.y+0.65-0.95-noise(p*7.0)*3.0*p.x*p.x;\n    res.x += 0.01*(1.0-smoothstep(0.0,0.0015,abs(yy)));\n    yy = p.y-0.15+1.45-noise(p*7.0)*3.0*p.x*p.x;\n    res.x += 0.01*(1.0-smoothstep(0.0,0.0015,abs(yy)));\n    \n    // ground\n    float n = fbm5(p);\n    float h = mix(clamp(n, 0.0, 0.5), sin(p.x*0.2), n);\n    h+=clamp(n, 0.0, 0.5);\n    float m = p.y-1.5+h*1.51;\n    res = smin(res, vec2(m, 2.0), 2.0);\n    return res;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd)\n{\n    float tmin = 0.0001;\n    float tmax = 120.0;\n\tfloat t = tmin;\n    vec2 res = vec2(0, -1);\n    \n    for (int i = 0; i < 100 && t < tmax; i++)\n    {\n    \tvec2 d = map(ro + rd * t);\n        if (d.x < 0.0001*t){\n        \tres = vec2(t, d.y);\n            break;\n        }\n\n        t+=d.x;\n    }\n    if(t>120.0) res = vec2(-1);\n    return res;\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(0.5 - p.y);\n    p.x+=iTime*2.0;\n\td -= 1.1*fbm5( p*0.45 );\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\n\nvec3 lig = vec3(-1.1, 0.5, -1.5);\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, out float rays, ivec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\trays = 0.0;\n    \n\t//float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.1;//*texelFetch( iChannel0, px&ivec2(255), 0 ).x;\n\tfor(int i=0; i<80; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = pos.y;\n\t\tfloat c = noise( (pos + lig*h)*0.35 );\n\t\trays += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n        //col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;//max(0.1,0.05*t);\n\t}\n    rays = clamp( rays, 0.0, 1.0 );\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nconst float maxHei = 0.8;\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n\n}\n\nvec3 calcCloudsNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*mapClouds( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*mapClouds( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*mapClouds( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*mapClouds( pos + e.xxx ).x );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// lighting from iq - https://www.shadertoy.com/view/Xds3zN\nvec3 render(vec3 ro, vec3 rd, vec2 fragCoord)\n{\n    vec2 t = raymarch(ro, rd);\n    vec3 p = ro+rd*t.x;\n    vec3 col = vec3(0.0);\n    vec3 nor = calcNormal(p);\n\tvec3 cnor = calcNormal(p);\n    \n    if (t.y < 0.0) {\n    \tcol = vec3(0.01);\n        return col;\n    }\n    \n    // monolite\n    if (t.y == 0.1) {\n        //col = vec3(.001);\n        //return col;\n    }\n\n    float tx = t.x*nor.z;\n    col = nor*clamp(tx, -.5, 1.5);\n    col = 0.7 + 0.5*col;\n    \n    // sun reflections\n    col += vec3(1.0,0.5,0.2)*0.35*pow( nor.x, 3.0 );\n\t\n    // fog\n  \tcol = mix( col, vec3(0.0), 1.0-exp( -0.0001*t.x*t.x*t.x) );\n    //col = mix(col, vec3(0.5, 1.1, 0.7), t.x*0.00015);\n    \n    // clouds\t\n    float rays = 0.0;\n    vec3 bcol = vec3(1.0);\n    \n    {\n\tif( t.x<0.0 ) t.x=100.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t.x, rays, ivec2(fragCoord) );\n\tcol = mix(col, 0.5-col*(1.0-res.w) + res.xyz * (vec3(0.9)), res.w*0.81);\n\t}\n\n\t//col = clamp( col, 0.0, 1.0 );\n    \n\t//col = sqrt(col);\n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\t\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = -1.5;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0, 5.0, 10.0+iTime*0.25);\n    vec3 ta = vec3(-9.0, 10.0, 0);\n    \n    ro.x = sin(iTime*0.01);\n    //ta.x = cos(iTime*0.1);\n    \n    vec3 tot = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n    \tvec3 rd = getCameraRayDir(p, ro, ta);   \n    \tvec3 col = render(ro, rd, fragCoord);\n        tot+=col;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// sdf \n\nfloat sdCube(in vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// domain\n\nfloat rep(float x, float d)\n{\n\treturn mod(x, d) - d/2.0;\n}\nmat2 rot(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}