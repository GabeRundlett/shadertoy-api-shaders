{
    "Shader": {
        "info": {
            "date": "1471698331",
            "description": "making epsilon variable, and using maxDist and maxSteps as training pool, allows for longer distances.\nThe extra performance on close surfaces is used to recursive reflections with shadows in reflections.\n\ngoto\nhttps://www.shadertoy.com/view/4lscW2",
            "flags": 0,
            "hasliked": 0,
            "id": "4td3Dj",
            "likes": 11,
            "name": "recursive reflections epsilon 1",
            "published": 3,
            "tags": [
                "reflection",
                "shadow",
                "horizon",
                "dynamiceps"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1519
        },
        "renderpass": [
            {
                "code": "//do do:\n//replace this initially dumb and lazy quadratic dynamicEps \n//  with the much better [mod_dynamiceps]\n\n//maybe replace the FishEyeCam with an orthogonal cam. fisheyecam is more an intentional stress-test than good looks.\n//maybe do some seeded scattering on calculating a reflection.\n//maybe add any texturing to this bland method-demo.\n//could need more parameters to the shadow function to make it look better close up than afar\n\n\n//not sure why, but shadertoy makes the color depth in reflections within reflections look a lot lower than other boilerplates.\n//this is likely a precision issue, unlikely a conversion error.\n//precision highp float;\n//nope that didnt do it!\n\n//line 55 \"epsmod1\"... sets performance the most \n//the MAX_ limit range definitions only set upper bounds.\n//that are reached exponentially, so their size barely matters.\n//\n//MAX_SHADOW_REFLECTIONS sets how many reflections will have shadows calculated for them\n#define MAX_SHADOW_REFLECTIONS 2.0\n//with 2.0, a reflection in a reflection has shadows in it. usually enough.\n//\n///MAX_DIST can easily be 1000000. but may crash in higher resolutions\n#define MAX_DIST          100000.\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n#define MAX_STEPS         100000.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n#define MAX_HARD  500\n//this is the absolute upper limit of steps per ray, including all its reflections.\n//the hardlimit is only reached in extreme cases, \n//like when the camera POSITION is already close to a surface!\n//\n//by ollj\n//goal is to allow for high render distance and high detail close to the camera\n//goal is to allow for hall of mirror reflections for as long as there are steps left, scatterable non-fake reflections.\n//goal is to see the shadow in the reflection of a revflection of a reflection...\n//goal is to have any fragment converge in the same linear time\n//closer surfaces simply get more detail/reflections.\n//\n//RECURSIVE REFLECTION;\n//if a ray hits a reflective wall, \n//it keeps raymarching a bounched ray.\n//the loop sums up a total color as sum of all reflected rays.\n//a reflected ray makes up a smaller fraction of the total color.\n//if that fraction is too small, it does not reflect.\n//in the end the last reflected fraction of a color is added, that is \"sky\" or \"ground\" color if we run out of steps.\n//\n//LONG RENDER DISTANCE;\n//Achieved by defining MAX_DIST and MAX_STEPS as non-static float pools\n//that diminish with each raymarchng step,\n//many small steps drain them differently than doing many large steps!\n//if any pool drains below 0, the raymarching ends before MAX_HARD loops are cycled.\n//\n//additionaly, epsilon increases each raymarching step (see \"epsmod1\" definition)\n//\n//all this causes raymarching to converge more linearily\n//for many very different fragments of very different scenes\n//while it also \"warps space\" towards the ray, the more steps have been taken.\n//surfaces close to the camera have low epsilon, high precision, lots of reflections.\n//surfaces far from the camera have less precision, less reflections\n//surfaces/hallways coplanar to a ray no longer have the problem of \"running out oof steps\".\n\n#define epsmod1 eps=mad(nextDistance,.0001,eps*1.005);\n//#define epsmod1 eps=nextDistance*.0001+eps*1.005;\n//epsilon increases exponentially, set by step distances.\n//above functions ballances performance/quality the most\n//as it sets a converging cubic-function for many different cases.\n//It makes raymarching more convergent by increasing epsilon and\n//different scenes have different ideal settings for it.\n//like the differences of indoor to outdoor scenes.\n//in general smaller constants cause beter quality and lower fps.\n//\n#define epsmod2 maxSteps -=eps*nextDistance;\n//maxSteps dains slower on short step distances.\n//this makes maxDist the limit for many short steps.\n#define epsmod3 maxDist  -=eps/nextDistance;\n//maxdist drains slower on long step distances.\n//this makes maxSteps the limit for many large steps.\n//\n//maxDist drains accumulative-inversed in comparison to maxSteps's accumulative drain.\n//but sooner or later these 2 converge towards each other!\n//i am sure this can be improved a lot. but benchmarking this on different scenes takes time.\n//and i lack the theoretical undertanding to model many cases to an optimum.\n\n#define PI acos(-1.)  \n#define PIB asin(1.)\n\n#define skyColor       vec3(.1,.5,1.)\n#define shadowColor    vec3(.1,.1,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(1.,.1,.8)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarchoing\n//too much for the average 2014 hardware in useful resolutions/framerates\n\nfloat CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}\nfloat sdHexPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*.866025+q.y*.5,q.y)-h.x);}\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ){\n    vec3 q = mod(point, repetition)-.5*repetition;return q;}\nfloat CubeRepetition(in vec3 point, in vec3 repetition ){\n  point.x+=sin(point.y*.11+time*5.);\n  point.z+=cos(point.y*.11);\n  vec3 q = mod(point,repetition)\n  -0.5*repetition;q.y = point.y;\n  return sdHexPrism(q.zxy,vec2(10.,50));\n  return CubeDistance2 ( q, vec3 (10., 50.+sin(time)*15.,10.));}\nfloat PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}\nfloat modA(float x){return mod(time*.1+x+55.,230.)-55.;}\nfloat fSphere       (vec3 p,float r){return length(p)-r;}\nfloat SphereDistance(vec3 point, vec3 center, float radius){\n  point.z = modA(point.z);point.x = modA(point.x);\n  return fSphere(point-center,radius);}\nfloat RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}\nfloat BuildingsDistance(in vec3 position){\n  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),\n\t         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}\nfloat GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}\n//merging distance functions above to distanceField function below:\nfloat df(in vec3 position, out int mtl){\n    float radial=length(vec2(position.x,position.z));\n\tfloat radialSine=sin(radial*.05-time*2.)*5.;\n    float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    return closest;}\n//end of sdf geometry;\n\n//iqs famous softshadow, set to low quality\nfloat SoftShadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){\n    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;\n    for(int s=0;s<20;++s){if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t ));\n        if( nextDist < 0.001 ){return 0.0;}\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;}return penumbraFactor;}\n\n//distance fog is no longer needed, is a relict here.\nvoid applyFog( in float distance, inout vec3 rgb ){\n    //float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    //vec3 fogColor = vec3(0.9,0.95,1);\n    //if(fogAmount<.6)rgb= vec3(1.,1.,0.);\n    //else rgb=clamp(rgb,0.,1.);\n    //rgb=mix(skyColor,rgb,fogAmount);\n}\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\nvec3 MaterialColor(int mtl){\n    if(mtl==      SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==   GROUND_MTL) return groundColor;\n    if(mtl==      RED_MTL) return redColor;\n    return vec3(1.0,1.0,1.0);}\nfloat AmbientOcclusion (vec3 p,vec3 n,float d,float s){float r=1.;int t;\n  for(int i=0;i<5;++i){if(--s<0.)break;r-=(s*d-(df(p+n*s*d,t)))/pow(2.,s);}return r;}\n \n//my reflection code only allows for coarse normal calculations with this function e=0.1 !\n//that means, smaller e will look bad, or not reflect at all. \n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal(vec3 pos, int material,float eps){int d;float e=.1;\n  return vec3(df(vec3(pos.x+e,pos.y  ,pos.z  ),d)-df(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y+e,pos.z  ),d)-df(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y  ,pos.z+e),d)-df(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n//main raymarching loop with maxDistance and MaxSteps and epsilon changed a bit.\n//if (hits a surface) reflect!\n//returns color of fragment.\nvec3 RayMarch(in vec3 position, in vec3 direction, out int mtl){\n  vec3 hitColor;\n  vec3 r;\n  float sg=1.;\n  float nextDistance= 1.;\n  float shadowReflections=MAX_SHADOW_REFLECTIONS;\n  float maxDist =MAX_DIST;\n  float maxSteps=MAX_STEPS;\n  int hardLimit =MAX_HARD;\n  float eps     =.01;\n  for(int ever=3;ever!=0;++ever){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlÃ¶imit in the loop-\n    nextDistance=df(position,mtl);\n\tposition+=direction*nextDistance;\n    if(nextDistance<eps){//if we hit a surface.\n      vec3 n=ComputeNormal(position,mtl,eps);n=normalize(n);\n      vec3 col=MaterialColor(mtl);\n\t  position+=n;\n      if(shadowReflections>0.0){//if we stil calculate shadows (for this reflection)\n\t\tvec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));\n        lightpos=lightpos-position;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);\n\t\tfloat shadow = SoftShadow(position, lightVector, 0.3, lightdist,shadowHardness);\n        if(mtl==BUILDINGS_MTL){col=mix(shadowColor,col,clamp(position.y/7.0,0.0,1.0));}\n\t\tfloat attenuation=clamp(dot(n,lightVector),0.0,1.0);\n\t\tshadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);\n        float AO=AmbientOcclusion(position,n, 1.0, 7.0);col=mix(shadowColor,col,AO);shadowReflections-=1.0;}\n      float refl=.45;//surface reflectiveness\n      if (mtl==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      r=mix(col,r,1.-sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return r;\n      direction=direction-(n*1.5*(dot(direction,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n    }hardLimit--;\n    epsmod1 \n    epsmod2 \n    epsmod3 \t\n    if(maxSteps<0.||maxDist<0.||hardLimit<0){\n\t  if (direction.y<0.)return mix(groundColor,r,1.-sg);\n                         return mix(skyColor   ,r,1.-sg);}}return vec3(3,3,3);}\n\nvoid FishEyeCamera( vec2 screenPos, float ratio, float fovy, out vec3 position, out vec3 direction ){\n    screenPos *= vec2(ratio,fovy);\n\tfloat height=cos(time/5.);\n    \n\tdirection=normalize(cross(vec3(screenPos,3.0),vec3(0,1,0)));\n    direction=vec3( sin(screenPos.y+PIB)*sin(screenPos.x)\n                  ,-cos(screenPos.y+PIB)-height*.5-.4+sin(time/20.)*0.2-0.1\n                  ,-sin(screenPos.y+PIB)*cos(screenPos.x));\n\tposition=vec3(sin(time/ 6.)*100.+20.+iMouse.x\n\t              ,height       *205.+206.+iMouse.y\n\t              ,sin(time/14.)*135.+cos(time/13.)*135.)+1.0;\n\tdirection=normalize(direction);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){float ratio=iResolution.x/iResolution.y;\n vec2 uv = fragCoord.xy/iResolution.xy*vec2(.5);\n vec3 d=vec3(1.,0.,0.);vec4 CamRotation;vec3 p;\n FishEyeCamera(uv,ratio,fovyCoefficient,p,d);\n int m;\n vec3 col=RayMarch(p,d,m);\n //vec3 col=vec3(0);\n fragColor=vec4(col,1.0);\n //if(m==SKY_MTL&&d.y<0.){m = GROUND_MTL;fragColor=vec4(1.,0.,0.,1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}