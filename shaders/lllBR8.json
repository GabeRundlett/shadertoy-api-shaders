{
    "Shader": {
        "info": {
            "date": "1511031317",
            "description": "new 3d car distance field texture in shaderoo.org. (here substituted by some dist field primitives)\nsee [url]https://www.shaderoo.org/?shader=oPd8FA[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "lllBR8",
            "likes": 24,
            "name": "3d voronoi car",
            "published": 3,
            "tags": [
                "3d",
                "voronoi"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 1516
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// 3d voronoi car\n\n// see https://www.shaderoo.org/?shader=oPd8FA\n// this is a test of the new shaderoo 3d-car-distance-field-texture.\n// (here substituted by some distance field primitives to work in shadetoy)\n\nvec3 getRand3d(vec3 pos)\n{\n    vec4 r1=texelFetch(iChannel1,(ivec2(pos.xy+.5)%ivec2(64)+ivec2(floor(pos.z+.5)*vec2(27,13))+1024)%ivec2(256),0);\n    return r1.xyz;\n}\n\nvec4 voronoiDist(in vec3 texc, float voronoiStrength, float voronoiScale)\n{\n    voronoiStrength=clamp(voronoiStrength,0.,2.);\n\n    vec3 p = texc*voronoiScale;\n    vec2 o;\n    vec3 g = floor(p);\n    p -= g;\n\n    vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    float mindist = 10.;\n    float mindist2 = 10.;\n    float mindist3 = 10.;\n    float mindist4 = 10.;\n    vec3 minPos=p;\n    vec3 minPos2=p;\n    vec3 minPos3=p;\n    vec3 minPos4=p;\n\n    int sampWidth=max(1,int(floor(voronoiStrength)));\n\n    vec3 pos0 = voronoiStrength*(getRand3d( g ));\n    for(int z = -sampWidth; z <= sampWidth; z++)\n    {\n        for(int y = -sampWidth; y <= sampWidth; y++)\n        {\n            for(int x = -sampWidth; x <= sampWidth; x++)\n            {\n                //vec3 hexOffs = 1.0*vec2(0.5,0.0)*(int(g.y+y)&1);\n                vec3 pos = vec3(x,y,z)+voronoiStrength*getRand3d( g + vec3(x,y,z) );\n                //vec2 pos = hexOffs + vec2(x,y)+voronoiStrength*(getVoronoiOffs((g+vec2(x,y))/voronoiScale/vec2(aspect,1.0))*(1.0-hexOffs));\n                float dist = dot(pos-p, pos-p);\n\n                if(dist<mindist)\n                {\n                    mindist=dist; minPos=pos;\n                }\n            }\n        }\n    }\n    vec3 minhdir=vec3(0.0);\n    float minhdist=0.0;\n    float sum=0.;\n    float softSize=0.05;\n    for(int z = -sampWidth; z <= sampWidth; z++)\n    {\n        for(int y = -sampWidth; y <= sampWidth; y++)\n        {\n            for(int x = -sampWidth; x <= sampWidth; x++)\n            {\n                vec3 pos = vec3(x,y,z)+voronoiStrength*getRand3d( g + vec3(x,y,z) );\n                if(dot(pos-minPos,pos-minPos) > 0.00001)\n                {\n                    float hdist=length(dot(p-(pos+minPos)*0.5,normalize(pos-minPos)))-0.1;\n                    minhdist += exp( -hdist/softSize );\n                }\n            }\n        }\n    }\n    minhdist=-log(minhdist)*softSize/*+0.07*/;\n\n    return vec4(minhdist/voronoiScale,normalize(minhdir));\n}\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp2(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp2(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n#define WheelRadius 0.45\n#define ObjBoundRadius 3.5\n\nfloat distCar(vec3 pos)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return length(pos)-ObjBoundRadius*0.5;\n    float dist = 100000.0;\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin2(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS((pos-WheelFR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelFL).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    return dist;\n}\n\n\nfloat maxcomp(vec3 v) { return max(max(v.x,v.y),v.z); }\nfloat mincomp(vec3 v) { return min(min(v.x,v.y),v.z); }\n\nvec2 mdist(vec3 pos)\n{\n    float m=1.;\n    vec3 tpos=clamp(pos,-.95,.95);\n    #ifdef SHADEROO\n    float d=texture(iChannel0,tpos*.5+.5).x;\n    #else\n    float d=distCar(tpos*2.5-vec3(0,0,-.3))/2.5;\n    #endif\n    //d+=maxcomp(abs(tpos-pos));\n    /*if (fract(iTime)>0.5)\n        d-=.005;\n    else*/\n        d=abs(d)-.005;\n        \n    d+=length(tpos-pos)*.5;\n    float dp=d;\n    d=max(d,voronoiDist(pos,.5,15.).x);\n    d=min(d,pos.z+.33);\n    if (d<dp) m=2.;\n    return vec2(d,m);\n}\n\nfloat dist(vec3 pos)\n{\n    return mdist(pos).x;\n}\n\n#define PI2 6.2832\n#define LNUM 5\n\nvec3 getGrad(vec3 p)\n{\n    float eps=.01;\n    vec3 d = vec3(eps,0,0);\n    return vec3(\n        dist(p+d.xyz)-dist(p-d.xyz),\n        dist(p+d.zxy)-dist(p-d.zxy),\n        dist(p+d.yzx)-dist(p-d.yzx)\n        )/eps;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec3 refl(vec3 dir)\n{\n    return mix(vec3(.2,.3,.4),vec3(.7,.85,1)*1.5,clamp(dir.z*3.+.5,0.,1.));\n\t//return texture(iChannel0,dir.yzx).zyx*1.2+.1;\n}\n\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float rval=0.0;\n    float R = 1.01;\n    float d0=length(pos);\n\n    // do some bounding check for better performance\n    bool inside = false;\n    // bounding sphere\n    vec3 pn = pos-dir*dot(pos,dir);\n    float d=length(pn);\n    inside = inside || (d<R);\n    inside=true;\n    if(!inside) return 0.0;\n    \n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n       \tfloat d=dist(pos);\n        if(d<eps) { rval=mdist(pos).y; break; }\n        if(d>d0+R) { rval=0.0; break; }\n        pos+=dir*d*1.;\n    }\n    return rval;\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel1,coord+.003*iTime);\n    c+=texture(iChannel1,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel1,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel1,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.33\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    vec3 colHor=vec3(.5,.55,.6);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*1.3,vec3(.8,.9,1)*1.3,clamp(7.*dir.z,0.,1.));\n    vec3 skyPos=pos+dir/abs(dir.z)*(20.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.001).x-.5));\n    colSky*=mix(1.,cloudPat,step(0.,dir.z));\n    vec3 colFloor=vec3(1.,.95,.9);\n    vec3 colScale=vec3(.0,.3,.5);\n    vec3 floorPos=pos-dir/dir.z*(pos.z-FloorZ);\n    vec2 s;\n    float scale=1.;\n    s=sin(floorPos.xy*PI2*.5*period);\n    scale*=(1.-.3*exp(-s.x*s.x/.01))*(1.-.3*exp(-s.y*s.y/.01));\n    s=sin(floorPos.xy*PI2*.5/10.*period);\n    scale*=(1.-.5*exp(-s.x*s.x/.001))*(1.-.5*exp(-s.y*s.y/.001));\n    colFloor=mix(colFloor,colScale,1.-scale)*(1.+.4*(getRand(floorPos.xy*.001).x-.5));\n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*6.)-.1,0.,1.));\n    return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec3 pos = vec3(0,0,2.5);\n    #ifdef SHADEROO\n \tpos *= 1.-iMouseData.z/1000.;\n    #endif\n \tvec3 dir = normalize(vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x,-1.));\n    vec2 ang=PI2*(iMouse.xy/iResolution.xy*vec2(-1,.3)-vec2(0,.02));\n    if(iMouse.x==0. && iMouse.y==0.) ang = vec2(1.+.3*iTime,1.4);\n    vec4 q = vec4(0,0,0,1);\n    q = multQuat(q,axAng2Quat(vec3(0,0,1),ang.x));\n    q = multQuat(q,axAng2Quat(vec3(1,0,0),ang.y));\n    pos=transformVecByQuat(pos,q);\n   \tdir=transformVecByQuat(dir,q);\n   \tvec3 camDir=transformVecByQuat(vec3(0,0,-1),q);\n   \tvec3 camPos=pos;\n    float m = march(pos,dir);\n    vec3 n = normalize(getGrad(pos));\n    \n    vec3 bg=mix(vec3(1),vec3(.3,.3,1),length(fragCoord.xy-.5*iResolution.xy)/iResolution.x);\n    \n    float fres=abs(dot(dir,n));\n    fres=1.-fres;\n    //fres*=fres;\n    fres=.7+.3*fres;\n    vec3 col=vec3(.75,.8,.85); // material color of car\n    if(int(m+.1)!=1) col=vec3(1);  // set to 1 if bg or floor\n    if(int(m+.1)==1) col*=1.-fres;\n    if(int(m+.1)==1) col+=.9*fres*myenv(pos,reflect(dir,n),10.).xyz;\n    col=.1+col*.9;\n    bg = refl(dir);\n    bg=myenv(pos,dir,10.).xyz;\n    // calc ao by stepping along normal\n    float ao=1.;\n    ao*=.2+.8*dist(pos+n.xyz*.12)/.12;\n    ao*=.4+.6*dist(pos+n.xyz*.25)/.25;\n    ao*=.6+.4*dist(pos+n.xyz*.5)/.5;\n    col*=clamp(ao*.7+.3,0.,1.);\n    \n    float vign = (1.1-.2*dot((fragCoord.xy/iResolution.xy)*2.-1.,(fragCoord.xy/iResolution.xy)*2.-1.));    \n    fragColor.xyz=col;\n    if(int(m+.1)!=1) fragColor.xyz*=bg;\n    fragColor.xyz*=vign;\n    pos=mix(pos,pos+dir*10000.,1.-m);\n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}