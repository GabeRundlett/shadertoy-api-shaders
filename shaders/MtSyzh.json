{
    "Shader": {
        "info": {
            "date": "1507348613",
            "description": "move with arrowsKey + mouse\n\nanother more weird distortion, movement is simple and euclidean.- vision is not. \na massive thing distorts vision in a not euclidean way.\nquaternion rotation still is intuitive though.",
            "flags": 49,
            "hasliked": 0,
            "id": "MtSyzh",
            "likes": 5,
            "name": "reciprocal black hole",
            "published": 3,
            "tags": [
                "blackhole",
                "vr",
                "hole",
                "black",
                "dynamiceps",
                "reciprocal",
                "edynvr"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 786
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA!\n//it needs a buffer for camera position and rotation.\n\n/*\n\nBuffA line 192 sets \"force\" oscillation of the blach holes mass.\nthis is likely the first thing you want to change.\n\n\n\nthe effect is also [generalized] as in\n, unlikely anything like real warped space.\n- \"time \"is unaffected\n- it is closer to adaptive-verlet-interpolation\n   than to analytic spacetime calculus.\n\nwhen you see the black hole as small circle, its masss oscilaltion is at its local minimum.\n this is a good moment to pause time and to accellerate.\ngetting closer to the black hole \n while it is less dense is more interestring topology!\n\n---\n\nif you see the blue half sphere, circle around it till it \"opens up\"\nthe \"opening timer\" sepends oon the position of the circling black hole.\ngetting closer to the black hole \nalso gets your vision into some \"stable orbitals\"\nwhere you can see multiple metaballs of the same single plane.\n\n-----\n\nyou are near something that distorts space\n, a very strong [generalized black hole] 100m aboge a planar floor.\n\nyour movement is unaffected by the black hole. \nit only distorts vision (bends light)\n but that is more than enough.\nMostly because All surfaces are reflective, yo your vamera ray \n eithr ends in the blue sky or on the event black horizon.\nthe mass of the black hole oscillates over time.\nthe black hole circles over a green plane at a constant height.\nthe red circles give you a guess about your height above ground.\n but with all the distortion, all is confusing.\n\nyour vision gets stuck in orbitals. often you only see the sky. \noften you only see the event horizon.\nsometimes you can see the same planar green floor\n as if it is warpped into spheres and toru multiple spheres\n 4d toruses or whatever. its hard to describe thsis black hole stuff.\nthere is a lot to discover here?\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//3d deformation black hole\n//self  : https://www.shadertoy.com/view/ltjyzR\n//parent: https://www.shadertoy.com/view/llc3R8\n\n\n#define zFar 1700.\n\n//raymarch iterations, dynamiceps has fast convergense, dont worry about high rvalues!\n#define iterRm 700\n//far clipping sphere\n\n\n//#define \n\n//[e*]=[epsilon] sets your heuristic precision.\n//Larger [e*] infrease framerate, make the world \"chubbier\".\n//Epsilon is split in 2; An inside or outside of..\n// eThreshold, Radius of sphere around camera,switches [epsilon modes];\n#define eThreshold 111.\n// eNear-mode (in eThreshold) for better nearby reflections.\n//  if (s<eNear){close enough}\n#define eNear .001\n// eFar-mode (out eThreshold)\n//  ,world gets log()aytmically more chubby by this factor.\n//  if (0.<log(t*t*eFar/s)){close enough}\n//  eNear mode has Better precision for reflections.\n#define eFar .000002\n//one factor is also he cameras distance to vec3(0)\n//, increasing precision loss where small e* get roundedtoo much\n//  eFar  mode has Better precision for long corridors and horizons\n\n//this begs the question\n// how a blakck hole distrts occludion in a SIMPLE model\n\n//black hole has reflections dimmed by *.5\n//, gives the black hole a visible shadow\n#define blackHoleDimReflections\n//Black hole mass is constant, only its .xz position changes.\n//a black hole having a reflection is unintuitive and fun\n//it distorts its own reflection?\n\n//inside of blaack hole is black.\n#define blackHoleIsInvisibleInside\n\n\n#define THRUST 0.2*iTimeDelta*scaleVR\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n\n//scene scaling for VR (poorly implemented concept placeholder)\n#define scaleVR 1.\n\n//camera collision sphere radius\n#define TOO_CLOSE .3\n//todo: TOO_CLOSE should internally scale with movement speed\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n//---lib.core:\n#define sat(a) clamp(a,.0,1.)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define PI acos(-1.)  \n#define PIB asin(1.)\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\n\n\n//----lib.hash for scatter-noise\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p){p=fract(p*HASHSCALE4.xyz)\n;p+=dot(p,p.yxz+19.19);return fract((p.xxy+p.yxx)*p.zyx);}\nfloat h12(in vec2 p){\n return fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n\n\n\n//---lib.buffer, originally from iq, modified\nfloat isInside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nvec4 load(int re){return texture(iChannel0,(.5+vec2(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in vec4 va, inout vec4 o, in vec2 u\n){if(isInside(u,vec2(re,0))>.0)o=va;}//o=(isInside(u,vec2(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);}\nfloat key(in int key){return texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x;}\n//---lib.quaterion\nvec4 qid(){return vec4(0,0,0,1);}\n//return q2, rotated by q1, order matters when unsigned(axes) are not identical.\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}//inverse quaternion\n//return p, rotated by q;\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n//return quaternion of vec3(pitch,yaw,roll) in that order:\n#define qpyrs(s,c,a) vec4(s.x*c.y,a*s.y*c.x,s.x*s.y,c.x*c.y)*c.z\nvec4 qpyr(vec3 o){o*=.5;vec3 s=sin(o),c=cos(o);return qpyrs(s,c,1.)+qpyrs(c,s,-1.);}\n//vec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\n//vec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\n//vec3 vmulq(vec3 p, vec4 q){return qmulq(qinv(q),qmulq(vec4(p,0.0),q)).xyz;}//inverse rotation\n/*\n//[quaternion spherical linear interpolation] between 2 quaterion rotations in 3d space.\nvec4 qslerp(vec4 a,vec4 b,float f)\n{float d=dot(a,b),theta=acos(abs(d)),ost=(1./sin(theta))\n;return normalize(a*sin(theta*(1.-f))*ost*sign(d)+b*sin(theta*f)*ost); }\n*/\n\n\n\n//struct FarLight{vec3 d;vec4 color;};        \nstruct PointLight{vec3 position;vec4 color;};\n\nvec3 repeat(vec3 v){return vec3(mod(v.x,6.)-3.,v.y,mod(v.z,10.));}\nfloat distFromPlane(vec3 p){\n;return dot(vec3(0,1,0), p)+1.5;}//normal,offset\n\n\n//accumulate color (infinite reflections with specular)\n//[r]reflective surface fraction (1=perfect mirror 0=100% matte)\n//[o]color Accumulator\n//[u]viewRayOrigin    (gets reflected by [n])\n//[d]viewRayDirection (gets reflected by [n])\n//[s]Farlight, parallel light source has angle and color (for specular) \n//[l]used-up percentage of matte-light (1.-[reflective surface fraction] adds to this)\n//[C]diffuse material color (often a constant)\n//[n]surface normal\nvoid accCol(float r,inout vec4 o,inout vec3 u,inout vec3 d,inout float l,vec3 s,vec4 C,vec3 n){\n//;vec3 u=v.o;\n//;vec3 d=v.d;\n;float a=dot(s,d)//angle\n;o+=pow(abs(a),180.)*.8;//specular (is very cheap within reflections)  \n    //doingthis within a modulo tesselation or any folded space looks bad though.\n;d=reflect(d,n)\n;u+=d\n;float mid=(1.-l)*r;\n;o.xyz=(o.xyz*l+C.xyz*mid)/(l+mid);\n;l+=mid;\n//v=Ray(u,d);\n}\n\n\nfloat sphere1(vec3 u){\n;vec3 s=vec3(0,0,8);//(vec3(0.0,cos(iTime),8.0+0.5*sin(iTime)))\n;return (length(repeat(u)-s)-1.5);\n}\n\n//The complete distance field is a min of all other distance fields.\n//Tther distance fields are seperated\n// to independently get other surface properties, this is a BVH  that resolves TextureID\nfloat gd(vec3 u, float t){\n//sphere is animated\n;vec3 s=(vec3(0.0,cos(iTime),8.0+0.5*sin(iTime)))\n;float distP=distFromPlane(u)\n;float distS=(length(repeat(u)-s)-1.5);\nreturn min(distP,distS);\n}\n\n\nbool eMode(float t,float s){\n if(t<eThreshold)return s<eNear;//better for short distance reflections\n return 0.<log(t*t*eFar/s);}//better for long distance\n/**/\n\n//problem here is that the set is 2 subsets.\n//no big issue, just rethinking conventions.\n\n//a raymarcher with infinite reflection,barelyNewtonian distortion, no AO\nvec4 MarchBlackHole(vec3 u,vec3 d){\n//;vec2 m=(iMouse.xy/iResolution.xy);\n;float l=0.;//[matte used], every reflection increases [matte used]\n;vec3 sun=normalize(vec3(sin(iTime),.4,cos(0.43*iTime)))\n;vec4 o=vec4(0,0,0,1)\n;float dLast=0.;//last distance to an object\n;float t=0.; //distance to camera\n//;vec3 hPos=vec3(5.*sin(.6*iTime),116,15.+5.*iTime+4.*cos(.2*iTime)) //position of black hole\n;vec3 hPos=vec3(5.*sin(.6*iTime),1,15.+5.*iTime+4.*cos(.2*iTime)) //position of black hole\n;const vec4 cPlane =vec4(.2,.4,.1,1);\n;const vec4 cSphere=vec4(.8,.1,.5,1);\n;float force,mdist;\n;for(int i=0;i<iterRm;++i\n){\n ;float distS=sphere1(u);\n ;float distP=distFromPlane(u)\n ;vec3 hPosd=(u-hPos)\n ;float mdist2=dot(hPosd,hPosd);mdist=sqrt(mdist2)\n //;force=22.*(.02+.5*((cos(0.1*iTime)+1.)))/mdist2 //mass of black hole\n //;force=22.*(.02+.5*((cos(0.1*iTime)+1.)))/mdist2 //mass of black hole\n ;force=cos(0.1*iTime)/mdist2\n #ifdef blackHoleDimReflections\n //;o*=smoothstep(-force,0.,.1*mdist*force);//black hole has a darker reflection \n #endif\n #ifdef blackHoleIsInvisibleInside\n ;if(mdist<force) return o;//if raymarched inside event horizon, break.\n #endif\n //distances to 2 shapes\n ;if(eMode(t,distS)\n ){accCol(.5,o,u,d,l,sun,cSphere,normalize(vec3(0,0,8)-repeat(u)));//explicit normal of sphere1()\n ;if(l>.99)break;}\n ;if(eMode(t,distP)\n ){accCol(.8,o,u,d,l,sun,cPlane,vec3(0,1,0));\n ;if(l>.99)break;}     \n ;dLast=min(min(distS,distP),mdist)\n ;t+=dLast\n ;if(mdist>zFar)break//enforce horizon for a blue sky line\n  #ifndef doBlackHole\n // ;d=normalize(d-dLast*force)//distortion by black hole\n ;d=normalize(d-dLast*force*(u-hPos))\n ;u+=d*dLast*.5 //u moves along the ray\n      \n //;d=normalize(d-dLast)//black hole bends ray (and shoortens ray)\n  #endif\n// ;u+=d*dLast//u moves along the ray\n;}\n;u+=d*force\n;o.xyz=(o.xyz*l+vec3(.2,.5,.9)*(1.-l));//remaining [l] becomes blue sky\n;float angle = dot(sun,d)\n//below reflects a modulo light on the floor that does not exist\n//still okay.\n//;o += pow((abs(angle)),180.)*.8;\n;return o\n;}\n\nvec4 mainImage2(out vec4 o, in vec2 u,vec3 A,vec3 D){\n;vec3 d=normalize(vec3((2.0*u-iResolution.xy)/iResolution.y,1.0))\n;vec3 l=load(0).xyz\n;vec4 fw=(load(1))//poaded camera position and camera rotation\n   \n//no, this part below doesnt make sense to me.\n//instead i just overwrite the VR-headset-position and -rotation\n//its simpler and more compatible with non-vr\n#ifdef doVr \n//t=qmulv(fw,A);\n#else\n;d=qmulv(fw,d);\n#endif\n//;d=normalize(d);//neglible difference\n//float s=h12(u);    \n;return MarchBlackHole(l,d)\n;return vec4(0);\n}\n\n\n//set camera position and rotation. (and meybe some derivatives over time of these?\n//this gts buffered in the lower left fragments.\n//these then get loaded by each fragment to render a camera view.\nvoid steer(out vec4 o,vec2 u){//asll colision detection is in this function!\n;vec4 p,q;if(iFrame<2){//initialize camera parameters\n ;p=vec4(1,0,0,.1);//.w=forward momentum.\n //thats pretty smart for compression, i used to store momentum seperately as vec3\n    //but for a plane this is good enough.\n q=(vec4(0,0,0,1));//optionally make q vec4(), storing a differential to null_Rot\n}else{p=load(0);q=load(1)//next frame//load state from previous frame\n ;vec3 fw=qmulv(q,vec3(0,0,1)) //this can be done simpler\n ,b=p.xyz+fw*p.w*.2;float t=1.;\n ;if(gd(b,t)>TOO_CLOSE)p.xyz=b;else //check each domain independently.\n     //this can be simplified with mstretch()==analstretching():\n {;vec3 ass=vec3(gd(vec3(b . x,p.yz ),t)\n                ,gd(vec3(p.x,b.y,p.z),t)\n                ,gd(vec3(p.xy , b.z ),t));\n p.xyz=mix(b.xyz,p.xyz,sign(vec3(TOO_CLOSE+1.)-ass));}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;float roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;vec2 m=vec2(0);if(iMouse.z>.0){//if(mous button down)\n  ;vec2 n=iMouse.xy-abs(iMouse.zw);n.x=-n.x;m.xy-=(n)/iResolution.xy;}\n #ifdef USE_AUTO_PILOT\n else{//I'm pretty sure this is how google cars steer\n  ;float d=gd(p.xyz)\n  ;b=qmulv(q,vec3(d,0,0))\n  ;float d2=gd(p.xyz+b)\n  ;m.x=sign(d2-d)*ROTATE/(.1+2.*d*d);}\n #endif\n ;vec4 qp=qpyr(vec3(m.yx*ROTATE,roll))\n ;q=normalize(qmulq(q,qp))//normalize before saving\n;};store(0,p,o,u);store(1,q,o,u);}//rotation//position,velocity\n\n//PiP Splitscreen, lower left pixels in veiw space buffer camera parameters for movement.\nvoid BufferSplit(out vec4 o,vec2 u,in vec3 A,in vec3 D){\n;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n;else o=mainImage2(o,u,A,D);}//this branch can be split in 2 frame buffers.\n//Shitty VR ignores [A]=HeadSetPosition and [D]=HeadSetLookingDirection\n// You can only move your view with keyboard and mouse.\n// Its up to you to inclide these vectors\n// Will not get much out of it, as shaderty VR support is not so good.\n// This is tricky and the pipelines are bad and this framework is bad.\nvoid mainVR(out vec4 o,in vec2 u,in vec3 a,in vec3 d){\n ;if(all(lessThan(u,vec2(2.5,1.5))))steer(o,u)\n ;else BufferSplit(o,u,a,d);}\n\n\n//mainImage() to mainVR() projection simulates VR:\n//[camPos]==offset of the VH headsed (in meters?)\n//[m.xy] sets Euler rotations of a VR headset with a mouse.\nvoid mainImage(out vec4 O,in vec2 U){\n const vec3 camPos=vec3(0);//camPos is a simple offset\n const float r=360./acos(-1.),d=acos(-1.)/180.;//360/pi ; pi/180\n vec2 m=u2(iMouse.xy/iResolution.xy); \n m=PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));\n vec2 fov=vec2(25.);fov.x=atan(tan(fov.y/r)*iResolution.x/iResolution.y)*r;\n mat3 c;\n c[0]=vec3(cos(m.x),0,sin(m.x));//camera.right\n m.x=m.x+PI*.5;\n c[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y));//cameraFwd\n //c[2]=-cross(c[0],c[1]));//camUp\n fov=(2.*U/iResolution.xy-1.)*sin(fov*d)/sin(PI*.5-fov*d);\n c[0]=camPos-c[1]+fov.x*c[0]-fov.y*cross(c[0],c[1]);\n c[1]=normalize(c[0]-camPos);\n // scene is accidentally backwards, ugh\n c[1]*=vec3(-1,1,-1);c[0]*=vec3(-1,1,-1);\n mainVR(O,U,c[0],c[1]);}//https://www.shadertoy.com/view/XlBGzm\n\nvoid mainImage2( out vec4 o, in vec2 u){\n;vec3 sun=(normalize(vec3(sin(iTime))))\n;u=u.xy/iResolution.y-vec2(.5)\n;u.x*=iResolution.x/iResolution.y;\n;vec3 r=vec3(0,3,5.*iTime)//rayOrigin\n;vec3 d=normalize(vec3(u,1))//ray direction\n;o=MarchBlackHole(r,d);\n;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}