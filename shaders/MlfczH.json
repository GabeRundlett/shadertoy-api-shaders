{
    "Shader": {
        "info": {
            "date": "1503408217",
            "description": "Mouse in:\n\nthe [optical circuit demo] video source code once appeared on glslsandbox.com\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\nit is fractal code golf overkill in [0..6] scenes.\nthis is a deconstruction of scene 1.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlfczH",
            "likes": 109,
            "name": "Optical deconstruction 1b",
            "published": 3,
            "tags": [
                "fractal",
                "optical",
                "glow",
                "kifs",
                "circuit",
                "0x4015"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 6128
        },
        "renderpass": [
            {
                "code": "//self 1: https://www.shadertoy.com/view/MlfczH\n//scene5: https://www.shadertoy.com/view/4tscR8\n//Optical-Circuit optical circuit scene 1 deconstruction b\n\n\n/*\n\niMouse.x changes the glowing (somewhat planar) lines\niMouse.y changes the density of the black fractal\n\nnot my code, just deconstructing it:\n\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\n\nThe [optical circuit demo] video source code once appeared on glslsandbox.com\n... with very nondesctiptic labels, \n... only using single letter names for functions and vars..\n\n\nIt is fractal code golf overkill in [0..6] scenes.\nThis is a deconstruction of scene 1. , not the whole demo.\nUn-used functions (only used in other scenes) are removed;\nscene-specific branches are set to 1, or removed \n... (multiplying by *0. or adding -0 iterations)\n... all changes are annotated.\n\nThis may run slightly faster due to removing all schene-specific branching\nMost of that modifies iteration count (between scenes, which are static per shader)\nThe [smart re-use of schene specific branches and modifiers] is what makes this a 4k demo.\n... at a cost of running slightly slower, by summing up scene-modifiers.\n*/\n\n//this loop with 20 iterations seems to have no change for scene1, but i may be wrong\n//my guess is camera pathing???\n//skips a lot of code, so it is disabled for performance.\n//#define doScene1Loop\n\n//move vehicles in traffic over time., is often barely noticable, may be skipped.\n#define MoveVehicles\n\n//number of itterations of the black fractal. \n//it is pretty space filling with some max(a,-b) for safe camera paths, \n//4 is a good compromise. +-2 look fine too.\n#define Oiter 4\n\n//number of iterations of the glowing lines fractal patterns\n//more iterations make the lines more planar-space-filling, brighter\n#define Giter 6\n\n//#define scene 1\n#define timeOffset 115.984024\n\n#define dd(a) dot(a,a)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\nfloat vsum(vec3 a){return dot(a,vec3(1));}//dot() is generally faster on a gpu than 2add()\n //return a.x+a.y+a.z;}\n\nconst float pi=acos(-1.);//3.14\nconst float t0=sqrt(.5);//0.707\n\n//non const floats are not good style, will create warnings on some parsers.\nfloat A,D,E;\nvec3 B,C;\n\n//return a, rotated by b, originally called F()\nvec3 rot(vec3 a,float b){float c=sin(b),d=cos(b);return mat3(d,-c,0,c,d,0,0,0, 1)*a;}\n\n//fractal glowing planes\nvec3 G(vec3 a, float b){a=fract(a*.2)*2.-1.;a.z=b;\n float m=iMouse.x/iResolution.x;\n //a-=iMouse.x/iResolution.x; //this fucks up the tesselation\n float c=50.;//brightness modifier\n for(int i=0;i<Giter;++i){//iteration cout is scene specific\n  float d=clamp(dd(a),.05,.65);\n  c*=d;\n  a=abs(a)/d-1.31+m;\n  a.xy=a.xy*mat2(1,1,-1,1)*t0-m;\n }return a*c;}\n\n/*\n#ifdef doScene1Loop\n//sub of X\nvec3 Z(float t){return vec3(0,-sin(t*.6),t*1.6+.5)+sin(t*.01*vec3(11, 23, 19))*vec3(.135,.25,.25);}\n//sub of Y a and t are always thr same, this looks like i can optimize it, a lot\nfloat X(vec3 a, float t, float b){float c=fract(t+b),e=t-c;\n vec3 f=Z(e)*vec3(0,1,1)+sin(vec3(0,23,37)*e),\n g=normalize(sin(vec3(0,17,23)*e))*8.,\n h=f+g+vec3(sin(e*53.)*.15,0,0),\n j=f-g+vec3(sin(e*73.)*.15,0,0),\n k=mix(h,j,c-.15),\n l=mix(h,j,c+.15);//i smell a lot of symmetry potential for optimization\n t=dot(a-k,l-k)/dd(l-k);//i smell distance to line segment\n return length((t<0.?k:t>1.?l:k+t*(l-k))-a);}//i smell a lot of BIsymmetry potential for optimization\n//sub of Y, internally modifies a, while Y keeps usig an unmodified a.\nvec3 I(vec3 a){a.z=a.z-A*1.5;float b=A*.5+floor(a.z);\n return rot(vec3(a.x,a.y+sin(b),fract(a.z)-.5),pi-cos(b));}\n//only used once in mainImage, within a loop that seems to have no visual effect for scene 1\n\nvec4 Y(vec3 a,float b,float t) {\n vec3 c=I(a)*20.,\n d=vec3(length(c+vec3(-.35,.57,2)),length(c+vec3(-.35,-.57, 2)),length(c+vec3(.7,0,2))),\n e=V(.2,d,b),\n f=vec3(X(a,t,0.),X(a,t,.3),X(a,t,.6)),g=V(.001,f,b);\n return vec4(\n  vsum(e)*vec3(30,75,150)*(E+1.)+vsum(g)*vec3(1.,.1,.2)*5000.\n  ,min(miv(d)*.05, miv(f)));}\n#endif\n*/\n\n//L M N O define thedark fractal shape, O is a fractal, L M N are a \"strange hash\"\n//L is sub of M and N\nfloat L(vec3 a){vec3 b=abs(fract(a + vec3(0,.5,0))-.5),c=abs(fract(a+.5)-.5);\n return .033-min(max(b.x-.46, b.y),.08-max(c.x, c.y));}\n//M is sub of N\nfloat M(vec3 a) {vec3 b=abs(fract(a*4.+.5)-.5)*.25;\n return max(max(max(b.x,b.y),b.z)-.08,max(L(a)-.01,.012-length(fract(a*25.)-.5)*.04));}\n//M is sub of O\nfloat N(vec3 a){\n return min(min(min(M(a),M(a.zyx)),M(a.zxy)),min(min(L(a),L(a.zyx)),L(a.zxy)));}\n//iterations of the black fractal\n//o is used once by T()\nfloat O(vec3 a){vec4 b=vec4((fract(a*.2+.5)-.5)*4.,1.);\n for(int i=0;i<Oiter;++i){\n  b.xyz = clamp(b.xyz,-1.,1.)*2.-b.xyz;\n  b*=clamp(max(.21/dd(b.xyz),.21),.0,1.)*-15.7;\n }a=b.xyz/b.w*5.;return max(length(a)-1.,N(a))*.25;}\n//used 5* in mainImage T is a very schene specific function; \n//return distance of [a] to a fractal.\nfloat T(vec3 a){\n float m=iMouse.y/iResolution.y;\n vec3 b=a*(20.);//for scene 1, b modifies placement of \"lines of vehicles\"\n #ifdef MoveVehicles\n  b.y+=A*5.*(fract(dot(floor(b),vec3(1,0,1))*pi)-.5);//animate lines of vehicles\n #endif\n vec3 c=rot((fract(b.zxy)-.5)*.05,A*8.*(fract(dot(floor(b),vec3(pi)))-.5)),//defines vehicles\n e=abs(fract(a+vec3(.5,.5,0))-.5);//defines vehicles\n a=rot(a,A*.025*(fract((a.z * 2.-fract(a.z*2.))*.437)-.5));//defines black fractal\n float d=mav(abs(fract(a*2.)-.5)*.5);//for scene1, K is 100% absorbed into T, here\n return min(//this line is the only line that includes \"O()\"\n  max(min(max(d+(m*.35-.12)-.201,O(a)),.299-d),length(a)-20.),\n  max(max(e.x,e.z)-.05,min(max(length(c)-.006,L(c*10.)*.1-.0002),.04)));}\n\n//V and W modify color accumulator of the last loop (mostly increasing brightness)\n//sub of W and I\nvec3 V(float a,vec3 b,float c){a*=c;return 1./((1.+2.*b/a+b*b/(a*a))*c+.0001);}\n//only used twice in mainImage, a and b and c are the same both times.\nvec3 W(vec3 a,float b,float c,float d){\n vec3 e=(V(.01,abs(a),d)*2.+V(.05,vec3(length(a.yz),length(a.zx),length(a.xy)),d)*5.)\n  *(sin(A*vec3(2.1,1.3,1.7)+b*10.)+1.);\n return(e*7.+e.yzx*1.5+e.zxy*1.5)*max(1.-c*200./d,0.)/d*float(100-30);}//is scene specific\n\n#define tswap h=j;j=k;k=l\n#define resolution iResolution\nvoid mainImage(out vec4 O, in vec2 Uuu){\n {//this  seems to have been an Initiation procedure, as it sets global vars.\n  A=iTime+timeOffset;\n  vec2 glVertex=Uuu.xy/iResolution.xy*2.-1.;\n  //a,b,d are very scene specific (and c depends on b)\n  vec3 a=normalize(sin(A*.001*vec3(21,11,17)))*20.1,\n  b=normalize(sin(A*.001*vec3(26,106,62))-a*.05),\n  c=normalize(cross(b,sin(A*.001*vec3(31,17,29))));\n  float d=A*float(1);\n  /*\n  #ifdef doScene1Loop\n  for(int i=0;i<20;++i){//i notice no changes when skipping this on scene1\n   float t=A-float(i)*.1;\n   vec4 y=Y(Z(t),25.,t);\n   //here an d+=... modifier is scene specific, is +=0. for scene1\n  }\n  #endif\n  */\n  //set globals:\n  vec3 e=normalize(vec3(sin(vec2(.53,.47)*d)*4.+sin(vec2(.91, 1.1) * d)*2.+sin(vec2(2.3,1.7)* d),200)),\n  f=normalize(cross(e,vec3(sin(d),50,0)));\n  B=a;\n  C=mat3(c,cross(c,b),b)*(f*glVertex.x*1.78+cross(f,e)*glVertex.y+e*1.4);\n  D=fract(sin(vsum(C)*99.317*pi)*85.081*pi);\n  E=fract(sin(A      *99.317*pi)*85.081*pi);\n }\n vec3 a=normalize(C),c=vec3(1),e=B,f= a,g=e,b=g*.0,s=vec3(1,-1,-1)*.0005;\n vec4 l=vec4(B,1),k=l*.0,j=k,h=j;\n int m=1;\n float t=0.,o=1.,p=1.,q=D*.01+.99,n;\n //raymarching loop:\n for(int i=0;i<64;++i){//iteration steps depend on z, but scene 1 has no summands here.\n  g=e+f*t;\n  float d=T(g);\n  if(d<(t*5.+1.)*.0001){\n   vec3 u=normalize(T(g+s)*s+T(g+s.yyx)*s.yyx+T(g+s.yxy)*s.yxy+T(g+s.xxx)*s.xxx);//normal\n   float r=pow(abs(1.-abs(dot(u,f))),5.)*.9+.1;\n   o+=t*p;\n   p=p*5./r;\n   e=g+u*.0001;\n   f=reflect(f, u);\n   t=.0;\n   float v=dd(u);\n   if(v<.9||1.1<v||v!=v)u=vec3(0);\n   if(m<4){tswap;l=vec4(g,max(floor(o),1.)+clamp(r,.001,.999));++m;\n  }}\n  else t=min(t+d*q,100.);\n }\n if(m<4){tswap;l=vec4(g,o+t*p);++m;}{\n  int a=m;for(int i=0;i<4;++i)if(a<4){tswap;++a;}}//simple sorting?\n e=h.xyz;\n f=normalize(j.xyz-h.xyz);\n n=length(j.xyz-h.xyz);\n t=.0;\n q=D*.1+.9;//q is scene specific\n o=1.;\n p=.0;\n //this loop pushes fog away by adding more \"glow\"\n //looks like a reflection and illumination loop. \n //fun part is that light sources scattered dots in lines in planar areas.\n for(int i=0;i<64;++i){//iteration steps are cene specific, scene 1 has no summands here.\n  if(t>n){\n   if(m<3)break;\n   tswap;--m;\n   e=h.xyz;\n   f=normalize(j.xyz-h.xyz);\n   n=length(j.xyz-h.xyz);\n   t=0.;\n   if(n<.0001)break;\n   float r=fract(h.w);\n   o=h.w-r;\n   p=(floor(j.w)-o)/n;\n   c*=mix(vec3(.17,.15,.12),vec3(1),r);\n  }\n  g=e+f*t;\n  //next 5 lines are scene specific\n  float u=abs(fract(g.z)-.5);//this line 100% absorbs U(), for scene1\n  g-=vec3(0,0,vec2(sign(fract(g.z)-.5)))*u;\n  float v=sin(A*.05+g.z)*.5,w=u*q+.001;\n  vec3 x=G(g,v);\n  c*=pow(.7,w);\n  t+=w;\n  b+=(W(x,v,u,o+p*t    )    +W(x,v,u,o+p*t+50.))*c*w;\n }\n //this line is also scene specific\n O=vec4(pow(b,vec3(.45)),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}