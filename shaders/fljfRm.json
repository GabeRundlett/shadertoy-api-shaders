{
    "Shader": {
        "info": {
            "date": "1651976315",
            "description": "A recreation of the video: https://www-users.cse.umn.edu/~arnold/moebius/",
            "flags": 0,
            "hasliked": 0,
            "id": "fljfRm",
            "likes": 23,
            "name": "Mobius transformation revealed",
            "published": 3,
            "tags": [
                "3d",
                "mobius"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 1414
        },
        "renderpass": [
            {
                "code": "/*\nThis animation shows that Mobius transformations are rigid motions\nof \"admissible\" spheres in the upper half-space.\n\nA sphere is called admissible if its highest point is above the xy-plane.\n\nThe procedure involves four steps:\n\n1. Map the complex plane (xy) to the sphere using inverse\n   stereographic projection.\n   \n2. Translate and rotate the sphere, but keeping it admissible..\n\n3. Map the sphere back to the complex plane using stereographic projection, \n   with the north pole being the highest point of the sphere.\n\n4. Combine steps 1-3 to get a Mobius transformation of the complex plane.\n   All Mobius transformations can be obtained this way.\n   \n\nIn this process,\n\n1. moving the sphere in the xy-plane is a translation of the complex plane.\n\n2. moving it along the z-axis is a scaling of the complex plane.\n\n3. rotating it in the xy-plane is a rotation of the complex plane.\n\n4. rotating 180 degress about the x-axis is the inverse map z -> 1/z.\n\n\nFor a given Mobius transformation M and a chosen initial position\nof the sphere, the rigid motion that gives M is unique.\n*/\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define TIME          iTime\n#define Y             vec3(0, 1, 0)\n#define NPOLE(sph)    (sph.xyz + sph.w * Y)\n#define PLANE         vec4(0, 1, 0, 1.5)\n#define aa            (2.0/iResolution.y)\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float grid_max     = 3.0;\nconst float grid_size    = 0.5;\nconst vec3  light_pos    = vec3(3, 4, 3);\nconst vec3  light_dir    = normalize(light_pos);\nconst vec3  sky0_color   = HSV2RGB(vec3(0.0, 0.65, 0.95)); \nconst vec3  sky1_color   = HSV2RGB(vec3(0.6, 0.5, 0.5));\nconst vec3  grid_color   = HSV2RGB(vec3(0.6, 0.6, 1.0)); \nconst vec3  light_color  = 12.0*HSV2RGB(vec3(0.6, 0.5, 1.0));\nconst vec3  plane_color  = HSV2RGB(vec3(0.7, 0.125, 1.0/32.0)); \n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 id = floor(p / size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return id;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 58.233))) * 13758.5453);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float r2 = sph.w * sph.w;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r2;\n    float h = b * b - c;\n    float d = -sph.w + sqrt(max(0.0, r2 - h));\n    float t = -b - sqrt(max(0.0, h));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);\n}\n\nfloat bounce() {\n    float t = fract(TIME) - 0.5;\n    return 0.25 - t*t;\n}\n\nvec2 path(float t) {\n    const float rad = 0.8;\n    return rad * vec2(cos(t), sin(t));\n}\n\nvoid rot(inout vec3 sp) {\n    sp.xy    *= ROT(TIME*0.3);\n    sp.xz    *= ROT(TIME*0.3);\n}\n\nvec3 diffuse(vec3 pos, vec3 nor) {\n    float ll = DOT2(light_pos - pos);\n    vec3  ld = normalize(light_pos - pos);\n    return light_color * max(dot(nor, ld), 0.0) / ll * 20.;\n}\n\nvec3 restrictColor(vec2 p, vec3 col) {\n    float cond =  step(abs(p.x), grid_max);\n          cond *= step(abs(p.y), grid_max);\n    return mix(plane_color, col, cond);\n}\n\nvec3 planeToSphere(vec3 p, vec4 sph) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(N - p);\n    float t = raySphere(p, rd, sph).x;\n    return p + rd*t;\n}\n\nvec3 sphereToPlane(vec3 p, vec4 sph, vec4 plane) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(p - N);\n    float t = rayPlane(p, rd, plane);\n    return p + rd*t - sph.xyz;\n}\n\nvec3 computeGridColor(vec3 pos, vec2 pp) {\n    vec2 z = pp;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * TIME + 0.25 * TAU * length(pos.xz));\n    \n    z = pp;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n    \n    float n  = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(TIME) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n  \n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(id), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2*vec3(2.0, 1.0, 1.0)*exp(-100.0*max(d2+0.01, 0.0));\n    gcol = mix(gcol, 6.*vec3(0.1, 0.09, 0.125), smoothstep(-aa, aa, -(d2+0.0075)));\n    gcol += 0.5*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(d2-0.00125));\n\n    vec3 col = clamp(gcol, -1.0, 1.0);\n\n    gcol = mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1-0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125)); \n    return col;\n}\n\n\nvec3 renderBackground(vec3 ro, vec3 rd, vec4 sph, float T) {\n    vec3 sky = smoothstep(1.0, 0.0, rd.y) * sky1_color + \n               smoothstep(0.5, 0.0, rd.y) * sky0_color;\n               \n    sky += pow(max(dot(rd, light_dir), 0.0), 800.0)*light_color;\n    if (rd.y >= 0.0)\n        return sky;\n        \n    float ht  = 1.0 + 0.2 * smoothstep(-0.05, 0.1, bounce());\n    float t   = rayPlane(ro, rd, vec4(vec3(0.0, ht, 0.0), 0.5));\n    vec3 pos  = ro + t*rd;\n    vec3 dif  = diffuse(pos, Y);\n    float sha = softShadow(pos, normalize(light_pos - pos), sph, 2.0);\n    dif *= sha;\n    \n    vec3 sp = planeToSphere(pos, sph);\n    sp -= sph.xyz;\n    rot(sp);\n    sp += sph.xyz;\n    vec3 pp = sphereToPlane(sp, sph, PLANE);\n\n    vec3 col = computeGridColor(pos, pp.xz);\n    col = restrictColor(pp.xz, col); \n    col += plane_color * dif;\n    col /= (1.0 + 0.25 * DOT2(pos.xz)); \n    col = mix(sky, col, tanh(500.0/(1.0 + DOT2(pos))));\n    return col;\n}\n\nvec3 renderBall(vec3 ro, vec3 rd, vec4 sph, vec2 st, float T) {\n    vec3 pos  = ro + st.x*rd;\n    vec3 sp   = pos - sph.xyz;\n    vec3 nor  = normalize(sp);\n    vec3 ref  = reflect(rd, nor);\n    vec3 dif  = diffuse(pos, nor);\n    rot(sp);\n    pos       = sp + sph.xyz;\n    vec3 pp   = sphereToPlane(pos, sph, vec4(0, 1, 0, 0.5));\n    vec3 rcol = renderBackground(pos, ref, sph, T);\n    \n    vec2 z = pp.xz;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * T + 0.25 * TAU * length(pp));\n    \n    z = pp.xz;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n    \n    float n = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(T) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n  \n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(sin(id * TAU)), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2*vec3(2.0, 1.0, 1.0)*exp(-100.0*max(d2+0.01, 0.0));\n    gcol = mix(gcol, 6.*vec3(0.09, 0.1, 0.125), smoothstep(-aa, aa, -(d2+0.0075)));\n    gcol += 1.*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(d2-0.00125));\n    vec3 col = clamp(gcol, -1., 1.);\n    gcol = mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1-0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125));\n    col = restrictColor(pp.xz, col);\n    col += rcol * 0.175;\n    return col;\n}\n\nvec3 render(vec2 p, vec2 uv) {\n    vec2 ph = path(TIME * 0.5);\n    vec3 ro = vec3(2.5, 1.0, 0.);\n    ro.xz *= ROT(TIME / 3.);\n    vec3 lookat = vec3(0., 0., 0.);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, Y));\n    vec3 up = normalize(cross(right, forward));\n    vec3 rd = normalize(p.x*right + p.y*up + 2.0*forward);\n    vec4 sph = vec4(vec3(0., bounce(), 0.), 0.5);\n    sph.xz += ph;\n    vec2 st = raySphere(ro, rd, sph);\n    if (st.x >= 0.0)\n        return renderBall(ro, rd, sph, st, TIME);\n    else\n        return renderBackground(ro, rd, sph, TIME);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = render(p, uv);\n\n    //float fi = smoothstep(0.0, 5.0, TIME);\n    //col = mix(vec3(0.0), col, fi);\n\n    col = postprocess(col, uv);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}