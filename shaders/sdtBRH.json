{
    "Shader": {
        "info": {
            "date": "1656080003",
            "description": "Procedural milky way galaxy",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtBRH",
            "likes": 11,
            "name": "Milky way galaxy",
            "published": 3,
            "tags": [
                "space",
                "galaxy",
                "stars",
                "nebula",
                "cosmos",
                "milkyway"
            ],
            "usePreview": 0,
            "username": "Peace",
            "viewed": 1037
        },
        "renderpass": [
            {
                "code": "#define BACKGROUND_COLOR vec3(0.1, 0.2, 0.6)\n#define SECONDARY_COLOR vec3(0.49, 0.45, 0.655)\n#define BIG_STAR_SIZE 16.\n#define MEDIUM_STAR_RATIO 0.3\n#define BIG_STAR_CHANCE 0.1\n#define STAR_COLOR vec3(0.9, 0.7, 1.0)\n#define SPACE_DUST_COLOR vec3(0.432941, 0.38627, 0.69020)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 hash(vec3 p3)\n{    \n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxx+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat voronoi(vec2 n, float t) {\n    \n    vec3 p = vec3(n.x, n.y, t);\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 q = h * h * h * h * vec4(dot(d0, hash(i)), dot(d1, hash(i + i1)), dot(d2, hash(i + i2)), dot(d3, hash(i + 1.0)));\n    \n    return dot(vec4(50.), q);\n\n}\n\n\nfloat voronoiFbm(vec2 p, int iter)\n{\n    float f = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    \n    for (int i = 0; i < iter; i++) {\n\t    f += a * abs(voronoi(p, 0.0)); \n        norm += a;\n        p *= 2.0;\n        a *= 0.65;\n    }\n    \n    return 1.0 - f / norm;\n}\n\nfloat fbm(vec2 p, int iter, float freq, float amp)\n{\n    float n = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    for(int i = 0; i < iter; ++i)\n    {\n        n += noise(p) * a;\n        norm += a;\n        p *= freq;\n        a *= amp;\n    }\n    return n / norm;\n}\n\n\nfloat fbm(vec2 p, int iter)\n{\n    return fbm(p, iter, 2.0, 0.5);\n}\n\nvec3 starColor(vec2 p)\n{\n    return sin(vec3(.2, .3, .9)*fract(rand(p + vec2(7.91, 246.792))*2345.2)*123.2)*vec3(0.15, 0.1, 0.15) + 0.75;\n}\n\nvoid stars(inout vec3 col, vec2 fragCoord, float density)\n{\n    vec2 p = fragCoord;\n    if(rand(vec2(ivec2(fragCoord / 2.0)) * 2.0) < MEDIUM_STAR_RATIO)\n        fragCoord = vec2(ivec2(fragCoord / 2.0)) * 2.0;\n    vec3 star = col * 0.5 + 0.5 * starColor(p);\n   \n    if(rand(fragCoord + vec2(1071.52, -662.1)) > 0.0) return;\n    col = star;\n}\n\nvoid bigStars(inout vec3 col, vec2 fragCoord, float density)\n{\n    vec2 p = vec2(ivec2(fragCoord / BIG_STAR_SIZE)) * BIG_STAR_SIZE;\n    float star_size = BIG_STAR_SIZE * pow(rand(p), 2.0);\n    vec3 star = col * 0.5 + 0.5 * starColor(p);\n    float d = max(1.0 - distance(p + star_size * 0.5, fragCoord) / star_size * 2.0, 0.0);\n    star += d * d * d * d;\n    \n    if(rand(p + vec2(6181.616, 9028.1)) > BIG_STAR_CHANCE) return;\n    col = mix(col, star, d * d * d);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = BACKGROUND_COLOR; // Background\n    float primary = sqrt(fbm(uv * 3.0 + vec2(6.175, -23.612), 8, 1.5, 0.5)); // Space lighness\n    float secondary = fbm(uv * 4.0, 8);\n    float nebula = 4.0 * pow(fbm(uv * 4.0 + vec2(-12.1, 2.62), 18, 2.0, 0.5), 5.0);\n    float space = primary * secondary * nebula;\n    vec3 variation = normalize(vec3(fbm((uv + vec2(11.61)) * 2.0, 8), fbm((uv - vec2(2.11)) * 2.0, 8), fbm((uv + vec2(66.61)) * 2.0, 8)));\n    \n    col *= space;\n    col = mix(col, secondary * SECONDARY_COLOR, 0.5); // Nebula\n    col = mix(variation, col, 0.93);\n    col += SPACE_DUST_COLOR * vec3(pow(fbm(uv * 12.0, 18, 2.0, 0.5), 3.0) * 0.5);\n    col += vec3(0.7, 0.6, 0.5) * nebula;\n    stars(col, fragCoord, space);\n    bigStars(col, fragCoord, space);\n    col /= 1.0 + vec3(1.0, 1.3, 1.5) * (4.0 * vec3(pow(max(voronoiFbm(uv * 2.0, 8), 0.0), 6.0))); // Voronoi (stripes of emptiness)\n    col = rgb2hsv(col);\n    col *= vec3(1.0, 1.0 + iMouse.x / 500.0, 1.0 + iMouse.y / 500.0);\n    col = hsv2rgb(col);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}