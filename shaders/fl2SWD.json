{
    "Shader": {
        "info": {
            "date": "1627698694",
            "description": "A helper / tooling shader I wrote to assist with developing 3d SDFs. Mouse controls Z offset. The red box indicates a reset position, which is useful for glsl-canvas in vscode.\n\nLicense: CC0",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2SWD",
            "likes": 1,
            "name": "3d SDF development tool",
            "published": 3,
            "tags": [
                "sdf",
                "tool",
                "3dsdf",
                "development",
                "tooling"
            ],
            "usePreview": 0,
            "username": "xertrov",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n// distributed under CC0\n\n/* here's an example of an SDF I was developing for a tetrahedron\n-- note: this was some experimental code where I was trying to get\nthe distances to play nicely. */\n\nfloat testSdTet(vec3 p, float r, out vec3 dists, out vec3 col) {\n  float zoomOut = 2.;\n  // p *= zoomOut;\n\n  float ySign = sign(p.y);\n  // p.xz = abs(ySign < 0. ? p.zx : p.xz);\n  // p.y = abs(p.y);\n  vec3 box = vec3(\n    mix(r/2., r, p.y / r / r),\n    r,\n    mix(r/2., r, -p.y / r / r)\n  );\n  p.y *= SQRT_3;\n  dists = (abs(p) - box);\n  return length(bestOf(dists)) * sign(bestOf(dists));\n\n  /* a neat version I found that gave me the idea for using mix + box method */\n  \n  /*\n  return (max(\n    abs(p.x - p.z) + p.y,\n    abs(p.x + p.z) - p.y\n  ) - r);\n  /**/\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float aspect = u_resolution.x / u_resolution.y;\n    vec2 uv = scaleUvWithAspect(gl_FragCoord.xy / u_resolution.xy, aspect);\n    vec2 mouse = scaleUvWithAspect(u_mouse.xy/u_resolution.xy, aspect);\n    float fw = bestOf(fwidth(uv));\n    float t = u_time * .8;\n    float zMovement = 0.;\n    float zResolution = .1;\n    \n    float gridSize = 5., fwg = fw * gridSize;\n    vec2 id, gv;\n    setIDGV(uv, gridSize, id, gv);\n    \n    /* comment this to remove animation */\n    zMovement = sin(iTime) * .2;\n    \n    if (bestOf(mouse.xy) > -.5 + 1. / gridSize) {\n        zMovement += mouse.y + mouse.x;\n    }\n    \n    vec3 col = vec3(0), p;\n\n    // z from -1 to 1\n    float gridN = id.x + id.y * gridSize;\n    float nGridCells = gridSize * gridSize;\n    float z = gridN / (nGridCells - 1.) * 2. - 1. + zMovement;\n    float zId = floor((z + zResolution / 2.) * (gridSize + 1.) * 2.);\n    p = vec3(gv * 2., z);\n\n    vec3 tmp;\n    float d = testSdTet(p, .5, tmp, col);\n    // float d = sdTriangleGen(p, .5, tmp);\n\n    if (col == vec3(0)) {\n      col.b = step(.0, d) * hh(hh(cos(d * TAU * 5.)));\n      col.g = step(.0, -d) * hh(hh(cos(d * TAU * 5.)));\n      // mark close to zero points with white --\n      col += onlyWithE(d, 1. / nGridCells, 0.);\n    }\n\n    // grid lines\n    col *= product(1. - step(.48, abs(gv)));\n    // mark slice near z==0 with green square\n    col.g += (only(zId, 0.) + .5 * onlyWithE(p.z, .3, 0.)) * step(.5 - fwg, bestOf(abs(gv)));\n    // mark bottom left with red square (indicating pos reset on mouseover)\n    col.r += (only(id.x, 0.) * only(id.y, 0.)) * step(.5 - fwg, bestOf(abs(gv)));\n\n\n    // black out squares outside core grid\n    col *= vec3(\n      step(.0, id.x) * step(- gridSize + 1., -id.x)\n      * step(.0, id.y) * step(- gridSize + 1., -id.y)\n    );\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* copy pasted from my libs. lots is written by me. you're welcome to use it, but caveat emptor. */\n\n#define u_resolution iResolution\n#define u_mouse iMouse\n#define u_time iTime\n#define gl_FragColor fragColor\n\n#define PI 3.141592653589\n#define TAU 6.28318530718\n\n#define SQRT_3 1.7320508\n#define SQRT_2 1.41421356\n\n#define S(a, b, t)smoothstep(a, b, t)\n#define hh(x)(x * 0.5 + 0.5)\n#define zoth vec4(0.0, 1.0, 2.0, 0.5)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n\nvec2 scaleUvWithAspect(vec2 st, float aspect) {\n  float scaleX = step(1.0, aspect), scaleY = 1. - scaleX;\n  aspect = max(aspect, 1. / aspect);\n  st.x = st.x * scaleY + scaleX * (st.x * aspect - (aspect - 1.) / 2.);\n  st.y = st.y * scaleX + scaleY * (st.y * aspect - (aspect - 1.) / 2.);\n  return st - .5;\n}\n\nvoid setIDGV(vec2 uv, float perAxis, out vec2 id, out vec2 gv) {\n  // returns a screen aligned grid with >= perAxis squares per axis, where\n  // all ID values that will be on any screen, are >= 0.\n  float odd = fract(perAxis / 2.) * 2.;\n  float adjID = floor(perAxis * .5 - .5) + 1.;\n  float scale = perAxis * 1.0;\n  vec2 idgvInput = uv * scale - 0.5 * odd;\n  id = floor(idgvInput) + adjID;\n  gv = fract(idgvInput) - 0.5;\n}\n\nvec2 best2(vec3 p) {\n  vec2 r = vec2(max(p.x, p.y), min(p.x, p.y)); // : vec2(p.y, p.x);\n  if (p.z > r.x) { return vec2(p.z, r.x);}\n  if (p.z > r.y) { return vec2(r.x, p.z);}\n  return r;\n}\n\nvec2 best2(vec4 p) {\n  vec2 r = p.x > p.y ? vec2(p.x, p.y) : vec2(p.y, p.x);\n  if (p.z > r.x) { r = vec2(p.z, r.x); }\n  else if (p.z > r.y) { r = vec2(r.x, p.z); }\n  if (p.w > r.x) { return vec2(p.w, r.x); }\n  else if (p.w > r.y) { return vec2(r.x, p.w); }\n  return r;\n}\n\nvec3 best3(vec4 p) {\n  vec2 zw = vec2(max(p.z, p.w), min(p.z, p.w));\n  // p.z > p.w ? vec2(p.z, p.w) : vec2(p.w, p.z);\n  vec2 xy = vec2(max(p.x, p.y), min(p.x, p.y));\n  if (xy.y > zw.x) {return vec3(xy, zw.x);} // testme\n  if (zw.y > xy.x) {return vec3(zw, xy.x);}\n  return vec3(max(xy.x, zw.x), min(xy.x, zw.x), max(xy.y, zw.y));\n\n  /* tests\n  col = best2(zoth.xyz) == vec2(2., 1.) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.zywx) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxzy) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.wxyz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth.xywz) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  col = best3(zoth) == vec3(2., 1., .5) ? zoth.yyy : zoth.yxx * .3;\n  */\n}\n\nfloat minOf(vec2 v) {\n  return min(v.x, v.y);\n}\nfloat maxOf(vec2 v) {\n  return max(v.x, v.y);\n}\nfloat sumOf(vec2 v) {\n  return v.x + v.y;\n}\n\nfloat minOf(vec3 v) {\n  return min(minOf(v.xy), v.z);\n}\nfloat maxOf(vec3 v) {\n  return max(maxOf(v.xy), v.z);\n}\nfloat sumOf(vec3 v) {\n  return sumOf(v.xy) + v.z;\n}\n\nfloat minOf(vec4 v) {\n  return min(minOf(v.xyz), v.w);\n}\nfloat maxOf(vec4 v) {\n  return max(maxOf(v.xyz), v.w);\n}\nfloat sumOf(vec4 v) {\n  return sumOf(v.xyz) + v.w;\n}\n\nfloat bestOf(vec2 p) {\n  // return p.x > p.y ? p.x : p.y;\n  return max(p.x, p.y);\n}\nfloat bestOf(vec3 p) {\n  return max(max(p.x, p.y), p.z);\n}\nfloat bestOf(vec4 p) {\n  return max(bestOf(p.xyz), p.w);\n}\n\n\nvec2 sinCos(in vec2 ab) {\n  return vec2(sin(ab.x), cos(ab.y));\n}\nvec2 sinCos(in float a) {\n  return vec2(sin(a), cos(a));\n}\n\n// roll from XY to XZ or YZ (0 no roll, 1=XZ, 2=YZ)\nmat3 rot3XY(float angle, int roll) {\n  float s = sin(angle), c = cos(angle);\n  mat3 r = mat3(c, - s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n  if (roll == 1) {\n    r = mat3(r[0].xzy, r[2].xzy, r[1].xzy);\n  } else if (roll == 2) {\n    r = mat3(r[2].zxy, r[0].zxy, r[1].zxy);\n  }\n  return r;\n}\n\n\nmat4 rot4(float angle, int axis) {\n  float s = sin(angle), c = cos(angle);\n  mat4 r = mat4(\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  // XY, XZ, XW\n  return axis == 0 ? r\n    : axis == 1 ? mat4(r[0].xzyw, r[2].xzyw, r[1].xzyw, r[3].xzyw)\n    : axis == 2 ? mat4(r[0].xwzy, r[3].xwzy, r[2].xwzy, r[1].xwzy)\n    // YZ, YW\n    : axis == 3 ? mat4(r[3].wxyz, r[0].wxyz, r[1].wxyz, r[2].wxyz)\n    : axis == 4 ? mat4(r[3].wxzy, r[0].wxzy, r[1].wxzy, r[2].wxzy)\n    // ZW\n    : axis == 5 ? mat4(r[3].wzxy, r[2].wzxy, r[0].wzxy, r[1].wzxy) : mat4(0.);\n}\n\n\n\nvec2 minWith(vec2 a, vec2 b) {\n  return (min(0., (a.x - b.x)) * a + min(0., (b.x - a.x)) * b) * -1. / abs(b.x - a.x);\n}\nvec4 minWith14(float a, vec4 av, float b, vec4 bv) {\n  float ba = b - a;\n  return (max(0., ba) * av + max(0., -ba) * bv) * -1. / abs(ba);\n  return b > a ? bv : av;\n}\n\n\nfloat onlyWithE(float edge, float e, float x) {\n  return 1.0 - step(e, abs(x - edge));\n}\n\nfloat only(float edge, float x) {\n  return onlyWithE(edge, 1.0 / 1e07, x);\n}\n\nfloat product(vec2 v) {\n  return v.x * v.y;\n}\nfloat product(vec3 v) {\n  return product(v.xy) * v.z;\n}\nfloat product(vec4 v) {\n  return product(v.xyz) * v.w;\n}\n\n/*\n// Some SDFs\n\nfloat sdTriangle1(vec2 uv, float b) {\n  float willFold = sign(step(.0, -uv.x) + (step(.0, -uv.y) * step(0., -dot(sinCos(TAU / 12.), uv))));\n  float splitAt = -dot(sinCos(- 7. * TAU / 12.), uv);\n  float top = sign(splitAt);\n  float foldAngle = (step(0., top) * TAU / 4. + step(0., -top) * (TAU / 12.)) * willFold;\n  vec2 n = sinCos(foldAngle);\n  float fold = -dot(n, uv) * willFold;\n  uv += fold * n * 2.;\n  // get distance to line that is our edge\n  return dot(uv, sinCos(TAU / 6.)) - b * .5;\n}\n\nvec4 sdTriangle1(vec3 p, float b) {\n  return vec4(length(vec2(sdTriangle1(p.xy, b), p.z)), abs(p)); // approximate dists for each axis\n}\n\nfloat sdTriangle2(vec2 uv, float b) {\n  float a = atan(uv.x, uv.y) + PI;\n  float id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return  uv.y - b / 2.;  // estimate based only on y; but it works...\n}\n\nvec4 sdTriangle2(vec3 p, float b) {\n  vec3 dd = abs(p) - vec3(0,b,0);\n  return vec4(length(vec2(sdTriangle2(p.xy, b), p.z)), dd);\n}\n\nvec2 foldXyThirds(vec2 uv, out float id) {\n  float a = atan(uv.x, uv.y) + PI;\n  id = floor(a * 3. / TAU) - 1.;\n  vec2 n = sinCos(-id * 7. * TAU / 12.);\n  uv += - abs(id) * dot(n, uv) * n * 2.;\n  return abs(uv);\n}\n\nvec2 foldXyThirds(vec2 uv) {\n  float id;\n  return foldXyThirds(uv, id);\n}\n\nfloat sdTriangleGen(vec3 p, float r, out vec3 dists) {\n  p.xy = foldXyThirds(p.xy);\n\n  vec3 a = vec3(r / 2. * SQRT_3, r / 2., 0.);\n  vec3 b = a * vec3(-1, 1, 1);\n  vec3 ap = p - a;\n  vec3 ab = b - a;\n  //* (step(r / 2., p.y) * 2. - 1.)\n  float dotPaBa = dot(ap, ab);\n  float dotBaBa = dot(ab, ab);\n  float h = clamp(dotPaBa / dotBaBa, -0., 1.);\n  dists = ap - h * ab;\n  float d = length(dists);\n  // for negative:\n  // * (step(r / 2., p.y) * 2. - 1.);\n\n  return d;\n}\n\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}