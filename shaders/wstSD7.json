{
    "Shader": {
        "info": {
            "date": "1572198108",
            "description": "A small effect that combines several mechanics used in the creation of special effects.",
            "flags": 0,
            "hasliked": 0,
            "id": "wstSD7",
            "likes": 25,
            "name": "Special effect",
            "published": 3,
            "tags": [
                "noise",
                "particles",
                "effect",
                "primitives",
                "geometry"
            ],
            "usePreview": 1,
            "username": "foxes",
            "viewed": 780
        },
        "renderpass": [
            {
                "code": "#define E1_COUNT 200\n#define E1_RADIUS 0.01f\n#define E1_RADIUS2 0.2f\n#define E1_RANGE 0.4f\n\n#define E2_COUNT 5\n#define E2_RADIUS 0.1f\n    \n#define E3_COUNT 20\n#define E3_RADIUS 0.1f\n#define E3_RADIUS2 2.0f\n\n#define E4_COUNT 10\n#define E4_RADIUS 0.2f\n#define E4_RADIUS2 0.1f\n\n#define E6_COUNT 5\n\nmat3 rotateX(float a)\n{\n    float sx = sin(a), cx = cos(a);\n    return mat3(vec3(1.0,0.0,0.0),vec3(0.0,cx,sx),vec3(0.0,-sx,cx));\n}\n\nmat3 rotateY(float a)\n{\n    float sy = sin(a), cy = cos(a);\n    return mat3(vec3(cy,0.0,-sy),vec3(0.0,1.0,0.0),vec3(sy,0.0,cy));\n}\n\nfloat hash(float a)\n{\n    return fract(5147.4235*sin(a*0.012345f));\n}\n\nvec3 hash3(vec3 a)\n{\n    return fract(5147.4235*sin(vec3(55.123,43.45,16.123) + dot(a,vec3(1.0f,14.554,145.34f))*0.012345f));\n}\n\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\nfloat noise3( vec3 x, float seed )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + dot(p.yz,vec2(157.0,113.0)) + seed;\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n}\n\nvec3 noisepos(int seed)\n{\n    return vec3(fract(5147.4235*sin(vec3(55.123,43.45,16.123) + vec3(float(seed)*0.012345f)))) - 0.5f;\n}\n\n/*vec3 lnoiseadd(vec3 p)\n{\n    return vec3(noise3(p,0.0f),noise3(p,10.0f),noise3(p,4.0f)) - vec3(0.5f);\n}*/\n\nvec3 lnoiseadd(vec3 p)\n{\n    return texture(iChannel0,p*0.1f).xyz - vec3(0.5f);\n}\n\n// particles\nvec4 effect1( vec3 pos, vec3 ray, float time, int seed )\n{\n    float a = 0.0;\n    float sr = 6.283f / float(E1_COUNT);\n\n    for (int i=0; i<E1_COUNT;i++)\n    {\n        float t = fract(time*0.5 - hash(float(i+seed))*0.3f*E1_RANGE);\n        t = sqrt(t);\n        float r = t*2.0f;\n        vec3 p = vec3(sin(float(i)*sr),0,cos(float(i)*sr));\n        p = normalize(p + lnoiseadd(p*20.0f+p*r*0.3f)*vec3(0.1f,1.0f,0.1f)*E1_RANGE);\n        p = p * r;\n        p += (lnoiseadd(p*1.0f))*0.3f*(r*0.4f+0.2f);\n        p -= pos;\n        float rl = 1.0f/dot(ray,normalize(p));\n        float finout = clamp(r,0.0f,1.0f) * clamp(2.0-r,0.0f,1.0f);\n        a += (1.0f - clamp(sqrt(rl*rl - 1.0) * length(p) / mix(E1_RADIUS,E1_RADIUS2,t),0.0,1.0)) * finout*0.5f;\n    }\n\n    return vec4(0.5,0.5,0.5,1)*a;\n}\n\n// rays\nvec4 effect2( vec3 pos, vec3 ray, float time, int seed )\n{\n    float a = 0.0f;\n    \n    for (int i=0; i<E2_COUNT; i++)\n    {\n        float tm = time*4.0f - hash(float(i+seed));\n    \tint s=int(floor(tm));\n        float io = fract(tm)* (1.0-fract(tm))*2.0f;\n    \n    \tvec3 nr = normalize(noisepos(seed+s*E2_COUNT+i));\n    \n    \tvec3 n = cross(nr,ray);\n    \tfloat ln = length(n);\n    \tn = normalize(n);\n    \tfloat rl = abs(dot(n, pos))/E2_RADIUS;\n    \n    \tfloat t = dot(cross(pos,nr),n) / ln;\n    \tt = dot(ray*t + pos,nr);\n    \tt=(1.0-abs(dot(nr,ray)))*t;\n    \n    \ta += ((1.0f - clamp(rl,0.0,1.0)) * clamp(t,0.0,1.0))*io;\n    }\n    \n    return mix(vec4(1.0f)*a,vec4(a*0.2f+0.5f,a*0.2f+0.5f,1,1)*a,a);\n}\n\n// dot particles\nvec4 effect3( vec3 pos, vec3 ray, float time, int seed )\n{\n    float a = 0.0f;\n    \n    vec3 npp = normalize(pos);\n    \n    for (int i=0; i<E3_COUNT;i++)\n    {\n        float tm = time*1.0f - hash(float(i+seed));\n    \tint s=int(floor(tm));\n        float io = fract(tm);\n        vec3 np = normalize(noisepos(i + seed + s*E3_COUNT));\n        vec3 p = np * sqrt(1.0f-io)*E3_RADIUS2 - pos;\n        \n        float ad=0.0;\n        for (int k=0;k<11;k++)\n        {\n            p += np*0.03f;\n        \tfloat rl = 1.0f/dot(ray,normalize(p));\n        \trl = (sqrt(rl*rl - 1.0));\n        \tad += (1.0f - clamp(rl * length(p) / E3_RADIUS,0.0,1.0))*abs(6.0f-float(5-k))*0.03f * io;\n        }\n        a += ad*ad;\n    }\n    \n    return vec4(a*a,a*a,a,1);\n}\n\n// core particles\nvec4 effect4( vec3 pos, vec3 ray, float time, int seed )\n{\n    float a = 0.0f;\n    \n    vec3 npp = normalize(pos);\n    \n    for (int i=0; i<E4_COUNT; i++)\n    {\n        float tm = time*1.0f - hash(float(i+seed)+floor(time));\n    \tint s=int(floor(tm));\n        float io = fract(tm) * (1.0-fract(tm));\n        vec3 np = normalize(noisepos(i + seed + s*E4_COUNT));\n        vec3 p = np * E4_RADIUS2 - pos;\n        float rl = 1.0f/dot(ray,normalize(p));\n        rl = (sqrt(rl*rl - 1.0));\n        a+= (1.0f - clamp(rl / E4_RADIUS,0.0,1.0)) * io;\n    }\n    \n    return vec4(a*a,a*a,a,1);\n}\n\nfloat perlin(vec3 p)\n{\n    //return texture(iChannel0,p*0.2f).x*0.4 + texture(iChannel0,p*0.4f).x*0.4 + texture(iChannel0,p*0.8f).x*0.2;\n    return texture(iChannel0,p*0.2f).x;\n}\n\nvec3 marh(vec3 pos, vec3 ray, float time, int seed)\n{\n    vec3 p = pos;\n    \n    for (int i=0; i<20; i++)\n    {\n        float n = (perlin(p + vec3(time*0.2f,0,0)) + perlin(p - vec3(time*0.2f,0.5f,0.5f))) * 0.5;\n        float h = mix(n*0.5f, 0.5f, clamp(length(p)*0.5f,0.0,1.0));\n        p += ray*clamp(h - 0.1f,0.0f,1.0f);\n    }\n    return p;\n}\n\nvec3 ofx;\nvec3 ofy;\n\nvec4 effect5( vec3 pos, vec3 ray, float time, int seed )\n{\n    float a = 0.0f;\n    \n    vec3 p = marh(pos,ray,0.0,seed);\n    vec3 p1 = marh(pos,normalize(ray+ofx),0.0,seed);\n    vec3 p2 = marh(pos,normalize(ray+ofy),0.0,seed);\n    vec3 n = normalize(cross(p1-p,p2-p));\n       \n    //a = (0.8-clamp(length(p-pos)*0.1f,0.0,1.0))*2.0f;\n    a = clamp(dot(n,normalize(vec3(0,0.0,1.0))),0.0,1.0);\n    \n    return vec4(1,1,1,1)*a;\n}\n\nfloat circle( vec2 uv, vec2 pos, float r, float w, float a)\n{\n    float c = abs(length(uv - pos) - r) - w;\n    return 1.0-clamp(c/a,0.0,1.0);\n}\n\nfloat fillcircle( vec2 uv, vec2 pos, float r, float a)\n{\n    float c = (length(uv - pos) - r);\n    return 1.0-clamp(c/a,0.0,1.0);\n}\n\nfloat noise(vec2 uv)\n{\n    return texture(iChannel0,vec3(uv,0.0)*0.04f).x;\n}\n\nfloat noise(vec3 uv)\n{\n    return texture(iChannel0,uv*0.04f).x;\n}\n\nfloat perlin(vec2 uv)\n{\n    return noise(uv) * noise(uv*2.0f)*0.9f + noise(uv*6.0f)*0.1f;\n}    \n\nvec2 repeat(vec2 uv, int count)\n{\n    float seg = 6.283185307179586476925286766559f/float(count);\n    float v = fract(atan(uv.x,uv.y)/seg) * seg - seg*0.5f;\n    return vec2(sin(v),cos(v)) * length(uv);\n}\n\nvec2 rotate(vec2 uv, float a)\n{\n    float v = atan(uv.x,uv.y)+a;\n    return vec2(sin(v),cos(v)) * length(uv);\n}\n\n// magic rings map\nfloat rings(vec2 uv, float t)\n{\n\tfloat a = 0.0;\n    float tr = length(uv);\n    tr = tr>3.4f ? t*0.1f : tr>2.4f ? -t*0.1f : 0.0;\n    float g = clamp((perlin(rotate(uv,tr)*15.0f)-0.23f)*10.0f,0.0f,1.0f);\n    float gb = clamp((perlin(uv*5.0f)-0.2f)*100.0f,0.0f,1.0f);\n    gb *= clamp((perlin(uv*5.0f + vec2(100.0f))-0.25f)*100.0f,0.0f,1.0f);\n    \n    float r2 = clamp((t-1.0f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\n    a += circle(uv,vec2(0.0,0.0),2.1f,0.01f,0.02f)*r2;\n    a += circle(uv,vec2(0.0,0.0),2.2f,0.02f,0.02f)*r2;\n    a += circle(uv,vec2(0.0,0.0),2.35f,0.05f,0.02f)*g*r2;\n    float r1 = clamp((t-1.6f)*8.0f + sin(t*40.0f) * 0.4f,0.0,1.0f);\n    a += circle(uv,vec2(0.0,0.0),2.8f,0.02f,0.02f)*r1;\n    a += circle(uv,vec2(0.0,0.0),3.1f,0.02f,0.02f)*r1;\n    a += circle(uv,vec2(0.0,0.0),2.95f,0.05f,0.02f)*g*r1;\n    a += circle(uv,vec2(0.0,0.0),3.2f,0.01f,0.02f)*r1;\n    float r0 = clamp((t-2.3f)*5.0f + sin(t*50.0f),0.0,1.0f);\n    a += circle(uv,vec2(0.0,0.0),3.8f,0.01f,0.02f) * 0.5f * r0;\n    a += circle(uv,vec2(0.0,0.0),3.95f,0.05f,0.02f)*g * 0.5f * r0;\n    \n    float c2 = clamp((t-0.5f)*2.0f + sin(t*20.0f)*0.03f,0.0,1.0f);\n    float p2 = clamp((t-0.5f)*2.0f,0.0,1.0f);\n    vec2 uvs = repeat(uv, E6_COUNT);\n    a = max(a - fillcircle(uvs,vec2(0.0,3.0-p2),0.64f,0.02f)*c2,0.0);\n    a += circle(uvs,vec2(0.0,3.0-p2),0.5f,0.03f,0.03f)*c2;\n    a += circle(uvs,vec2(0.0,3.0-p2),0.63f,0.01f,0.02f)*c2;\n    a += fillcircle(uvs,vec2(0.0,3.0-p2),0.3f,0.02f)*gb*c2 * r2;\n    \n    float p3 = sin(clamp(t,0.0,1.0f)*1.57);\n    uvs *= 5.0;\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),5.0f,0.1f,0.2f);\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),5.0f,0.1f,0.2f);\n\n    a += circle(uvs,vec2(-10.3 + p3*6.0f,2.2),4.2f,0.02f,0.2f);\n    a += circle(uvs,vec2(10.3 - p3*6.0f,2.2),4.2f,0.02f,0.2f);\n    \n    a = max(a - fillcircle(uv,vec2(0.0,0.0),0.71f * p3,0.02f)*0.9f,0.0);\n    a += circle(uv,vec2(0.0,0.0),0.6f*p3,0.02f,0.02f);\n    a += circle(uv,vec2(0.0,0.0),0.7f*p3,0.01f,0.02f);\n    return clamp(a,0.0,1.0);\n}\n\n// magic rings\nvec4 effect6(vec3 pos, vec3 ray, float t)\n{\n    vec3 fn = vec3(0.0,1.0,0.0);\n    vec3 fp = vec3(0.0,0.0,0.0);\n    vec2 pe6 = (ray *dot(pos+fp,fn)/dot(ray,fn)-pos).xz * 4.0f;\n\n    vec4 en = vec4(0.5,1.0,0.5,1.0) * perlin(vec2(length(pe6)*0.5f-t*3.0f,atan(pe6.x,pe6.y)*10.0f)) * clamp(1.0-length(pe6)*0.2f,0.0,1.0);\n    \n\treturn vec4(1.0) * rings(pe6,t) + vec4(1.0,0.0,1.0,1.0) * rings(pe6*0.96f,t)*0.5f\n        + en * clamp(t*0.4,0.0,1.0);\n}\n\n// cylinder vec3(forward, back, radius)\nvec3 cyl(vec3 pos, vec3 ray, vec3 p, vec3 ax, float r)\n{\n    vec3 n = cross(ray,ax);\n    float ln = length(n);\n    n = normalize(n);\n    float rl = abs(dot(n, pos - p));\n    if (rl>=r)\n        return vec3(0.0,0.0,1.0);\n    float d = dot(pos-p,n);\n\n    float t = dot(cross(pos-p,ax),n)/ln;\n    float it = 1.0/dot(ray,normalize(cross(n,ax)));\n    float s = abs (sqrt(r*r - d*d) *it);\n    return vec3(t+s,t-s,rl/r);\n}\n\nvec2 clampcyl(float ry,float py,vec2 cyl, float f, float t)\n{\n    return (vec2(1.0)-clamp(ry*cyl.xy-vec2(py)+vec2(f),vec2(0.0),vec2(1.0)))*clamp(ry*cyl.xy-vec2(py)+vec2(t),vec2(0.0),vec2(1.0));\n}\n\nfloat lc(vec3 pos)\n{\n    pos.y*=0.25f;\n    float a=noise(pos*2.0f)*0.4f + noise(pos*4.0f)*0.3f + noise(pos*10.0f)*0.2f+ noise(pos*20.0f)*0.1f;\n    return clamp((0.5f-abs(0.5f-a))*20.0f-8.0f,0.0,1.0);\n}\n\n// force column\nvec4 effect7( vec3 pos, vec3 ray, float time)\n{\n    float a = 0.0f;\n        \n    //vec3 c1 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\n    //vec3 c2 = cyl(pos-vec3(0.7,0,0),ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\n    vec3 c1 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.25f);\n    vec3 c2 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),0.20f);\n    vec3 c3 = cyl(pos,ray, vec3(0.0),vec3(0.0,1.0,0.0),clamp(4.25-time,0.0,1.0f)*100.0f);\n    \n    vec2 l1 = clampcyl(ray.y,pos.y,c1.xy,0.0,1000.0);\n    vec2 l2 = clampcyl(ray.y,pos.y,c2.xy,0.0,1000.0);\n    \n    a += (1.0-c2.z)*clamp(l2.x+l2.y,0.0,1.0);\n    float v = lc((ray*c1.x-pos)+vec3(0,time*10.0f,0))*2.0f*l1.x;\n        ;\n    a += abs(c1.x-c1.y)>0.0f ? (mix(a+l1.y*lc((ray*c1.y-pos)+vec3(0,time*10.0f,0))*0.5f, v*0.5f, v))*(1.0-c1.z) : 0.0;\n    a = a*clamp((time-4.2)*10.0f,0.0,1.0);\n    return vec4(1,1,0.5,1)*a + vec4(1.0f)*(1.0-c3.z)*clamp((time-4.1)*10.0f,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n    float time=iTime*1.0;\n    \n    // Ray, position and rotation\n    float mx = iMouse.z>0.0?iMouse.y/iResolution.y*1.5 - 1.5:-0.6;\n    //float mx = iMouse.z>0.0?iMouse.y/iResolution.y*4.0 - 2.0:-0.6;\n\tfloat my = iMouse.z>0.0?iMouse.x/iResolution.x*10.0:time*0.025;\n    mat3 imr = rotateX(mx) * rotateY(-my);\n    vec3 ray = normalize(vec3(p,2.0))*imr;\n    ofx = vec3(0.1,0.0,0.0)*imr;\n    ofy = vec3(0.0,0.1,0.0)*imr;\n    vec3 pos = vec3(0.0,0.2,-3.0)*imr;\n\n    // Output to screen\n    float a = 0.0;\n    \n    fragColor = iTime > 4.2f && iTime < 6.0f ? effect1(pos,ray,iTime,0) : vec4(0);\n    fragColor += mix(effect6(pos,ray,iTime-1.6f)*clamp(time-1.6,0.0,1.0)\n        + effect7(pos,ray,time)\n        + effect3(pos,ray,iTime,0)*clamp(time*0.25,0.0,1.0)\n                     + effect2(pos,ray,iTime,0)*clamp((time-1.5f)*3.0f,0.0,1.0)\n                     + effect4(pos,ray,iTime,0)*clamp(time-0.5f,0.0,1.0),vec4(1.0f),a);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}