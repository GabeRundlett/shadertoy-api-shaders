{
    "Shader": {
        "info": {
            "date": "1502675755",
            "description": "This is my first attempt to understand raymarching. Feedback would be welcome! I'm absolutely certain I've implemented a lot of things wrongly, so feel free to point that out!",
            "flags": 0,
            "hasliked": 0,
            "id": "XdSBDd",
            "likes": 4,
            "name": "Beginner raymarching",
            "published": 3,
            "tags": [
                "reflection",
                "raymarch",
                "beginner"
            ],
            "usePreview": 0,
            "username": "ashkitten",
            "viewed": 771
        },
        "renderpass": [
            {
                "code": "//// Definitions\n\n#define CAMERA_SPEED 0.5\n\n#define MAX_DIST 50.0\n#define EPSILON 0.0001\n\n#define SHADOWS\n#define SHADOW_THRESHOLD 0.01\n#define SOFT_SHADOWS\n#define SHADOW_HARDNESS 50.0\n\n#define LIGHT_INTENSITY 25.0\n#define AMBIENT_LIGHT 0.05\n\n#define MAX_REFLECTIONS 5\n#define REFLECTION_THRESHOLD 0.01\n\n#define FOG\n#define FOG_DISTANCE 25.0\n#define FOG_COLOR vec3(0.2, 0.25, 0.3)\n\n#define MATERIAL_LIGHTGRAY Material(vec3(0.9, 0.9, 0.9), 0.5, 8.0, 0.4)\n#define MATERIAL_GREEN Material(vec3(0.258824, 0.956863, 0.607843), 0.8, 8.0, 0.7)\n#define MATERIAL_BLUE Material(vec3(0.258824, 0.52549, 0.956863), 0.8, 4.0, 0.4)\n#define MATERIAL_PURPLE Material(vec3(0.878431, 0.4, 1.0), 1.0, 8.0, 0.0)\n#define MATERIAL_YELLOW Material(vec3(1.0, 0.843137, 0.0), 1.0, 8.0, 0.2)\n\n//// Structs\n\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n    float reflectivity;\n};\n\nstruct MapInfo {\n    Material material;\n    // Distance of the point we got info from to the map\n    float hit;\n};\n\nstruct Ray {\n    // Origin of the ray\n    vec3 origin;\n    // Ray's direction\n    vec3 direction;\n\n    // Where the ray is aiming at\n    vec3 target;\n\n    // Current position along the ray\n    float length;\n    // Just so we don't have to calculate it multiple times ¯\\_(ツ)_/¯\n    vec3 position;\n};\n\n//// Ray initializer\n\nRay initRayToTarget(vec3 origin, vec3 target) {\n    Ray ray;\n\n    // Init ray values\n    // Calculate ray direction\n    ray.direction = normalize(target - origin);\n\n    // Start a bit away from the origin so we don't hit whatever is at the start\n    ray.origin = origin + ray.direction * EPSILON;\n\n    ray.target = target;\n    ray.position = origin;\n\n    return ray;\n}\n\nRay initRayToDirection(vec3 origin, vec3 direction) {\n    Ray ray;\n\n    // Init ray values\n    ray.direction = direction;\n\n    ray.origin = origin + ray.direction * EPSILON;\n    ray.position = origin;\n\n    return ray;\n}\n\n//// Distance functions\n\nMapInfo plane(vec3 origin, Material material) {\n    return MapInfo(material, -origin.y);\n}\n\nMapInfo sphere(vec3 origin, float rad, Material material) {\n    return MapInfo(material, length(origin) - rad);\n}\n\nMapInfo box(vec3 origin, vec3 size, Material material) {\n    return MapInfo(material, length(max(abs(origin) - size, 0.0)));\n}\n\n//// Distance operations\n\nMapInfo opUnion(MapInfo o1, MapInfo o2) {\n    // min(o1, o2)\n    if (o1.hit < o2.hit) return o1;\n    return o2;\n}\n\nMapInfo opSubtract(MapInfo o1, MapInfo o2) {\n    // max(-o1, o2)\n    if (-o1.hit > o2.hit) return MapInfo(o1.material, -o1.hit);\n    return o2;\n}\n\nMapInfo opIntersect(MapInfo o1, MapInfo o2) {\n    // max(o1, o2)\n    if (o1.hit > o2.hit) return o1;\n    return o2;\n}\n\n//// The main mapping function\n\nMapInfo map(vec3 origin) {\n    // red plane at origin\n    MapInfo mapInfo = plane(origin, MATERIAL_LIGHTGRAY);\n    // blue sphere at 1.5, 1.0, 1.5 with radius 1.0\n    mapInfo = opUnion(mapInfo, sphere(origin + vec3(1.5, 1.0, 1.5), 1.0, MATERIAL_BLUE));\n    // green box at -1.5, 1.0, 1.5 with size 1.0 x 1.0 x 1.0\n    mapInfo = opUnion(mapInfo, box(origin + vec3(-1.5, 1.0, 1.5), vec3(1.0), MATERIAL_GREEN));\n    mapInfo = opUnion(mapInfo, opSubtract( // subtract sphere from box\n        sphere(origin + vec3(-1.5, 1.0, -1.5), 1.2, MATERIAL_PURPLE),  // purple sphere at -1.5, 1.0, -1.5 with radius 1.2\n        // purple box at -1.5, 1.0, -1.5 with size 1.0 x 1.0 x 1.0\n        box(origin + vec3(-1.5, 1.0, -1.5), vec3(1.0), MATERIAL_PURPLE))\n    );\n    mapInfo = opUnion(mapInfo, opIntersect( // intersect sphere with box\n        box(origin + vec3(1.5, 1.0, -1.5), vec3(1.0), MATERIAL_YELLOW), // yellow box at 1.5, 1.0, -1.5 with size 1.0 x 1.0 x 1.0\n        // yellow sphere at 1.5, 1.0, -1.5 with radius 1.2\n        sphere(origin + vec3(1.5, 1.0, -1.5), 1.2, MATERIAL_YELLOW))\n    );\n    return mapInfo;\n}\n\n//// Raymarching functions\n\nvec3 calcNormal(vec3 position) {\n    // Step around the point and see how far we are from the map at each position\n    // and do some math to figure out what the normal is\n    // I use a value of 0.02 because I find that's the best balance between accuracy and\n    // avoiding those nasty rings on some objects\n    vec2 eps = vec2(0.0, 0.005);\n    return normalize(vec3(\n        map(position + eps.yxx).hit - map(position - eps.yxx).hit,\n        map(position + eps.xyx).hit - map(position - eps.xyx).hit,\n        map(position + eps.xxy).hit - map(position - eps.xxy).hit\n    ));\n}\n\nMapInfo trace(inout Ray ray) {\n    while(distance(ray.position, ray.origin) < MAX_DIST) {\n        // Get info about our position in relation to the map\n        MapInfo mapInfo = map(ray.position);\n        // If we hit something, return the info about our position on the map\n        if(mapInfo.hit < EPSILON) return mapInfo;\n\n        // Step forward along the ray, as far as our distance to the map\n        ray.position += ray.direction * mapInfo.hit;\n    }\n    // Return fog if we didn't hit anything\n    return MapInfo(Material(FOG_COLOR, 0.0, 0.0, 0.0), 1.0);\n}\n\nfloat softshadow(inout Ray ray, float softness) {\n    // While we're not past the target, do the stuff\n    // Subtract EPSILON * 2 so we don't get close enough to the original object to trigger the shadow\n    float penumbra = 1.0;\n    while(distance(ray.origin, ray.position) < distance(ray.origin, ray.target) - EPSILON * 2.0) {\n        // Get info about our position in relation to the map\n        MapInfo mapInfo = map(ray.position);\n        // If we hit something, make the color black (shadow)\n        if(mapInfo.hit < EPSILON) return 0.0;\n\n        #ifdef SOFT_SHADOWS\n            penumbra = min(penumbra, softness * mapInfo.hit / distance(ray.position, ray.target));\n        #endif\n\n        if(mapInfo.hit > SHADOW_THRESHOLD) ray.position += ray.direction * mapInfo.hit;\n        // Move a bit closer to the target\n        else ray.position += ray.direction * SHADOW_THRESHOLD;\n    }\n    // If we don't hit anything, the point is not in shadow so the shadow multiplier is 1.0\n    return penumbra;\n}\n\n//// Main function\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //// Setup the viewport\n    // Screen coords go from -1.0 to 1.0\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    // Account for screen ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    //// Setup the camera\n    // Init camera 5.0 up, rotating in a circle, looking at 0.0, 0.0, 0.0\n    // Axes are flipped here I guess? Note the -vec3s\n    Ray cameraRay = initRayToTarget(-vec3(\n        sin(iTime * CAMERA_SPEED) * 5.0,\n        5.0,\n        cos(iResolution * CAMERA_SPEED) * 5.0), -vec3(0.0, 0.0, 0.0)\n    );\n    // Convert to screen coords\n    // Global up direction\n    vec3 globalUp = vec3(0.0, 1.0, 0.0);\n    // Right direction in relation to the camera\n    vec3 cameraRight = normalize(cross(globalUp, cameraRay.origin));\n    // Up direction in relation to the camera\n    vec3 cameraUp = cross(cameraRay.direction, cameraRight);\n    // Set the camera ray direction to point from the screen coordinate to our target\n    cameraRay.direction = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraRay.direction);\n\n    vec4 reflections[MAX_REFLECTIONS + 1];\n\n    // Background color\n    float reflectivity = 1.0;\n    for(int i = 0; i <= MAX_REFLECTIONS; i++) {\n        // Trace the ray's path\n        MapInfo mapInfo = trace(cameraRay);\n\n        // If the camera ray hit something\n        if(mapInfo.hit < EPSILON) {\n            //// Lighting\n\n            // Setup the light source\n            // Init light source at 5.0, 5.0, 5.0\n            // Again, axes need to be flipped, note the -vec3\n            Ray lightRay = initRayToTarget(-vec3(5.0, 5.0, 5.0), cameraRay.position);\n\n            #ifdef SHADOWS\n                // Trace shadows\n                float shadow = softshadow(lightRay, SHADOW_HARDNESS);\n            #else\n                float shadow = 1.0;\n            #endif\n\n            // Light stuff\n            // Calculate the normal of the position on the map\n            vec3 normal = calcNormal(cameraRay.position);\n            // Light fades by the inverse square of distance\n            float distanceFade =  LIGHT_INTENSITY / pow(distance(lightRay.origin, lightRay.target), 2.0);\n            // Multiply diffuse by shadow and distance fade\n            float diffuse = max(0.0, dot(-lightRay.direction, normal))\n                * mapInfo.material.diffuse * shadow * distanceFade;\n            // Specular lighting factor\n            float specular = pow(diffuse, mapInfo.material.specular);\n\n            // Get color from map info\n            vec3 hitColor = mapInfo.material.color;\n\n            // Add lighting values\n            hitColor *= diffuse + specular + AMBIENT_LIGHT;\n\n            #ifdef FOG\n                // Add fog\n                float fogAmount = 1.0 - exp(-max(distance(cameraRay.origin, cameraRay.position) - FOG_DISTANCE, 0.0) * 0.15);\n                hitColor = mix(hitColor, FOG_COLOR, fogAmount);\n            #endif\n\n            reflections[i] = vec4(hitColor, mapInfo.material.reflectivity);\n\n            // Set the camera ray to the reflection off the surface, and repeat\n            cameraRay = initRayToDirection(\n                cameraRay.position + normalize(reflect(cameraRay.direction, normal)) * EPSILON,\n                normalize(reflect(cameraRay.direction, normal))\n            );\n        } else {\n            reflections[i] = vec4(mapInfo.material.color, 0.0);\n            break;\n        }\n    }\n\n    fragColor = vec4(reflections[MAX_REFLECTIONS].rgb, 1.0);\n\n    for(int i = MAX_REFLECTIONS - 1; i >= 0; i--) {\n        fragColor = mix(vec4(reflections[i].rgb, 1.0), fragColor, reflections[i].a);\n    }\n\n    // Gamma correction\n    fragColor = vec4(pow(clamp(fragColor.xyz, 0.0, 1.0), vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}