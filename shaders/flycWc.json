{
    "Shader": {
        "info": {
            "date": "1662302022",
            "description": "I wanted to create a simple game in a single shader\nYou can create your own levels\n\nRULES :\n1) Reset the shader\n2) Click anywhere, and keep the mouse button pushed\n3) If the screen turns red, you lose\n\nOrange walls are just warnings, you can go through",
            "flags": 0,
            "hasliked": 0,
            "id": "flycWc",
            "likes": 5,
            "name": "ZigZag Game : The Maze",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "Tache",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "#define PIXEL 1./iResolution.y   // Size of a pixel in UV coordinates\n#define TIME (iTime*SPEED)\n\n// GLOBAL PARAMETERS\n#define BALL 0.007     // Radius of the player in UV coordinates\n#define WALL 0.002     // Wall thickness in UV coordinates\n#define SPEED 1.       // Game speed\n#define DANGER 1.      // Time between danger appearance and wall appearance\n#define VY 0.          // Vertical level translation speed\n#define VX 0.05        // Horizontal level translation speed\n\n// COLORS\n#define backCOLOR   vec3(0.1, 0.2, 0.1)    // Background Color\n#define dangerCOLOR vec3(1.0, 0.5, 0.0)    // Danger zone Color\n#define loseCOLOR   vec3(0.9, 0.1, 0.1)    // Lose screen Color\n#define wallCOLOR   vec3(0.7, 0.7, 0.7)    // Wall Color\n#define ballCOLOR   vec3(1.0, 0.6, 0.6)    // Player Color\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// LEVEL\n////////////////////////////////////////////////////////////////////////////////////////////\n//   To create your own level, remove everything in this\n// section and replace the WallSDF function by your own\n// function. It has to be the distance function to the\n// walls of your level, and it can depend on time.\n////////////////////////////////////////////////////////////////////////////////////////////\n\n// PARAMETERS SPECIFIC TO THIS LEVEL\n#define GRID 0.1       // Size of a cell in in UV coordinates\n#define RATE 1.        // Wall switchings speed Rate\n#define SEED 125.      // Level seed\n\n// Functions used for WallSDF \nfloat rand(vec2 p, float time){\n    float r = fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453 + SEED + RATE*time/40.);\n    if (r>0.5){ return 1.; }\n    else      { return 0.; }\n}\nfloat diagSDF(float x, float y){\n    return min(min(\n                abs(x-y)/sqrt(2.),\n                abs(x-y-1.)/sqrt(2.)),\n                abs(x-y+1.)/sqrt(2.));\n}\n\n// The 2D SDF function of the walls at point p and time t.\nfloat WallSDF(vec2 p, float t){\n    // Before starting the maze the level\n    if (p.x<3.*GRID){\n        p.y = mod(p.y+GRID/2.,GRID)-GRID/2.;\n        float L = 3.*GRID;\n        if (p.x+p.y>L)\n            {return (p.y-p.x+L)/sqrt(2.);}\n        if (p.x-p.y>L)\n            {return (-p.y-p.x+L)/sqrt(2.);}\n        return length(p-vec2(L,0.));\n    } \n    // Inside the maze\n    float xx = floor(p.x/GRID);\n    float yy = floor(p.y/GRID);\n    float dx = mod(p.x,GRID)/GRID;\n    float dy = mod(p.y,GRID)/GRID;\n    float orientation = rand(vec2(xx,yy), t);\n    if (orientation==1.){ return GRID*diagSDF(   dx,dy); }\n    else                { return GRID*diagSDF(1.-dy,dx); }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// GAME ENGINE\n////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // ENGINE\n    // Compute uv coordinates\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 M = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    // Level translation\n    uv += vec2(VX,VY)*TIME;\n    M += vec2(VX,VY)*TIME;\n    // Compute the walls SDF at TIME+DANGER\n    float danger = WallSDF(uv, TIME+DANGER);\n    // Compute the walls SDF at TIME\n    float wall = WallSDF(uv, TIME);\n\n    // GRAPHICS\n    // Print the background color\n    vec3 color = backCOLOR;\n    // Print a red screen if the player touches the walls\n    if ( WallSDF(M, TIME) < WALL+BALL)\n        { color = loseCOLOR; }\n    // Print the danger zone color\n    float dangerStep = smoothstep(PIXEL+WALL,WALL,danger);\n    if (mod(fragCoord.x,2.)*mod(fragCoord.y,2.)<0.5) // Hatching effect \n        { color = mix(color, dangerCOLOR, dangerStep); }\n    // Print the walls\n    float wallStep = smoothstep(PIXEL+WALL,WALL,wall);\n    color = mix(color, wallCOLOR, wallStep);\n    // Print the ball\n    float ball = sqrt((uv.x-M.x)*(uv.x-M.x)+(uv.y-M.y)*(uv.y-M.y));\n    ball = smoothstep(BALL+PIXEL,BALL,ball);\n    color = mix(color, ballCOLOR, ball);\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}