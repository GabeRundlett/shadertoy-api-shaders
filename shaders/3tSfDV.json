{
    "Shader": {
        "info": {
            "date": "1599859368",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "3tSfDV",
            "likes": 11,
            "name": "Day 265",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 336
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 264\" by None. https://shadertoy.com/view/-1\n// 2020-09-11 10:22:57\n\n// Fork of \"Day 264\" by jeyko. https://shadertoy.com/view/tl2BWG\n// 2020-09-11 09:35:06\n\n\n// HASH from Dave Hoskins Hash Without Sine\n// SPLINE and BEZIER by demofox\n// sdPolygon and sdTri  from IQ \n\n\nvec4 noise(float t){return texture(iChannel1,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n\t\n    \n    \n    \n    //col = 1. - col;\n    col = max(col,0.002);\n    \n    \n\tvec4 f = smoothstep(0.,1.,fbm(uv*50.));\n\tvec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n    \n    f.x = pow(f.x, 5.);\n    \n    float n = 0.;\n    n += f.x*.5;\n    n += pow(f.y,7.)*2.5;\n    n += pow(f.z,6.)*2.5;\n    n += pow(f.w,3.)*0.1;\n        \n    n += pow(g.x,6.)*3.;\n    n += pow(g.y,4.)*1.;\n    n += pow(g.z,4.)*1.;\n        \n    \n    n = min(n,0.5);\n    \n    \n    \n    if(length(col) > 0.2){\n        vec3 nn = vec3(n*0.6,n,n)*2.;\n        col *= 1. - nn;\n        //col -= pow(g,5.)*2.5;\n        //col -= pow(g,2.)*.9;\n    }\n    else{\n        col += pow(n,2.)*.7;\n    \t//col += f*4.;\n    \n    }    \n    \n    col *= vec3(1.06,0.98,0.9);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\n\n#define pi acos(-1.)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(99.);\n    }\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBox( in vec3 p, in vec3 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,p.z));\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + (right*uv.x + up*uv.y)*0.4);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec4 noise(float t);\nvec4 valueNoise(vec2 t, float w);\nvec4 fbm(vec2 uv);\n\nfloat df = 0.;\nfloat frame;\nvec2 guv;\nvec2 luv;\nfloat seg = 0.;\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n// ----------\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb);\n\n\nfloat bspline( in vec2 coords );\n\nfloat jaggy(vec2 uv, float densitya, float densityb, float w){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    uv.x += 0.5;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\t\n\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 925.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\nfloat mp = 1.;\n\nfloat map(vec3 p){\n\tfloat d = 10e5;\n    \n    //p.z = pmod(p.z,4.5);\n    \n    if(mp == 0.){\n    \td = length(p.xz) + 0.02 - abs(sin(p.y*9.))*.4*smoothstep(1.,0.,abs(p.y));\n    \n    \n    \td = xor(d, max(length(p.z), abs(p.y) - 0.5),0.3);\n    \n    } else if (mp == 1.){\n    \td = sdBox(p,vec3(0.8)) + 0.0 - 0.*abs(sin(p.y*4.))*.4*smoothstep(1.,0.,abs(p.y));\n    \n        \n        \n    \n    \t//d = xor(d, max(length(p.z), abs(p.y) - 0.1),0.3);\n    \n    \n    }\n    \n    \n    //d = sdBox(p,vec3(0.15));\n    //d = min(d,length(p.x) - 0.);\n    \n    d = abs(d) - 0.01;\n    \n    return d;\n}\n\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt){\n\tfloat d = 10e5;\n    \n    vec3 ro = vec3(0.3,0.34,.12)*12.;\n    \n    vec3 rd = getRd(ro,vec3(0.),uv);\n    \n    \n    \n    \n    for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n    \tvec3 lro = ro + vec3(0,i,0);\n        \n        \n        float plane = intersectPlane(lro,rd,vec3(0,-1,0)).x;\n        vec3 p = lro + rd*plane;\n    \t\n        vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n        \n        float m = map(vec3(p.x,(lro + rd*plane).y - i*1.5,p.z));\n        if(m <= d){\n        \t\n        \t//df = max(ldf.y,ldf.x)*1.;\n        \t\n            df = length(ldf)*1.;\n            \n\t\t\td = min(d,m);\n        \n        }\n        \n    }\n    \n    \n    return d ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    guv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    \n    seed = r11(frame)*200.;\n    \n    df = dFdx(uv.x)*9.;\n    \n    guv = uv;\n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 c = vec3(0.45,.35,0.25)*2.8;\n    \n    \n    c = vec3(1);\n    vec3 col = iFrame < 2 ? c : texture(iChannel3,fragCoord/iResolution.xy).xyz;\n\n    \n    float d = 10e5;\n    \n    \n    \n    float id = floor(mod(frame/period,10.));\n    seg = floor(frame/period );\n        \n    if(mod(float(iFrame)*SPEED,1.) < SPEED && frame > 0.){\n    \tvec2 roll = r12(frame + 1.);\n    \n        float a = 0.03;\n        \n        if(frame == 4.){\n\t\t\tmp = 0.;\n            \n            d = slice(uv, -2., 2., 39.);\n            \n        \tcol = colour( d + 0.006 , col, vec3(0), 0,0,8.,0.01);\n           \t\n            \n            d = xor(d, -abs(length(uv.x) - 1.),0.8);\n            \n            d = xor(d,-(length(uv.x) - 0.54),0.4);\n            \n        \tcol = colour( d , col, vec3(0.), 0,3,2.,.4);\n           \n            \n            d = jaggy(uv*rot(0.5*pi),0.,1.,0.5);\n\n            col = colour( d - 0.001, col, vec3(0.), 0,0,28.,0.001);\n           \t\n            \n            d = xor(d,-(length(uv) - .0),0.6);\n            \n            col = colour( d - 0.001, col, vec3(0.), 0,0,28.,0.001);\n        \n                \n            /*\n            uv *= 2.;\n            uv.y += 0.5;\n        \t\n            uv -= vec2(0.1,0.7);\n            d = dotwork(uv + 0.5, .5 - 0.1, 0.00,1.);\n        \n            \n            vec2 po = vec2(-0.5,0.2);\n            d = max(d, (length(uv - po) - .2));\n        \t\n            \n            d = min(d, abs(length(uv - po) - .2) - 0.003);\n        \n        \n            \n            uv += vec2(0.0,0.8);\n            d = min(d, (length(uv - vec2(0.3)) - .2));\n        */\n        \tcol = colour( d , col, vec3(0), 0,0,4.,0.);\n           // col = colour( d - 0.001, col, vec3(0.), 0,0,28.,0.001);\n           \t\n            \n            \n        }\n             \n         \n\t    \n        \n        \n        \n        \n        \n        \n        \n        \n        //d = max(d, length(uv) - 0.2);\n        \n        \n    }\n    \n    \n    col = max(col,0.);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // \n\n\n\n\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n    \n    \n    \n\tvec2 roll;\n\t\n    \n    \n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n    /*\n    if(ss == 0.){\n    \n    \n    } else if(ss == 1.){\n     \troll = r12(frame + 38.);\n    } else if(ss== 2.){\n     \troll = r12(frame - 13. - period*2.);\n    } else if(ss== 3.){\n     \troll = r12(frame + 44. - period*3.);\n    } else if(ss== 4.){\n     \troll = r12(frame - 64.);    \n    } else if(ss== 5.){\n     \troll = r12(frame - 24.);\n    }*/\n    \n    vec4 n = valueNoise(guv,1.); \n    \n    float deb;\n    \n    if (stroke == 0) {\n\t\t//db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*0.4).x*0.53*n.z*strokeparamb,0.,db );\n        \n        \n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        \n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08;\n        \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        //db -= texture(iChannel0,guv*(0.3 - n.y*0.2)).x*0.016 - texture(iChannel0,guv*(0.7 - n.z*0.4)).y*0.02*n.y;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    //cb*=1. - smoothstep(1.,0.,abs(db)*(30.01 + 0.*float(stroke==3)*strokeparam) + t.z*1.53)*.8;\n    \n    cb*=1. + smoothstep(1.,0.,abs(db)*10.01)*.0;\n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t\n    \n    if(mode == 0){\n    \t\n        // 0 replace\n        if(stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    \t//co = mix( oa, cb, deb);\n\n    } else if(mode == 1){\n    \t\n        // 1 multiply\n    \n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n    \t\n        // 2 overlay\n        \n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        \n        }\n    } else if(mode == 3){\n    \t\n        // 3 darken\n        \n    \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\n    \t\n        // 4 burn\n        \n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\n    \t\n        // 5 linear burn\n        \n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n    \t\n        // 6 color dodge\n        \n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}