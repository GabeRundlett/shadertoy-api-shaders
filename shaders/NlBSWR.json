{
    "Shader": {
        "info": {
            "date": "1628804775",
            "description": " - 1-4-7 based prog with equal temperment.\n - 7/4 meter with emphasising the missing beat. It'd be almost house music if it weren't for that.\n - more advanced visuals than last time ( still a bit lazy on the artefacts )",
            "flags": 40,
            "hasliked": 0,
            "id": "NlBSWR",
            "likes": 19,
            "name": "mouse ate my house",
            "published": 3,
            "tags": [
                "3d",
                "audio",
                "funny"
            ],
            "usePreview": 0,
            "username": "mare",
            "viewed": 576
        },
        "renderpass": [
            {
                "code": "\n#define lenSq(x) dot(x,x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    float colorScale = 6.0 / iResolution.y;\n    \n    vec2 pixelStep = 3.0 / iResolution.xy;\n    \n    vec3 center = texture( iChannel0, coord ).xyz;\n    vec3 top = texture( iChannel0, coord + vec2( .0, pixelStep.y ) ).xyz;\n    vec3 right = texture( iChannel0, coord + vec2( pixelStep.x, .0 ) ).xyz;\n    \n    float sobelThreshold = .25;\n    \n    float tvVignette = 1.0 - 1.5 * lenSq( coord - vec2( .5, .5 ) );\n    tvVignette *=  .9 + .1 * sin( 2.0 * fragCoord.y );\n    \n    fragColor = vec4(\n        tvVignette * texture( iChannel0, coord * ( 1.0 - colorScale )).r,\n        tvVignette * texture( iChannel0, coord ).g, \n        tvVignette * texture( iChannel0, coord * ( 1.0 + colorScale )).b,\n        1.0 );\n    if( lenSq( center - top ) > sobelThreshold || lenSq( center - right ) > sobelThreshold)\n    {\n        fragColor *= vec4( .25, .25, .25, 1.0 );\n\n    }\n    \n    \n    return;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TONE(f,i) sin((f)*float(i)*1.424759e-4)\n#define FADE_OUT_LIN(l,i) clamp(float(l-(i))/float(l), .0, 1.0)\n#define FADE_IN_LIN(l,i) clamp(float(i)/float(l), .0, 1.0)\n\n#define LP(f) clamp((lp-f)*.01-.05,.0,1.)\n#define PAN(f) vec2(sin(f),cos(f))\n#define CENTER *vec2(1.)\n\n\nint primes[ 16 ] = int[ 16 ]\n(\n0, 5, 7, 7,\n2, 7, 9, 9,\n3, 8, 10, 10,\n2, 7, 0, 0\n);\n\nint thirds[ 16 ] = int[ 16 ]\n(\n16, 21, 23, 23,\n17, 23, 24, 24,\n19, 24, 14, 13,\n17, 23, 16, 16\n);\n\nint sevenths[ 16 ] = int[ 16 ]\n(\n11, 14, 18, 18,\n12, 16, 17, 17,\n14, 19, 21, 20,\n12, 19, 21, 21\n);\n\nlowp float chord[5] = float[5](.0, .0, .0, .0, .0);\n\n// equal temperment\nfloat ratios[ 26 ] = float[26]\n(\n    1.0, 1.059463, 1.122462, 1.189207, 1.259921, 1.334840,\n    1.414213, 1.498307, 1.587401, 1.681793, 1.781797, 1.887749,\n    2.0, 2.118126, 2.244924, 2.378414, 2.519842, 1.669680, \n    2.828426, 2.996614, 3.174802, 3.363586, 3.563594, 3.775498,\n    4.0, .0\n);\n#define N 25\n\nfloat kick( int samp )\n{\n    float fout = FADE_OUT_LIN(12000,samp);\n    return 0.5 * TONE(220.0-.015 * float(samp), samp)\n        * FADE_IN_LIN(50, samp)\n        * fout * fout * fout;\n}\n\nfloat hat( int samp )\n{\n    float fm = float( max( 200, 3000 - 2 * samp ) );\n    float fadeOut = FADE_OUT_LIN(20000,samp);\n    fadeOut *= fadeOut * fadeOut;\n    fadeOut *= fadeOut * fadeOut;\n    return .3 * TONE(5000.0 +  fm * TONE(500.0, samp), samp)\n        * FADE_IN_LIN(50, samp)\n        * fadeOut;\n}\n\nvec2 glass( float f, int samp, int len )\n{\n    float fadeOutAtt = FADE_OUT_LIN(min(len, 6000),samp);\n    fadeOutAtt *=fadeOutAtt;\n    fadeOutAtt *=fadeOutAtt;\n    \n    return  TONE(min( f, f-300. +  .8 *float(samp) ), samp)*PAN(f)\n        * FADE_IN_LIN(300, samp)\n        * fadeOutAtt\\\n        * min(f, 1.0 );\n}\n\nfloat bass( float f, int samp, int len )\n{\n    return \n        ( max( TONE( f, samp ), .1 ) - .45 ) * .5\n\n        * FADE_IN_LIN(200, samp)\n        * FADE_OUT_LIN(200, samp - len + 200 )\n        * FADE_OUT_LIN(len*2, samp )\n        * min(f, 1.0 ); \n}\n\n\nvec2 pianoLP( float f, int samp, int len, float lp )\n{\n    float fadeOut = FADE_OUT_LIN(len, samp);\n    fadeOut *= fadeOut * fadeOut;\n    float fadeOutO1 = FADE_OUT_LIN(len, samp);\n    fadeOutO1 *= fadeOutO1 * fadeOutO1 * ( .7 + .3 * TONE( 6.0, samp ) );\n    float fadeOutO2 = FADE_OUT_LIN(len/6, samp);\n    fadeOutO2 *= fadeOutO2 * fadeOutO2 * ( .7 + .3 * TONE( 5.0, samp ) );\n    float fadeOutO3 = FADE_OUT_LIN(len/2, samp);\n    fadeOutO3 *= fadeOutO3 * fadeOutO3 * ( .7 + .3 * TONE( 4.0, samp ) );\n    \n    vec2 tone = TONE(f, samp )*LP(f) * PAN(f );\n    vec2 overtones1 = \n            .1 * TONE( 2. * f, samp )*LP(2.*f)*PAN(2.*f) +\n            .5 * TONE( 3. * f, samp )*LP(3.*f)*PAN(3.*f) +\n\n            .15 * TONE( 4. * f, samp )*LP(4.*f)*PAN(4.*f);\n    vec2 overtones2 = \n            .1 * TONE( 5. * f, samp )*LP(5.*f)*PAN(5.*f) +\n            .27 * TONE( 6. * f, samp )*LP(6.*f)*PAN(6.*f)+\n            .17 * TONE( 7. * f, samp )*LP(7.*f)*PAN(7.*f);\n    vec2 overtones3 = \n            .015 * TONE( 8. * f, samp )*LP(8.*f)*PAN(8.*f)+\n            .005 * TONE( 9. * f, samp )*LP(9.*f)*PAN(9.*f)+\n            .001 * TONE( 10. * f, samp )*LP(10.*f)*PAN(10.*f);\n   \n    \n    return FADE_IN_LIN(500, samp) * min( f, 1.0 ) * (\n        tone * fadeOut + \n        overtones1 * fadeOutO1 + \n        overtones2 * fadeOutO2 + \n        overtones3 * fadeOutO3\n        );\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    int barLength = 160000;\n    int beatLength = barLength / 7;\n    int subBeat1 = 5 * beatLength / 10;\n    int subBeat2 = 7 * beatLength / 10;\n    \n    int barSamp = samp % barLength;\n    int beatSamp = samp % beatLength;\n    int localBeatIndex = ( samp / beatLength ) % 7;\n    int beatIndex = samp / beatLength;\n    \n    int barIndex = samp / barLength;\n    int index = ( ( barIndex & 3 )<<1 ) + ( barIndex & 8 );\n      \n    if( barIndex >= 16 && barIndex < 24 )\n    {\n        index= 0;\n        barIndex = 16;\n    }\n    \n    float prime1 = 120.0 * ratios[ primes[ index ] ];\n    float prime2 = 120.0 * ratios[ primes[ index + 1 ] ];\n    float third1 = 120.0 * ratios[ thirds[ index ] ];\n    float third2 = 120.0 * ratios[ thirds[ index + 1 ] ];\n    float seventh1 = 240.0 * ratios[ sevenths[ index ] ];\n    float seventh2 = 240.0 * ratios[ sevenths[ index + 1 ] ];\n    \n    vec2 stereo = vec2( .0 );\n    float mono = .0;\n    if( barIndex >= 8 && !( barIndex >= 24 && barIndex < 32 ) )\n    {\n        if( barIndex >= 32 && barIndex < 48 )\n        {\n            mono += kick( barSamp );\n            mono += hat( barSamp - beatLength * 2 );\n            mono += kick( barSamp - beatLength * 3);\n            mono += hat( barSamp - beatLength * 5 );\n            \n            if( ( barIndex & 8 ) == 8)\n            {\n                mono += kick( beatSamp - subBeat1) * ( 1. - .5 * float( localBeatIndex & 2 ) );\n            }\n            \n            mono += .1 * hat(( beatSamp ) * 1 ) * ( 1. - float( localBeatIndex & 1 ) );\n            mono += .1 * hat(( beatLength /2 - beatSamp - 6000) * 3 ) * ( 1. - float( localBeatIndex & 1 ) );\n        }\n        else\n        {\n            mono += kick( beatSamp ) * ( 1. - float( localBeatIndex & 1 ) );\n            mono += hat(beatSamp ) * float( localBeatIndex & 1 );\n            \n            mono += .1 * hat(( beatLength /2 - beatSamp - 6000) * 3 );\n            mono += .1 * hat(( beatSamp - beatLength /2 ) * 1 );\n        }\n       \n        mono += kick(-barSamp + beatLength * 13/2);\n        if( barIndex < 48 )\n        {\n            stereo += .3 * glass( prime1 * 1.5, beatSamp - subBeat1, 6000);\n            stereo += .3 * glass( prime1 * 2.0, beatSamp - subBeat2, 6000);\n        }\n    }\n\n    if( barIndex >= 6)\n    {    \n        mono += bass(.5 * prime1, barSamp, subBeat1 );\n        mono += bass(.5 * prime1, barSamp - beatLength - subBeat1, subBeat1 );\n        mono += bass(.75 * prime1, barSamp - 3 * beatLength - subBeat1, subBeat1 );\n        mono += bass(.375 * prime2, barSamp - 5 * beatLength - subBeat2, 6000 );\n    }\n    \n    int offset2 = ( 3 + ((barIndex >>1)& 1 ) ) * beatLength;\n    \n    float fade4th = float( 1 - (barIndex & 1) );\n    fade4th = max( fade4th, 1.0 - abs( float( (barIndex>>1) - 2)  ) );\n    float weight2nd = smoothstep( -20000.0, 20000.0, float( barSamp - offset2 ) );\n    float prime = weight2nd * (prime2 - prime1) + prime1;\n    float third = weight2nd * (third2 - third1) + third1;\n    float seventh = weight2nd * (seventh2 - seventh1) + seventh1;\n    \n    chord[ 0 ] = prime;\n    chord[ 1 ] = third;\n    chord[ 2 ] = prime * 1.489;\n    chord[ 3 ] = seventh;\n    chord[ 4 ] = third * 2.0;\n    \n    int microBeatLength = beatLength / 24;\n    int microBeatSamp = barSamp % microBeatLength;\n    int microBeatIndex = barSamp / microBeatLength;\n    if( barIndex >= 16 ) \n    {\n        float f = 2. * chord[ microBeatIndex % 5 ];\n        stereo += 0.02 * TONE( f, microBeatSamp ) * PAN(f)\n            * FADE_IN_LIN( 100, microBeatSamp)\n            * FADE_OUT_LIN( 100, microBeatSamp - microBeatLength + 200 ) \n            * sin( float(microBeatIndex ) * .05 );\n    }\n    stereo += 0.02 * ( \n        TONE( 1. * prime, barSamp ) +     \n        TONE( 1.01 * prime, barSamp )  \n        ) * PAN( prime )\n        \n    * FADE_IN_LIN( 100, barSamp)\n    * FADE_OUT_LIN( 100, barSamp - barLength + 200 );\n    \n    stereo += .125 * glass(chord[ beatIndex % 5 ] * 2., beatSamp - subBeat1 , subBeat1 );\n    stereo += .03125 * glass(chord[ ( beatIndex + 3 ) % 5 ] * 2., beatSamp - subBeat2 , subBeat2 );\n    stereo += .0625 * glass(chord[ ( beatIndex + 3 ) % 5 ] * 2., beatSamp - subBeat1/2 , subBeat2 );\n    \n    float painoLp = exp( 3.5 * clamp( float(samp) * .125 / float( barLength ), .0, 1.0 ) + 6.5);\n    if(barIndex == 16)\n    {\n        painoLp = exp( 3.5 * clamp( TONE( .04, samp) * .5 + .5, .0, 1.0 ) + 6.5);\n    }\n    else if ( barIndex >= 24 && barIndex < 40 )\n    {\n        painoLp = exp( 7.5 );\n    }\n    \n    stereo += .2 * pianoLP( prime1, barSamp, beatLength * 4 , painoLp);\n    stereo += .2 * pianoLP( prime2, barSamp - offset2, beatLength * 3, painoLp ) * fade4th;\n    stereo += .2 * pianoLP( third2, barSamp - offset2, beatLength * 2, painoLp ) * fade4th;\n    stereo += .05 * pianoLP( seventh1, barSamp - 2000, beatLength * 4, painoLp );\n    \n    return ( .6 * mono CENTER + stereo ) * clamp( .1 * ( 180. - time ), .0, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define INV_MUL(a,b) a=(1.0-(1.0-(a))*(1.0-(b)))\n\nfloat cylinderXY( vec3 pos, vec3 center,float radius, float width )\n{\n\n    vec3 diff = pos - center;\n    float val = 1.0 - (smoothstep( radius -.05, radius + .05, length( vec2(diff) ) ) );\n    float zDiff =  pos.z - center.z; \n    val *= 1.0 - (smoothstep( width -.05, width + .05, abs( diff.z ) ) );\n    return val;\n}\n\nfloat cylinderXY2( vec3 pos, vec3 center,float radius, float width )\n{\n\n    vec3 diff = pos - center;\n    float val = (smoothstep( radius -.05, radius + .05, length( vec2(diff) ) ) );\n    float zDiff =  pos.z - center.z; \n    val *= (smoothstep( width -.05, width + .05, abs( diff.z ) ) );\n    return val;\n}\n\nfloat sphere( vec3 pos, vec3 center,float radius )\n{\n    return 1.0 - (smoothstep( radius -.09, radius + .09, length( pos - center ) ) );\n}\nfloat sphere2( vec3 pos, vec3 center,float radius )\n{\n    return (smoothstep( radius -.09, radius + .09, length( pos - center ) ) );\n}\n\n\nvec3 centerHead;\nvec3 leftHeadphone;\nvec3 rightHeadphone;\nvec3 leftEarCenter;\nvec3 rightEarCenter;\nfloat headRadius;\nfloat headPhoneSize;\nfloat cylinderWidth;\nfloat cylinderRadius;\nfloat eyeSize;\nvec3 leftEye;\nvec3 rightEye;\nfloat faceFade;\nvec3 headScale;\nfloat frogify;\n\n\nfloat blob( vec3 pos )\n{\n    float outVal = 1.0;\n    pos = clamp( pos, vec3( -1.6 ), vec3( 1.6) );\n    vec3 frogHeadphoesPos = vec3(.0, .1, -.1 );//, -.2 * frogify, -.2 * frogify);\n    float cyl = cylinderXY( pos, frogHeadphoesPos, cylinderRadius, cylinderWidth );\n    cyl *= step( .1, pos.y);\n    outVal *= 1.0 - cyl;\n    outVal *= sphere2( pos, leftHeadphone + frogHeadphoesPos, headPhoneSize );\n    outVal *= sphere2( pos, rightHeadphone + frogHeadphoesPos, headPhoneSize );\n      \n    outVal += 10.0 * faceFade * sphere( pos, centerHead + frogify * vec3(.0, .2, .0) + frogHeadphoesPos, headRadius);\n    outVal = clamp( outVal, .0, 1.0 );\n    \n    \n    outVal *= sphere2( pos, leftEarCenter, .3 );\n    outVal *= sphere2( pos, rightEarCenter, .3 );\n    outVal *= sphere2( pos * headScale, centerHead, headRadius );\n    \n    outVal *= sphere2( pos * headScale, vec3( .0, .0, -.5 ), .2 );\n    \n    outVal += sphere( pos, rightEye - vec3(.0,.0,.09), eyeSize * faceFade );\n    outVal += sphere( pos, leftEye - vec3(.0,.0,.09), eyeSize * faceFade);\n    \n    outVal *= sphere2( pos, rightEye, eyeSize );\n    outVal *= sphere2( pos, leftEye, eyeSize );\n    return 1.0 - outVal;\n}\n\nvec3 color( vec3 pos )\n{\n    vec3 outVal = vec3( 1.0 - .9 * frogify, .1, .1 + .9 * frogify);\n    pos = clamp( pos, vec3( -1.0 ), vec3( 1.0) );\n    float bodyColMask = sphere( pos, centerHead,  headRadius );\n    INV_MUL(bodyColMask, sphere( pos, vec3( .0, .0, -.5 ), .2 ));\n    outVal += bodyColMask * vec3( .0 + .3 * frogify, .8 + .2 * frogify, .45 - 1.6 * frogify);\n    outVal += vec3( 1.0 ) * sphere( pos, rightEye, eyeSize );\n    outVal += vec3( 1.0 ) * sphere( pos, leftEye, eyeSize );\n    outVal -= vec3( 6.0, 2.5, .0 ) * sphere( pos, rightEye - vec3(.0,.02,.09), .05 * faceFade );\n    outVal -= vec3( 6.0, 2.5, .0 ) * sphere( pos, leftEye - vec3(.0,.02,.09), .05 * faceFade );\n    \n    \n    outVal -= vec3( 10.0 ) * sphere( pos, rightEye - vec3(.0,.02,.09), .01 * faceFade);\n    outVal -= vec3( 10.0 ) * sphere( pos, leftEye - vec3(.0,.02,.09),  .01 * faceFade);\n    \n    outVal = clamp( outVal, vec3( .0 ) , vec3( 1.0 ) );\n    return outVal;\n}\n\n#define GRAD_WIDTH .0001\nvec3 blobNormal( vec3 pos )\n{\n    float blobCenter = blob( pos );\n    float blobX = blob( pos + vec3( GRAD_WIDTH, .0, .0 ) );\n    float blobY = blob( pos + vec3( .0, GRAD_WIDTH, .0 ) );\n    float blobZ = blob( pos + vec3( .0, .0, GRAD_WIDTH ) );\n    vec3 grad = vec3( \n        blobCenter - blobX, \n        blobCenter - blobY, \n        blobCenter - blobZ );\n    return normalize( grad );\n    \n    \n}\n\nfloat noise21(vec2 inVal )\n{\n    return fract( \n    12312.0 * sin( inVal.x * 6549874.0 + iTime) + \n    12132.0 * sin( inVal.y * 6299874.0 - iTime ) );\n}\n\n\n#define STEP .05\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time  = iTime;// + 90.0;\n\n    float barLength = 160000. / 44100.;\n    float tBeat = fract( time / barLength )  * 7.;\n    float bob = fract( tBeat );\n    \n    bob = max( min( 40.0 * bob, 1.0 - 100. * bob * bob * bob), .0 );\n    if( time < 28.0 || ( time > 86.0 ) && time < 114.0 )\n    {\n        bob = .0;\n    }\n    float beat7th = max( .0, ( tBeat - 6.0 ) * ( 7.0 - tBeat ) );\n\n\n    float peacesFade = clamp( 4.0 - time / 7.5, .0, 1.) + .05 * sin( time );\n    float phase = time * min( .3, time / 100.0 );\n    peacesFade = max( peacesFade, ( 10.0 * sin( time * .3 ) - 9.0 ) * .6 );\n    peacesFade = max( peacesFade, beat7th );\n    \n    \n    \n    frogify = clamp( ( time - 60.0f ) * .05,.0, 1.0 );\n    peacesFade += ( frogify * ( 1.0 - frogify ) );\n    \n    headScale = vec3( 1.0, 1.0 + frogify, 1.0 + frogify * .3 );\n    centerHead = vec3( .0, -.2 * frogify, -.2 * frogify ) + peacesFade * vec3( \n        .5 * sin( phase * 1.234 + 12.),\n        .5 * sin( phase * 3.234 + 15.),\n        .5 * sin( phase * 2.234 + 14.)\n        );\n    leftHeadphone = vec3( .4, .0, .0 )  + peacesFade * vec3( \n        .5 * sin( phase * 1.432 + 61.),\n        .5 * sin( phase * 2.234 + 82.),\n        .3 * sin( phase * 5.234 + 65.)\n        );\n    rightHeadphone = vec3( -.4, .0, .0 )  + peacesFade * vec3( \n        .5 * sin( phase * 2.1 + 21.),\n        .2 * sin( phase * 2.9 + 3.5),\n        .5 * sin( phase * 4.8 + 69.)\n        );\n    leftEarCenter = vec3( .4 - frogify * .3, .0, .0 )  + peacesFade * vec3( \n        .3 * sin( phase * 2.432 + 11.),\n        .5 * sin( phase * 3.234 + 92.),\n        .5 * sin( phase * 5.234 + 15.)\n        );     \n    rightEarCenter = vec3( -.4 + frogify * .3, .0, .0 )  + peacesFade * vec3( \n        .5 * sin( phase * 2.432 + 61.),\n        .2 * sin( phase * 3.234 + 82.),\n        .5 * sin( phase * 1.234 + 65.)\n        );    \n    leftEye = vec3( .2, .2 + .1 * frogify, -.41 + .3 * frogify )  + peacesFade * vec3( \n        .5 * sin( phase * 1.832 + 61.),\n        .6 * sin( phase * 5.134 + 81.),\n        .4 * sin( phase * 1.634 + 63.)\n        );\n    rightEye = vec3( -.2, .2 + .1 * frogify, -.41 + .3 * frogify )  + peacesFade * vec3( \n        .4 * sin( phase * 6.832 + 11.),\n        .3 * sin( phase * 1.134 + 21.),\n        .2 * sin( phase * 2.634 - 63.)\n        );        \n    headRadius = .6 - .4 * peacesFade;\n    headPhoneSize = .4 - .2 * peacesFade + bob * .03;\n    cylinderWidth = .1 - .3 * peacesFade;\n    cylinderRadius = .75 - .75 * peacesFade;\n    eyeSize = .1 + .1 * peacesFade + .05 *frogify;\n    faceFade = 1.0 - peacesFade;\n\n    float rotTime = 2.* time + 1.5 * sin( time * .5 );\n    vec2 uv = ( fragCoord - vec2( (iResolution.x - iResolution.y) * .5, 0 ) )/iResolution.y - vec2( .5 );\n    float ang = .9 * sin( time * .5 ) + 1.5;\n    vec3 center = vec3( -2.0 * cos( ang ), .0, -2.0 * sin( ang ) );\n    vec3 top = vec3( .0, 1., .0 );\n    center += top * .3;\n    vec3 front = -.5 * center;\n    vec3 side = vec3( front.z, .0, -front.x );\n    \n    vec3 ray = normalize( uv.x * side + uv.y * top + front );\n    vec3 lightPos = center + side + 2.0 * top;\n    \n    float foundDist = -2.0;\n    float dist = 1.2 + noise21( uv ) * STEP;\n    float accum = .0;\n    \n    while( dist < 2.6)\n    {\n    \n        vec3 probe = center + ray * dist;\n        float val = blob( probe );\n        if( val > .5)\n        {\n            foundDist = dist;\n            break;\n        }\n        accum += val;\n        if( accum > 6.0 )\n        {\n            fragColor = vec4(.0f, .0f, .0f,1.0);\n            return;\n        }\n        dist += STEP;\n    }\n    if( foundDist > .0 )\n    {\n        float step = STEP * .5 * (1.0 + .1 * noise21(uv * .3));\n        vec3 probe;\n        for( int i = 0; i < 4; ++i )\n        {\n            float newDist = foundDist - step;\n            probe = center + ray * newDist;\n            if( blob( probe) > .5 )\n            {\n                foundDist = newDist;\n            }\n            step *= .5;\n        \n        }\n        vec3 lightDir = normalize(lightPos - probe);\n        \n      \n        vec3 normal = blobNormal( probe );\n        float diffuse = clamp( dot( normal, lightDir ), .1, 1.0 );\n        diffuse = .25 + .5 * smoothstep( .2, .3, diffuse ) + + .25 * smoothstep( .8, .9, diffuse ) ;\n        \n        vec3 shadowStep = lightDir * .01;\n        vec3 shadowProbe = probe;\n        for( int i = 0; i < 30; ++i )\n        {\n            shadowProbe += shadowStep;\n            if( blob( shadowProbe ) > .5 )\n            {\n                diffuse = .25;\n                break;\n            }\n           \n        }\n       \n        fragColor = vec4( color( probe ) *  diffuse, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(vec3(1.0 - vec3( .4, .6, .5) * frogify),1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}