{
    "Shader": {
        "info": {
            "date": "1719029886",
            "description": "robot vacuum.\nJust wasting away my retirement.",
            "flags": 48,
            "hasliked": 0,
            "id": "M3tXz7",
            "likes": 7,
            "name": "Roomba",
            "published": 3,
            "tags": [
                "robotvacuum"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 84
        },
        "renderpass": [
            {
                "code": "// ===================================\n// Key commands:\n//\n// <Space>  Reset\n// <1>  Enter spiral mode\n// <2>  Enter square mode\n// ===================================\n\nvoid drawRoomba(inout vec4 fragColor,in vec2 fragCoord) {\n    const float d1 = 18.;\n    const float d2 = 28.;\n    const float d3 = 40.;\n    \n    float dist = length(fragCoord - position);\n    if(dist > RSIZE) return;\n    \n    vec3 col = vec3(0.);\n    \n    if(dist > d1) col = vec3(0.2,0.8,0.6);\n    if(dist > d2 && dist < d3)  col = vec3(0.4,0.5,0.96);\n    if(abs(dist-d2) < 1. || abs(dist-d3) < 1.) col = vec3(0.);\n    if(abs(dist-RSIZE) < 3.) col = vec3(1.,0.7,0.);\n    \n    if(dist < d1) {\n        if(state == STATE_MOVING)   col = vec3(0.,1.,0.);\n        if(state == STATE_ROTATING) col = vec3(1.,0.,0.);\n        if(state == STATE_SPIRAL)   col = vec3(1.,0.,1.);\n        if(state == STATE_SQUARE)   col = vec3(1.,1.,0.);\n    }\n    \n    if(abs(dist-d1) < 1.) col = vec3(0.);\n    \n    vec2 pt = position + vec2(cos(angle)*38.,sin(angle)*38.);\n    dist = length(fragCoord - pt);\n    if(dist < 8.) col = vec3(0.);\n  \n    fragColor = vec4(col,1.0);\n}\n\n// ---------------------------------------------------\n\nvoid drawBackground(inout vec4 fragColor,in vec2 fragCoord) {\n    // screen coord -> grid\n    fragCoord = (fragCoord - vec2(0.5))/iResolution.xy;\n    ivec2 addr = ivec2(0);\n    addr.x += int(float(GRIDX) * fragCoord.x);\n    addr.y += int(float(GRIDY) * fragCoord.y);\n         \n    vec3 v = fetchData(iChannel0, addr).xyz;\n    fragColor = vec4(v,1.);\n}\n\n// ---------------------------------------------------\n\nvoid getStoredData() { \n    for(int i=0;i<ADDR_COUNT;++i)\n        data[i] = fetchData(iChannel0, addrList[i]).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    getStoredData();\n\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor.xyz = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    drawBackground(fragColor,fragCoord);\n    drawRoomba(fragColor,fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ----------------------------------------------------------\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT  = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT  = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\n// ----------------------------------------------------------\n\nvec2 rseed = vec2(12.9898, 78.233);\n\nfloat frandom() { // 0...1\n    float v = sin(dot(rseed, vec2(12.9898, 78.233))) * 43758.5453;\n    rseed.x = rseed.y + iTime;\n    rseed.y = v - float(iFrame);\n\treturn fract(v);\n}\n\nint irandom(int max) {\n    return int(float(max) * frandom());\n}\n\nbool randomChance(float ratio) {\n    return frandom( ) <= ratio;\n}\n\n// ----------------------------------------------------------\n\nvoid getStoredData() { \n    for(int i=0;i<ADDR_COUNT;++i)\n        data[i] = fetchData(iChannel0, addrList[i]).xyz;\n}\n\nvoid updateStoredData(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor.xyz = data[i];\n            return;\n        }\n}\n\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    state = float(STATE_MOVING);\n    position = vec2(iResolution.x/2.,iResolution.y/2.);\n    angle = 1.;\n    angleDelta = 0.01;\n    \n    updateStoredData(fragColor,fragCoord);\n}\n\n// ----------------------------------------------------------\n\nconst int WIDTH = 2;\n\nvoid rectangle(int x1,int y1,int x2,int y2,inout vec4 fragColor,vec2 fragCoord) {\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if((abs(x-x1-WIDTH)<WIDTH || abs(x-x2-WIDTH)<WIDTH) && y >= y1 && y < y2) {\n        fragColor = vec4(1.);\n        return;\n    }\n\n    if((abs(y-y1)<WIDTH || abs(y-y2)<WIDTH) && x > x1 && x < x2+WIDTH*2) {\n        fragColor = vec4(1.);\n        return;\n    }\n\n    // room interior\n    if(x > x1 && x <= x2 && y > y1 && y < y2) \n       fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n}\n\nvoid vLine(int x1,int y1,int y2,inout vec4 fragColor,vec2 fragCoord) {\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    if(x > x1 && x < x1+WIDTH*2 && y >= y1+WIDTH && y < y2-1) \n       fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n}\n\n// ----------------------------------------------------------\n\nvoid layoutRooms(inout vec4 fragColor,vec2 fragCoord) {\n    // background\n    for(int x=0;x<GRIDX;++x) \n        for(int y=0;y<GRIDY;++y)\n            if(storeDataAddr(fragCoord,ivec2(x,y))) \n                fragColor = vec4(0.5,0.3,0.2,1.);\n    int x1 = 3;\n    int x2 = 100 + irandom(30);\n    int x3 = x2 + 100 + irandom(30);\n    int x4 = GRIDX-6-WIDTH;\n    int y1 = 5;\n    int y2 = 30 + irandom(50);\n    int y3 = GRIDY - 40 - irandom(50);\n    int y4 = GRIDY-5;\n      \n    rectangle(x1,y1,x2,y3,fragColor,fragCoord);\n    rectangle(x2,y2,x3,y4,fragColor,fragCoord);\n    rectangle(x3,y1,x4,y3,fragColor,fragCoord);\n    vLine(x2,y2,y3,fragColor,fragCoord);\n    vLine(x3,y2,y3,fragColor,fragCoord);    \n}\n\n// ----------------------------------------------------------\n\nvoid cleanDirt(inout vec4 fragColor,vec2 fragCoord) {\n    // only affect grid area, and only when roomba is traveling\n    if(fragCoord.x > float(GRIDX) || fragCoord.y > float(GRIDY)) return;\n    if(state == STATE_ROTATING) return;\n    \n    // screen coordinate -> grid\n    vec2 pt = vec2(fragCoord.x * iResolution.x / float(GRIDX),fragCoord.y * iResolution.y / float(GRIDY));\n    \n    // affect only region under roomba\n    float dist = length(pt - position);\n    if(dist > RSIZE) return;\n    \n    // slowly tend toward light grey \n    fragColor.x -= (fragColor.x - 0.85) * 0.03;\n    fragColor.y -= (fragColor.y - 0.85) * 0.03;\n    fragColor.z -= (fragColor.z - 0.85) * 0.03;\n}\n\n// ----------------------------------------------------------\n\n// Not touching a wall\nbool isLegalPosition2(int x,int y) {\n    vec3 col = fetchData(iChannel0, ivec2(x,y)).xyz;\n    return(col.x < 0.9 );\n}\n\nbool isLegalPosition(float x,float y) {\n    // screen coord -> grid\n    int ix = int(float(GRIDX) * x / iResolution.x);\n    int iy = int(float(GRIDY) * y / iResolution.y);\n    \n    if(!isLegalPosition2(ix-LSIZE,iy)) return false;\n    if(!isLegalPosition2(ix+LSIZE,iy)) return false;\n    if(!isLegalPosition2(ix,iy-LSIZE)) return false;\n    return(isLegalPosition2(ix,iy+LSIZE));\n}\n\n// ----------------------------------------------------------\n\nvoid enterSpiralMode() {\n    if(state != STATE_SPIRAL) {\n        state = STATE_SPIRAL;\n        spiralAngle = 0.6;\n        spiralDeltaRatio = 0.98;\n    }\n}\n\nconst float squareHop = 20.;\n\nvoid squareTurn() {\n    squareState = STATE_ROTATING;\n    squareDistance += squareHop;\n    squareOldPos = position;\n\tnewAngle = clampRadian(angle + PI * 0.5);\n}\n\nvoid enterSquareMode() {\n    if(state != STATE_SQUARE) {\n        state = STATE_SQUARE;\n\t\tsquareDistance = squareHop;\n\t\tsquareTurn();\n    }\n}\n\nbool rotateToNewAngle() {\n\tfloat deltaAngle = newAngle - angle;\n\tif (deltaAngle > 0.4) deltaAngle = 0.4;\n\telse if (deltaAngle < -0.4) deltaAngle = -0.4;\n\n\tangle = clampRadian(angle + deltaAngle);\n\n    if (abs(newAngle - angle) < 0.6) {\n        angle = newAngle;\n        return true;\n    }\n\n    return false;\n}\n\nvoid moveInCurrentDirection() {\n    float nx = position.x + cos(angle) * SPEED;\n    float ny = position.y + sin(angle) * SPEED;\n\n    if(isLegalPosition(nx,ny)) \n        position = vec2(nx,ny);\n    else {\n        state = STATE_ROTATING;\n        angleDelta = 0.1 + frandom() * 0.02;\n        if(randomChance(0.5)) angleDelta = -angleDelta;\n    }\n\n    if(state == STATE_MOVING && iFrame > 30) {\n        if((iFrame % 700) == 0) enterSpiralMode();            \n        if((iFrame % 1200) == 0) enterSquareMode();   \n    }\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor.xyz = fetchData(iChannel0, ivec2(fragCoord)).xyz;\n    getStoredData();\n\n    if(iFrame == 30 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        layoutRooms(fragColor, fragCoord);\n    }\n    \n    if(keyClick(49)) enterSpiralMode(); // '1'\n    if(keyClick(50)) enterSquareMode(); // '2'\n  \n    if(int(fragCoord.y) == P0_ADDR.y) {\n        if(state == STATE_MOVING || state == STATE_SPIRAL) {\n            moveInCurrentDirection();\n            cleanDirt(fragColor,fragCoord);\n        }\n\n        if(state == STATE_ROTATING) {\n            angle += angleDelta ;\n            if(angle < 0.) angle += PI2; else if(angle >= PI2) angle -= PI2;\n            float dx = cos(angle) * SPEED;\n            float dy = sin(angle) * SPEED;\n            float nx = position.x + dx;\n            float ny = position.y + dy;\n\n            if(isLegalPosition(nx,ny)) \n                state = STATE_MOVING;\n        }\n        \n        if(state == STATE_SPIRAL) {\n            if((iFrame % 5) == 0) {\n                angle = clampRadian(angle + spiralAngle);\n                spiralAngle *= spiralDeltaRatio;\n                spiralDeltaRatio *= 1.00011;\n                if (abs(spiralAngle) < 0.01) state = STATE_MOVING;\n                if (spiralDeltaRatio > 1.) state = STATE_MOVING;\n\t\t\t}\n        }\n                \n\t\tif (state == STATE_SQUARE) {\n\t\t\tif (squareState == STATE_ROTATING) {\n\t\t\t\tif (rotateToNewAngle()) \n\t\t\t\t\tsquareState = STATE_MOVING;\n\t\t\t}\n\n\t\t\tif (squareState == STATE_MOVING) {\n\t\t\t\tmoveInCurrentDirection();\n                if(state == STATE_SQUARE) \n                    if(length(position - squareOldPos) >= squareDistance)\n                        squareTurn();\n\t\t\t}\n       \n       } \n        \n    } \n    else\n       cleanDirt(fragColor,fragCoord);\n\n    updateStoredData(fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define STATE_MOVING   1.\n#define STATE_ROTATING 2.\n#define STATE_SPIRAL   3.\n#define STATE_SQUARE   4.\n\n#define RSIZE 50. // physical roomba size\n#define LSIZE 12 // logical roomba size\n#define SPEED 5.\n\n#define PI 3.141592654\n#define PI2 (PI * 2.0)\n\nfloat clampRadian(float v) {\n\tif (v < 0.) v += PI2;\n\telse if (v >= PI2) v -= PI2;\n\treturn v;\n}\n\n// ------------------------------------------------\n\n#define GRIDX 350\n#define GRIDY 200\n// grid stored 0,0 ... GRIDX-1,GRIDY-1\n\nconst ivec2 P0_ADDR =  ivec2( 0,GRIDY+1);\nconst ivec2 P1_ADDR =  ivec2( 1,GRIDY+1);\nconst ivec2 P2_ADDR =  ivec2( 2,GRIDY+1);\nconst ivec2 P3_ADDR =  ivec2( 3,GRIDY+1);\nconst ivec2 P4_ADDR =  ivec2( 4,GRIDY+1);\nconst int ADDR_COUNT = 5;\n\nconst ivec2[ADDR_COUNT] addrList = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ------------------------------------------------\n\nvec3[ADDR_COUNT] data;\n\n#define state            data[0].x\n#define position         data[0].yz\n#define angle            data[1].x\n#define angleDelta       data[1].y\n#define spiralAngle      data[1].z\n#define spiralDeltaRatio data[2].x\n#define squareDistance   data[2].y\n#define squareState      data[2].z\n#define squareOldPos     data[3].xy\n#define newAngle         data[3].z\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}