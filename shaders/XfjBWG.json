{
    "Shader": {
        "info": {
            "date": "1725478735",
            "description": "Just reinventing all of the wheels ;) Made by Rik Riesmeijer, 2024 - CC0 / Copyright-Free. At a quick glance you can see that nothing is highlighted, that is because no such functions are in use here.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjBWG",
            "likes": 1,
            "name": "Trig From Scatch:Fl/*U/I/Fn/Mads",
            "published": 3,
            "tags": [
                "glsl",
                "fun",
                "experimental",
                "trig",
                "cc0",
                "scratch",
                "atomic",
                "alternative",
                "restrictive"
            ],
            "usePreview": 0,
            "username": "rikr",
            "viewed": 66
        },
        "renderpass": [
            {
                "code": "// Trig From Scatch:Fl/*U/I/Fn/Mads\n// Made by Rik Riesmeijer, 2024 - CC0.\n//\n// Yep.. I built up a bunch of trig and general WebGl functions,\n// but basically this is only using atomic type instructions.\n// I thought it would be a fun way to get an idea of how demanding\n// different standard functions might be uintuitively after remaking them.\n//\n// I want to keep improving this shader to make it nice and handy for other\n// GLSL tinkering novices or otherwise.\n//\n// Features implemented here:\n//   + Mathematical set notation macros.                                    (named: Z for integers, N for natural numbers, R for reals)\n//   + Short variable casting macros.                                       (named: f, f1, f2, for floats and floatvecs etc.)\n//   + Dimensional parameter propagation macros.                            (named: pr + dim)\n//   + Short macros for useful constants.                                   (named: O for 0, I for 1, H for .5, D for double(2))\n//   + Short trig constant macros.                                          (named: half pi is ppi (sym), pii for 2pi (hehe, roman numerals)\n//   + Vectorized versions of macro constants.                              (named: pi2 for 2d, etc.)\n//   + Recursive addition for doubling, quadrupling and octupling.          (named: t, q, o (As in: twice, quadruple, octuple))\n//   + Vectorized versions of recusive doubling, quadrupling and octupling. (named: t2, t3, etc.)\n//   + Halfing functions.                                                   (named: h1, etc (As in: halfed/half))\n//   + Pointer reinterpretation macros.                                     (named: bXxY, like the tuples sampled in bijecting)\n//   + Absolute function that only uses rd, mul and div.                    (named: a)\n//   + Sign function from elementary abolute.                               (named: s)\n//   + Positive sign indicator function from elementary sign.               (named: p)\n//   + Maximum and minimum from elementary abs and mad.                     (named: g(i.e.: Greatest), l(i.e.: Least))\n//   + Clamp from elementary max and min.                                   (named: cl)\n//   + Fractional remainder from cast and sub.                              (named: r)\n//   + Tiplet mad function.                                                 (named: m)\n//   + Saturate from clamp.                                                 (named: sa)\n//   + Sine from differential remainder and triplet mad product.            (named: si)\n//   + Cosine from sine.                                                    (named: co)\n//   + Tangent from sine div cosine.                                        (named: ta)\n//   + Mix from elementary mads.                                            (named: mi)\n//   + Smoothstep from sine and clamp interpolation normalized with mads.   (named: smst)\n//   + Anti aliased comparison indicator function from smoothstep.          (named: cmp)\n//   + Almost all functions vectorized fully.                               (named: function + dimensionality)\n//\n// Any suggestions? Please comment if so..\n// Have fun if you're going to have a look, feel free to ask anything here in the comments!\n//\n// ~ Cheers, Rik ;)\n//\n\n#define f  float\n#define f1 float\n#define f2 vec2\n#define f3 vec3\n#define f4 vec4\n\n#define pr1(sclf, v) (f(sclf(v)))\n#define pr2(sclf, v) (f2(pr1(sclf, (v).x  ), sclf((v).y)))\n#define pr3(sclf, v) (f3(pr2(sclf, (v).xy ), sclf((v).z)))\n#define pr4(sclf, v) (f4(pr3(sclf, (v).xyz), sclf((v).w)))\n\n#define N     uint\n#define Z      int\n#define R    float\n#define NxN  uvec2\n#define ZxZ  ivec2\n#define RxR   vec2\n#define N3   uvec3\n#define Z3   ivec3\n#define R3    vec3\n#define N4   uvec4\n#define Z4   ivec4\n#define R4    vec4\n\n#define bRxN floatBitsToUint\n#define bRxZ  floatBitsToInt\n#define bNxR uintBitsToFloat\n#define bZxR  intBitsToFloat\n\n#define pi  3.14\n#define pii 6.28\n#define ppi 1.57\n#define H   0.50\n#define O   0.00\n#define I   1.00\n#define D   2.00\n\n#define O2 f2(0)\n#define I2 f2(1)\n#define H2 f2(H)\n#define D2 f2(D)\n#define O3 f3(0)\n#define I3 f3(1)\n#define H3 f3(H)\n#define D3 f3(D)\n#define O4 f4(0)\n#define I4 f4(1)\n#define H4 f4(H)\n#define D4 f4(D)\n\n#define pi2  f2(pi )\n#define pi3  f3(pi )\n#define pi4  f4(pi )\n#define pii2 f2(pii)\n#define pii3 f3(pii)\n#define pii4 f4(pii)\n#define ppi2 f2(ppi)\n#define ppi3 f3(ppi)\n#define ppi4 f4(ppi)\n\nf  t1(f  v) { return   (v + v); }\nf  q1(f  v) { return t1(v + v); }\nf  o1(f  v) { return q1(v + v); }\nf  h1(f  v) { return   (H * v); }\nf2 t2(f2 v) { return   (v + v); }\nf2 q2(f2 v) { return t2(v + v); }\nf2 o2(f2 v) { return q2(v + v); }\nf2 h2(f2 v) { return   (H * v); }\nf3 t3(f3 v) { return   (v + v); }\nf3 q3(f3 v) { return t3(v + v); }\nf3 o3(f3 v) { return q3(v + v); }\nf3 h3(f3 v) { return   (H * v); }\nf4 t4(f4 v) { return   (v + v); }\nf4 q4(f4 v) { return t4(v + v); }\nf4 o4(f4 v) { return q4(v + v); }\nf4 h4(f4 v) { return   (H * v); }\n\nf a1(f v) { return bNxR(bRxN(v) * 2u / 2u); }\nf s1(f v) { return v / a1(v); }\nf p1(f v) { return H * s1(v) + H; }\n\nf2 p2(f2 v) { return pr2(p1, (v)); }\nf2 s2(f2 v) { return pr2(s1, (v)); }\nf2 a2(f2 v) { return pr2(a1, (v)); }\nf3 p3(f3 v) { return pr3(p1, (v)); }\nf3 s3(f3 v) { return pr3(s1, (v)); }\nf3 a3(f3 v) { return pr3(a1, (v)); }\nf4 p4(f4 v) { return pr4(p1, (v)); }\nf4 s4(f4 v) { return pr4(s1, (v)); }\nf4 a4(f4 v) { return pr4(a1, (v)); }\n\nf  r1(f  v) { return v - f (  Z(v)); }\nf2 r2(f2 v) { return v - f2(ZxZ(v)); }\nf3 r3(f3 v) { return v - f3( Z3(v)); }\nf4 r4(f4 v) { return v - f4( Z4(v)); }\n\nf  m1(f  v) { return v + v * v; }\nf2 m2(f2 v) { return v + v * v; }\nf3 m3(f3 v) { return v + v * v; }\nf4 m4(f4 v) { return v + v * v; }\n\nf  g1(f  x, f  y) { return h1(a1(x - y) + x + y); }\nf2 g2(f2 x, f2 y) { return h2(a2(x - y) + x + y); }\nf3 g3(f3 x, f3 y) { return h3(a3(x - y) + x + y); }\nf4 g4(f4 x, f4 y) { return h4(a4(x - y) + x + y); }\n\nf  l1(f  x, f  y) { return -g1(-x, -y); }\nf2 l2(f2 x, f2 y) { return -g2(-x, -y); }\nf3 l3(f3 x, f3 y) { return -g3(-x, -y); }\nf4 l4(f4 x, f4 y) { return -g4(-x, -y); }\n\nf  cl(f  x, f  y, f  z) { return l1(y, g1(x, z)); }\nf2 cl(f2 x, f2 y, f2 z) { return l2(y, g2(x, z)); }\nf3 cl(f3 x, f3 y, f3 z) { return l3(y, g3(x, z)); }\nf4 cl(f4 x, f4 y, f4 z) { return l4(y, g4(x, z)); }\n\nf  sa(f  v) { return cl(O,  I , v); }\nf2 sa(f2 v) { return cl(O2, I2, v); }\nf3 sa(f3 v) { return cl(O3, I3, v); }\nf4 sa(f4 v) { return cl(O4, I4, v); }\n\nf  si(f  v) { return m1(r1(v = v / pi - D)) * o1(-r1(v *= H) + r1(v - H)); }\nf2 si(f2 v) { return m2(r2(v = v / pi - D)) * o2(-r2(v *= H) + r2(v - H)); }\nf3 si(f3 v) { return m3(r3(v = v / pi - D)) * o3(-r3(v *= H) + r3(v - H)); }\nf4 si(f4 v) { return m4(r4(v = v / pi - D)) * o4(-r4(v *= H) + r4(v - H)); }\n\nf  co(f  v) { return si(v - ppi); }\nf2 co(f2 v) { return si(v - ppi); }\nf3 co(f3 v) { return si(v - ppi); }\nf4 co(f4 v) { return si(v - ppi); }\n\nf  ta(f  v) { return si(v) / co(v); }\nf2 ta(f2 v) { return si(v) / co(v); }\nf3 ta(f3 v) { return si(v) / co(v); }\nf4 ta(f4 v) { return si(v) / co(v); }\n\nf  mi(f  x, f  y, f  z) { z = cl(O,  I , z); return z * x + y - z * y; }\nf2 mi(f2 x, f2 y, f2 z) { z = cl(O2, I2, z); return z * x + y - z * y; }\nf3 mi(f3 x, f3 y, f3 z) { z = cl(O3, I3, z); return z * x + y - z * y; }\nf4 mi(f4 x, f4 y, f4 z) { z = cl(O4, I4, z); return z * x + y - z * y; }\n\nf smst(f low, f high, f v) {\n    v *= a1(high - low);\n    f res = low * H  + h1(a1(high - low));\n    return res * si(cl(-ppi, ppi, v * -pi + ppi));\n}\n\nf2 smst(f2 low, f2 high, f2 v) {\n    v *= a2(high - low);\n    f2 res = low * H2 + h2(a2(high - low));\n    return res * si(cl(-ppi2, ppi2, v * -pi2 + ppi2));\n}\n\nf3 smst(f3 low, f3 high, f3 v) {\n    v *= a3(high - low);\n    f3 res = low * H3 + h3(a3(high - low));\n    return res * si(cl(-ppi3, ppi3, v * -pi3 + ppi3));\n}\n\nf4 smst(f4 low, f4 high, f4 v) {\n    v *= a4(high - low);\n    f4 res = low * H4 + h4(a4(high - low));\n    return res * si(cl(-ppi4, ppi4, v * -pi4 + ppi4));\n}\n\nf cmp(f x, f y) { x = smst(O, I, y + H - x); return cl(O, I, I / x); }\n\nf bval(f2 v) { return cmp(ta(si(v.x - H * iTime) - si(-iTime) / pi), v.y); }\nf gval(f2 v) { return cmp(co(v.x), v.y); }\nf rval(f2 v) { return cmp(v.y, f(smst(co(-iTime) * H + H, I, v.x))); }\n\nvoid mainImage(out f4 c, f2 v) {\n    v     = v / iResolution.xy - 0.5;\n    v    += v;\n    f2 w  = v * pii;\n    v.x  += H;\n    f2 u  = v;\n    u.x  -= iTime / pii;\n    v.x  -= H * si(-q1(iTime));\n    c = vec4(rval(v), gval(u), bval(w), I);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}