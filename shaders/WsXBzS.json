{
    "Shader": {
        "info": {
            "date": "1588718200",
            "description": "A strange museum with strange objects. Ticket is 50$.",
            "flags": 64,
            "hasliked": 0,
            "id": "WsXBzS",
            "likes": 19,
            "name": "Demoscene museum",
            "published": 3,
            "tags": [
                "metaballs",
                "refraction",
                "plasma",
                "demoscene"
            ],
            "usePreview": 1,
            "username": "friol",
            "viewed": 1119
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// Now that the demoscene is cultural heritage of humanity (at least in Finland)\n// I imagined how a demoscene museum would look like and what would would you find in there\n// sdf functions&ao by iq\n// plasma cube inspiration from patu https://www.shadertoy.com/view/4d3SRN\n// some materials taken from https://www.shadertoy.com/view/WslfD7\n// music by Salidad -> https://soundcloud.com/salidad\n//\n\nconst int iterationAmount=1024*3;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdAmigahSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTwistingBox( vec3 p, vec3 b, float r )\n{\n\tp=rotx(p,2.0*sin(iTime)*sin(.92*p.x+iTime/2.0));\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlasmaCube( vec3 p, vec3 b, vec3 shift )\n{\n  p=rotx(p,iTime);\n  p=roty(p,iTime);\n  p+=shift;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  p=roty(p,iTime+3.141592/2.0);\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n#define FK(k) int(cos(k))*int(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat noise(vec2 p) \n{\n    vec2 id = floor(p);\n    vec2 crds = fract(p);\n    float h1 = hash(id.x,id.y);\n    float h2 = hash(id.x+1.,id.y);\n    float h3 = hash(id.x,id.y+1.);\n    float h4 = hash(id.x+1.,id.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat triplanar(vec3 p, vec3 n) \n{\n    return mix(noise(p.xy), mix(noise(p.xz), noise(p.yz), n.x*n.x), 1.-n.z*n.z);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//\n//\n//\n\nfloat mapBin(vec3 r)\n{\n    //r*=1.55;\n\tfloat mainCone=sdCappedCone(r-vec3(0.0,-0.4,0.0),.6,  0.5,0.7);\n    float innerCone=sdCappedCone(r-vec3(0.0,-0.25,0.0),.55,0.45,0.65);\n    float t=opSubtraction(innerCone,mainCone);\n    //float t=100.0;\n    \n    vec3 capsr=r;\n    \n    const float PI=3.141592;\n    const float TWOPI=PI*2.0;\n    for (float i=0.0;i<TWOPI;i+=PI/18.0)\n    {\n        vec3 realcapsr=roty(capsr,i);\n    \trealcapsr=rotz(realcapsr,-0.15);\n        float caps=sdVerticalCapsule(realcapsr-vec3(0.60,-0.63,0.0),0.9,0.06);\n        t=opSubtraction(caps,t);\n        //t=min(t,caps);\n    }\n\n    return t;\n}\n\nfloat mapDemosceneLogo(vec3 r)\n{\n    //r*=1.55;\n    float t=10000.0;\n    \n    r=rotx(r,0.25);\n    r=rotz(r,-0.5);\n    \n    float spessore=0.05;\n    \n    float horz1=sdBox(r-vec3(0.0,0.85,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz1);\n    float horz2=sdBox(r-vec3(0.0,0.6,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz2);\n    float horz3=sdBox(r-vec3(0.0,0.35,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz3);\n    \n    float vertleft=sdBox(r-vec3(-0.25,0.80,0.0),vec3(spessore,0.25,spessore));\n    t=min(t,vertleft);\n    float vertright=sdBox(r-vec3(0.25,0.80,0.0),vec3(spessore,0.25,spessore));\n    t=min(t,vertright);\n    float vertcenter=sdBox(r-vec3(0.0,0.25,0.0),vec3(spessore,0.3,spessore));\n    t=min(t,vertcenter);\n    \n    return t;\n}\n\n// returns: t, material, hit type (0.0 solid, 1.0 transparent)\n\nvec3 SDF(vec3 r)\n{\n    float amt=9.0; // bump amount on glass panels\n    float t=0.0;\n    float mat=0.0;\n    vec3 origR=r;\n\n    vec3 boxR=r-vec3(0.0,0.0,0.0);\n    t=sdInvertedBox(boxR,vec3(4.0,2.5,35.0));\n    \n    //float domainRep=3.7;\n    //vec3 c=vec3(domainRep);\n    //r = mod(r+0.5*c,c)-0.5*c;\n    \n    // little boxes+balls at the entrance\n    float pyrh=1.1;\n    float pyr1=sdBox(r-vec3(3.0,-2.5,-5.0),vec3(.55,0.25,0.55));\n    t=min(t,pyr1);\n    \n    float pyr2=sdBox(r-vec3(-3.0,-2.5,-5.0),vec3(.55,0.25,0.55));\n    t=min(t,pyr2);\n\n    float container1=sdRoundBox(r-vec3(3.0,-1.7,-5.0),vec3(.5,.5,.5),0.1);\n    float innerBox1=sdBox(r-vec3(3.0,-1.7,-5.0),vec3(.49));\n    container1=opSubtraction(innerBox1,container1);\n    t=min(t,container1);\n\n    float container2=sdRoundBox(r-vec3(-3.0,-1.7,-5.0),vec3(.5,.5,.5),0.1);\n    float innerBox2=sdBox(r-vec3(-3.0,-1.7,-5.0),vec3(.49));\n    container2=opSubtraction(innerBox2,container2);\n    t=min(t,container2);\n    \n    float amigaball1=sdAmigahSphere(r-vec3(3.0,-1.7+0.05*sin(iTime*2.0),-5.0),0.45);\n    t=min(t,amigaball1);\n\n    float amigaball2=sdAmigahSphere(r-vec3(-3.0,-1.7+0.05*sin(iTime*2.0),-5.0),0.45);\n    t=min(t,amigaball2);\n    \n    // metaballs\n    \n    float mbz=11.0;\n    float mbally=0.0;\n    if (iTime>32.0) mbally=(iTime-32.0)/2.5;\n    \n    float backS=sdSphere(r-vec3(1.7*sin(iTime),-.7*sin(iTime)+mbally,mbz),.76);\n    backS+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n\n    float backS2=sdSphere(r-vec3(-1.0*cos(iTime),-.1+mbally,mbz),.86);\n    backS2+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n\n    float backS3=sdSphere(r-vec3(-1.0*sin(iTime),-.7*cos(iTime)+mbally,mbz),.76);\n    backS3+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n    \n    float metaballs=opSmoothUnion(opSmoothUnion(backS,backS2,0.5),backS3,0.5);\n    t=min(t,metaballs);\n    \n    // twisting block\n    vec3 tbr=r;\n    float tblockpos=.5;\n\n    float spikeAmt=6.0;\n    float tblocky=0.0;\n    if (iTime>25.0) tblocky=1.5*sin((iTime-25.0)/2.3);\n    float tblock=sdTwistingBox(tbr-vec3(iTime/4.0,tblocky,2.0+tblockpos),vec3(17.0,.87,.87),0.1);\n    tblock+=(.12)*sin(r.x*spikeAmt)*(.52*sin(r.y*spikeAmt))*(.52*cos(r.z*spikeAmt));\n    t=min(t,tblock);\n\n    float trashbin=10000.0;\n    float merlogo=10000.0;\n    \n    if (iTime>24.0)\n    {        \n        // biiin\n        float binx=3.2;\n        float binz=14.5;\n        trashbin=mapBin(r-vec3(binx,-1.5,binz));\n        t=min(t,trashbin);\n        // random demoscene logo\n        merlogo=mapDemosceneLogo(r-vec3(binx-0.21,-1.7,binz-0.1));\n        t=min(t,merlogo);\n    }\n    \n    // cyboman's torus (not really)\n    vec3 rottor=r;\n    float cybotorus=sdTorus(rottor-vec3(0.0,-.5,21.0),vec2(1.5,.5));\n    cybotorus+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,cybotorus);\n    \n    // plasmacube from 2nd reality\n    float cubeZ=27.0;\n    float cubeBase=sdBox(r-vec3(0.0,-1.96,cubeZ),vec3(1.35,1.07,1.35));\n    t=min(t,cubeBase);\n    \n    vec3 rcubed=r;\n    float cubeSide=0.52;\n    \n    //float innerCube=sdBox(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),vec3(cubeSide-0.1,cubeSide-0.1,cubeSide-0.1));\n    \n    float sideProf=0.32;\n    float pcube0=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,cubeSide,sideProf),\n                              vec3(0.0,0.0,-cubeSide/2.5));\n    float pcube1=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,cubeSide,sideProf),\n                              vec3(0.0,0.0,cubeSide/2.5));\n    float pcube2=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,sideProf,cubeSide),\n                              vec3(0.0,cubeSide/2.5,0.0));\n    float pcube3=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,sideProf,cubeSide),\n                              vec3(0.0,-cubeSide/2.5,0.0));\n    float pcube4=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(sideProf,cubeSide,cubeSide),\n                              vec3(-cubeSide/2.5,0.0,0.0));\n    float pcube5=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(sideProf,cubeSide,cubeSide),\n                              vec3(cubeSide/2.5,0.0,0.0));\n    t=min(t,pcube0);\n    t=min(t,pcube1);\n    t=min(t,pcube2);\n    t=min(t,pcube3);\n    t=min(t,pcube4);\n    t=min(t,pcube5);\n\n    float container3=sdRoundBox(r-vec3(0.0,-0.1,cubeZ),vec3(1.25,1.25,1.25),0.1);\n    float innerBox3=sdBox(r-vec3(0.0,-0.1,cubeZ),vec3(1.15,1.15,1.15));\n    container3=opSubtraction(innerBox3,container3);\n    t=min(t,container3);\n    //float container3=1000.0;\n    \n    //\n    // glass panels\n    //\n\n    float boxxpos=3.0;\n    float glass0z=0.0;\n    if (iTime>11.0) boxxpos+=iTime-11.0;\n    float rbox=sdRoundBox(r-vec3(boxxpos,-0.1,glass0z),vec3(3.0,4.6,0.1),0.1);\n    rbox+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox);\n\n    float rbox2=sdRoundBox(r-vec3(-boxxpos,-0.1,glass0z),vec3(3.0,4.6,0.1),0.1);\n    rbox2+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox2);\n\n    float boxxpos2=3.0;\n    float glass1z=8.0;\n    if (iTime>26.5) boxxpos2+=iTime-26.5;\n    float rbox3=sdRoundBox(r-vec3(boxxpos2,-0.1,glass1z),vec3(3.0,4.6,0.1),0.1);\n    rbox3+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox3);\n\n    float rbox4=sdRoundBox(r-vec3(-boxxpos2,-0.1,glass1z),vec3(3.0,4.6,0.1),0.1);\n    rbox4+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox4);\n\n    float boxxpos3=3.0;\n    float glass2z=16.0;\n    if (iTime>36.0) boxxpos3+=iTime-36.0;\n    float rbox5=sdRoundBox(r-vec3(boxxpos3,-0.1,glass2z),vec3(3.0,4.6,0.1),0.1);\n    rbox5+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox5);\n\n    float rbox6=sdRoundBox(r-vec3(-boxxpos3,-0.1,glass2z),vec3(3.0,4.6,0.1),0.1);\n    rbox6+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox6);\n\n    float boxxpos4=3.0;\n    float glass3z=25.0;\n    if (iTime>44.0) boxxpos4+=iTime-44.0;\n    float rbox7=sdRoundBox(r-vec3(boxxpos4,-0.1,glass3z),vec3(3.0,4.6,0.1),0.1);\n    rbox7+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox7);\n\n    float rbox8=sdRoundBox(r-vec3(-boxxpos4,-0.1,glass3z),vec3(3.0,4.6,0.1),0.1);\n    rbox8+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox8);\n    \n    // calc materials\n    \n    if (t==metaballs) return vec3(t,2.0,0.0);\n    if (t==tblock) return vec3(t,3.0,0.0);\n    if ((t==container1)||(t==container2)||(t==container3)) return vec3(t,7.0,1.0);\n    if ((t==rbox)||(t==rbox2)||(t==rbox3)||(t==rbox4)||(t==rbox5)||(t==rbox6)||(t==rbox7)||(t==rbox8)) return vec3(t,0.0,1.0);\n    if ((t==pyr1)||(t==pyr2)||(t==cubeBase)) return vec3(t,5.0,0.0);\n    if ((t==amigaball1)||(t==amigaball2)) return vec3(t,6.0,0.0);\n    if (t==cybotorus) return vec3(t,4.0,0.0);\n    if ((t==pcube0)||(t==pcube1)) return vec3(t,8.0,0.0);\n    if ((t==pcube2)||(t==pcube3)) return vec3(t,8.1,0.0);\n    if ((t==pcube4)||(t==pcube5)) return vec3(t,8.2,0.0);\n    if (t==trashbin) return vec3(t,9.0,0.0);\n    if (t==merlogo) return vec3(t,10.0,0.0);\n    \n    return vec3(t,1.0,0.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float h )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    pos.y+=h;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t=0.0;\n    float trasp=0.0;\n    bool refrakkted=false;\n    vec3 rd=rayDir;\n    for (int i=0;i<iterationAmount;i++)\n    {\n        vec3 res = SDF(rayOrigin + rd * t);\n        if (res[0] < (0.0001*t))\n        {\n            if (res[2]==0.0)\n            {\n            \treturn vec4(t,res[1],trasp,0.0);\n            }\n            else\n            {\n                if (!refrakkted)\n                {\n                    vec3 hitNorm=calcNormal(rayOrigin+rd*t);\n                    vec3 newdir;\n                    if (res[1]==7.0) newdir=rd; // don't refract the thecas\n                    else newdir=refract(rd,hitNorm,0.90);\n                    rd=newdir;\n                    trasp=t;\n                    refrakkted=true;\n                }\n            }\n        }\n\n        if (!refrakkted) t+=res[0];\n        else t += 0.02;\n    }\n    \n    return vec4(-1.0,-1.0,-1.0,-1.0);\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    const float FOG_DENSITY = 0.06;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\nvec3 srgb(float r) {\n    return vec3(r*r);\n}\n\nvec4 cubePlasma (vec2 coord, vec3 p, int ptype) \n{\n    float \n        k = iTime * 3.0,\n        as = 4.78207464329,\n    \tfd = 12.18910931609,\n    \tas1 = 2.839499561581 / 24.0 + sin(k) * 0.02,\n    \tfd2 = 2.188989119604,\n    \tps = -5.624243766069,\n    \tps2 = 9.393007904291,\n    \tp1 = sin(k / ps) * 4.0,\n    \tp2 = sin(k / fd) * 3.0,\n    \tt3 = sin(k / fd2) + cos(as1),\n        t4 = sin(k / ps);    \n    \n    float coordDivider=32.0;\n    coord.x = floor(coord.x * coordDivider) / coordDivider;\n    coord.y = floor(coord.y * coordDivider) / coordDivider;\n    \n    float x = sin(p1 + coord.x) * sin(p2 + coord.y) + sin(t3 + coord.x) * sin(t4 + coord.y) * -p.x;\n    \n    float r,g,b;\n    \n    if (ptype==0)\n    {\n        r = (0.01 );\n        g = (0.12 + sin(x / as1)) / 2.0; \n        b = (0.97 + sin(x / as1 )) + sin(coord.y / as1) / 4.0;\n    }\n    else if (ptype==1)\n    {\n        r = (0.81 + sin(x / as1)) / 2.0;\n        g = (0.51 + sin(x / as1)) / 2.0; \n        b = (0.37 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n    \t//r=pow(r,2.9);\n        r+=0.5;\n        g+=0.5;\n    \tg=pow(g,2.0);\n    \tb=pow(b,2.0);\n    }\n    else if (ptype==2)\n    {\n        r = (0.31 + sin(x / as1)) / 2.0;\n        g = (0.97 + sin(x / as1)) / 2.0; \n        b = (0.17 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n    \tr=pow(r,2.9);\n    \tg=pow(g,2.0);\n    \t//b=pow(b,2.0);\n    }\n\n    r=clamp(r,0.0,1.0);\n    g=clamp(g,0.0,1.0);\n    b=clamp(b,0.0,1.0);\n    vec4 color = vec4(vec3(r,g,b), 1.0);\n    return color;\n}\n\nvec4 boxmap( in vec3 p, in float k, int ptype ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = cubePlasma(p.yz, p,ptype);\n\tvec4 y = cubePlasma(p.zx, p,ptype);\n\tvec4 z = cubePlasma(p.xy, p,ptype);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(1.33,1.0,-1.0));\n\n    vec4 rayHit = castRay(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    vec3 N=calcNormal(pHit);\n    float dotprod=abs(dot(N,L));\n\n    if (mat==1.0)\n    {\n        float occlHeight=1.6;\n        if (pHit.z<0.0) occlHeight=0.52; // amigahballs\n        if ((pHit.z>13.5)&&(pHit.z<15.0)) occlHeight=0.5; // bin\n        if (pHit.z>16.0) occlHeight=0.2; // cybomantorus\n        float occ = calcAO( pHit, vec3(0.0,1.0,0.0),occlHeight );\n\n        vec2 a=vec2(1.0);\n        if ((N.z>0.01)||(N.z<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.y, 1.)));\n        }\n        else if ((N.x>0.01)||(N.x<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.y, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n        }\n        else if ((N.y>0.01)||(N.y<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n        }\n        \n        float cenDist=distance(vec3(pHit.x,pHit.y,mod(pHit.z,6.0)),vec3(0.0,0.0,3.0));\n\n        if (pHit.z<0.0)\n        {\n            //if (iTime>4.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n            //else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n            col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n        }\n        else if ((pHit.z>=0.0)&&(pHit.z<8.0))\n        {\n            if (iTime>5.80) col = vec3(.7-a.x,.8-a.y,0.9-a.x);\n            else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else if ((pHit.z>=8.0)&&(pHit.z<16.0))\n        {\n            if (iTime>6.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n            else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else if ((pHit.z>=16.0)&&(pHit.z<25.0))\n        {\n        \tcol = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else\n        {\n            if (iTime>8.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n        \telse col =vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n\n        col+=vec3(1.0)/cenDist*1.25;\n        if (N.y>0.01) col=mix(col,vec3(occ),0.06);\n        //col=fog(col,distance(rayOrigin,pHit)/4.0,vec3(1.,1.,1.));\n    }\n    else if (mat==2.0) // metaballs\n    {\n        dotprod+=pow(dotprod,16.0);\n        col=vec3(.85,.5,.7)*dotprod;\n\n        vec3 oldcolor = col + (col * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        col = floor(oldcolor);    \n    }\n    else if (mat==3.0) // twisting block\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.,.05,.1), srgb(0.4,.3,1.), diff1) + pow(diff1, spexex)*1.5;\n        vec3 col2 = mix(srgb(0.1,.0,0.3), srgb(1.,.2,0.5), diff2) + pow(diff2, spexex)*1.5;\n        vec3 col3 = mix(srgb(0.33), srgb(0.2,0.9,1.), diff3) + pow(diff3, spexex)*2.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));  \n        \n        if (iTime<5.80) col*=vec3(0.25);\n    }\n    else if (mat==4.0) // rolling torus\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.2,.05,.1), srgb(0.24,.3,1.), diff1) + pow(diff1, spexex)*2.5;\n        vec3 col2 = mix(srgb(0.41,.0,0.3), srgb(0.5,.2,0.5), diff2) + pow(diff2, spexex)*2.5;\n        vec3 col3 = mix(srgb(0.33), srgb(0.02,0.3,1.), diff3) + pow(diff3, spexex)*3.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));        \n    }\n    else if (mat==5.0) // ball's base\n    {\n        float occ = calcAO( pHit, vec3(0.0,1.0,0.0),0.3);\n        col=vec3(.05,.05,.05)*dotprod;\n\t\tif (N.y>0.01) col=mix(col,vec3(occ),0.06);\n    }\n    else if (mat==6.0) // amigahballs\n    {\n    \tvec3 amigaLight=normalize(vec3(1.03,1.0,-1.0));;\n        if (pHit.x>0.0) amigaLight=normalize(vec3(-1.03,1.0,-1.0));;\n        \n        vec3 N2=roty(N,iTime);\n        vec2 matuv = vec2( atan(N2.x,N2.z), acos(N2.y ) );\n        vec2 qp = floor(matuv*2.51);\n        float intensity=mod(qp.x+qp.y,2.0);\n        if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n        else col=vec3(1.0);\n        float NoL = max(dot(N, amigaLight), 0.1);\n        col*=NoL;\n        col+=pow(NoL,32.0);\n\n        vec3 oldcolor = col + (col * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        col = floor(oldcolor);    \n    }\n    else if ((mat==8.0)||(mat==8.1)||(mat==8.2)) // plasmacube\n    {\n        // 2nd reality cube faces are \n        // red-yellow-black\n        // blue-white-black\n        // green-brown-black\n        \n        float cubeZ=28.0;\n        if (mat==8.0) col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,0).xyz;\n        else if (mat==8.1) col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,1).xyz;\n        else col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,2).xyz;\n        \n        //col=vec3(1.0,0.0,0.0);\n        col*=dotprod;\n    }\n    else if (mat==9.0) // trashbin\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.05,.05,.05), srgb(0.3,.3,.3), diff1) + pow(diff1, spexex)*1.5;\n        vec3 col2 = mix(srgb(0.1,.1,0.1), srgb(.2,.2,0.2), diff2) + pow(diff2, spexex)*1.5;\n        vec3 col3 = mix(srgb(0.43,0.43,0.43), srgb(0.82,0.82,0.82), diff3) + pow(diff3, spexex)*2.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));\n        col*=0.8;\n    }\n    else if (mat==10.0) // random demoscene logo\n    {\n        col=vec3(1.0,85.0/255.0,0.0)*dotprod;\n        col*=0.8;\n    }\n    else\n    {\n        col=vec3(0.0,1.0,0.0);\n    }\n    \n    if (rayHit[2]!=0.0)\n    {\n        vec3 tN=calcNormal(rayOrigin+rayDir*rayHit[2]);\n        float dotprod=max(dot(tN,L),0.0);\n        dotprod+=pow(dotprod,2.0);\n        col=mix(col,vec3(0.8,0.8,0.8)*dotprod,0.15);\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    //float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n\n    // opening fade in\n    if (iTime<10.4)\n    {\n        camPos=vec3(0.0,-1.8,-11.0+(iTime/11.0));\n        camTarget=vec3(0.0,0.0,-4.0+(iTime/11.0));\n    }\n    // panning right-left\n    else if ((iTime>=10.4)&&(iTime<20.0))\n    {\n        camPos=vec3(10.4-iTime/1.5,-1.6,-8.0);\n        camTarget=vec3(10.4-iTime/1.5,-1.6,-7.0);\n    }\n    // walkthrough\n    else if ((iTime>=20.0)&&(iTime<49.0))\n    {    \n        camPos=vec3(0.0,-0.1,-26.0+iTime);\n        camTarget=vec3(0.0,0.0,0.0+iTime);\n    }\n    else\n    {\n        camPos=vec3(0.0,-0.1,(-18.0+42.0)-(abs(.7*sin(iTime-49.0))));\n        camTarget=vec3(0.0,0.0,-18.0+42.0+2.0);\n    }\n    \n    //camPos=vec3(sin(iTime)*0.2,0.6,7.5);\n    //camTarget=vec3(0.0,0.0,9.0);\n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4(render(camPos, rayDir,uv,fragCoord).xyz,1.0);\n    \n    // fadein\n    if (iTime<2.001)\n    {\n        finalCol=vec4(mix(finalCol.xyz,vec3(0.0),(2.0-iTime)/2.0),1.0);\n    }\n    \n    // fadeout\n    if (iTime>55.0)\n    {\n        finalCol=vec4(mix(vec3(0.0),finalCol.xyz,clamp((59.0-iTime)/4.0,0.0,1.0)),1.0);\n    }\n\n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 22476,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/salidad/salidad-white-day"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}