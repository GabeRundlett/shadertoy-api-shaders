{
    "Shader": {
        "info": {
            "date": "1592943503",
            "description": "experimenting with 2D slicing the sphere packing SDF to get an array of circles of different sizes.\n\nNew: [url=https://youtu.be/I8fmkLK1OKg]The tutorial video[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXcWB",
            "likes": 179,
            "name": "Whack-A-Mole Pistons",
            "published": 3,
            "tags": [
                "domainrepetition",
                "pistons"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 8549
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//uncomment for slow but pretty version\n//#define PRETTY\n#ifdef PRETTY\n#define AA_SAMPLES 8\n#define MOTION_BLUR\n#else\n#define AA_SAMPLES 1\n#endif\n\n//the following functions assume that p is inside the cube of radius 1 centered at the origin\n//closest vertex of the cube to p\nvec3 vertex(vec3 p) {\n    return step(0.,p)*2.-1.;\n}\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(sign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,sign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n//closest edge of the cube to p\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = vertex(p);\n    vec3 a = v*mask.zxy, b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat corner(vec2 p, float h) {\n    vec2 q = p - vec2(0,h);\n    return super(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\n//returns rhombic dodecahedron tessalation data for p\n//x: distance to circle of radius .6 in current cell\n//y: distance to circle of radius .6 in closest adjacent cell\n//zw: ID of cell\nvec4 grid(vec3 p) {\n    vec3 id = floor(p)+.5;\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z<0.) id += face(p-id);\n    p -= id;\n    float d1 = length(p)-.6;\n    p -= edge(p);\n    float d2 = length(p)-.6;\n    return vec4(d1,d2,id);\n}\n\n#define FBI floatBitsToInt\nfloat hash(float a, float b) {\n    int x = FBI(cos(a))^FBI(a);\n    int y = FBI(cos(b))^FBI(b);\n    return float((x*x+y)*(y*y-x)+x)/2.14e9;\n}\n\n//springy impulse\nfloat spring(float x) {\n    return smoothstep(-.4,.4,x) + smoothstep(-.3,.3,x) - smoothstep(-.7,.7,x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = max(vec3(0),k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//mtime set by \"pixel_color\" to influence the time used by the scene\nfloat mtime;\n//lots of globals set by \"scene\"\nvec2 gid;\nvec3 glocal;\nfloat gnd;\nfloat gt;\nfloat scene(vec3 p) {\n    //ds1 chooses z coordinate in 2d slicing of the rhombic dodecahedron tessalation\n    //by varying it over space, we get different sized circles\n    float ds1 = dot(cos(p.xy/5.), sin(p.xy/4.))*.06;\n    vec3 p3 = vec3(p.xy, ds1);\n    vec4 g = grid(p3);\n    gid = g.zw;\n \n    float s1 = hash(gid.x,gid.y);\n    float s2 = hash(s1,s1);\n    gt = sin(s1*100.+mtime*mix(1.,2.,s2*.5+.5))-.4;\n    float h = spring(gt)*2.-.5;\n\n    vec2 crd = vec2(g.x,p.z);\n    vec2 crd2 = vec2(g.y,p.z);\n    float maxheight = 1.7;\n\n    gnd = corner(crd*vec2(-1,1)+vec2(0.08,0.),0.)-.04; //ground holes\n\n    //transform things into local coordinates for piston\n    crd.y -= h;\n    glocal = p - vec3(gid,h);\n    glocal = erot(glocal,vec3(0,0,1),s1*100.+gt*2.);\n    float curr = corner(crd, 0.); //distance to current piston\n    \n    //little holes on side of piston\n    vec3 lp = glocal;\n    lp.z = asin(sin(lp.z*5.+.5))/5.;\n    curr = -smin(-curr, length(lp.yz)-0.05,.03);\n    \n    float adjacent = corner(crd2, maxheight); //distance to adjacent piston (assumes maximally extended)\n    return min(gnd,min(curr, adjacent)-.02);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 skylight(vec3 p) {\n    float d = dot(p,normalize(vec3(1)));\n    return vec3(1)*d*.2+.2 + pow(max(0.,d),10.)*1.5;\n}\n\nfloat smpl(vec3 p, vec3 dir, float dist) {\n    return smoothstep(-dist,dist,scene(p+dir*dist));\n}\n\nvec3 pixel_color(vec2 uv, float time)\n{\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    mtime = time;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-7,0,0);\n    \n    float yrot = 0.7+sin(time*.3)*.2;\n    float zrot = time*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    init.xy += time*vec2(.5,sqrt(2.));\n    init.z += 2.;\n    vec3 p =init;\n    bool hit = false;\n    float dist; int i;\n    for (i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    //save globals locally\n    bool g = gnd == dist;\n    vec2 id = gid;\n    float s1 = hash(gid.y,gid.x);\n    float s2 = hash(s1,gid.x);\n    vec3 local = g ? p : glocal+vec3(id,0);\n    \n    float fog = min(1.,smoothstep(5.,50.,distance(p,init))+smoothstep(100.,200.,float(i)));\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smpl(p,n,.1);\n    \n    //brushed metal tops. not sure if this is the right way, but it works!\n    if (!g && n.z>.9) {\n        float ang = atan(p.x-id.x,p.y-id.y);\n        float ang2 = atan(local.x-id.x,local.y-id.y);\n        local = vec3(ang2/2.,length(p.xy-id)*40.,local.z+id.x*.9+id.y*.4);\n        n = normalize(vec3(cos(ang*2.),sin(ang*2.),1));\n    }\n    \n    //rough texture\n    float sharpness = texture(iChannel0,local/2.).x;\n    sharpness = sqrt(texture(iChannel0,local*vec3(1,4,.5)+sharpness*.1).x);\n    sharpness *= pow(texture(iChannel0,local/10.+sharpness*.1).x, 2.);\n    sharpness = sharpness*.5+.9;\n    \n    //fake reflection occlusion\n    float ro = sqrt(smpl(p,r,.9)*smpl(p,r,.5)*smpl(p,r,.2));\n    \n    float spec = length(sin(r*3.*sharpness)*.4+.6)/sqrt(3.) * smoothstep(-1.,-.0,p.z);\n    float fres = 1.-abs(dot(cam,n))*.5;\n    vec3 mcol = abs(erot(vec3(0.4,0.6,0.9), normalize(vec3(0,s2,2)), s1*.6));\n    if (g) mcol = vec3(0.1);\n    \n    vec3 col = (mcol*spec + pow(spec,10.*sharpness))*ro*ao*fres*1.5;\n    vec3 bgcol = skylight(cam);\n    vec3 fragColor = hit ? mix(col,bgcol,fog) : bgcol;\n    return fragColor;\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nfloat bayer(ivec2 uv) {\n    return texelFetch(iChannel1, uv % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    float b = bayer(ivec2(fragCoord));\n    for (int i = 0; i < AA_SAMPLES+int(min(0,iFrame)); i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n#ifdef MOTION_BLUR\n\t\t//using yx's bayer motion blur idea https://www.shadertoy.com/view/wsfcWX\n        float blur = ((float(i)+b)/float(AA_SAMPLES)-.5) * iTimeDelta;\n#else\n        float blur = 0.;\n#endif\n        fragColor += vec4(pixel_color(uv2, iTime+blur), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n    \n    fragColor.xyz = smin(fragColor.xyz,vec3(1),0.1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}