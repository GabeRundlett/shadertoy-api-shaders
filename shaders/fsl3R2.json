{
    "Shader": {
        "info": {
            "date": "1616456997",
            "description": "I took some inspiration from the logo of this website and decided to add my own twist to it. ",
            "flags": 0,
            "hasliked": 0,
            "id": "fsl3R2",
            "likes": 26,
            "name": "Breathing Eye",
            "published": 3,
            "tags": [
                "noise",
                "eye",
                "psychedelic",
                "iris"
            ],
            "usePreview": 0,
            "username": "manu210404",
            "viewed": 714
        },
        "renderpass": [
            {
                "code": "#define PI acos(-1.)\n\n// -------------------------------------- //\n// Animation\n#define ANIM\n\n// inner/outer Radius of iris\n#define INNER_R (0.25+sin(iTime*PI*0.5)*0.06125)\n#define OUTER_R .875\n\n// Background, background of the iris, inner and outer color of eye\n#define BG     vec3(0.1, 0.0, 0.1 )\n#define EYE_BG vec3(0.1, 0.05,0.15)\n#define EYE_1  vec3(0.5, 0.25,0.03)\n#define EYE_2  vec3(0.45,0.65,0.6 )\n\n// how many layers of \"strings\" are rendered\n#define LAYERS 4\n// -------------------------------------- //\n\n// Antialiasing\n#define EPS 12. / iResolution.y / length(p) // epsilon for antialiasing\n\n// gamma correction\n#define G(a) pow((a), vec3(0.4545))\n#define IG(a) pow((a), vec3(2.2))\n\n// hash functions by Dave_Hoskins - https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash11(in float p) {uvec2 n = uint(int(p)) * UI2;uint q = (n.x ^ n.y) * UI0;return float(q) * UIF;}\n\nvec2 hash22(in vec2 p) {uvec2 q = uvec2(ivec2(p))*UI2;q = (q.x ^ q.y) * UI2;return vec2(q) * UIF;}\n\n// simplex noise by iq - https://www.shadertoy.com/view/Msf3WH\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404,K2 = 0.211324865;vec2 i=floor(p+(p.x+p.y)*K1),a=p-i+(i.x+i.y)*K2;float m=step(a.y,a.x);vec2 o=vec2(m,1.-m);\n    vec2 b=a-o+K2,c=a-1.+2.*K2;vec3 h=max(0.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.),n=h*h*h*h*vec3(dot(a,hash22(i+0.0)),dot(b,hash22(i+o)),dot(c,hash22(i+1.)));\n    return dot(n,vec3(70.0));\n}\n\nmat2 rot(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat iris(in vec2 p) {\n    float d = (OUTER_R + INNER_R) * 0.5;\n    d = (abs(length(p) - d) - d + INNER_R) / (d - INNER_R); // normalized distance to the radii\n    mat2 r;                        // animated rotation of noise-domain\n    float s,                       // animated scale of noise-domain\n          a = atan(p.y, p.x),      // angle to center\n          na,                      // offset of the angle (determined by 2d-noise)\n          f = exp2(float(LAYERS)), // scale of the layers\n          pattern,                 // output variable\n          n,                       // value of the \"strings\" (determined by looping 1d-noise)\n          t,                       // added thickness to \"strings\"\n          alpha;                   // maybe not alpha but I don't know how else to call it\n    vec2 m = iMouse.xy/iResolution.y; // mouse offset of noise-domain\n\n    #ifdef ANIM\n    s = sin(iTime * PI * 0.25) * 0.25;    // animated scale of domain\n    r = rot(iTime * PI * 0.0078125);      // animated rotation of domain\n    #endif\n    \n    for (int i=0; i<LAYERS; i++) {\n        na = a + noise((p - m/f) * 1.5 * f * (1. + s / f) * r) * length(p) * 0.5 / f; // noise to warp strings\n        n = noise(vec2(sin(na),cos(na)) * 2. * f);                                    // value of strings\n        \n        \n        t = .75 / f ;                                     // thickness/density of strings\n        t += - 1.5 * smoothstep(1.0, 0.0, d + 0.5) + 1.5; // strings are cut off at the edge of the iris\n        t += -.125 * smoothstep(1.0, 0.0, d + 1.);        // strings are thicker when closer to center radius\n        \n        pattern -= smoothstep(-0.35,  0.25,  n - t) * 0.5 * pattern; // \"shadows\" of the \"strings\"\n        alpha =    smoothstep(-EPS*f, EPS*f, n - t);\n        pattern += pow(alpha, 2.) * (1. - pattern);               // addition of the layers (i don't really know what im doing here but it looks nice)\n    \n        f *= 0.5;\n    }\n    return max(0.0, pattern); // because of the shadows it could be negative so i clamp it here\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float irisPerimiter_mask = smoothstep(0.1,  -0.1,  length(p) - OUTER_R);\n    float irisPupil_mask =     smoothstep(0.05, -0.05, length(p) - INNER_R);\n    float iris_mask =          -irisPupil_mask + irisPerimiter_mask;\n    \n    float iris_pattern = iris(p);\n    \n    vec3 iris_color = IG(mix(G(EYE_1), G(EYE_2), vec3(sqrt(clamp((length(p) - INNER_R) / (OUTER_R - INNER_R) + 0.01, 0.0, 1.0))))); // color gradient (is this how you gamma correct?)\n    \n    vec3 col = iris_pattern * iris_color + EYE_BG * (1. - iris_pattern); // blending between the gradient and the background\n    \n    col = col * iris_mask + (1. - iris_mask) * BG;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}