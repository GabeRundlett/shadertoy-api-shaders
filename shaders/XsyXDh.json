{
    "Shader": {
        "info": {
            "date": "1463965996",
            "description": "Variations on the Kaliset Fractal, based on 'Simplicity', uploaded by JoshP on 2013-May-7 : https://www.shadertoy.com/view/lslGWr",
            "flags": 0,
            "hasliked": 0,
            "id": "XsyXDh",
            "likes": 6,
            "name": "Kaliset Variations",
            "published": 3,
            "tags": [
                "2d",
                "fractal"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 1064
        },
        "renderpass": [
            {
                "code": "/* 'Kaliset Variations' by wjbgrafx \n   \n    Minor modifications to code from 'Simplicity', uploaded by JoshP on 2013-May-7 \n    https://www.shadertoy.com/view/lslGWr\n*/\n//================================================================================\n\nfloat field( vec3 p ) \n{\n\t// Pattern fades out at around 310 seconds. Rather than figure out why, just\n    // reverse the time between 310 and 620 seconds ( You're *still* watching this!? )\n    float time = mod( iTime, 620.0 );\n    time = time > 310.0 ? 620.0 - time : time;\n\t    \n    //float strength = 7.0 + 0.03 * log( 1.e-6 + fract( sin( time ) * 4373.11 ) ),\n\t// Smaller value of 'strength' = brighter image\n\tfloat strength = 4.0 - sin( time * 0.0005 ),\n\t      //power = 2.3,\n\t      power = 2.3 + sin( time * 0.003 ),\n\t      accum = 0.0,\n\t      prev = 0.0,\n\t      tw = 0.0;\n\t      \n\tfor ( int i = 0; i < 32; i++ ) \n\t{\t\t\n\t\tfloat mag = dot( p, p ),\n\t\t      w = exp( -float( i ) / 7.0 );\n\t\t\n\t\tp = abs( p ) / mag + vec3( -0.5, -0.4, -1.5 );\n\t\t//accum += w * exp( -strength * pow( abs( mag - prev ), 2.3 ) );\n\t\taccum += w * exp( -strength * pow( abs( mag - prev ), power ) );\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\t\n\treturn max( 0.0, 5.0 * accum / tw - 0.7 );\n}\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = mod( iTime, 620.0 );\n    time = time > 310.0 ? 620.0 - time : time;\n\n\n    // 'uv' is a -1 to 1 range coord in both x and y ( without aspect ratio ).\n\t// 'uvs' is a -1 to 1 range coord in x, and a y-range of -y/x to +y/x =\n\t// smaller values since yres is smaller.\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tvec2 uvs = uv * iResolution.xy / max( iResolution.x, iResolution.y );\t\n\t\n\t//----------------------------------------------------------\n\t// Original - off-center image\n\t//vec3 p = vec3( uvs / 4.0, 0.0 ) + vec3( 1.0, -1.3, 0.0 );\n\t\n\t// Movement via altering the z position of off-center image\n\t//vec3 p = vec3( uvs / 4.0, 0.0 ) + vec3( 1.0, -1.3, time * 0.01 );\n\t\n\t// Altering z position of centered image\n\t//vec3 p = vec3( uvs / 4.0, time * 0.01 );// + vec3( 1.0, -1.3, time * 0.01 );\n\t\n\t// Using time to zoom in on the off-center image\n\t//vec3 p = vec3( uvs / (4.0 + time * 0.1 ), 0.0 ) + vec3( 1.0, -1.3, 0.0 );\n\n\t// Using time to zoom out of the centered image\n\t//vec3 p = vec3( uvs / (4.0 - time * 0.1 ), 0.0 );// + vec3( 1.0, -1.3, 0.0 );\n\t\n\t// Altering z position of centered image while slowly zooming in\n\t//vec3 p = vec3( uvs / exp( time * 0.005 ), time * 0.01 );\n\t\n\t// Very slow zoom-in\n\t//vec3 p = vec3( uvs / exp( time * 0.005 ), log( time * 0.01 ) );\n\t\n\t//--------------------------------------------------------------\n\t\n\t// Altering z position of centered image while slowly zooming out\n\tvec3 p = vec3( uvs / log( time * 0.001 ), exp( time * 0.005 ) );\n\t\n\t//----------------------------------------------------------\n\t\n\t// Moves the image around the screen in original code\n\t//----------------------------------\n//\tfloat transRate = 0.2;\t\n//\tp += transRate * \n//\t       vec3( sin( time / 16.0 ), sin( time / 12.0 ), sin( time / 128.0 ) );\n\t//----------------------------------\n\t\n\t// 'v' ranges from 0 at the edges of the screen, and rapidly approaches\n\t// 1.0 ( without equalling it ) towards the center of the screen; i.e.,\n\t// 1/10th of the way from edge to center, 'v' already equals about 0.45;\n\t// 1/4 of the way, 'v' equals about 0.75; 1/2 of the way, 'v' equals about\n\t// 0.9475; 3/4 of the way, 'v' equals about 0.986. This applies when the\n\t// multiplier = 6.0. A smaller multiplier makes the range smoother, larger\n\t// makes the range increase very rapidly moving away from the edges, but \n\t// still approaching but not reaching 1.0.\n\tfloat t = field( p ),\n\t      v = ( 1.0 - exp( ( abs( uv.x ) - 1.0 ) * 6.0 ) ) * \n\t          ( 1.0 - exp( ( abs( uv.y ) - 1.0 ) * 6.0 ) );\n\t          \n//------------------------------------------------------------------\n// Original\n// -------- Mixing based on 'v' makes multiplier of final color 0.4 at the \n// edges, rapidly increasing towards 1.0 at the center ( see value of 'v', above).\n\t\n//\tfragColor = mix( 0.4, 1.0, v ) * vec4( 1.8 * t * t * t, \n//\t                                          1.4 * t * t, t, 1.0 );\n//------------------------------------------------------------------\n// Modified original\n// -----------------\n\n\tfloat rTime = time * 0.05,\n\t\t  gTime = time * 0.03,\n\t      bTime = time * 0.01,\n\t      red = mod( ( 1.1 + sin( rTime) ) * t * t * t + rTime, 2.0 ),\n\t      grn = mod( ( 1.1 + sin( gTime ) ) * t * t + gTime, 2.0 ),\n\t      blu = mod( t + bTime, 2.0 );\n\t      \n\tred = red > 1.0 ? 2.0 - red : red;\n\tgrn = grn > 1.0 ? 2.0 - grn : grn;\n\tblu = blu > 1.0 ? 2.0 - blu : blu;\t      \n\t\n\tfragColor = mix( 0.05, 1.1 + sin( bTime ), v ) * vec4( red, grn, blu, 1.0 );\n\t\t\n//------------------------------------------------------------------\n\t\n// Simple greyscale\n//\tfragColor = vec4( t, t, t, 1.0 );\n\n//------------------------------------------------------------------\n\n// Abhuese\n/*\n\tfloat red = mod( t * t + v * v, 2.0 ),\n\t      grn = t * v,\n\t      blu =  dot( t, v );\n\t      \n\tred = ( red > 1.0 ) ? 2.0 - red : red;\n\t\n\tred = mod( red + grn, 1.0 );\n\tgrn = mod( grn + blu, 1.0 );\t      \n\tblu = mod( blu + red, 1.0 );\n\n\tfragColor = vec4( red,grn,blu, 1.0 );\n*/\n//------------------------------------------------------------------\n\n// ( and now for ) Something completely different\n/*\n\tfloat red = t,\n\t      grn = v,\n\t      blu = t + v;\n\t      \t      \n\tfragColor = vec4( red,grn,blu, 1.0 );\n*/\n\n//------------------------------------------------------------------\n\n// Something else entirely\n/*\t\n\tfloat red = mod( 2.0 * t * t * t, 2.0 ),\n\t      grn = mod( red * t * t, 2.0 ),\n\t      blu = mod( grn * t, 2.0 );\n\t      \n\t      \n\tred = red > 1.0 ? 2.0 - red : red;\n\tgrn = grn > 1.0 ? 2.0 - grn : grn;\n\tblu = blu > 1.0 ? 2.0 - blu : blu;\n\t\t                                               \n\tfragColor = vec4( red,grn,blu, 1.0 );\n*/\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}