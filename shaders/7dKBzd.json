{
    "Shader": {
        "info": {
            "date": "1658747482",
            "description": "CC0: Slerp - spherical linear interpolation\nFrom: https://en.wikipedia.org/wiki/Slerp\nInterpolating between 2 vectors using spherical linear interpolation\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7dKBzd",
            "likes": 5,
            "name": "Spherical linear interpolation",
            "published": 3,
            "tags": [
                "2d",
                "tech"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "// CC0: Slerp - spherical linear interpolation\n// From: https://en.wikipedia.org/wiki/Slerp\n// Interpolating between 2 vectors\n// Left side is a normalized mix/lerp which looks decent when the angles are small between the two input vectors\n// As angle nears 180 there's a speedup and slowdown happening\n// Right side uses slerp that has a linear speed, sometimes more desirable\n\n// According to the wikipedia article slerp is generalizable to any dimension so I threw in a vec3 version too, not tested.\n\n// I suppose there's already a slerp on this site somewhere\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length(pa - ba*h);\n}\n\nvec2 slerp(vec2 p0, vec2 p1, float t) {\n  // https://en.wikipedia.org/wiki/Slerp\n  float d = dot(p0, p1)*inversesqrt(dot(p0, p0)*dot(p1, p1));\n  float o = acos(d);\n  float c = inversesqrt(1.0-d*d); // Cheaper than computing (1.0/sin(o))?\n  return (sin((1.0-t)*o)*p0 + sin(t*o)*p1)*c; \n}\n\nvec3 slerp(vec3 p0, vec3 p1, float t) {\n  // https://en.wikipedia.org/wiki/Slerp\n  float d = dot(p0, p1)*inversesqrt(dot(p0, p0)*dot(p1, p1));\n  float o = acos(d);\n  float c = inversesqrt(1.0-d*d); // Cheaper than computing (1.0/sin(o))?\n  return (sin((1.0-t)*o)*p0 + sin(t*o)*p1)*c; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  float n = floor(p.x);\n  p.x = fract(p.x)-0.5;\n  \n  vec3 col = vec3(0.01);\n  if (abs(n+0.5) < 1.0) {\n    const float r = 0.4;\n    float t = smoothstep(-0.9, 0.9, sin(TIME));\n    vec2 p0 = r*vec2(0., 1.0)*ROT(-1.5*sin(sqrt(0.5)*TIME));\n    vec2 p1 = r*vec2(1.0, 0.0);\n    vec2 p2 =\n      (n == 0.0)\n      ? slerp(p0, p1, t)\n      : r*normalize(mix(p0, p1, t))\n      ;\n  \n    float lw = aa*2.0;\n    float d0 = segment(p, vec2(0.0), p0)-lw;\n    float d1 = segment(p, vec2(0.0), p1)-lw;\n    float d2 = segment(p, vec2(0.0), p2)-lw;\n    float dc = length(p) - r;\n    col = mix(col, vec3(0.1, 0.1, 0.1), smoothstep(aa, -aa, dc));\n    col = mix(col, vec3(0.5, 0.0, 0.0), smoothstep(aa, -aa, d0));\n    col = mix(col, vec3(0.0, 0.5, 0.0), smoothstep(aa, -aa, d1));\n    col = mix(col, vec3(0.5, 0.5, 0.0), smoothstep(aa, -aa, d2));\n  }\n  \n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}