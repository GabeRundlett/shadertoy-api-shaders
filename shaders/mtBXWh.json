{
    "Shader": {
        "info": {
            "date": "1675980937",
            "description": "Hopefully this will turn into a kind of \nzoomable user interface for browsing \nand editing textual information.",
            "flags": 48,
            "hasliked": 0,
            "id": "mtBXWh",
            "likes": 0,
            "name": "WIP: fisheye view of text plane",
            "published": 3,
            "tags": [
                "sdf",
                "sphere",
                "projection",
                "fisheye",
                "font",
                "zui",
                "zoomableuserinterface"
            ],
            "usePreview": 0,
            "username": "e4iso",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o, in vec2 p) {\n  o = texture(iChannel0, p.xy / iResolution.xy); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/* a circle that is a viewport to a plane\n * \n * https://registry.khronos.org/OpenGL-Refpages/es3.0/\n * https://www.ronja-tutorials.com/post/034-2d-sdf-basics/\n * https://iquilezles.org/articles/distfunctions2d/\n * https://github.com/CesiumGS/cesium\n * https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n * https://github.com/microsoft/monaco-editor\n * * https://github.com/scalameta/metabrowse\n * * https://github.com/benhutchison/scalajs-monaco-editor/blob/master/src/main/scala/facade/monacoEditorFacade.scala\n *\n * https://www.shadertoy.com/view/XtG3Rt (sliders, digits, draganddrop)\n * https://www.shadertoy.com/view/lddXzM (Shadertext)\n */\n// ----------------------------------------------------------------------------------------------------------------------\n// read/write\nconst vec2 activeUIAddress = vec2(0,4);\nconst vec4 bitShL          = vec4(    16777216.0,     65536.0,     256.0, 1.0);\nconst vec4 bitShR          = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\nbool  isCell(in vec2 p, in vec2 a) { return floor(p) == a;}\nvoid  savePixel(vec4 val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=val;}\nvec4  readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nvec4 packInt(int val) { // only positive int\n  vec4 res = floor(float(val)*bitShR);\n  res.yzw -= res.xyz*256.0;\n  return res;\n}\nfloat unpackInt( const in vec4 value ){ return dot(value, bitShL);}\nvoid saveInt(int val, vec2 address, inout vec4 col, vec2 p){if(isCell(p, address)) col= packInt(val);}\nfloat readInt(vec2 address){ return unpackInt(readPixel(address));}\nvec4 packFloat(const in float val){ // +-2147483 with 3 digit float precigion\n  bool negative = sign(val)==-1.;\n  vec4 res      = floor(abs(val)*1000.0*bitShR);\n  res.gba      -= res.rgb*256.0;\n  if(negative) res.r+=256.;\n  return res;\n}\nfloat unpackFloat( in vec4 val){\n  float m = 1.0;\n  if(val.r>=256.){ val.r-=256.; m=-1.0; }   \n  return dot(val, bitShL)/1000.*m;\n}\nvoid  saveFloat(float val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=packFloat(val);}\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n// ----------------------------------------------------------------------------------------------------------------------\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius) { vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat slider(in int intId, in vec4 conf, in vec2 loc, in vec2 sp, inout vec4 col, inout float ui) { \n  float id         = float(intId);\n  float val        = readFloat(vec2(id,0));                               // read saved value \n  vec4  data       = readPixel(vec2(id,3));\n  float activeUIID = readInt(activeUIAddress);    \n  float slui       = dfBoxRounded(floor(sp), vec4(loc,124,20), 5.0);\n  slui             = max(-slui-2.0, slui);    \n  if(data.x==0.) {                                                        // set default value\n    val = conf.x; data.x=.05;\n    saveFloat(val, vec2(id,0), col, sp);\n  } if(iMouse.z <= 0.) {                                                  // on mouse up\n    data.g = 0.;                                                          // stop drag this point\n    savePixel(vec4(0), activeUIAddress, col, sp);                         // unlock other controlls\n  } else if(dfBox(iMouse.xy, vec4(loc, 120, 20))<2. && activeUIID==0.0) { // on press\n    data.g = .05;                                                         // start drag this point\n    saveInt(int(id),activeUIAddress, col, sp);                            // lock other controlls\n  } else if(data.g>0.0 && activeUIID==id) {                               // on mouse drag\n    float distanceFromLeftEdge = clamp(iMouse.x, loc.x, loc.x+120.0)-loc.x;\n    val = mix(conf.y, conf.z, distanceFromLeftEdge/120.0);\n    val = floor(val/conf.w) * conf.w;        \n    saveFloat(val, vec2(id,0), col, sp);\n  }\n  slui = min(slui, dfBoxRounded(floor(sp), vec4(loc+vec2(2,2),120.0*(val-conf.y)/(conf.z-conf.y),16), 3.0) );\n//ui   = min(ui, -drawFloat(val,    2.0, sp, loc+vec2(128,  8), 1)); // val   \n//ui   = min(ui, -drawFloat(conf.y, 2.0, sp, loc+vec2(  0, 24), 1)); // from   \n//ui   = min(ui, -drawFloat(conf.z, 2.0, sp, loc+vec2( 80, 24), 1)); // to   \n//ui   = min(ui, -drawFloat(conf.w, 2.0, sp, loc+vec2( 50,-10), 1)); // step    \n  ui   = min(ui, slui);     \n  savePixel(data, vec2(id,3), col, sp);     \n  return val;    \n}\n// ----------------------------------------------------------------------------------------------------------------------\n// Shadertoy specific stuff...\nvec4 mouse()                { return iMouse / min(iResolution.x, iResolution.y); }\nbool iKeyPressed(int ascii) { return (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.); }\n\nint KeySpace = 32;\nint KeyA     = 65;\nint KeyB     = 66;\nint KeyC     = 67;\nint KeyD     = 68;\nint KeyE     = 69;\nint KeyF     = 70;\nint KeyG     = 71;\nint KeyH     = 72;\nint KeyI     = 73;\nint KeyJ     = 74;\nint KeyK     = 75;\nint KeyL     = 76;\nint KeyM     = 77;\nint KeyN     = 78;\nint KeyO     = 79;\nint KeyP     = 80;\nint KeyQ     = 81;\nint KeyR     = 82;\nint KeyS     = 83;\nint KeyT     = 84;\nint KeyU     = 85;\nint KeyV     = 86;\nint KeyW     = 87;\nint KeyX     = 88;\nint KeyY     = 89;\nint KeyZ     = 90;\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----- >>> character drawing <<< --------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// vec2  v00 = vec2(0., 0.);  // (.0, .0)\n// vec2  v01 = vec2(3., 4.);  // (.3, .4)\n\nstruct fmt { // format\n  float Xw;\n  float Xh;\n  float xw;\n  float hx;\n  float wo;\n  float Xx;\n  vec2 X11;\n  vec2 X12;\n  vec2 X21;\n  vec2 X22;\n  vec2 x11;\n  vec2 x12;\n  vec2 x21;\n  vec2 x22;\n};\nfmt createFmt(float Xw,float Xh,float xw,float hx,float wo) {\n  return fmt(\n    Xw,Xh,xw,hx,wo,\n    Xh-hx,\n    vec2(Xw,Xh),vec2(Xw,-Xh),vec2(-Xw,Xh),vec2(-Xw,-Xh),\n    vec2(xw,hx),vec2(xw,-hx),vec2(-xw,hx),vec2(-xw,-hx)\n  );\n}\n\nstruct pnt { // point\n  vec2 P;\n  vec2 p;\n  vec2 Abs;\n  vec2 abs;\n  vec2 Xabs;\n  vec2 Neg;\n  vec2 NegX;\n};\npnt createPnt(fmt f, vec2 P) {\n  vec2 p = vec2(P.x, P.y + f.Xx);\n  return pnt(P,p,abs(P),abs(p), vec2(abs(P.x),P.y), -P, vec2(-P.x, P.y));\n}\n\nstruct bdl { // bounding lines\n  vec2 lbl1; // upper point of left bounding line\n  vec2 lbl2;\n  vec2 rbl1;\n  vec2 rbl2;\n};\n\nvec2   py(vec2 p,float dy) { return vec2( p.x,p.y+dy); }\nvec2   lc(vec2 p)          { return py(p, 2.); }\nvec2 absx(vec2 p)          { return vec2(abs(p.x), p.y); }\nvec2 P00 = vec2(0., 0.); // centre of 'X'\n// ----------------------------------------------------------------------------------------------------------------------\n// These functions are re-used by multiple letters\nfloat line(vec2 p,vec2 a,vec2 b){vec2 c=p-a;vec2 d=b-a;float h=clamp(dot(c,d)/dot(d,d),0.,1.);return length(c-d*h);}\nvec2     dx(vec2 p, float dx){return vec2(p.x+dx,p.y);}\nfloat   _sY(vec2 p, float dy){return length(vec2(p.x, max(0.,abs(p.y)-dy)));}  // stretch Y\nfloat   _i(vec2 p, fmt f) { return length(vec2(p.x,       max(0.,abs(p.y)-f.hx)                 )); }\nfloat   _l(vec2 p,fmt f){return _sY(p, f.Xh); }  // 6. = f.hY\nfloat   _u(vec2 p,float w,float v) { return length(vec2(abs(length(vec2(p.x,max(.0,-(6.-v)-p.y)))-w),max(.0,p.y-2.))); }\nvec2  lcnx(vec2 p) { return vec2(-p.x,p.y+2.); }\n//float  _pp(vec2 p,fmt f) { return min(_o(p,f),_l(p+vec2(2.5,4.))); }\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n\n\nconst int XX = 88;\nconst int YY = 89;\nconst int bb = 98;\nconst int dd = 100;\nconst int oo = 111;\nconst int pp = 112;\nconst int xx = 120;\n\n/*'X'*/float u0058(pnt p,fmt f){return line(p.Abs,P00,f.X11);}\n/*'Y'*/float u0059(pnt p,fmt f){return min(line(p.Neg,P00,f.X11),line(p.Xabs,P00,f.X11));}\n/*'o'*/float u006f(pnt p,fmt f){return abs(_sY(p.p,f.hx-f.wo)-f.wo);}\n/*'b'*/float u0062(pnt p,fmt f){return min(u006f(p,f),_l(dx(p.P, f.wo),f));}\n/*'d'*/float u0064(pnt p,fmt f){return u0062(createPnt(f,p.NegX),f);}\n/*'x'*/float u0078(pnt p,fmt f){return line(p.abs,P00,f.x11);}\n\nbdl charWidth(int c, fmt f) { switch(c) { // left and right bounding lines\n  case XX:return bdl(f.X21,f.X22,f.X11,f.X12);break;\n  case YY:return bdl(f.X21,f.X22,f.X11,f.X12);break;\n  case bb:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n  case dd:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n  case oo:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n  case xx:return bdl(f.x21,f.x22,f.x11,f.x12);break;\n}; }\n\nfloat char(pnt p, int c, fmt f) { switch(c) {  // calculates the signed distance from point p to character c - formatted with f\n  case XX:return u0058(p,f);break;\n  case YY:return u0059(p,f);break;\n  case xx:return u0078(p,f);break;\n  case bb:return u0062(p,f);break;\n  case dd:return u0064(p,f);break;\n  case oo:return u006f(p,f);break;\n}; }\n\nint text[] = int[](dd,bb,oo,xx,YY,XX);\n\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\nfloat r  = 1.; // radius of circle at end of line (half line with)\nfloat cd = 2.; // character distance\n\n\nfloat xyz(vec2 p, fmt f) {\n  float tl2    = 0.; \n  float d      = 100000.;\n  float dx     = 0.;\n  for (int i=0; i<text.length(); i++) { \n    int   c  = text[i];\n    bdl bdl2 = charWidth(c, f);\n    float cw = max(bdl2.rbl1.x, bdl2.rbl2.x) + r;\n    if (i > 0) dx += cw;\n    d = min(d, char(createPnt(f, vec2(p.x - dx, p.y)), c, f) - r); // +// float(text.length())*.5;\n    dx += cw + cd;\n  };\n  return d;\n}\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n/* A grid of columns and rows helps visualizing a projection.\n * @return signed distance to grid lines\n */ \nfloat grid(vec2 p, float lineDistance, float lineWidth) { vec2 g = mod(p +.5 * lineWidth, lineDistance) - lineWidth; return min(g.x, g.y); }\nfloat lH(vec2 p, float y, float r) { return abs(p.y-y)-r; } // horizontal line\nfloat lV(vec2 p, float x, float r) { return abs(p.x-x)-r; } // vertical line\nfloat y[] = float[](6., 2., -2., -6., -10.);\nfloat llH(vec2 p) { float d = lH(p,0.,0.2); for (int i=0;i<y.length();i++) d = min(d,lH(p,y[i],0.1)); return d; }\nfloat llV(vec2 p, float cw) { float d = lV(p,0.,0.2); d = min(d,lV(p,cw,0.1)); return min(d,lV(p,-cw,0.1)); }\nfloat crosshair(vec2 p, float cw) { return min(llH(p), llV(p, cw)); }\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\nconst vec4  backgroundColor = vec4(.1, .1, .1, 1.);\nconst vec4  foregroundColor = vec4(.2, .2, .2, 1.);\nconst vec4  crosshairColor  = vec4(.6, .0, .2, 1.);\nconst float da              = 0.; // 6. - data area height\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\nvoid mainScene(inout vec4 col, in vec2 sp) {\n  fmt  myFmt         = createFmt(3., 6., 2., 4.,2.5);  // makeFormat(1., .2, 0., false, 0.);\n  bool withCrosshair = true;\n  vec2 center        = vec2(0., 0.); // center: the point on the plane that shall be in the center of the circle\n  \n  float viewPortScale = 1.; // ##### how much of the viewport do i see? #####          2. * sin(1.7 * iTime) + 1.;\n  if (iKeyPressed(KeyA)) { viewPortScale =  .00; }\n  if (iKeyPressed(KeyS)) { viewPortScale = -.25; }\n  if (iKeyPressed(KeyD)) { viewPortScale = -.50; }\n  if (iKeyPressed(KeyF)) { viewPortScale = -.75; }\n  if (iKeyPressed(KeyG)) { viewPortScale = -1.0; }\n  \n  \n  int   model         = 0;\n//float ui            = 0.;\n//viewPortScale = slider(3, vec4(1, -1, 1, .10), vec2(5, 85), sp, col, ui); // #############################################################################################\n//dx            = slider(4, vec4(1, -1, 2, .02), vec2(5, 45), sp, col, ui); // #############################################################################################\n//dy            = slider(5, vec4(1, -1, 2, .02), vec2(5,  5), sp, col, ui); // #############################################################################################\n  float vpScale = 1./min(iResolution.x,iResolution.y)/pow(2.5,1.*(viewPortScale+1.));\n  vec2  point   = 2. * sp - iResolution.xy;\n  vec2  circle  = point * vpScale;\n  float len     = length(circle);\n  if (len > 1. && sp.y > 5.) { col = backgroundColor; return; }\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n  /* And what is the projection from the plane to the circular viewport?\n   * computes the fisheye view within the circle distance ∈ [0, ∞[\n   */\n  vec2 plane = circle * 0.90 * (1. / (1. - len) - 1.)  / len; \n  switch (model) {\n    case  0: plane = circle * 0.95 * tan(radians(90. * len)) / len; break;\n  };\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n  float zoom = 80. * vpScale;   // ##### how big shall text at the center point be? #####\n  if (iKeyPressed(KeyQ)) { zoom *= pow(2.5, -1.); }\n  if (iKeyPressed(KeyW)) { zoom *= pow(2.5, -2.); }\n  if (iKeyPressed(KeyE)) { zoom *= pow(2.5, -3.); }\n  if (iKeyPressed(KeyR)) { zoom *= pow(2.5, -4.); }\n  if (iKeyPressed(KeyT)) { zoom *= pow(2.5, -5.); }\n  \n  vec2  info          = (plane + center) / zoom;\n  vec4  c             = foregroundColor;\n  if (withCrosshair) {\n//  if (crosshair(info, charWidth(text[0], myFmt)) < .0) c.r = 0.6;\n  }\n//if (grid(plane,  0.1, 0.02) > .0) c.b = 1.;\n  if (iKeyPressed(KeySpace)) { if (grid(circle, 1., 0.2) > .0) c.g = .4; } //SPACE\n  if (grid(info,   1., 0.1) < .0) c.b = 1.;\n  if (length(info) - 6.*r   < .0) c.g = .4;\n//if (length(info) -    r   < .0) c.g = .6;\n  if (xyz(info, myFmt)      < .0) c.r = .8;\n//if (ui   < .0)  c.g = 0.8;\n  if (sp.y >= da)  col = c;  //draw only on non data area // mix(col, vec4(1., 0.6, 0.1, 1.0), simpleFill(ui));\n}\nvoid mainImage( out vec4 o, in vec2 p ){ \n  o = (p.y < da) ? texture(iChannel0,p.xy / iResolution.xy) : vec4(0);  //data for next frame\n  mainScene(o, p);   \n}\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n/*\n//////////////////////////////\n//   Read Write             //\n//////////////////////////////\n\nvec4 packNormal( const in float value) { // only positive in range 0-1\n  vec4 res = fract( value*bitShL );\n  res.yzw -= res.xyz/256.0;\n  return res;\n}\nfloat unpackNormal(const in vec4 value) { return dot(value, bitShR);}\n\nvoid saveIntVec2(vec2 val, float id, inout vec4 col, vec2 p) {\n  saveInt(int(val.x), vec2(id,0.0), col, p);        \n  saveInt(int(val.y), vec2(id,1.0), col, p);\n}\n\n////// Constants ////////////////////////////////////////////////////////////////////////\nconst float PI    = 3.14159265358979323846;\nconst float SQRT2 = 1.41421356237309504880;\n\n////// 2D Transformations ///////////////////////////////////////////////////////////////\nvec2 translate(vec2 p, vec2 t){\treturn p - t;}\nvec2 scale(vec2 p, float s){ return p * mat2(s, 0, 0, s);}\nvec2 rotate(vec2 p, float a){return p * mat2(cos(a), -sin(a), sin(a), cos(a));}\nvec2 rotateCCW(vec2 p, float a){\treturn p * mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n////// 2D Matrix Transformations /////////////////////////////////////////////////////////\nmat3 rotate(float r){float c = cos(r), s = sin(r); return mat3(c,-s,0,  s,c,0,  0,0,1);}\nmat3 scale(float s){ return mat3(s,0,0, 0,s,0, 0,0,1);}\nmat3 translate(vec2 p) { return mat3(1,0,p.x, 0,1,p.y, 0,0,1);}\nmat3 skew(float r) { return mat3(1,tan(r),0, 0,1,0, 0,0,1);}\nmat3 skewVert(float r) { return mat3(1,0,0, tan(r),1,0, 0,0,1);}\nmat3 inverse2x3(mat3 m){\n      float a=m[0][0], b=m[0][1], c=m[0][2], d=m[1][0], e=m[1][1], f=m[1][2], t=a*e-b*d;\n      return mat3(e/t, -b/t, (f*b-c*e)/t, -d/t, a/t, (-f*a+c*d)/t, 0, 0, 1);\n}\nvec2 transform(vec2 p, mat3 m){ return (vec3(p,1)*m).xy;}\n////// Distance field functions //////////////////////////////////////////////////////////\n\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfRoundedBox(vec2 p, vec2 size, float radius){size -= vec2(radius);vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\n\nfloat dfCircle(vec2 p, float radius){\t\n    return length(p) - radius;\n}\nfloat dfLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n////// UI /////////////////////////////////////////////////////////////////////////////////\nfloat extract_bit(float n, float b){ return mod(floor(n/exp2(floor(b))),2.0);}\nfloat extract_decimal(float n, float index){ return mod(n/pow(10.0, index),10.0);}\n\n\nfloat drawDigit(int n, vec2 p) { \n  p=floor(p);\n  int i = n== 0?0x69996:\n          n== 1?0x62227:\n          n== 2?0xE168F:\n          n== 3?0xE161E:\n          n== 4?0x99711:\n          n== 5?0xF8E1E:\n          n== 6?0x68E96:\n          n== 7?0xF1244:\n          n== 8?0x69696:\n          n== 9?0x69716:\n          n==10?0x00700:\n          n==11?0x00004:\n                0xFFFFF;\n  return extract_bit(float(i), mod(p.y,5.0) * 4.0 + 3.0-p.x);\n}\n\nfloat drawFloat(in float val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    p-=location; p/= float(zoom);\n    float n = floor(p.x / 5.0); //current char index \n    p.x -= n*5.; //move origin\n    if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.) return 0.; //out of digit bounds\n    if(sign(val)<0.0){if(n==0.) return drawDigit(10, p);n-=1.; val=abs(val);}  //draw minus sign \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    float count = intCount + fractPrecision; //totla number of digits to print \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    if(intCount <= n){if(intCount == n) return drawDigit(11, p); n-=1.0;}  //draw dot  \n    if(count <= n)  return 0.0; //no need to draw more\n    return drawDigit(int(extract_decimal(val, count-n-1.)), p); //draw digit   \n}\nfloat drawVec2(in vec2 val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    float r =drawFloat(val.y,fractPrecision, p, location, zoom);\n    r+=drawFloat(val.x,fractPrecision, p, location+vec2(0,6*zoom), zoom);\n    return r;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n\nvec2 controlPoint(float id, vec2 loc, mat3 stv, vec2 sp, inout vec4 col, inout float ui){\n    \n    vec4 data = readPixel(vec2(id,3));\n    float activeUIID = readInt(activeUIAddress);\n    vec2 m = transform(iMouse.xy, stv); //viewport mouse position \n    vec2 pos = vec2(readFloat(vec2(id,0)),readFloat(vec2(id,1)));//read saved value \n    \n    \n    if(data.x==0.){ //set default value\n        pos = loc; data.x=.05;\n    \tsaveFloat(pos.x, vec2(id,0), col, sp);\n    \tsaveFloat(pos.y, vec2(id,1), col, sp);\n    }\n    vec2 spos = transform(pos, inverse2x3(stv));\n    \n    if(iMouse.z <= 0.){//on mouse up\n        data.g = 0.;//stop drag this point\n        savePixel(vec4(0), activeUIAddress, col, sp);//unlock other controlls\n    }else if(distance(spos, iMouse.xy)<20. && activeUIID==0.0){//on press\n        data.g = .05;//start drag this point\n        saveInt(int(id),activeUIAddress, col, sp);//lock other controlls\n        \n    }else if(data.g>0.0 && activeUIID==id){//on mouse drag\n        pos = m;//drag this point\n        spos = iMouse.xy;//drag this point\n    \tsaveFloat(pos.x, vec2(id,0), col, sp);\n    \tsaveFloat(pos.y, vec2(id,1), col, sp);\n    } \n    \n    ui = min(ui, -drawVec2(pos, 2.0, sp, spos+vec2(10,-5), 1));    \n    ui = min(ui, dfCircle(sp-spos, 6.));\n    \n    savePixel(data, vec2(id,3), col, sp); \n    \n    return pos;\n}\n\n\n/////// Combine distance field functions //////////////////////////////////////////////////\nfloat merge(float d1, float d2){return min(d1, d2);}\n\n\n////// Grid //////////////////////////////////////////////////////////////////////////////\nfloat chessboard(vec2 p){ p=floor(p*2.0); return mod(p.x+p.y, 2.0);}\n\n\n/////////////////////////////////////////////////////////////////\n//    Bezier                                                  //\n///////////////////////////////////////////////////////////////\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c){\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n// Find the unsigned distance from a point to a bezier curve\nfloat usBezier(vec2 A, vec2 B, vec2 C, vec2 p){    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;\n}\n\n\n////// Masks for drawing /////////////////////////////////////////////////////////////////\n\nfloat hardFill(float d){return step(0.0, -d);}\nfloat fill(in float d, in float softness, in float offset){\n    return clamp((offset +softness*.5 - d)/softness, 0.0, 1.0);\n}\nfloat simpleFill(float d){return clamp(-d, 0.0, 1.0);}\nfloat sharpFill(in float d){return clamp(.5-d, 0.0, 1.0);} //same as fill(d, 1.0, 0.0)\nfloat stroke(in float d, in float softness, in float offset, in float width){ \n   d = abs(d-offset);\n   return clamp((width/2.0 +softness*.5 - d)/softness, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainScene(inout vec4 col, in vec2 sp ){\n    \n    float zoom = 1.;\n   \n    //viewport transformation matrix \n    mat3 screenToView = translate(-iResolution.xy / 2.0)*scale(zoom); \n    mat3 screenToView2 = translate(vec2(-iResolution.x / 2.0, -25))*scale(0.025); \n    \n    //ui elements\n    float ui = 0.;\n    vec2 pt1 = controlPoint(1.0, vec2(-125, -40), screenToView, sp, col, ui);\n    vec2 pt2 = controlPoint(2.0, vec2(-35, 122), screenToView, sp, col, ui);    \n    vec2 pt3 = controlPoint(3.0, vec2(115, 40), screenToView, sp, col, ui);     \n    \n    ///////////////// output /////////////////\n    if(sp.y > 80.){ //viewport 1\n        \n        \n        vec2 p = transform(sp.xy, screenToView);  //viewport pixel position\n        // background     \n        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient\n        col.r -= .03*chessboard(p*.05); //grid2  \n        \n        // scene\n        float lines = merge(dfLine(p, pt1, pt2), dfLine(p, pt3, pt2));\n        float bz = usBezier(pt1, pt2, pt3, p);    \n        float cc = dfCircle(p, 50.);\n\n        col = mix(col, vec4(1.0, 0.7, 0.9, 1.0), stroke(cc, softness * zoom, offset * zoom, width * zoom));         \n        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), stroke(bz, softness * zoom, offset * zoom, width * zoom)); \n        col = mix(col, vec4(0.2, 0.2, 0.2, 1.0), stroke(lines, zoom, .0, .5*zoom));\n        \n    }else if(sp.y > 5.){ //viewport 2    \t\n        vec2 p = transform(sp.xy, screenToView2);         \n        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient\n        col.rgb -= .03*chessboard(p*.5); //grid2         \n        \n        float fn = stroke(p.x, softness, offset, width);\n        float ln = p.y < fn ? -1. : 0.;\n        col = mix(col, vec4(.4, 0.4, 0.4, 1.0), simpleFill(ln));\n        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), 1.0-step(simpleFill(ln)*p.y,.0));\n        col = mix(col, vec4(.3,.3,.3,1), hardFill(dfRoundedBox(p,vec2(.05,10), .0)));\n        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(5,0),vec2(.025,10), .0)));\n        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(-5,0),vec2(.025,10), .0)));\n    }\n    \n}\n*/\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n// ----------------------------------------------------------------------------------------------------------------------\n\n/*\n      val xh = 0.2 - (0.2 + 0.2) * 2 / 3\n\n      val X1: IsoPoint = IsoPoint(-1, -2) // 1--2--3\n      val X2: IsoPoint = IsoPoint(0, -2)  // |\\ | /|\n      val X3: IsoPoint = IsoPoint(1, -2)  // | \\|/ |\n      val X4: IsoPoint = IsoPoint(-1, 0)  // 4--5--6\n      val X5: IsoPoint = IsoPoint(0, 0)   // | /|\\ |\n      val X6: IsoPoint = IsoPoint(1, 0)   // |/ | \\|\n      val X7: IsoPoint = IsoPoint(-1, 2)  // 7--8--9\n      val X8: IsoPoint = IsoPoint(0, 2)\n      val X9: IsoPoint = IsoPoint(1, 2)\n\n      def lx(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, xh), IsoPoint(0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(0.1 + dx, xh), IsoPoint(-0.1 + dx, 0.2))\n      )\n      def lz(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, xh), IsoPoint(0.1 + dx, xh)),\n        IsoLine(IsoPoint(0.1 + dx, xh), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(0.1 + dx, 0.2))\n      )\n\n      def lX(dx: Double): Seq[IsoLine] = Seq(IsoLine(X1, X9), IsoLine(X3, X7))\n\n      def lY(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(0.0 + dx, 0.0), IsoPoint(-0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2))\n      )\n      def lZ(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(0.1 + dx, 0.2))\n      )\n      def lH(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(0.1 + dx, -0.2), IsoPoint(0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.0), IsoPoint(0.1 + dx, 0.0))\n      )\n      def lV(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.0 + dx, 0.2)),\n        IsoLine(IsoPoint(0.0 + dx, 0.2), IsoPoint(0.1 + dx, -0.2))\n      )\n      def lT(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(0.0 + dx, -0.2), IsoPoint(0.0 + dx, 0.2))\n      )\n      def lL(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(-0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(0.1 + dx, 0.2))\n      )\n      def lN(dx: Double): Seq[IsoLine] = Seq(\n        IsoLine(IsoPoint(-0.1 + dx, 0.2), IsoPoint(-0.1 + dx, -0.2)),\n        IsoLine(IsoPoint(-0.1 + dx, -0.2), IsoPoint(0.1 + dx, 0.2)),\n        IsoLine(IsoPoint(0.1 + dx, 0.2), IsoPoint(0.1 + dx, -0.2))\n      )\n*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}