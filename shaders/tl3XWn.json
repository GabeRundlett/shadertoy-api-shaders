{
    "Shader": {
        "info": {
            "date": "1581949213",
            "description": "just learning, left click to rotate the camera.1",
            "flags": 0,
            "hasliked": 0,
            "id": "tl3XWn",
            "likes": 10,
            "name": "Learning aboat Raymarch",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "firegump",
            "viewed": 1484
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n  \tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    return length(p - c) - r;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n  \tvec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap)/dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t- .5) - .5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x,y), 0.);\n        \n    return e + i ;\n}\nfloat sdTorus(vec3 p, vec2 r){\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\nfloat sdBox(vec3 p, vec3 s){\n    p = abs(p)-s;\n    float  i = min(max(p.x, max(p.y, p.z)), 0.);\n    float  e = length(max(p, 0.));\n\treturn e + i ;\n    \n}\n\nfloat GetDist(vec3 p){ //p is the sample point\n    float t = iTime;\n    float t1 = t* 0.9;\n    float t2 = t* 0.08;\n    float y = -fract(t1)*(fract(t1)-1.);\n    y *= 3.;\n    float planeDist = p.y;\n    \n    for(int i = 1; i < 9;i++){\n        float j = float(i)*8.;\n        float c= fract(sin( float(i) * 100.) * 5377.)* 6.283;\n        \n        float m = -fract(t2 *float(i)+c)*(fract(t2*float(i)+c)-1.);\n        m *= 1.;\n    \tvec4 sr = vec4(-15.+ float(i)*3. + sin(t2+float(i)),-.3 + m*15. , 0.+cos(t2*float(i))*2., .8 );\n        sr.w *= sin(m)*3.;\n        sr.xyz += sin(m);\n     \n        float sdr = length(p - sr.xyz) - sr.w;\n        \n        vec4 sc = vec4( 0.+cos(t2*float(i))*2.,-.3 + m*15. + cos(t1+float(i))*3.,-15.+ float(i)*3. + sin(t2+float(i)), .8);\n        sc.w *= sin(m)*3.;\n        sc.xyz += sin(m);\n        float sdc = length(p - sc.xyz) - sc.w;\n        \n        \n        float sdf = smin(sdr, sdc , .7);\n        \n        for(int e; e<5; e++){\n            \n            float Rr = float(e)*3.;\n            \n            vec4 sq = vec4(sin(j+Rr)*Rr,-.3+m*15.*((c/6.283)*.3+.7),cos(j)*Rr,.7*m);//around sphere\n            sq.xyz += m*1.;\n            sq.w += m*.1 + (c/6.283)*.1;\n            float sdq = length(p - sq.xyz) - sq.w;\n\n            sdf = smin(sdf, sdq, .7);\n        }\n        \n        \n        planeDist = smin(planeDist, sdf, 0.5);\n        \n    }\n    \n    vec4 sA = vec4(0, 1.2 + y,0,1);\n    float sdA = length(p - sA.xyz) - sA.w;\n   \n    vec4 sB = vec4(0., -.4 + y , 0, 1.1);\n    float sdB = length(p - sB.xyz) - sB.w;\n    \n    \n    float sd = sdB;\n    \n    float td = sdTorus(p - vec3(0, 2.2 + y*2., 0), vec2(0.7+ y*.3, 0.27));\n    sd = smin(sd,td,0.5);\n    \n    float Cad = sdCapsule(p, vec3(0,1. + y *2.,0), vec3(0, 0,0), 0.7);\n    sd = smin(sd, Cad,0.5);\n    \n    \n    float tda = sdTorus(p - vec3(0,fract(-t1)*2., 0), vec2(0.5*(abs(sin(t*2.))), 0.27));//absorb\n    sd = smin(sd, tda, 0.5);\n    \n    vec3 bp = p - vec3(0, 1 , 0);\n    bp.xz *= Rot(iTime);\n    \n    float BoxDist = sdBox(bp, vec3(.7));\n    \n    float CylDist = sdCylinder(p, vec3(2, 0.3,2), vec3(6, 0.3,5), 0.3);\n    \n    sd = smin(BoxDist, sd, 0.7);\n    float d= smin(sd, planeDist, 0.7); \n    \n    //float planeDist1 = 9.- p.y;//ceil\n    \n   \t//d = smin(d, planeDist1, .7);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i = 0 ; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(GetDist(p - e.xyy),//same to vec3(d- d1, d- d2, d- d3);\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    \n   \n    return normalize(n);\n}\n\n\nvec3 GetLight(vec3 p,vec3 rd,vec3 lightPos, vec3 lightCol){\n\tvec3 v = -rd;\n    ;\n    \n    //attenuation\n    float atten = 1. - length(lightPos - p)/21.;//float is light Area\n    \n    float MoveRadius = 0.;\n    float MoveSpeed = 0.;\n    \n    float t = iTime * MoveSpeed;\n    lightPos.xz += vec2(sin(t), cos(t)) * MoveRadius;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    vec3 ref = reflect(n,rd);\n    //ambient\n    float amb = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n    //diffuse\n    float NdotL = dot(n, l);\n    NdotL = NdotL*.5 + .5;\n    float dif = clamp(NdotL, 0. , 1.);\n    //specular\n    vec3 h = normalize(l + v);\n    float spe = pow(max(dot(n,h),0.), 128.);\n    //fresnel\n    //float fs = .4; //fresnel scale\n    \n    \n    \n    \n    \n    float fre =  clamp(  1.+ dot(rd,n)       ,0.,1.);\n    fre = pow(fre, 1.4);\n    //dom\n    float dom = smoothstep( -0.2, 0.2, ref.y );\n    \n    \n    vec3 finCol = vec3(0.); \n    finCol += amb * vec3(1,1,0) * .5;\n    finCol += dif * vec3(1,1,1) * .5;\n    finCol += spe * vec3(1,1,1) * 2.;\n    finCol += fre * vec3(.3,0,1) * 2.;\n   \tfinCol += dom * vec3(0,1,1) * 0.3;\n    \n    \n    finCol *= atten*lightCol;\n    finCol *= 1.;\n    //finCol = vec3(dom);\n    //shadow\n    float d = RayMarch(p + n * SURF_DIST *2. , l);// 2. is fixed the center of the sphere sample\n    if(p.y< 0.01 && d < length(lightPos - p))\n    {\n        finCol *= 0.3;\n    }\n    return finCol;\n    \n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m -= 0.5;\n    //m.y *= .2;\n    vec3 col = vec3(0);\n    \n    //camera position\n    vec3 ro = vec3(0,5,-20.);\n    //ro.yz *= Rot(-m.y+.4);\n    //ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    ro.yz *= Rot(-m.y + 0.4);\n    ro.xz *= Rot(-m.x*6.2831+ iTime );\n     \n    vec3 rd = R(uv, ro, vec3(0,1.,0), 2.);\n    \n    \n    \n\tfloat d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec3 lightPos = vec3(-2, 9., -4);\n    vec3 lightCol = vec3(1, 1 ,1);\n    col = GetLight(p,rd,lightPos, lightCol);\n    \n    \n    //col = vec3(dif);\n    \n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}