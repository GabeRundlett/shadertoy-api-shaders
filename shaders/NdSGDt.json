{
    "Shader": {
        "info": {
            "date": "1618091402",
            "description": "Add thyme...\n\nProbably not the best way to tell the time...\nThe clocks are set anyway though!",
            "flags": 0,
            "hasliked": 0,
            "id": "NdSGDt",
            "likes": 10,
            "name": "Clock Soup Vortex",
            "published": 3,
            "tags": [
                "clock",
                "wip",
                "soup"
            ],
            "usePreview": 0,
            "username": "Pelegefen",
            "viewed": 426
        },
        "renderpass": [
            {
                "code": "\n// number of layers to render, go over 3.5 only if you have a strong GPU! \n// min is 1.1\n#define NUM_LAYERS 3.5\n\n#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\n\n\nfloat Hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(smoothstep(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r, float dr) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn smoothstep(r, 0.7*r, d);\n}\n\n\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n    1. * RES.y/RES.x * w, .5);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/9.,/* Height*/ l - .2),1.);\n    col += Triangle ;\n   \n    \n    \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n      w, .5);\n    uv.y += .02;\n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/4. * w,/* Height*/ l - .2),1.);\n    col += Triangle ;\n    col = mix(Triangle, shape, .5);\n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .5;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    //uv.x = PolarCoord(uv);\n    \n    uv = polarMap(uv + .5, -.2486 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n    \n    \n    vec2 id = floor(uv * 24.  );\n    \n    float idF = (id.x / id.y);\n\n    col *= vec4(idF,idF,idF,1.)    ;\n    \n    col += circle(uv - vec2(0.,.5 ),1., .001 );\n    col += segment(uv / 60. * m ,vec2(0. ,0.0), vec2(6. ,2.),.01) * .5 ;\n    if(id.x <=  .5 && id.y <= 24.) return col = vec4(.35);\n    col += segment(uv,vec2(.0 ,0.9), vec2(.8 ,0.9),.1);\n    \n    \n    \n    float h = segment(uv,vec2(-.8 ,0.5),\n     vec2(.8 ,0.5),.2);\n    vec4 tx = texture(iChannel0,uv);\n    col +=  h; \n    col += col *  tx;\n    col = mix(col, tx, col) * .4;\n    \n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = texture(iChannel0,uv);// sample wood tex\n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = 1. - (circle(uv,4.3, .025 ) );//clocks frame bevel\n    f -= fm;\n    col += f;\n    \n    //Decoration at 12 o'clock\n    col -= circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .5;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    col = mix(col,wt,col - circle(uv,3.7, .001 ) * .9); // apply wood tex\n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .2); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n    m += circle(uv,3.7,.001);\n    m = 1. - m;\n    \n    col -=  smoothstep(0., pow(d,40.), m ) ;\n    \n    //col = vec4(m);\n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    col += Dial(uv , 1.5);\n    \n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( (iDate.w),        60.0 );\n\tfloat mins = mod( (iDate.w/60.0),   60.0 );\n\tfloat hors = mod( (iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    vec4 ch1m = Hand(uv, 0.6,0.1, hors  * TAU * .8 );//hours hand m\n    ch1 -= ch1m;\n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n    vec4 ch2m = Hand(uv, 1.3,0.1, mins);//minutes hand m\n    ch2 -= ch2m;\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = HandsShadow(uv , 2.0,.8, secs , .5);\n    col -= ch3s;\n    \n    \n    vec4 tex1 = texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 = texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 = texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n    \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    //col -= cc;\n    \n    col =  mix(cc * wt, col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\n\n\nvec4 Layer(vec2 uv , float a)\n{\n    vec2 ouv = uv; //storing the original uvs.\n\n//if (uv.x >= 0.) uv.y += 0.5;\n    //uv.x = abs(uv.x);\n    uv.x +=  iTime * .001;\n    uv = rot(uv,a * 0.1);\n    vec2 buv = uv;\n    //buv.x = buv.x +sin( buv.y + iTime * .001);\n    \n    \n    buv *= cos(sin(  iTime * .0001)*.5+.5) * 5.;\n    vec2 mouse = iMouse.xy / iResolution.xy + .5;\n    buv *= 1.- mouse.x + 1.5;\n    \n    \n    buv = rot(buv,iTime * .0001);\n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n    \n    \n    uv = buv;\n\n    \n    \n    //col -= max( 1. - length((uv + vec2(.0,.1))* .63), 0.) ;\n    vec4 cf = ClockFace(uv*2.8 /Hash21(id * 3.)- 1.5);\n    \n    \n    cf *= vec4(Hash21(id + .3),Hash21(id+ .5),Hash21(id+ .7),1.) * 1.3;\n    cf = min(cf,vec4(1.));\n    //cf = clamp(cf,.3,.9);\n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n    \n\n\ncol.a = ceil(col.a);\n//\nreturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec2 ouv = uv; //storing the original uvs.\n    vec4 col = vec4( 0.);\n     if (uv.x <= 0.) uv.y += .5;\n     if (uv.y <= 0.) uv.x += .5;\n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n    \n    uv.x += iTime * .01;\n    uv.y += iTime * .01;\n    vec4 bg = texture(iChannel1,uv * 1.);\n     bg *= vec4(.5,.5,1.,1.);\n     col += bg;\n     \n     \n      //black in the middle\n     \n    col -=  max(.5 - length((ouv.x) * 2.0),0.) ;\n    col -=  max(.5 - length((ouv.y) * 2.0),0.) ;\n     \n     for(float i = 0.;i < NUM_LAYERS;i += 1./NUM_LAYERS)\n     {\n      vec4 l1 = Layer(ouv / i * 2., iTime * i+ (4622.2* i));\n    \n      col = mix(col, l1, l1.a);\n     }\n     //vec4 l1 = Layer(ouv, iTime * .5);\n    \n     //col = mix(col, l1, l1.a);\n\n    \n    // vec4 l2 = Layer(ouv * .5, iTime * .3+ 4622.2);\n    \n    // col = mix(col, l2, l2.a);\n     \n    // vec4 l3 = Layer(ouv * .3, iTime * .2 + 42312.2);\n    \n    // col = mix(col, l3, l3.a);\n     \n     //vignette\n     col -= vec4(pow(length(ouv),4.) );\n  \n   \n\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}