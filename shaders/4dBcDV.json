{
    "Shader": {
        "info": {
            "date": "1493795977",
            "description": "A grassy field with wind. Use the mouse and arrow keys to move around. Try changing some of the defines in Image and Buf A for fun. If it runs too slow, turn down LAYERS and maybe DISTANCE (or turn them up if you have a beefy GPU). Clouds by drift.",
            "flags": 48,
            "hasliked": 0,
            "id": "4dBcDV",
            "likes": 69,
            "name": "grass with wind",
            "published": 3,
            "tags": [
                "grass",
                "landscape",
                "fur",
                "physics",
                "nature",
                "wind",
                "outdoor"
            ],
            "usePreview": 0,
            "username": "kev7774",
            "viewed": 7410
        },
        "renderpass": [
            {
                "code": "//The more layers, the higher the quality\n//Try higher values if your computer can take it\n#define LAYERS 70\n//Draw distance of the grass\n#define DISTANCE 50.\n\n//Height darkening of grass(to approximate AO)\n#define DARKNESS .15\n//Darkening factor for far distance, where grass is not drawn\n#define FARDARK vec3(.87,.59, .78)\n\n//Higher values make grass blades thinner and spaced closer together\n//Set to 2.0 for hilarious chubby grass blades\n#define SCALING 18.\n//Height of grass\n#define HEIGHT 1.\n\n\n\n//Field of view\n#define FOV (3.14159/3.)\n\n\n\n//Credit to drift for the clouds:\n//https://www.shadertoy.com/view/4tdSWr\n\n\nconst float cloudscale = 1.6;\nconst float speed = 0.02;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\n#define HALF_PI 1.5707963267948966\n\nfloat sineOut(float t) {\n  return sin(t * HALF_PI);\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nfloat easeWhite(float x){\n  if(x > sqrt(3.)/2.){\n    float temp = (2.*x-2.);\n    return 1. - temp*temp;\n  }else{\n    return x * 1.0717968;\n  }\n}\n\nfloat easeIn(float t, float b, float strength){\n    float a = 1./ (2.*b - b*b);\n    if(t<=b) return mix(t, a*t*t, strength);\n    \n    else return mix(t, mix(a*b*b, 1., (t-b)/(1.-b)), strength);\n}\n\n// -----------------------------------------------\n\nvoid clouds( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy*4.;\n\tvec2 uv = p;    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i < 11; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= i >=6 ? .56 : .7;\n    }\n  //if(iMouse.z <= 0.) r -= .04;  //TRYTHIS\n     r *= .984;\n    //noise shape\n\tfloat f = 0.0;\n    uv = p;\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<13; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, 2.3-2.*sqrt(length(p)));\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result;\n    \n    float fc = max(0., f+c) * 2.;\n    \n    \n    //if(iMouse.z > 0.) result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), cubicOut(clamp((f + c)*.5, 0.0, 1.0)));\n    /*else*/  result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0),\n                       easeIn( easeWhite(min(1.,1.07* fc / (1. +fc))), .35, .65 )   );\n\tfragColor = vec4( result, 1.0 );\n}\n\n\n\n\n\n\n\n//simple nonlinear function for hashing\nfloat curve(float x)\n{\n     return x * (x*x + 3.0);\n}\n\n#define HASHSCALE (2.711651661)\n\nfloat rand(vec2 p) {\n    p = fract(p*HASHSCALE);\n    return fract(curve( p.x + p.y * .618034) * 43758.5453);\n}\n\n#define PREVIEWSCALE (iResolution.y > 271. ? 1. : .5)\n    \nvec4 sampleGrass(vec2 uv, float h) {\n    uv /= PREVIEWSCALE;\n    vec2 uv2 = uv*.75 + vec2(float(iFrame) * .053)+.5;\n    uv2 = floor(uv2) + smoothstep(0.,1., fract(uv2));\n    uv2 -= .5;\n    \n    vec2 offs = texture(iChannel2, uv2/64. ).xy - vec2(.25); \n    //Use this line to debug velocity field\n    //return vec4(offs,0.,1.);\n    \n    uv += .65*offs.xy* h * (h*.7+.3);\n    \n    uv /= iResolution.xy;\n    uv *= PREVIEWSCALE * SCALING;\n    uv = mod(uv,(PREVIEWSCALE * 256.)/iResolution.xy);\n    uv += 4./iResolution.xy;\n\treturn texture(iChannel0, uv);    \n}\n\nvec3 sampleGrassLOD(vec2 uv){\n    uv /= 100. * iResolution.xy * PREVIEWSCALE;;\n    uv *= PREVIEWSCALE * 1800.;\n    uv = mod(uv,PREVIEWSCALE * 256./iResolution.xy);\n    uv += 1./iResolution.xy;\n    \n    uv /= 8.;\n    uv.x += PREVIEWSCALE * 400./iResolution.x;\n    \n    return texture(iChannel0,uv).xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    vec3 c = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    fragColor = vec4(c, 1.);\n    return;\n    */\n    \n    vec3 rd = normalize(vec3( (fragCoord.xy*2. - iResolution.xy)/iResolution.x, FOV )); \n    vec4 tm = texture( iChannel1, vec2(1.5,.5)/iResolution.xy); \n    rd.zy = rd.zy * tm.x + rd.yz * vec2(tm.z, -tm.z);\n    rd.xz = rd.xz * tm.y + rd.zx * vec2(tm.w, -tm.w);\n\tvec3 ro = texture( iChannel1, vec2(3.5,.5)/iResolution.xy).xyz;\n    \n    vec3 campos = ro.xzy;\n    campos.z += 4.;\n    vec3 raydir = rd.xzy;\n    \n    float tHit = -campos.z/raydir.z;\n    \n    //campos.z + t*raydir.z = h\n    //t = (h - campos.z)/raydir.z\n    \n    if(tHit < 0.){ \n        vec3 dir2 = normalize(raydir + vec3(0.,0.,.1));\n            \n        float t = 1./dir2.z;\n        vec2 uv = dir2.xy*t;\n\n        vec4 skycol;\n\n        clouds(skycol, uv/24.);\n\n        fragColor = skycol;\n        return;\n    }else{\n        \n        \n        vec3 hitBottom = campos + raydir *tHit;\n        \n        \n        vec3 botCol = sampleGrassLOD(hitBottom.xy) * FARDARK;\n        \n        if(tHit > DISTANCE){\n            fragColor = vec4(vec3(1.1,1.3,1.1)*botCol,1.);\n            return;\n        }\n        \n        vec3 col =  sampleGrass(hitBottom.xy, 0.).xyz * DARKNESS;\n        \n        for(int i=1; i<=LAYERS; i++){\n            float h = float(i)/float(LAYERS);\n            h += (rand(fragCoord) -.5)/float(LAYERS);\n\n\t\t\tfloat t = (h*HEIGHT-campos.z)/raydir.z;\n\n            if(t<0.) continue;\n\n            vec3 hit = campos + raydir * t;\n\n            vec4 s = sampleGrass(hit.xy, h);\n            \n            float tip = min(1., h+.2);\n           \n            s.rgb = mix(s.rgb, min(vec3(1.), s.rgb*vec3(16.,1.5,2.8)), .8*pow(tip, 6.));\n            \n            s.a *= 1.-h;\n            //s.a = smoothstep(.1,.2,s.a);\n            s.a = 1.-pow(1.-smoothstep(.12,.2,s.a), 100./float(LAYERS));\n\n            s.rgb *= mix(h,1.,DARKNESS);\n            col = mix(col, s.rgb, s.a*.5);\n\n        }\n        \n        float fac = tHit/DISTANCE;\n        fac = fac*fac;\n        fac = max(0., 1.-fac);\n        \n        fragColor = vec4(vec3(1.1,1.3,1.1)*mix(botCol, col, fac),1.);\n    }\n    \n    \n    \n\t//fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Adds \"fuzz\" underneath the grass to cover up the ground when you look down. (range 0.0 - 1.0)\n//Looks fine with no fuzz, but 0.2 is a good value to try.   0.5 and higher looks weird.\n//NEED TO RESET TIME TO SEE RESULT\n#define FUZZ .0\n\n#define PREVIEWSCALE (iResolution.y > 271. ? 1. : .5)\n\n//simple nonlinear function for hashing\nfloat curve(float x)\n{\n     return x * (x*x + 3.0);\n}\n\n#define HASHSCALE (2.711651661)\n\nfloat rand(vec2 p) {\n    p = fract(p*HASHSCALE);\n    return fract(curve( p.x + p.y * .618034) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if(iFrame > 3){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n\n    fragCoord = floor(fragCoord);\n    \n    if(fragCoord.x >= PREVIEWSCALE * 400. && fragCoord.x < (PREVIEWSCALE *400.) + 34. && fragCoord.y < 34.){\n        vec2 uv1 = fragCoord - vec2(PREVIEWSCALE*400.,0.);\n        uv1 *= PREVIEWSCALE * 8.;\n        uv1 += vec2(.5);\n        \n        vec3 sum = vec3(0.);\n        for(int x=0; x<4; x++){\n            for(int y=0; y<4; y++){\n                vec2 uv2 = uv1 + vec2(float(x*2), float(y*2));\n                sum += texture(iChannel0, uv2/iResolution.xy).xyz;\n            }\n        }\n        fragColor = vec4(sum/16., 1.);\n        return;\n    }\n    \n    fragCoord = mod(fragCoord, PREVIEWSCALE*vec2(256.,256.));\n    \n    float m = rand(fragCoord);\n    float n = rand(fragCoord + vec2(0.,1.));\n    float e = rand(fragCoord + vec2(1.,0.));\n    float s = rand(fragCoord + vec2(0.,-1.));\n    float w = rand(fragCoord + vec2(-1.,0.));\n    \n    float ne = rand(fragCoord + vec2(1.,1.));\n    float se = rand(fragCoord + vec2(1.,-1.));\n    float sw = rand(fragCoord + vec2(-1.,-1.));\n    float nw = rand(fragCoord + vec2(-1.,1.));\n    \n    float res = 1.;\n    \n    res = (m > n) ? res : 0.;\n    res = (m > e) ? res : 0.;\n    res = (m > s) ? res : 0.;\n    res = (m > w) ? res : 0.;\n    \n    res = (m > ne) ? res : 0.; \n    //res = (m > se) ? res : 0.;\n    res = (m > sw) ? res : 0.;\n    //res = (m > nw) ? res : 0.;\n    \n    float h = rand(fragCoord * vec2(2.24722,7.16163) + vec2(31.12515, 59.1616));\n    /*\n    h = h*2.-1.;\n    h = h*h*h;\n    h = h*.5+.5;\n    res = h * (.75*res+.25);\n    */\n    res = mix(res,1.,FUZZ) * sqrt(h);\n    \n    float r1 = rand(fragCoord * vec2(4.23236,11.843583) + vec2(61.1261661, 22.724727));\n    float r2 = rand(fragCoord * vec2(7.8645,3.274247) + vec2(171.2437247, 54.23724372));\n    \n    vec3 col = mix(vec3(.2,1.,.3), vec3(.42,.86,.15), r1);\n    \n    col = mix(col, vec3(.05,.65,.10), r2*r2);\n    \n    fragColor = vec4(col, res);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Free fly by Tempally: https://www.shadertoy.com/view/MtGSzD\n\n// [A]=65 ... [Z]=90, [0]=48 ... [9]=57, [space]=32, [<]=37, [^]=38, [>]=39, [v]=40\n\n#define KEY_LEFT 0.146484375\n#define KEY_RIGHT 0.154296875\n#define KEY_DOWN 0.158203125\n#define KEY_UP 0.150390625\n\n\n//Use these defines for WASD controls (not the default because not everyone has a qwerty keyboard)\n/*\n#define KEY_LEFT 0.255859375\n#define KEY_RIGHT 0.267578125\n#define KEY_DOWN 0.326171875\n#define KEY_UP 0.341796875\n*/\n\n//change velocity per frame:\n#define ACCEL .02\n#define BRAKE .9;\n\nconst vec2 mouseSens = vec2(-.6, 1.); //mouse sensivity, change signs to invert axis \n\nfloat getKey(float key) {return texture(iChannel1, vec2(key, .25)).x;}\n\nvec4 getVar(int key) {return texture(iChannel0, vec2(.05 + float(key), .5)/iResolution.xy);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y > .9) discard;\n    int idx=int(fragCoord.x);\n    if (idx <= 1) // orientation\n    {\n        fragColor = getVar(0);\n        fragColor.xy += (float(fragColor.w>.0) - float(iMouse.z>.0 && idx==0)) * \n                        (iMouse.yx/iResolution.yx - .5) * mouseSens;\n        vec4 cr = fragColor*6.28318530718;\n        if (idx == 0) fragColor.w = iMouse.z; \n        else fragColor = vec4(cos(cr.x), cos(cr.y), sin(cr.x), sin(cr.y));\n    }\n    else if (idx == 2) // velocity\n    {\n        vec4 camV = getVar(idx--);\n        vec4 tm = getVar(idx);\n        camV.xyz += ACCEL * (\n          \t\t\t(getKey(KEY_UP) - getKey(KEY_DOWN)) * vec3(tm.x*tm.w, -tm.z, tm.x*tm.y) +\n          \t\t\t(getKey(KEY_RIGHT) - getKey(KEY_LEFT)) * vec3(tm.y, 0, -tm.w) );\n        fragColor = camV * BRAKE;\n    }\n    else if (idx == 3) fragColor = getVar(idx--) + getVar(idx); // position\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}