{
    "Shader": {
        "info": {
            "date": "1378762363",
            "description": "A ray-traced sphere floating in a ray-marched ocean. Refraction & reflection effects.\nIt looks particularly nice when you pause it and move the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdsGDB",
            "likes": 469,
            "name": "Buoy",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "noise",
                "reflection",
                "refraction"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 84826
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec3 localRay;\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// Noise functions, distinguished by variable types\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\n\tvec4 rg = textureLod( iChannel0, (uv+f.xy+0.5)/256.0, 0.0 );\n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec2 NoisePrecise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\n\tvec4 rg = mix( mix(\n\t\t\t\ttextureLod( iChannel0, (uv+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (uv+vec2(1,0)+0.5)/256.0, 0.0 ),\n\t\t\t\tf.x ),\n\t\t\t\t  mix(\n\t\t\t\ttextureLod( iChannel0, (uv+vec2(0,1)+0.5)/256.0, 0.0 ),\n\t\t\t\ttextureLod( iChannel0, (uv+1.5)/256.0, 0.0 ),\n\t\t\t\tf.x ),\n\t\t\t\tf.y );\n\t\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p.xy + f.xy;\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn textureLod( iChannel0, (vec2(x)+0.5)/256.0, 0.0 );\n}\n\nvec2 Noise( in ivec3 x )\n{\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).xz;\n}\n\n\nfloat Waves( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 5;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesDetail( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 8;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*2.0+abs(NoisePrecise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesSmooth( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 2;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\t//f  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tf  = f*2.0+sqrt(pow(NoisePrecise(pos).x-.5,2.0)+.01)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WaveCrests( vec3 ipos, in vec2 fragCoord )\n{\n\tvec3 pos = ipos;\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves1 = 6;\n\tconst int octaves2 = 16;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\tpos += iTime*vec3(0,.1,.1);\n\tvec3 pos2 = pos;\n\tfor ( int i=0; i < octaves1; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*1.5+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tpos = pos2 * exp2(float(octaves1));\n\tpos.y = -.05*iTime;\n\tfor ( int i=octaves1; i < octaves2; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*1.5+pow(abs(Noise(pos).x-.5)*2.0,1.0);\n\t\tpos *= 2.0;\n\t}\n\tf /= 1500.0;\n\t\n\tf -= Noise(ivec2(fragCoord.xy)).x*.01;\n\t\n\treturn pow(smoothstep(.4,-.1,f),6.0);\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn vec3(.4,.45,.5);\n}\n\n\nvec3 boatRight, boatUp, boatForward;\nvec3 boatPosition;\n\nvoid ComputeBoatTransform( void )\n{\n\tvec3 samples[5];\n\t\n\tsamples[0] = vec3(0,0, 0);\n\tsamples[1] = vec3(0,0, .5);\n\tsamples[2] = vec3(0,0,-.5);\n\tsamples[3] = vec3( .5,0,0);\n\tsamples[4] = vec3(-.5,0,0);\n\t\n\tsamples[0].y = WavesSmooth(samples[0]);\n\tsamples[1].y = WavesSmooth(samples[1]);\n\tsamples[2].y = WavesSmooth(samples[2]);\n\tsamples[3].y = WavesSmooth(samples[3]);\n\tsamples[4].y = WavesSmooth(samples[4]);\n\n\tboatPosition = (samples[0]+samples[1]+samples[2]+samples[3]+samples[4])/5.0;\n\t\n\tboatRight = samples[3]-samples[4];\n\tboatForward = samples[1]-samples[2];\n\tboatUp = normalize(cross(boatForward,boatRight));\n\tboatRight = normalize(cross(boatUp,boatForward));\n\tboatForward = normalize(boatForward);\n\t\n\tboatPosition += .0*boatUp;\n}\n\nvec3 BoatToWorld( vec3 dir )\n{\n\treturn dir.x*boatRight+dir.x*boatUp+dir.x*boatForward;\n}\n\nvec3 WorldToBoat( vec3 dir )\n{\n\treturn vec3( dot(dir,boatRight), dot(dir,boatUp), dot(dir,boatForward) );\n}\n\nfloat TraceBoat( vec3 pos, vec3 ray )\n{\n\tvec3 c = boatPosition;\n\tfloat r = 1.0;\n\t\n\tc -= pos;\n\t\n\tfloat t = dot(c,ray);\n\t\n\tfloat p = length(c-t*ray);\n\tif ( p > r )\n\t\treturn 0.0;\n\t\n\treturn t-sqrt(r*r-p*p);\n}\n\n\nvec3 ShadeBoat( vec3 pos, vec3 ray )\n{\n\tpos -= boatPosition;\n\tvec3 norm = normalize(pos);\n\tpos = WorldToBoat(pos);\n\t\n\tvec3 lightDir = normalize(vec3(-2,3,1));\n\tfloat ndotl = dot(norm,lightDir);\n\t\n\t// allow some light bleed, as if it's subsurface scattering through plastic\n\tvec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);\n\n\t// anti-alias the albedo\n\tfloat aa = 4.0/iResolution.x;\n\t\n\t//vec3 albedo = ((fract(pos.x)-.5)*(fract(pos.y)-.5)*(fract(pos.z)-.5) < 0.0) ? vec3(0) : vec3(1);\n\tvec3 albedo = vec3(1,.01,0);\n\talbedo = mix( vec3(.04), albedo, smoothstep( .25-aa, .25, abs(pos.y) ) );\n\talbedo = mix( mix( vec3(1), vec3(.04), smoothstep(-aa*4.0,aa*4.0,cos(atan(pos.x,pos.z)*6.0)) ), albedo, smoothstep( .2-aa*1.5, .2, abs(pos.y) ) );\n\talbedo = mix( vec3(.04), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.6) ) );\n\talbedo = mix( vec3(1,.8,.08), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.65) ) );\n\t\n\tvec3 col = albedo*light;\n\t\n\t// specular\n\tvec3 h = normalize(lightDir-ray);\n\tfloat s = pow(max(0.0,dot(norm,h)),100.0)*100.0/32.0;\n\t\n\tvec3 specular = s*vec3(1,1,1);\n\n\tvec3 rr = reflect(ray,norm);\n\tspecular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );\n\t\n\tfloat ndotr = dot(norm,ray);\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\tfresnel = mix( .001, 1.0, fresnel );\n\n\tcol = mix( col, specular, fresnel );\n\t\n\treturn col;\n}\n\n\nfloat OceanDistanceField( vec3 pos )\n{\n\treturn pos.y - Waves(pos);\n}\n\nfloat OceanDistanceFieldDetail( vec3 pos )\n{\n\treturn pos.y - WavesDetail(pos);\n}\n\nvec3 OceanNormal( vec3 pos )\n{\n\tvec3 norm;\n\tvec2 d = vec2(.01*length(pos),0);\n\t\n\tnorm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );\n\tnorm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );\n\tnorm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );\n\n\treturn normalize(norm);\n}\n\nfloat TraceOcean( vec3 pos, vec3 ray )\n{\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tif ( h < .01 || t > 100.0 )\n\t\t\tbreak;\n\t\th = OceanDistanceField( pos+t*ray );\n\t\tt += h;\n\t}\n\t\n\tif ( h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\n\nvec3 ShadeOcean( vec3 pos, vec3 ray, in vec2 fragCoord )\n{\n\tvec3 norm = OceanNormal(pos);\n\tfloat ndotr = dot(ray,norm);\n\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\t\n\tvec3 reflectedRay = ray-2.0*norm*ndotr;\n\tvec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;\t\n\trefractedRay = normalize(refractedRay);\n\n\tconst float crackFudge = .0;\n\t\n\t// reflection\n\tvec3 reflection = Sky(reflectedRay);\n\tfloat t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );\n\t\n\tif ( t > 0.0 )\n\t{\n\t\treflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );\n\t}\n\n\t\n\t// refraction\n\tt=TraceBoat( pos-crackFudge*refractedRay, refractedRay );\n\t\n\tvec3 col = vec3(0,.04,.04); // under-sea colour\n\tif ( t > 0.0 )\n\t{\n\t\tcol = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );\n\t}\n\t\n\tcol = mix( col, reflection, fresnel );\n\t\n\t// foam\n\tcol = mix( col, vec3(1), WaveCrests(pos,fragCoord) );\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tComputeBoatTransform();\n\t\n\tvec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 1.0, fragCoord );\n\t\n\tfloat to = TraceOcean( pos, ray );\n\tfloat tb = TraceBoat( pos, ray );\n\t\n\tvec3 result;\n\tif ( to > 0.0 && ( to < tb || tb == 0.0 ) )\n\t\tresult = ShadeOcean( pos+ray*to, ray, fragCoord );\n\telse if ( tb > 0.0 )\n\t\tresult = ShadeBoat( pos+ray*tb, ray );\n\telse\n\t\tresult = Sky( ray );\n\t\n\t// vignette effect\n\tresult *= 1.1*smoothstep( .35, 1.0, localRay.z );\n\t\n\tfragColor = vec4(ToGamma(result),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}