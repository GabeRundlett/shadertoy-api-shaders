{
    "Shader": {
        "info": {
            "date": "1610582801",
            "description": "you are a rainbow\n    yes it is true,\nplease let your light glow\n    make something new",
            "flags": 0,
            "hasliked": 0,
            "id": "3lKyzW",
            "likes": 5,
            "name": "you are a rainbow",
            "published": 3,
            "tags": [
                "rainbow"
            ],
            "usePreview": 0,
            "username": "netgrind",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "// Fork of \"cosmos font smooth\" by netgrind. https://shadertoy.com/view/Xdjfzw\n// 2021-01-14 00:00:36\n\n#define line1 _ y_ o_ u_ _ a_ r_ e_ _ a_ crlf\n#define line2 _ _ r_ a_ i_ n_ b_ o_ w_\n\n// line function, used in k, s, v, w, x, y, z\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 size = vec2(1., -1);\nvec2 edge = vec2(1, 0.);\nvec2 xLine = vec2(0., 0.);\n\nfloat circle(vec2 uv){\n\treturn abs(length(uv)-size.x);   \n}\nfloat circleS(vec2 uv){\n\treturn abs(length(uv)-size.x*.5);   \n}\n\nfloat vert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x)));   \n}\nfloat halfvert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x*.5)));   \n}\nfloat hori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x),uv.y));   \n}\nfloat halfhori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x*.5),uv.y));   \n}\nfloat diag(vec2 uv){\n\treturn length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.),uv.y+uv.x));   \n}\nfloat halfdiag(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x-uv.y)-size.x),uv.y+uv.x));   \n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    float x = circle(uv);\n    x = mix(x, min(vert(uv-edge), vert(uv+edge)), step(uv.y, 0.));\n    x = min(x, hori(uv-xLine));\n    return x;\n}\nfloat bb(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-xLine));\n    x = mix(min(circleS(uv-size.xx*.5),circleS(uv-size*.5)),x, step(uv.x, .5));\n    return x;\n}\nfloat cc(vec2 uv) {\n    float x = circle(uv);\n    float p = .8;\n    float a = atan(uv.x, abs(uv.y));\n    a = smoothstep(.7, 1.5707, a);\n   \tx += a;\n    uv.y = -abs(uv.y);\n    x = min(length(uv+size.x*vec2(-cos(p), sin(p))), x);\n    return x;\n}\nfloat dd(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv),x, step(uv.x, 0.));\n    return x;\n}\nfloat ee(vec2 uv) {\n    float x = cc(uv);\n    x = mix(circle(uv), x, step(uv.y, 0.));\n    x = min(x, hori(uv));\n    return x;\n}\nfloat ff(vec2 uv) {\n   \tfloat x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv), x, step(min(-uv.x, uv.y), 0.));\n    x = min(x, halfhori(uv+edge*.5));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = cc(uv);\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    x = min(x, halfhori(uv-edge*.5));\n    return x;\n}\nfloat hh(vec2 uv) {\n    float x = vert(abs(uv)-edge);\n    x = min(x, hori(uv));\n    //x = min(x, circle(uv+edge.yx));\n    //x = mix(x, min(length(uv-size.xy), length(uv-size.yy)), step(uv.y, size.y));\n    return x;\n}\nfloat ii(vec2 uv) {\n    return hh(uv.yx);\n}\nfloat jj(vec2 uv) {\n    float x = vert(uv-edge);\n    x = min(x, length(uv+edge));\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    return x;\n}\nfloat kk(vec2 uv) {\n    uv.y = abs(uv.y);\n    float x = circle(uv-edge.yx);\n    x = mix( length(uv-size.xx),x,step(uv.y, size.x)); \n    x = mix(x,min(vert(uv+edge), hori(uv)), step(uv.x, 0.));\n    return x;\n}\nfloat ll(vec2 uv) {\n    return min(vert(uv+edge), hori(uv+edge.yx));\n}\nfloat mm(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = vert(uv-edge);\n    x = min(x, halfvert(uv-edge.yx*.5));\n    x = mix( circleS(uv-size.xx*.5),x, step(uv.y, 0.5));\n    return x;\n}\nfloat nn(vec2 uv) {\n    float x = circle(uv);\n    x = mix(min(vert(uv-edge), vert(uv+edge)), x, clamp(ceil(uv.y), 0., 1.));\n    return x;\n}\nfloat oo(vec2 uv) {\n    return circle(uv);\n}\nfloat pp(vec2 uv) {\n    float x = hori(uv);\n    x = min(x, hori(uv-edge.yx));\n    x = mix( circleS(uv+size.yy*.5),x, step(uv.x, size.x*.5));\n    x = min(x, vert(uv+edge));\n    return x;\n}\nfloat qq(vec2 uv) {\n    float x = circle(uv);\n    x = min(x, halfdiag(uv-size.xy*.5));\n    return x;\n}\nfloat rr(vec2 uv) {\n    float x = min(hori(uv-edge.yx), vert(uv+edge));\n    x = mix(x, circle(uv), step(0., min(-uv.x, uv.y)));\n    return x;\n}\nfloat ss(vec2 uv) {\n    float x = hori(uv-edge.yx);\n    x = min(x, halfhori(uv));\n    vec2 u = uv;\n    u+=vec2(-size.y*.5, size.y*.5);\n    x = mix(circleS(u),x, step(-edge.x*.5, uv.x));\n    \n    float x2 = hori(uv+edge.yx);\n    x2= min(x2, halfhori(uv));\n    u = uv;\n    u-=vec2(-size.y*.5, size.y*.5);\n    x2 = mix(x2,circleS(u),step(edge.x*.5, uv.x));\n    \n    return min(x,x2);\n}\nfloat tt(vec2 uv) {\n    /*float x = min(hori(uv+edge.yx), vert(uv+edge));\n    x = mix( circle(uv),x, step(0., max(uv.x, uv.y)));\n    x = min(halfhori(uv+edge*.5), x);*/\n    float x = min(vert(uv), hori(uv-edge.yx));\n    return x;\n}\nfloat uu(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = mix(circle(uv), vert(uv-edge),  step(0., uv.y));\n    return x;\n}\nfloat vv(vec2 uv) {\n    uv.x = abs(uv.x);\n    float p = .5;\n    uv *= mat2(cos(p), -sin(p), sin(p), cos(p));\n    float x = vert(uv-edge*.5);\n    return x;\n}\nfloat ww(vec2 uv) {\n    uv.y = -uv.y;\n    return mm(uv);\n}\nfloat xx(vec2 uv) {\n    return diag(abs(uv)*vec2(-1., 1.));\n}\nfloat yy(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = min(halfvert(uv+edge.yx*.5), circle(uv-edge.yx));\n    x = mix(x, length(uv-size.xx), step(size.x, uv.y));\n    return x;\n}\nfloat zz(vec2 uv) {\n    float x = min(hori(uv-edge.yx), hori(uv+edge.yx));\n    uv.x = -uv.x;\n    return min(x, diag(uv));\n}\n\n//Render char if it's up\n#define ch(l)  x=min(x,l(uv+vec2(spacing.x*nr, 0.)));nr-=size.x;\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n\n//Space\n#define _ nr--;\n//Space\n#define _half nr-=.5;\n\n//Next line\n#define crlf uv.y += spacing.w; nr = 0.;\n\nvec4 spacing = vec4(3.33, 2., .25, 3.33);\n\nfloat field(vec2 uv){\n    float x = 100.;\n    float nr = 0.;\n    \n    line1;\n    line2;\n    return x;\n}\n\nvec2 fieldNormal(vec2 uv)\n{\n   const vec2 e = vec2(0.3,0.0);\n   return normalize(vec2(\n      field(uv + e.xy) - field(uv - e.xy),\n      field(uv + e.yx) - field(uv - e.yx) \n   ));\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nvec3 art(vec2 uv){\n    float aa = atan(uv.x, uv.y);\n\n    pModPolar(uv, 6., iTime);\n    uv.x = abs(mod(uv.x-iTime, 10.)-5.);\n    uv.y = abs(mod(uv.y+15., 30.)-15.);\n    \n    float a = atan(uv.x, uv.y);\nfloat d= length(uv)*.2;\nuv.x*=1.+sin(uv.x+a-d+iTime)*.1;\nuv.y*=1.+cos(uv.y+a+d+iTime)*.1;\n    float grid = smoothstep(.03, .5, abs(mod(a/3.1415*7., 2.)-1.));\n    grid += smoothstep(0., 1.,pow(mod(d, 1.), 3.));\n    vec3 c =vec3(mix(d, grid, smoothstep(.1, 1., d)));\n    c.rgb +=aa/3.1415;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spacing.y = spacing.x*.5;\n    spacing.z = 1./spacing.x;\n    \n    float scale = 1.0;\n\tvec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.xx)*40.;\n    \n    vec2 p = uv;\n    \n    uv.x*=1.+sin(uv.y*.2-iTime)*.05;\n    uv.y*=1.+cos(uv.x*.5+iTime)*.1;\n    uv.y+=cos(uv.x*.1-iTime);\n    \n    uv.x += 5.*spacing.x;\n    uv.y -= spacing.w*.5;\n    \n    float x = field(uv);\n    vec2 norm = fieldNormal(uv);\n    \n    float amp = pow(smoothstep(5., .5, x), .7);\n    vec3 c = art(p*(1. + iMouse.x/iResolution.x*10.)-norm*amp);\n    c = sin((vec3(0., .33, .66)+c+smoothstep(.5, .0, x)+smoothstep(.1, 2., x))*6.28+iTime)*.5+.5;\n   // c = mix(c, vec3(0.), smoothstep(.5, .4, x));\n   float v = smoothstep(.2, .3, x);\n\tc = mix( sin(vec3(0., .33, .66)*7.+p.x+p.y+iTime)*.3+.9, c*smoothstep(15., 5., x), v);\n    fragColor = vec4(c, 1.);//vec4(clamp(clr,0.0,1.0),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}