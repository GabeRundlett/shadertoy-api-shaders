{
    "Shader": {
        "info": {
            "date": "1720373168",
            "description": "Inspired by iq's worms",
            "flags": 0,
            "hasliked": 0,
            "id": "4XKSRd",
            "likes": 1,
            "name": "Data Stream RGB",
            "published": 3,
            "tags": [
                "sdf",
                "fisheye"
            ],
            "usePreview": 0,
            "username": "WilstonOreo",
            "viewed": 113
        },
        "renderpass": [
            {
                "code": "uniform float cam_roll; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_pitch; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_yaw; // default = 0.0, min = -180.0, max = 180.0\n\n#ifdef TOUCHDESIGNER\nuniform float glow; // default 1.0, min = 0.0, max = 2.0\nuniform float oscillate; // default 1.0, min = 0.0, max = 2.0\nuniform float wobble; // default 0.0, min = -0.6, max = 0.6\nuniform float vortex; //default 0.0, min = -1.0, max = 1.0\n\nuniform float small_packets_speed; // default 1.0, min = -4.0, max = 4.0\nuniform float small_packets_opacity; // default 1.0, min = 0.0, max = 2.0\n\nuniform float large_packets_speed; // default 1.0, min = -4.0, max = 4.0\nuniform float large_packets_opacity; // default 1.0, min = 0.0, max = 2.0\n\nuniform float x_movement; // default iTime\n#else \nconst float glow = 1.0; // default 1.0, min = 0.0, max = 2.0\nconst float oscillate = 0.1; // default 1.0, min = 0.0, max = 2.0\nconst float wobble = 0.5;\nconst float vortex = 0.0;\n\nconst float small_packets_speed = 1.0; // default 1.0, min = -4.0, max = 4.0\nconst float small_packets_opacity = 1.0; // default 1.0, min = 0.0, max = 2.0\n\nconst float large_packets_speed = 1.0; // default 1.0, min = -4.0, max = 4.0\nconst float large_packets_opacity = 1.0; // default 1.0, min = 0.0, max = 2.0\n\n#endif\n\n#define AA 2\n\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nvec2  sincos( float x ) { return vec2( sin(x), cos(x) ); }\nvec3  opU( vec3 d1, vec3 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\n\n\nconst float PI = 3.14159265358979323846264;\n\n/// Convert degrees to radians\nfloat deg2rad(in float deg)\n{\n  return deg * PI / 180.0;\n}\n\n\n/// Convert radians to degrees\nfloat rad2deg(in float rad)\n{\n  return rad / PI * 180.0;\n}\n\nfloat sqr(in float a)\n{\n  return a*a;\n}\n\n/// Calculates the rotation matrix of a rotation around X axis with an angle in radians\nmat3 rotateAroundX( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0,0.0,0.0,\n              0.0,  c, -s,\n              0.0,  s,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Y axis with an angle in radians\nmat3 rotateAroundY( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c,0.0,  s,\n              0.0,1.0,0.0,\n               -s,0.0,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Z axis with an angle in radians\nmat3 rotateAroundZ( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c, -s,0.0,\n                s,  c,0.0,\n              0.0,0.0,1.0);\n}\n\n/// Calculate rotation by given yaw and pitch angles (in degrees!)\nmat3 rotationMatrix(in float yaw, in float pitch, in float roll)\n{\n  return rotateAroundZ(deg2rad(yaw)) *\n         rotateAroundY(deg2rad(-pitch)) *\n         rotateAroundX(deg2rad(roll));\n}\n\n// Get fisheye camera ray from screen coordinates\nfloat fisheye_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n\tuv = uv - 0.5;\n  float phi = atan(uv.x,uv.y);\n  float l = length(uv);\n\n  if (l > 0.5)\n  {\n    return -1.0;\n  }\n  float theta  = l * PI;\n  rd = normalize(vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));\n  return 1.0;\n}\n\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return fisheye_direction(screenCoord,res,rd);\n}\n\nvec2 sdCylinder( in vec3 p )\n{\n    return vec2( length(p.xz), (p.y+50.0)/100.0 );\n}\n\n\nmat2 rotation2d(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat2(\n    c, -s,\n    s, c\n  );\n}\n\n\nvec3 map( vec3 p )\n{\n   float time = iTime*0.3;\n#ifndef TOUCHDESIGNER\n   float x_movement = time*0.75;\n#endif\n    p.xz *= rotation2d(p.y * vortex);\n\n    p.x += x_movement;\n    \n    vec2  id = floor( (vec2(p.x, p.z)+1.0)/2.0 );\n    float ph = hash(id+2.1);\n    float ve = hash(id);\n\n    p.xz = mod( vec2(p.x, p.z)+1.0, 2.0 ) - 1.0;\n    p.xz += 0.5*cos( 2.0*ve*time + (2.0*p.y+ph)*vec2(sin(time*0.21),sin(time*0.35))*oscillate);\n\n    p.xz *= rotation2d(2.0*time);\n    p.xz *= 1.0 + wobble * sin(p.y * 0.75 + time * 8.0);\n    \n    \n    vec3 p1 = p; p1.xz += 0.1*sincos(1.2*p.y-ve*time*ve+0.0);\n    vec3 p2 = p; p2.xz += 0.1*sincos(1.2*p.y-ve*time*ve+2.0);\n    vec3 p3 = p; p3.xz += 0.1*sincos(1.2*p.y-ve*time*ve+4.0);\n    \n    vec2 h1 = sdCylinder( p1 );\n    vec2 h2 = sdCylinder( p2 );\n    vec2 h3 = sdCylinder( p3 );\n\n    return opU( opU( vec3(h1.x-0.1, ve + 0.000, h1.y), \n                     vec3(h2.x-0.1, ve + 0.015, h2.y) ), \n                     vec3(h3.x-0.1, ve + 0.030, h3.y) );\n\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float px, const float maxdist )\n{\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 h = map(ro + t*rd);\n        res = vec3( t, h.yz );\n        if( abs(h.x)<(px*t) || t>maxdist ) break;\n        t += min( h.x, 0.5 ) * 0.8;\n    }\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.003;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.1;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.0*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += h-d;\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float px )\n{\n    vec3 col = vec3(0.0);\n    float time = iTime*0.3;\n    const float maxdist = 24.0;\n    vec3 res = intersect( ro, rd, px, maxdist );\n    if( res.x < maxdist )\n    {\n        vec3  pos = ro + res.x*rd;\n        vec3  nor = calcNormal( pos );\n        float occ = calcOcc( pos, nor );\n\n        col.r *= 0.5 + 1.5*nor.y;\n        col.r += clamp(glow*(1.0+dot(rd,nor)),0.0,1.0);\n        float u = 800.0*res.z - sin(res.y)*time;\n   \n        // Stripes\n        col.r *= occ;\n        \n        // Small packets\n        {\n            float fl = mod( (0.5-cos(2.0+pos.y*0.05 + time * small_packets_speed + 60.0*res.y)) * 0.1, 0.25 )/0.25;\n            col.g += small_packets_opacity * clamp(2.0-2.5*smoothstep(0.05,0.06,10.0*abs(res.z-fl)),0.0, 2.0);\n        }\n        \n        \n        // Large packets\n        {\n            float fl = mod( (0.5-cos(res.y*9.0))*time*large_packets_speed * 0.2, 1.0 )/1.0;\n            col.b += large_packets_opacity * clamp(2.0-4.5*smoothstep(0.05,0.8,10.0*abs(res.z-fl)),0.0, 2.0);\n        }\n    }\n    \n    return col * clamp(1.0 - 0.09*length(res - ro), 0.0, 1.0);\n}\n\n// Get fisheye camera ray from screen coordinates with rotation\nfloat direction(in vec2 screenCoord, in vec2 res, float rotX, float rotY, float rotZ, out vec3 rd)\n{\n  if (direction(screenCoord,res,rd) < 0.0)\n  {\n    return -1.0;\n  }\n  rd *= rotateAroundZ(rotZ)*rotateAroundY(rotY)*rotateAroundX(rotX);\n  return 1.0;\n}\n\nfloat setup_camera_ray(in vec2 uv, out vec3 ray)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n  return direction(uv,vec2(1.0),deg2rad(90.0+cam_yaw),deg2rad(cam_roll),deg2rad(cam_pitch),ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 tot = vec3(0.0);\n    vec3  ro = vec3(0.6,2.4,1.2);\n\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.xy*0.5 + 0.5;\n\n        vec3 rd;\n        if (setup_camera_ray(uv, rd) < 0.) {\n            continue;\n        }\n        \n        float fl = 3.0;\n\n        vec3 col = render( ro, rd, 1.0/(iResolution.y*fl) );\n \n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    vec2 q = fragCoord.xy/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}