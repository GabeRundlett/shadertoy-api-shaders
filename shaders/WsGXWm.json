{
    "Shader": {
        "info": {
            "date": "1574133181",
            "description": "another addition to the crystal series. Value noise is expensive, so no more multisampled raytracing.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsGXWm",
            "likes": 24,
            "name": "Strange Watery Crystal",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "noise",
                "reflection",
                "refraction",
                "crystal"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 794
        },
        "renderpass": [
            {
                "code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(1., 1., 1.)\n\n#define ABSORPTION_RATE vec3(0.5, 0.6, 0.7)\n#define IOR 1.33\n#define SCATTER_FACTOR 0.02\n#define REFLECTIONS 3\n#define RAYMARCH_STEPS 15\n#define RAYMARCH_TOL 0.005\n\n#define TIME_T 4.\n#define TIME_H 0.1\n#define TIME_L 10.\n\n/**\n * Assorted utilities\n */\n\n// 2D rotation matrix\nmat2 rot2(float ang) {\n    float c = cos(ang);\n    float s = sin(ang);\n    return mat2(c, -s, s, c);\n}\n\n// Cubic interpolation\nfloat cubemix(float a, float b, float t) {\n    float c = t*t*(3.-2.*t);\n    return mix(a, b, c);\n}\n\n// Schlick approximation for the Fresnel factor\nfloat schlick_fresnel(float R0, float cos_ang) {\n    return R0 + (1.-R0) * pow(1.-cos_ang, 5.);\n}\n\n// oscillate between 0 and 1 with specified timing\nfloat oscillate(float t_low, float t_high, float t_transition, float t_offset) {\n    float t_osc = 0.5*(t_high+t_low)+t_transition;\n    float h_l = 0.5*t_low/t_osc;\n    float h_h = (0.5*t_low+t_transition)/t_osc;\n    return smoothstep(0., 1., (clamp(abs(mod(iTime + t_offset, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n}\n\n/* * * * */\n\n/**\n * random functions and fractal noise\n */\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat rand(vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat valuenoise(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2 offset = vec2(0.,1.);\n    float v00 = rand(iuv);\n    float v01 = rand(iuv+offset.xy);\n    float v10 = rand(iuv+offset.yx);\n    float v11 = rand(iuv+offset.yy);\n    vec2 disp = fract(uv);\n    float v0 = cubemix(v00, v01, disp.y);\n    float v1 = cubemix(v10, v11, disp.y);\n    return cubemix(v0, v1, disp.x) - 0.5;\n}\n\nfloat fractalnoise(vec2 uv, float mag) {\n    float d = valuenoise(uv);\n    int i;\n    float fac = 1.;\n    vec2 disp = vec2(0., 1.);\n    for (i=0; i<3; i++) {\n        uv += mag * iTime * disp * fac;\n        disp = mat2(.866, 0.5, -0.5, .866) * disp; //rotate each moving layer\n        fac *= 0.5;\n        d += valuenoise(uv/fac)*fac;\n    }\n    return d;\n}\n\n/* * * * */\n\n/**\n * Ray tracing & marching primitives\n */\n\n// Raytrace box\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return -1.;\n    if (entering) {\n    \tnn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    } else {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\n// Perturbed box SDF\nfloat boxsdf(in vec3 ro, in vec3 r) {\n    vec3 mo = abs(ro);\n    vec3 b = mo - r;\n    float d = max(b.x, max(b.y, b.z));\n    // triplanar projection of animated noise for water effect\n    vec3 mask = step(mo.zxy, mo.xyz) * step(mo.yzx, mo.xyz);\n    ro *= 2.;\n    float disp = mask.x * fractalnoise(ro.yz + vec2(0., iTime), 0.25) + mask.y * fractalnoise(ro.zx + vec2(iTime, 0.), 0.25) + mask.z * fractalnoise(ro.xy, 0.5);\n    d += 0.015 * disp;\n    return d;\n}\n\n// SDF normals\nvec3 boxgrad(in vec3 ro, in vec3 r) {\n    vec2 diff = vec2(RAYMARCH_TOL, 0.);\n    float dx = boxsdf(ro + diff.xyy, r) - boxsdf(ro - diff.xyy, r);\n    float dy = boxsdf(ro + diff.yxy, r) - boxsdf(ro - diff.yxy, r);\n    float dz = boxsdf(ro + diff.yyx, r) - boxsdf(ro - diff.yyx, r);\n    return normalize(vec3(dx, dy, dz));\n}\n\n// Hybrid raytracing/raymarching of box\nfloat hybridbox(in vec3 ro, in vec3 rd, in vec3 r, out vec3 n, in bool entering) {\n    // first check for intersection with the basic primitive\n    float t = box(ro, rd, r, n, entering);\n    if (t > 0.) {\n        // refine the distance to the perturbed surface through raymarching\n        for (int i=0; i<RAYMARCH_STEPS; i++) {\n            float dist = boxsdf(ro + t*rd, r);\n            t += (entering ? dist : -dist);\n            if (dist < RAYMARCH_TOL) {\n                n = boxgrad(ro + t*rd, r);\n                return t;\n            }\n        }\n    }\n    return -1.;\n}\n\n// Raytrace sphere\nvec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return vec2(-1.);\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    float tout = -pd + tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return vec2(tin, tout);\n}\n\n// Sky color\nvec3 bgcol(in vec3 rd) {\n    vec3 sundir = normalize(vec3(0.7, 1., 1.5));\n    //vec3 sundir = vec3(1., 0., 0.);\n    vec3 skycol = mix(vec3(0.8, 0.9, 1.), vec3(0.6, 0.8, 1.), 1.-pow(max(0., dot(rd, sundir)), 2.));\n    vec3 suncol = vec3(20.) * smoothstep(0.995, 0.997, dot(rd, sundir));\n    return skycol + suncol;\n}\n\n// Raytrace the exterior surroundings\nvec3 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    if (t < 0.) return bgcol(rd);\n    vec2 uv = ro.xy+t*rd.xy;\n    if (max(abs(uv.x), abs(uv.y)) > 8.) return bgcol(rd);\n    vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n    float aofac = smoothstep(-0.5, 1., length(abs(uv)-min(abs(uv), vec2(0.75))));\n    return mix(vec3(0.2), vec3(1.), min(checkers.x,checkers.y)) * aofac;\n}\n\n// Raytrace the interior\nvec3 insides(in vec3 ro, in vec3 rd, in float INNERRAD, in mat2 rot, out float tout) {\n    vec3 ni;\n    vec2 t = sphere(ro, rd, INNERRAD, ni);\n    vec3 ro2 = ro + t.x * rd;\n    // shading/texture\n    vec2 checkers = step(mod(rot * ro2.xy, vec2(0.25)), vec2(0.01));\n    vec3 tex = mix(vec3(1.), vec3(0., 0.7, 0.), abs(checkers.x-checkers.y));\n    float fac = -ni.z;\n    \n    //inner background\n    vec3 n;\n    float tb = box(ro, rd, vec3(INNERRAD), n, false);\n    vec3 rob = ro + tb * rd;\n    vec3 checkersb = abs(mod(rob.xyz, vec3(0.5))-0.25)*4.;\n    vec3 texb = mix(vec3(0., 0., 1.), vec3(0.), step(0.25, abs(abs(checkersb.x-checkersb.y)-checkersb.z)));\n    tout = mix(tb, t.x, step(0., t.x));\n    return mix(mix(vec3(0.5), texb, step(0., tb)) * 0.5, tex * fac, step(0., t.x));\n}\n\n/* * * * */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera setup\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    // Initial intersection check\n    vec3 n;\n    float t = hybridbox(eye, rd, BOXDIMS, n, true);\n    \n    if (t > 0.) {\n\t    vec3 ro = eye + t * rd;\n        \n        // External reflection\n        vec3 rdr = reflect(rd, n);\n        vec3 reflcol = background(ro, rdr);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n\t\tfloat fresnel = schlick_fresnel(R0, dot(-rd, n));\n        \n        // Compute parameters\n        float osc = oscillate(TIME_L, TIME_H, TIME_T, 0.);\n    \tfloat INNERRAD = mix(0.5, 1.5, osc);\n        float ang = -iTime * 0.33;\n    \tmat2 rot = rot2(ang);\n        vec2 coords = ro.xy * n.z + ro.yz * n.x + ro.zx * n.y;\n        \n        // Compute internal reflections and light leaked with each bounce\n        vec3 rd2 = refract(rd, n, 1./IOR);\n        vec3 insidecol = vec3(0.);\n        float accum = 1.;\n        vec3 transmission = vec3(1.);\n        \n        for (int j=0; j<REFLECTIONS; j++) {\n            // Transform ray into interior space and check for intersection with interior geometry\n            float tb;\n            vec2 coords2 = ro.xy * n.z + ro.yz * n.x + ro.zx * n.y;\n            vec3 eye2 = vec3(coords2, -max(INNERRAD, 1.));\n            vec3 rd2trans = rd2.yzx * n.x + rd2.zxy * n.y + rd2.xyz * n.z;\n            rd2trans.z = -rd2trans.z;\n            vec3 internalcol = insides(eye2, rd2trans, INNERRAD, rot, tb);\n            if (tb > 0.) {\n                // Terminate at interior geometry\n                insidecol += accum * internalcol * transmission * pow(ABSORPTION_RATE, vec3(tb));\n                break;\n            } else {\n                // Compute contribution of the light leaked from the environment through this bounce\n                float tout = hybridbox(ro, rd2, BOXDIMS, n, false);\n                vec3 rout = ro + tout * rd2;\n                vec3 rdout = refract(rd2, -n, IOR);\n                float fresnel2 = schlick_fresnel(R0, dot(rdout, n));\n                rd2 = reflect(rd2, -n);\n\n                ro = rout;\n                // slight correction to get rid of artifacts where transparent interior touches the floor\n                ro.z = max(ro.z, -0.999);\n\n                // Accumulate leaked light\n                transmission *= pow(ABSORPTION_RATE, vec3(tout));\n                insidecol += accum * (1.-fresnel2) * background(ro, rdout) * transmission;\n                if (fresnel2 < 0.1) break;\n                accum *= fresnel2;\n            }\n        }\n        vec3 col = mix(insidecol, reflcol, fresnel);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(background(eye, rd), 1.);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}