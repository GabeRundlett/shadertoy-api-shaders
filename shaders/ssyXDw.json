{
    "Shader": {
        "info": {
            "date": "1635163329",
            "description": "A quarter circle animation in extruded form.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssyXDw",
            "likes": 46,
            "name": "Extruded Circle Animation",
            "published": 3,
            "tags": [
                "circle",
                "design",
                "extrude",
                "propeller"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 595
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Circle Animation\n    -------------------------\n\n\tAs previously mentioned, I on occasion like to take a simple flat 2D \n    example, then extrapolate it to a quasi 3D setting to see if it looks\n    interesting. In this case, I've extruded a 2D animation I've seen in \n    various forms. I think this particular one was originally written by \n    FLRN (Florian).\n    \n    I got the idea to do it after looking at a version on Shadertoy written\n    by Vamoss -- The links to it and the original it was based on are below,\n    for anyone interested.\n    \n    The extruded version is interesting, but it's really hard to beat the \n    simplicity of the original. Anyway, there's nothing technically\n    challenging here, but I've provided a heap of options below, for anyone\n    who wishes to play around with various rendering styles.\n\t\n    \n\n\tBased on the following:\n    \n\tSquare Circle Dance - vamoss\n    https://www.shadertoy.com/view/ldK3Dc\n    \n    Which in turn was based  on:\n    FLORIAN (FLRN)\n    https://flrn-gif.tumblr.com/post/116319247625\n\n\n\n*/\n\n// Textured, metallic and environmental lighting options. Turning them\n// all off looks a little cleaner, which is sometimes preferred, but I've\n// defaulted to a weathered appearance.\n#define TEXTURE\n#define METALLIC\n#define ENVIRONMENT\n\n// Palette - Spectrum: 0, Golden brown: 1, Green and blue: 2, Blinking: 3, \n// Mondrian: 4, White: 5.\n#define PALETTE 0\n\n// Paint the sides a lighter color.\n#define SIDES\n\n// Bump map the background cells.\n#define BUMP_BG\n\n// Giving the camera a subltle tilt.\n#define CAM_TILT\n// Lens warp.\n#define LENS_WARP\n\n\n\n\n// Grayscale (and slightly sepia), for that pretentious artistic look. :)\n//#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n// Scale.\nconst vec2 gScale = vec2(.5);\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// Two different angles. One for each alternate checkered set.\nvec2 gAng;\n\n// Moving the extruded tiles: There are two sets split into\n// alternate checkers. There are 8 key frames.\nvoid move(){\n\n    \n    float n = mod(floor(iTime), 8.); // 8 keyframe.\n    float t = mod(iTime, 8.); // Fractional time.\n    float st = smoothstep(.3, .7, fract(t)); // Smoothing.\n\n    // Each checkered set moves differently: Rotating back and forth,\n    // or rotating by a quarter whilst stopping and resting on alternate\n    // frames. It's mostly common sense.\n    \n    // Angle one.\n    float ndiv2 = floor(n/2.);\n    if(mod(n, 2.) == 0.) gAng.x = mix(ndiv2*3.14159/2., (ndiv2 + 1.)*3.14159/2., st);\n    else gAng.x = (ndiv2 + 1.)*3.14159/2.;\n\n\n    // Angle two.\n    if(mod(floor(t), 2.)<.5){\n        gAng.y = mix(3.14159/2., 0., st);\n    }\n    else {\n        gAng.y = mix(0., 3.14159/2., st);\n    }\n       \n\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n\n#define SHAPE 2\n\n// Shape distance metrics. You could put whatever you feel like here.\nfloat dist(vec2 p, vec2 b){\n \n      \n      #if SHAPE == 0\n      // Square.\n      p = abs(p) - b;\n      return max(p.x, p.y);\n      #elif SHAPE == 1\n      // Diamond.\n      p = abs(p);\n      return (p.x + p.y)*.7071 - mix(b.x, b.y, .5);\n      #elif SHAPE == 2\n      // Octagon.\n      //p *= rot2(3.14159/8.);\n      p = abs(p);\n     \n      return max((p.x + p.y)*.7071, max(p.x, p.y)) - mix(b.x, b.y, .5);\n      \n      // Dodecahedron.\n      // vec2 p2 = p*.8660254 + p.yx*.5;\n      // p = vec2(max(p2.x, p2.y), max(p.y, p.x));\n      // p = abs(p) - mix(b.x, b.y, .5);\n      return max(p.x, p.y);\n      \n      \n      #else\n      // Circle.\n      return length(p) - (b.x + b.y)/2.;\n      #endif\n      \n      //p = abs(p) - b;\n      //p = p*.8660254 + p.yx*.5;\n      //return max(p.x, p.y);\n      \n      //p = abs(p)-b;\n      //p = (p + p.yx)*.7071;\n      //return max(p.x, p.y);\n}\n\n\nfloat faceDist;\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = gScale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    //vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n        \n        p -= idi; // New local position.\n\n\n        // The extruded block height. See the height map function, above.\n        float h = 1.;//hm(idi);\n        \n        //h = floor(h*15.999)/15.*.1; // Or just, \"h *= .15,\" for nondiscreet heights.\n        h *= .025;\n        \n        \n            \n        // One larger extruded block.\n        //float di2D = sBoxS(p, l/2. - .0*scale, .02);\n        \n        \n        vec2 q = p;\n        \n        float t = mod(iTime, 4.);\n;\n        \n        if((i&1)==0){\n            q *= rot2(-gAng.x);\n        }\n        else {\n            q *= rot2(-gAng.y);\n        }\n        \n        //float pin = dist(q, vec2(.09*gScale.x));\n        float pin = length(q) - .08*gScale.x;\n        \n        float di2D = length(q) - (l.x/2. - .01);\n        //float di2D = dist(q, l/2. - .01);\n        di2D = max(di2D, -(max(abs(q.x - .5), abs(q.y - .5)) - .5-.01));\n        di2D = max(di2D, -(max(abs(q.x + .5), abs(q.y + .5)) - .5-.01));\n        \n        di2D = max(di2D, -pin);\n        \n        //pin = abs(pin + .02*gScale.x) - .02*gScale.x;\n        \n\n        \n           \n    \n\n        // Boring out some of the lower boxes. I like it, but thought it\n        // confused matters.\n        //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n        \n        //di -= min(-di2D*.7, .02);\n        di += di2D*.35;\n        \n        //float pat = (abs(fract(di2D*32.) - .5)*2. - .125)/32.;\n        //di -= (pat)*.1;\n        \n        \n        pin = opExtrusion(pin, (q3.z + h - .5), h + .5 + .01);\n        \n //       di = min(di,  opExtrusion(abs(di2D + .01+.002) -.01, (q3.z + h + .005), h + .005));\n        \n        // Cell object ID -- Hacked in at the last minute.\n        float cOID = di<pin? 0. : 1.;\n        di = min(di, pin);\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // Not used in this example, so we're saving the calulation.\n            boxID = cOID;\n            \n            faceDist = di2D;  \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .05;\n/*    \n    vec2 sc = gScale/2.*vec2(1, 1);\n    vec2 q = p.xy;// + vec2(sc.x/2.*1., sc.y/2.);\n            //if(mod(floor(q.y/sc.y), 2.)==0.) q.x += sc.x/2.;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*(sc);\n    q = abs(q);\n    float block = max(max(q.x, q.y) - sc.x/2. + .025, abs(p.z - sc.x/8.) - sc.x/8.);\n    fl = min(fl + .04, block + (max(q.x, q.y) - sc.x/2.)/8.);\n*/\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Distance, block ID, and cell object ID.\n    \n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow \n    // test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime/4.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c, c*c, c); // Blueish tinge.\n    \n    return mix(p.zxy, p, n3D2); // Mixing in a bit of red.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    #ifdef CAM_TILT\n    vec3 ro = vec3(-.125, -.125, -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.005, .01, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    #else\n    vec3 ro = vec3(0, 0, -2.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n    #endif\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .5, 1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    //vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV));\n    #ifdef LENS_WARP\n    // Ray warping, lens warping, etc -- One of many variations.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z + (.5 - dot(rd.xy, rd.xy))*.5, 0.))));\n    #endif\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.yz *= rot2( sin(-3.14159/3.)/3. );\n\t//rd.xz *= rot2( sin(iTime/1.)/64. );\n\t//rd.xy *= rot2( cos(iTime/2.)/64. );\n\n    \n    // Retrieve the two angular postions of the alternating\n    // grid cell objects.\n    move();\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block distance, ID and cell object ID.\n    vec4 svGID = gID;\n    \n    float svfaceDist = faceDist;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(0);   \n\n        \n        // Object: Forground or background.\n        if(svObjID<.5){\n            \n            \n            // The extruded propeller grid.\n            \n            // Coloring.\n            \n            vec2 sc = gScale;\n            vec3 q = sp;\n            vec2 iq = floor(q.xy/sc) + .5;\n            q.xy -= iq*sc;\n            int check = mod(iq.x + iq.y, 2.)<.5? 1 : 0;\n            \n            if(check==1) q.xy *= rot2(-gAng.x);\n            else q.xy *= rot2(-gAng.y);\n\n            \n            // Random value based on cell ID.\n            float rnd = (svGID.y + svGID.z)/4.;\n            \n            //rnd = floor(rnd*16.)/16.;\n            \n            #if PALETTE == 0\n            // Spectrum.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831 + vec3(0, 1, 2)*2. - 2.15);\n            #elif PALETTE == 1\n            // Golden brown.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/4.5 + vec3(0, 1, 2) + .35);\n            #elif PALETTE == 2\n            // Green and blue.\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/4.5 + vec3(0, 1, 2) + .35);\n            if(check == 1) texCol1 = texCol1.zyx;\n            else texCol1 = texCol1.yxz;//vec3(dot(texCol1, vec3(.299, .587, .114)));\n            //if(check == 1 && q.x>q.y) texCol1 = texCol1.yxz;\n            //if(check == 0 && q.x>q.y) texCol1 = texCol1.yxz;\n            #elif PALETTE == 3\n            // Blinking earthtone quarter colors.\n            vec2 iq2 = iq;\n            if(q.x>0.) iq2 += 1./2.;\n            if(q.y<0.) iq2 += 1./4.;\n            rnd = hash21(iq2);\n            float rnd2 = hash21(iq2 + .13);\n            vec3 texCol1 = .5 + .45*cos(-rnd*6.2831/3. + vec3(0, 1, 2) + 1.65);\n            texCol1 = mix(texCol1, mix(texCol1.xzy, texCol1, .25), \n                          smoothstep(.8, .9, sin(rnd2*6.2831 + iTime*2.)*.5 + .5));\n            #elif PALETTE == 4\n            // Mondrian.\n            vec3 texCol1 = vec3(.7);\n            if(check == 1 && q.x<q.y) texCol1 = vec3(1, .07, .06);\n            if(check == 1 && q.x>q.y) texCol1 = vec3(0, .5, 1);\n            if(check == 0 && q.x>q.y) texCol1 = vec3(1, .9, .1);\n            /*\n            // Alternative.\n            vec3 texCol1 = vec3(.7);\n            vec2 qID = mod(floor(svGID.yz*2.), 2.);\n            if(qID.x == 1. && qID.y == 0.) texCol1 = vec3(1, .07, .06);\n            if(qID.x == 0. && qID.y == 1.) texCol1 = vec3(0, .5, 1);\n            if(qID.x == 1. && qID.y == 1.) texCol1 = vec3(1, .9, .1);\n            */\n            #else\n            // White.\n            vec3 texCol1 = vec3(.65);\n            #endif\n             \n            // The outer propellor rim color.\n            vec3 texCol2 = mix(vec3(1.5), texCol1, dot(texCol1, vec3(.299, .587, .114)));//tx/1.5;//\n            #if PALETTE == 4\n            texCol2 = vec3(.85);\n            #endif\n     \n            // Applying the texture, if defined.\n            #ifdef TEXTURE\n            vec3 tx = tex3D(iChannel0, vec3(q.xy + iq/2. - .125, q.z)/2., sn);\n            tx = smoothstep(-.1, .5, tx);\n            texCol1 = mix(texCol1, texCol1*tx*1.75, .65);\n            texCol2 = tx;\n            #endif\n            \n            // Setting the outer and inner propellor colors.\n            if(svGID.w == 1.) texCol = texCol2;\n            else texCol = texCol1;\n\n            \n            \n           \n        \n            // Constructing the dark propeller edge markings.          \n            float ht = 1.;//hm(svGID.yz);\n            vec2 lCoord = sp.xy - svGID.yz;\n            sc = gScale;\n            float lw = gScale.x*.06;//.05;\n            float dS = abs(svfaceDist) - lw;\n\n            // Tapering the sides, or not.\n            #ifndef SIDES\n            dS = max(dS, abs(sp.z + ht*.025*2.) - lw); // Just the rim.\n            #endif\n            \n\n            \n            if(svGID.w == 0.){\n                // Rendering the propeller colors and dark edge markings. \n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .005, dS))*.95);\n                texCol = mix(texCol, texCol2*.7, (1. - smoothstep(0., .005, dS + .015)));\n            }\n            else {\n                // Inner markings.\n                float cir = length(lCoord) - lw/2.  -.005;\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .007, cir)));\n                texCol = mix(texCol, texCol2, (1. - smoothstep(0., .007, cir + .015)));\n            }\n              \n           \n \n        }\n        else {\n            \n            // The dark floor in the background.\n            //\n            // Scaling, ID and local square cell coordinates.\n            vec2 sc = gScale/2.*vec2(1, 1);\n            vec2 q = sp.xy;// + vec2(sc.x/2.*1., sc.y/2.);\n            //if(mod(floor(q.y/sc.y), 2.)==0.) q.x += sc.x/2.; // Brickwork.\n            vec2 iq = floor(q/sc) + .5;\n            q -= iq*(sc);\n            \n            // Two square samples for bump mapping purposes. In case it isn't obvious,\n            // this is a very cheap and hacky procedure, but it's good enough.\n            float sq = max(abs(q.x) - sc.x/2., abs(q.y) - sc.y/2.);\n            vec2 ld2 = normalize(ld.xy);\n            float sq2 = max(abs(q.x + ld2.x*.01) - sc.x/2., abs(q.y + ld2.y*.01) - sc.y/2.);\n            float bord = abs(sq) - .005;\n            bord = abs(bord - .015) - .005;\n            \n            float b = max((sq2 - sq)/.01, 0.); // Bump value.\n            texCol = vec3(.05);\n            #ifdef BUMP_BG\n            texCol += b*b*.05; // Adding the bump value.\n            #endif\n            // Extra bordering.\n            texCol = mix(texCol, texCol*2., (1. - smoothstep(0., .005*4., bord)));\n            texCol = mix(texCol, texCol/8., (1. - smoothstep(0., .005, bord)));\n            \n            // If the texture is set, apply it.\n            #ifdef TEXTURE\n            vec3 tx = getTex(sp.xy/3.);\n            tx = smoothstep(-.1, .55, tx);\n            texCol *= tx*2.;\n            #endif\n            \n        }\n        \n        // Greyscale values.\n        #ifdef GRAYSCALE\n        texCol = vec3(1.1, .95, .8)*dot(texCol, vec3(.299, .587, .114));\n        #endif\n        \n        \n        // Ramping up the diffuse values, depending on what part of the scene we've hit.\n        vec2 sc = gScale;\n        float lw = gScale.x*.06;\n        float dS = abs(svfaceDist) - lw;\n        \n        #ifdef METALLIC\n        \n        if(svObjID == 0.){\n           // Outer and inner propeller diffuse values.\n           diff = mix(diff, pow(diff, 4.)*1.5, 1. - smoothstep(0., .005, dS));\n           if(svGID.w == 1.) diff = pow(diff, 4.)*1.5;\n           //diff = pow(diff, 4.)*1.5;\n        }\n        else {\n           // Making the dark background more metallic.\n           diff = pow(diff, 6.)*2.35;\n        }\n        #endif\n        \n        \n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(.25, .5, 1)*fre*0. + vec3(1, .97, .9)*spec*freS*2.*sh);\n\n        \n        #ifdef ENVIRONMENT\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        \n        if(svObjID == 0.){\n            // Adding more environment lighting to the out propeller.\n            col = mix(col + (col)*cTex*2., col + (col)*cTex*6., 1. - smoothstep(0., .005, dS));\n        }\n        else col = col + (col)*cTex*2.; // Just a bit of environment lighting to the background.\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // Debug AO, shadows, etc.\n        //col = vec3(ao);\n\t\n\t}\n    \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}