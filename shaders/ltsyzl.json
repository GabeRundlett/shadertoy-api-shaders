{
    "Shader": {
        "info": {
            "date": "1506072534",
            "description": "Left - Sampling emitter area.\nRight - Sampling emitter solid angle.\nReference :\nAn Area-Preserving Parametrization for Spherical Rectangles\nhttps://www.solidangle.com/research/egsr2013_spherical_rectangle.pdf",
            "flags": 0,
            "hasliked": 0,
            "id": "ltsyzl",
            "likes": 20,
            "name": "Sampling Spherical Rectangle",
            "published": 3,
            "tags": [
                "rectangle",
                "sampling",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "koiava",
            "viewed": 1650
        },
        "renderpass": [
            {
                "code": "#define PIXEL_SAMPLES \t\t4\t\t\t//Increase for higher quality\n#define LIGHT_SAMPLES\t\t1\t\t\t//Increase for higher quality\n\n//CDF for RIS to resample projected solid angle\n#define CDF_SIZE 1\t//Increase for better quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\n#define LIGHT_CLIPPING\n//#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t\t0\n#define SAMPLE_SPHERICAL_RECTANGLE\t1\n#define SAMPLE_NONE\t\t\t\t\t2\nint samplingTechnique;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_TRIANGLE\t4\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createTriangle(mat4 transform, vec2 v1, vec2 v2, vec2 v3, int mtl, out Object obj) {\n    obj.type_ = OBJ_TRIANGLE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = v1.x;\t\t\t\n    obj.params_[1] = v1.y;\t\t\t\n    obj.params_[2] = v2.x;\t\t\t\n    obj.params_[3] = v2.y;\t\t\t\n    obj.params_[4] = v3.x;\t\t\n    obj.params_[5] = v3.y;\t\t\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.x==0.0)?0.8:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = 0.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -1.8+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 3.0, z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n    createPlane(trans, -3.0, -1.0, 3.0, 1.0, MTL_LIGHT, objects[0]);\n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 2.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.0, 0.0, -5.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    CHECK_OBJ( objects[0] );\n    if(!forShadowTest) {\t//Hack optimization for shadow rays\n        CHECK_OBJ( objects[1] );\n        CHECK_OBJ( objects[2] );\n        CHECK_OBJ( objects[3] );\n    }\n    CHECK_OBJ( objects[4] );\n    CHECK_OBJ( objects[5] );\n    CHECK_OBJ( objects[6] );\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformPointWitinTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in float Xi1, in float Xi2 ) {\n    Xi1 = sqrt(Xi1);\n    return (1.0-Xi1)*v1 + Xi1*(1.0-Xi2)*v2 + Xi1*Xi2*v3;\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, 1.0, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\nstruct SphQuad {\n    vec3 o, x, y, z; // local reference system ’R’\n    float z0, z0sq; //\n    float x0, y0, y0sq; // rectangle coords in ’R’\n    float x1, y1, y1sq; //\n    float b0, b1, b0sq, k; // misc precomputed constants\n    float S; // solid angle of ’Q’\n};\n    \nvoid SphQuadInit(vec3 s,vec3 ex,vec3 ey,vec3 o, out SphQuad squad) {\n    squad.o = o;\n    float exl = length(ex), eyl = length(ey);\n    // compute local reference system ’R’\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    // flip ’z’ to make it point against ’Q’\n    if (squad.z0 > 0.) {\n    squad.z *= -1.;\n    squad.z0 *= -1.;\n    }\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0);\n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0);\n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0,n1));\n    float g1 = acos(-dot(n1,n2));\n    float g2 = acos(-dot(n2,n3));\n    float g3 = acos(-dot(n3,n0));\n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2.*PI - g2 - g3;\n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n}\n\nvoid SphQuadSample(in vec3 x, SphQuad squad, float u, float v, out vec3 w, out float pdf) {\n    // 1. compute ’cu’\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = 1./sqrt(fu*fu + squad.b0sq) * (fu>0. ? +1. : -1.);\n    cu = clamp(cu, -1., 1.); // avoid NaNs\n    // 2. compute ’xu’\n    float xu = -(cu * squad.z0) / sqrt(1. - cu*cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n    // 3. compute ’yv’\n    float d = sqrt(xu*xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1-h0), hv2 = hv*hv;\n    float yv = (hv2 < 1.-EPSILON) ? (hv*d)/sqrt(1.-hv2) : squad.y1;\n    // 4. transform (xu,yv,z0) to world coords\n    \n    vec3 p = (squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z);\n    w = normalize(p - x);\n    pdf = 1. / squad.S;\n}\n\nvoid update_x_bounds(vec3 pos, vec3 n, inout vec2 pmin, inout vec2 pmax) {\n    vec2 p1 = pmin;\n    vec2 p2 = vec2(pmin.x, pmax.y);\n    if(n.x != 0.0) {\n        float tmin = (pos.z*n.z - (p1.y - pos.y)*n.y)/n.x - p1.x + pos.x;\n        float tmax = (pos.z*n.z - (p2.y - pos.y)*n.y)/n.x - p2.x + pos.x;\n\n        float minx = clamp(pmin.x + tmin, pmin.x, pmax.x);\n        float maxx = clamp(pmin.x + tmax, pmin.x, pmax.x);\n\n        if(n.x > 0.0) {\n            pmin.x = min(minx, maxx);\n        } else {\n            pmax.x = max(minx, maxx);\n        }\n    }\n}\n\nvoid update_y_bounds(vec3 pos, vec3 n, inout vec2 pmin, inout vec2 pmax) {\n    vec2 p1 = pmin;\n    vec2 p2 = vec2(pmax.x, pmin.y);\n    //pos = pos.xzy;\n    if(n.y != 0.0){\n        float tmin = (pos.z*n.z - (p1.x - pos.x)*n.x)/n.y - p1.y + pos.y;\n        float tmax = (pos.z*n.z - (p2.x - pos.x)*n.x)/n.y - p2.y + pos.y;\n\n        float miny = clamp(pmin.y + tmin, pmin.y, pmax.y);\n        float maxy = clamp(pmin.y + tmax, pmin.y, pmax.y);\n\n        if(n.y > 0.0) {\n            pmin.y = min(miny, maxy);\n        } else {\n            pmax.y = max(miny, maxy);\n        }\n    }\n}\n\nvoid sampleArea(in vec3 pos, vec2 pmin, vec2 pmax, out vec3 w, out float pdfW) {\n    vec2 size = pmax - pmin;\n    float pdfA = 1.0 / (size.x*size.y);\n    vec3 p = vec3(pmin + size*vec2(rnd(), rnd()), 0.0);\n    w = p - pos;\n    float d2 = dot(w,w);\n    w /= sqrt(d2);\n    float aCosThere = max(0.0,-w.z);\n    pdfW = PdfAtoW( pdfA, d2, aCosThere );\n}\n\nvoid sampleDirectLight( vec3 pos,\n                       \tvec3 normal,\n                        float Xi1,\n                        float Xi2, \n                       \tout vec3 dir,\n                       \tout float pdf ) {\n    float height = objects[0].params_[2] - objects[0].params_[1];\n    float r = objects[0].params_[0];\n    float pdfA;\n    float d2;\n    float aCosThere;\n    float theta;\n    float thetaPdf;\n    float h;\n    float hPdf;\n    \n    //convert position to object space\n    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );\n    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );\n    \n    if(pos.z > 0.0) { \n        vec2 pmin = vec2(objects[0].params_[0], objects[0].params_[1]);\n        vec2 pmax = vec2(objects[0].params_[2], objects[0].params_[3]);\n\n#ifdef LIGHT_CLIPPING\n        update_x_bounds(pos, normal, pmin, pmax);\n        update_y_bounds(pos, normal, pmin, pmax);\n#endif\n        vec3 w[CDF_SIZE];\n        float ww[CDF_SIZE];\n        if(samplingTechnique == SAMPLE_TOTAL_AREA){\n            for(int i=0; i<CDF_SIZE; i++) {\n            \tsampleArea(pos, pmin, pmax, w[i], pdf);\n                ww[i] = max(0.0, dot(w[i], normal)) / pdf;\n            }\n        } else {\n            vec3 s = vec3(pmin, 0.0);\n            vec3 ex = vec3(pmax.x - pmin.x, 0., 0.);\n            vec3 ey = vec3(0., pmax.y - pmin.y, 0.);\n            SphQuad squad;\n            SphQuadInit(s, ex, ey, pos, squad);\n            \n            for(int i=0; i<CDF_SIZE; i++) {\n                SphQuadSample(pos, squad, rnd(), rnd(), w[i], pdf);\n                ww[i] = max(0.0, dot(w[i], normal)) / pdf;\n            }\n        }\n        \n        for(int i=1; i<CDF_SIZE; i++) {\n            ww[i] += ww[i-1];\n        }\n        \n        float a = Xi1 * ww[CDF_SIZE-1];\n        for(int i=0; i<CDF_SIZE; i++) {\n            if(ww[i] > a) {\n                pdf *= (ww[i] - ((i == 0)? 0.0 : ww[i-1])) / ww[CDF_SIZE-1];\n                pdf *= float(CDF_SIZE);\n                dir = w[i];\n                break;\n            }\n        }\n    } else {\n        pdf = 0.0;\n    }\n    \n    //convert dir to world space\n    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(4.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = (dot(hit.normal_, Wo) > 0.0)? L : vec3(0.0, 0.0, 0.0);\n        } else {\n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                float pdfWi;\n                vec3 n = hit.normal_ * ((dot(hit.normal_, Wo) > 0.0 )? 1.0 : -1.0);\n                \n            \tfloat Xi1 = rnd();\n            \tfloat Xi2 = rnd();\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                Xi2 = strataSize * (float(i) + Xi2);\n#endif\n                \n                sampleDirectLight( hit.position_, n, Xi1, Xi2, Wi, pdfWi );\n                float dotNWi = dot( Wi, n );\n\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + n*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);//max(0.0, dot(Wi, hit.normal_))*vec3(1.0);//Material_Evaluate( hit, Wo, Wi );\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float split = iMouse.x;\n    split = (split == 0.0)? iResolution.x * 0.5 : split;\n    float k = iMouse.x/iResolution.x;\n    float split1 = iMouse.x*k;\n    float split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if(p > split+1.0){\n        samplingTechnique = SAMPLE_SPHERICAL_RECTANGLE;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}