{
    "Shader": {
        "info": {
            "date": "1521492016",
            "description": "this is my first try on z pass, i did this based on a game i played a lot, after burner 2 on sega saturn. the rendering in that was probably an array of pixels that would rotate.\n\nthis is my first test on rotation and z position. all done together",
            "flags": 0,
            "hasliked": 0,
            "id": "Mdcczf",
            "likes": 5,
            "name": "After Burner 2 logo",
            "published": 3,
            "tags": [
                "3d",
                "rotationmatrix"
            ],
            "usePreview": 0,
            "username": "indominator",
            "viewed": 634
        },
        "renderpass": [
            {
                "code": "#define SC(a) vec3(sin(a),cos(a),sin(a))\n\n#define C(a,b) clamp(a,0.,1.)*b\n#define PI 3.14159265358979323844\n\n/////////////////////////////////\n////////circles properties///////\n/////////////////////////////////\n\n\n//const float zcenter = 0.;\n\n///////////////////////////////////\n//////circles is red array////////\n//////////////////////////////////\n\nconst int isred[132] =  int[132]\n    (0,0,0,0,0,0,0,0,0,0,0,0, \t//1\n     0,0,0,0,0,0,0,0,0,0,0,0,\t//2\n     0,0,1,1,1,1,1,1,1,1,0,0,\t//3\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//4\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//5\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//6\n     0,0,0,0,1,0,0,1,0,0,0,0, \t//7\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//8\n     0,0,1,1,1,1,1,1,1,1,0,0,\t//9\n     0,0,0,0,0,0,0,0,0,0,0,0,\t//10\n     0,0,0,0,0,0,0,0,0,0,0,0);\t//11\n\n\n/////////////////////////////////\n////////////functions///////////\n////////////////////////////////\n\n//////////////////////////////////////////// this is to get the direction of the whole batch\nvec3 o_dir = vec3(0.,0.,1.);\nvec3 dir_angle = vec3(0.,0.,0.);\nvec3 rot_angle = normalize(vec3(0.,1.,0.)); \nvec3 get_direction( float angle){\n    \n    float px =\n        o_dir.x* ( cos(angle) + pow(rot_angle.x,2.)*(1. - cos(angle) ) ) \n        +o_dir.y*( rot_angle.y*rot_angle.x* (1. - cos(angle)) + rot_angle.z* sin(angle) ) \n        +o_dir.z*(rot_angle.z*rot_angle.x*(1. - cos(angle)) - rot_angle.y* sin(angle) ) ;\n     float py = \n       o_dir.x*(rot_angle.x*rot_angle.y*(1. - cos(angle)) - rot_angle.z* sin(angle)) \n      +o_dir.y*(cos(angle) +pow(rot_angle.y,2.)*(1. - cos(angle)) )\n      +o_dir.z*(rot_angle.z*rot_angle.y*(1. - cos(angle)) + rot_angle.x* sin(angle));\n     float pz = \n       o_dir.x*(rot_angle.z*rot_angle.y*(1. - cos(angle)) + rot_angle.y* sin(angle)) \n      +o_dir.y*(rot_angle.z*rot_angle.z*(1. - cos(angle)) - rot_angle.x* sin(angle)) \n      +o_dir.z*(cos(angle) +pow(rot_angle.z,2.)*(1. - cos(angle)));\n    \n    return normalize(vec3(px,py,pz));\n    \n}\n\n/////// get position of center\nvec3 center = vec3(0.5,0.5,0.);\nfloat dist_fcenter = 0.;\nvec3 center2 = vec3(0.5,0.5,0.);\nfloat dist_fcenter2 = 0.;\n\nvec3 get_center_position(bool red){\n    if(!red)\n return center + dir_angle*dist_fcenter ;\n    else\n        return center2 + dir_angle*dist_fcenter2 ;\n}\n\nfloat noat = -1223233.4;\n\n/////ZPOS of a single sphere\nvec3 p_scale = vec3(50.,50.,0.);\nfloat radius =22.;   \n\nfloat s_ratio = 0.;\n\nfloat ZPOS_circle\n (int number,  float angle,   vec2 fragCoord, bool red){\n  int y = number/12;\n    int x = number%12;\n    vec3 p_temp = vec3((float(x) - 6.)*p_scale.x,(float(y) - 5.5)*p_scale.y,0.);\n float px =\n        p_temp.x*(cos(angle) +pow(dir_angle.x,2.)*(1. - cos(angle))) \n        +p_temp.y*(dir_angle.y*dir_angle.x*(1. - cos(angle)) + dir_angle.z* sin(angle))\n        +p_temp.z*(dir_angle.z*dir_angle.x*(1. - cos(angle)) - dir_angle.y* sin(angle));\n       float py = \n       p_temp.x*(dir_angle.x*dir_angle.y*(1. - cos(angle)) - dir_angle.z* sin(angle)) \n      +p_temp.y*(cos(angle) +pow(dir_angle.y,2.)*(1. - cos(angle)) )\n      +p_temp.z*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.x* sin(angle));\n     float pz = \n       p_temp.x*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.y* sin(angle)) \n      +p_temp.y*(dir_angle.z*dir_angle.z*(1. - cos(angle)) - dir_angle.x* sin(angle)) \n      +p_temp.z*(cos(angle) +pow(dir_angle.z,2.)*(1. - cos(angle)));\n    \n    /// here recalc radius\n    \n  float  radius2 =  radius + (pz)*s_ratio;\n    \n    \n  \n    \n    \n    ///get X Y and if lenght() < radius\n     \n    if(\n        length (fragCoord - vec2(px ,py) - \n                (red? center2.xy: center.xy)*iResolution.xy  ) < radius2\n        )\n    return pz + center.z;\n        else return noat;\n}\n\n//vec3 p_scale = vec3(20.,20.,20.);\n\nint HighesZ_ofSpheres\n( float angle,   vec2 fragCoord){\n   float Mz = noat;\n    int num = -1;\n    for(int i =0; i < 132; i ++){\n        float tz =  ZPOS_circle( i,angle,fragCoord,isred[i]==0);\n        \n        if(tz != noat &&tz > Mz){Mz = tz; num=i;}\n    }\n        \n   return num;     \n}\n\n////XYZ pos of sphere  ///REMAKE /// INTo NORMAL\nvec3 normal(int number, float angle,vec2 fragCoord){\n int y = number/12;\n    int x = number%12;\n    vec3 p_temp = vec3((float(x) - 6.)*p_scale.x,(float(y) - 5.5)*p_scale.y,0.);\n float px =\n        p_temp.x*(cos(angle) +pow(dir_angle.x,2.)*(1. - cos(angle))) \n        +p_temp.y*(dir_angle.y*dir_angle.x*(1. - cos(angle)) + dir_angle.z* sin(angle))\n        +p_temp.z*(dir_angle.z*dir_angle.x*(1. - cos(angle)) - dir_angle.y* sin(angle));\n       float py = \n       p_temp.x*(dir_angle.x*dir_angle.y*(1. - cos(angle)) - dir_angle.z* sin(angle)) \n      +p_temp.y*(cos(angle) +pow(dir_angle.y,2.)*(1. - cos(angle)) )\n      +p_temp.z*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.x* sin(angle));\n     float pz = \n       p_temp.x*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.y* sin(angle)) \n      +p_temp.y*(dir_angle.z*dir_angle.z*(1. - cos(angle)) - dir_angle.x* sin(angle)) \n      +p_temp.z*(cos(angle) +pow(dir_angle.z,2.)*(1. - cos(angle)));\n    \n  \n  float  radius2 =  radius + (pz)*s_ratio;\n    \n   //this is broken  \n    bool red = (isred[number]==1);\n    \n    vec2 cent = fragCoord - vec2(px ,py) - \n                (red? center2.xy: center.xy)*iResolution.xy;\n    \n     float z =sqrt( pow(radius2,2.) - pow(cent.x,2.) - pow(cent.y,2.));  //1. \n    \n\n    \n    return normalize( vec3(cent,z));\n}\n\n///////////////////////////\n\n\n\n//////////////////////////////////////////////\n//////////////////MAIN ///////////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    \n     float angle = iTime;        //rotation velocity //iTime*algo\n    \n    \n \t dir_angle = get_direction(angle); // rotation angle normalized\n    center = get_center_position(false);\n    center2 = get_center_position(true);\n  \n   int numero = HighesZ_ofSpheres(angle,fragCoord);\n    \n\n    \n    /////////////// COLOR SET//////////////\n     //////////////////////// LIGHT SET////////\n     if(numero > - 1){\n           vec3 normal =  normal(numero,angle,fragCoord);\n          vec3 ldir = (vec3(0.3,0.,1.1));\n          float cosTheta = clamp( dot( normal,ldir ), 0.3,1.0);\n         float  dis =1.- length( ldir - normal )/2. ;\n\n         vec3 light1col = vec3( 1.0, 2.0, 3.0 ); \n          if(isred[numero]==1)fragColor = vec4(1.,0.,0.,1.)* cosTheta;\n        else fragColor = vec4(0.,0.,1.,1.)* cosTheta;\n         \n      fragColor.rgb += light1col * pow( dis, 8.0);\n         \n\n    \n     }\n    \n   \n    \n    \n\n      \n \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}