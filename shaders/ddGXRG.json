{
    "Shader": {
        "info": {
            "date": "1681244151",
            "description": "Nice\n",
            "flags": 32,
            "hasliked": 0,
            "id": "ddGXRG",
            "likes": 2,
            "name": "Pathtracing WIP 1",
            "published": 3,
            "tags": [
                "3d",
                "pathtracing",
                "pathtracer",
                "pbr"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //vec4 col = vec4(texture(iChannel0, uv).xyz, 1);\n    fragColor = texture(iChannel0, uv);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 backCol = vec3(1);\n\nstruct material{\n    vec3 col;\n    float brightness;\n    float smoothness;\n    float specularProbability;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n};\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random32(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y)*p.z);\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return fract(p.x + p.y);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 6; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nSDF sphere(vec3 p, float r, material mat){\n    return SDF((length(p) - r)*0.9, mat);\n}\n\nSDF plane(vec3 p, vec3 n, float h, material mat){\n    return SDF(length((p - h)*n)*0.9, mat);\n}\n\nSDF box(vec3 p, vec3 s, material mat){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat);\n}\n\nSDF infinitePatternSDF(vec3 p, vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return sphere(q, 1.0, mat);\n}\n\nSDF fuselage(vec3 p, material mat){\n    p.z *= 0.125;\n    p.y -= 0.1;\n    p.x *= 1.5;\n    p.x += smoothstep(0.0, 1.0, p.z)*0.2*sign(p.x)*abs(p.z);\n    p.y *= 0.7;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z*0.8 + 0.3)*2.0;\n    p.y += smoothstep(0.0, 1.0, -p.z)*0.6;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, -p.z*3.5 - 0.3)*2.0;\n    \n    p.y -= smoothstep(0.0, 1.0, p.z)*1.0;\n    \n    SDF s = sphere(p - vec3(0, 0, 0), 0.25, mat);\n    return SDF(s.dist*0.5, mat);\n}\n\nSDF wings(vec3 p, material mat){\n    p.y += 0.1;\n    p.z -= 0.12;\n    p.x *= 0.14;\n    p.y *= 3.5;\n    p.z *= 0.4;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, -p.z)*7.0;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z)*2.0;\n    p.y -= smoothstep(0.0, 1.0, abs(p.x))*2.0;\n    p.y += smoothstep(0.0, 1.0, p.z + 0.1)*0.2;\n    p.z -= smoothstep(0.0, 1.0, abs(p.x))*1.0;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z)*0.1;\n    \n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.3, mat);\n}\n\nSDF horizontalStabilizer(vec3 p, material mat){\n    p.z -= 1.5;\n    p.y -= 0.15;\n    p.x *= 0.3;\n    p.y *= 4.0;\n    p.z *= 0.8;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, -p.z)*6.0;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z)*2.0;\n    p.y += smoothstep(0.0, 1.0, p.z + 0.1)*0.1;\n    p.z -= smoothstep(0.0, 1.0, abs(p.x))*1.0;\n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.3, mat);\n}\n\nSDF verticalStabilizer(vec3 p, material mat){\n    p.z -= 1.6;\n    p.y -= 0.3;\n    p.x *= 3.0;\n    p.y *= p.y > 0.0 ? 0.4 : 1.0;\n    p.z *= 0.8;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, -p.z)*6.0;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, p.z + 0.3)*1.0;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, p.y - 0.1)*2.0;\n    p.x += smoothstep(0.0, 1.0, p.z)*0.1;\n    p.z *= 1.0 + smoothstep(0.0, 1.0, p.y)*2.0;\n    p.z -= smoothstep(0.0, 1.0, abs(p.y))*1.0;\n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.2, mat);\n}\n\nSDF canopy(vec3 p, material mat){\n    p.y -= 0.2;\n    p.z += 0.7;\n    p.z *= 0.4;\n    p.x *= 1.6;\n    p.y += smoothstep(0.0, 1.0, -p.z);\n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.7, mat);\n}\n\nSDF engine(vec3 p, material mat){\n    p.z *= 0.4;\n    SDF intake = sphere(p, 0.3, mat);\n    p.z /= 0.4;\n    p.z -= 9.8;\n    SDF cutout = sphere(p, 10.0, mat);\n    p.z += 9.5;\n    p.x *= 0.7;\n    p.z *= 0.2;\n    p.y -= smoothstep(0.0, 1.0, p.z);\n    p.x *= 1.0 + smoothstep(0.0, 1.0, p.z + 0.1)*4.0;\n    float s = max(-intake.dist, max(cutout.dist, sphere(p, 0.25, mat).dist));\n    return SDF(s*0.4, mat);\n}\n\nSDF airplaneSDF(vec3 p, material mat){\n    SDF can = canopy(p, material(vec3(0.5), 0.5, 1.0, 0.2));\n    \n    float s = min(min(min(min(min(fuselage(p, mat).dist, engine(p, mat).dist), can.dist), verticalStabilizer(p, mat).dist), horizontalStabilizer(p, mat).dist), wings(p, mat).dist);\n    if(s == can.dist){\n        return can;\n    }else{\n        return SDF(s, mat);\n    }\n}\n\nSDF scene(vec3 p){\n    SDF ground = plane(p, vec3(0, 1, 0), -0.5, material(vec3(1), 0.5, 1.0, 1.0));\n    SDF b1 = sphere(p - vec3(0, 0, 2), 0.5, material(vec3(1), 0.5, 1.0, 1.0));\n    SDF l1 = box(p - vec3(1.5, 1, 2), vec3(0.25), material(vec3(0, 1, 1), 10.0, 0.0, 0.0));\n    SDF l2 = sphere(p - vec3(-1, 0, 2), 0.5, material(vec3(1), 0.5, 1.0, 1.0));\n    float closest = min(ground.dist, min(b1.dist, min(l1.dist, l2.dist)));\n    if(closest == ground.dist){\n        return ground;\n    }else if(closest == b1.dist){\n        return b1;\n    }else if(closest == l2.dist){\n        return l2;\n    }else{\n        return l1;\n    }\n}\n\nfloat raymarch(vec3 o, vec3 d, inout bool h, inout material mat){\n    float t = 0.0;\n    for(int i = 0; i < 300 && t <= 100.0 && !h; i++){\n        SDF s = scene(o + d*t);\n        mat  = s.mat;\n        t += s.dist;\n        if(abs(s.dist) <= 0.002*t && t >= 0.0) h = true;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    vec2 e = vec2(0, 0.01);\n    return normalize(vec3(\n        scene(h + e.yxx).dist - scene(h - e.yxx).dist,\n        scene(h + e.xyx).dist - scene(h - e.xyx).dist,\n        scene(h + e.xxy).dist - scene(h - e.xxy).dist\n    ));\n}\n\nvoid getPixelCol(vec3 o, vec3 d, inout vec3 col, float seed){\n    bool hit = false;\n    material mat = material(vec3(1), 1.0, 0.0, 0.0);\n    float t = raymarch(o, d, hit, mat);\n    float depth = t;\n    vec3 dens = 1.0 - exp(-t*vec3(0.01, 0.011, 0.015));\n    if(hit){\n        col *= mix(mat.col*mat.brightness, backCol, dens);\n        col = clamp(col, vec3(0), vec3(1));\n        if(mat.brightness > 1.0) return;\n        for(int i = 0; i < 10; i++){\n            hit = false;\n            vec3 n = getNormal(o + d*t);\n            o = o + d*t;\n            //From Sebastian Lague\n            bool isSpecularBounce = mat.specularProbability <= (random32(o*2093847.4832 + 293.482 + seed) + 1.0)/2.0;\n            vec3 dd = normalize(vec3(random32(o*2093847.4832 + 293.482 + seed), random32(o*3283742.438 + 213.847 + seed), random32(o*208347.483 + 283.837 + seed)));\n            vec3 sd = normalize(reflect(d, n));\n            d = mix(dd, sd, mat.smoothness*(isSpecularBounce ? 0.0 : 1.0));\n            d *= sign(dot(d, n));\n            t = raymarch(o, d, hit, mat);\n            dens = 1.0 - exp(-t*vec3(0.1, 0.11, 0.15));\n            if(hit){\n                //col = mix(col, vec3(1), isSpecularBounce ? 0.0 : 1.0);\n                col *= mix(mat.col*mat.brightness*clamp(dot(d, n), 0.0, 1.0)*2.0, backCol, dens);\n            }else{\n                col *= backCol*mat.brightness*clamp(dot(d, n), 0.0, 1.0)*2.0;\n                break;\n            }\n            if(mat.brightness > 1.0) return;\n        }\n    }else{\n        col *= backCol;\n        return;\n    }\n    col = mix(col, backCol, 1.0 - exp(-depth*vec3(0.01, 0.011, 0.015)));\n}\n\nconst float focalLength = 4.0;\nconst float aperture = 0.3;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(1);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 1, -2);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(10.0), radians(0.0))));\n    vec3 focalPoint = o + d*focalLength;\n    vec3 so = o + vec3(random3(d*483092.4837 + float(iFrame)), random3(d*327463.3247 + float(iFrame)), random3(d*227422.2347 + float(iFrame)))*aperture;\n    vec3 cd = normalize(focalPoint - so);\n    getPixelCol(so, cd, col, float(iFrame));\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //vec4 col = ;\n    fragColor = texture(iChannel1, uv)*(1.0 - 1.0/float(iFrame + 1)) + texture(iChannel0, uv)*1.0/float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}