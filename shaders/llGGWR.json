{
    "Shader": {
        "info": {
            "date": "1474061227",
            "description": "Automated version to explore quickly many cellular automatons. Includes an extra special bitmap font technique.",
            "flags": 32,
            "hasliked": 0,
            "id": "llGGWR",
            "likes": 15,
            "name": "Automated Automata",
            "published": 3,
            "tags": [
                "2d",
                "numbers",
                "bitmap",
                "font",
                "automata",
                "cellular"
            ],
            "usePreview": 1,
            "username": "TimoKinnunen",
            "viewed": 765
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bufA = texture(iChannel0, uv);\n    fragColor = bufA;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#line 2\n/////////////////////////////////////////////\n// Automated Automata\n//\n// Based on Simple Cellular Autonoma by sobokhan\n// @ https://www.shadertoy.com/view/Xty3WR\n//\n// Cycles through various automatas. Also prints\n// bitmap font numbers using a technique which\n// stores them in an uncompressed, easily\n// editable form.\n//\nconst float tau = 6.283185307179586;\nconst vec4 white = vec4(1., 1., 1., 1.);\nconst vec4 black = vec4(0., 0., 0., 1.);\nconst vec4 red = vec4(0., 1., 0., 1.);\n// Change this to change the rule, 0-255\n// 126 is a sierpinski triangle\n// good other values 30, 54, 60, 62, 90, 94, 102, 110, 122\n// 126, 150, 152, 182, 188, 190, 220, 222, 250\nconst int rule = 100;\n\nint PIX_size;\nivec2 PIX_XY;\nivec2 PIX_xy;\nvec4 PIX_on;\nvec4 PIX_color;\n\nvec2 iResolution0;\nvec2 glFragResolution;\nvec2 glFragCoord;\n\n#define PIX(pxx,pxy) PIX_XY=ivec2(pxx,pxy);PIX_xy=PIX_XY;\n#define ln PIX_xy.y-=PIX_size;PIX_xy.x=PIX_XY.x;\n#define PIXon PIX_color += (1.0- PIX_color.a)* clamp(PIX_on* (float(PIX_size)*.5- distance(glFragCoord.xy+float(PIX_size)*.5, vec2(PIX_xy))),0.,1.);\n#define PIXnx PIX_xy.x += PIX_size;\n#define PIXel PIXon PIXnx\n\n#define        _ PIXnx PIXnx\n#define        X PIXnx PIXel\n#define       _X PIXnx PIXnx PIXel\n#define       X_ PIXnx PIXel PIXnx\n#define      _X_ PIXnx PIXnx PIXel PIXnx\n#define       XX PIXnx PIXel PIXel\n#define      _XX PIXnx PIXnx PIXel PIXel\n#define      XX_ PIXnx PIXel PIXel PIXnx\n#define     _XX_ PIXnx PIXnx PIXel PIXel PIXnx\n#define      XXX PIXnx PIXel PIXel PIXel\n#define     _XXX PIXnx PIXnx PIXel PIXel PIXel\n#define     XXX_ PIXnx PIXel PIXel PIXel PIXnx\n#define    _XXX_ PIXnx PIXnx PIXel PIXel PIXel PIXnx\n#define     XXXX PIXnx PIXel PIXel PIXel PIXel\n#define    _XXXX PIXnx PIXnx PIXel PIXel PIXel PIXel\n#define    XXXX_ PIXnx PIXel PIXel PIXel PIXel PIXnx\n#define   _XXXX_ PIXnx PIXnx PIXel PIXel PIXel PIXel PIXnx\n#define    XXXXX PIXnx PIXel PIXel PIXel PIXel PIXel\n#define   _XXXXX PIXnx PIXnx PIXel PIXel PIXel PIXel PIXel\n#define   XXXXX_ PIXnx PIXel PIXel PIXel PIXel PIXel PIXnx\n#define  _XXXXX_ PIXnx PIXnx PIXel PIXel PIXel PIXel PIXel PIXnx\n#define   XXXXXX PIXnx PIXel PIXel PIXel PIXel PIXel PIXel\n#define  _XXXXXX PIXnx PIXnx PIXel PIXel PIXel PIXel PIXel PIXel\n#define  XXXXXX_ PIXnx PIXel PIXel PIXel PIXel PIXel PIXel PIXnx\n#define _XXXXXX_ PIXnx PIXnx PIXel PIXel PIXel PIXel PIXel PIXel PIXnx\n#define  XXXXXXX PIXnx PIXel PIXel PIXel PIXel PIXel PIXel PIXel\n#define _XXXXXXX PIXnx PIXnx PIXel PIXel PIXel PIXel PIXel PIXel PIXel\n#define XXXXXXX_ PIXnx PIXel PIXel PIXel PIXel PIXel PIXel PIXel PIXnx\n#define XXXXXXXX PIXnx PIXel PIXel PIXel PIXel PIXel PIXel PIXel PIXel\n\n// variable-width uncompressed numbers\nvoid printNumber(int number) {\nif(number==1){\n_XX ln\nXXX ln\n_XX ln\n_XX ln\n_XX\n} else if(number==2){\n_XXX_ ln\n_ _XX ln\n_XXX_ ln\nXX_ _ ln\nXXXXX\n} else if(number==3){\nXXXX_ ln\n_ _XX ln\n_XXX_ ln\n_ _XX ln\nXXXX_\n} else if(number==4){\n_X XX ln\nXX XX ln\nXXXXX ln\n_ _XX ln\n_ _XX\n} else if(number==5){\nXXXX_ ln\nXX_ _ ln\nXXXX_ ln\n_ _XX ln\nXXXX_\n} else if(number==6){\n_XXX_ ln\nXX_ _ ln\nXXXX_ ln\nXX XX ln\n_XXX_\n} else if(number==7){\nXXXXX ln\n_ _XX ln\n_ XX_ ln\n_XX _ ln\nXX_ _\n} else if(number==8){\n_XXX_ ln\nXX XX ln\n_XXX_ ln\nXX XX ln\n_XXX_\n} else if(number==9){\n_XXX_ ln\nXX XX ln\n_XXXX ln\n_ _XX ln\n_XXX_\n} else {\n_XXX_ ln\nXX XX ln\nXX XX ln\nXX XX ln\n_XXX_\n}\n}\nvoid printUInt8(int num, ivec2 pos) {\n\tPIX(pos.x, pos.y)\n\tif(num< 10) {\n\t\tprintNumber(num);\n\t} else {\n\t\tif(num>= 100) {\n\t\t\tprintNumber(num< 200 ? 1 : 2);\n\t\t\tPIX(PIX_xy.x, pos.y)\n\t\t}\n\t\tprintNumber(num/ 10- num/ 100* 10);\n\t\tPIX(PIX_xy.x, pos.y)\n\t\tprintNumber(num- num/ 10* 10);\n\t}\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord0) {\n    PIX_size = int(min(10.0, ceil(iResolution.y/ 60.0- 2.0)+ 2.0));\n    PIX_XY = ivec2(0);\n    PIX_xy = ivec2(0);\n    PIX_on = vec4(0.2* fragCoord0.y/ iResolution.y+ 0.3, 0.8- 0.5* fragCoord0.y/ iResolution.y, 1, 1);\n    PIX_color = vec4(0);\n    iResolution0 = iResolution.xy;\n    glFragResolution = ceil(iResolution0/ vec2(1, 4));\n    glFragCoord = floor(mod(fragCoord0.xy, glFragResolution))+ 0.5;\n#define fragCoord glFragCoord\n#define iResolution glFragResolution\n\n\tfloat iTime = float(iFrame);\n\tint x = int(fragCoord.x);\n\tint y = int(fragCoord.y);\n\tint w = int(iResolution.x);\n\tint h = int(iResolution.y);\n\tint t = iFrame- iFrame/ h* h;\n\tint u = int(mod((iTime- fragCoord0.y)/ iResolution.y, 256.0));\n\tvec4 rb[8];\n\t// get our texture coordinate\n\tvec2 uv = fragCoord0.xy/ iResolution0.xy;\n\t// get the color from the last render\n\tfragColor = texture(iChannel0, uv);\n\n\tint r = rule+ u;\n\tr -= r/ 256* 256;\n\tint printedRule = rule+ u+ 255;\n\tprintedRule -= printedRule/ 256* 256;\n\tfor(int i = 7; i>= 0; i--) {\n\t\tint v = int(pow(2., float(i)));\n\t\tif(r>= v) {\n\t\t\tr -= v;\n\t\t\trb[i] = black;\n\t\t} else if(i- i/ 2* 2< 1) {\n\t\t\trb[i] = red;\n\t\t} else {\n\t\t\trb[i] = white;\n\t\t}\n\t}\n\n\tif(fragCoord0.y== 0.5) {\n\t\t// initialize the screen\n\t\tif(x- x/ (w/ 4)* (w/ 4)== (w/ 8)) fragColor = black;\n\t\telse fragColor = white;\n\t} else if(iFrame== 0|| x< 2) {\n\t\tfragColor = white;\n\t} else if(y== t) {\n\t\t// get those lines after the first\n\t\tvec2 puv[3];\n\t\tvec4 pixel[3];\n\t\tpuv[0] = (fragCoord0.xy+ vec2( -1., -1.))/ iResolution0.xy;\n\t\tpuv[1] = (fragCoord0.xy+ vec2(0., -1.))/ iResolution0.xy;\n\t\tpuv[2] = (fragCoord0.xy+ vec2( +1., -1.))/ iResolution0.xy;\n\t\tpixel[0] = texture(iChannel0, puv[0]);\n\t\tpixel[1] = texture(iChannel0, puv[1]);\n\t\tpixel[2] = texture(iChannel0, puv[2]);\n\t\tint index = (pixel[0]== black ? 1 : 0)+\n\t\t\t\t\t\t\t\t(pixel[1]== black ? 2 : 0)+\n\t\t\t\t\t\t\t\t(pixel[2]== black ? 4 : 0);\n\t\tif(index== 0) fragColor = rb[0];\n\t\telse if(index== 1) fragColor = rb[1];\n\t\telse if(index== 2) fragColor = rb[2];\n\t\telse if(index== 3) fragColor = rb[3];\n\t\telse if(index== 4) fragColor = rb[4];\n\t\telse if(index== 5) fragColor = rb[5];\n\t\telse if(index== 6) fragColor = rb[6];\n\t\telse if(index== 7) fragColor = rb[7];\n\n\t}\n\t// adjust number to hide the switch\n\tint ny = t+ h+ (y< h/ 2 ? 6* PIX_size : 0);\n\tny = ny- ny/ h* h+ (y< h/ 2 ? 0 : 6* PIX_size);\n\tprintUInt8(printedRule, ivec2(5, ny));\n\tfragColor = mix(fragColor, PIX_color, PIX_color.a);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}