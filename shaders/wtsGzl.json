{
    "Shader": {
        "info": {
            "date": "1557354650",
            "description": "This is an updated variation of what I did at Revision 2019 demoparty in Shader Showdown.\nYou can find the one I coded on stage here: https://youtu.be/uifMBMt9ASU?t=1704\nParameters in \"Common\" tab (antialias, gamma, shape, dof etc.)\nYou can use your mouse",
            "flags": 32,
            "hasliked": 0,
            "id": "wtsGzl",
            "likes": 32,
            "name": "Crystallic Dodecahedron",
            "published": 3,
            "tags": [
                "raymarch",
                "folding",
                "dodecahedron",
                "iridescence"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 1780
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nCrystallic Dodecahedron.\nThis is an updated variation of what I did at Revision 2019 demoparty in Shader Showdown.\nYou can find the one I coded on stage here: https://youtu.be/uifMBMt9ASU?t=1704\n\nParameters in \"Common\" tab (antialias, gamma, shape, dof etc.)\nYou can use your mouse to explore this shader.\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nYou can find information about shading here:\nhttps://www.shadertoy.com/view/tsSSzW\n\nThis shader was inspired by this shader: https://www.shadertoy.com/view/ltlGWM\n\nYou can find information about folding here (plane symmetry):\nhttp://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nhttps://www.shadertoy.com/view/4tX3DS\nhttps://www.shadertoy.com/view/XlX3zB\n\nDepth of Field from Tropical Trevor:\nhttp://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nldir: light direction\n*/\n\n\n// Depth of field pass 2\n// http://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    vec2 uv = fragCoord.xy / iResolution.xy;  \n  \n    float z = texture(iChannel0, uv).w;  \n  \n    vec2 blurdir = vec2(1.0, 0.577350269189626);  \n    vec2 blurvec = normalize(blurdir) / iResolution.xy;  \n    vec3 color0 = depthDirectionalBlur(iChannel0, z, CoC(z), uv, blurvec);  \n  \n    blurdir = vec2(-1.0, 0.577350269189626);  \n    blurvec = normalize(blurdir) / iResolution.xy;  \n    vec3 color1 = depthDirectionalBlur(iChannel0, z, CoC(z), uv, blurvec);  \n  \n    vec3 color = min(color0, color1);  \n    \n    // gamma\n\tcolor = pow(color, vec3(1. / gamma));\n\n\t// vignetting (from iq)\n\tcolor *= .5 + 0.5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .25);\n    \n    fragColor = vec4(color, 1.0);  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nCrystallic Dodecahedron.\nThis is an updated variation of what I did at Revision 2019 demoparty in Shader Showdown.\nYou can find the one I coded on stage here: https://youtu.be/uifMBMt9ASU?t=1704\n\nParameters in \"Common\" tab (antialias, gamma, shape, dof etc.)\nYou can use your mouse to explore this shader.\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nYou can find information about shading here:\nhttps://www.shadertoy.com/view/tsSSzW\n\nThis shader was inspired by this shader: https://www.shadertoy.com/view/ltlGWM\n\nYou can find information about folding here (plane symmetry):\nhttp://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nhttps://www.shadertoy.com/view/4tX3DS\nhttps://www.shadertoy.com/view/XlX3zB\n\nDepth of Field from Tropical Trevor:\nhttp://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nldir: light direction\n*/\n\n\n// Put this to 2 or 3 to enhance quality\n#define ANTIALIAS 1\n\nconst float gamma = 2.2;\n\n// Geometry\nconst int geometry_id = 0; // change the geometry here\nconst bool show_allshape = true;\nconst float speed_showshape = .1;\n\n// Depth of Field parameters\n// http://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\nconst int NUM_SAMPLES = 16;\n\nfloat uSharpDist = 2.; // distance from camera that is 100% sharp  \nfloat uSharpRange = 5.; // distance from the sharp center that remains sharp  \nfloat uBlurFalloff = 5.; // distance from the edge of the sharp range it takes to become 100% blurry  \nfloat uMaxBlur = 5.; // radius of the blur in pixels at 100% blur  \n\nfloat CoC(float z)  \n{  \n    return uMaxBlur * min(1., max(0., abs(z - uSharpDist) - uSharpRange) / uBlurFalloff);  \n}  \n\n\n//note: uniform pdf rand [0;1)  \nfloat hash1(vec2 p)  \n{  \n    p = fract(p * vec2(5.3987, 5.4421));  \n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));  \n    return fract(p.x * p.y * 95.4307);  \n}  \n\n\nvec3 depthDirectionalBlur(sampler2D tex, float z, float coc, vec2 uv, vec2 blurvec)  \n{  \n    // z: z at UV  \n    // coc: blur radius at UV  \n    // uv: initial coordinate  \n    // blurvec: smudge direction  \n    // numSamples: blur taps  \n    vec3 sumcol = vec3(0.);  \n  \n    for (int i = 0; i < NUM_SAMPLES; ++i)  \n    {  \n        float r =  (float(i) + hash1(uv + float(i) + 1.) - 0.5)  / (float(NUM_SAMPLES) - 1.) - 0.5;  \n        vec2 p = uv + r * coc * blurvec;  \n        vec4 smpl = texture(tex, p);  \n        if(smpl.w < z) // if sample is closer consider it's CoC  \n        {  \n            p = uv + r * min(coc, CoC(smpl.w)) * blurvec;  \n            p = uv + r * CoC(smpl.w) * blurvec;  \n            smpl = texture(tex, p);  \n        }  \n        sumcol += smpl.xyz;  \n    }  \n  \n    sumcol /= float(NUM_SAMPLES);  \n    sumcol = max(sumcol, 0.0);  \n  \n    return sumcol;  \n}  ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nCrystallic Dodecahedron.\nThis is an updated variation of what I did at Revision 2019 demoparty in Shader Showdown.\nYou can find the one I coded on stage here: https://youtu.be/uifMBMt9ASU?t=1704\n\nParameters in \"Common\" tab (antialias, gamma, shape, dof etc.)\nYou can use your mouse to explore this shader.\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nYou can find information about shading here:\nhttps://www.shadertoy.com/view/tsSSzW\n\nThis shader was inspired by this shader: https://www.shadertoy.com/view/ltlGWM\n\nYou can find information about folding here (plane symmetry):\nhttp://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nhttps://www.shadertoy.com/view/4tX3DS\nhttps://www.shadertoy.com/view/XlX3zB\n\nDepth of Field from Tropical Trevor:\nhttp://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nldir: light direction\n*/\n\n\n#define PI 3.14159\n#define time iTime\n\n// from Anton\n#define kick(t,b) (floor(t) + fract(t) + sin(fract(t)*PI)*b)\n\n#define pal(t,a,b,c,d) (a+b*cos(2.*PI*(c*t+d)))\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2.*min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\nfloat crystal1(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat cryst = sin(fp.y*.8)*2. + dot(fp, normalize(sign(fp))) - .3 - sin(fp.x*1.)*.1 - sin(fp.z*.3)*.2;\n\tcryst += min(fp.x*2., sin(fp.y*1.)*2.);\n\n\tfp = fold(fp) - vec3(.1, 0, .2);\n\tfp = fold(fp) - vec3(1.4, 0, -.1);\n\tcryst += fp.x*.7;\n\tcryst *= .2;\n\treturn cryst / scale;\n}\n\nfloat crystal2(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat cryst = dot(fp, normalize(sign(fp))) - .1 - sin(fp.y*.2)*2. - sin(fp.y*.7)*1.;\n\tcryst += min(fp.x*1., sin(fp.y*.3));\n\n\tfp = fold(fp) - vec3(.2, 0, -.2);\n\tfp = fold(fp) - vec3(.1, 3, -2.3);\n\tfp = fold(fp) - vec3(.8, 1, .1);\n\tfp = fold(fp) - vec3(0, .3, 0);\n\tcryst += sin(fp.y*.1)*3.;\n\tcryst *= .6;\n\n\treturn cryst / scale;\n}\n\nfloat crystal3(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\n\tfloat cryst = dot(fp, normalize(sign(fp))) - .23 - sin(fp.y*.8)*1.6 - sin(fp.y*.7)*1.;\n\tcryst += min(fp.x*1., sin(fp.y*.3));\n\n\tfp = fold(fp) - vec3(.2, 0, -.1);\n\tfp = fold(fp) - vec3(-.1, 3.89, -.3);\n\tfp = fold(fp) - vec3(0, .1, .1);\n\tcryst += sin(fp.y*.27)*4.;\n\tcryst *= .55;\n\n\treturn cryst / scale;\n}\n\nfloat de(vec3 p) {\n\n\tp.xy += vec2(cos(time), sin(time))*.16;\n\n\tfloat cryst;\n\n\tif (show_allshape) {\n\t\tfloat t = fract(iTime * speed_showshape);\n\t\tif (t < .33)\n\t\t\tcryst = crystal1(p, 4.);\n\t\tif (t >= .33 && t < .66)\n\t\t\tcryst = crystal2(p, 3.);\n\t\tif (t >= .66 && t < 1.)\n\t\t\tcryst = crystal3(p, 4.5);\n\t}\n\telse {\n\t\tif (geometry_id == 0)\n\t\t\tcryst = crystal1(p, 4.);\n\t\tif (geometry_id == 1)\n\t\t\tcryst = crystal2(p, 3.);\n\t\tif (geometry_id == 2)\n\t\t\tcryst = crystal3(p, 4.5);\n\t}\n\n\tvec3 fp = fold(p / 2.5);\n\tfp = fold(fp) - vec3(.1, .1, 1.8);\n\tfp = fold(fp) - vec3(0, .1, -.1);\n\tfloat d = 2.5*(length(fp.xz) - .02);\n\n\td = min(d, cryst);\n\n\treturn d;\n}\n\n\n// suggested from tdhooper.\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 normal(vec3 pos) {\n\tvec3 eps = vec3(.0001, 0, 0);\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += de(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvec3 shade(vec3 p, vec3 rd) {\n\tvec3 n = normal(p);\n\n\tvec3 ld = normalize(vec3(-1, .6, 1));\n\tvec3 h = normalize(ld - rd);\n\n\tfloat dotNL = max(0., dot(n, ld));\n\tfloat dotNV = max(0., dot(n, -rd));\n\tfloat spe = pow(max(0., dot(n, h)), 16.);\n\n\tvec3 col = .7 * pal(dotNV,\n\t\tvec3(.4),\n\t\tvec3(.5),\n\t\tvec3(.8),\n\t\tvec3(.1, .18, .27)\n\t);\n\n\tcol = mix(\n\t\t.5 * pal(dotNV, vec3(.1), vec3(.5), vec3(.5, .7, .6), vec3(.85, .1, .15)),\n\t\tcol,\n\t\t1. - spe);\n\n\tcol += .2 * dotNL;\n\tcol += .4 * spe;\n\n\treturn col;\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x*left + up * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec3 ray_ori;\n\tif (iMouse.z > 0.) {\n\t\tfloat xm = (-iMouse.x*10. / iResolution.x);\n\t\tfloat ym = (-iMouse.y*10. / iResolution.x);\n\t\tray_ori = vec3(-2. * cos(xm), cos(ym) * 5., 2. * sin(xm));\n\t}\n\telse {\n\t\tray_ori = vec3(-2.*cos(kick(time*2., .1)), .5 + .5*cos(kick(time, .1)), -2.*sin(kick(time, .1)));\n\t\t//ray_ori = vec3(-2.*cos(time*.3), 0, -2.*sin(time*.3));\n\n\t\tfloat aa = 3.14 / 2. + .02;\n\t\t//ray_ori = vec3(-2.*cos(aa), 0, -2.*sin(aa));\n\t}\n\n\tvec3 tcol = vec3(0);\n\tfloat zbuf = 0.;\n\tvec3 target = vec3(0);\n\n#if ANTIALIAS > 1\n\tfor (int j = 0; j < ANTIALIAS; j++) {\n\t\tfor (int i = 0; i < ANTIALIAS; i++) {\n\t\t\tvec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);\n\n\t\t\tvec2 uv = (fragCoord.xy + off) / iResolution.xy - .5;\n#else\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n#endif\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 rd = camera(ray_ori, uv, target);\n\tvec3 p;\n\n\tfloat tdist = 0.; // total distance from the ray origin to the point\n\tfloat tmax = 30.; // max distance\n\t\t\t\t\t  // Sphere-tracing\n\tfor (float i = 0.; i < 1.; i += .01) {// 100 iterations\n\t\tp = ray_ori + rd * tdist;\n\t\tfloat dist = de(p); // signed distance field\n\t\tif (dist < .001 || tdist > tmax)\n\t\t\tbreak;\n\t\ttdist += dist;\n\t}\n\n    vec3 bg = vec3(.9, .9, .87);\n\tvec3 col = bg;\n\tif (tdist <= tmax) {\n\t\tcol = shade(p, rd);\n\t\tcol = mix(col, bg, 1. - exp(-.001*tdist*tdist));\n\t\tcol = clamp(col, 0., 1.);\n\t}\n\n\n\tzbuf = tdist;\n\ttcol += col;\n#if ANTIALIAS > 1\n\t\t}\n\t}\n\ttcol /= float(ANTIALIAS * ANTIALIAS);\n#endif\n\n\n\tfragColor = vec4(tcol, zbuf);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nCrystallic Dodecahedron.\nThis is an updated variation of what I did at Revision 2019 demoparty in Shader Showdown.\nYou can find the one I coded on stage here: https://youtu.be/uifMBMt9ASU?t=1704\n\nParameters in \"Common\" tab (antialias, gamma, shape, dof etc.)\nYou can use your mouse to explore this shader.\n\nGeometries are generated with sphere-tracing algorithm:\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nhttps://iquilezles.org/articles/distfunctions\nhttp://mercury.sexy/hg_sdf/\n\nYou can find information about shading here:\nhttps://www.shadertoy.com/view/tsSSzW\n\nThis shader was inspired by this shader: https://www.shadertoy.com/view/ltlGWM\n\nYou can find information about folding here (plane symmetry):\nhttp://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nhttps://www.shadertoy.com/view/4tX3DS\nhttps://www.shadertoy.com/view/XlX3zB\n\nDepth of Field from Tropical Trevor:\nhttp://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nldir: light direction\n*/\n\n\n// Depth of field pass 1\n// http://trevorius.com/scrapbook/uncategorized/improving-a-renderer/\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    const vec2 blurdir = vec2( 0.0, 1.0 );  \n    vec2 blurvec = (blurdir) / iResolution.xy;  \n    vec2 uv = fragCoord / iResolution.xy;  \n  \n    float z = texture(iChannel0, uv).w;  \n    fragColor = vec4(depthDirectionalBlur(iChannel0, z, CoC(z), uv, blurvec), z);  \n} ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}