{
    "Shader": {
        "info": {
            "date": "1601241749",
            "description": "triangles, some subdivide into 4 smaller triangles.\ninspired by [url=https://www.shadertoy.com/view/WtBfDd]fizzer[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3scyR2",
            "likes": 8,
            "name": "recursive triangles",
            "published": 3,
            "tags": [
                "3d",
                "voxels",
                "triangle",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "// adjustable constants\n#define detail 4\n#define steps 600\n#define maxdistance 30.0\n\n#define pi acos(-1.0)\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define n1 vec3(0, 0, -1)\n#define n2 vec3( sin(pi/3.0), 0,cos(pi/3.0))\n#define n3 vec3(-sin(pi/3.0), 0,cos(pi/3.0))\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat hash31(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\nfloat h(vec3 p) {\n    vec2 pos = vec2(p.y-p.z,-p.x);\n    \n    float height = dot(cos(pos+iTime*0.2),vec2(1))-2.0;\n    \n    return height;\n}\n\nbool map(vec3 p, float size)\n{\n    return hash31(p+size*3.14) > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.2,0,iTime);\n    \n    vec3 rd = normalize(vec3(uv,1));\n    \n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    vec3 dists = vec3(\n        dot(ro,n1),\n        dot(ro,n2),\n        dot(ro,n3));\n    \n    ro.y = clamp(h(dists)+1.0,-0.5,0.5);\n    \n    vec3 rd2 = vec3(\n        dot(rd,n1),\n        dot(rd,n2),\n        dot(rd,n3));\n    \n    \n    float size = 1.0;\n    vec3 lro = mod(dists,size);\n    vec3 cell = dists-lro;\n    vec3 srd = sign(rd2);\n    \n    bool exitoct = false;\n    int recursions = 0;\n    \n    dists = fract(dists)-step(0.0,rd2);\n    vec3 ird = 1.0/rd2;\n    dists = -dists*ird;\n    ird *= srd;\n    vec3 mask;\n    \n    float d = 0.0;\n    vec3 n;\n    for (int i = 0; i < steps; i++)\n    {\n        if (d > maxdistance) break;\n        \n        //i go up a level\n        if (exitoct)\n        {\n            vec3 newcell = floor(cell/(size*2.0))*(size*2.0);\n            vec3 subcell = cell-newcell;\n            lro += subcell;\n            cell = newcell;\n            \n            subcell = subcell/size;\n            subcell = -(subcell-0.5)*srd+0.5;\n            dists += subcell*ird*size;\n            \n            recursions--;\n            size *= 2.0;\n            \n            exitoct = (recursions > 0) && (abs(dot(mod(cell/size+0.5,2.0)-1.0+mask*srd*0.5,mask))<0.1);\n        }\n        else\n        {\n            //checking for a subdivide\n            if(map(cell, size) && recursions < detail-1)\n            {\n                recursions++;\n                size *= 0.5;\n\n                //find which of the 8 voxels i will enter\n                vec3 mask2 = step(vec3(size),lro);\n                cell += mask2*size;\n                lro -= mask2*size;\n                \n                mask2 = -(mask2-0.5)*srd+0.5;\n                dists -= mask2*size*ird;\n                \n            }\n            //move forward\n            else\n            {\n                \n                if (dists.x < min(dists.y,dists.z))\n                {\n                    mask = vec3(1,0,0);\n                }\n                else if (dists.y < dists.z)\n                {\n                    mask = vec3(0,1,0);\n                }\n                else\n                {\n                    mask = vec3(0,0,1);\n                }\n                \n                float len = dot(dists,mask);\n                \n                float h = h(cell);\n                \n                if (ro.y+rd.y*d < h)\n                {\n                    break;\n                }\n\n                //moving forward in ray direction, and checking if i need to go up a level\n                d += len;\n                \n                if (rd.y < 0.0) {\n                    // note: precalculate 1.0/rd.y\n                    float r = -(ro.y-h)/rd.y;\n                    if (r < d) {\n                        n = vec3(0,1,0);\n                        d = r;\n                        break;\n                    }\n                }\n                //fdist += len;\n                lro += rd2*len-mask*srd*size;\n                vec3 newcell = cell+mask*srd*size;\n                \n                exitoct = (floor(newcell/size*0.5+0.25)!=floor(cell/size*0.5+0.25))&&(recursions>0);\n                cell = newcell;\n    \t\t\tdists += mask*ird*size-len;\n                \n                n = mask.x*n1+mask.y*n2+mask.z*n3;\n            }\n        }\n    }\n    \n    vec3 lightdir = normalize(vec3(cos(0.5),-1,sin(0.5)));\n    \n    vec3 col = vec3(0);\n    if (d < maxdistance)\n    {\n        vec3 p = ro+rd*d;\n        vec2 uv;\n        if (n == vec3(0,1,0)) {\n            uv = p.xz;\n        } else {\n            uv.x = dot(p.xz,n.zx);\n            uv.y = p.y-h(cell);\n        }\n        \n    \tvec2 c = vec2(cell.y-cell.z,-cell.x);\n        float r = hash31(vec3(c,size));\n        \n        col = texture(iChannel0,uv).xyz;\n        \n        col *= sin(r+vec3(0,1,2)*pi/3.0*2.0)*0.3+0.7;\n        \n        float light = max(dot(n,-lightdir),0.2);\n        \n        col *= light;\n    }\n    fragColor = vec4(sqrt(col),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}