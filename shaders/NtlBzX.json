{
    "Shader": {
        "info": {
            "date": "1651224077",
            "description": "first: source sdf, which was used to generate the pixelated texture\nleft: source texture, 8 bit\nmiddle left: linear filtering\ncenter: sdf on linear filtering\nmiddle right: cubic filtering\nright: sdf on cubic filtering",
            "flags": 0,
            "hasliked": 0,
            "id": "NtlBzX",
            "likes": 16,
            "name": "SDF reconstruction from textures",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "AntonioNoack",
            "viewed": 998
        },
        "renderpass": [
            {
                "code": "\n// 0.5 is perfect for a thin line,\n// larger values are too sharp,\n// smaller values (for outlines & such) like 0.01 reduce pixel quality for low-bit textures, e.g. R8\n#define SHARPNESS 0.5\n\nfloat smax(float a, float b, float k){\n   if(k <= 0.0) return max(a,b);\n   float h = max(k-abs(a-b), 0.0)/k;\n   float m = h*h*h*0.5;\n   float s = m*k*(1.0/3.0); \n   return max(a,b)+s;\n}\nfloat smin(float a, float b, float k){\n    return -smax(-a,-b,k);\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdf(vec2 p){\n    p.x -= (floor(p.x*6.0)+0.5)/6.0; // repeat shape on x-axis\n    p.y -= (clamp(floor(p.y*4.0),-1.0,0.0)+0.5)/4.0; // repeat shape on y-axis\n    float scale = 10.0;\n    // if sb wants to, he can create a nice letter here :)\n    p *= scale;\n    // sloped edge with small curvature?? doesn't show obvious problems...\n    // I get issues at 22.5Â° with a 1px thin curve (res=60, sdf=max(length(p)-0.5, 0.3-length(p))),\n    // but that's because of resolution; set it to 120 and everything is fine\n    // float sdf = length(p-vec2(4.0))-5.5;\n    // standard shape: a circle, which is cut off from the top\n    // float sdf = max(length(p)-0.5, p.y+sin(iTime)*.5-.2);\n    // new shape: the letter f\n    vec2 p0 = p;\n    p *= rot(-0.1);\n    p.x += 0.1;\n    if(p.y < 0.0) p = -p;\n    vec2 q1 = p-vec2(0.64,0.3);\n    vec2 q2 = p-vec2(0.64,0.3);\n    float sdf = max(length(q1)-0.8, 0.6-length(q2));\n    sdf = smin(sdf,smax(abs(p.y)-0.1,abs(p.x)-0.3,0.1),0.04);\n    sdf = smax(sdf,abs(dot(p,vec2(1.0,0.3)))-0.7,0.2);\n    // add original shape ^^\n    p0 *= 2.0;\n    p0 += vec2(-1.0,1.5);\n    sdf = min(sdf,0.5*max(length(p0)-0.5, p0.y+sin(iTime)*.5-.2));\n    sdf /= scale;\n    return sdf;\n}\n\nfloat nearestTexture(vec2 p, float res){\n    // make pixelated\n    p = round(p*res)/res;\n    float raw = clamp(sdf(p)*res*SHARPNESS+0.5, 0.0, 1.0);\n    return round(raw*255.0)/255.0;// discretize to 8 bit \n}\n\nfloat linearTexture(vec2 p, float res){\n    p *= res;\n    vec2 index = floor(p)/res;\n    vec2 delta = vec2(0.0,1.0/res);\n    vec2 frac = fract(p);\n    float c00 = nearestTexture(index + delta.xx, res);\n    float c01 = nearestTexture(index + delta.xy, res);\n    float c10 = nearestTexture(index + delta.yx, res);\n    float c11 = nearestTexture(index + delta.yy, res);\n    return mix(\n        mix(c00,c01,frac.y),\n        mix(c10,c11,frac.y),\n        frac.x\n    );\n}\n\n// bicubic interpolation from Inigo Quilez, https://www.shadertoy.com/view/XsSXDy\nconst vec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nconst vec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nconst vec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nconst vec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nconst vec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 ca=RE_A, cb=RE_B;\n// vec4 ca=CR_A, cb=CR_B;\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\nfloat spline(float x, float c0, float c1, float c2, float c3){\n    return c0 * dot(cb, powers(x + 1.0)) + \n           c1 * dot(ca, powers(x      )) +\n           c2 * dot(ca, powers(1.0 - x)) +\n           c3 * dot(cb, powers(2.0 - x));\n}\n\n#define SAM(a,b) nearestTexture((i+vec2(a,b))/res,res)\nfloat bicubicTexture(vec2 p, float res){\n    vec2 f = fract(p*res);\n    vec2 i = floor(p*res);\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n// sdf colors from Inigo Quilez (e.g. https://www.shadertoy.com/view/4llXD7)\nvec3 colorize(float sdf){\n    float d = sdf*6.0;\n    float sh = 10.0*length(vec2(dFdx(d),dFdy(d)));\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-50.0*abs(d));\n    col *= 0.8 + 0.2*cos(150.0*d);\n    return mix( col, vec3(1.0), 1.0-smoothstep(0.0,sh*0.3,abs(d)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x;\n    \n    // texture resolution over whole screen, based on y axis\n    float res = 120.0;\n    // how many slices are shown\n    int numSlices = 6;\n    // the second implementation here is animated\n    // int slice = int(float(fragCoord.x)/float(iResolution.x) + (sin(iTime*3.0/float(numSlices))*.5+.5)*float(numSlices-1));\n    int slice = (numSlices*int(fragCoord.x))/int(iResolution.x);\n    // sample our texture with nearest or with linear filtering\n    float nearestPixel = nearestTexture(uv,res);\n    float linearPixel  = linearTexture( uv,res);\n    float bicubicPixel = bicubicTexture(uv,res);\n    // display the difference between the techniques and the raw, unfiltered texture\n    vec3 col;\n    float sh, f;\n    vec3 white = vec3(1.0);\n    bool halfY = fragCoord.y*2.0 > iResolution.y;\n    switch(slice){\n        case 0:\n            // sdf itself\n            f= sdf(uv);\n            sh = length(vec2(dFdx(f),dFdy(f)));\n            col = halfY ? vec3(smoothstep(-sh,sh,f)) : colorize(f);\n            break;\n        case 1:\n            // raw texture\n            col = halfY ? vec3(nearestPixel) : white;\n            break;\n        case 2:\n            // linearly filtered texture = alpha approach\n            col = halfY ? vec3(linearPixel) : white;\n            break;\n        case 3:\n            // signed distance approach\n            f = (linearPixel-0.5)*SHARPNESS;\n            sh = length(vec2(dFdx(f),dFdy(f)));\n            col = halfY ? vec3(smoothstep(-sh, +sh, f)) : colorize((linearPixel-0.5)/res/SHARPNESS);\n            break;\n        case 4:\n            // bicubic filtered texture\n            col = halfY ? vec3(bicubicPixel) : white;\n            break;\n        case 5:\n            // bicubic filtered texture, then sdf\n            f = (bicubicPixel-0.5)*SHARPNESS;\n            sh = length(vec2(dFdx(f),dFdy(f)));\n            col = halfY ? vec3(smoothstep(-sh,+sh,f)) : colorize((bicubicPixel-0.5)/res/SHARPNESS);\n            break;\n    }\n    fragColor = vec4(vec3(col),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}