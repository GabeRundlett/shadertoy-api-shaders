{
    "Shader": {
        "info": {
            "date": "1536296307",
            "description": "[b]Warning code is bad.[/b]\nMade just as try of learning shaders. Has no other use.\n\nto learn basics that I use in this shader:\n[b]Watch this video - [/b] [url]https://youtu.be/LLZPnh_LK8c[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4lKcDD",
            "likes": 48,
            "name": "Sine mountains",
            "published": 3,
            "tags": [
                "2d",
                "mountain"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 1534
        },
        "renderpass": [
            {
                "code": "\n// License - CC0 or use as you wish\n\nfloat xRandom(float x) {\n    return mod(x * 7241.6465 + 2130.465521, 64.984131);\n}\n\nfloat mfunc(float x, float xx, float yy) {\n    x /= .20 * 3.14159;\n    x = mod((x)*2.0, 2.8) - 1.195;\n    x *= 19.0 * 3.14159;\n    return abs(8. + abs(-19.15 + abs(-15.0 + yy + abs(-12.25 - yy + abs(-18.0 + xx + abs(-15.0 - xx + abs(.95 * x + 4.0))))))) / 100.;\n}\n\nfloat hash2(in vec2 p) {\n    return fract(dot(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat noise2(float y, float t) {\n    vec2 fl = vec2(floor(y), floor(t));\n    vec2 fr = vec2(fract(y), fract(t));\n    float a = mix(hash2(fl + vec2(0.0, 0.0)), hash2(fl + vec2(1.0, 0.0)), fr.x);\n    float b = mix(hash2(fl + vec2(0.0, 1.0)), hash2(fl + vec2(1.0, 1.0)), fr.x);\n    return mix(a, b, fr.y);\n}\n\nfloat line(vec2 uv, float width, float center) {\n    float b = (1. - smoothstep(.0, width / 2., (uv.y - center)))*1.; \n    return b;\n}\n\nconst vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 dark = vec3(0x1a, 0x13, 0x21) / float(0xff);\nconst vec3 bluebg = vec3(0x00, 0x19, 0x5e) / float(0xff);\nconst vec3 colsun = vec3(0x07, 0xaf, 0x81) / float(0xff);\nconst vec3 white2 = vec3(0xec, 0xe8, 0x9e) / float(0xff);\n\nconst vec3 l1 = vec3(0x07, 0x27, 0x21) / float(0xff);\nconst vec3 l2 = vec3(0x00, 0x6c, 0xae) / float(0xff);\nconst vec3 l3 = vec3(0x00, 0x48, 0x7f) / float(0xff);\nconst vec3 treecol = vec3(0x12, 0x19, 0x27) / float(0xff);\nconst vec3 watercol = vec3(0xcf, 0xe5, 0xf2) / float(0xff);\n\nconst vec3 traincol = vec3(0x00, 0x6a, 0xb9) / float(0xff);\nconst vec3 trainlcol = vec3(0xef, 0xe8, 0x95) / float(0xff);\nconst vec3 toplvlcol = vec3(0x00, 0x6a, 0x71) / float(0xff);\n\nfloat circle(in vec2 uv, float r1, float r2, bool disk) {\n    float w = 2.0 * fwidth(uv.x);\n    float t = r1 - r2;\n    float r = r1;\n\n    if (!disk)\n        return smoothstep(-w / 2.0, w / 2.0, abs(length(uv) - r) - t / 2.0);\n    else\n        return smoothstep(-w / 3.0, w / 3.0, (length(uv) - r));\n}\n\nfloat circle2(in vec2 uv, float r1, float r2, bool disk) {\n    float w = 2.0 * fwidth(uv.x);\n    float t = r1 - r2;\n    float r = r1;\n    if (!disk)\n        return smoothstep(-w / 2.0, w / 2.0, abs(length(uv) - r) - t / 2.0);\n    else\n        return smoothstep(-w / 3.0, 1.05 + w / 3.0, (length(uv) - r));\n}\n\nfloat w1(float x) {\n    x += -0.45;\n    float iTime = mod(iTime+150.1, 310.);\n    if (iTime > 150.)\n        return 01.5 + 010.15 * mfunc(x * .7, -80. * (cos(0.5 + mod(0. / 150. + 1., 3.))), 0.);\n    else\n        if (iTime > 5.)\n        return 01.5 + 010.15 * mfunc(x * .7, -80. * (cos(0.5 + mod((iTime - 5.) / 140. + 1., 3.))), 0.);\n    else\n        return 01.5 + 010.15 * mfunc(x * .7, -80. * (cos(0.5 + mod((0.) / 140. + 1., 3.))), 0.);\n}\n\nfloat layer(vec2 uv) {\n    float iTime = mod(iTime+150.1, 310.);\n    vec2 ouv = uv;\n    uv *= 0.5;\n    if (iTime > 150.)\n        uv.x += ((iTime - 150.) / 200.);\n    uv.x += 50.;\n    uv.y += -0.21;\n    float Range = 100.;\n    float Line_Smooth = 1.;\n    float Amplitude1 = w1(uv.x);\n    vec2 p = uv;\n    float Light_Track = line(vec2(p.x, p.y * 1.5 + (Amplitude1 - .5)*.12 * Line_Smooth), .005, .0);\n    if (iTime < 150.)\n        return Light_Track * smoothstep(0., 5., iTime);\n    else if (iTime < 300.)\n        return Light_Track * smoothstep(150., 155., iTime);\n    else\n        return Light_Track * smoothstep(305., 300., iTime);\n}\n\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\nfloat shape(vec2 uv, int N, float radius_in, float radius_out, float zoom) {\n    float color = 0.0;\n    float d = 0.0;\n    float a = atan(uv.x, uv.y) + PI;\n    float rx = TWO_PI / float(N);\n    d = cos(floor(.5 + a / rx) * rx - a) * length(uv);\n    color = smoothstep(.44, .44 + (2. + 1.2 * zoom) / iResolution.y, abs(d - radius_in) + radius_out);\n    return (1. - color);\n}\n\nfloat msine(vec2 uv) {\n    float heightA = 0.025;\n    float heightB = 0.025;\n    float heightC = 0.013; //+0.071*sin(iTime/105.); //xD\n    uv.y = sin((uv.x + (1.))*5.0) * heightA;\n    uv.y = uv.y + sin((uv.x + (0. / 5.))*3.0) * heightB;\n    uv.y = uv.y + sin((uv.x + (1.))*2.0) * heightC;\n    return uv.y;\n}\n\nfloat trees(vec2 uv) {\n    float zoom = 10.;\n    uv.x += iTime / 35.;\n    uv *= zoom;\n    vec2 tuvy = vec2(0., 08. * msine(vec2(floor(uv.x / (0.38)), uv.y) / zoom));\n    float rval = xRandom(floor(uv.x / 0.38));\n    float d = 0.;\n    if (rval > (85.) * fract(cos(rval)) + 85. * (sin(rval))) {\n        rval = max(1., 2.5 * abs(sin(rval)));\n        uv.x = mod(uv.x, 0.38) - 0.19;\n        uv += tuvy;\n        uv *= rval;\n        float xval = 1.2 * sin(xRandom(tuvy.y))*0.19 * (1.25 - rval);\n        uv.y += 0.75 / rval;\n        uv.x += xval;\n        vec2 ouv = uv;\n        uv.y *= .85;\n        d = shape(uv, int(3.), -0.380, 0., zoom + rval);\n        uv.y += .12;\n        uv.y *= .75;\n        d = max(d, shape(uv, int(3.), -0.370, 0., zoom + rval));\n        uv.y += .1;\n        uv.y *= 1.2;\n        d = max(d, shape(uv, int(3.), -0.3650, 0., zoom + rval));\n        d = max(d, smoothstep(0.02 + (2. + 1.2 * (zoom + rval)) / iResolution.y, 0.02, abs(uv.x)) * step(ouv.y, 0.)) *\n                step(-0.75 + 0.12 * (2.5 - rval), ouv.y);\n    }\n    return d;\n}\n\nfloat layer_bghills(vec2 uv) {\n    uv.x += iTime / 35.;\n    float d = smoothstep(0.5 + 20. / iResolution.y, 0.5, msine(uv / 0.38 - 0.038)*10. + uv.y * 10. + 01.6);\n    return d;\n}\n\nfloat treex(vec2 uv) {\n    uv.y += 0.08;\n    float d = trees(uv);\n    return d;\n}\n\nfloat water(vec2 uv) {\n    float d;\n    d = step(uv.y, -0.25);\n    return d;\n}\n\n\n#define HASHSCALE1 443.8975\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float t = f * f * (3.0 - 2.0 * f);\n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\n\nfloat fbm(float x, float persistence, int octaves) {\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    for (int i = 0; i < octaves; ++i) {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return (total / maxValue);\n}\n\nfloat msine2(vec2 uv) {\n    return (fbm(uv.x / 10., 0.25, 4)*20. + 0.5);\n}\n\nfloat trees2(vec2 uv) {\n    float zoom = 10.;\n    uv.x += iTime / 45.;\n    uv *= zoom;\n    vec2 tuvy = vec2(0., 0.2 * msine2(vec2(floor(uv.x / 0.38), uv.y)));\n    float rval = xRandom(floor(uv.x / 0.38));\n    float d = 0.;\n    if (rval > (55.) * fract(cos(rval)) + 85. * (sin(rval))) {\n        rval = max(1.5, 2.5 * abs(sin(rval)));\n        uv.x = mod(uv.x, 0.38) - 0.19;\n        uv += tuvy;\n        uv *= rval;\n        float xval = -1.2 * sin(xRandom(tuvy.y))*0.19 * (1.25 - rval);\n        uv.y += -0.25 / rval;\n        uv.x += xval;\n        vec2 ouv = uv;\n        uv.y *= .85;\n        d = shape(uv, int(3.), -0.380, 0., zoom + rval);\n        uv.y += .12;\n        uv.y *= .75;\n        d = max(d, shape(uv, int(3.), -0.370, 0., zoom + rval));\n        uv.y += .1;\n        uv.y *= 1.2;\n        d = max(d, shape(uv, int(3.), -0.3650, 0., zoom + rval));\n        d = max(d, smoothstep(0.02 + (2. + 1.2 * (zoom + rval)) / iResolution.y, 0.02, abs(uv.x)) * step(ouv.y, 0.)) *\n                step(-0.75 + 0.12 * (2.5 - rval), ouv.y);\n    }\n    return d;\n}\n\nfloat layer_bghills2(vec2 uv) {\n    uv.x += 1.2;\n    uv.x += iTime / 45.;\n    float d = smoothstep(5.5 + 20. / iResolution.y, 5.5, msine2(uv / 0.38 - 0.038)*40. + uv.y * 40. + 010.6);\n    d = smoothstep(-0.1555 + 8. / iResolution.y, -0.1555, .2 * msine2((uv * 10.) / 0.38 - 0.038) + uv.y * 11. + 0.86);\n    return d;\n}\n\nfloat treex2(vec2 uv) {\n    uv.x += 1.2;\n    uv.y += 0.08;\n    float d = trees2(uv);\n    return d;\n}\n\nvec3 undw(in vec2 uv, vec3 tc) {\n    vec2 res = iResolution.xy / iResolution.y;\n    uv.x += iTime / 10.;\n    uv += res / 2.;\n    uv.y = 1. - uv.y;\n    uv.y += -0.759;\n    uv.x *= .5;\n    uv *= 5.3;\n    float divs = 5.;\n    float slope = 4.2;\n    float y_off = sin(2. * uv.y + 0. * iTime / 1.73);\n    float vy = (uv.y + (floor(5. - (uv.y + 02.75) / .52) / 5.) * sin(uv.x * 6.28318 + y_off)*.1 - .05);\n    float c = (smoothstep(0., 1., mod(vy*divs, 1.0) * slope) + floor(vy * divs)) / divs;\n    vec2 uv_d = vec2(uv.x * 0.3 + y_off * .01, c);\n    vec2 uv_d2 = vec2(uv.x + y_off * .05, .3 * c + .7 * vy);\n    vec3 fragColor;\n    vec3 gamma = vec3(0.65 * 2.2, .8 * 2.2, 2.2);\n    gamma = tc;\n    fragColor.r = pow(c, 1. / gamma.r);\n    fragColor.g = pow(c, 1. / gamma.g);\n    fragColor.b = pow(c, 1. / gamma.b);\n    fragColor.rgb *= tc * (-noise2(uv_d.x, uv_d.y)*.3 + .7);\n    return max(vec3(0.), fragColor);\n}\n\nfloat trainxl(vec2 uv) {\n    uv.y += 0.3;\n    uv.y += -0.07;\n    vec2 ouv = uv;\n    uv.x = mod(uv.x, 0.01) - 0.005;\n    float d = smoothstep(0.0045 + 2. / iResolution.y, 0.0025, abs(uv.x));\n    d *= step(abs(uv.y), 0.0025);\n    uv.x = ouv.x;\n    uv.x = mod(uv.x, 0.15) - 0.005;\n    d *= step(abs(uv.x), 0.0025 * 50.);\n    d *= step(ouv.x, -0.05);\n    d *= step(-0.50, ouv.x);\n    d += smoothstep(0.0110 + 2. / iResolution.y, .01, abs(ouv.x + 0.021)) * step(abs(uv.y), 0.0025);\n    d += smoothstep(0.025 + 2. / iResolution.y, .024, abs(ouv.x - 0.035)) * step(abs(uv.y), 0.0025);\n    return d;\n}\n\nfloat trainx(vec2 uv) {\n    uv.y += 0.325;\n    float d = 1. - circle(uv, 0.11, 0., true);\n    float stval = step(0.07, uv.y);\n    d *= stval;\n    d = max(d, step(-0.5, uv.x) * step(uv.x, 0.0) * step(uv.y, 0.109)) * stval;\n    d = max(d, 1. - circle(uv + vec2(0.5, 0.), 0.11, 0., true)) * stval;\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res / 2.0;\n    float b = 1. - circle(uv - 0.21, 0.1242, 0.22, true);\n    vec3 col = vec3(bluebg);\n    float b1 = 1. - circle2(uv - 0.21, 0.1242, 0.22, true);\n    float b2 = smoothstep(-01., -0.05, uv.y);\n    float lx1 = layer(uv + vec2(0., -0.152));\n    col = (col - lx1 * l1 * b1);\n    col += (b1) * colsun;\n    col = mix(col, white2, min(b, 1. - lx1));\n    col = mix(col, l2*b1, layer_bghills2(uv + vec2(0., -0.05)));\n    col = mix(col, 3. * treecol*b1, treex2(uv + vec2(0., -0.05)));\n    col = mix(col, l3*b1, layer_bghills(uv + vec2(0., 0.0)));\n    col = mix(col, treecol*b1, treex(uv + vec2(0., 0.0)));\n    vec3 toplvlcol2 = vec3(0.);\n    if ((uv.y<-0.25))\n        toplvlcol2 = undw(uv, watercol);\n    col = mix(col, toplvlcol2 + 0.42 * b2*l2, water(uv));\n    uv.x += 0.3 * (sin(0.5 * sin(iTime / 8.) + cos(iTime / 10.)));\n    float trx = trainx(uv);\n    col = mix(col, traincol*b1, (trx * (1. - water(uv))));\n    col = mix(col, trainlcol, trainxl(uv) * trx);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}