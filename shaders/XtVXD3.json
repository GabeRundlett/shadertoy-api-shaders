{
    "Shader": {
        "info": {
            "date": "1486212942",
            "description": "Orbiting a cube\n\nI am pleased that I matched the \"nub\" in the top right,\nbut I need to work on getting the exact curve on the bottom left... splines?\n\nI also think the trajectory should be more dynamic than a static circular orbit.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtVXD3",
            "likes": 0,
            "name": "Skydio Logo",
            "published": 3,
            "tags": [
                "flat",
                "cube",
                "orbit",
                "drone",
                "negativespace"
            ],
            "usePreview": 0,
            "username": "mdonahoe",
            "viewed": 181
        },
        "renderpass": [
            {
                "code": "/*\n * Skydio Logo, v2\n * 2017.02.04\n *\n * original design by Character\n * programmed by Matt Donahoe\n *\n * box tracing adapted from https://www.shadertoy.com/view/4sj3WK\n * sphere tracing adapted from https://www.shadertoy.com/view/ltBSzK\n * camera adapted from https://www.shadertoy.com/view/ld2XzV\n *\n */\n\n#define PI 3.14159265359\n\n// Simple colors\nconst vec3 blue = vec3(0,0,1);\nconst vec3 white = vec3(1,1,1);\nconst vec3 black = vec3(0,0,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 green = vec3(0,.8,0);\n\n\n#define HIT_BACKGROUND 0\n#define HIT_BOX 1\n#define HIT_OUTER_ORBIT 2\n#define HIT_INNER_ORBIT 3\n#define HIT_DISK 4\n\n// MAIN COLORS: Change me!!\nconst vec3 bgColor = white;\nconst vec3 boxColor = blue;\nconst vec3 innerOrbitColor = boxColor;\nconst vec3 outerOrbitColor = bgColor;\nconst vec3 diskColor = white;\n\n\n\n// the bad example from IQ's article, Haha!\n// https://iquilezles.org/articles/noacos\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c );\n}\n\n\n// Ray-Plane Intersection Test\nfloat iPlane(vec3 ro, vec3 rd, vec4 plane) {\n\tvec3 n = plane.xyz;\n\tfloat dist = -plane.w;\n\tfloat denom = dot(n, rd);\n\treturn - (dot(n, ro) + dist) / denom;\n}\n\n\nvoid swapIfGreater(inout float x, inout float y) {\n\tif(x>y) {\n\t\tfloat temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t}\t\t\n}\n\n\n// Ray-Sphere Intersection Test\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sph, in float rad) {\n    // Thanks for IQ's ray sphere instruction\n\t// https://iquilezles.org/blog/?p=2411\n\t// This is relating directly to parametric equation\n    // where we define a function xyz = ro + t*rd\n    // solving the quadradic equation below\n \tvec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float t = b*b - c;\n    if( t > 0.0) \n        t = -b - sqrt(t);\n    return t;\n}\n\n// Ray-Box Intersection Test\nfloat iBox(vec3 ro, vec3 rd, vec3 center, vec3 sides, out vec3 normal) {\n\tvec3 axis = normalize(vec3(0.0, 1.0, 0.0));\n\tmat3 rot = rotationAxisAngle(axis, PI/2.);\n\tvec3 xn = rot*vec3(1.0, 0.0, 0.0);\n\tvec3 yn = rot*vec3(0.0, 1.0, 0.0);\n\tvec3 zn = rot*vec3(0.0, 0.0, 1.0);\n\taxis = normalize(vec3(0.0, 1.0, 0.0));\n\txn = rot*xn;\n\tyn = rot*yn;\n\tzn = rot*zn;\t\n\tfloat t1, t2;\n\tfloat tNear = -10000.0;\n\tfloat tFar = 10000.0;\n\t\t\n\t// x -> yz-plane\n\tt1 = iPlane(ro, rd, vec4(xn, -0.5*sides.x));\n\tt2 = iPlane(ro, rd, vec4(xn, 0.5*sides.x));\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = xn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\t// y -> xz-plane\n\tt1 = iPlane(ro, rd, vec4(yn, -0.5*sides.y));\n\tt2 = iPlane(ro, rd, vec4(yn, 0.5*sides.y));\t\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = yn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\t// z -> xy-plane\n\tt1 = iPlane(ro, rd, vec4(zn, -0.5*sides.z));\n\tt2 = iPlane(ro, rd, vec4(zn, 0.5*sides.z));\t\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = zn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\treturn tNear;\n}\n\nfloat squareWave(in float x) {\n\tfloat y = 0.0;\n    const int N = 7;\n    for (int i = 1; i < N; i+=2) {\n    \ty += 4.0 / (float(i) * PI) * sin(2.0 * float(i) * PI * x);\n    }\n    return y;\n}\n\n// Check given ray against box and orbit.\nint intersect( in vec3 ro, in vec3 rd, out float depth, out vec3 normal ){\n\tdepth = 1000.0;\n\tint hit_id = HIT_BACKGROUND;\n    float orbit = 3.1;\n    const int N = 200;\n    float dt = 0.005;\n    float localTime = min(5.11, iTime);\n    \n    // Check for intersection against the orbit\n    // The orbit is made up of a series of spheres with decreases radii\n    // The orbit has an INNER and OUTER sides, colored differently.\n    for (int i = 0; i < 140; i++) {\n        float sTime = 1.1 * localTime - dt * float(i);\n        float a = 4.0 * sTime - PI / 2.0;\n        vec3 sph = orbit * vec3(sin(a), 0.0, cos(a));\n        sph.x += 0.1;\n        sph.y = 0.3 + 1.2 * sin(a - 1.2 * PI / 4.0) + 0.3;\n        float radius = 0.5 * float(N - i) / float(N);\n    \tfloat tsph2 = iSphere(ro, rd, sph, radius); \n    \tif(tsph2 > 0.0 && tsph2 < depth){\n       \t\tdepth = tsph2;\n       \t\thit_id = HIT_OUTER_ORBIT;\n   \t\t}\n        vec3 sph2 = sph - normalize(sph) * radius * 1.2;\n        float r2 = radius * 0.9;\n       \tfloat tsph3 = iSphere(ro, rd, sph2, r2); \n    \tif(tsph3 > 0.0 && tsph3 < depth){\n       \t\tdepth = tsph3;\n       \t\thit_id = HIT_INNER_ORBIT;\n   \t\t}\n    }\n    for (int i = 0; i < 10; i++) {\n        vec3 boxCenter = vec3(2.0 , 0.0, 0.0);\n        vec3 boxSides = vec3(2.0, 2.0, 2.0)*2.0;\n        float tCube = iBox(ro, rd, boxCenter, boxSides, normal);\n        if(tCube > 0.0 && tCube < depth ) {\n            hit_id = HIT_BOX;\n            depth = tCube;\n        }\n    }\n    float tDisk = iPlane(ro, rd, vec4(0,1,0,-2));\n    if (tDisk > 0.0 && tDisk < depth) {\n        vec3 pt = (tDisk * rd) + ro;\n        vec3 delta = (pt - vec3(0,0,0));\n        float r = length(delta);\n        float angle = atan(delta.z, delta.x);\n        float angle_b = angle +  2.0 * 3.14;\n        float current = mod(3.0 * iTime, 2.0 * 3.14);\n        if (r < 5.0 && r > 4.5 && ((abs(angle - current)  < 0.5) || (abs(angle_b - current) < 0.5))) {\n      \t  depth = tDisk;\n      \t  hit_id = HIT_DISK;\n        }\n    }\n\treturn hit_id;\n}\n\n// Transform from spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p) {\n    vec2 s  = sin(p);\n    vec2 c  = cos(p);\n    return normalize(vec3(c.x * s.y, c.y, s.x * s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Look at point (cd)\n    // Fixed\n    vec3 cd = vec3(0.0, 0.0, 0.0);\n    \n    // Camera origin (co)\n    // Rotate around box, decelerating to a stop, while moving backward.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 camSphe;\n    float x = iTime - 5.0;\n    float y = x * x * x;\n    float decelRamp = max(0.0, -0.05 * y);\n    if (iMouse.z < 1.0) {\n        // If the mouse button is not down, spin the camera automatically\n        camSphe = vec2(decelRamp + PI / 2.0, PI / 2.0);\n    } else {\n        // Otherwise use the mouse to control camera rotation.\n        vec2 centeredMouse = (iMouse.xy / iResolution.xy - 0.5 * vec2(1, 1));\n        camSphe = vec2(0.0, PI / 2.0) + centeredMouse * vec2(5.0, 0.7);\n    }\n    float dist = min(10.0, 4.0 + 3.0 * iTime);\n    vec3 co = sphe2cart(camSphe) * dist;\n    \n\n    // Ray direction (rd)\n    vec3 cf = normalize(cd - co);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    vec3 cr = normalize(cross(cf, cu));\n    cu = cross(cr, cf);\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.0;\n    vec3 rd = normalize(cf + cr * uv.x + cu * uv.y);\n\n\t// Intersection test\n    // Send rays to detect intersections with objects\n    // intersect will return the object type \"hit_id\"\n\t// and set the ray depth and normal at the intersection point\n\tfloat depth;\n\tvec3 normal;\n\tint hit_id = intersect(co, rd, depth, normal);\n\n    // Color based on the object hit, ignore normals.\n\tvec3 intersectColor;\n\tif(hit_id == HIT_BOX) {\n        intersectColor = boxColor;\n    } else if (hit_id == HIT_OUTER_ORBIT) {\n        intersectColor = outerOrbitColor;\n    } else if (hit_id == HIT_INNER_ORBIT) {\n    \tintersectColor = innerOrbitColor;\n    } else if (hit_id == HIT_DISK) {\n    \tintersectColor = diskColor;\n    } else {\n    \tintersectColor = bgColor;\n    }\n\tfragColor = vec4(intersectColor, 1.0);\n}\n\n\nbool intersectPlane(in vec3 ro, in vec3 rd, in vec3 planePoint, in vec3 planeNormal,\n                    out vec3 intersectionPoint) {\n    return true;\n}\n    ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}