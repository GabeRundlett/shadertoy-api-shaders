{
    "Shader": {
        "info": {
            "date": "1516782786",
            "description": "包含例子\n不透明度，正片叠底，颜色加深，颜色减淡。\n线性加深，线性减淡，变亮，变暗。\n滤色， 叠加， 柔光， 强光。\n亮光， 点光， 线性光， 实色混合。\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XlSBzt",
            "likes": 2,
            "name": "Layer blending algorithm图层混合算法",
            "published": 3,
            "tags": [
                "layerblendingalgorithm"
            ],
            "usePreview": 0,
            "username": "liuhaidong",
            "viewed": 732
        },
        "renderpass": [
            {
                "code": "\n//不透明模式 \n//d表示改层的透明度 (0-1.0)\nvec3 matteOpacityMode (vec3 color, vec3 blendColor, float d)\n{\n    vec3 rgb = d*color.rgb + (1.0-d)*blendColor.rgb;\n    return rgb;\n}\n\n//正片叠底模式\n//任何颜色和黑色正片叠底得到的任然是黑色，任何颜色和白色执行正片叠底则保持原来的颜色不变.\n//而与其他颜色执行此模式会产生暗室中以此种颜色照明的效果。 \nvec3 multiplyMode (vec3 color1 ,vec3 color2)\n{\n    vec3 rgb = color1.rgb *color2.rgb;\n    return rgb;\n} \n\n//颜色加深模式\n//如果上层越暗，则下层获取的光越少，如果上层为全黑色，则下层越黑\n//如果上层为全白色，则根本不会影响下层。结果最亮的地方不会高于下层的像素值 \nvec3 colorBurnMode (vec3 colorA, vec3 colorB)\n{\n\n    vec3 rgb = 1.0 - (1.0 - colorB)/colorA;\n    return rgb;\n}\n\n//颜色减淡模式\n//上层的亮度决定了下层的暴露程度。如果上层越亮，下层获取的光越多，也就是越亮。\n//如果上层是纯黑色，也就是没有亮度，则根本不会影响下层。如果上层是纯白色，则下层除了像素为255的地方暴露外，其他地方全部为白色（也就是255，不暴露）。\n//结果最黑的地方不会低于下层的像素值。\nvec3 colorDodgeMode (vec3 colorA, vec3 colorB)\n{\n    vec3 rgb = colorB/(1.0-colorA);\n    return rgb;\n}\n\n//线性加深模式\n//如果上下层的像素值之和小于255，输出结果将会是纯黑色。如果将上层反相。\nvec3 linearBurnMode  (vec3 colorA, vec3 colorB)\n{\n    vec3 rgb = colorB + colorA -1.0;\n    return rgb;\n}\n\n//线性减淡\n//将上下层的色彩值相加。结果将更亮 \nvec3 linearDodgeMode  (vec3 colorA, vec3 colorB)\n{\n    vec3 rgb = colorB + colorA;\n    return rgb;\n}\n\n//变亮\n//取色彩值较大的（也就是较亮的）作为输出结果。 \nvec3 lightenMode (vec3 colorA, vec3 colorB)\n{\n    float r = colorB.r<=colorA.r ? colorA.r : colorB.r;\n    float g = colorB.g<=colorA.g ? colorA.g : colorB.g;\n    float b = colorB.b<=colorA.b ? colorA.b : colorB.b;\n    return vec3(r,g,b);    \n}\n\n//变暗\n//取色彩值较小的（也就是较亮的）作为输出结果。 \nvec3 deepeningMode (vec3 colorA, vec3 colorB)\n{\n    float r = colorB.r<=colorA.r ? colorB.r : colorA.r;\n    float g = colorB.g<=colorA.g ? colorB.g : colorA.g;\n    float b = colorB.b<=colorA.b ? colorB.b : colorA.b;\n    return vec3(r,g,b);    \n}\n\n//滤色模式\n//它是将两个颜色的互补色的像素值相乘，然后除以255得到的最终色的像素值。通常执行滤色模式后的颜色都较浅。\n//任何颜色和黑色执行滤色，原色不受影响;任何颜色和白色执行滤色得到的是白色；而与其他颜色执行滤色会产生漂白的效果。\nvec3 screenMode (vec3 colorA, vec3 colorB)\n{\n    vec3 rgb = 1.0 - (1.0- colorA)*(1.0 - colorB);\n    return rgb;\n}\n\n//叠加模式\nfloat overlayFloat (float rgbA,float rgbB)\n{\n    return rgbB<=0.5 ? (2.0*rgbB*rgbA) : 1.0 - 2.0*(1.0-rgbA)*(1.0-rgbB);\n}\n\nvec3 overlayMode (vec3 colorA, vec3 colorB)\n{\n    \n    float r = overlayFloat(colorA.r,colorB.r);\n    float g = overlayFloat(colorA.g,colorB.g);\n    float b = overlayFloat(colorA.b,colorB.b);\n    return vec3(r,g,b);\n}\n\n//柔光模式\n//根据绘图色的明暗程度来决定最终色是变亮还是变暗，当绘图色比50%的灰要亮时，则 底色图像变亮。\n//当绘图色比50%的灰要暗时，则底色图像就变暗。如果绘图色有纯黑色或纯白色，最终色不是黑色或白色，而是稍微变暗或变亮。\n//如果底色是纯白色或纯黑色，不产生任何效果。此效果与发散的聚光灯照在图像上相似。 \n\nfloat softLightFloat (float rgbA,float rgbB)\n{    \n    if(rgbA<=0.5)\n    {\n     \treturn (2.0*rgbA - 1.0) *(rgbB-rgbB*rgbA) +rgbB;   \n    }\n    else\n    {\n     \treturn (2.0*rgbA - 1.0) *(sqrt(rgbB)-rgbB) +rgbB;   \n    }    \n}\n\nvec3 softLightMode (vec3 colorA, vec3 colorB)\n{\n    float r = softLightFloat(colorA.r,colorB.r);\n    float g = softLightFloat(colorA.g,colorB.g);\n    float b = softLightFloat(colorA.b,colorB.b);\n    return vec3(r,g,b);\n}\n\n//强光模式\n//当绘图色比50%的灰要亮 时，则底色变亮，就执行“滤色”模式一样，这对增加图像的高光非常有帮助；\n//当绘图色比50%的灰要暗时，则底色变暗，就执行“正片叠底”模式一样，可增加 图像的暗部。\n//当绘图色是纯白色或黑色时得到的是纯白色和黑色。此效果与耀眼的聚光灯照在图像上相似。 \nfloat hardLightFloat (float rgbA,float rgbB)\n{\n\n    if(rgbA<=0.5)\n    {\n     \treturn 2.0*rgbA*rgbB;   \n    }\n    else\n    {\n     \treturn 1.0 - 2.0*(1.0-rgbA)*(1.0-rgbB);   \n    }    \n}\n\nvec3 hardLightMode (vec3 colorA, vec3 colorB)\n{\n    float r = hardLightFloat(colorA.r,colorB.r);\n    float g = hardLightFloat(colorA.g,colorB.g);\n    float b = hardLightFloat(colorA.b,colorB.b);\n    return vec3(r,g,b);\n}\n\n//亮光模式\n//根据绘图色通过增加或降低“对比度”，加深或减淡颜色。\n//如果绘图色比50%的灰亮，图像通过降低对比度被照亮，\n//如果绘图色比50%的灰暗，图像通过增加对比度变暗。 \nfloat vividLightFloat (float rgbA,float rgbB)\n{\n\n    if(rgbA<=0.5)\n    {\n     \treturn 1.0 - (1.0-rgbB)/(2.0*rgbA);   \n    }\n    else\n    {\n     \treturn rgbB/(2.0*(1.0-rgbA));   \n    }    \n}\nvec3 vividLightMode (vec3 colorA, vec3 colorB)\n{\n    float r = vividLightFloat(colorA.r,colorB.r);\n    float g = vividLightFloat(colorA.g,colorB.g);\n    float b = vividLightFloat(colorA.b,colorB.b);\n    return vec3(r,g,b);\n}\n\n//点光模式\nfloat pinLightFloat (float rgbA,float rgbB)\n{\n    if(rgbA<=0.5)\n    {\n     \treturn min(2.0*rgbA,rgbB);   \n    }\n    else\n    {\n        return max(2.0*(rgbA-0.5),rgbB);   \n    }    \n}\nvec3 pinLightMode (vec3 colorA, vec3 colorB)\n{\n    float r = pinLightFloat(colorA.r,colorB.r);\n    float g = pinLightFloat(colorA.g,colorB.g);\n    float b = pinLightFloat(colorA.b,colorB.b);\n    return vec3(r,g,b);\n}\n\n//线性光模式\nvec3 lineLightMode (vec3 colorA, vec3 colorB)\n{\n    return colorB + 2.0 * colorA -1.0;\n}\n\n\n//实色混合模式\n//该模式导致了最终结果仅包含6种基本颜色，每个通道要么就是0，要么就是255。\nfloat hardMixFloat (float rgbA,float rgbB)\n{\n    if(rgbA<1.0-rgbB)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\n\nvec3 hardMixMode (vec3 colorA, vec3 colorB)\n{\n    float r = hardMixFloat(colorA.r,colorB.r);\n    float g = hardMixFloat(colorA.g,colorB.g);\n    float b = hardMixFloat(colorA.b,colorB.b);\n    return vec3(r,g,b);\n}\n\n//差值模式\n//查看每个通道中的颜色信息，比较底色和绘图色，用较亮的像素点的像素值减去较暗的像素点的像素值。与白色混合将使底色反相；与黑色混合则不产生变化 \nvec3 differenceMode (vec3 colorA, vec3 colorB)\n{\n    return abs(colorA - colorB);\n}\n\n//消除模式\n//亮的图片区域将导致另一层的反相，很暗的区域则将导致另一层完全没有改变 \nvec3 exclusionMode (vec3 colorA, vec3 colorB)\n{\n    return (colorA + colorB)-2.0*colorA*colorB;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n   \tvec4 texMapColour1 = texture(iChannel0, uv); \n   \tvec4 texMapColour2 = texture(iChannel1, uv); \n    \n    vec4 texMapColour3 = vec4 (exclusionMode(texMapColour1.rgb,texMapColour2.rgb),1.0);\n   \n    fragColor = texMapColour3;\n\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}