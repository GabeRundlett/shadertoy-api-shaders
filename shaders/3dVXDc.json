{
    "Shader": {
        "info": {
            "date": "1576029393",
            "description": "Tileable Perlin-Worley 3D noise implementation for modeling volumetric clouds like the ones from Horizon Zero Dawn.  Drag the mouse along y-axis to see different slices.",
            "flags": 32,
            "hasliked": 0,
            "id": "3dVXDc",
            "likes": 156,
            "name": "Tileable Perlin-Worley 3D",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "clouds",
                "fbm",
                "perlin",
                "gradient",
                "worley"
            ],
            "usePreview": 0,
            "username": "piyushslayer",
            "viewed": 14455
        },
        "renderpass": [
            {
                "code": "/**\nAn implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds\ninspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider\n(Guerrilla Games). The first column is the perlin-worley noise generated by remapping\nperlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms\nwith increasing frequencies, and are used to model the cloud shapes which are rendered\nin the last column. See the common tab for all the noise functions used.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.y;\n    st.x *= 5.; // 5 columns for different noises\n    uv -= .02 * iTime;\n\n    vec3 col = vec3(0.);\n    \n    float perlinWorley = textureLod(iChannel0, uv * .5, 0.).x;\n    \n    // worley fbms with different frequencies\n    vec3 worley = textureLod(iChannel0, uv, 0.).yzw;\n    float wfbm = worley.x * .625 +\n        \t\t worley.y * .125 +\n        \t\t worley.z * .25; \n    \n    // cloud shape modeled after the GPU Pro 7 chapter\n    float cloud = remap(perlinWorley, wfbm - 1., 1., 0., 1.);\n    cloud = remap(cloud, .85, 1., 0., 1.); // fake cloud coverage\n    \n    if (st.x < 1.)\n        col += perlinWorley;\n    else if(st.x < 2.)\n        col += worley.x;\n    else if(st.x < 3.)\n        col += worley.y;\n\telse if(st.x < 4.)\n        col += worley.z;\n    else if(st.x < 5.)\n        col += cloud;\n            \n    // column dividers\n    float div = smoothstep(.01, 0., abs(st.x - 1.));\n    div += smoothstep(.01, 0., abs(st.x - 2.));\n\tdiv += smoothstep(.01, 0., abs(st.x - 3.));\n    div += smoothstep(.01, 0., abs(st.x - 4.));\n        \n    col = mix(col, vec3(0., 0., .866), div);\n        \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\nThis buffer writes the tileable 3D noise to a texture. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec4 col = vec4(0.);\n    \n    float slices = 128.; // number of layers of the 3d texture\n    float freq = 4.;\n    \n    float pfbm= mix(1., perlinfbm(vec3(uv, floor(m.y*slices)/slices), 4., 7), .5);\n    pfbm = abs(pfbm * 2. - 1.); // billowy perlin noise\n    \n    col.g += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq);\n    col.b += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq*2.);\n    col.a += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq*4.);\n    col.r += remap(pfbm, 0., 1., col.g, 1.); // perlin-worley\n    \n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\nThis tab contains all the necessary noise functions required to model a cloud shape.\n*/\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Fbm for Perlin noise based on iq's blog\nfloat perlinfbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * gradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}