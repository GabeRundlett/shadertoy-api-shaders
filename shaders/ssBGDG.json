{
    "Shader": {
        "info": {
            "date": "1617919509",
            "description": "Study 1/2 into what can be done with all the different parameters one can tweak in a gyroid-function. You can yaw-orbit around the gyroid with the mouse.",
            "flags": 64,
            "hasliked": 0,
            "id": "ssBGDG",
            "likes": 10,
            "name": "Evolving Gyroid - study 1/2",
            "published": 3,
            "tags": [
                "3d",
                "phong",
                "sdf",
                "gyroid",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1364
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Evolving gyroid-thing - study into what can be done with all the different\n// parameters one can tweak in a gyroid-function.\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// the HW_PERFORMANCE-check should take care of some optimization, if that does\n// not help you can still force GROUND_WAVES to 0 and/or AA_SIZE to 1 manually\n#if HW_PERFORMANCE==0\n#define GROUND_WAVES 0\nconst int AA_SIZE = 1;\n#else\n#define GROUND_WAVES 1\nconst int AA_SIZE = 2;\n#endif\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .5;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 12.;\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5*(b - a)/k, .0, 1.);\n    return mix (b, a, h) - h*k*(1. - h); \n}\n\nmat2 r2d (float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat plane (vec3 p, float h)\n{\n    return p.y + h;\n}\n\nfloat ball (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat cube (vec3 p, float size)\n{\n    return length (max (abs (p) - size, .0));\n}\n\nfloat gyroid (vec3 p, float scale, float thickness, float bias, vec2 modulation, vec2 offset)\n{\n    float modulate = (modulation.x > modulation.y) ? modulation.x : modulation.y;\n    p *= scale;\n    float d = dot (sin(p*modulation.x) + offset.x,\n                   cos(p.yzx*modulation.x) + offset.y) - bias;\n\n    return abs (d)/scale/modulate - thickness;\n}\n\nfloat scene (vec3 p)\n{\n    // doing the wavy ground with fbm() is a bit on the costly side\n    vec3 groundP = p;\n    groundP.x += iTime;\n    float pk = 1.5;\n    #if GROUND_WAVES \n    if( p.y<0.5 )\n    pk += .25*fbm(groundP.xz, 2);\n    #endif\n    float ground = plane (p, pk);\n\n    if (length(p) - 1.1 < ground) {\n        p.xz *= r2d (5.*iTime);\n        p.yx *= r2d (7.*iTime);\n        vec2 modulation = vec2 (2. + .75*cos(iTime),\n                                1.23 + .55*sin(iTime));\n        float thickness = .125 *(1./(1. + 5.*( cos(iTime)*.5 + .5 )));\n        float bias1 = 1.3;\n        float bias2 = .3;\n        float scale = 5.;\n        vec2 offset = vec2 (.1, .4);\n        float gyroid1 = gyroid (p, scale, thickness, bias1, modulation, offset)*.55;\n        float gyroid2 = gyroid (p, scale, thickness, bias2, modulation, offset)*.55;\n        float gyroidFinal = min (gyroid1 , gyroid2);\n        gyroidFinal = gyroid1 + gyroid2*.1;\n\n        float r = 1.125 + .05*cos (20.*p.y + 5.*iTime);\n        float ball = ball (p, r);\n\n        float g = smin (ball, gyroidFinal, -.05);\n        ground = min (g, ground);\n    }\n\n    return ground;\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out int iter)\n{\n    float d = .0;\n    float t = .0;\n    int i = 0;\n    vec3 p = vec3 (.0);\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) {\n            iter = i;\n            break;\n        }\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p);\n    vec3 n = normalize (vec3 (scene (p + e.xyy),\n                              scene (p + e.yxy),\n                              scene (p + e.yyx)) - d);\n    return n;\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    int ignore = 0;\n    float distToWorld = raymarch (p + .01*n, lDir, ignore);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (3.*cos(iTime), 3., 3.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 30. / (lDist1*lDist1);\n    vec3 lColor1 = vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (-2.*cos(.3*iTime), 3., 4.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 40. / (lDist2*lDist2);\n    vec3 lColor2 = vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    // don't do material assignment like this, this is a super lazy-ass hack!\n    vec3 gyroidMaterial = 1.5*vec3(.9, .6, .4);\n    bool isFloor = (p.y < -1.);\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.9), vec3 (.1), mask);\n    vec3 diffMaterial = isFloor ? floorMaterial : gyroidMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = 2.*(fragCoord/iResolution.xy) - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // allow some yaw-orbit with the mouse\n    vec2 yaw = .75*vec2 (PI*cos (4.*iMouse.x/iResolution.x),\n                         PI*sin (4.*iMouse.x/iResolution.x));\n    float pitch = 1.;\n\n    // create origin/camera/view-ray\n    vec3 ro = vec3 (yaw.x, pitch, yaw.y);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 1.75;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // raymarch, shading & floor-glow\n    int iter = 0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    vec3 n = vec3 (.0);\n    vec3 color = vec3 (.0);\n    float fog = .0;\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n        for (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n            uv = 2.*((fragCoord + pixelOffset)/iResolution.xy) - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\trd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n            //iter = 0;\n\t\t\td = raymarch (ro, rd, iter);\n            p = ro + d*rd;\n            n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n);\n            /*if (p.y < -1.) {\n                float glow = float (iter) / float (MAX_ITER);\n                ctmp += pow (glow, 1.05)*vec3 (1., .8, .2);\n            };*/\n            fog = 1. / (1. + d*d*.1);\n            ctmp *= fog;\n            ctmp = mix (ctmp, .5*vec3 (.15, .4, .9), pow (1. - 1./d, 6.));\n\n\t\t\tcolor += ctmp;\n        }\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // make the final picture 'pretty'\n    color = color / (1. + color);\n    color *= 1. - .25*dot (uv, uv);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 26571,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/weareoliver/oliver-mechanical"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}