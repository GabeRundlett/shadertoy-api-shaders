{
    "Shader": {
        "info": {
            "date": "1665347351",
            "description": "Speed test for random cloud particle rendering.\nUses a bounding sphere for fast step marching into a shaped voxel cloud.\nThe anti-aliasing also helps the time smearing by increasing sampling.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftyfzt",
            "likes": 32,
            "name": "Star blizzard",
            "published": 3,
            "tags": [
                "3d",
                "voxel",
                "stars",
                "blizzard",
                "temporalantialiasing"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 550
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/ftyfzt\n// By David Hoskins, 2022.\n\nvec3 camPos, camTar, camRay;\nfloat gTime, gTimeDelta;\n\n#define MOUSE_SCRUB\n//#define SHOW_BOUNDING\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define tri(x) abs(fract(x)-.5)*2.\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Flattened torus...\nfloat disc( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y*1.5);\n  return length(q)-t.y;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getColour(vec3 id)\n {\n\n   return cos(id*13.)*.4+.6;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\t\n    return mix(mix(mix( hash13(p+vec3(0,0,0)), \n                        hash13(p+vec3(1,0,0)),f.x),\n                   mix( hash13(p+vec3(0,1,0)), \n                        hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(p+vec3(0,0,1)), \n                        hash13(p+vec3(1,0,1)),f.x),\n                   mix( hash13(p+vec3(0,1,1)), \n                        hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nfloat smthU(float k, float d1, float d2)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n//-------------------------------------------------------------------------------------------------------\nvec2 boundingSphere(vec3  ro, vec3  rd,vec3 cen, float rad)\n{\n    ro = (ro - cen)/ rad;\n    float d = dot(rd,ro);\n    float c = dot(ro,ro) - 1.0;\n    float h = d*d - c;\n\n    \n    if (h < 0.0 ) return vec2(-1); // Not intersecting\n\t\n    h = sqrt( h );\n    float t1 = -d - h;\n    float t2 = -d + h;\n    \n    if( t2 < 0.0) return  vec2(-1);  //...Behind \n\n    t1 = max( t1, 0.0 );\n    t2 = max( t2, 0.0 );\n\n    return vec2(t1, t2) * rad; // ...Return front and back points rescaled.\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat  mapGalaxy(vec3 p)\n{\n    float d = disc(p, vec2(55,35));\n    float d2 = disc(p, vec2(85,15));\n    d = min(d, d2);\n\n    float d3 = length(p)-62.;\n    d = smthU(20.0, d, d3);\n    return d;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec2 distanceRayPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    p -= ro;\n    float h = dot(p,rd);\n    return vec2(length(p-rd*h), h);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getOffset(in vec3 id, float si)\n{\n    return clamp(tri(id*3.53), si*.25, (1.-si*.25));\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 renderStars(in vec3 ro, in vec3 rd, in vec2 bounds)\n{ \n \n    vec2 d;\n    ro += rd * bounds.x;\n    int dist = int(bounds.y - bounds.x);\n\n   \n \tvec3 pos = floor(ro),\n         ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + 0.5 +rs*.5) * ri,\n         sum = vec3(0), col = sum;\n    \n    // Go as far as the back of the bounding sphere\n\tfor( int i = 0; i < dist; i++ )\n    {\n        vec3 id = hash33(pos*139.31);\n        float si = (id.y+id.z)*.2+.1;\n\n        vec3 offset = getOffset(id, si);\n\n        d = distanceRayPoint(ro, rd, pos+offset);\n        if (d.y > 0.0)\n        {\n            float  gal = mapGalaxy(pos+offset);\n            if (gal < 0.0)\n            {\n                vec3 mat = getColour(id);\n                float f = pow(smoothstep(si, 0.0,d.x), 20.0)*1.5;\n                col = mat * f;\n                sum += col;\n                sum += vec3(-gal*.0001,-gal*.0001,-gal*.00002 );\n                //fade *= .9;\n            }\n        }\n\n\n\t\tvec3 st = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += st * rs * ri;\n        pos += st * rs;\n\n\t}\n  \n\treturn sum*.15;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getSky(vec3 pos)\n{\n\tfloat t = 0.0, a = 3.;\n    pos *= 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float v = noise(pos);\n        v = pow(abs(v-.5), 4.)*3.;\n        t += v * a;\n        pos *= 2.1;\n        pos.xy *= mat2(.7, .5, -.5, .7);\n        a *= .53;\n        //pos.x *= pos.z;\n\n    }\n    //\n\n\n\treturn vec3(t*.7, t*.7, t*.7);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Do some basic camera positioning...\nvoid getPath()\n{\n   float r = cos(gTime*.8+1.0)*50.0 + 80.0;\n\tcamPos = vec3(sin(gTime*2.)*r+10., sin(gTime*1.5)*10.+5., cos(gTime*2.)*r);\n    camTar = vec3(0,0,0);\n }\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n    vec3 cw = normalize(camTar-camPos);\n\tvec3 cu = normalize(cross(cw,vec3(0,1,0)));\n\tvec3 cv = normalize(cross(cu,cw));\n    return normalize(uv.x*cu + uv.y*cv + cw * .5);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gT = iTime *.25;\n\n    #ifdef MOUSE_SCRUB\n    gT += iMouse.x*30./iResolution.x;\n    #endif\n    // Got to do a single camera pass to find the bounding sphere...\n    gTime = gT;\n    getPath();\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    camRay = getCamera(uv);\n    vec2 bounds = boundingSphere(camPos, camRay, vec3(0), 95.); \n    \n    \n    vec3 col = getSky(camRay); // Just a simple FBM background.\n    if (bounds.x >= 0.)\n    {\n        #ifdef SHOW_BOUNDING\n        col += vec3(.1,0,0);\n        #endif\n        for (int aa = 0; aa < 4; aa++)\n        {\n            vec2 co = (fragCoord*2. + vec2(aa & 1, (aa >> 1)));// Get anti-aliasing position\n\n            \n            gTime = gT- hash12(co)*iTimeDelta; //...Scatter the time line\n            getPath();\n            vec2 uv = (co-iResolution.xy)/iResolution.y;\n            camRay = getCamera(uv);\n            col += renderStars(camPos, camRay, bounds);\n        }\n    }\n    \n    col = clamp(col, 0.0, 1.0);\n    col = col*col*(3.0-2.0*col); // ...Stretch for higher contrast\n    col *= smoothstep(0.0, 4.0, iTime); //...Fade in\n\n    \n    \n    fragColor = vec4(sqrt(col),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}