{
    "Shader": {
        "info": {
            "date": "1528841797",
            "description": "Use keyboard+mouse for navigation.\nCamera control you can find here ( https://www.shadertoy.com/view/XdKBWW )",
            "flags": 48,
            "hasliked": 0,
            "id": "4dccRr",
            "likes": 23,
            "name": "Working wormhole",
            "published": 3,
            "tags": [
                "raymarching",
                "wormhole",
                "quaternion",
                "controls"
            ],
            "usePreview": 0,
            "username": "Zabidon",
            "viewed": 1571
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Created by Kirill Osipov --- zabidon\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// QUATERNION OPERATIONS\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvec4 quat_decode(vec4 quat) {\n\treturn normalize(quat * 2. - 1.);\n}\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\nvec4 panorama(float n, vec3 pos) {\n    if (n < 0.5) {\n        return texture(iChannel1, pos);\n    } else {\n        return texture(iChannel2, pos);\n    }\n}\n\nconst float lightSpeed = .3;\n// it's over 9000 * 1000\nconst float INFINITY = 9000000.0;\nconst float ROOM_EDGE = 9000.0;\nconst float EPSILON = 0.0001;\n\nconst vec4 wormhole = vec4(0, 0, 3, 1);\nconst float wormholeGravityRatio = 0.5;\nconst float gravityWormhole = wormhole.w * lightSpeed * lightSpeed;\n\n#define ID_ROOM1 2\n#define ID_ROOM2 3\n\nfloat sphereDistance(vec3 rayPosition, vec3 rayDirection, vec4 sphere) {\n    vec3 v;\n    float p, d;\n    v = rayPosition - sphere.xyz;\n    p = dot(rayDirection, v);\n    d = p * p + sphere.w * sphere.w - dot(v, v);\n    return d < 0.0 ? -1.0 : -p - sqrt(d);\n}\n\nvoid testDistance(int i, float dist, inout float currentDistance, inout int currentObject) {\n    if (dist >= EPSILON && dist < currentDistance) {\n        currentDistance = dist;\n        currentObject = i;\n    }\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 position = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    vec4 rotation = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 room = texelFetch(iChannel0, ivec2(4,0), 0);\n    \n\trotation = quat_decode(rotation);\n    \n    vec3 ray = normalize(\n        vec3(\n            (fragCoord.xy-iResolution.xy*.5)/iResolution.x,\n            0.3 - 0. * length(velocity) / 666.\n        )\n    );\n    ray = quat_rotate(rotation, ray);\n\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    float currentDistance = INFINITY;\n    int currentObject = -1;\n    float currentRoom = room.x;\n    for (int i = 0; i < 100; i++) {\n        currentDistance = INFINITY;\n        vec3 gravity = wormhole.xyz - position;\n        float wormholeDist = length(gravity);\n        float stepSize = wormholeDist - wormhole.w * 0.90;\n        if (stepSize <= 0.1) {\n            break;\n        }\n        float amount = wormholeGravityRatio /\n            \t(wormholeDist - wormhole.w * (1.0 - wormholeGravityRatio));\n        vec3 rayAccel = normalize(gravity) * gravityWormhole * amount * amount;\n\n        if (length(rayAccel) > lightSpeed) {\n            rayAccel = normalize(rayAccel) * lightSpeed;\n        }\n        ray = normalize(ray * lightSpeed + rayAccel * stepSize);\n\n        // PLACE HERE YOUR RAYMARCHING CODE\n        // use the testDistance function\n\n        if (currentRoom < 0.5) {\n            testDistance(ID_ROOM1, ROOM_EDGE, currentDistance, currentObject);\n        } else {\n            testDistance(ID_ROOM2, ROOM_EDGE, currentDistance, currentObject);\n        }\n        wormholeDist = lightSpeed * stepSize;\n\n        float realWormholeDist = sphereDistance(position, ray, wormhole);\n        if (realWormholeDist > 0.0 && realWormholeDist < wormholeDist) {\n            // Ray goes through wormhole\n            currentRoom = 1.0 - currentRoom;\n            vec3 intersection = position + ray * realWormholeDist;\n            gravity = normalize(intersection - wormhole.xyz);\n            position = 2.0 * wormhole.xyz - intersection;\n            // little experiments\n            // ray = -reflect(ray, gravity);\n            // ray += gravity / 2.;\n            // magic constant :-P\n            position += ray * realWormholeDist / 1.25;\n        } else {\n            position += ray * wormholeDist;\n        }\n\n    }\n\n    if (currentObject == ID_ROOM1 || currentObject == ID_ROOM2) {\n        color.rgb = panorama(currentRoom, ray).rgb;\n    }\n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The MIT License\n// Created by Kirill Osipov --- zabidon\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst float accel = 1.;\nconst float decay = .9;\n\nconst vec4 wormhole = vec4(0, 0, 3, 1);\n\nconst int Key_Space = 32;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\n\nfloat key_state(int key) {\n\treturn textureLod(iChannel3, vec2((float(key) + .5) / 256.0, .25), 0.0).x;\n}\n\n// QUATERNION OPERATIONS\nvec3 quat_rotate(vec4 quat, vec3 dir) {\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvec4 quat_invert(vec4 quat) {\n    return vec4(-quat.xyz, quat.w);\n}\n\nvec4 quat_multiply(vec4 quat_1, vec4 quat_2) {\n    vec4 dest = vec4(0.0, 0.0, 0.0, 1.0);\n\n    dest.x = quat_1.x * quat_2.w + quat_1.w * quat_2.x + quat_1.y * quat_2.z - quat_1.z * quat_2.y;\n    dest.y = quat_1.y * quat_2.w + quat_1.w * quat_2.y + quat_1.z * quat_2.x - quat_1.x * quat_2.z;\n    dest.z = quat_1.z * quat_2.w + quat_1.w * quat_2.z + quat_1.x * quat_2.y - quat_1.y * quat_2.x;\n    dest.w = quat_1.w * quat_2.w - quat_1.x * quat_2.x - quat_1.y * quat_2.y - quat_1.z * quat_2.z;\n\n    return normalize(dest);\n}\n\nvec4 quat_from_axis_angle(vec3 axis, float rad) {\n    vec4 dest;\n    \n    rad = rad / 2.;\n    float s = sin(rad);\n\n    dest.x = s * axis[0];\n    dest.y = s * axis[1];\n    dest.z = s * axis[2];\n    dest.w = cos(rad);\n\n    return normalize(dest);\n}\n\nvec4 quat_encode(vec4 quat) {\n\treturn quat / 2. + 0.5;\n}\n\nvec4 quat_decode(vec4 quat) {\n\treturn quat * 2. - 1.;\n}\n\n// STORAGE:\n// (0, 0) --- position\n// (1, 0) --- rotation quaternion\n// (2, 0) --- velocity\n// (3, 0) --- last mouse position\n\nvoid init_position(out vec4 fragColor) {\n    fragColor = vec4(0);\n}\n\nvoid init_rotation(out vec4 fragColor) {\n    fragColor = quat_encode(vec4(0, 0, 0, 1));\n}\n\nvoid init_velocity(out vec4 fragColor) {\n    fragColor = vec4(0);\n}\n\nvoid process_position(out vec4 fragColor) {\n    vec4 position = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n\n    vec4 new_position = position + velocity * iTimeDelta;\n    \n    // change room\n    float to_wormhole_distance = distance(new_position.xyz, wormhole.xyz);\n    if (to_wormhole_distance < wormhole.w) {\n        new_position.xyz = wormhole.xyz + (2. * wormhole.w - to_wormhole_distance) *\n            \tnormalize(wormhole.xyz - new_position.xyz);\n    }\n    fragColor = new_position;\n}\n\nvoid process_room(out vec4 fragColor) {\n    vec4 position = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 room = texelFetch(iChannel0, ivec2(4,0), 0);\n\n    vec4 new_position = position + velocity * iTimeDelta;\n        \n    if (distance(new_position.xyz, wormhole.xyz) < wormhole.w) {\n        fragColor = vec4(1. - room.x, 0.0, 0.0, 0.0);\n    } else {\n        fragColor = room;\n    }\n}\n\nvoid process_rotation(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 rotation = texelFetch(iChannel0, ivec2(1,0), 0);\n    rotation = quat_decode(rotation);\n    vec4 last_mouse = texelFetch(iChannel0, ivec2(3,0), 0);\n\n    bool is_pressed = iMouse.w > .5;\n    bool was_press = last_mouse.w > .5;\n\n    vec2 cur_mouse_loc = iMouse.xy / iResolution.xy;\n    vec2 delta_angles = is_pressed && was_press? cur_mouse_loc - last_mouse.xy: vec2(0);\n    float delta_roll = (key_state(Key_Q)-key_state(Key_E))/ 100.;\n\n    vec4 delta_rot_x = quat_from_axis_angle(vec3(0,-1,0), delta_angles.x);\n    vec4 delta_rot_y = quat_from_axis_angle(vec3(1,0,0), delta_angles.y);\n    vec4 delta_rot_z = quat_from_axis_angle(vec3(0,0,1), delta_roll);\n\n    vec4 delta_rot = quat_multiply(delta_rot_y, delta_rot_x);\n    delta_rot = quat_multiply(delta_rot_z, delta_rot);\n    vec4 res_quat = quat_multiply(rotation, delta_rot);\n\n    // TODO: correct up\n    fragColor = quat_encode(res_quat);\n}\n\nvoid process_velocity(out vec4 fragColor) {\n    vec4 position = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 velocity = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 rotation = texelFetch(iChannel0, ivec2(1,0), 0);\n    rotation = quat_decode(rotation);\n    \n    \n    vec3 right = quat_rotate(rotation, vec3(1.0, 0.0, 0.0)) * accel;    \n    velocity.xyz += (key_state(Key_D) - key_state(Key_A)) * right;\n\n    vec3 up = quat_rotate(rotation, vec3(0.0, 1.0, 0.0)) * accel;\n    velocity.xyz += (key_state(Key_R)-key_state(Key_F)) * up;\n\n    vec3 forward = quat_rotate(rotation, vec3(0.0, 0.0, 1.0)) * accel;\n    velocity.xyz += (key_state(Key_W) - key_state(Key_S)) * forward;\n\n    velocity *= 1. - (1. - decay) * (1. - iTimeDelta);\n    \n    fragColor = velocity;\n}\n\nvoid process_mouse(out vec4 fragColor) {\n    fragColor = vec4(iMouse.xy / iResolution.xy, 0, iMouse.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n            init_position(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n            init_rotation(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n            init_velocity(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n            //init_mouse(fragColor);\n        } else if (ivec2(fragCoord.xy) == ivec2(4, 0)) {\n        \tfragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        }\n        return;\n    }\n\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        process_position(fragColor);\n    } else if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        process_rotation(fragColor, fragCoord);\n    } else if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n        process_velocity(fragColor);\n    } else if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        process_mouse(fragColor);\n    } else if (ivec2(fragCoord.xy) == ivec2(4, 0)) {\n        process_room(fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}