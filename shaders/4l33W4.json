{
    "Shader": {
        "info": {
            "date": "1469348130",
            "description": "Win the opponent 5 times to win the game\n\nIn main screen select the game mode with the arrows and press ENTER to start playing\nPlayer 1: Move with the arrows, SPACE for turbo\nPlayer 2: Move with W, A, S, D and SHIFT for turbo\nDEL to restart",
            "flags": 112,
            "hasliked": 0,
            "id": "4l33W4",
            "likes": 80,
            "name": "[SH16C] Tron",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "tron",
                "sh16c"
            ],
            "usePreview": 1,
            "username": "davidbargo",
            "viewed": 8056
        },
        "renderpass": [
            {
                "code": "// Created by David Bargo - davidbargo/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture( iChannel0, fragCoord.xy/iResolution.xy ).xyz;\n    vec3 fontLayer = texture( iChannel1, fragCoord.xy/iResolution.xy ).xyz;\n\n    col = mix(col, fontLayer, fontLayer.x + fontLayer.y + fontLayer.z > 0.01 ? 1.:0.);\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 4225,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/disney-music-group-emea/derezzed-by-daft-punk-tron"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by David Bargo - davidbargo/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// gameplay\n\n//----------------------------------------------------------------------------------------------\n\n\nconst vec2 txP1PosDir        = vec2(124.0,1.0);\nconst vec2 txState           = vec2(124.0,3.0);\nconst vec2 txWins            = vec2(124.0,5.0);\nconst vec2 txBoosts          = vec2(124.0,7.0);\nconst vec2 txP2PosDir        = vec2(124.0,9.0);\nconst vec2 txOptions         = vec2(124.0,11.0);\nconst vec4 txCells           = vec4(0.0,0.0,108.0,124.0);\n\n\nconst float KEY_ENTER = 13.5/256.0;\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_DEL   = 46.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\n\nconst float speedPlayer = 60.0;\nconst float boostTime = 1.;\nconst float speedBoost = 150.0;\n\nfloat map( in vec2 p ) \n{\n    float x = abs(p.x - txCells.z*.5) - txCells.z*0.5;\n    float y = abs(p.y - txCells.w*.5) - txCells.w*0.5;\n\treturn x > -4. || y > -4. ? 1.:0.;\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute gameplay outside of the data area\n    if( fragCoord.x > txCells.w + 1. || fragCoord.y>txCells.w + 1. ) discard;\n    \n    //---------------------------------------------------------------------------------   \n\t// load game state\n\t//---------------------------------------------------------------------------------\n    vec4  p1PosDir        = loadValue( txP1PosDir );\n    vec4  p2PosDir        = loadValue( txP2PosDir );\n    float state           = loadValue( txState ).x;\n    vec2  wins            = loadValue( txWins ).xy;\n    float cell            = loadValue( fragCoord-0.5 ).x;\n    vec4  boosts          = loadValue( txBoosts );\n\tvec2  options         = loadValue( txOptions ).xy;\n    \n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n    if( iFrame==0 )\n    {\n        state = -10.0;\n        options = vec2(1, 0);\n    }\n\n    if (state < -9.)\n    {\n        // Main Screen\n        float pressEnter = texture( iChannel1, vec2(KEY_ENTER,0.25) ).x;\n        if( pressEnter<0.5 && options.y > 1.5)\n        {\n            options.y = 0.;\n        }\n        else if (options.y < 1.5) \n        {\n            if( pressEnter>0.5 )\n            {\n                state = -5.0;\n            }\n            else\n            {\n\n                float changeOption = texture( iChannel1, vec2(KEY_DOWN,0.25) ).x + texture( iChannel1, vec2(KEY_UP,0.25) ).x;\n                if (options.y > 0.5)\n                {\n                    if (changeOption < 0.5) options.y = 0.;\n                }\n                else if( changeOption > 0.5 )\n                {\n                    options.x = 1. - options.x;\n                    options.y = 1.;\n                }\n            }\n        }\n    }\n    else\n    {\n        if( state<0.5 )\n        {\n            p1PosDir  = vec4(txCells.z/2.,13.0,0.0,3.0);\n            p2PosDir  = vec4(txCells.z/2.,txCells.w - 13.0,0.0,4.0);\n            boosts    = vec4(3., -1., 3., -1.);\n        }\n\n        if( state < -4. )\n        {\n            state          = -3.0;\n            wins           =  vec2(0.);\n            if( fragCoord.x<txCells.z && fragCoord.y<txCells.w ) \n                cell = map( fragCoord );\n\n        }\n        else if( state < 0.5 )\n        {\n            state += iTimeDelta*1.75;\n            if( state >= 0. )\n            {\n                state = 1.0;\n            }\n        }\n        else if( state < 1.5 ) \n        {\n\n            // controls p1\n            if( texture( iChannel1, vec2(KEY_RIGHT,0.25) ).x>0.5 && p1PosDir.w > 2.5) p1PosDir.w = 1.;\n            if( texture( iChannel1, vec2(KEY_LEFT, 0.25) ).x>0.5 && p1PosDir.w > 2.5) p1PosDir.w = 2.;\n            if( texture( iChannel1, vec2(KEY_UP,   0.25) ).x>0.5 && p1PosDir.w < 2.5) p1PosDir.w = 3.;\n            if( texture( iChannel1, vec2(KEY_DOWN, 0.25) ).x>0.5 && p1PosDir.w < 2.5) p1PosDir.w = 4.;\n\n            if( texture( iChannel1, vec2(KEY_SPACE, 0.25) ).x>0.5 && boosts.x > 0. && boosts.y < 0. )\n            {\n                boosts.x--;\n                boosts.y = boostTime;\n            }\n\n\t\t\tif (options.x > 0.5)\n            {\n                // AI\n                \n                float bestDir = p2PosDir.w;\n                int bestCount = -1;\n\n                for (float i = 0.; i < 4.; i++)\n                {\n                    float d = mod(p2PosDir.w+i - 1., 4.) + 1.;\n                    vec2 destPos = p2PosDir.xy +dir2dis(d);\n\n                    if (loadValue(destPos).x < 0.25)\n                    {\n                        int count = 0;\n                        for (float i2 = 1.; i2 < 5.; i2++)\n                        {\n                            vec2 destPos2 = destPos.xy +dir2dis(i2);\n\n                            if (loadValue(destPos2).x < 0.25)\n                            {\n                                for (float i3 = 1.; i3 < 5.; i3++)\n                                {\n                                    vec2 destPos3 = destPos2.xy +dir2dis(i3);\n\n                                    if (loadValue(destPos3).x < 0.25)\n                                    {\n                                        for (float i4 = 1.; i4 < 5.; i4++)\n                                        {\n                                            vec2 destPos4 = destPos3.xy +dir2dis(i4);\n\n                                            if (loadValue(destPos4).x < 0.25)\n                                            {\n                                                count++;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\t\t\t\t\t\tif (count == bestCount)\n                        {\n                            float newDist2Player = length(destPos - p1PosDir.xy);\n                            float bestDist2Player = length(p2PosDir.xy +dir2dis(bestDir) - p1PosDir.xy);\n                        \tif (newDist2Player < bestDist2Player)\n                            {\n                                bestCount = count;\n                            \tbestDir = d;\n                            }\n                        }\n                        else if (count > bestCount)\n                        {\n                            bestCount = count;\n                            bestDir = d;\n                        }\n                    }\n                }\n                p2PosDir.w = bestDir;\n                \n                if( boosts.z > 0. && boosts.w < 0. && hash(float(iFrame)*13.1) > 0.995)\n                {\n                    boosts.z--;\n                    boosts.w = boostTime;\n                }\n            }\n\t\t\telse\n            {\n                // controls p2\n                if( texture( iChannel1, vec2(KEY_D    ,0.25) ).x>0.5 && p2PosDir.w > 2.5) p2PosDir.w = 1.;\n                if( texture( iChannel1, vec2(KEY_A   , 0.25) ).x>0.5 && p2PosDir.w > 2.5) p2PosDir.w = 2.;\n                if( texture( iChannel1, vec2(KEY_W ,   0.25) ).x>0.5 && p2PosDir.w < 2.5) p2PosDir.w = 3.;\n                if( texture( iChannel1, vec2(KEY_S   , 0.25) ).x>0.5 && p2PosDir.w < 2.5) p2PosDir.w = 4.;\n\n                if( texture( iChannel1, vec2(KEY_SHIFT, 0.25) ).x>0.5 && boosts.z > 0. && boosts.w < 0. )\n                {\n                    boosts.z--;\n                    boosts.w = boostTime;\n                }\n            }\n\n            p1PosDir.z += iTimeDelta*(boosts.y > 0. ? speedBoost : speedPlayer);\n            p2PosDir.z += iTimeDelta*(boosts.w > 0. ? speedBoost : speedPlayer);\n            boosts.y = max(boosts.y - iTimeDelta, -1.);\n            boosts.w = max(boosts.w - iTimeDelta, -1.);\n\n            vec2 off = dir2dis(p1PosDir.w);\n            vec2 np = p1PosDir.xy + off;\n\n            if( p1PosDir.z>=1.0 )\n            {\n                p1PosDir.z = 0.0;\n\n                float c = loadValue( np ).x;\n                if( c > 0.25 )\n                {\n                    state = 2.0;\n                }\n                else\n                {\n                    p1PosDir.xy = np;\n\n                    float isin = isInside( fragCoord, np );\n                    if( isin>0.0 ) cell = 2.;\n                }\n            }\n\n            off = dir2dis(p2PosDir.w);\n            np = p2PosDir.xy + off;\n\n            if( p2PosDir.z>=1.0 )\n            {\n                p2PosDir.z = 0.0;\n\n                float c = loadValue( np ).x;\n                if( c > 0.25 )\n                {\n                    state = state > 1.5 ? 4. : 3.0;\n                }\n                else\n                {\n                    p2PosDir.xy = np;\n\n                    float isin = isInside( fragCoord, np );\n                    if( isin>0.0 ) cell = 3.;\n                }\n            }\n\n            if (abs(p1PosDir.x -p2PosDir.x) < 0.5 && abs(p1PosDir.y -p2PosDir.y) < 0.5) state = 4.;\n\n            if (state < 3.5 && state > 1.5)\n            {\n                if (state > 2.5) wins.x++;\n                else wins.y++;\n            }\n        }\n        else\n        {\n            float pressEnter = texture( iChannel1, vec2(KEY_ENTER,0.25) ).x;\n            if( pressEnter>0.5 )\n            {\n                if (wins.x > 4.5 || wins.y > 4.5)\n                {\n                    options.y = 2.;\n                \tstate = -10.;   \n                }\n                else\n                {\n                    if( fragCoord.x<txCells.z && fragCoord.y<txCells.w ) \n                        cell = map( fragCoord );\n                    state = -3.0;\n                }\n            }\n        }\n        \n        float pressDel = texture( iChannel1, vec2(KEY_DEL,0.25) ).x;\n        if( pressDel>0.5 )\n        {\n            if( fragCoord.x<txCells.z && fragCoord.y<txCells.w ) \n                cell = map( fragCoord );\n            state = -10.0;\n            options.y = 2.;\n        }\n    }\n  \n\t//---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n   \n    storeValue( txP1PosDir,         vec4(p1PosDir),              fragColor, fragCoord );\n    storeValue( txP2PosDir,         vec4(p2PosDir),              fragColor, fragCoord );\n    storeValue( txState,            vec4(state,0.0,0.0,0.0),     fragColor, fragCoord );\n    storeValue( txWins,             vec4(wins,0.0,0.0),          fragColor, fragCoord );\n    storeValue( txCells,            vec4(cell,0.0,0.0,0.0),      fragColor, fragCoord );\n    storeValue( txBoosts,           vec4(boosts),                fragColor, fragCoord );\n    storeValue( txOptions,          vec4(options,0.0,0.0),       fragColor, fragCoord );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by David Bargo - davidbargo/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// rendering\n\nconst vec2 txP1PosDir    = vec2(124.0,1.0);\nconst vec2 txState       = vec2(124.0,3.0);\nconst vec2 txWins        = vec2(124.0,5.0);\nconst vec2 txBoosts      = vec2(124.0,7.0);\nconst vec2 txP2PosDir    = vec2(124.0,9.0);\nconst vec4 txCells       = vec4(0.0,0.0,108.0,124.0);\n\nconst vec3 p1Color       = vec3(1.,0.9,0.2);\nconst vec3 p2Color       = vec3(.0,0.9,1.);\n\n//============================================================\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nfloat sdDonut(vec2 pos, float radius, float width)\n{\n    return abs(length(pos)-radius)-width;   \n}\n\nvec2 rot(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n\treturn p * mat2(c, -s, s, c);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-(dist+0.01)*100.0, 0.0, 1.0);\n}\n\nfloat innerBorderMask(float dist, float width)\n{\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n//============================================================\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//============================================================\n\nfloat IsGridLine(vec2 fragCoord)\n{\n\tvec2 vPixelsPerGridSquare = vec2(32.0, 32.0);\n\t\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\t\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(2.3));\n\t\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\treturn fIsGridLine;\n}\n\nvec3 drawMap( vec3 col, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    float xCells = txCells.w*(iResolution.x / iResolution.y);\n    vec2 p = uv-vec2(0.5-txCells.z/(xCells*2.), 0.); // center\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 q = floor(p*txCells.w);\n    vec2 r = fract(p*txCells.w);\n\n    vec2 l = vec2((15.*fragCoord-iResolution.xy)/iResolution.y);\n    l.x -= 0.55; l.y -= 0.5;\n    l = abs(fract(l) - 0.5) - 0.25;\n    l = step(0.0, l)*l*4.0;\n    l *= l; l *= l; l *= l;\n    l = 1. - l;\n    float val = 1.0 - l.x*l.y;\n    \n    vec3 bg = mix(vec3(0., 0.1, 0.15), vec3(1.), val);\n    col += bg*step(0., p.x)*step(p.x, txCells.z/txCells.w);\n    if( q.x>=0.0 && q.x<=txCells.z )\n    {\n        float c = texture( iChannel0, (q+0.5)/iResolution.xy, -100.0 ).x;\n        if( c>0.5 )\n        {            \n            float d = sdBox(r-0.5, vec2(1.));\n            float f = 1.0 - smoothstep( -0.01, 0.01, d );\n            \n            vec3 wco = c > 2.5 ? p2Color :\n            \t\t   c > 1.5 ? p1Color : vec3(0.25);\n            col = mix( col, wco, f );\n            //col += 0.15*vec3(1.0,0.8,0.0)*exp(-1500.0*d*d);\n        }\n    }\n    return col;\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\n\nvec2 cell2ndc( vec2 c )\n{\n\tc = (c+0.5) / txCells.w;\n    return c;\n}\n\n\nvec3 drawPlayer( vec3 col, in vec2 fragCoord, float player, in vec4 playerPosDir, bool dead )\n{\n    vec2 off = dir2dis(playerPosDir.w);    \n    vec2 mPlayerPos = playerPosDir.xy + off*playerPosDir.z;\n\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    float xCells = txCells.w*(iResolution.x / iResolution.y);\n    vec2 p = uv-vec2(0.5-txCells.z/(xCells*2.), 0.); // center\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 q = p - cell2ndc( mPlayerPos );\n\n    float c = sdCircle(q, 0.023);\n\n    vec3 color = mix(p1Color, p2Color, player - 1.);\n    \n    float phase = 0.5+0.5*sin(2.0*6.2831*iTime);\n    if (dead) color = mix(color, vec3(1., 0., 0.), phase);\n    col += 0.1*color*exp((-100.0 - (dead ? 50.*phase : 0.))*c);\n\n    return col;\n}\n\n\n#define PI 3.141592\nvec3 drawMainTitle(vec3 col, vec2 fragCoord)\n{    \n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 p = -1. + 2.*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    p *= 120.;\n    \n    // green lines\n    float f = abs((p.x)-32.);\n    f = min(f, abs((p.y)-48.));\n    col += vec3(0.,0.8,0.3)*exp(-1.5*f);\n    \n    p += vec2(130, -80);\n\n    // T\n    float d = sdBox(p + vec2(-32, 8), vec2(32, 8));\n    d = merge(d,  sdBox(p + vec2(-32, 32), vec2(16, 32)));\n    \n    // R\n    p.x -= 65.;\n    d = merge(d,  sdBox(p + vec2(-8, 16+32), vec2(8, 16)));\n    float r = sdBox(p + vec2(-26-16, 16+32), vec2(26, 16));\n    r = intersect(r, sdBox(rot(p + vec2(-30-12, 12+36), PI/3.7), vec2(30, 8)));\n\td = merge(d, r);\n    \n    d = merge(d, sdBox(p + vec2(-12 -8, 8),     vec2(12, 8)));\n    d = merge(d, sdCircle(p + vec2(-12. -19., 8),     8.));\n    d = merge(d, sdCircle(p + vec2(-12. -21., 8),     8.));\n        \n    r = sdDonut(p + vec2(-32, 32), 24., 8.);\n    r = intersect(r, sdBox(p + vec2(-32 - 16, 16),         vec2(16, 16)));\n        \n    d = merge(d, r);\n    \n    // O\n    p.x -= 65.;\n    d = merge(d, sdDonut(p - vec2(32, -32), 24., 8.));\n    \n    // N\n    p.x -= 65.;\n    float nc = sdBox(rot(p + vec2(-32-13, 0), PI/4.), vec2(64, 32));\n    float nd = sdBox(p + vec2(-32 , 32),         vec2(32, 32));\n    r = substract(sdBox(p + vec2(-32-16 , 32+18), vec2(32, 18)), substract(nc, nd));\n    d = merge(d, r);\n    r = substract(sdBox(p, vec2(32+16, 32)), intersect(nc, nd));\n    d = merge(d, r);\n    \n    \n    vec3 fontColor = mix(vec3(0., 0., 0.02), vec3(0., 0.5, 0.7), smoothstep(-32., -48., p.y));\n    fontColor = mix(fontColor, vec3(1.), smoothstep(-40., -56., p.y));\n\tcol = mix(col, fontColor, fillMask(d));\n\tcol = mix(col, vec3(.9,0,0), innerBorderMask(d, 2.));\n    \n    return col;\n}\n\n//============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------\n    // load game state\n    //------------------------\n       \n    vec4  p1PosDir  = loadValue( txP1PosDir );\n    vec4  p2PosDir  = loadValue( txP2PosDir );\n    float state     = loadValue( txState ).x;\n    vec2  wins      = loadValue( txWins ).xy;\n\tvec2  boosts    = loadValue( txBoosts ).xz;\n\n    //------------------------\n    // render\n    //------------------------\n    vec3 col = vec3(0.0);\n    \n    if (state < -9.)\n    {\n        col = drawMainTitle(col, fragCoord);\n    }\n    else \n    {\n        // map\n        col = drawMap( col, fragCoord );\n\n        // players\n        col = drawPlayer( col, fragCoord, 1., p1PosDir, (state > 1.5 && state < 2.5) || state > 3.5 );\n        col = drawPlayer( col, fragCoord, 2., p2PosDir, state > 2.5 );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Font rendering\n\nconst vec2 txState           = vec2(124.0,3.0);\nconst vec2 txWins            = vec2(124.0,5.0);\nconst vec2 txBoosts          = vec2(124.0,7.0);\nconst vec2 txOptions         = vec2(124.0,11.0);\n\nconst vec3 p1Color       = vec3(1.,0.9,0.2);\nconst vec3 p2Color       = vec3(.0,0.9,1.);\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//============================================================\n// Font rendering by Flyguy (https://www.shadertoy.com/view/llSGRm)\n\n\n#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n\nvec2 print_pos = vec2(0);\nfloat font_size = 5.;\n//Automatically generated from the sprite sheet here: http://uzebox.org/wiki/index.php?title=File:Font6x8.png\nvec2 ch_spc = vec2(0.0,0.0);\nvec2 ch_exc = vec2(276705.0,32776.0);\nvec2 ch_quo = vec2(1797408.0,0.0);\nvec2 ch_hsh = vec2(10738.0,1134484.0);\nvec2 ch_dol = vec2(538883.0,19976.0);\nvec2 ch_pct = vec2(1664033.0,68006.0);\nvec2 ch_amp = vec2(545090.0,174362.0);\nvec2 ch_apo = vec2(798848.0,0.0);\nvec2 ch_lbr = vec2(270466.0,66568.0);\nvec2 ch_rbr = vec2(528449.0,33296.0);\nvec2 ch_ast = vec2(10471.0,1688832.0);\nvec2 ch_crs = vec2(4167.0,1606144.0);\nvec2 ch_per = vec2(0.0,1560.0);\nvec2 ch_dsh = vec2(7.0,1572864.0);\nvec2 ch_com = vec2(0.0,1544.0);\nvec2 ch_lsl = vec2(1057.0,67584.0);\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_col = vec2(195.0,1560.0);\nvec2 ch_scl = vec2(195.0,1544.0);\nvec2 ch_les = vec2(135300.0,66052.0);\nvec2 ch_equ = vec2(496.0,3968.0);\nvec2 ch_grt = vec2(528416.0,541200.0);\nvec2 ch_que = vec2(934929.0,1081352.0);\nvec2 ch_ats = vec2(935285.0,714780.0);\nvec2 ch_A = vec2(935188.0,780450.0);\nvec2 ch_B = vec2(1983767.0,1190076.0);\nvec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\nvec2 ch_lsb = vec2(925826.0,66588.0);\nvec2 ch_rsl = vec2(16513.0,16512.0);\nvec2 ch_rsb = vec2(919584.0,1065244.0);\nvec2 ch_pow = vec2(272656.0,0.0);\nvec2 ch_usc = vec2(0.0,62.0);\nvec2 ch_a = vec2(224.0,649374.0);\nvec2 ch_b = vec2(1065444.0,665788.0);\nvec2 ch_c = vec2(228.0,657564.0);\nvec2 ch_d = vec2(66804.0,665758.0);\nvec2 ch_e = vec2(228.0,772124.0);\nvec2 ch_f = vec2(401543.0,1115152.0);\nvec2 ch_g = vec2(244.0,665474.0);\nvec2 ch_h = vec2(1065444.0,665762.0);\nvec2 ch_i = vec2(262209.0,33292.0);\nvec2 ch_j = vec2(131168.0,1066252.0);\nvec2 ch_k = vec2(1065253.0,199204.0);\nvec2 ch_l = vec2(266305.0,33292.0);\nvec2 ch_m = vec2(421.0,698530.0);\nvec2 ch_n = vec2(452.0,1198372.0);\nvec2 ch_o = vec2(228.0,665756.0);\nvec2 ch_p = vec2(484.0,667424.0);\nvec2 ch_q = vec2(244.0,665474.0);\nvec2 ch_r = vec2(354.0,590904.0);\nvec2 ch_s = vec2(228.0,114844.0);\nvec2 ch_t = vec2(8674.0,66824.0);\nvec2 ch_u = vec2(292.0,1198868.0);\nvec2 ch_v = vec2(276.0,664840.0);\nvec2 ch_w = vec2(276.0,700308.0);\nvec2 ch_x = vec2(292.0,1149220.0);\nvec2 ch_y = vec2(292.0,1163824.0);\nvec2 ch_z = vec2(480.0,1148988.0);\nvec2 ch_lpa = vec2(401542.0,66572.0);\nvec2 ch_bar = vec2(266304.0,33288.0);\nvec2 ch_rpa = vec2(788512.0,1589528.0);\nvec2 ch_tid = vec2(675840.0,0.0);\nvec2 ch_lar = vec2(8387.0,1147904.0);\n\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,22.0); //Fixes small artefacts on my nexus 7\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec2 ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv/font_size - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nvec2 get_digit(int d)\n{    \n    if(d == 0) return ch_0;\n    if(d == 1) return ch_1;\n    if(d == 2) return ch_2;\n    if(d == 3) return ch_3;\n    if(d == 4) return ch_4;\n    if(d == 5) return ch_5;\n    if(d == 6) return ch_6;\n    if(d == 7) return ch_7;\n    if(d == 8) return ch_8;\n    if(d == 9) return ch_9;\n    return vec2(0.0);\n}\n\n//============================================================\n//============================================================\n\n\nvec3 mainScreenText(vec2 uv, float playerVsGpu)\n{\n    vec3 c = vec3(0);\n    \n    float col = 0.0;\n    \n    font_size = mix(5., 7., playerVsGpu);\n    print_pos = vec2(-STRWIDTH(13.0)/2.0, -150./font_size -STRHEIGHT(1.0)/2.0);\n    \n    col = char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_v,uv);\n    col += char(ch_s,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_G,uv);\n    col += char(ch_P,uv);\n    col += char(ch_U,uv);\n    c += mix(vec3(0.5), vec3(1.,.9,0.1), playerVsGpu)*col;\n    \n    font_size = mix(7., 5., playerVsGpu);\n    print_pos = vec2(-STRWIDTH(16.0)/2.0, -250./font_size -STRHEIGHT(1.0)/2.0);\n       \n    col = char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_v,uv);\n    col += char(ch_s,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    c += mix(vec3(1.,.9,.1), vec3(0.5), playerVsGpu)*col;\n    \n    return c;\n}\n\nvec3 gameStartCounter(vec2 uv, float state)\n{        \n    font_size = 16.;\n    print_pos = vec2(-STRWIDTH(1.0)/2.0, -STRHEIGHT(1.0)/2.0);\n    float col = char(get_digit(int(-state)+1),uv);       \n\n    return vec3(.1,.9,1.)*col;\n}\n\nvec3 gameHud(vec2 uv, float playerVsGpu, vec2 wins, vec2 boosts)\n{        \n    font_size = 6.;\n    print_pos = vec2(-490.*(iResolution.x/iResolution.y)/font_size, 490./font_size-STRHEIGHT(1.0));\n    float col = 0.;       \n\tcol += char(ch_P,uv);\n    col += char(ch_L,uv);\n    col += char(ch_A,uv);\n    col += char(ch_Y,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_1,uv);\n    \n    font_size = 4.;\n    print_pos = vec2(-490.*(iResolution.x/iResolution.y)/font_size, 400./font_size-STRHEIGHT(1.0));\n\tcol += char(ch_L,uv);\n    col += char(ch_i,uv);\n    col += char(ch_v,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(5 - int(wins.y)),uv);\n    \n    print_pos = vec2(-490.*(iResolution.x/iResolution.y)/font_size, 330./font_size-STRHEIGHT(1.0));\n\tcol += char(ch_T,uv);\n    col += char(ch_u,uv);\n    col += char(ch_r,uv);\n    col += char(ch_b,uv);\n    col += char(ch_o,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(int(boosts.x)),uv);\n    \n    if (wins.x > 4.5)\n    {\n        font_size = 8.;\n        print_pos = vec2(-460.*(iResolution.x/iResolution.y)/font_size + STRWIDTH(1.0)/2., 0.);\n        col += char(ch_Y,uv);\n        col += char(ch_O,uv);\n        col += char(ch_U,uv);\n        print_pos = vec2(-460.*(iResolution.x/iResolution.y)/font_size, -STRHEIGHT(1.0));\n        col += char(ch_W,uv);\n        col += char(ch_I,uv);\n        col += char(ch_N,uv);\n        col += char(ch_exc,uv);\n    }\n    else if (wins.y > 4.5)\n    {\n        font_size = 8.;\n        print_pos = vec2(-460.*(iResolution.x/iResolution.y)/font_size + STRWIDTH(1.0)/2., 0.);\n        col += char(ch_Y,uv);\n        col += char(ch_O,uv);\n        col += char(ch_U,uv);\n        print_pos = vec2(-460.*(iResolution.x/iResolution.y)/font_size, -STRHEIGHT(1.0));\n        col += char(ch_L,uv);\n        col += char(ch_O,uv);\n        col += char(ch_S,uv);\n        col += char(ch_E,uv);\n    }\n    \n    vec3 p1c = p1Color*col;\n    \n    font_size = 6.;\n    \n    if (playerVsGpu > 0.5)\n    {\n        print_pos = vec2(490.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(3.0), 490./font_size-STRHEIGHT(1.0));\n        col = char(ch_G,uv);\n        col += char(ch_P,uv);\n        col += char(ch_U,uv);\n    }\n    else\n    {\n        print_pos = vec2(490.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(8.0), 490./font_size-STRHEIGHT(1.0));\n        col = char(ch_P,uv);\n        col += char(ch_L,uv);\n        col += char(ch_A,uv);\n        col += char(ch_Y,uv);\n        col += char(ch_E,uv);\n        col += char(ch_R,uv);\n        col += char(ch_spc,uv);\n        col += char(ch_2,uv);\n\n        if (wins.y > 4.5)\n        {\n            font_size = 8.;\n            print_pos = vec2(460.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(3.5), 0.);\n            col += char(ch_Y,uv);\n            col += char(ch_O,uv);\n            col += char(ch_U,uv);\n            print_pos = vec2(460.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(4.0), -STRHEIGHT(1.0));\n            col += char(ch_W,uv);\n            col += char(ch_I,uv);\n            col += char(ch_N,uv);\n            col += char(ch_exc,uv);\n        }\n        else if (wins.x > 4.5)\n        {\n            font_size = 8.;\n            print_pos = vec2(460.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(3.5), 0.);\n            col += char(ch_Y,uv);\n            col += char(ch_O,uv);\n            col += char(ch_U,uv);\n            print_pos = vec2(460.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(4.0), -STRHEIGHT(1.0));\n            col += char(ch_L,uv);\n            col += char(ch_O,uv);\n            col += char(ch_S,uv);\n            col += char(ch_E,uv);\n    \t}\n    }\n    \n    font_size = 4.;\n    print_pos = vec2(490.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(9.0), 330./font_size-STRHEIGHT(1.0));\n    col += char(ch_T,uv);\n    col += char(ch_u,uv);\n    col += char(ch_r,uv);\n    col += char(ch_b,uv);\n    col += char(ch_o,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(int(boosts.y)),uv);\n    \n    print_pos = vec2(490.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(8.0), 400./font_size-STRHEIGHT(1.0));\n\tcol += char(ch_L,uv);\n    col += char(ch_i,uv);\n    col += char(ch_v,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n    col += char(ch_spc,uv);\n    col += char(get_digit(5 - int(wins.x)),uv);\n    \n    \n                \n    vec3 p2c = p2Color*col;\n    return p1c + p2c;\n}\n\nvec3 showContinue(vec2 uv)\n{        \n    font_size = 4.;\n    float col = 0.;       \n\n    print_pos = vec2(480.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(11.0), -490./font_size+STRHEIGHT(2.0));\n    col += char(ch_P,uv);\n    col += char(ch_r,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_s,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_E,uv);\n    col += char(ch_N,uv);\n    col += char(ch_T,uv);\n    col += char(ch_E,uv);\n    col += char(ch_R,uv);\n    \n    print_pos = vec2(480.*(iResolution.x/iResolution.y)/font_size - STRWIDTH(11.0), -490./font_size+STRHEIGHT(1.0));\n    col += char(ch_t,uv);\n    col += char(ch_o,uv);\n    col += char(ch_spc,uv);\n    col += char(ch_c,uv);\n    col += char(ch_o,uv);\n    col += char(ch_n,uv);\n    col += char(ch_t,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_u,uv);\n    col += char(ch_e,uv);\n    return vec3(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------\n    // load game state\n    //------------------------\n    float state  = loadValue( txState ).x;\n    float playerVsGpu  = loadValue( txOptions ).x;\n    vec2 wins  = loadValue( txWins ).xy;\n    vec2 boosts  = loadValue( txBoosts ).xz;\n    \n    \n    //------------------------\n    // render\n    //------------------------\n    \n    vec3 col = vec3(0);\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 p = -500. + 1000.*uv;\n    p.x *= iResolution.x / iResolution.y;\n    if (state < -9.)\n    {\n        col += mainScreenText(p, playerVsGpu);\n    }\n    else\n    {\n     \tif (state < 0.)\n        {\n            col += gameStartCounter(p, state);\n        }\n        else if (state > 1.5)\n        {\n            col += showContinue(p);\n        }\n        col += gameHud(p, playerVsGpu, wins, boosts);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}