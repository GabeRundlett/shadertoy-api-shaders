{
    "Shader": {
        "info": {
            "date": "1666025541",
            "description": "Simple test using standard SDF ray marching, with reflections and refractions. The floor uses a 2D voronoi implementation.",
            "flags": 0,
            "hasliked": 0,
            "id": "DsfGD8",
            "likes": 10,
            "name": "SDF ray marching and voronoi",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi",
                "sdf"
            ],
            "usePreview": 1,
            "username": "LukasBoersma",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "/***********************************************\n* MY SOURCES OF INSPIRATION AND CODE SAMPLES:\n*  - https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n*  - Various demos and shader samples by Inigo Quilez (https://iquilezles.org/)\n***********************************************/\n\n\n\n/***********************************************\n* SETTINGS\n***********************************************/\n\n// Number of nested ray marching calls (for reflections/refractions)\n#define MARCHING_NESTED_CALLS 3\n\n// Max number of marching steps\n#define MARCHING_MAX_STEPS 512\n\n// When we are this close to a surface, we count it as \"on the surface\"\n#define MARCHING_EPSILON 1e-3\n\n#define MARCHING_MAX_DISTANCE 20.0\n\n#define MARCHING_USE_BUILTIN_DERIVATIVES 1\n\n#define GRADIENT_DELTA_EPSILON 1e-4\n\n#define SHADOW_BIAS 0.2\n\n#define SHADOW_HARDNESS 8.0\n\n\n\n/***********************************************\n* MATERIALS\n***********************************************/\n\nstruct Material\n{\n    vec3 diffuse;\n    vec3 filtering;\n    bool reflections;\n    bool refractions;\n    float shininess;\n};\n\nconst Material[4] materials = Material[4](\n    // WHITE\n    Material(\n        vec3(1),\n        vec3(1),\n        false,\n        false,\n        0.5\n    ),\n    // RED\n    Material(\n        vec3(1,0,0),\n        vec3(0.3, 0.05, 0.05),\n        true,\n        true,\n        0.5\n    ),\n    // GREEN\n    Material(\n        vec3(0,0,0),\n        vec3(0.3,1,0.3),\n        true,\n        true,\n        1.0\n    ),\n    // BLUE\n    Material(\n        vec3(0,0,1),\n        vec3(1),\n        true,\n        false,\n        0.8\n    )\n);\n\n#define MAT_WHITE   1\n#define MAT_RED     2\n#define MAT_GREEN   3\n#define MAT_BLUE    4\n\n\n\n/***********************************************\n* UTILS\n***********************************************/\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return fract(sin(x*10534.125)); }\nfloat random( int x ) { return fract(sin(float(x)*10534.125)); }\nfloat random( vec2  v ) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*15.1981); }\nfloat random( vec3  v ) { return fract(sin(dot(v, vec3(10534.125, 67125.378, 23679.367)))*1573.1981); }\nfloat random( vec4  v ) { return fract(sin(dot(v, vec4(10534.125, 67125.378, 23679.367, 29814.204)))*1573.1981); }\n\n\nfloat distSquared(vec2 a, vec2 b)\n{\n    vec2 d = a-b;\n    return dot(d,d);\n}\n\nfloat distSquared(vec3 a, vec3 b)\n{\n    vec3 d = a-b;\n    return dot(d,d);\n}\n\n// Smooth min-function,\n// From https://iquilezles.org/articles/smin/\nfloat sMinCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n\n/***********************************************\n* VORONOI\n***********************************************/\n\nvec2 getCellPoint2D(ivec2 cell)\n{\n    vec2 rand = vec2(\n        random(cell.x + cell.y),\n        random(cell.x * 5 + cell.y * 3)\n    )*0.5;\n    return vec2(cell) + rand;\n}\n\nfloat voronoi2D(vec2 uv)\n{\n    ivec2 cell = ivec2(uv);\n    \n    float bestDistance = 1e9;\n    float res = 0.0;\n    \n    for(int dx=-1; dx <= 1; dx++)\n    {\n        for(int dy=-2; dy <= 2; dy++)\n        {\n            vec2 cellPoint = getCellPoint2D(cell+ivec2(dx,dy));\n            bestDistance = min(bestDistance, distance(uv, cellPoint));\n            //res += 1.0/pow( distance(uv, cellPoint), 8.0 );\n        }\n    }\n    \n    return bestDistance;\n    //return pow( 1.0/res, 1.0/16.0 );\n}\n\n\n\n/***********************************************\n* RAY MATH\n***********************************************/\n\nstruct Ray\n{\n    vec3 start;\n    vec3 dir;\n};\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nRay getViewRay(vec2 fragCoord)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 screenCoords = fragCoord.xy / iResolution.xy - vec2(0.5);\n    screenCoords.x *= aspectRatio;\n    \n    mat3 view = rotation3dY(iTime/3.);\n\n    vec3 camPos = view * vec3(0.0, 2.5, -10.0);\n\n    // Todo: Proper ciew direction calculation\n    vec3 viewDirection = normalize(view * vec3(screenCoords.xy, 1.0));\n\n    return Ray(camPos, viewDirection);\n}\n\n\n\n/***********************************************\n* SDF FUNCTIONS\n***********************************************/\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCube(vec3 p, float r)\n{\n    return max(max(abs(p.x), abs(p.y)), abs(p.z)) - r;\n}\n\nfloat sdVoronoiColumns(vec3 p)\n{\n    float v = voronoi2D(p.xz / 10.0) - 0.5;\n    return max(p.y, v);\n}\n\n\n\n/***********************************************\n* SCENE DEFINITION (MAIN DISTANCE FIELD)\n***********************************************/\n\n#define JOIN_SMOOTH(sdValue1, sdValue2, k) sMinCubic((sdValue1), (sdValue2), k)\n\n#define JOIN_IMPL(a,b) sMinCubic((a), (b), cos(iTime) * 0.75 + 0.75)\n\nfloat join(float sd1, float sd2) { return JOIN_IMPL(sd1, sd2); }\nfloat join(float sd1, float sd2, float sd3) { return JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3); }\nfloat join(float sd1, float sd2, float sd3, float sd4) { return JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3), sd4); }\nfloat join(float sd1, float sd2, float sd3, float sd4, float sd5) { return JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3), sd4), sd5); }\nfloat join(float sd1, float sd2, float sd3, float sd4, float sd5, float sd6) { return JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(JOIN_IMPL(sd1, sd2), sd3), sd4), sd5), sd6); }\n\n#define DRAW(sdValue, matValue) do { mat = sd < sdValue ? mat : matValue; sd = JOIN_IMPL(sd, sdValue); } while(false)\n\nvec2 sdMain(vec3 p)\n{\n    int mat = MAT_WHITE;\n    float sd = 1e6;\n\n    float plane = abs(sdPlane(p)) > 1.3 ? sdPlane(p) : sdPlane(p) - voronoi2D(p.xz*0.3) - voronoi2D(p.xz)*0.1;\n\n    DRAW(plane, MAT_WHITE);\n    DRAW(\n        JOIN_SMOOTH(\n            sdSphere(p - vec3(0,1,0), 1.0),\n            join(\n                sdSphere(p - vec3(0.5,1.5 + sin(iTime+1.),0.5), 0.3),\n                sdSphere(p - vec3(-0.5,1.5 + sin(iTime+2.),0.5), 0.3),\n                sdSphere(p - vec3(-0.5,1.5 + sin(iTime+3.),-0.5), 0.3),\n                sdSphere(p - vec3(0.5,1.5 + sin(iTime+4.),-0.5), 0.3)\n            ),\n            0.8\n        ),\n        MAT_RED\n    );\n\n    DRAW(sdSphere(p - vec3(3,1,3), 1.0), MAT_WHITE);\n\n    float sphere = sdSphere(p - vec3(-3,1,3), 1.0);\n    float cube = sdCube(p - vec3(-3,1,3), 1.0);\n\n    DRAW(\n        mix(sphere, cube, sin(iTime*3.) * 0.4 + 0.4),\n        MAT_BLUE\n    );\n    DRAW(sdSphere(p - vec3(3,1,-3), 1.0), MAT_RED);\n    DRAW(sdSphere(p - vec3(-3,1,-3), 1.0), MAT_GREEN);\n    \n    return vec2(sd, float(mat));\n}\n\n\n\n/***********************************************\n* RAY MARCHING\n***********************************************/\n\nstruct MarchingResult\n{\n    vec4 posAndMaterial;\n    vec2 minDistance; // x: minimum distance read from SDF, y: ray length where that distance was found\n};\n\nvec3 getSdNormal(vec3 p)\n{\n    // Todo: Try using the dFdx/dFdy functions for builtin faster derivatives\n    return normalize(vec3(\n        sdMain(vec3(p.x + GRADIENT_DELTA_EPSILON, p.y, p.z)).x - sdMain(vec3(p.x - GRADIENT_DELTA_EPSILON, p.y, p.z)).x,\n        sdMain(vec3(p.x, p.y + GRADIENT_DELTA_EPSILON, p.z)).x - sdMain(vec3(p.x, p.y - GRADIENT_DELTA_EPSILON, p.z)).x,\n        sdMain(vec3(p.x, p.y, p.z  + GRADIENT_DELTA_EPSILON)).x - sdMain(vec3(p.x, p.y, p.z - GRADIENT_DELTA_EPSILON)).x\n    ));\n}\n\n// Returns the nearest surface position (from sdMain) that intersects the given ray.\n// Returns a vec4 where xyz is the position, and w is the material index if an intersection was found,\n// or 0 if no intersection was found.\nMarchingResult rayMarch(Ray ray, float startT, float endT, float minStep, float maxStep)\n{\n    // Our position on the ray (position = ray.start + ray.dir * t)\n    float t = startT;\n    vec2 minDist = vec2(1e6, 0.0); // x: minimum distance read from SDF, y: ray length where that distance was found\n    float sd = 0.0;\n    bool distHasPeaked = false;\n    bool isOutside = false;\n\n    for(int i = 0; i < MARCHING_MAX_STEPS && t < endT; i++)\n    {\n        vec3 p = ray.start + ray.dir * t;\n        vec2 sdAndMat = sdMain(p);\n        float newSd = sdAndMat.x;\n        float mat = sdAndMat.y;\n\n        if(newSd <= sd)\n        {\n            distHasPeaked = true;\n        }\n\n        if(newSd > 0.)\n        {\n            isOutside = true;\n        }\n\n        if(distHasPeaked && newSd < minDist.x)\n        {\n            minDist = vec2(newSd, t);\n        }\n\n        sd = newSd;\n\n        t += clamp(abs(sd), minStep, maxStep);\n\n        // Are we on a surface?\n        if(isOutside && sd < MARCHING_EPSILON)\n        {\n            p = ray.start + ray.dir * t;\n            return MarchingResult(\n                vec4(p, float(mat)),\n                vec2(0.0, t)\n            );\n        }\n    }\n\n    // No intersection found. Return a vec4 with a zero in the w component.\n    return MarchingResult(vec4(0), minDist);\n}\n\nMarchingResult rayMarchForDiffuse(Ray ray)\n{\n    return rayMarch(ray, MARCHING_EPSILON*2., MARCHING_MAX_DISTANCE, MARCHING_EPSILON*2.0, 1e6);\n}\n\nfloat rayMarchForShadow(Ray ray)\n{\n    const float startT = SHADOW_BIAS;\n    const float endT = MARCHING_MAX_DISTANCE;\n    const float minStep = MARCHING_EPSILON;\n    const float maxStep = 1e6;\n    // Our position on the ray (position = ray.start + ray.dir * t)\n    float t = startT;\n    float sd = 0.0;\n    bool distHasPeaked = false;\n\n    float res = 1.0;\n\n    for(int i = 0; i < MARCHING_MAX_STEPS && t < endT; i++)\n    {\n        vec3 p = ray.start + ray.dir * t;\n        vec2 sdAndMat = sdMain(p);\n        float newSd = sdAndMat.x;\n        float mat = sdAndMat.y;\n\n        if(newSd <= sd)\n        {\n            distHasPeaked = true;\n        }\n\n        sd = newSd;\n\n        if(distHasPeaked)\n        {\n            res = min(res, SHADOW_HARDNESS * sd/t);\n        }\n\n\n        t += clamp(abs(sd), minStep, maxStep);\n\n        // Are we on a surface?\n        if(sd < MARCHING_EPSILON)\n        {\n            return 0.0;\n        }\n    }\n\n    // No intersection found. Return the soft shadow result\n    return res;\n}\n\n\n\n/***********************************************\n* SHADING\n***********************************************/\n\nconst vec3 light1Direction = normalize(vec3(1.0, 1.0, -0.5));\nconst vec3 light1Color = vec3(0.5, 0.3, 0.5);\nconst vec3 light2Direction = normalize(vec3(-0.5, 0.8, -1.0));\nconst vec3 light2Color = vec3(0.3, 0.5, 0.8);\n\nconst vec3 ambientColor = vec3(0.2);\n\nfloat directionalShadow(vec3 pos, vec3 lightDir)\n{\n    return rayMarchForShadow(Ray(pos, lightDir));\n}\n\nvec3 shade(Material material, vec3 pos, vec3 n, vec3 viewDir, vec3 reflection, vec3 refraction, bool useShadows)\n{\n    float shadowLight1 = useShadows ? directionalShadow(pos, light1Direction) : 1.0;\n    vec3 light1 = shadowLight1 * max(vec3(0.), dot(n, light1Direction) * light1Color);\n\n    float shadowLight2 = useShadows ? directionalShadow(pos, light2Direction) : 1.0;\n    vec3 light2 = shadowLight2 * max(vec3(0.), dot(n, light2Direction) * light2Color);\n\n    float fresnel = clamp(pow(1. + dot(viewDir, n), 1.0/material.shininess) + max(0., material.shininess-1.), 0., 1.);\n\n    float occlusionFactor = 0.0;\n    for(float od = 0.02; od < 0.3; od += 0.1)\n    {\n        occlusionFactor += max(0., sdMain(pos + n*od).x/od);\n    }\n    occlusionFactor = pow(clamp(occlusionFactor/3., 0., 1.), 0.3);\n\n    return material.diffuse * ((light1 + light2 + ambientColor) * occlusionFactor) + reflection*fresnel + refraction*material.filtering;\n}\n\n\n\n/***********************************************\n* MAIN\n***********************************************/\n\nvec3 renderRay(Ray ray)\n{\n    MarchingResult hit = rayMarchForDiffuse(ray);\n\n    // hit?\n    if(hit.posAndMaterial.w > 0.)\n    {\n        int materialIndex = int(hit.posAndMaterial.w);\n        Material material = materials[materialIndex-1];\n        vec3 pos = hit.posAndMaterial.xyz;\n        vec3 n = getSdNormal(pos);\n        vec3 reflection = vec3(0);\n        vec3 refraction = vec3(0);\n\n        if(material.reflections)\n        {\n            vec3 reflectedRayDir = normalize(reflect(ray.dir, n));\n            Ray ray2 = Ray(pos + reflectedRayDir * 0.1, reflectedRayDir);\n            MarchingResult hit2 = rayMarchForDiffuse(ray2);\n            if(hit2.posAndMaterial.w > 0.)\n            {\n                int materialIndex2 = int(hit2.posAndMaterial.w);\n                Material material2 = materials[materialIndex2-1];\n                vec3 pos2 = hit2.posAndMaterial.xyz;\n                vec3 n2 = getSdNormal(pos2);\n                vec3 reflection2 = vec3(0);\n\n                if(material2.reflections)\n                {\n                    vec3 reflectedRayDir2 = normalize(reflect(ray2.dir, n2));\n                    Ray ray3 = Ray(pos2 + reflectedRayDir2 * 0.1, reflectedRayDir2);\n                    MarchingResult hit3 = rayMarchForDiffuse(ray3);\n                    if(hit3.posAndMaterial.w > 0.)\n                    {\n                        int materialIndex3 = int(hit3.posAndMaterial.w);\n                        Material material3 = materials[materialIndex3-1];\n                        vec3 pos3 = hit3.posAndMaterial.xyz;\n                        vec3 n3 = getSdNormal(pos3);\n                        reflection2 = shade(material3, pos3, n3, ray3.dir, vec3(0), vec3(0), false);\n                    }\n                }\n\n                reflection = shade(material2, pos2, n2, ray2.dir, reflection2, vec3(0), true);\n            }\n        }\n\n        if(material.refractions)\n        {\n            vec3 refractedRayDir = normalize(refract(ray.dir, n, 0.9));\n            Ray ray2 = Ray(pos + refractedRayDir * 2.5, refractedRayDir);\n            MarchingResult hit2 = rayMarchForDiffuse(ray2);\n            int materialIndex2 = int(hit2.posAndMaterial.w);\n            Material material2 = materials[materialIndex2-1];\n            vec3 pos2 = hit2.posAndMaterial.xyz;\n            vec3 n2 = getSdNormal(pos2);\n            refraction = shade(material2, pos2, n2, ray2.dir, vec3(0), vec3(0), true);\n        }\n\n        return shade(material, pos, n, ray.dir, reflection, refraction, true);\n    } \n    else\n    {\n        return vec3(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspectRatio;\n\n    //fragColor = vec4(vec3(voronoi2D(uv*10.0)), 1.0);\n\n    \n\n    Ray viewRay = getViewRay(fragCoord);\n\n    vec3 col = renderRay(viewRay);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}