{
    "Shader": {
        "info": {
            "date": "1464956534",
            "description": "Autores:\nLucia Cubel\nHector Suarez\n\nPractica 1 de PGATR \nShader de San Valentin 2016: La Galeria de Cupido (shader2 comentado por no ser igual al del video)\nVideo completo del shader en el enlace\nhttps://youtu.be/7ChTuGi6pWc",
            "flags": 0,
            "hasliked": 0,
            "id": "MsySzG",
            "likes": 0,
            "name": "Galeria de Cupido",
            "published": 3,
            "tags": [
                "heart",
                "valentine",
                "pgatr",
                "love",
                "migjrv"
            ],
            "usePreview": 1,
            "username": "hecLu",
            "viewed": 646
        },
        "renderpass": [
            {
                "code": "/*****************************************************************************************\n*Shader realizado para la asignatura Procesadores Graficos y Aplicaciones en Tiempo Real\n*\n* Autores:\n* LucÃ­a Cubel\n* HÃ©ctor SuÃ¡rez\n*\n*Shader de san valentin \"La GalerÃ­a de Cupido\"\n*\n*Video completo del shader en el enlace https://www.youtube.com/watch?v=7ChTuGi6pWc\n******************************************************************************************/\n\n#define PI 3.14159265359\n#define zoom .45\n#define offset vec2(1.,1.1)\n\n#define iterations 9\n#define scale 1.3+iMouse.y/iResolution.y\n#define minscale .4\n#define trans .75-iMouse.x/iResolution.x\n\n#define orbittraps vec3(3.,2.,1.)\n#define trapswidths vec3(1.5,1.,.5)\n\n#define trap1color vec3(1.00,0.40,0.10)\n#define trap2color vec3(0.35,0.25,1.00)\n#define trap3color vec3(1.,1.,0.05)\n\n#define trapsbright vec3(1.2,1.5,1.)\n#define trapscontrast vec3(10.)\n\n#define rotspeed .2\n\n#define saturation .5\n#define brightness 2.\n#define contrast 1.5\n\n#define antialias 4. //max 4\n\n#define numRadios 7\n#define numCapas 3\n#define numCapas2 20\nvec2 fragCoord2;\n\nvec2 animatePos(vec2 pos){\n\tfloat tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + pos.y*0.5)*exp(-tt*4.0);\n    pos *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\treturn pos;\n}\n\n/*****************************************************************************************\nCodigo obtenido del sahder \"Â¨Heart\" iq\n******************************************************************************************/\n\n//funcion para pintar un corazon\n//pide origen del corazon, fragmento con el que se trabaja, un factor de forma\n//que afectara al tamaÃ±o del corazon y el color de fondo\nvoid corazon(vec2 origen, vec2 posicion,float tamanio,inout vec3 color){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    color = mix( color, hcol, smoothstep( -0.01, 0.01, d-r) );\n}\n\n//funcion para pintar un corazon\n//pide origen del corazon, fragmento con el que se trabaja, un factor de escalado\n//que afectara al tamaÃ±o del corazon, el color de fondo y el color del corazon\nvec3 corazon2(vec2 origen, vec2 posicion,float tamanio,vec3 color,vec3 colorCorazon){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\t\n    vec3 result = mix( color, colorCorazon, smoothstep( -0.01, 0.01, d-r) );\n\treturn result;\n}\nvec3 corazon3(vec2 origen, vec2 posicion,float tamanio,vec3 color){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    color = mix( color, hcol, smoothstep( -0.01, 0.01, d-r) );\n\treturn color;\n}\nvoid corazon4(vec2 origen, vec2 posicion,float tamanio,inout vec3 color){\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    color = mix( color, hcol, -0.1-smoothstep( -0.06, 0.001, d-r) );\n}\nfloat rand(vec2 n) \n{\n\treturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 );\n}\nfloat noise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) \n{\n\tfloat total = 0.0, amplitude = 0.5;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= .5;\n\t}\n\t\n\treturn total;\n}\nvec3 getColor(){\n\tvec2 p = vec2(fragCoord2.xy / iResolution.xy);\n\tvec2 r =  3.0*vec2(fragCoord2.xy + 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\tret = vec3(sin(v+0.5*PI)*0.1, sin(v)*0.3+0.2, 1.0);\n\t\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n\treturn ret;\n}\nvoid corazonFbm(vec2 origen, vec2 posicion,float tamanio,inout vec3 color){\n\t//Centrar el cÃ­rculo\n\tvec2 v =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 w = v*v;\n\tfloat centerCirculito = w.x+w.y;\n\tvec2 p = posicion-origen;\n\t// parte donde se calcula la forma\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n\td*=tamanio;\n\n\t//Color original + modificado aniadiendo \"Fractional Brownian Motion\"\n\tfloat q = fbm(p);\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(2.0*q*1.0,4.0*q*0.5*r-1.0,3.0*q*0.3-2.0)*s;\n\t\n\t//RatÃ³n\n\tvec2 center;\n\tvec3 col1 = vec3(0,0,0); //Color del cursor\n\tvec3 col4 = vec3(0,0,0); // P!nk\t\n\t\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x,clamp(iMouse.y / iResolution.y,0.0,1.0),(cos(iMouse.x / iMouse.y)+1.0)*0.5);\n\tvec3 ret = bgCol;\n\t//Forma del cursor.\tPodrÃ­a estar dentro de una funciÃ³n.\t\n\t\n\tvec2 m = (fragCoord2.xy-iMouse.xy)/min(iMouse.y,iMouse.x);\n\t\n\tfloat am = (atan(m.x,m.y)/3.141593);\n    float rm = length(m);\n    float hm = abs(am);\n    float dm = (13.0*hm - 22.0*hm*hm + 10.0*hm*hm*hm)/(6.0-5.0*hm)*1.0/4.0;\t\n\t\n    vec3 col2 = mix( color, hcol, -0.9*smoothstep( -0.2, 0.001, dm-rm) );\t\n\t\n    vec3 col= mix( bgCol, hcol, smoothstep( -0.8, 0.1, d-r) );\n\tcol += ret+col2;\t\n\tif (centerCirculito < 0.00004)//pequeÃ±o para que no se vea\n\t{\n\t col = hcol;\n\t}\n\tcolor=col;\n}\nvec2 rotate(vec2 p, float angle) {\nreturn p*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n}\nvec3 caleidoscopio(vec2 uv){\n\tvec3 aacolor=vec3(0.);\n\t\n\tfloat aspect=iResolution.x/iResolution.y;\n\tvec2 pos=uv;\n\tpos.x*=aspect;\n\tfloat zoo=1./zoom;\n\tpos*=offset;\n\tpos*=zoo; \n\tvec2 pixsize=1./iResolution.xy*zoo;\n\tpixsize.x*=aspect;\n\tfloat av=0.;\n\tvec3 its=vec3(0.);\n\tfloat t=iTime*rotspeed;\n\tfor (float aa=0.; aa<16.; aa++) {\n\t\tvec3 otrap=vec3(1000.);\n\t\tif (aa<antialias*antialias) {\n\t\t\tvec2 aacoord=floor(vec2(aa/antialias,mod(aa,antialias)));\n\t\t\tvec2 z=pos+aacoord*pixsize/antialias;\n\t\t\tfor (int i=0; i<iterations; i++) {\n\t\t\t\tz=abs(z)-aspect*trans;\n\t\t\t\tz=rotate(z,-t+3.3);\n\t\t\t\tfloat l=dot(z,z);\n\t\t\t\tz/=clamp(l,minscale,1.);\n\t\t\t\tz=z*scale-1.;\n\t\t\t\tvec3 ot=abs(vec3(l)-orbittraps);\n\t\t\t\tif (ot.x<otrap.x) {\n\t\t\t\t\totrap.x=ot.x;\n\t\t\t\t\tits.x=float(iterations-i);\t\n\t\t\t\t}\n\t\t\t\tif (ot.y<otrap.y) {\n\t\t\t\t\totrap.y=ot.y;\n\t\t\t\t\tits.y=float(iterations-i);\t\n\t\t\t\t}\n\t\t\t\tif (ot.z<otrap.z) {\n\t\t\t\t\totrap.z=ot.z;\n\t\t\t\t\tits.z=float(iterations-i);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\totrap=pow(max(vec3(0.),trapswidths-otrap)/trapswidths,trapscontrast);\n\t\tits=its/float(iterations);\n\t\tvec3 otcol1=otrap.x*pow(trap1color,3.5-vec3(its.x*3.))*trapsbright.x;\n\t\tvec3 otcol2=otrap.y*pow(trap2color,3.5-vec3(its.y*3.))*trapsbright.y;\n\t\tvec3 otcol3=otrap.z*pow(trap3color,3.5-vec3(its.z*3.))*trapsbright.z;\n\t\taacolor+=(otcol1+otcol2+otcol3)/3.;\n\t}\n\taacolor=aacolor/(antialias*antialias);\n\tvec3 color=mix(vec3(length(aacolor)),aacolor,saturation)*brightness;\n\tcolor=pow(color,vec3(contrast));\t\t\n\tcolor*=vec3(1.2,1.15,1.);\n\tcolor*=1.-pow(max(0.,max(abs(uv.x),abs(uv.y))-.4)/.1,8.);\n\treturn color;\n}\n//funcion que dibuja un rombo rojo\nvoid rombo(vec2 r,vec2 centro,float factorD,float xMax,inout vec3 pixel){\n\t//comprobamos que el punto se encuentra dentro de unos valores maximos\n\tvec2 punto=vec2(abs(r.x-centro.x),abs(r.y-centro.y));\n\tfloat pinta=step(punto.x,xMax)*step(punto.y,(xMax/factorD));\n\t//Si el punto no esta dentro de las cotas, pinta vale 0\n\t//y se devuelve el color original del pixel\n\t\n\t//evaluamos si el punto esta dentro del rombo. Para ello se divide el area\n\t//del rombo en cuadrantes, y se evalua solo aquellos puntos contenidos en la\n\t//zona comprendida por las x e y positivas. Se aplica valor absoluto al punto\n\t//r para evaluar simultaneamente si el valor se encuentra dentro de uno de los\n\t//cuadrantes\n\tfloat valorX=xMax-(factorD*punto.y);\n\t//Para hacer la evaluacion se traza una recta cuya ecuacion es la siguiente:\n\t//x=xMax-factorD*y\n\t//Se obtine la x tomando la y del punto introducido. Si la x resultante es\n\t//mayor o igual que la x del punto pasado entonces el punto pertenece al rombo\n\tif(valorX>=punto.x){\n\t\tpixel=(pixel*abs(pinta-1.0))+(vec3(1.0,0.0,0.0)*pinta);\n\t}\n}\n//pinta un circulo. Fragmento de codigo extraido de los tutoriales\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tfloat m=1.0 - smoothstep( radius-0.02, radius+0.02, length(r-center));\n\tpixel=mix(pixel,color,m);\n}\n//funcion que evalua el estado de la luna\nvoid estadoLuna(vec2 r,vec2 centroEstatico,vec2 centroDinamico,float radio,inout vec3 luna,inout vec3 pixel){\n\tluna=vec3(1,1,0.5);\n\t//se toman dos centros el de la luna que es estatico, un que se mueve de\n\t//acuerdo trancurre el tiempo. Si el punto se encuentra a una distancia menro\n\t//que el radio introducido se cambia el color de la luna en ese punto\n\t//por otro que simula que la luna esta desapareciendo\n\tif( (length(r-centroEstatico) < radio+0.02)&&(length(r-centroDinamico) < radio+0.02)) {\n\t\tluna=vec3(0,0,0.05);\n\t}\n}\n//funcion que pinta una luna\nvoid luna(vec2 r, float t, inout vec3 pixel){\n\tvec3 colorLuna;\n\tvec2 centroLuna=vec2(-7.0, 5.3);\n\tfloat radio=1.9;\n\tfloat y=centroLuna.y;\n\tfloat x=t;\n\tx =\t(0.0-mod(x,41.0)-15.0)*0.2;\n\tvec2 cicloLuna=vec2(x,y);\n\testadoLuna(r,centroLuna,cicloLuna,radio,colorLuna,pixel);\n\tdisk(r, centroLuna, radio, colorLuna, pixel);\n}\n//Worley+plasma azul\nvec3 water(){\n\tvec2 pos = gl_FragCoord.xy / iResolution.yy;\n\tpos += vec2(sin(pos.x * 12.0 + iTime) * 0.017 + sin(pos.y * 27.0 + 2.0 * iTime) * 0.015);\n\n\tfloat numTiles = 10.0;\n\t\n\tvec2 curretTile = floor(pos * numTiles);\n\tpos = fract(pos * numTiles) + 1.0;\n\t\n\tfloat minDist = 2.0;\n\t\n\tfor(float y = -1.0; y < 2.0; y++) {\n\n\t\tfor(float x = -1.0; x < 2.0; x++) {\n\t\t\tfloat po = rand( vec2(curretTile.x + x, curretTile.y + y) );\n            //Animacion basada en un shader de iq (https://www.shadertoy.com/view/ldl3W8)\n            //con nuestro pequeÃ±o toque personal\n\t\t\tpo=0.5 + 0.4*cos( iTime + 6.2831*po );\n\t\t\tvec2 point = vec2( (1.0 + x) + po , (1.0 + y) + (1.0 - po) );\n\t\t\t\n\t\t\tfloat dist = distance(pos, point);\n\t\t\tfloat cond=float(minDist > dist);\n\t\t\tminDist =minDist*(1.0-cond)+dist*cond;\n\t\t}\n\n\t}\n\tvec3 color=mix(getColor()*0.4,getColor(),smoothstep(0.0,1.0,clamp(minDist*0.9,0.0,1.0)));\n\treturn color;\n}\n////////////////////////////////////////////////////////////////////////////////////////////\nfloat lineas(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\t}\n\treturn ret;\n}\nfloat lineas2(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret -= 2.-smoothstep(0.01, 0.015, abs(r.x));\n\t}\n\treturn ret;\n}\nfloat lineasB(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret -= 2.-smoothstep(0.001, 0.015, abs(r.x));\n\t}\n\treturn ret;\n}\nvec3 parteB(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); // \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=mod((float(i)*incrementoAngulo+t),2.0*PI);\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineasB(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\nfloat lineasC(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret += 1.+smoothstep(0.001, 0.101, abs(r.x));\n\t}\n\treturn ret;\n}\nvec3 parteC(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=float(i)*incrementoAngulo-mod(t,2.0*PI);\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineasC(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\nfloat lineasD(vec2 r) {\n\tfloat ret = 0.0;\n\tif(r.y>0.0){\n\t// Draw the axes\n\tret -= 1.-smoothstep(0.001, 0.503, abs(r.x));//cambio grosor y smooth de lineas de telaraÃ±a\n\t}\n\treturn ret;\n}\nvec3 parteD(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=float(i)*incrementoAngulo+mod(t,2.0*PI);\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineasD(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\nvec3 shader1(){\n\tfloat t=iTime;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 p2=p;\n\t\n\tp.y /= 0.25;\n\tp.x/=0.25;\n\t\n\t\n\tvec3 color = vec3(2.0,0.8,0.3-1.07*p.y)*(1.0-0.25*length(p));\t//cambia valores de fondo y hace gradiente\n\t\n\n\n\n\tfloat y=0.5;\n\tfloat x=t*0.5;\n\tx =\t(-mod(x,4.5)+2.1);\n\tvec2 origen1=vec2(x,y);\n\tx=t*0.5;\n\tx =\t(mod(x,4.5)-2.1);\n\tvec2 origen2=vec2(x,y);\n\t//para trabajar mejor con la operacion modulo, se multiplica la coordenada\n\t// actual ,comprendiada entre -1 y 1, por un entero y se desacha la parte \n\t//decimal\n\t//pintado por franjas\n\tint posY= int(floor(p.y*4.0));\n\t\n\t//la segunda entrada del modulo indicara la division del espacio\n\tif(int(mod(float(posY),2.0))==0){\n\t\tcorazon(origen1,p,1.00,color);\n\t}else{\n\t\tcorazon(origen2,p,1.0,color);\n\t}\n\treturn color;\n}\n/*\nvec3 shader2(){\n\tvec2 p = vec2(fragCoord2.xy / iResolution.xy);\n\tvec2 p2 = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n\tr = r * 8.0;\n\tvec3 ret;\n\t//pintamos el cielo\n\tret = texture(iChannel0, p).xyz*vec3(0.5,0.5,0.7);\n\tif(p.y < 1./3.){\n\t// Plasma de color rosa. \n\t//Simula amor(Fragmento de codigo extraido de los tutoriales)\n\t\tvec3 colorCielo=ret;\n\t\tfloat v1 = sin(r.x +t);\n\t\tfloat v2 = sin(r.y +t);\n\t\tfloat v3 = sin(r.x+r.y +t);\n\t\tfloat v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\t\tfloat v = v1+v2+v3+v4;\n\t\tv *= 1.0;\n\t\tret = vec3(1.0, clamp(sin(v+0.5*PI),0.0,0.7), 1.0);\n\t\tret = 0.3+ 0.7*ret;\n\t\tfloat m = smoothstep(0.15, 0.3, p.y);\n\t\tret = mix(ret, colorCielo, m);\n\t}\n\tvec3 pixel = ret;\n\t//pintamos la luna\n\tluna(r,t,pixel);\n\tfloat intervaloTiempo=2.0;\n\t//evaluamos si hay que pintar rombos\n\tint mostrar=1;\n\tif(mod(floor(t),intervaloTiempo)==0.0){\n\t\tmostrar=int(abs(float(mostrar-1)));\n\t}\n\t//pintamos 2 rombos(+18 anios) parpadeantes\n\tif(mostrar==1){\n\t\trombo(r, vec2(8.0,6),0.5,0.5,pixel);\n\t\trombo(r, vec2(9.0,6),0.5,0.5,pixel);\n\t}\n\tfloat escala=0.2;\n\tfloat y=mod(t,2.0)-1.0;\n\tvec2 pos1=vec2(sin(y*8.0)*0.2-0.8,y);\n\tpixel=mix(corazon3(pos1,p2,escala,pixel),pixel,smoothstep(-1.0,2.0,y));\n\t\n\ty=mod(t,1.5)-1.0;\n\tvec2 pos2=vec2(sin(y*8.0)*0.3-0.6,y);\n\tpixel=mix(corazon3(pos2,p2,escala,pixel),pixel,smoothstep(-1.0,1.0,y));\n\t\n\ty=mod(t,4.0)-1.0;\n\tvec2 pos3=vec2(sin(y*8.0)*0.1-0.5,y);\n\tpixel=mix(corazon3(pos3,p2,escala,pixel),pixel,smoothstep(-1.0,3.0,y));\n\t\n\ty=mod(t,2.0*PI)-1.0;\n\tvec2 pos4=vec2(sin(y*8.0)*0.2-0.3,y);\n\tpixel=mix(corazon3(pos4,p2,escala,pixel),pixel,smoothstep(-1.0,2.0*PI-1.0,y));\n\t\n\ty=mod(t,2.5)-1.0;\n\tvec2 pos5=vec2(sin(y*8.0)*0.2+0.1,y);\n\tpixel=mix(corazon3(pos5,p2,escala,pixel),pixel,smoothstep(-1.0,1.5,y));\n\t\n\ty=mod(t,PI)-1.0;\n\tvec2 pos6=vec2(sin(y*8.0)*0.2+0.5,y);\n\tpixel=mix(corazon3(pos6,p2,escala,pixel),pixel,smoothstep(-1.0,PI-1.0,y));\n\t\n\ty=mod(t,3.0)-1.0;\n\tvec2 pos7=vec2(sin(y*8.0)*0.2+0.7,y);\n\tpixel=mix(corazon3(pos7,p2,escala,pixel),pixel,smoothstep(-1.0,2.0,y));\n\t\n\treturn pixel;\n}*/\nvec3 shader3(){\n\tvec3 color=(parteB()+parteC()+parteD())/1.5;\n\treturn color;\n}\nvec3 shader4(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = water();\n\tr=animatePos(r);\n\tp=animatePos(p);\n\t\n\tvec3 color1 = vec3(0.8, 0.8, 0.8); \n\tfloat incrementoAngulo=(2.0/float(7))*PI;\n\tfor(int i=0;i<numRadios;i++){\n\t\tfloat angle=float(i)*incrementoAngulo;\n\t\tvec2 q=vec2(0.0,0.0);\n\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\tq=-q;\n\t\tcolorFondo = mix(colorFondo, color1, lineas(q) );\n\t}\n\t\n\tfloat tamanioMax=1.1;\n\tfloat tamanioMin=0.4;\n\tfloat escalaHilo=0.25;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.15);\n\tfor(int i=0;i<numCapas;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tcorazon4(posicion,p,tamanioMin,colorFondo);\n\treturn colorFondo;\n}\n\nvec3 shader5(){\n\tfloat t=iTime;\n\tvec2 r =  2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec3 colorFondo = vec3(1.050*p.y,0.8-0.2*p.y*0.5,0.7-0.57*p.y)*(1.05-0.25*length(p)); //cambiar valores vec3 //primer valor de vec3 //segundo valor\n\tvec3 color1 = vec3(0.78, 0.8, 0.7); // 0.7 mas rosita\n\tfloat t2=mod(t,14.0);\n //cambiando el num de radios hace una especie de superposicion, en este caso de 6 parece que salen rayos y vienen hacia tÃ­\n\tfloat incrementoAngulo=(2.0/float(7))*PI; //cambiando el angulo salen cosas\n\tfor(int i=0;i<numRadios;i++){\n\t\tif(i<(int(clamp(t2,0.0,7.0))-int(t2/7.0)*int(mod(t2,7.0)))){\n\t\t\tfloat angle=float(i)*incrementoAngulo;\n\t\t\tvec2 q=vec2(0.0,0.0);\n\t\t\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\t\t\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\t\tq=-q;\n\t\t\tcolorFondo = mix(colorFondo, color1, lineas2(q) );\n\t\t}\n\t}\n\t\n\tfloat tamanioMax=3.5; //\n\tfloat tamanioMin=0.082; //mas pequeÃ±o el corazon\n\tfloat escalaHilo=0.15;\n\tfloat anchura=(tamanioMax-tamanioMin)/float(numCapas2);\n\tfloat grosorHilo=anchura*escalaHilo;\n\tvec2 posicion=vec2(0.0,0.01);//ajustar el corazon al centro\n\tfor(int i=0;i<numCapas2;i++){\n\t\tfloat tamanioCorazon=tamanioMax-(float(i)*anchura);\n\t\tvec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);\n\t\tcolorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);\n\t}\n\tvec2 pos=(2.0*iMouse.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tfloat escalaMax=1.2;\n\tcorazon(posicion,p,escalaMax-clamp(length(pos),0.0,escalaMax),colorFondo);\n\treturn colorFondo;\n}\nvec3 shader6(){\n\tvec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tvec2 uv=fragCoord2.xy / iResolution.xy - 0.5;\n\t\n\tvec3 color=caleidoscopio(uv);\n\tvec2 centerHeart;\n\tcenterHeart = vec2(iResolution.x/2., iResolution.y/2.);\n\tfloat radius = 20.0;\t\n\t\n\t//Si el cursor esta dentro de la circunferencia, el corazÃ³n se anima.\n\tif( length(iMouse.xy-centerHeart)<radius ) {\t\t\n\t\tfloat tt = mod(iTime,1.5)/1.5;\n\t\tfloat ss = pow(tt,.2)*0.5 + 0.5;\n\t\tss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n\t\tp *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\t}\n\tvec2 posicion=vec2(0.0,0.2);\n\tfloat escala=1.0;\n\tcorazonFbm(posicion,p,escala,color);\n\treturn color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tfloat momento=float(mod(t,120.0));\n    fragCoord2=fragCoord;\n\tvec3 color=vec3(0.0);\n    \n\tif(momento<=15.0){\n\t\tcolor=shader1();\n\t}else if(momento>15.0&&momento<22.0){\n\t\tcolor=mix(shader1(),shader3(),smoothstep( 15.0, 22.0, momento));\n\t\t\n\t}else if(momento>=22.0&&momento<=37.0){\n\t\tcolor=shader3();\n\t\t\n\t}else if(momento>37.0&&momento<44.0){\n\t\tcolor=mix(shader3(),shader4(),smoothstep( 37.0, 44.0, momento));\n\t\t\n\t}else if(momento>=44.0&&momento<=59.0){\n\t\tcolor=shader4();\n\t\t\n\t}else if(momento>59.0&&momento<66.0){\n\t\tcolor=mix(shader4(),shader5(),smoothstep( 59.0, 66.0, momento));\n\t\t\n\t}else if(momento>=66.0&&momento<=81.0){\n\t\tcolor=shader5();\n\t\t\n\t}else if(momento>81.0&&momento<88.0){\n\t\tcolor=mix(shader5(),shader6(),smoothstep( 81.0, 88.0, momento));\n\t}else if(momento>=88.0&&momento<=103.0){\n\t\tcolor=shader6();\n\t\t\n\t}else if(momento>103.0&&momento<120.0){\n\t\tcolor=mix(shader6(),shader1(),smoothstep( 103.0, 120.0, momento));\n\t}\n\tfragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}