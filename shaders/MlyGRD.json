{
    "Shader": {
        "info": {
            "date": "1473465863",
            "description": "All main functions taken from shadertoy user.",
            "flags": 64,
            "hasliked": 0,
            "id": "MlyGRD",
            "likes": 8,
            "name": "â™« Crateria - 1st anniversary",
            "published": 3,
            "tags": [
                "raymarching",
                "sky",
                "landscape",
                "old"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "\n// S h a d e r T o y - - - C h r o m e   E x t e n s i o n\n\n// https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl\n\n\n// Do not copy. Parts of this code are licensed. \n\n\nvec3 lightDir = vec3( -12., 0.1, 12.);\nvec3 lightColour = vec3(1.8, 1.0, 0.3); \n\n\nvec3 cameraPos = vec3(10., 2.9, 0.);\nvec3 cameraLookat = vec3(0., -7.0, 0.);\n\nfloat specularHardness = 1.4;\n\n\n\nfloat specular = 2.1;\nfloat diffuse = 1.;\nfloat len;\nfloat glow = 0.;\n\n#define GAMMA 1.4\n#define CONTRAST 1.0\n#define SATURATION 1.\n#define BRIGHTNESS 1.4\n\n#define RAY_DEPTH 96\n#define MAX_DEPTH 52.0\n#define DISTANCE_MIN 0.01\n#define PI 3.14159265\n\nint STAGE = 1;\n\nvec3 boxPosition = vec3(0.0);\n\nconst vec2 delta = vec2(0.001, 0.);\n\nfloat raise = 0.;\n\n\nvec4 cubePlasma (vec2 coord, vec3 p) {\n    \n    float \n        k = iTime * 3.0,\n        as = 4.78207464329,\n    \tfd = 12.18910931609,\n    \tas1 = 2.839499561581 / 24.0 + sin(k) * 0.02,\n    \tfd2 = 2.188989119604,\n    \tps = -5.624243766069,\n    \tps2 = 9.393007904291,\n    \tp1 = sin(k / ps) * 4.0,\n    \tp2 = sin(k / fd) * 3.0,\n    \tt3 = sin(k / fd2) + cos(as1),\n        t4 = sin(k / ps);    \n    \n    coord.x = floor(coord.x * 16.0) / 16.0;\n    coord.y = floor(coord.y * 16.0) / 16.0;\n    \n    float x = sin(p1 + coord.x) * sin(p2 + coord.y) + sin(t3 + coord.x) * sin(t4 + coord.y) * -p.x;\n    \n    float r = (0.87 + sin((x / as1 ) / 8.0) + sin(x / as1)) / 2.0;\n    float g = (0.42 + sin(x / as1)) / 2.0; \n    float b = (0.77 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n\n    if (\n        coord.y <= -0.9 || coord.y >= 0.9 ||\n        coord.x <= -0.9 || coord.x >= 0.9    \n    ) { \n        r = 1.;  \n        b = 1.; \n        g = 1.; \n    }\n    \n    \n     \n    vec4 color = vec4(vec3(r, g, b) * 2.0, 1.0);\n     \n    return color;\n    \n}\nvec4 boxmap( in vec3 p, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = cubePlasma(p.yz, p);\n\tvec4 y = cubePlasma(p.zx, p);\n\tvec4 z = cubePlasma(p.xy, p);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n\nmat3 xrotate(float t) {\n\treturn mat3(\n        \t\t1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t)\n    \t\t);\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(\n        \t\tcos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t)\n    \t\t);\n}\n\nmat3 zrotate(float t) {\n    return mat3(\n        \t\tcos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0\n    \t\t);\n}\n\nmat3 fullRotate(vec3 r) { \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nvec2 Dist(vec3 pos)\n{\n   //float t = iTime / 10.;\n    float n = noise(pos.xz / 4.) * 1.;\n    float height = 1. + max(\n       (n * 4.), \n       abs(2. * sin(abs(n))));\n   \n    float dust = noise(pos.xz * 4.) / 20. ;\n    \n    if (abs(pos.x) < 4.) height += cos(((pos.x * 3.14)) / 8.) * 4. + dust;\n       \n    height += dust + noise(pos.xz) / 4.;\n    height += noise(pos.xz / 20.) * 12. - 2.;\n    \n    float plane = Plane(pos - vec3(0., -height, 0.), vec3(0., 1, 0.));\n    \n    vec3 cpos = pos; \n    vec3 bpos = pos;\n    \n    bpos.y += 1.4 + sin(iTime) * 3.;\n    \n    boxPosition = \n        bpos *= fullRotate(vec3(iTime));\n    \n    cpos.y = cpos.y * 2. + 3.8;\n    \n    float crater = length(cpos)- 10. - n - dust * 4. - sin(n) *  2.;\n    \n    vec2 map = opS(\n        vec2(plane, 1.0), \n        vec2(crater, -1.0)\n    );\n    \n    vec2 box = vec2(sdBox(bpos, vec3(1.0)), 3.0);\n    vec2 wave = vec2(length(pos)- 8., 4.);\n    \n    map = opU(\n        map, \n        box\n    ); \n \n //   if (pos.y > 4. + n ) return vec2(0.0, 4.0);\n    return map;\n} \n\nvec3 GetNormal(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = Dist( pos + delta.xyy ).x - Dist( pos - delta.xyy ).x;\n   n.y = Dist( pos + delta.yxy ).x - Dist( pos - delta.yxy ).x;\n   n.z = Dist( pos + delta.yyx ).x - Dist( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n// Original method by David Hoskins\nvec3 Sky(in vec3 rd, bool showSun)\n{\n   \n   float sunSize = 13.1;\n   float sunAmount = max(dot(rd, lightDir), 0.0);\n   float v = pow(1.2 - max(rd.y, 0.0), 1.);\n   vec3 sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32) * 1.0, v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 0.5 + lightColour * min(pow(sunAmount, 1512.0)* sunSize, sunSize / 24.);\n    \n    //if (showSun) sky += texture(iChannel0, vec2(v, rd.x) * 4.).rgb / 4.;\n   //if (showSun) sky -= fract(v /  4.) * vec3(0.3, 0.2, 0.1) ;//- noise(rd.xy * 100.);\n   return clamp(sky, 0.0, 1.0);\n}\n\n// Fog routine - original by IQ\nvec3 Fog(vec3 rgb, vec3 rd, float distance)   // camera to point distance\n{\n    const float b = 0.1;\n    \n    //b +=  * 2.;\n    \n    float fogAmount = 1.0 - exp(-distance * b);\n    vec3 fogColor = Sky(rd, false);\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// Based on a shading method by Ben Weston.\nvec3 Shading(vec3 pos, vec3 rd, vec3 norm, vec3 ro)\n{\n   vec3 light = lightColour * max(0.0, dot(norm, lightDir));\n   vec3 view = normalize(-rd);\n   vec3 heading = normalize(view + lightDir);\n   float spec = 0.0;//pow(max(0.0, dot(heading, norm)), specularHardness);\n   \n   float fresnel = .3;\n\n   light = clamp((diffuse * light) + (spec * specular * lightColour), 0.0, 1.0) * (1.0-fresnel);\n   if (fresnel > 0.01)\n   {\n      vec3 refrd = reflect(rd, norm);\n      light += Sky(refrd, false) * fresnel;\n   }\n   \n   light = Fog(light, rd, length(ro-pos));\n   vec3 cc = vec3(1.0);// - texture(iChannel2, norm.xz * 8.).rrr / 8.;\n   return cc * light;\n} \n    \n// Original method by David Hoskins\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(GAMMA));\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\nvec4 March(vec3 ro, vec3 rd)\n{\n   float t = 1.0;\n   float minDist = 1000.;\n   vec2 d = vec2(0.);\n    \n    \n   for (int i=0; i<RAY_DEPTH; i++)\n   {\n      vec3 p = ro + rd * t;\n      d = Dist(p);\n      \n      if (d.y == 3.0) {\n           minDist = min(minDist, d.x * (4. + fract(iTime)));\n           glow = pow( 1. / minDist, 2.);\n      }\n        \n      if (abs(d.x) < DISTANCE_MIN && d.y != 4.0)\n      {\n         return vec4(p, d.y);\n      }\n      t += d.x * .76;\n      if (t >= MAX_DEPTH) break;\n   }\n   return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    float t = mod(iTime, 120.);\n    \n    raise = mod(t * 4., 1250.);\n    \n    float stageT = mod(t / 12., 6.);\n    \n    STAGE = int(ceil(stageT));\n    \n    if (STAGE == 1) { \n     \tcameraPos.x = 2. * t;\n        cameraPos.y = 2.2;\n        cameraPos.z = 10. - t * 3. ;\n        cameraLookat = cameraPos + vec3(sin(t /4.) * 34., -5., cos(t / 2.2) * 50.);\n    }\n    \n    if (STAGE == 2) { // canion\n     \tcameraPos.x = 0.;\n        cameraPos.y = 1.0;\n        cameraPos.z = t * 5. ;\n        cameraLookat = cameraPos + vec3(sin(t / 6.) * 2., -2.0, 8.);\n    }\n    \n\tif (STAGE == 3) {\n        cameraPos.y = 3.0;\n   \t\tcameraPos.x = cos(t / 5. + iMouse.x/ 300.) * 19.; \n   \t\tcameraPos.z = sin(t / 5. + iMouse.x/ 300.) * 17. ; \n        cameraLookat = vec3(0., -4.0, 0.);\n    }\n   \n    if (STAGE == 4) { \n     \tcameraPos.x = 10. + sin(t/ 4.) / 3.;\n        cameraPos.y = 1.2 + sin(t/ 4.) / 3.;\n        cameraPos.z = 10.;\n        cameraLookat = vec3(-14., -9.0, -52. - sin(t / 6.) * 10.);\n    }\n    \n    if (STAGE == 5) { // canion\n     \tcameraPos.x = t * 2.;\n        cameraPos.y = 1.5;\n        cameraPos.z = t * 3. ;\n        cameraLookat = cameraPos + vec3(sin(t) * 3., -8.0, 18.);\n    }\n    \n    if (STAGE == 6) { // canion\n     \tcameraPos.x = sin(t/ 8. ) * sin(t / 1000.+ 2.) * 200. + 8. ;\n        cameraPos.y = 3.5;\n        cameraPos.z = cos(t / 8. ) * sin(t / 100.+ 1.) * 20. + 4.;\n        cameraLookat = vec3(0.);\n    }\n       \n    \n   cameraPos.y += sin(t * 2.) / 12.;\n   cameraPos.z += cos(t * 2. + 2.) / 12.;\n    \n   cameraLookat.y += sin(t * 2.) / 8.;\n    \n   lightDir = vec3( sin(t / 100.) * 200., sin(t / 100.) * 114., cos(t / 100.) * 200.); \n    \n   len = lightDir.x * lightDir.x + lightDir.y* lightDir.y + lightDir.z*lightDir.z;\n   lightDir *= 1. / sqrt(len); \n   \n   vec3 ro = cameraPos;\n   vec3 rd = normalize(GetRay(cameraLookat - cameraPos, p));\n    \n   vec4 res = March(ro, rd);\n    if (res.a == 1.0) {\n        res.rgb = clamp(Shading(res.rgb, rd, GetNormal(res.rgb), ro).rgb, 0.0, 1.0);\n        \n    } \n    if (res.a == 3.0) {\n        glow = fract(iTime * .835) > 0.1 ? 0.0 : 1.0; \n        res.rgb = boxmap(boxPosition, 2.0).rgb / 2.;\n    }\n\n    if (res.a == 0.0) res.rgb = Sky(rd, true);\n    \n    float glowSize = 4.;//+ mod(iTime * .835, 5.);\n    \n    float fade = fract(stageT) > 0.75 ? (fract(stageT) - 0.75) * 4. : 0.;\n    fade = fract(stageT) < 0.1 ? 1. - ((fract(stageT)) * 10.) : fade;\n    vec4 color = (vec4(res.rgb, 1.0) + glow * glowSize) * (1. - fade); \n    \n    color.rgb = PostEffects(color.rgb, p);\n    fragColor = color; \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 4664,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/johnfaustus/somewhere-in-time-and-space"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}