{
    "Shader": {
        "info": {
            "date": "1572507740",
            "description": "Be spooky.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyGWK",
            "likes": 17,
            "name": "Hallomeowy",
            "published": 3,
            "tags": [
                "glow",
                "spooky"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 736
        },
        "renderpass": [
            {
                "code": "#define PI 3.1416\n#define TERRAIN_PATTERN 4.0*sin(12.0*pos.x)+sin(20.0*pos.y)+sin(15.0*pos.z)\n#define SPEED aTime*0.2\n#define MAX_DIST 40.0\n#define MAX_STEP 60\n#define LIGHT_DIRECTION vec3(0.8,0.2,1.0)\n#define LIGHT_INTENSITY vec3(0.5,1.0,2.0)*2.0\n#define SKY_COLOR vec3(0.01, 0.01, 0.02)\n#define TERRAIN_COLOR vec3(0.01,0.02,0.03)\n#define GLOW_COLOR vec3(0.1,0.85,1.2)\n#define RIM_POWER 0.25\n#define AA_SIZE 1\n\nvec3 rotateY(vec3 p, float rad) {\n    p.x = cos(rad)*p.x + sin(rad)*p.z;\n    p.z = -sin(rad)*p.x + cos(rad)*p.z;\n    return p;\n}\n\nvec3 rotateZ(vec3 p, float rad) {\n    p.x = cos(rad)*p.x - sin(rad)*p.y;\n    p.y = sin(rad)*p.x + cos(rad)*p.y;\n    return p;\n}\n\nfloat sdSphere(in vec3 pos, in float r)\n{\n    return length(pos)-r;\n}\n\n//https://iquilezles.org/articles/ellipsoids\nfloat sdElipsoid(in vec3 pos, in vec3 r)\n{\n    float k0 = length(pos/r);\n    float k1 = length(pos/r/r);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return min(a,b) - h*h*0.25/k;\n}\n\nfloat smax(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return max(a,b) + h*h*0.25/k;\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lim )\n{\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat tombStone(vec3 p) {\n    float b = 4.0;\n    vec3 rep = vec3(mod(abs(p.x),b)-2.5, p.y, mod(abs(p.z+1.5), b)-2.5);\n    vec2 id = vec2(floor(abs(p.x)/b),floor((p.z+1.5)/b));\n    float fid = id.x*133.3 + id.y*311.7;\n    float wr = 0.5+0.3*sin(fid);\n        \n    vec3 newP = rotateY(rep, wr);\n    newP = rotateZ(newP, 0.2*wr);\n    float d = sdRoundBox( newP, vec3(wr*0.5, wr, 0.04), 0.03);\n    return d;\n}\nfloat streetlight(vec3 p) {\n    p -= vec3(0.0,0.5,-2.0);\n    \n    //vec3 rep = opRepLim(p, 8.0, vec3(2.0, 0.0, 2.0));\n    vec3 rep = opRep(p, vec3(12.0, 0.0, 12.0));  \n    float t = iTime*0.5;\n    float d = sdCappedCone(rep, 5.0+2.0*sin(p.x*0.2+p.z*0.5+t), 0.01, 1.8 ) + 0.1*sin(p.z*3.0+p.y*2.0+iTime);\n    d *= 0.6;\n    return d;\n}\n\nvec4 map(in vec3 pos, float aTime)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = fract(aTime);\n    float y = 3.0*t*(1.0-t); \n    float sinT = sin(aTime);\n    vec3 cen = vec3(0.0,0.55,SPEED);\n    float sy = 0.8 + 0.2*y;\n    float sz = 1.0/sy;\n    vec3 r = vec3(0.35,0.32+0.05*sy,0.25+0.05*sz);\n    vec3 q = pos-cen;\n    vec3 h = q;\n    \n    //body \n    float ta0 = step(fract(aTime*10.0),0.99);\n    h.z -= 3.0;\n    h.z += ta0*9.0;\n    float d = sdElipsoid(h-vec3(0.0, 0.03, -0.09), r);\n    {\n    \n    //head \n    float d1 = sdElipsoid(h - vec3(0.0, 0.32, 0.01), vec3(0.28, 0.2, 0.18));\n    float d2 = sdElipsoid(h - vec3(0.0, 0.30, -0.07), vec3(0.2));\n    d2 = smin(d1, d2, 0.08);\n    d = smin(d, d2, 0.08);\n    \n    vec3 sh = vec3(abs(h.x), h.yz);//symmetric along x\n    \n    //ears\n    d2 = sdElipsoid(sh - vec3(0.15, 0.47, -0.05), vec3(0.06, 0.09, 0.04));\n    d = smin(d, d2, 0.08);\n    res = vec4(d,2.0,0.0,0.0);  \n     \n    //eyes\n    float d3 = sdSphere(sh - vec3(0.068,0.4,0.108), 0.07);\n    res = sdUnion(res, vec4(d3,3.0,0.0,0.0));\n    \n    //terrain\n    float fh = -0.05+0.05*(sin(2.5*pos.x) + sin(1.5*pos.z));\n    float d4 = pos.y - fh;\n    d4 -= .01*texture(iChannel0, pos.xz).x;\n    res = sdUnion(res, vec4(d4,0.0,0.0,0.0));\n    \n    //tombstone\n    float d5 = tombStone(pos);\n    res = sdUnion(res, vec4(d5,1.0,0.0,0.0));\n    \n    //light\n    float d6 = streetlight(pos);\n    res = sdUnion(res, vec4(d6,4.0,0.0,0.0));\n    \n    float glow = d6;\n    res.w = glow;\n        \n    float shadow = min(d4, d5); \n    res.z = shadow;\n    }\n    \n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float aTime)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.32*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, aTime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.85;\n        \n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos, in float aTime)\n{\n    vec2 e = vec2(0.001,0.0);\n    return normalize( vec3(map(pos + e.xyy,aTime).x - map(pos - e.xyy,aTime).x,\n                          map(pos + e.yxy,aTime).x - map(pos - e.yxy,aTime).x,\n                          map(pos + e.yyx,aTime).x - map(pos - e.yyx,aTime).x) );\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd, in float aTime)\n{\n    float res = 1.0;\n    float t = 0.01;\n    float tMax = MAX_DIST;\n    \n    for (int i=0; i<MAX_STEP;++i)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos,aTime).z;\n        res = min( res, 16.0*h/t );\n        if (res<0.01 || t > tMax) break;\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float aTime)\n{\n   float t = 0.01;\n   vec4 m = vec4(0.0);\n   float tMax = MAX_DIST;\n   float minDist = MAX_DIST;\n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t*rd;\n       vec4 h = map( pos,aTime );\n       minDist = min(minDist, h.w/t);\n       m.x = t;\n       m.y = h.y;\n       m.z = minDist;\n       m.w = h.w;\n       \n       if ( abs(h.x)<(0.001*t) || t>tMax ) break;\n       t += h.x;\n   } \n    \n   if ( t>tMax )\n   {\n       m.x = MAX_DIST;\n       m.y = -1.0;\n       m.w = MAX_DIST;\n   }\n   \n   return m;\n}\n\nvec3 render(in vec2 fragCoord, in float aTime)\n{\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = 2.0*iMouse.xy/iResolution.xy-1.0;\n    float angle = 10.0*iMouse.x/iResolution.x;\n    \n    vec3 ta = vec3(0.0,0.85,3.0+SPEED);\n    vec3 ro = ta+vec3( 1.0*sin(angle), 0.0, 1.0*cos(angle) );;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross( ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    \n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0*ww);\n    vec3 mDir = LIGHT_DIRECTION;\n    vec3 bg = SKY_COLOR;\n    vec3 col = bg;\n    \n    vec2 uv = rd.xz/rd.y; //sky dome( intersect the top )\n    \n    vec4 tm = castRay(ro, rd, aTime);\n    float t = tm.x;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos, aTime);\n    vec3 mate = vec3(0.0);\n    float occ = calcOcclusion( pos, nor, aTime );\n    float fresnel = clamp(1.0+dot(nor,rd),0.0,1.0);\n    float mDiff = clamp( dot(nor, mDir),0.0,1.0 );\n    float mShadow = castShadow(pos+nor*0.01, mDir, aTime);\n    if ( tm.x < MAX_DIST )\n    {  \n        if (tm.y == 0.0) {\n            mate = TERRAIN_COLOR;//terrain\n        } \n        else if (tm.y == 1.0){\n           mate = vec3(0.1);\n           mate += RIM_POWER*GLOW_COLOR*fresnel;    \n        }\n        else if (tm.y==2.0)\n        {\n            mate = vec3(0.5); //body\n            mDiff = 0.0;\n        } \n        else if (tm.y==3.0)\n        {\n            mate = vec3(1.0); //eyes\n            mDiff = 1.0;\n        }\n        else if (tm.y==4.0)\n        {\n            mate = vec3(0.0,0.5,0.5); //light\n            mate += step(fract(pos.y*3.0),0.25)*vec3(2.0,0.0,2.0);\n    \t\tmate += step(fract(pos.y*1.5),0.15)*vec3(0.0,2.0,2.0);\n            mDiff = 1.0;\n            mShadow = 1.0;\n            occ = 1.0;\n        }  \n       \n        col = mate*LIGHT_INTENSITY*mDiff*mShadow;\n        col *= occ*occ; \n        \n    } \n    \n    // fog\n    col = mix( col, vec3(0.0,0.05,0.05), 1.0-exp( -0.003*t*t ) );\n    \n    float glow = 0.1*exp(-64.0*tm.z); \n    col += GLOW_COLOR*glow;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.0);\n    \n#if AA_SIZE>1\n    //anti aliasing & motion blur\n    for (float aaY = 0.0; aaY < float(AA_SIZE); ++aaY)\n    {\n        for (float aaX = 0.0; aaX < float(AA_SIZE); ++aaX)\n        {\n            off = -0.5+vec2(aaY,aaX)/float(AA_SIZE);\n            \n            float md = texelFetch(iChannel0, ivec2(fragCoord)&255, 0).x;\n            float mb = (aaY*float(AA_SIZE)+aaX)/(float(AA_SIZE*AA_SIZE-1));\n            mb += (md-0.5)/float(AA_SIZE*AA_SIZE);\n            float aTime = iTime - mb*0.5*(1.0/24.0); //1 frame in 24fps for film\n#else\n            float aTime = iTime;\n#endif\n            col += render(fragCoord+off, aTime);\n             \n            \n#if AA_SIZE>1\n        }\n    }\n    col /= float(AA_SIZE*AA_SIZE);\n#endif\n    \n    //gamma\n    col = pow( col, vec3(0.4546));\n   \n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    fragColor = vec4(col,0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}