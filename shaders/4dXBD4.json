{
    "Shader": {
        "info": {
            "date": "1496134020",
            "description": "Just my first raymarching attempt with some basic lights, fog and simple models.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dXBD4",
            "likes": 4,
            "name": "Basic raymarching with comments",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sphere",
                "models",
                "fog",
                "scene"
            ],
            "usePreview": 0,
            "username": "Hitokage",
            "viewed": 752
        },
        "renderpass": [
            {
                "code": "//links\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n//https://gamedev.stackexchange.com/questions/67719/how-do-raymarch-shaders-work\n//https://iquilezles.org/articles/distfunctions\n//https://learnopengl.com - for lighting, matrices, camera theory etc.\n\n//constants\n//raymarching\nconst float EPSILON = 0.001;\nconst int MAX_STEPS = 150;\n//camera\nconst float NEAR = 0.0;\nconst float FAR = 300.0;\n//fog\nconst float FOG_START = 1.0;\nconst float FOG_END = 10.0;\n\nstruct light\n{\n    vec3 position;\n    vec3 color;\n    float ambientCoef;\n    float attenuation;\n};\n\nstruct material\n{\n    vec3 color;\n    vec3 specularColor;\n    float shininess;\n};\n\nlight light0 = light(vec3(0.8,0.5,1.8), vec3(0.5,0.5,0.5), 0.02, 0.02);\n\nmaterial material0 = material(vec3(0.0,1.0,0.0), vec3(1.0,1.0,1.0), 10.0);\n\n//environment\nvec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\nfloat fov = 45.0;\n\n//distance functions for the primitives\nfloat sphereDist (vec3 point, float radius)\n{\n    return length(point)-radius;\n}\n\nfloat boxDist( vec3 point, vec3 dimensions )\n{\n    return length(max(abs(point)-dimensions,0.0));\n}\n\n//gets the minimal distance of the whole scene\n//the scene is specified here\n//transformations are done by transforming the point\nfloat sceneMinDist (vec3 point)\n{\n    return min(sphereDist(point,1.0),\n               boxDist(point+vec3(0.0,-1.0,0.0), vec3(60.0,0.1,60.0)));\n}\n\n//view matrix\nmat4 lookAt(vec3 cam, vec3 focusPoint, vec3 up) {\n    //we need to create the new coord system\n    vec3 z = normalize(focusPoint-cam);\n    vec3 x = cross(z, up);\n    vec3 y = cross(z,x);\n    //simply make a matrix of this system\n    return mat4(vec4(x, 0.0),vec4(y, 0.0),vec4(-z, 0.0),vec4(0.0, 0.0, 0.0, 1));\n}\n\n\n//aproximates the normal based on the gradient change, gradient tells us which direction is the fastest growth of function, direction to the object is negative so gradient = normal\n//gradient is calculated as partial derivation by x,y,z for each element of f(x,y,z), approximation by nearby points gives us this function:\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n                         sceneMinDist(vec3(p.x + EPSILON, p.y, p.z)) - sceneMinDist(vec3(p.x - EPSILON, p.y, p.z)),\n                         sceneMinDist(vec3(p.x, p.y + EPSILON, p.z)) - sceneMinDist(vec3(p.x, p.y - EPSILON, p.z)),\n                         sceneMinDist(vec3(p.x, p.y, p.z  + EPSILON)) - sceneMinDist(vec3(p.x, p.y, p.z - EPSILON))\n                     ));\n}\n\n//raymarching function, returns the distance to the closest surface\n//gets the cam position, direction of the marching ray and near and far clipping params\nfloat closestDistance(vec3 cam, vec3 direction, float near, float far)\n{\n    float t=near;\n\n    //TODO: recognize object and return the correct material\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 ray=cam+direction*t;\n        float minDistance = sceneMinDist(ray);\n        if (minDistance<EPSILON)\n            return t;\n\n        t +=minDistance;\n\n        if (t >= far)\n            return far;\n    }\n    return far;\n}\n\nvec3 blinnPhong(vec3 cameraPos,light light0, vec3 point)\n{\n    //blinn-phong lighting model\n    vec3 normal = getNormal(point);\n    vec3 surfaceToLight = normalize(light0.position - point);\n\n    //ambient aka when there is no light at all\n    vec3 ambient = light0.ambientCoef*material0.color;\n    ambient *= light0.color;\n\n    //diffuse - that normal shading\n    //cosine of the angle of incidence = dot(x,y)/(|x|*|y|) where lengths are 1 - normalized\n    float diffuseCoef = max(0.0,dot(normal, surfaceToLight));\n    vec3 diffuse = diffuseCoef*light0.color*material0.color;\n\n    //specular - shiny stuff\n    //if it was a mirror, how much would the reflection from the light go to the camera?\n    //incidence vector = -surfaceToLight\n    vec3 specular = vec3(0.0,0.0,0.0);\n    if (diffuseCoef > 0.0)\n    {\n        vec3 surfaceToCamera = normalize(cameraPos - point);\n        //normal phong calculates the cos of angle between vector to camera and reflection\n        //vec3 reflection = reflect(-surfaceToLight, normal);\n        //blinn adds the halfway vector\n        vec3 halfway = normalize(surfaceToLight+surfaceToCamera);\n        float cosAngle = max(0.0, dot(normal,halfway));\n        float specularCoef = pow(cosAngle,material0.shininess);\n        specular = specularCoef*material0.specularColor*light0.color;\n    }\n\n\n    //attenuation - loss of light over distance from the light source\n    float distanceToLight = length(light0.position - point);\n    float attenuation = 1.0/(1.0 + light0.attenuation * pow(distanceToLight,2.0));\n    vec3 linearColor = ambient + attenuation*(diffuse+specular);\n    \n    return linearColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cameraPos=vec3(0.0,0.0,5.0);\n\n    //let's normalize the point on the view plane to -1-1 coordinates, center is 0,0\n    vec2 planeCoord = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n    //we need to fix one dimension\n    planeCoord.x *= iResolution.x/iResolution.y;\n\n    //x,y of the current plane point, the z is based on the right triangle where tan = A/B (right angle at center of screen, A-half of screen, B is Z), - sign defines the direction of Z\n    //since we have -1 to 1 plane, half is 1.0\n    vec3 rayDirection = vec3(planeCoord.xy, -(1.0 / tan(radians(fov))));\n    rayDirection = normalize(rayDirection);\n    \n    //animation of the camera\n    //sin and cos are related to the unit circle, polar coordinates r*cos/sin+center\n    cameraPos.x = 2.0*cos(iTime);\n    cameraPos.z = 2.0*sin(iTime);\n    //calculate the rotation for the camera direction\n    //creates the view->world matrix\n    mat4 rrr = lookAt(cameraPos,vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0));\n    //apply it to the rays that are coming out of it, result in world space\n    rayDirection = (rrr*vec4(rayDirection,0.0)).xyz;\n\n    //raymarching\n    float dist = closestDistance(cameraPos, rayDirection, NEAR, FAR);\n    //the ray went too far, nothing\n    vec3 linearColor = backgroundColor.xyz;\n    //the ray hit something, get the color then\n    if (dist-EPSILON < FAR)\n    {\n        //get the point in world space\n        vec3 point = cameraPos+rayDirection*dist;\n        linearColor = blinnPhong(cameraPos, light0, point);\n    }\n    \n    //now let's get the fog factor using simple linear fog\n    float fogFactor = (FOG_END-dist)/(FOG_END - FOG_START); \n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    linearColor = mix(vec3(0.7,0.7,0.7), linearColor, fogFactor);\n    \n    //gamma correction - transform the linear rgb to more natural one for human eye (CRT style)\n    vec3 gamma = vec3(1.0/2.2);\n    fragColor = vec4(pow(linearColor,gamma), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}