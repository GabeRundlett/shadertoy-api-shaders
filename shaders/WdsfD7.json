{
    "Shader": {
        "info": {
            "date": "1588397199",
            "description": "Tried to make a watercolour painting. Quite happy with how it turned out.\nThoughts and criticism appreciated.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdsfD7",
            "likes": 10,
            "name": "Watercolour Sketches",
            "published": 3,
            "tags": [
                "watercolour",
                "handdraw"
            ],
            "usePreview": 1,
            "username": "samhattangady",
            "viewed": 740
        },
        "renderpass": [
            {
                "code": "/*\n * 02 May 2020\n * I liked yesterday's sketch a lot. Wanted to make it a little less thick.\n * Fiddled with the values till I had a nice thin line that looked nice.\n * Wanted to go with a quick and dirty watercolour style sketch. Really happy\n * with the result.\n * The biggest problem I'm facing is the uniformity of the noise. Specifically\n * while filling in the colours (painting). So if I draw\n * multiple shapes that occupy the same space, their behaviour is identical which\n * doesn't look so great. So I need to figure out what infrastructure is required\n * so that the scale of noise is dependent on the size of the area being filled,\n * as well as use a different noise pattern for every individual shape (or something\n * along those lines) like passing a \"seed\" that is shared for the single fill.\n */\nfloat PI = 3.14159;\n\nvec3 paper_colour = vec3(0.9, 0.9, 0.85);\nvec3 pencil_colour = vec3(0.3, 0.3, 0.40);\n\nfloat line_thickness = 0.0;\nfloat line_variation = 5.2508;\nfloat line_smoothness = 1.5;\nfloat fill_noise = 35.04;\n\nfloat rand(vec2 c) {\n    //return pow((sin(iTime/1.0)),2.0)*0.1 + 0.9*fract(sin(dot(c.xy ,vec2(15.868,781.233))) * 4378.5453);\n\n\treturn fract(sin(dot(c.xy ,vec2(15.868,781.233))) * 4378.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n    p += vec2(iTime*14.50, 0.0);\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 30.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat pNoise2(vec2 p, int res){\n    p += vec2(iTime*12.0, iTime*52.0);\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 3.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat get_noise(vec2 p) {\n    float noise = pNoise(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\nfloat get_noise2(vec2 p) {\n    float noise = pNoise2(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\n\nfloat triangle_sign (vec2 p1, vec2 p2, vec2 p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool point_in_triangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3) {\n    float d1, d2, d3;\n    bool has_neg, has_pos;\n    d1 = triangle_sign(pt, v1, v2);\n    d2 = triangle_sign(pt, v2, v3);\n    d3 = triangle_sign(pt, v3, v1);\n    has_neg = (d1 < 0.0) || (d2 < 0.0) || (d3 < 0.0);\n    has_pos = (d1 > 0.0) || (d2 > 0.0) || (d3 > 0.0);\n    return !(has_neg && has_pos);\n}\n\nfloat rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nfloat distance_to_line(vec2 p, vec2 p1, vec2 p2) {\n    float d;\n    float l_sq = pow(distance(p1, p2), 2.0);\n    if (l_sq == 0.0)\n        d = distance(p, p1);\n    else {\n        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));\n        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment\n        d = distance(p, projection);\n    }\n    return d;\n}\n\nfloat triangle (vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    float d, d2, d3;\n    d = distance_to_line(p, p1, p2);\n    d = min(d, distance_to_line(p, p2, p3));\n    d = min(d, distance_to_line(p, p3, p1));\n    if (point_in_triangle(p, p1, p2, p3))\n        return -d;\n    return d;\n}\n\nvec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {\n    // return current_colour;\n    p += sin(iTime/1.2)*4.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    p1 += 5.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    p2 -= 5.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    float d = distance_to_line(p, p1, p2);\n    float noise;\n    // TODO (01 May 2020 sam): Figure out how to to better line check\n    if (p1.y<p.y) noise = get_noise(p.yx);\n    else noise = get_noise(p);\n    d += noise*line_variation;\n    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);\n    return mix(pencil_colour, current_colour, pencil);\n}\n\nvec3 fill_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, vec3 fill_colour) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise2(p);\n    noise *= fill_noise;\n    if (bd+noise<0.0)\n        colour = fill_colour;\n    return colour;\n}\n\nvec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, bool fill_paper) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise(p);\n    noise *= 5.0;\n    if (bd-noise<0.0 && fill_paper)\n        colour = paper_colour;\n    colour = draw_line(p, p1, p2, colour);\n    colour = draw_line(p, p2, p3, colour);\n    colour = draw_line(p, p3, p4, colour);\n    colour = draw_line(p, p4, p1, colour);\n    return colour;\n}\n\nvec3 fill_triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 current_colour, vec3 fill_colour) {\n    vec3 colour = current_colour;\n    float d = triangle(p, p1, p2, p3);\n    float noise = get_noise2(p);\n    noise *= fill_noise;\n    if (d+noise<0.0)\n        colour = fill_colour;\n    return colour;\n}\n\nvec3 draw_pillar(vec2 pos, vec2 p1, vec2 p3, vec3 current) {\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n    vec3 building_colour = paper_colour*0.95;\n    vec3 shadow_colour = building_colour*0.9;\n    vec3 sky_colour = vec3(0.83, 0.83, 0.85);\n    vec3 ground_colour = vec3(0.8, 0.8, 0.65);\n    \n    vec3 colour = current;\n    colour = draw_box(pos, p1, p3, colour, true);\n    colour = fill_box(pos, p1, p3, colour, building_colour);\n    colour = fill_box(pos, vec2(p1.x+WIDTH*0.015, p1.y), p3, colour, shadow_colour);\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 colour;\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n    vec3 building_colour = paper_colour*0.95;\n    vec3 shadow_colour = building_colour*0.9;\n    vec3 sky_colour = vec3(0.83, 0.83, 0.85);\n    vec3 ground_colour = vec3(0.8, 0.8, 0.65);\n\n    vec2 pos = fragCoord;\n    vec2 uv = pos/iResolution.xy;\n    colour = paper_colour;\n    // background\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.99), colour, sky_colour*0.93);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.75), colour, sky_colour*0.96);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.5), colour, sky_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.01), vec2(WIDTH*0.99, HEIGHT*0.31), colour, ground_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.3),  vec2(WIDTH*0.95, HEIGHT*0.1), colour, ground_colour*0.9);\n    float fade = rectangle(pos-vec2(WIDTH*0.5,HEIGHT*0.5), vec2(WIDTH*0.05, 0.0001));\n    fade += get_noise2(pos.yx) * 500.0;\n    fade = smoothstep(WIDTH*0.25, WIDTH*0.452, fade);\n    colour = mix(colour, paper_colour, fade);\n    // horizon\n    colour = draw_line(pos, vec2(-50000.0, iResolution.y/3.0), vec2(iResolution.x*5000.0, iResolution.y/3.0), colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.18, HEIGHT*0.66), vec2(WIDTH*0.5, HEIGHT*0.82), vec2(WIDTH*0.82, HEIGHT*0.66), colour, paper_colour);\n    // pillars\n    colour = draw_pillar(pos, vec2(WIDTH*0.22, HEIGHT*0.405), vec2(WIDTH*0.26, HEIGHT*0.585), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.30, HEIGHT*0.405), vec2(WIDTH*0.34, HEIGHT*0.588), colour);\n    //colour = draw_pillar(pos, vec2(WIDTH*0.22, HEIGHT*0.41), vec2(WIDTH*0.26, HEIGHT*0.59), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.37, HEIGHT*0.407), vec2(WIDTH*0.41, HEIGHT*0.586), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.44, HEIGHT*0.404), vec2(WIDTH*0.48, HEIGHT*0.583), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.51, HEIGHT*0.406), vec2(WIDTH*0.55, HEIGHT*0.588), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.59, HEIGHT*0.404), vec2(WIDTH*0.63, HEIGHT*0.589), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.66, HEIGHT*0.408), vec2(WIDTH*0.70, HEIGHT*0.586), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.74, HEIGHT*0.409), vec2(WIDTH*0.78, HEIGHT*0.583), colour);\n    // base\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour, true);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour, building_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.36), colour, shadow_colour);\n    colour = draw_box(pos, vec2(WIDTH*0.24, HEIGHT*0.32), vec2(WIDTH*0.76, HEIGHT*0.38), colour, false);\n    // roof\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour, true);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour, building_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.26, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.64), colour, shadow_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), vec2(WIDTH*0.8, HEIGHT*0.68), colour, building_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.6, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), vec2(WIDTH*0.8, HEIGHT*0.68), colour, shadow_colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.8, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.8, HEIGHT*0.68), colour);\n    fragColor = vec4(colour, 1.0);\n    float c = get_noise(pos.yx);\n    // fragColor = vec4(vec3(c), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}