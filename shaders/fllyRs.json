{
    "Shader": {
        "info": {
            "date": "1648556977",
            "description": "nothing description",
            "flags": 0,
            "hasliked": 0,
            "id": "fllyRs",
            "likes": 8,
            "name": "undead tunnel2",
            "published": 3,
            "tags": [
                "fbm",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "cxm",
            "viewed": 3495
        },
        "renderpass": [
            {
                "code": "mat2 _rot1(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c,s,-s,c);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n    return sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvoid drawCircle( inout float d, in vec2 uv, in vec2 pos, float r ){\n    float g = smoothstep( .0, r + .01, length( uv - pos ) );\n    \n    d = mix(\n        d,\n        1.,\n        g\n    );\n    \n    d = mix(\n        d,\n        2.,\n        smoothstep( r + .05, .0, length( uv - pos ) )\n    );\n    \n}\n\n// pulse\nfloat Pulse2Pixel( in vec2 uv, vec2 pos, float rot, float size, float idx ){\n    float b = 0.;\n    vec2 bUv = uv;\n    uv -= pos;\n    uv *= _rot1( rot );\n    uv += pos;\n    \n    uv = fbm4_2( uv + fbm4_2( uv +fbm4_2( uv - rot ) ) );\n    b = cos( uv.x ) * sin( uv.y );\n    // b = noise( uv ) + cos( uv.x ) * sin( uv.y ) * .3;\n    \n\n    b *= 1. - smoothstep(.0, size, length( bUv - pos ) );\n    \n    b = mix(\n        b, \n        0.,\n        1. - smoothstep(.0, size * .6, length( bUv - pos ) )\n    );\n    \n    // pulse overlay\n    b = mix(\n        b, \n        uv.x * .2,\n        1. - smoothstep(.0, size, length( bUv - pos ) )\n    );\n    \n    return b;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n    vec2 center = vec2( .5 );\n    \n    float d = 1.;\n    vec3 col;\n    \n    \n    float t = fract( iTime * .5 );\n\n    \n    for( float i = 0.; i < 5.; i++ ){\n    \n        t = fract( iTime * .5 - .25 * i );\n        \n    \n        uv -= .5;\n        uv *= _rot1( iTime * .3 ); \n        uv += .5;\n\n        d = Pulse2Pixel( uv, ( center ) * 2. - .5, t, t, 0. );\n\n        col = mix(\n            col,\n            vec3( 3. - 3. * ( t ) ),\n            d\n        );\n        \n\n    \n    }\n    \n    d = col.x;\n    \n    uv -= .5;\n    uv *= _rot1( iTime );\n    uv += .5;\n    \n    uv *= 3.;\n\n    uv = fbm4_2(uv+d+fbm4_2(uv+d+fbm4_2(uv + d - iTime)) + fbm4_2( uv + d - iTime ) + d);\n\n    // Time varying pixel color\n    col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= 5.;\n    // col = vec3( d );\n    col *= d;\n    \n \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}