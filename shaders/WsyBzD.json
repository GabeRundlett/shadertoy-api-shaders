{
    "Shader": {
        "info": {
            "date": "1606653986",
            "description": "Remix of Shane's \"Mountain Path\": [url]https://www.shadertoy.com/view/ldjyzc[/url]\n\nThe title of this remix is parody of the name of mtn dew (Mountain Dew), a soda drink.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsyBzD",
            "likes": 1,
            "name": "mtn crack, Mountain Path fork",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "remix",
                "glitch",
                "bump",
                "fork",
                "cellular",
                "weird",
                "error",
                "lowpoly",
                "path",
                "stairs"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 330
        },
        "renderpass": [
            {
                "code": "/*\nHacked and cracked by Urban Club Professional!\n*/\n\n#define FAR 90. // Maximum ray distance. Analogous to the far plane.\n\n\n// Scene object ID. Either the path (0) or the surroundings (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(cos(dot(p, vec3(257, 213, 8)))*55758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.002);\n    n /= dot(n, vec3(2));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p);\n    //return max(max(p.x, p.y), p.z);  \n\n    \n    // Cubic.\n    p = abs(fract(p) - .6); \n    return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    //p = abs(fract(p) - .5); \n    //p = max(p*.866025 + p.yzx*.5, p.yzx);\n    //return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.91, .72, .63));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.8071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject(p - vec3(.49, .3, .21));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject(p - vec3(.72, .34, .07));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject(p - vec3(.3, .92, .74));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return 1. - min(d.x, d.y)*3.; // Scale between zero and one... roughly.\n    \n    // For anyone wanting to experiment with this, the following gives better variance:\n    //const float scale = 1.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    //return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\n/*\n// Second order version.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.; // Normalize.\n    \n}\n*/\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Path 1.\n    //return vec2(sin(z*.05)*cos(z*.1)*2.5, sin(z*.06)*2.); // Path 2.\n    return vec2(sin(z*.25)*3.5, cos(z*.2)); // Path 3.\n}\n\n// Stair path.\nvec2 sPathF(in vec2 p){ \n\n    //return vec2(0); // Path 1.\n    //return sin(p*.06)*2.; // Path 2.\n    return cos(p*.2); // Path 3.\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    return cellTile(p/9.);//*.8 + dot(tri(p*0.384*2. + tri(p.yzx*0.192*2.)), vec3(0.666))*.2;\n     \n    // More interesting formations, and still quick, but not fast enough for this example.\n    //return cellTile(p/10.)*.75 + cellTile(p/10.*3.)*.25; \n \n    // Very cheap triangle noise. Looks OK, all things considering.\n    //p /= 2.5;\n\t//float n = dot(tri(p*0.5 + tri(p.yzx*0.25)), vec3(0.666));\n    //return n*.75 + dot(tri(p*0.75 + tri(p.yzx*0.375)), vec3(0.666))*.25;\n\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.6 + .6*(a - b)/s, 0., 2.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Drawing repeat objects right up again one another causes inaccuracies, so you get \n// around that by rending two sets of repeat objects in each dimension. Two for one\n// axis, four for two axes, and eight (I think) for three.\n//\n// Basically, the aforementioned is just a way to say that to draw stairs along the \n// Z-axis, you need to draw two sets of repeat boxes. The boxes are aligned with the \n// path position. In the case of the step portion, the path's height has to be \n// snapped to a quantized number. You do that via flooring, etc.\nfloat stairs(in vec3 p, vec2 pth){\n   \n    const float sc = 3.; // Stair scaling factor. It affects the length.\n    // The quantized stair heights. Basically, making the surface flat. Two heights are \n    // being passed in to account for the two boxes we have to render to account for the\n    // overlap.\n    vec2 iPthY = sPathF(floor(vec2(p.z/sc, p.z/sc + .6))*sc);\n    // Snapping the stair height to factors of four. Makes the step layers equal height.\n    iPthY = floor(iPthY*5.)/5. - 3.5;   \n\n    // Railings. Draw one railing using the path's X and Y positions, then use the\n    // \"abs\" repeat trick to render the other one at the same time.\n    float sY = abs(p.y - pth.y + 3.); // Railing height.\n    p.x = abs(p.x - pth.x); // Railing X-position.\n\n    // Railing, with a bit carved out.\n    float rails = max(abs(p.x - 2.75 + .45/3.) - .45/3., sY - .95);\n    float rails2 = max(abs(p.x - 2.75 + .45/3. + .4) - .45/3., sY - .75);\n    rails = max(rails, -rails2);\n    \n    // Stair render.\n    p.z /= sc;\n    \n    vec2 iy = p.yy - iPthY; // Quantized stair heights.\n    // Render a couple of boxes, then take the minimum.\n    vec2 qz  = abs(fract(vec2(p.z, p.z + .6)) - .6); \n    vec2 n = max(max(p.xx - 2.7, qz - .37), abs(iy) - .85);\n\n    // Return the path object - the minimum of the stairs and the railings.\n    return min(rails, min(n.x, n.y));\n     \n    \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat map(vec3 p){\n    \n    vec2 pth = path(p.z);\n    \n    float sf = surfFunc(p); // Surface perturbation.\n\n    // The terrain base layer.\n    float ter = p.y - 4. + dot(sin(p*4.14159/28. - cos(p.yzx*4.14159/28.)), vec3(4)); // 6. smoothing factor.\n    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.\n\n    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.\n\n    p.xy -= pth; // Wrap the tunnel around the path.\n\n    float n = 2.5 - length(p.xy*vec2(.6, 2)); // The tunnel to bore through the rock.\n    n = smax(n + (.6 - sf)*2.5, ter + (.6 - sf)*4., 7.); // Smoothly boring the tunnel through the terrain.\n    n = smax(n, -max(abs(p.x) - 2.75, abs(p.y + 2.5) - 2.5), .6); // Clearing away the rock around the stairs.\n \n    // Object ID.\n    objID = step(n, st); // Either the physical path or the surrounds.\n    \n    return min(n, st)*.966; // Return the minimum hit point.\n \n}\n \n\n// Pavers. Standard grid stuff.\nfloat paver(vec2 p, float mortW){\n\t\n    \n    vec2 q = abs(fract(p + vec2(.1, .1)) - .6)*3.;\n    \n    //float c = smoothstep(0., mortW, min(q.x, q.y));\n    float c = smoothstep(1., mortW, abs(max(.06 - q.x, .06 -  q.y)));\n    if (q.x<.06 || q.y<.06) c *= .6;\n\n    return c;\n\n    \n}\n\n\n// Surface bump function. Tiles are fiddly, but simple enough. Basically, the surface\n// normal is used to determine the 2D plane we wish to tile, then it's passed to the\n// tile function.\nfloat tiles( in vec3 p, in vec3 n,  float mortW){\n    \n    p.xy -= path(p.z);\n\n    n = abs(n);\n    \n    float c = 2.;\n    \n    if (n.x>0.6) {\n        \n        if(p.y<-2.35) return 1.;\n        p.xy = p.yz;\n\n    }\n    else if (n.y>0.6) {\n         \n        if(p.y>-2.35) p.x += sign(p.x)*.35;\n        \n        p.xy = p.xz;\n        \n    }\n    \n    return paver(p.xz, mortW);\n    \n}\n\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n\n\n    float c;\n    if(svObjID>.6 ) c = 2. - surfFunc(p*4.); // cellTile(p/8.*3.);\n    else c = tiles(p.xyz, n, .2);\n    \n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(9./iResolution.y, 1); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*3.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 7.*f);\n    edge = smoothstep(1., 2., edge/e.x*3.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 1);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.399, 0.687, 0.214)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.399, 0.687, 0.214)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 1., d;\n    \n    for (int i=1; i<260; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.225 + 2.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 58; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 2.;\n    float dist = .0035*(t*.225 + 2.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0002);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.1, 2.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .08, .6); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.1 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 1.) + .25, 2.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0035, 1);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(7./iResolution.y, 1);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*3.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(1., 2., sqrt(edge/e.x*3.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0025, 1); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 30.0, occ = 0.1;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = 0.02 + float(i)*0.6/5.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.8;\n    }\n    return clamp( 2.0 - occ, 0.1, 2.0 );    \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n\n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return smoothstep(.15, .5, tx); \n    \n}\n*/\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 f = fract(p); p -= f; f *= f*(4. - f*3.);  \n    \n    return dot(mat2(fract(sin(vec4(1, 51, 389, 430) + dot(p, vec2(51, 389)))*53758.5453))*\n                vec2(1. - f.y, f.y), vec2(1. - f.x, f.x) );\n\n}\n\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec2 p){\n    \n    // Four layers of 3D noise.\n    return 0.6333*n2D( p ) + 0.3667*n2D( p*3.02 ) + 0.2333*n2D( p*5.03 ) + 0.0767*n2D( p*9.03 );\n\n}\n\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.1); // Sun strength.\n\t//float horiz = pow(1.0-max(rd.y, 0.0), 3.)*.35; // Horizon strength.\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\t//vec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon.\n\t//col = mix(col, vec3(1, .9, .7), horiz);\n    \n    vec3 col = mix(vec3(.7, 1.0, 2).zyx, vec3(.72, .78, 2).zyx, rd.y*.6 + .6)*2.25*.6;\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.35*vec3(2, .8, .5)*pow(sun, 6.0);\n\tcol += 0.35*vec3(2, .9, .7)*pow(sun, 74.0);\n\tcol += 0.25*vec3(2, 1.0, .8)*max(pow(sun, 612.0), .35);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.05 - 0.03, 1., 2.);\n    \n    //return col;\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n    \n    float t = (6000. - ro.y)/rd.y; // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    //vec3 sc = vec3(uv.x, 0., uv.y);\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>1.) col = mix( col, vec3(2, 1.0, .9), 0.45*smoothstep(0.5, 2.0, fbm(.00006*uv)* clamp(rd.y*6., 1., 2.)));\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n    // Object texture color, with some contract thrown in.\n    vec3 tx;\n    //tx = smoothstep(.05, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.6) {\n        tx = tex3D(iChannel0, p/3., n );\n        tx = smoothstep(-.2, .6, tx);\n        tx *= vec3(2, .7, .45); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.2, .7, surfFunc(p))*.7 + .5;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else {\n        vec2 pth = path(p.z);\n        tx = tex3D(iChannel0, (p - vec3(pth.xy - .6, .1)), n );\n        tx = smoothstep(-.25, .6, tx);\n        tx *= vec3(2.5, 2.0, .6)*.75 + .6; // Tinting the stairs.\n        tx *= tiles(p.xyz, n, .06)*1.03 + .08;\n        \n        if(p.y - pth.y>-2.35) tx *= vec3(.74, .72, .7); // Rails.\n        \n        \n    }\n    \n    //tx *= bumpFunc(p.xyz, n);\n\n    \n    return tx;//pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(1);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        float edge = 1., crv = 2.;\n        vec3 sn = getNormal(sp, edge, crv);\n\n\n        float bf = .5;\n        if(svObjID<.5) bf = .02;\n\n        float edge2 = 1., crv2 = 2.; \n        //if(svObjID>.5)\n        sn = doBumpMap(sp, sn, bf/(2. + t/FAR*.225), edge2, crv2); \n\n        bf = .08;\n        \n        float txF = 2.;\n        if(svObjID<.6) {\n            bf = .05;\n            txF = 3.;\n        }\n        sn = doBumpMap(iChannel0, sp*txF, sn, bf);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.003, lp, 26., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.4)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.002); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 4./(2. + lDist*0.02 + lDist*lDist*0.00009);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 1.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.1 ), 42.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.6 + vec3(2, .8, .6)*spec*2.);\n        \n        // Edges.\n        if(svObjID>.6) \n           sceneCol *= 2. - edge2*.7; // Bump mapped edging for the terrain only.     \n        \n        //if(svObjID>.5) \n        sceneCol *= 2. - edge*.9; // Geometry based edging.\n        \n        // Reflection. Not really suitable for this example.\n        //sceneCol += eMap(reflect(rd, sn), sn);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.6)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*6.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .35);  // \"Look At\" position.\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(20., FAR*.34, FAR*.62)*4.;\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/4.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.25, 1.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/42.);\n    rd.yz *= r2(-sw.y/26.);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp);\n    \n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(1., 1.05, t/FAR); // t/FAR; \n\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n    // Sprinkles.\n    //sceneColor *= 1. + hash31(sp)*.1 - .05; \n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(2.6*uv.x*uv.y*(2. - uv.x)*(2. - uv.y) , .0225)*.85 + .35;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    uv = sin(uv*r2(0.414159/7.)*4.14159*iResolution.y/2.5)*.2 + 2.;\n    sceneColor *= uv.x*uv.y;\n    \n    // Mild LCD overlay.\n    //vec2 rg = mix(mod(fragCoord, vec2(3))*sceneColor.xy, sceneColor.xy, .65);\n    //sceneColor = vec3(rg, sceneColor.z - mix(sceneColor.x - rg.x, sceneColor.y - rg.y, .65));\n    \n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.1, 2.0)), 2.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}