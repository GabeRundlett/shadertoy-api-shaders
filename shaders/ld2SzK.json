{
    "Shader": {
        "info": {
            "date": "1414387470",
            "description": "Our investigation of the signal from the planet's surface brought us to what seems to be an alien beacon. Based on the rock formation around the beacon, it was probably left here millions of years ago.",
            "flags": 0,
            "hasliked": 0,
            "id": "ld2SzK",
            "likes": 72,
            "name": "Alien Beacon",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "terrain"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 5223
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n*/\n\n// The noise function in this was inspired by IQ's \"Terrain Tubes\" shader. I never really figured out\n// his function completely, so I'm not sure of the exact similarities. It's nice though because it\n// works the same on all computers (I think). It's not based on a hash that changes from computer to \n// computer. That means I can finally rely on the terrain being the same and make a camera path. :)\n// It's also a much faster noise function, although it can look a bit repetitive.\n\n#define MOTION_BLUR\n#define MOVING_SUN\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 208.0, 100.0) / 4255.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\n// This is a spline used for the camera path\nvec4 CatmullRom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    float t2 = t*t;\n    float t3 = t*t*t;\n    return 0.5 *((2.0 * p1) +\n                 (-p0 + p2) * t +\n    \t\t\t (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t2 +\n    \t\t\t (-p0 + 3.0 * p1- 3.0 * p2 + p3) * t3);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoiseD(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        n += abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        //p.xy += vec2(p.y, -p.x) * nudge;\n        //p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\n// These are the xyz camera positions and a left/right facing angle relative to the path line\n// I think webgl glsl can only access arrays using a constant, so I'm writing all these out.\n// Someone please tell me if I'm wrong.\nvec4 c00 = vec4(3.5, 2.0, 13.1, 0.0);\t// start point\nvec4 c01 = vec4(12.5, 2.2, 17.0, 0.0);\t// run up to canyon 2 before hole in large rock face\nvec4 c02 = vec4(21.5, 4.0, 8.1, 0.0);\t// canyon 2 before hole in large rock face\nvec4 c03 = vec4(21.0, 5.0, 1.1, -0.5);\t// before hole in large rock face\nvec4 c04 = vec4(17.8, 5.4, -0.2, 0.0);\t// hole in large rock face\nvec4 c05 = vec4(14.7, 2.5, 1.4, 0.0);\t// after hole in large rock face\nvec4 c06 = vec4(7.9, 2.3, -2.1, 0.0);\nvec4 c07 = vec4(0.5, -0.7, -3.5, 1.0);\nvec4 c08 = vec4(-3.0, -1.0, -3.5, 1.3);\nvec4 c09 = vec4(-3.5, -1.0, 4.0, 1.3);\nvec4 c10 = vec4(3.0, -0.7, 3.3, 0.8);\nvec4 c11 = vec4(3.5, -1.0, -4.75, 0.0);\nvec4 c12 = vec4(-6.0, -0.2, 1.0, 3.14);\nvec4 c13 = vec4(-6.0, -1.0, 5.5, 0.0);\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nfloat camPathOffset = 0.0;\t// where to start on the camera path - parametric t var for catmull-rom spline\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\nfloat waterLevel = 1.5;\n// from a time t, this finds where in the camera path you are.\n// It uses Catmull-Rom splines\nvec4 CamPos(float t)\n{\n    t = mod(t, 14.0);\t// repeat after 14 time units\n    float bigTime = floor(t);\n    float smallTime = fract(t);\n    // Can't do arrays right, so write this all out.\n    if (bigTime == 0.0) return CatmullRom(c00, c01, c02, c03, smallTime);\n    if (bigTime == 1.0) return CatmullRom(c01, c02, c03, c04, smallTime);\n    if (bigTime == 2.0) return CatmullRom(c02, c03, c04, c05, smallTime);\n    if (bigTime == 3.0) return CatmullRom(c03, c04, c05, c06, smallTime);\n    if (bigTime == 4.0) return CatmullRom(c04, c05, c06, c07, smallTime);\n    if (bigTime == 5.0) return CatmullRom(c05, c06, c07, c08, smallTime);\n    if (bigTime == 6.0) return CatmullRom(c06, c07, c08, c09, smallTime);\n\n    if (bigTime == 7.0) return CatmullRom(c07, c08, c09, c10, smallTime);\n    if (bigTime == 8.0) return CatmullRom(c08, c09, c10, c11, smallTime);\n    if (bigTime == 9.0) return CatmullRom(c09, c10, c11, c12, smallTime);\n    if (bigTime == 10.0) return CatmullRom(c10, c11, c12, c13, smallTime);\n    if (bigTime == 11.0) return CatmullRom(c11, c12, c13, c00, smallTime);\n    if (bigTime == 12.0) return CatmullRom(c12, c13, c00, c01, smallTime);\n    if (bigTime == 13.0) return CatmullRom(c13, c00, c01, c02, smallTime);\n    return vec4(0.0);\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);\t// mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t// large scale terrain features\n    final -= SpiralNoise3D(p);\t// more large scale features, but 3d, so not just a height map.\n    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t// small scale noise for variation\n\tfinal = min(final, length(p) - 1.99);\t// sphere in center\n    final = min(final, p.y + waterLevel);\t// water\n\t//final = min(final, length(p-camLookat) - 0.3);\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n/*    if (iTime == 0.0)\t// for debugging with manual camera\n    {\n        camPos = cXX.xyz;\n        camLookat = vec3(0.0)*cXX.xyz;\n    }*/\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.1;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(5.2); \t// prp\n\n    // set time for moving camera along path\n    float timeLine = iTime*0.2 + camPathOffset;\n    camFacing = camLookat + camPos;\n    // without this if condition, the mac doesn't work. mysterious. :(\n    if (iTime != -1.0)\n    {\n        vec4 catmullA = CamPos(timeLine);\n        // get a smoother derivative even though the spline is not C2 continuous.\n        // Also look ahead a bit so the camera leads the motion\n        vec4 catmullB = CamPos(timeLine + 0.3);\n#ifdef MOTION_BLUR\n        vec4 catmullC = CamPos(timeLine + 0.004);\t// adjust for camera motion blur\n        vec4 catmullBlur = mix(catmullA, catmullC, Hash2d(uv));\t// motion blur along camera path\n        camPos = catmullBlur.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullBlur.w);\n#else\n        camPos = catmullA.xyz;\n        // face camera along derivate of motion path\n        camFacing = normalize(catmullB.xyz - catmullA.xyz);\n        // rotate camera based on w component of camera path vectors\n        camFacing = RotateY(camFacing, -catmullA.w);\n#endif\n        camFacing = RotateY(camFacing, -mx);\n    \tcamLookat = camPos + camFacing;\n    }\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat dist = 0.05;\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n\t// ray marching time\n    for (int i = 0; i < 200; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        if ((t > maxDepth) || (abs(dist) < 0.0075)) break;\n        pos = camPos + relVec * t;\n        // *******************************************************\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry.\n        // *******************************************************\n        dist = DistanceToObject(pos);\n        t += dist * 0.25;\t// because deformations mess up distance function.\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n#ifdef MOVING_SUN\n\tvec3 sunDir = normalize(vec3(sin(iTime*0.047-1.5), cos(iTime*0.047-1.5), -0.5));\n#else\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n#endif\n    // This makes the sky fade at sunset\n    float skyMultiplier = saturate(sunDir.y+0.7);\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(dist) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normal = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n\n        /*if (pos.y <= waterLevel-2.995)\t// water waves?\n        {\n            normal += SpiralNoise3D(pos*32.0+vec3(iTime*8.0,0.0,0.0))*0.0001;\n            normal += SpiralNoise3D(pos*27.0+vec3(0.0,0.0, iTime* 10.333))*0.0001;\n            normal += SpiralNoiseD(pos*37.0+vec3(0.0,iTime* 14.333,0.0))*0.0002;\n        }*/\n        normal = normalize(normal);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        //ambient *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        float sunSet = saturate(sunDir.y*4.0); // sunset dims the sun\n        sunShadow = saturate(sunShadow) * sunSet;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // pulse the ball light source\n        vec3 ballGlow = vec3(0.1, 0.97, 0.1) * abs(SpiralNoise3D(vec3(iTime*1.3)));\n\n        // ------ Calculate texture color of the rock ------\n        // basic orange and white blended together with noise\n        vec3 texColor = mix(vec3(0.95, 1.0, 1.0),  vec3(0.9, 0.7, 0.5), pow(abs(SpiralNoise3D(pos*1.0)-1.0), 0.6) );\n        // make the undersides darker greenish\n        texColor = mix(vec3(0.2, 0.2, 0.1), texColor, saturate(normal.y));\n        // fade to reddish/orange closer to the water level\n        texColor = mix(texColor, vec3(0.64, 0.2, 0.1) , saturate(-0.4-pos.y));\n        // some more variation to the color vertically\n        texColor = mix(texColor, vec3(0.2, 0.13, 0.02) , pow(saturate(pos.y*0.125+0.5), 2.0));\n        // give the rock a stratified, layered look\n        float rockLayers = abs(cos(pos.y*1.5+ SpiralNoiseD(pos*vec3(1.0, 2.0, 1.0)*4.0)*0.2 ));\n        texColor += vec3(0.7, 0.4, 0.3)*(1.0-pow(rockLayers, 0.3));\n\n        // make the water orange. I'm trying for that \"nickel tailings\" look.\n        texColor = mix(texColor, vec3(1.4, 0.15, 0.05) + SpiralNoise3D(pos)*0.025, saturate((-pos.y-1.45)*17.0));\n        // make the sphere white\n        if (length(pos) <= 2.01) texColor = vec3(1.0);\n        // don't let it get too saturated or dark\n        texColor = max(texColor, 0.05);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(1.0, 0.75, 0.75) * saturate(dot(sunDir, normal)) * sunShadow*1.5;\n        // sky color, hemisphere light equation approximation, anbient occlusion, sunset multiplier\n        lightColor += vec3(1.0,0.3,0.6) * ( dot(sunDir, normal) * 0.5 + 0.5 ) * ambient * 0.25 * skyMultiplier;\n        // Make the ball cast light. Distance to the 4th light falloff looked best. Use local ambient occlusion.\n        float lp = length(pos) - 1.0;\n        lightColor += ambientS*(ballGlow*1.2 * saturate(dot(normal, -pos)*0.5+0.5) / (lp*lp*lp*lp));\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // Make the water reflect the sun (leaving out sky reflection for no good reason)\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunShadow * saturate(normal.y*normal.y) * saturate(-(pos.y+1.35)*16.0);\n\n        // make the ball itself glow\n        finalColor += pow(saturate(1.0 - length(pos)*0.4925), 0.65) * ballGlow*6.1;\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(1.0, 0.41, 0.41)*skyMultiplier + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0*sunSet, finalColor, exp(-t*0.03));\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.5, 0.5), vec3(0.40, 0.25, 0.91), saturate(relVec.y))*skyMultiplier;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    //finalColor = vec3(Hash2d(uv)*0.91,  Hash2d(uv+47.0)*0.91, 0.0);\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.3;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}