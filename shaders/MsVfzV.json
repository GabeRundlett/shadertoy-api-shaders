{
    "Shader": {
        "info": {
            "date": "1530531380",
            "description": "Predators (blue) eat prey (red). Prey eat vegetation (green).\n\nClick to show history of population cycles in each patch.",
            "flags": 32,
            "hasliked": 0,
            "id": "MsVfzV",
            "likes": 14,
            "name": "Population dynamics",
            "published": 3,
            "tags": [
                "simulation",
                "predator",
                "prey",
                "ecology",
                "population"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 645
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 c = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(0.92, 0.67, 0.49, 1);\n    fragColor = mix(fragColor, vec4(0.39, 0.51, 0.16, 1), smoothstep(0.0, 0.1, c.g));\n    fragColor = mix(fragColor, vec4(0.01, 0.19, 0.01, 1), smoothstep(0.1, 0.2, c.g));\n    if (c.r > 0.) fragColor = mix(fragColor, vec4(0.2, 0., 0., 1), 0.75);\n    if (c.b > 0.) fragColor = mix(fragColor, vec4(0., 0., 0.5, 1), 0.75);\n    \n    if (iMouse.z > 0. || (fragCoord.x < 64. && fragCoord.y < 64.)) {\n        c = texture(iChannel1, fragCoord/iResolution.xy);\n        fragColor = mix(fragColor, vec4(1), 0.5);\n        if (c.r > 0.) fragColor = vec4(0.5, 0., 0., 1);\n        if (c.b > 0.) fragColor = vec4(0., 0., 0.5, 1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// https://www.shadertoy.com/view/4tdSWr\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n        vec2 i = floor(p + (p.x+p.y)*K1);       \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));  \n}\n\nfloat fbm(vec2 n) {\n        float total = 0.0, amplitude = 0.1;\n        for (int i = 0; i < 7; i++) {\n                total += noise(n) * amplitude;\n                n = m * n;\n                amplitude *= 0.4;\n        }\n        return total;\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 c, in vec2 p ) {\n    if (iFrame < 10) {\n        if (hash22(p).x < 0.33) c.r = 1.;\n        else if (hash22(p).y < 0.33) c.b = 1.;\n    \tc.g = clamp(fbm(3. * p/iResolution.xy), 0.25, 1.);\n        return;\n    }\n    \n    c = texture(iChannel0, p/iResolution.xy);\n    \n    float r = hash33(vec3(p, iFrame)).x;\n    vec2 d = (r < 0.25) ? vec2( 0, 1)\n           : (r < 0.50) ? vec2( 1, 0)\n           : (r < 0.75) ? vec2( 0,-1)\n           :              vec2(-1, 0);\n    vec4 n = texture(iChannel0, (p + d) / iResolution.xy);\n    \n    r = hash33(vec3(p, iFrame)).z / 0.2;\n    \n    // predator diffusion\n    if (c.rb == vec2(0) && r < 0.5) c.b = n.b;\n    if (n.rb == vec2(0) && hash33(vec3(p+d, iFrame)).z / 0.2 < 0.5) c.b = 0.;\n    \n    // prey diffusion\n    if (c.rb == vec2(0) && r < 0.2) c.r = n.r;\n    if (n.rb == vec2(0) && hash33(vec3(p+d, iFrame)).z / 0.2 < 0.2) c.r = 0.;\n    \n    // predator death\n    if (r < 0.1) c.b = 0.;\n    \n    // predation\n    if (c.r > 0. && n.b > 0. && r < 2.2) {\n        c.r = 0.;\n        c.b = 1.;\n    }\n    \n    // prey offspring\n    if (c.rb == vec2(0) && n.r > 0. && r < 4. * c.g) c.r = 1.;\n    \n    // grazing\n    if (c.r > 0.) {\n        c.g -= 0.01;\n    } else {\n        c.g += 1e-3 * hash33(vec3(p, floor(iTime))).y;\n    }\n    c.g = clamp(c.g, 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define LOD 6.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame < 10) {\n        fragColor = vec4(0);\n        return;\n    }\n    vec2 p = fragCoord;\n    if (iFrame % 10 == 0) p += vec2(1,0);\n    fragColor = texture(iChannel1, p/iResolution.xy);\n    float cell = pow(2., LOD);\n    vec4 c = textureLod(iChannel0, (0.5 + floor(fragCoord/cell))*cell/iResolution.xy, LOD);\n    float x = mod(fragCoord.x, cell);\n    float y = mod(fragCoord.y, cell);\n    if (x < 5.) fragColor = vec4(0);\n    if (x >= cell - 1.) {\n        if (iFrame % 10 == 0) fragColor = vec4(0);\n        if (abs(y - 5. * c.b * cell) < 0.5) {\n            fragColor.b = 1.;\n        } else if (abs(y - 2. * c.r * cell) < 0.5) {\n            fragColor.r = 1.;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}