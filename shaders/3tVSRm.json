{
    "Shader": {
        "info": {
            "date": "1582424610",
            "description": "Simulates diffraction of light through a grating.\n\nControls:\nA/S zoom in/out\nD/F change number of slits\nC/V change spacing between slits\n\nNumber keys:\n1 - 532 nm, show phases\n2 - 532 nm, show color\n3 - RGB source\n4 - full spectrum\n\n1&2: Mouse: show waves!",
            "flags": 48,
            "hasliked": 0,
            "id": "3tVSRm",
            "likes": 22,
            "name": "Diffraction Grating",
            "published": 3,
            "tags": [
                "simulation",
                "interactive",
                "demo",
                "diffraction"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 1001
        },
        "renderpass": [
            {
                "code": "/*\n\nDiffraction Grating Simulation\nCopyright 2020 Theron Tarigo\n\nSimulates diffraction of light through a grating.\n\nControls:\nA/S zoom in/out\nD/F change number of slits\nC/V change spacing between slits\n\nNumber keys:\n1 - 532 nm, show phases\n2 - 532 nm, show color\n3 - RGB source\n4 - full spectrum\n\nModes 1&2: Mouse: show waves!  Z to toggle showing superposition.\n\n*/\n\nCOMMONDEF\n\nconst float pi = 3.1415927;\nvec2 compsin (float x) { return vec2(cos(x),sin(x)); }\nfloat sinc (float x) { return abs(x)<1e-4?1.:sin(x)/x; }\nfloat square (float a) { return a*a; }\n\nint getFrame() { return iFrame; }\nvec4 readctl (int ch, int n) { return readctlch(iChannel3, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(iChannel2, ivec2(keycode,evt), 0).r>.5;\n}\n\nvec3 complex_color (vec2 v) {\n  vec2 vn = normalize(v);\n  vec3 cb = vec3(1.) + vec3(1,-.5,-.5)*vn.x + vec3(0.,.866,-.866)*vn.y;\n  return cb/dot(cb,vec3(.213,.715,.072))*dot(v,v);\n}\n\nvec2 gfc = vec2(0.);\nfloat cvis = 0.;\n\nvec2 diffraction_pattern(vec2 uv, int nslits, float spacing, float lambda) {\n  float xprop = cvis*iTime;\n  vec2 v = vec2(0.);\n  if (uv.x<0.) {\n    float d = max(1.,abs(uv.y)/(spacing*float(nslits)/2.))-1.;\n    float a = 1./(1.+10.*d*d);\n    v = a*compsin(2.*pi*fract((uv.x-xprop)/lambda))*1e6;\n  }\n  else\n  for (int i=-(nslits/2); i<((nslits+1)/2); i++) {\n    float h = spacing*(float(i)+.5*float((nslits+1)%2));\n    vec2 r = uv-vec2(0.,h);\n    float a = 1./length(r)*(r.x*r.x)/dot(r,r);\n    v+= a*compsin(2.*pi*fract((length(r)-xprop)/lambda));\n  }\n  return v;\n}\n\nvoid diffraction_wavevis(inout vec3 color, vec2 uv, vec2 p, float gscale, int nslits, float spacing, float lambda) {\n  vec4 rnd = paramdither(vec2(uvec2(gfc)/2u), 28841);\n  float xprop = cvis*iTime;\n  for (int i=-(nslits/2); i<((nslits+1)/2); i++) {\n    float h = spacing*(float(i)+.5*float((nslits+1)%2));\n    vec2 s = vec2(0.,h);\n    vec2 r = p-s;\n    vec2 rn = normalize(r);\n    vec2 uvw = mat2(rn.x,-rn.y,rn.y,rn.x)*(uv-p);\n    uvw.x+=length(r);\n    uvw.x-=uvw.y*r.y/r.x;\n    vec2 uvwh = vec2(uvw.x,abs(uvw.y));\n    mat2 window = mat2(0., -gscale, length(r)+2.*gscale*10., 2.*gscale);\n    mat2 domain = mat2(window[0][0], -2., window[0][0]+window[1][0], 2.);\n    float vscale = 1./sqrt(float(nslits));\n    float gsm = smoothstep(.05,.2,fwidth(uv.x)/lambda);\n    float gin = 1.-gsm;\n    vec3 col_single = vec3(0.,.5,1.)*4.;\n    vec3 col_sum = vec3(1.,.5,0.)*4.;\n    gsm*=.02;\n    PLOT_CONTINUOUS(color, uvw, window, domain,  gin*col_single, 0, 1, .02*gscale, cos(2.*pi*fract((x-xprop)/lambda))*vscale );\n    PLOT_CONTINUOUS(color, uvw, window, domain,  gsm*col_single, 1, 1, .02*gscale, 1.*vscale );\n    PLOT_CONTINUOUS(color, uvw, window, domain, -gsm*col_single, 1, 1, .02*gscale, -1.*vscale );\n    #define acompensate (4./x*(r.x*r.x)/dot(r,r))\n    float falloff = 5.*exp(-square((uvw.x-length(r))/gscale)/mix(1.,10.,gin));\n    window[0][1]*=4.; window[1][1]*=4.; domain = mat2(window[0][0], -2., window[0][0]+window[1][0], 2.);\n    if (!KEYBOARD(Z,TOGGLE)) {\n      PLOT_CONTINUOUS(color, uvw, window, domain,  gin*falloff*col_sum, 0, 1, .02*gscale, \n        diffraction_pattern( s + rn*x, nslits, spacing, lambda ).x/acompensate*vscale );\n      PLOT_CONTINUOUS(color, uvw, window, domain,  gsm*falloff*col_sum, 1, 1, .02*gscale, \n        length(diffraction_pattern( s + rn*x, nslits, spacing, lambda ))/acompensate*vscale );\n      PLOT_CONTINUOUS(color, uvw, window, domain, -gsm*falloff*col_sum, 1, 1, .02*gscale, \n        -length(diffraction_pattern( s + rn*x, nslits, spacing, lambda ))/acompensate*vscale );\n    }\n    #undef acompensate\n  }\n}\n\nvoid demo_waves(inout vec3 color, vec2 uv, int nslits, float spacing, vec2 mouse, float gscale) {\n  float lambda = readctl(CTL_LAMBDA).x;\n  diffraction_wavevis(color, uv, mouse, gscale, nslits, spacing, lambda);\n}\n\nvec3 demo_phase(vec2 uv, int nslits, float spacing) {\n  vec3 color = vec3(0.);\n  float lambda = readctl(CTL_LAMBDA).x;\n  vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n  vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n  return mix(complex_color(v),vec3(1.,.7,1.)*dot(v,v),\n    smoothstep(.2,.4,fwidth(uv.x)/lambda));\n}\n\nvec3 demo_single(vec2 uv, int nslits, float spacing) {\n  vec3 color = vec3(0.);\n  float lambda = readctl(CTL_LAMBDA).x;\n  vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n  vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n  return wcol*dot(v,v);\n}\n\nvec3 demo_rgb(vec2 uv, int nslits, float spacing) {\n  vec3 color = vec3(0.);\n  for (int c=0; c<3; c++) {\n    float lambda = 1e-9*float[](650.,532.,450.)[c];\n    float intens = float[](2.17,.94,.57)[c]*2.;\n    vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n    vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n    color+=wcol*dot(v,v)*intens;\n  }\n  return color;\n}\n\nvec3 demo_spectrum(vec2 uv, int nslits, float spacing) {\n  vec4 rnd = paramdither(gfc, 28431);\n  vec3 color = vec3(0.);\n  for (int nw=370; nw<780; nw+=20) { \n    float lambda = (float(nw)+.5*20.*rnd.x)*1e-9;\n    vec2 v = diffraction_pattern(uv, nslits, spacing, lambda);\n    vec3 wcol = wavelength_to_srgbl(lambda*1e9);\n    color+=wcol*dot(v,v);\n  }\n  return color*.4;\n}\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord ) {\n  vec2 mouse = iMouse.xy/iResolution.xy;  \n  vec2 R = iResolution.xy;\n  vec2 uvr = fragCoord/R;\n  gfc = fragCoord;\n  C_iFrame = iFrame;\n  \n  fragData = vec4(0.);\n\n  vec3 color = vec3(0.);\n\n  vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.x;\n  vec2 muv = (2.*iMouse.xy - iResolution.xy) / iResolution.x;\n  uv.x+=.95; muv.x+=.95;\n  float scale = readctl(CTL_SCALE).x;\n  uv/=scale; muv/=scale;\n  uv.x-=5e-6; muv.x-=5e-6;\n  \n  float spacing = readctl(CTL_SLITSPACING).x;\n  float dsize = spacing*readctl(CTL_NSLITS).x;\n  int nslits = int(ceil(dsize/spacing));\n  nslits = clamp(nslits,0,256);\n  \n  int demo = readctli(CTL_WHICHDEMO).x;\n  \n  if (demo==1 || demo==2) {\n    cvis = KEYBOARD(X,TOGGLE) ? 0. : 3e8/1e15;\n  }\n  \n  float isc = 1./pow(scale*20.,2.);\n  isc /= max(float(nslits),32.)/32.;\n\n  if (demo==1) color += demo_phase(uv, nslits, spacing) * isc;\n  if (demo==2) color += demo_single(uv, nslits, spacing) * isc;\n  if (demo==1 || demo==2) {\n    color *= 1. - .8*readctl(CTL_MOUSEEASE).x;\n    if (iMouse.z>0.) demo_waves(color, uv, nslits, spacing, muv, .04/scale);\n  }\n  if (demo==3) color += demo_rgb(uv, nslits, spacing) * isc;\n  if (demo==4) color += demo_spectrum(uv, nslits, spacing) * isc;\n\n  color += .004;\n \n  color = tonemap(color);\n  fragData.rgb = srgbl_to_srgb(color);\n  fragData.rgb += dither(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Collection of utilities from old shaders\n\nconst float C_pi = 3.1415927;\n\n// Expression Plotter by ttg https://www.shadertoy.com/view/3t3XWf\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n    } \\\n  }\n\n\n/*\nhttps://www.shadertoy.com/view/wtGXzm\n\nSpectral tonemap (closest sRGB approximation without banding)\n\nTrying to render spectral colors into screen space with as little desaturation\nas possible given the white-level, and no color banding.\n\n\nMouse: plot R,G,B and Luminance at a horizontal slice through the image.\nHorizontal lines: limits (0 and 1)\n\nTop: Just enough white added so that color-matching RGB values are nonnegative.\nBottom: No white added, negative values get handled by tonemap.\nIn-between: gradient of white.\n\n\n*/\n\n// srgbl - linear srgb\nvec3 wavelength_to_srgbl (float l_nm ) {\n    if (l_nm<370.||l_nm>780.) return vec3(0.);\n    vec4 l = vec4(1.065, 1.014, 1.839, 0.366);\n    vec4 c = vec4(593.,556.3,449.8, 446.);\n    vec4 s = vec4(.056,.075,.051, .043);\n    if (l_nm<446.) s.a = 0.05; // fix creep from violet back to blue\n    if (l_nm>593.) s.r = 0.062; // fix creep from red back to green\n    vec4 v = (log(l_nm)-log(c))/s;\n    vec4 xyzx = l*exp(-.5*v*v);\n    vec3 xyz = xyzx.xyz+vec3(1,0,0)*xyzx.a;\n    const mat3 xyz_to_rgb = \n      mat3(3.240,-.969,.056, -1.537,1.876,-.204, -0.499,0.042,1.057);\n    vec3 rgb = xyz_to_rgb*xyz;\n    return rgb;\n}\n\nfloat rgb_to_lum (vec3 v) {\n  vec3 w = vec3(.213,.715,.072);\n  return dot(w,v);\n}\n\nvec3 rgb_to_hue (vec3 v) {\n  vec2 hv = mat3x2( 1., 0., -.5, .866, -.5,-.866) * v;\n  float h = atan(hv.y,hv.x);\n  v = .5+.5*cos(h-vec3(0,1,2)/3.*2.*C_pi);\n  v -= -log(dot(vec3(1.),exp(-v*10.)))/10.;\n  v/=rgb_to_lum(v);\n  return v;\n}\n\nfloat rgb_to_sat (vec3 v) {\n  v/=rgb_to_lum(v);\n  vec3 h = rgb_to_hue(v);\n  if (any(isnan(h))) return 0.;\n  // doesn't matter which component of (1-v)/(1-h) is used!\n  return dot(vec3(1./3.), (1.-v)/(1.-h) );\n}\n\nvec3 tonemap (vec3 color) {\n  vec3  hue = rgb_to_hue(color);\n  float sat = rgb_to_sat(color);\n  float lum = rgb_to_lum(color);\n\n  // smooth-clamp\n  sat = -log(exp(-sat*10.)+exp(-10.))/10.;\n\n  /* tonemapping options:\n       - desaturate when very bright\n       - smooth-clamp brightness to a maximum that still\n          allows some color variation                              */\n  sat = sat*(exp(-lum*lum*2.));\n  lum = .8*(1.-exp(-lum));\n\n  color = lum*mix(vec3(1.),hue,sat);\n  return color;\n}\n\nvec3 srgbl_to_srgb(vec3 linearRGB) {\n  // https://www.shadertoy.com/view/4tXcWr\n  // By https://www.shadertoy.com/user/Tynach\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nuint triple32(uint x) {\n    // https://www.shadertoy.com/view/WttXWX\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nint C_iFrame;\n\nvec3 dither (vec2 fc) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec3 h = (uvec3(z)>>uvec3(0,8,16))&0xFFu;\n  return vec3(ivec3(h)-128)/128./256.;\n}\n\nvec4 paramdither (vec2 fc, int seed) {\n  uvec2 c = uvec2(fc);\n  uint z = triple32(uint(seed)+c.x+(c.y<<10)+(uint(C_iFrame)<<20));\n  uvec4 h = (uvec4(z)>>uvec4(0,8,16,24))&0xFFu;\n  return vec4(ivec4(h)-128)/128.;\n}\n\nvec4 boxmuller (vec4 r) {\n  vec4 v;\n  v.xy = sqrt(abs(2.*log(r.x+1e-4)))*vec2(cos(2.*C_pi*r.y),sin(2.*C_pi*r.y));\n  v.zw = sqrt(abs(2.*log(r.z+1e-4)))*vec2(cos(2.*C_pi*r.w),sin(2.*C_pi*r.w));\n  return v;\n}\n\nconst struct KEYCODES_T {\n  int A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\n  _0,_1,_2,_3,_4,_5,_6,_7,_8,_9,\n  end;\n} KEYCODES = KEYCODES_T(\n 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,\n 48,49,50,51,52,53,54,55,56,57,\n -1\n);\nconst struct KEYSTATES_T { int DOWN,PRESS,TOGGLE; }\n  KEYSTATES = KEYSTATES_T( 0, 1, 2 );\n\n#define KEYBOARD(NAME,STATE) keyboard(KEYCODES.NAME,KEYSTATES.STATE)\n\nivec4 decodeInteger (vec4 e) {\n    return floatBitsToInt(e)&0x3FFFFFFF;\n}\n\nvec4 encodeInteger (ivec4 d) {\n    return intBitsToFloat((d&0x3FFFFFFF)|0x40000000);\n}\n\nconst ivec2 ctlbuf_size = ivec2(256);\n\nvoid ctlbuf_pack (ivec2 pix, out int ch, out int n) {\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = pix/ivec2(bw,bh);\n  ivec2 bpix  = pix%ivec2(bw,bh);\n  n = bpix.y+bh*bpix.x;\n  ch = block.x+nbx*block.y;\n}\n\nivec2 ctlbuf_unpack(int ch, int n) {\n  if (n<0||n>=ctlbuf_size.x) return ivec2(-1);\n  const int bh = 8;\n  const int bw = ctlbuf_size.y/bh;\n  const int nbx = ctlbuf_size.x/bw;\n  ivec2 block = ivec2(ch%nbx, ch/nbx);\n  ivec2 bpix = ivec2(n/bh, n%bh);\n  return ivec2(bw,bh)*block+bpix;\n}\n\nvec4 readctlch (sampler2D samp, int ch, int n) {\n  ivec2 pix = ctlbuf_unpack(ch,n);\n  if (pix==ivec2(-1)) return vec4(0.);\n  return texelFetch(samp, pix, 0);\n}\n\n#define COMMONDEF \\\nvec4 readctl (int ch, int n); \\\nivec4 readctli (int ch, int n) { return decodeInteger(readctl(ch,n)); }\n\n#define CTL_MOUSETIME 8,0\n#define CTL_MOUSEEASE 8,1\n\n#define CTL_WHICHDEMO 10,0\n#define CTL_SCALE 11,0\n#define CTL_SLITSPACING 11,2\n#define CTL_NSLITS 11,1\n#define CTL_LAMBDA 11,3\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define CH_SELF iChannel3\n#define CH_KEYB iChannel2\n\nvec4 readctl (int ch, int n) { return readctlch(CH_SELF, ch, n); }\nbool keyboard (int keycode, int evt) {\n  return texelFetch(CH_KEYB, ivec2(keycode,evt), 0).r>.5;\n}\n\nvoid mainImage ( out vec4 f, in vec2 fc ) {\n  int ch, n;\n  ctlbuf_pack(ivec2(fc), ch, n);\n  ivec2 chn = ivec2(ch,n);\n  bool init = (iFrame<2);\n  vec4 forig = texelFetch(CH_SELF, ivec2(fc), 0);\n  f = forig;\n  ivec4 d = decodeInteger(forig);\n  // Keyboard\n  if (ch<3) { f = texelFetch(CH_KEYB, ivec2(n,ch), 0); return; }\n  \n  if (chn==ivec2(CTL_MOUSETIME)) {\n    // x: last down, y: last up\n    if (f.x<f.y && iMouse.z>0.) f.x = iTime;\n    if (f.y<f.x && iMouse.z<0.) f.y = iTime;\n  }\n  \n  if (chn==ivec2(CTL_MOUSEEASE)) {\n    float rate = 4.;\n    f.x = mix(f.x, float(iMouse.z>1.), rate*iTimeDelta);\n  }\n  \n  if (chn==ivec2(CTL_WHICHDEMO)) {\n    for (int i=1; i<9; i++) {\n      if (keyboard(48+i,1)) {\n        d.x = i;\n      }\n    }\n    if (init) d.x = 3;\n  }\n  \n  if (chn==ivec2(CTL_SCALE)) {\n    float rate = 2.;\n    if (KEYBOARD(A,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (KEYBOARD(S,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (init) f.x = 8e3;\n    f.x = clamp(f.x, 1e2, 1e5);\n  }\n\n  if (chn==ivec2(CTL_NSLITS)) {\n    float rate = 2.;\n    if (KEYBOARD(D,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (KEYBOARD(F,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (init) f.x = 14.;\n    f.x = clamp(f.x, 1., 100.);\n  }\n\n  if (chn==ivec2(CTL_SLITSPACING)) {\n    float rate = 2.;\n    if (KEYBOARD(C,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (KEYBOARD(V,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (init) f.x = 1.3e-6;\n    f.x = clamp(f.x, 4e-7, 1e-5);\n  }\n\n  if (chn==ivec2(CTL_LAMBDA)) {\n    float rate = .15;\n    if (KEYBOARD(G,DOWN)) f.x/=1.+rate*iTimeDelta;\n    if (KEYBOARD(H,DOWN)) f.x*=1.+rate*iTimeDelta;\n    if (init) f.x = 532e-9;\n    f.x = clamp(f.x, 370e-9, 780e-9);\n  }\n  \n  if (d!=decodeInteger(forig)) f = encodeInteger(d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}