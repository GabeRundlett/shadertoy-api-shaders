{
    "Shader": {
        "info": {
            "date": "1474732054",
            "description": "Another.",
            "flags": 0,
            "hasliked": 0,
            "id": "4tV3DD",
            "likes": 6,
            "name": "Another Yet Another IFS",
            "published": 3,
            "tags": [
                "ifs",
                "another",
                "yet"
            ],
            "usePreview": 0,
            "username": "vox",
            "viewed": 539
        },
        "renderpass": [
            {
                "code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n#define GRID_WIDTH 8.0\n#define GRID_HEIGHT 8.0\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI*(-1.0)+1.0)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//#define iTime (iTime*.1)\n\nvoid plane1(in vec2 uv, out vec3 p1, out vec3 p2)\n{\n        \n    float theta1 = uv.x*2.0*PI;\n    float theta2 = theta1+uv.y*PI*2.0;\n\n\n    float omega1 = theta1;\n    float omega2 = theta2+time*sign(cos(uv.x*PI));\n\n    float index = (uv.x*GRID_WIDTH+uv.y*GRID_WIDTH*GRID_HEIGHT);\n    \n    float t = time;\n    vec2 c1 = vec2(cos(index*PI/2.0+t),\n                   sin(index*PI/2.0+t));\n\n    p1 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n\t\n    omega1 += c1.x/PI/GR/E;\n    omega2 += c1.y/PI/GR/E;\n    \n    p2 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n}\n\nvoid plane2(in vec2 uv, out vec3 p1, out vec3 p2)\n{\n        \n    float theta1 = uv.x*2.0*PI;\n    float theta2 = theta1+uv.y*PI*2.0;\n\n\n    float omega1 = theta1;\n    float omega2 = theta2+time*sign(cos(uv.x*PI));\n\n    float index = (uv.x*GRID_WIDTH+uv.y*GRID_WIDTH*GRID_HEIGHT);\n    \n    float t = time;\n    vec2 c1 = vec2(cos(index*PI/2.0+t),\n                   sin(index*PI/2.0+t));\n\n    p1 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n\t\n    omega1 += c1.x/PI/GR/E;\n    omega2 += c1.y/PI/GR/E;\n    \n    p2 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n}\n\nvoid plane3(in vec2 uv, out vec3 p1, out vec3 p2)\n{\n        \n    float theta1 = uv.x*2.0*PI;\n    float theta2 = theta1+uv.y*PI*2.0;\n\n\n    float omega1 = theta1;\n    float omega2 = theta2+time*sign(cos(uv.x*PI));\n\n    float index = (uv.x*GRID_WIDTH+uv.y*GRID_WIDTH*GRID_HEIGHT);\n    \n    float t = time;\n    vec2 c1 = vec2(cos(index*PI/2.0+t),\n                   sin(index*PI/2.0+t));\n\n    p1 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n\t\n    omega1 += c1.x/PI/GR/E;\n    omega2 += c1.y/PI/GR/E;\n    \n    p2 = vec3(cos(omega1)*sin(omega2),\n                   sin(omega1)*sin(omega2),\n                   cos(omega2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\t//vec3 eye = vec3(0.0, 0.0, 3.0);\n\tvec3 eye = vec3(cos(iTime), sin(iTime*.5), sin(iTime))*2.0;\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 foward = normalize(look-eye);\n    vec3 right = normalize(cross(foward, up));\n    up = normalize(cross(right, foward));\n    vec3 ray = normalize(foward+uv.x*right+uv.y*up);\n    \n    fragColor = vec4(0.0);\n    \n \tconst float outerCount = GRID_WIDTH;\n \tconst float innerCount = GRID_HEIGHT;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        if(i >= outerCount)\n            break;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            if(j >= innerCount)\n                break;\n            vec3 p1 = vec3(0.0);\n            vec3 p2 = vec3(0.0);\n            \n            vec2 xy = vec2(i, j)/vec2(outerCount, innerCount);\n            \n            vec3 weight = flux(time/PI/2.0);\n            \n            vec3 temp1, temp2;\n            plane1(xy, temp1, temp2);\n            p1 += weight.x*temp1;\n            p2 += weight.x*temp2;\n            plane2(xy, temp1, temp2);\n            p1 += weight.y*temp1;\n            p2 += weight.y*temp2;\n            plane3(xy, temp1, temp2);\n            p1 += weight.z*temp1;\n            p2 += weight.z*temp2;\n            vec3 ray2 = normalize(p2-p1);\n            \n            float a = dot(ray,ray);\n            float b = dot(ray,ray2);\n            float c = dot(ray2,ray2);\n            float d = dot(ray,eye-p1);\n            float e = dot(eye-p1,ray2);\n            \n            float t1 = (b*e-c*d)/(a*c-b*b);\n            float t2 = (a*e-b*d)/(a*c-b*b);\n            \n            float dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            float lineWidth = 50.0/max(iResolution.x, iResolution.y);\n            \n            float lineLength = 2.5+.5*sin(time);\n            \n            float isFoward = (sign(t1)*.5+.5);\n            \n            \n            \n                float sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                float ends = (1.0-smoothstep(0.0, lineLength, abs(t2)));\n                float line = sides*ends*isFoward;\n                \n                map += line*(1.0+i/innerCount+j/outerCount)/2.0;\n                sum += 1.0*line*isFoward;\n        }\n    }\n    \n\tfragColor = vec4(flux(PI*map/sum+time), 1.0)*clamp(map, 0.0, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}