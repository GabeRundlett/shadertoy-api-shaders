{
    "Shader": {
        "info": {
            "date": "1529213660",
            "description": "Fast Real Time RayTracing!\nThe \"Lab\" Scene by 834144373.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdVfRm",
            "likes": 102,
            "name": "Fast Path Tracing[Lab]!",
            "published": 3,
            "tags": [
                "gi",
                "pathtrace",
                "pathtracing",
                "mis",
                "brdf",
                "ggx",
                "vndf"
            ],
            "usePreview": 1,
            "username": "834144373",
            "viewed": 4639
        },
        "renderpass": [
            {
                "code": "/*\n\t\"Fast PathTracing[Lab]!\" by 834144373(恬纳微晰)\n\tThis shader url : https://www.shadertoy.com/view/XdVfRm\n\tLicence: CC3.0 署名（BY）-非商业性使用（NC）-相同方式共享（SA）\n\tAlso 834144373 is 恬纳微晰 or TNWX or 祝元洪\n*/\n/*\n--------------------Main Reference Knowledge-------------------\nMIS: [0]https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf\n     [1]https://hal.inria.fr/hal-00942452v1/document\n     [2]Importance Sampling Microfacet-Based BSDFs using the Distribution of Visible Normals. Eric Heitz, Eugene D’Eon\n     [3]Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Eric Heitz\n     [4]Microfacet Models for Refraction through Rough Surfaces. Bruce Walter, Stephen R. Marschner, Hongsong Li, Kenneth E. Torrance\n\tNote: More details about theory and math you can easy find on \"Common\" shader.\n*/\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 R = iResolution.xy;\n   \tvec2 uv = U/R;\n    \n    /*\n\t\tThanks for reinder suggestion for anti-aliasing,:)\n\t\tI uncomment FXAA and added the Triangular Noise for camera dither.\n\t\tif you don't do the some tracing,like game,the best is \"Triangular Noise and TAA\".\n\t\tAnd if you just do a fewer sample with tracing,it seems \"AI-Denoise\" can help you.\t\n\t*/\n    //C = FXAA(iChannel0,uv,R);\n    C = texture(iChannel0,uv);\n    \n    //C.rgb = ExposureCorrect(C.rgb,1.1, -1.3);\n    C.rgb = ExposureCorrect(C.rgb,2.1, -0.8);\n    C.rgb = ACESFilmicToneMapping(C.rgb);\n}\n\n/* \n\tHum... if you see black point on screen,please report,\n\tbecause it's NAN point,so thanks :)\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tThe mathematics details by 834144373(恬纳微晰)\n\tThis shader url : https://www.shadertoy.com/view/XdVfRm\n\tLicence: CC3.0 署名（BY）-非商业性使用（NC）-相同方式共享（SA）\n\tAlso 834144373 is 恬纳微晰 or TNWX or 祝元洪\n*/\n//----------Some For Option Math Constant Define---------\n#define MY_E \t\t\t\t\t2.7182818\n#define ONE_OVER_E\t\t\t\t0.3678794\n#define PI \t\t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t\t6.2831852\n#define FOUR_PI \t\t\t\t12.566370\n#define INVERSE_PI \t\t\t\t0.3183099\n#define ONE_OVER_TWO_PI \t\t0.1591549\n#define ONE_OVER_FOUR_PI \t\t0.0795775\n#define OFFSET_COEF \t\t\t0.0001\n#define INFINITY         \t\t1000000.0\n//--------------------Material Fresnel-------------------- \n//水\n#define F0_WATER        0.02\t\n//塑料\n#define F0_PLASTIC      0.03\t\n//塑料-主高光\n#define F0_PLASTIC_HIGH 0.05\t\n//玻璃\n#define F0_GLASS        0.08\t\n//钻石\n#define F0_DIAMOND      0.17\t\n//铁制\n#define F0_IRON         0.56\t\n//铜制\n#define F0_COPPER       0.95\t\n//金制\n#define F0_GOLD         1.00\t\n//铝制\n#define F0_ALUMINIUM    0.91\t\n//银制\n#define F0_SILVER       0.95\n\n//Monte Carlo by Importance Samplering Methods\n/*\n \tF(N) ≈ (1/N) * SUM( f(Xi)/pdf(Xi) ) <1,N>\n*/\n//----------------------Math Function---------------------\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\n#if __VERSION__ >= 300\nfloat FastSqrt(float x){return intBitsToFloat(532483686 + (floatBitsToInt(x) >> 1));}\n#endif\nfloat POW2(float x){ return x*x;}\nfloat POW3(float x){ return x*x*x;}\nfloat POW4(float x){ float x2 = x*x; return x2*x2;}\nfloat POW5(float x){ float x2 = x*x; return x2*x2*x;}\n\nfloat Complement(float coeff){ return 1.0 - coeff; }\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return w.z*w.z; }\nfloat cosTheta4(vec3 w) { float cos2Theta = cosTheta2(w); return cos2Theta*cos2Theta;}\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return Complement(w.z*w.z); }\nfloat sinTheta(vec3 w) { return sqrt(clamp(sinTheta2(w),0.,1.)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\n\nfloat cosPhi(vec3 w) { return w.x / sinTheta(w);}\nfloat sinPhi(vec3 w) { return w.y / sinTheta(w);}\nfloat cosPhi2(vec3 w){ return w.x*w.x/sinTheta2(w);}\nfloat sinPhi2(vec3 w){ return w.y*w.y/sinTheta2(w);}\n//angle(θ,ϕ)\nvec3 Angle2Cartesian(vec2 angle){\n\tfloat SinTheta = sin(angle.x);\n\tvec2 CosSinPhi = vec2(cos(angle.y),sin(angle.y));\n\treturn vec3(SinTheta*CosSinPhi,cos(angle.x)); //x,y,z\n}\n//计算正交向量基\n//http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nvoid naive (vec3 n,vec3 b1,vec3 b2){\n    // If n is near the x-axis , use the y- axis . Otherwise use the x- axis .\n    if(n.x > 0.9) b1 = vec3(0.0,1.0,0.0);\n    else b1 = vec3(1.0,0.0,0.0);\n    b1 -= n* dot (b1 , n ); // Make b1 orthogonal to n\n    b1 *= inversesqrt(dot(b1,b1)); // Normalize b1\n    b2 = cross (n , b1 ); // Construct b2 using a cross product\n}\nvoid hughes_moeller (vec3 n,vec3 b1,vec3 b2 ){\n    // Choose a vector orthogonal to n as the direction of b2.\n    if(abs(n.x )>abs(n.z)) b2 = vec3(-n.y,n.x,0.);\n    else b2 = vec3 (0.,-n.z,n.y );\n    b2 *= inversesqrt(dot(b2,b2 )); // Normalize b2\n    b1 = cross (b2 , n ); // Construct b1 using a cross product\n}\nvoid frisvad(in vec3 n, out vec3 f, out vec3 r){\n    if(n.z < -0.999999) {\n        f = vec3(0.,-1,0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1.+n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\nmat3 CoordBase(vec3 n){\n\tvec3 x,y;\n    frisvad(n,x,y);\n    return mat3(x,y,n);\n}\n\n\nvec3 ToOtherSpaceCoord(mat3 otherSpaceCoord,vec3 vector){\n\treturn vector * otherSpaceCoord;\n}\nvec3 RotVector(mat3 otherSpaceCoord,vec3 vector){\n\treturn otherSpaceCoord * vector;\n}\n//-----------------Specular BRDF Microfacet---------------\n/*\n\t\t\t   D(h)F(v,h)G(l,v,h)\t\tD(Distribution)   \n\tf(l,v) = ———————————-    F(Fresnel)\n\t\t\t\t   4(n•l)(n•v)\t\t\tG(Geometry)\n*/\n//--->Distribution Term<----\nfloat D_GGX(float roughress,vec3 N,vec3 H){\n\tfloat r2 = POW2(roughress);\n    float cosTheta2 = POW2(dot(N,H));\n    return (1.0/PI) * sqrt(roughress/(cosTheta2 * (r2 - 1.0) + 1.0));\t\n}\n//------>Fresnel Term<------\nfloat F_Schlick(float F0, vec3 L,vec3 H){\n    return F0 + (1.0 - F0)*POW5(1.0-dot(L,H));\n}\n/*\n\thttps://github.com/thefranke/dirtchamber/blob/master/shader/brdf.hlsl\n*/\n#define OneOnLN2_x6 8.656170 // == 1/ln(2) * 6   (6 is SpecularPower of 5 + 1)\nvec3 F_schlick_opt(vec3 SpecularColor,vec3 E,vec3 H){\n    // In this case SphericalGaussianApprox(1.0f - saturate(dot(E, H)), OneOnLN2_x6) is equal to exp2(-OneOnLN2_x6 * x)\n    return SpecularColor + (1.0 - SpecularColor) * exp2(-OneOnLN2_x6 * clamp(0.,1.,dot(E, H)));\n}\n//------------Multiple Importance Sample Weight-----------\n/*\n\theuristic\n\there βis 2;so power of coeff\n*/\nfloat MISWeight(float a,float b){\n\tfloat a2 = a*a;\n\tfloat b2 = b*b;\n\treturn a2/(a2+b2);\n}\nfloat MISWeight(float coffe_a,float aPDF,float coffe_b,float bPDF){\n    return MISWeight(coffe_a * aPDF,coffe_b*bPDF);\n}\n//--------------Probability Density Function and Sample--------------\n/*\n\t----------------GGX NDF-----------------\n\tD(m)  \t = a^2/(PI*((a^2-1)*cos^2(θ)+1)^2)\n\tPh(ω) \t= a^2*cos(θ)/(PI*((a^2-1)*cos^2(θ)+1)^2) \n\tPh(θ,ϕ) = a^2*cos(θ)*sin(θ)/(PI*((a^2-1)*cos^2(θ)+1)^2)\n\tSo we can get θ,ϕ by inverse CDF\n\t\tϕ = 2*PI*ϵ      \n\t\tθ = arccos{sqrt[(1-ϵ)/(ϵ*(a^2-1)+1)]} Or θ = arctan{a*sqrt[ϵ/(1-ϵ)]} \n\tNote: ϵ or 1-ϵ is uniform distribution noise at (0,1)\n*/\nvec2 GGXSampleAngle(float x1,float x2,float a){\n\tfloat phi   = TWO_PI * x2;\n\tfloat theta = atan(a*sqrt(x1/(1.0-x1)));\n\treturn vec2(theta,phi);\n}\n/*\n\t----------------Beckmann NDF-----------------\n\tD(m)  \t= \t   1/(PI*a^2*cos^4(θ)))*ϵ^-(tan(θ)/a)^2\n\tPh(ω) \t= \t   1/(PI*a^2*cos^3(θ)))*ϵ^-(tan(θ)/a)^2\n\tPh(θ,ϕ) = sin(θ)/(PI*a^2*cos^3(θ)))*ϵ^-(tan(θ)/a)^2\n\tSo we can get θ,ϕ by inverse CDF\n\t\tϕ = 2*PI*ϵ      \n\t\tθ = arccos{sqrt[1/(1-a^2*ln(1-ϵ))]} Or θ = arctan{sqrt[-a^2*ln(1-ϵ)]} \n\tNote: ϵ or 1-ϵ is uniform distribution noise at (0,1)\n*/\nvec2 BeckmannSampleAngle(float x1,float x2,float a){\n\tfloat phi\t= TWO_PI * x2;\n\tfloat theta = atan(sqrt(-a*a*log(1.0-x1)));\n\treturn vec2(theta,phi);\n}\n/*\n\t----------------Blinn NDF-----------------\n\tD(m)  \t = (a+2)/_2PI * [cos(θ)]^(a)\n\tPh(ω) \t= (a+2)/_2PI * [cos(θ)]^(a+1)\n\tPh(θ,ϕ) = (a+2)/_2PI * [cos(θ)]^(a+1) * sin(θ)\n\tSo we can get θ,ϕ by inverse CDF\n\t\tϕ = 2*PI*ϵ      \n\t\tθ = arccos{1/(ϵ^(a+2))}  Or  θ = arccos{1/(ϵ^(a+1))}  <note:form PBRT>\n\tNote: ϵ or 1-ϵ is uniform distribution noise at (0,1)\n*/\nvec2 BlinSampleAngle(float x1,float x2,float a){\n\tfloat phi   = TWO_PI * x2;\n\tfloat theta = acos(1.0/pow(x1,a+1.0));\t\t//<note:form PBRT>\n\treturn vec2(theta,phi);\n}\n/*---------------------------------\n\tWhether it’s solid angle or spherical coordinate. \n\tWhat we have so far is the pdf for half-vector,a transformation is necessary.\n---> P(θ) = Ph(θ)*(dWh)/(dWi) = Ph(θ)/(4*Wo*wh)\n*/\nfloat PDF_h2theta(float pdf_h,vec3 wi,vec3 wh){\n\treturn 0.25*pdf_h/dot(wi,wh);//return pdf_h/(4.0*dot(wo,wh));\n}\nvec3 UniformUnitShpereRay(float x1,float x2){\n\tfloat theta = PI * x1;\n    float phi   = TWO_PI * x2;\n    float sinTheta = sin(theta);\n    return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cos(theta));\n}\nvec3 DiffuseUnitSpehreRay(float x1,float x2){\n\tfloat theta = acos(sqrt(1.0-x1));\n    float phi   = TWO_PI * x2;\n    float sinTheta = sin(theta);\n    return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cos(theta));\n}\n/*\nForm https://www.shadertoy.com/view/4ssXRX\n\t https://www.shadertoy.com/view/MslGR8\n\t https://www.loopit.dk/banding_in_games.pdf\n*/\nfloat nrand( vec2 n ){\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//float GetRandom(float seed){return fract(sin(seed)*43758.5453123);}\nfloat TriangularNoise(vec2 n,float time){\n    float t = fract(time);\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\nvec2 TriangularNoise2DShereRay(vec2 n,float time){\n\tfloat theta = TWO_PI*GetRandom();\n    float r = TriangularNoise(n,time);\n    return vec2(cos(theta),sin(theta))*(1.-r);\n}\n//---------------VNDF-----------------\n/*\n\thttps://hal.inria.fr/hal-00942452v1/document\n\thttps://hal.archives-ouvertes.fr/hal-01509746/document\n\thttps://hal.inria.fr/file/index/docid/996995/filename/article.pdf\n\tand some reference https://www.shadertoy.com/view/llfyRj\n  \talpha_x/alpha_y is anisotropic roughness; U1/U2 is uniform random numbers\n*/\nvec3 sampleGGXVNDF(vec3 V_, float alpha_x, float alpha_y, float U1, float U2){\n\t// stretch view\n\tvec3 V = normalize(vec3(alpha_x * V_.x, alpha_y * V_.y, V_.z));\n\t// orthonormal basis\n\tvec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0,0,1))) : vec3(1,0,0);\n\tvec3 T2 = cross(T1, V);\n\t// sample point with polar coordinates (r, phi)\n\tfloat a = 1.0 / (1.0 + V.z);\n\tfloat r = sqrt(U1);\n\tfloat phi = (U2<a) ? U2/a * PI : PI + (U2-a)/(1.0-a) * PI;\n\tfloat P1 = r*cos(phi);\n\tfloat P2 = r*sin(phi)*((U2<a) ? 1.0 : V.z);\n\t// compute normal\n\tvec3 N = P1*T1 + P2*T2 + sqrt(max(0.0, 1.0 - P1*P1 - P2*P2))*V;\n\t// unstretch\n\tN = normalize(vec3(alpha_x*N.x, alpha_y*N.y, max(0.0, N.z)));\n\treturn N;\n}\n/*\n------>GGX Distribution\n*/\nfloat GGX_Distribution(vec3 wh, float alpha_x, float alpha_y) {\n    float tan2Theta = tanTheta2(wh);\n    if(alpha_x == alpha_y){\n    \t//------when alpha_x == alpha_y so\n    \tfloat c = alpha_x + tan2Theta/alpha_x;\n    \treturn 1.0/(PI*cosTheta4(wh)*c*c);\n\t}else{\n\t\tfloat alpha_xy = alpha_x * alpha_y;\n\t\tfloat e_add_1 = 1. + tan2Theta / alpha_xy;\n    \treturn 1.0 / (PI * alpha_xy * cosTheta4(wh) * e_add_1 * e_add_1);\n\t}\n}\n/*\n    \tΛ(ω) = (-1+sign(a)sqrt(1+1/(a*a))/2 where a = 1/(ai*tan(theta_i))   \t<0,π>\n\tso  Λ(ω) = (-1+sqrt(1+ai^2*tan^2(θ)))/2\t\t<0,π/2>\n*/\nfloat lambda(vec3 w, float alpha_x, float alpha_y){\n\treturn 0.5*(-1.0 + sqrt(1.0 + alpha_x*alpha_y*tanTheta2(w)));\n}\n/*\n\t  G (wo,wi) = G1(wo)G1(wi) \n\t  G1(ωo,ωm) = 1/(1+Λ(ωo)) \n*/\nfloat GGX_G1(vec3 w, float alpha_x, float alpha_y) {\n    return 1.0 / (1.0 + lambda(w, alpha_x, alpha_y));\n}\n/*\n\thttps://jo.dreggn.org/home/2016_microfacets.pdf\n\tG2(ωi, ωo, ωm) is masking-shadowing\n\tG2(ωi, ωo, ωm) = G1(ωi, ωm)G1(ωo, ωm)  [Walter et al.2007]\n\t\t<If ωi and ωo are on the same side of the microsurface (i.e. reflection),it has the closed for>\n\tG2(ωi, ωo) = 1/[1+Λ(ωi)+Λ(ωo)]\n\n------>GGX Geometry\n*/\nfloat GGX_G2(vec3 wo, vec3 wi, float alpha_x, float alpha_y) {\n    return 1.0 / (1.0 + lambda(wo, alpha_x, alpha_y) + lambda(wi, alpha_x, alpha_y));\n}\n/*\n\thttps://hal.inria.fr/hal-00996995v1/document\n\tPDF(ωm·ωg)D(ωm)\t previous\n\tPDF Dωi(ωm)\t\t   now this\n\t\tDωi(ωm) = G1(ωi,ωm)|ωi·ωm|D(ωm)/|ωi·ωg|\n*/\nfloat GGX_PDF(vec3 wi, vec3 wh, float alpha_x, float alpha_y) {\n    return GGX_Distribution(wh, alpha_x, alpha_y) * GGX_G1(wi, alpha_x, alpha_y) * abs(dot(wi, wh)) / abs(wi.z);\n}\n//For Diffuse Lambert Sample\nfloat Diffuse_PDF(vec3 L){\n\treturn INVERSE_PI*cosTheta(L);\n}\n//For Reflect Micro-fact Sample\nfloat Specular_PDF(vec3 wi, vec3 wh, float alpha_x, float alpha_y){\n\treturn PDF_h2theta(GGX_PDF(wi,wh,alpha_x,alpha_y),wi,wh); \n}\n//--------------------Post Processing---------------------\nvec3 GammaCorrect(vec3 col,float coeff){\n\treturn pow(col,vec3(coeff));\n}\nvec3 GammaCorrect(vec3 col,vec3 coeff){\n\treturn pow(col,coeff);\n}\nvec3 ExposureCorrect(vec3 col, float linfac, float logfac){\n\treturn linfac*(1.0 - exp(col*logfac));\n}\n/*\n\tAn almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n*/\nvec3 GammaToLinear(vec3 sRGB){\n    return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 LinearToGamma(vec3 linRGB){\n    linRGB = max(linRGB, vec3(0.));\n    return max(1.055 * pow(linRGB, vec3(0.416666667)) - 0.055, vec3(0.));\n}\nvec3 SimpleToneMapping(vec3 col){\n\treturn 1.0/(1.0+col);\n}\nfloat Luminance(vec3 linearRGB){\n    return dot(linearRGB, vec3(0.2126729,  0.7151522, 0.0721750));\n}\n//------------------------YCoCg-R---------------------------\n//x:Y y:Co z:Cg\n/*\n\tCo  = R - B;\n\ttmp = B + Co/2;\n\tCg  = G - tmp;\n\tY   = tmp + Cg/2;\n*/\nvec3 RGB2YCoCg_R(vec3 RGB) {\n\tvec3 YCoCg_R;//x:Y y:Co z:Cg\n\tYCoCg_R.y = RGB.r - RGB.b;\n\tfloat tmp = RGB.b + YCoCg_R.y / 2.;\n\tYCoCg_R.z = RGB.g - tmp;\n\tYCoCg_R.x = tmp + YCoCg_R.z / 2.;\n\treturn YCoCg_R;\n}\n/*\n\ttmp = Y - Cg/2;\n\tG   = Cg + tmp;\n\tB   = tmp - Co/2;\n\tR   = B + Co;\n*/\nvec3 YCoCg_R2RGB(vec3 YCoCg_R) {\n\tvec3 RGB;\n\tfloat tmp = YCoCg_R.x - YCoCg_R.z / 2.;\n\tRGB.g = YCoCg_R.z + tmp;\n\tRGB.b = tmp - YCoCg_R.y / 2.;\n\tRGB.r = RGB.b + YCoCg_R.y;\n\treturn RGB;\n}\n//-------------------------YCoCg----------------------------\n/*\n\t Y = R/4 + G/2 + B/4\n\tCo = R/2 - B/2\n\tCg =-R/4 + G/2 - B/4\n*/\nvec3 RGB2YCoCg(vec3 RGB) {\n\tvec3 YCoCg;\n\tYCoCg.x =  RGB.r / 4. + RGB.g / 2. + RGB.b / 4.;\n\tYCoCg.y =  RGB.r / 2. - RGB.b / 2. ;\n\tYCoCg.z = -RGB.r / 4. + RGB.g / 2. - RGB.b / 4.;\n\treturn YCoCg;\n}\n/*\n\tR = Y + Co - Cg\n\tG = Y + Cg\n\tB = Y - Co - Cg\n*/\nvec3 YCoCg2RGB(vec3 YCoCg) {\n\tvec3 RGB;\n\tRGB.r = YCoCg.x + YCoCg.y - YCoCg.z;\n\tRGB.g = YCoCg.x + YCoCg.z;\n\tRGB.b = YCoCg.x - YCoCg.y - YCoCg.z;\n\treturn RGB;\n}\n/*\n\tACES\n\thttps://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n*/\nvec3 ACESFilm(vec3 x ){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp(vec3(0.),vec3(1.),(x*(a*x+b))/(x*(c*x+d)+e));\n}\n/*\n\thttp://filmicworlds.com/blog/filmic-tonemapping-operators/\n\thttps://de.slideshare.net/hpduiker/filmic-tonemapping-for-realtime-rendering-siggraph-2010-color-course\n*/\nconst float A = 0.15;//ShoulderStrength\nconst float B = 0.50;//LinearStrength\nconst float C = 0.10;//LinearAngle\nconst float D = 0.20;//ToeStrength\nconst float E = 0.02;\nconst float F = 0.30;\nconst float W = 10.2;\n\nvec3 Uncharted2Tonemap(vec3 x){\n   \treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n#define Gamma 2.2\nvec3 ACESFilmicToneMapping(vec3 col){\n\tvec3 curr = Uncharted2Tonemap(col);\n    const float ExposureBias = 2.0;\n\tcurr *= ExposureBias;\n    curr /= Uncharted2Tonemap(vec3(W));\n    return LinearToGamma(curr);\n}\n/*\n\thttps://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ToneMapping.hlsl\n*/\nvec3 Linear2sRGB(vec3 color){\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(vec3(0.),vec3(1.),color),vec3(0.4166667)) - 0.055;\n    vec3 clr = color;\n    clr.r = color.r < 0.0031308 ? x.r : y.r;\n    clr.g = color.g < 0.0031308 ? x.g : y.g;\n    clr.b = color.b < 0.0031308 ? x.b : y.b;\n    return clr;\n}\nvec3 sRGB2Linear(vec3 color){\n    vec3 x = color / 12.92f;\n    vec3 y = pow(max((color+0.055f)/1.055, 0.0),vec3(2.4));\n    vec3 clr = color;\n    clr.r = color.r <= 0.04045 ? x.r : y.r;\n    clr.g = color.g <= 0.04045 ? x.g : y.g;\n    clr.b = color.b <= 0.04045 ? x.b : y.b;\n    return clr;\n}\n// Applies the filmic curve from John Hable's presentation\nvec3 ToneMapFilmicALU(vec3 color){\n    color = max(vec3(0.),color-0.004);\n    color = (color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06);\n    return color;\n}\nvec3 ColorGrade(vec3 vColor){\n    vec3 vHue = vec3(.97, .8, .2);\n    vec3 vGamma = 1. + vHue * 0.6;\n    vec3 vGain = vec3(0.9) + vHue * vHue * 8.0;\n    vColor *= 1.5;\n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\n#define _LUT_Size 16.\nvec3 ColorGradeLUT(sampler2D _LUT,vec3 color) {\n    vec3 coord = color*(_LUT_Size -1.);\n    coord.xy = vec2((coord.x + _LUT_Size*floor(coord.z)+.5)/ (_LUT_Size*_LUT_Size),(coord.y+0.5)/ _LUT_Size);\n    return texture(_LUT,coord.xy).rgb;\n}\n\n/*\n\thttps://www.shadertoy.com/view/MdyyRt from 834144373\n\tOr you can easy find from wiki\n*/\n#define _Strength 10.\nvec4 FXAA(sampler2D _Tex,vec2 uv,vec2 RenderSize){\n    vec3 e = vec3(1./RenderSize,0.);\n\n    float reducemul = 0.125;// 1. / 8.;\n    float reducemin = 0.0078125;// 1. / 128.;\n\n    vec4 Or = texture(_Tex,uv); //P\n    vec4 LD = texture(_Tex,uv - e.xy); //左下\n    vec4 RD = texture(_Tex,uv + vec2( e.x,-e.y)); //右下\n    vec4 LT = texture(_Tex,uv + vec2(-e.x, e.y)); //左上\n    vec4 RT = texture(_Tex,uv + e.xy); // 右上\n\n    float Or_Lum = Luminance(Or.rgb);\n    float LD_Lum = Luminance(LD.rgb);\n    float RD_Lum = Luminance(RD.rgb);\n    float LT_Lum = Luminance(LT.rgb);\n    float RT_Lum = Luminance(RT.rgb);\n\n    float min_Lum = min(Or_Lum,min(min(LD_Lum,RD_Lum),min(LT_Lum,RT_Lum)));\n    float max_Lum = max(Or_Lum,max(max(LD_Lum,RD_Lum),max(LT_Lum,RT_Lum)));\n\n    //x direction,-y direction\n    vec2 dir = vec2((LT_Lum+RT_Lum)-(LD_Lum+RD_Lum),(LD_Lum+LT_Lum)-(RD_Lum+RT_Lum));\n    float dir_reduce = max((LD_Lum+RD_Lum+LT_Lum+RT_Lum)*reducemul*0.25,reducemin);\n    float dir_min = 1./(min(abs(dir.x),abs(dir.y))+dir_reduce);\n    dir = min(vec2(_Strength),max(-vec2(_Strength),dir*dir_min)) * e.xy;\n\n    //------\n    vec4 resultA = 0.5*(texture(_Tex,uv-0.166667*dir)+texture(_Tex,uv+0.166667*dir));\n    vec4 resultB = resultA*0.5+0.25*(texture(_Tex,uv-0.5*dir)+texture(_Tex,uv+0.5*dir));\n    float B_Lum = Luminance(resultB.rgb);\n\n    //return resultA;\n    if(B_Lum < min_Lum || B_Lum > max_Lum)\n        return resultA;\n    else \n        return resultB;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n\t\"Fast PathTracing[Lab]!\" by 834144373(恬纳微晰)\n\tThis shader url : https://www.shadertoy.com/view/XdVfRm\n\tLicence: CC3.0 署名（BY）-非商业性使用（NC）-相同方式共享（SA）\n\tAlso 834144373 is 恬纳微晰 or TNWX or 祝元洪\n*/\n/*\n--------------------Main Reference Knowledge-------------------\nMIS: [0]https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf\n     [1]https://hal.inria.fr/hal-00942452v1/document\n     [2]Importance Sampling Microfacet-Based BSDFs using the Distribution of Visible Normals. Eric Heitz, Eugene D’Eon\n     [3]Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Eric Heitz\n     [4]Microfacet Models for Refraction through Rough Surfaces. Bruce Walter, Stephen R. Marschner, Hongsong Li, Kenneth E. Torrance\n\tNote: More details about theory and math you can easy find on \"Common\" shader.\n*/\n#define GI_DEPTH 3\n\n/*Scene Objects*/\n#define N_SPHERES 3\n#define N_ELLIPSOIDS 1\n#define N_OPENCYLINDERS 1\n#define N_CONES 1\n#define N_DISKS 1\n#define N_QUADS 1\n#define N_BOXES 1\n\n/*Type*/\n#define LIGHT 0\n#define DIFF 1\n#define REFR 2\n#define SPEC 3\n#define CHECK 4\n#define COAT 5\n#define VOLUME 6\n#define TRANSLUCENT 7\n#define SPECSUB 8\n#define WATER 9\n#define WOOD 10\n#define SEAFLOOR 11\n#define TERRAIN 12\n#define CLOTH 13\n#define LIGHTWOOD 14\n#define DARKWOOD 15\n#define PAINTING 16\n\nconst vec3 BACKGROUD_COL = vec3(0.,0.,0.);\n\nconst vec3 ZERO = vec3(0.,0.,0.);\nconst vec3 ONE  = vec3(1.,1.,1.);\nconst vec3 UP   = vec3(0.,1.,0.);\n//const vec3 FORWORD = vec3(0.,0.,1.);\n//const vec3 RIGHT   = vec3(1.,0.,0.);\n\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Sphere { float radius; vec3 position; vec3 emission; vec3 color; float roughness; int type; };\nstruct Ellipsoid { vec3 shape; vec3 position; vec3 emission; vec3 color; float roughness; int type; };\nstruct OpenCylinder { float radius; vec3 pos1; vec3 pos2; vec3 emission; vec3 color; float roughness; int type; };\nstruct Cone { vec3 pos0; float radius0; vec3 pos1; float radius1; vec3 emission; vec3 color; float roughness; int type; };\nstruct Disk { float radiusSq; vec3 pos; vec3 normal; vec3 emission; vec3 color; float roughness; int type; };\nstruct Quad { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 v3; vec3 emission; vec3 color; float roughness; int type; };\nstruct Box { vec3 minCorner; vec3 maxCorner; vec3 emission; vec3 color; float roughness; int type; };\nstruct Intersection {float distance;vec2 uv; vec3 normal; vec3 emission; vec3 color; float roughness; int type; };\n\nstruct Light{float radius;vec3 direction;vec3 emission;float radiance;float pdf;int type;};\nstruct Material{float id;vec2 uv;vec3 normal;vec3 specular;vec3 diffuse;float roughness;int type;}; \n    \nSphere spheres[N_SPHERES];\nEllipsoid ellipsoids[N_ELLIPSOIDS];\nOpenCylinder openCylinders[N_OPENCYLINDERS];\nCone cones[N_CONES];\nDisk disks[N_DISKS];\nQuad quads[N_QUADS];\nBox boxes[N_BOXES];\n    \nbool solveQuadratic(float A, float B, float C, out float t0, out float t1){\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim < 0.0 )\n        \treturn false;\n    \n\tfloat rootDiscrim = sqrt(discrim);\n\n\tfloat Q = (B > 0.0) ? -0.5 * (B + rootDiscrim) : -0.5 * (B - rootDiscrim); \n\tfloat t_0 = Q / A; \n\tfloat t_1 = C / Q;\n\t\n\tt0 = min( t_0, t_1 );\n\tt1 = max( t_0, t_1 );\n    \n\treturn true;\n}\nfloat SphereIntersect( float rad, vec3 pos, Ray ray ){\n\tfloat t = INFINITY;\n\tfloat t0, t1;\n\tvec3 L = ray.origin - pos;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - (rad * rad);\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn INFINITY;\n\tif ( t1 > 0.0 )\n\t\tt = t1;\n\tif ( t0 >= 0.0 )\n\t\tt = t0;\n\treturn t;\n}\nfloat EllipsoidIntersect( vec3 radii, vec3 pos, Ray r ){\n\tfloat t = INFINITY;\n\tfloat t0, t1;\n\tvec3 oc = r.origin - pos;\n\tvec3 oc2 = oc*oc;\n\tvec3 ocrd = oc*r.direction;\n\tvec3 rd2 = r.direction*r.direction;\n\tvec3 invRad = 1.0/radii;\n\tvec3 invRad2 = invRad*invRad;\n\t\n\t// quadratic equation coefficients\n\tfloat a = dot(rd2, invRad2);\n\tfloat b = 2.0*dot(ocrd, invRad2);\n\tfloat c = dot(oc2, invRad2) - 1.0;\n\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn INFINITY;\n\t\n\tif ( t1 > 0.0 )\n\t\tt = t1;\n\t\t\n\tif ( t0 > 0.0 )\n\t\tt = t0;\n\t\n\treturn t;\n}\nfloat OpenCylinderIntersect( vec3 p0, vec3 p1, float rad, Ray r, out vec3 n ){\n\tfloat r2=rad*rad;\n\t\n\tvec3 dp=p1-p0;\n\tvec3 dpt=dp/dot(dp,dp);\n\t\n\tvec3 ao=r.origin-p0;\n\tvec3 aoxab=cross(ao,dpt);\n\tvec3 vxab=cross(r.direction,dpt);\n\tfloat ab2=dot(dpt,dpt);\n\tfloat a=2.0*dot(vxab,vxab);\n\tfloat ra=1.0/a;\n\tfloat b=2.0*dot(vxab,aoxab);\n\tfloat c=dot(aoxab,aoxab)-r2*ab2;\n\t\n\tfloat det=b*b-2.0*a*c;\n\t\n\tif(det<0.0)\n\treturn INFINITY;\n\t\n\tdet=sqrt(det);\n\t\n\tfloat t = INFINITY;\n\t\n\tfloat t0=(-b-det)*ra;\n\tfloat t1=(-b+det)*ra;\n\t\n\tvec3 ip;\n\tvec3 lp;\n\tfloat ct;\n\tif (t1 > 0.0)\n\t{\n\t\tip=r.origin+r.direction*t1;\n\t\tlp=ip-p0;\n\t\tct=dot(lp,dpt);\n\t\tif((ct>0.0)&&(ct<1.0))\n\t\t{\n\t\t\tt = t1;\n\t\t     \tn=(p0+dp*ct)-ip;\n\t\t}\n\t\t\n\t}\n\tif (t0 > 0.0)\n\t{\n\t\tip=r.origin+r.direction*t0;\n\t\tlp=ip-p0;\n\t\tct=dot(lp,dpt);\n\t\tif((ct>0.0)&&(ct<1.0))\n\t\t{\n\t\t\tt = t0;\n\t\t\tn=ip-(p0+dp*ct);\n\t\t}\n\t\t\n\t}\n\treturn t;\n}\nfloat ConeIntersect( vec3 p0, float r0, vec3 p1, float r1, Ray r, out vec3 n ){\n\tr0 += 0.1;\n\tfloat t = INFINITY;\n\tvec3 locX;\n\tvec3 locY;\n\tvec3 locZ=-(p1-p0)/(1.0 - r1/r0);\n\t\n\tRay ray = r;\n\tray.origin-=p0-locZ;\n\t\n\tif(abs(locZ.x)<abs(locZ.y))\n\t\tlocX=vec3(1,0,0);\n\telse\n\t\tlocX=vec3(0,1,0);\n\t\t\n\tfloat len=length(locZ);\n\tlocZ=normalize(locZ)/len;\n\tlocY=normalize(cross(locX,locZ))/r0;\n\tlocX=normalize(cross(locY,locZ))/r0;\n\t\n\tmat3 tm;\n\ttm[0]=locX;\n\ttm[1]=locY;\n\ttm[2]=locZ;\n\t\n\tray.direction*=tm;\n\tray.origin*=tm;\n\t\n\tfloat dx=ray.direction.x;\n\tfloat dy=ray.direction.y;\n\tfloat dz=ray.direction.z;\n\t\n\tfloat x0=ray.origin.x;\n\tfloat y0=ray.origin.y;\n\tfloat z0=ray.origin.z;\n\t\n\tfloat x02=x0*x0;\n\tfloat y02=y0*y0;\n\tfloat z02=z0*z0;\n\t\n\tfloat dx2=dx*dx;\n\tfloat dy2=dy*dy;\n\tfloat dz2=dz*dz;\n\t\n\tfloat det=(\n\t\t-2.0*x0*dx*z0*dz\n\t\t+2.0*x0*dx*y0*dy\n\t\t-2.0*z0*dz*y0*dy\n\t\t+dz2*x02\n\t\t+dz2*y02\n\t\t+dx2*z02\n\t\t+dy2*z02\n\t\t-dy2*x02\n\t\t-dx2*y02\n        );\n\t\n\tif(det<0.0)\n\t\treturn INFINITY;\n\t\t\n\tfloat t0=(-x0*dx+z0*dz-y0*dy-sqrt(abs(det)))/(dx2-dz2+dy2);\n\tfloat t1=(-x0*dx+z0*dz-y0*dy+sqrt(abs(det)))/(dx2-dz2+dy2);\n\tvec3 pt0=ray.origin+t0*ray.direction;\n\tvec3 pt1=ray.origin+t1*ray.direction;\n\t\n\tif(t1>0.0 && pt1.z>r1/r0 && pt1.z<1.0)\n\t{\n\t\tt=t1;\n\t\tn=pt1;\n\t\tn.z=0.0;\n\t\tn=normalize(n);\n\t\tn.z=-pt1.z/abs(pt1.z);\n\t\tn=normalize(n);\n\t\tn=tm*-n;\n\t}\n\t\n\tif(t0>0.0 && pt0.z>r1/r0 && pt0.z<1.0)\n\t{\n\t\tt=t0;\n\t\tn=pt0;\n\t\tn.z=0.0;\n\t\tn=normalize(n);\n\t\tn.z=-pt0.z/abs(pt0.z);\n\t\tn=normalize(n);\n\t\tn=tm*n;\n\t}\n\treturn t;\t\n}\nfloat DiskIntersect( vec3 diskPos, vec3 normal, float radius, Ray r ){\n\tvec3 n = normalize(-normal);\n\tvec3 pOrO = diskPos - r.origin;\n\tfloat denom = dot(n, r.direction);\n\t// use the following for one-sided disk\n\t//if (denom <= 0.0)\n\t//\treturn INFINITY;\n\t\n        float result = dot(pOrO, n) / denom;\n\tif (result < 0.0)\n\t\treturn INFINITY;\n        vec3 intersectPos = r.origin + r.direction * result;\n\tvec3 v = intersectPos - diskPos;\n\tfloat d2 = dot(v,v);\n\tfloat radiusSq = radius * radius;\n\tif (d2 > radiusSq)\n\t\treturn INFINITY;\n\treturn result;\n}\nfloat QuadIntersect( vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 normal, Ray r ){\n\tvec3 u, v, n;    // triangle vectors\n\tvec3 w0, w, x;   // ray and intersection vectors\n\tfloat rt, a, b;  // params to calc ray-plane intersect\n\t\n\t// get first triangle edge vectors and plane normal\n\tv = v2 - v0;\n\tu = v1 - v0; // switched u and v names to save calculation later below\n\t//n = cross(v, u); // switched u and v names to save calculation later below\n\tn = -normal; // can avoid cross product if normal is already known\n\t    \n\tw0 = r.origin - v0;\n\ta = -dot(n,w0);\n\tb = dot(n, r.direction);\n\tif (b < 0.0001)   // ray is parallel to quad plane\n\t\treturn INFINITY;\n\n\t// get intersect point of ray with quad plane\n\trt = a / b;\n\tif (rt < 0.0)          // ray goes away from quad\n\t\treturn INFINITY;   // => no intersect\n\t    \n\tx = r.origin + rt * r.direction; // intersect point of ray and plane\n\n\t// is x inside first Triangle?\n\tfloat uu, uv, vv, wu, wv, D;\n\tuu = dot(u,u);\n\tuv = dot(u,v);\n\tvv = dot(v,v);\n\tw = x - v0;\n\twu = dot(w,u);\n\twv = dot(w,v);\n\tD = 1.0 / (uv * uv - uu * vv);\n\n\t// get and test parametric coords\n\tfloat s, t;\n\ts = (uv * wv - vv * wu) * D;\n\tif (s >= 0.0 && s <= 1.0)\n\t{\n\t\tt = (uv * wu - uu * wv) * D;\n\t\tif (t >= 0.0 && (s + t) <= 1.0)\n\t\t{\n\t\t\treturn rt;\n\t\t}\n\t}\n\t\n\t// is x inside second Triangle?\n\tu = v3 - v0;\n\t///v = v2 - v0;  //optimization - already calculated above\n\n\tuu = dot(u,u);\n\tuv = dot(u,v);\n\t///vv = dot(v,v);//optimization - already calculated above\n\t///w = x - v0;   //optimization - already calculated above\n\twu = dot(w,u);\n\t///wv = dot(w,v);//optimization - already calculated above\n\tD = 1.0 / (uv * uv - uu * vv);\n\n\t// get and test parametric coords\n\ts = (uv * wv - vv * wu) * D;\n\tif (s >= 0.0 && s <= 1.0)\n\t{\n\t\tt = (uv * wu - uu * wv) * D;\n\t\tif (t >= 0.0 && (s + t) <= 1.0)\n\t\t{\n\t\t\treturn rt;\n\t\t}\n\t}\n\n\n\treturn INFINITY;\n}\nfloat BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal ){\n\tvec3 invDir = 1.0 / r.direction;\n\tvec3 tmin = (minCorner - r.origin) * invDir;\n\tvec3 tmax = (maxCorner - r.origin) * invDir;\n\t\n\tvec3 real_min = min(tmin, tmax);\n\tvec3 real_max = max(tmin, tmax);\n\t\n\tfloat minmax = min( min(real_max.x, real_max.y), real_max.z);\n\tfloat maxmin = max( max(real_min.x, real_min.y), real_min.z);\n\t\n\tif (minmax > maxmin)\n\t{\n\t\t\n\t\tif (maxmin > 0.0) // if we are outside the box\n\t\t{\n\t\t\tnormal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);\n\t\t\treturn maxmin;\t\n\t\t}\n\t\t\n\t\telse if (minmax > 0.0) // else if we are inside the box\n\t\t{\n\t\t\tnormal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);\n\t\t\treturn minmax;\n\t\t}\n\t\t\t\t\n\t}\n\t\n\treturn INFINITY;\n}\n\n// I = ΔΦ/4π\nconst vec3 LIGHTCOLOR = vec3(0.8,0.8,0.3);\nvec3 GetLightIntensity(){\n\treturn 50.* LIGHTCOLOR;\n}\n\nfloat SceneIntersect( Ray r, inout Intersection intersec ){\n    float d = INFINITY;\t\n    float t = 0.;\n    vec3 normal = vec3(0.);\n    for(int i=0;i<spheres.length();i++){\n        t = SphereIntersect(spheres[i].radius,spheres[i].position,r);\n        if (t < d){\n            d = t;\n            intersec.normal = normalize((r.origin + r.direction * t) - spheres[i].position);\n            intersec.emission = spheres[i].emission;\n            intersec.color = spheres[i].color;\n            intersec.roughness = spheres[i].roughness;\n            intersec.type = spheres[i].type;\n\t\t}\n    }\n    /*\n    for(int i=0;i<ellipsoids.length();i++){\n    \tt = EllipsoidIntersect(ellipsoids[i].shape,ellipsoids[i].position,r);\n        if (t < d){\n        \td = t;\n            intersec.normal = normalize((r.origin + r.direction * t - ellipsoids[i].position)/(ellipsoids[i].shape*ellipsoids[i].shape));\n            intersec.emission = ellipsoids[i].emission;\n            intersec.color = ellipsoids[i].color;\n            intersec.roughness = ellipsoids[i].roughness;\n            intersec.type = ellipsoids[i].type;\n        }\n    }\n    for(int i=0;i<openCylinders.length();i++){\n    \tt = OpenCylinderIntersect(openCylinders[i].pos1, openCylinders[i].pos2, openCylinders[i].radius, r, normal);\n        if (t < d){\n        \td = t;\n            intersec.normal = normalize(normal);\n            intersec.emission = openCylinders[i].emission;\n            intersec.color = openCylinders[i].color;\n            intersec.roughness = openCylinders[i].roughness;\n            intersec.type = openCylinders[i].type;\n        }\n    }\n\t*/\n    /*\n    for(int i=0;i<cones.length();i++){\n    \tt = ConeIntersect(cones[i].pos0, cones[i].radius0,cones[i].pos1,cones[i].radius1, r, normal);\n        //t = OpenCylinderIntersect(openCylinders[i].pos1, openCylinders[i].pos2, openCylinders[i].radius, r, normal);\n        if (t < d){\n            d = t;\n            intersec.normal = normalize(normal);\n            intersec.emission = cones[i].emission;\n            intersec.color = cones[i].color;\n            intersec.roughness = cones[i].roughness;\n            intersec.type = cones[i].type;\n        }\n    }\n\t*/\n\t/*\n    for(int i=0;i<disks.length();i++){\n    \tt = DiskIntersect( disks[i].pos, disks[i].normal, disks[i].radiusSq, r );\n        if (t < d){\n        \td = t;\n            intersec.normal = normalize(disks[i].normal);\n            intersec.emission = disks[i].emission;\n            intersec.color = disks[i].color;\n            intersec.roughness = disks[i].roughness;\n            intersec.type = disks[i].type;\n        }\n    }\n\t*/\n    \n    for(int i=0;i<quads.length();i++){\n        t = QuadIntersect( quads[i].v0, quads[i].v1, quads[i].v2, quads[i].v3, quads[i].normal, r );\n        if (t < d){\n        \td = t;\n            intersec.normal = normalize(quads[i].normal);\n            intersec.emission = quads[i].emission;\n            intersec.color = quads[i].color;\n            intersec.roughness = quads[i].roughness;\n            intersec.type = quads[i].type;\n        }\n    }\n\t\n    for(int i=0;i<boxes.length();i++){\n    \tt = BoxIntersect(boxes[0].minCorner,boxes[0].maxCorner,r,normal);\n        if(t < d){\n        \td = t;\n            intersec.normal = normalize(normal);\n            intersec.emission = boxes[i].emission;\n            intersec.color = boxes[i].color;\n            intersec.roughness = boxes[i].roughness;\n            intersec.type = boxes[i].type;\n        }\n    }\n    intersec.distance = d;\n    return d;\n}\nvoid SetupScene(){\n\tspheres[0] = Sphere( 0.2, vec3(-0.1 , 0., 0.), vec3(0.), vec3(0.3,1. ,0.  ), 0.7, SPEC);\n\tspheres[1] = Sphere( 0.23, vec3(0.2, 0.1, 0.), vec3(0.), vec3(1.,0.,0.05), 0.4, SPEC);\n   \tspheres[2] = Sphere( 0.4, vec3(0.2, 0.4,0.3),vec3(1.,0.8,0.8),vec3(1.,0.,0.4), 0.05, SPEC);\n    ellipsoids[0] = Ellipsoid(vec3(1.,2.,1.),vec3(-1.,0.,1.5),vec3(0.2),vec3(0.,0.8,0.5),0.4,SPEC);\n\topenCylinders[0] = OpenCylinder(0.3,vec3(0.,0.2,0.),vec3(0.,0.,0.),vec3(0.2),vec3(0.,0.6,0.9),0.4,SPEC);\n\tcones[0] = Cone(vec3(1.,1.,0.),0.5,vec3(5.,1.,0.), 1., vec3(0.5),vec3(1.,1.,0.),0.4,SPEC);\n    disks[0] = Disk(1.0, vec3(0.,2.,0.), vec3(0.,1.,0.), vec3(0.7,0.8,0.7), vec3(0.2,0.3,0.4), 0.2, LIGHT);\n    quads[0] = Quad(vec3(0.,0.,1.),vec3(-0.5,0.,-1.), vec3(0.5,0.,-1.), vec3(0.5 ,0.55 ,-1. ), vec3(-0.5,0.55,-1.), vec3(0.6,0.6,0.6), vec3(0.4,0.5,0.6),0.4, LIGHT);\n    boxes[0] =  Box(vec3(-0.7,-0.3,-0.7),vec3(0.7,0.0,0.7), vec3(0.,0.,0.), vec3(0.,0.2,0.1), 0.1, DIFF);\n}\n#define time iTime*0.1\nmat3 CameraCoordBase(vec3 campos,vec3 lookAt,vec3 up){\n\tvec3 LookForward = normalize(lookAt - campos);\n    vec3 BaseRight = normalize(cross(LookForward,up));\n    vec3 BaseUp    = normalize(cross(BaseRight,LookForward));\n    mat3 mat = mat3(BaseRight,BaseUp,LookForward);\n\treturn mat;\n}\n\nMaterial GetMaterial(Intersection _intersec){\n\tMaterial mat;\n    mat.type = _intersec.type;\n    mat.uv = _intersec.uv;\n    mat.normal = _intersec.normal;\n    mat.diffuse = _intersec.color;\n    mat.specular = LIGHTCOLOR;\n    mat.roughness = _intersec.roughness;\n    return mat;\n}\n\nfloat isSameHemishere(float cosA,float cosB){\n\treturn cosA*cosB;\n} \n//pdf area to solid angle\nfloat PDF_Area2Angle(float pdf,float dist,float costhe){\n\treturn pdf*dist*dist/costhe;\n}\n//vec3 v0; vec3 v1; vec3 v2; vec3 v3\n//     A\t\tB         C        D\n/*  v3------v2\n\t|\t O\t |\n\tv0------v1\n*/\nvec3 LightSample(vec3 p,float x1,float x2,out vec3 wo,out float dist,out float pdf){\n\tvec3 v0v1 = quads[0].v1 - quads[0].v0;\n    vec3 v0v3 = quads[0].v3 - quads[0].v0;\n    float width  = length(v0v1);\n    float height = length(v0v3);\n    vec3 O = quads[0].v0 + v0v1*x1 + v0v3*x2;\n    wo = O - p;\n    dist = length(wo);\n    wo = normalize(wo);\n    float costhe = dot(-wo,quads[0].normal);\n    pdf = PDF_Area2Angle(1./(width*height),dist,clamp(costhe,0.0001,1.));\n    return costhe>0. ? GetLightIntensity(): vec3(0.);\n}\nvec3 MicroFactEvalution(Material mat,vec3 nDir,vec3 wo,vec3 wi){\n\tmat3 nDirSpace = CoordBase(nDir);\n    //light dir\n    vec3 L_local = ToOtherSpaceCoord(nDirSpace,wo);\n    //eye dir\n    vec3 E_local = ToOtherSpaceCoord(nDirSpace,wi);\n    if(isSameHemishere(L_local.z,E_local.z) < 0.){\n    \treturn ZERO;\n    }\n    if(any(equal(vec2(L_local.z,E_local.z),ZERO.xy))){\n    \treturn ZERO;\n    }\n    float alpha = mat.roughness;\n    vec3 H_local = normalize(L_local + E_local);\n    float D = GGX_Distribution(H_local, alpha, alpha);\n    float F = F_Schlick(F0_ALUMINIUM, L_local,H_local);\n    float G = GGX_G2(L_local, E_local, alpha, alpha);\n    vec3 specular_Col = mat.specular*0.25*D*G/clamp(L_local.z*E_local.z,0.,1.);\n    vec3 diffuse_Col = mat.diffuse*INVERSE_PI;\n    return mix(specular_Col,diffuse_Col,F);\n}\nfloat EnergyAbsorptionTerm(float roughness,vec3 wo){\n\treturn mix(1.-roughness*roughness,sinTheta(wo),roughness);\n}\n//F function\nvec3 LightingDirectSample(Material mat,vec3 p,vec3 nDir,vec3 vDir,out float pdf){\n\tvec3 L = vec3(0.,0.,0.);\n    float x1 = GetRandom(),x2 = GetRandom();\n    vec3 wo;\n    float dist;\n    vec3 Li = LightSample(p,x1,x2,wo,dist,pdf);\n    float WoDotN = dot(wo,nDir);\n    if(WoDotN >= 0. && pdf > 0.0001){\n        vec3 Lr = MicroFactEvalution(mat,nDir,wo,vDir);\n        Ray shadowRay = Ray(p,wo);\n        Intersection shadow_intersc;\n        float d = SceneIntersect(shadowRay,shadow_intersc);\n        if(shadow_intersc.type == LIGHT){\n            L = Lr*Li/pdf;\n        }\n    }\n    return L;\n}\n//G function \nvec3 LightingBRDFSample(Material mat,vec3 p,vec3 nDir,vec3 vDir,inout float _pathWeight,inout Intersection _intersec,inout Ray ray,out float pdf){\n\tvec3 L = vec3(0.);\n    float x1 = GetRandom(),x2 = GetRandom();\n    mat3 nDirSpace = CoordBase(nDir);\n    //light dir\n    vec3 L_local;\n    //eye dir\n    vec3 E_local = ToOtherSpaceCoord(nDirSpace,vDir);\n    float alpha = mat.roughness;\n    if(E_local.z <= 0.)\n        return ZERO;\n    vec3 N_local = sampleGGXVNDF(E_local,alpha,alpha,x1,x2);\n    N_local *= sign(E_local.z * N_local.z);\n\n    float part_pdf = 0.5;\n    float path_pdf = 0.;\n    if(GetRandom() < part_pdf){\n        //diffuse ray\n        L_local = DiffuseUnitSpehreRay(x1,x2);\n        path_pdf = Diffuse_PDF(L_local);\n    }\n    else{\n        //specular ray\n        L_local = reflect(-E_local, N_local);\n        path_pdf = Specular_PDF(E_local,N_local,alpha,alpha);\n    }\n    \n    vec3 wo = RotVector(nDirSpace,L_local); //to world coord base\n    vec3 Lr = MicroFactEvalution(mat,nDir,wo,vDir);\n    Ray shadowRay = Ray(p,wo);\n    float d = SceneIntersect(shadowRay,_intersec);\n    ray = Ray(p,wo);\n    if(path_pdf > 0.0001){\n        if(_intersec.type == LIGHT && cosTheta(L_local)>0.){\n            L = GetLightIntensity()/(d*d)*Lr*dot(wo,nDir)/part_pdf;\n        }\n        L /=path_pdf;\n    }\n    pdf = path_pdf;\n\t//我们要简单得考虑物体对 能量 得损失(we should simple think about energy absorption)\n    _pathWeight *= EnergyAbsorptionTerm(alpha,L_local);\n    return L;\n}\nvec3 Randiance(Ray ray,float x1){\n\tfloat t = INFINITY;\n    Intersection intersecNow;\n    Intersection intersecNext;\n    vec3 col = vec3(0.,0.5,0.);\n    vec3 Lo = vec3(0.,0.,0.);\n    float pathWeight = 1.;\n    if(SceneIntersect(ray,intersecNow)>=INFINITY)\n    \treturn BACKGROUD_COL;\n    //显示光源\n    if(intersecNow.type == LIGHT){\n        Lo = GetLightIntensity();\n        return Lo;\n    }\n\t//计算GI光照\n    for(int step=0;step<GI_DEPTH;step++){\n\t\tif(intersecNow.type == LIGHT)\n            break;\n   \t\tvec3 viewDir = -ray.direction;\n        vec3 nDir = intersecNow.normal;\n        nDir = faceforward(nDir,-viewDir,nDir);\n        Material mat = GetMaterial(intersecNow);\n        if(dot(viewDir,nDir)<0.)\n            break;\n\t\t//物体表面\n        vec3 point = ray.origin + ray.direction * intersecNow.distance +nDir*0.00001;\n        float Light_pdf,BRDF_pdf;\n       \tvec3 LIGHT_S = LightingDirectSample(mat,point,nDir,viewDir,Light_pdf);\n        vec3 BRDF_S = LightingBRDFSample(mat,point,nDir,viewDir,pathWeight,intersecNext,ray,BRDF_pdf);\n        Lo += LIGHT_S*MISWeight(1.,Light_pdf,1.,BRDF_pdf)\n           +  BRDF_S*MISWeight(1.,BRDF_pdf,1.,Light_pdf);\n        Lo *= pathWeight;\n\t\tintersecNow = intersecNext;\n    }\n    return Lo/float(GI_DEPTH);\n}\n#define R iResolution.xy\nconst vec2 FRAME_START_UV = vec2(0.,0.);\nvec4 readValues(vec2 xy){\n\treturn texture(iChannel0,(xy+0.5)/R);\n}\nvoid mainImage( out vec4 C, in vec2 U ){\n\tvec2 iU = U - 0.5;\n    /*\n\t\tMy new enhanced method noise seed.(test)\n\t*/\n    seed = iTime*sin(iTime) + (U.x+R.x*U.y)/(R.y);\n    \n    vec2 uv = (U+U-R)/R.y;\n    vec2 mousePos = readValues(FRAME_START_UV).yz/R*10.;\n    if(iFrame == 0){\n         mousePos = R/vec2(3.,4.);\n\t}\n    vec3 pos = vec3(cos(mousePos.x),mousePos.y/2.-0.5,sin(mousePos.x));\n    \t pos.xz *= 1.5;\n    vec3 dir = normalize(vec3(uv,2.3));\n\tdir = RotVector(CameraCoordBase(pos,vec3(0.,0.05,0.),vec3(0.,1.,0.)),dir);\n    dir = normalize(dir);\n    SetupScene();\n    \n    mat3 cameraSpace = CoordBase(normalize(pos-vec3(0.,0.05,0.)));\n    vec2 dither = TriangularNoise2DShereRay(uv,iTime);\n    pos += (RotVector(cameraSpace,vec3(dither,0.)))*0.004;\n    Ray ray = Ray(pos,dir);\n    vec3 col = Randiance(ray,GetRandom());\n    if(all(equal(iU,FRAME_START_UV))){\n        if(iFrame == 0){\n            C = vec4(1.,R/vec2(3.,4.),0.);\n        }\n        else{\n            if(iMouse.z > 1.){\n                C = vec4(1.,iMouse.xy,0.);\n            }\n            else{\n                C = readValues(FRAME_START_UV);\n                ++C.r;\n            }\n        }\n    }\n    else{\n        if(iFrame == 0){\n        \tC = vec4(col.rgb,0.);\n        \t//with krax suggestion awoid NaN\n            C = clamp(C, 0., 10.);\n        }\n        else{\n            vec4 Frame_data = readValues(FRAME_START_UV);\n            C = texture(iChannel0,U/R);\n            //float N = col.r + col.g + col.b;\n            //with krax suggestion awoid NaN\n            col = clamp(col, 0., 10.);\n            //if(!(N<0.))\n            C = mix(C,vec4(col,1.),1./Frame_data.r);\n        }\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}