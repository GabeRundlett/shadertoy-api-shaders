{
    "Shader": {
        "info": {
            "date": "1696454972",
            "description": "iterating further on the concept of an odometer without discrete wheels.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdyczt",
            "likes": 5,
            "name": "Warped Counter",
            "published": 3,
            "tags": [
                "clock",
                "counter",
                "exponential"
            ],
            "usePreview": 0,
            "username": "Retr0id",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "// A selection of fonts generated from Shadertoy's font texture.\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// quality of font anti-aliasing - number of samples doubles with each level of quality\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\n// Font Definitions\nstruct Typeface\n{\n    vec2 scale;\n    vec2 padding;\n    vec2 bias;\n    float biasAngle;\n    float threshold;\n};\n\nconst Typeface Deco = Typeface( vec2(.6,.7), vec2(0), vec2(-.02,.025), 0., -.02 );\nconst Typeface Deco_Light = Typeface( vec2(.63,.7), vec2(-1,0), vec2(-.01,.04), 0., -.02 );\n\nconst Typeface Impactful = Typeface( vec2(.5,1), vec2(4,2), vec2(-.02,.01), 0., .01 );\n\nconst Typeface Elegant = Typeface( vec2(.6,.9), vec2(-2,0), vec2(.05,-.005), -1.04, -.022 );\nconst Typeface Elegant_Condensed = Typeface( vec2(.5,1.), vec2(0,1), vec2(.0,.1), -1., -.02 );\n\nconst Typeface Timely = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), -.5, -.02 );\nconst Typeface Timely_Light = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.02,.02), -.5, -.01 );\nconst Typeface Timely_Heavy = Typeface( vec2(.8,.7), vec2(4,1), vec2(-.03,.02), 2.5, .01 );\n\nconst Typeface Neat = Typeface( vec2(.6,.7), vec2(-1,1), vec2(-.017,.02), -.3, -.02 );\n\nconst Typeface Comic = Typeface( vec2(.8,.7), vec2(2,1), vec2(-.05,.0), 1., -.02 );\nconst Typeface Comic_Title = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), 1., .0 );\n\nconst Typeface WildWest = Typeface( vec2(.9), vec2(2,0), vec2(-.05,.0), 0., -.02 );\nconst Typeface WildWest_Wide = Typeface( vec2(1,.7), vec2(0,2), vec2(.05,.0), 0., .02 );\n\nconst Typeface Gothic = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., .01 );\nconst Typeface Gothic_Light = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., -.01 );\nconst Typeface Gothic_Condensed = Typeface( vec2(.5,1.), vec2(0), vec2(.05,.0), -1.04, .02 );\nconst Typeface Gothic_Book = Typeface( vec2(.6,.7), vec2(0,2), vec2(.1,.0), 1., .0 );\n\nconst Typeface Haunted = Typeface( vec2(.75,.9), vec2(2,0), vec2(.0,.03), 0., .01 );\nconst Typeface Haunted_Condensed = Typeface( vec2(.5,1), vec2(4,0), vec2(-.02,.03), 0., .01 );\nconst Typeface Haunted_Script = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.05), .7, .0 );\n\n// Round-tipped font (actually not round in close-up)\nconst Typeface Round = Typeface( vec2(1), vec2(0,6), vec2(-.02,-.02), 0., -.01 );\nconst Typeface Round_Bold = Typeface( vec2(1), vec2(4,6), vec2(-.04,-.04), 0., -.01 );\n\n\nfloat RenderFont_NoAA\n    (\n        vec2 uv,\n        Typeface font,\n        uint text[8]\n    )\n{\n    // each char is in a 64x64 space, trim off the white boundary\n    vec2 charBottomLeft = vec2(18,3) - font.padding/2.;\n    vec2 charDims = vec2(28,52) + font.padding;\n\n    uv = uv/font.scale; //+vec2(iTime*200.,0);\n    \n    if ( uv.y < .0 || uv.y >= charDims.y ) return 1.;\n    \n    uint index = uint(uv.x/charDims.x);\n    ivec2 res = ivec2(iResolution.xy);\n    uint index4 = index/4u;\n\n    if ( index4 >= uint(text.length()) ) return 1.;\n    \n    uint char = ( text[index4] >> (8u*(index&3u)) )&0xffu;\n    \n    char = char^0xf0u; // flip the y coord\n    \n    uv.x = fract(uv.x/charDims.x)*charDims.x;\n    uv += vec2(ivec2(char&0xfu,char>>4u)) * iChannelResolution[0].xy/16.;\n    uv += charBottomLeft;\n                            \n    vec4 v = texture( iChannel0, uv/iChannelResolution[0].xy ) -.5;\n                            \n    vec2 bias = 2.*v.yz;\n    bias = bias*cos(font.biasAngle) + bias.yx*sin(font.biasAngle)*vec2(1,-1);\n    bias = pow(abs(bias),vec2(3));\n    \n    // view the SDF\n//    float f = v.w + dot( font.bias, bias ) - font.threshold; return .5+.5*f/(abs(f)+.04);\n    \n    return step( font.threshold, v.w + dot( font.bias, bias ) );\n}\n\n\n\n// RenderFont\n//\n// Output:\n//\t\tA linear brightness value where 0 = text, 1 = background.\n//\t\tI recommend applying a gamma curve before displaying.\n//\n// uv\n//\t\tRelative to the bottom left of the line of text, most fonts are about 40 units tall\n//\n// font\n//\t\tOne of the Typefaces defined earlier\n//\n// text\n//\t\tA line of text, encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n//\t\tEach byte is 4-bit u, 4-bit v coord of a character in the font texture.\n//\nfloat RenderFont\n    (\n        vec2 uv,\n        Typeface font,\n\t\tuint text[8]\n    )\n{\n    const int numSamples = 1<<(AA_QUALITY);\n    \n    float sum = 0.;\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n\n    // anti-alias the font\n    // this would be more efficient run per-character inside the font render function\n    // (the SDFs on some of the fonts are good enough that I could probably just soften the step function)\n    for ( int i=0; i < numSamples; i++ )\n    {\n        // ideal 2D quasirandom sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        sum += RenderFont_NoAA( uv + jitter.x*duvdx + jitter.y*duvdy, font, text );\n    }\n   \n    return sum/float(numSamples);\n}\n\n\n\nfloat factor = 10.0;\nfloat segments = 4.0;\nfloat zoom = 0.30;\n\nvec4 test(vec2 uv) {\n    return vec4(uv.x, 0.0, uv.y, 1.0);\n}\n\nvec4 digits(vec2 uv) {\n    float f = RenderFont( vec2((uv.y)*170.0, (1.0-uv.x)*25.0 + 8.0), Deco, uint[]( 0x33323130U, 0x37363534U, 0x20203938U, 0U, 0U, 0U, 0U, 0U ) );\n    return texture(iChannel1, uv) * vec4(0.7, 0.9, 1.6, 1.0) * f + vec4(1.0) * (1.0-f);\n    //return vec4(vec3( pow( f, 1./2.2 ) ), 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(1.0-uv.y, uv.x);\n\n    float t = iTime / 1000.0;\n\n    uv.x = uv.x * segments; // repeat n times\n    uv.y -= 0.5; // vertical centering\n    uv.y *= pow(factor, mod(-uv.x, 1.0)) * zoom; // exponential scaling\n    uv.y += t * pow(factor, floor(uv.x)); // make each wheel faster than the previous\n   \n    // Output to screen\n    //fragColor = test(mod(uv, 1.0));\n    fragColor = digits(mod(uv, 1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}