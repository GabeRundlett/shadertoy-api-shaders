{
    "Shader": {
        "info": {
            "date": "1483743371",
            "description": "made for my friend connor bell aka macbooktall's birthday party\nmouse-x for mic sensitivity",
            "flags": 36,
            "hasliked": 0,
            "id": "4lySDR",
            "likes": 7,
            "name": "connorb birthlord",
            "published": 3,
            "tags": [
                "orb",
                "mic"
            ],
            "usePreview": 0,
            "username": "netgrind",
            "viewed": 725
        },
        "renderpass": [
            {
                "code": "// By Cale Bradbury, 2017\n// Base ray trace code via https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//mic input to the power of\n#define POW 3.\t\n\n//0-b/w   1-rainbow  2-blu/oran  3-dark mint   4-red/purp\n#define COLOR 0\n\n//fuck yeah, mirror that shit\n//#define MIRRORV\n\n//fuck yeah, mirror that shit\n//#define MIRRORH\n\n//how many itterations of the fractal\n#define LOOPS 8.0\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat qbox( vec3 p, float s ){\n  return length(max(abs(p)-vec3(s,s,s),0.0));\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y,uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nfloat f(vec3 pos, float size, float cur){\n    return smin(cur,sphere(pos,size), .05);\n}\n#define pi 3.14158\n#define sixthpi .52359877\n\nvec2 map( in vec3 pos, vec4 mi)\n{\n    float size = .2+length(pos)*.05;\n    pos.z+=iTime;\n    float pie = pi*(1.45+sin(iTime*.1+length(pos)*.2)*.05);\n    pos =(opRep(pos,vec3(3.,3.,3.)));\n   pos.xy = kale(pos.xy,sixthpi,pie+cos(iTime)*.1,0.);\n   pos.xz = kale(pos.xz,sixthpi,pie+sin(iTime)*.1,0.);\n    \n    float r = f(pos,size,1.);  \n    \n    \n    for(float i = 0.; i<LOOPS;i++){\n        float v = mi[int(mod(float(i), 4.))]*(i+1.);\n        pos+=vec3(size*(.8+v),0.,0.);\n        size*=(.666);\n        r = f(pos,size*(1.+v*.5),r);\n    }\n    return vec2(r,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd , vec4 mi)\n{\n    float tmin = 0.;\n    float tmax = 10.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n\t    vec2 res = map( ro+rd*t,mi );\n        //if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos, vec4 mi )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy,mi).x - map(pos-eps.xyy,mi).x,\n\t    map(pos+eps.yxy,mi).x - map(pos-eps.yxy,mi).x,\n\t    map(pos+eps.yyx,mi).x - map(pos-eps.yyx,mi).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, vec4 mi )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)*.5;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos,mi ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, float c, vec4 mi )\n{ \n    vec2 res = castRay(ro,rd, mi);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 col = vec3(100.);\n    if( m>-.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos , mi);\n        \n        // lighitng        \n        float occ = calcAO( pos, nor,mi );\n        pos = vec3(t);\n        col = pos*.1+occ*.1;//+abs(nor*max(0., 1.0-t*.1)*.1);\n        col = clamp(col, 0., 1.);\n    \t//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 getColor(vec2 uv){\n    vec2 p = -1.0+2.0*uv;\n\tp.x *= iResolution.x/iResolution.y;\n    #ifdef MIRRORH\n    p.x = -abs(p.x);\n    #endif\n    #ifdef MIRRORV\n    p.y = -abs(p.y);\n    #endif\n\t\t \n\tfloat camDist = 5.;\n\t// camera\t\n\tvec3 ro = vec3(0.,0,0.);\n    float t = iTime*.5;\n\tvec3 ta = ro+normalize(vec3(sin(t*.1+.5), cos(t*.23), sin(t*.156+3.14) ));\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0. );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,.6+cos(iTime*.4)*.2) );\n    float bg =  uv.y*.2+.1;\n    // render\t\n    \n    float smoo = iMouse.y/iResolution.y;\n    vec4 mi = vec4(0.,0.,0.,0.);\n    mi[0] = texture(iChannel0, vec2(.05,smoo)).r;\n    mi[1] = texture(iChannel0, vec2(.1,smoo)).r;\n    mi[2] = texture(iChannel0, vec2(.15,smoo)).r;\n    mi[3] = texture(iChannel0, vec2(.2,smoo)).r;\n    mi = pow(mi, vec4(POW))*((1.-(iMouse.x/iResolution.x))*8.+1.);\n    \n    vec3 col = render( ro, rd,bg, mi);\n    col = vec3(mix(col.r,bg,1.0-col.r));\n\n    col *= 1.-length((uv*2.-1.))*.3;\n\tcol = pow( col, vec3(0.7545) );\n\n    return vec4( col, 1.0 );\n}\n\n\nvec3 threeGradient(vec3 high, vec3 med, vec3 low, float m){\n return mix(high, mix(low, med, min(m*2.,1.)),min((1.-m)*2.,1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n       \n    vec4 c = getColor(uv);\n    \n    #if COLOR == 1\n    c.rgb = sin((c.rgb*3.+vec3(0., .33, .66))*6.28+ +iTime*.5235)*.5+.5; \n    #elif COLOR == 2\n    c.rgb = sin((c.rgb*3.+vec3(0., .33, .66))*3.28+ +iTime*.5235)*.5+.5; \n    #elif COLOR == 3\n    c.rgb = threeGradient(vec3(1.), vec3(0.),vec3(0., 1.,.8), c.r*1.3-.15); \n    #elif COLOR == 4\n    c.rgb = threeGradient(vec3(0.,0., .2), vec3(.5, .0, 0.33),vec3(1., 0.,.1), c.r*1.3-.15); \n    #endif\n\tfragColor = c;//texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float m = texture(iChannel0, vec2(uv.x, .333)).r;\n    float c = texture(iChannel1, uv).r;\n   //c = max(c*uv.y, m);\n    c = mix(c, m, uv.y);\n    fragColor = vec4(c,c,c,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}