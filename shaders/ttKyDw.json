{
    "Shader": {
        "info": {
            "date": "1611157803",
            "description": "shader livecoding(1hour)",
            "flags": 0,
            "hasliked": 0,
            "id": "ttKyDw",
            "likes": 4,
            "name": "Electronic tower",
            "published": 3,
            "tags": [
                "raymarching",
                "livecoding"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 317
        },
        "renderpass": [
            {
                "code": "\nfloat PI = acos(-1.);\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.0);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat loncylin(vec3 p,float s){\n  return length(p.xy)-s;\n}\n\nvec2 pmod(vec2 p,float n){\n  float np = 2.0*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\n\nvec4 dist(vec3 p){\n  \n  p.zy *= rot(0.5*PI);\n  \n  float ke = 1.5;\n  \n  float cs = 0.1/abs(mod(p.z+iTime,ke)-0.5*ke);\n  \n  \n  vec3 sp = p;\n  \n  sp.xy *= rot(p.z*10.3+0.8*iTime);\n  \n  sp.xy = pmod(sp.xy,12.);\n  \n  sp.x -= 0.02;\n  \n  float d5 = loncylin(sp,0.0001);\n  \n  p.z += 0.1*iTime;\n  \n  p.xy = pmod(p.xy,7.);\n\n  float k = 0.6;\n  \n  vec3 ssp = p;\n  p = mod(p,k)-0.5*k;\n  float d= cube(p,vec3(0.1));\n  float d1 = cube(p,vec3(0.03,0.03,10.));\n  float d2 = cube(p,vec3(0.03,10.,0.03));\n  float d3 = cube(p,vec3(10.,0.03,0.03));\n  d = min(d,d3);\n  d = min(d,d1);\n  d = min(d,d2);\n  \n  vec3 sssp = ssp;\n  \n  ssp.xy *= rot(0.25*PI);\n  sssp.xz *= rot(0.25*PI);\n  \n  ssp = mod(ssp,k)-0.5*k;\n  \n  sssp = mod(sssp,k)-0.5*k;\n \n  float d7 = cube(ssp,vec3(10.,0.03,0.03));\n   float d8 = cube(sssp,vec3(10.,0.03,0.03));\n  d = min(d,d7);\n  d = min(d,d8);\n  vec3 col = exp(-3.0*d)*(vec3(0.2,0.2,1.0)+0.8*cs*vec3(0.1,0.6,0.2));\n  if(d>d5) col = 0.03*vec3(0.5,0.5,0.1)/max(d5,0.01);\n  d = min(d,d5);\n  \n  return vec4(col,d);\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.0001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n\nfloat d,t=0.0;\n\n\nfloat ra = 0.2;\nfloat krt = iTime*0.4;\nvec3 ro = vec3(ra*cos(krt),0.0,ra*sin(krt));\n\nvec3 ta = vec3(0.0,0.1,0.0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\n\nvec3 rd = normalize(p.x*side+p.y*up+cdir*1.0);\n\nvec4 tsd;\n\nvec3 ac = vec3(0.0);\nfor(int i = 0;i<86;i++){\n  tsd = dist(ro+rd*t);\n  d = 0.7*tsd.w;\n  t += d;\n  ac += tsd.xyz;\n  if(d<0.001)break;\n}\n\nvec3 ac2 = vec3(0.0);\nif(d<0.001){\n  vec3 ps = ro+rd*t;\n  vec3 normal = getNormal(ps);\n  rd = reflect(rd,normal);\n  t = 0.04;\n  \n  ro =ps;\n  for(int i = 0;i<46;i++){\n    tsd = dist(ro+rd*t);\n    d = tsd.w;\n    t += d;\n    ac2 += tsd.xyz;\n    if(d<0.001)break;\n  }\n\n}\n\n\nvec3 col = vec3(0.5)*ac*0.1+normalize(ac)*vec3(1.3)*ac2*0.1;\ncol *= 0.7;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}