{
    "Shader": {
        "info": {
            "date": "1496547142",
            "description": "Fragment shader adapted from a gif I made with ShaderGif.\nThe code was pretty read-only, but I tried to add at least something at the top of each function.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdsBD7",
            "likes": 7,
            "name": "2D palm tree",
            "published": 3,
            "tags": [
                "2d",
                "tree",
                "art",
                "palm"
            ],
            "usePreview": 0,
            "username": "antoineMoPa",
            "viewed": 685
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n\nuniform float time;\nuniform float ratio;\n\n/* \n\tO.K.: this is not a leaf, this is a parabolic + sine function\n\tthat look like a set of leaves.\n*/\nfloat leaf(vec2 pos){\n    if(pos.y > 1.0 || pos.y < 0.0){\n        return 0.0;\n    }\n    pos *= 2.0;\n    pos.y *= -0.7;\n    float func = 0.0;\n    pos.x *= 1.0;\n    func = 0.0 - 6.0 * pow(pos.x, 2.0) + 0.3;\n    func += 0.07 * cos(pos.x * 6.0);\n    func += 0.02 * cos(pos.x * 170.0);\n    \n    if(-pos.y < func){\n        if(cos((pos.y - func) * 80.0) < 0.8){\n            return 1.0;\n        }\n    }\n    \n    return 0.0;\n}\n\n/* \n\tThis renders many \"leaves\" around a point \n\tI render the leaf function with the polar coordinates of the point\n\tangle becomes x, distance becomes y\n\tIn the x (angle) axis, I take the cos of x * 5 in order to have\n\tmany leaves and not just one.\n*/\nvec4 leaves_f(vec2 pos){\n    vec2 tpos;\n    vec4 col = vec4(0.0);\n    \n    vec2 top = vec2(-0.225, 0.22);\n    float dtop = length((top - pos) * vec2(1.0, 1.4));\n    vec2 v = top - pos;\n    float treefac = 0.0;\n    \n    if(dtop < 0.6){\n        float angle = atan(v.y, v.x);\n        tpos = vec2(cos(angle * 5.0 + 0.02 * cos(iTime * PI2)), 10.0 * dtop);\n        \n        treefac += leaf(0.1 * tpos);\n        \n        if(treefac > 0.0){\n            col.rgb = treefac * vec3(0.2, 0.0, 0.2);\n        }\n    }\n    \n    col.a = treefac;\n    \n    return col;\n}\n\n/* \n\tSmall boat code I took from another gif I made\n*/\nvec4 boat(vec2 pos){\n    vec4 col = vec4(0.0);\n    \n    if(pos.y < 0.1 && pos.y > -0.1){\n        if(pos.x < 0.3 + 0.5 * pos.y && pos.x > -0.3 - 0.5 * pos.y){\n            col.rgb += 0.2;\n        }\n    }\n    \n    float polex = -0.03;\n    \n    if(distance(pos.x, polex) < 0.014 && pos.y > 0.1 && pos.y < 0.48){\n        col.rgb += 0.1;\n    }\n    \n    if(pos.x > 0.05 + polex && pos.x < 0.4 - 0.7 * pos.y + polex && pos.y > 0.14 && pos.y < 0.48){\n        col.rgb += 0.2;\n    }\n    \n    return col;\n}\n\n/* Tri periodic function used in bridge /\\/\\/\\/\\/\\ */\nfloat tri(float x){\n    if(mod(x,2.0) < 1.0){\n        return mod(x,1.0);\n    } else {\n        return 1.0 - mod(x - 1.0,1.0);\n    }\n}\n\n/* The bridge */\nvec4 bridge(vec2 pos){\n    vec4 col = vec4(0.0);\n    \n    float floor = 0.01 * cos(10.0 * pos.x) + 0.01;\n    \n    floor += 0.006 * cos(pos.x * 10.4);\n    floor += 0.13 * cos(pos.x * 2.0);\n    \n    if(distance(floor, pos.y) < 0.03){\n        if(distance(floor, pos.y) < 0.003){\n            col.rgb = vec3(0.4);\n            col.a = 1.0;\n        }\n\n        // Vehicles (front lane)\n        if(pos.y > floor + 0.003 && pos.y < floor + 0.014){\n            float vehicle = cos(pos.x * 100.0 + mod(iTime,1.0) * PI2);\n            vehicle = vehicle < 0.0? 0.0: 1.0;\n            if(vehicle > 0.0){\n                col.rgb = vec3(0.3);\n                col.a = 1.0;\n            }\n        }\n\n        // Vehicles (back lane)\n        if(pos.y > floor + 0.003 && pos.y < floor + 0.01){\n            float vehicle = cos(pos.x * 100.0 - mod(iTime,1.0) * PI2 );\n            vehicle = vehicle < 0.0? 0.0: 1.0;\n            if(vehicle > 0.0){\n                col.rgb = vec3(0.5);\n                col.a = 1.0;\n            }\n        }\n    }\n    \n    float supportheight = 0.1;\n    \n    float space = 2.0;\n    \n    if(pos.y < floor + supportheight && pos.y > 0.0){\n        if(1.0 * cos(space * 10.0 * pos.x) + 1.0 < 0.003){\n            col.rgb = vec3(0.2);\n            col.a = 1.0;\n        }\n        float triheight = supportheight * tri(pos.x * space * PI);\n        if(pos.y > floor && pos.y - floor < triheight){\n            if(cos(700.0 * (pos.y - floor - triheight)) < -0.3){\n                col.rgb = vec3(0.3);\n                col.a = 1.0;\n            }\n        }\n    }\n    \n    \n    return col;\n}\n\n/* \n\tUse sines to make many buildings without using loops or repeated function calls \n*/\nvec4 buildings(vec2 pos){\n\tvec4 col;\n    \n    col = vec4(0.0);\n    \n    float qty = 10.0;\n    float x = 1.0/qty * floor(pos.x * qty);\n    \n    float height = 0.25 * cos(x * 15.0) + 0.4;\n    float bx = (pos.x - x) * qty;\n    \n    if(pos.x > 0.0 && pos.x < 1.0 && pos.y < height && bx > 0.05 && bx < 0.95 && pos.y > 0.0){\n    \tif(sin(bx * 30.0) > 0.5 && sin(pos.y * 100.0) > 0.1){\n        \tcol.rg += 0.9;\n        } else {\n        \tcol.rgb += vec3(0.5, 0.4, 0.4);\n        }\n        col.a = 1.0;\n    }\n    \n    return col;\n}\n\n/*\n\tPart of the scene that will be reflected on the water\n*/\nvec4 above_water(vec2 pos){\n\tvec4 col = vec4(0.0);\n    \n    if(pos.y < -0.2){\n    \treturn col;\n    }\n    \n    vec4 bcol = buildings(pos * vec2(2.3, 3.4) + vec2(1.4, 0.68));\n    bcol.a *= 0.4;\n    col = bcol.a * bcol + (1.0 - bcol.a) * col;\n    bcol = buildings(pos * vec2(2.3, 3.4) + vec2(-0.5, 0.68));\n  \tbcol.a *= 0.4;\n    col = bcol.a * bcol + (1.0 - bcol.a) * col;\n    bcol = bridge(pos + vec2(0.0, 0.2));\n    col = bcol.a * bcol + (1.0 - bcol.a) * col;\n   \n    if(distance(vec2(0.0, -0.2), pos) < 0.08){\n    \t// SUN\n\t\tcol.rgb = vec3(1.0,0.5,0.3);    \n        col.a = 1.0;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 UV = uv;\n    float ratio = iResolution.y / iResolution.x;\n    \n    float x = uv.x - 0.5;\n    float y = uv.y * ratio - 0.5;\n    \n    vec2 pos = vec2(x, y); \n    \n    pos *= 1.3;\n    pos.y += 0.3;\n    \n    vec4 col = vec4(0.0);\n    \n    vec2 tpos;\n    \n    float water_offset = 0.003 * cos(pos.y * (3.0 * (pow(11.0 - 40.0 * pos.y,2.0))) - iTime * PI2);\n    \n    if(pos.y < -0.3){\n        // GROUND\n        col.rgb = vec3(0.1,0.0,0.2);\n    } else if (pos.y < -0.2) {\n        // WATER\n        col.rgb = vec3(0.2,0.24,0.9);\n    } else {\n        // SKY\n        col.rgb = vec3(0.6 * (1.2),0.24,0.7); \n    }\n    \n    vec4 above = above_water(pos);\n    col = above.a * above + (1.0 - above.a) * col;\n    \n    if(pos.y > -0.3){\n    \tcol += above_water(pos * vec2(1.0, -1.0) + vec2(0.0, -0.4 +water_offset));\n    }\n    \n    // TREE\n    float trunk = -0.6 + 0.3 * pow(3.0, pos.y + 0.004 * cos(pos.y * 6.0 + iTime * PI2));\n    float trunksize = 0.002 * cos(300.0 * pos.y) + 0.01;\n    vec2 lpos = pos; // leaves pos [(l)pos]\n    lpos.y += 1.5 * pow((pos.x + 0.29), 2.0);\n    lpos += 0.001 * cos(pos.x * 20.0 + time * PI2);\n    vec4 leaves = leaves_f(lpos);\n    col = leaves * leaves.a + (1.0 - leaves.a) * col;\n    \n    if(distance(pos.x, trunk) < trunksize && pos.y < 0.2 && leaves.a < 0.5){\n        col.rgb = vec3(0.14,0.1,0.2);\n    }\n    \n    col += 1.0 * boat(pos * 17.0 + vec2(-5.4, 3.3 + 0.01 * cos(iTime * PI2)));\n    col += 0.4 * boat((pos * 17.0 + vec2(-5.4, 3.5 - 0.01 * cos(iTime * PI2))) * vec2(1.0, -1.0));\n    \n    // some lights\n    float d = distance(pos, vec2(0.157, 0.04));\n    if(d < 0.004){\n    \tcol.r += 0.5 * cos(iTime * PI2) + 0.5;\n    }\n    d = distance(pos, vec2(-0.157, 0.04));\n    if(d < 0.004){\n    \tcol.r += 0.5 * cos(iTime * PI2 + 1.1) + 0.5;\n    }\n    d = distance(pos, vec2(0.317, -0.162));\n    if(d < 0.002){\n    \tcol.r += 0.5 * cos(iTime * PI2 + 1.1) + 0.5;\n    }\n    \n    vec3 before_postproc = col.rgb;\n    col.rgb = vec3(0.3 * length(col.rgb));\n    col.r *= 1.2;\n    col.g *= 0.4;\n    col.b *= 1.2;\n    \n    // Too intense for gif:\n    // Vignette effect\n    col *= 1.2 * pow(1.0 - distance(pos, vec2(0.0)),1.3);\n    col.rgb += 0.6 * before_postproc;\n    \n    col.a = 1.0;\n        \n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}