{
    "Shader": {
        "info": {
            "date": "1487709354",
            "description": "try full screen for more, or scale = 5 + full screen for even more !  (still working with loglevel=2)",
            "flags": 0,
            "hasliked": 0,
            "id": "XdsyWr",
            "likes": 9,
            "name": "Z-curve 2",
            "published": 3,
            "tags": [
                "zcurve",
                "morton"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 974
        },
        "renderpass": [
            {
                "code": "// Z-curve / Morton code  : see https://www.shadertoy.com/view/4sscDn\n// refs : https://en.wikipedia.org/wiki/Z-order_curve\n//        https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n#define loglevel 2 // max 3    1: for 16x16 grid  2: for 256x256 grid\n#define scale 10.\n\nint xy2z(vec2 U) {                   // --- grid location to curve index\n    ivec2 I = ivec2(U);\n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n\nivec2 z2xy(int z) {                  // --- curve index to grid location \n    int n=1;\n    ivec2 I = ivec2(z,z>>1) & MASKS[0];\n    for (int i=1; i<=loglevel+1; i++)\n        I = (I | (I >>  n)) & MASKS[i],\n        n *= 2;\n    return I;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) { // --- draw line(a,b)  ( indeed, get distance field )\n\tvec2 pa = p - a, ba = b - a,\n          d = pa - ba *  clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(d); \n}\n\n    \nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U -= 4.5; O-=O;\n    U /= scale;\n    float R = exp2(ceil(log2(iResolution.y/scale)));\n/*   \n    for (int Z=0; Z<int(R*R); Z++)    // quite expensive construction.\n        O += smoothstep(1.5/scale,0.,line(U, vec2(z2xy(Z)), vec2(z2xy(Z+1)))) ; \n*/   \n    if ( max(U.x,U.y) >= R) return;\n    vec2 P;\n    #define L(x,y) O += smoothstep(1.5/scale,0.,line(U, P=vec2(x,y),vec2(z2xy(xy2z(P)-1)))) * sqrt(vec4(xy2z(P))/R/R)\n    for (int p = 0; p < int(R); p++) // only check lines in the current row + current column\n         L( p, ceil(U.y) ),\n         L( ceil(U.x), p );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}