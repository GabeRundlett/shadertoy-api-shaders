{
    "Shader": {
        "info": {
            "date": "1668419034",
            "description": "Same as: https://www.shadertoy.com/view/ddSGDd\n2D version.",
            "flags": 32,
            "hasliked": 0,
            "id": "msXSzn",
            "likes": 8,
            "name": " Particles 2D version",
            "published": 3,
            "tags": [
                "2d",
                "particles",
                "bloom"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 30;\nconst float MIN_DIST = 6.;\nconst float MAX_DIST = 3.;\nconst float PRECISION = 0.002;\n#define AA 0\n#define PI 3.14159\n\n\nconst float K = 120.;\n\n// iq's palette\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.4, 0.2, 1.);\n    vec3 b = vec3(0.75, 0.7, 0.7);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.6, 0.35, 0.05);\n    \n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 analytic_sphere(vec2 p, float r) {\n    //return sphere_coord;\n    float l = length(p);\n    float h = r*cos(l*PI/2./(r*1.5));\n    p = normalize(p/r)*asin(length(p/r)) / PI;\n    //p *= smoothstep(0., 0.001, sign(p));\n    return vec3(p, h*16.);\n}\n\nvec3 Ring(vec2 uv, inout vec3 col, inout vec3 col_bloom){\n    \n    float dmin=1e10, d;\n    \n    vec3 pos, posf;\n    for (int i=0; i<int(get_NPARTICLES()); i++){\n        vec3 tmp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n        \n        pos.xy = decode(tmp.x);\n        pos.z = tmp.y;\n                \n        d = 1.-smoothstep(0., .001, length(uv-pos.xy)-(1.+pos.z)/K);\n        \n        float d2 = abs(length(uv-pos.xy));\n        \n        if (d2<dmin){ \n            dmin = d2;\n            posf = pos*d;\n        }\n        \n        col += d*palette(float(i)/get_NPARTICLES()+iTime/8.);\n        \n        d2 = d2-(1.+pos.z)/K;\n        if (iFrame >= 1) col_bloom += palette(float(i)/get_NPARTICLES()+iTime/8.)*exp(-abs(d2*d2)/.0003)*.4; \n           \n    }\n    return posf;\n}\n\nvec3 calcNormal(vec2 uv){\n    vec2 e = vec2(1.0, -1.0) * 0.0001*1.45674;\n    vec3 pos;\n    float d;\n    float dtot = 0.;\n    vec3 S = vec3(0.);\n    vec3 tmpS;\n    for (int i=0; i<int(get_NPARTICLES()); i++){\n        vec3 tmp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n        pos.xy = decode(tmp.x);\n        pos.z = tmp.y;\n        d = 1.-smoothstep(0., .1, length(uv-pos.xy)-(1.+pos.z)/K);\n        tmpS =\n            normalize(\n                e.xyx*analytic_sphere(uv +  e.xy -pos.xy, (1.+pos.z)/K) + \n                e.yxx*analytic_sphere(uv +  e.yx -pos.xy, (1.+pos.z)/K) + \n                e.xxx*analytic_sphere(uv +  e.xx -pos.xy, (1.+pos.z)/K))*d              \n                ;\n        S = max(S, tmpS);\n\n    }\n    return S;\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, vec3 col) {\n  // ambient\n  float N = 2.;\n  vec3 ambient = (col*(.5) *N )/N;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = (col * dotLN*N)/N;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = ((col) * pow(dotRV, 5.)*N)/N;\n\n  return  ambient + diffuse + specular*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1)*4.;\n  \n  vec3 col_ball = vec3(0.);\n  vec3 col_bloom = vec3(0.);\n  \n  vec3 p = Ring(uv*1.4, col_ball, col_bloom);\n\n  vec3 normal = calcNormal(uv*1.4);\n  \n  \n  vec3 lightPosition = vec3(2, 2, 3);\n  vec3 ld = normalize(lightPosition - p);\n\n  vec3 rd = normalize(vec3(uv, 2)); \n  vec3 col = phong(ld, normal, rd, col_ball);\n      \n  // Output to screen\n  vec3 col_tot = col_bloom+max(col*.4, vec3(0.));\n  \n  fragColor = vec4(col_tot, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NPARTICLES 150\n#define PI 3.14159\n\nfloat get_NPARTICLES(){\n    return float(NPARTICLES);\n}\n\nfloat hash11( float x){\n    return fract( sin( float(x)*101.4567)*41.234);\n}\n\n\nvec2 hash22(vec2 p){\n    vec2 a = vec2(10.487,9.4567);\n    vec2 b = vec2(456.775, 150.2467);\n    return fract( sin(vec2(dot(a,p), dot(b,p)))*41.234);\n}\n\nvec3 hash33(vec3 p){\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\nvec3 hash13(float x){\n    vec3 p = vec3(x,x,x);\n    vec3 a = vec3(10.487,9.4567, 41.28753);\n    vec3 b = vec3(456.775, 150.2467, 234.4565);\n    vec3 c = vec3(21.125, 15.6754, 23.6125);\n    return fract( sin(vec3(dot(a,p), dot(b,p), dot(c,p)))*41.234);\n}\n\n// PACK UNPACK METHODS FROM https://www.shadertoy.com/view/WtfyDj\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\n// iq's sdf\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec3 init_position(vec3 seed){\n    vec3 pos = vec3(seed);\n    return vec3(pos);\n}\n\nvec3 init_velocity(vec3 seed){\n    vec3 vel = vec3(seed.yxz);\n    return vec3(vel);\n}\n\n// found this on: https://www.vertexshaderart.com/art/aqgyqr6ASpcsZTeEu\nvec2 sphere_point(float i) {\n  // golden ratio\n  float phi = (sqrt(5.) + 1.) / 2. - 1.;\n  // golden angle\n  float ga = phi * 2. * PI;\n  \n  vec2 p = vec2(0.);  \n  p.x = ga * i;\n  p.x /= 2. * PI;\n  p.x = fract(p.x);\n  p.x *= 2. * PI;\n    \n  p.y = asin(-1. + 2. * i / get_NPARTICLES());\n  return p;\n}\nvec3 lla2xyz(vec2 latlon, float rad) {\n  float rxz = rad * cos(latlon.y);\n  \n  return vec3(\n    rxz * cos(latlon.x),\n    rad * sin(latlon.y),\n    rxz * sin(latlon.x)\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    \n    if (uv.x>int(get_NPARTICLES())){\n        fragColor = vec4(0.);\n        return;\n    }\n    if (uv.y>1){\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 center_obj = vec3(0.);\n    \n    vec3 pos;\n    vec3 vel;\n    \n    if (iFrame <= 1){\n        float seedx = hash11( float(uv.x)+.1);\n        float seedy = hash11( float(uv.x)+5.);\n        float seedz = hash11(  float(uv.x)+1.);\n        pos = init_position(vec3(seedx, seedy, seedz));\n        vel = init_velocity(vec3(seedx, seedy, seedz));\n        }\n        \n    else{\n        vec4 state = texelFetch(iChannel0, uv, 0);\n        \n        pos.xy = decode(state.x);\n        pos.z = state.y;\n        \n        vec2 tmp = sphere_point(mod(float(uv.x)-40.*floor(iTime/2.), get_NPARTICLES()));\n        vec3 id = lla2xyz(tmp, .5) + .05*(hash13(float(uv.x)+floor(iTime*2.*PI)) -.5)*(.5+.5*cos(iTime));\n               \n        vel.xy = decode(state.z);\n        vel.z = state.w;\n        \n        pos += vel*.2;\n        vel = (.96 * vel + .04 * -(pos-id));\n\n    }\n    \n    vec4 state;\n    \n    state.x = encode(pos.xy);\n    state.y = pos.z;\n    \n    state.z = encode(vel.xy);\n    state.w = vel.z;\n\n    \n    fragColor = state;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}