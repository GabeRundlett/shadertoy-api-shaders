{
    "Shader": {
        "info": {
            "date": "1615664403",
            "description": "This is still a blank for a generalized planet generator. It remains only to decorate Will be updated.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ssXGRM",
            "likes": 17,
            "name": "Planets evolution",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "noise",
                "perlin",
                "planet"
            ],
            "usePreview": 0,
            "username": "foxes",
            "viewed": 886
        },
        "renderpass": [
            {
                "code": "//\n// Panteleymonov A K 2021\n//\n\n//****************** if there are problems with the image change the hash ***********\n\n//#define hash(n) fract(mod(n*n*34.+n,289.)/289.)\n#define hash(n) fract(abs(sin(n))*1399763.5453123)\n//#define hash(n) fract(fract(n*0.31830988618379067153776752674503)*fract(n*0.15915494309189533576888376337251)*265871.1723)\n\nvec2 scroll = vec2(0.);\nint cid = 0;\nfloat cmf = 0.;\n\n//atmosfera colors\nconst vec3 catm01[6] = vec3[6](vec3(1.0,0.3,0.0),vec3(1.0,0.96,0.7),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.3,0.76,1.0),vec3(1.0,1.0,1.0));\nconst vec3 catm02[6] = vec3[6](vec3(1.0,.99,.94),vec3(1.0,0.96,0.7),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.3,0.76,1.0),vec3(1.0,1.0,1.0));\n\n//cloud colors\nconst vec3 ccl01[6] = vec3[6](vec3(0.0,0.0,0.0),vec3(0.9,0.8,0.6),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\nconst vec3 ccl02[6] = vec3[6](vec3(0.0,0.0,0.0),vec3(1.0,0.9,0.6),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7));\n\n//ground colors\nconst vec3 cps01[6]  = vec3[6](vec3(2.0,0.2,0.0),vec3(.94,.63,0.33),vec3(.94,.68,0.53),vec3(.94,.63,0.33),vec3(.94,.63,0.33),vec3(1.0,1.0,1.0));\nconst vec3 cps02[6]  = vec3[6](vec3(0.02,0.0,.0),vec3(1.0,0.85,.57),vec3(0.95,0.85,.47),vec3(1.0,0.85,.57),vec3(1.0,0.85,.57),vec3(1.0,1.0,1.0));\n\n//water and lava colors\nconst vec3 cwl01[6] = vec3[6](vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(0.1,0.9,0.4), vec3(0.0,0.9,1.0), vec3(0.0,0.7,1.0), vec3(0.0,0.7,1.0));\nconst vec3 cwl02[6] = vec3[6](vec3(1.,1.,0.), vec3(.8,1.,.1), vec3(0.1,0.4,0.2), vec3(0.3,0.0,0.6), vec3(0.2,0.0,0.7), vec3(0.2,0.0,0.7));\n\nvec3 catmF01() { return mix(catm01[cid],catm01[cid+1],cmf); }\nvec3 catmF02() { return mix(catm02[cid],catm02[cid+1],cmf); }\n\nvec3 cclF01() { return mix(ccl01[cid],ccl01[cid+1],cmf); }\nvec3 cclF02() { return mix(ccl02[cid],ccl02[cid+1],cmf); }\n\nvec3 cpsF01() { return mix(cps01[cid],cps01[cid+1],cmf); }\nvec3 cpsF02() { return mix(cps02[cid],cps02[cid+1],cmf); }\n\nvec3 cwlF01() { return mix(cwl01[cid],cwl01[cid+1],cmf); }\nvec3 cwlF02() { return mix(cwl02[cid],cwl02[cid+1],cmf); }\n\nvec4 hash4( vec4 n ) { return hash(n); }\nvec3 hash3( vec3 n ) { return hash(n); }\nvec2 NC0=vec2(1.0,136.0);\nvec3 NC1=vec3(1.0,136.0,31.0);\nfloat seed = 0.0;\n\nvec2 getBL(vec3 pos) { return vec2(atan(pos.x,pos.z),atan(length(pos.xz),pos.y))/3.1415; }\nvec3 setBL(vec2 bl) { bl*=3.1415; return vec3(cos(bl.y)*cos(bl.x),sin(bl.y),cos(bl.y)*sin(bl.x)); }\n\n// Simple 2d interpolated noise for mercator projection, using local seed.\nfloat sphereNoise2Ds(vec2 bl,float scale,float seed)\n{\n    bl = vec2(fract(bl.x*0.5+0.5), bl.y*scale);\n    vec2 yc = floor(vec2(bl.y)+vec2(0.,1.));\n    vec2 xc = floor(sin(3.1415 * yc/scale)*scale*2.0);\n    vec4 p = xc.xyxy*vec4(bl.xx, fract(bl.xx+1.0/max(vec2(1.),xc)));\n    vec3 f = fract(vec3(p.xy, bl.y));\n    f=f*f*(3.0-2.0*f);\n    yc = (yc + vec2(scale)) * NC0.y;\n    vec3 fn = 1.-f;\n    vec4 n= hash4(floor(p)*NC0.x + yc.xyxy +seed);\n    return dot(n, vec4(fn.xy,f.xy)*vec4(fn.z,f.z,fn.z,f.z));\n}\n\nvec2 sphereNoise2D2s(vec2 bl,float scale,vec2 seed)\n{\n    bl = vec2(fract(bl.x*0.5+0.5), bl.y*scale);\n    vec2 yc = floor(vec2(bl.y)+vec2(0.,1.));\n    vec2 xc = floor(sin(3.1415 * yc/scale)*scale*2.0);\n    vec4 p = xc.xyxy*vec4(bl.xx, fract(bl.xx+1.0/max(vec2(1.),xc)));\n    vec3 f = fract(vec3(p.xy, bl.y));\n    f=f*f*(3.0-2.0*f);\n    yc = (yc + vec2(scale)) * NC0.y;\n    vec3 fn = 1.-f;\n    p = floor(p)*NC0.x + yc.xyxy;\n    vec4 n1= hash4(p +seed.x);\n    vec4 n2= hash4(p +seed.y);\n    p = vec4(fn.xy,f.xy)*vec4(fn.z,f.z,fn.z,f.z);\n    return vec2(dot(n1, p), dot(n2, p));\n}\n\n// Simple 2d interpolated noise for mercator projection, using global seed.\nfloat sphereNoise2D(vec2 bl,float scale) { return sphereNoise2Ds(bl,scale,seed); }\n\n// Simple 2d interpolated noise for mercator projection, using global seed animated.\nfloat sphereNoise2D(vec3 blt,float scale)\n{\n    float z = floor(blt.z)*54.0;\n    float f = fract(blt.z);\n    //f=f*f*(3.0-2.0*f);\n    return dot(sphereNoise2D2s(blt.xy,scale,seed+z+vec2(0.,54.)),vec2(1.-f,f));\n}\n\n// Simple 2d interpolated distortion noise for mercator projection, using global seed.\nfloat sphereNoise2Do(vec2 bl,float scale,float force)\n{\n    bl = bl+sphereNoise2D2s(bl,scale*2.0f,vec2(3.,20.))*force/scale;\n    bl.y = clamp(bl.y,0.0,1.0);\n    return sphereNoise2D(bl,scale);\n}\n\nfloat sphereNoise2Do2(vec2 bl,float scale,float force, float s)\n{\n    bl = bl+sphereNoise2D2s(bl,scale*s,vec2(3.,20.))*force/scale;\n    bl.y = clamp(bl.y,0.0,1.0);\n    return sphereNoise2D(bl,scale);\n}\n\nvec2 sphereIntersect(vec3 ray,vec3 pos,float r)\n{\n    float r2=r*r;\n    float cd = dot(pos,ray);\n    vec3 p = ray * cd-pos;\n    float t2 = dot(p,p);\n    if (t2>=r2) return vec2(-1.0, -1.0);\n    float d = sqrt(r2-t2);\n    return cd+vec2(- d,d);\n}\n\nfloat sphereIntersectIn(vec3 ray,vec3 pos,float r)\n{\n    float r2=r*r;\n    float cd = dot(pos,ray);\n    vec3 p = ray * cd-pos;\n    float t2 = dot(p,p);\n    if (t2>=r2) return -1.0;\n    return cd + sqrt(r2-t2);\n}\n\nvec3 sphereNormal(vec3 pos, vec3 surface)\n{\n    return normalize(surface-pos);\n}\n\nfloat spherePerlin(vec2 bl,float scale)\n{\n    return (sphereNoise2D(bl,512.0*scale)*0.8+sphereNoise2D(bl,256.0*scale)*0.8\n     +sphereNoise2D(bl,128.0*scale)+sphereNoise2D(bl,64.0*scale)\n     +sphereNoise2D(bl,32.0*scale)+sphereNoise2D(bl,16.0*scale)\n     +sphereNoise2D(bl,8.0*scale)+sphereNoise2D(bl,4.0*scale)\n     +sphereNoise2D(bl,2.0*scale)*1.2+sphereNoise2D(bl,scale)*1.2)*0.1;\n}\n\nfloat spherePerlinA(vec3 blt,float scale)\n{\n    return (sphereNoise2D(blt,16.0*scale)\n     +sphereNoise2D(blt,8.0*scale)+sphereNoise2D(blt,4.0*scale)\n     +sphereNoise2D(blt,2.0*scale)*1.2+sphereNoise2D(blt,scale)*1.2)*0.2;\n}\n\nfloat spherePerlinHalf(vec2 bl,float scale)\n{\n    return (sphereNoise2D(bl,16.0*scale)+sphereNoise2D(bl,8.0*scale)+sphereNoise2D(bl,4.0*scale)\n     +sphereNoise2D(bl,2.0*scale)+sphereNoise2D(bl,scale))*0.2;\n}\n\nfloat spherePerlinHalfs(vec2 bl,float scale, float seed)\n{\n    return (sphereNoise2Ds(bl,16.0*scale,seed)+sphereNoise2Ds(bl,8.0*scale,seed)+sphereNoise2Ds(bl,4.0*scale,seed)\n     +sphereNoise2Ds(bl,2.0*scale,seed)+sphereNoise2Ds(bl,scale,seed))*0.2;\n}\n\nvec2 spherePerlinHalf2s(vec2 bl,float scale, vec2 seed)\n{\n    return (sphereNoise2D2s(bl,16.0*scale,seed)+sphereNoise2D2s(bl,8.0*scale,seed)+sphereNoise2D2s(bl,4.0*scale,seed)\n     +sphereNoise2D2s(bl,2.0*scale,seed)+sphereNoise2D2s(bl,scale,seed))*0.2;\n}\n\n// Perlin distortion noise \nfloat spherePerlinHalfd(vec2 bl,float scale,float force)\n{\n    return (sphereNoise2Do(bl,16.0*scale,force)+sphereNoise2Do(bl,8.0*scale,force)\n     +sphereNoise2Do(bl,4.0*scale,force)\n     +sphereNoise2Do(bl,2.0*scale,force)+sphereNoise2Do(bl,scale,force))*0.2;\n}\n\n// Perlin distortion noise with increasing coefficient\nfloat spherePerlinHalfds(vec2 bl,float scale,float force)\n{\n    return sphereNoise2Do(bl,16.0*scale,force)*0.05\n    +sphereNoise2Do(bl,8.0*scale,force)*0.15+sphereNoise2Do(bl,4.0*scale,force)*0.2\n    +sphereNoise2Do(bl,2.0*scale,force)*0.25+sphereNoise2Do(bl,scale,force)*0.35;\n}\n\nvec3 wind3D(vec3 pos,float rings,float skip)\n{\n    vec3 f = fract(pos)-0.5;\n    vec3 px = floor(pos);\n    float r = length(pos);\n    vec3 wind =vec3(0.);\n\n    for (int z = -0;z<2;z++)\n    for (int y = -0;y<2;y++)\n    for (int x = -0;x<2;x++) {\n        vec3 off = vec3(float(x),float(y),float(z));\n        vec3 xyz = px + off;\n        float p = dot(xyz,NC1);\n        vec3 add = hash(vec3(p,p+30.0,p+23.0));\n        vec3 fxyz = f + add*0.8-off;\n        float ml = clamp(1.0-length(fxyz)*1.5,0.,1.);\n        vec3 wp = normalize(pos - fxyz) * r - pos;\n        float l1 = length(wp);\n        float l2 = 1.-l1;\n        vec3 w = normalize(cross(wp,pos));\n        wind +=w*ml*clamp(0.5-l1,0.,1.)*clamp(1.0-l2*l2*l2,0.,1.);\n    }\n    return wind;\n}\n\nfloat atmosphere(vec3 pos, vec3 atmosSurface, vec3 ray, vec3 lnorm, float planetRadius, float atmosRadius, float atmosDepth)\n{\n    float wall = sqrt(atmosRadius*atmosRadius - planetRadius*planetRadius);\n    float acc = clamp(atmosDepth/wall,0.0,1.0);\n    acc = acc*pow(clamp(dot(lnorm,normalize(atmosSurface-pos)),0.0,1.0),0.4);\n    acc = acc*acc;\n    acc = acc*acc;\n    \n    return acc;\n}\n\nvec3 sphereTexture(vec3 realSurface,vec3 ray, vec3 snorm,vec3 lnorm,float time)\n{\n    seed = 1.0;\n    vec2 bl = getBL(realSurface);\n\n    seed = 2.0;\n    float d = spherePerlinHalfds(bl,8.0,0.5);\n    seed = 5.0;\n    float c = spherePerlin(bl,4.0);//(c1 + c2)*0.5;\n    float canr = clamp(1.0-abs(d-0.4)*10.0,0.0,1.0);\n    float can = clamp(1.0-abs(d-0.5)*10.0,0.0,1.0) * clamp(c*5.0-1.6,0.0,1.0);\n    float can2 = can*can;\n    float can3 = can2*can;\n    float canr3 = canr*canr*canr*canr;\n    \n    float middle = (0.25 - abs(0.25-abs(0.5-bl.y)))*4.;\n    seed = 10.0;\n    float e = spherePerlinHalfds(bl,6.0,0.5);\n    float mc = clamp(e*6.0-2.4, 0.0, 1.0);\n\n    float snow = scroll.x-0.55;\n    snow = (snow*snow*snow*snow*snow+0.5)*40.0-20.3;\n    snow = clamp((snow+abs(0.5-bl.y)-e*0.3)*50.0,0.,1.);\n\n    float waterline = scroll.x-0.5;\n    waterline = clamp((waterline*waterline*waterline+0.5)*14.0-6.5, 0., 1.);\n    float beach = mix(e, e*c*2.6, 0.05) - waterline;\n    float land = clamp(clamp(beach * 200.0, 0., 1.), 0., 1.); //continents\n    land = land - mix(0.,clamp((mix(canr3,canr3*c*2.6,0.1)-1.3+waterline)*10.0, 0.0, 1.0),land*middle); //river\n\n    vec3 water = mix(cwlF02(),cwlF01(),c+mc*0.2);\n\n    float fa = (spherePerlinA(vec3(bl,time),200.0)+spherePerlinA(vec3(bl,time+2.5),200.0))*0.5;\n    \n    float f = mix(1.0-pow(1.0-c*1.7,2.0),c*1.7,0.3);\n    \n    float forest = scroll.x-0.2;\n    forest = clamp(forest*4.0, 0., 1.);\n    forest = clamp((canr+can+forest*2.-2.3+f*0.1+mc*c*0.5)*4.,0.,1.)*clamp((middle-0.5+mc*c*0.4)*8.,0.,1.);//+forest-0.5\n    forest = clamp(forest*2.,0.,1.);\n\n    float ground = scroll.x-0.2;\n    ground = clamp(ground*4.0, 0., 1.);\n    ground = clamp((canr+can+ground*2.-1.8+f*0.1+mc*c*0.5)*2.,0.,1.)*clamp((middle-0.4+mc*c*0.4)*4.,0.,1.);//+forest-0.5\n    ground = clamp(ground*2.,0.,1.);\n    \n    float rock = scroll.x-0.7;\n    rock = clamp((rock+abs(0.5-bl.y)-e*0.3)*50.0,0.,1.);\n    \n    float canl = (can3+fa-0.5);\n    f = f-can3*0.34;\n\n    float light = 1.-clamp(dot(snorm,lnorm),0.0,1.0);\n    light = 1.0-light*light;\n    float ref = clamp(dot(reflect(ray,normalize(snorm+0.6*cross(ray,snorm)*(0.5-fa))),lnorm),0.0,1.0);\n    ref = ref*0.9;\n    \n    vec3 ert = mix(cpsF01(),cpsF02(),f)*f;\n    ert = mix(ert, mix(vec3(1.0,0.5,0.0),vec3(1.0,0.8,0.33),mc), 0.2);\n    vec3 gc = mix(mix(vec3(0.3,0.3,0.0),vec3(0.5,0.5,0.3),e*f*f)*f, mix(vec3(0.3,0.2,0.0),vec3(1.0,0.8,0.33),mc), 0.5);\n    ert = mix(ert,gc, clamp(ground+forest,0.,1.));\n    ert = mix(ert, vec3(0.8)*clamp(f*2.-1.4+c,0.,1.), rock*0.7);\n    ert = clamp(mix(ert, mix(vec3(0.7,0.9,0.0),vec3(0.0,0.1,0.1),c), forest),vec3(0.,0.,0.),vec3(1.,1.,1.));\n    vec3 col = mix(water,ert,land);\n    \n    float l = (1.0-land) * pow(ref,8.0)*(fa+1.0);\n    float wl = clamp((light+pow(ref,6.0)) * (1.0-land) * mix((abs(0.5-fa)*2.0),0.0,0.3),0.0,1.0);\n       \n    vec3 lcolor = l*mix(vec3(1.0),vec3(1.0,0.9,0.8),clamp(dot(ray,lnorm),0.,1.));\n    col = clamp(mix(col*light+lcolor,vec3(1.0),wl*1.0*light),vec3(0.,0.,0.),vec3(1.,1.,1.));\n    \n    vec3 lav = mix(vec3(1.,0.0,0.),mix(cwlF02(),cwlF01(),clamp(abs(0.5-canl)*3.0,0.,1.)),clamp(canl,0.,1.));\n    float lm=clamp(scroll.x*5.0,0.,1.);\n    can3 = mix(mix(can3,can3*can3*can3*can3,lm),0.,lm);\n    col = mix(col*light,lav*2.0,can3);\n\n    vec3 snowc = clamp(mix(mix(vec3(0.1,0.3,0.7),vec3(0.6,0.6,0.6),mc),vec3(1.0,1.0,1.0),f)*f,vec3(0.,0.,0.),vec3(1.,1.,1.));\n    snowc = mix(snowc,mix(vec3(0.0,1.0,1.0),vec3(1.0,1.0,1.0),mc),0.2);\n\n    col = mix(col,snowc*light,snow);\n\n    return clamp(col,vec3(0.,0.,0.),vec3(1.,1.,1.));\n}\n\nvec2 cloudTexture(vec3 realSurface, float time)\n{\n   seed = 14.0;\n   vec2 bl = getBL(realSurface);\n\n   vec3 w = wind3D(realSurface*1.,1.5,0.);\n   w += wind3D(realSurface*2.,1.5,0.)*0.2;\n   w += wind3D(realSurface*6.,1.5,0.)*0.1;\n   vec2 t = time*vec2(0.2,0.5); \n   vec2 bld1 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.x))));\n   vec2 bld2 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.x+0.5))));\n   vec2 blc1 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.y))));\n   vec2 blc2 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.y+0.5))));\n\n   seed = 14.0+floor(t.x)*0.1;\n   float d1 = spherePerlinHalf(bld1, 6.0);\n   seed = 14.05+floor(t.x+0.5)*0.1;\n   float d2 = spherePerlinHalf(bld2, 6.0);\n   \n   seed = 14.0+floor(t.y)*2.0;\n   float c1 = spherePerlinHalf(blc1, 192.0);\n   seed = 15.0+floor(t.y+0.5)*2.0;\n   float c2 = spherePerlinHalf(blc2, 192.0);\n   vec2 fdc = abs(0.5-fract(t))*2.0;\n   float d = mix(d1,d2,fdc.x);\n   float c = mix(c1,c2,fdc.y);\n   \n   float f = clamp((d*d)*4.0-c-0.5,0.0,1.0);\n   f = 1.-f;\n   return vec2(1.-f*f,0);\n   //return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // resolution\n    float res = 1.0 / iResolution.y;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\n    \n    // bace const\n    float time=iTime*1.0;\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 col = vec3(0.0);\n    vec2 mouse = (iMouse.xy*2.0-iResolution.xy)*res;\n\n    // segments\n    scroll = iMouse.z>0.0 ? mouse : vec2(floor(p.x*2.5)*0.4+0.2,0.0);\n    scroll = clamp(scroll*0.5+0.5,vec2(0.),vec2(1.));\n    // test scroll\n    cid = int(floor(scroll.x*5.0));\n    cmf = fract(scroll.x*5.0);\n    //const vec3 pal[6] = vec3[6](vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.0,0.0,1.0),vec3(1.0,0.0,1.0));\n    //col = mix(pal[int(floor(scroll.x*5.0))],pal[int(floor(scroll.x*5.0))+1],fract(scroll.x*5.0));\n\n    // transforms\n    vec2 rotate = iMouse.z>0.0 ? vec2((mouse.x*5.+5.0)*3.1415,mouse.y*2.) : vec2(0.,-0.6);\n    //vec2 rotate = vec2(0.,-0.6);\n    float protate = time*0.025;\n    vec4 mcs=vec4(sin(rotate),cos(rotate));\n    vec2 pcs=vec2(cos(protate),sin(protate)); // planet rotation\n    mat3 mr=mat3(vec3(mcs.z,0.0,mcs.x),vec3(0.0,1.0,0.0),vec3(-mcs.x,0.0,mcs.z));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,mcs.w,mcs.y),vec3(0.0,-mcs.y,mcs.w))*mr;\n    mat3 pmr=mat3(vec3(pcs.x,0.0,pcs.y),vec3(0.0,1.0,0.0),vec3(-pcs.y,0.0,pcs.x));\n    \n    // object data\n    float dist=2.3;\n    float rplanet = 1.0;\n    float ratmos = 1.15;\n    float rcloud = 1.005;\n    vec3 spos = vec3(0.0,0.0,dist);\n    vec3 lpos = vec3(4.5,4.5,-9.0+dist);\n    lpos = mr*(lpos-spos) + spos;\n    vec3 lnorm = normalize(lpos - spos);\n    \n    // render calc\n    float dplanet = sphereIntersect(ray,spos,rplanet).x;\n    vec2 dcloud = sphereIntersect(ray,spos,rcloud);\n    float datmos = sphereIntersect(ray,spos,ratmos).x;\n    if (dplanet>0.0) {\n        vec3 ssurface = ray*dplanet;\n        vec3 snorm = sphereNormal(spos,ssurface);\n        vec3 lsnorm = normalize(lpos - ssurface);\n        float dcs = sphereIntersectIn(lnorm,spos-ssurface,rcloud);\n        vec3 scloud = ssurface+lnorm*dcs;\n        float cs = dot(snorm,lnorm)>0. ? clamp(1.0-cloudTexture((scloud-spos)*mr*pmr,time*0.2).x,0.0,1.0) : 1.0;\n\n        col = sphereTexture((ssurface-spos)*mr*pmr,ray,snorm,lsnorm,time);\n        col = mix(col,col*cs,0.7);\n    }\n    if (datmos>0.0) {\n        float adepth = dplanet>0.0 ? (dplanet-datmos)*1.2 : abs(dot(ray,spos)-datmos);\n        vec3 ssurface = ray*datmos;\n        float ap = atmosphere(spos, ssurface, ray, lnorm, rplanet, ratmos, adepth);\n        col = mix(col,mix(catmF01(),catmF02(),ap),ap);\n    }\n    if (dcloud.x>0.0) {\n        vec3 sback = ray*dcloud.y;\n        vec3 ssurface = ray*dcloud.x;\n        vec3 snorm = sphereNormal(spos,ssurface);\n        vec3 lsnorm = normalize(lpos - ssurface);\n        vec2 al = cloudTexture((ssurface-spos+lsnorm*0.01)*mr*pmr,time*0.2);\n        vec2 a = cloudTexture((ssurface-spos)*mr*pmr,time*0.2);\n        float emboss = a.x-al.x+0.05;\n        float light = 1.-clamp(dot(snorm,lsnorm),0.0,1.0);\n        light = 1.-light*light;\n        col = mix(col,mix(cclF01(),cclF02(),a.y)*light,clamp(a.x,0.,1.))\n            + vec3(clamp(emboss*0.2,0.,1.)+clamp(emboss*0.3*a.x+a.x*0.3*light,0.,1.))*light;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}