{
    "Shader": {
        "info": {
            "date": "1649105697",
            "description": "Mostly a homage to @Shane's techniques for multi-tap and cube mapping. Playing with truchet tiles in bmp+texture in a single layered grid. \nAA = 2 suggested ",
            "flags": 0,
            "hasliked": 0,
            "id": "slSczz",
            "likes": 29,
            "name": "Cube Stacks ðŸ§Š",
            "published": 3,
            "tags": [
                "raymarching",
                "cube",
                "texture",
                "cubemap"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 528
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    ðŸ§Š Cube Stacks - its really just one layer packed with waves. \n    4/3/22 | @byt3_m3chanic\n    \n    Mostly a homage to @Shane's techniques for multi-tap grids and cube mapping.\n    Was just a fun exercise in playing with cube maps\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    75.\n\n#define ZERO (min(iFrame,0))\n// AA 1 = Off/ 2+ = On\n#define AA 1\n\nmat2 rot(float a) { \n    return mat2(cos(a),sin(a),-sin(a),cos(a)); \n}\nfloat hash21(vec2 a){ \n    return fract(sin(dot(a, vec2(27.609, 57.583)))*43768.5453); \n}\n//@iq ALL THE SDFS\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),.0);\n}\nfloat box(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),.0);\n}\n\n//globals s = saved / g = global\nvec3 s_hit,g_hit;\nvec2 s_id,g_id;\nfloat travelspeed = 0.,s_hash,g_hash;\n\n//scales for all things\nconst float scale = 1./.345;\nconst float scale_h = scale*.5;\nconst vec2 s = vec2(scale)*2.;\n\n//positions and rotations\nconst vec2 pos = vec2(.5,-.5);\nconst vec2[4] ps4 = vec2[4](pos.yx,pos.xx,pos.xy,pos.yy);\nconst vec4 rotations = vec4(0.,1.570,3.141,4.712);\n\n// block map\n// 4 tap technique @Shane\nvec2 map(vec3 q3){\n    vec2 res = vec2(1e5,0.);\n\n    q3.xz += vec2(travelspeed,-travelspeed);\n    \n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    float t=1e5, y=1e5;\n\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2. -  ps4[0]/2.;\n        p = q3.xz - ct*s;\n        ip = floor(p/s) + .5;\n        p -= (ip)*s;\n        vec2 idi = (ip + ct)*s;\n\n        float px = sin(idi.x*2.)*.4;\n        float py = cos(idi.y*2.)*.4;\n        float ah = -floor((px+py)*scale)*scale;\n  \n        vec3 q = vec3(p.x,q3.y+9.-ah,p.y);\n\n        // just a box\n        float b = box(q,vec3(scale*.4645))-.125;\n        if(b<t) {\n            t = b;\n            s_id = idi;\n            s_hit = q;\n            s_hash= px+py;\n        }\n  \n    }\n    \n\tif(t<res.x) res = vec2(t,2.);\n\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p);\n        if(abs(t.x)<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.35:t.x;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 getFace(int face, vec3 p, inout vec3 mask) {\n    vec2 uv = p.xy;\n    float px = fwidth(uv.x)*.5;\n    uv = uv/scale_h;\n\n    vec3 color = vec3(.5);\n\n    \n    vec2 grid_uv = fract(uv)-.5;\n    vec2 grid_id = floor(uv);\n    \n    float rnd = hash21(grid_id+g_id);\n    if(rnd>.5) grid_uv.x*=-1.;\n\n    vec2 d2 = vec2(length(grid_uv-.5),length(grid_uv+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid_uv-.5):vec2(grid_uv+.5);\n\n    float fm = box(uv,vec2(scale_h*.5))-.075;\n    float fx = fm;\n    fm=abs(fm)-.025;\n\n    fm=smoothstep(px,-px,fm);\n    fx=smoothstep(px,-px,fx);\n    color=mix(color,vec3(.05),fx);\n\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.125;\n\n    mask=vec3(circle,fm,fx);\n    circle=smoothstep(px,-px,circle);\n    color = mix(color, vec3(.15),circle);\n\n    return vec3(1.-color);\n}\n\n// based on bmp mapping from @Passion\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face, inout vec3 mask){\n    vec2 e = vec2(per*MIN_DIST, 0);  \n    mat3 m = mat3( \n        getFace(face, p - e.xyy,mask), \n        getFace(face, p - e.yxy,mask), \n        getFace(face, p - e.yyx,mask)\n    );\n    vec3 g = vec3(.299,.587,.114) * m; \n    g = (g-dot(getFace(face, p,mask),vec3(.299,.587,.114)))/e.x; \n    g -= n*dot(n,g);  \n    return normalize(n+g*bf);\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 4.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.0029/.27; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nconst vec3 FC = vec3(0.059,0.090,0.102);\n\nvec3 hue(float t){ return .54 + .45*cos(PI2*t*(vec3(.95,.97,.98)+vec3(0.471,0.878,0.063))); }\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    bool hit = false;\n\n    vec2 ray = marcher(ro,rd,p, hit, 85);\n    d = ray.x;\n    m = ray.y;\n    g_hit = s_hit;\n    g_id = s_id;\n    g_hash=s_hash;\n    \n    if(hit)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-18.*sin(T*.1),11,8.*cos(T*.1));\n        vec3 l = normalize(lpos);\n        \n        float rhash= hash21(g_id.yx);\n \n        vec3 h = vec3(.45);\n        vec3 clr = hue((rhash*3.44)*.46);\n        \n        vec3 hp = g_hit;\n        vec3 tn = n;\n        \n        vec3 cuv;\n        int face;\n        \n        if(m==2.){\n            tn = n;\n            //@Shane https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n\n            // set coords\n            if(face==0) cuv = hp.yzx;\n            if(face==1) cuv = hp.zxy;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.xzy;\n            if(face==5) cuv = hp.yzx;\n\n            // get bump map surface\n            vec3 mask = vec3(0);\n\n            n=doBumpMap(cuv,n,.5,d,face,mask);\n            vec3 txt = vec3(.7);\n            vec3 dtr = texture(iChannel1,(cuv.xy*.5)-.5).rgb*vec3(.815,.812,.839);\n            vec3 otr = texture(iChannel0,cuv.xy*.5).rgb;\n            vec3 bse = rhash>.8?clr:dtr;\n            vec3 sqr = vec3(.001);\n            vec3 pth = rhash>.8?clr*dtr:vec3(0.902);\n            \n            float mx =abs(mask.x+.05)-.05;\n            mask.x=smoothstep(.011,.01,mask.x);\n            mx=smoothstep(.011,.01,mx);\n            \n            h=mix(otr,bse,mask.z>.5?1.:0.);\n            h=mix(h,pth,mask.x>.5?1.:0.);\n            h=mix(h,sqr,min(1.-mask.x,mask.y)>.5?.8:0.);\n     \n            ref =min(1.-mask.x,mask.z)>.5? h:vec3(.0001);\n        }\n        \n        float diff = clamp(dot(n,l),.25,.95);\n        float ao = calcAO(p,n);\n        float shdw = 1.;\n        //@Shane - softshadows\n        for( float t=.01;t<10.; ) {\n            float h = map(p + l*t).x;\n            if(h<MIN_DIST) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if(shdw<MIN_DIST||t>12.)break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n        \n        float spec = .65 * pow(max(dot(normalize(p-ro),reflect(l,n)),.2),24.);\n\n        RC = (h*diff) + min(spec,shdw)*ao;\n\n        ro = p+n*.05;\n        rd = reflect(rd,n);\n\n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nvec3 render( vec2 uv, in vec2 F ) {\n\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv, -1.));\n\n    // mouse //\n    float x = M.xy==vec2(0)||M.z<0. ? .07+.02*sin(T*.1) : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0)||M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    \n    mat2 rx =rot(-.68+x);\n    mat2 ry =rot(.58+y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0),RC=vec3(0),ref=vec3(0),fill=vec3(1),p = ro;\n    float d = 0., fA = 0.;\n    \n    // reflection loop + stop unroll\n    for(int i = 0; i < 2 + min(iFrame, 0); i++){\n        RC = render(ro,rd,ref,2-i,d);\n        C = mix(C,clamp(C+RC,vec3(0),vec3(1)),fill);\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    // fog dusting\n    C = mix(C,FC, 1.-exp(-.0000125*fA*fA*fA));\n    return C;\n}\n\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    travelspeed = T;\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = render(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.0);\n}\n//end",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}