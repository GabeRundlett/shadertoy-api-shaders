{
    "Shader": {
        "info": {
            "date": "1489120432",
            "description": "Simple radial grid",
            "flags": 0,
            "hasliked": 0,
            "id": "MtKGWh",
            "likes": 11,
            "name": "Radial Grid",
            "published": 3,
            "tags": [
                "radialgrid"
            ],
            "usePreview": 0,
            "username": "fscur",
            "viewed": 1776
        },
        "renderpass": [
            {
                "code": "float pi = 3.14159265;\nfloat oneDegreeInRadian = 0.01745329251;\n\nvec2 toPolar(vec2 c)\n{   \n \treturn vec2(length(c), atan(-c.y, -c.x) + pi);   \n}\n\nfloat lineSegDist( vec2 uv, vec2 ba, vec2 a, float r )\n{\n    vec2 pa = uv - a - ba*r; ba = -ba*r*2.0;\n    return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) );\n}\n\nfloat round_(float value)\n{\n\tif (fract(value) < 0.5)\n        return floor(value);\n    else \n        return ceil(value);\n}\n\nfloat addRadii2(vec2 uv)\n{\n\tvec2 polarUv = toPolar(uv);\n    float theta = polarUv.y; // [0, 2.0 * pi]\n    float d = 45.0;\n    float alpha = d * oneDegreeInRadian;\n    float edge = round(theta/alpha);\n    \n    //float angle = edge/(360.0/d);\n    float angle = edge/(360.0/d) * 2.0 * pi;\n    \n    vec2 end = vec2(cos(angle), sin(angle));\n    \n    float line = lineSegDist(uv, end, vec2(0.0), 2.0);\n    \n    float r = 1.0-smoothstep(0.005, 0.0055, line);\n    \n    return r;\n}\n\nfloat addRadii(vec2 uv)\n{\n    vec2 polarUv = toPolar(uv);\n    float theta = polarUv.y; // [0, 2.0 * pi]\n    float d = 90.0;\n    float alpha = d * oneDegreeInRadian;\n    float edge = floor(theta/alpha);\n    \n    return mod(edge, 2.0) == 0.0 ? 0.0 : 1.0;\n}\n\nfloat addCircles(vec2 uv)\n{\n    float diff = length(uv);\n\tfloat scale = 5.0;\n    float func = exp(-abs(sin(scale * pi * diff)));\n    return smoothstep(0.9, 0.95, func);\n}\n\nfloat addCircle(vec2 uv, float scale)\n{\n    return 0.0;\n}\n\nfloat addCurrentAngle(vec2 uv, float angle)\n{\n\tvec2 rotatedPolarPos0 = toPolar(uv);\n    float detectionEdgeDist0 = (mod(-rotatedPolarPos0.y, 2.0 * pi) - angle) / pi;\n    float currentAngle = smoothstep(0.0, 0.001, detectionEdgeDist0);\n    \n    float diff = length(uv);\n    float func = exp(-abs(sin(3.9269908169872415480783042290994 * diff)));\n    float circle = smoothstep(0.98, 0.99, func);\n    \n    float t = pi * iTime;\n    vec2 end = vec2(cos(-angle), sin(-angle));\n    float line = 1.0-smoothstep(0.010, 0.015, lineSegDist(uv - end, end, vec2(0.0), 1.0));\n    \n    return currentAngle * (1.0 + circle + line);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    float t = iTime;\n    float dist = length(uv);\n    vec3 color = vec3(0.0);\n    \n    float r = (1.0 - smoothstep(0.0, 1.0, dist));\n    \n    //float currentAngle = addCurrentAngle(uv, (2.0 * abs(cos(t)) * pi));\n    //color += vec3(1.0, 0.0, 0.0) * addCircle(uv, 1.0) * currentAngle * (1.0 - smoothstep(1.1, 1.11, dist));\n    \n    color += vec3(1.0, 0.0, 0.0) * addCircles(uv) * r;\n    color += vec3(0.4, 0.0, 0.0) * addCurrentAngle(uv, (2.0 * abs(cos(t)) * pi)) * (1.0 - smoothstep(0.0, 1.5, dist));\n    color += vec3(0.5, 0.0, 0.0) * addRadii(uv) * r;\n    \n    color += vec3(1.0, 0.0, 0.0) * addRadii2(uv) * (1.0 - smoothstep(0.8, 0.9, dist));\n    \n    //vec3 color = vec3(0.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}