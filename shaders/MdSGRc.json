{
    "Shader": {
        "info": {
            "date": "1391556832",
            "description": "Changing the distance metric in voronoi patterns to get different shapes",
            "flags": 0,
            "hasliked": 0,
            "id": "MdSGRc",
            "likes": 138,
            "name": "Voronoi - metrics",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "worley"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 8072
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\n\n\nvec4 voronoi( in vec2 x, float mode )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n\tfloat m2 = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n\n\t\t// animate\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n\n\t\tvec2 r = g - f + o;\n\n        // euclidean\t\t\n\t\tvec2 d0 = vec2( sqrt(dot(r,r)), 1.0 );\n        // manhattam\t\t\n\t\tvec2 d1 = vec2( 0.71*(abs(r.x) + abs(r.y)), 1.0 );\n        // triangular\t\t\n\t\tvec2 d2 = vec2( max(abs(r.x)*0.866025+r.y*0.5,-r.y), \n\t\t\t\t        step(0.0,0.5*abs(r.x)+0.866025*r.y)*(1.0+step(0.0,r.x)) );\n\n\t\tvec2 d = d0; \n\t\tif( mode<3.0 ) d=mix( d2, d0, fract(mode) );\n\t\tif( mode<2.0 ) d=mix( d1, d2, fract(mode) );\n\t\tif( mode<1.0 ) d=mix( d0, d1, fract(mode) );\n\t\t\n        if( d.x<m.x )\n        {\n\t\t\tm2 = m.x;\n            m.x = d.x;\n            m.y = hash1( dot(n+g,vec2(7.0,113.0) ) );\n\t\t\tm.z = d.y;\n        }\n\t\telse if( d.x<m2 )\n\t\t{\n\t\t\tm2 = d.x;\n\t\t}\n\n    }\n    return vec4( m, m2-m.x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mode = mod(iTime/5.0,3.0);\n\tmode = floor(mode) + smoothstep( 0.8, 1.0, fract(mode) );\n\t\n    vec2 p = fragCoord.xy/iResolution.xx;\n    vec4 c = voronoi( 8.0*p, mode );\n\n    vec3 col = 0.5 + 0.5*sin( c.y*2.5 + vec3(1.0,1.0,1.9) );\n    col *= sqrt( clamp( 1.0 - c.x, 0.0, 1.0 ) );\n\tcol *= clamp( 0.5 + (1.0-c.z/2.0)*0.5, 0.0, 1.0 );\n\tcol *= 0.4 + 0.6*sqrt(clamp( 4.0*c.w, 0.0, 1.0 ));\n\t\n\t\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}