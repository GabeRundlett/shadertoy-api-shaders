{
    "Shader": {
        "info": {
            "date": "1525300188",
            "description": "choose progs in bufB.\nExplanations and best links: [url]https://en.wikipedia.org/wiki/Core_War[/url]\nWIP.    TODO:\n- fork should slow down color program (or unfair!)\n- implement ICWS88 decrement adressing mode. \n- implement labels would be cool. But how?",
            "flags": 32,
            "hasliked": 0,
            "id": "XddBD4",
            "likes": 16,
            "name": "Core war",
            "published": 3,
            "tags": [
                "game",
                "simulation",
                "mars",
                "redcode"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1334
        },
        "renderpass": [
            {
                "code": "// === display ===\n\n// --- display values ( for debug ) . From https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c) { // --- access to the image of ascii code c\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n}\nvec4 pInt(vec2 p, float n) { // --- display int4\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) {  // --- display float4.4\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= 2.;\n    v += char(p, 46);      p.x -= .5;\n    v += pInt(p,fract(n)*1e4);\n    return v;\n}\n// --- arena ---------------\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, A = vec2(arena),\n          U = (u-.5) * A/R;\n    int x = int(U.x), y = int(U.y), p = x + arena.x * y;\n    \n    O = texelFetch(iChannel1, ivec2(U), 0);\n    float c = fract(O.x),                       // display code owner\n          w = float(iFrame/CLOCK)-O.w;\n    O =   c==F0 ? vec4(1,0,0,0)\n        : c==F1 ? vec4(0,1,0,0)\n        : c==F2 ? vec4(0,0,1,0)\n                : .5*vec4(O.x!=0.);             // data block\n    O /= 1.+.01*w;                              // fade if inactive\n \n  for(int j=0; j<pos.length(); j++) \n    for (int i=1; i<=int(T(0,j).a); i++)        // display PCs location\n        if (float(p)==T(i,j).a) { O += .6; break; } // don't pile up\n                \n    u = floor(mod(u,R/A));                      // grid\n    if (u.x*u.y==0.) O = vec4(0,0,.4,1);\n        \n    vec2 M = iMouse.xy * A/R;                   // --- debug: display picked val\n    vec4 C = TA(int(M.x)+arena.x*int(M.y));\n    U = ( (U-M)*A.y/A + vec2(0,2) ) / vec2(2,4);\n    if (iMouse.z>0.) \n     // O += pInt( U, int(C.x)==1 ? C.y:C.x ).x;\n        O +=  pFloat( U,               C.x).x\n            + pFloat( U+vec2(0,3./4.), C.y).x\n            + pFloat( U+vec2(0,6./4.), C.z).x; /**/\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// === manage program counters and execution ===\n\nvoid mainImage( out vec4 O, vec2 U )\n{   \n    int x = int(U.x), y = int(U.y);\n    if ( y >= pos.length() ) return;\n    \n    if (iFrame==0) {                          // === initialization\n        if ( y < pos.length() ) {             // for each color y :\n            if (x==0) O.a = 1.;               //  process queue\n            if (x==1) O.a = float(pos[y]);    //  ( number of processes, PCs )\n        }\n        return;\n    }\n                                              // === execution\n       \n    O = texelFetch(iChannel0, ivec2(U), 0);   // persist\n    if (iFrame % CLOCK != 0 )   return;       // clock\n\n    int p = int(T(0,y).a), n=0;               // --- check for forks\n    for (int i=1; i<=p; i++)        \n        if (T(i,y).x==-2.) n++;               // fork (maybe several requests)\n    if (n>0 && x<=p+n) {\n        for (int i=1,c=0; i<=p; i++)\n            if (T(i,y).x==-2.)                // process each request\n                { c++; if (x==p+c) O.a = T(i,y).y; } // new PC\n        p = min( p+n, 100 );                  // update queue length + safety limit\n        if (x==0) O.a = float( p );\n    }\n                             \n    if (x==0 || x > p )    return;            // --- check for valid PC\n    p = int(O.a); if (p<0) return;            // address in PC\n                                              // --- decode addressings\n#define getA(w) ( f=F(w), v=I(w), f==0 ? v : f==1 ? A(p+v) : A(p+v+A(p+v) ) )   \n#define getB(w) ( f=F(w), v=I(w), f==0 ? v : f==1 ?   p+v  :   p+v+A(p+v)   ) \n                                  // not implemented: f==3 <><><>\n    vec4 C = TA(p);\n    int f,v,M = arena.x*arena.y,\n    //    command        param A           param B \n        c = int(C.x), a = getA(C.y), b = (M+getB(C.z)) %M,  aa = (M+getB(C.y)) %M ;\n        \n    p = (p+1)%M;\n    O = vec4(-1);\n    switch(c) {                               // --- execute instruction\n        case  2:{O = vec4( b, f>0?aa:a, f>0, p );} break;  // MOV\n             //  O = vec4( b,      a, 0, p );  break;  // MOV \n        case  3: O = vec4( b, A(b)+a, 0, p );  break;  // ADD\n        case  4: O = vec4( b, A(b)-a, 0, p );  break;  // SUB\n        case  5: O.a = float(        b     );  break;  // JMP\n        case  6:{O.a = float( a==0 ? b : p );} break;  // JMZ\n        case  7:{O.a = float( a!=0 ? b : p );} break;  // JMN\n        case  8:{v= A(aa)-1; O = vec4(aa, v, 0, v==0 ? b : p);} break; // DJZ\n        case  9:{v= A(aa)-1; O = vec4(aa, v, 0, v!=0 ? b : p);} break; // DJN\n        case 10:{O.a = float( a==b ? p:(p+1)%M);}break;// CMP\n        case 11:{O.a = float( a< b ? p:(p+1)%M);}break;// SLT\n        case 12: O = vec4( -2, b, 0, p);       break;  // SPL\n        default: break;                        // error: kill program\n    }\n    // O.x: address to update, O.y: value,  O.z: mode,  O.w: next PC\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "ivec2 arena= ivec2(128,64);// why 114 not ok ?\n#define CLOCK 10  // ticks spacing\n\n// Red Code reference: \n//   ICWS84: http://corewar.co.uk/standards/cwg.txt 1,2,3,4,5,6,8,10\n//   ICWS86/88: http://members.gaponline.de/w.zimmer/Mars/anleitung.html +7,9,11,12\n//   ICWS-94: +5 cmd , + modifiers  http://corewar.co.uk/standards/icws94.htm\n// more: https://en.wikipedia.org/wiki/Core_War\n\n// instructions\n#define DAT(A)    vec3( 1,A,0)  // Initialize location to value A\n#define MOV(A,B)  vec3( 2,A,B)  // Move A into location B\n#define ADD(A,B)  vec3( 3,A,B)  // Add operand A to contents of location B  and store result in B\n#define SUB(A,B)  vec3( 4,A,B)  // Subtract operand A from contents of location B and store result in B\n#define JMP(B)    vec3( 5,0,B)  // Jump to location B\n#define JMZ(A,B)  vec3( 6,A,B)  // Jump to location B If operand A is 0\n#define JMN(A,B)  vec3( 7,A,B)  // Jump to location B If operand A is not 0\n#define DJZ(A,B)  vec3( 8,A,B)  // Decrement contents of location A. If 0 jump to location B\n#define DJN(A,B)  vec3( 9,A,B)  // Decrement contents of location A. If not 0 jump to location B\n#define CMP(A,B)  vec3(10,A,B)  // If operand A != operand B skip next instruction\n#define SLT(A,B)  vec3(11,A,B)  // If operand A  < operand B skip next instruction\n#define SPL(B)    vec3(12,0,B)  // fork to location B\n \n// adressing modes:             // #A, A, @A\n//        A                     // Immediate   A\n#define r(A) float(A)+F0        // Relative    (PC+A)\n#define R(A) float(A)+F1        // Indirect    (PC+ofs+(PC+A))\n#define D(A) float(A)+F2        // DecIndirect (PC+ofs+(PC+A)--) <><> UNIMPLEMENTED\n\nint[] pos = int[]( 10, 1700, 3800 );  // initial programs location\n\n#define F(x) int(fract(x)*4.)%4 // decode / code flags\n#define F0 .25\n#define F1 .50\n#define F2 .75\n#define I(x) int(floor(x))\n\n#define T(x,y)  texelFetch(iChannel0, ivec2(x,y), 0)\n#define TA(a)   texelFetch(iChannel1, ivec2( (arena.x*arena.y+(a))%arena.x, (arena.y+(a)/arena.x)%arena.y ), 0)\n#define A(a)    I(TA(a).y)\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// === define progs & manage arena === \n\n// initial programs\nconst vec3 p0[] = vec3[]( // --- propagate (KNIRPS) http://members.gaponline.de/w.zimmer/Mars/ICWS88/knirps.txt\n                         MOV(r(0),r(1)) ),\n           p1[] = vec3[]( // --- propagate & fork\n                         SPL(r(0)), MOV(r(0),r(1)) ),\n           p2[] = vec3[]( // --- protect after (CERBERUS) http://members.gaponline.de/w.zimmer/Mars/ICWS88/cerberus.txt\n                         SUB(1,r(7)), MOV(0,R(6)),  \n                         SUB(1,r(5)), MOV(0,R(4)),\n                         JMN(r(3),r(-4)),\n                         SPL(r(0)), DAT(0), DAT(50) ),\n           p3[] = vec3[]( // --- fork everywhere (MICES) http://members.gaponline.de/w.zimmer/Mars/ICWS88/mice.txt\n                         MOV(12,r(-1)), SUB(1,r(7)), MOV(R(-3),R(6)),\n                         DJN(r(-4),r(-2)),SPL(R(4)),\n                         ADD(654,r(3)), JMZ(r(-7),r(-6)), DAT(0), DAT(834) ),\n           p4[] = vec3[]( // --- back propagates\n                         MOV(8,r(8)),MOV(-2,r(8)),MOV(-16,r(8)), MOV(R(6),R(7)), SUB(1,r(5)),SUB(1,r(5)), DJN(r(2),r(-3)), JMP(r(-20)), DAT(0), DAT(0), DAT(0) ),\n           p5[] = vec3[]( // --- propagate from 2 ends\n                         SPL(r(12)), \n                         MOV(8,r(8)),MOV(-2,r(8)),MOV(-16,r(8)), MOV(R(6),R(7)), SUB(1,r(5)),SUB(1,r(5)), DJN(r(2),r(-3)), JMP(r(-20)), DAT(0), DAT(0), DAT(0),\n                         MOV(r(0),r(1)) ),\n           p6[] = vec3[]( // --- fire in arena (GNOM) http://members.gaponline.de/w.zimmer/Mars/ICWS88/gnom.txt\n                         SPL(r(0)), ADD(727,r(3)), MOV(r(2),R(2)), JMP(-r(2)), DAT(0)),\n           p7[] = vec3[]( // --- fork & fire in arena \n                         SPL(r(0)), ADD(727,r(3)), MOV(r(2),R(2)), JMP(-r(2)), DAT(0)), \n           p8[] = vec3[]( // --- fork^2 & fire in arena \n                         SPL(r(0)), ADD(727,r(3)), MOV(r(2),R(2)), JMP(-r(2)), DAT(0)),\n           p9[] = vec3[]( // --- test\n                         ADD(11,r(2)), JMP(r(-1)), DAT(0) );\nvec3 prog0[] = p3,\n     prog1[] = p7,\n     prog2[] = p0;\n\n// -----------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{   \n    int x = int(U.x), y = int(U.y), p = x + arena.x * y, q;\n    if (x >= arena.x || y >= arena.y ) return;\n    \n    if (iFrame==0) {                          // --- initialization\n        q = p -pos[0];                        // red initial programm:\n        if (q >= 0 && q < prog0.length())     //   content (code + red mark)\n            O.xyz = prog0[q], O.x += F0;\n        q = p - pos[1];                       // green initial programm:\n        if (q >= 0 && q < prog1.length())     //   content (code + green mark)\n            O.xyz = prog1[q], O.x += F1;\n        q = p - pos[2];                       // blue initial programm:\n        if (q >= 0 && q < prog2.length())     //   content (code + blue mark)\n            O.xyz = prog2[q], O.x += F2;\n        return;\n    }\n                                              // --- updates\n    O = texelFetch(iChannel1, ivec2(U), 0);\n\n  for(int j=0; j<pos.length(); j++) \n    for (int i=1; i<=int(T(0,j).a); i++) {    // check addresses to be updated (MOV,ADD,SUB,DEC)\n        vec4 C = T(i,j);\n        if (float(p)==C.x) { \n            if (C.z==0.) O.x=1.,O.y = C.y; else O = TA(I(C.y)); // mv v or A(v)\n            O.w = float(iFrame/CLOCK);              // time stamp\n        }//break;}\n        if (float(p)==C.a) O.x = floor(O.x)+float(j+1)/4., // (recolor code at PC)\n                           O.w = float(iFrame/CLOCK); // time stamp\n    }\n}    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}