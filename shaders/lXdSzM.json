{
    "Shader": {
        "info": {
            "date": "1718825247",
            "description": "combination\n/*sources https://www.shadertoy.com/view/M3dSzM https://www.shadertoy.com/view/XlfGRj https://www.shadertoy.com/view/M3dXRN https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/4tyfWy*/",
            "flags": 0,
            "hasliked": 0,
            "id": "lXdSzM",
            "likes": 2,
            "name": "galaxy with ufo ",
            "published": 3,
            "tags": [
                "fractal",
                "galaxy",
                "universe",
                "ufo",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 287
        },
        "renderpass": [
            {
                "code": "/*sources https://www.shadertoy.com/view/M3dSzM https://www.shadertoy.com/view/XlfGRj https://www.shadertoy.com/view/M3dXRN https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/4tyfWy*/\n#define PI acos(-1.)\n#define ID_NONE -1.\n#define BLUE 1.\n#define ORANGE 5.1\nfloat random(vec2 st){\n    return fract(sin(dot(st, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    vec2 u = f;\n    \n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\nfloat opExtrusion( in vec3 p, in float sdf, in float h ){\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\nconst float MAX_DIST = 64.0;\nconst float EPSILON = 0.0001;\n\nvec2 curve(float t) {\n    t = t / 5.0;\n    return 1.5 * vec2(cos(2.0 * t) * sin(t + cos(t)), sin(t) * cos(t + sin(t) / 2.0));\n}\n\nfloat width(float z) {\n    return 2.0 + sin(z) / 3.0;\n}\n\nfloat box2d(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size;\n    return length(max(d, 0.0)) - min(max(d.x, d.y), 0.0);\n}\n\nfloat repeatedBox(vec2 p, vec2 size) {\n    p -= 2.0 * floor((p + 1.0) / 2.0);\n    return box2d(p, size);\n}\n\nfloat infCylinder(vec3 p, vec3 c) {\n    return length(p.xy - c.xy) - c.z;\n}\n\nfloat infBox(vec3 p, vec3 c) {\n    return box2d(p.xy - c.xy, vec2(c.z));\n}\n\nfloat sdf(vec3 p) {\n    float capsule = abs(infCylinder(p, vec3(curve(p.z), width(p.z))));\n    const vec2 BOX_SIZE = vec2(1.0, 1.0);\n    float box = repeatedBox(p.yz, vec2(1.0, 1.0));\n    \n    float total = capsule;\n    total -= 0.1 * smoothstep(0.0, 0.15, box);\n    \n    return 0.25 * total;\n}\n\n\nvec3 raymarch(vec3 ro, vec3 rd, inout float outDist) {\n    float d = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < 256; i++) {\n        float dist = sdf(p);\n        if (dist < EPSILON)\n            break;\n        d += dist;\n        p += rd * dist;\n    }\n    outDist = d;\n    return p;\n}\n\n// from https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*h ) + \n                      k.yyx*sdf( p + k.yyx*h ) + \n                      k.yxy*sdf( p + k.yxy*h ) + \n                      k.xxx*sdf( p + k.xxx*h ) );\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(rr, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 ptCol(vec3 pt, vec3 normal) {\n    const vec3 LIGHT_DIR = normalize(vec3(1.0, 0.0, -1.0));\n    float col = 0.3 * dot(normal, LIGHT_DIR) + 0.7;\n    return col * (normal * 0.5 + 0.5);\n}\n\nvec3 render(vec2 uv) {\n    vec3 ro = vec3(curve(iTime), iTime);\n    vec3 rd = vec3(uv, 1.0);\n    rd = calcLookAtMatrix(ro, vec3(curve(iTime + 2.0), iTime + 2.0), 0.0) * rd;\n    \n    float dist;\n    vec3 p = raymarch(ro, rd, dist);\n    \n    vec3 normal = calcNormal(p);\n    vec3 reflected = normalize(rd - 2.0 * normal * dot(normal, rd));\n    \n    //float dist2;\n    //vec3 p2 = raymarch(p + reflected * EPSILON * 2.0, reflected, dist2);\n    //vec3 normal2 = calcNormal(p2);\n    \n    // DEBUG\n    \n    //col += smoothstep(1.0, 0.0, 2.5 * abs(p.y - curve(p.z).y));\n    //col += smoothstep(1.0, 0.0, 2.5 * abs(p.x - curve(p.z).x));\n    return ptCol(p, normal);// * 0.65 + ptCol(p2, normal2) * 0.35;\n}\nfloat sdSphere(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat c1(vec2 p){\n    float d = 10.;\n    float r = .75*(1.+.1*sin(iTime*1.6));\n    \n    p = rot(iTime/5.)*p;\n    d = min(d, max(sdSphere(p, (r+.05)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/5.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*10., 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c2(vec2 p){\n    float d = 10.;\n    float r = .69*(.95+.15*sin(iTime*1.6));\n    \n    p = rot(-iTime/3.)*p;\n    d = min(d, max(sdSphere(p, (r+.01)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/5.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - 10.*vec2(r, 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c3(vec2 p){\n    float d = 10.;\n    float r = .9*(1.+.05*sin(iTime*1.6));\n    \n    p = rot(-iTime/5.)*p;\n    d = min(d, max(sdSphere(p, (r+.005)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/3.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - 10.*vec2(r, 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c4(vec2 p){\n    float d = 10.;\n    float r = .4*(1.+.1*sin(iTime*1.6));\n    \n    p = rot(iTime/5.)*p;\n    d = min(d, max(sdSphere(p, (r+.05)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/3.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*10., 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c5(vec2 p){\n    float d = 10.;\n    float r = .95*(1.+.05*sin(iTime*1.6));\n    float n = 10.;\n    \n    float no = noise(p*7.)/5.;\n    p = rot(iTime+no)*p;\n    d = min(d, max(sdSphere(p, (r+.001)*n+no), -sdSphere(p, r*n+no)));   \n    float angle = 2.*PI/11.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*n, 0.), n*vec2(.2, .35+.3*sin(iTime*1.5))));\n    \n    return d;\n}\nfloat c6(vec2 p){\n    float d = 10.;\n    float r = .5*(1.+.1*sin(iTime*1.6));\n    float n = 10.;\n    \n    float no = noise(p*7.)/5.;\n    p = rot(-iTime+no)*p;\n    d = min(d, max(sdSphere(p, (r+.001)*n+no), -sdSphere(p, r*n+no)));   \n    float angle = 2.*PI/5.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*n, 0.), n*vec2(.2, .35+.3*sin(iTime*1.5))));\n    \n    return d;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvec2 intersect(vec3 pos){\n    vec2 p = pos.xy;\n    pos.z+=0.2*cos(iTime);\n    float d = 10.;\n    float id = ID_NONE;\n        \n    d = min(d, c1(p));\n    \n    d = min(d, c2(p));\n    \n    d = min(d, c3(p));\n    \n    d = min(d, c4(p));\n    if(d != 10.)id = BLUE;\n    \n    if(c5(p) < d){\n        d = c5(p);\n        id = ORANGE;\n    }\n   \n    \n    \n    return vec2(id, opExtrusion(pos, d, .103));\n}\n\n#define iterations 14\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n   vec3 col = vec3(.1, .2, .8)*mix(1., .8, smoothstep(0., 1., length(p)));\n   vec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec3 col2 = render(uv);\n    vec2 cPos = uv * 3.0 ;\n\n    // Комплексное число c, определяющее множество Жюлиа\n    vec2 c = vec2(-0.7, 0.27);\nfloat t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t2);\n\tfloat co = cos(t2);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s2 = 0.0;\n\tfor (int i = 0; i < 70; i++)\n\t{\n\t\tvec3 p = s2 * vec3(uv, 0.0);\n\t\n\t\tp += vec3(.22, .3, s2 - 1.5 - sin(iTime * .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts2  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col3 = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n    // Начальное значение z = cPos (точка на комплексной плоскости)\n    vec2 z = cPos*ma*col3.xy;\n\n    int maxIterations = 256;\n    int iteration;\n\n\n    for (iteration = 0; iteration < maxIterations; iteration++)\n    {\n        if (dot(z, z) > 4.0) break; // Условие выхода при |z|^2 > 4\n\n        // z = z^2 + c\n        z = vec2(\n            z.x * z.x - z.y * z.y + c.x,\n            2.0 * z.x * z.y + c.y\n        );\n    }\n\n    vec3 color;\n    if (iteration == maxIterations)\n    {\n        color = vec3(0.0, 0.0, 0.0)*col3.xyz; // Пиксель принадлежит множеству Жюлиа (черный)\n    }\n    else\n    {\n        float t = float(iteration) / float(maxIterations);\n        color = vec3(sin(6.2831 * t + 0.0), sin(6.2831 * t + 0.0), sin(6.2831 * t + 2.0))+col3.xyz * 0.5 + 0.1;\n    }\n\n\tvec3 dir=vec3(uv*zoom,1.);\n    vec3 from=vec3(1.,.5,0.5)*color;\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=rot(iTime*0.01);// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.005); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.3-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation)*col3.xyz; //color adjust\n\t\t\n   vec3 ro = vec3(0., 4., 15.);\nro.x+=10.*cos(iTime);\nro.y+=10.*sin(iTime);\n   vec3 rd = vec3(p, -0.5+0.3);\n   rd.zy = rot(radians(-10.))*rd.zy;\n   rd = normalize(rd);\n   rd.z+=0.3*cos(iTime);\n   #define TMIN .051\n   #define TMAX 200.\n   #define EPS .051\n   #define ITR 256.\n   \n   vec3 ray;\n   float t = TMIN;\n   for(float i = 0.;i < ITR;i++){\n       ray = ro + rd*t;\n    \nray.xy*=rot(iTime);\n\n       vec3 rayR = ray;\nrayR.xz*=rot(iTime);\n       vec2 obj = intersect(rayR);\n       if(obj.y <2000.*EPS){\n           if(obj.x == BLUE)col += .05*vec3(.005, .01, .03)*i;\n           if(obj.x == ORANGE)col += .03*vec3(.05, .03, .1005)*i;\n       }\n       \n       if(obj.y > TMAX)break;\n       t += 0.17*obj.y;\n   }\n\n    //col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n    fragColor*= vec4(v*.03,1.);\n  uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor += vec4(happy_star(uv, anim) * vec3(0.35,0.2,0.55)*.1, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}