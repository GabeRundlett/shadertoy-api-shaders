{
    "Shader": {
        "info": {
            "date": "1606763437",
            "description": "A simple 3D rasterizer. It took me forever to get the faces right!",
            "flags": 0,
            "hasliked": 0,
            "id": "3sGfzw",
            "likes": 6,
            "name": "3D Triangle Rasterizer",
            "published": 3,
            "tags": [
                "3d",
                "rasterizer",
                "triangle"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 246
        },
        "renderpass": [
            {
                "code": "const float Z_NEAR = 0.1;\nconst float Z_FAR = 100.0;\nconst float FOCAL_LENGTH = 1.0;\n\nvec3[] vertices = vec3[8](vec3( -1.0,  1.0,  1.0 ),\n                          vec3( -1.0, -1.0,  1.0 ),\n                          vec3(  1.0, -1.0,  1.0 ),\n                          vec3(  1.0,  1.0,  1.0 ),\n                          vec3(  1.0,  1.0, -1.0 ),\n                          vec3(  1.0, -1.0, -1.0 ),\n                          vec3( -1.0, -1.0, -1.0 ),\n                          vec3( -1.0,  1.0, -1.0 ));\n\nivec3[] triangles = ivec3[12](ivec3( 0, 1, 2 ),\n                              ivec3( 2, 3, 0 ),\n                              ivec3( 4, 5, 6 ),\n                              ivec3( 6, 7, 4 ),\n                              ivec3( 3, 2, 5 ),\n                              ivec3( 5, 4, 3 ),\n                              ivec3( 7, 6, 1 ),\n                              ivec3( 1, 0, 7 ),\n                              ivec3( 7, 0, 3 ),\n                              ivec3( 3, 4, 7 ),\n                              ivec3( 5, 2, 1 ),\n                              ivec3( 1, 6, 5 ));\n\nvec3[] faceNormals = vec3[12](vec3(  0.0,  0.0,  1.0 ),\n                              vec3(  0.0,  0.0,  1.0 ),\n                              vec3(  0.0,  0.0, -1.0 ),\n                              vec3(  0.0,  0.0, -1.0 ),\n                              vec3(  1.0,  0.0,  0.0 ),\n                              vec3(  1.0,  0.0,  0.0 ),\n                              vec3( -1.0,  0.0,  0.0 ),\n                              vec3( -1.0,  0.0,  0.0 ),\n                              vec3(  0.0,  1.0,  0.0 ),\n                              vec3(  0.0,  1.0,  0.0 ),\n                              vec3(  0.0, -1.0,  0.0 ),\n                              vec3(  0.0, -1.0,  0.0 ));\n\nvec3[] faceColors = vec3[12](vec3( 1.0, 0.0, 0.0 ),\n                             vec3( 1.0, 0.0, 0.0 ),\n                             vec3( 0.0, 1.0, 0.0 ),\n                             vec3( 0.0, 1.0, 0.0 ),\n                             vec3( 1.0, 1.0, 0.0 ),\n                             vec3( 1.0, 1.0, 0.0 ),\n                             vec3( 0.0, 0.0, 1.0 ),\n                             vec3( 0.0, 0.0, 1.0 ),\n                             vec3( 1.0, 0.0, 1.0 ),\n                             vec3( 1.0, 0.0, 1.0 ),\n                             vec3( 0.0, 1.0, 1.0 ),\n                             vec3( 0.0, 1.0, 1.0 ));\n\nvec3 transformVertex(in vec3 v) {\n    float c = cos(iTime), s = sin(iTime);\n    v.xz *= mat2(c, -s, s, c);\n    v.yz *= mat2(c, -s, s, c);\n    v += vec3(0.0, 0.0, -5.0);\n    return v;\n}\n\nvec3 transformNormal(in vec3 n) {\n    float c = cos(iTime), s = sin(iTime);\n    n.xz *= mat2(c, -s, s, c);\n    n.yz *= mat2(c, -s, s, c);\n    return n;\n}\n\nvec3 calcBaryCoords(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n    float abc = abs(ba.x * cb.y - ba.y * cb.x);\n\n    return vec3(bcp / abc, cap / abc, abp / abc);\n}\n\nvec3 pixelShader(in vec3 p, in vec3 n, in vec3 c) {\n    return c * max(0.0, dot(n, vec3(-0.58, 0.58, 0.58)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3[vertices.length()] transformedVertices;\n    for (int i=0; i < vertices.length(); i++) {\n        vec3 transformedVertex = transformVertex(vertices[i]) * vec3(1.0, 1.0, -1.0);\n        float perspective = FOCAL_LENGTH / transformedVertex.z;\n        transformedVertex.xy *= perspective;\n        transformedVertices[i] = transformedVertex;\n    }\n\n    vec3[faceNormals.length()] transformedNormals;\n    for (int i=0; i < faceNormals.length(); i++) {\n        transformedNormals[i] = transformNormal(faceNormals[i]);\n    }\n\n    bool pixelIsOverlappingTriangle = false;\n    vec3 fragmentPos, normal, color;\n    float fragDepth = Z_FAR;\n\n    for (int i=0; i < triangles.length(); i++) {\n        if (transformedNormals[i].z > 0.0) {\n            vec3 triA = transformedVertices[triangles[i][0]];\n            vec3 triB = transformedVertices[triangles[i][1]];\n            vec3 triC = transformedVertices[triangles[i][2]];\n\n            vec3 baryCoords = calcBaryCoords(uv, triA.xy, triB.xy, triC.xy);\n            float newFragDepth = baryCoords.x * triA.z + baryCoords.y * triB.z + baryCoords.z * triC.z;\n            if (abs(baryCoords.x + baryCoords.y + baryCoords.z - 1.0) < 0.001 && newFragDepth > Z_NEAR && newFragDepth < fragDepth) {\n                pixelIsOverlappingTriangle = true;\n                fragDepth = newFragDepth;\n                fragmentPos = baryCoords.x * vertices[triangles[i][0]] + baryCoords.y * vertices[triangles[i][1]] + baryCoords.z * vertices[triangles[i][2]];\n                normal = transformedNormals[i];\n                color = faceColors[i];\n            }\n        }\n    }\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (pixelIsOverlappingTriangle) {\n        fragColor.rgb = pixelShader(fragmentPos, normal, color);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}