{
    "Shader": {
        "info": {
            "date": "1565088361",
            "description": "More signed distance field practice",
            "flags": 1,
            "hasliked": 0,
            "id": "ttBXRh",
            "likes": 8,
            "name": "Shapes and materials sdf",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "tmulgrew",
            "viewed": 1105
        },
        "renderpass": [
            {
                "code": "// A little SDF ray-marching \"framework\".\n// Much of the techniques are copied from IQ's demos and articles.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst float tmin = 0.01;\t\t\t\t\t\t\t\t// Ray minimum distance\nconst float tmax = 500.0;\t\t\t\t\t\t\t\t\nconst int raySteps = 256;\t\t\t\t\t\t\t\t// Max iterations when resolving a ray\nconst int shadowSteps = 50;\t\t\t\t\t\t\t\t// Max iterations when resolving a shadow ray\nconst float limit = 0.0005;\t\t\t\t\t\t\t\t// Convergence to surface limit when ray tracing\nconst float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-0.5, -1.0, 0.6));\t// Light direction\nconst float ambient = 0.2;\t\t\t\t\t\t\t\t// Ambient light\nconst vec3 fog = vec3(0.5,0.7,0.9);\t\t\t\t\t\t// Fog colour\nconst int bounces = 3;\t\t\t\t\t\t\t\t\t// Max reflection bounces (actually bounces + 1, as includes initial ray)\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Data structures\n\nstruct lightingParams {\n \tfloat diffuse;\n    float specular;\n    float shiny;\n};\n\nstruct material {\n    vec3 col;\t\t\t\t\t\t\t\t\t\t\t// Surface colour\n    lightingParams lighting;\n    float reflective;\t\t\t\t\t\t\t\t\t// Reflectiveness. 0 = not reflective. 1 = completely reflective (e.g. mirror).\n};\n    \nstruct rayInfo {\n    vec3 origin;\n    vec3 dir;\n};\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Functions (implemented at the bottom)\n    \n// Get camera ray for specified pixel\nrayInfo getRay(in vec2 fragCoord);\n\n// Get VR ray\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir);\n\n// Get sample point.\n// Format is vec4:\n//\tx,y\t\t= Material parameter (e.g. uv)\n//\tz\t\t= Distance to nearest surface\n//\tw\t\t= Material index (will be passed to getMaterial())\nvec4 map(in vec3 p);\n\n// Get material properties by index\nmaterial getMaterial(float index, vec2 uv);\n\n// Get colour for ray that misses\nvec3 getRayMissCol(in rayInfo ray);\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Trig\n\nconst float PI = 3.14159265;\n\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotatez(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 euler) {\n \treturn rotatey(rotatex(rotatez(p, euler.z), euler.x), euler.y);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Helper functions\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\n// Pinched from: https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Combining shapes\n//\n// Sample format is vec3:\n//\tx,y\t\t= Material parameter (e.g. texture coordinates)\n//\tz\t\t= Distance\n\n// Union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2) { \n    return p1.z < p2.z ? p1 : p2;\n}\n\n// Smoothed union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z < p2.z ? p1.xy : p2.xy, sminCubic(p1.z, p2.z, k));\n}\n\n// Subtract shape p2 from p1\nvec3 carve(in vec3 p1, in vec3 p2) { \n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\n// Intersection of two shapes\nvec3 intersect(in vec3 p1, in vec3 p2) { \n    return p1.z > p2.z ? p1 : p2;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shape primitives\n\nvec3 sphere(in vec3 p, in vec3 center, float rad) { \n    p -= center;\n    return vec3(atan(p.x, p.y) * rad, atan(length(p.xy), p.z) * rad, length(p) - rad); \n}\nvec3 box(in vec3 p, in vec3 center, in vec3 size) {\n    p -= center;\n    vec3 x = vec3(p.yz, abs(p.x) - size.x);\n    vec3 y = vec3(p.xz, abs(p.y) - size.y);\n    vec3 z = vec3(p.xy, abs(p.z) - size.z);\n    return intersect(x, intersect(y, z));\n}\nvec3 cube(in vec3 p, in vec3 center, float size) \t{ return box(p, center, vec3(size)); }\nvec3 planeLeft(in vec3 p, float x)\t\t\t\t\t{ return vec3(p.yz, x-p.x); }\nvec3 planeRight(in vec3 p, float x)\t\t\t\t\t{ return vec3(p.yz, p.x-x); }\nvec3 planeBottom(in vec3 p, float y)\t\t\t\t{ return vec3(p.xz, y-p.y); }\nvec3 planeTop(in vec3 p, float y) \t\t\t\t\t{ return vec3(p.xz, p.y-y); }\nvec3 planeFront(in vec3 p, float z)\t\t\t\t\t{ return vec3(p.xy, z-p.z); }\nvec3 planeBack(in vec3 p, float z)\t\t\t\t\t{ return vec3(p.xy, p.z-z); }\nvec3 cylinder(in vec3 p, in vec3 center, float radius, float height) { \n    p -= center;\n    vec3 tube = vec3(atan(p.x, p.z) * radius, p.y, length(p.xz) - radius);\n    vec3 top = planeTop(p, height);\n    vec3 bottom = planeBottom(p, -height);\n    return intersect(tube, intersect(top, bottom));\n}\nvec3 torus(in vec3 p, in vec3 center, float radius, float thickness) { \n    p -= center;\n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\nvec3 plane(in vec3 p, in vec3 center, in vec3 n) { \n    return vec3(0, 0, dot(p - center, n)); \n}\nvec3 pyramid(in vec3 p, in vec3 center, float width, float height) {\n    vec3 top = center + vec3(0, height, 0);\n    vec3 r = planeBottom(p, center.y);\n    r = intersect(r, plane(p, top, normalize(vec3( height,width, 0))));\n    r = intersect(r, plane(p, top, normalize(vec3(-height,width, 0))));\n    r = intersect(r, plane(p, top, normalize(vec3( 0,width, height))));\n    r = intersect(r, plane(p, top, normalize(vec3( 0,width,-height))));\n    return r;\n}\n\n// Creating and combining full sample including material index\nvec4 makes(in vec3 d, float material) {\n    // Like a distance sample, but with w = material index.\n    // Specifically:\n    //\tx,y\t= material parameter (e.g. texture coord)\n    //\tz\t= distance\n    //\tw\t= material index\n \treturn vec4(d, material);   \n}\n\nvec4 merges(in vec4 result, in vec3 d, float material) {\n \treturn d.z < result.z ? makes(d, material) : result;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Rendering\n\n// Calculate ray direction for a given pixel\nvec3 screenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), 1);\n}\n\n// Simple lighting\nfloat shading(in vec3 e, in vec3 n, in lightingParams p) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * p.diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), p.shiny) * p.specular;\n\n    return max(d + s, 0.0);\n}\n\n// Calculate normal at a point\nvec3 normal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).z;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).z - d,\n        map(p + vec3(0,s,0)).z - d,\n        map(p + vec3(0,0,s)).z - d);\n    \n    return normalize(r);\n}\n\n// Cast regular ray\nvec4 raycast(in vec3 from, in vec3 dir) {\n    \n    float t = tmin;\n    vec4 d;\n    for (int i = 0; i < raySteps && t < tmax; i++) {\n        vec3 p = from + dir * t;\n        d = map(p);\n        if (abs(d.z) <= limit * t) {\n            d.z = t;\n            return d;\n        }\n        t += d.z;\n    }    \n    \n    // Avoid flicker when polygons are edgewise to the camera.\n    // In this case the ray cannot quite find the surface and runs out of steps.\n    // Just return the last sample point.\n    if (t < tmax) {\n        d.z = t;\n        return d;\n    }\n    \n    return vec4(0,0,-1.0,0);    \n}\n\n// Cast shadow ray\nfloat shadow(in vec3 from, in vec3 dir, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < shadowSteps && t < tmax; i++) {\n     \tvec3 p = from + dir * t;\n        float d = map(p).z;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\nvec3 drawPixel(in rayInfo ray) {\n    ray.dir = normalize(ray.dir);\n\n    // Sum up reflection bounces    \n    vec3 sumCol = vec3(0);\n    float alpha = 1.0;\n    for (int bounce = 0; bounce < bounces && alpha > 0.0002; bounce++) {\n    \n\t    // Ray cast\n\t    vec4 r = raycast(ray.origin, ray.dir);\n    \n        // Distance is returned in r.z\n\t    // Miss?\n\t    if (r.z == -1.0)\n\t    {\n            vec3 missCol = getRayMissCol(ray);\n            sumCol += missCol * alpha;\n\t        break;\n\t    }\n        \n\t    // Position and normal\n\t    vec3 p = ray.origin + r.z * ray.dir;\n\t    vec3 n = normal(p, r.z);\n\n        // Get material info\n        material mat = getMaterial(r.w, r.xy);        \n        \n        // Cancel reflection if on last bounce\n        if (bounce == bounces - 1)\n            mat.reflective = 0.0001;\n    \n        // Apply lighting\n        float i = shading(ray.dir, n, mat.lighting);\n        if (i > 0.0) \n            i *= shadow(p, -light, 16.0);    \n        i = clamp(i + ambient, 0.0, 1.0);\n        mat.col *= i;\n\n        // Apply fog\n        float f = clamp(r.z * r.z / 50000.0, 0.0, 1.0);\n        sumCol += fog * f * alpha;\n        alpha *= (1.0 - f);\n\t    \n        // Add to sum of colours\n        mat.col *= (1.0 - mat.reflective);\n        sumCol += mat.col * alpha;\n        alpha *= mat.reflective;\n        \n        // Calculate reflection vector\n        ray.origin = p;\n        ray.dir = normalize(reflect(ray.dir, n));\n    }    \n    \n    return sumCol;\n}\n\n// Main entrypoints\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rayInfo ray = getRay(fragCoord);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) \n{\n \trayInfo ray = getVRRay(fragCoord, fragRayOri, fragRayDir);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\nrayInfo getRay(in vec2 fragCoord) {\n    rayInfo ray;\n    \n    vec3 ang = vec3(0.65, iTime * 0.05, 0);\n    ray.origin = vec3(0,-2,0) + rotate(vec3(0, 0, -30), ang);\n    ray.dir = rotate(screenRay(fragCoord), ang);\n    return ray;\n}\n\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n \trayInfo ray;\n    ray.origin = fragRayOri * 50.0 + vec3(0,40,10);\n    ray.dir = fragRayDir;\n    return ray;\n}\n\nvec3 getRayMissCol(in rayInfo ray) {\n    vec3 skycol = fog;\n    if (ray.dir.y > 0.1) {\n        vec2 t = ray.dir.xz / ray.dir.y;\n        float cloud = texture(iChannel3, t * 0.1 + iTime * vec2(0.01, 0.007)).x \n            + texture(iChannel3, t * 0.3 + iTime * vec2(0.005, -0.003)).x * 0.3\n            + texture(iChannel3, t * 1.0 + iTime * vec2(-0.004, -0.006)).x * 0.1;\n        cloud = clamp(cloud - 0.6, 0.0, 1.0);\n        skycol += vec3(cloud);            \n    }\n    \n    return skycol;\n}\n\n// Material types.\n// Returned by map(). Then passed into getMaterial() to get colour, lighting etc.\nconst float redMat \t\t= 1.0;\nconst float blueMat \t= 2.0;\nconst float mirrorMat \t= 3.0;\nconst float marbleMat \t= 4.0;\nconst float woodMat \t= 5.0;\nconst float checkerMat \t= 6.0;\nconst float metalMat \t= 7.0;\n\n// Lookup material colour etc\nmaterial getMaterial(float matType, vec2 uv) {\n\n    // Set defaults\n    material mat;\n    mat.lighting.diffuse = 0.6;\n    mat.lighting.specular = 0.8;\n    mat.lighting.shiny = 32.0;\n    mat.reflective = 0.0001;\n    \n    if (matType == redMat) {        \n        mat.col = vec3(0.8, 0.3, 0.2);\n        mat.reflective = 0.05;\n        mat.lighting.specular = 2.5;\n    }\n    else if (matType == blueMat) {        \n        mat.col = vec3(0.3, 0.5, 0.9);\n    }        \n    else if (matType == marbleMat) {\n        mat.reflective = 0.15;\n        mat.col = texture(iChannel0, uv * 0.05).xyz;\n    }\n    else if (matType == mirrorMat) {\n        mat.reflective = 0.6;\n        mat.col = vec3(0.7);\n    }\n    else if (matType == woodMat) {\n        mat.col = texture(iChannel1, uv * 0.05).xyz;  \n    }\n    else if (floor(matType) == checkerMat) {\n        float p = (matType - checkerMat) * PI * 2.0;\n        mat.col = vec3(sin(p), sin(p + 2.0), sin(p + 4.0)) * 0.4 + vec3(0.6);\n        if (checkerboard(uv * PI / 2.0))\n            mat.col = mix(mat.col, vec3(1), 0.4);\n    }\n    else if (matType == metalMat) {\n        mat.reflective = 0.15;\n        mat.col = texture(iChannel2, uv * 0.05).xyz * 2.0;              \n    }\n    \n    return mat;\n}\n\nvec3 coffeeCup(in vec3 p, in vec3 center) {\n    \n    // Create a vec3 distance sample by combining distance samples for primative shapes.    \n\tp -= center;\n    \n    float d = length(p - vec3(0, 2.75, 0.6));\n    if (d > 5.5) \n        return vec3(0,0,d - 5.0);    \n    \n    // Component primatives\n    vec3 base = sphere(p, vec3(0, 2, 0), 3.0);\n    base = intersect(base, planeBottom(p, 0.0));        \n    vec3 body = cylinder(p, vec3(0, 3, 0), 3.0, 2.0);    \n    vec3 hole = cylinder(p, vec3(0, 4, 0), 2.8, 3.0);    \n    vec3 rim = torus(p, vec3(0, 5, 0), 2.9, 0.1);    \n    vec3 handle = torus(p.zxy, vec3(3, 0, 2.85), 1.5, 0.3);\n    \n    // Combine together\n    return combine(carve(combine(combine(base, body), handle, 0.5), hole), rim);\n}\n\nvec4 map(in vec3 p) {\n\n    // Combine shapes with materials\n    vec4 r = makes(torus(p, vec3(16, 1.0, 0), 5.0, 1.0), checkerMat + 0.55);\n    r = merges(r, cube(p, vec3(-18, 3.0, 3), 3.0), woodMat);\n    r = merges(r, cylinder(p, vec3(-3, 4, 10), 2.0, 4.0), checkerMat + 0.0);\n    r = merges(r, sphere(p, vec3(sin(iTime * 0.3 * 2.0) * 15.0, 4, cos(iTime * 0.3) * 20.0), 4.0), mirrorMat);\n    r = merges(r, pyramid(p, vec3(-18, 0, -4), 4.0, 6.0), redMat);    \n    vec3 cupp = rotatey(p - vec3(0, 0, -10), -PI*0.5);\n    r = merges(r, coffeeCup(cupp, vec3(0)), metalMat);\n    r = merges(r, planeTop(p, 0.0), marbleMat);\n    \n    return r;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}