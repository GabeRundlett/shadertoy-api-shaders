{
    "Shader": {
        "info": {
            "date": "1637164283",
            "description": "最开始学到噪声的时候，对于simplex噪声的了解只停留在了他的原理层面上，但苦于计算方式没有注释去解释说明以至于难于理解，今天好在看到了一片对于噪声的文章，令我渐渐理解了这种方法，当然作为一个初学者，也可能描述得不是那么得十分正确，仅供自学。如果像详细了解可以看看我最下面的那个链接",
            "flags": 0,
            "hasliked": 0,
            "id": "flK3R1",
            "likes": 2,
            "name": "入门之路-18",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "jialouluo",
            "viewed": 244
        },
        "renderpass": [
            {
                "code": "vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n    //这篇主要是对simplex噪声的一些学习理解笔记\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat simplex_noise(vec2 st){\n    //simplex噪声基于perlin噪声上优化 将原来2^n的复杂度改进到n^2 这样在处理高维空间的时候 性能大大得到提升\n    //原理就是就是采用寻找一个空间晶格的单形的方式来去求权重 ,二维空间下的单形是一个特殊三角形，你可以想想一下将一个平行四边形平分为两个三角形的样子，\n    //至于更多关于单形的解释 推荐看看我放在最下面的链接\n    //话不多说，我们传入进来的st的坐标是未偏斜的，所以我们的第一步就是偏斜我们原有的坐标系\n    //          -----------                   --------\n    //          |          |                  \\      /\\\n    //          |          |                   \\    /  \\\n    //          |          |      ====>         \\  /    \\\n    //          |          |                     \\/      \\\n    //          -----------                       --------\n    //利用公式x′=x+(x+y+...)⋅K1;y′=x+(x+y+...)⋅K1; K1 = (sqrt(n+1)-1)/n  (n为维度);\n    float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    vec2 nst = st + (st.x +st.y)*K1;\n    //对新坐标 老两样 fract floor\n    vec2 fr = fract(nst);//取小数部分，小数部分可以帮助我们进一步判断输入点所在的单形以及计算权重\n    vec2 fl = floor(nst);//取整\n    float K2 = (sqrt(3.)/6. - 0.5);\n    //然后下面的思路是判断我们的输入点(st)处于上三角还是下三角，变形前后对结果没有影响，所以我们选择变形之前的坐标来进行计算判断\n    //单形顶点变回到之前由单形组成的单形网格。这一步需要使用第一步公式的逆函数来求得：x=x-(x′+y′+...)⋅K2\n    //K2=(1/sqrt(n+1) -1)/n; 变换一下就是 (sqrt(3)-3)/6; ==> sqrt(3)/6 -1/2;\n    vec2 a = st - (fl +(fl.x +fl.y) *K2 );//a 也是输入点到单形第一个顶点的距离向量\n    vec2 local = a.x>a.y?vec2(1.0,0.0):vec2(0.0,1.0);//单性存在的区域 (1.0，0.0)表示右下的三角形，(0.0，1.0)表示左上的三角形\n    //接下来我们的思路是 还要计算两个点到输入点的距离向量\n    //对于二维空间来说，如果xf,yf满足xf>yf，\n    //那么对应的3个单形坐标为：首先找到(0, 0)，由于x分量比较大，因此下一个坐标是(1, 0)，接下来是y分量，坐标为(1, 1)\n    //为了方便 就叫他小b和小c吧。\n    //怎么来得出b，c呢 我们是用a去减算出来的local坐标，这个local由于是偏斜坐标系下的，还需要利用k2系数将其转换到直角坐标系\n    vec2 b = a - (local +(local.x+local.y) * K2);\n    vec2 c = a - (vec2(1.0) + (1.0 +1.0) * K2);//这样写便于理解\n    //这样我们的3个点就都求出来了。上面这些运算才是这个这个算法的核心，建议多看几遍 我就是在写这篇分享的时候转变了几次我的理解方式\n    //非常建议上面这段多看几遍，看我这个看不懂的，看下面那个链接的，多看几遍。\n    //------------------------------------------------------------------\n    //下面便简单一些\n    //利用这个公式(r^2−|dist|^2)^4×dot(dist,grad)来计算每个顶点对结果的贡献度(dist代表距离值)(r^2一般取0.5 或0.6)\n    //r^2取0.5的原因:由于经过坐标偏斜后得到的网格宽度为1，因此我们可以倒推出在变形前单形网格中每个单形边的边长为sqrt(2/3)，\n    //这样一来单形每个顶点到对面边的距离（即高）的长度为√2/2，它的平方即为0.5。很奇妙的是，不仅是二维，在其他维度下，每个单形顶点到对面边/面的距离都是0.5。\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(fl)), dot(b, hash22(fl + local)), dot(c, hash22(fl + 1.0)));\n    return dot(vec3(70.0, 70.0, 70.0), n);\n    /**\n    *@链接里面的K2公式没问题，代码那里减是对K2取反，\n    *因为我变形之后K2是(sqrt(3) -3)/6 ，博主K2的值((3-sqrt(3))/6)刚好是取反的值\n    * */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(simplex_noise(uv + iTime));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0)*texture(iChannel0,uv);\n}\n//参考链接 https://blog.csdn.net/candycat1992/article/details/50346469，非常感谢大佬对于噪声的解释。",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}