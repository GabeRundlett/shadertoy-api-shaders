{
    "Shader": {
        "info": {
            "date": "1644063854",
            "description": "CC0: 3 Domes\nSome saturday coding to create some domes I hope will enable some other effects to look cool.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsSyDK",
            "likes": 13,
            "name": "CC0: 3 Domes",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "// CC0: 3 Domes\n//  Some saturday coding to create some domes I hope will enable some other effects\n//  to look cool.\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI      3.141592654\n#define TAU     (2.0*PI)\n#define ROT(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PERIOD  10.0\n\n#define SKYCOLOR skyColor\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal)  {\n  vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n  vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n  vec3 k = abs(m)*boxSize;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n  float tN = max( max( t1.x, t1.y ), t1.z );\n  float tF = min( min( t2.x, t2.y ), t2.z );\n  if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n  outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n  return vec2( tN, tF );\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n  float r2 = ra*ra;\n  vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n  vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n  float ka = 1.0/dot(d2,d2);\n  float k3 = ka* dot(ro,d3);\n  float k2 = ka* dot(o2,d2);\n  float k1 = ka* dot(o3,rd);\n  float k0 = ka*(dot(o2,o2) - r2*r2);\n  float c2 = k2 - k3*k3;\n  float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n  float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n  float p = c2*c2 + c0/3.0;\n  float q = c2*c2*c2 - c2*c0 + c1*c1;\n  float h = q*q - p*p*p;\n  if( h<0.0 ) return -1.0; //no intersection\n  float sh = sqrt(h);\n  float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n  float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n  vec2  w = vec2( s+t,s-t );\n  vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n  float r = length(v);\n  return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nvec3 normalSphere4(in vec3 pos) {\n  return normalize(pos*pos*pos);\n}\n\nvec3 skyColor1(vec3 ro, vec3 rd) {\n  const vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\n  const vec3 lightCol2 = vec3(8.0/8.0,5.0/8.0,5.0/8.0);\n  const vec3 lightDir1 = normalize(vec3(-0.3, 0.15, 1.0));\n  const vec3 lightDir2 = normalize(vec3(-0.33,  -0.2, -1.0));\n  \n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n  float yf       = (0.5+0.5*rd.y);\n  yf *= yf;\n  yf *= yf;\n  vec3 final     = vec3(vec3(0.25, 0.2, 0.3))*yf;\n\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) final = vec3(2.0)*rd.y;\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(clamp(1.0 - roundBox*0.5, 0.0, 1.0), 6.0);\n  \n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 8.0*lightCol1 * pow(ld1, 400.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += 8.0*lightCol2 * pow(ld2, 400.0);\n  return final;\n}\n\nvec3 skyColor2(vec3 ro, vec3 rd) {\n  const vec3 lightDir1 = normalize(vec3(-0.3, 0.25, 1.0));\n  const vec3 lightDir2 = normalize(vec3(-0.33,  -0.3, -1.0));\n  const vec3 hiLightCol1 = HSV2RGB(vec3(0.6, 0.5, 1.0))*8.0;\n  const vec3 loLightCol1 = HSV2RGB(vec3(0.9, 0.5, 1.0))*2.0;\n  const vec3 hiLightCol2 = HSV2RGB(vec3(0.1, 0.5, 1.0))*8.0;\n  const vec3 loLightCol2 = HSV2RGB(vec3(0.5, 0.5, 1.0))*2.0;\n  const vec3 skyCol      = HSV2RGB(vec3(0.7, 0.75, 0.25));\n  \n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n\n  vec3 nb;\n  const vec3 boxDim = vec3(1000.0, 500.0, 1000.0);\n  vec2 db = rayBox(ro, rd, boxDim, nb);\n  \n  vec3 p = ro+rd*db.y;\n\n  vec3 mp = p;\n  \n  vec3 dp = abs(mp);\n  vec3 sel = abs(nb);\n  vec3 d3 = mix(dp, boxDim*2.0, sel);\n  float d = d3.x;\n  const float sm = 20.0;\n  d = pmin(d, d3.y, sm);\n  d = pmin(d, d3.z, sm);\n  \n  vec3 m3 = sin(TIME+3.0*p/boxDim);\n  float m = mix(0.75, 0.9, tanh_approx(m3.x+m3.y+m3.z));\n  m *= m;\n  m *= m;\n  vec3 hsv = vec3(0.4+mix(0.45,0.0, m), tanh_approx(0.005*mix(50.0, 10.0, m)*d), 1.0);\n  vec3 gcol = 1.5*hsv2rgb(hsv)*exp(-0.005*mix(30.0, 10.0, m)*d);\n\n\n  float dif = max(dot(rd, -nb), 0.0);\n  dif *= dif;\n  dif *= dif;\n\n  float yf       = (0.5+0.5*rd.y);\n  yf *= yf;\n\n  vec3 col = skyCol*yf;\n  \n  col += gcol;\n  if (rd.y > 0.0) {\n    const vec3 gcol = HSV2RGB(vec3(0.8, 0.33, 1.0));\n    vec3 pos  = ro + db.y*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, boxDim.xz*0.7)-50.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(10.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.0125*max(db, 0.0));\n  }\n  \n  col += loLightCol1 * pow(ld1, 10.0);\n  col += hiLightCol1 * pow(ld1, 800.0);\n  col += loLightCol2 * pow(ld2, 10.0);\n  col += hiLightCol2 * pow(ld2, 800.0);\n\n  return col;\n}\n\nfloat blobs(vec2 p) {\n  // Generates a grid of dots\n  vec2 bp = p;\n  vec2 bn = mod2(bp, vec2(3.0));\n\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 skyColor3(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));\n  vec3 col = clamp(vec3(0.00125/abs(rd.y))*gcol, 0.0, 1.0);\n  \n  \n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    const float fz = 0.25;\n    const float bz = 1.0/fz;\n    vec2 bpos = pos.xz/bz;\n    float db = blobs(bpos)*bz;\n    db = abs(db);\n    vec2 pp = pos.xz*fz;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.125);\n    dp = min(dp, db);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    \n    float f = 1.0-tanh_approx(0.1*length(pos.xz));\n    col = mix(col, pcol , f);\n  }\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));\n  }\n\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float tp = mod(TIME, PERIOD);\n  float np = mod(floor(TIME/PERIOD), 3.0);\n  vec3 col;\n  if (np == 0.0) {\n    col = skyColor1(ro, rd);\n  } else if (np == 1.0) {\n    col = skyColor2(ro, rd);\n  } else {\n    col = skyColor3(ro, rd);\n  }\n  \n  return col*smoothstep(0.25, 1.0, tp)*smoothstep(PERIOD-0.25, PERIOD-1.0, tp);\n}\n\n\nvec3 color(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  \n  mat3 rot = \n    rot_x(0.25*TIME)\n    *rot_y(0.33*TIME)\n    *rot_z(0.45*TIME)\n    ;\n  mat3 irot = transpose(rot);\n  \n  vec3 bro = rot*ro;\n  vec3 brd = rot*rd;\n  \n  float bi = raySphere4(bro, brd, 3.0);\n  \n  if (bi > -1.0) {\n    \n    vec3 bp = bro + bi*brd;\n    vec3 bn = normalSphere4(bp);\n    vec3 p = irot*bp;\n    vec3 n = irot*bn;\n    vec3 r = reflect(rd, n);\n    float bf = 1.0+dot(rd,n);\n    float fre = bf;\n    fre *= fre;\n    vec3 rsky = SKYCOLOR(p, r);\n    vec3 col = mix(0.125, 1.0, fre)*rsky;\n    float rdif = dot(-rd, n);\n    rdif *= rdif;\n    col += 0.25*mix(0.0125, 0.05, rdif)*vec3(1.0);\n    return mix(skyCol, col, smoothstep(1.0, 0.85, bf));\n  }\n  \n  return skyCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 3.0, 7.0);\n  ro.xz *= ROT(0.125*TIME);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  float fov = tan(TAU/6.0);\n  vec2 np = p + vec2(aa); \n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n\n  vec3 col = color(ro, rd);;\n\n  fragColor = vec4(sRGB(col), 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}