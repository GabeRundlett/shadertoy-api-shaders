{
    "Shader": {
        "info": {
            "date": "1569812746",
            "description": "test",
            "flags": 0,
            "hasliked": 0,
            "id": "wdVGR1",
            "likes": 0,
            "name": "Test20190929",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "xiahogzhi",
            "viewed": 293
        },
        "renderpass": [
            {
                "code": "float sdSphere(vec3 pos,float len){\n    return length(sin(pos)) - len;\n\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat castRay(vec3 ro,vec3 rd){\n\n    float t = 0.0;\n    \n    for(int i = 0 ;i < 500 ;i++){\n\t\t\n        vec3 p = ro + rd * t;\n        \n        \n        float r = sdSphere(p - vec3(0.0,iTime, 0.0) ,0.5);\n        \n      //  float r = sdBox(p - vec3(0.0,iTime, 0.0),vec3(0.8));\n        \n      //  float r = sdTorus(p - vec3(sin(iTime*0.5),0.0,0.0),vec2(0.5,0.5));\n        \n      //  r = r <= r2 ? r: r2;\n        \n\t\t\n        if(abs(r)<0.001*t)\n        { \n           return t;\n        }\n         t += r;\n        \n        \n    }\n    return -1.0;\n}\n\nvec3 render(vec3 ro,vec3 rd){\n    \n    float t = castRay(ro,rd);\n\n\n    if(t > 0.0 && t < 30.0){\n        \n        vec3 pos = ro + rd *t;\n\n        vec3 lightPos = vec3(sin(iTime)*10.0,cos(iTime)*10.0,cos(iTime)*10.0+5.0);\n\n        vec3 lightDir = normalize(lightPos - pos );\n\n        float f = clamp (dot(pos,lightDir) , 0.0,3.0);\n        \n        vec3 srcCol = vec3(0.3,0.4,0.8);\n\n        vec3 l = srcCol * f;\n        \n\n        return vec3(l);\n    }\n    \n    return vec3(0.5);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr),cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = 15.0 + iTime*1.5;\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    //float pixel = 1.0/iResolution.y;\n    \n    // camera\t\n    vec3 ta = vec3(0.5, -0.4, -0.5);\n    vec3 ro = ta + vec3(sin(iTime)*2.0,sin(iTime)*3.0-2.0,cos(iTime)*2.9-10.0);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta,0.0 );\n\n    vec3 rd = ca * normalize( vec3(uv,2.0) );\n    \n    fragColor = vec4(render(ro,rd),1.0);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}