{
    "Shader": {
        "info": {
            "date": "1638757308",
            "description": "Infinite zoom of a snowflake-esque fractal constructed from tetrahedrons. The surface coloring involves thin-film interference. Click to zoom / change level of detail.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lyGRz",
            "likes": 21,
            "name": "Crystal Tetrahedron Fractal",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "mouse",
                "zoom",
                "tetrahedron",
                "rainbow",
                "infinite",
                "iridescent"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "// Infinite zoom of a snowflake-esque fractal constructed from tetrahedrons. The self-\n// similarity is exploited to appear as an infinite zoom despite never zooming beyond\n// two iterations.\n// Created by Anthony Hall\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\nconst vec3 rgbWavelengths = vec3(0.612, 0.549, 0.464) / pi;\n\nconst float maxDistance = 40.0;\nconst float epsilon = 0.003;\n\n// Many of the following globals are set/modified in mainImage\nvec3 cameraPos = vec3(0.0, 0.0, 4.0);\nvec3 cameraDest = vec3(0.0);\nconst float fov = radians(50.0);\n\nfloat time;\n\n// The base number of iterations at no zoom, and the amount each iteration scales\n// the size down. The bound lobes in the SDF were crafted for these values, so raising\n// baseLevels or lowering levelScale will cause glitches. See scene for details/fixes\nfloat baseLevels = 7.0;\nconst float levelScale = 2.0;\n\nconst float zoomPeriod = 4.0; // Time to zoom through one level\nfloat zoomTotal; // Number of levels it looks like we have zoomed\nfloat zoomBase; // Percentage of the first level we have zoomed\nfloat zoomRepeat; // Percentage of the second level we have zoomed\nfloat zoom; // Number of levels we have actually zoomed (zoomBase + zoomRepeat)\n\n// Transforms the point evaluating the SDF (only rotation/scale)\nmat3 sceneTransform = mat3(1.0);\n\n// The amount the scene is zoomed in\nfloat sceneScale;\n\n// Translation component of the SDF point transformation. It's separate because\n// mat3 * vec3 + vec3 is slightly cheaper than mat4 * vec4 (please correct me if wrong)\nvec3 sceneOffset;\n\nfloat linestep(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nmat2 rotate(float theta)\n{\n    vec2 cs = vec2(cos(theta), sin(theta));\n    return mat2(\n        cs.x, cs.y,\n        -cs.y, cs.x);\n}\n\n// Tetrahedron's vertices\nconst vec3[4] vertices = vec3[4](\n    vec3(1, 1, 1),\n    vec3(-1, 1, -1),\n    vec3(-1, -1, 1),\n    vec3(1, -1, -1));\n\n// Tetrahedron bound SDF by yx\n// https://www.shadertoy.com/view/Ws23zt\nfloat sdTetrahedron(vec3 p)\n{\n    return (max(\n        abs(p.x+p.y)-p.z,\n        abs(p.x-p.y)+p.z\n    )-1.)/sqrt(3.);\n}\n\n// Arbitrarily oriented flat disk\nfloat sdDisk(vec3 point, vec3 normal, float radius)\n{\n    float dist = dot(point, normal);\n    vec3 planePoint = point - dist * normal;\n    float l = length(planePoint);\n    float r = min(l, radius);\n    planePoint = planePoint / l * r;\n    return distance(point, planePoint);\n}\n\n// Folds space about a plane, and scales only the mirrored side without branching.\n// scale returns how much the space was scaled\nvec3 scaleFold(vec3 point, vec3 planePoint, vec3 normal, out float scale)\n{\n    float planeDist = dot(point - planePoint, normal);\n    float reflected = float(planeDist < 0.0);\n    scale = 1.0 - reflected + levelScale * reflected;\n  \n    // min(0.0, planeDist) seems to be slightly faster than reflected * planeDist\n    point -= 2.0 * min(0.0, planeDist) * normal;\n    point -= planePoint;\n    point *= scale;\n    point += planePoint;\n    return point;\n}\n\n// Distance to the scene\nfloat scene(vec3 point)\n{\n    point = sceneTransform * point + sceneOffset;\n    float dist = 1e10;\n    float scaleAcc = 1.0;\n    float levels = baseLevels + zoom;\n\n    for (float i = 0.0; i < ceil(levels); i += 1.0)\n    {\n        // The magic here is that each vertex of the tetrahedrons has an even number\n        // of negative signs. This means we can easily transform the vertex octants to\n        // the [+, +, +] octant and leave the others alone.\n        \n        float signs = (sign(point.x) * sign(point.y) * sign(point.z));\n        point = mix(point, abs(point), 0.5 + 0.5 * signs);\n        \n        float scale;\n        point = scaleFold(point, vertices[0], -vertices[0] / sqrt(3.0), scale);\n        scaleAcc *= scale;\n\n        // When the level is fractional, blend the last and second to last distances\n        if (levels - i < 1.0)\n        {\n            float newDist = min(dist, sdTetrahedron(point) / scaleAcc);\n            dist = mix(dist, newDist, levels - i);\n        }\n        // Take the initial distance when we are at the final whole level\n        else if (levels - i < 2.0)\n            dist = min(dist, sdTetrahedron(point) / scaleAcc); // TODO\n    }\n    // The SDF is now super messed up because the transformations above are not uniformly\n    // applied to space. A point may not know it is near something because it's in a \"less\"\n    // transformed region of space. To fix this, we will add lobe bounds that fully cover\n    // the regions that may be overestimated. \n    \n    // Slight optimization: by mapping every non-vertex octant to the [-, +, +] octant,\n    // we only need to check the neighboring three lobes instead of all four. This also\n    // maps all vertex octants to [+, +, +], so they're covered by the first lobe check.\n    \n    // It's not perfect, there are still viewing conditions in which glitching can occur\n    // and I'm stumped\n    \n    float signs = sign(point.x) * sign(point.y) * sign(point.z);\n    point = mix(vec3(-abs(point.x), abs(point.yz)), abs(point), 0.5 + 0.5 * signs);\n    float boundDist = 1e10;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        boundDist = min(boundDist, sdDisk(point - (1.205 + 1.0 / levelScale) * vertices[i],\n            vertices[i] / sqrt(3.0), 1.3));\n    }\n    // Lower the epsilon multiplier to raise baseLevels over 7\n    // Raise the disk size (0.95) to lower levelScale below 2\n    dist = min(dist, abs((boundDist - 0.95) / scaleAcc) + 3.0 * epsilon);\n    return dist * sceneScale;\n}\n\nvec3 estimateNormal(vec3 point, float distAtIntersect)\n{\n    const vec2 k = vec2(0.0, epsilon);\n    return normalize(vec3(\n        scene(point + k.yxx),\n        scene(point + k.xyx),\n        scene(point + k.xxy)) - distAtIntersect);\n}\n\n// Rather than use the depth and refractive index ratio, \"incident distance\"\n// is used to save a couple operations. I define it as double the depth of the film\n// multiplied by the speed of light outside the film over the speed of light inside\n// the film. Think of it as the distance the light wave travels when hitting the\n// film straight on,  accounting for the fact that the wavelength changes while\n// inside the different medium.\n\nvec3 filmInterference(vec3 incident, vec3 normal, float incidentDist)\n{\n    // Extra distance traveled by the light that goes through the film\n    float dist = incidentDist / dot(-incident, normal);\n    return abs(cos(dist / rgbWavelengths));\n}\n\n// Rainbow sky\nvec3 sky(vec3 normal)\n{\n    float y = 2.0 * asin(normal.y) / pi; // Phi normalized to [-1, 1] \n    float phase = 1.3 * (y + 1.0) - 0.01;\n    vec3 color = 0.5 + 0.5 * cos(phase / rgbWavelengths);\n    \n    // Wave-like function for changing brightness and color exponent\n    float theta = atan(normal.z, normal.x);\n    float intensity = cos(5.0 * theta - 0.7 * time)\n        * cos(6.0 * theta)\n        * cos(3.0 * theta + 0.82 * time);\n        \n    // Push values away from 0 a little\n    intensity = sign(intensity) * pow(abs(intensity), 0.875);\n    \n    // Get rid of the weirdness at the poles\n    intensity = mix(intensity, 0.4, linestep(0.5, 0.85, abs(y)));\n    \n    return (0.8 + 0.2 * intensity) * pow(color, vec3(pow(2.0, -2.0 * intensity)));\n}\n\nvec3 shadeSurface(vec3 point, vec3 normal, vec3 incident)\n{\n    // Make the surface white with a little bit of thin film interference from the\n    // sky reflection. I chose the refractive index and \"incident distance\" arbitrarily\n    // for aesthetic reasons. In order to accurately model the phenomenon, incident\n    // distance must be caculated as 2 * depth * R_film / R_air (see filmInterference)\n    \n    vec3 skyColor = sky(reflect(incident, normal));\n    vec3 filmRefraction = refract(incident, normal, 0.8);\n    vec3 surface = 0.65 + 0.6 * skyColor * filmInterference(filmRefraction, normal, 2.5);\n    \n    // The lighting model is essentially a ring around the hemisphere that gets dark\n    // very fast, with a ton of ambient light. This completely throws the sRGB color space\n    // out the window, but the result has enough contrast without overwhelming brightness.\n    float diffuse = dot(normal.xz, normal.xz); \n    diffuse = 0.5 + 0.5 * diffuse;\n    return min(diffuse * surface, 1.0); // Surface color can exceed 1 so it needs clamping\n}\n\nvec3 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 color;\n    vec3 point = rayOrigin;\n    float t;\n    bool hit = false;\n\n    for (t = 0.0; t < maxDistance; point = rayOrigin + t*rayDir)\n    {\n        float dist = scene(point);\n        if (dist <= epsilon)\n        {\n            vec3 normal = estimateNormal(point, dist);\n            color = shadeSurface(point, normal, rayDir);\n            hit = true;\n            break;\n        }\n        t += dist;\n    }\n    if (!hit)\n        // There's not quite enough contrast without darkening the sky a bit\n        color = 0.75 * sky(rayDir);\n\n    return color;\n}\n\n// Changes t [0, 1] to an exponential curve such that its derivative at 0 is levelScale\n// times its derivative at 1. That is, its speed exponentially decreases\nfloat expT(float t)\n{\n    return 1.0 - (pow(levelScale, 1.0 - t) - 1.0) / (levelScale - 1.0);\n}\n\n// Given 3 points that lie on an arc, this interpolates between two of them on the arc.\n// previous -> start and start -> end must be equidistant on the arc for this to work.\nvec3 arcInterp(vec3 previous, vec3 start, vec3 end, float t)\n{\n    vec3 toPrev = previous - start;\n    vec3 toEnd = end - start;\n    vec3 toCenter = normalize(toPrev + toEnd);\n    float cDot = dot(toPrev, toCenter);\n    float radius = dot(toPrev, toPrev) / (2.0 * cDot);\n    vec3 center = start + radius * toCenter;\n\n    // Correct t so that the angle change is constant\n    float theta = 0.5 * (pi - 2.0 * acos(cDot / length(toPrev)));\n    t = 2.0 * t - 1.0;\n    t = tan(t * theta) / tan(theta);\n    t = 0.5 + 0.5 * t;\n\n    vec3 raw = mix(start, end, t);\n    return center + radius * normalize(raw - center);\n}\n\nmat3 rotateRay(vec3 camera, vec3 dest, vec3 up)\n{\n    vec3 forward = normalize(dest - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // First, there's a whole lot of globals calculation to do\n    time = iTime;\n    \n    float click = float(iMouse.z > 0.0);\n    vec2 mouse = click * iMouse.xy / iResolution.xy;\n    mouse.y += 1.0 - click;\n    \n    baseLevels = max(baseLevels - (4.0 - 4.0 * mouse.y), 1.0); // Must be >= 1 for SDF to work\n  \n    if (time < 2.0)\n        time = 0.25 * time * time;\n    else\n        time = time - 1.0;\n\n    zoomTotal = time / zoomPeriod + 3.0 * mouse.x;\n    zoomBase = min(zoomTotal, 1.0);\n    zoomRepeat = fract(zoomTotal - zoomBase);\n    zoom = zoomBase + zoomRepeat;\n    sceneScale = pow(levelScale, zoom);\n\n    // The rotation matrix from one level to the next is calculated from the perspective\n    // of directly facing the center tetrahedron (kind of how the camera is at the\n    // beginning). Thus, that rotation must be corrected for that orientation.\n    // f, u, r = forward, up, right vectors\n    \n    const vec3 f0 = vertices[3] / sqrt(3.0);\n    const vec3 u0Init = vec3(0, 1, 0);\n    const vec3 r0 = normalize(cross(f0, u0Init));\n    const vec3 u0 = cross(f0, -r0);\n    const mat3 correction = transpose(mat3(r0, u0, -f0));\n\n    // Now, rotate from one level to the next\n    const vec3 mirrorNormal = vertices[0] / sqrt(3.0);\n    const vec3 f1 = f0 - 2.0 * dot(f0, mirrorNormal) * mirrorNormal; // Mirrors f0\n    const vec3 u1Init = vertices[0];\n    const vec3 r1 = normalize(cross(f1, u1Init));\n    const vec3 u1 = cross(f1, -r1);\n\n    const mat3 fullRot = mat3(r1, u1, -f1) * correction;\n    const mat3 invRot = transpose(fullRot);\n    \n    // Directly interpolating the rotation of each axis doesn't work well because \n    // the rotation takes a sharp turn at the border of each level. Considering the\n    // original axes and the axes after the first and second rotations, these three\n    // points will lie on an arc. When doing partial rotations, we want to figure out\n    // where along this arc the new axis should lie. See arcInterp\n    \n    const vec3 prevU = invRot[1];\n    const vec3 prevF = -invRot[2];\n\n    const vec3 destU = fullRot[1];\n    const vec3 destF = -fullRot[2];\n\n    float zoomFract = fract(zoom);\n\n    vec3 partialF = arcInterp(\n        prevF,\n        vec3(0, 0, -1),\n        destF,\n        zoomFract);\n\n    vec3 partialU = arcInterp(\n        prevU,\n        vec3(0, 1, 0),\n        destU,\n        zoomFract);\n\n    vec3 partialR = normalize(cross(partialF, partialU));\n    partialU = cross(partialF, -partialR);\n    mat3 partialRot = mat3(partialR, partialU, -partialF);\n\n    // The idea for the offset is similar. The actual path of the offset should be a\n    // logarithmic spiral centered at wherever the zoom is converging. I don't know how\n    // to actually solve for the center of this logarithmic spiral, so we can utilize\n    // the fact that logarithmic spirals are closely approximated by tangent arcs of\n    // exponentially decreasing size. This approximation isn't perfect, hence you may\n    // notice the figure wobble a bit especially when zooming quickly.\n    \n    const vec3 destOffset = vertices[0] * (1.0 + 1.0 / levelScale);\n    const vec3 prevOffset = -invRot * destOffset;\n    \n    vec3 partialOffset = arcInterp(\n        prevOffset,\n        vec3(0),\n        destOffset,\n        expT(zoomFract));\n    \n    if (zoom < 1.0)\n    {\n        sceneTransform = partialRot;\n        sceneOffset = partialOffset;\n    }\n    else\n    {\n        sceneTransform = partialRot * fullRot;\n        sceneOffset = destOffset + fullRot * partialOffset / levelScale;\n    }\n    sceneTransform /= sceneScale;\n\n    // Percentage that approaches 1 as time goes on\n    float startExp = 1.0 - exp(-0.1 * time);\n\n    // The camera is placed such that it's never looking toward the part that\n    // disappears when the zoom repeats. It also avoids sky reflections that directly\n    // face the poles.\n    \n    float xzTheta = -0.5 + 0.25 * cos(0.1 * time);\n    cameraPos = (-6.0 + 1.5 * startExp) * vertices[3];\n    cameraPos.xz = rotate(xzTheta) * cameraPos.xz;\n    cameraPos.y -= 2.0 * startExp;\n    \n    // The camera approaches looking close to where the fractal path converges\n    cameraDest = startExp * vec3(1.6, 1.6, 1.3);\n\n    // Rotate the up vector around slowly\n    vec3 up = vec3(sin(0.12 * time), cos(0.12 * time), 0.0);\n    up = rotateRay(cameraPos, cameraDest, vec3(0, 1, 0)) * up;\n    \n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDir = normalize(vec3(point * tan(fov/2.0), -1.0));\n    rayDir = rotateRay(cameraPos, cameraDest, up) * rayDir;\n    \n    fragColor = vec4(castRay(cameraPos, rayDir), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}