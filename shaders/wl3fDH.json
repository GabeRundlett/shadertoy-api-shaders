{
    "Shader": {
        "info": {
            "date": "1613520446",
            "description": "props to rgb shifting!  still work in progress! ",
            "flags": 32,
            "hasliked": 0,
            "id": "wl3fDH",
            "likes": 4,
            "name": "ultimate custom feedback wip*",
            "published": 3,
            "tags": [
                "webcam",
                "feedback"
            ],
            "usePreview": 1,
            "username": "SimonOakey",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nfloat rand (vec2 p) {\n\n    p = fract(p*vec2(123.34,456.567));\n    p += dot(p, p+45.32);\n    return fract(p.x * p.y);\n}\n*/\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvec2 rotate(vec2 coords, float angle){\n\tfloat sin_factor = sin(angle );\n    float cos_factor = cos(angle );\n    coords = vec2((coords.x - 0.5) , coords.y - 0.5) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n    coords += 0.5;\n    return coords;\n}\n\n\n\nvec3 hsb2rgb( in vec3 c ){\n    \n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec2 swizzle( vec2 pol, vec2 _uv ) {\n\n    float _mode = 3.5;// (iMouse.y/iResolution.y)*6.;\n\n    vec2 displacement = vec2(0.);\n    \n    float morph_speed = iTime; // feedback morph speed\n    \n    float feedback_amount = 1.; // feedback amount\n\n    float _freq = (iMouse.x/iResolution.x)*1.8 +.5;\n    \n    \n   // displacement.x = noise( vec2( sin(pol.y*morph_speed*.0013 + morph_speed*.1), cos(pol.x*morph_speed*.00413)) ) ;\n    //displacement.y = noise( vec2( cos(pol.y*morph_speed*.0013), sin(pol.x*morph_speed*.0013 + morph_speed*.3)) ) ;\n    \n    // ----------------------\n    // META FEEDBACK MAP\n     // ----------------------\n    \n     // micro noise\n    \n    // displacement.y = cos(noise(vec2(pol.x*3.,pol.y*33.+ iTime*.1))*4.2) *.6;\n    // displacement.x = sin(noise(vec2(pol.y*9.+ iTime*.61 ,pol.x*13.))*4.2) *.3;\n    \n    \n    // tiny noise\n      displacement.y = cos(noise(_uv*33. + iTime*.1)*3.);\n     displacement.x = sin(noise(_uv*12. + iTime*.1)*3.);\n    \n    \n     \n     //circular osc simple\n     //  displacement.y = sin(_uv.x*12.+ iTime*.51)*2.;\n     // displacement.x = cos(_uv.y*12.+ iTime*.51)*2.;\n     \n     // color based oscillation\n     //displacement.y  = sin(pol.x*12.+ iTime*.51);\n     //displacement.x  = cos(pol.x*12.+ iTime*.51);\n     \n      // fullscreen noise\n     //displacement.x += sin(noise(_uv*.3 + iTime*.1)*3.)*1.2;\n    // displacement.y += cos(noise(_uv*.9 + iTime*.1)*3.)*1.2;\n     \n     //hor and vert linear grid\n    //  displacement.y  +=  ( abs(sin(_uv.x*33.+ iTime*1.51))  )*2.;\n    // displacement.x  =  ( abs(sin(_uv.y*33.+ iTime*1.51))  )*2.;\n     \n    \n    \n     // ----------------------\n      // ----------------------\n       // ----------------------\n    \n   \n     /*\n     if(_mode>=0. && _mode<1.){ \n     \n            \n          // osccillating dsiplacement\n         displacement =  vec2( \n            pol.x * cos(pol.y*6.*_freq) + sin(pol.y*_freq+morph_speed)*.5,\n            pol.y * sin(pol.x*3.*_freq) + (cos(pol.x*.6*_freq+morph_speed))*.65\n           );\n     }\n    \n    \n    if(_mode>=1. && _mode<2.){ \n        // uv&color based displacement\n        displacement.y += sin(pol.y*_uv.x*13.3*_freq + morph_speed*1.3) ;\n        displacement.x += cos(pol.x*_uv.y*23.3*_freq  + morph_speed*1.3);\n    }\n   \n   \n   if(_mode>=2. && _mode<3.){ \n   // simple linear displacement\n       displacement.y -= .4 + pol.y*.2;//2.3*pol.x;\n       displacement.x +=  sin( pol.y*12.1*_freq +morph_speed )*.14 ;//* 1.*pol.y;\n     }\n   \n    if(_mode>=3. && _mode<4.){ \n   // osccillating noise > brilliant!\n     displacement.y += sin(noise(pol*_freq  +morph_speed*.1)*3.4 );\n     displacement.x += cos(noise(pol*_freq  +morph_speed*.1)*5.4 );\n   }\n   \n    if(_mode>=4. && _mode<5.){ \n       // fluffl noise > nice\n        displacement.y += noise(_uv*pol.x*2.6*_freq  +cos(morph_speed*.4));\n        displacement.x += noise(_uv*pol.y*2.6*_freq  +sin(morph_speed*.4));\n    }\n    \n    if(_mode>=5. && _mode<6.){ \n    // fract sinusal > work on this more!\n     displacement.y +=  sin(fract((pol.x*2.3*_uv.y*_freq+morph_speed*.3))* 2.);\n    displacement.x +=  cos(fract( (pol.y*2.3*_uv.x*_freq+morph_speed*.3 ))*2.);\n   }\n    */\n    displacement *=feedback_amount;\n    \n   \n    \n    return displacement;\n    \n}\n\n\n\nvec4 color_swizzle2( vec4 _col, vec2 _uv ) {\n\n\n        float color_freq = iMouse.x/iResolution.x;\n        float color_amplitude = iMouse.y/iResolution.y;\n    \n        float col_freq =  .001 + color_freq*.03;\n        float col_amplitude = .001 + color_amplitude * 0.75;\n        \n\t\tvec3 o_col = _col.rgb;\n        vec3 colOut = rgb2hsv(_col.rgb); // convert color to hsb\n        \n     \n         float unision =  sin( _col.r*col_freq*3.14  ) *.5;\n         \n        \n         \n        unision *= noise(sin(_uv*.4*_col.r*col_freq+ iTime*.01*col_freq )*3.)*.1;\n     \n      unision *=color_amplitude;\n     \n\t  colOut.r +=  unision*.004 + .003 * color_amplitude;\n      \n        colOut.g +=  unision*.004 + .003 * color_amplitude;\n       \n          colOut.b += unision*.12 + .003 * color_amplitude;\n        \n      //  colOut.b += noise( sin(_uv*13.14*_col.r+ iTime*.1 )*3.)*.4;\n      // colOut.r += (noise( sin(_uv*1222.14*_col.b*col_freq+ iTime*.1 )*3.)*.2 ) *col_amplitude;\n\t\t\n\t\t //colOut.g += (col_freq+_col.b*col_freq*.001 ) *col_amplitude;\n\t  \n\t\t //colOut.b += sin(_col.b*col_freq )*col_amplitude;\n\t\t\n         colOut.r  += (rand(_uv)-.5)*.02;\n         //colOut.r += mod(colOut.r+.001,1.0);\n        \n     \n      colOut = hsv2rgb(colOut);\n      \n       return vec4(vec3(colOut),1.);\n      \n     //   colOut.r += sin(colOut.r*11.31)*.1;\n     \n     /*\n     // SIMPLE RGB SHIFTING\n      o_col.r += ( sin(col_freq*iTime*_col.g* 3.13)*.5+.5 ) *.01*col_amplitude;\n       o_col.g += ( cos(col_freq*iTime*_col.r*2.16)*.5+.5 ) *.004*col_amplitude;\n       o_col.b += ( sin(col_freq*iTime*_col.r*5.01)*.5+.5 ) *.01*col_amplitude;\n     \n     \n      return vec4(vec3( o_col),1.);\n    */\n\n}\n\nvec4 color_swizzle( vec4 _col, vec2 _uv ) {\n\n     \n    \n    vec3 col = rgb2hsv(_col.rgb);\n    \n     // ---------------------------------\n    // --------COLOR  SHIFT --------------\n    // ---------------------------------\n    \n    // simple continuous color shift\n    float colorshift = 1.0014*iTime; \n    \n     // colorshift distortion based\n       //colorshift += (sin( col.x*.04 + _uv.y*.14)*.5+.5)*.002;\n     \n     // colorshift color based\n    //   colorshift = (sin( col.x*.014 + col.y*.014)*.5+.5)*.002;\n    \n      //  colorshift = 0.; \n    \n    \n    // ---------------------------------\n    // --------SATURATION SHIFT --------------\n    // ---------------------------------\n    float sat_shift  =  col.y;\n    \n    \n     //sat_shift *= abs(sin(.001*_col.y+_uv.x*.001+iTime*.4)*.5+.5)*1.19+.95;\n      //sat_shift = mod(col.r+.001, 1.0)*04.;\n      // sat_shift =.5;\n    //   sat_shift += abs(sin(2.1*_col.x + cos(1.1*_uv.x)))*.08;\n     \n      // ---------------------------------\n    // -------BRIGHT SHIFT --------------\n    // ---------------------------------\n     \n     float b_shift = col.z;\n     \n     //contrasty wandering\n      b_shift =  (sin(_uv.y*2.031+_col.z*2.6+iTime*.021+_uv.x*2.1))*.3+.66; \n     \n    // col.g = .5;\n    // col.g = cos(_col.r*1.3 + _uv.y* 1.1)*.5+.25; // saturation\n      //col.b = .8;// cos(_col.g*.71)*.5+.5; // saturation\n     \n     //col.r =  abs(sin(_uv.y*col.r*.1+iTime*.001))*1.05;\n     //col.r += mod(col.r+.01, 1.0)*4.;\n    //col.b = mod(col.b+.01, 1.0);\n    \n    // col.r += colorshift; // color shift\n       //col.b = sat_shift;\n      // col.g = b_shift;\n    \n    col = hsv2rgb(col);\n   col = fract(col);\n\n    return vec4(vec3(col),1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    float dry = iMouse.x/iResolution.x;\n    dry = .01;\n\n\n    vec2 uv = fragCoord / iResolution.xy;\n    // uv.y *= iResolution.y/iResolution.x;\n    vec2 displacedUv = uv;\n    vec4 imageIn = texture(iChannel0, uv);    \n    vec4 feedbackIn = texture(iChannel1, uv);\n    displacedUv += swizzle( vec2(length(feedbackIn.rg), length(feedbackIn.rb)), uv) / 1000.0;\n\n\n    // optional rotate whole feedback \n    //displacedUv = rotate(displacedUv,.001);\n    \n    vec4 feedback = texture(iChannel1, displacedUv);\n   \n    feedback = color_swizzle2(feedback,displacedUv);\n  \n   feedback = mix(feedback,imageIn,dry);\n   \n   \n   \n        fragColor = feedback;\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}