{
    "Shader": {
        "info": {
            "date": "1687279447",
            "description": "Shows how to compute if a point is inside a triangle, apply rotation too.\nUse Xoring of triangles for cool effects thanks to the suggestion of FabriceNeyret2.\nThere is a layer of imbrication, you could play with the side of the triangle for various effect",
            "flags": 0,
            "hasliked": 0,
            "id": "mdsyWf",
            "likes": 2,
            "name": "Simple sun rosace",
            "published": 3,
            "tags": [
                "trianglerosacerosetterotation"
            ],
            "usePreview": 0,
            "username": "etdeagle",
            "viewed": 144
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535897932384626433832795;\n\nvec3 xorCols(vec3 col0, vec3 col1) {\n    vec3 col = vec3(int(col0.x * 255.0) ^ int(col1.x * 255.0),\n    int(col0.y * 255.0) ^ int(col1.y * 255.0),\n    int(col0.z * 255.0) ^ int(col1.z * 255.0));\n    return col / 255.0;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 drawTriangle(in vec2 suv, in vec2 rot, in float side) {\n\n    // Create triangle vertices in local coordinates\n    float height = sqrt(side * side - (side * side / 4.0));\n    vec2 p1 = vec2(-side / 2.0, 0);\n    vec2 p2 = vec2(0, height);\n    vec2 p3 = vec2(side / 2.0, 0);\n\n    // Rotate and translate vertices\n    /*p1 = vec2(dot(p1, rot), dot(p1, vec2(-rot.y, rot.x)));\n    p2 = vec2(dot(p2, rot), dot(p2, vec2(-rot.y, rot.x)));\n    p3 = vec2(dot(p3, rot), dot(p3, vec2(-rot.y, rot.x)));*/\n\n\n    p1 = vec2(p1.x * rot.x - p1.y * rot.y, p1.x * rot.y + p1.y * rot.x);\n    p2 = vec2(p2.x * rot.x - p2.y * rot.y, p2.x * rot.y + p2.y * rot.x);\n    p3 = vec2(p3.x * rot.x - p3.y * rot.y, p3.x * rot.y + p3.y * rot.x);\n\n    // Compute barycentric coordinates\n    /*vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1;*/\n    \n     vec2 barycenter = (p1 + p2 + p3) / 3.0;\n    \n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1 + barycenter;\n    \n    \n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float dot13 = dot(v1, v3);\n    float dot22 = dot(v2, v2);\n    float dot23 = dot(v2, v3);\n    float invDenom = 1.0 / (dot11 * dot22 - dot12 * dot12);\n    float u = (dot22 * dot13 - dot12 * dot23) * invDenom;\n    float v = (dot11 * dot23 - dot12 * dot13) * invDenom;\n    vec2 uv = vec2(u, v);\n\n    vec3 col = vec3(0);\n    if ((uv.x >= 0.0) && (uv.y >= 0.0) && (uv.x + uv.y < 1.0)) {\n        //col = vec3(1.0);// flat shading\n        col = vec3(uv.x * uv.x, uv.y * uv.y, 1.0 - uv.x * uv.x  - uv.y * uv.y); // colorful shading wiht artifacts\n        //col = vec3(uv.x, uv.y, 1.0 - uv.x  - uv.y * uv.y);\n    }\n    return col;\n}\n\n\nvec3 ring(float r, vec2 uv, float petals, float triangle_radius) {\n            \n        float a = atan(uv.y, uv.x);\n        a = mod(a, 2.0 * PI / petals); // 6-fold symmetry\n        \n        vec2 suv = vec2(cos(a), sin(a))*r;\n        \n        // Create rosette pattern\n        float da = 2.0 * PI / petals;\n        float ca = cos(da);\n        float sa = sin(da);\n        vec2 rot = vec2(ca, sa);\n\n        vec3 col = vec3(0);\n        for(int i = 0; i < int(petals); ++i) {\n            col = col + drawTriangle(suv, rot, triangle_radius);\n            suv = vec2(dot(suv, rot), dot(suv, vec2(-rot.y, rot.x)));\n        }\n    return col;\n}\n\nvec3 xorTriangles(in vec2 suv0, in vec2 rot0, in float side0, in vec3 col0,\n                  in vec2 suv1, in vec2 rot1, in float side1, in vec3 col1) {\n\n    vec3 cola = drawTriangle(suv0, rot0, side0);\n    vec3 colb = drawTriangle(suv1, rot1, side1);\n    \n    if (cola.x == 0.0) {\n        cola = col0;\n    }\n    \n    if (colb.x == 0.0) {\n        colb = col1;\n    }\n    \n    vec3 col = xorCols(cola, colb);\n    return col;\n\n}\n\n/*\nvec3 xorPolygons(in vec3 polygon0_center, in float polygon0_radius, in int polygon0_sides, in float polygon0_offset,\n                in vec3 polygon1_center, in float polygon1_radius, in int polygon1_sides, in float polygon1_offset,\n                in vec2 uv) {\n    // The color is xor of the polygons surfaces\n    vec3 col = vec3(0);\n\n    // Create polygon 0\n    float a = atan(uv.y - polygon0_center.y, uv.x - polygon0_center.x);\n    a = mod(a, 2.0*3.141598 / float(polygon0_sides)); // 6-fold symmetry\n    vec2 suv = vec2(cos(a), sin(a))*polygon0_radius;\n\n    // Create rosette pattern\n    float da = 2.0*3.141598 / float(polygon0_sides) + polygon0_offset;\n    float ca = cos(da);\n    float sa = sin(da);\n    vec2 rot = vec2(ca, sa);\n\n    // Draw polygon 0\n\n    for(int i = 0; i < polygon0_sides; ++i) {\n        vec2 uv = drawTriangle(suv, rot, 0.1);\n        float u = uv.x;\n        float v = uv.y;\n        if ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) {\n            col = vec3(1.0);\n        }\n        suv = vec2(dot(suv, rot), dot(suv, vec2(-rot.y, rot.x)));\n    }\n\n    // Create polygon 1\n    a = atan(uv.y - polygon1_center.y, uv.x - polygon1_center.x);\n    a = mod(a, 2.0*3.141598 / float(polygon1_sides)); // 6-fold symmetry\n    suv = vec2(cos(a), sin(a))*polygon1_radius;\n    \n    // Create rosette pattern\n    da = 2.0*PI / float(polygon1_sides) + polygon1_offset;\n    ca = cos(da);\n    sa = sin(da);\n    rot = vec2(ca, sa);\n\n    // Draw polygon 1\n    for(int i = 0; i < polygon1_sides; ++i) {\n        vec2 uv = drawTriangle(suv, rot, 0.1);\n        float u = uv.x;\n        float v = uv.y;\n        if ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) {\n            col = vec3(1.0);\n        }\n        suv = vec2(dot(suv, rot), dot(suv, vec2(-rot.y, rot.x)));\n    }\n\n    return col;\n}\n*/\n\nvec3 pick_random_color(vec3 colors[6], in int seed) {\n    //rand();\n    //int idx = int(rand(vec2(iTime, iTime * 2.43243212)) * 6.0);\n    //int idx = int(iTime * float(seed) / 30.0) % 6;\n    return colors[seed % 6];\n\n    //return colors[idx];\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Create a circle\n    float r = length(uv);\n    if(r < 6.0) {\n        //col = ring(r, uv, 6.0, 0.3);\n        //col += ring(r * 2.0, uv, 6.0, 0.3);\n        //col += ring(r * 4.0, uv, 6.0, 0.3);\n\n        \n        float a = atan(uv.y, uv.x);\n        //a = mod(a, 2.0 * PI / petals);\n        vec2 suv = vec2(cos(a), sin(a)) * r;\n        vec2 rot = vec2(cos(2.0 * PI / 6.0), sin(2.0 * PI / 6.0));\n        float side = 1.0;\n\n        vec2 suv2 = vec2(cos(a + PI), sin(a + PI)) * r;\n        vec2 rot2 = vec2(cos(2.0 * PI / 6.0 + PI), sin(2.0 * PI / 6.0 + PI));\n    \n    \n        vec2 rot3 = vec2(1.0, 0);\n        vec2 rot4 = vec2(-1.0, 0);\n        \n        /* Repeating inner pattern\n        vec3 col0 = xorTriangles(suv, rot3, side, suv, rot4, side);\n        vec3 col1 = xorTriangles(suv, rot3, side * 1.3 / 3.0, suv, rot4, side * 1.3 / 3.0);\n        vec3 col2 = xorTriangles(suv, rot3, side * 3.0 / 1.3, suv, rot4, side * 3.0 / 1.3);\n        col = col0 + col1 + col2;\n        */\n        \n        /*\n        float t0 = sin(iTime);\n        float t1 = cos(iTime);\n        float t2 = sin(cos(iTime));\n        \n        vec3 col0 = xorTriangles(suv, rot3, side * t0, suv, rot4, side * t0);\n        vec3 col1 = xorTriangles(suv, rot3, side * t1 / 3.0, suv, rot4, side * t1 / 3.0);\n        vec3 col2 = xorTriangles(suv, rot3, side * t2 / 2.0, suv, rot4, side * t2 / 2.0);\n        */\n        \n        float t0 = 1.0;\n        float t1 = 1.4;\n        float t2 = 1.5;\n        float t3 = 1.8;\n\n        vec3 turquoise = vec3(71., 224., 204.) / 255.0;\n        vec3 ochre = vec3(239., 192., 102.) / 255.0;\n        vec3 blue = vec3(24., 88., 178.) / 255.0;\n        vec3 green = vec3(10, 81, 51) / 255.0;\n        // make a list with all the colors\n\n        vec3 colors[6];\n        colors[0] = turquoise;\n        colors[1] = ochre;\n        colors[2] = blue;\n        colors[3] = green;\n        colors[4] = vec3(0.);\n        colors[5] = vec3(1.);\n\n        // pick six random colors col00, col01, col10, col11, col20, col21 from truquoise, ochre, blue, green\n        vec3 col00 = pick_random_color(colors, 0);\n        vec3 col01 = pick_random_color(colors, 0);\n        vec3 col10 = pick_random_color(colors, 1);\n        vec3 col11 = pick_random_color(colors, 1);\n        vec3 col20 = pick_random_color(colors, 2);\n        vec3 col21 = pick_random_color(colors, 2);\n        vec3 col30 = pick_random_color(colors, 4);\n        vec3 col31 = pick_random_color(colors, 4);\n        \n        vec3 col0 = xorTriangles(suv, rot3, side * t0, col00,\n                                 suv, rot4, side * t0, col01);\n        vec3 col1 = xorTriangles(suv, rot3, side * t1 / 3.0, col10,\n                                 suv, rot4, side * t1 / 3.0, col11);\n        vec3 col2 = xorTriangles(suv, rot3, side * t2 / 2.0, col20,\n                                 suv, rot4, side * t2 / 2.0, col);\n        vec3 col3 = xorTriangles(suv, rot3, side * t3 / 1.2, col30,\n                                 suv, rot4, side * t3 / 1.2, col31);\n        \n        \n        col = xorCols(xorCols(col0, xorCols(col1, col2)), col3);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}