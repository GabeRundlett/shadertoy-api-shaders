{
    "Shader": {
        "info": {
            "date": "1587903759",
            "description": "Thought this looked pretty cool even though it's really simple. :) ",
            "flags": 0,
            "hasliked": 0,
            "id": "tsXBzM",
            "likes": 12,
            "name": "Simple terrain (SS13)",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "terrain",
                "shadersundays"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 1371
        },
        "renderpass": [
            {
                "code": "#define saturate(val) clamp(val, 0.0, 1.0)\n\n/*\n\tShader Sundays! (13/52) \n\t\"Simple Terrain\"\n\t\n\tI've dabled in terrain raymarching before but never did a deep dive on it.\n\tBeen working on that on and off this week and I'm pretty happy with this one even\n\tthough it's so simple. There's something really cool about looking into depth buffers,\n\tso although I did some experiments with more elaborate shading I thought\n\tthis simple colored depth buffer looked pretty interesting already. \n\n\tHere are some sources that I used for this and other cool shaders worth checking out\n\tanyway :\n\n\thttps://www.shadertoy.com/view/ttcSD8 (Swiss alps)\n\thttps://www.shadertoy.com/view/MdX3Rr (Elevated)\n\thttps://www.shadertoy.com/view/MdlGW7 (Cloudy terrain)\n\thttps://www.shadertoy.com/view/ttc3zr (High quality murmur hashes)\n*/\n\n\n//https://www.shadertoy.com/view/ttc3zr\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat\nSmoothNoise(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 fr = fract(uv);\n\n    fr = fr*fr*(3.0 - 2.0*fr);\n\n    float bl = hash12(id);\n    float br = hash12(id + vec2(1.0, 0.0));\n    float b  = mix(bl, br, fr.x);\n\n    float tl = hash12(id + vec2(0.0, 1.0));\n    float tr = hash12(id + vec2(1.0, 1.0));\n    float t  = mix(tl, tr, fr.x);\n\n    return mix(b, t, fr.y);\n}\n\nfloat\nValueNoise(vec2 uv, int octaves)\n{\n    float noise;\n    float totalAmplitude;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n\n    for(int i = 0; i < octaves; ++i)\n    {\n        totalAmplitude += amplitude;\n        noise += SmoothNoise(uv * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude /= 2.0;\n    }\n\n    return noise / totalAmplitude;\n}\n\nmat3\nSetCamera(vec3 eye, vec3 target, float roll)\n{\n    vec3 i, j, k, temp;\n\n    k = normalize(target - eye);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    i = normalize(cross(temp, k));\n    j = cross(k, i);\n\n    return mat3(i, j, k);\n}\n\n#define HI_LOD 8\n#define LO_LOD 2\nfloat\nterrain(vec3 p)\n{\n    return p.y - ValueNoise(p.xz, HI_LOD);\n}\n\n// I know I could change MAX_STEPS and remove the weird haze when you get close to the ground\n// but I like it :)\n#define MAX_STEPS 23\n#define MAX_DIST 20.0\n#define MIN_DIST 0.01\nfloat\nintersectTerrain(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++ i)\n    {\n        float hit = terrain(ro + t*rd);\n\t\t\n        //Some fancy inigo thing I don't fully understand yet\n        //\tif ray is partially in it's still cool?\n        //\twe make the min distance larger when further away?\n        //  Optimization or stylistic thing?\n        if(abs(hit) < MIN_DIST *t)break;\n\n        t += hit;\n    }\n    return t;\n}\n\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    vec3 col;\n\t\n    //Raymarching the terrain\n    float t = intersectTerrain(ro, rd);\n    \n    //Simple shading\n    col += t / 9.80665; // :) \n    col *= vec3(0.78, 0.9, 1.0);\n\n    return saturate(col);\n}\n\n#define INV_GAMMA 0.45454545\n#define ONE(val) (val * 0.5 - 0.5)\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Camera Setup\n    float nearp = 1.0;\n    float roll = 0.0;\n    vec3 ta = vec3(0.0 + iTime, 0.0, 0.0);\n    vec3 ro = ta + vec3(0.0, 2.0 + 1.25*ONE(sin(iTime / 5.0)) , -abs(10.0*sin(iTime / 30.0)));\n    vec2 uv = ((fragCoord) - 0.5*iResolution.xy)/iResolution.y;\n    mat3 cam = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearp));\n\n    vec3 col = Render(ro, rd);\n    \n    //Noise debug\n    //col = vec3(hash12(uv));\n    //col = vec3(SmoothNoise(uv * 20.0));\n    //col = vec3(ValueNoise(uv* 2.0 + iTime, 8));\n\t\n    col = pow(col, vec3(1.0 / (0.65)));\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}