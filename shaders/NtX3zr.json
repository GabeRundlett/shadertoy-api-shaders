{
    "Shader": {
        "info": {
            "date": "1621485837",
            "description": "Color is combined using only xor. You can enable a Conway's Game of Life version of microbes but I couldn't get it to look very good.",
            "flags": 32,
            "hasliked": 0,
            "id": "NtX3zr",
            "likes": 7,
            "name": "microbial life",
            "published": 3,
            "tags": [
                "2d",
                "xor",
                "twotone"
            ],
            "usePreview": 0,
            "username": "pugbyte",
            "viewed": 327
        },
        "renderpass": [
            {
                "code": "// Toggle primary effects\n#define CIRCLE_FILTER 1\n#define SPLIT_FILTER 1\n#define LENS_FILTER 0\n#define LENS_ANIMATE_DISTORTION 1\n\n// Display gradient showing lens distortion curve\n#define LENS_DEBUG 0\n\n// Lens zoom reveals basic dots darting around\n#define MICROBES_PARTICLE 1\n\n// Lens zoom reveals microbes found in Game of Life\n// Notes:\n//   1) it looks bad\n//   2) the seed is bad\n//   3) resizing window messes it up\n#define MICROBES_GAME_OF_LIFE 0\n\n// Displays raw Buffer A contents which contains the Game of Life simulation\n#define GAME_OF_LIFE_DEBUG 0\n\n#define PI 3.14159\n#define TAU (2.*PI)\n\nmat2 rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat circle(vec2 uv, vec2 p, float r) {\n  return 1.0-step(r, length(uv - p));\n}\n\n// uv from 0 to 1\nint texel(vec2 uv) {\n    return int(step(0.5, texture(iChannel2, uv).x));\n}\n\nfloat screen_filter(vec2 uv, float t, float wiggle_displacement) {\n    vec2 filter_pos = vec2(sin(t*0.13), cos(t*0.13))*0.4;\n    float filter_radius = clamp(sin(t*0.1)*1.5, 0., 2.);\n    \n    float wiggle_amount = mix(0.0, wiggle_displacement, smoothstep(0.00, 0.07, filter_radius));\n    \n    return circle(uv, filter_pos, filter_radius+wiggle_amount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.yy;\n    uv *= 1.0;\n    \n    // Test Game of Life\n#if GAME_OF_LIFE_DEBUG\n    uv = fragCoord / iResolution.xy;\n    fragColor = vec4(texture(iChannel2, uv).x,0.,0.,1.);\n    return;\n#endif\n    \n    // Rotation is sickening\n    //uv *= rot(mix(0.0, 0.3, sin(t*0.1)));\n    \n    // Softly zoom\n    uv *= mix(0.85, .7, sin(t*0.1));\n\n    // Color is set exclusively (pun intended) using xor.\n    int b = 1;\n    \n    vec2 p = vec2(sin(t*0.2), cos(t*0.2));\n    \n    //float lens_radius = 0.19;\n    float lens_radius = 0.4;\n    vec2 lens_pos = vec2(-0.1)+p*-0.2;\n    \n    int lens = int(circle(uv, lens_pos, lens_radius));\n    b ^= lens;\n    \n    // Outer ring\n    b ^= int(circle(uv, lens_pos, lens_radius+0.04));\n    \n    vec2 bp = vec2(sin(t), cos(t));\n    \n    if (lens > 0) {\n        // Coordinates centered around lens\n        vec2 cuv = uv - lens_pos;\n        \n        // Distance from edge: 0 on edge, 1 center\n        float dist = length(uv - lens_pos);\n        float nd = 1.0 - clamp(dist, 0., lens_radius)/lens_radius;\n        \n        float curve = 1.0 - pow(abs(nd-1.), 5.);\n\n#if LENS_ANIMATE_DISTORTION\n        // Animate the lens distortion\n        curve *= clamp(sin(t*0.5)*2.0+0.5, 0., 1.);\n#endif\n\n#if LENS_DEBUG\n        // Test lens curve\n        fragColor = vec4(0.,curve,0.,1.);\n        return;\n#endif\n        \n        cuv *= mix(1.0, 0.4, curve);\n        cuv += lens_pos;\n        \n        \n        b ^= int(circle(cuv, bp*0.21, texture(iChannel0, cuv).x ));\n        b ^= int(circle(cuv, bp*0.22, texture(iChannel0, cuv).y ));\n        \n#if MICROBES_GAME_OF_LIFE\n        // Microbes using Conway's Game of Life (not happy with it)\n        int microbe = texel(cuv / lens_radius * 0.5 + 0.5) * int(step(0.01, curve));\n        // Vary the percent of microbe texture that is visible based on curve.\n        // This prevents all microbes from popping into existance at once.\n        microbe *= int(step( 1.0-curve, mod(cuv, 0.0001) / 0.0001 ));\n        \n        b ^= microbe;\n#endif\n        \n#if MICROBES_PARTICLE\n        // Microbes using circles\n        for (int i = 0; i < 100; i ++) {\n            \n            // Slow down time for microbes\n            float mt = t * 0.003;\n            \n            float muvx = sin(mt+float(i)+203.);\n            float muvy = cos(mt+float(i));\n            \n            // Offset in the range -1 to 1\n            vec2 microbe_offset = vec2(\n                texture(iChannel1, vec2(muvx)).x,\n                texture(iChannel1, vec2(muvy)).y\n            ) * 2.0 - 1.0;\n            \n            // Stretch so they fill the lense\n            microbe_offset *= lens_radius;\n            \n            b ^= int(circle(cuv, lens_pos + microbe_offset, 0.001));\n        }\n#endif\n        \n    } else {\n        b ^= int(circle(uv, bp*0.21, texture(iChannel0, uv).x ));\n        b ^= int(circle(uv, bp*0.22, texture(iChannel0, uv).y ));\n    }\n    \n    float wiggle_displacement = texture(iChannel0, vec2(t*0.007,uv.y*0.1)).x*0.05;\n    \n#if LENS_FILTER\n    // Lens filter\n    float rt = clamp(sin(t*.1)*2.+0.5, 0., 1.);\n    float lens_filter_radius = lens_radius * rt;\n    b ^= int(circle(uv, lens_pos, lens_filter_radius));\n#endif\n\n#if CIRCLE_FILTER\n    //TODO: screen filter should expand white, then expand black, etc. never shrink\n    b ^= int(screen_filter(uv, t, wiggle_displacement));\n#endif\n\n#if SPLIT_FILTER\n    // Screen split filter\n    float split_offset = sin(t*0.2)*1.5;\n    b ^= int(step(split_offset+wiggle_displacement*1.5, uv.x));\n#endif\n\n    vec3 col = mix(vec3(0.9), vec3(0.1), float(b));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "int texel(vec2 pos) {\n    return int(step(0.5, texelFetch(iChannel0, ivec2(pos), 0).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // This cell\n    int cell = texel(fragCoord + vec2(0, 0));\n    \n    int ms = int(floor(iTime * 1000.0));\n\n    if (iFrame == 0) {\n        // Initialize the microbes\n        float v = texture(iChannel1, uv).x;\n        fragColor = vec4(step(0.5, v),0.0,0.0,1.0);\n        return;\n    //} else if ((ms % 100) > 0) {\n    } else if (iFrame % 10 > 0) {\n        fragColor = vec4(cell,0.0,0.0,1.0);\n        return;\n    }\n    \n    // Check neighbors\n    int sum;\n    \n    sum += texel(fragCoord + vec2(-1, 1));\n    sum += texel(fragCoord + vec2(-1, 0));\n    sum += texel(fragCoord + vec2(-1, -1));\n    \n    sum += texel(fragCoord + vec2(0, 1));\n    //sum += cell;\n    sum += texel(fragCoord + vec2(0, -1));\n    \n    sum += texel(fragCoord + vec2(1, 1));\n    sum += texel(fragCoord + vec2(1, 0));\n    sum += texel(fragCoord + vec2(1, -1));\n    \n    int next;\n    \n    if (cell == 1 && sum < 2) {\n        next = 0;\n    } else if (cell == 1 && sum > 3) {\n        next = 0;\n    } else if (cell == 0 && sum == 3) {\n        next = 1;\n    } else {\n        next = cell;\n    }\n    \n    \n    fragColor = vec4(next,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}