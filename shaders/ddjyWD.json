{
    "Shader": {
        "info": {
            "date": "1687735394",
            "description": "Using a xor of triangles technique discussed in https://www.shadertoy.com/view/mdsyWf",
            "flags": 0,
            "hasliked": 0,
            "id": "ddjyWD",
            "likes": 5,
            "name": "Zillij inspired mosaic",
            "published": 3,
            "tags": [
                "xor",
                "mosaic",
                "geometric",
                "zillij"
            ],
            "usePreview": 0,
            "username": "etdeagle",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535897932384626433832795;\n\nvec3 xorCols(vec3 col0, vec3 col1) {\n    vec3 col = vec3(int(col0.x * 255.0) ^ int(col1.x * 255.0),\n    int(col0.y * 255.0) ^ int(col1.y * 255.0),\n    int(col0.z * 255.0) ^ int(col1.z * 255.0));\n    return col / 255.0;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec3 rgb_to_hsl(vec3 rgb) {\n    vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n    float fmin = min(min(rgb.r, rgb.g), rgb.b);    //Min. value of RGB\n    float fmax = max(max(rgb.r, rgb.g), rgb.b);    //Max. value of RGB\n    float delta = fmax - fmin;             //Delta RGB value\n\n    hsl.z = (fmax + fmin) / 2.0; // Luminance\n\n    if (delta == 0.0)\t\t//This is a gray, no chroma...\n    {\n        hsl.x = 0.0;\t// Hue\n        hsl.y = 0.0;\t// Saturation\n    }\n    else                                    //Chromatic data...\n    {\n        if (hsl.z < 0.5)\n            hsl.y = delta / (fmax + fmin); // Saturation\n        else\n            hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n        float deltaR = (((fmax - rgb.r) / 6.0) + (delta / 2.0)) / delta;\n        float deltaG = (((fmax - rgb.g) / 6.0) + (delta / 2.0)) / delta;\n        float deltaB = (((fmax - rgb.b) / 6.0) + (delta / 2.0)) / delta;\n\n        if (rgb.r == fmax)\n            hsl.x = deltaB - deltaG; // Hue\n        else if (rgb.g == fmax)\n            hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n        else if (rgb.b == fmax)\n            hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n        if (hsl.x < 0.0)\n            hsl.x += 1.0; // Hue\n        else if (hsl.x > 1.0)\n            hsl.x -= 1.0; // Hue\n    }\n\n    return hsl;\n}\n\n\nvec3 drawTriangle(in vec2 suv, in vec2 rot, in float side) {\n\n    // Create triangle vertices in local coordinates\n    float height = sqrt(side * side - (side * side / 4.0));\n    vec2 p1 = vec2(-side / 2.0, 0);\n    vec2 p2 = vec2(0, height);\n    vec2 p3 = vec2(side / 2.0, 0);\n\n    // Rotate and translate vertices\n    /*p1 = vec2(dot(p1, rot), dot(p1, vec2(-rot.y, rot.x)));\n    p2 = vec2(dot(p2, rot), dot(p2, vec2(-rot.y, rot.x)));\n    p3 = vec2(dot(p3, rot), dot(p3, vec2(-rot.y, rot.x)));*/\n\n\n    p1 = vec2(p1.x * rot.x - p1.y * rot.y, p1.x * rot.y + p1.y * rot.x);\n    p2 = vec2(p2.x * rot.x - p2.y * rot.y, p2.x * rot.y + p2.y * rot.x);\n    p3 = vec2(p3.x * rot.x - p3.y * rot.y, p3.x * rot.y + p3.y * rot.x);\n\n    // Compute barycentric coordinates\n    /*vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1;*/\n    \n     vec2 barycenter = (p1 + p2 + p3) / 3.0;\n    \n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    vec2 v3 = suv - p1 + barycenter;\n    \n    \n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float dot13 = dot(v1, v3);\n    float dot22 = dot(v2, v2);\n    float dot23 = dot(v2, v3);\n    float invDenom = 1.0 / (dot11 * dot22 - dot12 * dot12);\n    float u = (dot22 * dot13 - dot12 * dot23) * invDenom;\n    float v = (dot11 * dot23 - dot12 * dot13) * invDenom;\n    vec2 uv = vec2(u, v);\n\n    vec3 col = vec3(0);\n    if ((uv.x >= 0.0) && (uv.y >= 0.0) && (uv.x + uv.y < 1.0)) {\n        // col = vec3(uv.x, uv.y, 1.0 - uv.x  - uv.y * uv.y);\n\n        float t1 = uv.x;// * 2.0  + uv.y;\n        float t2 = uv.y;// * 2.1 + uv.x;\n\n        float x = (1.0 + pow(sin(t1 * sin(t1 * 8.0) + pow(sin(t1 * t1), 1.) * 5.0), 2.0)) / 2.0;\n        float y = (1.0 + cos(cos(t2) * 18.0)) / 2.0;\n        float z = 1.0 - x * x - y * x;\n        //col = rgb_to_hsl(vec3(x + y * x + z * x / 3.0 + z / 2.0, 0.7, x * y + y * z));\n        //col = rgb_to_hsl(vec3(uv.x, uv.y, 1.0 - uv.x - uv.y));\n        //col = vec3(uv.x, uv.y, 1.0 - uv.x - uv.y);\n        col = vec3(1.0);\n    }\n    return col;\n}\n\n\n\nvec3 xorTriangles(in vec2 suv0, in vec2 rot0, in float side0, in vec3 col0,\n                  in vec2 suv1, in vec2 rot1, in float side1, in vec3 col1) {\n\n    vec3 cola = drawTriangle(suv0, rot0, side0);\n    vec3 colb = drawTriangle(suv1, rot1, side1);\n    \n    if (cola.x == 0.0) {\n        cola = col0;\n    }\n    \n    if (colb.x == 0.0) {\n        colb = col1;\n    }\n    \n    vec3 col = xorCols(cola, colb);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Create a circle\n    float r = length(uv);\n    if(r < 6.0) {\n        float a = atan(uv.y, uv.x);\n        vec2 suv = vec2(cos(a), sin(a)) * r;\n        vec2 rot = vec2(cos(2.0 * PI / 6.0), sin(2.0 * PI / 6.0));\n        float side = 1.2;\n        vec2 rot3 = vec2(1.0, 0);\n        vec2 rot4 = vec2(-1.0, 0);\n\n\n        float t0 = 1.0;\n        float t1 = 1.4;\n        float t2 = 1.5;\n        float t3 = 1.8;\n\n        vec3 turquoise = vec3(71., 224., 204.) / 255.0;\n        vec3 ochre = vec3(239., 192., 102.) / 255.0;\n        vec3 blue = vec3(24., 88., 178.) / 255.0;\n        vec3 green = vec3(10, 81, 51) / 255.0;\n        // make a list with all the colors\n\n        vec3 colors[6];\n        // some nice colors to swap arounc\n        colors[0] = vec3(0.14461228,0.15513487,0.27088341);\n        colors[1] = vec3(0.87665264,0.56123238,0.49973392);\n        colors[2] = vec3(0.06986726,0.44971911,0.75165264);\n        colors[3] = vec3(1.00000000,0.85636869,0.50259627);\n        colors[4] = vec3(0.97761418,0.93624878,0.73902827);\n        colors[5] = vec3(0.16251525,0.29011418,0.25204154);\n\n        // pick six random colors col00, col01, col10, col11, col20, col21 from truquoise, ochre, blue, green\n        vec3 col00 = vec3(0.14461228,0.15513487,0.27088341);\n        vec3 col01 = vec3(0.14461228,0.15513487,0.27088341);\n\n\n\n        vec3 colx = vec3(0.00000000,0.00000000,0.00000000);\n        int rings =5;\n        int ngon = 4;\n        side = 0.9;\n        for(int i = 0; i < rings; i++) {\n            t0 = 0.4+float(i) / 3.0;\n\n            for(int j = 0; j < ngon ; j++) {\n                vec2 localRot = vec2(cos(float(j) * 2.0 * PI / float(ngon)), sin(float(j) * 2.0 * PI / float(ngon)));\n                colx = xorCols(colx, xorTriangles(suv, rot3, side * t0, col00,\n                                                  suv, localRot, side * t0, col01));\n            }\n        }\n        col = colx;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}