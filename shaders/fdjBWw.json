{
    "Shader": {
        "info": {
            "date": "1646763409",
            "description": "texcoord sprite effect.\nrecord or edit it for you game sprite.\nIt's bad performance to normalize each one.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdjBWw",
            "likes": 13,
            "name": "texcoord / 3d sprite effect",
            "published": 3,
            "tags": [
                "sprite",
                "texcoord",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "cxm",
            "viewed": 3560
        },
        "renderpass": [
            {
                "code": "\n#define scale 1.\n#define count 100\n#define time iTime\n\n#define PI 3.1415926\n#define TAU 6.2831852\n\nconst float speed = .1;\n\nmat2 _rot1(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c,s,-s,c);\n}\n\n\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat getPrint( in vec2 uv, float rot, float size, float idx ){\n\n    float p = 0.;\n\n    uv -= .5;\n    uv *= _rot1( rot * .1 + ( idx * 3.1415926 *  .25 ) - fract( iTime * speed ) * TAU + 5. );\n    uv += .5;\n\n\n    float r = hashOld33( vec3( cos( fract( iTime * speed ) * TAU ), sin( fract( iTime * speed ) * TAU ), cos( fract( iTime * speed ) * TAU ) ) ).r;\n\n    vec2 bUv = uv;\n\n    float my =  .5 * 1. - cos( rot + r ) * .001;\n\n    // mix blobs, or change color\n    float g = ( 1. - abs( bUv.x - my ) * sin( idx / 70. ) * idx / float( count ) * 50. );\n\n    // g = max( 0.1, g );\n\n    p = 1. - smoothstep( 0., .1 * size * abs( cos( rot ) ) * 1., distance( uv, vec2( my + sin( fract( iTime * speed ) * TAU ) * .01, .2 + sin( rot ) * -.05 * cos( fract( iTime * speed ) * TAU ) ) ) );\n\n    p *= g;\n    \n    return p;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n\n    float resRa = ( iResolution.x / iResolution.y );\n    uv.x -= ( iResolution.x - iResolution.y ) / iResolution.y * .5;\n\n\n    // Time varying pixel color\n    vec3 col = vec3( 0. );\n    \n    float p = .0;\n    \n    float t = iTime * 5.;\n\n\n    for( int i = 0; i < count; i++ ){\n        p = getPrint( uv, t * float( i ) / float( count ), atan( 1., cos( float( i ) * cos( fract( iTime * speed ) * TAU ) * .1 ) ), float( i ) );\n\n        col = mix(\n            col,\n            // colors[ int(mod( float(i), 7. )) ] * float( i ) / float( count ),\n            vec3( 1. ) * float( i ) / float( count ) * 1.1,\n            p\n        );\n\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}