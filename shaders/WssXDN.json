{
    "Shader": {
        "info": {
            "date": "1551644364",
            "description": "just playin",
            "flags": 0,
            "hasliked": 0,
            "id": "WssXDN",
            "likes": 3,
            "name": "RaybowMarching",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf"
            ],
            "usePreview": 0,
            "username": "paz7",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "#define MXDIST 1000.\n#define MXSTEPS 10000\n#define ACCURACY 0.001\n\nfloat testDistance(vec3 p){\n    float result = opRep(p,vec3(2),mix(1.05,1.56,(sin(iTime*1.75)+1.)/2.));\n    return result;\n}\n\nfloat rayMarch(vec3 p, vec3 d){\n\tfloat dist=0.;\n    for(int i = 0;i<MXSTEPS;i++){\n        vec3 point = p + d*dist;\n        float dtest = testDistance(point);\n        dist += dtest;\n        if(dtest<ACCURACY||dist>MXDIST) break;\n    }\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n\tfloat d = testDistance(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        testDistance(p-e.xyy),\n        testDistance(p-e.yxy),\n        testDistance(p-e.yyx));\n    return normalize(n);\n}\n\nfloat getLight(vec3 p){\n\tvec3 lightPos = vec3(1,1,iTime/2.+1.);\n    vec3 l = normalize (lightPos - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    float d = rayMarch(p+n*ACCURACY*2.,l);\n    if(d<length(lightPos-p)) dif *= .75;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y/.25;\n    vec3 rOrigin = vec3(1,1,iTime/2.);\n    vec3 rDir = normalize(vec3(uv.x,uv.y,1.));\n    float d = rayMarch(rOrigin,rDir);\n    vec3 colhue = hsv2rgb(vec3(d*.45,1,1));\n    vec3 p = rOrigin + rDir*d;\n    float dif = getLight(p);\n\td = clamp(d,0.,d);\n    d*=.15;\n    d=.77/(d*d);\n    d = clamp(d,0.,1.);\n    \n    vec3 col = vec3(dif*colhue);\n    fragColor = vec4(col+(1.-d),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane(float y){\n\treturn y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n   \treturn mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opRep( in vec3 p, in vec3 c,float sr)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return opSmoothSubtraction(sdSphere(q,sr),sdBox(q,vec3(1.)),.09);\n\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}