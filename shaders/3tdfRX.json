{
    "Shader": {
        "info": {
            "date": "1613169249",
            "description": "So originally, I was modelling a temple on this mountain, but it was taking too long so I postponed it. I really like the mountain so I'm releasing it. And the cube is something I made this morning.\n\npress up to toggle zoom.",
            "flags": 16,
            "hasliked": 0,
            "id": "3tdfRX",
            "likes": 13,
            "name": "Cube morphing thing",
            "published": 3,
            "tags": [
                "raymarching",
                "cube",
                "texture",
                "thing",
                "idk",
                "mountain"
            ],
            "usePreview": 0,
            "username": "TheNosiriN",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "\n#define LESS_DETAIL\n\n\n\n\nfloat mountain(vec3 x)\n{\n    vec2 p = x.xz * 0.05;\n    float t = 0.0, a = 1.0;\n    float dist = smoothstep(0.9, 1.0, 1.0-(length(p)-0.1));\n    for (int i=0; i<3; i++){\n        #ifdef LESS_DETAIL\n        float n = (textureLod(iChannel0, p, 2.0).r);\n        #else\n        float n = (textureLod(iChannel0, p, 0.0).r);\n        #endif\n        t += mix(n, dist+n, dist) * a;\n        p = mat2(0.8,-0.6,0.6,0.8)*p*2.0+dist*0.3;\n        a *= 0.5;\n    }\n    return (x.y-t)*0.3;\n}\n\n\nvec3 thing(vec3 p)\n{\n    p *= 0.5;\n    vec3 st;\n    vec3 q = abs(p)-1.5;\n    st.x = max(q.x, q.z); st.y = 2.0;\n    st.x = max(st.x, dot(abs(p.xz)-1.0, normalize(vec2(0.5,0.1)) ))-0.25;\n    st = mind(st, vec3(mountain(p), 1.0, 0.0)); p.y -= 3.0;\n    st.x = max(p.y, st.x);\n    \n    vec3 bd = vec3(MAX_DIST,0,0);\n    vec3 rp = p*1.5; rp.y -= 0.0; rp = abs(rp);\n    \n    //a cube made out of many cubes\n    for (float i=0.0, sc=1.0; i<6.0; i++){\n        rp = abs(rp)-sc/2.0;\n        float ff = sin(iTime*0.1);\n        rp *= mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64)*pow(ff,3.0);\n        bd.x = min(bd.x, max(rp.y,max(rp.x,rp.z)));\n        sc *= 0.6*length(rp) + 0.1;\n        rp *= 1.0/dot(rp,rp);\n    }\n    \n    bd.x = max(max(abs(p.y)-1.5,max(q.x, q.z)+0.5), bd.x);\n    st = mind(st, bd);\n    \n    return maxd(vec3(length(p)-6.0,0,0), st);\n}\n\n\nvec4 raymarch(vec3 eye, vec3 dir)\n{\n    vec3 info = vec3(0);\n    float depth = 0.0, i;\n    for (i=0.0; i<256.0 && depth<MAX_DIST; i++){\n        vec3 p = eye + depth * dir;\n        info = thing(p);\n        if (abs(info.x) < EPSILON * depth)break;\n        depth += info.x * remap(i,0.0,256.0,0.5,1.0);\n    }\n    return vec4(depth, info.yz, i/256.0);\n}\n\n\n\n\nfloat shadow(vec3 eye, vec3 dir) {\n    float res = 1.0;\n    float depth = 0.0;\n    float ph = 1e10;\n    for( float i=0.0; i<32.0 && depth<MAX_DIST; i++ ){\n     \tvec3 p = eye + dir * depth;\n        float h = thing(p).x;\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,depth-y) );\n        depth += h * remap(float(i),0.0,32.0,0.1,1.0);\n        depth += 0.05;\n    }\n\n    return res;\n}\n\n\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * EPSILON;\n \treturn normalize(\n        thing(p+P.xyy).x * \n        P.xyy + thing(p+P.yxy).x * \n        P.yxy + thing(p+P.yyx).x * \n        P.yyx + thing(p+P.xxx).x * \n        P.xxx\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 50.0, h = 5.0;\n    if (!(texelFetch( iChannel1, ivec2(38,2), 0 ).x>0.0)){\n        fov = 20.0, h = 7.0;\n    }\n    \n    vec3 eye = rotateCamera(40.0, iMouse.xy/iResolution.xy, iMouse);\n    \n    vec3 lookAt = vec3(0.0, h, 0.0);\n    vec3 light = normalize(vec3(1.0, 0.25, 1.0));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    float hsh = hash21(fragCoord.xy/iResolution.xy);\n    \n    vec3 col = vec3(0);\n    vec4 dist = raymarch(eye, worldDir);\n    \n    if (dist.x < MAX_DIST){\n        vec3 P = eye + worldDir * dist.x;\n        \n        vec3 N = normal(P);\n        if (dist.y == 1.0){\n            N = triplanarNormal(iChannel0, P, N, 3.0, 1.0, 3.0);\n        }else if (dist.y == 2.0){\n            N = triplanarNormal(iChannel0, P, N, 1.5, 0.7, 3.0);\n        }\n        N = normalize(N+hsh*0.05); //why did I do this? It looks nicer, kinda.\n        \n        float shading = saturate(dot(N, light)*0.5+0.25);\n        shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n        if (shading >= 0.0){ shading *= shadow(P,light); }\n\n        col += (shading+0.1)+(dist.x/MAX_DIST)*0.1;\n        col = mix(col*0.5, col, saturate(1.0-pow(dist.w,3.0)*3.0));\n    }else{\n        col = vec3(0.5);\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float MAX_DIST = 50.0;\nconst float EPSILON = 0.0001;\n\n#define PI 3.1415972\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define hash21(p) (fract(sin(dot(p, p+5373.836))*9272.8363) *2.0-1.0)\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale, float lod)\n{\n    p *= scale;\n    \n    return  (textureLod(tex,p.xy,lod).rgb*n.z*n.z\n            +textureLod(tex,p.zy,lod).rgb*n.x*n.x\n            +textureLod(tex,p.xz,lod).rgb*n.y*n.y);\n}\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale, float lod)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B;\n    B.x = triplanarMap(tex, p+P.xzz, N, scale, lod).r;\n    B.y = triplanarMap(tex, p+P.zxz, N, scale, lod).r;\n    B.z = triplanarMap(tex, p+P.zzx, N, scale, lod).r;\n    B -= triplanarMap(tex, p, N, scale, lod).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n\n\n\n\nfloat remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}