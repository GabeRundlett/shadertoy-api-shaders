{
    "Shader": {
        "info": {
            "date": "1609308863",
            "description": "A reference GLSL implementation of the VRayMtl material",
            "flags": 0,
            "hasliked": 0,
            "id": "WtcyRB",
            "likes": 1,
            "name": "Vraymtl_GLSL",
            "published": 3,
            "tags": [
                "vraymaterialshadervrayglsl"
            ],
            "usePreview": 0,
            "username": "unrealwilson",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "//********************************************************************\n// V-Ray Material Shader\n//\n// Copyright (c) 2020 Chaos Software Ltd\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//********************************************************************\n\nprecision highp float;\n\n#define PI 3.1415926535897932384626433832795\n#define INV_PI 0.31830988618\n#define INV_2PI 0.15915494309\n// A spherical env map affects how the LOD is computed based on normal\n#define ENV_MAP_SPHERICAL 0\n// How many env samples to take - increase for rougher surfaces\n#define NUM_ENV_SAMPLES 8\n// Additional samples added for rough reflection & refraction\n#define NUM_ENV_SAMPLES_ROUGH 16\n// Set to 1 to use a procedural checker environment (useful for local testing)\n#define PROCEDURAL_ENV 1\n\n// Conductor Fresnel values for sheen\n#define SHEEN_N 2.9114\n#define SHEEN_K 3.0893\n\n// color conversion\nvec3 srgb_from_rgb(vec3 rgb) {\n\tvec3 a = vec3(0.055, 0.055, 0.055);\n\tvec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n\tvec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 ginv = 1.0 / g;\n\tvec3 select = step(vec3(0.0031308, 0.0031308, 0.0031308), rgb);\n\tvec3 lo = rgb * 12.92;\n\tvec3 hi = ap1 * pow(rgb, ginv) - a;\n\treturn mix(lo, hi, select);\n}\n\nvec3 rgb_from_srgb(vec3 srgb) {\n\tvec3 a = vec3(0.055, 0.055, 0.055);\n\tvec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n\tvec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 select = step(vec3(0.04045, 0.04045, 0.04045), srgb);\n\tvec3 lo = srgb / 12.92;\n\tvec3 hi = pow((srgb + a) / ap1, g);\n\treturn mix(lo, hi, select);\n}\n\n\n// Engine-specific functions {{{\n// These must be implemented depending on your engine\n// The implementation here is for use in ShaderToy, with env map in iChannel0\n// Note that the TextureEnvMapLOD and EnvIrradiance functions must return linear rgb\n\n// Get maximum lod for texture env\nfloat engGetMaxEnvLOD() {\n\tivec2 envSize = textureSize(iChannel0, 0);\n\tfloat minsz = float(max(envSize.x, envSize.y));\n\treturn log2(minsz);\n}\n\n// Convert Cartesian vector to spherical coordinates\nvec2 toSpherical(vec3 dir) {\n\tfloat alpha, beta;\n\tif (dir.z * dir.z + dir.x * dir.x < 1e-12) {\n\t\talpha = 0.0;\n\t\tbeta = (dir.y > 0.0) ? 0.0 : 1.0;\n\t} else {\n\t\talpha = atan(dir.z, dir.x) * INV_PI;\n\t\tbeta = acos(clamp(dir.y, -1.0, 1.0)) * INV_PI;\n\t}\n\n\tfloat u = alpha * 0.5 + 0.5;\n\tfloat v = beta;\n\treturn vec2(u, v);\n}\n\nvec3 sampleCheckerEnv(vec3 dir) {\n\tvec2 uv = toSpherical(dir);\n\tfloat size = 0.1;\n\tint x = int(floor(uv.x / size));\n\tint y = int(floor(uv.y / size));\n\treturn vec3(1.0 - float((x + y) & 1));\n}\n\n// Sample environment with LOD\nvec3 engTextureEnvMapLOD(vec3 dir, float lod) {\n#if PROCEDURAL_ENV == 1\n\treturn sampleCheckerEnv(dir);\n#else\n    vec3 color;\n#   if ENV_MAP_SPHERICAL\n    vec2 texcoord = toSpherical(dir);\n    texcoord.y = 1.0 - texcoord.y;\n    color = textureLod(iChannel0, texcoord, lod).xyz;\n#   else\n    color = textureLod(iChannel0, dir, lod).xyz;\n#   endif\n    return rgb_from_srgb(color);\n#endif\n}\n\n// Diffuse environment light (averaged over the hemisphere)\nvec3 engEnvIrradiance(vec3 dir) {\n#if PROCEDURAL_ENV == 1\n\treturn sampleCheckerEnv(dir);\n#else\n\tfloat lod = max(0.0, engGetMaxEnvLOD() - 1.0);\n\treturn rgb_from_srgb(textureLod(iChannel0, dir, lod).xyz);\n#endif\n}\n\n/// Get the LOD for sampling the environment\n/// @param Wn World-space normal\n/// @param p Probability of this direction (from sampleBRDF)\n/// @param numSamples Number of environment samples for the BRDF\nfloat computeEnvLOD(vec3 Wn, float p, int numSamples) {\n#if ENV_MAP_SPHERICAL\n\tfloat distortion = sqrt(max(0.0, 1.0 - Wn.y * Wn.y));\n#else\n\tfloat distortion = 1.0;\n#endif\n\tif (numSamples < 2) {\n\t\treturn 0.0;\n\t} else {\n\t\treturn max(0.0, (engGetMaxEnvLOD() - 0.5 * log2(1.0 + float(numSamples) * p * INV_2PI * distortion)));\n\t}\n}\n\n// }}} engine-specific functions\n\nstruct VRayMtlInitParams {\n\tvec3 Vw;\n\tvec3 geomNormal;\n\tvec3 diffuseColor;\n\tfloat diffuseAmount;\n\tfloat roughness;\n\tvec3 selfIllum;\n\tvec3 reflColor;\n\tfloat reflAmount;\n\tfloat reflGloss;\n\tbool traceReflections;\n\tfloat metalness;\n\tfloat aniso;\n\tfloat anisoRotation;\n\tint anisoAxis;\n\tvec3 opacity;\n\tvec3 refractionColor;\n\tfloat refractionAmount;\n\tfloat refrGloss;\n\tbool traceRefractions;\n\tfloat refractionIOR;\n\tbool useFresnel;\n\tfloat fresnelIOR;\n\tbool lockFresnelIOR;\n\tbool doubleSided;\n\tbool useRoughness;\n\tfloat gtrGamma;\n\tint brdfType;\n\tvec3 fogColor;\n\tfloat fogMult;\n\tfloat fogBias;\n\tbool sssOn;\n\tvec3 translucencyColor;\n\tfloat sssFwdBackCoeff;\n\tfloat sssScatterCoeff;\n\tfloat thickness;\n\tfloat distToCamera;\n\tvec3 sheenColor;\n\tfloat sheenAmount;\n\tfloat sheenGlossiness;\n\tvec3 coatColor;\n\tfloat coatAmount;\n\tfloat coatGlossiness;\n\tfloat coatIOR;\n};\n\nstruct VRayMtlContext {\n\tvec3 geomNormal;\n\tfloat gloss1;\n\tfloat roughnessSqr;\n\tfloat reflGloss;\n\tvec3 e;\n\tvec3 diff;\n\tfloat fresnel;\n\tvec3 refl;\n\tvec3 refr;\n\tvec3 illum;\n\tvec3 opacity;\n\tfloat rtermA;\n\tfloat rtermB;\n\tfloat gtrGamma;\n\tfloat fragmentNoise; // per-fragment noise value\n\tmat3 nm;\n\tmat3 inm;\n\tvec3 sheen;\n\tbool hasSheen;\n\tfloat sheenGloss;\n\tvec3 coat;\n\tmat3 coatNM;\n\tfloat coatRoughnessSqr;\n\tbool hasCoat;\n};\n\nvec3 sampleBRDF(VRayMtlInitParams params, VRayMtlContext ctx,\n\t\tint sampleIdx, int nbSamples, out float brdfContrib);\nvec3 sampleRefractBRDF(VRayMtlInitParams params, VRayMtlContext ctx,\n\t\tint sampleIdx, int nbSamples, out bool totalInternalReflection);\n\nVRayMtlContext initVRayMtlContext(VRayMtlInitParams initParams);\n\nvec3 computeDirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\nvec3 computeDirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\nvec3 computeDirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\nvec3 computeDirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\n\nvec3 computeIndirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx);\nvec3 computeIndirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx);\nvec3 computeIndirectRefractionContribution(VRayMtlInitParams params, VRayMtlContext ctx, float alpha, vec3 alphaDir);\nvec3 computeIndirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx);\nvec3 computeIndirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx);\n\nvec3 computeRefractFogContrib(VRayMtlInitParams params, VRayMtlContext ctx, vec3 diffuseContrib);\n\n// utility functions {{{\n\nfloat sqr(float x) {\n\treturn x * x;\n}\n\n// return random number in [0, 1)\nfloat hashRand(vec2 co) {\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// return random vector in [0, 1)\nvec2 rand(VRayMtlContext ctx, int sampleIdx, int nbSamples) {\n\t// fibonacci spiral distribution using the plastic constant\n\tconst float plast = 1.324717957244746;\n\tconst float invPlast = 1.0/plast;\n\treturn vec2(\n\t\tfract(float(sampleIdx + 1) * invPlast),\n\t\tfloat(sampleIdx) / float(nbSamples) + ctx.fragmentNoise\n\t);\n}\n\nfloat intensity(vec3 v) {\n\treturn (v.x + v.y + v.z) / 3.0;\n}\n\nvec3 whiteComplement(vec3 x) {\n\treturn clamp(1.0 - x, 0.0, 1.0);\n}\n\n// }}} end utility functions\n\n/// Compute the two orthogonal vectors to a given input vector\n/// @param n Input vector\n/// @param[out] u The first orthogonal vector\n/// @param[out] v The second orthogonal vector\nvoid computeTangentVectors(vec3 n, out vec3 u, out vec3 v) {\n\t// It doesn't matter what these vectors are, the result vectors just need to be perpendicular to the normal and to\n\t// each other\n\tu = cross(n, vec3(0.643782, 0.98432, 0.324632));\n\tif (length(u) < 1e-6)\n\t\tu = cross(n, vec3(0.432902, 0.43223, 0.908953));\n\tu = normalize(u);\n\tv = normalize(cross(n, u));\n}\n\n/// Make an orthogonal matrix given a surface normal\n/// @param n The normal vector\n/// @param[out] m The output orthogonal matrix with n in the third column\nvoid makeNormalMatrix(in vec3 n, out mat3 m) {\n\tcomputeTangentVectors(n, m[0], m[1]);\n\tm[2] = n;\n}\n\n/// Get the Fresnel reflectance for a dielectric.\n/// @param fresnelIOR Surface index of refraction\n/// @param e View direction\n/// @param n Surface normal\n/// @param refractDir Refracted view direction\n/// @return Fresnel reflectance\nfloat getFresnelCoeff(float fresnelIOR, vec3 e, vec3 n, vec3 refractDir) {\n\tif (abs(fresnelIOR - 1.0) < 1e-6)\n\t\treturn 0.0;\n\n\tfloat cosIn = -dot(e, n);\n\tfloat cosR = -dot(refractDir, n);\n\n\tif (cosIn > 1.0 - 1e-12 || cosR > 1.0 - 1e-12) { // View direction is perpendicular to the surface\n\t\tfloat f = (fresnelIOR - 1.0) / (fresnelIOR + 1.0);\n\t\treturn f * f;\n\t}\n\n\tfloat ks = (cosR / cosIn) * fresnelIOR;\n\tfloat fs2 = (ks - 1.0) / (ks + 1.0);\n\tfloat Fs = fs2 * fs2;\n\n\tfloat kp = (cosIn / cosR) * fresnelIOR;\n\tfloat fp2 = (kp - 1.0) / (kp + 1.0);\n\tfloat Fp = fp2 * fp2;\n\n\treturn 0.5 * (Fs + Fp);\n}\n\n/// Get the Fresnel reflectance for a conductor.\n/// Accurate values for n and k can be obtained from https://refractiveindex.info/\n/// For some conductors the n and k parameters vary with the light wavelength so the\n/// Fresnel reflectance should be computed separately for R,G and B.\n/// @param cosTheta Cosine of the angle between the view direction and the normal\n/// @param n Refractive index\n/// @param k Extinction coefficient\n/// @return Fresnel reflectance.\nfloat getConductorFresnel(float cosTheta, float n, float k) {\n\tfloat c2 = cosTheta * cosTheta;\n\tfloat n2k2 = n * n + k * k;\n\tfloat nc2 = 2.0f * n * cosTheta;\n\tfloat rsa = n2k2 + c2;\n\tfloat rpa = n2k2 * c2 + 1.0f;\n\tfloat rs = (rsa - nc2) / (rsa + nc2);\n\tfloat rp = (rpa - nc2) / (rpa + nc2);\n\treturn 0.5f * (rs + rp);\n}\n\nvec3 getSpecularDir(float u, float v, float k) {\n\tfloat thetaSin = clamp(pow(u, 1.0 / (k + 1.0)), 0.0, 1.0);\n\tfloat thetaCos = sqrt(1.0 - thetaSin * thetaSin);\n\tfloat phi = 2.0 * PI * v;\n\treturn vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n}\n\nvec3 getPhongDir(float uc, float vc, float glossiness, vec3 view, mat3 nm) {\n\tvec3 reflectDir = reflect(-view, nm[2]);\n\tvec3 s = cross(vec3(0, 1, 0), reflectDir);\n\tvec3 s1 = cross(reflectDir, s);\n\tmat3 m;\n\tm[0] = normalize(s);\n\tm[1] = normalize(s1);\n\tm[2] = normalize(reflectDir);\n\tvec3 sampleDir = getSpecularDir(uc, vc, glossiness);\n\treturn m * sampleDir;\n}\n\nvec3 getBlinnDir(float uc, float vc, float glossiness, vec3 view, mat3 nm) {\n\tvec3 nn = getSpecularDir(uc, vc, glossiness);\n\tvec3 h = normalize(nm * nn);\n\tfloat cs = 2.0 * dot(h, view);\n\tvec3 dir = normalize(-view + cs * h);\n\treturn dir;\n}\n\nvec3 getSphereDir(float u, float v) {\n\tfloat thetaSin = u;\n\tfloat thetaCos = sqrt(1.0 - thetaSin * thetaSin);\n\tfloat phi = 2.0 * PI * v;\n\treturn vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n}\n\nvec3 getDiffuseDir(float u, float v) {\n\tfloat thetaSin = sqrt(u);\n\tfloat thetaCos = sqrt(1.0 - u);\n\tfloat phi = 2.0 * PI * v;\n\treturn vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n}\n\nvec3 getWardDir(float u, float v, float glossiness, vec3 view, mat3 nm) {\n\tif (u >= 1.0)\n\t\tu -= 1.0;\n\n\tfloat k = -log(1.0 - u);\n\tif (k < 0.0)\n\t\tk = 0.0;\n\n\tfloat thetaCos = sqrt(1.0 / (glossiness * k + 1.0));\n\tvec3 hn = getSphereDir(thetaCos, v);\n\tvec3 hw = normalize(nm * hn);\n\tvec3 dir = reflect(-view, hw);\n\treturn dir;\n}\n\nvec3 getGTR1MicroNormal(float uc, float vc, float sharpness) {\n\tfloat sharpness2 = min(sharpness * sharpness, 0.999);\n\tfloat thetaCosSqr = (1.0 - pow(sharpness2, 1.0 - uc)) / (1.0 - sharpness2);\n\tfloat thetaCos = sqrt(thetaCosSqr);\n\tfloat thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n\n\tfloat phi = 2.0 * PI * vc;\n\treturn vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n}\n\n// Specific implementation when gamma == 2. See section B.2 Physically-Based Shading at Disney from SIGGRAPH 2012\nvec3 getGTR2MicroNormal(float uc, float vc, float sharpness) {\n\tfloat thetaCosSqr = (1.0 - uc) / (1.0 + (sharpness * sharpness - 1.0) * uc);\n\tfloat thetaCos = sqrt(thetaCosSqr);\n\tfloat thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n\n\tfloat phi = 2.0 * PI * vc;\n\treturn vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n}\n\n// General implementation  when gamma != 1 and != 2. See section B.2 Physically-Based Shading at Disney from SIGGRAPH 2012\nvec3 getGTRMicroNormal(float uc, float vc, float sharpness, float gtrGamma) {\n\tfloat sharpness2 = min(sharpness * sharpness, 0.999);\n\tfloat thetaCosSqr =\n\t\t(1.0 - pow(pow(sharpness2, 1.0 - gtrGamma) * (1.0 - uc) + uc, 1.0 / (1.0 - gtrGamma))) / (1.0 - sharpness2);\n\tfloat thetaCos = sqrt(thetaCosSqr);\n\tfloat thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n\n\tfloat phi = 2.0 * PI * vc;\n\treturn vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n}\n\nvec3 getGGXMicroNormal(float uc, float vc, float sharpness, float gtrGamma) {\n\tif (abs(gtrGamma - 1.0) < 1e-3)\n\t\treturn getGTR1MicroNormal(uc, vc, sharpness);\n\telse if (abs(gtrGamma - 2.0) < 1e-3)\n\t\treturn getGTR2MicroNormal(uc, vc, sharpness);\n\telse // if (gtrLowerLimit <= gtrGamma && gtrGamma <= gtrUpperLimit)\n\t\treturn getGTRMicroNormal(uc, vc, sharpness, gtrGamma);\n}\n\nfloat getGTR1MicrofacetDistribution(float mz, float sharpness) {\n\tfloat cosThetaM = mz; // dotf(microNormal, normal);\n\tif (cosThetaM <= 1e-3)\n\t\treturn 0.0;\n\n\tfloat cosThetaM2 = sqr(cosThetaM);\n\tfloat tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n\tfloat sharpness2 = sqr(sharpness);\n\tfloat div = PI * log(sharpness2) * cosThetaM2 * (sharpness2 + tanThetaM2);\n\t// when div<(sharpness2-1.0)*1e-6 no division by zero will occur (the dividend and the divisor are always negative);\n\t// div can get 0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n\t// and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n\tfloat res = (div < (sharpness2 - 1.0) * 1e-6) ? (sharpness2 - 1.0) / div : 0.0;\n\n\treturn res;\n}\n\nfloat getGTR2MicrofacetDistribution(float mz, float sharpness) {\n\tfloat cosThetaM = mz; // dotf(microNormal, normal);\n\tif (cosThetaM <= 1e-3)\n\t\treturn 0.0;\n\n\tfloat cosThetaM2 = sqr(cosThetaM);\n\tfloat tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n\tfloat sharpness2 = sqr(sharpness);\n\tfloat div = PI * sqr(cosThetaM2 * (sharpness2 + tanThetaM2));\n\t// when div>sharpness2*1e-6 no division by zero will occur (the dividend and the divisor are always positive);\n\t// div canget0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n\t// and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n\tfloat res = (div > sharpness2 * 1e-6) ? sharpness2 / div : 0.0;\n\n\treturn res;\n}\n\nfloat getGTRMicrofacetDistribution(float mz, float sharpness, float gtrGamma) {\n\tfloat cosThetaM = mz; // dotf(microNormal, normal);\n\tif (cosThetaM <= 1e-3)\n\t\treturn 0.0;\n\n\tfloat cosThetaM2 = sqr(cosThetaM);\n\tfloat tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n\tfloat sharpness2 = sqr(sharpness);\n\tfloat divisor =\n\t\tPI * (1.0 - pow(sharpness2, 1.0 - gtrGamma)) * pow(cosThetaM2 * (sharpness2 + tanThetaM2), gtrGamma);\n\tfloat dividend = (gtrGamma - 1.0) * (sharpness2 - 1.0);\n\t// when fabsf(divisor)>fabsf(dividend)*1e-6 no division by zero will occur\n\t// (the dividend and the divisor are always either both positive or both negative);\n\t// divisor canget0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n\t// and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n\tfloat res = (abs(divisor) > abs(dividend) * 1e-6) ? dividend / divisor : 0.0;\n\n\treturn res;\n}\n\nfloat getGGXMicrofacetDistribution(float cosNH, float sharpness, float gtrGamma) {\n\tif (abs(gtrGamma - 1.0) < 1e-3)\n\t\treturn getGTR1MicrofacetDistribution(cosNH, sharpness);\n\telse if (abs(gtrGamma - 2.0) < 1e-3)\n\t\treturn getGTR2MicrofacetDistribution(cosNH, sharpness);\n\telse // if (gtrLowerLimit <= gtrGamma && gtrGamma <= gtrUpperLimit)\n\t\treturn getGTRMicrofacetDistribution(cosNH, sharpness, gtrGamma);\n}\n\nfloat getGTRMonodirectionalShadowing0(float cotThetaV) {\n\treturn 2.0 / (1.0 + sqrt(1.0 + 1.0 / (cotThetaV * cotThetaV)));\n}\n\nfloat getGTRMonodirectionalShadowing1(float sharpness, float cotThetaV) {\n\tfloat cotThetaV2 = sqr(cotThetaV);\n\tfloat sharpness2 = min(0.999, sqr(sharpness));\n\tfloat a = sqrt(cotThetaV2 + sharpness2);\n\tfloat b = sqrt(cotThetaV2 + 1.0);\n\treturn cotThetaV * log(sharpness2) / (a - b + cotThetaV * log(sharpness2 * (cotThetaV + b) / (cotThetaV + a)));\n}\n\nfloat getGTRMonodirectionalShadowing2(float sharpness, float cotThetaV) {\n\treturn 2.0 / (1.0 + sqrt(1.0 + sqr(sharpness / cotThetaV)));\n}\n\nfloat getGTRMonodirectionalShadowing3(float sharpness, float cotThetaV) {\n\tfloat cotThetaV2 = sqr(cotThetaV);\n\tfloat sharpness2 = min(0.999, sqr(sharpness));\n\tfloat a = sqrt(cotThetaV2 + sharpness2);\n\tfloat b = sharpness2 + 1.0;\n\treturn 4.0 * cotThetaV * a * b / (2.0 * cotThetaV * b * (cotThetaV + a) + sharpness2 * (3.0 * sharpness2 + 1.0));\n}\n\nfloat getGTRMonodirectionalShadowing4(float sharpness, float cotThetaV) {\n\tfloat cotThetaV2 = cotThetaV * cotThetaV;\n\tfloat sharpness2 = min(0.999, sqr(sharpness));\n\tfloat sharpness4 = sharpness2 * sharpness2;\n\tfloat a = 8.0 * (sharpness4 + sharpness2 + 1.0);\n\tfloat b = sqrt(cotThetaV2 + sharpness2);\n\tfloat b3 = b * (cotThetaV2 + sharpness2);\n\treturn 2.0 * cotThetaV * a * b3\n\t\t/ (a * cotThetaV * (b3 + cotThetaV * cotThetaV2)\n\t\t   + 3.0 * sharpness2\n\t\t\t   * (4.0 * cotThetaV2 * (2.0 * sharpness4 + sharpness2 + 1.0)\n\t\t\t\t  + sharpness2 * (5.0 * sharpness4 + 2.0 * sharpness2 + 1.0)));\n}\n\nfloat getGGXMonodirectionalShadowing(vec3 dir, vec3 hw, vec3 normal, float sharpness, float gtrGamma) {\n\tfloat cosThetaV = dot(dir, normal);\n\n\tif (cosThetaV <= 1e-3)\n\t\treturn 0.0;\n\n\tif (dot(dir, hw) * cosThetaV <= 0.0) // Note: technically this is a division, but since we are only interested in\n\t\t\t\t\t\t\t\t\t\t // the sign, we can do multiplication\n\t\treturn 0.0;\n\n\t// when direction is collinear to the normal there is no shadowing\n\t// moreover if this case is not handled a division by zero will happen on the next line\n\tif (cosThetaV >= 1.0 - 1e-6)\n\t\treturn 1.0;\n\n\tfloat cotThetaV = cosThetaV / sqrt(1.0 - sqr(cosThetaV));\n\n\tfloat res = 0.0;\n\n\t// when gamma is any of the integer values 0, 1, 2, 3, 4 apply analytical solution\n\tif (gtrGamma <= 0.01)\n\t\tres = getGTRMonodirectionalShadowing0(cotThetaV);\n\telse if (abs(gtrGamma - 1.0) <= 1e-2)\n\t\tres = getGTRMonodirectionalShadowing1(sharpness, cotThetaV);\n\telse if (abs(gtrGamma - 2.0) <= 1e-2)\n\t\tres = getGTRMonodirectionalShadowing2(sharpness, cotThetaV);\n\telse if (abs(gtrGamma - 3.0) <= 1e-2)\n\t\tres = getGTRMonodirectionalShadowing3(sharpness, cotThetaV);\n\telse if (gtrGamma >= 4.0 - 1e-2)\n\t\tres = getGTRMonodirectionalShadowing4(sharpness, cotThetaV);\n\telse {\n\t\t// gamma is not an integer. interpolate\n\t\t// gtrGamma is not an integer. interpolate\n\t\t// If we get here gtrGamma is in (0.01, 3.99).\n\n\t\t// We use a cubic spline curve with 5 knots to evaluate the shadowing, based on the results for integer values.\n\t\t// The original code used a CubicSpline<5> object to construct and evaluate the spline, but Vladimir Nedev\n\t\t// derived a simplified version for Lavina, which is used below.\n\n\t\t// knots[i].x is implicit and is equal to 'i', so we store only knots[i].y in knots[i].\n\t\tfloat knots[5];\n\t\tknots[0]=getGTRMonodirectionalShadowing0(cotThetaV);\n\t\tknots[1]=getGTRMonodirectionalShadowing1(sharpness, cotThetaV);\n\t\tknots[2]=getGTRMonodirectionalShadowing2(sharpness, cotThetaV);\n\t\tknots[3]=getGTRMonodirectionalShadowing3(sharpness, cotThetaV);\n\t\tknots[4]=getGTRMonodirectionalShadowing4(sharpness, cotThetaV);\n\n\t\t// The code that follows is a simplified version of the code for CubicSpline<5> that constructs the spline,\n\t\t// using the fact that the distance between the spline knots in x is always 1.\n\t\t// We also directly compute which polynomial we are going to use instead of binary searching.\n\t\t// From CubicSpline::construct: h[i] = 1\n\t\t// From evalMomentsNatural: m[i] = 4\n\t\t// We compute f, instead of 'c', since 'f' is the argument name of solveTridiagonal.\n\t\t// From solveTridiagonal:\n\t\t// a[i] = h[i] = 1\n\t\t// b[i] = h[i+1] = 1\n\t\t// c[i] = m[i+1] = 4;\n\t\tfloat f[3];\n\t\tf[0]=knots[2]-knots[1]-knots[1]+knots[0];\n\t\tf[1]=knots[3]-knots[2]-knots[2]+knots[1];\n\t\tf[2]=knots[4]-knots[3]-knots[3]+knots[2];\n\n\t\tf[1]-=0.25*f[0];\n\t\tf[2]-=0.26666666666666666666666666666667*f[1];\n\n\t\t// Reuse 'f'.\n\t\tf[2]=f[2]*0.26785714285714285714285714285715;\n\t\tf[1]=(f[1]-f[2])*0.26666666666666666666666666666667;\n\t\tf[0]=(f[0]-f[1])*0.25;\n\n\t\tint i=int(floor(gtrGamma));\n\n\t\tfloat mi=(i>0 ? f[i-1] : 0.0);\n\t\tfloat mi1=(i<3 ? f[i] : 0.0);\n\t\tfloat a=(mi1-mi);\n\t\tfloat b=(3.0*mi);\n\t\tfloat c=(knots[i+1]-knots[i])-(2.0*mi+mi1);\n\t\tfloat d=knots[i];\n\n\t\tfloat x=gtrGamma-float(i);\n\t\tres=((a*x+b)*x+c)*x+d;\n\t}\n\n\treturn clamp(res, 0.0, 1.0);\n}\n\nfloat getGGXBidirectionalShadowingMasking(\n\tvec3 view, vec3 dir, vec3 hw, vec3 normal, float sharpness, float gtrGamma) {\n\treturn getGGXMonodirectionalShadowing(view, hw, normal, sharpness, gtrGamma)\n\t\t* getGGXMonodirectionalShadowing(dir, hw, normal, sharpness, gtrGamma);\n}\n\nfloat getGGXContribution(\n\tvec3 view,\n\tvec3 dir,\n\tvec3 hw,\n\tvec3 hl,\n\tfloat sharpness,\n\tfloat gtrGamma,\n\tvec3 normal,\n\tout float partialProb,\n\tout float D) {\n\tfloat cosIN = abs(dot(view, normal));\n\tfloat cosON = abs(dot(dir, normal));\n\n\tif (cosIN <= 1e-6 || cosON <= 1e-6)\n\t\treturn 0.0;\n\n\tfloat partialBrdf = 0.0;\n\n\tfloat hn = hl.z;\n\tD = getGGXMicrofacetDistribution(hn, sharpness, gtrGamma);\n\t// division by cosON is omitted because we would have to multiply by the same below\n\tpartialBrdf =\n\t\t0.25 * getGGXBidirectionalShadowingMasking(view, dir, hw, normal, sharpness, gtrGamma) / cosIN;\n\n\tif (hn > 0.0) {\n\t\tpartialProb = hn;\n\n\t\tfloat ho = dot(hw, dir);\n\t\tpartialProb *= ho > 0.0 ? 0.25 / ho : 0.0;\n\t}\n\n\t// reduce some multiplications in the final version\n\t// partialBrdf *= cosON; - omitted\n\n\treturn partialBrdf;\n}\n\nvec3 getGGXDir(\n\tfloat u, float v, float sharpness, float gtrGamma, vec3 view, mat3 nm, out float prob, out float brdfDivByProb) {\n\tvec3 microNormalLocal = getGGXMicroNormal(u, v, sharpness, gtrGamma);\n\tif (microNormalLocal.z < 0.0)\n\t\treturn nm[2];\n\n\tvec3 microNormal = nm * microNormalLocal;\n\n\t// Compute and keep the length of the half-vector in local space; needed for anisotropy correction\n\tfloat L2 = dot(microNormal, microNormal);\n\tfloat L = sqrt(L2);\n\tmicroNormal /= L;\n\n\tvec3 dir = reflect(-view, microNormal);\n\n\tfloat Dval = 0.0;\n\tfloat partialProb = 0.0;\n\tfloat partialBrdf =\n\t\tgetGGXContribution(view, dir, microNormal, microNormalLocal, sharpness, gtrGamma, nm[2], partialProb, Dval);\n\tpartialProb *= L * L2; // take anisotropy in consideration\n\tprob = (Dval >= 1e-6) ? partialProb * Dval * 2.0 * PI\n\t\t\t\t\t\t  : 1e18; // compute full probability and apply vray specific corrections\n\tbrdfDivByProb = (partialProb >= 1e-6) ? partialBrdf / partialProb : 0.0;\n\treturn dir;\n}\n\nvec3 sampleBRDF(\n\tVRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\tvec3 geomNormal = params.geomNormal;\n\tfloat ggxTail = params.gtrGamma;\n\tint brdfType = params.brdfType;\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tfloat u = uv.x, v = uv.y;\n\n\tvec3 dir = vec3(0.0);\n\trayProb = 1.0;\n\tbrdfContrib = 1.0;\n\tif (brdfType == 0) {\n\t\tdir = getPhongDir(u, v, ctx.gloss1, -ctx.e, ctx.nm);\n\t} else if (brdfType == 1) {\n\t\tdir = getBlinnDir(u, v, ctx.gloss1, -ctx.e, ctx.nm);\n\t} else if (brdfType == 2) {\n\t\tdir = getWardDir(u, v, ctx.roughnessSqr, -ctx.e, ctx.nm);\n\t} else /* brdfType==3 */ {\n\t\tdir = getGGXDir(u, v, ctx.roughnessSqr, ctx.gtrGamma, -ctx.e, ctx.nm, rayProb, brdfContrib);\n\t}\n\n\tif (dot(dir, geomNormal) < 0.0) {\n\t\tbrdfContrib = 0.0;\n\t}\n\treturn dir;\n}\n\nvec3 sampleCoatBRDF(\n\tVRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\tvec3 geomNormal = params.geomNormal;\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tfloat u = uv.x, v = uv.y;\n\n\tvec3 dir = vec3(0.0);\n\trayProb = 1.0;\n\tbrdfContrib = 1.0;\n\tdir = getGGXDir(u, v, ctx.coatRoughnessSqr, 2.0, -ctx.e, ctx.coatNM, rayProb, brdfContrib);\n\n\tif (dot(dir, geomNormal) < 0.0) {\n\t\tbrdfContrib = 0.0;\n\t}\n\treturn dir;\n}\n\nvec3 sampleRefractBRDF(\n\tVRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out bool totalInternalReflection) {\n\tvec3 geomNormal = params.geomNormal;\n\tvec3 refractDir = refract(ctx.e, geomNormal, 1.0 / params.refractionIOR);\n\ttotalInternalReflection = false;\n\tif (refractDir == vec3(0.0)) {\n\t\trefractDir = reflect(ctx.e, geomNormal);\n\t\ttotalInternalReflection = true;\n\t}\n\n\tvec3 s = cross(vec3(0, 1, 0), refractDir);\n\tvec3 s1 = cross(refractDir, s);\n\tmat3 m;\n\tm[0] = normalize(s);\n\tm[1] = normalize(s1);\n\tm[2] = normalize(refractDir);\n\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tfloat u = uv.x, v = uv.y;\n\tfloat gloss = 1.0 / pow(max(1.0 - params.refrGloss, 1e-4), 3.5) - 1.0;\n\tvec3 sampleDir = getSpecularDir(u, v, gloss);\n\n\treturn m * sampleDir;\n}\n\n/// Sheen BRDF functions based on the Production Friendly Microfacet Sheen BRDF paper\n/// Implementation of the curve fitting polynomial (Table 1 and Section 3)\nfloat sheenP(float a, float b, float c, float d, float e, float x) {\n\treturn a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\n/// Implementation of the lambda curve fitting and interpolation (Table 1 and Section 3)\nfloat sheenL(float x, float roughness) {\n\tfloat a0 = 25.3245;\n\tfloat b0 = 3.32435;\n\tfloat c0 = 0.16801;\n\tfloat d0 = -1.27393;\n\tfloat e0 = -4.85967;\n\tfloat a1 = 21.5473;\n\tfloat b1 = 3.82987;\n\tfloat c1 = 0.19823;\n\tfloat d1 = -1.97760;\n\tfloat e1 = -4.32054;\n\n\tfloat t = (1.0 - roughness) * (1.0 - roughness);\n\tfloat p0 = sheenP(a0, b0, c0, d0, e0, x);\n\tfloat p1 = sheenP(a1, b1, c1, d1, e1, x);\n\treturn t * p0 + (1.0 - t) * p1;\n}\n\n/// Implementation of the lambda term (Section 3)\nfloat sheenLambda(float cosTheta, float roughness) {\n\tif (cosTheta < 0.5) {\n\t\treturn exp(sheenL(cosTheta, roughness));\n\t} else {\n\t\treturn exp(2.0 * sheenL(0.5, roughness) - sheenL(1.0 - cosTheta, roughness));\n\t}\n}\n\n/// Implementation of the full shadowing term (Section 3 and Section 4)\nfloat sheenShadowingMasking(float cosIN, float cosON, float roughness) {\n\tfloat c1 = 1.0 - cosON;\n\tfloat c2 = c1 * c1;\n\tfloat c4 = c2 * c2;\n\tfloat c8 = c4 * c4;\n\tfloat lambdaON = pow(sheenLambda(cosON, roughness), 1.0 + 2.0 * c8);\n\tfloat lambdaIN = sheenLambda(cosIN, roughness);\n\treturn 1.0 / (1.0 + lambdaIN + lambdaON);\n}\n\n/// Implementation of the full sheen BRDF including the cos(N,L) multiplication and \n/// VRay's probability transformation (2pi multiplication)\n/// Glossiness must be in the [0, 1) range. In theory the result is undefined for glossiness = 1\n/// but in practice the highlight disappears and we check for that as soon as we read the glossiness texture.\nfloat sheenProbability(vec3 viewDir, vec3 lightDir, vec3 normal, float glossiness) {\n\tvec3 incomingDir = -viewDir;\n\n\tfloat cosIN = min(1.0, dot(incomingDir, normal));\n\tfloat cosON = min(1.0, dot(lightDir, normal));\n\tif (cosIN <= 1e-6 || cosON <= 1e-6)\n\t\treturn 0.0;\n\n\tfloat roughness = 1.0 - glossiness;\n\tvec3 halfVector = normalize(lightDir - viewDir);\n\n\tfloat cosTheta = clamp(dot(halfVector, normal), 0.0, 1.0);\n\t// This should be fine because we expect theta in [0, pi/2] range and both \n\t// sin(theta) and cos(theta) are non-negative in this case\n\tfloat sinThetaSq = clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0);\n\t// Compute the microfacet distribution (Section 2)\n\t// The 2pi divide is cancelled by VRay's probability transformation\n\tfloat invRoughness = 1.0 / roughness;\n\tfloat D = (2.0 + invRoughness) * pow(sinThetaSq, 0.5 * invRoughness);\n\tfloat G = sheenShadowingMasking(cosIN, cosON, roughness);\n\t// cosON divide will be cancelled by cosON multiplication later so just skip both.\n\tfloat res = 0.25 * D * G / cosIN;\n\treturn res;\n}\n\n/// Size of the sheen albedo LUT\n#define SHEEN_LUT_SIZE 16\n\n/// Directional sheen albedo LUT where the row index corresponds to roughness and the column index corresponds to cosTheta\n/// Conductor Fresnel for wavelength 650nm with n=2.9114 and k=3.0893 (Iron) is used instead of the usual dielectric Fresnel.\n/// Conductor Fresnel inputs taken from https://refractiveindex.info/\n/// It's computed according to Section 2.1.5. in the paper\n/// \"A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling\"\nfloat sheenAlbedoLUT[SHEEN_LUT_SIZE * SHEEN_LUT_SIZE] = float[] (\n\t0.64503, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000,\n\t0.44977, 0.26630, 0.18104, 0.12713, 0.08979, 0.06302, 0.04360, 0.02954, 0.01947, 0.01245, 0.00762, 0.00438, 0.00229, 0.00103, 0.00035, 0.00005,\n\t0.38310, 0.26927, 0.20305, 0.15812, 0.12440, 0.09790, 0.07660, 0.05932, 0.04531, 0.03419, 0.02527, 0.01810, 0.01234, 0.00780, 0.00429, 0.00170,\n\t0.36921, 0.27749, 0.21857, 0.17769, 0.14612, 0.12046, 0.09902, 0.08085, 0.06543, 0.05263, 0.04182, 0.03255, 0.02453, 0.01759, 0.01161, 0.00650,\n\t0.37188, 0.28926, 0.23348, 0.19442, 0.16387, 0.13861, 0.11709, 0.09843, 0.08221, 0.06847, 0.05657, 0.04605, 0.03662, 0.02811, 0.02040, 0.01344,\n\t0.38180, 0.30284, 0.24825, 0.20989, 0.17968, 0.15446, 0.13273, 0.11365, 0.09683, 0.08242, 0.06979, 0.05843, 0.04806, 0.03849, 0.02961, 0.02137,\n\t0.39514, 0.31710, 0.26267, 0.22437, 0.19410, 0.16870, 0.14666, 0.12715, 0.10981, 0.09488, 0.08168, 0.06971, 0.05867, 0.04836, 0.03868, 0.02957,\n\t0.40983, 0.33122, 0.27639, 0.23780, 0.20725, 0.18153, 0.15912, 0.13919, 0.12140, 0.10601, 0.09236, 0.07993, 0.06839, 0.05755, 0.04731, 0.03762,\n\t0.42452, 0.34459, 0.28906, 0.25001, 0.21907, 0.19299, 0.17020, 0.14987, 0.13168, 0.11592, 0.10191, 0.08911, 0.07719, 0.06598, 0.05535, 0.04527,\n\t0.43822, 0.35667, 0.30038, 0.26082, 0.22948, 0.20304, 0.17990, 0.15923, 0.14070, 0.12464, 0.11035, 0.09727, 0.08509, 0.07361, 0.06272, 0.05239,\n\t0.45014, 0.36703, 0.31005, 0.27004, 0.23836, 0.21161, 0.18820, 0.16726, 0.14848, 0.13220, 0.11771, 0.10444, 0.09208, 0.08043, 0.06937, 0.05890,\n\t0.45964, 0.37532, 0.31783, 0.27751, 0.24559, 0.21866, 0.19507, 0.17397, 0.15503, 0.13861, 0.12400, 0.11064, 0.09818, 0.08643, 0.07530, 0.06476,\n\t0.46621, 0.38123, 0.32352, 0.28309, 0.25111, 0.22412, 0.20048, 0.17933, 0.16034, 0.14389, 0.12926, 0.11587, 0.10340, 0.09164, 0.08050, 0.06997,\n\t0.46947, 0.38454, 0.32698, 0.28669, 0.25484, 0.22796, 0.20442, 0.18335, 0.16443, 0.14805, 0.13348, 0.12016, 0.10775, 0.09606, 0.08499, 0.07452,\n\t0.46915, 0.38511, 0.32810, 0.28824, 0.25674, 0.23016, 0.20687, 0.18602, 0.16730, 0.15109, 0.13670, 0.12353, 0.11127, 0.09971, 0.08876, 0.07842,\n\t0.46510, 0.38285, 0.32683, 0.28769, 0.25679, 0.23070, 0.20784, 0.18736, 0.16896, 0.15304, 0.13891, 0.12599, 0.11395, 0.10260, 0.09184, 0.08168\n);\n\n/// Average sheen albedo LUT used to normalize the diffuse scaling factor.\n/// Each element corresponds to a roughness value.\n/// Check Section 2.2. in the paper \"A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling\"\n/// The LUT stores 1 - average albedo as a small optimization for the renderer\nfloat sheenAlbedoAvg[SHEEN_LUT_SIZE] = float[] (\n\t1.00000,\n\t0.97841,\n\t0.96276,\n\t0.94874,\n\t0.93569,\n\t0.92349,\n\t0.91217,\n\t0.90178,\n\t0.89235,\n\t0.88392,\n\t0.87652,\n\t0.87017,\n\t0.86488,\n\t0.86065,\n\t0.85749,\n\t0.85538\n);\n\n/// Sample the sheen albedo LUT for a given incident angle and glossiness\n/// @param cosTheta Cosine of the angle between the incident direction and the surface normal\n/// @param glossiness Sheen glossiness\n/// @return Directional sheen albedo for the given incident angle and glossiness.\nfloat sheenDirectionalAlbedo(float cosTheta, float glossiness) {\n\tfloat roughness = (1.0 - glossiness);\n\tfloat x = cosTheta * float(SHEEN_LUT_SIZE - 1);\n\tfloat y = roughness * float(SHEEN_LUT_SIZE - 1);\n\tint ix = int(x);\n\tint iy = int(y);\n\tint ix2 = clamp(ix + 1, 0, SHEEN_LUT_SIZE - 1);\n\tint iy2 = clamp(iy + 1, 0, SHEEN_LUT_SIZE - 1);\n\tfloat fx = x - float(ix);\n\tfloat fy = y - float(iy);\n\n\tfloat v1 = (1.0 - fx) * sheenAlbedoLUT[iy  * SHEEN_LUT_SIZE + ix] + fx * sheenAlbedoLUT[iy  * SHEEN_LUT_SIZE + ix2];\n\tfloat v2 = (1.0 - fx) * sheenAlbedoLUT[iy2 * SHEEN_LUT_SIZE + ix] + fx * sheenAlbedoLUT[iy2 * SHEEN_LUT_SIZE + ix2];\n\tfloat albedo = (1.0 - fy) * v1 + fy * v2;\n\n\treturn clamp(albedo, 0.0, 1.0);\n}\n\n/// Sample the average sheen albedo from the LUT for a given glossiness value\n/// @param glossiness Sheen glossiness\n/// @return Average sheen albedo for the given glossiness\nfloat getSheenAlbedoAverage(float glossiness) {\n\tfloat roughness = 1.0 - glossiness;\n\tfloat y = roughness * float(SHEEN_LUT_SIZE - 1);\n\tint iy0 = int(y);\n\tint iy1 = clamp(iy0 + 1, 0, SHEEN_LUT_SIZE - 1);\n\tfloat fy = y - float(iy0);\n\tfloat avg0 = sheenAlbedoAvg[iy0];\n\tfloat avg1 = sheenAlbedoAvg[iy1];\n\tfloat albedoAvg = (1.0 - fy) * avg0 + fy * avg1;\n\treturn albedoAvg;\n}\n\n/// Get the partial sheen albedo scaling factor (without the view direction albedo).\n/// Used to dim the diffuse according to section 2.2. in the paper\n/// \"A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling\"\n/// The light direction albedo needs to be computed per light direction but\n/// the view direction albedo can be computed earlier and used to split the samples \n/// between the diffuse and the sheen layer.\n/// @param sheenColor Sheen color\n/// @param cosTheta Cosine of the angle between the light direction and the normal\n/// @param glossiness Sheen glossiness\n/// @return Partial albedo scaling factor\nvec3 getSheenAlbedoLightDim(vec3 sheenColor, float cosTheta, float glossiness) {\n\tfloat albedoLight = sheenDirectionalAlbedo(max(0.0, cosTheta), glossiness);\n\tfloat avgAlbedo = getSheenAlbedoAverage(glossiness); // This is 1 - average albedo\n\t// No need to check the divisor because it's always large enough for this BRDF\n\treturn (1.0 - sheenColor * albedoLight) / avgAlbedo;\n}\n\nvec3 sampleSheenBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\t// Sample the hemisphere uniformly\n\tmat3 localToWorld;\n\tmakeNormalMatrix(ctx.geomNormal, localToWorld);\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tvec3 dir = localToWorld * getSphereDir(uv.x, uv.y);\n\trayProb = INV_2PI;\n\tfloat glossyFresnelCoeff = getConductorFresnel(-dot(ctx.e, normalize(dir - ctx.e)), SHEEN_N, SHEEN_K);\n\tbrdfContrib = sheenProbability(ctx.e, dir, ctx.geomNormal, ctx.sheenGloss);\n\tbrdfContrib *= glossyFresnelCoeff;\n\treturn dir;\n}\n\nvec3 sampleDiffuseBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\t// Sample the hemisphere with cosine distribution\n\tmat3 localToWorld;\n\tmakeNormalMatrix(ctx.geomNormal, localToWorld);\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tvec3 dir = localToWorld * getDiffuseDir(uv.x, uv.y);\n\trayProb = INV_2PI;\n\tbrdfContrib = 1.0;\n\treturn dir;\n}\n\nfloat pow35(float x) {\n\treturn x * x * x * sqrt(x);\n}\n\n/// Blend between a metal color and reflection color based on a dielectric Fresnel value\n/// This approximates the tinted reflection visible in some conductors\n/// @param metalColor Metallic color, currently derived from the diffuse (base) color and the metalness value.\n/// @param reflectionColor The color of the specular highlight\n/// @param fresnel Dielectric fresnel coefficient\n/// @return Blended reflection color.\nvec3 computeMetallicReflection(vec3 metalColor, vec3 reflectionColor, float fresnel) {\n\tvec3 reflectionDim = reflectionColor * fresnel;\n\treturn metalColor * (1.0 - reflectionDim) + reflectionDim;\n}\n\nVRayMtlContext initVRayMtlContext(VRayMtlInitParams initParams) {\n\tfloat reflGloss = initParams.reflGloss;\n\tvec3 Vw = initParams.Vw;\n\tvec3 geomNormal = initParams.geomNormal;\n\tvec3 selfIllum = initParams.selfIllum;\n\tvec3 diffuseColor = initParams.diffuseColor;\n\tfloat diffuseAmount = initParams.diffuseAmount;\n\tvec3 reflColor = initParams.reflColor;\n\tfloat reflAmount = initParams.reflAmount;\n\tbool traceReflections = initParams.traceReflections;\n\tfloat metalness = initParams.metalness;\n\tfloat aniso = initParams.aniso;\n\tfloat anisoRotation = initParams.anisoRotation;\n\tint anisoAxis = initParams.anisoAxis;\n\tvec3 opacity = initParams.opacity;\n\tfloat roughness = initParams.roughness;\n\tvec3 refractionColor = initParams.refractionColor;\n\tfloat refractionAmount = initParams.refractionAmount;\n\tbool traceRefractions = initParams.traceRefractions;\n\tfloat refractionIOR = initParams.refractionIOR;\n\tbool useFresnel = initParams.useFresnel;\n\tfloat fresnelIOR = initParams.fresnelIOR;\n\tbool lockFresnelIOR = initParams.lockFresnelIOR;\n\tbool doubleSided = initParams.doubleSided;\n\tbool useRoughness = initParams.useRoughness;\n\tfloat gtrGamma = initParams.gtrGamma;\n\tint brdfType = initParams.brdfType;\n\tfloat sheenGloss = initParams.sheenGlossiness;\n\tfloat coatGloss = initParams.coatGlossiness;\n\n\tVRayMtlContext result;\n\tif (initParams.lockFresnelIOR)\n\t\tinitParams.fresnelIOR = initParams.refractionIOR;\n\n\tresult.e = -normalize(Vw);\n\t // Invert glossiness (turn it into roughness)\n\tif (useRoughness) {\n\t\treflGloss = 1.0 - reflGloss;\n\t\tcoatGloss = 1.0 - coatGloss;\n\t\tsheenGloss = 1.0 - sheenGloss;\n\t}\n\n\tresult.reflGloss = reflGloss;\n\tresult.opacity = opacity;\n\tresult.diff = diffuseColor * diffuseAmount * result.opacity;\n\tresult.illum = selfIllum * result.opacity;\n\t// roughness\n\tfloat sqrRough = roughness * roughness;\n\tresult.rtermA = 1.0 - 0.5 * (sqrRough / (sqrRough + 0.33));\n\tresult.rtermB = 0.45 * (sqrRough / (sqrRough + 0.09));\n\n\tif (doubleSided && dot(geomNormal, result.e) > 0.0)\n\t\tgeomNormal = -geomNormal;\n\n\tvec3 reflectDir = reflect(result.e, geomNormal);\n\tresult.geomNormal = geomNormal;\n\n\t// check for internal reflection\n\tbool internalReflection;\n\tvec3 refractDir;\n\tbool outToIn = (dot(geomNormal, result.e) < 0.0);\n\tfloat ior = (outToIn ? 1.0 / refractionIOR : refractionIOR);\n\tvec3 normal = (outToIn ? geomNormal : -geomNormal);\n\n\tfloat cost = -dot(result.e, normal);\n\tfloat sintSqr = 1.0 - ior * ior * (1.0 - cost * cost);\n\tif (sintSqr > 1e-6) {\n\t\tinternalReflection = false;\n\t\trefractDir = ior * result.e + (ior * cost - sqrt(sintSqr)) * normal;\n\t} else {\n\t\tinternalReflection = true;\n\t\trefractDir = reflectDir;\n\t}\n\tfloat fresnel = 1.0;\n\tif (useFresnel && !internalReflection)\n\t\tfresnel = clamp(getFresnelCoeff(fresnelIOR, result.e, normal, refractDir), 0.0, 1.0);\n\n\tvec3 reflNoFresnel = reflColor * reflAmount * result.opacity;\n\tresult.refl = reflNoFresnel * fresnel;\n\n\t// Reflection calculation including metalness. Taken from VRayMtl's original implementation.\n\tvec3 metalColor = result.diff * metalness;\n\n\tvec3 dielectricReflectionTransparency = traceReflections ? (1.0 - result.refl) : vec3(1.0);\n\tvec3 reflectionTransparency = (1.0 - metalness) * dielectricReflectionTransparency;\n\tif (traceRefractions) {\n\t\tresult.refr = refractionColor * refractionAmount * result.opacity * reflectionTransparency;\n\t} else {\n\t\tresult.refr = vec3(0.0);\n\t}\n\tresult.diff *= reflectionTransparency - result.refr;\n\n\tresult.refl = computeMetallicReflection(metalColor, reflNoFresnel, fresnel);\n\n\tvec3 sheenColor = initParams.sheenColor * initParams.sheenAmount;\n\tresult.hasSheen = ((sheenColor.x + sheenColor.y + sheenColor.z) > 1e-6) && (1.0 - sheenGloss > 1e-5);\n\tif (result.hasSheen) {\n\t\tfloat albedoView = sheenDirectionalAlbedo(max(0.0, dot(-result.e, geomNormal)), sheenGloss);\n\t\tvec3 sheenViewDim = 1.0 - initParams.sheenColor * albedoView;\n\t\tresult.diff *= sheenViewDim;\n\t\tresult.sheen = initParams.sheenColor * (reflectionTransparency - result.refr);\n\t}\n\n\tresult.hasCoat = (initParams.coatAmount > 1e-6);\n\tif (result.hasCoat && !internalReflection) {\n\t\tfloat coatFresnel = clamp(getFresnelCoeff(initParams.coatIOR, result.e, normal, refractDir), 0.0, 1.0);\n\t\tfloat coatAmount = initParams.coatAmount;\n\t\tvec3 coatColor = initParams.coatColor * (1.0 - coatFresnel);\n\t\tvec3 coatDim = traceReflections ? ((1.0 - coatAmount) + coatAmount * coatColor) : vec3(1.0);\n\t\t// Dim all layers below the coat\n\t\tresult.refl *= coatDim;\n\t\tresult.refr *= coatDim;\n\t\tresult.sheen *= coatDim;\n\t\tresult.diff *= coatDim;\n\t\tmakeNormalMatrix(geomNormal, result.coatNM);\n\t\tresult.coat = vec3(1.0) * initParams.coatAmount * coatFresnel;\n\t}\n\n\tresult.gloss1 = max(0.0, 1.0 / pow35(max(1.0 - reflGloss, 1e-4)) - 1.0); // [0, 1] -> [0, inf)\n\tresult.roughnessSqr = max(1.0 - reflGloss, 1e-4);\n\tresult.roughnessSqr *= result.roughnessSqr;\n\tresult.coatRoughnessSqr = max(1.0 - coatGloss, 1e-4);\n\tresult.coatRoughnessSqr *= result.coatRoughnessSqr;\n\tresult.sheenGloss = sheenGloss;\n\tresult.gtrGamma = gtrGamma;\n\n\t// Set up the normal/inverse normal matrices for BRDFs that support anisotropy\n\tvec3 anisoDirection = vec3(0.0, 0.0, 1.0);\n\tif (anisoAxis == 0)\n\t\tanisoDirection = vec3(1.0, 0.0, 0.0);\n\telse if (anisoAxis == 1)\n\t\tanisoDirection = vec3(0.0, 1.0, 0.0);\n\tfloat anisoAbs = abs(aniso);\n\tif (anisoAbs < 1e-12 || anisoAbs >= 1.0 - 1e-6) {\n\t\tmakeNormalMatrix(geomNormal, result.nm);\n\t\tresult.inm = transpose(result.nm); // inverse = transpose for orthogonal matrix\n\t} else if (!internalReflection) {\n\t\tvec3 base0, base1;\n\t\tbase0 = normalize(cross(geomNormal, anisoDirection));\n\t\tbase1 = normalize(cross(base0, geomNormal));\n\t\tfloat anisor = anisoRotation * 6.2831853;\n\t\tif (abs(anisor) > 1e-6) {\n\t\t\tfloat cs = cos(anisor);\n\t\t\tfloat sn = sin(anisor);\n\t\t\tvec3 nu = base0 * cs - base1 * sn;\n\t\t\tvec3 nv = base0 * sn + base1 * cs;\n\t\t\tbase0 = nu;\n\t\t\tbase1 = nv;\n\t\t}\n\n\t\tif (length(cross(base0, base1)) < 1e-6)\n\t\t\tcomputeTangentVectors(geomNormal, base0, base1);\n\t\tif (aniso > 0.0) {\n\t\t\tfloat a = 1.0 / (1.0 - aniso);\n\t\t\tbase0 *= a;\n\t\t\tbase1 /= a;\n\t\t} else {\n\t\t\tfloat a = 1.0 / (1.0 + aniso);\n\t\t\tbase0 /= a;\n\t\t\tbase1 *= a;\n\t\t}\n\t\tresult.nm[0] = base0;\n\t\tresult.nm[1] = base1;\n\t\tresult.nm[2] = geomNormal;\n\t\tresult.inm = inverse(result.nm);\n\t}\n\n\treturn result;\n}\n\n/// Lambertian BRDF contribution\nvec3 vrayMtlDiffuse(vec3 lightDir, vec3 normal) {\n\treturn vec3(max(0.0, dot(lightDir, normal)));\n}\n\n/// Oren-Nayar BRDF contribution\nvec3 vrayMtlDiffuseRoughness(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat lightNdotL = max(0.0, dot(lightDir, ctx.geomNormal));\n\tfloat rmult = 1.0;\n\tvec3 vecV = -ctx.e;\n\tfloat NV = clamp(dot(ctx.geomNormal, vecV), 0.0, 1.0);\n\tfloat theta_i = acos(lightNdotL);\n\tfloat theta_r = acos(NV);\n\tfloat alpha = max(theta_i, theta_r);\n\tif (alpha > 1.571) { // 1.571==pi/2\n\t\trmult = 0.0;\n\t} else {\n\t\tfloat beta = min(theta_i, theta_r);\n\t\tvec3 vecVtan = vecV - ctx.geomNormal * NV;\n\t\tvec3 vecLtan = lightDir - ctx.geomNormal * lightNdotL;\n\t\tfloat fMult = length(vecVtan) * length(vecLtan);\n\t\tfloat cosDeltaPhi = fMult < 0.000001 ? 1.0 : dot(vecVtan, vecLtan) / fMult;\n\t\trmult = (ctx.rtermA + ctx.rtermB * sin(alpha) * tan(beta) * max(0.0, cosDeltaPhi));\n\t}\n\treturn vec3(lightNdotL * rmult);\n}\n\n/// Blinn BRDF contribution\nvec3 vrayMtlBlinn(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat k = max(0.0, ctx.gloss1);\n\tvec3 hw = lightDir - ctx.e;\n\tvec3 hn = normalize(ctx.inm * hw);\n\tfloat cs1 = hn.z;\n\tif (cs1 > 1e-6) {\n\t\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\t\tif (cs1 > 1.0)\n\t\t\tcs1 = 1.0;\n\t\tfloat cs = -dot(normalize(hw), ctx.e);\n\t\tk = cs < 1e-6 ? 0.0 : pow(cs1, k) * (k + 1.0) * 0.125 / cs;\n\t\tk *= lightNdotL;\n\t\tif (k > 0.0)\n\t\t\treturn vec3(k);\n\t}\n\treturn vec3(0.0);\n}\n\n/// Phong BRDF contribution\nvec3 vrayMtlPhong(vec3 lightDir, VRayMtlContext ctx) {\n\tvec3 reflectDir = reflect(ctx.e, ctx.geomNormal);\n\tfloat cs1 = dot(lightDir, reflectDir);\n\tif (cs1 > 0.0) {\n\t\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\t\tif (cs1 > 1.0)\n\t\t\tcs1 = 1.0;\n\t\tfloat k = pow(cs1, ctx.gloss1) * (ctx.gloss1 + 1.0) * 0.5; // phong k\n\t\tk *= lightNdotL;\n\t\tif (k > 0.0)\n\t\t\treturn vec3(k);\n\t}\n\treturn vec3(0.0);\n}\n\n/// Ward BRDF contribution\nvec3 vrayMtlWard(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat cs1 = -dot(ctx.e, ctx.geomNormal);\n\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\tif (lightNdotL > 1e-6 && cs1 > 1e-6) {\n\t\tvec3 hw = lightDir - ctx.e;\n\t\tvec3 hn = normalize(ctx.inm * hw);\n\t\tif (hn.z > 1e-3) {\n\t\t\tfloat tanhSqr = (1.0 / (hn.z * hn.z) - 1.0);\n\t\t\tfloat divd = cs1 * ctx.roughnessSqr;\n\t\t\tfloat k = exp(-tanhSqr / ctx.roughnessSqr) / divd;\n\t\t\tk *= lightNdotL;\n\t\t\tif (k > 0.0)\n\t\t\t\treturn vec3(k);\n\t\t}\n\t}\n\treturn vec3(0.0);\n}\n\n/// GTR BRDF contribution\nvec3 vrayMtlGGX(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat cs1 = -dot(ctx.e, ctx.geomNormal);\n\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\tif (lightNdotL > 1e-6 && cs1 > 1e-6) {\n\t\tvec3 hw = normalize(lightDir - ctx.e);\n\t\tvec3 hn = normalize(ctx.inm * hw);\n\t\tif (hn.z > 1e-3) {\n\t\t\tfloat D = getGGXMicrofacetDistribution(hn.z, ctx.roughnessSqr, ctx.gtrGamma);\n\t\t\tfloat G =\n\t\t\t\tgetGGXBidirectionalShadowingMasking(-ctx.e, lightDir, hw, ctx.geomNormal, ctx.roughnessSqr, ctx.gtrGamma);\n\t\t\tvec3 micron = ctx.nm * hn;\n\t\t\tfloat L2 = dot(micron, micron);\n\t\t\tfloat anisotropyCorrection = L2 * sqrt(L2);\n\t\t\tfloat k = 0.25 * D * G * anisotropyCorrection * PI / cs1; // anisotropy correction\n\t\t\tif (k > 0.0)\n\t\t\t\treturn vec3(k);\n\t\t}\n\t}\n\treturn vec3(0.0);\n}\n\n/// GGX BRDF contribution that uses the coat layer parameters\nvec3 vrayMtlGGXCoat(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat cs1 = -dot(ctx.e, ctx.geomNormal);\n\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\tif (lightNdotL > 1e-6 && cs1 > 1e-6) {\n\t\tvec3 hw = normalize(lightDir - ctx.e);\n\t\tvec3 hn = normalize(ctx.inm * hw);\n\t\tif (hn.z > 1e-3) {\n\t\t\tfloat D = getGGXMicrofacetDistribution(hn.z, ctx.coatRoughnessSqr, 2.0);\n\t\t\tfloat G = getGGXBidirectionalShadowingMasking(-ctx.e, lightDir, hw, ctx.geomNormal, ctx.coatRoughnessSqr, 2.0);\n\t\t\tvec3 micron = ctx.coatNM * hn;\n\t\t\tfloat k = 0.25 * D * G * PI / cs1;\n\t\t\tif (k > 0.0)\n\t\t\t\treturn vec3(k);\n\t\t}\n\t}\n\treturn vec3(0.0);\n}\n\nvec3 computeRefractFogContrib(VRayMtlInitParams params, VRayMtlContext ctx, vec3 diffuseContrib) {\n\tif (intensity(ctx.diff) < 0.001)\n\t\treturn vec3(0.0);\n\n\tvec3 fogColor = params.fogColor;\n\tfloat fogMult = max(1e-6, params.fogMult);\n\tfloat fogBias = params.fogBias;\n\tif (fogBias > 0.0) {\n\t\tfogBias = 1.0 / (1.0 + fogBias);\n\t} else {\n\t\tfogBias = 1.0 - fogBias;\n\t}\n\n\tfloat fogDist = params.distToCamera * 0.001;\n\tfogDist = pow(fogDist, fogBias);\n\tfogColor = pow(fogColor, vec3(fogMult * fogDist));\n\treturn fogColor * ctx.diff * diffuseContrib;\n}\n\nvec3 computeDirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\tvec3 res = vec3(0.0);\n\tif (params.roughness < 1e-6) {\n\t\tres = vrayMtlDiffuse(lightDir, ctx.geomNormal);\n\t} else {\n\t\tres = vrayMtlDiffuseRoughness(lightDir, ctx);\n\t}\n\n\tif (ctx.hasSheen) {\n\t\tvec3 sheenLightDim = getSheenAlbedoLightDim(params.sheenColor, dot(lightDir, ctx.geomNormal), ctx.sheenGloss);\n\t\tres *= sheenLightDim;\n\t}\n\n\treturn res;\n}\n\nvec3 computeDirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\tvec3 res = vec3(0.0);\n\n\tif (params.brdfType == 0) {\n\t\tres = vrayMtlPhong(lightDir, ctx);\n\t} else if (params.brdfType == 1) {\n\t\tres = vrayMtlBlinn(lightDir, ctx);\n\t} else if (params.brdfType == 2) {\n\t\tres = vrayMtlWard(lightDir, ctx);\n\t} else /* if (params.brdfType==3) */ {\n\t\tres = vrayMtlGGX(lightDir, ctx);\n\t}\n\treturn res;\n}\n\n// Sheen BRDF contribution based on the \"Production Friendly Microfacet Sheen BRDF\" paper\nvec3 computeDirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\tvec3 res = vec3(0.0);\n\n\t// Use fixed IOR for sheen\n\tfloat glossyFresnelCoeff = getConductorFresnel(-dot(ctx.e, normalize(lightDir - ctx.e)), SHEEN_N, SHEEN_K);\n\tfloat k = sheenProbability(ctx.e, lightDir, ctx.geomNormal, ctx.sheenGloss);\n\tres = vec3(k) * glossyFresnelCoeff * 0.5;\n\n\treturn res;\n}\n\nvec3 computeDirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\treturn vrayMtlGGXCoat(lightDir, ctx);\n}\n\nvec3 computeIndirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (ctx.hasSheen) {\n\t\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * 2.0);\n\t\tfloat invNumSamples = 1.0 / float(numSamples);\n\t\tvec3 envSum = vec3(0.0);\n\t\tfor (int i = 0; i < numSamples; ++i) {\n\t\t\tfloat brdfContrib = 0.0;\n\t\t\tfloat rayProb = 0.0;\n\t\t\tvec3 dir = sampleDiffuseBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\t\tvec3 sheenLightDim = getSheenAlbedoLightDim(params.sheenColor, dot(dir, ctx.geomNormal), ctx.sheenGloss);\n\t\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib * sheenLightDim;\n\t\t}\n\t\tres += envSum * invNumSamples;\n\t} else {\n\t\tres = engEnvIrradiance(params.geomNormal);\n\t}\n\n\treturn res;\n}\n\nvec3 computeIndirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceReflections)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * (params.aniso + 0.5 * ctx.roughnessSqr));\n\tif (ctx.roughnessSqr < 0.0001)\n\t\tnumSamples = 1;\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 envSum = vec3(0.0);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tfloat brdfContrib = 0.0;\n\t\tfloat rayProb = 0.0;\n\t\tvec3 dir = sampleBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\tif (brdfContrib < 1e-6)\n\t\t\tcontinue;\n\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib;\n\t}\n\tres += envSum * invNumSamples;\n\n\treturn res;\n}\n\nvec3 computeIndirectRefractionContribution(\n\tVRayMtlInitParams params, VRayMtlContext ctx, float alpha, vec3 alphaDir) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceRefractions)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * params.refrGloss);\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 view = -params.Vw;\n\n\tif (alpha <= 0.999) {\n\t\tres += engTextureEnvMapLOD(alphaDir, 0.0);\n\t} else {\n\t\tvec3 envSum = vec3(0.0);\n\t\tfor (int i = 0; i < numSamples; ++i) {\n\t\t\tbool totalInternalReflection;\n\t\t\tvec3 dir = sampleRefractBRDF(params, ctx, i, numSamples, totalInternalReflection);\n\t\t\tif (totalInternalReflection) {\n\t\t\t\tenvSum += engTextureEnvMapLOD(dir, 0.0);\n\t\t\t} else {\n\t\t\t\tenvSum += engTextureEnvMapLOD(dir, 0.0);\n\t\t\t}\n\t\t}\n\t\tres += envSum * invNumSamples;\n\t\tvec3 diffuseContrib = computeIndirectDiffuseContribution(params, ctx);\n\t\tres += computeRefractFogContrib(params, ctx, diffuseContrib);\n\t}\n\n\treturn res;\n}\n\nvec3 computeIndirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceReflections || !ctx.hasSheen)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * 0.5 * (1.0 - ctx.sheenGloss));\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 envSum = vec3(0.0);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tfloat brdfContrib = 0.0;\n\t\tfloat rayProb = 0.0;\n\t\tvec3 dir = sampleSheenBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\tif (brdfContrib < 1e-6)\n\t\t\tcontinue;\n\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib;\n\t}\n\tres += envSum * invNumSamples;\n\n\treturn res;\n}\n\nvec3 computeIndirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceReflections || !ctx.hasCoat)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * 0.5 * ctx.coatRoughnessSqr);\n\tif (ctx.coatRoughnessSqr < 0.0001)\n\t\tnumSamples = 1;\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 envSum = vec3(0.0);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tfloat brdfContrib = 0.0;\n\t\tfloat rayProb = 0.0;\n\t\tvec3 dir = sampleCoatBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\tif (brdfContrib < 1e-6)\n\t\t\tcontinue;\n\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib;\n\t}\n\tres += envSum * invNumSamples;\n\n\treturn res;\n}\n\n//////////////////////////////////////////////////////////////////////\n// End of VRayMtl implementation.\n// Following code implements a very simple raytracer\n// and sets up the material parameters.\n// You can run it on ShaderToy or with the VSCode Shader Toy plugin\n//////////////////////////////////////////////////////////////////////\n\n\n\n// presets\n\nstruct VRayMtlPreset {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 reflColor;\n\tfloat reflGloss;\n\tfloat metalness;\n\tfloat aniso;\n\tfloat anisoRotation;\n\tint anisoAxis;\n\tvec3 refractionColor;\n\tfloat refrGloss;\n\tfloat refractionIOR;\n\tbool useRoughness;\n\tvec3 fogColor;\n\tfloat fogMult;\n\tvec3 sheenColor;\n\tfloat sheenGlossiness;\n\tvec3 coatColor;\n\tfloat coatAmount;\n\tfloat coatGlossiness;\n};\n\n#define PRESET_COUNT 24\n\nconst VRayMtlPreset gPresets[PRESET_COUNT] = VRayMtlPreset[PRESET_COUNT](\n// aluminium\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9019, 0.9137, 0.9215),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// aluminium (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9019, 0.9137, 0.9215),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.12,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// aluminium (brushed)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9019, 0.9137, 0.9215),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.3,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.8,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 1,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// chrome\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.5529, 0.5529, 0.5529),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.03,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// copper\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9333, 0.6196, 0.5372),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.21901,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// copper (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9333, 0.6196, 0.5372),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.1,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.21901,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// gold\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9529, 0.7882, 0.4078),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.35002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// gold (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9529, 0.7882, 0.4078),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.15,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.35002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// iron\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.8862, 0.8745, 0.8235),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.006,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// lead\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.6549, 0.6588, 0.6901),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.016,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// silver\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9882, 0.9803, 0.9764),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.082,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// silver (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9882, 0.9803, 0.9764),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.11,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.082,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// diamond\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.98,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(1.0, 1.0, 1.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 2.42,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// glass\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.914, 0.914, 0.914),\n/* reflGloss\t   */ 1.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.977, 0.977, 0.977),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.517,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// glass (frosted)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.914, 0.914, 0.914),\n/* reflGloss\t   */ 0.75,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.977, 0.977, 0.977),\n/* refrGloss\t   */ 0.8,\n/* refractionIOR   */ 1.517,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// glass (tinted)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.914, 0.914, 0.914),\n/* reflGloss\t   */ 1.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.977, 0.977, 0.977),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.517,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(0.702, 0.95, 0.702),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// water\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.784, 0.784, 0.784),\n/* reflGloss\t   */ 1.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.333,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// chocolate\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.032, 0.019, 0.009),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.442, 0.442, 0.442),\n/* reflGloss\t   */ 0.68,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.195, 0.195, 0.195),\n/* refrGloss\t   */ 0.6,\n/* refractionIOR   */ 1.59,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// ceramic\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.7764, 0.6941, 0.6352),\n/* roughness\t   */ 0.6,\n/* reflColor\t   */ vec3(0.996, 1.0, 0.988),\n/* reflGloss\t   */ 0.99,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// plastic\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0627, 0.0588, 0.0627),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.9725, 0.9607, 1.0),\n/* reflGloss\t   */ 0.98,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 0.6,\n/* refractionIOR   */ 1.46,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// rubber\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.008, 0.01, 0.01),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.929, 0.975, 1.0),\n/* reflGloss\t   */ 0.472,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.468,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// generic rough white ball\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(1.0, 1.0, 1.0),\n/* roughness\t   */ 1.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// basic sheen\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.25, 0.25, 0.25),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.0, 0.0, 0.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 1.0),\n/* sheenGlossiness */ 0.85,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0,\n/* coatGlossiness  */ 1.0),\n\n// basic coat\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 1.0, 1.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.4,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(1.0, 0.0, 1.0),\n/* coatAmount      */ 1.0,\n/* coatGlossiness  */ 0.95)\n\n); // end presets\n\n// Get the index of the preset to apply\n// @param sweepFactor Number from 0 to 1 used to animate the preset switch with a screen sweep effect. Set to fragCoord.x / iResolution.x\nint getPresetIdx(float sweepFactor) {\n\tconst int totalPresets = PRESET_COUNT;\n\tconst float secsPerPreset = 5.0;\n\tconst float secsSweep = 0.75; // included in secsPerPreset\n\tconst float secsPerCycle = secsPerPreset * float(totalPresets);\n\tfloat cycleTime = mod(iTime, secsPerCycle);\n\tint presetIdx = int((cycleTime + secsSweep * sweepFactor) / secsPerPreset);\n\tif (presetIdx >= totalPresets) {\n\t\tpresetIdx = 0;\n\t}\n\treturn presetIdx;\n}\n\n\nvoid initPresetParams(inout VRayMtlInitParams initParams, float sweepFactor) {\n\tint presetIdx = getPresetIdx(sweepFactor);\n\tif (presetIdx >= 0 && presetIdx < PRESET_COUNT) {\n\t\tinitParams.diffuseColor = gPresets[presetIdx].diffuseColor;\n\t\tinitParams.roughness = gPresets[presetIdx].roughness;\n\t\tinitParams.reflColor = gPresets[presetIdx].reflColor;\n\t\tinitParams.reflGloss = gPresets[presetIdx].reflGloss;\n\t\tinitParams.metalness = gPresets[presetIdx].metalness;\n\t\tinitParams.aniso = gPresets[presetIdx].aniso;\n\t\tinitParams.anisoRotation = gPresets[presetIdx].anisoRotation;\n\t\tinitParams.anisoAxis = gPresets[presetIdx].anisoAxis;\n\t\tinitParams.refractionColor = gPresets[presetIdx].refractionColor;\n\t\tinitParams.refrGloss = gPresets[presetIdx].refrGloss;\n\t\tinitParams.refractionIOR = gPresets[presetIdx].refractionIOR;\n\t\tinitParams.useRoughness = gPresets[presetIdx].useRoughness;\n\t\tinitParams.fogColor = gPresets[presetIdx].fogColor;\n\t\tinitParams.fogMult = gPresets[presetIdx].fogMult;\n\t\tinitParams.sheenColor = gPresets[presetIdx].sheenColor;\n\t\tinitParams.sheenGlossiness = gPresets[presetIdx].sheenGlossiness;\n\t\tinitParams.coatColor = gPresets[presetIdx].coatColor;\n\t\tinitParams.coatAmount = gPresets[presetIdx].coatAmount;\n\t\tinitParams.coatGlossiness = gPresets[presetIdx].coatGlossiness;\n\t}\n}\n\n//Texture normal\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\nfloat somestep(float t)\n{\n    return pow(t, 4.0);\n}\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n//--------------------------------------------------------------------------\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n//Custom BRDFGGX\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n//-------------------------------------------------------------------------------\nvec3 shade(vec3 point, vec3 normal, vec3 eyeDir, float distToCamera, float sweepFactor, float fragmentNoise, vec3 rayDir) {\n\t// Init VRayMtl with defaults\n\tVRayMtlInitParams initParams;\n\tinitParams.Vw = normalize(eyeDir);\n\tinitParams.geomNormal = normal;\n\tinitParams.diffuseColor = vec3(0.5, 0.5, 0.5);\n\tinitParams.diffuseAmount = 1.0;\n\tinitParams.roughness = 0.0;\n\tinitParams.selfIllum = vec3(0);\n\tinitParams.reflColor = vec3(0.5, 0.5, 0.5);\n\tinitParams.reflAmount = 1.0;\n\tinitParams.reflGloss = 1.0;\n\tinitParams.traceReflections = true;\n\tinitParams.metalness = 0.0;\n\tinitParams.aniso = 0.0;\n\tinitParams.anisoRotation = 0.0;\n\tinitParams.anisoAxis = 2;\n\tinitParams.opacity = vec3(1, 1, 1);\n\tinitParams.refractionColor = vec3(0.0, 0.0, 0.0);\n\tinitParams.refractionAmount = 1.0;\n\tinitParams.refrGloss = 1.0;\n\tinitParams.refractionIOR = 1.6;\n\tinitParams.traceRefractions = true;\n\tinitParams.useFresnel = true;\n\tinitParams.fresnelIOR = 1.6;\n\tinitParams.lockFresnelIOR = true;\n\tinitParams.doubleSided = true;\n\tinitParams.useRoughness = false;\n\tinitParams.gtrGamma = 2.0;\n\tinitParams.brdfType = 3;\n\tinitParams.fogColor = vec3(0.0, 0.0, 0.0);\n\tinitParams.fogBias = 0.0;\n\tinitParams.sssOn = false;\n\tinitParams.sheenAmount = 1.0;\n\tinitParams.coatIOR = 1.6;\n\t// unused yet - corresponds to translucency color in SSS\n\tinitParams.translucencyColor = vec3(1.0);\n\tinitParams.sssFwdBackCoeff = 0.0;\n\tinitParams.sssScatterCoeff = 0.0;\n\tinitParams.thickness = 1000.0;\n\tinitParams.distToCamera = distToCamera;\n\tinitPresetParams(initParams, sweepFactor);\n\n    // fresnel\n    float metallic = 0.0;\n    float roughness = step(fract(normal.x * 2.02), 0.5/*surface*/) + 0.6;\n    float fresnel_pow = mix(5.0, 3.5,metallic);\n    float fresnel = max(1.0 - dot(normal,-rayDir), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);\n    //IbL\n    vec3 ibl_diffuse = pow(vec3(texture(iChannel3,normal.xy)), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel0,reflect(rayDir,normal)), vec3(2.2));\n    \n    // Init context and sample material\n\tVRayMtlContext ctx = initVRayMtlContext(initParams);\n\tctx.fragmentNoise = fragmentNoise;\n\tvec3 lightDir = normalize(vec3(1, 1, 0.2));\n\tvec3 diffuseDirect = computeDirectDiffuseContribution(initParams, ctx, lightDir);\n\tvec3 diffuseIndirect = computeIndirectDiffuseContribution(initParams, ctx);\n\tvec3 diffuse = /*diffuseDirect + diffuseIndirect*/pow(textureLod( iChannel3, rayDir.xy,0.0).xyz,vec3(2.2));\n\n    \n\tvec3 reflDirect =  computeDirectReflectionContribution(initParams, ctx, lightDir);\n\tvec3 reflIndirect = computeIndirectReflectionContribution(initParams, ctx);\n\tvec3 reflection = /*reflDirect + reflIndirect*/pow(textureLod( iChannel1, rayDir,0.0).xyz ,vec3(2.2));\n    // reflection\n    reflection = mix(reflection,ibl_reflection,(1.0-fresnel)*roughness);\n    reflection = mix(reflection,ibl_reflection,roughness);\n    \n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 light_color = pow(texture(iChannel0,vec3(1.0,0.0,0.0)).xyz * 1.5, vec3(2.2));\n    vec3 spec = light_color * GGX(normal,-rayDir,light,roughness*0.3, 0.2);\n    reflection -= spec;\n    \n    // diffuse\n    diffuse = ibl_diffuse;\n    diffuse = mix(diffuse,reflection,fresnel);\n    \n\tvec3 sheen = vec3(0.0);\n\tif (ctx.hasSheen) {\n\t\tvec3 sheenDirect = computeDirectSheenContribution(initParams, ctx, diffuse);\n\t\tvec3 sheenIndirect = computeIndirectSheenContribution(initParams, ctx);\n\t\tsheen = sheenDirect + sheenIndirect/*diffuse*/;\n\t}\n\n\tvec3 coat = vec3(0.0);\n\tif (ctx.hasCoat) {\n\t\tvec3 coatDirect = computeDirectCoatContribution(initParams, ctx, diffuse);\n\t\tvec3 coatIndirect = computeIndirectCoatContribution(initParams, ctx);\n\t\tcoat = coatDirect + coatIndirect ;\n\t}\n\t\n\tfloat alpha = intensity(ctx.opacity);\n\tvec3 refraction = computeRefractFogContrib(initParams, ctx, vec3(0.0))\n\t\t+ computeIndirectRefractionContribution(initParams, ctx, alpha, -initParams.Vw);\n        \n    vec3 color = mix(mix(mix(mix(diffuse,reflection ,metallic),refraction*ctx.refr,metallic),sheen*ctx.sheen,metallic),coat * ctx.coat,metallic) + spec;\n    return color;\n    return pow(color, vec3(1.0/2.2));\n    \n\t//return diffuse  + reflection  + refraction * ctx.refr + sheen  + coat * ctx.coat;\n    \n}\n\n\n// simple raytracing of a sphere\nconst float INFINITY = 100000.0;\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n\tvec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt * dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// simple sphere\n\tfloat wh = min(iResolution.x, iResolution.y);\n\tvec3 rayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / wh, -0.85))  ;\n\trayDir = normalize(rayDir);\n    //background_ray\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 reverse_rayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / wh, -0.85))  ;\n    reverse_rayDir = normalize(reverse_rayDir);\n\tvec3 rayOrigin = vec3(0, 0, 2.25);\n\t// rotate camera with time\n\tfloat angle = iTime * 0.25;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2 camRot = mat2(ca, sa, -sa, ca);\n\trayOrigin.xz = camRot * rayOrigin.xz;\n\trayDir.xz = camRot * rayDir.xz;\n    //background_ray\n    float angle_1 = iTime * -0.25;\n\tfloat ca_1 = cos(angle_1);\n\tfloat sa_1 = sin(angle_1);\n    mat2 reverse_camRot = mat2(-ca_1,-sa_1,sa_1,-ca_1);\n    reverse_rayDir.xz = reverse_camRot * reverse_rayDir.xz;\n    \n    vec3 TextureColor = vec3(texture(iChannel3, uv).xyz);//贴图\n    \n\tconst vec3 sphereO = vec3(0.0, 0.0, 0.0);\n\tconst float sphereR = 1.3;\n\tvec3 point;\n    vec2 e = vec2(0.001, 0.00);\n\tvec3 normal  ;\n\tfloat distToCamera = raySphere(rayOrigin, rayDir, sphereO, sphereR, point, normal);\n\tvec3 linColor;\n\tif (distToCamera < INFINITY) {\n\t\tfloat sweepFactor = 1.0 - abs(dot(normal.xz, camRot[0]));//转换动画\n\t\t// Ideally this would be blue noise, but regular hash random also works.\n\t\tfloat fragmentNoise = hashRand(fragCoord + vec2(0.01, 0.023) * float(iTime));\n\t\tlinColor = shade(point, normal, rayOrigin - point, distToCamera, sweepFactor, fragmentNoise,rayDir);\n\t} else {\n        vec3 background = pow(textureLod(iChannel1, reverse_rayDir,0.0).xyz,vec3(2.2));//背景gamma校正\n\t\tlinColor = background;\n\t}\n\tfragColor = vec4(srgb_from_rgb(linColor), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}