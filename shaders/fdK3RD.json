{
    "Shader": {
        "info": {
            "date": "1631196606",
            "description": "Rouché's theorem in complex analysis",
            "flags": 0,
            "hasliked": 0,
            "id": "fdK3RD",
            "likes": 22,
            "name": "Rouché - winding number theorem",
            "published": 3,
            "tags": [
                "2d",
                "complexanalysis"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 714
        },
        "renderpass": [
            {
                "code": "/*\n\nWinding number theorem:\n\nA man is walking his dog along closed paths represented by f(z) and g(z),\nrespectively. If the man holds the leash tight enough to prevent the dog\nfrom touching the tree throughout their walk, they will circle the tree the\nsame number of times when they return to their initial positions.\n\nRouché's theorem:\n\nWhen f and g are analytic functions in a region that encloses the unit circle S\nand |f(z)| > |f(z) - g(z)| whenever z in S (here |f-g| is the length of the leash),\nthen f(S) and g(S) will circle the origin the same number of times, and this number\nequals the number of their zeros inside S.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 p = uv * 9.;\n    p -= vec2(1.5, .5); // adjust the postion of the curves\n    vec2 O = vec2(0.5);\n\n    // Smoothing factor.\n    float sf = 8./iResolution.y;\n\n    // background color\n    vec3 col = vec3(1, .92, .75);\n    float hatch = doHatch(uv, iResolution.y);\n    col *= hatch*.2 + .8;\n    \n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n\n    // curve width\n    float lw = .02;\n\n    float dc1 = dcurve(p, 0);\n    float dc2 = dcurve(p, 1);\n\n    float tA = mod(iTime*.2, 2.*PI);\n    float tB = max(0., tA + sin(iTime) * .1 - .1);\n    vec2 A0 = map1(0.), B0 = map2(0.);\n   \n    vec2 A = map1(tA);\n    vec2 B = map2(tB);\n    float dA = length(p - A) ;\n    float dB = length(p - B) ;\n\n    // dash grid lines\n    vec2 p1 = uv * 6.;\n    p1 -= floor(p1) + 0.5;\n    float bord = max(abs(p1.x), abs(p1.y))-0.49;\n    vec2 q1 = abs(mod(p1, 1./8.) - .5/8.);\n    float lines = (min(q1.x, q1.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    float dlink = dSegment(p, A, B);\n    // noisy background pattern\n    col *= fbm(p*48.)*.4 + .6;\n    // draw the grid lines\n    col = mix(col, vec3(0), bord*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc2 - lw*2.4));\n    col = mix(col, colorB, (1. - smoothstep(0., sf*4., dc2 - lw*1.6))*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc1))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc1 - lw*2.4));\n    col = mix(col, colorA, 1. - smoothstep(0., sf*4., dc1 - lw*1.6));\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*.7, dlink - 0.005))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*.7, dlink - .008));\n    col = mix(col, vec3(1, 1, .3), 1. - smoothstep(0., sf*.7, dlink));\n\n    lw *= 12.;\n\n    dA -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA));\n    dA += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dA)); \n    dA += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dA))); \n\n    dB -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB));\n    dB += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dB)); \n    dB += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dB)));\n    \n    float dA0 = length(p - A0);\n    dA0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0 - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA0));\n    dA0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0));\n    \n    float dB0 = length(p - B0);\n    dB0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0 - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB0));\n    dB0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0));\n \n    vec2 q = p - O;\n    float ci = length(q) - .7;\n    float sh = max(.75 - ci*4., 0.);\n    col = mix(col, vec3(0), (ss(sf*6., ci - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, ci));\n    col = mix(col, vec3(1, .7, .4)*(ci + sh*sh*.1 + .5), ss(sf, ci + .03));\n    col = mix(col, col*1.6, ss(sf*4., ci + .15));\n   \tcol = mix(col, vec3(0), ss(sf, abs(ci + .1) - .01));   \n    col = mix(col, vec3(0), (ss(sf, length(q) - .18))*.5);\n    col = mix(col, vec3(0), ss(sf, abs(length(q) - .12) - .01));\n    col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n    A -= O;\n    B -= O;\n    vec2 qA = rot2(atan(A.y, A.x-.5) -PI/2.) * q;\n    vec2 qB = rot2(atan(B.y, B.x)-PI/2.) * q;\n    float indA = distLine(qA - vec2(0, -.005), qA - vec2(0, .46)) - .01;\n    float indB = distLine(qB - vec2(0, -.005), qB - vec2(0, .3)) - .01;\n    \n    const float rad = .45;\n    const float aNum = 12.;\n    q = rot2(3.14159/aNum)*q;\n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n    ia = ia*6.283/aNum;\n    q = rot2(ia)*q;\n    q.x -= rad;\n        \n    // Markings.\n    float mark = sBox(q, vec2(.04, .022), 0.);\n    col = mix(col, vec3(.5), ss(sf, mark - .015));\n    col = mix(col, vec3(0), ss(sf, mark));\n        \n    // Indicator.        \n    col = mix(col, vec3(0), ss(sf, indA - .025));\n    col = mix(col, colorA, ss(sf, indA));\n    col = mix(col, vec3(0), ss(sf, indB - .025));\n    col = mix(col, colorB, ss(sf, indB));\n    \n    p -= vec2(-7.5, -3.);\n    p *= .8;\n    float ds1 = min(abs(length(p) - 1.), sqrt(dSegment(p, vec2(0), vec2(1, 0))));\n    col = mix(col, vec3(0.2), ss(sf, ds1 - 0.025));\n    float dr = distRoots(p);\n    col = mix(col, vec3(0.5, 0, 0), ss(sf, dr - .05));\n    col = mix(col, vec3(0.2), ss(sf, length(p - vec2(1, 0)) - .1));\n    \n    vec2 P = vec2(cos(tA), sin(tA));\n    float dP = length(p - P);\n    \n    dP -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dP - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dP - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dP));\n\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NUM_SEGMENTS  100\n#define PI            3.141592653\n#define ss(a, b)      (1. - smoothstep(0., a, b))\n#define colorA   vec3(1, 0.2, 0.2)\n#define colorB   vec3(0.3, 1., .6)\n\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 transform(vec2 z, vec2 a) {\n    return cdiv(z - a, vec2(1, 0) - cmul(vec2(a.x, -a.y), z));\n}\n\nfloat n2D(vec2 p) {\n    const vec2 s = vec2(1, 113);\n    vec2 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = fract(sin(h)*43758.5453);\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x);\n}\n\nfloat fbm(vec2 p) {\n    return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\nfloat distLine(vec2 a, vec2 b) {\n    b = a - b;\n    float h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\nfloat sBox(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\n\nfloat dSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return dot2(pa - ba*clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0));\n}\n\nvec2 map1(float t) {\n    const float s = 2.;\n    vec2 p = vec2(cos(t), sin(t));\n    vec2 z = transform(p, vec2(.5, .7));\n    z = cmul(z, transform(p, vec2(-.6, 0.5)));\n    z = cmul(z, transform(p, vec2(-0.4)));\n    z = cmul(z, p - vec2(s, s));\n    return z;\n}\n\nfloat distRoots(vec2 p) {\n    float d = length(p - vec2(.5, .7));\n    d = min(d, length(p - vec2(-0.6, 0.5)));\n    d = min(d, length(p - vec2(-0.4)));\n    return d;\n}\n\nvec2 map2(float t) {\n    return map1(t) + vec2(cos(t) * 1.6, sin(t) * 1.2);\n}\n\nfloat dcurve(vec2 p, int index) {\n    float h = 0.05;\n    float t = 0.0;\n\n    vec2  a = index == 0 ? map1(t) : map2(t);\n    float d = dot2(p - a);\n\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        vec2  b = index == 0 ? map1(t) : map2(t);\n        d = min(d, dSegment(p, a, b));\n        t += clamp(0.01*length(a-p)/length(a-b), 0.01, 0.15);\n        a = b;\n    }\n    return sqrt(d);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453);\n}\n\nfloat doHatch(vec2 p, float res) {\n    p *= res/16.;\n    float hatch;\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;\n    else if (hRnd > 0.33) hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    else hatch = clamp(sin((p.x + p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    return hatch;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}