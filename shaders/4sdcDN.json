{
    "Shader": {
        "info": {
            "date": "1520685870",
            "description": "\nTesting Tomkh's refinements on IQ's straight edged Voronoi formula to produce detailed, rounded cell borders on hexagonal Voronoi - Basically, just another excuse to code something shiny. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4sdcDN",
            "likes": 58,
            "name": "Round Voronoi Border Refinement",
            "published": 3,
            "tags": [
                "voronoi",
                "hexagon",
                "chromatic",
                "bump",
                "metal",
                "border"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2486
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRound Voronoi Border Refinement\n\t-------------------------------\n\n\tTesting Tomkh's refinements on IQ's straight-edged Voronoi formula to produce detailed, \n\trounded cell borders on hexagonal Voronoi - Basically, just another excuse to code something \n\tshiny. :)\n\n\tThanks to Tomkh, rounded Voronoi borders with continuous isolines are possible - or close enough\n\tto enable nice equidistant contour lines that line up at the edges. His solution was based on \n\tprevious work by IQ, Abje, Dr2 and others. My contribution was to sit on the sidelines and wait \n\tfor someone else to do the work. :D\n\n\tAnyway, this is a simple bump mapped example. The cliche faux chromatic look is achieved by \n\tlighting the surface with a red-tinged light and a blue-tinged light. The individual specular \n\tcomponents have more prominent red and blue coloring. For anyone wondering, you can usually fake\n\ta metallic look by increasing the intensity and ramping up the diffuse lighting power. Metallic\n\ttexturing can help too.\n\n\tI'm not entirely sure why the hardened metal substance is moving so fluidly, but I'm pretty sure\n\tit can all be explained with Star Trek physics. :)\n\n\tBased on:\n\t\n\tA Voronoi Edge distance function that is continuous across \n\tthe whole domain and smooth at the non-zero distance.\n\tRounder Voronoi Edge Distance - tomkh\n\thttps://www.shadertoy.com/view/ld3yRn\n\n\n*/\n\n// Very unimaginative cell color options. :)\n// Grey: 0, Brown: 1, Blue: 2., 3: Green. \n#define CELL_COLOR 0\n\n// Scene object ID, and individual cell IDs. Used for coloring.\nfloat objID; // The rounded web lattice, or the individual Voronoi cells.\n//vec2 cellID; // Individual Voronoi cell IDs.\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's esmooth minimum function. \nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n*/\n\n// Commutative smooth minimum function. Provided by Tomkh and \n// taken from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n// vec2 to vec2 hash.\nvec2 hash22H(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*.8660254; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    // Slightly lower number, so as not to overshoot the hexagonal bounds.\n    return sin( p*6.2831853 + iTime )*.3660254 + .5; \n    \n}\n\n\n// Converting to the hexagonal grid.\nvec2 pixToHex(vec2 p){\n    \n    return floor(vec2(p.x + .57735*p.y, 1.1547*p.y) + 1./3.);\n}\n\n\n// Randomized hexagonal offset point.\nvec2 hexPt(vec2 p) {\n\n    // The offset value is restricted to the radius of the incircle of the\n    // hexagon, or apothem as it's technically known.\n    return vec2(p.x - p.y*.5, .866025*p.y) + (hash22H(p) - .5)*.866025/2.;\n    \n}\n\n\n// This is a hexagonal variation on a regular 2-pass Voronoi traversal that produces\n// a Voronoi pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It uses elements from an old hexagonal Voronoi example, \n// and is based on IQ's original example. It was inspired by Dr2's hexagonal examples.\n// The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to attemp to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Desert Town - dr2\n// https://www.shadertoy.com/view/XslBDl\nvec3 Voronoi(vec2 p){\n    \n    // Convert to the hexagonal grid.\n    vec2 pH = pixToHex(p); // Map the pixel to the hex grid.\n\n    // There'd be a heap of ways to get rid of this array and speed things up. The\n    // most obvious, would be unrolling the loops, but there'd be more elegant ways.\n    // Either way, I've left it this way just to make the code easier to read.\n \n    // Hexagonal grid offsets. \"vec2(0)\" represents the center, and the other offsets effectively circle it.\n    // Thanks, Abje. Hopefully, the compiler will know what to do with this. :)\n\tconst vec2 hp[7] = vec2[7](vec2(-1), vec2(0, -1), vec2(-1, 0), vec2(0), vec2(1), vec2(1, 0), vec2(0, 1)); \n    \n    \n    // Voronoi cell ID containing the minimum offset point distance. The nearest\n    // edge will be one of the cell's edges.\n    vec2 minCellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for (int i=0; i<7; i++){\n    \n        // Determine the offset hexagonal point.\n        vec2 h = hexPt(pH + hp[i]) - p;\n        // Determine the distance metric to the point.\n    \td = dot(h, h);\n    \tif( d<md ){ // Perform updates, if applicable.\n            \n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = h; \n            //cellID = h + p; // For cell coloring.\n            minCellID = hp[i]; // Record the minimum distance cell ID.\n        }\n    }\n    \n    // Second pass: Point to nearest cell-edge distance.\n    //\n    // With the ID of the cell containing the closest point, do a sweep of all the\n    // surrounding cell edges to determine the closest one. You do that by applying\n    // a standard distance to a line formula.\n    for (int i=0; i<7; i++){\n    \n         // Determine the offset hexagonal point in relation to the minimum cell offset.\n        vec2 h = hexPt(pH + hp[i] + minCellID) - p - mo; // Note the \"-mo\" to save some operations. \n        \n        // Skip the same cell.\n        if(dot(h, h)>.00001){\n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article (link above) for a visual representation.            \n            lnDist = dot(mo + h*.5, normalize(h));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based\n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // Polynomial-based smooth minimum. The last factor controls the roundness of the \n            // edge joins. Zero gives you sharp joins, and something like \".25\" will produce a\n            // more rounded look. Tomkh noticed that a variable smoothing factor - based on the\n            // line distance - produces continuous isolines.\n            lMd = smin2(lMd, lnDist, (lnDist*.5 + .5)*.15);\n            //lMd = smin2(lMd, lnDist, .1);\n            // Exponential-based smooth minimum.\n            //lMd = sminExp(lMd, lnDist, 20.); \n            //lMd = sminExp(lMd, lnDist, (lnDist*.5 + .5)*50.);\n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n            \n        }\n\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but I'm not \n    // positive. Although not used here, the standard minimum point distance is returned also.\n    return max(vec3(lMd, lMd2, md), 0.);\n    \n    \n}\n\n\n// The bump function. Used for bump mapping, coloring and shading.\nfloat bumpFunc(vec2 p){\n    \n\t// Voronoi vector. It holds the rounded edge value, straight edge value,\n    // and a dummy value.\n    vec3 v = Voronoi(p);\n    \n    float c = v.x; // Rounded edge value.\n    \n\n    float ew = .07; // Border threshold value. Bigger numbers mean thicker borders.\n    \n    // If the Voronoi value is under the threshold, produce a web like contoured border.\n    if(c<ew){ \n        \n        objID = 1.; // Voronoi web border ID.\n        \n        c = abs(c - ew)/ew; // Normalize the domain to a range of zero to one.\n        \n        // Add the contoured pattern to the web border.\n        c = smoothstep(0., .25, c)/4. + clamp(-cos(c*6.283*1.5) - .5, 0., 1.);\n \n    }\n    else { // Over the threshold? Use the regular Voronoi cell value.\n        \n        objID = 0.;\n        c = mix(v.x,  v.y, .75); // A mixture of rounded and straight edge values.\n        c = (c - ew)/(1. - ew); // Normalize the domain to a range of zero to one.\n        c = clamp(c + cos(c*6.283*24.)*.002, 0., 1.); // Add some ridges.\n    }\n    \n    return c; // Return the object (bordered Voronoi) value.\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    //SETUP.\n    //\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.);\n    \n    // Very subtle screen warping, for that bulbous fish-eye look.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    uv *= 1. + dot(uv*aspect, uv*aspect)*.05;\n    \n    // Unit direction ray.\n    vec3 r = normalize(vec3(uv.xy, 1.));\n\n    // Scaling and movement.\n    vec2 p = uv*3.5 + vec2(0, iTime*.5);\n    \n    // The webbed Voronoi value.\n    float c = bumpFunc(p);\n    \n    // Saving the ID.\n    float svObjID = objID; \n    \n    // 3D screen hit point. Just a flat plane at the zero point on the Z-axix.\n    vec3 sp = vec3(p, 0.);\n    \n    // Two lights, set back from the plane, and rotating about the XY plane on\n    // opposite sides of an ellipse, or something to that effect.\n    vec3 lp = sp + vec3(-1.3*sin(iTime/2.), .8*cos(iTime/2.), -.5);\n    vec3 lp2 = sp + vec3(1.3*sin(iTime/2.), -.8*cos(iTime/2.), -.5);\n    \n    // Fake hit-point height value. Normally, you'd cast a ray to the hit point, but \n    // since it's a simple bump mapped example, we're estimating it.\n    sp.z -= c*.1;\n    \n    \n    // BUMP MAPPING AND EDGING. Pretty standard stuff. \n    //\n    vec2 e = vec2(8./iResolution.y, 0); // Sample spred.\n    float bf = .4; // Bump factor.\n    \n    // If we hit the webbing section, reduce the sample spread. It's a bit of fake\n    // trickery to reduce artifacts on the webbing portion.\n    if (svObjID>.5) { e.x = 2./iResolution.y; }\n    \n    float fx = (bumpFunc(p - e) - bumpFunc(p + e)); // Nearby horizontal samples.\n    float fy = (bumpFunc(p - e.yx) - bumpFunc(p + e.yx)); // Nearby vertical samples.\n\tvec3 n = normalize(vec3(fx, fy, -e.x/bf)); // Bumped normal.\n    \n    float edge = abs(c*2. - fx) + abs(c*2. - fy); // Edge value.\n\t\n    \n    // TEXTURE AND COLORING.\n    //\n    // Texture sample with fake height information added.\n    vec3 tx = texture(iChannel0, (p + n.xy*.125)*.25).xyz; tx *= tx; // sRGB to linear.\n    tx = smoothstep(0., .5, tx); // Accentuating the color a bit.\n    \n    // Object color. Initialize to the texture value.\n    vec3 oCol = tx; \n    \n    \n    if(svObjID>.5){ // The webbing portion.\n        \n        //oCol *= vec3(1.2, .8, .4); // Uncomment for gold webbing.\n        //oCol *= vec3(1.4, 1, .7);\n        oCol *= .9;\n        \n    }   \n    #if CELL_COLOR > 0\n    else { // The cell portion. Do what you want here.\n         \n\t    // Uncomment for colored cells, etc.\n        #if CELL_COLOR == 1\n        oCol *= vec3(1.4, 1, .7);\n        #elif CELL_COLOR == 2\n        oCol *= vec3(.9, 1.1, 1.3); \n        #else\n        oCol *= vec3(1.1, 1.4, .7); \n        #endif\n        \n    }\n\t#endif\n    \n  \n    //oCol *= vec3(1.2, 1, .84); // Warmer coloring.\n    //oCol *= vec3(.9, 1.1, 1.3); // Cooler coloring.\n    \n\t\n\t// LIGHTING.\n    //\n    float lDist = length(lp - sp); // Light distance one.\n    float atten = 1./(1. + lDist*lDist*.5); // Light one attenuation.\n    vec3 l = (lp - sp)/max(lDist, .001); // Light one direction (normalized).\n\tfloat diff = max(max(dot(l, n), 0.), 0.); // Diffuse value one.\n    float spec = pow(max(dot(reflect(l, n), r), 0.), 64.); // Specular value one.\n    \n    \n    float lDist2 = length(lp2 - sp); // Light distance two.\n    float atten2 = 1./(1. + lDist2*lDist2*.5); // Light two attenuation.\n    vec3 l2 = (lp2 - sp)/max(lDist2, .001); // Light two direction (normalized).\n\tfloat diff2 = max(max(dot(l2, n), 0.), 0.); // Diffuse value two.\n    float spec2 = pow(max(dot(reflect(l2, n), r), 0.), 64.); // Specular value twp.\n    \n    \n    // Ramping up the power and increasing the intensity of the diffuse values to \n    // give more of a metallic look.\n    diff = pow(diff, 4.)*2.;\n    diff2 = pow(diff2, 4.)*2.;\n\n    \n \t// Combining the texture and lighting information above.\n    \n    // Light one.\n    vec3 col = oCol*(diff*vec3(.5, .7, 1) + .25 + vec3(.25, .5, 1)*spec*32.)*atten*.5;\n    \n    // Adding light two.\n    col += oCol*(diff2*vec3(1, .7, .5) + .25 + vec3(1, .3, .1)*spec2*32.)*atten2*.5;\n\n    // Apply the edging. This provides fake AO, depth information, etc. Comment it out, and\n    // the example becomes very 2-dimensional.\n    col *= edge;\n    \n    // POSTPROCESSING, SCREEN PRESENTATION, ETC.\n    //\n    //col *= vec3(1.5, 1., .6); // Warmer coloring.\n    //col *= vec3(.9, 1.2, 1.4); // Cooler coloring.\n    \n\t// Subtle vignette.\n    vec2 u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125);\n    // Colored variation.\n    //col = mix(pow(min(vec3(1.5, 1, 1)*col, 1.), vec3(1, 3, 16)), col, \n            //pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125)*.75 + .25);     \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}