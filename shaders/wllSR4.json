{
    "Shader": {
        "info": {
            "date": "1562310491",
            "description": "pathtracer that has pixel decorrelation with blue noise\nit's a very simple concept, see:\n\nhttps://www.arnoldrenderer.com/research/dither_abstract.pdf",
            "flags": 32,
            "hasliked": 0,
            "id": "wllSR4",
            "likes": 29,
            "name": "Path Tracer Blue Seeds",
            "published": 3,
            "tags": [
                "raytracing",
                "pathtracer",
                "bluenoise"
            ],
            "usePreview": 1,
            "username": "joeedh",
            "viewed": 1449
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 c;\n    c = texture(iChannel0, uv);\n    vec3 c2 = c.rgb/c.a;\n    \n    //toning\n    c2 = sqrt(c2*2.0);\n    //vec3 c3 = 1.0-exp(-c2*1.8);\n    vec3 toning;\n    //vec3 toning = mix(c2, c3, 0.5)*0.875;\n    \n    toning = exp(-(1.0-c2)*3.0);\n    //toning = sqrt(c2)*0.5 + c2*c2*0.5;\n    //toning = c.rgb/c.a;\n    \n    \n    fragColor = vec4(toning, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nAuthor: Joe Eagar\n\nhttps://www.shadertoy.com/view/wllSR4\n\npathtracer that has pixel decorrelation with blue noise\nit's a very simple concept, see:\n\nhttps://www.arnoldrenderer.com/research/dither_abstract.pdf\n\n02/20/2020: added a preview mode.  tried to make navigation more interesting.\n\n*/\n\n//uncomment for preview mode\n//#define PREVIEW\n\n#ifdef PREVIEW\n#define STEPS 50\n#define IFSSTEPS 6\n#define BOUNCES 2\n#else\n#define STEPS 100\n#define IFSSTEPS 8\n#define BOUNCES 4\n#endif\n\n#define COHERENCY_STEPS 19 //controls how may pixels in blue noise mask produce same seed\n#define BLUE_NOISE_SEEDS 1\n#define DSCALE 2.5 //scale per fractal level\n\n#define SUN_ENERGY 1.0\n#define SUN_SIZE 0.1\n#define AMBIENT 1.0\n\n//#define LIGHTS\n\nstruct State {\n    vec3 origin;\n    vec3 target;\n    \n    mat3 bases;\n    float focal_dist;\n};\n\nState state;\n\nstruct Sample {\n    float d;\n    vec3 color;\n    vec3 emission;\n    vec3 no;\n};\n\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\nvec2 rot2d(vec2 v, float th) {\n    return vec2(cos(th)*v.x + sin(th)*v.y, cos(th)*v.y - sin(th)*v.x);\n}\n\nvec3 cubenorm(vec3 co2) {\n    vec3 aco2 = abs(co2);\n            \n    if (aco2[0] > aco2[1] && aco2[0] > aco2[2])\n        co2 = vec3(sign(co2[0]), 0.0, 0.0);\n    else if (aco2[1] > aco2[0] && aco2[1] > aco2[2])\n        co2 = vec3(0.0, sign(co2[1]), 0.0);\n        else\n            co2 = vec3(0.0, 0.0, sign(co2[2]));\n        \n\treturn -co2;\n}\n\nfloat psuedoxor(float a, float b) {\n\treturn a < 0.5 == b < 0.5 ? min(a, b) : max(a, b);\n}\n\nfloat cube(vec3 co2, float ll) {\n    float l = max(abs(co2.x), abs(co2.y));\n    l = max(l, abs(co2.z));\n    \n    return l - ll;\n}\n\nSample s_cube(vec3 co, float l1) {\n    Sample s;\n    \n    s.d = cube(co, l1);\n    s.color = vec3(1.0,1.0,1.0)*0.78;\n    s.no = -cubenorm(co);\n    \n    return s;\n}\n\n\nfloat sphere(vec3 co, float radius) {\n    return length(co) - radius;\n}\n\nSample s_sphere(vec3 co, float radius) {\n    Sample s;\n    \n    s.d = sphere(co, radius);\n    s.color = vec3(1.0, 1.0, 1.0)*0.78;\n    s.no = normalize(co);\n    \n    return s;\n}\n\nvoid s_union(inout Sample a, Sample b) {\n    if (a.d > b.d) {\n        a = b;\n    }\n}\n\nvoid s_diff(inout Sample a, Sample b) {\n    if (a.d < -b.d) {\n        a = b;\n        a.d = -a.d;\n        a.no = -a.no;\n    }\n\n}\n\nvoid s_intersect(inout Sample a, Sample b) {\n    if (a.d < b.d) {\n        a = b;\n    }\n\n}\n\n\nvec3 tent(vec3 f) {\n    return vec3(tent(f.x), tent(f.y), tent(f.z));\n}\n\n\nfloat rand(float seed) {\n    //seed += 50.0;\n    \n    float f = fract(sin(seed*3.14159265453)*59407.2751);\n    \n    f = fract(1.0 / (0.0000001 + 0.00001*f));\n    \n    return f;\n}\n\nvec3 randvec(float seed) {\n    return vec3(\n        rand(seed),\n        rand(seed+12.23432),\n        rand(seed+35.73423)\n    ) - 0.5;\n}\n\nSample fractal(vec3 co, float seed) {\n    Sample s;\n    \n    vec3 center = vec3(1.0);\n    vec3 co2 = co;\n    int i;\n    float th=0.0, thscale = 1.3, dscale = DSCALE;\n    float k = 0.0, fi=0.0;\n\n    //s = s_cube(co2, 0.5);\n    s = s_sphere(co2, 0.5);\n    \n    float scale = dscale;\n    \n    for (i=0; i<IFSSTEPS; i++) {\n        float x1, y1;\n\t\t\n        /*\n        co.xy = rot2d(co2.xy, th);\n        co2.yz = rot2d(co2.yz, th);\n        th += k;\n        k += thscale*thscale;\n\t\t//*/\n        \n        co2 = floor(co*scale + 0.5)/scale;\n        scale *= dscale;\n        co2 = (co - co2);\n        \n        s_diff(s, s_cube(co2, 1.0/scale));\n#ifdef LIGHTS\n        float sz = 100.0;\n        float f = tent(sz*co[0])*tent(sz*co[1])*tent(sz*co[2]);\n        f = float(f > 0.75)*30.0;\n        \n        s.emission[1] = 0.25*f;\n        s.emission[0] = f;\n#endif       \n        \n    }\n    \n    return s;\n}\n\n\nSample dsample(vec3 co, float seed) {\n    return fractal(co, seed);\n}\n\n\nSample trace(vec3 co, vec3 nray, out vec3 outco, out float found, float seed) {\n    float dt = 3.0 / float(STEPS);\n    Sample outl, f, l;\n    \n    found = 0.0;\n    \n    float facmul = pow(0.7, 1.0 / float(STEPS)), fac = 1.0;\n    float t = 0.0;\n    vec3 co2 = co;\n    nray = normalize(nray);\n    \n    float mint=1000.0;\n                     \n    for (int i=0; i<STEPS; i++) {\n        l = dsample(co2, seed);\n        \n        if (abs(l.d) < 0.0003) {// && abs(l.d) < mint) {//l < 0.1 && l > -0.1) { //abs(l) < 0.05) {\n             outl = l;\n\t\t     outco = co2;\n             found = 1.0;\n             mint = abs(l.d);\n             if (abs(l.d) < 0.00004)\n            \tbreak;\n        }\n\n        t += l.d; //*((cos(iTime*55.23532))*0.15+1.0);\n        \n        //don't let ray go behind origin\n        t = max(t, 0.0);\n        \n        co2 = co + nray*t;\n        fac *= facmul;\n    }\n    \n    return outl;\n}\n\n\n/*\nambient occlusion.  currently unused.\n\nsamples the distance field at random points in a sphere\n*/\nfloat ao(vec3 co, vec3 nray, float max_dist, float seed) {\n    int i;\n    float tot=0.0;\n    float sum=0.0;\n    \n    vec3 co2;\n    \n    for (int i=0; i<2; i++) {\n        float seed2 = seed + 11.234 + 0.00123*float(i); //co.x*co.y*co.z + float(i)*3.14159;\n        \n        vec3 nray2 = normalize(randvec(seed2));\n        float found;\n        \n        trace(co + nray2*0.005, nray2, co2, found, seed);\n        sum += float(length(co2-co) < max_dist)*found;\n        tot += 1.0;\n    }\n    \n    sum = tot != 0.0 ? 1.0-sum / tot : 1.0;\n    return sum;\n}\n\n//main pathtracing loop\nvec3 shadeloop(vec3 co, vec3 nray, float seed) {\n    vec3 co2;\n    vec3 color;\n    float seed2 = seed*5.0;\n    \n    for (int i=0; i<BOUNCES; i++) {\n        seed2 += 1.32423;\n        float found, f;\n        Sample s = trace(co, nray, co2, found, seed2);\n        float l = s.d;\n\t\t\n        //sample ambient?\n        if (found == 0.0) {\n            color += vec3(0.4, 0.5, 0.9)*AMBIENT;\n            break;\n        }\n\n        vec3 n = s.no;\n\t\t\n        //planar area light instead of sun,\n        //because it makes prettier shading :)\n        vec3 light = vec3(3.0, 0.6, 3.0) + SUN_SIZE*randvec(seed2+1.0)*1.0*vec3(1.0,1.0,0.0); //nray[0], nray[1], nray[2]-2.5);\n        vec3 ln = normalize(light-co2);\n        \n        f = max(dot(n, ln), 0.0)*SUN_ENERGY;\n        \n        vec3 co3;\n        trace(co2 + -nray*0.004, ln, co3, found, seed2+2.0);\n\n        f *= float(found < 0.1);\n        \n        color = color*s.color + s.color*f;\n        color += s.emission;\n        \n        co = co2 - nray*0.004;\n        nray = randvec(seed2+3.0);\n        if (dot(nray, n) < 0.0) {\n            nray = -nray;\n        }\n    }\n    \n    return color;\n}\n\nvec3 viewtrace(vec3 viewco, float seed) {\n    float f = 0.0;\n\n    vec3 planeco = state.origin + state.bases[2]*state.focal_dist;\n    \n    planeco += state.bases[0]*viewco[0];\n    planeco += state.bases[1]*viewco[1];\n\n    vec3 ray = planeco - state.origin;\n    vec3 nray = normalize(ray);\n    vec3 co2 = state.origin;// + nray*state.focal_dist + nray*1.2;\n    vec3 co;\n    \n    return shadeloop(co2, nray, seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 inp = texture(iChannel0, uv);\n    \n    float seed = inp[3]*10.23423;\n    \n    //sample blue noise texture\n    vec2 buv = fract(fragCoord.xy / iChannelResolution[1].xy);\n    float bn = texture(iChannel1, buv)[0];\n    bn = floor(bn*float(COHERENCY_STEPS))/float(COHERENCY_STEPS);\n    \n    float t = 1.0;\n    vec2 viewco2d = fragCoord / iResolution.xy;\n    viewco2d = (viewco2d - 0.5) * 2.0;\n    viewco2d[0] *= iResolution.x / iResolution.y;\n\t\n#if BLUE_NOISE_SEEDS\n    //decorrelate pixel seeds with blue noise \n    seed += bn;\n#else\n    //white noise\n    seed += rand(fragCoord.x*sqrt(3.0) + fragCoord.y*sqrt(5.0))*3.2432;\n#endif \n    \n    /*jitter the pixel grid a bit.\n      for antiasing.  pseudo-uniform distribution (tent blur)\n      by adding two random vectors.\n     */\n    viewco2d.xy += 2.0*(randvec(seed)+randvec(seed+1.1)).xy/iResolution.x;\n    \n    vec3 viewco = vec3(viewco2d, 0.0);\n    vec3 clrout = vec3(0.0, 0.0, 0.0);\n    float f = 0.0;\n    \n    viewco *= 1.5;\n    \n    //set camera origin\n    float mx = iMouse.x/iResolution.x;\n    float my = iMouse.y/iResolution.y;\n    \n    //offset so mouse at 0/0 is specific coordinates\n    mx = fract(mx+0.73);\n    //my = my+0.63;\n    \n    float th = -mx*1.5;\n    float cr = 1.75 - 1.65*pow(abs(my), 0.2)*sign(my);\n    \n    float z = 2.0 - 1.0*(my-0.05);\n    \n    state.origin = vec3(cos(th), sin(th), z)*cr;\n    state.target = vec3(0, 0, 0.33);\n    \n    state.focal_dist = 0.15;\n    \n    viewco[2] = state.focal_dist;\n    viewco.xy *= 0.01;\n\n    state.bases[2].xyz = normalize(state.target - state.origin);\n    state.bases[0].xyz = normalize(cross(state.bases[2].xyz, vec3(0, 0, 1)));\n    state.bases[1].xyz = normalize(cross(state.bases[0].xyz, state.bases[2].xyz));\n    \n\tvec3 co = viewco;    \n    float df = 1.0 / iResolution.y;\n\n    clrout = viewtrace(co, seed);\n    \n    if (false || iMouse.z > 0.0) {\n    \tfragColor = vec4(clrout.rgb, 1.0);\n    \treturn;\n    }\n    \n    fragColor[3] = inp[3] + 1.0;\n    fragColor.xyz = inp.xyz + clrout;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}