{
    "Shader": {
        "info": {
            "date": "1663509888",
            "description": "wat ever",
            "flags": 0,
            "hasliked": 0,
            "id": "sldcW2",
            "likes": 0,
            "name": "Into Infinity",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "dominionxvii",
            "viewed": 64
        },
        "renderpass": [
            {
                "code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 5000\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\n#define S smoothstep\n#define T iTime\n#define STEPS 0.5\n#define IOR 1.47\n\n#define ANTIALIASING\n\n//vec3 camPosition;\nvec3 cameraForward;\n\nstruct RayHit\n{\n    vec3 ro;\n    vec3 rd;\n    \n    vec3 pos;\n    float dist;\n\n    vec3 normal;\n    vec3 reflDir;\n    vec3 refractDir;\n    int steps;\n    bool hasHit;\n    vec3 instanceID;\n    float closestDist;\n    \n    float totalDist;\n};\n\nvec3 GetObjectColor(vec3 instanceID)\n{\n    float hue = 37. * instanceID.x + 43. * instanceID.y + 29. * instanceID.z;\n    return HSVtoColor(hue, 1., 1.);\n}\n\nvec3 GetObjectColor(RayHit hit)\n{\n    return GetObjectColor(hit.instanceID);\n}\n\n\nvec3 GetInstanceID(vec3 p)\n{\n    return floor((p + STEPS/2.) / STEPS);\n}\n\nvec3 DistortTimeAndSpace(vec3 p)\n{\n    p.y += 5.5 * sin(p.z * .15); \n    p.x += 5.5 * cos(p.z * .15);\n    \n    mat2 r2 = Rot(p.z * .0);\n    p.xy *= r2;\n    \n    return p;\n}\n\nfloat GetDist(vec3 p)\n{\n    p = DistortTimeAndSpace(p);\n    vec3 ids = GetInstanceID(p);\n    \n    p = opRep(p, vec3(STEPS));\n\n    //float d = sdSphere(p, 0.15 + 0.05 * sin(ids.z * .7 + ids.x * 0.5));\n    float d = sdSphere(p, 0.1);\n\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nRayHit CalculateRayHit(vec3 ro, vec3 rd, float dist, bool hasHit, int steps, float closestDist)\n{\n    RayHit hit;\n    hit.ro = ro;\n    hit.rd = rd;\n    hit.dist = dist;\n    hit.pos = ro + rd * dist;\n    hit.normal = GetNormal(hit.pos);\n    hit.reflDir = reflect(rd, hit.normal);\n    hit.refractDir = refract(rd, hit.normal, IOR);\n    hit.steps = steps;\n    hit.closestDist = closestDist;\n\n    hit.hasHit = hasHit;\n    hit.instanceID = GetInstanceID(DistortTimeAndSpace(hit.pos));\n    return hit;\n}\n\n\n\nRayHit RayMarch(vec3 ro, vec3 rd) {\n\tfloat dist = 0.;\n    bool hasHit = false;\n    \n    int steps = 0;\n    float closestDist = MAX_DIST;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * dist;\n        float dS = GetDist(p);\n        dist += dS;\n        \n        closestDist = min(closestDist, dS);\n        \n        steps = i;\n        \n        if(dist > MAX_DIST) break;\n        \n        if(abs(dS) < SURF_DIST)\n        {\n            hasHit = true;\n            break;\n        }\n    }\n    \n    return CalculateRayHit(ro, rd, dist, hasHit, steps, closestDist);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) \n{ \n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 GetColor(RayHit hit)\n{\n    vec3 col;\n    vec3 highLight;\n    \n    if(hit.hasHit) \n    {\n        float fresnel = saturate(dot(-hit.rd, hit.normal));\n        fresnel = 1. - pow(fresnel, 1.);\n        \n        col = GetObjectColor(hit);\n        \n        col += fresnel;\n        \n        vec3 lightDir = cameraForward;\n\n        float diffuse = 2. * saturate(dot(hit.normal, lightDir));\n        \n        float specularStrength = 1.5;\n        float spec = pow(max(dot(hit.rd, hit.reflDir), 0.0), 32.);\n        vec3 specular = specularStrength * spec * vec3(1);  \n\n        col *= diffuse + specular;\n        col *= saturate(0.5 - saturate(hit.totalDist / (MAX_DIST * 0.3)));\n        //col = pow(col, 5.);\n    }\n    \n    \n    //highLight = vec3(1.0) * saturate(hit.closestDist * 1.);\n    \n    \n    float highlightRatio = saturate(float(hit.steps) / 150.);\n    highlightRatio = highlightRatio * highlightRatio;\n    vec3 fog = GetCol(109, 143, 163);\n    //vec3 fog =  vec3(0.0);\n\n    return mix(col, fog, highlightRatio) + highLight; \n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, float fov, float aspectRatio, out vec3 ro, out vec3 rd)\n{\n\n    //float imageAspectRatio = resolution.x / resolution.y;  //assuming width > height\n    uv.x = uv.x * tan(fov / 2. * PI / 180.) * aspectRatio;\n    uv.y = uv.y * tan(fov / 2. * PI / 180.);\n\n    //Add FOV\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.));\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\nvoid OrthographicCam(vec3 camPos, vec4 camRot, vec2 uv, float size, float aspectRatio, out vec3 ro, out vec3 rd)\n{\n    //float imageAspectRatio = resolution.x / resolution.y;  //assuming width > height\n    uv.x = uv.x * aspectRatio;\n    uv.y = uv.y;\n\n    //Add FOV\n    //float3 forward = normalize(float3(uv.x, uv.y, 1.0));\n    ro = camPos + (uv.x * qmul(camRot, vec3(1, 0, 0)) * size) + (uv.y * qmul(camRot, vec3(0, 1, 0)) * size);\n    rd = qmul(camRot, vec3(0, 0, 1));\n}\n\n\n\nvec3 GetColor(vec3 camPos, vec4 camRot, vec2 uv)\n{\n    //vec3 ro1, rd1;\n    //vec3 ro2, rd2;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    //PerspectiveCam(camPos, camRot, uv, aspectRatio, ro1, rd1);\n    //OrthographicCam(camPos, camRot, uv, 5., aspectRatio, ro2, rd2);\n\n    //vec3 ro = mix(ro1, ro2, 0.0);\n   // vec3 rd = mix(rd1, rd2, 0.0);\n    vec3 ro, rd;\n    const float fov = 40.;\n    PerspectiveCam(camPos, camRot, uv, fov, aspectRatio, ro, rd);\n\n\n    //vec3 fpos = DistortTimeAndSpace(vec3(0.0, 0.0, 0.75 * iTime));\n    //vec3 ro = vec3(-fpos.x - STEPS/2., -fpos.y - STEPS/2., fpos.z);\n    //camPosition = ro;\n    \n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    const int reflections = 5;\n    int lastReflectionId = 0;\n    vec3 hitColors[reflections];\n    \n    float totalDist = 0.;\n    RayHit hit;\n    for(int i = 0; i < reflections; i++)\n    {\n        hit = RayMarch(ro, rd);\n        \n        if(hit.hasHit)\n        {\n            totalDist += hit.dist;\n            hit.totalDist = totalDist;\n            hitColors[i] = GetColor(hit);\n        \n            lastReflectionId = i;\n            ro = hit.pos + hit.normal * (SURF_DIST + 0.01);\n            rd = hit.reflDir;\n        }\n        else\n        {\n            \n            break;\n        }\n    }\n    \n    vec3 col = hitColors[lastReflectionId];\n    for (int i = lastReflectionId - 1; i >= 0; i--)\n    {\n        col = mix(hitColors[i], col, 0.2);\n    }\n    return col;\n}\n\nvec3 FixPos(vec3 pos)\n{\n    pos = DistortTimeAndSpace(pos);\n    return vec3(-pos.x + STEPS/2., -pos.y + STEPS/2. , pos.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy) - vec2(0.5);\n\n    \n    float speed = 1.5;\n    //float speed = 1.5;\n\n   // vec3 fpos = DistortTimeAndSpace(vec3(0.0, 0.0,speed * iTime));\n    \n    vec3 fposPrev1 = FixPos(vec3(0.0, 0.0, speed * iTime + 1.5));\n    vec3 fposPrev2 = FixPos(vec3(0.0, 0.0, speed * iTime + 1.4));\n    cameraForward = normalize(fposPrev1 - fposPrev2);\n\n    //vec3 camPos = vec3(-fpos.x + STEPS/2., -fpos.y + STEPS/2. , fpos.z);\n    vec3 camPos = FixPos(vec3(0.0, 0.0, speed * iTime));\n\n    vec4 camRot = qLookAt(cameraForward, vecY(1.0));\n\n\n    vec3 col;\n    #ifdef ANTIALIASING\n        vec3 colorSum = vec3(0.0);        \n        //vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n        vec2 nextUv = ((fragCoord.xy+vec2(1.0)) / iResolution.xy) - vec2(0.5);\n\n\n        colorSum += GetColor(camPos, camRot, uv);\n        colorSum += GetColor(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n        colorSum += GetColor(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n        colorSum += GetColor(camPos, camRot, mix(uv, nextUv, 0.5));\n        colorSum /= 4.0;\n        \n        col = colorSum;  \n    #else\n        col = GetColor(camPos, camRot, uv);\n    #endif\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TAU 6.283185\n#define PI 3.141592\n\nvec3 GetCol(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 v)\n{\n    return vec3(saturate(v.x), saturate(v.y), saturate(v.z));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Quantize(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec2 Quantize(vec2 x, vec2 resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec2 Quantize(vec2 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec3 Quantize(vec3 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec3 Quantize(vec3 x, vec3 resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec3 HSVtoColor(float hue, float saturation, float value)\n{\n    float hi = mod(floor(hue / 60.), 6.);\n    float f = hue / 60. - floor(hue / 60.);\n\n    value = value;\n    float v = value;\n    float p = value * (1. - saturation);\n    float q = value * (1. - f * saturation);\n    float t = value * (1. - (1. - f) * saturation);\n\n    if (hi == 0.)\n        return vec3(v, t, p);\n    else if (hi == 1.)\n        return vec3(q, v, p);\n    else if (hi == 2.)\n        return vec3(p, v, t);\n    else if (hi == 3.)\n        return vec3(p, q, v);\n    else if (hi == 4.)\n        return vec3(t, p, v);\n    else\n        return vec3(v, p, q);\n}\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n        \nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoiseRotate(vec2 center, float r, float t)\n{\n    t *= TAU;\n    float s = sin(t), c = cos(t);\n    vec2 p = center + r * vec2(s, c);\n    return snoise(p);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\n\nfloat pnoise(vec2 P, vec2 rep)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\nvec2 cellular(vec3 P)\n{\n    const float K = 0.142857142857; // 1/7\n    const float Ko = 0.428571428571; // 1/2-K/2\n    const float K2 = 0.020408163265306; // 1/(7*7)\n    const float Kz = 0.166666666667; // 1/6\n    const float Kzo = 0.416666666667; // 1/2-1/6*2\n    const float jitter = 1.0f; // smaller jitter gives more regular pattern\n\n    vec3 Pi = mod289(floor(P));\n    vec3 Pf = fract(P) - 0.5;\n    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n    vec3 p1 = permute(p + Pi.y - 1.0);\n    vec3 p2 = permute(p + Pi.y);\n    vec3 p3 = permute(p + Pi.y + 1.0);\n    vec3 p11 = permute(p1 + Pi.z - 1.0);\n    vec3 p12 = permute(p1 + Pi.z);\n    vec3 p13 = permute(p1 + Pi.z + 1.0);\n    vec3 p21 = permute(p2 + Pi.z - 1.0);\n    vec3 p22 = permute(p2 + Pi.z);\n    vec3 p23 = permute(p2 + Pi.z + 1.0);\n    vec3 p31 = permute(p3 + Pi.z - 1.0);\n    vec3 p32 = permute(p3 + Pi.z);\n    vec3 p33 = permute(p3 + Pi.z + 1.0);\n    vec3 ox11 = fract(p11 * K) - Ko;\n    vec3 oy11 = mod7(floor(p11 * K)) * K - Ko;\n    vec3 oz11 = floor(p11 * K2) * Kz - Kzo; // p11 < 289 guaranteed\n    vec3 ox12 = fract(p12 * K) - Ko;\n    vec3 oy12 = mod7(floor(p12 * K)) * K - Ko;\n    vec3 oz12 = floor(p12 * K2) * Kz - Kzo;\n    vec3 ox13 = fract(p13 * K) - Ko;\n    vec3 oy13 = mod7(floor(p13 * K)) * K - Ko;\n    vec3 oz13 = floor(p13 * K2) * Kz - Kzo;\n    vec3 ox21 = fract(p21 * K) - Ko;\n    vec3 oy21 = mod7(floor(p21 * K)) * K - Ko;\n    vec3 oz21 = floor(p21 * K2) * Kz - Kzo;\n    vec3 ox22 = fract(p22 * K) - Ko;\n    vec3 oy22 = mod7(floor(p22 * K)) * K - Ko;\n    vec3 oz22 = floor(p22 * K2) * Kz - Kzo;\n    vec3 ox23 = fract(p23 * K) - Ko;\n    vec3 oy23 = mod7(floor(p23 * K)) * K - Ko;\n    vec3 oz23 = floor(p23 * K2) * Kz - Kzo;\n    vec3 ox31 = fract(p31 * K) - Ko;\n    vec3 oy31 = mod7(floor(p31 * K)) * K - Ko;\n    vec3 oz31 = floor(p31 * K2) * Kz - Kzo;\n    vec3 ox32 = fract(p32 * K) - Ko;\n    vec3 oy32 = mod7(floor(p32 * K)) * K - Ko;\n    vec3 oz32 = floor(p32 * K2) * Kz - Kzo;\n    vec3 ox33 = fract(p33 * K) - Ko;\n    vec3 oy33 = mod7(floor(p33 * K)) * K - Ko;\n    vec3 oz33 = floor(p33 * K2) * Kz - Kzo;\n    vec3 dx11 = Pfx + jitter * ox11;\n    vec3 dy11 = Pfy.x + jitter * oy11;\n    vec3 dz11 = Pfz.x + jitter * oz11;\n    vec3 dx12 = Pfx + jitter * ox12;\n    vec3 dy12 = Pfy.x + jitter * oy12;\n    vec3 dz12 = Pfz.y + jitter * oz12;\n    vec3 dx13 = Pfx + jitter * ox13;\n    vec3 dy13 = Pfy.x + jitter * oy13;\n    vec3 dz13 = Pfz.z + jitter * oz13;\n    vec3 dx21 = Pfx + jitter * ox21;\n    vec3 dy21 = Pfy.y + jitter * oy21;\n    vec3 dz21 = Pfz.x + jitter * oz21;\n    vec3 dx22 = Pfx + jitter * ox22;\n    vec3 dy22 = Pfy.y + jitter * oy22;\n    vec3 dz22 = Pfz.y + jitter * oz22;\n    vec3 dx23 = Pfx + jitter * ox23;\n    vec3 dy23 = Pfy.y + jitter * oy23;\n    vec3 dz23 = Pfz.z + jitter * oz23;\n    vec3 dx31 = Pfx + jitter * ox31;\n    vec3 dy31 = Pfy.z + jitter * oy31;\n    vec3 dz31 = Pfz.x + jitter * oz31;\n    vec3 dx32 = Pfx + jitter * ox32;\n    vec3 dy32 = Pfy.z + jitter * oy32;\n    vec3 dz32 = Pfz.y + jitter * oz32;\n    vec3 dx33 = Pfx + jitter * ox33;\n    vec3 dy33 = Pfy.z + jitter * oy33;\n    vec3 dz33 = Pfz.z + jitter * oz33;\n    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n    // Sort out the two smallest distances (F1, F2)\n    // Do it right and sort out both F1 and F2\n    vec3 d1a = min(d11, d12);\n    d12 = max(d11, d12);\n    d11 = min(d1a, d13); // Smallest now not in d12 or d13\n    d13 = max(d1a, d13);\n    d12 = min(d12, d13); // 2nd smallest now not in d13\n    vec3 d2a = min(d21, d22);\n    d22 = max(d21, d22);\n    d21 = min(d2a, d23); // Smallest now not in d22 or d23\n    d23 = max(d2a, d23);\n    d22 = min(d22, d23); // 2nd smallest now not in d23\n    vec3 d3a = min(d31, d32);\n    d32 = max(d31, d32);\n    d31 = min(d3a, d33); // Smallest now not in d32 or d33\n    d33 = max(d3a, d33);\n    d32 = min(d32, d33); // 2nd smallest now not in d33\n    vec3 da = min(d11, d21);\n    d21 = max(d11, d21);\n    d11 = min(da, d31); // Smallest now in d11\n    d31 = max(da, d31); // 2nd smallest now not in d31\n    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n    d12 = min(d12, d21); // 2nd smallest now not in d21\n    d12 = min(d12, d22); // nor in d22\n    d12 = min(d12, d31); // nor in d31\n    d12 = min(d12, d32); // nor in d32\n    d11.yz = min(d11.yz, d12.xy); // nor in d12.yz\n    d11.y = min(d11.y, d12.z); // Only two more to go\n    d11.y = min(d11.y, d11.z); // Done! (Phew!)\n    return sqrt(d11.xy); // F1, F2\n}\n\n   \nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                  -0.80,  0.36, -0.48,\n                  -0.60, -0.48,  0.64 );\n\n   \nfloat fbm_4r( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n    }\n\treturn a;\n}\n\nfloat fbm_4r( in vec3 x, mat3 rot)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\nfloat fmb4_3x( in vec3 x)\n{\n    return fbm_4(x + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat fmb4r_3x( in vec3 x, mat3 rot)\n{\n    return fbm_4r(x + vec3(fbm_4r(x + vec3(fbm_4r(x, rot), rot), rot)));\n}\n\nfloat fmb4_3x( in vec3 x, vec3 offset)\n{\n    return fbm_4(x + offset + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\n\nfloat cellfbmr( in vec2 x, mat2 rot, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\n\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec2 NextVec2(vec2 rmin, vec2 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\n// Quaternion multiplication.\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\n// Rotate a vector with a rotation quaternion.\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\nvec4 qInverse(vec4 q)\n{\n    vec4 x = q;\n    return vec4(1.0/(dot(x, x)) * x * vec4(-1.0, -1.0, -1.0, 1.0));\n}\n\nvec4 qLookAt(vec3 forward, vec3 up)\n{\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward, right));\n\n    float m00 = right.x;\n    float m01 = right.y;\n    float m02 = right.z;\n    float m10 = up.x;\n    float m11 = up.y;\n    float m12 = up.z;\n    float m20 = forward.x;\n    float m21 = forward.y;\n    float m22 = forward.z;\n\n    float num8 = (m00 + m11) + m22;\n    vec4 q = vec4(0., 0., 0., 1.);\n    if (num8 > 0.0)\n    {\n        float num = sqrt(num8 + 1.0);\n        q.w = num * 0.5;\n        num = 0.5 / num;\n        q.x = (m12 - m21) * num;\n        q.y = (m20 - m02) * num;\n        q.z = (m01 - m10) * num;\n        return q;\n    }\n\n    if ((m00 >= m11) && (m00 >= m22))\n    {\n        float num7 = sqrt(((1.0 + m00) - m11) - m22);\n        float num4 = 0.5 / num7;\n        q.x = 0.5 * num7;\n        q.y = (m01 + m10) * num4;\n        q.z = (m02 + m20) * num4;\n        q.w = (m12 - m21) * num4;\n        return q;\n    }\n\n    if (m11 > m22)\n    {\n        float num6 = sqrt(((1.0 + m11) - m00) - m22);\n        float num3 = 0.5 / num6;\n        q.x = (m10 + m01) * num3;\n        q.y = 0.5 * num6;\n        q.z = (m21 + m12) * num3;\n        q.w = (m20 - m02) * num3;\n        return q;\n    }\n\n    float num5 = sqrt(((1.0 + m22) - m00) - m11);\n    float num2 = 0.5 / num5;\n    q.x = (m20 + m02) * num2;\n    q.y = (m21 + m12) * num2;\n    q.z = 0.5 * num5;\n    q.w = (m01 - m10) * num2;\n    return q;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}