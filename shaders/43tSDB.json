{
    "Shader": {
        "info": {
            "date": "1724816137",
            "description": "for izzy",
            "flags": 0,
            "hasliked": 0,
            "id": "43tSDB",
            "likes": 3,
            "name": "tangent city",
            "published": 3,
            "tags": [
                "noise",
                "fast",
                "perlin",
                "compressed"
            ],
            "usePreview": 0,
            "username": "homek",
            "viewed": 68
        },
        "renderpass": [
            {
                "code": "\n\n\nint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return int(hash);\n}\n\n\nfloat rand(vec2 uv) {\n    const highp float a = 12.9898;\n    const highp float b = 78.233;\n    const highp float c = 43758.5453;\n    highp float dt = dot(uv, vec2(a, b));\n    highp float sn = mod(dt, 3.1415);\n    return fract(sin(sn) * c);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 fractPosition = fract(position);\n    uvec2 cellCoordinates = uvec2(floor(position));\n    vec2 t = fractPosition * fractPosition * fractPosition * (fractPosition * (fractPosition * 6.0 - 15.0) + 10.0);\n    return mix(mix(dot(vec2(((hash(cellCoordinates, seed) & 1) * 2) - 1 , (((hash(cellCoordinates, seed) >> 1) & 1) * 2) - 1), fractPosition), dot(vec2(((hash((cellCoordinates + uvec2(1, 0)), seed) & 1) * 2) - 1 , (((hash((cellCoordinates + uvec2(1, 0)), seed) >> 1) & 1) * 2) - 1), fractPosition - vec2(1.0, 0.0)), t.x), mix(dot(vec2(((hash((cellCoordinates + uvec2(0, 1)), seed) & 1) * 2) - 1 , (((hash((cellCoordinates + uvec2(0, 1)), seed) >> 1) & 1) * 2) - 1), fractPosition - vec2(0.0, 1.0)), dot(vec2(((hash((cellCoordinates + uvec2(1, 1)), seed) & 1) * 2) - 1 , (((hash((cellCoordinates + uvec2(1, 1)), seed) >> 1) & 1) * 2) - 1), fractPosition - vec2(1.0, 1.0)), t.x), t.y);\n}\n\nfloat FBM(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        // This could be faster if you made a single dim murmur hash alg but I'm going for compression, you can also just remove this\n        currentSeed = uint(hash(uvec2(currentSeed), 0x0U)); // create a new seed for each octave\n        \n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return (value + .5);\n}\n\nvec2 paralaxSpeed(vec2 uv, float horizenFromFront, float layerDistFromFront, float speedOfFront) {\n    float relativeTime = iTime + (1.5 + sin(iTime/5.));\n\n    return uv + vec2(\n     relativeTime\n    * (((horizenFromFront - layerDistFromFront) * speedOfFront) / horizenFromFront),\n    0.);\n}\n\nvec4 layerCity(\n    vec2 fragCoord, \n    float CITY_LINE, \n    vec2 CITY_HEIGHT,\n    float CITYBUILDINGWIDTH,\n    float CITYSPACING,\n    float SEED,\n    vec3 CITYCOLOR) {\n    \n    float totalDist = CITYBUILDINGWIDTH + CITYSPACING;\n    \n    float cellX = floor(fragCoord.x/totalDist);\n    float buildingOffset = rand(vec2(SEED, cellX)) * CITYSPACING;\n    float cellOffset = mod(fragCoord.x, totalDist);\n    float buildingHeight = (CITY_HEIGHT.y - CITY_HEIGHT.x) * rand(vec2(cellX, SEED));\n    \n    \n    \n    if(\n    fragCoord.y > (iResolution.y/2.) + CITY_LINE &&  // Bottom border\n    cellOffset > buildingOffset &&\n    cellOffset < buildingOffset + CITYBUILDINGWIDTH &&\n    fragCoord.y < (iResolution.y/2.) + CITY_LINE + CITY_HEIGHT.x + buildingHeight\n    )\n        return vec4(CITYCOLOR,1.);\n    \n    \n    \n    \n    return vec4(0.);\n}\n\nvec4 layerForest(\n    vec2 fragCoord,\n    float FOREST_LINE,\n    float FOREST_HEIGHT,\n    float FOREST_PERC,\n    vec3 FOREST_COLOR,\n    int OCTAVE,\n    int FREQ\n    ) {\n    \n    vec2 uv = fragCoord / iResolution.y;\n\n    float treeHeight = pow(FBM(vec2(uv.x, 0.), FREQ, OCTAVE, 0.5, 2.0,  0x578437adU),2.); // multiple octaves\n    \n    if(\n        fragCoord.y > (iResolution.y/2.) + FOREST_LINE && // Bottom border\n        fragCoord.y < (iResolution.y/2.) + FOREST_LINE + (treeHeight * FOREST_HEIGHT * (1. -FOREST_PERC )) + (FOREST_PERC * FOREST_HEIGHT)\n    )\n        return vec4(FOREST_COLOR,1.);\n\n    return vec4(0.);\n}\n\nvec4 layerRoad(\n    vec2 fragCoord,\n    float ROAD_LINE,\n    float ROAD_HEIGHT\n    ) {\n    \n    float DASH_HEIGHT = 8.;\n    float DASH_PERC = 0.5;\n    float DASH_WIDTH = 80.;\n\n    if(\n        fragCoord.y > (iResolution.y/2.) + ROAD_LINE + (ROAD_HEIGHT/2.) && // Bottom border\n        fragCoord.y < (iResolution.y/2.) + ROAD_LINE + (ROAD_HEIGHT/2.) + DASH_HEIGHT &&\n        mod(fragCoord.x, DASH_WIDTH) < DASH_WIDTH * DASH_PERC\n        )\n        return vec4(vec3(0.933,0.914,0.541),1.);\n    \n    if(\n        fragCoord.y > (iResolution.y/2.) + ROAD_LINE && // Bottom border\n        fragCoord.y < (iResolution.y/2.) + ROAD_LINE + ROAD_HEIGHT\n    )\n        return vec4(vec3(0.267,0.388,0.455),1.);\n\n    return vec4(0.);\n}\n\n\nvec4 layerStars( vec2 fragCoord) {\n    fragCoord = floor(fragCoord);\n\n    \n    float starVal = smoothstep(0.990, 1.0, rand(fragCoord));\n    \n    if(starVal > .05)\n        return vec4(vec3(starVal),1.);\n        \n    //color += step(0.99, stars) * t;\n    return vec4(0.);\n}\n\nvec2 rotateFragCoord(vec2 fragCoord) {\n    // Step 1: Translate fragCoord to the center of the screen\n    vec2 centeredCoord = fragCoord - (iResolution.xy * 0.5) + vec2(0.,4000.);\n\n    // Step 2: Compute the rotation angle (clockwise)\n    float angle = iTime * -0.001;\n\n    // Step 3: Create the rotation matrix\n    mat2 rotationMatrix = mat2(\n        cos(angle), sin(angle),\n        -sin(angle), cos(angle)\n    );\n\n    // Step 4: Apply the rotation\n    centeredCoord = rotationMatrix * centeredCoord;\n\n    // Step 5: Translate back to original position\n    return centeredCoord + iResolution.xy * 0.5;\n}\n\n\n#define FRONT_SPEED 1500.\n\n#define layer() if(fragColor.w != 0.){ fragColor = mix(fragColor, vec4(vec3(rand(fragCoord)),1.), 0.15 * (1. - (fragCoord / iResolution.y)).y);  return; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //position.x *= iResolution.x / iResolution.y;\n    //position += iTime * .25;\n    uint seed = 0x578437adU;\n    \n\n    \n    \n    \n    fragColor = vec4(0.);\n    layer();\n    fragColor = layerForest( paralaxSpeed(fragCoord, 2000., -200., FRONT_SPEED), -2060., 1600., 0.98,  vec3(0.098,0.176,0.314), 4, 14);\n    layer();\n    fragColor = layerForest( paralaxSpeed(fragCoord, 2000., 200., FRONT_SPEED), -1560., 1250., 0.97, vec3(0.122,0.224,0.302), 4, 14);\n    layer();\n    fragColor = layerForest( paralaxSpeed(fragCoord, 2000., 550., FRONT_SPEED), -460., 200., 0.9, vec3(0.365,0.655,0.365), 4, 14);\n\n    \n    \n    layer();\n    fragColor = layerRoad( paralaxSpeed(fragCoord, 2000., 700., FRONT_SPEED), -280., 103. );\n    \n    layer();\n    fragColor = layerForest( paralaxSpeed(fragCoord, 2000., 750., FRONT_SPEED), -180., 40., 0.5, vec3(0.365,0.655,0.365), 4, 9);\n    layer();\n    fragColor = layerForest( paralaxSpeed(fragCoord, 2000., 1200., FRONT_SPEED), -180., 90., 0.5, vec3(0.122,0.224,0.302), 4, 7);\n    layer();\n    fragColor = layerForest( paralaxSpeed(fragCoord, 2000., 1700., FRONT_SPEED), -180., 140., 0.5, vec3(0.098,0.176,0.314), 10, 5);\n    \n    layer();\n    fragColor = layerCity(paralaxSpeed(fragCoord, 2000., 1870., FRONT_SPEED), -120., vec2(60.,210.), 80., 0., 4., vec3(0.027,0.047,0.114));\n    layer();\n    fragColor = layerCity(paralaxSpeed(fragCoord, 2000., 1910., FRONT_SPEED), -120., vec2(150.,265.), 150., 90., 3., vec3(0.027,0.047,0.114));\n    layer();\n    fragColor = layerCity(paralaxSpeed(fragCoord, 2000., 1950., FRONT_SPEED), -120., vec2(200.,390.), 75., 60., 2., vec3(0.027,0.047,0.114));\n\n    \n    layer();\n    fragColor = layerStars(rotateFragCoord(fragCoord.xy) );\n    \n    \n    layer();\n    fragColor = vec4(vec3(0.161,0.082,0.275), 1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}