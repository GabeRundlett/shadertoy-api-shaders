{
    "Shader": {
        "info": {
            "date": "1510059861",
            "description": "A couple of screen warp effects for 2D backgrounds, perhaps useful for 2D games like platformers.\nUse keys 1-5 to switch between different effects. Drag the mouse to change the width and radius of the effect.",
            "flags": 48,
            "hasliked": 0,
            "id": "4l2cWW",
            "likes": 15,
            "name": "Screen warp effects",
            "published": 3,
            "tags": [
                "2d",
                "vertical",
                "camerafilter",
                "screenwarp"
            ],
            "usePreview": 0,
            "username": "FTPlus",
            "viewed": 1279
        },
        "renderpass": [
            {
                "code": "/*\n * A couple of screen warp effects for 2D backgrounds\n * As a limitation the effects only transform strips vertically;\n * each column of the original image can be displaced and stretched vertically.\n * \n * The code can be used freely and is licened under the zlib license.\n * by FTPlus, October 2017\n */\n\nconst vec4 BGCOLOR = vec4(.53, .44, .67, 1.);\n#define W (iResolution.x)\n#define H (iResolution.y)\n\n// From the wiki :P\nfloat rand(float n) { return fract(cos(n*89.42)*343.42); }\n\n// Describes a vertical strip taken from the source screen\nstruct column\n{\n    float y;\n    float height;\n};\n\n// Transforms the coordinates so they match the column retuned by an effect.\nvoid applyEffect(inout vec2 coord, in column col)\n{\n    coord.y = ((coord.y + col.y) * col.height) / iResolution.y;\n}\n\n// Planet surface effect for 2D backgrounds\n// Works by shifting columns downwards\ncolumn planetEffect(float x, float w/*idth*/, float r/*adius*/)\n{\n    if (x >= w && x <= W - w)\n        return column(0., H);\n    x -= (W / 2.);\n    float x0 = w - (W / 2.);\n    float y = sqrt(r * r - x0 * x0) - sqrt(r * r - x * x);\n    return column(y, H);\n}\n\n// As above but also scales columns accordingly\ncolumn planetEffect2(float x, float w/*idth*/, float r/*adius*/)\n{\n    if (x >= w && x <= W - w)\n        return column(0., H);\n    x -= (W / 2.);\n    float x0 = w - (W / 2.);\n    float y = sqrt(r * r - x0 * x0) - sqrt(r * r - x * x);\n    float R = r + H;\n    float h = H + sqrt(R * R - x0 * x0) - sqrt(R * R - x * x);\n    return column(y, h - y);\n}\n\n// Inside-a-barrel effect for 2D backgrounds\ncolumn barrelEffect(float x, float w/*idth*/, float r/*adius*/)\n{\n    if (x >= w && x <= W - w)\n        return column(0., H);\n    x -= (W / 2.);\n    float x0 = w - (W / 2.);\n    float y = sqrt(r * r - x0 * x0) - sqrt(r * r - x * x);\n    return column(y, H - y - y);\n}\n\n// A very cheesy rain effect for 2D backgrounds\ncolumn rainEffect(float x, float w/*idth*/, float r/*adius*/)\n{\n    if (x >= w && x <= W - w)\n        return column(0., H);\n    x -= (W / 2.);\n    float x0 = w - (W / 2.);\n    float h = 1. + sqrt(r * r - x0 * x0) - sqrt(r * r - x * x);\n    float y = fract(rand(x) + iTime) * h;\n    return column(y, H - y);\n}\n\n// Paper scrolling effect, useful for maps\ncolumn scrollEffect(float x, float w/*idth*/, float r/*adius*/)\n{\n    if (x >= w && x <= W - w)\n        return column(0., H);\n    x -= (W / 2.);\n    float x0 = w - (W / 2.);\n    r *= 4.;\n    float t = sqrt(r * r - x0 * x0) - sqrt(r * r - x * x);\n    float y = sin(t + iTime / 2.) * t;\n    return column(y, H);\n}\n\n// Darkening the sides of the screen\nvoid applyFalloff(inout vec4 color, in vec2 coord, float w/*idth*/)\n{\n    float c = (W / 2.);\n    float x = c - abs(c - coord.x);\n    if (x < w)\n    \tcolor *= sqrt(x / w);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    float width = W / 3.;\n    float radius = W * 2.5;\n    \n    if (iMouse.z > .5)\n    {\n        width = min(iMouse.x, (W / 2.));\n        radius = W * mix(.75, 20., iMouse.y / W);\n    }\n    \n    int effect = int(texelFetch(iChannel1, ivec2(10,10), 0).r * 10.);\n   \tif (effect == 0)\n    \tapplyEffect(coord, planetEffect(coord.x, width, radius));\n    else if (effect == 1)\n    \tapplyEffect(coord, planetEffect2(coord.x, width, radius));\n    else if (effect == 2)\n    \tapplyEffect(coord, barrelEffect(coord.x, width, radius));\n    else if (effect == 3)\n    \tapplyEffect(coord, rainEffect(coord.x, width, radius));\n    else if (effect == 4)\n    \tapplyEffect(coord, scrollEffect(coord.x, width, radius));\n    \n    // Draw the effect and a background behind it\n    if (coord.y >= 0.0 && coord.y < iResolution.y)\n    {\n\t\tvec4 grid = texture(iChannel0, coord / iResolution.xy);\n        vec4 scene = texture(iChannel2, coord / iResolution.xy);\n        color.a = 1.;\n        color.rgb = mix(grid.rgb, scene.rgb, scene.a);\n    }\n    else\n        color = BGCOLOR;\n    \n    // Darken the edges for added depth perception\n    applyFalloff(color, coord, width);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// A simple grid to please the eyes\n\nconst vec4 BGCOLOR = vec4(.95, .9, .77, 1.);\nconst vec4 GRIDCOLOR = vec4(.39, .16, .11, 1.);\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{    \n    coord -= iResolution.xy / 2.;\n    \n    coord.x += sin(iTime / 2.) * 128.;\n    \n    color = BGCOLOR;\n    if (int(coord.x) % 64 == 0 || int(coord.y) % 64 == 0)\n        color = GRIDCOLOR;\n    else if ((int(coord.x) - 32) % 64 == 0 || (int(coord.y) - 32) % 64 == 0)\n        color = mix(BGCOLOR, GRIDCOLOR, .4);\n    \n    if (coord.y < iResolution.y * -.3)\n        color = mix(color, GRIDCOLOR, .25);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Keyboard interaction:\n// remembers which key was pressed\n\n#define KEYDOWN(kc) (texelFetch(iChannel1, ivec2((kc), 0), 0).x > 0.5)\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    if (iFrame < 1)\n    {\n        color = vec4(.25, .0, .0, .0);\n        return;\n    }\n    color = texture(iChannel0, coord / iResolution.xy);\n    \n    for (int i = 0; i < 9; ++i)\n    {\n        if (KEYDOWN(49 + i))\n        {\n            color.r = float(i) * .1;\n            break;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// A simple scene to see the effects in perspective\n// I hope my ''original art work'' isn't too harsh on your eyes ;)\n\n#define RATIO .5625\n#define ASPECT vec2(iResolution.x, iResolution.x * RATIO)\n\n// common sd functions (thanks to iq)\n\nfloat sdRectangle(in vec2 p, in vec4 r)\n{\n    r.pq /= 2.;\n    vec2 d = abs(p - r.xy - r.pq) - r.pq;\n    d.y *= RATIO;\n  \t//return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n    // I prefer the Chebyshev distance in this case\n    return min(max(d.x, d.y), 0.) + max(max(d.x, d.y), 0.);\n}\n\nfloat sdEllipse(in vec2 p, in vec4 r)\n{\n    r.pq /= 2.;\n\treturn (length((p - r.xy - r.pq) / r.pq) - 1.) * min(r.p, r.q * RATIO);\n}\n\n// sd functions of tree\n\nconst vec4 treetrunk[9] = vec4[9](\n    vec4(0.6904, 0.1780, 0.0381, 0.0339),\n\tvec4(0.7109, 0.1832, 0.0293, 0.0391),\n\tvec4(0.7227, 0.2066, 0.0820, 0.0547),\n\tvec4(0.7725, 0.1988, 0.0396, 0.0391),\n\tvec4(0.7871, 0.1806, 0.0469, 0.0391),\n\tvec4(0.8369, 0.4149, 0.0513, 0.0208),\n\tvec4(0.8047, 0.3889, 0.0483, 0.0339),\n\tvec4(0.7988, 0.3550, 0.0161, 0.0547),\n\tvec4(0.7388, 0.2613, 0.0601, 0.2656));\n\nfloat sdTreetrunk(in vec2 p)\n{\n    float dist = 10.;\n    for (int i = 0; i < 9; ++i)\n        dist = min(dist, sdRectangle(p, treetrunk[i]));\n    return dist;\n}\n\nconst vec4 treecrown[13] = vec4[13](\n\tvec4(0.6831, 0.4696, 0.0674, 0.1068),\n\tvec4(0.6611, 0.5503, 0.0864, 0.1432),\n\tvec4(0.6860, 0.6493, 0.0527, 0.0938),\n\tvec4(0.7271, 0.6311, 0.0615, 0.1380),\n\tvec4(0.7739, 0.6753, 0.0483, 0.0703),\n\tvec4(0.7915, 0.6128, 0.0703, 0.0911),\n\tvec4(0.8091, 0.5425, 0.0410, 0.0859),\n\tvec4(0.7842, 0.4826, 0.0469, 0.0677),\n\tvec4(0.6978, 0.4905, 0.1436, 0.2292),\n\tvec4(0.8530, 0.3993, 0.0542, 0.0755),\n\tvec4(0.8457, 0.4436, 0.0308, 0.0521),\n\tvec4(0.8691, 0.4436, 0.0337, 0.0521),\n\tvec4(0.8574, 0.3785, 0.0322, 0.0599));\n\nfloat sdTreecrown(in vec2 p)\n{\n    float dist = 10.;\n    for (int i = 0; i < 13; ++i)\n        dist = min(dist, sdEllipse(p, treecrown[i]));\n    return dist;\n}\n\nfloat sdTreehole(in vec2 p) { return sdEllipse(p, vec4(0.7490, 0.3472, 0.0381, 0.0651)); }\n\n// sd functions of house\n\nfloat sdHousefacade(in vec2 p) { return sdRectangle(p, vec4(0.1855, 0.1736, 0.3125, 0.3819)); }\nfloat sdHousedoor(in vec2 p)   { return sdRectangle(p, vec4(0.3809, 0.1736, 0.0586, 0.1736)); }\nfloat sdDoorknob(in vec2 p)    { return sdEllipse  (p, vec4(0.4199, 0.2257, 0.0098, 0.0174)); }\n\nconst vec4 housewindows[4] = vec4[4](\n    vec4(0.2344, 0.3819, 0.0781, 0.1389),\n\tvec4(0.3711, 0.3819, 0.0781, 0.1389),\n\tvec4(0.2344, 0.2083, 0.0781, 0.1389),\n\tvec4(0.3906, 0.2604, 0.0391, 0.0694));\n\nfloat sdWindow(in vec2 p, in vec4 r, in float t/*hickness*/)\n{\n    vec2 o = (1. / ASPECT) * t;\n    r.pq = r.pq / 2. - o;\n    return min(min(min(\n        sdRectangle(p, r),\n        sdRectangle(p, r + vec4(r.p + o.x + o.x, 0., 0., 0.))),\n        sdRectangle(p, r + vec4(0., r.q + o.y + o.y, 0., 0.))),\n        sdRectangle(p, r + vec4(r.pq + o + o, 0., 0.))\n    );\n}\n        \nfloat sdHousewindows(in vec2 p)\n{\n    float dist = 10.;\n    for (int i = 0; i < 4; ++i)\n        dist = min(dist, sdWindow(p, housewindows[i], 2.));\n    return dist;\n}\n\nfloat sdHouseroof(in vec2 p)    { return sdRectangle(p, vec4(0.1660, 0.5208, 0.3516, 0.1910)); }\nfloat sdHousechimney(in vec2 p) { return sdRectangle(p, vec4(0.4395, 0.6424, 0.0586, 0.1736)); }\n\n// Drawing the scene\n\nstruct object\n{\n    float sd;\n    vec3 color;\n};\n\nvoid draw(in vec2 p, inout vec4 c, object o, float t/*hickness*/)\n{\n    float P = 1. / ASPECT.x;\n    t = P / t;\n    float a = 1. - smoothstep(P + t, P + t + P, o.sd);\n    float b = 1. - smoothstep(0., P, o.sd);\n    vec3 color2 = o.color / 2.;\n    c.rgb = mix(c.rgb, color2, a);\n    c.rgb = mix(c.rgb, o.color, b);\n    c.a = max(c.a, a);\n}\n   \nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    color = vec4(0.);\n    color = texture(iChannel0, coord / iResolution.xy) * .75; // ''motion blur''\n    coord.x = floor(coord.x + sin(iTime / 2.) * 128.);\n    \n    vec2 p = coord / ASPECT;\n    \n    object scene[9] = object[9](\n        object(sdTreetrunk(p), vec3(.39, .16, .11)),\n        object(sdTreecrown(p), vec3(.39, .95, .11)),\n        object(sdTreehole(p), vec3(.19, .16, .11)),\n        object(sdHousefacade(p), vec3(.95, .9, .44)),\n        object(sdHousedoor(p), vec3(.39, .16, .11)),\n        object(sdDoorknob(p), vec3(.95, .9, .11)),\n    \tobject(sdHousewindows(p), vec3(.50, .45, .77)),\n    \tobject(sdHouseroof(p), vec3(.95, .45, .22)),\n    \tobject(sdHousechimney(p), vec3(.95, .9, .44)));\n    \n    // Painter's algorithm because I'm lazy\n    for (int i = 0; i < 9; ++i)\n        draw(p, color, scene[i], 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}