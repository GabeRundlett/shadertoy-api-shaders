{
    "Shader": {
        "info": {
            "date": "1692328814",
            "description": "A study of ray marching, and using noise.  There are many artifacts (most close to camera) that need to be fixed",
            "flags": 0,
            "hasliked": 0,
            "id": "mtjcDV",
            "likes": 11,
            "name": "Mountain RAY MARCH",
            "published": 3,
            "tags": [
                "terrain",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Blindman67",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "\nconst Ray sun = Ray(vec3(0), normalize(vec3(0.8, 0.4, -0.2)));\nstruct Norms {\n    vec3 nL;\n    vec3 n;\n    vec3 nH;\n};\n/* Used by Noise2D */\nmat2 twist;\nconst mat2 twist1 = mat2(sin(0.3), -cos(0.3), cos(0.3), sin(0.3));\nconst mat2 twist2 = mat2(0.6, -0.8, 0.8, 0.632);\n\nfloat TerrainSDF(vec2 coord, uint stopAt) {\n    vec2 p = coord;\n    float a = 0.0, b = 1.0;\n    vec2 d = vec2(0);\n    uint i = 0u;\n    while (i < stopAt) {\n        vec3 n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    return 120.0 * a;\n}\nvec3 TerrainSDF(vec2 coord) {\n    vec2 p = coord;\n    float a = 0.0, b = 1.0;\n    vec2 d = vec2(0);\n    uint i = 0u;\n    vec3 n, res;\n    while (i < 3u) {\n        n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.x = 120.0 * a;\n    while (i < 8u) {\n        n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.y = 120.0 * a;\n    while (i < 16u) {\n        n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.z = 120.0 * a;\n    return res;\n}\nfloat RayMarch(Ray ray, float dist, float maxDist) {\n    vec3 p = ray.origin + dist * ray.dir;\n    for(uint i = 0u; i < MAX_ITER && dist < maxDist; i++) {\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 8u);\n        if (abs(h) < EPSILON * dist) { return dist; }\n        h *= 0.6;\n        p += h * ray.dir;\n        dist += h;\n    }\n    return dist;\n}\nfloat RayShadow(Ray ray, float dis) {\n    float minStep = clamp(0.01 * dis, 0.5, 50.0);\n    float res = 1.0;\n    float dist = 0.001;\n    for(int i = 0; i < 80; i++) {\n        vec3 p = ray.origin + dist * ray.dir;\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 8u);\n        res = min(res, 8.0 * h / dist);\n        dist += max(minStep, h);\n        if(res < 0.001 || p.y > 200.0) {  break; }\n    }\n    return UClamp(res);\n}\nvec3 CalcNorm(vec3 pos, float dist, uint stopAt) {\n    vec2 e = vec2(0.001 * dist, 0);\n    return normalize(vec3(\n        TerrainSDF((pos.xz - e.xy) * MAP_SCALE, stopAt) - TerrainSDF((pos.xz + e.xy) * MAP_SCALE, stopAt), \n        2.0 * e.x, \n        TerrainSDF((pos.xz - e.yx) * MAP_SCALE, stopAt) - TerrainSDF((pos.xz + e.yx) * MAP_SCALE, stopAt)\n    ));\n}\nNorms CalcNorms(vec3 pos, float dist) {\n    vec2 e = vec2(0.001 * dist * MAP_SCALE , 0);\n    vec2 p = pos.xz * MAP_SCALE;\n    vec3 A = TerrainSDF(p - e.xy);\n    vec3 B = TerrainSDF(p + e.xy);\n    vec3 C = TerrainSDF(p - e.yx);\n    vec3 D = TerrainSDF(p + e.yx);\n    float e2 = 0.002 * dist;\n    return Norms(\n        normalize(vec3(A.x - B.x, e2, C.x - D.x)),\n        normalize(vec3(A.y - B.y, e2, C.y - D.y)),\n        normalize(vec3(A.z - B.z, e2, C.z - D.z))\n    );\n}\nvec3 DrawPixel(Ray ray) {\n    float dist = RayMarch(ray, MIN_DIST, MAX_DIST);\n    vec3 col = vec3(0);\n    vec3 atmosphere = vec3(0.3, 0.5, 0.85) - ray.dir.y * ray.dir.y * 0.5;\n    atmosphere = mix(atmosphere, 0.85 * vec3(0.7, 0.75, 0.85), pow(1.0 - max(ray.dir.y, 0.0), 4.0));\n\n    float sdot = UClamp(dot(ray.dir, sun.dir));\n    atmosphere += vec3(1.0, 0.7, 0.0) * pow(sdot, 5.0);\n    atmosphere += vec3(1.5, 1.2, 0.6) * pow(sdot, 64.0);\n    atmosphere += vec3(2.0, 2.0, 1.1) * pow(sdot, 512.0);\n    atmosphere += vec3(1.0, 0.7, 0.3) * pow(sdot, 8.0);\n    \n    if (dist <= MAX_DIST) {\n        vec3 p = ray.origin + dist * ray.dir;\n        Norms norms = CalcNorms(p, dist);\n        float t = dot(norms.nH, vec3(0,1,0));\n        float snow = p.y + t * 10.0 > 75.0 ? dot(norms.n, vec3(0,1,0)) : 0.0;\n        float snowCover = UClamp((150.0 - p.y) / 150.0) + 0.3;\n        float green = p.y + t * 10.0 < 70.0 ? dot(norms.nH, vec3(0,1,0)) : 0.0;\n        float greenCover = UClamp(p.y / 150.0) + 0.5;\n        \n        vec3 rockC = mix(COl_A, COl_B, t);\n        float mixSnow = step(UClamp(snowCover), snow);\n        if (mixSnow > 0.5) {\n            twist = twist1;\n            norms.nL = CalcNorm(p, dist, 3u);\n            twist = twist2;\n        }\n        float mixGrass = step(UClamp(greenCover), green);\n        rockC = mix(rockC, COl_C, mixSnow);\n        rockC = mix(rockC, mix(COl_D, COl_D1, norms.nH.z * norms.nH.y), mixGrass);\n        col = t * rockC;\n        vec3(0);\n        vec3 n = mix(norms.nH, norms.nL, max(mixSnow, mixGrass));\n        float difuse = UClamp(dot(sun.dir, n));\n        float sh = RayShadow(sun, dist), shh = sh * sh;\n        float ambient = UClamp(n.y * 0.5 + 0.5);\n        float bac = UClamp(dot(vec3(-sun.dir.x, 0.0, sun.dir.z), n) * 0.8 + 0.2);\n        vec3 lin = vec3(8.0, 5.0, 3.0) * difuse * 1.5 * vec3(sh, shh * 0.5 + 0.5 * sh, shh * 0.8 + 0.2 * sh);\n        lin += vec3(0.4, 0.6, 1.0) * ambient * 6.0;\n        lin += vec3(0.4, 1.15, 1.6) * bac;\n        col = mix(col * lin, atmosphere, 1.0 - exp(-pow(0.002 * dist, 1.5)));\n    } else {\n        col = atmosphere;\n    }\n    return col;\n}\n\nvec3 GetPixel(in vec2 fragCoord) {\n    twist = twist2;\n    float time = Time(iFrame, ORBIT_SPEED);\n    vec3 invRes = InvRes(iResolution);\n    Ray ray = Ray(vec3(0), vec3(0));\n    ray.origin = vec3( cos(time) * ORBIT_RADIUS, cos(time) * 0.3 + 0.4, sin(time) * ORBIT_RADIUS);\n    ray.origin.y = TerrainSDF(ray.origin.xz * MAP_SCALE, 8u) + CAMERA_OFFSET;\n    vec2 px = 1.0 / iResolution.xy;   \n    vec2 uv = FixUV(fragCoord, iResolution) * invRes.y;\n    mat3 vmat;\n    if (time < 0.1) {\n        vmat = lookMouse(2.0 * (iMouse.xy + iResolution.xy * (invRes.xy * 0.55)) * invRes.xy);    \n    } else {\n        vmat = lookMouse(2.0 * iMouse.xy * invRes.xy);\n    }\n    #ifndef ANTI_ALIAS\n        ray.dir = normalize(vmat * vec3(uv, 2.0));\n        return  DrawPixel(ray);   \n    #else\n        vec3 col = vec3(0);\n        vec2 subPx = vec2(0);  \n        for (subPx.y = 0.0; subPx.y < 1.0; subPx.y += AA_STEP) {\n            for (subPx.x = 0.0; subPx.x < 1.0; subPx.x += AA_STEP) {\n                ray.dir = normalize(vmat * vec3(uv + px * subPx, 2.0));\n                vec3 c = DrawPixel(ray);   \n                col += c * c;\n\n            }\n        }\n        return pow(col * AA_SAMPLES, vec3(0.5));\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(1.0 - exp(-GetPixel(fragCoord) * 2.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define ANTI_ALIAS 3.0\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define FOG_SCALE 100.0\n#define FAR vec4(1e5)\n#define EPSILON 0.0001\n#define MAX_ITER 128u\n#define MAP_SCALE 0.003\n#define ORBIT_RADIUS 4012.0\n#define ORBIT_SPEED 0.0055\n#define CAMERA_OFFSET 10.0\n\nconst float INV_255 = 1.0 / 255.0;\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n#ifdef ANTI_ALIAS\n    const float AA_STEP = 1.0 / ANTI_ALIAS;\n    const float AA_SAMPLES = 1.0 / (ANTI_ALIAS * ANTI_ALIAS);\n#endif\nconst float inv_60 = 1.0 / 60.0;\n\nconst vec3  BG_Color = vec3 (0.45, 0.76, 1.0);\nconst vec3  COl_A = vec3(0.05, 0.043, 0.025);\nconst vec3  COl_B = vec3(0.057, 0.057, 0.05);\nconst vec3  COl_C = vec3(0.257, 0.257, 0.25);\nconst vec3  COl_D = vec3(0.028, 0.032, 0.02);\nconst vec3  COl_D1 = vec3(0.034, 0.035, 0.03);\nconst vec3  COLs[4] = vec3[](COl_A, COl_B, COl_C, COl_D);\nconst vec3  COl_Ambient = vec3(0.2, 0.3, 0.4);\nconst vec3  COl_Dark = vec3(0.2, 0.4, 0.3);\nconst vec3  COl_Light = vec3(1);\n\n\nconst vec3 lightPos1 = normalize(vec3(1, 1, -1));\nconst vec3 lightPos2 = normalize(vec3(-1, 0, 1));\n\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\nvec3 RGB2Color(float R, float G, float B) { return vec3(R * INV_255, G * INV_255, B * INV_255); }\nvec3 RGB2Color(uint R, uint G, uint B) { return vec3(float(R) * INV_255, float(G) * INV_255, float(B) * INV_255); }\n\nfloat UClamp(in float v) { return clamp(v, 0.0, 1.0); } /* U for unit */\n\n\nfloat Hash(vec2 pos) {\n    pos = fract(pos * 13.654678) * 65.247743;\n    return pow(fract((pos.x + pos.y) * pos.x * pos.y), 2.0);\n}\nvec3 Noise2D(vec2 pos) {\n    vec2 p = floor(pos);\n    float a = Hash(p);\n    float b = Hash(p + vec2(1, 0));\n    float c = Hash(p + vec2(0, 1));\n    float d = Hash(p + vec2(1, 1));\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * u * (1.0 - u);\n    return vec3(\n        a + (b - a) * u.x * (1.0 - u.y) + (c - a) * (1.0 - u.x) * u.y + (d - a) * u.x * u.y, \n        du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx)\n    );\n}\n\nvec3 InvRes(in vec3 res) { return 1.0 / res; }\nvec2 FixUV(in vec2 uv, in vec3 res) { return (2.0 * uv - res.xy); }\nfloat Time(in int f) { return float(f) * inv_60; }\nfloat Time(in int f, in float scale) { return float(f) * inv_60 * scale; }\nfloat plane(Ray ray, Ray plane){\n    float d = dot(plane.dir, ray.dir);\n    return d > MIN_DIST ? dot(plane.origin - ray.origin, plane.dir) / d : MAX_DIST;\n}\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\nmat3 lookMouse(in vec2 unitMouse) {\n    return camMatrix((unitMouse.x * 1.0 + 0.0) * PI, (unitMouse.y * 0.5 + 0.5) * PI);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}