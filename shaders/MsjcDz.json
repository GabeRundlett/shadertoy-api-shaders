{
    "Shader": {
        "info": {
            "date": "1491756139",
            "description": "Showing relation between sets. Drag your mouse around the left side. \nFor points that are on the inside of Mandelbrot set, Julia set is connected, and on the outside it becomes not connected.\nBased on: https://www.shadertoy.com/view/MtjSRw\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MsjcDz",
            "likes": 0,
            "name": "Mandelbrot and Julia relations",
            "published": 3,
            "tags": [
                "julia",
                "mandelbrot",
                "fractals",
                "educational"
            ],
            "usePreview": 0,
            "username": "andrut",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "/*\n  Based on: https://www.shadertoy.com/view/MtjSRw by jonathan potter  \n*/\n\nconst int MAX_ITERATIONS = 512;\n\nstruct complex { \n  float real;\n  float imaginary;\n};\n\nint fractal(complex c, complex z) {\n  for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\n    // z <- z^2 + c\n    float real = z.real * z.real - z.imaginary * z.imaginary + c.real;\n    float imaginary = 2.0 * z.real * z.imaginary + c.imaginary;\n\n    z.real = real;\n    z.imaginary = imaginary;\n\n    if (z.real * z.real + z.imaginary * z.imaginary > 4.0) {\n      return iteration;\n    }\n  }\n\n  return 10000;\n}\n\nint mandelbrot(vec2 coordinate) {\n  complex c = complex(coordinate.x, coordinate.y);\n  complex z = complex(0.0, 0.0);\n\n  return fractal(c, z);\n}\n\nint julia(vec2 coordinate, vec2 offset) {\n  complex c = complex(offset.x, offset.y);\n  complex z = complex(coordinate.x, coordinate.y);\n\n  return fractal(c, z);\n}\n\nvec2 fragCoordToXY(vec2 fragCoord) {\n  vec2 relativePosition = fragCoord.xy / iResolution.xy;\n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec2 cartesianPosition = (relativePosition - vec2(0.38, 0.5)) * 3.0;\n  cartesianPosition.x *= aspectRatio;\n\n  return cartesianPosition;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 coordinate    = fragCoordToXY(fragCoord);\n  vec2 clickPosition = fragCoordToXY(vec2(iMouse.x, iMouse.y));\n  if (iMouse.z < 1.0) {\n      clickPosition = vec2(cos(iTime/2.0)/4.0-1.1, sin(iTime/2.0)/4.0);\n  }\n  \n  float clickPoint;\n  int iters;\n  if (2.0*fragCoord.x > iResolution.x) {\n    iters = julia(coordinate - vec2(2.0, 0), clickPosition);    \n    float clickPoint = 0.0; \n  } else {\n    if(length(clickPosition - coordinate) < 0.02) {\n  \t  fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n      return;\n    }\n    iters = mandelbrot(coordinate);  \t    \n  }\n    \n  \n  if (iters > MAX_ITERATIONS) {\n      fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n  } else {\n      float color = pow(5.0 * float(iters) / float(MAX_ITERATIONS), 0.7);      \n      fragColor = vec4(color/3.0, color, color/2.0, 1.0);\n  }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}