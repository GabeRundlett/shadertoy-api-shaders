{
    "Shader": {
        "info": {
            "date": "1608210750",
            "description": "polished version of \"rikka\" http://glslsandbox.com/e#52473.0",
            "flags": 40,
            "hasliked": 0,
            "id": "3dyfDV",
            "likes": 19,
            "name": "[â™ª]Rikka 2",
            "published": 3,
            "tags": [
                "raymarching",
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "//--- Rikka 2\n// by Catzpaw 2020\n\n//Image:post effect\n\n//CHROMATIC ABERRATION\n#define ZERO min(0,iFrame)\nvec3 tx1(vec2 uv){return texture(iChannel1,uv).rgb;}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nvec3 ca(vec2 uv,vec2 xy){\n    vec2 uvr=uv-xy*.015;\n    vec3 c=vec3(0);\n    float f=0.;\n    for(int i=ZERO;i<10;i++)c+=tx1(mix(uvr,uv,f)).rgb*hsv(f+.85,1.,1.),f+=.1;\n    return c*.3;\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec2 xy=(fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    fragColor=vec4(ca(uv,xy)*pow(1.1-length(xy),.3),texture(iChannel1,uv).a);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//--- Rikka 2\n// by Catzpaw 2020\n\n//Buffer A:animation\n\n//SETUP\n#define OCT 5\n#define ITER 170\n#define EPS 7e-3\n#define NEAR 0.1\n#define FAR 13.0\n\nfloat time;\n\n//SNIPPETS\n#define ZERO min(0,iFrame)\nfloat hash(float v){return fract(sin(v*22.9)*67.);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\n//SDF\nvec2 hexFold(vec2 p){return abs(abs(abs(p)*mat2(.866,.5,-.5,.866))*mat2(.5,-.866,.866,.5));}\nfloat sdHex(vec3 p){p=abs(p);return max(p.z-.02,max((p.x*.5+p.y*.866),p.x)-.015);}\n\n//SCENE\nfloat map(vec3 p){\n\tfloat h=hash(floor(p.x)+floor(p.y)*133.3+floor(p.z)*166.6),o=FAR,s=1.+h;\n\tp=fract(p)-.5;\n    p.y+=h*.4-.2;\n    p.xz*=rot(time*(h+.8));\n    p.yz*=rot(time+h*5.);\n    h=hash(h);p.x+=h*.15;\n    float l=dot(p,p);\n    if(l>.1)return l*2.;\n \tfor(int i=ZERO;i<OCT;i++){\n\t\tp.xy=hexFold(p.xy);\n\t\tp.xy*=mat2(.866,-.5,.5,.866);\n\t\tp.x*=(s-h);\n\t\th=hash(h);p.y-=h*.065-.015;p.y*=.8;\n        p.z*=1.2;\n\t\th=hash(h);p*=1.+h*.3;\n\t\to=min(o,sdHex(p));\n        h=hash(h);s=1.+h*2.;\n    }\n\treturn o;\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out vec3 n){\n\tfloat t=NEAR,d;\n    float eps;\n\tvec3 p;\n\tvec2 e=vec2(.1,-.1);\n\tfor(int i=ZERO;i<ITER;i++){\n        float l=log(t+1.);\n        eps=EPS*l;\n\t\tp=ro+rd*t;\n\t\td=map(p);\n\t\tif(d<eps||t>FAR)break;\n\t\tt+=step(d,.3)*d*.2+d*l*.16;\n\t}\n\tn=normalize(e.xyy*map(p+e.xyy*eps)+e.yyx*map(p+e.yyx*eps)+e.yxy*map(p+e.yxy*eps)+e.xxx*map(p+e.xxx*eps));\n\treturn min(t,FAR);\n}\n\n//BACKGROUND\nvec3 tx0(vec3 rd){float v=abs(dot(rd,vec3(.35,-.5,.35)));return vec3(v);}\n//vec3 tx0(vec3 rd){return texture(iChannel0,rd).rgb*.4;}\n\n//MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime+117.7;\n\tvec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tvec3 n,ro=vec3(-.9,time*.4,-.9),rd=normalize(vec3(uv*.7,1.));\n    rd.yz*=rot(.45);\n    rd.xz*=rot(.78);\n    float d=trace(ro,rd,n);\n\tfloat v=1.-d*(1./FAR),s=pow(1.-abs(dot(n,normalize(-rd))),5.);\n    v=v>.01?v:0.;\n    vec3 c=vec3(.0,.1,.2)+tx0(rd)*.5;\n    c+=v>.01?(tx0(n)+s)*v:vec3(0);\n    \n\tfragColor=vec4(c,d/FAR);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//--- Rikka 2\n// by Catzpaw 2020\n\n//Sound:scale sequencer 3\n//https://www.shadertoy.com/view/ts3fDN\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =442.;\t//master tuning (Hz)\nconst float bpm  = 80.;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst float gateSeed=160.; //random seed for gate generator;\nconst float noteSeed=112.; //random seed for note generator;\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\n//const uint[4] scl=uint[](0xcb975420u,0xcb975420u,0xcb975420u,0xcb975420u); //major,major,major,major\nconst uint[4] scl=uint[](0xcb975420u,0xca875320u,0xcb875320u,0xcb975320u); //major,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xca875320u,0xca875320u,0xcb875320u,0xcb975320u); //minor,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xc9974420u,0xca775530u,0xca775530u,0xca775530u); //pentatonic(major,minor)\n//const uint[4] scl=uint[](0xcb775540u,0xcb755420u,0xcb755420u,0xcb755420u); //ryukyu(pentatonic,hexatonic)\n//const uint[4] scl=uint[](0xba875410u,0xba875410u,0xba875410u,0xba875410u); //maqam hijaz octatonic\n//const uint[4] scl=uint[](0xba876320u,0xba876320u,0xba876320u,0xba876320u); //gypsy minor octatonic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\n//div1(2),scale2(2),div2(2),scale3(2),chord1(8),chord2(8),chord3(8)\n//chord:\n//  00-07:I,I,II,III,IV,V,VI,VII\n//  +00:triad\n//  +10:-3\t  +18:+3\n//\t+20:-5\t  +28:+5\n//\t+30:-3-5  +38:+3+5\n//\t+40:add9\n//\t+80:diatonic6(m6 or 6)\n//\t+c0:diatonic7(7 or M7)\n//  Example...symbol:C7 = key:C,scale:minor,chord:Im7+3 = 0x01+0x18+0xc0 = 0xd9\nconst int chordlen=16;const uint chordseq[chordlen]=uint[](\n\t0x00000041u,0x00000001u,0x000000c1u,0x00000081u,\n\t0x00000041u,0x00000001u,0x000000c1u,0x00000081u,\n\t0x44032346u,0x08000214u,0x4403c6c3u,0x08001581u,\n\t0x08001404u,0x84150434u,0x4803c622u,0x08001585u\n);\n\n//PATTERN (version 3)\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\n// You can set up to 256 patterns.\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x08008001u,0x070af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x45164300u,0x46214603u,0x55104143u,0x46170443u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973175u,0x36390700u,  //08-0B melody\n    0x460e121cu,0x45043100u,0x37393701u,0x00000000u,  //0C-0F melody\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,  //10-13 \n    0x70333444u,0x00000000u,0x66111202u,0x00000000u,  //14-17 accompaniment,bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//PATTERN SEQUENCE (version 3)\n// speed1(2),speed2(2),division(4),top1(4),pattern1(8),top2(4),pattern2(8)\n// speed    0:1x 1:2x 2:0.25x 3:0.5x\n// top      0-e ... auto inversion amount (0:no inversion 7:octave)\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2 8:half)\n// The length of each sequence is unlimited.\nconst int len1= 8;const uint[len1] seq1=uint[]( //snare+hihat\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,\n    0x00000018u,0x00000018u,0x00000019u,0x0000001bu);\nconst int len2= 4;const uint[len2] seq2=uint[]( //bassdrum+conga\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0e01e01fu);\nconst int len3= 1;const uint[len3] seq3=uint[]( //bass\n    0x00000616u);\nconst int len4= 1;const uint[len4] seq4=uint[]( //chord\n    0x00000003u);\nconst int len5= 2;const uint[len5] seq5=uint[]( //accompaniment\n    0xa0000814u,0xe8814814u);\nconst int len6=16;const uint[len6] seq6=uint[]( //melody\n    0x00000004u,0x00000005u,0x00000006u,0x00000007u,\n    0x00000004u,0x00000005u,0x00000006u,0x0000000cu,\n    0x00000008u,0x00000009u,0x0000000au,0x0000000bu,\n    0x0000000du,0x00000009u,0x0000000au,0x0000000eu);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//FOLDBACK DISTORTION (input,threshould,ratio)\nfloat fbdist(float v,float t,float f){return abs(v)>t?sign(v)+(t-v)*f:v;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n/*\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\n//vec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\n//vec2 c30piano(float f,float x){return vec2(osc_c30(f*(1.-detune),3),osc_c30(f*(1.+detune),3))*max(env_d(x,.05),env_d(x,2.5)*.6);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6))*env_d(x,.5);}\n*/\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\n//float nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(6./(x*.4+.1),.6)*env_d(x,.025);}\nfloat neshc(float x){return osc_duty(10./(x*.4+.1),.6)*env_d(x,.025);}\n\n/*\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n*/\n\n//FM INSTRUMENTS (freq,time)\nfloat fmbass(float f,float x){f*=6.283;return fbdist(sin(f*2.03)*.5+sin(f*2.+sin(f+sin(f*7.51)*env_d(x,.07))*env_d(x,.2)),1.,.02)*env_d(x,.5);}\nfloat fmharpsi(float f,float x){f*=6.283;return (sin(f+sin(f*5.+sin(f*9.))))*env_d(x,.7);}\n//float fmvibe(float f,float x){f*=6.283;return (sin(f+sin(f*9.)))*env_d(x,.9);}\nfloat fmep(float f,float x){f*=6.283;return (sin(f+sin(f*15.)*env_d(x,.5)*.6))*env_d(x,.7);}\n//float fmmarimba(float f,float x){f*=6.283;return (sin(f+sin(f*3.99+sin(f*5.3)*env_d(x,.08))*env_d(x,.3)))*env_d(x,.4);}\n//float fmguitar(float f,float x){f*=6.283;return fbdist(sin(f+sin(f*3.01+sin(f*3.49)*env_d(x,.4))*env_d(x,.7)*.6)*1.3*env_d(x,.9),1.,1.);}\nfloat fmpad(float f,float x){f*=6.283;return sin(f+sin(f*1.01))*(.9+sin(x*60.)*.1);}\n\n//PERCUSSION INSTRUMENTS (time)\nfloat bd(float x){return sin(x*freq(84./(1.+x*.7)))*env_d(x,.5);}\nfloat sd(float x){return (osc_nesnoise(x,11)*.7*env_d(x,.2)+sin(x*freq(81.5/(1.+x*.05)))*env_d(x,.25));}\n//float hh(float x,float d){return osc_nesnoise(x,3)*env_d(x,d);}\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);sc=st<d?sc:get2(p,12);ch=st<d?ch:get8(p,0);\n    scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateSeed)*50.)<(float(get4(pt,6))*.0625)?-99:\n        imod(int(abs(sin(float(s+s1+s*s2)*noteSeed)*float(s2))),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n// track(t,l,s)\n//   t...time\n//   l...measure length (steps/bpm)\n//   s...step now playing\n//\n//   getPattern(t,patternSequence)...get pattern data now playing\n//   getGate(t,l)...get noteTime and noteNum from percussive pattern\n//   getNote(t,l)...get noteTime and noteNum from melodic pattern\n//   getNoteByChord(t,l)...noteNum will restricted by chord\n//   getChord(n)...get chord noteNum 0:root 2:3rd 4:5th 6:7th\n//\n// render(t,l,inout o,e)\n//   o...audio output\n//   e...false:render is called by delay effect\n//\n//   scaleChord(t,l,chordSequence)...set scale & chord for following tracks\n//\n//--------------------------------------------------------------------------------\n//TRACK 1 snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?sd(n.x)*vec2(.48,.62):vec2(0);\n    o+=(n.y==2.)?neshh(n.x,.08)*vec2(.15,.24):vec2(0);\n    o+=(n.y==3.)?neshh(n.x,.2)*vec2(.15,.24):vec2(0);\n    return o;\n}\n//TRACK 2 bassdrum,lowconga,highconga\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?bd(n.x)*vec2(.4,.55):vec2(0);\n    o+=(n.y==2.)?neslc(n.x)*vec2(.05,.15):vec2(0);\n    o+=(n.y==3.)?neshc(n.x)*vec2(.05,.15):vec2(0);\n    return o;\n}\n//TRACK 3 bass\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?(fmbass(freq(n.y+11.95)*n.x,n.x)+fmbass(freq(n.y+12.05)*n.x,n.x))*vec2(.28,.31):vec2(0);\n    return o;\n}\n//TRACK 4 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?fmpad(freq(n.y+36.03)*n.x,n.x)*vec2(.29,.21):vec2(0);\n    o+=(n.y>-50.)?fmpad(freq(getChord(2)+48.02)*n.x,n.x)*vec2(.30,.20):vec2(0);\n    o+=(n.y>-50.)?fmpad(freq(getChord(4)+36.01)*n.x,n.x)*vec2(.31,.19):vec2(0);\n    o+=(n.y>-50.)?fmpad(freq(getChord(6)+48.01)*n.x,n.x)*vec2(.32,.18):vec2(0);\n    return o;\n}\n//TRACK 5 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?fmharpsi(freq(n.y+72.)*n.x,n.x)*vec2(.08,.05):vec2(0);\n    return o;\n}\n//TRACK 6 melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?fmep(freq(n.y+36.03)*n.x,n.x)*.4:0.;\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):track1(t,l,s)*.5; //TRACK 1 snaredrum,closehh,openhh\n    o+=e?track2(t,l,s):vec2(0); //TRACK 2 bassdrum,lowconga,highconga\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 accompaniment\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    12\n#define DELAY_WET       0.4\n#define DELAY_FEEDBACK  0.84\n#define DELAY_TIME      0.11\n#define DELAY_STEREO    0.08\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}