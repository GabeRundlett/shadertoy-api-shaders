{
    "Shader": {
        "info": {
            "date": "1536897571",
            "description": "Drawing landscapes on a grid of equilateral triangles",
            "flags": 32,
            "hasliked": 0,
            "id": "4lccDj",
            "likes": 29,
            "name": "Isometric Shores",
            "published": 3,
            "tags": [
                "2d",
                "triangles",
                "landscape",
                "isometric"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 1027
        },
        "renderpass": [
            {
                "code": "//apply isometric filter to landscape - convert square pixels to equilateral triangles\n\n//Enable this to see how the square pixels are converted to equilateral triangles\n//#define GRID_TRANSFORM_DEMO\n\n//anti-aliasing on triangles (only y-axis, to smooth out diagonal sides)\n#define AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = VIEW_SCALE * fragCoord/iResolution.y;\n    \n    #ifdef GRID_TRANSFORM_DEMO\n    float gridlerp = clamp( sin(iTime*0.5)+0.5, 0.0, 1.0 );\n    uv.y *= mix( 1.73205081, 1.0, gridlerp );\n    #else\n    uv.y *= 1.73205081;\t\t\t\t\t//sqrt(3.0)\n    #endif\n    \n    uv += fract(iTime*MOVEMENT_SPEED);\t\t//for smooth panning\n    \n    ivec2 ind = ivec2(uv)+ivec2(0,1);\n    \n    vec2 f = fract(uv);\n    if ( mod(float(ind.x+ind.y),2.0) > 0.5 ) f.x = 1.0-f.x;\n    \n    #ifdef GRID_TRANSFORM_DEMO\n    f.x = mix(f.x, 0.5, gridlerp );\n    #endif\n    \n    #ifdef AA\n\n    vec2 vi = vec2(ind)+0.5;\n    float pp = iResolution.y/VIEW_SCALE/2.0;\n    \n    float yoff = clamp((f.x+f.y-1.5)*pp, -0.5, 1.0) - clamp((f.x-f.y-0.5)*pp, -0.5, 1.0);\n    vi.y += clamp(yoff, -1.0, 1.0);\n    \n    //vi.x += clamp( (uv.x-float(ind.x))*pp, -0.5, 0.5);\n    \n    vec3 col = texture(iChannel0, vi/iResolution.xy).rgb;\n    \n    #else\n    \n    if (f.x+f.y>1.5)      ind.y++;\n    else if (f.x-f.y>0.5) ind.y--;\n    vec3 col = texelFetch(iChannel0, ind, 0).rgb;\n    \n    #endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//generate heightmap\n\n#define PERLIN\n\n\nfloat getgradientnoise( vec2 p ) {\n\tvec2 fp = floor(p);\n\tvec2 pfract = p-fp;\n\n\tvec2 nw = vec2(fp.x,     fp.y+1.0);\n\tvec2 ne = vec2(fp.x+1.0, fp.y+1.0);\n\tvec2 sw = vec2(fp.x,     fp.y);\n\tvec2 se = vec2(fp.x+1.0, fp.y);\n\n\tvec2 dnw = vec2(pfract.x,     pfract.y-1.0);\n\tvec2 dne = vec2(pfract.x-1.0, pfract.y-1.0);\n\tvec2 dsw = vec2(pfract.x,     pfract.y);\n\tvec2 dse = vec2(pfract.x-1.0, pfract.y);\n\n\tfloat vnw = dot(hash22(nw), dnw);\n\tfloat vne = dot(hash22(ne), dne);\n\tfloat vsw = dot(hash22(sw), dsw);\n\tfloat vse = dot(hash22(se), dse);\n\n\t//pfract *= pfract*pfract*(pfract*(pfract*6.0-15.0)+10.0);\n\tfloat v = mix( mix(vsw, vse, pfract.x), mix(vnw, vne, pfract.x), pfract.y);\n\t\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = fragCoord;\n    uv.y += floor(iTime*MOVEMENT_SPEED);\n    \n    #ifdef PERLIN\n    \n    float octaves = 8.0;\n    for (float f=0.0; f<=octaves; f++) {\n\t\tcol += getgradientnoise(uv*octaves/exp2(f)) / exp2(octaves-f);\t\t//-0.5 to 0.5\n    }\n    col *= 2.0;\n    col += 0.5;\n    \n    #else\n    \n    //generate fractal noise\n    float octaves = 5.0;\n    for (float f=0.0; f<=octaves; f++) {\n    \tcol += hash32(floor(uv/exp2(f))) / exp2(octaves+1.0-f);\n\t}\n    \n    #endif\n    \n    //hill slope\n    //col *= uv.y*0.004;\n    //col += uv.y*0.001;\n    \n    col.r = min(col.r, 1.0)*MAX_HEIGHT;\n    \n    //col.r += evenfloor((fragCoord.y-VIEW_SCALE)*0.2);\n    \n    //fix \"half-height\" blocks\n    col.r = floor(col.r/2.0)*2.0-1.0;\n    \n    fragColor = vec4(col, 0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//build landscape from heightmap\n\n#define VOID\t\tvec3( 0.0, 0.0, 0.0 )\n#define GRASS\t\tvec3( 0.2, 0.5, 0.1 )\n#define SAND\t\tvec3( 0.8, 0.7, 0.2 )\n#define SNOW\t\tvec3( 0.8, 0.8, 0.9 )\n#define DIRT\t\tvec3( 0.7, 0.4, 0.1 )\n#define WATER \t\tvec3( 0.1, 0.5, 0.9 )\n\n\nivec2 cell( vec2 uv ) {\n    //get heightmap grid cell that falls inside isometric pixel\n    uv.x+=250.0;\n    uv.y-=250.0-MAX_HEIGHT;\n\treturn ivec2( ceil((uv.x-uv.y)/2.0), floor((uv+uv.y)/2.0) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    vec2 uv = fragCoord+floor(iTime*MOVEMENT_SPEED);\n    \n    //find visible cell and height\n    ivec2 vc = cell(fragCoord);\n    float z = 0.0;\n    float h = 0.0;\n    for ( float f=0.0; f<MAX_HEIGHT; f++ ) {\n       \tivec2 t = cell(fragCoord-vec2(0.0,f));\t\t\t//target cell coordinates\n        float nh = texelFetch( iChannel0, t, 0 ).r;\t\t//target cell height\n        if (nh>f) {\n            vc = t;\t\t\t\t\t\t\t\t\t\t//visible cell coordinates\n            z = f;\t\t\t\t\t\t\t\t\t\t//new height of cell\n            h = nh-f;\t\t\t\t\t\t\t\t\t//height of target cell relative to screen-space cell\n        }\n    }\n    \n    if (min(vc.x,vc.y)<0 || h+z>MAX_HEIGHT) {\n        //outside of map\n        col = VOID;\n    } else if (h<=1.0) {\n    \t//top of cell\n        col = z<GRASS_LEVEL ? SAND : GRASS;\n        col = z>50.0 ? SNOW : col;\n        \n        //check for shadows\n    \tfor ( float f=1.0; f<MAX_HEIGHT-z; f++ ) {\n        \tfloat sh = texelFetch( iChannel0, vc-ivec2(f*0.5,0), 0 ).r;\t\t//potential shadow cell height\n        \tif (sh-f>z) {\n            \tcol *= SHADOW_FACTOR;\n        \t    break;\n        \t}\n    \t}\n    } else {\n    \t//side of cell\n        col = DIRT;\n        if (z>=SNOW_LEVEL+4.0) col = SNOW*0.8;\n        else if (z>=GRASS_LEVEL+hash12(uv)*8.0) col = GRASS*0.8;\n        else if (z<14.0) col = SAND*0.8;\n        \n        if ( (mod(float(vc.x+vc.y),2.0)<0.5)^^(mod(fragCoord.x,2.0)>0.5) ) {\t//side of block (true = right, false = left)\n            //dark side\n        \tcol *= SHADOW_FACTOR;\n        } else {\n            //light side - check for shadows\n        \tfor ( float f=1.0; f<MAX_HEIGHT-z; f++ ) {\n        \t\tfloat sh = texelFetch( iChannel0, vc-ivec2(f*0.5,1), 0 ).r;\n                if (evenfloor(sh-f)>z) {\n            \t\tcol *= SHADOW_FACTOR;\n        \t\t    break;\n        \t\t}\n        \t}\n        }\n    }\n    \n    //draw checkerboard\n    //col *= 1.0 + ( ( mod(float(vc.x+vc.y)+floor(iTime*MOVEMENT_SPEED),2.0)<0.5 ) ? -0.03 : 0.03 );\n    \n    if(z<WATER_LEVEL) {\n        //draw water\n    \tvc = cell(fragCoord);\n\t\th = 0.0;\n        col = mix(col, WATER, 0.85);\n        z = WATER_LEVEL;\n        /*\n        if ( (texelFetch(iChannel0,vc-ivec2(1,0),0).r > WATER_LEVEL) ||\n           \t (texelFetch(iChannel0,vc-ivec2(0,1),0).r > WATER_LEVEL) ||\n             (texelFetch(iChannel0,vc+ivec2(1,0),0).r > WATER_LEVEL) ||\n             (texelFetch(iChannel0,vc+ivec2(0,1),0).r > WATER_LEVEL)\n           ) col = vec3(1.0);\n\t\t*/\n    }\n    \n    \n    col *= 0.75+((evenfloor(z)/MAX_HEIGHT)-(WATER_LEVEL/MAX_HEIGHT))*1.5;\t\t\t//height light  \n    //col *= 1.0+sin(float(vc.y)/50.0+iTime*0.5)*0.5;\t\t\t\t\t\t\t\t//cloud shadows\n    col = mix( vec3(0.0), col, 0.8+float(vc.x-200)/VIEW_SCALE/2.0 );\t\t\t\t\t\t//depth fog\n        \n    //col = (fract((uv.y)/3.0)<0.75) ? ((fract((uv.x)/2.0)<0.5 ^^ fract((uv.y)/6.0)<0.5) ? DIRT : DIRT*0.7) : GRASS;\n    //col = vec3( fract((fragCoord.x+fragCoord.y)/3.0)*1.333, fract((fragCoord.x-fragCoord.y)/3.0)*1.333, 0.5 );\n    \n    fragColor = vec4(col, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define MAX_HEIGHT \t\t40.0\n//#define WATER_LEVEL\t\tevenfloor(10.0+5.0*sin(iTime))\n#define WATER_LEVEL\t\t12.0\n#define GRASS_LEVEL\t\t18.0\n#define SNOW_LEVEL\t\t50.0\n\n#define SHADOW_FACTOR\t0.6\n\n#define VIEW_SCALE\t\t100.0\n//#define VIEW_SCALE\t\t(225.0*(iMouse.x/iResolution.x) + 25.0)\n#define MOVEMENT_SPEED\t7.0\n\n\nfloat evenfloor( float x ) {\n    return floor(x*0.5)*2.0;\n}\n\n\n//from Dave Hoskins - https://www.shadertoy.com/view/4djSRW\nfloat hash12( vec2 p ) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}