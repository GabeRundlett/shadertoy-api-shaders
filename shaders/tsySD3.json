{
    "Shader": {
        "info": {
            "date": "1575144095",
            "description": "...important weekend thoughts ;-)\n(press rewind if music is not starting)",
            "flags": 112,
            "hasliked": 0,
            "id": "tsySD3",
            "likes": 35,
            "name": "if the river was whiskey",
            "published": 3,
            "tags": [
                "fluid",
                "cfd",
                "singlepass",
                "whiskey"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1747
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ...if the river was whiskey\n\n// Music:\n// https://soundcloud.com/brorgunnarjansson/if-the-river-was-whiskey\n// ...just found that by simply searching for that phrase, and pretty much like it!\n\n// final pass, vignetting + border blur\n\n// same fluid as in \"Spilled\" - https://www.shadertoy.com/view/MsGSRd\n// ...but with self-consistent-ish velocity field\n// the previous method was just defined implicitely by the rotations on multiple scales\n// here the calculated velocity field is put back into the stored field\n\n\n#define Res (iResolution.xy)\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.xy;\n    vec4 r=texture(iChannel1,fragCoord/Res1*.66+iTime*4.5)-.5;\n    fragColor=texture(iChannel0,uv,dot(sc,sc)*1.3*log2(Res.x))+r*.15;\n\tfloat vign=1.-1.*dot(sc,sc);\n    fragColor*=vign;\n\tfragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 20376,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/brorgunnarjansson/if-the-river-was-whiskey"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD - with some self consistency fixes\n\n// ...the actual fluid simulation\n\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n#define SUPPORT_EVEN_ROTNUM\n\n//#include Include_A.glsl\n\n#define keyTex iChannel2\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n\nconst float ang = PI2/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    float l=log2(dot(b,b))*sqrt(.125)*.0;\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(textureLod(iChannel0,((pos+p)/Res0.xy),l).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec2 b = cos(float(iFrame)*1.-vec2(0,1.57));  // vary curl-evaluation-points in time\n    vec2 v=vec2(0);\n    float bbMax=.5*Res0.y; bbMax*=bbMax; // take curls up to half screen size\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n            v+=p.yx*getRot(pos+p,-mh*b);\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    v*=vec2(-1,1)/float(RotNum);\n    \n    // perform advection\n    fragColor=textureLod(iChannel0,(pos-v*.1*Res0.x)/Res0.xy,0.);\n    \n    // feeding some self-consistency into the velocity field\n    // (otherwise velocity would be defined only implicitely by the multi-scale rotation sums)\n    fragColor.xy=mix(fragColor.xy,v,.025);\n    \n    // add a little \"motor\"\n    vec2 c=fract(scuv(iMouse.xy/iResolution.xy))*iResolution.xy;\n    vec2 dmouse=texelFetch(iChannel3,ivec2(0),0).zw;\n    c=Res0*.5;\n    vec2 scr=fract((fragCoord.xy-c)/Res0.x+.5)-.5;\n    // slowly rotating current in the center (when mouse not moved yet)\n    fragColor.xy += 0.002*cos(iTime*.3-vec2(0,1.57)) / (dot(scr,scr)/0.05+.05);\n    // feed mouse motion into flow\n    fragColor.xy += .0003*dmouse/(dot(scr,scr)/0.05+.05);\n\n    // add some \"crunchy\" drops to surface\n    fragColor.zw += (texture(iChannel1,fragCoord/Res1*.35).zw-.5)*.002*1.;\n    fragColor.zw += (texture(iChannel1,fragCoord/Res1*.7).zw-.5)*.001*1.;\n    \n    // initialization\n    if(iFrame<=4) fragColor=vec4(0);\n    if(KEY_I>.5 ) fragColor=(texture(iChannel1,uvSmooth(fragCoord.xy/Res0.xy*.05,Res1))-.5)*.7;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// just some mouse motion detection\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 c=texelFetch(iChannel0,ivec2(0),0);\n    vec2 m=iMouse.xy;\n    vec2 d=vec2(0);\n    if(iMouse.xy!=iMouse.zw) { d=iMouse.xy-c.xy; }\n    fragColor.xyzw = vec4(m,d);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// your code here\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    //return uv+.8*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD - with some self consistency fixes\n\n// drawing the liquid\n\n// same fluid as in \"Spilled\" - https://www.shadertoy.com/view/MsGSRd\n// ...but with self-consistent-ish velocity field\n// the previous method was just defined implicitely by the rotations on multiple scales\n// here the calculated velocity field is put back into the stored field\n\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel1\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    #ifndef SHADEROO\n    return texture(iChannel3,dir.xzy);\n    #else\n    float azim = atan(dir.y,dir.x);\n    float th = asin(dir.z);\n    float c=(sin(-azim*5.-1.5)*.15+.25);\n    float thr  = .5*.5*(.7*sin(2.*azim*5.)+.3*sin(2.*azim*7.));\n    float thr2 = .5*.125*(.7*sin(2.*azim*13.)+.3*sin(2.*azim*27.));\n    float thr3 = .5*.05*(.7*sin(2.*azim*32.)+.3*sin(2.*azim*47.));\n    float br  = smoothstep(thr-.2, thr+.2, dir.z+.25);\n    float br2 = smoothstep(thr2-.2,thr2+.2,dir.z+.15);\n    float br3 = smoothstep(thr3-.2,thr3+.2,dir.z);\n    vec4 r1 = .5*(texture(RandTex,dir.xy*.01)-texture(RandTex,dir.xy*.017+.33));\n    vec3 skyCol=vec3(.9,1,1.1)+.3*(r1.xxx*.5+r1.xyz*.5);\n    //skyCol*=2.5;\n    vec4 r2 = .5*(texture(RandTex,dir.xy*.1)-texture(RandTex,dir.xy*.07-.33));\n    vec3 floorCol = vec3(.9,1.1,1.)*.8+.5*(r2.xxx*.7+r2.xyz*.3);\n    vec3 col=mix(floorCol.zyx,skyCol,br3);\n    col=mix(floorCol.yzx*.7,col,br2);\n    col=mix(floorCol.xyz*.7*.7,col,br);\n    vec3 r=texture(RandTex,vec2(azim/PI2*.125,.5)).xyz;\n    col*= 1.-clamp(((r.xxx*.7+r.xzz*.3)*2.-1.)*clamp(1.-abs(dir.z*1.6),0.,1.),0.,1.);\n    return vec4(col*col*vec3(1.1,1,.9)/**clamp(1.+dir.x*.3,.9,1.2)*/,1);\n    #endif\n}\n\n//#include Include_A.glsl\n\nvec4  getCol(vec2 uv,float lod) { return textureLod(iChannel0,scuv(uv),lod); }\nfloat getVal(vec2 uv,float lod) { return length(getCol(uv,lod).xyz); }\nvec4  getCol(vec2 uv) { return getCol(uv,0.); }\nfloat getVal(vec2 uv) { return getVal(uv,0.); }\n    \nvec2 getGrad2(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0); return vec2( getVal(uv+d.xy)-getVal(uv-d.xy),\n                                       getVal(uv+d.yx)-getVal(uv-d.yx) )/delta;\n}\n\nvec2 pos2uv(vec3 p) { return p.xy*vec2(1.,Res0.x/Res0.y)*.5+.5; }\n\nfloat fluidDist=1.;\n\nfloat dist(vec3 p)\n{\n    float h=0.;\n    h+=(getVal(pos2uv(p)))*.15;\n    float hf=-.5+(textureLod(iChannel1,p.xy*.8,0.).x-.5)*.1;\n    h=mix(hf,h,fluidDist);\n    return p.z-h;\n}\n\nvec3 getGrad(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\nint march(inout vec3 p, vec3 dir)\n{\n    float eps=.0001;\n    for(int i=0;i<100;i++)\n    {\n        float d=dist(p);\n        p+=dir*d;\n        if (d<eps) break;\n    }\n    return 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    // calculate normal from gradient (the faster the higher)\n    vec3 n = vec3(-getGrad2(uv,1.4/iResolution.x)*.02,1.);\n    n=normalize(n);\n\n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=1.-iMouseData.z/1000.;\n    #endif\n    vec3 pos=vec3(0,0,1.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-1));\n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*6.;\n    if(iMouse.x<1.) { th=1.1+.3*sin(iTime*.1); ph=-iTime*.25; }\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q);\n    dir=transformVecByQuat(dir,q);\n    \n    vec3 pos0=pos;\n    march(pos,dir);\n    \n    n=getGrad(pos,.001);\n    n+=getGrad(pos,.01);\n    n=normalize(n);\n\n    vec3 refrDir=refract(dir,n,1./1.36);\n    \n    fluidDist=0.;\n    vec3 pos1=pos;\n    march(pos,refrDir);\n    vec3 nf=getGrad(pos,.001);\n\n    vec3 caustic=vec3(1.);\n    caustic*=getVal(pos2uv(pos),.5)/getVal(pos2uv(pos),3.5+log2(Res.x/600.));\n    caustic*=getVal(pos2uv(pos),2.7)/getVal(pos2uv(pos),4.7+log2(Res.x/600.));\n    //ao+=vec3(-.1,.14,.07)*.3;\n    //ao=clamp(ao,0.,1.);\n    caustic=caustic*.3+.7;\n\n    vec3 light = normalize(vec3(-.5,.5,2));\n    float diff=clamp(dot(n,light),0.,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0); spec=exp2(log2(spec)*24.0)*2.5;\n    \n    // evironmental reflection\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(vec3(0),R.xyz-vec3(0,0,.0),1.).xyz*.5+.5;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    //fres*=fres*sqrt(abs(fres));\n    fres=fres*.9+.1;\n    \n    // slightly add velocityfield to color - gives it a bit of a 'bismuty' look\n    vec4 col=getCol(pos2uv(pos))+.5;\n    //col=mix(vec4(1),col,.3);\n    col.xyz=vec3(.3,.1,0);\n    //col.xyz=vec3(1);\n    //col.xyz*=.95-.05*n; // slightly add some normals to color\n    col.xyz=.8*dot(nf,light)*pow(vec3(1.,.65,.0),1.3*vec3(length(pos-pos1)))*(1.-fres);\n    \n    float zr=length(pos-pos0)/10.;\n\t//fragColor.xyz = col.xyz*(.5+.5*diff)+.1*refl;\n\t//fragColor.xyz = ao*col.xyz*vec3(1,.7,.7)*refl;\n\tvec3 bg=vec3(.6,.5,.4);\n\tbg=mix(bg,myenv(vec3(0),dir,1.).xyz,.6);\n\tfragColor.xyz = mix(mix(col.xyz,refl,fres)*caustic,bg,1.-exp(-zr*zr));\n    //fragColor.xyz = vec3(0)+ao;\n\tfragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}