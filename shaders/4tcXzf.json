{
    "Shader": {
        "info": {
            "date": "1480812343",
            "description": "Playing with Pickover popcorn functions...",
            "flags": 0,
            "hasliked": 0,
            "id": "4tcXzf",
            "likes": 3,
            "name": "Popcorn Picker",
            "published": 3,
            "tags": [
                "2d",
                "popcorn"
            ],
            "usePreview": 0,
            "username": "xbe",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "// Created by Xavier Benech - xbe/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Pickover Popcorn\n//\n\n#define PI 3.141592654\n#define NBIT 56\n#define NBITF 56.\n\nvec2 popcorn1(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * cos(b*r.y + sin(a*r.y)),\n       h * sin(a*r.x + cos(b*r.x)));\n}\n\nvec2 popcorn2(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * sin(b*r.y + sin(a*r.y)),\n       h * sin(a*r.x + sin(b*r.x)));\n}\n\nvec2 popcorn3(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * cos(b*r.y + sin(a*r.y)),\n       h * cos(a*r.x + sin(b*r.x)));\n}\n\nvec2 popcorn4(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * sin(b*r.y + cos(a*r.y)),\n       h * sin(a*r.x + cos(b*r.x)));\n}\n\nvec2 popcorn5(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * sin(b*r.y + tan(a*r.y)),\n       h * sin(a*r.x + tan(b*r.x)));\n}\n\nvec3 iterate(in vec2 p, float t, float pc) {\n    float a = PI * (0.75 + 0.5 * sin(t));\n    float b = PI * (0.75 + 0.5 * cos(t));\n    float h = 0.04 + 0.02*cos(PI*t);\n    vec2 r = p;\n    float d = 0.;\n    for (int i=0; i < NBIT; ++i) {\n        if (pc < 1.)\n\t        r.xy -= popcorn1(r.xy, h, a, b);\n        else if (pc < 2.)\n\t        r.xy -= popcorn2(r.xy, h, a, b);\n        else if (pc < 3.)\n\t        r.xy -= popcorn3(r.xy, h, a, b);\n        else\n\t        r.xy -= popcorn4(r.xy, h, a, b);\n        d += distance(r.xy,p);\n   }\n    d /= NBITF;\n    vec3 s = vec3(0.);\n    s.x = 1.0/(0.1+d);\n    s.y = sin(atan( r.y-p.y, r.x-p.x ));\n    s.z = exp(-0.2*d);\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 1.33;\n    \n    float t = 0.0625 * iTime;\n\n    float pcf = mod(0.025*iTime, 4.);\n    vec3 s = vec3(0.);\n    if (fract(pcf) < 0.5) {\n    \ts = iterate(p, t, pcf);\n    } else {\n    \ts = 0.7 * iterate(iterate(p, t + 0.5 * PI, pcf).xy, t, pcf+1.);\n    }\n    \n    vec3 col = 0.5 + 0.25*cos( vec3(0.0,0.4,0.6) + 2.5 + s.z*6.2831 );\n\t\n\tif (fract(pcf) < 0.5) {\n\t\tcol += 0.25 * vec3(0.8, 0.6, 0.4) * s.y;\n\t    col *= 0.33 * s.x;\n    \tcol *= 0.85+0.15*sin(10.0*abs(s.y));\n    } else {\n\t\tcol += 0.75 * vec3(0.8, 0.6, 0.4) * s.y;\n\t    col *= 0.66 * s.x;\n    \tcol *= 0.70 + 0.15*sin(10.0*abs(s.z)) + 0.15*sin(-6.*s.y);\n    }\n    \n    col *= vec3(0.7, 0.5, 0.35);\n    \n\tvec3 nor = normalize( vec3( dFdx(s.x), 0.02, dFdy(s.x) ) );\n\tfloat dif = dot( nor, vec3(0.7,0.1,0.7) );\n\tcol += 0.05*vec3(dif);\n\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    col = pow(clamp(col, 0., 1.), vec3(0.45));\n    fragColor = vec4(clamp(col, 0., 1.), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}