{
    "Shader": {
        "info": {
            "date": "1599162541",
            "description": "Made it 2 years ago, [b]code is very bad.[/b]\nMade for learning shaders at same time with [url=https://www.shadertoy.com/view/4lKcDD]this shader[/url].\n\nNow used as startup image in [url=https://danilw.itch.io/particle-effects-godot3]this project[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2fWw",
            "likes": 56,
            "name": "Planets 2d animation ",
            "published": 3,
            "tags": [
                "2d",
                "animation"
            ],
            "usePreview": 0,
            "username": "morimea",
            "viewed": 1167
        },
        "renderpass": [
            {
                "code": "\n// License - CC0 or use as you wish\n\nfloat rand(float p) {\n    return mod(p*7241.6465+2130.465521, 64.984131);\n}\n\nfloat rand2(vec2 p) {\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash(in vec2 p)\n{\n    return fract(dot(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat noise( float y, float t)\n{\n    vec2 fl = vec2(floor(y), floor(t));\n    vec2 fr = vec2(fract(y), fract(t));\n    float a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n    float b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n    return mix(a,b,fr.y);\n}\n\nfloat line(vec2 uv,float width, float center, float px)\n{\n    float b\t\t=\t(1.- smoothstep(.0, width/2.+px, (uv.y-center)))*1.;\n    return b;\n}\n\nconst vec3 dark=vec3(0x1a,0x13,0x21)/float(0xff);\nconst vec3 white=vec3(0xdc,0xe0,0xd1)/float(0xff);\nconst vec3 red=vec3(0xa6,0x36,0x2c)/float(0xff);\nconst vec3 redw=vec3(0xfd,0x8c,0x77)/float(0xff);\n\nfloat circle( in vec2 uv, float r1, float r2, bool disk)\n{\n    float w = 2.0*fwidth(uv.x);\n    float t = r1-r2;\n    float r = r1;\n\n    if(!disk)\n        return smoothstep(-w/2.0, w/2.0, abs(length(uv) - r) - t/2.0);\n    else\n        return smoothstep(-w/3.0, w/3.0, (length(uv) - r) );\n\n}\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat animstart=2.5;\n\nvec3 strucb(vec2 uv, float timer) {\n    float d=step(-0.14,uv.y)*step(uv.y,-0.127)*step(abs(uv.x+0.19),0.02);\n    vec3 ret=vec3(0.);\n    d=max(d,step(-0.14,uv.y)*(1.-circle(uv+vec2(0.225,0.14),0.02270,0.35,true)));\n    d=max(d,step(-0.14,uv.y)*(1.-circle(uv+vec2(0.165,0.14),0.02970,0.35,true)));\n    d=max(d,step(uv.y,-0.094)*step(-0.14,uv.y)*smoothstep(0.0031,0.0008,abs(uv.x+0.12)));\n    d=max(d,step(uv.y,-0.115)*step(-0.14,uv.y)*smoothstep(0.0031,0.0008,abs(uv.x+0.1075)));\n    ret=d*red;\n    float tuvx=mod(uv.x,0.006)-0.003;\n    d=step(-0.132,uv.y);\n    d=step(abs(uv.x+0.225),0.015)*d*smoothstep(0.0031,0.0005,abs(tuvx))*(1.-circle(uv+vec2(0.225,0.143),0.021970,0.35,true));\n    ret=mix(ret,redw*1.25,d);\n    tuvx=mod(uv.x-0.093,0.012)-0.006;\n    d=smoothstep(0.0061,0.0035,abs(tuvx))*step(abs(uv.y+0.122),0.00182);\n    ret=mix(ret,white,d*step(abs(uv.x+0.165),0.0165));\n    return ret*smoothstep(animstart+2.2,animstart+3.2,timer);\n}\n\nvec3 postfx(vec2 uv, vec3 col,float reg) {\n    vec3 ret=col+ 1.5*reg*((rand2(uv)-.5)*.07);\n    //ret = clamp(1.5*ret,0.,1.);\n    return ret;\n}\n#define PI (4.0 * atan(1.0))\n#define TWO_PI PI*2.\n\nfloat animendfade(float timer) {\n    return smoothstep(animstart+11.5,animstart+9.5,timer);\n}\n\nvec3 map(vec2 uv, float lt, float timer) {\n    float d=(circle(uv,0.32*smoothstep(animstart-1.,animstart+0.35,timer),0.,true));\n\n    vec3 tcol=d*dark;\n    float a=1.-circle(uv,0.3542,0.35,false);\n    vec2 tuv=uv;\n    float af = atan(tuv.x,tuv.y);\n    float r = length(tuv)*0.75;\n    tuv = vec2(af/TWO_PI,r);\n    a*=step(tuv.x,-PI/2.+PI*smoothstep(animstart+2.5,animstart+4.8,timer));\n    vec3 ret=max(tcol,a*(1.-lt)*redw);\n    ret=max(ret,lt*dark);\n    ret=max(ret,(1.-lt)*(1.-d)*red)*smoothstep(animstart-1.,animstart+0.35,timer);\n    float b=1.-circle(uv+vec2(0.,0.225*smoothstep(animstart,animstart-2.,timer)),0.2242,0.22,true);\n    tuv=uv;\n    float tuvy=mod(tuv.y,0.015)-0.0075;\n    float e=1.-max(smoothstep(0.0005,0.0031,abs(tuvy)),step(0.195,tuv.y)+step(tuv.y,0.185)*step(0.165,tuv.y)+\n                   step(tuv.y,0.14)*step(0.06,tuv.y)+step(tuv.y,0.03)*step(0.015,tuv.y));\n\n    float di=smoothstep(animstart+4.5,animstart+6.5,timer);\n    float di2=smoothstep(animstart+8.5,animstart+9.5,timer);\n    e*=step(uv.x+1.5*uv.y*(1.-di),di-0.5);\n    e*=step(di2-.5,uv.x-2.*uv.y*(1.-di2));\n\n    e=(1.-e)*(b);\n    ret=max(ret,(1.-lt)*e*white);\n    float c=1.-circle(uv,0.3542,0.35,true);\n    tuvy=(mod(uv.y,0.026+0.1*smoothstep(-.5,0.5,uv.y))-0.013-0.05*smoothstep(-.5,0.5,uv.y));\n    e=smoothstep(0.001,0.0051,abs(tuvy));\n    e=((step(uv.y,-0.109))*c*(1.-e*step(uv.y,-0.109)));\n    e*=step(abs(uv.x),0.5*smoothstep(animstart+1.5,animstart+3.,timer));\n    ret=max(ret,red*e);\n    tuv=uv;\n    tuv*=MD(3.3-sin(01.0-cos(2.0*smoothstep(animstart+4.25,animstart+5.5,timer))));\n    tuv+=vec2(0.35521,0.);\n    float f=1.-circle(tuv,0.0270,0.35,true);\n    ret=max(ret,f*redw*(1.-lt));\n    tuv=uv;\n    tuv*=MD(-0.3+01.*smoothstep(animstart+2.,animstart+4.8,timer));\n    tuv+=vec2(0.2242,0.);\n    f=1.-circle(tuv,0.0570,0.35,true);\n    ret=max(ret*(1.-(1.-lt)*f),(1.-lt)*f*dark*(1.-lt));\n    ret=max(ret,strucb(uv,timer));\n    f*=animendfade(timer);\n    return max(dark,ret*animendfade(timer));\n}\n\nfloat animm(float timer) {\n    return smoothstep(animstart,animstart+1.5,timer);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    float Range = 10.;\n    float timer=mod(iTime,15.);\n    float Line_Smooth\t= animm(timer)*\n                          pow(smoothstep(Range,Range-.05,2.*Range*(abs(smoothstep(.0, Range,uv.x+.5 )-.5))),.2);\n\n    float ft=2000.;\n    float fx=rand(uv.x*.0031+.0005);\n    float am  =0.5000 * noise(fx, ft)\n                       +0.2500 * noise(fx, ft)\n                       +0.1250 * noise(fx, ft)\n                       +0.0625 * noise(fx, ft);\n\n    vec2 p=uv;\n    p.y+=((cos(.5*p.x-0.15))-.975)*animm(timer);\n    float lt  = line(vec2(p.x,p.y*2.+(am-.5)*.12*Line_Smooth), .005, .0, 2./iResolution.y);\n\n    vec3 line1 =  lt*dark;\n\n    vec3 retcol=vec3(0.);\n    retcol=postfx(uv,map(uv,lt,timer),0.75);\n    fragColor =vec4(retcol,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}