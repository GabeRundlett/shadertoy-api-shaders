{
    "Shader": {
        "info": {
            "date": "1620401405",
            "description": "https://www.desmos.com/calculator/u5zfwind97?lang=es",
            "flags": 0,
            "hasliked": 0,
            "id": "fd2XW1",
            "likes": 2,
            "name": "getErraticWave",
            "published": 3,
            "tags": [
                "wave",
                "time",
                "pattern"
            ],
            "usePreview": 0,
            "username": "TestCoder",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "float cbrt(float number) {\n    return pow(abs(number), 1. / 3.);\n}\n\nfloat getErraticWave(float number) {\n    float scale = 1.;\n\n    return (\n        cbrt(sin(number))\n      + pow(\n          sin(\n              number + iTime / 3.\n          ),\n          3.\n        )\n    ) / scale;\n}\n\nvec3 getErraticPattern(float x, float y, vec2 uv) {\n    float stretch = 2.;\n    float mainDance = getErraticWave(\n        getErraticWave(uv.y + uv.x)\n      + getErraticWave(uv.y + -uv.x)\n      + getErraticWave(-uv.y + uv.x)\n      + getErraticWave(-uv.y + -uv.x)\n    );\n\n    return (\n        getErraticWave(\n            x\n        ) + getErraticWave(\n            y\n        )\n    ) * stretch * (1. - vec3(\n        mainDance * (\n            sin(\n                iTime / 20. + .5\n            ) + 1.\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + .25\n            ) + .5\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + 1.\n            ) + .25\n        ) + mainDance\n    ));\n}\n\n#define A .205          // Animation speed factor\n#define B 10          // Fractal iterations\n#define C 9             // Fractal sequence length\n#define D 20      // Array size for weights\n#define E 0.97          // Weight base value\n#define F 0.3028         // Weight oscillation amplitude\n#define G .001         // Weight phase offset\n#define H 0.496          // Weight oscillation speed\n#define I 1.4900  // X update factor\n#define J 4.14159265    // Pi constant\n#define K 0.8           // Color shift red\n#define L 0.55          // Color shift green\n#define M 0.00330       // Color shift blue\n#define N 0.74          // Color shift speed\n#define O 0.5           // Color component base\n#define P 0.3           // Color2 red offset\n#define Q 0.33          // Color2 green offset\n\nprecision highp float;\n#define ANIMATION_SPEED_FACTOR A\n#define FRACTAL_ITERATIONS B\n#define FRACTAL_SEQUENCE_LENGTH C\nint fractalSequence[] = int[C](0, 0, 1, 0, 0, 0, 1, 1, 1);\nvec3 computeColor(vec2 pixelCoordinate) {\n    float currentTime = iTime * A;\n    float weights[D];\n    float x = 0.00000009250;\n    float height = 0.00000920;\n    for (int i = 0; i < D; i++) {\n        weights[i] = E + F * sin(float(i) + G + H * currentTime);\n    }\n    for (int iteration = 0; iteration < B; iteration++) {\n        for (int step = 0; step < C; ++step) {\n            x = weights[step] * pixelCoordinate[fractalSequence[step]] * x * (1.0 - x);\n            height += log2(abs(weights[step] * pixelCoordinate[fractalSequence[step]] * (1.0 - I * x)));\n        }\n    }\n    height /= float(B) * float(C);\n    vec3 colorShift = vec3(K, L, M) + currentTime * N;\n    vec3 color1 = cos((colorShift + -.5 * abs(height)) * J) * O + O;\n    vec3 color2 = vec3(O) + O * sin(vec3(P, Q, P) + 2.5 * abs(height) + currentTime * O);\n    return (height < 0.0) ? mix(color1, color2, pow(abs(height), 13.625)) : vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    uv.x *= iResolution.x/iResolution.y;\n\n    float zoomOut = 10.;\n    \n    vec2 centeredCoordinate = fragCoord - iResolution.xy * 0.5; // Move the fractal center to the screen center\n    vec2 uvColor = computeColor(3.3740 + (1.0 * centeredCoordinate.xy / iResolution.xy)).xy;\n\n    vec3 rgb = (1. - getErraticPattern(\n                uvColor.x, uvColor.y, uvColor * zoomOut\n            ) + getErraticPattern(\n                -uvColor.x, uvColor.y, uvColor * zoomOut\n            ) + getErraticPattern(\n                uvColor.x, -uvColor.y, uvColor * zoomOut\n            ) + getErraticPattern(\n                -uvColor.x, -uvColor.y, uvColor * zoomOut\n            ) );\n    \n    fragColor = vec4(1. - rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}