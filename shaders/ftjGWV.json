{
    "Shader": {
        "info": {
            "date": "1624747537",
            "description": "for livecode.demozoo.org party",
            "flags": 0,
            "hasliked": 0,
            "id": "ftjGWV",
            "likes": 13,
            "name": "anticore 26/06 shader jam",
            "published": 3,
            "tags": [
                "raymarching",
                "shader",
                "jam"
            ],
            "usePreview": 0,
            "username": "anticore",
            "viewed": 413
        },
        "renderpass": [
            {
                "code": "\nvec3 cam(vec3 ro, vec3 rd, vec2 uv) {\n  vec3 f = normalize(rd - ro);\n  vec3 l = normalize(cross(vec3(0,1,0), f));\n  vec3 u = normalize(cross(f, l));\n  \n  return normalize(f + l * uv.x + u * uv.y);\n}\n\nfloat ni(float a){\n    //return texture(texFFTIntegrated, a).x;\n    return iTime;\n}\n\n\nvoid mo(inout vec2 p,vec2 d){p = abs(p)-d;if(p.y>p.x)p=p.yx;}\nvec3 rep(vec3 p, vec3 c) { return mod(p + .5 * c, c) - .5 * c; }\nvec3 repl(vec3 p,vec3 c,vec3 l){return p-c*clamp(round(p/c),-l,l);}\nmat2 rot(float t) { return mat2(cos(t), sin(t), -sin(t), cos(t)); }\nfloat sdBox(vec3 p, vec3 b) { vec3 q = abs(p) - b; return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.); }\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdPlane(vec3 p, vec3 n, float h) { return dot(p,n) + h; }\nfloat rnd(float p) { p = fract(p * .131); p *= p + 333.33; return fract(2. * p * p); }\nfloat dirlight(vec3 n, vec3 ld) {\n  ld = normalize(ld);\n  return clamp(max(dot(n, ld), 0.), 0., 1.);\n }\nfloat spec(vec3 p, vec3 n, vec3 ld, float k) {\n    ld = normalize(ld);\n    vec3 r = reflect(-ld, n);\n    vec3 v = normalize(-p);\n    return pow(max(dot(r,n), 0.), k);\n}\nvec3 palette(float t) {\n    vec3 a= vec3(1);\n    vec3 b= vec3(1);\n    vec3 c = vec3(2);\n    vec3 d = vec3(0,.1, .2);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 ground(vec3 p) {\n    float plane = sdPlane(p, vec3(0,1,0), 0.);\n    float cracks = texture(iChannel0, p.xz * 0.05).r;\n    float crack = 0.28;\n  \n    return vec2(\n    plane + texture(iChannel1, p.xz * .7).r * 0.03\n      + texture(iChannel0, p.zx * 0.1).r * 1.\n      + texture(iChannel0, p.xz * 0.01).r * 4.,\n      \n       cracks > crack && cracks < crack + 0.01 ? 4 : 0\n    );\n}\n\n\nfloat bid;\nfloat tunnel(vec3 p) {\n    vec3 bp = p;\n    bp.xy *= rot(bp.z * 0.1);\n    mo(bp.xy, vec2(0.5));\n    mo(bp.zy, vec2(0.5));\n    bid = rnd(round(p.z + 0.5) * 120.);\n    float b = sdBox(rep(bp + vec3(-1.5, 0, 0), vec3(0, 0, 2)), vec3(0.1, 1.5, 0.1));\n    return b;\n}\n\n\nfloat sid;\nvec2 sphrs(vec3 p) {\n  p = p + vec3(0,0,-iTime - 7.);\n  p.xz *= rot(iTime);\n  p.yz *= rot(iTime);\n  sid = rnd(round(p.x - 0.75) * 10. + round(p.y - 0.75) * 20. +  round(p.z - 0.75) * 10.);\n  p = repl(p, vec3(.5), vec3(2));\n  float s = sdSphere(p + vec3(sin(iTime * 10. + p.x / 10.) * 0.05), .2 - abs(sin(sid * 60. + iTime)) * .15);\n  return vec2(s, fract(sid + iTime) < 0.9 ? 2 : 3);\n}\n\nvec2 map(vec3 p) {\n    float m = 999.;\n    float mm = 0.;\n    \n    vec2 g = ground(p);\n    if (g.x < m) { m = g.x; mm = g.y; }\n    \n    float t = tunnel(p);\n    if (t < m) { m = t; mm = 1.; }\n    \n    vec2 s = sphrs(p);\n    if (s.x < m) { m = s.x; mm = s.y; }\n    \n    return vec2(m, mm);\n}\nvec3 norm(vec3 p) {\n    float E = 0.01; vec2 k = vec2(1, -1);\n    \n    return normalize(\n      k.xyy * map(p + k.xyy * E).x +\n      k.yyx * map(p + k.yyx * E).x +\n      k.yxy * map(p + k.yxy * E).x +\n      k.xxx * map(p + k.xxx * E).x \n    );\n}\n\nvec3 bg(vec2 uv) {\n    float h = uv.y;\n    float n = texture(iChannel0, vec2(uv.x, uv.y - iTime * 0.05)).x;\n    float s = texture(iChannel0, uv * 6. + vec2(sin(iTime) + iTime, cos(iTime))).x > 0.45 ? 1. : 0.;\n  \n    return vec3(n * h*2. * palette(uv.y / 2.1));\n}\n\n\nvec3 ld = vec3(0, 30, 10);\nvec4 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n    vec4 c = vec4(0);\n    vec4 g = vec4(0);\n    int bnc = 0;\n    float en = 1.;\n  \n    for (int i = 0; i < 1000; i++) {\n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x * 0.3;\n      \n        if (h.y == 1.) {\n            g += vec4(palette(bid * (ni(0.15) * 1. + iTime / 2.)) * exp(-h.x * 10.) * .07, 1.);\n        }\n        \n        if (h.y == 3.) {\n          g += vec4(palette(sid / 10.) * exp(-h.x * 10.) * .07, 1.);\n        }\n        if (h.y == 4.) {\n          g += vec4(palette(0.63 + sin(ip.x / 10. + iTime * 0.2)) * exp(-h.x * 10.) * (.5 + abs(sin(ip.x + ip.z + iTime)) * .5), 1.);\n        }\n       \n      \n        if (h.x < 0.01) {\n          vec3 inorm = norm(ip);\n          \n          if (h.y == 0.) {\n              c += vec4(dirlight(inorm, ld) * palette(ip.y * 0.2 + 0.45) * en * 0.7 + spec(ip, inorm, ld, 20.), 1.) * en;\n           }\n           \n           if (h.y == 1.) {\n                c += vec4(palette(bid * (ni(0.15) * 1. + iTime / 2.)) * en, 1.);\n           }\n           \n           if (h.y == 2.) {\n             c += vec4(0.2) * en;\n             ro = ip;\n             rd = reflect(rd, inorm);\n             td = .1;\n             bnc += 1;\n             en = max(en - .7, 0.);\n           }\n           \n           if (h.y == 3.) {\n               c += vec4(palette(sid / 10.) * en, 1.);\n            }\n            \n            if (h.y == 4.) {\n                c += vec4(0.9);\n            }\n        }\n        \n        if (td > 200.) {\n            return vec4(bg(uv) + vec3(g) * exp(-td * 0.05), td/1000.);\n        }\n      \n        if (c.a >= 1. || bnc > 1 || en < 0. || td > 1000.) break;\n    }\n    \n    return vec4((vec3(c) + vec3(g)) * exp(-td * 0.05), td/1000.);\n}\n\n/*\nvoid main(void)\n{\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n\tvec3 ro = vec3(fract(t / 10) > 0.5 ? 10 : 0, 0, t);\n  vec3 rd = cam(ro, vec3(0,0,t + 10), uv);\n  out_color = tr(ro, rd, uv);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(fract(iTime / 10.) > 0.5 ? 10. : 0., 0., iTime);\n      vec3 rd = cam(ro, vec3(0,0,iTime + 10.), uv);\n    fragColor = tr(ro, rd, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}