{
    "Shader": {
        "info": {
            "date": "1606158746",
            "description": "The shape is the intersection of two cylinders.\nThe shadow is the sum of these cylinders.",
            "flags": 32,
            "hasliked": 0,
            "id": "tsdBWX",
            "likes": 1,
            "name": "Ghost Cross of Two Cylinders",
            "published": 3,
            "tags": [
                "3d",
                "primitives"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "// basically anti-aliasing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 du = vec2(1.0, 0.0) / iResolution.xy;\n    vec2 dv = vec2(0.0, 1.0) / iResolution.xy;\n    float alpha = 1.5;\n\n    vec3 col = vec3(0.0);\n    col += texture(iChannel0, uv + du + dv).xyz;\n    col += texture(iChannel0, uv + du).xyz;\n    col += texture(iChannel0, uv + du - dv).xyz;\n    col += texture(iChannel0, uv + dv).xyz;\n    col += texture(iChannel0, uv - dv).xyz;\n    col += texture(iChannel0, uv - du + dv).xyz;\n    col += texture(iChannel0, uv - du).xyz;\n    col += texture(iChannel0, uv - du - dv).xyz;\n    col += texture(iChannel0, uv + 2.0 * du).xyz;\n    col += texture(iChannel0, uv - 2.0 * du).xyz;\n    col += texture(iChannel0, uv + 2.0 * dv).xyz;\n    col += texture(iChannel0, uv - 2.0 * dv).xyz;\n    col /= 12.0;\n    col = 1.0 - vec3(\n        \tpow(1.0 - col.x, alpha),\n        \tpow(1.0 - col.y, alpha),\n        \tpow(1.0 - col.z, alpha)\n    );\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\n\n// ----------------------- Light ----------------------- //\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    float angle;\n};\n\nSpotLight new_light(vec3 position, vec3 direction, float angle) {\n    SpotLight light;\n    light.position = position;\n    light.direction = direction;\n    light.angle = angle;\n    return light;\n}\n\n// ----------------------- Camera ----------------------- //\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nCamera new_camera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nvec3 camera_ray(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    return normalize(right * w * uv.x + up * h * uv.y + camera.direction);  \n}\n\n// ----------------------- Basic Math ----------------------- //\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n// determinant of a 3x3 matrix\nfloat det(in mat3 a) {\n    return a[0][0] * a[1][1] * a[2][2]\n        + a[0][1] * a[1][2] * a[2][0]\n        + a[0][2] * a[1][0] * a[2][1]\n        - a[0][1] * a[1][0] * a[2][2]\n        - a[0][2] * a[1][1] * a[2][0]\n        - a[0][0] * a[1][2] * a[2][1];\n}\n\n// Solves the equation Ax = b.\nvec3 solve(in mat3 a, in vec3 b) {\n    return vec3(\n        det(mat3(b, a[1], a[2])),\n        det(mat3(a[0], b, a[2])),\n        det(mat3(a[0], a[1], b))\n    ) / det(a);\n}\n\n// the square of the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    vec3 a = point - origin;\n    vec3 h = a - dot(a, direction) * direction;\n    return dot(h, h);\n}\n\n// the distance between a point pt and a line stipulated by its origin and its direction\n// The direction vector have to be normalized.\nfloat distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {\n    return sqrt(distance2_point_line(point, origin, direction));\n}\n\n// ------------------- good old Phong model ------------------- //\nfloat phong_ambient() {\n    return 1.0;\n}\n\nfloat phong_diffuse(vec3 position, vec3 normal, SpotLight light) {\n    vec3 dir = normalize(light.position - position);\n    return dot(dir, normal);\n}\n\nfloat phong_specular(vec3 position, vec3 normal, SpotLight light, Camera camera, float alpha) {\n    vec3 light_dir = normalize(light.position - position);\n    if (dot(light_dir, normal) < 0.0) return 0.0;\n    vec3 camera_dir = normalize(camera.position - position);\n    vec3 reflect_dir = reflect(-light_dir, normal);\n    float cos_alpha = clamp(dot(camera_dir, reflect_dir), 0.0, 1.0);\n    return pow(cos_alpha, alpha);\n}\n\nvec3 phong_vector(\n    vec3 position,\n    vec3 normal,\n    SpotLight light,\n    Camera camera,\n    float specular_alpha\n) {\n    return vec3(\n        phong_ambient(),\n        phong_diffuse(position, normal, light),\n        phong_specular(position, normal, light, camera, specular_alpha)\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Copyright Â© 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst vec3 CYLINDER_COLOR = vec3(220.0, 214.0, 231.0) / 255.0;\nconst vec3 CYLINDER_REFLECT_RATIO = vec3(0.2, 0.6, 0.2);\nconst vec3 FLOOR_COLOR = vec3(117.0, 109.0, 145.0) / 255.0;\n\nconst vec3 CYLINDER0_ORIGIN = vec3(0.0, 1.0, -1.0);\nconst vec3 CYLINDER0_DIRECTION = vec3(0.0, 0.0, 1.0);\nconst vec3 CYLINDER1_ORIGIN = vec3(0.0, 0.0, 0.0);\nconst vec3 CYLINDER1_DIRECTION = vec3(0.0, 1.0, 0.0);\nconst float CYLINDER_RADIUS = 0.25;\nconst float CYLINDER_HEIGHT = 2.0;\n\nconst vec3 CORE_CENTER = CYLINDER0_ORIGIN + CYLINDER_HEIGHT * CYLINDER0_DIRECTION / 2.0;\n\nconst vec3 LIGHT_POSITION = vec3(5.0, 5.0, 0.0);\nconst vec3 LIGHT_DIRECTION = normalize(CORE_CENTER - LIGHT_POSITION);\nconst float LIGHT_FOV = PI / 15.0;\n\nconst vec3 LIGHT_GAZE = LIGHT_POSITION - LIGHT_POSITION.y / LIGHT_DIRECTION.y * LIGHT_DIRECTION;\n\nconst vec3 CAMERA_DEFAULT_POSITION = vec3(4.0, 3.5, -3.25) / 1.75;\nconst vec3 CAMERA_DEFAULT_DIRECTION = normalize(LIGHT_GAZE - CAMERA_DEFAULT_POSITION);\nconst float CAMERA_FOV = PI / 4.0;\nconst vec3 CAMERA_ROT_CENTER = LIGHT_GAZE;\nconst float CAMERA_FIX_INTERVAL = 4.0; // second\nconst float CAMERA_ROT_INTERVAL = 4.0; // rad / second\nconst float CAMERA_ONE_CYCLE = CAMERA_ROT_INTERVAL + CAMERA_FIX_INTERVAL;\n\nconst float SPOTLIGHT_BOUNDARY_SHARPNESS = 200.0;\nconst float SHADOW_BOUNDARY_SHARPNESS = 200.0;\n\nstruct Cylinder {\n    vec3 origin;\n    vec3 direction; // have to be normalized\n    float radius;\n    float height;\n};\n\n// Returns positive value if a point is in a cylinde.\nfloat in_cylinder(\n    in vec3 point,\n    in Cylinder cylinder\n) {\n    float dist2 = distance2_point_line(point, cylinder.origin, cylinder.direction);\n    return cylinder.radius * cylinder.radius - dist2;\n}\n\n// Creats an orthogonal matrix whose z_axis is dir.\nmat3 create_matrix(in vec3 dir) {\n    int tmp = abs(dir[0]) < abs(dir[1]) ? 0 : 1;\n    int midx = abs(dir[tmp]) < abs(dir[2]) ? tmp : 2;\n    vec3 axis0 = vec3(0.0);\n    axis0[(midx + 1) % 3] = dir[(midx + 2) % 3];\n    axis0[(midx + 2) % 3] = -dir[(midx + 1) % 3];\n    vec3 axis1 = cross(dir, axis0);\n    return mat3(axis0, axis1, dir);\n}\n\n// Find the intersection of a ray of light with a cylinder extending infinitely around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat regular_infinite_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    out vec3 position,\n    out vec3 normal\n) {\n    vec2 p_ray = normalize(ray.xy);\n    vec2 p_org = origin.xy;\n    vec2 p_h = dot(p_ray, p_org) * p_ray - p_org;\n    float res = radius * radius - dot(p_h, p_h);\n    if (res < 0.0) {\n        return res;\n    }\n    float t = dot(p_ray, -p_org) - sqrt(res);\n    t *= 1.0 / length(ray.xy);\n    position = origin + t * ray;\n    normal = vec3(position.xy, 0.0);\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder around the z-axis.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[in] height the height of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return Returns a positive value if the ray and the cylinder have a intersection.\nfloat regular_cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in float radius,\n    in float height,\n    out vec3 position,\n    out vec3 normal\n) {\n    float res = regular_infinite_cylinder_intersection(\n        origin,\n        ray,\n        radius,\n        position,\n        normal\n    );\n    if (position.z < 0.0) {\n        position = origin - origin.z / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    } else if (position.z > height) {\n        position = origin + (height - origin.z) / ray.z * ray;\n        res = radius * radius - dot(position.xy, position.xy);\n    }\n    return res;\n}\n\n// Find the intersection of a ray of light with a cylinder.\n// @param[in] origin the origin of the ray\n// @param[in] ray the direction of the ray\n// @param[in] radius the radius of the cylinder\n// @param[out] position the intersection point\n// @param[out] normal the normal vector of the cylinder at the intersection point\n// @return radius^2 - (the distance between the ray and the z-axis)^2\nfloat cylinder_intersection(\n    in vec3 origin,\n    in vec3 ray,\n    in Cylinder cylinder,\n    out vec3 position,\n    out vec3 normal\n) {\n    mat3 mat = create_matrix(cylinder.direction);\n    if (abs(det(mat)) < 1.0e-3) {\n        return -1.0;\n    }\n    float res = regular_cylinder_intersection(\n        solve(mat, origin - cylinder.origin),\n        solve(mat, ray),\n        cylinder.radius,\n        cylinder.height,\n        position,\n        normal\n    );\n    position = mat * position + cylinder.origin;\n    normal = mat * normal;\n    return res;\n}\n\n// Renders the intersection of two cylinders\nfloat render_core(\n    in vec2 uv,\n    in Camera camera,\n    in SpotLight light,\n    in Cylinder cylinder[2],\n    out vec3 col\n) {\n    vec3 ray = camera_ray(camera, uv);\n    vec3 position0, normal0, position1, normal1;\n    float res0 = cylinder_intersection(camera.position, ray, cylinder[0], position0, normal0);\n    float res1 = cylinder_intersection(camera.position, ray, cylinder[1], position1, normal1);\n    float res = min(res0, res1);\n    if (res < 0.0) {\n        return res;\n    }\n    vec3 position, normal;\n    float res01 = in_cylinder(position0, cylinder[1]);\n    float res10 = in_cylinder(position1, cylinder[0]);\n    if (res01 < 0.0 && res10 < 0.0) {\n        return -1.0;\n    } else if (res01 < 0.0) {\n        position = position1;\n        normal = normal1;\n    } else if (res10 < 0.0) {\n        position = position0;\n        normal = normal0;\n    } else {\n        float depth0 = length(position0 - camera.position);\n        float depth1 = length(position1 - camera.position);\n        position = depth0 < depth1 ? position0 : position1;\n        normal = depth0 < depth1 ? normal0 : normal1;\n    }\n    vec3 phong_vector = phong_vector(position, normal, light, camera, 5.0);\n    col = CYLINDER_COLOR * dot(phong_vector, CYLINDER_REFLECT_RATIO);\n    return res;\n}\n\n// Renders the floor\nvec3 render_floor(\n    vec2 uv,\n    Camera camera,\n    SpotLight light,\n    Cylinder cylinder[2]\n) {\n    vec3 ray = camera_ray(camera, uv);\n    float t = -camera.position.y / ray.y;\n    vec3 pt = camera.position + t * ray;\n    vec3 light_dir = normalize(pt - light.position); \n    float sub0 = cos(light.angle) - dot(light_dir, light.direction);\n    if (sub0 > 0.0) {\n        sub0 = clamp(1.0 - SPOTLIGHT_BOUNDARY_SHARPNESS * sub0, 0.0, 1.0);\n        return FLOOR_COLOR * sub0 * (-light_dir.y);\n    }\n    float sub1 = -10.0;\n    for (int i = 0; i < 2; i++) {\n        vec3 _position, _normal;\n        float tmp = cylinder_intersection(\n            light.position,\n            light_dir,\n            cylinder[i],\n            _position,\n            _normal\n        );\n        sub1 = max(sub1, tmp);\n    }\n    if (sub1 > -0.01) {\n        sub1 = clamp(1.0 - SHADOW_BOUNDARY_SHARPNESS * sub1, 0.0, 1.0);\n        return FLOOR_COLOR * sub1 * (-light_dir.y);\n    }\n    return FLOOR_COLOR * (-light_dir.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time0 = CAMERA_FIX_INTERVAL / CAMERA_ONE_CYCLE;\n    float time = clamp(fract(iTime / CAMERA_ONE_CYCLE), time0, 1.0);\n    float camera_rot_angle = 2.0 * PI * time / (1.0 - time0);\n    \n    Cylinder cylinder[2];\n    cylinder[0].origin = CYLINDER0_ORIGIN;\n    cylinder[0].direction = CYLINDER0_DIRECTION;\n    cylinder[0].radius = CYLINDER_RADIUS;\n    cylinder[0].height = CYLINDER_HEIGHT;\n    cylinder[1].origin = CYLINDER1_ORIGIN;\n    cylinder[1].direction = CYLINDER1_DIRECTION;\n    cylinder[1].radius = CYLINDER_RADIUS;\n    cylinder[1].height = CYLINDER_HEIGHT;\n    \n    mat3 camera_rot = rot(vec3(0.0, 1.0, 0.0), camera_rot_angle);\n    vec3 camera_position = CAMERA_DEFAULT_POSITION - CAMERA_ROT_CENTER;\n    camera_position = camera_rot * camera_position + CAMERA_ROT_CENTER;\n    Camera camera = new_camera(\n        camera_position,\n        camera_rot * CAMERA_DEFAULT_DIRECTION,\n        vec3(0.0, 1.0, 0.0),\n        CAMERA_FOV,\n        iResolution.x / iResolution.y\n    );\n\n    SpotLight light = new_light(\n        LIGHT_POSITION,\n        LIGHT_DIRECTION,\n        LIGHT_FOV\n    );\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = render_core(uv, camera, light, cylinder, col);\n    if (t > 0.0) fragColor = vec4(col, 1.0);\n    else fragColor = vec4(render_floor(uv, camera, light, cylinder), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}