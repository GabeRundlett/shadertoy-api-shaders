{
    "Shader": {
        "info": {
            "date": "1609561964",
            "description": "my new year's resolution is to watch what unfolds",
            "flags": 0,
            "hasliked": 0,
            "id": "ttdcR2",
            "likes": 9,
            "name": "New Year's Resolution 2021",
            "published": 3,
            "tags": [
                "eyes",
                "eye",
                "rainbow",
                "resolution",
                "unfold",
                "2021"
            ],
            "usePreview": 0,
            "username": "netgrind",
            "viewed": 408
        },
        "renderpass": [
            {
                "code": "// \"Fork\" of \"Geodesic tiling (abs position)\" by tdhooper. https://shadertoy.com/view/XtKSWc\n// Most of the geodesic stuff is gone, but the march/render code is still in place\n// various sdf functions via iq and mercury\n// 2021-01-01 23:50:17\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 color;\n};\n\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nvec4 fOpUnionRound(vec4 a, vec4 b, float r) {\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/r, 0.0, 1.0 );\n    return mix( b, a, h ) - r*h*(1.0-h);\n}\n    \nvec4 opSmoothSubtraction( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    return mix( d2, vec4(-d1.x, d1.yzw), h ) + k*h*(1.0-h); \n}\nvec4 opUnion( vec4 d1, vec4 d2 ) {  return mix(d1,d2, clamp(ceil(d1.x-d2.x), 0., 1.)); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n// The actual model\nModel map(vec3 p) {\n    \n    float sineTime = iTime*6.28*.5;\n\n\tfloat sphere = length(p) - 2.; \n    sphere = max(-(length(p)-1.8), sphere);\n    vec2 uv = p.xy*2.;\n   \n    float f = floor(uv.x+uv.y) + floor(uv.y-uv.x);\n    uv = vec2(fract(uv.x+uv.y),fract(uv.y-uv.x));\n    uv -= .5;\n    \n    vec3 pos = p;\n    //pos.y-=.08;\n    float i = pMod1(pos.y, .25);\n    float j = pModPolar(pos.xz,30.,i*3.14159+(sineTime+sin(sineTime+3.1415)*1.5)*(mod(i, 2.)-.5));\n    pos -= vec3(.8-cos((i)*.2+3.14159), 0., 0.);\n    float eye = length(pos+vec3(0., .04, 0.))-.1;\n    eye = max(eye, length(pos-vec3(0., .04, 0.))-.1);\n    vec4 s = fOpUnionRound(vec4(sphere, 0., 0., 0.), vec4(eye, 2., 2., 2.), 0.05);\n    s = opSmoothSubtraction(vec4(eye-.005, 0., 0., 0.), s, .01);\n    pR(pos.xy, p.y*.5+sin(i+j+sineTime)*.05);\n    float a =atan(pos.z, pos.y);\n    vec3 eyeColor = sin(vec3((p.x+p.y*2.+vec3(0., .3, .6))*7.+sineTime))*.4+.4;\n    eyeColor+=cos(a*20.+a*3.)*.2+.2;\n    float pupilSize = 0.025+sin(sineTime-(p.y-p.x)*2.)*0.005;\n    eyeColor*=smoothstep(pupilSize, pupilSize+.01, length(pos.zy));\n    s = opUnion(s, vec4(length(pos)-.06, eyeColor));\n    p*=.8;\n    //p.y -= .01;\n    pR(p.yz, 1.);\n    pos = p;\n    i = pModPolar(pos.xz, 10., sineTime);\n    pR(pos.xy, -sineTime*.5);\n    j = pModPolar(pos.yx, 5., sineTime);\n    float box = fBox(pos, vec3(0., .1*smoothstep(0., .1,length(p-vec3(0., .1, 0.))), 0.));\n    vec4 b = vec4(box, sin((pos.y*8.+vec3(0., .66, .33))*7.-sineTime+atan(p.x, p.z))*.5+.5);\n    b = fOpUnionRound(b, vec4(length(p)-.05, 1, 1, 1), .1);\n    s = opUnion(s, b); \n\treturn Model(s.x, s.yzw);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.;\nconst float INTERSECTION_PRECISION = .00001;\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        //if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n        //    break;\n        //}\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    if (hit.isBackground) {\n        return vec3(0);\n    }\n    vec3 color = hit.model.color;\n    color += sin(dot(hit.normal, vec3(0,1,0))) * .2; // lighting\n    color *= 1. - clamp(hit.ray.len * .4 - .8, 0., 1.); // fog\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 camPos = vec3(0, 0, .4);\n    vec3 camTar = vec3(0);\n    float camRoll = 0.;\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camRoll);\n    \n    vec3 rd = normalize(camMat * vec3(p.xy, 2.));\n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    float f = .85;\n    //color *= smoothstep(f+.05, f, abs(p.y-.08)-abs(p.x)*.1);\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}