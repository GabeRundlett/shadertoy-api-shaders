{
    "Shader": {
        "info": {
            "date": "1613093990",
            "description": "V1.0, I wanted to simulate a black hole starting to consume a large star. This doesn't seem to work well on mobile.\n\nSources:\n\nhttps://www.shadertoy.com/view/MdtGRl\nhttps://www.shadertoy.com/view/4lSXD1\nhttps://www.shadertoy.com/view/Xsc3R4",
            "flags": 0,
            "hasliked": 0,
            "id": "ttdBzj",
            "likes": 3,
            "name": "Black Hole Near Event Horizon",
            "published": 3,
            "tags": [
                "space",
                "galaxy",
                "blackhole",
                "disk",
                "dust",
                "eventhorizon"
            ],
            "usePreview": 0,
            "username": "Ubiquitous",
            "viewed": 421
        },
        "renderpass": [
            {
                "code": "// \"Black Hole Near Event Horizon\" by Ubiquitous, thanks Duke!\n// \n//-------------------------------------------------------------------------------------\n// Based on \"Protoplanetary Disk\" (https://www.shadertoy.com/view/MdtGRl)\n// In addition to \"Dusty nebula 1\" (https://www.shadertoy.com/view/4lSXD1) \n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------------\n\n//#define MOUSE_CAMERA_CONTROL\n\n// comment this string to see fluffy clouds\n#define DENSE_DUST\n\n#define DITHERING\n#define BACKGROUND\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat2 Spin(float angle)\n{\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(2.0,4.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 2.8)/256.0, 2.5 ).yx;\n\treturn -1.0+0.7*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p)\n{\n   return pn(p*.06125)*.5 + pn(p*.125)*.15 + pn(p*.15)*.225;// + pn(p*.5)*.625;\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(2.9898,1.233))) * 63758.5453);\n}\n\nfloat Ring(vec3 p)\n{\n  vec2 q = vec2(length(p.xy)-5.3,p.z);\n  return length(q)-0.51;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.15);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.45 + 0.14*(b-a)/k, 1.250, 0.250 );\n\treturn mix( b, a, h ) - k*h*(2.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float t=0.23*iTime;\n\tfloat d1 = Disk(p,vec3(2.75,0.88,0.45)) + fpn(vec3(Spin(t*3.25+p.z*1.20)*p.xy*24.,p.z*25.-t)*5.0) * 0.845;\n    float d2 = Ring(p);\n    return smin(d1,d2,1.52);\n\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( 0.6*vec3(0.26,0.5,0.4), vec3(0.8,0.25,0.1), density );\n\t\n\t// color added for disk\n\tvec3 colCenter = 2.*vec3(0.22,0.6,0.5);\n\tvec3 colEdge = 3.*vec3(0.08,0.23,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.2)/1.0, 0.25 ) );\n\t\n\treturn result;\n}\n\nbool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 11.;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.15 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.1 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t// top, bottom\n\tvec2 zcap = vec2(9.15, -2.85);\n\tvec2 cap = (zcap - org.z) / dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 2.5 && far > near;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.7;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.15)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 2.5));\n\tvec3 ro = vec3(1.1, 1.2, -6.+key*0.2);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*4.);\n    R(rd.xz, iMouse.x*0.041*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*4.);\n    R(ro.xz, iMouse.x*0.041*pi*2.);\n    #else\n    R(rd.yz, -pi*3.65);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.65);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n   \t// randomizing the length \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \n\t#endif \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0.48, td=0.23, w=1.04;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=21.8, t=21.2;\n   \n\tvec4 sum = vec4(0.1);\n   \n    float min_dist=2.52, max_dist=222.5;\n\n    if(Raycylinderintersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<36; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n\n\t\tfloat fld = 0.40;\n       \n\t\t// Loop break conditions.\n        if(td>(0.9-1./7.) || d<0.008*t || t>13. || sum.a > 0.99 || t>max_dist) break;\n\t  \n\t\t// evaluate distance function\n\t\td = map(pos); \n       \n\t\t// direction to center\n\t\tvec3 stardir = normalize(vec3(3.4)-pos);\n      \n\t\t// change this string to control density \n\t\td = max(d,0.04);\n      \n\t\tif (d<0.1) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = 0.2 - d;\n\t\t\t\n            #ifdef DENSE_DUST          \n\t\t\tfld = clamp((ld - map(pos+4.2*stardir))/1.4, 0.22, 1.3 );\n\t\t\tld += fld;\n            #endif\n \t\t\t\n            // compute weighting factor \n\t\t\tw = (1.4 - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 2./3.;\n\t\t\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.5));\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\t\t\n\t\t\t// uniform scale density\n\t\t\tcol.a *= 1.02;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a/11.08;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.08 - sum.a);  \n\t\t}\n      \n\t\ttd += 1./110.;\n       \n        // point light calculations\n        vec3 ldst = vec3(1.32)-pos;\n        float lDist = max(length(ldst), 0.021);\n\n        // star in center\n        vec3 lightColor=vec3(0.81,0.31,0.15);\n        sum.rgb+=lightColor/(lDist*lDist*lDist*7.);//*10.); //add a bloom around the light\n\n        // using the light distance to perform some falloff\n        //float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\n        // accumulating the color\n        //sum += w*atten*fld;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.24); \n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        d=abs(d)*(1.+0.58*rand(seed*vec2(i)));\n        #endif \n\t  \n        t +=  max(d * 0.13, 0.19);\n      \n\t}\n    \n    //scattering test\n\t//sum *= 1. / exp( ld * 0.2 ) * 1.05;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-1.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<1.8)\n    {\n        vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.1,0.3,0.2), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.4),rd)+0.75,0.4,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n    \n   fragColor = vec4(sum.xyz,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}