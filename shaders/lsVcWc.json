{
    "Shader": {
        "info": {
            "date": "1524046348",
            "description": "[WIP]learning basic ray tracing",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVcWc",
            "likes": 6,
            "name": "Basic Ray Tracing",
            "published": 3,
            "tags": [
                "3d",
                "raytracing"
            ],
            "usePreview": 0,
            "username": "IOchair",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "#define N_SPHERES 2\n\nconst float PI = 3.14159265358979323846;\n\nstruct Ray{vec3 o;vec3 d;};\nstruct Sphere{vec3 p;float r;};\nstruct Cam{vec3 pos;vec3 lookAt;float fstop;};\n\n//Sphere setup\nSphere spheres[N_SPHERES];\nvec3 L = normalize(vec3(.618,.618,-.618));\nvoid SetupScene(void)\n{\n    spheres[0] = Sphere(vec3(0.,-10000.,0.),10000.);//Ground\n    spheres[1] = Sphere(vec3(0.,1.,8.),1.);\n}\n    \n    \n//---Math---\nfloat sqr(float x) { return x*x; }\n\n//---Intersect---\n//\nfloat distLine(Ray ray,Sphere sphere){\n    float dist = length(cross(sphere.p - ray.o ,ray.d))/length(ray.d);\n    /*if(dist > sphere.r)\n        dist = 0.;\n    else\n        dist = 1.;// - dist;*/\n\treturn dist;\n}\n\n//www.shadertoy.com/view/MsySzd\nfloat sphereIntersect( Ray ray , Sphere sphere)\n{\n    vec3 op = sphere.p - ray.o;\n    float eps = 0.01;\n    float b = dot(op , ray.d);\n    float det = b * b - dot(op,op) + sphere.r * sphere.r;\n    if (det < 0.0)\n        return 0.0;\n\n    det = sqrt(det);\n\n    float t1 = b - det;\n    if( t1 > eps )\n        return t1;\n\n    float t2 = b + det;\n    if( t2 > eps )\n        return t2;\n\n    return 0.0;\t\n}\n\nfloat Intersect(Ray r , inout Sphere s , inout float t )\n{\n    float d;\n    t   = 0.0;\n    for (int i = 0; i < N_SPHERES; i++)\n    {\n        d = sphereIntersect( r , spheres[i]);\n        if (d != 0.0)\n        {\n            t = d;\n            s = spheres[i];\n        }\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 hitPos,Sphere sphere)\n{\n    return normalize(hitPos-sphere.p);\n}\n\nfloat calcShadow(Ray ray)\n{\n    float dist = distLine(ray,spheres[1]);\n    //dist = clamp (dist/spheres[1].r,.9 ,1.);\n    return dist/spheres[1].r > 1. ?1.:0.;\n    //dist = dist/spheres[1].r;\n    //return dist;\n}\n\nvec4 normalIntersect( Ray ray,Sphere sphere)\n{\n    float t;\n    float shadowFactor = 1.0;\n    t = Intersect(ray,sphere,t);\n    if(t>0.0)\n    {\n        vec3 hitPos = ray.o + t*ray.d;\n        vec3 n = calcNormal(hitPos , sphere);\n        if (sphere == spheres[0])\n        {\n            Ray shadowRay = Ray(hitPos,-L);\n            shadowFactor = calcShadow(shadowRay);\n        }\n        return vec4(n,shadowFactor);\n    }\n    return vec4(0.);\n}\n\n//---Cam---\nvoid camRay(vec2 uv,Cam cam,inout Ray ray)\n{\n    vec3 fowardVec = normalize(cam.lookAt - cam.pos);\n    vec3 rightVec = normalize(cross(vec3(0.,1.,0.),fowardVec));\n    vec3 upVec = cross(fowardVec,rightVec);\n    \n    vec3 rayOrigin = cam.pos;\n    vec3 rayCenter = cam.pos + (iResolution.x/iResolution.y)*cam.fstop*fowardVec;\n    vec3 rayDir = normalize(rayCenter + rightVec*uv.x + upVec*uv.y - rayOrigin);\n    \n    ray = Ray(rayOrigin,rayDir);\n}\n\n//---BRDF---\n\n//GGX from Disney brdf explorer\nfloat GGX(float alpha, float cosThetaM)\n{\n    float CosSquared = cosThetaM*cosThetaM;\n    float TanSquared = (1.0-CosSquared)/CosSquared;\n    return (1.0/PI) * sqr(alpha/(CosSquared * (alpha*alpha + TanSquared)));\n}\n\nfloat Lambert(vec3 L,vec3 N)\n{\n    return clamp(dot(L,N),0.,1.);\n}\n\nvec3 BRDF( vec3 L, vec3 V, vec3 N ,float factor)\n{\n    vec3 Col = (N+1.)*.5;\n    vec3 H = normalize( L - V );\n    vec3 Diffuse = Col*Lambert(L,N)*factor;//Lambert Diffuse with normal color\n    vec3 Specular = Col*GGX(.1, dot(N,H))*factor;\n    vec3 Ambient = Col*0.1;\n    return Diffuse + Specular + Ambient;\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51f;\n    float tB = 0.03f;\n    float tC = 2.43f;\n    float tD = 0.59f;\n    float tE = 0.14f;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    Ray ray;\n    Cam cam = Cam(vec3(-3.,4.,-2.),vec3(0.,1.,8.),1.4); \n    Sphere sphere;// = Sphere(vec3(0.,1.,8.),1.);\n    SetupScene();\n    \n    camRay(uv, cam, ray);\n    vec4 surfaceInfo = normalIntersect(ray,sphere);\n\n    // point distance to color\n    vec3 col = BRDF(L,ray.d,surfaceInfo.xyz,surfaceInfo.w);\n    \n\n    // Output to screen with Gamma correction    \n    col = ACESFilm(col*2.0);\n    fragColor = vec4( col,1.0);;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}