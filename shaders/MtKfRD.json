{
    "Shader": {
        "info": {
            "date": "1542063503",
            "description": "made another one, this time everything is centered but there is a circle and a box instead of just circles, also a 3d and 2d comparison.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MtKfRD",
            "likes": 5,
            "name": "boxcircle shape distance",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distance",
                "union"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 495
        },
        "renderpass": [
            {
                "code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nfloat box(vec2 p, vec2 s) {\n    vec2 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,q.y),0.0);\n}\n\nfloat box(vec3 p, vec3 s) {\n    vec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(max(q.x,q.y),q.z),0.0);\n}\n\nfloat boxcircle(vec2 p, float r0, float r1, float sign0, float sign1) {\n    \n    if (r1 < r0) {\n        vec2 q = abs(p);\n        q = vec2(min(q.x,q.y),max(q.x,q.y));\n        vec2 corner = vec2(sqrt(r0*r0-r1*r1),1);\n        vec2 q2 = q-corner;\n        vec2 n = vec2(-corner.y,corner.x);\n        if (min(sign1*dot(q2,n),-sign0*q2.x)>0.0) return length(q2);\n    }\n    \n    float len = -sign0*(length(p)-r0);\n    len = max(len,sign1*box(p,vec2(r1)));\n    return len;\n}\n\nfloat map(vec3 p, float r0, float r1, float sign0, float sign1) {\n    \n    if (r1 < r0) {\n        vec3 p2 = abs(p);\n        vec3 q = vec3(min(min(p2.x,p2.y),p2.z),0,max(max(p2.x,p2.y),p2.z));\n        q.y = dot(p2-q,vec3(1));\n        vec2 q2 = vec2(length(q.xy),q.z);\n\n        vec2 corner = vec2(sqrt(r0*r0-r1*r1),1);\n        q2 = q2-corner;\n        vec2 n = vec2(-corner.y,corner.x);\n        if (min(sign1*dot(q2,n),-sign0*q2.x)>0.0) return length(q2);\n    }\n    \n    float len = -sign0*(length(p)-r0);\n    len = max(len,sign1*box(p,vec3(r1)));\n    return len;\n}\n\nvec3 findnormal(vec3 p, float eps, float r0, float r1, float sign0, float sign1) {\n    vec2 e = vec2(0,eps);\n    \n    return normalize(vec3(\n        map(p+e.yxx,r0,r1,sign0,sign1),\n        map(p+e.xyx,r0,r1,sign0,sign1),\n        map(p+e.xxy,r0,r1,sign0,sign1))\n       -map(p      ,r0,r1,sign0,sign1));\n}\n\nfloat line( vec2 pa, vec2 ba) \n{\n    float h = max( dot(pa,ba)/dot(ba,ba), 0.0 );\n    return length( pa - ba*h );\n}\n\nfloat visualize(vec2 p, float r0, float r1, float sign0, float sign1) {\n    \n    float len = abs(length(p)-r0);\n    //len = min(len,abs(box(p,vec2(r1))));\n    //float len = 1000.0;\n    \n    if (r1 < r0) {\n        p = abs(p);\n        p = vec2(min(p.x,p.y),max(p.x,p.y));\n        vec2 corner = vec2(sqrt(r0*r0-r1*r1),1);\n        vec2 q = p-corner;\n        vec2 n = vec2(-corner.y,corner.x);\n\n        len = min(len,min(abs(line(q,-corner*sign0)),abs(line(q,vec2(0,1)*sign1))));\n    }\n    //if (min(sign0*dot(q,n),sign1*dot(q,vec2(-1,0)))>0.0)len = length(q);\n    \n    return max(0.25-abs(len)*iResolution.y/32.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float r0 = mix(1.0,sqrt(2.0),sin(iTime)*0.5+0.5);\n    float r1 = 1.0;\n    float sign0 = 1.0;\n    float sign1 = 1.0;\n    \n    if (fragCoord.x > iResolution.x*0.5) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = 2.0*(fragCoord*2.0-iResolution.xy)/iResolution.x*2.0;\n\t\tuv.x -= 2.0;\n\n        float len = boxcircle(uv,r0,r1,sign0,sign1);\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        //this is a bit different, i wanted the border to be resolution independent\n        vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n        col *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n        col *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n        col = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\n        fragColor = vec4(col*col, 1.0);\n\n        fragColor += visualize(uv,r0,r1,sign0,sign1);\n    } else {\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.x*2.0;\n\t\tuv.x += 1.0;\n        \n        \n        vec3 ro = vec3(0,0,-3.0);\n        vec3 rd = normalize(vec3(uv,1));\n        \n        if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.15-3.15*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.15*2.0-3.15);\n            ro.yz *= rot(iMouse.y/iResolution.y*3.15-3.15*0.5);\n            ro.xz *= rot(iMouse.x/iResolution.x*3.15*2.0-3.15);\n        }\n        \n        \n        float d = 0.0;\n        \n        for( int i = 0; i < 200; i++) {\n            vec3 p = ro+rd*d;\n            float l = map(p,r0,r1,sign0,sign1)-0.2;\n            d += l;\n            if (d > 10.0 || l < d/iResolution.y) {\n                break;\n            }\n        }\n        if (d < 10.0) {\n            vec3 p = ro+rd*d;\n            \n            vec3 normal = findnormal(p,0.001,r0,r1,sign0,sign1);\n            vec3 light = vec3(-1.0/sqrt(3.0));\n            \n            \n            fragColor = vec4(normal*0.2+0.8,1);\n            fragColor *= max(dot(normal,-light),0.1);\n        } else {\n            fragColor = vec4(vec3(0.6,0.5,0.8)*(rd.y*0.5+0.5)\n                            +vec3(0.8,0.7,0.4)*(dot(rd,vec3(-1.0/sqrt(3.0)))*0.5+0.5),1);\n        }\n    }\n    // squareroot for 2.0 gamma\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}