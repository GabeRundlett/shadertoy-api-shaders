{
    "Shader": {
        "info": {
            "date": "1640352037",
            "description": "Very simple.",
            "flags": 0,
            "hasliked": 0,
            "id": "slyXzw",
            "likes": 2,
            "name": "Doors_lesson-127",
            "published": 3,
            "tags": [
                "fragmentshader"
            ],
            "usePreview": 0,
            "username": "xlat",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": "///----------------------------------------------------------------------------|\n/// XLAT\n/// Doors_lesson-127\n///----------------------------------------------------------------------------:\n/// (... написан на коленке, без оптимизаций и обфурскаций ...)\n///----------------------------------------------------------------------------:\n\n///------------------------|\n/// Config.                |\n///------------------------:\nconst float RADIUSS  =  0.7;\nconst float NSEC     = 18.0;\n      float SPEED    =  0.2;\n///------------------------.\n\nconst vec4  WHITE    = vec4(0.9, 0.9, 0.9, 1.);\nconst vec4  BLUE     = vec4(0.0, 0.0, 0.6, 1.);\nconst vec4  RED      = vec4(0.6, 0. , 0. , 1.);\nconst vec4  BGROUND  = vec4(0.0, 0.0, 0.2, 1.);\nconst vec4  YELLOW   = vec4(0.0, 0.0, 0.0, 1.);\n\nconst float PIx2     = 6.2831853;\n\n/// not use\nvec4 tonsin(float minn, float maxx, float a)\n{   a = a - minn;\n    float x = 1.57 / (maxx - minn);\n    float c  = 0.3  * cos(a * x);\n    return vec4(c, c, c, .8);\n}\n\nfloat distance_x2(vec2 p1, vec2 p2)\n{   vec2   dp = p1 - p2;\n    return dp.x * dp.x + dp.y * dp.y;\n}\n\nbool isCircle(vec2 p, float radius)\n{   float d = distance_x2(p, vec2(0., 0.));\n    float r = radius * radius;\n    if( d < r && d > r * 0.8 ) return true ;\n                               return false;\n}\n\n#define step_t vec2\n\nfloat Speed ;\nfloat Speed1;\nfloat Speed2;\nfloat RADIUS;\n\n#define SIN  sin(Speed)\n#define SIN1 sin(Speed1)\n#define SIN2 sin(Speed2)\n#define COS  cos(Speed) \n#define COS1 cos(Speed1)\n#define COS2 cos(Speed2)\n\n#define STEP(amplitude_x, speed_x, amplitude_y, speed_y) step_t( \\\n                              -abs(amplitude_x * sin(speed_x)),  \\\n                                   amplitude_y * sin(speed_y))\n\n///----------------------------------------------|\n/// Lept\n///----------------------------------------------:\nstruct Lept\n{   int   i          ;\n    float radius     ;\n    float radiusintro;\n    vec2  pos        ;\n    float speedx     ;\n    float speedy     ;\n    float speedr     ;\n    int   modecolor  ;\n    vec3  colorinit  ;\n};\n\n///----------------------------------------------|\n/// Common lib.\n///----------------------------------------------:\nvec2 rot(vec2 p, float a)\n{   return vec2( p.x * cos(a) - p.y * sin(a),\n                 p.x * sin(a) + p.y * cos(a) );\n}\n\nfloat getAngle(vec2 pos)\n{   vec2 p = normalize(pos);\n    if(p.y > 0.0) return acos(p.x);\n    else          return PIx2 - acos(p.x);\n}\n\nconst int       AMOUNT_LEPTS = 2;\nLept      lepts[AMOUNT_LEPTS];\nvoid init_lepts()\n{   \n    lepts[0] = Lept(0, 0.1 , 0.8, vec2( 0.3, 0.1), 0.9, 1.0, 1.1, 3,\n                                  vec3( 0.3, 0.3 , 0.3));\n                                  \n    lepts[1] = Lept(1, 0.08, 0.5, vec2( 0.1,-0.1), 1.2, 1.2, 1.0, 2,\n                                  vec3( 0.3, 0.3 , 0.3));\n}\n        \nvec3 move_lept(int i, inout vec2 pixel)\n{   \n    vec3 colorresult = vec3(-1.0);\n    if(isCircle(pixel + STEP(0.1, lepts[i].speedx * SIN2 - 0.2 * SIN,\n                             0.2, lepts[i].speedy * COS1 - 0.1 * COS),\n                                  lepts[i].radius * SIN + lepts[i].radius + 0.05))\n    {   if(1 == lepts[i].modecolor)\n        {\n            colorresult.r = lepts[i].colorinit.r * COS + 0.7;\n            colorresult.g = lepts[i].colorinit.g * SIN + 0.7;\n            colorresult.b = 0.0;\n        }\n        else if(2 == lepts[i].modecolor)\n        {\n            colorresult.r = lepts[i].colorinit.r * COS + 0.7;\n            colorresult.g = 0.0;\n            colorresult.b = lepts[i].colorinit.b * SIN + 0.7;\n        }\n        else if(3 == lepts[i].modecolor)\n        {\n            colorresult.r = 0.0;\n            colorresult.g = lepts[i].colorinit.g * COS + 0.7;\n            colorresult.b = lepts[i].colorinit.b * SIN + 0.7;\n        }\n    }\n    return colorresult;\n  //return BLUE;\n}\n\nvec4 flower(vec2 pixel)\n{   for(int i = 0; i < AMOUNT_LEPTS; ++i)\n    {   vec3 color   = move_lept(i, pixel);\n        if(  color.r > -1.0)\n        {   return vec4(color, 1.0);\n        }\n    }\n    return vec4(-1.0);\n    //return BLUE;\n}\n\n#define NO if(false)\n\nvec4 colorSectors(vec2 pos)\n{\n    pos = rot(pos - 0.5, Speed);\n\n    if(RADIUS * RADIUS < pos.x * pos.x + pos.y * pos.y) return BGROUND;\n\n    float asector = PIx2 / NSEC  ;\n    float a       = getAngle(pos);\n\n    for(float i = asector, j = 0.; i < PIx2; i += asector, j += 1.)\n    {\n        if(a < i)\n        {   \n            if(mod(j, 2.) == 0.)\n            {\n                vec4 color = flower(rot(pos, -i));\n                if(color.a > 0.)\n                {   return color + vec4( 0., 0., fract(a)/3., 0.);\n                }\n            }\n            else\n            {   float t =  i - asector - a - a;\n                vec4 color = flower(rot(pos, t));\n                if(color.a > 0.)\n                {   return color + vec4( fract(t)/3., fract(t)/3., fract(t)/3., 0.);\n                }\n            }\n\n            return vec4(0.3*sin(i)+0.4, 0.0, 0.0, 1.0);\n        }\n    }\n\n    return WHITE;\n}\n\n///----------------------------------------------------------------------------|\n/// Doors.\n///----------------------------------------------------------------------------:\nvec4 Door_X(vec2 pos)\n{   \n    if(pos.x < 0.05) return tonsin(0.  , 0.05, pos.x);\n    if(pos.x > 0.45) return tonsin(0.45, 0.5 , pos.x);\n    \n    if(pos.y < 0.05) return tonsin(0.  , 0.05, pos.y);\n    if(pos.y > 0.95) return tonsin(0.95, 1.  , pos.y);\n    \n    return tonsin(0.4, 0.8, pos.y);\n}\n\nfloat Move_Door(float t)\n{   float a = cos(t / 4.) * 0.21;\n\n    if(a < 0.) return 0.42;\n\n           t = 0.21 - cos(t / 2.) * 0.21;\n    return t;\n}\n\nvec4 Doors(vec2 pos, float t)\n{\n    float open = Move_Door(t);\n\n    float\n       xx = pos.x + open;\n    if(xx < 0.5) return Door_X(vec2(xx      , pos.y));\n\n       xx = pos.x - open;\n    if(xx > 0.5) return Door_X(vec2(xx - 0.5, pos.y));\n\n    return vec4(-1.);\n}\n\n///----------------------------------------------------------------------------|\n/// Run.\n///----------------------------------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/iResolution.xy;  \n    init_lepts();\n    \n    float arr[] = float[5](1., 1., 1., 1., 1.);\n\n    float a = ((SPEED+.6)*sin(iTime/ 5.) - 1.6) / iTime;\n    \n    Speed    = iTime * (SPEED+a)      ;\n    Speed1   = iTime * (SPEED+a) * 1.2;\n    Speed2   = iTime * (SPEED+a) * 1.5;\n    \n    RADIUS   = iTime / 5.; if(RADIUS > RADIUSS) RADIUS = RADIUSS;\n\n    vec4 brd = Doors(pos, iTime);\n    if(  brd.a == -1.) fragColor = colorSectors(pos);\n    else               fragColor = brd;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}