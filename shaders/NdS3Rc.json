{
    "Shader": {
        "info": {
            "date": "1619407446",
            "description": "A sierpinski pyramid and its inverse as distance functions",
            "flags": 0,
            "hasliked": 0,
            "id": "NdS3Rc",
            "likes": 2,
            "name": "sierpinski - Distance function",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "distance",
                "piramid"
            ],
            "usePreview": 0,
            "username": "nbardy",
            "viewed": 261
        },
        "renderpass": [
            {
                "code": "// Fork of \"Pyramid - distance\" by iq. https://shadertoy.com/view/Ws3SDl\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec3 fold(vec3 p) { \n    return vec3(abs(p.x),p.y, abs(p.z));\n}\n\nfloat sdPyramid(in vec3 p, float h) {\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    \n    float final = 100.0;\n    p = fold(p);\n\n        corner = vec3(base.x + h/2.0, base.y, base.z + h/2.0);\n        cornerx = vec3(base.x - h/2.0, base.y, base.z + h/2.0);\n        cornerz = vec3(base.x + h/2.0, base.y, base.z - h/2.0);\n        float d1 = sdTriangle(p.xy, top.xy, cornerx.xy, corner.xy);\n        float d2 = sdTriangle(p.zy, top.zy, cornerz.zy, corner.zy);\n        float d = max(d1, d2);\n        \n        return d;\n\n}\n float D = 4.0;\n \n// calc normal\n// signed distance to a pyramid of base 1x1 and height h\n\n// TO speed up:\n// replace sdtriangle with wave functions.\nvec4 sdSerp( in vec3 p, in float h )\n{\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    vec3 norm;\n    \n    float d1;\n    float d2;\n    \n    float final = 100.0;\n    vec3 prefold = p;\n    p = fold(p);\n    for(float i = 0.0;  i < D; i++) {\n        float h2 = h/2.0 + 0.;\n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        cornerx = vec3(base.x - h2, base.y, base.z + h2);\n        cornerz = vec3(base.x + h2, base.y, base.z - h2);\n        d1 = sdTriangle(p.xy, top.xy, cornerx.xy, corner.xy);\n        d2 = sdTriangle(p.zy, top.zy, cornerz.zy, corner.zy);\n        float d = max(d1, d2);\n        \n        if( d > epsilon) { \n            return vec4(d, vec3(0.0));\n        }\n        \n        float topd = length(p-top);\n        float cornerd = length(p-corner);\n        \n        final = min(final,d);\n            // calc normal\n        if(final < 0.0001) {\n             if(abs(p.y-base.y)- 0.00005 < 0.0001 ) {\n               norm = vec3(0.0,1.0,0.0);              \n              } else {\n              if(p.x > p.z) {\n                  norm = normalize(vec3(sign(prefold.x)*1.0,-1., 0.));          \n              } else {\n                  norm = normalize(vec3(0.0,-1.0,sign(prefold.z)*1.0));\n              }\n           }\n        }\n         \n        // TODO matmin instead of if\n        if( topd < cornerd) {\n           top = top;\n           h /= 2.0;\n           base = top + vec3(0.0,h,0.0);\n        } else {\n           h /= 2.0;\n           top = top + vec3(h/2.0, h, h/2.0);\n           base = top + vec3(0.0,h,0.0);\n           \n           p = fold(p - top) + top;\n        }\n        \n        \\\n        prefold = p;\n    }\n    \n    return vec4(final, norm);\n    \n\n}\n\n// sierpinski inverted\nvec4 sdSerpInv( in vec3 p, in float h )\n{\n    vec3 top = vec3(0.0);   \n    //base if above the point\n    vec3 base = top + vec3(0.0,h,0.0);\n    float epsilon = 0.0001;\n    vec3 corner ;\n    vec3 cornerx;\n    vec3 cornerz;\n    vec3 norm;\n    \n    float d1;\n    float d2;\n    \n    float final = 100.0;\n    vec3 prefold = p;\n    p = fold(p);\n    for(float i = 0.0;  i < D; i++) {\n        float h2 = h/2.0 + 0.;\n        float h4 = h2/2.0;\n        \n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        vec3 base2 = base - vec3(0.,h2,0.);\n        \n        vec3 midcorner = vec3(base2.x + h4, base2.y, base2.z + h4);\n        cornerx = vec3(base2.x - h4, base2.y, base2.z + h4);\n        cornerz = vec3(base2.x + h4, base2.y, base2.z - h4);\n        float d1 = sdTriangle(p.xy, base.xy, cornerx.xy, midcorner.xy);\n        float d2 = sdTriangle(p.zy, base.zy, cornerz.zy, midcorner.zy);\n        float d = max(d1, d2);\n        \n\n        \n        float topd = length(p-top);\n        float cornerd = length(p-corner);\n        \n        final = min(final,d);\n        \n        // calc normal\n           if( d < epsilon) { \n                if(abs(p.y-base2.y) -0.00005 < 0.0001 ) {\n                    norm = vec3(0.0,-1.0,0.0);              \n                } else {\n                // TODO(gold edition): round corners with banded equality and rounded normal\n                    if(p.x > p.z) {\n                        norm = normalize(vec3(sign(p.x),1., 0.));          \n                    } else {\n                        norm = normalize(vec3(0.0,1.0,sign(p.z)));\n                    }\n                }\n                           \n           return vec4(d,norm);\n        }\n\n           \n        \n        norm = vec3(1.);\n        corner = vec3(base.x + h2, base.y, base.z + h2);\n        // TODO matmin instead of if\n        if( topd < cornerd) {\n           top = top;\n           h /= 2.0;\n           base = top + vec3(0.0,h,0.0);\n        } else {\n           h /= 2.0;\n           top = top + vec3(h/2.0, h, h/2.0);\n           base = top + vec3(0.0,h,0.0);\n           prefold = p;\n           p = fold(p - top) + top;\n        }\n\n\n    }\n    norm = vec3(0.,0.,0.);\n    \n    return vec4(final, norm);\n}\n\n// does the less distance of two d+norm vecs)\nvec4 dmin(vec4 v1, vec4 v2) {\n    if(v2.x < v1.x) {\n        return v2;\n    } else {\n        return v1;\n    }\n}\n\nvec4 map( in vec3 pos ,vec3 ro)\n{\n    vec3 p = pos;\n    float h = 1.0;\n    vec4 r1 = sdSerp(pos + vec3(0.,-0.2,0.), h);\n    vec4 r2 = sdSerpInv(p + vec3(0., 0.8,0.), h);\n    \n    vec3 nor = r1.yzw;\n\n    // This is a hack to remove stray plane intersection rays.\n    if(nor.y == 1.0 && nor.x == 0. && nor.z == 0.) {\n                 if(ro.y < pos.y) {\n                      r1.z = -1.0;\n                 }\n            }\n    nor = r2.yzw;\n               if(nor.y == -1.0 && nor.x == 0. && nor.z == 0.) {\n                 if(ro.y > pos.y) {\n                      r2.z = 1.0;\n                 }\n            }\n    \n    //return dmin(dmin(r1, r2), vec4(length(pos - vec3(1.5,0.0,0.0)) - 0.2, 0., 0.,0.));\n    return dmin(r1,r2);\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3( 3.0*cos(an), 3.4*sin(iTime), 3.0*sin(an) );\n    //vec3 ro = vec3( 3.0*cos(an), 1.8*sin(0.2*iTime), 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n        vec4 result;\n\n        // raymarch\n        const float tmax = 60.0;\n        float t = 0.0;\n        for( int i=0; i<1024; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            result = map(pos, ro);\n            //unpack\n            float h = result.x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            \n            vec3 nor = result.yzw;\n            \n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}