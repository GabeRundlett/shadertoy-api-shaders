{
    "Shader": {
        "info": {
            "date": "1567012832",
            "description": "Storming Pixels. Inspired by Inigo Quilez live stream shader deconstruction",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl2SWG",
            "likes": 37,
            "name": "Storming Pixels",
            "published": 3,
            "tags": [
                "animation"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 986
        },
        "renderpass": [
            {
                "code": "// Storming Pixels\n// inspired by Inigo Quilez live stream shader deconstruction\n// Leon Denise (ponk) 2019.08.28\n// Licensed under hippie love conspiracy\n\n// Using code from\n// Inigo Quilez\n// Morgan McGuire\n\n// tweak zone\nconst float speed = 1.;\nconst float range = 1.;\nconst float radius = .35;\nconst float blend = .7;\nconst float balance = 1.9;\nconst float falloff = 1.8;\n\n// increment it at your own GPU risk\nconst float motion_frames = 1.;\n\n// tool box\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\nfloat geometry (vec3 pos, float time) {\n    float a = 1.0;\n    float scene = 1.;\n    float t = time + pos.x / 4.;\n    t = floor(t)+pow(fract(t),.5);\n    for (int i = 6; i > 0; --i) {\n        pos.xy *= rot(cos(t)*balance/a+a*2.);\n        pos.zy *= rot(sin(t)*balance/a+a*2.);\n        pos.xz = abs(pos.xz)-range*a;\n        scene = smoothmin(scene, length(pos)-radius*a, blend*a);\n        a /= falloff;\n    }\n    return scene;\n}\n\nfloat raymarch ( vec3 eye, vec3 ray, float time, out float total ) {\n    float dither = random(ray.xy+fract(iTime));\n    total = 0.0;\n    const int count = 30;\n    for (int index = count; index > 0; --index) {\n        float dist = geometry(eye+ray*total,time);\n        dist *= 0.9+0.1*dither;\n        total += dist;\n        if (dist < 0.001 * total)\n            return float(index)/float(count);\n    }\n    return 0.;\n}\n\nvec3 camera (vec3 eye) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if (iMouse.z > 0.5) {\n        eye.yz *= rot(mouse.y*3.1415);\n        eye.xz *= rot(mouse.x*3.1415);\n    } else {\n        eye = vec3(1,3.5,1.);\n    }\n    return eye;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = camera(vec3(0,0,3.5));\n    vec3 ray = look(eye, vec3(0), uv, 2.);\n    float total = 0.;\n    fragColor = vec4(0);\n    for (float index = motion_frames; index > 0.; --index) {\n        float dither = random(ray.xy+fract(iTime+index));\n        float time = iTime*speed+(dither+index)/10./motion_frames;\n        fragColor += vec4(raymarch(eye, ray, time,total))/motion_frames;\n    }\n    \n    // extra color\n    float gray = fragColor.r;\n    fragColor.rgb *= vec3(.8,.8,.9);\n    float d = smoothstep(0.0,2.,length(uv));\n    vec3 sky = mix(vec3(0.35,.37,.4), vec3(0.), d);\n    d = smoothstep(5.,0.,total);\n    fragColor.rgb += vec3(0.8,.7,.6) * d;\n    fragColor.rgb = mix(sky.rgb, fragColor.rgb, pow(fragColor.r,.3));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}