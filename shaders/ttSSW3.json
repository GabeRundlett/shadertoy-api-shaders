{
    "Shader": {
        "info": {
            "date": "1567775629",
            "description": " ",
            "flags": 0,
            "hasliked": 0,
            "id": "ttSSW3",
            "likes": 10,
            "name": "Magic Lamp",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "noise",
                "light",
                "volumetric",
                "tranlucent"
            ],
            "usePreview": 0,
            "username": "ikuto",
            "viewed": 554
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415927\n\nstruct Light\n{\n    vec3  pos;\n    vec3  col1, col2;\n    float rad1, rad2;\n    mat3  rotMat;\n};\n\nLight lights[4];\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRing(vec3 p, float r1, float r2)\n{\n    vec2 v = vec2(abs(length(p.xy)-r1), p.z);\n    return length(v)-r2;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float d = max(k-abs(a-b), 0.0);\n    return min(a,b) - d*d/k/4.0;\n}\n\nvec2 sincos(float t) { return vec2(sin(t), cos(t));}\n\nvec2 mapScene(vec3 p)\n{\n    float objID = 1.0;\n\n    //rings\n    float d = sdRing(p, 1.0, 0.03);\n    d = smin(d, sdRing(lights[2].rotMat*p, 1.0, 0.03), 0.02);\n    d = smin(d, sdRing(lights[3].rotMat*p, 1.0, 0.03), 0.02);\n    \n    vec3 p2 = p-vec3(0.0,-1.9,0.0);\n    float h = 1.0;\n    float x = (1.0-clamp((p2.y+h)/(2.0*h), 0.0, 1.0));\n    float r = 0.05*(15.0*pow(x,6.0)+1.0);\n\n    //body\n    float d2 = sdCappedCylinder(p2, h, r);\n    d2 = smin(d2, length(p2-vec3(0.0,1.0,0.0))-0.1, 0.05);\n    vec3 p3 = p2-vec3(0.0,0.0,0.0); p3.y *= 2.0;\n    d2 = smin(d2, length(p3)-0.18, 0.2);\n    p3= p2-vec3(0.0,-0.3,0.0); p3.y *= 2.0;\n    d2 = smin(d2, length(p3)-0.2, 0.2);\n    \n    d2 = smin(d2, sdCappedCylinder(p3-vec3(0.0,2.0,0.0), 0.06, 0.4), 0.2);\n    d2 = smin(d2, sdCappedCylinder(p3-vec3(0.0,1.75,0.0), 0.06, 0.6), 0.2);\n    d2 = smin(d2, sdCappedCylinder(p3-vec3(0.0,1.5,0.0), 0.1, 0.5), 0.2);\n    if (d2 < d) objID = 2.0;\n    d = min(d, d2);\n    \n    return vec2(d, objID);\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    vec3 dt = vec3(0.01, 0.0, 0.0);\n    return normalize( vec3(\tmapScene(p+dt.xyy).x-mapScene(p-dt.xyy).x,\n                         \tmapScene(p+dt.yxy).x-mapScene(p-dt.yxy).x,\n                          \tmapScene(p+dt.yyx).x-mapScene(p-dt.yyx).x ) );\n}\n\nfloat calculateAO(vec3 pos, vec3 normal)  //ambient occlusion\n{\n    float ao = 0.0, sca = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n   \t\tfloat h = 0.01 + 0.11*float(i)/4.0;\n        vec3 p = pos + h * normal;\n        float d = mapScene(p).x;\n        ao += (h-d)*sca;\n        sca *= 0.95;\n    }\n    \n    return pow(clamp(1.0-2.0*ao, 0.0, 1.0), 2.0);\n}\n\nvec3 noise(vec3 pos, vec3 nor)\n{\n\tvec3 x = texture(iChannel0, pos.yz).xyz;\n\tvec3 y = texture(iChannel0, pos.zx).xyz;\n\tvec3 z = texture(iChannel0, pos.xy).xyz;\n\treturn x*abs(nor.x) + y*abs(nor.y) + z*abs(nor.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 background(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 noise = hash31(float(i)*215.4);\n        vec3 lv = (10.0*noise-5.0) - ro;\n        float ll = length(lv);\n        float angle = acos(clamp(dot(rd, lv/ll), 0.0, 1.0));\n        float t = (1.0-smoothstep(0.0, 1.5 + 1.0*noise.x, angle*ll));\n        color += 0.05 * (0.6*noise+vec3(0.1)) *pow(t, 4.0); \t\n    }\n    return color;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //init lights\n    float st = 0.8 + 0.1*sin(5.0*iTime);\n    lights[0] = Light(vec3(0.0), 0.5*vec3(0.5,1.0,1.0), 8.0*vec3(0.5,1.0,1.0), 4.0*st, 0.8*st, mat3(0.0));\n    lights[1] = Light(vec3(0.0), 0.5*vec3(1.0,0.0,0.0), 2.0*vec3(1.0), \t\t   0.8*st, 0.4, mat3(0.0));\n    lights[2] = Light(vec3(0.0), 0.5*vec3(0.0,1.0,0.0), 2.0*vec3(1.0), \t\t   0.8*st, 0.4, mat3(0.0));\n    lights[3] = Light(vec3(0.0), 0.5*vec3(0.0,0.0,1.0), 2.0*vec3(1.0), \t\t   0.8*st, 0.4, mat3(0.0));\n    \n    //update lights\n    float t = iTime-0.5;\n\tlights[1].pos = vec3(sincos(t), 0.0);\t    \t\n    lights[2].rotMat = rotate(vec3(1.0,0.2,0.0), PI/3.0);\n    lights[2].pos = vec3(sincos(t-PI/1.5), 0.0) * lights[2].rotMat;\n    lights[3].rotMat = rotate(vec3(1.0,-0.2,0.0), -PI/3.0);\n    lights[3].pos = vec3(sincos(-t-PI/0.75), 0.0) * lights[3].rotMat;\n    \n  \tvec3 color = background(ro, rd);\n    //ray marching\n    float tmin = 0.1, tmax = 8.0;\n    vec2 res;\n    for (float t = tmin; t < tmax;)\n    {\n        vec3 pos = ro + t * rd;\n        res = mapScene(pos);\n        float dist = res.x;\n        \n        if (dist < 0.05)\n        {\n            vec3 nor = calculateNormal(pos);\n            float ao = calculateAO(pos, nor);\n            \n            vec3 albedo = vec3(0.0);\n            if (res.y < 1.5)\n            {\n            \talbedo = vec3(5.0);\n            }\n            else if (res.y < 2.5)\n            {\n                albedo = vec3(1.0);\n                float w = 0.5 + 0.5*sin(iTime);\n            \tnor = normalize(nor + 0.5*w*(noise(w*pos, nor)-0.5)); //alter normal\n            }\n                \n            if (dist < 0.02)\n            {\n            \tfor (int i = 0; i < 4; ++i) //apply lights\n            \t{\n                \tvec3  l = lights[i].pos - pos;\n                    float d = length(l);\n                    float attenuation = 1.0 / (0.2*d*d+0.5*d+1.0);\n                    float diffuse = max(0.0,dot(normalize(l),nor));\n                    float sepcular = pow(max(dot(normalize(reflect(l,nor)),rd),0.0), 16.0);\n\n                    vec3 col = 0.01*albedo * lights[i].col2 * diffuse;\n                    col += 4.0*sepcular*lights[i].col1;\n                    col *= attenuation * pow(ao,4.0);\n                    color += 0.07 * col;\n                }\n            }\n\n            color += 0.002*vec3(0.0,1.0,0.9)*pow(1.0-smoothstep(0.0, 0.1, dist), 1.0);\n        }\n        \n        t += max(0.005, (dist-0.1)*0.5);\n    }\n    \n    for (int i = 0; i < 4; ++i) //draw lights\n    {\n        vec3 lv = lights[i].pos - ro;\n        float ll = length(lv);\n        float angle = acos(clamp(dot(rd, lv/ll), 0.0, 1.0));\n        float t = (1.0-smoothstep(0.0, lights[i].rad1, angle*ll));\n        color += lights[i].col1*pow(t, 4.0);\n        t = (1.0-smoothstep(0.0, lights[i].rad2, angle*ll));\n        color += lights[i].col2*pow(t, 4.0);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2  uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float an = PI/2.0 + 0.4*iTime;\n    \n    vec3  rayOri = 4.0 * vec3(sin(an), 0.1, cos(an));\n    mat3  viewMat = lookAt(rayOri, vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0));\n    vec3  rayDir = viewMat * normalize(vec3(uv, -1.5));\t//rotate camera\n    \n    vec3 color = render(rayOri, rayDir);\n    \n    //gamma correction\n    color = pow(color, vec3(0.4545)); \n    \n    //contrast\n\tcolor = clamp(color, 0.0, 1.0);\n\tcolor = color * color * (3.0 - 2.0 * color);\n\n\t//saturation\n\tfloat sat = 0.2;\n\tcolor = color * (1.0 + sat) - sat * dot(color, vec3(0.33));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}