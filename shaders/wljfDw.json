{
    "Shader": {
        "info": {
            "date": "1599146410",
            "description": "A geometric pencil sketch pattern rendered onto some animated hanging paper.",
            "flags": 0,
            "hasliked": 0,
            "id": "wljfDw",
            "likes": 73,
            "name": "Geometric Paper Pattern",
            "published": 3,
            "tags": [
                "wall",
                "truchet",
                "sketch",
                "pencil",
                "paper",
                "art"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1178
        },
        "renderpass": [
            {
                "code": "/*\n\n\tGeometric Paper Pattern\n    -----------------------\n\n    A geometric pattern rendered onto some animated hanging paper, which for some \n    inexplicable and physics defying reason is also animated. :D\n\n\tI put this together out of sheer boredom, and I didn't spend a lot of time on \n    it, so I wouldn't look too much into the inner workings, especially not the \n\tphysics aspects... I honestly couldn't tell you why the paper is waving around \n\tlike that. :)\n\n\tThe pattern is about as basic as it gets. I've used some equally basic post\n    processing to give it a slightly hand drawn look. The pencil algorithm I've\n\tused is just a few lines, and is based on one of Flockaroo's more sophisticated\n\texamples. The link is below, for anyone interested. At some stage, I'd like\n    to put a sketch algorithm out that is more hatch-like.\n\n    On a side note, for anyone who likes small functions, feel free to take a look \n    at the \"n2D\" value noise function. I wrote it ages ago (also when I was bored) \n    and have taken it as far as I can take it. However, I've often wondered whether \n    some clever soul out there could write a more compact one.\n\n\n\n\n\tRelated examples:\n\n    // A more sophisticated pencil sketch algorithm.\n    When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n\n*/\n\n// For those who find the default pattern just a little too abstract and minimal,\n// here's another slighly less abstract minimal pattern. :D\n//#define LINE_TRUCHET\n\n// I felt the pattern wasn't artistic enough, so I added some tiny holes. :)\n#define HOLES\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n// IQ's box formula -- modified for smoothing.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n    \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\nfloat distField(vec2 p){\n    \n    // Cell ID and local cell coordinates.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    // Some random numbers.\n    float rnd = hash21(ip + .37);\n    float rnd2 = hash21(ip + .23);\n    float rnd3 = hash21(ip + .72);\n \n    \n    // Cell boundary.\n    float bound = sBox(p, vec2(.5)); \n    \n    \n    float d = 1e5; // Distance field.\n    \n    // Random 90 degree cell rotation.\n    p *= rot2(floor(rnd*64.)*3.14159/2.);\n    \n     \n    // Just adding a tiny hole to draw the eye to the... No idea why artists do \n    // this kind of thing, but it enables them to double the price, so it's\n    // definitely worth the two second effort. :)\n    float hole = 1e5;\n    \n    \n    #ifdef LINE_TRUCHET\n    \n    // Three tiled Truchet pattern consisting of arc, straight line \n    // and dotted tiles.\n    \n    // Four corner circles.\n    vec2 q = abs(p);\n    float cir = min(length(q - vec2(0, .5)), length(q - vec2(.5, 0)));\n    \n    if(rnd3<.75){\n        if(rnd2<.65){\n            d = abs(min(length(p - .5), length(p + .5)) -.5) - .5/3.;\n            \n        }\n        else {\n            p = abs(p) - .5/3.;\n            d = min(max(p.x, -(p.y - .5/8.)), p.y);\n        }\n        \n    }\n    else {\n        // Four dots in the empty squares to complete the pattern.\n        d = cir - .5/3.;\n    }\n    \n    // Corner holes.\n    hole = cir -.05;\n    \n    #else\n    // Very common quarter arc and triangle Truchet pattern, which is a \n    // favorite amongst the abstract art crowd.\n    if(rnd3<.75){;\n        \n        // Corner holes.\n        hole = length(p - .325) - .05;\n                 \n        if(rnd2<.5){\n            // Corner quarter circle... Well, it's a full one,\n            // but it gets cut off at the grid boundaries.\n            d = length(p - .5) - 1.;\n        }\n        else {\n            // A corner diamond, but we'll only see the triangular part.\n            p = abs(p - .5);\n            d = abs(p.x + p.y)/sqrt(2.) - .7071;\n        }\n    }\n    #endif\n    \n    #ifdef HOLES\n    d = max(d, -hole);\n    #endif\n    \n    // Cap to the cell boundaries. Sometimes, you have to do this\n    // to stop rendering out of bounds, or if you wish to include\n    // boundary lines in the rendering.\n    //\n    return max(d, bound);\n}\n\n// Cell grid borders.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    p = abs(p);\n    float grid = abs(max(p.x, p.y) - .5) - .005;\n    \n    return grid;\n}\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.64 + n2D(q*2.*sc)*.34);\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = min(min(ns, ns2), ns3) + .5; // Rough pencil sketch layer.\n    //ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .5); // Same, but with contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(ns);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scaling factor.\n    float gSc = 8.;\n    \n    // Smoothing factor.\n    float sf = 1./iResolution.y*gSc;\n    \n    // Unperturbed coordinates.\n    vec2 pBg = uv*gSc; \n    \n    vec2 offs = vec2(fbm(uv/1. + iTime/4.), fbm(uv/1. + iTime/4. + .35));\n    const float oFct = .04;\n    uv -= (offs - .5)*oFct;\n    \n    // Scaled perturbed coordinates.. \n    vec2 p = uv*gSc;\n    \n    \n    // The paper distance field.\n    vec2 fw = vec2(6, 3);\n    float bw = 1./3.;\n    float paper = sBoxS(p, fw + bw, .05);\n  \n    // Mixing the static background coordinates with the wavy offset ones to\n    // save calculating two functions for various things.\n    vec2 pMix = mix(p, pBg, smoothstep(0., sf, paper));\n\n    // Failed experiment with a moving pattern.\n    //vec2 rnd22 = vec2(hash21(ip + 1.6), hash21(ip + 2.6));\n    //rnd22 = smoothstep(.9, .97, sin(6.2831*rnd22 + iTime/2.));\n    //float d = distField(p + rnd22);\n    \n    // The geometric pattern field.\n    float d = distField(pMix);\n    \n    // Canvas pattern square ID.\n    vec2 ip = floor(p) + .5;\n    \n    // Background. Nothing exciting, but theres' a subtle vertical gradient\n    // to mimic an overhead light, or something to that effect.\n    vec3 bg = vec3(.9, .82, .74)*.85;\n    bg = mix(bg, bg*.9, -uv.y*.5 + .5);\n    \n    // Initialize the scene color to the background.\n    vec3 col = bg;\n    \n   \n    // Using the pattern distance field for a subtle background wall overlay.\n    // Back in the old days (the 90s), you'd reuse whatever you could.\n    col = mix(col, bg*.92, 1. - smoothstep(0., sf, d));\n    col = mix(col, bg*.96, 1. - smoothstep(0., sf, d + .03)); \n    \n  \n    // The paper shadow distance field and application.\n    vec2 shOff = normalize(vec2(1, -3))*.1;\n    float dSh = sBoxS(p - shOff, fw + bw, .05);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., dSh))*.5);\n    \n    // Paper rendering.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, paper))*.1); \n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, paper + .02))); \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, paper + bw))); \n    \n    \n    /*\n    // Distance field-based lines on the canvas. I tried a few quick things\n    // for this example, and unfortunately, not a lot worked, but I've left\n    // the workings in for anyone who wants to play around with this.\n    const float lnN = 8.; // Number of concentric pattern lines.\n    float pat = abs(fract(d*lnN*1. - .5) - .5)*2. - .05;\n    pat = smoothstep(0., sf*lnN*2., pat)*.65 + .35;\n    */\n    \n    \n    // Random animated background color for each square.\n    float rndC = hash21(ip + .23);\n    rndC = sin(6.2831*rndC + iTime/2.);   \n    vec3 sqCol = .55 + .45*cos(6.2831*rndC + vec3(0, 1, 2)); // IQ's palette.\n    col = mix(col, sqCol, (1. - smoothstep(0., sf, paper + bw + .0))); \n\n\n    // Render a colored Truchet pattern in one of two styles.\n    \n    // Restrict pattern rendering to the canvas.\n    d = max(d, (paper + bw));\n    \n \n    // IQ's really cool, and simple, palette.\n    vec3 shCol = .55 + .45*cos(6.2831*rndC + vec3(0, 1, 2) + 1.);\n\n    // Subtle drop shadow, edge and coloring.\n    col = mix(col, bg*.03, (1. - smoothstep(0., sf*4., d))*.5);\n    col = mix(col, bg*.03, (1. - smoothstep(0., sf, d)));\n    col = mix(col, shCol, (1. - smoothstep(0., sf, d + .02)));\n\n    \n    // Adding in some blinking offset color, just to mix things up a little.\n    rndC = hash21(ip + .87);\n    rndC = smoothstep(.8, .9, sin(6.2831*rndC + iTime*2.)*.5 + .5);\n    vec3 colB = mix(col, col.xzy, rndC/2.);\n    col = mix(col, colB, 1. - smoothstep(0., sf, paper + bw));\n    \n    \n        \n    // Putting some subtle layerd noise onto the wall and paper.\n    col *= fbm(pMix*48.)*.2 + .9;\n    \n    \n \n    // Grid lines on the canvas.\n    float grid = gridField(p);\n    grid = max(grid, paper + bw);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., grid))*.5);\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n\n    /*\n    // Circles on the pattern... Too busy looking.\n    vec3 svC = col/2.;\n    float cir = length(p - ip) - .1;\n    cir = max(cir, bord + bw);\n    col = mix(col, bg*.07, (1. - smoothstep(0., sf, cir)));\n    //col = mix(col, svC, (1. - smoothstep(0., sf, cir + .02)));\n    */  \n   \n \n    \n    // Recalculating UV with no offset to use with postprocessing effects. \n    uv = (fragCoord - iResolution.xy*.5)/iResolution.y; \n\n    float canv = smoothstep(0., sf*2., (paper + bw));\n    float canvBord = smoothstep(0., sf*2., (paper));\n\n    /*\n    // Corduroy lines... Interesting texture, but I'm leaving it out.\n    vec2 q3 = mix(uv, p/gSc, 1. - (canvBord));\n    float lnPat = abs(fract((q3.x - q3.y)*80.) - .5)*2. - .01;\n    float frM = smoothstep(0., sf, max(paper, -(paper + bw)));\n    lnPat = smoothstep(0., sf*80./2., lnPat);\n    col = mix(col, col*(lnPat*.25 + .75), frM);\n    */\n    \n    \n    // Boring, and admittedly, inefficient hanger and string calculations, etc.\n    // A lot of it is made up on the spot. However, at the end of the day, this\n    // is a pretty cheap example, so it'll do.\n    vec2 q2 = uv;\n    q2.x = mod(q2.x, 1.) - .5;\n    q2 -= (offs - .5)*oFct + vec2(0, (3. + bw*.9)/gSc);\n    // String, and string shadow. \n    float strg = lBox(q2, vec2(0), vec2(0, .5) - (offs - .5)*oFct, .002);\n    float strgSh = lBox(q2 - shOff*.5,  vec2(0, .04), vec2(0, .5) - (offs - .5)*oFct, .002);\n    // Rendering the strings and shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, strgSh))*.25);\n    col = mix(col, vec3(.5, .4, .3), (1. - smoothstep(0., sf/gSc/2., strg)));\n    // The little black hangers and corresponding shadow.\n    float hang = sBoxS(q2, vec2(1, .5)*bw/gSc, .0);\n    float hangBk = sBoxS(q2, vec2(1. + .05, .5)*bw/gSc, .0);\n    float hangBkSh = sBoxS(q2 - vec2(.008, -.004), vec2(1. + .06, .5)*bw/gSc, .0);\n    hangBk = max(hangBk, -paper);\n    hangBkSh = max(hangBkSh, -paper);\n    float hangSh = sBoxS(q2 - shOff*.1, vec2(1, .5)*bw/gSc, .0);\n    // Rendering the hangers and shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc*2., hangBkSh))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc*2., hangSh))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, hangBk)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/gSc, hang)));\n    col = mix(col, bg*oFct, 1. - smoothstep(0., sf/gSc, hang + .004));\n    \n    \n   \n\n    // Adding very subtle lighting to the wavy pattern... So subtle that it's\n    // barely worth the effort, but it's done now. :)\n    float eps = .01;\n    vec2 offs2 = vec2(fbm(uv/1. + iTime/4. - eps), fbm(uv/1. + iTime/4. + .35 - eps));\n    float z = max(dot(vec3(0, 1, -.5), vec3(offs2 - offs, eps)), 0.)/eps;\n    col *= mix(1., .9 + z*.1, 1. - canvBord);\n   \n\n     \n    // Subtle pencel overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = mix(uv*gSc*2., p, 1. - (canvBord));\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    //col *= colP*.8 + .5; \n    col *= mix(vec3(1), colP*.8 + .5, .8);\n    //col = colP; \n    \n    \n    // Cheap paper grain... Also barely worth the effort. :)\n    vec2 oP = floor(p/gSc*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    vec3 pg = .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    col *= mix(vec3(1), pg, 1. - canv);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}