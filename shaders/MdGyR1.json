{
    "Shader": {
        "info": {
            "date": "1521125687",
            "description": "homogenous volume; throbbing light; rainbow tint",
            "flags": 0,
            "hasliked": 0,
            "id": "MdGyR1",
            "likes": 2,
            "name": "bitcrushed_james_turrell",
            "published": 3,
            "tags": [
                "colorfieldaliasing"
            ],
            "usePreview": 0,
            "username": "xxyxxy",
            "viewed": 429
        },
        "renderpass": [
            {
                "code": "#define SPHERE_RADIUS 0.9\n#define SPHERE_DENSITY 4.0\n#define EXTINCTION_COEFFICIENT 2.0\n\n#define RAYMARCH_LENGTH (2.0 * SPHERE_RADIUS)\n#define NUM_STEPS 12\n#define STEP_SIZE (RAYMARCH_LENGTH/float(NUM_STEPS))\n\n#define LIGHT_POS (vec3(0.0, 0.0, 0.0))\n\nfloat LIGHT_INTENSITY;\n\n\nfloat schlick_phase(float theta, float k) {\n\treturn (1.0 - k * k) / (4.0 * 3.14 * pow(1.0 + k * cos(theta), 2.0));\n}\n\nfloat old_sphere(vec3 P) {\n    float density = SPHERE_DENSITY;\n    float transmittance = exp(-density * EXTINCTION_COEFFICIENT * STEP_SIZE);\n    \n\treturn length(P) < SPHERE_RADIUS ? transmittance : 1.0;\n}\n\nfloat sphere(vec3 P) {\n    float t = iTime;\n\tfloat rho = sqrt(P.x * P.x + P.z * P.z);\n    float theta= atan(P.z, P.x);\n    float z = P.y;\n    \n    P = vec3(rho, theta, z);\n    \n    return 1.0 - sin(-cos(rho + t) + z) * theta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{               \n    // set up coordinate system\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // set up color, truly this represents extinction; start at one means transparent\n    float color = 1.0;\n    \n    // shoot primary ray through sphere, accumulating extinction as we go\n    float z = -RAYMARCH_LENGTH/2.0;\n    for (int i = 0; i < NUM_STEPS/2; ++i) {\n        \n   \t\tvec3 P = vec3(uv.x, uv.y, z);\n        color *= sphere(P);\n\n        // shoot secondary ray towards light, accumulating extinction as we go\n        if (color < 1.0) {\n            float second_ray_color = 1.0;\n            for (int j = 0; j < NUM_STEPS; ++j) {\n                P += STEP_SIZE * LIGHT_POS;\n                second_ray_color *= sphere(P);\n            }\n            \n            \t\n\t\t\t// pulse light, this drives entire rig\n\t\t\tLIGHT_INTENSITY = 8.0 * (0.5 + 0.5*sin(0.05*iTime));\n            \n            // pointlight falloff via inverse distance square relation\n            color += second_ray_color * LIGHT_INTENSITY * 1.0/(distance(P, LIGHT_POS) * distance(P, LIGHT_POS));\n        }  \n\n        color *= schlick_phase(0.0, sin(0.1 * iTime)); \n        \n\t\tz += STEP_SIZE;\n    }\n    \n    \n\n    // write to frame buffer (alpha blending is off)\n    fragColor = vec4(color, color, color, 0.0);\n    \n    // im in luuuuuv with the rothko -o.t. genasis \n    float r = 0.5 + 0.5*sin(0.1*iTime);\n    float g = 0.5 + 0.5*cos(0.3*iTime);\n    float b = 0.5 + 0.5*sin(0.5*iTime);\n\n    fragColor.rgb *= vec3(r,g,b);  \t\n    \n    fragColor.rgb *= LIGHT_INTENSITY;\n    \n    // gamma correct\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}