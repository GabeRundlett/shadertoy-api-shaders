{
    "Shader": {
        "info": {
            "date": "1686432034",
            "description": "Use the mouse to look around :)",
            "flags": 0,
            "hasliked": 0,
            "id": "mtVXD3",
            "likes": 9,
            "name": "Another water shader",
            "published": 3,
            "tags": [
                "sea",
                "water",
                "ocean",
                "sky",
                "foam",
                "sand"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime*1.5)\n#define ZERO min(iFrame, 0)\n#define NEAR 0.0005\n#define FAR 800.0\n#define STEPS 60\n\n#define ID_GROUND 0\n#define ID_WATER 1\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n    bool hit;\n    bool water;\n    bool is_refract;\n};\n\nstruct Material {\n  float rough;\n  float metallic;\n  float spec;\n  float z;\n  vec3 bump;\n};\n\n#define NEW_MATERIAL Material(1.0, 0.0, 1.0, 0.0, vec3(0.0))\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1, false, false, false)\n\n//#define DEBUG_TEXTURE sandTexture\nvec3 sandTexture(in vec2 uv, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 lf1 = noise(uv, 0.028128, 4.5, 4);\n    vec3 lf2 = noise(uv, 5.555321, 9.5, 4);\n    vec3 hf1 = noise(uv, 9.281823, 128.5, 7);\n    vec3 grain = abs(normalize(cross(lf2*2.0-1.0, hf1*2.0-1.0)));\n    \n    \n    vec3 c1 = vec3(0.722, 0.596, 0.400);\n    vec3 c2 = vec3(0.616, 0.471, 0.302);\n    vec3 c3 = vec3(0.737, 0.592, 0.400);\n    vec3 c4 = vec3(0.773, 0.631, 0.427);\n    \n    vec3 c5 = (c2+vec3(0.537, 0.098, 0.039))*0.5;\n    vec3 c6 = vec3(0.188, 0.063, 0.027);\n    vec3 c7 = vec3(0.812, 0.722, 0.612);\n    vec3 c8 = vec3(0.149, 0.110, 0.082);\n    \n    float g1 = lf1.x*grain.x;\n    float g2 = lf2.x*grain.y;\n    \n    vec3 a1 = mix(c1, c2, lf1.x);\n    vec3 b1 = mix(c3, c4, lf1.y);\n    vec3 ab1 = mix(a1, b1, g1);\n    \n    vec3 a2 = mix(c5, c6, lf1.x);\n    vec3 b2 = mix(c7, c8, lf1.y);\n    vec3 ab2 = mix(a2, b2, g2);\n    \n    col += ab1;\n    \n    float spots = 0.5*grain.z * smoothstep(0.4, 0.7, lf1.x);\n    col = mix(col, ab2, spots);\n    \n    m.z = 0.5 - (spots*0.5);\n    m.bump = makeNormal(m.z, 0.5);\n    m.spec = clamp((spots+spots*spots)+(lf1.y*lf1.y*lf1.y*0.25), 0.01, 1.0);\n    \n    return col;\n}\n\nfloat waterHeight(in vec3 p) {\n    \n    float h = -2.0;\n    float t = T*0.25;\n    vec2 shift = vec2(sin(t), cos(t));\n    \n   // p.xz += shift*0.015;\n    \n    float r1 = unoise(p.xz+shift+vec2(cos(t*4.), sin(t*4.)), 0.298212, 0.25, 4);\n    float r2 = unoise(p.zx-(shift*6.), 24.48381, 0.011, 4);\n    shift *= (1.0 + (r2*0.1));\n    vec3 hm = noise(p.xz+(shift*0.25), 193.382812, 0.01, 2);\n    t *= mix(1.0, 1.2, smoothstep(0.4, 0.9, hm.y));\n    vec3 detail = noise(p.xz+shift+0.8*vec2(sin((t*2.) + 3.5*r2), cos((t*.2) + 3.5*r1)), 77.595892, 0.6, 6);\n    \n    float waveFreq = 0.89*mix(0.45, 0.25, 0.33*(0.5+(0.5*(sin(t-r1)))));\n    \n    float z = mix(p.z, p.x, 0.87*smoothstep(0.4, 0.9, r2*(0.5+(0.5*cos((t-r1)+3.3938321)))));\n    \n    h += exp(cos(z*waveFreq+t)-1.);\n    \n    \n    float hh = smoothstep(0.4, 0.7, hm.x);\n    \n    h *= hh;\n    \n    h += detail.x * smoothstep(0.6, 0.0, p.y-h);\n    \n    h -= (r1+r2)*0.5;\n    \n    return h;\n}\n\nfloat waterSDF(in vec3 p) {\n    if (p.y < -10. || p.y > 300.) return p.y;\n    float h = waterHeight(p);\n    return p.y - h;\n}\n\nfloat groundHeight(in vec3 p) {\n    if (p.y > 20. || p.y < -90.) return p.y;\n    float h = 0.0;\n    float n1 = unoise(p.xz, 0.039821, 0.4, 3);\n    float n2 = unoise(p.xz, 2.292813, 0.05, 3);\n    h += n1;\n    h -= smoothstep(0.25, 0.6, n2)*6.;\n    return h;\n}\n\nfloat groundSDF(in vec3 p) {\n    float h = groundHeight(p);\n    return p.y - h;\n}\n\nfloat sdf(in vec3 p, inout Data data) {\n    \n    float dist = FAR*2.;\n    \n    if (data.water) {\n        data.id = ID_WATER;\n        float water = waterSDF(p);\n        dist = min(dist, water);\n    } else {\n        data.id = ID_GROUND;\n        float ground = groundSDF(p);\n        dist = min(dist, ground);\n    }\n    \n    return dist;\n}\n\nbool march(in vec3 ro, in vec3 rd, inout Data data) {\n    float d = 0.0;\n    float next = 0.0;\n    vec3 p = vec3(0.0);\n\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        p = ro + rd * d;\n        next = sdf(p, data);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (abs(d) * 3.)))) break;\n        if ((d) >= FAR) return false;\n    }\n    \n    vec2 e = vec2(0.0009, 0.0);\n    data.n = normalize(next - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    data.d = abs(d);\n    data.p = p;\n    data.hit = true;\n    \n    return true;\n}\n\nvec3 getSky(in vec3 rd, in vec3 L, vec3 lcol) {\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 col = vec3(0.071, 0.471, 0.753);\n    col = pow(col, vec3(1.0 + (dotup*2.0)));\n    \n    \n    float sun = max(0.0, dot(rd, L));\n    col += pow(sun, 8.0) * lcol;\n    \n    return col;\n}\n#define L normalize(vec3(1, 2, 3.0))\n#define lcol vec3(0.8, 0.7, 0.66)\nvec3 ray(in vec3 ro, in vec3 rd, inout Data data) {\n    if (!march(ro, rd, data) || data.id < 0) return getSky(rd, L, lcol);\n    \n    vec3 albedo = vec3(0.77);\n    \n    Material m = NEW_MATERIAL;\n    \n    switch (data.id) {\n        case ID_GROUND: albedo = sandTexture(data.p.xz, m); break;\n        case ID_WATER: albedo = vec3(0.4, 0.5, 0.6); break;\n        default: albedo = vec3(0.77); break;\n    }\n    \n    vec3 diffuse = albedo / M_PI;\n    \n    vec3 N = normalize(data.n + 0.25*m.bump);\n    vec3 ref = reflect(L, N);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 64.0) * m.spec;\n    float ls = 4.0;\n    float NdotL = max(0.0, dot(N, L));\n    vec3 att = NdotL * lcol * ls;\n    \n    vec3 col = vec3(0.0);\n    \n    col += (diffuse + spec) * att;\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dist = FAR;\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    Data dataGround1 = NEW_DATA;\n    Data dataGround2 = NEW_DATA;\n    Data dataWater = NEW_DATA;\n    Data dataWaterReflect = NEW_DATA;\n    dataWater.water = true;\n    \n    vec3 groundColor = ray(ro, rd, dataGround1);\n    vec3 waterColor = ray(ro, rd, dataWater);\n    \n    if (!dataGround1.hit || !dataWater.hit) {\n        col = getSky(rd, L, lcol);\n        dist = FAR;\n    } else {\n        if (dataWater.d < dataGround1.d && dataWater.hit) {\n            col = waterColor;\n            vec3 ro2 = dataWater.p;//-(dataWater.n*0.9);\n            vec3 rd2 = refract(rd, dataWater.n, 1.0/1.33);\n            dataGround2.is_refract = true;\n            vec3 refractColor = ray(ro2, rd2, dataGround2);\n            col = (col/2.0)+refractColor;\n            dist = dataWater.d;\n            \n            vec3 ro3 = dataWater.p;\n            vec3 rd3 = reflect(rd, dataWater.n);\n            vec3 reflectColor = ray(ro3, rd3, dataWaterReflect);\n            reflectColor += getSky(rd3, L, lcol)*0.25;\n            float NdotV = dot(dataWater.n, -rd);\n            vec3 F0 = mix(vec3(0.04), waterColor, 0.5);\n            vec3 F = fresnelSchlickRoughness(NdotV, F0, 0.002);\n            \n            \n            float wd = distance(dataWater.p, dataGround1.p);\n            \n            col += reflectColor * F;\n            \n            col = mix(col, col*col, smoothstep(0.0, 1.0, wd));\n            \n            col.r /= (1.0 + wd*0.02);\n            col.g /= (1.0 + wd*0.008);\n            \n            \n            float nn = noise((dataWater.p.xz+(0.25*vec2(sin(T-dataWater.p.x), cos(T+dataWater.p.z))))*16., 0.32123).x;\n            \n            col += 0.27*smoothstep(0.5, 0.0, wd)*(0.06+(nn*nn*nn));\n           \n        } else {\n            dist = dataGround1.d;\n            col = groundColor;\n        }\n    }\n    \n    \n    \n    float depth = dist / FAR;\n    col += smoothstep(0.02, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.3, dotup));\n    \n    return col;\n}\n\n\n\nvec3 getNextPos(in vec3 old_pos, in float t) {\n    vec2 p = vec2(sin(t-0.25*cos(t+0.928183)), cos(t+0.25*sin(t-0.333271))) - (old_pos.xz*0.321233);\n    p.x -= t*0.07;\n    p.y += t*0.07;\n    p *= rot(sin(t+3.39281));\n    \n    p += vec2(sin(p.x), cos(-p.x)) / M_PI;\n    p += vec2(cos(p.y), sin(-p.y)) / M_PI;\n    \n    p += 0.000298813;\n    \n    \n    \n    return vec3(p.x, 0.0, p.y) * 40.;\n}\n\n\nfloat atan2(in float y, in float x) { return abs(x) <= 0.000001 ? sign(y)*M_PI/2. : atan(y, x); }\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc - 0.5 * R.xy)/R.y;\n    \n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    vec3 ro = vec3(0.0, 0.2, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    float t = T*0.08;\n    \n    bool control = false;\n    if (m.z > 0.001) {\n      rd.yz *= rot(m.y * TAU);\n      rd.xz *= rot(m.x * TAU);\n      control = true;\n    }\n    \n    float a = 0.0;\n    vec3 cur = getNextPos(ro, t);\n    vec3 next = getNextPos(ro, t+0.2182881);\n    vec2 dir1 = next.xz-cur.xz;\n    vec2 dir = normalize(dir1);\n\n    a = atan(dir.x, dir.y);\n      \n    float ss = smoothstep(2.5, 6.5, iTime);\n    a = mix(0.0, a, ss);\n      \n    ro.xz = mix(ro.xz, cur.xz, ss);\n    if (!control) {\n        rd.xz *= rot(a);\n    }\n      \n      ro.y += 4.0*(0.5+(0.5*sin(t*4.)));\n    //ro.z += T;\n    ro.y += 3.;\n    \n    #ifdef DEBUG_TEXTURE\n    Material m = NEW_MATERIAL;\n    col = DEBUG_TEXTURE(fc.xy/R.xy, m);\n    #else\n    col = render(ro, rd);\n    #endif\n    \n    col += (luma(col) * col) * 0.5;\n    col = mix(col, col*col, 0.45);\n    col /= (1.0 + (0.5*max(col-1.0, 0.0)));\n    col = aces(col);\n    \n    col = pow(col, vec3(1.0/2.2));\n    O = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifndef HW_PERFORMANCE\n#define iFrame 0\nuniform sampler2D iChannel3;\n#endif\n#define M_PI 3.14159\n#define TAU (M_PI*2.0)\n\n#define ZERO min(iFrame, 0)\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\n#define NOISE(p, s) textureLod(iChannel3, (p + 43.29183*s)/256.0, 0.0).rgb\n\nvec3 noise(in vec2 p, in float seed) {\n    p += 11.8182;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(NOISE(id, seed), NOISE(id+vec2(1, 0), seed), lv.x),\n        mix(NOISE(id+vec2(0, 1), seed), NOISE(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = ZERO; i < oct; i++) {\n        n += amp * noise(p*freq, seed);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat hash21(in vec2 ip, in float seed) {\n    uvec2 p = floatBitsToUint(ip);\n    uint s = floatBitsToUint(seed);\n    uint w = ~s;\n    uvec2 i = ~p;\n    p ^= p << 17U;\n    p += p * (w << p.y) * i;\n    p ^= p >> 13U;\n    p ^= p << 5U;\n    p += (p * i + (w << p.x)) >> 3U;\n    uint n = (p.x ^ p.y) + (p.x * w + p.y) * (p.x + p.y);\n    return float(n*1013U) / float(0xFFFFFFFFU);\n}\n\nfloat unoise(in vec2 p, in float seed) {\n    p += 11.8182;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat unoise(in vec2 p, in float seed, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = ZERO; i < oct; i++) {\n        n += amp * unoise(p*freq, seed);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 makeNormal(in float z, in float amp) {\n    float fx = dFdx(z);\n    float fy = dFdy(z);\n    float eps = 0.07;\n    vec2 dx = vec2(dFdx(z), eps);\n    vec2 dy = vec2(eps, dFdy(z));\n    \n    vec3 n = cross(vec3(dx, amp), vec3(dy, amp));\n    vec3 fn = fwidth(n);\n    n = (n + fn)*0.5;\n    return normalize(n);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}