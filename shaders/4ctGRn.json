{
    "Shader": {
        "info": {
            "date": "1711370074",
            "description": "This shader was inspired by the sky i saw after sunset on a rainy evening. The landscape was dark, almost black, while the sky was shining in various colors from blue to red, the clouds in the sky appearing dark.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ctGRn",
            "likes": 9,
            "name": "Evening sky in the rain",
            "published": 3,
            "tags": [
                "2d",
                "raymarching",
                "sunset",
                "sky",
                "landscape",
                "rain"
            ],
            "usePreview": 0,
            "username": "TunaAlert",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "float sqr(float x)\n{\n    return x*x;\n}\nvec3 sqr(vec3 v)\n{\n    return v*v;\n}\nfloat lerp(float a, float b, float t)\n{\n    return b*t + a*(1.-t);\n}\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return b*t + a*(1.-t);\n}\nvec2 rotate(vec2 v, float theta)\n{\n    float c=cos(theta), s=sin(theta);\n    mat2 rotmat = mat2(c,-s,s,c);\n    return rotmat*v;\n}\nvec3 blendColors(vec3 a, vec3 b, float t)\n{\n    vec3 sqra = sqr(a);\n    vec3 sqrb = sqr(b);\n    vec3 sqrblend = lerp(sqra, sqrb, t);\n    return sqrt(sqrblend);\n}\n\nvec3 skyGradient(float y)\n{\n    vec3 col0 = vec3(36, 148, 163)/255.;\n    vec3 col1 = vec3(80, 181, 126)/255.;\n    vec3 col2 = vec3(219, 163, 66)/255.;\n    vec3 col3 = vec3(242, 107, 48)/255.;\n    \n    float pos0 = 1.;\n    float pos1 = .3;\n    float pos2 = -.2;\n    float pos3 = -.5;\n    \n    vec3 col = col0;\n    \n    if(y >= pos0){\n    }else if(y < pos0 && y > pos1){\n        float m = -1./(pos0-pos1);\n        float b = -m*pos0;\n        col = blendColors(col0, col1, b+m*y);\n    }else if(y > pos2){\n        float m = -1./(pos1-pos2);\n        float b = -m*pos1;\n        col = blendColors(col1, col2, b+m*y);\n    }else if(y > pos3){\n        float m = -1./(pos2-pos3);\n        float b = -m*pos2;\n        col = blendColors(col2, col3, b+m*y);\n    }else{\n        col = col3;\n    }\n    \n    return col;\n}\n\n//outputs a number between -1 and 1\n//x = point to sample\n//seed = variation\n//ffac = frequency factor per layer\n//afac = amplitude factor per layer\n//lc = number of layers\nfloat terrain(float x, float seed, float ffac, float afac, float lc){\n    float h = 0.;\n    float f = 1.;\n    float a = 0.5;\n    float w = seed;\n    for(float i = 0.; i < lc; i++){\n        float l = sin(f*x+w)*a;\n        h += l;\n        f *= ffac;\n        a *= afac;\n        w += seed;\n    }\n    return h;\n}\nfloat cloudnoise(vec2 uv, float scale, float seed){\n    float t = 0.;\n    const float layercount = 20.;\n    for(float i = 1.; i <= layercount; i++){\n        t += texture(iChannel0, rotate(uv+vec2(i+seed), i)*scale*(1.+i/layercount)).x/layercount;\n        //rotating the texture several times and adding the layers together removes the pixelated look!\n        //rotate uv+vec2*i( to remove the fixpoint at 0,0 which looks ugly\n    }\n    \n    return t;\n}\n\nvec3 backView(vec2 uv){\n    float terrain = terrain(uv.x + iTime*0.1, 6., 2.14, .54, 7.)*0.3-0.4;\n    //mountains\n    if(uv.y < terrain){\n        return vec3(0);\n    }\n    //sky\n    vec3 skyCol = skyGradient(uv.y);\n    vec3 col = skyCol;\n    \n    //clouds\n    float cloudnoise = cloudnoise(vec2((uv.x+iTime*0.1)*.2, uv.y*.8), 0.15, iTime*0.005);\n    cloudnoise *= 1.-uv.y*.3;\n    float cloud0 = 0.5;\n    float cloud1 = 0.525;\n    float cloud2 = 0.54;\n    if(cloudnoise > cloud0){\n        vec3 rimCol = vec3(219, 163, 66)/255.;\n        vec3 fillCol = blendColors(vec3(22, 54, 40)/255., vec3(10, 28, 26)/255., clamp(uv.y*.5+.2, 0., 1.));\n        if(cloudnoise < cloud1){\n            float m = -1./(cloud0-cloud1);\n            float b = -m*cloud0;\n            col = blendColors(col, rimCol, b+m*cloudnoise);\n        }else if(cloudnoise < cloud2){\n            float m = -1./(cloud1-cloud2);\n            float b = -m*cloud1;\n            col = blendColors(rimCol, fillCol, b+m*cloudnoise);\n        }else{\n            col = vec3(fillCol);\n        }\n    }\n    float terrainBloom = 0.02;\n    if(uv.y < terrain+terrainBloom){\n        float bloomIntensity = 20.;\n        col *= 1.+terrainBloom*bloomIntensity+(terrain-uv.y)*bloomIntensity;\n    }\n    float aasize = 3./iResolution.y;\n    if(uv.y - terrain < aasize){\n        col = blendColors(vec3(0), col, (uv.y - terrain)/aasize);\n    }\n    return col;\n}\n\n//implementation derived from bradforj287's implementation on stackoverflow\nvec3 refractVector(vec3 v, vec3 n, float rIndex){\n    float cosi = dot(v, n) / (length(v) * length(n));\n    float nr = rIndex;\n    if(cosi < 0.){\n        cosi = -cosi;\n        nr = 1./nr;\n    }else{\n        n *= -1.;\n    }\n    float k = 1. - nr*nr * (1. - cosi * cosi);\n    if(k <= 0.){\n        return v;\n    }\n    return v*nr + n*(nr*cosi - sqrt(k));\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n//from Inigo Quilez\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRaindrop(vec3 p, float scale){\n    return sdRoundCone(p, 1.*scale, 0.2*scale, 1.4*scale);\n}\n\nfloat rainLayer(vec3 p, float scale, float intensity, vec2 sampleoffs)\n{\n    vec2 uv = p.xy/scale;\n    vec2 grid = floor(uv);\n    if(texture(iChannel1, grid/1024.+sampleoffs).x < 1.-intensity) return 2.;\n    vec2 rel = mod(uv, 1.)*4.-vec2(2.);\n    return sdRaindrop(vec3(rel, p.z), 1.);\n}\n\nfloat rainSDF(vec3 p)\n{\n    float minlayer = 10.;\n    float iadd = -p.y*.5+.5;\n    //big drops\n    for(float i = 0.; i < 2.; i++){\n        vec3 p_ = p;\n        p_.y += iTime*(0.2+0.1*i);\n        minlayer = min(minlayer, rainLayer(p_-vec3(sin(2.*i), cos(2.*i), 0.), .15, .25+.05*iadd, vec2(i/3.)));\n    }\n    //meduim drops\n    for(float i = 0.; i < 3.; i++){\n        vec3 p_ = p;\n        p_.y += iTime*(0.15+0.05*i);\n        minlayer = min(minlayer, rainLayer(p_-vec3(sin(2.*i), cos(2.*i), 0.), .1, .3+.05*iadd, vec2(i/3.)));\n    }\n    //small drops\n    for(float i = 0.; i < 4.; i++){\n        vec3 p_ = p;\n        p_.y += iTime*(0.1+0.1*i);\n            minlayer = min(minlayer, rainLayer(p_-vec3(sin(2.*i), cos(2.*i), 0.), .07, .3+.1*iadd, vec2(i/3.)));\n    }\n    return minlayer;\n}\n\nvec3 rainNormal(vec3 p)\n{\n    vec2 h = vec2(0.001, 0);\n    return normalize(vec3(\n        rainSDF(p + h.xyy) - rainSDF(p - h.xyy),\n        rainSDF(p + h.yxy) - rainSDF(p - h.yxy),\n        rainSDF(p + h.yyx) - rainSDF(p - h.yyx)\n        ));\n}\n\nvec3 rainDrops(vec2 uv)\n{\n    float bgz = 2.;\n    float hmiss = 0.01;\n    vec3 p = vec3(uv, -1.);\n    vec3 d = vec3(0., 0., 1.);\n    float h;\n    const float raysteps = 5.;\n    for(float i = 0.; i < raysteps; i++){\n        h = rainSDF(p);\n        p += d*h;\n        if(p.z > 0.) return vec3(uv, 0.);//the ray went past the drops\n        if(h < hmiss) break;\n    }\n    vec3 normal = rainNormal(p);\n    const float normalBlend = .2;\n    float brighten = 0.;\n    //blend normal to (0 0 -1) near the edges\n    if(normal.z > -normalBlend){\n        brighten = lerp(1., 0., -normal.z/normalBlend);\n        normal = lerp(vec3(0., 0., -1), normal, -normal.z/normalBlend);\n        normal = normalize(normal);\n    }\n    \n    vec3 refractedV = refractVector(d, normal, 1.333);//1.333 is the refractive index of water\n    vec2 deltauv = refractedV.xy * (bgz - p.z) / refractedV.z;\n    return vec3(uv+deltauv, brighten);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)*2./iResolution.y;\n    \n    vec3 rain = rainDrops(uv);\n    vec3 col = backView(rain.xy);\n    if(rain.z > .5){\n        col = blendColors(col, backView(uv), rain.z*2.-1.);\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}