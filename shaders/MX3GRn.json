{
    "Shader": {
        "info": {
            "date": "1717578696",
            "description": "This is a demo showing how to approximate any 4 sample interpolation with a 3 sample interpolation without any visual artifacts. This specific example shows how to have a distortion-free spherical flow-mapping.",
            "flags": 32,
            "hasliked": 0,
            "id": "MX3GRn",
            "likes": 23,
            "name": "Seamless Sphere Flowmap (3-Tap)",
            "published": 3,
            "tags": [
                "sphere",
                "approximation",
                "normal",
                "flow",
                "mapping",
                "optimization",
                "flowmap",
                "seamless",
                "tennis",
                "spheremap",
                "tennisball",
                "tbn",
                "guardian"
            ],
            "usePreview": 1,
            "username": "gehtsiegarnixan",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI’m developing an experimental method called Guardian Approximation. This \nmethod simplifies multivariate interpolations by approximating multi-sample \ninterpolations with less samples. It does so without visual artifacts, \nwhile adding some divergence from the ground truth.\n\nIn this demo, I’ve used this method to simplify a 4-sample interpolation of \ntennis-ball mapping and animated flow mapping into an artifact-free 3-sample \ninterpolation.\n\nI’m still struggling with finding the optimal programmable criterion for \nselecting the best guardian weights for the general algorithm to \napproximate any multi-sample interpolation. I welcome any feedback or \nsuggestions for improvement.\n\nFor context, see the Quasar Approximation, which solves the generell \nproblem but with occasional artifacts:\nhttps://www.shadertoy.com/view/MfdXz4\n*/\n\n// Flow direction in degree (0=North, 90=East, 180=South, 270=West) in sphere A tangent space\n#define DIRECTION 60.0\n\n// Flow displacement maximum within a cycle, should be low or texture is ruined\n#define FLOW_LENGTH 0.2\n\n// Time until the flow animation repeats its cycle\n#define PERIOD 5.0\n\n// Noise direction offset amount 0-1, to make flow more interesting\n#define NOISE_DIRECTION 0.2\n\n// Temporal noise 0-1 to reduce the pulsing effect, but can create counter flow\n#define NOISE_TEMPORAL 1.0\n\n// Switch SHOW_VALUES to enable different views\n// 0 = textures and normals with lighting\n// 1 = unlit textures\n// 2 = 1, with RGBY colored Phases, White Quiverplot, Black Lat/Lon Grid\n// 3 = Weight values for the interpolation\n// 4 = Mip levels as colormap\n// 5 = Normal vectors\n#define SHOW_VALUES 0\n\n// Struct for barycentric weights and when to switch weights\nstruct ApproxBary {\n    vec3 weights;\n    bool flip;\n};\n\n// Approximate bilinear weights as barycentric weights under the condition\n// guardians have to be able to cover damsels so damsels never meet\nApproxBary guardianApprox (vec2 guardian, vec2 damsel) {\n\n    // Initialize the results\n    vec3 weights;\n    bool flip;\n    \n    // If damsel A is smaller than damsel B, and make damsel 0 at transition\n    if(damsel.x < damsel.y) {    \n        weights = vec3(guardian, damsel.y - damsel.x);\n        flip = true;\n        \n    } else {\n        weights = vec3(guardian, damsel.x - damsel.y);\n        flip = false;\n    }\n    \n    // Normalize weights to be sum 1\n    weights = weights / (weights.x + weights.y + weights.z);\n    \n    // Make struct for output\n    return ApproxBary(weights, flip);\n}\n\n// Function combining tennis ball mapping and flow mapping\nMaterialVal sphereFlowMap (vec3 colorBase, sampler2D tex, sampler2D noiseTex, vec3 normal, float scale, \n            float contrast, float direction, float flowLength, float directionNoise, float temporalNoise, \n            float time) {\n    \n    // Generate tennis ball mapping with TBN matrix and weight\n    TennisBallMapping tennis = mapTennisBall(normal, contrast);\n            \n    // Optional noise, I see a nice opportunity for improvement\n    vec2 noise = texture(noiseTex, vec2(tennis.sphereA.uv.x * 0.5, tennis.sphereA.uv.y)).xy;\n    \n    // Temporal offset to reduce pulsing, but may create counterflow so be careful with scale\n    time -= noise.y * temporalNoise;\n    \n    // Translate noise 0-1 to radian offset scaled by noise amount\n    float noiseAngle = (noise.x-0.5) * 6.283 * directionNoise;\n   \n    // Translate flow direction into vector in tangent space of sphere A\n    float directionRad = (direction * 3.142 / 180.0) + noiseAngle;\n    \n    // Noise angle to direction vector\n    vec2 directionA = vec2(sin(directionRad), cos(directionRad)) * flowLength;\n    \n    // Convert flow direction A to world space using sphereA's TBN\n    vec3 directionWS = tennis.sphereA.TBN * vec3(directionA, 0.0);\n    \n    // Convert windDirWorld to tangent space of sphereB using inverse of sphereB's TBN\n    vec2 directionB = (inverse(tennis.sphereB.TBN) * directionWS).xy;\n    \n    // Apply scaling of the textures\n    tennis.sphereA.uv *= scale;\n    tennis.sphereB.uv *= scale;\n    \n    // Generate two flow mappings\n    FlowMapping flowA = mapFlow(tennis.sphereA.uv, directionA, time, (1.-tennis.weight));\n    FlowMapping flowB = mapFlow(tennis.sphereB.uv, directionB, time, tennis.weight);\n    \n    // Combine tennis and flow weights\n    vec2 flowWeightA = vec2(1.-flowA.weight, flowA.weight) * (1.-tennis.weight);\n    vec2 flowWeightB = vec2(1.-flowB.weight, flowB.weight) * tennis.weight;\n    \n    // Guardian approximation of 4 weights to 3 weights\n    ApproxBary bary = guardianApprox(vec2(flowWeightA.x, flowWeightB.y), \n                                     vec2(flowWeightA.y, flowWeightB.x));\n\n    // Merged damsel UVs so we only need 3 samples\n    vec2 uvCFlip = bary.flip ? flowB.uvA : flowA.uvB;\n\n    #if SHOW_VALUES == 4\n        // Debug feature to show the mip level        \n        vec3 colorA = visualizeMips(tex, flowA.uvA);\n        vec3 colorB = visualizeMips(tex, flowB.uvB);  \n        vec3 colorC = visualizeMips(tex, uvCFlip);  \n        \n    #else\n        // Sample 3 Color textures. I use color modification here, but default textures work too\n        vec3 colorA = colorBase + colorMod(tex, flowA.uvA) * 1.5;\n        vec3 colorB = colorBase + colorMod(tex, flowB.uvB) * 1.5;\n        vec3 colorC = colorBase + colorMod(tex, uvCFlip)   * 1.5;\n    #endif\n    \n    #if SHOW_VALUES == 2\n        // Debug view to show the different phases in different colors\n        colorA = vec3(1.0, 0.05, 0.0) * colorA.z;\n        colorB = vec3(0.0, 0.0, 1.0) * colorB.z;\n        colorC = mix(vec3(0.0, 1.0, 0.38) * colorC.z, vec3(1.0, 0.81, 0.0) * colorC.z, float(bary.flip));\n    #endif\n\n    // Barycentric interpolation between 3 samples\n    vec3 color = colorA * bary.weights.x + colorB * bary.weights.y + colorC * bary.weights.z;\n    \n    #if SHOW_VALUES != 4 \n        // Disable when showing mip levels\n        // Histogram Blend Correction published in https://hal.inria.fr/inria-00536064v2\n        color = clamp(colorBase + (color - colorBase) / \n                sqrt(dot(bary.weights, bary.weights)),0.,1.);\n    #endif\n\n    // Sample normal, if you can obviously use a normal texture instead\n    vec3 normalTSA = HeightToNormal(tex, flowA.uvA, iChannelResolution[0].xy, 8.0);\n    vec3 normalTSB = HeightToNormal(tex, flowB.uvB, iChannelResolution[0].xy, 8.0);\n    vec3 normalTSC = HeightToNormal(tex, uvCFlip, iChannelResolution[0].xy, 8.0);\n\n    // Merged damsel TBN matrix so we only need 3 samples\n    mat3 TBNCFlip = bary.flip ? tennis.sphereB.TBN : tennis.sphereA.TBN;\n\n    // Tangent space normal to world space\n    vec3 normalWSA = tennis.sphereA.TBN * normalTSA;\n    vec3 normalWSB = tennis.sphereB.TBN * normalTSB;  \n    vec3 normalWSC = TBNCFlip * normalTSC; \n\n    // Interpolate normals. Slerp may be better but I can't tell the difference\n    vec3 normalWS = normalize(normalWSA * bary.weights.x + \n                              normalWSB * bary.weights.y + \n                              normalWSC * bary.weights.z);\n    \n    #if SHOW_VALUES == 2\n        // Debug view to show quiverplot and lat/lon grid\n        float gridScale = 16.0;\n    \n        // Generate sphere coords and a fixed fwidth \n        vec4 sphereFixed = sampleSphericalMapDD(normal, gridScale);\n        vec2 uvAFwidth = sphereFixed.zw;\n        \n        // Lat/Lon grid over the sphere\n        vec2 grid = smoothstep(0.02+uvAFwidth, 0.02-uvAFwidth,\n                                 abs(fract(sphereFixed.xy)-0.5));\n        \n        // Apply grid to color  \n        color = mix(color, vec3(0), max(grid.x, grid.y)); \n            \n        // Calculate anti-aliasing effect with edge, but it get's hidden\n        vec2 uvBFwidth = fwidth(tennis.sphereB.uv) * 2.;\n        \n        // Debug Wind direction shown as quiver plot\n        float arrowA = quiverPlot(tennis.sphereA.uv, directionA *3., gridScale/scale, max(uvAFwidth.x, uvAFwidth.y));\n        float arrowB = quiverPlot(tennis.sphereB.uv, directionB *3., gridScale/scale, max(uvBFwidth.x, uvBFwidth.y));\n        \n        // Apply quiverplot to color  \n        color = mix(color, vec3(1), mix(arrowA, arrowB, tennis.weight)); \n        \n    #elif SHOW_VALUES == 3\n        // Debugview return the weights as color\n        color = bary.weights;\n    #endif\n    \n    return MaterialVal(color, normalWS);\n}\n\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    p.x*=iResolution.x/iResolution.y;\n    vec2 um = iMouse.xy / iResolution.xy-.5;\n    um.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\n    //camera\n    vec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    vec2 cursor;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.y;\n        vec2 coords = fragCoord / iResolution.y;\n\n        // Generate Mouse coursor, x = mouse color, y = mouse weight \n        float mouseSize = 0.01;\n        float mouseDist = length(coords - mouse); \n        float aa = fwidth(mouseDist); // cheap anti-aliasing factor\n        cursor.x = smoothstep(mouseSize*0.5 + aa, mouseSize*0.5 - aa, mouseDist);\n        cursor.y = smoothstep(mouseSize + aa, mouseSize - aa, mouseDist);\n\n    } else {\n        mx = mm2(-iTime*.1+um.x*5.);\n        my = mm2(iTime*0.05+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\n    vec2 t = iSphere(ro,rd);\n\n    // Some constants for lighting\n    const vec3 sunColor = vec3(1.000,0.859,0.490);\n    const vec3 ambientColor = vec3(0.773,0.129,0.129);\n    const vec3 sphereColor = vec3(0.078,0.486,0.620);\n    const vec3 lightDir = normalize(vec3(0,1,0));\n\n    // Alternate between background and sphere mapping\n    vec3 color;\n    if (t.x > 0.) {\n        // Sphere mapping\n        vec3 normal = ro+rd*t.x;\n    \n        // Sample albedo textures\n        MaterialVal sphere = sphereFlowMap(sphereColor, iChannel0, iChannel1, normal, 6., \n                                  4., DIRECTION, FLOW_LENGTH, NOISE_DIRECTION, NOISE_TEMPORAL, \n                                  iTime/PERIOD);        \n        \n        #if SHOW_VALUES == 0        \n            // Apply lighting to show the normals too\n            color = phongLighting(sphere.albedo, sphere.normal, ro, lightDir, ambientColor, sunColor, 0.8);\n            \n        #elif SHOW_VALUES == 5\n            // Just show the normal vector for debugging\n            color = sphere.normal *0.5+0.5;\n\n        #else\n            // Just show color for debugging\n            color = sphere.albedo;\n        #endif\n        \n    } else {\n        // Background mapping\n        vec3 normal = rd;\n        \n        // Make sun with halo\n        vec3 sun = sunSpace(normal, lightDir, sunColor);\n        \n        // Generate tennis ball mapping with TBN matrix and weight\n        TennisBallMapping tennis = mapTennisBall(normal, 1.);\n\n        // generate a colormap from tennisball weight, for a thematic gradient\n        vec3 colorBase = YlGnRd_r(smoothContrast(1.-tennis.weight, 1.6));\n        \n        // add some color modulation using tennisball mapping\n        vec3 colorA = colorBase + colorMod(iChannel0, tennis.sphereA.uv * 2.) * 1.5;\n        vec3 colorB = colorBase + colorMod(iChannel0, tennis.sphereB.uv * 2.) * 1.5;\n        vec3 backgroundColor = mix(colorA, colorB, tennis.weight);\n        \n        // Combine background albedo and sunlight\n        color = backgroundColor + sun;\n    }\n\n    #if SHOW_VALUES == 0\n        // Fresnel mask for cheap quasi atmosphere\n        float fresnel = pow(clamp(1.-abs(t.y), 0., 1.), 32.); \n        \n        // gradient fading out on the darkest spot of the sphere\n        float brightnes = sqrt(clamp(dot(lightDir, ro + rd * iSphere(ro*0.95,rd).x)*0.5+0.5, 0.,1.));\n        \n        // blend between sunside and darkside color\n        vec3 atmosColor = mix(sphereColor * ambientColor, sphereColor, brightnes);\n        \n        // apply atmosphereto image using the fresnel mask\n        color = mix(color, atmosColor, fresnel);\n        \n    #elif SHOW_VALUES == 2\n        // Calculate anti-aliasing effect\n        float aa = fwidth(t.y);\n    \n        // Black outline for debug view\n        color *= smoothstep(0.005-aa, 0.005+aa, abs(t.y));\n    #endif\n    \n    // Add mouse cursor\n    color = mix(color, vec3(cursor.x), cursor.y);\n    \n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// GENERIC FUNCTIONS ______________________________________________________________\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInfAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInfAlpha);\n}\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(sampler2D tex, vec2 uv, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(tex, uv).x;\n    float h1 = texture(tex, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(tex, uv + s * vec2(0,textureOffset)).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return safeNormalize(vec3(xy * strength, 1.0), vec3(0,0,1));\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Generate a neutral color variation vector to make colors more interesting\nvec3 colorMod(sampler2D tex, vec2 uvCoords) {\n\n    // Sample the highest mip to get the texture's average color\n    vec3 averageColor = textureLod(tex, vec2(0), 99.).xyz;\n    \n    // Sample the texture as usual\n    vec3 albedo = texture(tex, uvCoords).xyz;\n    \n    // Subtract the average to get a -0.5 to 0.5 color variation vector\n    return albedo - averageColor;\n}\n\n// Struct to hold material values\nstruct MaterialVal {\n    vec3 albedo;\n    vec3 normal;\n};\n\n// TENNIS BALL MAPPING ____________________________________________________________\n\n// Struct to hold sphere mapping values\nstruct SphereMapping {\n    vec2 uv;\n    mat3 TBN;\n};\n\n// Simple spherical map texture sampler\nSphereMapping sampleSphericalMap(vec3 normal) {\n\n    // sample spherical map\n    float u = 0.5 + atan(normal.y, normal.x) / (2. * 3.1415);\n    float v = 0.5 + asin(normal.z) / 3.1415;\n    vec2 uv = vec2(u,v);\n    \n    // so UVs are ~equal scale, as X is circumference, but Y is only half\n    uv.x *= 2.; \n    \n    // TBN Matrix for the spherical mapping above\n    vec3 tangent = safeNormalize(vec3(-normal.y, normal.x, 0.), vec3(1, 0, 0));\n    vec3 bitangent = cross(normal, tangent);\n    mat3 tbn = mat3(tangent, bitangent, normal);\n\n    // pack everything into a struct\n    return SphereMapping(uv, tbn);\n}\n\n// Simple spheremap texture sampler with corrected FWidth\nvec4 sampleSphericalMapDD(vec3 normal, float scale) {\n\n    // Sample spheremap\n    vec2 uv = sampleSphericalMap(normal).uv;\n    \n    // Append 180-degree flipped uv.x and scale \n    vec3 uvn = vec3(uv, mod(uv.x -1., 2.)) * scale;\n    \n    // Calculate partial derivatives of the 3 coordinates\n    vec3 uvnFWidth = fwidth(uvn);\n    \n    // Switch partial derivatives between sphere sides\n    vec2 uvFWidth = (normal.x < 0.0) ? uvnFWidth.zy : uvnFWidth.xy;\n\n    // Join UVs and fwidth\n    return vec4(uvn.xy, uvFWidth);\n}\n\n// Struct to hold tennis ball mapping values\nstruct TennisBallMapping {\n    SphereMapping sphereA;\n    SphereMapping sphereB;\n    float weight;\n};\n\n// Tennis ball mapping function\nTennisBallMapping mapTennisBall(vec3 normal, float contrast) {    \n    // rotated normal to align with the other side of the tennis ball\n    vec3 rotatedNormal = vec3(-normal.x, normal.z, normal.y); \n\n    // sample spherical maps\n    SphereMapping sphereA = sampleSphericalMap(normal);\n    SphereMapping sphereB = sampleSphericalMap(rotatedNormal);\n\n    // adjust TBN matrix of sphereB to account for rotation\n    sphereB.TBN = mat3(-sphereB.TBN[0].x, sphereB.TBN[0].z, sphereB.TBN[0].y,\n                       -sphereB.TBN[1].x, sphereB.TBN[1].z, sphereB.TBN[1].y,\n                       -sphereB.TBN[2].x, sphereB.TBN[2].z, sphereB.TBN[2].y);\n\n    // Prevent floating point errors on some hardware\n    normal = clamp(normal, -1., 1.);\n    \n    // combine halves of SDF\n    float weight;\n    if (normal.x > 0.) {\n        // poles\n        weight = 1. - acos(abs(normal.z)) * 0.63662; \n    } else {\n        // seam of the edge between poles\n        weight = acos(abs(normal.y)) * 0.63662; \n    }\n    \n    // increase contrast of the tennis ball mask\n    weight = straightContrast(weight, contrast);\n        \n    // pack everything into a struct\n    return TennisBallMapping(sphereA, sphereB, weight);\n}\n\n// FLOW MAPPING _____________________________________________________________________\n\n// Struct to hold flow mapping values\nstruct FlowMapping {\n    vec2 uvA;\n    vec2 uvB;\n    float weight;\n};\n\n// Temporal flow map with some extra features to make it smoother\nFlowMapping mapFlow( vec2 uv, vec2 direction, float time, float mask) { \n\n    // Generate timers range -0.5 to 0.5\n    float progressA = fract(time) - 0.5;\n    float progressB = fract(time + 0.5) - 0.5;\n    \n    // Offset each new phase\n    vec2 jump = vec2(0.248, 0.201);\n    vec2 offsetA = (time - progressA) * jump;\n    vec2 offsetB = (time - progressB) * jump + 0.5;\n    \n    // Sample color texture using different timers to scale offset strength\n    vec2 uvA = uv - progressA * direction + offsetA;\n    vec2 uvB = uv - progressB * direction + offsetB;\n    \n    // Generate interpolation weights\n    float weight = abs(progressA * 2.); \n    \n    return FlowMapping(uvA, uvB, weight);\n}\n\n// LIGHTING _______________________________________________________________________\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir, \n                   vec3 ambientLightColor, vec3 sunColor, float specularStrength) {\n    // Ambient\n    vec3 ambient = ambientLightColor * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 8.0);\n    vec3 specular = specularStrength * spec * sunColor;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\nvec3 sunSpace(vec3 normal, vec3 lightDir, vec3 sunColor) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Prevent Nan errors with fron acos\n    NdotL = clamp(NdotL, -1., 1.);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) * 0.3183; // 1/PI\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 16.0) * 1.5;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * sunColor;\n}\n\n// DEBUG ______________________________________________________________________\n\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize, float aa) {\n\n    // constants that maybe should be input variables\n    const float lineThickness = 0.03;    // Thickness of the arrow line\n    const float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    const float maxSize = 0.8;           // Maximum arrow length (1 should be the max)\n    const float minSize = 0.1;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the direction vector length is almost 0\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        //return step(arrowDist, 0.0); // no AA\n        float blur = gridSize * aa;\n        return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    const vec3 c0 = vec3(0.503560,-0.002932,1.000009);\n    const vec3 c1 = vec3(-1.294985,3.144463,0.001872);\n    const vec3 c2 = vec3(-16.971202,0.031355,-1.232219);\n    const vec3 c3 = vec3(97.134102,-5.180126,-0.029721);\n    const vec3 c4 = vec3(-172.585487,-0.338714,0.316782);\n    const vec3 c5 = vec3(131.971426,3.514534,-0.061568);\n    const vec3 c6 = vec3(-37.784412,-1.171512,0.003376);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes YlGnBu_r colormap with polynimal 6\nvec3 YlGnRd_r(float t) {\n    const vec3 c0 = vec3(0.501291,0.002062,0.146180);\n    const vec3 c1 = vec3(1.930635,-0.014549,0.382222);\n    const vec3 c2 = vec3(0.252402,-2.449429,-6.385366);\n    const vec3 c3 = vec3(-10.884918,30.497903,29.134150);\n    const vec3 c4 = vec3(18.654329,-67.528678,-54.909286);\n    const vec3 c5 = vec3(-12.193478,59.311181,49.311295);\n    const vec3 c6 = vec3(2.736321,-18.828760,-16.894758);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Function to calculate the highest mip level based on texture size\nfloat getHighestMipLevel (vec2 texSize) {\n    // Find the maximum dimension of the texture\n    float maxDimension = max(texSize.x, texSize.y);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension) + 1.;\n\n    // Return the highest mip level\n    return highestMipLevel;\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\n// Based on Unreal Engines ComputeMipLevel Material Function \nvec2 getMipLevel(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = duvdx * texSize;\n    vec2 scaledDDY = duvdy * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Calculate the highest possible mip level for the texture\n    float maxMipLevel = getHighestMipLevel(texSize);\n\n    // Clamp the mip level between 0 and the maximum mip level\n    mipLevel = clamp(mipLevel, 0.0, maxMipLevel);\n\n    // Return both the mip level and the maximum mip level\n    return vec2(mipLevel, maxMipLevel);\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\nvec2 getMipLevel(sampler2D sam, vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    // Caculate Mip level\n    return getMipLevel(sam, uv, duvdx, duvdy);\n}\n\n// Visualizes Mip level based on UV coordinates and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv);\n\n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// NOISE BUFFER ___________________________________________________\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 mercatorNormals(vec2 uv) \n{\n    float theta = (1.0 - uv.y) * 3.142;\n\tfloat phi   = uv.x * 3.142 * 2.0;\n    \n    float sinTheta = sin(theta);    \n    \n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sinTheta * sin(phi),                     \n                    sinTheta * cos(phi),\n                    cos(theta));\n    return dir;\n}\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nvec2 smoothValue(vec2 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// Make tiling bilinear weights\nvec4 bilinearWeights(vec2 uv) {\n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(uv * 0.5) * 2.0 - 1.0);\n    \n    // Invert zigzag as a partial of the weights\n    vec2 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = zigZag.x * zigZag.y;\n    float weightB = zigZag.x * infZigZag.y;\n    float weightC = infZigZag.x * zigZag.y;\n    float weightD = infZigZag.x * infZigZag.y;\n    \n    // Combine weight/alpha values. \n    return vec4(weightA, weightB, weightC, weightD);\n}\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define FPRIME 2800852409U\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tuint n = (q.x & q.y) * FPRIME;\n\treturn float(n) * SMALLESTFLOAT;\n}\n\n// Helper Function for Perlin noise\nfloat rndGradient(vec2 grid, vec2 id, vec2 offset, uint gridsize, uvec2 seed) {\n\n    // Current cell coordinates\n    vec2 cell = id + offset;\n\n    #ifdef TILING\n        // This makes the noise repeat between positions 0 and 1\n        cell = mod(cell, float(gridsize));\n    #endif\n\n    // Generate a random offset for the current cell\n    vec2 randomOffset = hash22(cell + vec2(seed)) *2.-1.;\n    \n    // generate random gradient    \n    return dot(grid - offset, randomOffset);\n}\n\n// Function to generate Perlin 2D noise\nfloat perlin(vec2 position, uint gridsize, uvec2 seed) {\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 id = floor(position.xy); // Integer coordinates\n    vec2 grid = position.xy - id; // Fractional coordinates    \n    \n    // Sample noise at the corners\n    float a = rndGradient(grid, id, vec2(0,0), gridsize, seed);\n    float b = rndGradient(grid, id, vec2(0,1), gridsize, seed);\n    float c = rndGradient(grid, id, vec2(1,0), gridsize, seed);\n    float d = rndGradient(grid, id, vec2(1,1), gridsize, seed);\n    \n    // generate weight values\n    vec2 smoothCoords = smoothValue(grid); // for some contrast\n    vec4 weights = bilinearWeights(smoothCoords);\n    \n    // Bilinear interpolation between the corner values\n    float result = a * weights.x + b * weights.y + c * weights.z + d * weights.w;\n    \n    // rescale result to 0-1\n    return result *0.5+0.5;\n}\n\n// Sine hill tiling mask, which is faster than a texture lookup\nfloat sineHills(vec2 uv) {\n    vec2 d = sin(uv * 3.1415); // Remove pi-sized grid\n    return (d.x + d.y) * 0.25 + 0.5; // Add and rescale to 0-1\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // sample the buffer itself\n    vec4 previousFrame = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // translate the current resolution to a hash\n    float hash = hash12(iResolution.xy);\n        \n    // check if the resolution changed, to not caculate more than needed\n    if (abs(previousFrame.z - hash) < 0.0001) {\n    \n        // Use the previously computed result to save performance\n        fragColor = previousFrame;   \n        \n    } else {        \n        // 0-1 normalized coordinates to sample the buffer\n        vec2 uv = fragCoord / iResolution.xy;\n    \n        // Unwrap sphere normals onto a flat surface\n        vec3 normal = mercatorNormals(uv);\n\n        // Generate tennis ball mapping with TBN matrix and weight\n        TennisBallMapping tennis = mapTennisBall(normal, 4.);\n\n        // Generate Curl noise scaled to 0-1\n        float perlinA = perlin(tennis.sphereA.uv, uint(8), uvec2(691));\n        float perlinB = perlin(tennis.sphereB.uv, uint(8), uvec2(691));\n\n        // Sine hills to reduce pulsing in flowmap with low counterflow\n        // This could be improved to be user-proof, maybe with a different pattern\n        float hillsA =  sineHills(tennis.sphereA.uv *8.);\n        float hillsB = sineHills(tennis.sphereB.uv *8.);\n\n        // Joined noise\n        vec2 noiseA = vec2(perlinA, hillsA);\n        vec2 noiseB = vec2(perlinB, hillsB);\n\n        // Interpolate both sides of the tennis ball mapping\n        vec2 noise = mix(noiseA, noiseB, tennis.weight);\n\n        // Artistic increase of the variance, so the noise is not so gray\n        noise.x = smoothContrast(noise.x, 3.);\n                \n        fragColor = vec4(noise, hash, 1);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}