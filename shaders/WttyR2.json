{
    "Shader": {
        "info": {
            "date": "1609531609",
            "description": "Fun little 3D printer animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "WttyR2",
            "likes": 12,
            "name": "3D SDF Printer",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "animation",
                "3dprinting",
                "slicing"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "// Signed distance functions from Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat sdPyramid(in vec3 p, in float h) {\n    float m2 = h * h + 0.25;\n    \n    p.xz = abs(p.xz);\n    p.xz = p.z > p.x ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n   \n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n    \n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n    \n    float d2 = min(q.y, -q.x * m2 - q.y * 0.5) > 0.0 ? 0.0 : min(a, b);\n\n    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdThreadedCylinder(in vec3 p, in float h, in float r, in float turns, in float turnOffset, in float threadThickness) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    float cylinder = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n    float a = p.y * turns + turnOffset;\n    float c = cos(a), s = sin(a);\n    p.xz *= mat2(c, -s, s, c);\n    p.z -= r;\n    float threads = max(abs(p.x), abs(p.z)) - threadThickness;\n\n    return max(cylinder, -threads);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdPrintObject(in vec3 p) {\n    float cube = sdBox(p, vec3(1.35));\n    float sphere = sdSphere(p, 1.6875);\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3)));\n}\n\nfloat mapScene(in vec3 p) {\n    p.yz *= mat2(0.965925826289068, 0.258819045102521, -0.258819045102521, 0.965925826289068);\n\n    float r = (iMouse.x / iResolution.x - 0.5) * 3.1415926535;\n    float c = cos(r), s = sin(r);\n    p.xz *= mat2(c, -s, s, c);\n\n    float printObj = sdPrintObject(p);\n\n    float time = max(0.0, iTime - 1.0);\n    float animTime = time;\n    if (time > 10.0) animTime = time * 10.0 - 100.0;\n    if (time > 20.0) animTime = time * 100.0 - 2000.0;\n    if (time > 30.0) animTime = time * 1000.0 - 30000.0;\n\n    p += 1.35;\n    vec3 pos = floor(mod(animTime / vec3(1.0, 18225.0, 135.0), 2.7) / 0.02) * 0.02;\n    if (animTime > 49207.5) pos = vec3(2.7);\n\n    float stack = p.y - pos.y;\n    float layer = max(stack - 0.02, p.z - pos.z);\n    float row = max(max(stack - 0.02, p.z - pos.z - 0.02), p.x - pos.x);\n\n    vec3 bp = p;\n    bp.xz -= 1.35;\n    float base = sdBox(vec3(bp.x, bp.y + 0.5, bp.z), vec3(3.25, 0.25, 3.25)) - 0.1;\n\n    vec3 lp = bp;\n    lp.xz = abs(lp.xz) - 2.5;\n    lp.y -= 2.25;\n    float lifts = sdThreadedCylinder(lp, 2.5, 0.1, 15.0, pos.y * 10.0, 0.05);\n\n    vec3 rp = vec3(lp.x, bp.y - pos.y - 2.0, bp.z);\n    float risers = sdBox(lp - vec3(0.0, pos.y - 0.25, 0.0), vec3(0.4)) - 0.1;\n    risers = min(risers, sdThreadedCylinder(rp.xzy, 2.5, 0.1, 15.0, pos.z * 10.0, 0.05));\n\n    vec3 sp = vec3(rp.x, rp.y, rp.z + 1.35 - pos.z);\n    float sliders = sdBox(sp, vec3(0.4)) - 0.1;\n    sliders = min(sliders, sdThreadedCylinder(vec3(sp.y, bp.x, sp.z), 2.5, 0.1, 15.0, pos.x * 10.0, 0.05));\n\n    vec3 hp = p - pos;\n    hp.y = 1.0 - hp.y;\n    float head = sdPyramid(hp, 1.0) - 0.05;\n    hp.y += 0.65;\n    head = min(head, sdBox(hp, vec3(0.45, 0.65, 0.45)) - 0.1);\n\n    float printer = min(base, min(min(lifts, min(risers, sliders)), head));\n\n    return min(printer, max(printObj, min(stack, min(layer, row))));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, -0.125, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += (0.5 + 0.5 * n) * max(0.3, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}