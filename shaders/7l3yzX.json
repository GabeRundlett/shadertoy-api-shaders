{
    "Shader": {
        "info": {
            "date": "1660213730",
            "description": "An update of the original; mouseable (mouse in top/bottom for static views)",
            "flags": 0,
            "hasliked": 0,
            "id": "7l3yzX",
            "likes": 18,
            "name": "Spitfire Pursuit II",
            "published": 3,
            "tags": [
                "landscape",
                "aircraft",
                "flight"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "// \"Spitfire Pursuit II\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 21 in \"Aeroplane\" series\n    \"Spruce Goose\"                (fdy3DW) - others listed here\n    \"Snoopy and the Red Baron 2\"  (NdVSDV)\n    \"Mighty Mriya\"                (7llfz2)\n    \"Mriya Plans\"                 (ftjBzG)\n*/\n    \n#define AA   0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_FLYER  2\n\nmat3 flyerMat[N_FLYER];\nvec3 flyerPos[N_FLYER], qHit, qHitTr, sunDir, trkAx, trkFx, trkAy, trkFy;\nfloat dstFar, tCur, flyerSz;\nint idObj, idObjTr, idObjGrp, vuMode;\nconst int idFus = 1, idCkpt = 2, idWngM = 3, idWngT = 4, idTail = 5, idNos = 6,\n   idGun = 7, idEx = 8, idIn = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMINTRQ(id) if (d < dMin) { dMin = d;  idObjTr = id;  qHitTr = q; }\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, tapr;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  float dx, dz;\n  dx = abs (p.x - wg.trans);\n  dz = dx / wg.span;\n  p.yz = abs (p.yz);\n  p.y -= - (wg.sRad + wg.tapr * dz * dz * dz);\n  return max (length (p.yz) - wg.thck, dx - wg.span);\n}\n\nfloat FusRad (float z)\n{\n  return 1.68 - 0.0083 * z * z;\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, df, wSpan;\n  dMin /= flyerSz;\n  p /= flyerSz;\n  if (vuMode == 0) d = PrRoundBoxDf (p, vec3 (15., 4., 15.), 0.1);\n  if (vuMode > 0 || d < 0.1 / flyerSz) {\n    wSpan = 15.;\n    q = p;\n    df = PrCapsDf (q - vec3 (0., 0., -1.44), FusRad (q.z), 12.);\n    df = max (df, q.z - 10.92);\n    d = df;\n    DMINQ (idObjGrp + idFus);\n    d = PrCapsDf (q - vec3 (0., 0.78 + 0.13 * q.z, -1.2), 1.2, 3.6);\n    d = SmoothMin (d, df, 0.05);\n    DMINQ (idObjGrp + idCkpt);\n    q = p;\n    q.yz -= vec2 (-0.75, 1.8);\n    q.x = abs (q.x);\n    q.xy = Rot2Cs (q.xy, sin (-0.01 * pi + vec2 (0.5 * pi, 0.)));\n    d = WingDf (q, WingParm (wSpan, 13.7, 0., 14.05, 0.37));\n    d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (abs (q.x) - 7.5) - 2.5, q.z + 2.5),\n       vec2 (2., 0.7))), 0.07);\n    d = SmoothMin (d, df, 0.3);\n    DMINQ (idObjGrp + idWngM);\n    q = p;\n    q.yz -= vec2 (0.1, -11.4);\n    d = WingDf (q, WingParm (0.4 * wSpan, 6.8, 0., 7.05, 0.37));\n    d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (q.x) - 2.5, q.z + 1.6),\n       vec2 (1.4, 0.7))), 0.07);\n    d = SmoothMin (d, df, 0.2);\n    DMINQ (idObjGrp + idWngT);\n    q = p;\n    q.yz -= vec2 (-0.2, - 11.8);\n    d = max (WingDf (vec3 (q.x, Rot2Cs (q.yz, sin (0.05 * pi + vec2 (0.5 * pi, 0.)))).yxz,\n       WingParm (0.18 * wSpan, 7., 1.5, 7.2, 0.2)), - q.y);\n    d = SmoothMax (d, - abs (PrBox2Df (vec2 (q.y - 1.9, q.z + 1.7), vec2 (1.2, 0.6))), 0.07);\n    d = SmoothMin (d, df, 0.2);\n    DMINQ (idObjGrp + idTail);\n    q = p;\n    q.z -= 11.76;\n    d = PrConeDf (q, vec3 (0.8, 0.6, 0.9));\n    DMINQ (idObjGrp + idNos);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (5., -0.6, 4.7);\n    d = PrCylDf (q, 0.1, 0.6);\n    DMINQ (idObjGrp + idGun);\n    q = p;\n    q.x = abs (q.x);\n    q.z -= 8.;\n    q.xz = Rot2Cs (q.xz, sin (-0.045 * pi + vec2 (0.5 * pi, 0.)));\n    q.z = abs (abs (q.z - 0.3) - 0.6);\n    q.xz -= vec2 (1.07, 0.3);\n    d = PrCapsDf (q, 0.12, 0.1);\n    DMINQ (idObjGrp + idEx);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (2.3, -0.8, 3.);\n    d = max (PrRoundBoxDf (q, vec3 (0.5, 0.05, 0.8), 0.2), q.y - 0.05);\n    DMINQ (idObjGrp + idIn);\n  } else dMin = min (dMin, d);\n  return flyerSz * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    if (vuMode == 0 || vuMode == k + 1) {\n      idObjGrp = (k + 1) * 256;\n      dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n    }\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar / flyerSz;\n  for (int k = VAR_ZERO; k < N_FLYER; k ++) {\n    if (vuMode == 0 || vuMode == k + 1) {\n      idObjGrp = (k + 1) * 256;\n      q = (flyerMat[k] * (p - flyerPos[k])) / flyerSz;\n      q.z -= 11.05;\n      d = PrCylDf (q, 2.3, 0.05);\n      DMINTRQ (idObjGrp);\n    }\n  }\n  return flyerSz * dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, bCol4;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  bCol4 = (ig == 1) ? vec4 (0.9, 0.2, 0.9, 0.2) : vec4 (0.9, 0.9, 0.2, 0.2);\n  col4 = vec4 (0.9, 0.9, 1., 0.2);\n  if (id == idFus) {\n    col4 = mix (col4, bCol4, smoothstep (-0.75, -0.65, qHit.y));\n    col4 = mix (bCol4.gbra, col4, smoothstep (0., 0.02,\n       abs (length (qHit.yz - vec2 (0.2, -5.)) - 0.5) - 0.07));\n  } else if (id == idCkpt) {\n    col4 = (abs (qHit.x) > 0.07 && qHit.z > 0.5 && abs (abs (abs (qHit.z - 1.) - 1.) -\n       0.5) > 0.07) ? vec4 (0., 0., 0., -1.) : bCol4;\n  } else if (id == idWngM) {\n    col4 = mix (bCol4.gbra, col4, smoothstep (0., 0.05,\n       abs (length (qHit.xz - vec2 (8., 0.5)) - 1.) - 0.1));\n    if (qHit.y > 0.) col4 = mix (bCol4, col4, smoothstep (0., 0.05,\n       length (qHit.xy - vec2 (0., 0.84)) - FusRad (qHit.z + 1.8) - 0.2));\n  } else if (id == idWngT) {\n    col4 = mix (bCol4, col4, smoothstep (0., 0.05, length (qHit.xy - vec2 (0, -0.1)) -\n        FusRad (qHit.z - 11.4) - 0.1));\n  } else if (id == idTail) {\n    col4 = mix (bCol4.gbra, col4, smoothstep (0., 0.05,\n       abs (length (qHit.yz - vec2 (2.5, 0.)) - 0.5) - 0.07));\n    col4 = mix (bCol4, col4, smoothstep (0., 0.05, length (qHit.xy - vec2 (0., 0.2)) -\n       FusRad (qHit.z - 11.8) - 0.1));\n  } else if (id == idNos) {\n    col4.rgb *= 0.8;\n  } else if (id == idGun) {\n    col4.rgb *= 0.6;\n  } else if (id == idEx) {\n    col4.rgb *= 0.7;\n  } else if (id == idIn) {\n    col4.rgb *= 0.8 * (1. - 0.4 * step (0., qHit.z) *\n       (1. - smoothstep (0., 0.02, PrBox2Df (qHit.xy, vec2 (0.5, 0.2)))));\n  }\n  return col4;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), 0.5 + abs (dot (trkAy, sin (trkFy * t))), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkFx * trkAx, cos (trkFx * t)), dot (trkFy * trkAy, cos (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkFx * trkFx * trkAx, - sin (trkFx * t)), 0., 0.);\n}\n\nfloat GrndDf (vec3 p, float d)\n{\n  vec3 pt;\n  vec2 q, r;\n  float wAmp, h, s, w, t;\n  wAmp = 1.;\n  q = 0.02 * p.xz;\n  t = 0.;\n  h = 0.; // (from \"Terrain Explorer 2\", simplified)\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    r = Noisev2v2 (3. * q);\n    t += r.y;\n    h += wAmp * r.x / (1. + t * t);\n    wAmp *= 0.5;      \n    q *= 2.;\n  }\n  h *= 16. * (1. + 0.4 * Noisefv2 (0.01 * p.xz));\n  h *= 1. - 0.5 * smoothstep (0.9, 1., d / dstFar);\n  pt = TrackPath (p.z);\n  w = abs (p.x - pt.x);\n  s = smoothstep (10., 35., w);\n  h = mix (pt.y + 0.2 * h * (0.5 + 2.5 * s + 0.004 * w * w) + 0.1 * Noisefv2 (p.xz) - 2.5, h, s);\n  return p.y - h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    h = GrndDf (ro + s * rd, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.1, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (GrndDf (ro + s * rd, s) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (1., -1.) * max (0.01, 0.00001 * d * d);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)), d);\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = GrndDf (ro + d * rd, d);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += max (0.01 * d, 2. * h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 GrndCol (vec3 p, vec3 vn)\n{\n  vec4 col, gCol, rCol, snCol, saCol;\n  float f;\n  f = length (p.xz);\n  gCol = mix (vec4 (0.2, 0.45, 0.3, 0.1), vec4 (0.15, 0.35, 0.25, 0.1),\n     smoothstep (0.35, 0.65, Fbm2 (0.5 * p.xz)));\n  rCol = mix (vec4 (0.4, 0.4, 0.45, 0.), vec4 (0.37, 0.37, 0.4, 0.),\n     smoothstep (0.4, 0.6, Fbm2 (vec2 (f, 3. * p.y)))) * (0.9 +\n     0.1 * Noisefv2 (vec2 (4. * f, 8. * p.y)));\n  col = mix (rCol, gCol, smoothstep (0.45, 0.8, vn.y) * (1. - smoothstep (10., 20., p.y)));\n  snCol = vec4 (0.97, 0.97, 1., 0.3) * (0.9 + 0.1 * Noisefv2 (4. * p.xz));\n  if (vn.y > 0.25) col = mix (col, snCol, smoothstep (20., 25., p.y - 0.5 * Noisefv2 (2. * p.xz)));\n  saCol = vec4 (0.6, 0.53, 0.43, 0.1) * (0.8 + 0.2 * Noisefv2 (4. * p.xz));\n  col = mix (col, saCol, (1. - smoothstep (0.02, 0.1, p.y)) * smoothstep (0.85, 0.95, vn.y));\n  return col;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.1, 0.2, 0.55) + 0.25 * pow (1. - abs (rd.y), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  f = Fbm2 (0.01 * (ro + rd * (200. - ro.y) / rd.y).xz);\n  return mix (SkyBg (rd) + 0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.9), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 objCol, col, vn, roo, rdo, rp;\n  float dstObj, dstWat, dstGrnd, sh, refFac, dstFade;\n  bool isLit;\n  roo = ro;\n  rdo = rd;\n  refFac = 1.;\n  sh = 1.;\n  isLit = false;\n  dstWat = dstFar;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (vuMode == 0) {\n    dstGrnd = GrndRay (ro, rd);\n    dstFade = dstGrnd;\n    if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n      dstWat = - ro.y / rd.y;\n      dstFade = dstWat;\n      ro += dstWat * rd;\n      rd = reflect (rd, VaryNf (2. * ro, vec3 (0., 1., 0.),\n         0.1 * (1. - smoothstep (0.1, 0.4, dstWat / dstFar))));\n      ro += 0.01 * rd;\n      dstGrnd = GrndRay (ro, rd);\n      dstFade += dstGrnd;\n      dstObj = ObjRay (ro, rd);\n      refFac *= 0.8;\n    }\n    if (dstObj < min (dstGrnd, dstFar)) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = FlyerCol ();\n      if (col4.a >= 0.) {\n        sh = ObjSShadow (ro, sunDir);\n        isLit = true;\n      } else col = 0.2 + 0.7 * SkyCol (ro, reflect (rd, vn));\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro, dstGrnd);\n      vn = VaryNf (0.15 * ro, vn, 1.5 - 1.2 * smoothstep (10., 15., ro.y));\n      col4 = GrndCol (ro, vn);\n      sh = GrndSShadow (ro + 0.01 * vn, sunDir);\n      isLit = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n    }\n  } else {\n    col = vec3 (0.2, 0.2, 0.3);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = FlyerCol ();\n      if (col4.a >= 0.) {\n        sh = ObjSShadow (ro, sunDir);\n        isLit = true;\n      } else col = 0.2 + 0.7 * SkyCol (ro, reflect (rd, vn));\n    }\n  }\n  if (isLit) col = refFac * (col4.rgb * (0.1 + 0.1 * max (vn.y, 0.) + \n     0.2 * max (- dot (vn, normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n     sh * max (dot (vn, sunDir), 0.)) +\n     col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.));\n  if (vuMode == 0 && refFac == 1. && dstGrnd < min (dstObj, dstFar))\n     col = mix (refFac * 1.05 * SkyBg (rd), col, exp2 (min (0., 4. - 9. * dstFade / dstFar)));\n  if (TrObjRay (roo, rdo) <  min (min (min (dstObj, dstGrnd), dstWat), dstFar))\n     col = mix (0.85 * col, ((idObjTr / 256 == 1) ?\n     vec3 (0.9, 0.3, 0.9) : vec3 (0.9, 0.9, 0.3)),\n     0.3 * SmoothBump (0., 0.2, 0.02, length (qHitTr.xy) - 1.9));\n  return clamp (col, 0., 1.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid FlyerPM (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, va, ori, ca, sa;\n  float tgr, td, el, az, rl;\n  if (vuMode == 0) {\n    flPos = TrackPath (t);\n    vel = TrackDir (t);\n    el = - ((vu == 0.) ? 1. : 0.3) * asin (vel.y / length (vel));\n    az = atan (vel.z, vel.x) - 0.5 * pi;\n    va = cross (TrackAcc (t), vel) / length (vel);\n    rl = ((vu == 0.) ? 20. : 6.) * length (va) * sign (va.y);\n    if (vu > 0.) {\n      el *= -1.;\n      rl *= -1.;\n      az += pi;\n    }\n    ori = vec3 (el, az, rl);\n    ca = cos (ori);\n    sa = sin (ori);\n    flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n            mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n    tgr = 100.;\n    td = floor (t / tgr) * tgr;\n    flPos.y = 5.5 - mix (GrndDf (vec3 (TrackPath (td).xz, 0.).xzy, 0.),\n       GrndDf (vec3 (TrackPath (td + tgr).xz, 0.).xzy, 0.), (t - td) / tgr);\n  } else {\n    flPos = vec3 (0.);\n    flMat = mat3 (1., 0., 0., 0., 1., 0., 0., 0., 1.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr, asp, spd, tGap, ts;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  vuMode = 0;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    if (abs (mPtr.y) < 0.45) {\n      el = clamp (0.6 * pi * mPtr.y, - 0.25 * pi, 0.25 * pi);\n    } else {\n      vuMode = (mPtr.y < 0.) ? 1 : 2;\n      az += 0.6 * pi;\n      el = -0.1 * pi * sign (mPtr.y);\n    }\n  }\n  tCur = mod (tCur, 1200.) + 30. * floor (dateCur.w / 3600.);\n  if (vuMode == 0) {\n    trkAx = 8. * vec3 (1.9, 2.9, 4.3);\n    trkFx = 0.15 * vec3 (0.23, 0.17, 0.13);\n    trkAy = 0.7 * vec3 (1.7, 3.7, 0.);\n    trkFy = 0.3 * vec3 (0.21, 0.15, 0.);\n    spd = 15.;\n    tGap = 15. * (1. + 0.3 * sin (0.01 * pi * tCur));\n    ts = 1. - 2. * SmoothBump (0.25, 0.75, 0.1, mod (tCur / 60., 1.));\n    for (int k = 0; k < N_FLYER; k ++) FlyerPM (spd * tCur + (float (k) -\n       0.5 * float (N_FLYER - 1)) * tGap, 0., flyerPos[k], flyerMat[k]);\n    FlyerPM (spd * tCur + ts * tGap * float (N_FLYER - 1), sign (ts), ro, flMat);\n    vuMat = StdVuMat (- el * sign (ts), az);\n    zmFac = 2.5;\n    ro.y += 1.3;\n    ro.x += 1.5 * sin (0.05 * pi * tCur);\n    sunDir = normalize (vec3 (-0.9, 1.5, -1.));\n    flyerSz = 0.08;\n  } else {\n    for (int k = 0; k < N_FLYER; k ++) FlyerPM (0., 0., flyerPos[k], flyerMat[k]);\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -20.);\n    zmFac = 3.5;\n    sunDir = vuMat * normalize (vec3 (0.5, 0.1, -1.));\n    flyerSz = 0.5;\n  }\n  dstFar = 300.;\n  if (vuMode > 0 || abs (uv.y) < 0.9) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      uvv /= zmFac;\n      if (vuMode == 0) rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp,\n         uvv.y, 1.)) * flMat;\n      else rd = normalize (vec3 (uvv, 1.));\n      rd = vuMat * rd;\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n    if (vuMode == 0) col += GlareCol (rd, flMat * (sunDir * vuMat), uv);\n    else if (abs (abs (uv.y) - 0.895) < 0.005) col = vec3 (0.4, 0.4, 0.6);\n  } else {\n    col = vec3 (0.2, 0.2, 0.3);\n    if (mPtr.z > 0.) col += vec3 (0.2, 0.2, 0.) * step (PrBox2Df (vec2 (uv.x, abs (uv.y) - 0.95),\n       vec2 (0.07, 0.01)), 0.);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v2 (vec2 p)\n{\n  return vec2 (Noisefv2 (p), Noisefv2 (p + vec2 (17., 23.)));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}