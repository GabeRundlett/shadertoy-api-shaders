{
    "Shader": {
        "info": {
            "date": "1553569083",
            "description": "I'm really enjoying this, kinda hypnotic!",
            "flags": 32,
            "hasliked": 0,
            "id": "tsSSDh",
            "likes": 5,
            "name": "flowing green string thing",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "blue"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 536
        },
        "renderpass": [
            {
                "code": "\n/**\n * Ray marching parameters for this scene\n */\n#define MAX_STEPS  300000\n#define MAX_DIST   20.0\n#define EPSILON    0.001\n#define STEP_RATIO 0.20\n#define FRACTAL_ITERATIONS 7\n/**\n * object ids\n */\n#define ID_FLOOR 10\n#define ID_BIZZO 1\n#define ID_BIZZO2  2\n#define ID_CAP   4\n\n#define COS_30    0.8660254037844387\n#define HEX_EVEN  1.7320508075688772\n\nvec2 dist_bizzo(vec3 where) {\n    float d = length(where) -1.0;\n    float ratio = 1.75 + 0.1 * sin(iTime * 0.13);\n    \n    float a2 = 1.0 + 1.0 * sin(iTime *0.49) + 0.25 * sin(iTime*0.01)* where.y;\n    float s2 = sin(a2);\n    float c2 = cos(a2);\n    \n    float a3 = 1.0 * sin(iTime *0.29) + 0.015 * 0.25 * sin(iTime*0.03)*where.x ;\n    float s3 = sin(a3);\n    float c3 = cos(a3);\n    \n    float a = 1.0 + sin(iTime * 0.39) + 0.15 * cos(where.z);\n    float s = sin(a);\n    float c = cos(a);\n    \n\tfloat depth = 0.0;\n    \n    vec3 displacement = vec3(\n        -2.2 +  c,\n        2.5 + 0.9 * s,\n        -1.5 + 0.9 * sin(iTime * 0.13)\n\t);\n    for (int  i = 0; i <FRACTAL_ITERATIONS; i++) {\n        \n        where = vec3(\n            c2 * where.x - s2 * where.z,\n            where.y,\n            s2 * where.x + c2 * where.z\n        );\n        where = vec3(\n            c3 * where.x - s3 * where.y,\n            s3 * where.x + c3 * where.y,\n            where.z\n        );\n\n        where = -abs(where);\n\n        where.xz = -where.zx;\n        where.y = -5.0/(1.0 + pow(length(where.yz),2.0));\n        where = where * ratio + displacement;\n        float j = 0.5*(length(where) -1.0) / ratio;\n//        d = blend(d, j, 0.2);\n        // blend function body\n        float k = 0.2;\n    \tfloat h = max( k - abs(d - j), 0.0 );\n        float together = min(d, j);\n    \td= together - h*h*0.25/k;\n        float progress = clamp((j-d)/k, 0.0, 1.0);\n        depth+=progress;\n\t\n    }\n    return vec2(d, depth);\n}\n\nfloat dist_bizzo2(vec3 where) {\n    where.y += 22.0;\n    \n\n\twhere.y += cos(sin(iTime + length(where.xz)) * 5.0);\n    where.y += 0.5 * sin(iTime*0.73 + sin(where.z) * 3.0);\n    return where.y;\n}\n\n/**\n * find the closest object in the scene and return its distance and id\n */\nvec3 measure(vec3 where) {\n    vec3 closest = vec3(100000.0, 0.0, 0.0);\n\tfloat depth = 0.0;\n    /*\n    float dist_floor = where.y + 30.0;\n    if (dist_floor <= closest.x) {\n        closest = vec3(dist_floor, ID_FLOOR, 0.0);\n    }\n*/\n    vec2 dist_bizzo = dist_bizzo(where);\n    if (dist_bizzo.x <= closest.x) {\n        closest = vec3(dist_bizzo.x, ID_BIZZO, dist_bizzo.y);\n    }\n/*\n    float dist_bizzo2 = dist_bizzo2(where);\n    if (dist_bizzo2 <= closest.x) {\n        closest = vec3(dist_bizzo2, ID_BIZZO2, 0.0);\n    }\n*/\n    return closest;\n}\n\n/**\n * Figure out coloring for where we hit\n */\nconst vec4 floor_color =  vec4(0.018,0.018,0.022,0.0);\nconst vec4 bizzo_color = vec4(0.1, 0.4, 0.32, 0.2) * 0.5;\nconst vec4 bizzo2_color = vec4(0.25,0.23,0.21,0.2);\n\nconst vec4 guts_color = vec4(0.5,0.2,0.1,0.0);\nconst vec4 rod_color = vec4(1,0,0,1.0);\nconst vec4 bone_color = vec4(0.6,0.57,0.50,0.2);\nconst vec4 sky_top = vec4(0.8, 0.74, 0.74, 1.0);\nconst vec4 sky_bottom = vec4(BLACK,1.0); //vec4(0.4, 0.37, 0.37, 1.0);\n\nvec4 paint(vec3 hit, vec3 where) {\n\n    int who = int(hit.y);\n    float ambient = 0.0;\n    if (who == ID_FLOOR) {\n        return 0.1 * bone_color;\n    }\n    if (who == ID_BIZZO) {\n        return bizzo_color + vec4(hit.z/7.0) * vec4(1,1,0.5,1);\n    }\n    if (who == ID_BIZZO2) {\n        return bizzo2_color;\n    }\n    if (who == ID_CAP) {\n        return bone_color;\n    }\n    return sky_top;\n}\n\n// end of model stuff\n\nvec3 calc_surface_normal(vec3 hit);\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(\n        sin(iTime/10.0)*12.0,\n        7.0,\n        cos(iTime/10.0)*12.0\n    );\n    vec3 look_at = vec3(0,0,0);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec3 current;\n    int who = 0;\n    for(int steps = 0; steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        float pos = 0.5 * (ray.y + 1.0);\n        fragColor = mix(sky_bottom, sky_top, pos);\n        return;\n    }\n\tvec3 hit = where;\n    \n    vec4 the_paint = paint(current, where);\n    vec3 to_light = normalize(vec3(-5,15,-1));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient) * \n        (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = shadow * pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += vec3(specular, specular, specular);\n    fragColor = vec4(coloring, total_dist * 0.2);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\n/**\n * centred modulo\n */\nfloat cmod(float x, float r) {\n    return mod(x + 0.5 *r, r) - 0.5 *r;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n/**\n * Ray marching parameters for this scene\n */\n#define MAX_STEPS  100\n#define MAX_DIST   50.0\n#define EPSILON    0.001\n#define STEP_RATIO 0.01\n\n/**\n * object ids\n */\n#define ID_FLOOR 10\n#define ID_BIZZO 1\n#define ID_BIZZO2  2\n#define ID_CAP   4\n\n#define COS_30    0.8660254037844387\n#define HEX_EVEN  1.7320508075688772\n\nvec2 dist_bizzo(vec3 where) {\n    float d = length(where) -1.0;\n    float ratio = 2.0 + 0.1 * sin(iTime * 0.13);\n    \n    float a2 = 1.0 + 1.0 * sin(iTime *0.49) + 0.5 * where.y;\n    float s2 = sin(a2);\n    float c2 = cos(a2);\n    \n    float a3 = 1.0 * sin(iTime *0.29) + 0.15 * 0.5 * where.x ;\n    float s3 = sin(a3);\n    float c3 = cos(a3);\n    \n    float a = 1.0 + sin(iTime * 0.39) + 0.15 * cos(where.z);\n    float s = sin(a);\n    float c = cos(a);\n    \n\tfloat depth = 0.0;\n    \n    vec3 displacement = vec3(\n        -6.2 +  c,\n        6.5 + 0.9 * s,\n        -6.5 + 0.9\n\t);\n    for (int  i = 0; i <6; i++) {\n        \n        where = vec3(\n            c2 * where.x - s2 * where.z,\n            where.y,\n            s2 * where.x + c2 * where.z\n        );\n        where = vec3(\n            c3 * where.x - s3 * where.y,\n            s3 * where.x + c3 * where.y,\n            where.z\n        );\n\n        where = -abs(where);\n\n        where.xz = -where.zx;\n        where.y = -5.0/(1.0 + pow(length(where.yz),2.0));\n        where = where * ratio + displacement;\n        float j = 0.5*(length(where) -1.0) / ratio;\n//        d = blend(d, j, 0.2);\n        // blend function body\n        float k = 0.2;\n    \tfloat h = max( k - abs(d - j), 0.0 );\n        float together = min(d, j);\n    \td= together - h*h*0.25/k;\n        float progress = clamp((j-d)/k, 0.0, 1.0);\n        depth+=progress;\n\t\n    }\n    return vec2(d, depth);\n}\n\nfloat dist_bizzo2(vec3 where) {\n    where.y += 22.0;\n    \n\n\twhere.y += cos(sin(iTime + length(where.xz)) * 5.0);\n    where.y += 0.5 * sin(iTime*0.73 + sin(where.z) * 3.0);\n    return where.y;\n}\n\n/**\n * find the closest object in the scene and return its distance and id\n */\nvec3 measure(vec3 where) {\n    vec3 closest = vec3(100000.0, 0.0, 0.0);\n\tfloat depth = 0.0;\n    float dist_floor = where.y + 30.0;\n    if (dist_floor <= closest.x) {\n        closest = vec3(dist_floor, ID_FLOOR, 0.0);\n    }\n\n    vec2 dist_bizzo = dist_bizzo(where);\n    if (dist_bizzo.x <= closest.x) {\n        closest = vec3(dist_bizzo.x, ID_BIZZO, dist_bizzo.y);\n    }\n\n    float dist_bizzo2 = dist_bizzo2(where);\n    if (dist_bizzo2 <= closest.x) {\n        closest = vec3(dist_bizzo2, ID_BIZZO2, 0.0);\n    }\n\n    return closest;\n}\n\n/**\n * Figure out coloring for where we hit\n */\nconst vec4 floor_color =  vec4(0.018,0.018,0.022,0.0);\nconst vec4 bizzo_color = vec4(0.1, 0.4, 0.32, 0.2) * 0.5;\nconst vec4 bizzo2_color = vec4(0.25,0.23,0.21,0.2);\n\nconst vec4 guts_color = vec4(0.5,0.2,0.1,0.0);\nconst vec4 rod_color = vec4(1,0,0,1.0);\nconst vec4 bone_color = vec4(0.6,0.57,0.50,0.2);\nconst vec4 sky = vec4(0,0,0,0);\n\nvec4 paint(vec3 hit, vec3 where) {\n\n    int who = int(hit.y);\n    float ambient = 0.0;\n    if (who == ID_FLOOR) {\n        return 0.1 * bone_color;\n    }\n    if (who == ID_BIZZO) {\n        return bizzo_color + vec4(hit.z/5.0) * vec4(1,1,0.5,1);\n    }\n    if (who == ID_BIZZO2) {\n        return bizzo2_color;\n    }\n    if (who == ID_CAP) {\n        return bone_color;\n    }\n    return sky;\n}\n\n// end of model stuff\n\nvec3 calc_surface_normal(vec3 hit);\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime/10.0)*12.0,\n                    7.0,\n                    cos(iTime/10.0)*12.0);\n    vec3 look_at = vec3(0,0,0);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec3 current;\n    int who = 0;\n    for(int steps = 0; steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        fragColor = vec4(fog_color, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    \n    vec4 the_paint = paint(current, where);\n    vec3 to_light = normalize(vec3(-5,15,-1));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient) * \n        (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = shadow * pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += vec3(specular, specular, specular);\n    fragColor = vec4(coloring, total_dist * 0.2);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}