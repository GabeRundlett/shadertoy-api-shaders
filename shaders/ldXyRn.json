{
    "Shader": {
        "info": {
            "date": "1486653954",
            "description": "SVG viewer.    Copy-Paste-adapt your SVG data: see comments \nslow GPU: decrease N.\n\nV2: more robust interior detection ( thanks to  TimoKinnunen ! )\n\nNB: 3260 chars: 1700 for data 1560 for code.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldXyRn",
            "likes": 52,
            "name": "svg viewer v2 / nVidia logo",
            "published": 3,
            "tags": [
                "bezier",
                "logo",
                "svg",
                "nvidia"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2613
        },
        "renderpass": [
            {
                "code": "// improved version of https://www.shadertoy.com/view/MlVSWc\n// === SVG Player ====      short spec: https://www.w3.org/TR/2008/REC-SVGTiny12-20081222/paths.html\n\n#define N 20.  // splines discretization. Lower it on slow GPUs\n// absolute main SVG commands\n#define M(x,y)             x0 = _x = x;   y0 = _y = y;\n#define L(x,y)             d = min(d, line(uv, vec2(_x,_y), vec2(x,y)) ); _x=x,_y=y;\n#define C(x1,y1,x2,y2,x,y) d = min(d, bezier(uv, vec2(_x,_y), vec2(x1,y1),vec2(x2,y2), vec2(x,y)) ); _x=x,_y=y; \n#define H(x)               d = min(d, line(uv, vec2(_x,_y), vec2(x,_y)) ); _x=x;\n#define V(y)               d = min(d, line(uv, vec2(_x,_y), vec2(_x,y)) ); _y=y;\n#define Z                  d = min(d, line(uv, vec2(_x,_y), vec2(x0,y0)) );\n// relative main SVG commands\n#define m(x,y)             M(_x+x,_y+y)\n#define l(x,y)             L(_x+x,_y+y)\n#define c(x1,y1,x2,y2,x,y) C(_x+x1,_y+y1,_x+x2,_y+y2,_x+x,_y+y)\n#define h(x)               H(_x+x)\n#define v(y)               V(_y+y)\n#define z                  Z\n\n#define style(f,c)         fill=f; S=1.; COL = mod(vec4((c)/65536,(c)/256,c,1),256.)/255.;\n#define path(cmd)          d = 1e38; cmd; draw(d,O);\n\nfloat bezier(vec2,vec2,vec2,vec2,vec2);\nfloat line(vec2,vec2,vec2);\nvoid  draw(float,inout vec4);\nconst float FILL=1., CONTOUR=0.;\nvec4 COL = vec4(0); float fill=FILL, S=1., contrast=1.;  // style state\nfloat d = 1e38;   // global to allow unique distance field\n\n// === SVG drawing ===============================================================\nvoid SVG(vec2 uv, inout vec4 O) \n{\n    float _x, _y, x0, y0; // d = 1e38; \n    uv *= 400.;                             // scaling\n    contrast = 1.;\n\n// Copy-paste your SVG pathes here.  Slight adaptations : \n//  - add () around command params and  comma between points, \n//  - split polylines and polybÃ©ziers into sets of 1 vs 3 pairs of coordinates\n//  - path( style( FILL/CONTOUR, color(hexa) )\n//          commands \n//        )    \n\n// nvidia logo from https://upload.wikimedia.org/wikipedia/fr/4/47/Nvidia_%28logo%29.svg\n\n    path( style(FILL,0x74b71b)              // left exterior arc\n        M( 82.2115,102.414  )\n        C( 82.2115,102.414, 104.7155,69.211, 149.6485,65.777 )\n        L( 149.6485,53.73   )\n        C( 99.8795,57.727, 56.7818,99.879,  56.7818,99.879   )\n        C( 56.7818,99.879, 81.1915,170.445, 149.6485,176.906 )\n        L( 149.6485,164.102 )\n        C( 99.4105,157.781, 82.2115,102.414, 82.2115,102.414 ) \n        z\n    )\n  \n    path( style(FILL,0x74b71b)            // left interior arc\n    \tM( 149.6485,138.637 )\n    \tL( 149.6485,150.363 )\n    \tC( 111.6805,143.594, 101.1415,104.125, 101.1415,104.125 )\n    \tC( 101.1415,104.125, 119.3715,83.93,   149.6485,80.656  )\n    \tL( 149.6485,93.523  )\n    \tC( 149.6255,93.523, 149.6095,93.516,  149.5905,93.516   )\n    \tC( 133.6995,91.609, 121.2855,106.453,  121.2855,106.453 )\n    \tC( 121.2855,106.453, 128.2425,131.445, 149.6485,138.637 ) \n    )\n\n    path( style(FILL,0x74b71b)            // right main plate\n    \tM( 149.6485,31.512  )\n    \tL( 149.6485,53.73   )\n    \tC( 151.1095,53.617,  152.5705,53.523,  154.0395,53.473  )\n    \tC( 210.6215,51.566,  247.4885,99.879,  247.4885,99.879  )\n    \tC( 247.4885,99.879,  205.1455,151.367, 161.0315,151.367 )\n    \tC( 156.9885,151.367, 153.2035,150.992, 149.6485,150.363 )\n    \tL( 149.6485,164.102 )\n    \tC( 152.6885,164.488, 155.8405,164.715, 159.1295,164.715 )\n    \tC( 200.1805,164.715, 229.8675,143.75,  258.6135,118.937 )\n    \tC( 263.3795,122.754, 282.8915,132.039, 286.9025,136.105 )\n    \tC( 259.5705,158.988, 195.8715,177.434, 159.7585,177.434 )\n    \tC( 156.2775,177.434, 152.9345,177.223, 149.6485,176.906 )\n    \tL( 149.6485,196.211 )\n    \tL( 305.6805,196.211 )\n    \tL( 305.6805,31.512  )\n    \tL( 149.6485,31.512  )\n    \tz\n    )\n\n    path( style(FILL,0x74b71b)            // right interior arc\n    \tM( 149.6485,80.656  )\n    \tL( 149.6485,65.777  )\n    \tC( 151.0945,65.676, 152.5515,65.598, 154.0395,65.551     )\n    \tC( 194.7275,64.273, 221.4225,100.516, 221.4225,100.516   )\n    \tC( 221.4225,100.516, 192.5905,140.559, 161.6765,140.559  )\n    \tC( 157.2275,140.559, 153.2385,139.844, 149.6485,138.637  )\n    \tL( 149.6485,93.523  )\n    \tC( 165.4885,95.437, 168.6765,102.434, 178.1995,118.309   )\n    \tL( 199.3795,100.449 )\n    \tC( 199.3795,100.449, 183.9185,80.172, 157.8555,80.172    )\n    \tC( 155.0205,80.172, 152.3095,80.371, 149.6485,80.656     ) \n    )\n}\n\n// --- spline interpolation ( inspired from revers https://www.shadertoy.com/view/MlGSz3 )\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t)\n{\n    vec2 A = G4-G1 + 3.*(G2-G3),\n         B = 3.*(G1-2.*G2+G3),\n         C = 3.*(G2-G1),\n         D = G1;\n    return t * (t * (t * A + B) + C) + D;\n}\n\n\nfloat line(vec2 p, vec2 a, vec2 b) \n{\n\tvec2 pa = p - a, ba = b - a,\n\t     d = pa - ba * clamp(dot(pa, ba) / dot(ba, ba) , 0., 1.); // distance to segment\n    if  ( (a.y>p.y) != (b.y>p.y) &&\n           pa.x < ba.x * pa.y / ba.y ) S = -S;     // track interior vs exterior\n\treturn dot(d,d); //length(d);                  // optimization by deferring sqrt\n}\n// interior detection (sign S): ( thanks TimoKinnunen https://www.shadertoy.com/view/4lySWd )\n// see http://web.archive.org/web/20161116163747/https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html - previously on https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\nfloat bezier( vec2 uv, vec2 A, vec2 B, vec2 C, vec2 D)    \n{\n    //float d = 1e5;                               // for global field\n    vec2 p = A;\n    for (float t = 1.; t <= N; t++) {\n        vec2 q = interpolate(A, B, C, D, t/N);\n        float l = line(uv, p, q);\n        d = min(d, l );\n\t\tp = q;\n\t}\n\treturn d;\n}\n\nvoid draw(float d, inout vec4 O) \n{\n    d = min(sqrt(d)*contrast*2.,1.);             // optimization by deferring sqrt here\n    O = mix(COL, O, fill>0. ? .5+.5*S*d : d);    // paint \n}\n\nvoid mainImage(out vec4 O, vec2 U) \n{\n    O = vec4(1);\n    vec2 R = iResolution.xy;\n    U.y = R.y-U.y; U /= R.x;\n\tSVG( U, O );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}