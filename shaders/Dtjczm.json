{
    "Shader": {
        "info": {
            "date": "1691602121",
            "description": "further simplifying  of https://shadertoy.com/view/DdXSD4  \nthat was simplifying \"Void And Cluster Bluenoise\" by krax  [url]https://www.shadertoy.com/view/cdfSD8[/url]\nLeft: krax algo with sigma = 2.5\nRight: shadertoy bluenoise.",
            "flags": 32,
            "hasliked": 0,
            "id": "Dtjczm",
            "likes": 13,
            "name": "Void And Cluster Bluenoise -spl2",
            "published": 3,
            "tags": [
                "noise",
                "bluenoise"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "// further simplifying  https://shadertoy.com/view/DdXSD4\n// simplifying \"Void And Cluster Bluenoise\" by krax. https://shadertoy.com/view/cdfSD8\n// from ref: https://alister-chowdhury.github.io/posts/20221230-bluenoise-generator/\n// Deeper simplif and optim here: https://www.shadertoy.com/view/mt2cWR\n\n// more reading: https://momentsingraphics.de/BlueNoise.html#The_void_and_cluster_method\n// about variance: larger → more LF but more isotropic.  very low → Bayer. Best compromise ~1.9, but shadertoy one ~ 2.5\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n // O = vec4(texelFetch(iChannel2, ivec2(u), 0).x!=0.); return; // for debug\n \n    vec2 R = iResolution.xy, U = u/R;\n    if ( int(u) == int(R)/2 ) { O = vec4(1, U.y > float(iFrame)/(s*s),0,0); return; } // reference shadertoy bluenoise\n    if ( U.x>.5 ) { O = texelFetch(iChannel1, ivec2(u)%1024, 0 ).xxxx; return; } // red separator\n\n#if 1\n    u = s*fract(u/s);\n#else \n    u *= s/R;\n#endif \n\n    O = T(u.x,u.y).xxxx;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int S = 64;           // bluenoiseSize = SxS , cycling tile\nfloat  s = float(S);\n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n\nint H(uvec3 Seed)                                   // hash function\n{\n    uint  hx = 0xb543c3a6u ^ Seed.x,\n          hy = 0x526f94e2u ^ Seed.y,\n         hz0 = 0x53c5ca59u ^ (hx*hy >> 5u),\n         hz1 = 0x74743c1bu ^ Seed.z;\n    return int( hz0 * hz1 );\n}\n\n\n# if 1 \n\n#define INIT(S,SEED)   /* SEED ignored in my version */                 \\\n    if( U.x>float(S) || U.y>float(S) ) return; /* we only simulate a small square */ \\\n    O = vec4( 1e35, 0,0,0);                                             \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ), /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                \\\n    int x,y;\n        \n#define M(S,s,c)                                                        \\\nvoid mainImage( out vec4 O, vec2 U ) {                                  \\\n    INIT( S,  s );                                                      \\\n    for( y=start.y; y<end.y; ++y)                                       \\\n    for( x=start.x; x<end.x; ++x)                                       \\\n     {                                                                  \\\n        vec4 E = T(x,y);                                                \\\n        c;                           /* store result */                 \\\n}   } \n\n\n#else // original version. But the order scrambling seems useless to me, since energy can't be symmetrical due to initial hash\n\n#define INIT(S,SEED)                                                    \\\n    O = vec4( 1e35, 0,0,0);                                             \\\n    ivec2   start = min( ivec2(U) << 3, S - 1 ),                        \\\n              end = min( start + 8, S );                                \\\n    /* Reduce 8x8 at a time, but mix up the order of comparison */      \\\n    /* to prevent biasing in any one location */                        \\\n    int yh = H(uvec3(start + 1, SEED)) >> 20,                           \\\n        xh = H(uvec3(start + ivec2(13, 11), yh)) >> 19, x,y,i,j;\n        \n#define M(S,s,c)                                                        \\\nvoid mainImage( out vec4 O, vec2 U ) {                                  \\\n    INIT( S,  s );                                                      \\\n    for( j=0; j < 8; ++j ) {                                            \\\n        y = start.y + ((yh ^ j) & 7);                                   \\\n        if(y < end.y)                                                   \\\n            for( i=0; i < 8; ++i ) {                                    \\\n                x = start.x + ((xh ^ i) & 7);                           \\\n                if(x < end.x) {                                         \\\n                    vec4 E = T(x,y);                                    \\\n                    c;                           /* store result */     \\\n}   }       }   }\n\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background\n// energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if( U.x>s || U.y>s ) return; // we only simulate a small (cyclicling) square\n\n    if(iFrame == 0)              // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, intBitsToFloat(H(uvec3(U, 2111)) & 0x1fffffff) );\n        return;\n    }\n    \n    O = T(U.x,U.y);              // previous state\n    if(iFrame > S*S-1) return;   // max iteration reached\n \n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).yz ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s*s-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n    vec2 d = ( abs( U - .5 ) - .5 )  * s / 2.5 ;  // sigma = 2.5\n                                                  // $FaN: krax used 1.9 and fract(U)\n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -dot(d,d) ) );         // energy += gaussian to optimum\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Void and cluster reduce init\n// input: SxS state noise,energy.\n// output: .xyz = lowest energy value + position on SxS  ( and not already chosen ). could have been/8 with modulo fetch\n\nM( S , \n   floatBitsToInt(iTime) ^ int(iFrame) ,                   // seed: useless in my version\n   if( E.x == 0. && E.y < O.x ) O = vec4( E.y, x, y, 0)\n )",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Void and cluster reduce iteration\n// input: SxS state energy,location\n// output: .xyz = lowest energy value + position on SxS /8 ( and not already chosen ). could have been/8 with modulo fetch\n\nM( (S+7)/8,                                            // or just S/8 if S = power of 2\n   H(floatBitsToUint(iDate.yzw * iTime)) ^ iFrame,     // seed. useless in my version\n   if( E.x < O.x ) O = E\n )",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Final reduction, no 8x8 tiling, since we have no more buffers.\n// input: SxS /8 state energy,location\n// output: .xyz = lowest energy value + position on SxS /8²    ( and not already chosen )\n\nM( (S+63) /64, 0,                // or just S/64 if S = power of 2\n   if ( E.x < O.x ) O = E;       // seed. useless in my version\n )\n\n/* original: \n\nvoid mainImage( out vec4 O, vec2 U )\n{\nINIT( (S+63) /64, 0 );\n    \n    for( y=start.y; y<end.y; ++y)\n    for( x=start.x; x<end.x; ++x)\n    {\n        vec4 E = T(x,y);\n        if ( E.x < O.x ) O = E; \n    }\n}\n*/    \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}