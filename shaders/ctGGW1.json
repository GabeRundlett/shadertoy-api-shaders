{
    "Shader": {
        "info": {
            "date": "1683950860",
            "description": "My take on the popular \"negative space becomes positive space\" illusion genre.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctGGW1",
            "likes": 17,
            "name": "Dancing Tiles Illusion (628 ch)",
            "published": 3,
            "tags": [
                "illusion",
                "squares",
                "floating",
                "codegolf"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  My take on the popular \"negative space becomes positive space\" illusion genre.\n//\n//  This shader seems like the kind of thing that is amenable to golfing, but I feel like\n//  I'm still missing something big. Maybe there is a more compact noise function?\n//\n// ---------------------------------------------------------------------------------------\n\n// From FabriceNeyret2: (628 chars)\n\n//*\n#define R(X) mat2(cos( X * 3.14 + vec4(0, 11, 33, 0)))                 //\n#define c   ( vec4(.3, .6, 1, 1) - r* vec4(-.2,.5,.5,0) )              //\n#define S(v) smoothstep(v,0.,d)                                        //\n#define L                                                               \\\n        d = 1.;                                                         \\\n        for (int k=0; k<9; k++)                                         \\\n            P = vec2(k%3,k/3) - .5,                                     \\\n            h = fract(1e4*sin(trunc(vec3(u + P + .5, t))                \\\n             * mat3(R+17.,R+51.,57.-R))) -.5,                           \\\n            D = abs( ( fract(u) - P + h.xy * R(t) * M )                 \\\n                    * R( .8 - trunc( h.z*12. + sign(h.z) ) * fract(t) ) \\\n                   ) - .354,                                            \\\n            d = min(d, length(max(D,0.)) + min(max(D.x,D.y),0.));       \\\n        O \n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3  R = iResolution, h;\n    float t = iTime / 8.,\n          m = abs( fract(t) - .5), d=m, M = S(.5),\n          r = fract(t * .5) > .5 ? 1. : 0.,   \n          z = 4. - 2.*cos(t);\n    vec2  P, D;\n          u = z * ( u+u - R.xy ) / R.y + r*.5;\n    z *= 3./R.y;\n    L = c *(1.-.5*S(  M *.1 + z));\n    d = m-.25, u += vec2(.2, -.2) * S(.25);\n    r = 1. - r; L += (c-O)*  S(z);\n}\n\n\n/**/\n\n\n// Golfed by me: (735 ch)\n\n/*\n\n#define R(X) mat2(cos((X) * 3.14 + vec4(0, 11, 33, 0)))\n#define c(X) mix(vec4(.3, .6, 1, 1), vec4(.5, .1, .5, 1), X)\n#define S smoothstep\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t = iTime / 8.,\n          m = abs(fract(t) - .5),\n          r = fract(t * .5) > .5 ? 1. : 0.,\n          s = 0., x, y, d, R = iResolution.y;\n    \n    u = (8. - cos(t) * 4.) * (u - .5 * iResolution.xy) / R + r * .5;\n    \n    for (O = c(r); s < 2.; ++s)\n    {\n        d = 1e6;\n        for (x = -1.; x <= 1.; ++x)\n        for (y = -1.; y <= 1.; ++y)\n        {\n            vec3 h = fract(vec3(trunc(u + vec2(x, y) + 10.), trunc(t)) * vec3(.1, .11, .01));\n            h += dot(h, h.yxz+33.33);\n            h = fract((h.xxy + h.yxx)*h.zyx) - .5;\n            \n            vec2 v = (fract(u) - .5 - vec2(x, y) + h.xy * R(t) * S(.5, 0., m))\n                     * R(-trunc(h.z * 12. + sign(h.z)) * fract(t) + .25),\n                 D = abs(v) - .354;\n                 \n            d = min(d, length(max(D,0.)) + min(max(D.x,D.y),0.));\n        }\n        \n        u += vec2(.2, -.2) * smoothstep(.5, .25, m);\n        O = mix(O, s < 1. ? O * .5 : c(1. - r), S((1. - s) * S(.5, 0., m) * .1 + 3. / R, 0., d));\n    }\n}\n/**/\n\n// Original: 1038 chars\n\n/*\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r + vec4(0, 11, 33, 0)));\n}\n\n// Dave_Hoskin's Hash Without Sine: https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nconst float PI = 3.14159;\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    float t = (iTime - .5) * .125;\n    float m = fract(t);\n    float r = float(fract(t * .5) > .5);\n    \n    u = (8. - cos(t) * 4.) * (u - .5 * iResolution.xy) / iResolution.y + (r * vec2(.5));\n    \n    O = mix(vec4(.3, .6, 1, 1), vec4(.5, .1, .5, 1), r);\n    \n    for (float s = 0.; s < 2.; ++s)\n    {\n        float md = 1e6;\n        for (float x = -1.; x <= 1.; ++x)\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            vec2 id = trunc(u + vec2(x, y) + 100.);\n            vec3 h = hash33(vec3(id, trunc(t)) + 130.) - .5;\n            vec2 off = h.xy * rot(PI * t) * smoothstep(.5, 0., abs(m - .5));\n            vec2 v = fract(u) - .5 - vec2(x, y);\n            v += off;\n            v *= rot(PI * (-trunc(h.z * 12. + sign(h.z)) * m + .25));\n\n            float d = sdBox(v, vec2(.5/sqrt(2.)));\n            md = min(md, d);\n        }\n        \n        u += vec2(.2, -.2) * smoothstep(.5, .25, abs(m - .5));\n        O = mix(O, s < 1. ? O * .5 : mix(vec4(.5, .1, .5, 1), vec4(.3, .6, 1, 1), r),\n            smoothstep((1. - s) * smoothstep(.5, 0., abs(m - .5)) * .1 + 3. / iResolution.y, 0., md));\n    }\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}