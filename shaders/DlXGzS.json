{
    "Shader": {
        "info": {
            "date": "1671890396",
            "description": "Still A-life, Pointillism shader",
            "flags": 0,
            "hasliked": 0,
            "id": "DlXGzS",
            "likes": 6,
            "name": "Still A-life, Pointillism shader",
            "published": 3,
            "tags": [
                "raymarching",
                "phong",
                "sdf",
                "painting",
                "pointillism",
                "stilllife"
            ],
            "usePreview": 0,
            "username": "yunChenLee_329",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "// Author: Yun-Chen Lee yclee@arch.nycu.edu.tw\n// Project: Still A-life, Pointillism shader\n// Date: 2022/12/22\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\n\n//=== noise ===//\n//-----------------------------------------------------------------\nvec3 normalMap(vec3 p, vec3 n);\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//=== distance functions ===//\n//-----------------------------------------------------------------\n// Rotate function\nmat2 Rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}  \n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n    n = normalize(n);\n    return dot(p,n) + h;\n}\n\nfloat sdSphere( vec3 p, float s, vec3 rotation, vec3 scale )\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    return length(bp)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    vec3 d = abs(bp) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    float q = length(bp.xz);\n    return max(dot(c.xy,vec2(q,bp.y)),-h-bp.y);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    vec2 d = abs(vec2(length(bp.xz),bp.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    bp = abs(bp);\n    bp.xy -= 2.0*min(dot(k.xy, bp.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(bp.xy-vec2(clamp(bp.x,-k.z*h.x,k.z*h.x), h.x))*sign(bp.y-h.x),\n       bp.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(in vec3 p)\n{\n    float dist;\n\n    float sd_plane = sdPlane(p,vec3(0.0,1.0,1.0),0.38);\n    float sd_box = sdBox(p+vec3(0.0,0.2,0.0), vec3(0.4, 0.4, 0.4),vec3(0.628,0.0,0.2), vec3(2.0));\n    dist = min(sd_plane,sd_box);\n    \n    float sd_sphere = sdSphere(p+vec3(-0.03,-0.04,-0.35), 0.2, vec3(0.0), vec3(1.0));\n    dist = min(dist, sd_sphere);\n\n    float sd_cone = sdCone(p+vec3(0.48,0.1,-0.45), vec2(0.8,0.25),0.8,vec3(-0.628,0.0,0.0), vec3(1.0));\n    dist = min(dist, sd_cone);\n\n    float sd_cappedCylinder = sdCappedCylinder(p+vec3(0.48,0.26,-0.3),0.3,0.1,vec3(0.628,0.0,-0.9), vec3(1.0));\n    dist = min(dist,sd_cappedCylinder);\n\n    float sd_hex = sdHexPrism(p+vec3(-0.45,0.45,-0.15),vec2(0.12,0.5), vec3(-0.9,-0.6,0.0), vec3(1.0));\n    dist = min(dist,sd_hex);\n\n\n    return dist;\n}\n\n//=== gradient functions ===//\n//-----------------------------------------------------------------\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===//\n//-----------------------------------------------------------------\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\n    float d=0.0, t=0.0;\n    for (int i=0; i<30; ++i)\n    {\n        p= o+r*t;\n        d=map(p);\n        if(d<0.0) break;\n        t += d*0.6; //影響輪廓精準程度\n        }\n    return t;\n}\n\nfloat traceInner(vec3 o,vec3 r,out vec3 p)\n{\n    float d=0.,t=0.01;\n    for(int i=0;i<32;++i)\n    {\n        p=o+r*t;\n        d=-map(p);\n        if(d<0.001 || t>10.0) break;\n        t+=d*.5;//影響輪廓精準程度\n    }\n    return t;\n}\n\n\n\n//=== camera functions ===//\n//-----------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n\n//=== phong shading ===//\n//-----------------------------------------------------------------\n// thank 仁愷!\nstruct Light{\n    vec3 p; // position\n    vec3 ia;\n    vec3 id; // diffuse color\n    vec3 is; // specular color\n};\n\nstruct Mat{    \n    float ka; // factor of abient\n    float kd; // factor of diffuse\n    float ks; // factor of specular\n    float s; // shiness\n};\n\nvec3 phongShading(Light light, Mat m, vec3 p, vec3 n, vec3 v, out vec3 ambient, out vec3 diffuse, out vec3 specular, out float shadow){\n\n    vec3 L = normalize(light.p-p);\n    vec3 r = normalize(reflect(-L,n));\n\n    ambient = m.ka*light.ia;\n    diffuse = m.kd*dot(L,n)*light.id;\n    specular = m.ks*pow(max(dot(r,v),0.0),m.s)*light.is;\n\n    vec3 diffWithShadow = diffuse;\n    vec3 temp;\n    float d = trace(p+n*0.03, L, temp);\n    if(d<length(light.p-p)) {\n        shadow = 0.0;\n        diffWithShadow *= 0.1;\n    }\n    else shadow = 1.0;\n\n    vec3 result;\n    // result = ambient + diffuse + specular;\n    result = ambient + diffWithShadow + specular;\n\n    return result;\n    \n}\n\n//=== dot brush ===//\n//-----------------------------------------------------------------\nfloat getMask(float r, float scl, float div, vec2 uv, vec2 offset){\n    // float mask = step(r*scl, length(mod((uv + offset)*div,1.)*2.-1.));\n    float mask = step(r*scl,length(random2(floor((uv+offset)*div))-fract(uv*div)));\n    if(mask>0.1) mask = 1.;\n    else mask = 0.;\n    return mask;\n}\n\nvec3 setColor(float mask, vec3 clr){\n    vec3 result = vec3(1.);\n    if(mask==0.) result = clr;\n    return result;\n}\n\nvec3 mixColor(vec3 clr1, vec3 clr2, float ratio){\n    vec3 result = vec3(1.0);\n\n    if(clr1.r<1.|| clr1.g<1.|| clr1.b<1.){\n        if(clr2 == vec3(1.)) result = clr1;\n        else result = mix(clr1,clr2,ratio);\n    }\n    else if(clr2.r<1.|| clr2.g<1.|| clr2.b<1.){\n        if(clr1 == vec3(1.)) result = clr2;\n        // else result = mix(clr1,clr2, ratio);\n        // else result = vec3(0.);\n        // if(clr1!=vec3(1.)) result = vec3(0.);\n    }\n    return result;\n}\n\n//=================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    uv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n    // camera option1  (模型應在原點，適用於物件)\n\t// vec3 CameraRot=vec3(0.0, mouse.y, -mouse.x); \n   \n    vec3 CameraRot=vec3(0.0, -0.7, 0.0);  \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\n    // vec3 CameraRot=vec3(u_time ,0.0, 0.0);  \n    // vec3 CameraRot=vec3(0.0,-mouse.y*3.0, mouse.x*3.0);\n\t// vec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\t\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    \n    vec3 bump = normalMap(p*10.0,n);\n    // // n=n+bump*0.05;\n    \n    \n    float edge = dot(-RayDir,n);\n    edge = smoothstep(-0.3,0.3,edge);\n    \n\n    // if(t<2.5) result = result; else result = vec3(0.9);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n\n    // mask\n    // float r = 1.0-(result.r+result.g+result.b)/3.0;\n    // float div = 40.0;\n    // float circleMask = step(r*1.2,length(mod((uv+bump.xy*0.005)*div,1.0)*2.0-1.70));\n    // float circleMask = step(r*1.2,length(mod((uv)*div,1.0)*2.0-1.0));\n\n    // float circleMask2 = step(r*1.2,length(mod((uv+vec2(0.0,0.01)+bump.xy*0.005)*div,1.0)*2.0-1.0));\n\n    // vec3 col1 = vec3(1.0-circleMask)*vec3(0.0,0.0,1.0);\n    // vec3 col2 = vec3(1.0-circleMask2)*vec3(1.0,0.0,0.0);\n\n    // vec3 col = mix(col1,col2,0.4);\n\n    // phong shading\n    Light l1 = Light(vec3(20.*sin(iTime/3.),10.+5.*sin(iTime/5.),20.+10.*cos(iTime/3.)),vec3(.7),vec3(1.0),vec3(1.));\n    Mat m1 = Mat(1.,1.,1.,1.);\n    vec3 amb1, diff1, spec1, result1;\n    float shdw1;\n    result1 = phongShading(l1, m1, p, n, -RayDir, amb1, diff1, spec1, shdw1);\n\n    Light l2 = Light(vec3(0.+5.*sin(iTime/3.),10.+8.*sin(iTime/4.),0.), vec3(.7),vec3(1.),vec3(1.));\n    Mat m2 = Mat(1.,1.,1.,10.);\n    vec3 amb2, diff2, spec2, result2;\n    float shdw2;\n    result2 = phongShading(l2, m2, p, n, -RayDir, amb2, diff2, spec2, shdw2);\n\n    // SSS\n    vec3 p1, n1;\n    float ior = 1.31;\n    vec3 RayDir1 = refract(p-l1.p,n,1.0/ior);  // material A -> B\n    // vec3 RayDir1 = refract(RayDir,n,1.0/ior);  // material A -> B\n    float t1 = traceInner(p,RayDir1, p1);\n\n    // color -----------------------------------------\n    // float siz = 1.3+sin(u_time)*0.5;\n    float siz = 1.;\n    // float mask1 = getMask(1.0-(result1.r+result1.g+result1.b)/3.0, 1.2, 40., uv, vec2(0.,0.01));\n    // vec3 layer1 = setColor(mask1, vec3(1.0,0.0,0.0));\n\n    // background\n    // float mbx = getMask(0.8+bump.x*0.5, 1.0,59.0,uv,0.002*vec2(bump.y,bump.z));\n    float mbx = getMask(0.3+bump.x*0.05, 1.0,58.0*siz,uv,0.002*vec2(bump.y,bump.z));\n    vec3 dbx = setColor(mbx, vec3(0.67, 0.82, 1.));\n\n    float mby = getMask(0.3+bump.y*0.05, 1.0,40.0*siz,uv,0.002*vec2(0.01+bump.x, bump.z));\n    vec3 dby = setColor(mby,vec3(1., 0.89, 0.85));\n\n    vec3 result = mixColor(dbx,dby,0.5);\n    // vec3 result = mix(dbx,dby,0.5);\n\n    float mbz = getMask(0.7+bump.z*0.5, 1.0,47.0*siz,uv,0.002*vec2(bump.x, bump.z));\n    vec3 dbz = setColor(mbz,vec3(0.71, 0.96, 0.95));\n\n    result = mixColor(result,dbz,0.5);\n    \n    // // toon\n    vec3 rt;\n    if(t<2.5)  rt = 1.0-vec3(floor(result1*2.0)/2.0);else rt = vec3(1.0);\n    // vec3 rt = 1.0-vec3(floor(result1*2.0)/2.0);\n    vec3 toon1 = vec3(1.), toon2 = vec3(1.), toon3 = vec3(1.);\n    if(rt.x < .01) toon1 = vec3(0.0);\n    if(rt.x > .2 && rt.x < .9) toon2 = vec3(0.0);\n    // if(result_toon.x > .9) toon3 = vec3(.0);\n\n    float mt1 = getMask((1.0-(toon1.x+toon1.y+toon1.z)/3.0)*0.4+bump.y*0.0, 1.0,60.0*siz,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    // float mt1 = getMask((1.0-(toon1.x+toon1.y+toon1.z)/3.0)*0.4+bump.y*0.0, 1.0,60.0,uv,vec2(0.));\n    vec3 dt1 = setColor(mt1, vec3(0., 0.5, 0.88));\n    float mt2 = getMask((1.0-(toon2.x+toon2.y+toon2.z)/3.0)*0.4+bump.y*0.0, 1.0,55.0*siz,uv,0.002*vec2(0.03+bump.y, 0.05+bump.x));\n    // float mt2 = getMask((1.0-(toon2.x+toon2.y+toon2.z)/3.0)*0.4+bump.y*0.0, 1.0,55.0,uv,vec2(0.));\n    vec3 dt2 = setColor(mt2, vec3(0., 0.73, 1.));\n    // float mt3 = getMask((1.0-(toon3.x+toon3.y+toon3.z)/3.0)*0.4+bump.y*0.0, 1.0,45.0,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    // vec3 dt3 = setColor(mt3, vec3(0.0235, 1.0, 0.9529));\n\n    vec3 temp = mixColor(dt1,dt2,0.5);\n    // temp = mixColor(temp,dt3,0.5);\n    result = mixColor(result,temp,0.5);\n\n    // diffuse\n    if(t<2.5)  diff1 = diff1;else diff1 = vec3(1.0);\n    // float md1 = getMask((1.0-(diff1.x+diff1.y+diff1.z)/3.0)*0.4+bump.y*0.0, 1.0,69.0,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    float md1 = getMask((1.0-(diff1.x+diff1.y+diff1.z)/3.0)*0.4+bump.y*0.0, 1.0,69.0*siz,uv,vec2(0.));\n    // vec3 dd1 = setColor(md1, vec3(0.078, 0.34, 0.22));\n    vec3 dd1 = setColor(md1, vec3(0.2196, 0.1725, 0.6471));\n    result = mixColor(result,dd1,0.5);\n\n\n    // light2 diff\n    if(t<2.5)  diff2 = diff2;else diff2 = vec3(1.0);\n    // float md2 = getMask((1.0-(diff2.x+diff2.y+diff2.z)/3.0)*0.4+bump.y*0.0, 1.0,40.0,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    float md2 = getMask((1.0-(diff2.x+diff2.y+diff2.z)/3.0)*0.4+bump.y*0.0, 1.0,40.0*siz,uv,vec2(0.));\n    vec3 dd2 = setColor(md2, vec3(0.89, 0.49, 0.27));\n    result = mixColor(result,dd2,0.2);\n\n    \n\n    // shadow\n    float msd = getMask((1.-shdw1)*0.4, 1.0,73.0*siz,uv,vec2(0.));\n    vec3 dsd = setColor(msd, vec3(0.15, 0.22, 0.3));\n    result = mixColor(result,dsd,0.6);\n\n    // sss\n    if (t>2.5) t1=1.;\n    t1 = step(t1,0.5);\n    float msss = getMask(((t1)*0.3), 1.0,60.0*siz,uv,vec2(0.));\n    vec3 dsss = setColor(msss, vec3(1.0, 0.85, 0.17));\n    result = mixColor(result,dsss,0.5);\n\n    // sepcular\n    float msp = getMask((length(spec1))*0.3, 1.0,75.0*siz,uv,vec2(0.));\n    result += (1.-msp);\n\n    float msp2 = getMask((length(spec2))*0.5, 1.0,75.0*siz,uv,vec2(0.));\n    result += (1.-msp2);\n\n    fragColor = vec4(vec3(result),1.0);\n}\n\n//=================================================================\n\n\n\n\n\n//=== 2d noise functions ===//\n//-----------------------------------------------------------------\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//=== 3d noise functions p/n ===//\n//-----------------------------------------------------------------\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}