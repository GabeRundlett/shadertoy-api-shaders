{
    "Shader": {
        "info": {
            "date": "1626660198",
            "description": "A gray bamboo forest based off of the Arashiyama Bamboo Forest and the bamboo forest near the fox shrine that I visited while in Japan.",
            "flags": 0,
            "hasliked": 0,
            "id": "ftfSWH",
            "likes": 4,
            "name": "Bamboo Forest",
            "published": 3,
            "tags": [
                "raymarching",
                "forest",
                "bamboo"
            ],
            "usePreview": 0,
            "username": "will7007",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "// Fork of \"Donut factory\" by anclin. https://shadertoy.com/view/MsffDS\n// 2021-07-05 22:22:34\n\n// I was going to make things much more complex with crepuscular rays, textures, curving bamboo\n// trunks, and moving leaves (among other things), but I wanted to have a \"good enough\" version to\n// wrap things up and just get this thing out the door!\n\nconst float EPSILON = 0.001;\n\nconst vec3 leafColorDark = vec3(0x58, 0x66, 0x0f)/255.;\nconst vec3 leafColorLight = vec3(0xc0, 0xc0, 0x6e)/255.;\nconst vec3 trunkColor = vec3(0xb1, 0xb5, 0xb1)/255.;\n\n// credit to iq for making these SDF transforms/shapes\nfloat opExtrussion(in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nfloat bamboo(vec3 origin, float height, float radius) {\n  float radiusBumpy = max(-.02*abs(sin(10.*origin.y))+radius,radius-.002);\n  origin.y -= clamp(origin.y, 0.0, height);\n  return length(origin) - radiusBumpy;\n}\n\nfloat leaves(vec3 origin, float h, float distortion) {\n    // don't look too closely at these crazy, distorted \"leaves\"!\n    origin.y -= h;\n    float c = opExtrussion( origin, sdCircle( vec2(origin.x,origin.z), .5 ), 0.6 );\n    return c-.7*sin(distortion*origin.x)*sin(distortion*origin.y)*sin(distortion*origin.z);\n}\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\nfloat SceneSDF(vec3 p){\n    //p = rotateY(iTime * 0.2) * p;\n    float smallest = 5.;\n    float d = 100.;\n    vec3 xyz = fract(p);  // point within a grid cell\n    xyz.y = p.y;  // we want the absolute y position in the grid cell for correctly calculating notches\n    vec2 id = floor(p.xz);  // the grid cell we are in\n    \n    for(float y=-1.; y <= 1.; y++) {  // look at the neighboring cells\n        for(float x=-1.; x <= 1.; x++) {  // to see which cell has a point that is the closest to our pixel\n            vec2 off = vec2(x, y);\n            vec2 coord = id+off;\n            vec2 n = N22(id+off);\n            \n            // calculate the point, then add the offset to it\n            // so that the point is moved into its own grid cell\n            // this is the origin for the purposes of this grid cell (i.e. the place where the bamboo trunk is centered)\n            // and xyz is the pixel where we are, so we measure from xyz->point since we want to know dist from point->origin\n            vec2 point = off+n;\n            \n            // dist between Voronoi point and current pixel RELATIVE TO GRID\n            // because the point is created relative to the grid\n            // so there won't be any Voronois if uv goes too far from the origin\n            vec3 gridCenter = vec3(xyz.x-point.x,xyz.y,xyz.z-point.y);\n            \n            d = bamboo(vec3(gridCenter),20.,.05);\n            d = min(d,leaves(gridCenter,21.9,20.));\n            \n            smallest = (d < smallest) ? d : smallest;\n        }\n    }\n    return smallest;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 255; i++){\n        vec3 pos = eye + depth * marchingDirection;\n        //if(pos.y >= 30.) break;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    float t = iTime*0.05;\n    vec3 eye = vec3(30.0+10.0*sin(t),3.,10.*cos(t));\n    \n    vec3 lookAtPos = vec3(1.0,40.,1.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = (viewToWorld*vec4(rayDir,0)).xyz;\n    \n    vec4 shortDist = ShortestDistanceToSurface(eye,worldDir,0.,100.0);\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 lightPos = vec3(.5,1.5,.5);\n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse,0.);\n    \n    vec3 finalColor = vec3(0);\n\n    if(shortDist.y >= 21.35) {\n        finalColor = leafColorLight;\n    } else if(shortDist.y >= 20.) {\n        finalColor = leafColorDark;\n    } else {\n        finalColor = trunkColor;\n    }\n\n    vec3 ambientColor = vec3(.4);\n    finalColor = finalColor*(diffuse+ambientColor);\n\n\tfragColor = vec4(finalColor,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}