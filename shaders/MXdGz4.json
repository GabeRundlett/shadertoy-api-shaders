{
    "Shader": {
        "info": {
            "date": "1716210505",
            "description": "Pixel Rick!",
            "flags": 0,
            "hasliked": 0,
            "id": "MXdGz4",
            "likes": 4,
            "name": "Fork Pixel Rick+Radiant MusicVis",
            "published": 3,
            "tags": [
                "rickandmorty",
                "rickmorty",
                "pixelrick",
                "pixelrick"
            ],
            "usePreview": 0,
            "username": "ArthurTent",
            "viewed": 173
        },
        "renderpass": [
            {
                "code": "// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n// This Shader will be available in ShaderAmp 1.0.1\n// 1.0 Release: 2024-05-25 @Towel Day @c-base Berlin\n\n// https://github.com/ArthurTent/ShaderAmp\n// https://chromewebstore.google.com/detail/shaderamp/pbgkhemojiabmajgkcgjelgpnpoddcgl\n\n// Merged Pixel Rick with Radiant Music Visualiser\n// https://www.shadertoy.com/view/4sVBWy\n// Radiant Music Visualiser\n// by Hazel Quantock 2018\n\n// https://www.shadertoy.com/view/tssyWB\n// Pixel Rick\n// by leviathwaite\n\n\n#define PI 3.14\n#define TWO_PI 6.28\n\n// colors\n#define colorBackground vec3(253.0 / 255.0, 253.0 / 255.0, 93.0 / 255.0)\n#define colorBlack vec3(0.0)\n#define colorHair vec3(0.659, 0.894, 1.0)\n#define colorSkin vec3(227.0 / 255.0, 211.0 / 255.0, 195.0 / 255.0)\n#define colorShirt vec3(0.659, 0.94, 1.0)\n#define colorWhite vec3(1.0)\n#define colorVomit vec3(0.788, 0.914, 0.729) // rgb(78.8%,91.4%,72.9%)\n#define colorVomitBorder vec3(0.69, 0.855, 0.678)// 69% red, 85.5% green and 67.8% blue.\n\n/////////////////////////////// References ///////////////////////////////////////\n// The Amazing World of Gumball - Created by emmasteimann\n// https://www.shadertoy.com/view/WtfGWn\n\n// The art of code youtube series by Bigwings\n// https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// Smiley\n// https://www.shadertoy.com/view/lsXcWn\n\n// Inigo Quilez's youtube\n// https://youtu.be/0ifChJ0nJfM\n// and site\n// https://iquilezles.org/articles/distfunctions2d\n\n\n\n// https://mortoray.com/2015/06/19/antialiasing-with-a-signed-distance-field/\n\n/*\nfloat DrawHair(vec2 uv)\n{\n    // uv *= -1.0;\n    // translate\n    uv.y -= 0.15;\n    // scale larger at top than bottom\n    uv.x *= uv.y - 0.99;\n  \treturn SpikeyCircle(uv, 11.0);\n}\n*/\n/*\nfloat shape(vec2 p) {\n  float r = length (p - vec2(0,.005) ) * 2.5 - .4,\n        a = atan(p.y + .07, p.x),\n        f = 1. - sin(mod(a * 6., 4.*.855) + a*.1) * .45,\n        w = .05;// w = fwidth(f); \n  return smoothstep( -w, w, r - p.y*.5 - f );\n}\n\nvec3 drawHair(vec3 color, vec2 p)\n{\n...\n  // best hair \n  color = mix(colorBlack, color, shape(p)) ;         // outline \n  return  mix(colorHair , color, shape(p*1.035) );   // fill \n}\n*/\n\n// better hair, but messy and needs to be higher on the y direction to look right\nvec3 drawHair(vec3 color, vec2 p)\n{\n  // translate\n  p.x -= 0.02;\n  // scale\n  p *= 0.8;\n  // scale height\n  p.y *= 0.8;\n\n  float r = length(vec2(p.x, p.y - 0.005)) * 2.5 - 0.4;\n  float a = atan(p.y + 0.07, p.x);\n\n  // best hair\n  // outline\n  // float f = (1.0 - sin(mod(a * 6.0, 4.0 * (0.855)) + a * 0.1) * 0.45);\n  float f = (1.0 - sin(mod(a * 6.0, 4.0 * (0.855))) * 0.45);\n\n  f = smoothstep(f, f + 0.05, r - (p.y * 0.5));\n    \n  color = mix(colorBlack, color, f);\n    \n  // fill \n  p *= 1.035;\n  r = length(vec2(p.x, p.y - 0.005)) * 2.5 - 0.4;\n  a = atan(p.y + 0.07, p.x);\n  f = (1.0 - sin(mod(a * 6.0, 4.0 * (0.85)) + a * 0.1) * 0.45);\n\n  f = smoothstep(f, f + 0.05, r - (p.y * 0.5));\n  color = mix(color, colorHair, 1.0 - f);\n    \n  return color;\n}\n\nvec3 ears(vec3 color, vec2 p)\n{\n    p = vec2(p.x - 0.35, p.y + 0.15);\n    float size = 0.1;\n    \n    // Ears\n\tfloat d = sdCircle(p, size);\n    color = mix(colorBlack, color, d);\n   \n    d = sdCircle(p * 1.09, size);\n   \tcolor = mix(colorSkin, color, d);\n    \n    // Ears\n    p = vec2(p.x + 0.7, p.y);\n    \n\td = sdCircle(p, size);\n    color = mix(colorBlack, color, d);\n   \n    d = sdCircle(p * 1.09, size);\n   \tcolor = mix(colorSkin, color, d);\n    return color;\n}\n\nvec3 head(vec3 color, vec2 p)\n{\n    // Head\n\tfloat d = sdCircle(p,0.5);\n    color = mix(colorBlack, color, d);\n   \n    d = sdCircle(p * 1.03,0.5);\n   \tcolor = mix(colorSkin, color, d);\n    return color;\n}\n\n// TODO consolidate arc methods\nfloat eyeOutline(vec2 p, float radius, float thickness)\n{\n    // Arc\n    float ta = -PI * 0.5; // 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = 2.5; // 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = thickness; //0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    \n    // distance\n    float len = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), radius, rb);\n    \n    return len;\n}\n\n// TODO consolidate arc methods\nfloat eyeLid(vec2 p, float radius, float thickness)\n{\n    // translate\n    p.y += 0.98;\n    // Arc\n    float ta = 3.14*(0.5+0.5*0.0);\n    float tb = 0.14; // 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = thickness; //0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    \n    // distance\n    float len = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), radius, rb);\n    \n    return len;\n}\n\nvec3 eyes(vec3 color, vec2 p)\n{\n    // Right Eyes\n    p = vec2(p.x - 0.18, p.y);\n    float size = 0.13;\n    float outlineOffset = 0.01;\n   \n    float d = sdCircle(p * 1.05, size);\n   \n    float d1 = sdCircle(vec2(p.x, p.y + 1.0), 1.0);\n    d = opIntersection(d, d1);\n   \tcolor = mix(colorWhite, color, d);\n    \n    // eye outline\n    d = eyeOutline(p, size + outlineOffset, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    // pupil\n    d = 0.2 + 0.1 * cos(atan(p.y, p.x)* 10.0);\n    d = smoothstep(d * 0.03 + 0.01, d * 0.03 + 0.02, length(p));\n    color = mix(colorBlack, color, d);\n    \n    // eyeLid\n    d = eyeLid(p, 1.0, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    // Left Eyes\n    p = vec2(p.x + 0.36, p.y);\n   \n    d = sdCircle(p * 1.05, size);\n    d1 = sdCircle(vec2(p.x, p.y + 1.0), 1.0);\n    d = opIntersection(d, d1);\n   \tcolor = mix(colorWhite, color, d);\n    \n    // eye outline\n    d = eyeOutline(p, size + outlineOffset, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    // pupil\n    d = 0.2 + 0.1 * cos(atan(p.y, p.x)* 10.0);\n    d = smoothstep(d * 0.03 + 0.01, d * 0.03 + 0.02, length(p));\n    color = mix(colorBlack, color, d);\n    \n    // eyeLid\n    d = eyeLid(p, 1.0, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    return color;\n}\n\n// TODO consolidate arc methods\nfloat bagsArc(vec2 p, float radius, float thickness)\n{\n    // Arc\n    float ta = 3.14*(0.5+0.5*10.0);\n    float tb = 0.3; // 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = thickness; //0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    \n    // distance\n    float len = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), radius, rb);\n    \n    return len;\n}\n\nvec3 bags(vec3 color, vec2 p)\n{\n    p.y += 0.825;\n    vec2 centerP = p;\n    \n    // p.y *= 0.9;\n    \n    // edge\n    p = vec2(p.x - 0.22, p.y - 0.95);\n    float d = bagsArc(p, 0.2, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    // edge\n    p.x += 0.44;\n    p.y -= 0.115;\n    p.x *= 1.0;\n    d = bagsArc(vec2(p.x, p.y), 0.3, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    return color;\n\n}\n\nvec3 nose(vec3 color, vec2 p)\n{\n  p.y += 0.05;\n  p.y = -p.y;\n  float r1 = 0.05+0.1*0.01;\n  float r2 = 0.03+0.1*0.1;\n  float h = 0.15;\n  \n  float nose = sdUnevenCapsule( p, r1, r2, h );\n    \n  color = mix(colorBlack, color, nose);\n    \n  // Fill\n  p.y += 0.021;\n  r1 = 0.04+0.1*0.01;\n  r2 = 0.027+0.1*0.1;\n  h = 0.156;\n  \n  nose = sdUnevenCapsule( p, r1, r2, h );\n    \n  color = mix(colorSkin, color, nose);\n    \n  return color;\n}\n\n// TODO consolidate arc methods\nfloat mouthLine(vec2 p, float radius, float thickness)\n{\n    // translate\n    p.y += 0.98;\n    // Arc\n    float ta = 3.14*(0.5+0.5*0.0); // * 0.0 change starting point\n    float tb = 0.3; // 3.14*(0.5+0.5*cos(iTime*0.31+2.0)); // length\n    float rb = thickness; //0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    \n    // distance\n    float len = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), radius, rb);\n    \n    return len;\n}\n\n// TODO consolidate arc methods\nfloat mouthEdge(vec2 p, float radius, float thickness)\n{\n    // translate\n    p.y += 0.98;\n    // Arc\n    float ta = 3.14*(0.5+0.5*1.2);\n    float tb = 1.5; // 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = thickness; //0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    \n    // distance\n    float len = sdArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), radius, rb);\n    \n    return len;\n}\n\n/*\nfloat DrawMouth(vec2 uv)\n{\n  // position\n  uv.x -= 0.0;\n  uv.y += 0.06;\n  // curve\n  uv.y -= uv.x * uv.x * 1.5;\n  // end points\n  vec2 a = vec2(1.4, 0.85);\n  vec2 b = vec2(-1.4, 0.7);\n  // line width\n  float lWidth = 0.001;\n  float rLine = sdLineSegmentRounded(uv * 1.8, a, b, lWidth);\n  return rLine;\n}\n*/\n\nvec3 mouth(vec3 color, vec2 p)\n{\n    p.y += 0.3;\n    vec2 centerP = p;\n    \n    p.y *= 0.9;\n    \n    // edge\n    p = vec2(p.x - 0.22, p.y - 0.95);\n    float d = mouthEdge(p, 0.06, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    // edge\n    p.x += 0.44;\n    d = mouthEdge(vec2(-p.x, p.y), 0.06, -0.007);\n    color = mix(colorBlack, color, d);\n    \n    // mouth\n    centerP.y -= 0.23;\n    d = mouthLine(centerP, 0.75, -0.007);\n    color = mix(colorBlack, color, d);\n    return color;\n}\n\nvec3 brow(vec3 color, vec2 p)\n{\n    // brow\n    p.y -= 0.81;\n    \n\tvec2 v1 = vec2(-0.22, -0.5);\n    vec2 v2 = vec2(0.22, -0.5);\n    \n    // outline\n    float thickness = 0.04;\n\tfloat d = sdSegment( p, v1, v2, thickness);\n\t\n    color = mix(colorBlack, color, d);\n    \n    // fill\n    thickness = 0.04;\n\td = sdSegment( p, v1, v2, thickness - 0.01);\n\t\n    color = mix(colorHair, color, d);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // TODO shared rotated uv\n    vec2 uvRot = Rotate2D(-0.15) * uv;\n    \n    vec3 col = vec3(0.);\n    \n    // Hair Outline\n \t// color = mix(color, vec3(0.0), DrawHair(uvRot * 0.99));\n  \t// Hair\n  \t// color = mix(color, colorHair, DrawHair(uvRot));\n    \n    uv.y -=0.25;\n    float l = length(uv)/length(iResolution.xy/iResolution.y);\n    float a = atan(uv.x,uv.y)+iTime;\n    float s = texture(iChannel0,vec2(abs(fract(5.*a/6.283)*2.-1.),.75)).r;\n    \n    float A = .4;\n    float B = .45;\n    if ( iMouse.z > 0. )\n    {\n        A = iMouse.x / iResolution.x; // strength of chromatic dispersion\n        B = iMouse.y / iResolution.y; // strength of waveform\n    }\n    A *= A; // apply a curve so mouse movements feel better\n    B *= B;\n    vec3 col2 = vec3(0.);\n    col2.r = texture(iChannel0,vec2(pow(mix(mix(l,.0,A),    s ,B),2.),.25)).r;\n    col2.g = texture(iChannel0,vec2(pow(mix(mix(l,.5,A),(1.-s),B),2.),.25)).r;\n    col2.b = texture(iChannel0,vec2(pow(mix(mix(l,1.,A),    s ,B),2.),.25)).r;\n    \n    // tweak the contrast\n    col2.rgb = smoothstep(.05,1.,col2.rgb+.2*l);\n    col2.rgb = pow( col2.rgb, vec3(2) );\n    uv.y +=0.25;\n    \n    // Hair Outline2\n    if(iTime>17.)\n        col = drawHair(col, vec2(-uvRot.x, uvRot.y)*(.5+sin(iTime)/2.));\n    else\n        col = drawHair(col, vec2(-uvRot.x, uvRot.y));\n    col *=col2;\n    \n    col = ears(col, vec2(uv.x, uv.y));\n    col = head(col, vec2(uv.x * 1.35, uv.y * 0.825));\n    col = eyes(col, vec2(uv.x, uv.y - 0.125));\n    col = nose(col, Rotate2D(-0.15) * uv);\n    col = mouth(col, uv);\n    col = brow(col, uv);\n    col = bags(col, uv);\n    \n    // col = mix(vec3(0.0), col, DrawEyeBrow(uvRot * 0.98));\n    // col = mix(colorHair, col, DrawEyeBrow(uvRot));\n    \n    /*\n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\t*/\n    \n\n    \n    //col2.a = 1.;\n\n\tfragColor += vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Distance Estimation\n// https://iquilezles.org/articles/distance\n\n// Rotate\nmat2 Rotate2D(float _angle)\n{\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// 2D distance functions\n// https://iquilezles.org/articles/distfunctions2d\n// https://www.shadertoy.com/view/3ltSW2\n\nfloat SpikeyCircle(vec2 p, float points)\n{\n   vec2 st = vec2(atan(p.x, p.y + 0.1), length(p));\n\n  // float t = mod(st.x, 0.05);\n  // float t = st.x + st.y * 5.0;\n  float t = 1.0 - st.y * 0.2;\n\n  st = vec2(st.x / 6.2831 + 0.5 * t, st.y);\n\n  float x = st.x * points;\n  float m = min(fract(x), fract(1.0 - x));\n  float spikeLength = 0.7 - st.y;\n  float centerRadius = 0.25;\n  float c = smoothstep(0.0, 0.02, m * spikeLength + centerRadius - st.y);\n\n\n  return c;\n\n}\n\n// Circle\nfloat sdCircle( vec2 p, float r )\n{\n  return smoothstep(0.01, 0.02, length(p) - r);\n}\n\n/*\nfloat RotatedRectangle(vec2 st, vec2 size, float angle)\n{\n  st = Rotate2D(angle) * st;\n  return Rectangle (st, size.x, size.y);\n\n*/\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return smoothstep(0.01, 0.02,length(p) - r1);\n    if( k > a*h ) return smoothstep(0.01, 0.02,length(p-vec2(0.0,h)) - r2);\n    return smoothstep(0.01, 0.02,dot(p, vec2(a,b) ) - r1);\n}\n\n// Segment\n\n// Segment - exact   (https://www.shadertoy.com/view/3tdSDj and https://www.youtube.com/watch?v=PMltMdi1Wzg)\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, float thickness )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    // return length( pa - ba*h );\n    return smoothstep(thickness - 0.003, thickness + 0.003,length( pa - ba*h ));\n}\n\nfloat sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)\n{\n   uv *= 10.0;\n    vec2 pa = uv-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    // return length( pa - ba*h ) - lineWidth*0.5;\n    float line = length( pa - ba*h ) - lineWidth*0.5;\n    line = smoothstep(line, line - lineWidth, 0.1);\n\n    return line;\n}\n\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return smoothstep(0.01, 0.015,sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb);\n}\n\n    \n// boolean operations                   \n// https://iquilezles.org/articles/distfunctions\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n                   ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}