{
    "Shader": {
        "info": {
            "date": "1608359977",
            "description": "A variation on my last shader",
            "flags": 32,
            "hasliked": 0,
            "id": "3tdczn",
            "likes": 10,
            "name": "-Threads-",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "pos"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "// Fork of \"Web Compound - X\" by Plento. https://shadertoy.com/view/wt3czr\n// 2020-12-19 06:01:50\n\n// By Cole Peterson (Plento)\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    float sv = ss(0.0, 1.0, abs(nuv.y));\n    float rnd = hash12(u+iTime)*.055;\n    \n    sv += rnd;\n    sv*=0.022;\n    \n    uv += sv;\n    float r = texture(iChannel0, uv).x;\n    uv += sv;\n    float g = texture(iChannel0, uv).y;\n    uv += sv;\n    float b = texture(iChannel0, uv).z;\n    \n    vec3 col = vec3(r, g, b);\n    \n    col *= 1.-step(.45,abs(nuv.y)); // Border\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.); // Final color with gamma correction\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Raymarch scene\n\n//iquilezles.org/articles/distfunctions\nfloat sdCap( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n// Get distance field\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    rp.xy*=rot(iTime*.1);\n    rp.z-=iTime*.4;\n    \n    rp.yx += vec2(.4, .36);\n    \n    // Repeat space\n    vec3 b = vec3(vec2(0.78), 2.6);\n    vec3 id = floor(rp/vec3(b.x, b.y, 1.));\n    \n    //rp.yz *= rot(id.x*0.3);\n    \n    //rp.z += cos(rp.x*3. + iTime*10.)*0.02;\n    //rp.x += sin(rp.y*3. + iTime*10.)*0.02;\n    \n    rp = mod(rp, b)-b*0.5;\n    \n    // Mirror space\n    rp.xy = -abs(rp.xy);\n    \n    // Sphere height\n    float z = .18*cos(.8*iTime+(id.x+id.y*4.)*40.);\n    \n    vec2 c0 = vec2(.5);\n    vec2 c = c0;\n    vec2 lc = c;\n    \n    // Build the web grid thing\n    for(float i = 0.0; i < 19.0; i++){\n        c = c0 * rot(i*8.6);\n        d = min(d, sdCap(rp, vec3(lc, 0.), vec3(c, 0.), .017));\n        lc = c;\n    }\n    \n    \n    return d;\n}\n\n// Standard raymarch normals\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n// Trace scene\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 55; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0015 || t > 8.) break;\n        \n        t += d * .55;\n    }\n    return t;\n}\n\n// Color pixel\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    // Light position and direction\n    vec3 lp = vec3(0., 22., -13.0);\n    vec3 ld = normalize(lp-p);\n   \t\n    // Standard specular\n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 16.);\n   \n    vec3 col = vec3(0.75, 0.9, 0.95)*spec*.16;\n   \n    col = mix(vec3(.333), col, exp(-t*t*t*t*0.0007)); // White fog\n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    // Ray direction with inverted fish eye \n    vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * -.7));\n    // Ray origin\n    vec3 ro = vec3(0., 0., -1.8);\n    \n    rd.yz *= rot(-.6);\n    //rd.xz *= rot(.07);\n    \n    // Mouse movement\n    if(iMouse.z > 0.){\n        ro.x += m.x*3.;\n        ro.y += m.y*2.3;\n        rd.xz *= rot(m.x*.9);\n    }\n    \n    float t = march(rd, ro); // Dist to scene\n    vec3 n = normal(ro + rd*t); // normals of scene\n    vec3 col = color(ro + rd*t, rd, n, t); // Get pixel color\n    \n    col *= ss(0.9, 0.45, abs(uv.x)); // Outer side shade\n    \n    f = vec4(col, 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 100.\n#define ss(a, b, t) smoothstep(a, b, t)\n\n// Dave hoshkin hash\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}