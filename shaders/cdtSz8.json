{
    "Shader": {
        "info": {
            "date": "1679393815",
            "description": "Procedural wallpaper of satin",
            "flags": 0,
            "hasliked": 0,
            "id": "cdtSz8",
            "likes": 4,
            "name": "Wallpaper - Satin Void",
            "published": 3,
            "tags": [
                "procedural",
                "color",
                "wallpaper",
                "satin"
            ],
            "usePreview": 0,
            "username": "elementbound",
            "viewed": 239
        },
        "renderpass": [
            {
                "code": "// #define WALLPAPER\n\n#ifdef WALLPAPER\n    #define SLOWNESS 512.0\n    // #define SHIMMER\n    // #define GRADIENT\n    // #define LOOP\n#else\n    #define SLOWNESS 16.0\n    #define SHIMMER\n    // #define GRADIENT\n    // #define LOOP\n#endif\n\nfloat SEED_BASE;\nfloat RND_AT = 0.0;\n\nvoid seed(float s) {\n    SEED_BASE = s;\n}\n\nfloat seed() {\n    RND_AT += 1.0;\n    return SEED_BASE + hash11(RND_AT) * 512.0;\n}\n\nvec4 satin(vec2 uv) {\n    float grain = mix(1.0 / 16.0, 1.0 / 128.0, perlin11(seed()));\n    float size = mix(0.25, 1.0, perlin11(seed()));\n    float strength = mix(1.0, 4.0, perlin11(seed()));\n\n    vec2 offset = perlin21(seed()) * 4.0;\n    vec2 distortion = perlin23(vec3(offset - uv * size, seed())) * strength;\n\n    vec3 light = perlin33(vec3(offset + uv * size + distortion, seed()));\n    light = 2.0 * light - 1.0;\n    light = normalize(light);\n    vec3 normal = perlin33(vec3(offset + uv * size + distortion, seed()));\n    normal = 2.0 * normal - 1.0;\n    normal = normalize(normal);\n\n    float noise = (1.0 + dot(normal, light)) / 2.0;\n    \n    #ifdef SHIMMER\n    noise += hash13(vec3(uv * iResolution.xy, seed())) * grain;\n    #else\n    noise += hash12(uv * iResolution.xy) * grain;\n    #endif\n    \n    float p = mix(1.0, 4.0, perlin11(seed()));\n    noise = pow(noise, p);\n    \n    #ifdef GRADIENT\n    float gx = (1.0 + uv.x) / 2.0;\n    #else\n    float gx = noise;\n    #endif\n\n    float vp = mix(0.25, 2.0, perlin11(seed()));\n    float value = pow(gx, vp);\n\n    float satRampdown = mix(0.5, 1.0, perlin11(seed()));\n    float satEnd = mix(0.0, 0.25, perlin11(seed()));\n    float saturation = 1.0 - smoothstep(1.0 - satRampdown, 1.0, gx);\n    saturation = mix(satEnd, 1.0, saturation);\n\n    vec2 hueRange = perlin21(seed());\n    float hue = hueRange.x + gx * hueRange.y * 2.0;\n    \n    return vec4(hsv2rgb(vec3(hue, saturation, value)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef LOOP\n    // Will loop in 2*SLOWNESS seconds\n    seed(1.0 - abs(1.0 - mod(iTime / SLOWNESS, 2.0)));\n    #else\n    seed(iTime / SLOWNESS);\n    #endif\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n\n    fragColor = satin(uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ================================================================================================\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// ================================================================================================\n// HSV <-> RGB\n// Source: https://gist.github.com/983/e170a24ae8eba2cd174f\n// ================================================================================================\n// because http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl is often down\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// ================================================================================================\n// Hash without Sine custom additions\n// ================================================================================================\n\n// 6 out, 2 in...\nvoid hash62(vec2 p, out vec3 n1, out vec3 n2)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    n1 = fract((p3.xxy+p3.yzz)*p3.zyx);\n    \n    p3 = fract(vec3(p.xyx)  * vec3(.0976, .1080, .0923));\n    p3 += dot(p3, p3.yxz+33.33);\n    n2 = fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// 6 out, 3 in...\nvoid hash63(vec3 p3, out vec3 n1, out vec3 n2)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    n1 = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    p3 = fract(p3  * vec3(.0976, .1080, .0923));\n    p3 += dot(p3, p3.yxz+33.33);\n    n2 = fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// 9 out, 3 in...\nvoid hash93(vec3 p3, out vec3 n1, out vec3 n2, out vec3 n3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    n1 = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    p3 = fract(p3  * vec3(.0976, .1080, .0923));\n    p3 += dot(p3, p3.yxz+33.33);\n    n2 = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    p3 = fract(p3  * vec3(.1030, .1099, .1065));\n    p3 += dot(p3, p3.yxz+33.33);\n    n3 = fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// ================================================================================================\n// Perlin noise\n// ================================================================================================\n\n//----------------------------------------------------------------------------------------\n// 1 out, 1 in\n\nfloat pn11(float o, float p) {\n    float n = (2.0 * hash11(o) - 1.0);\n    return (p - o) * n;\n}\n\nfloat perlin11(float p) {\n    float o = floor(p);\n    float f = smoothstep(0.0, 1.0, fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        pn11(o + 0.0, p), pn11(o + 1.0, p), f\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 1 out, 2 in\n\nfloat pn12(vec2 o, vec2 p) {\n    vec2 n = (2.0 * hash22(o) - 1.0);\n    return dot(p - o, n);\n}\n\nfloat perlin12(vec2 p) {\n    vec2 o = floor(p);\n    vec2 f = smoothstep(vec2(0), vec2(1), fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        mix(pn12(o + vec2(0.0, 0.0), p), pn12(o + vec2(1.0, 0.0), p), f.x),\n        mix(pn12(o + vec2(0.0, 1.0), p), pn12(o + vec2(1.0, 1.0), p), f.x),\n        f.y\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 1 out, 3 in\n\nfloat pn13(vec3 o, vec3 p) {\n    vec3 n = (2.0 * hash33(o) - 1.0);\n    return dot(p - o, n);\n}\n\nfloat perlin13(vec3 p) {\n    vec3 o = floor(p);\n    vec3 f = smoothstep(vec3(0), vec3(1), fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        mix(\n            mix(pn13(o + vec3(0.0, 0.0, 0.0), p), pn13(o + vec3(1.0, 0.0, 0.0), p), f.x),\n            mix(pn13(o + vec3(0.0, 1.0, 0.0), p), pn13(o + vec3(1.0, 1.0, 0.0), p), f.x),\n            f.y\n        ),\n        mix(\n            mix(pn13(o + vec3(0.0, 0.0, 1.0), p), pn13(o + vec3(1.0, 0.0, 1.0), p), f.x),\n            mix(pn13(o + vec3(0.0, 1.0, 1.0), p), pn13(o + vec3(1.0, 1.0, 1.0), p), f.x),\n            f.y\n        ),\n        f.z\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 2 out, 1 in\n\nvec2 pn21(float o, float p) {\n    vec2 n = (2.0 * hash21(o) - 1.0);\n    return vec2(\n        (p - o) * n.x,\n        (p - o) * n.y\n    );\n}\n\nvec2 perlin21(float p) {\n    float o = floor(p);\n    float f = smoothstep(0.0, 1.0, fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        pn21(o + 0.0, p), pn21(o + 1.0, p), f\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 2 out, 2 in\n\nvec2 pn22(vec2 o, vec2 p) {\n    vec4 n = (2.0 * hash42(o) - 1.0);\n    return vec2(\n        dot((p - o), n.xy),\n        dot((p - o), n.zw)\n    );\n}\n\nvec2 perlin22(vec2 p) {\n    vec2 o = floor(p);\n    vec2 f = smoothstep(vec2(0), vec2(1), fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        mix(pn22(o + vec2(0.0, 0.0), p), pn22(o + vec2(1.0, 0.0), p), f.x),\n        mix(pn22(o + vec2(0.0, 1.0), p), pn22(o + vec2(1.0, 1.0), p), f.x),\n        f.y\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 2 out, 3 in\n\nvec2 pn23(vec3 o, vec3 p) {\n    vec3 n1, n2;\n    hash63(o, n1, n2);\n    return vec2(\n        dot((p - o), 2.0 * n1 - 1.0),\n        dot((p - o), 2.0 * n2 - 1.0)\n    );\n}\n\nvec2 perlin23(vec3 p) {\n    vec3 o = floor(p);\n    vec3 f = smoothstep(vec3(0), vec3(1), fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        mix(\n            mix(pn23(o + vec3(0.0, 0.0, 0.0), p), pn23(o + vec3(1.0, 0.0, 0.0), p), f.x),\n            mix(pn23(o + vec3(0.0, 1.0, 0.0), p), pn23(o + vec3(1.0, 1.0, 0.0), p), f.x),\n            f.y\n        ),\n        mix(\n            mix(pn23(o + vec3(0.0, 0.0, 1.0), p), pn23(o + vec3(1.0, 0.0, 1.0), p), f.x),\n            mix(pn23(o + vec3(0.0, 1.0, 1.0), p), pn23(o + vec3(1.0, 1.0, 1.0), p), f.x),\n            f.y\n        ),\n        f.z\n    );\n}\n\n\n//----------------------------------------------------------------------------------------\n// 3 out, 1 in\n\nvec3 pn31(float o, float p) {\n    vec3 n = (2.0 * hash31(o) - 1.0);\n    return vec3(\n        (p - o) * n.x,\n        (p - o) * n.y,\n        (p - o) * n.z\n    );\n}\n\nvec3 perlin31(float p) {\n    float o = floor(p);\n    float f = smoothstep(0.0, 1.0, fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        pn31(o + 0.0, p), pn31(o + 1.0, p), f\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 3 out, 2 in\n\nvec3 pn32(vec2 o, vec2 p) {\n    vec3 n1, n2;\n    hash62(o, n1, n2);\n    return vec3(\n        dot((p - o), 2.0 * vec2(n1.xy) - 1.0),\n        dot((p - o), 2.0 * vec2(n1.z, n2.x) - 1.0),\n        dot((p - o), 2.0 * vec2(n2.yz) - 1.0)\n    );\n}\n\nvec3 perlin32(vec2 p) {\n    vec2 o = floor(p);\n    vec2 f = smoothstep(vec2(0), vec2(1), fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        mix(pn32(o + vec2(0.0, 0.0), p), pn32(o + vec2(1.0, 0.0), p), f.x),\n        mix(pn32(o + vec2(0.0, 1.0), p), pn32(o + vec2(1.0, 1.0), p), f.x),\n        f.y\n    );\n}\n\n//----------------------------------------------------------------------------------------\n// 3 out, 3 in\n\nvec3 pn33(vec3 o, vec3 p) {\n    vec3 n1, n2, n3;\n    hash93(o, n1, n2, n3);\n    return vec3(\n        dot((p - o), 2.0 * n1 - 1.0),\n        dot((p - o), 2.0 * n2 - 1.0),\n        dot((p - o), 2.0 * n3 - 1.0)\n    );\n}\n\nvec3 perlin33(vec3 p) {\n    vec3 o = floor(p);\n    vec3 f = smoothstep(vec3(0), vec3(1), fract(p));\n    \n    return 0.5 + 0.5 * mix(\n        mix(\n            mix(pn33(o + vec3(0.0, 0.0, 0.0), p), pn33(o + vec3(1.0, 0.0, 0.0), p), f.x),\n            mix(pn33(o + vec3(0.0, 1.0, 0.0), p), pn33(o + vec3(1.0, 1.0, 0.0), p), f.x),\n            f.y\n        ),\n        mix(\n            mix(pn33(o + vec3(0.0, 0.0, 1.0), p), pn33(o + vec3(1.0, 0.0, 1.0), p), f.x),\n            mix(pn33(o + vec3(0.0, 1.0, 1.0), p), pn33(o + vec3(1.0, 1.0, 1.0), p), f.x),\n            f.y\n        ),\n        f.z\n    );\n}\n\n// ================================================================================================\n// Useful constants\n\n#define PI 3.1415926535897932384626433832795\n\n// ================================================================================================\n// Others\n\nfloat unlerp(float a, float b, float x) {\n    return (x - a) / (b - a);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}