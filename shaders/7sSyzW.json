{
    "Shader": {
        "info": {
            "date": "1643156511",
            "description": "I was trying to find the SDF of an helical staircaise, and I saw that dr2 has found a way to do it (amongst other great things) ! (there is also a version by FabriceNeyret2)\nhere it is, a bit simplified, and with parameters.\nnot exact, but works great :)",
            "flags": 0,
            "hasliked": 0,
            "id": "7sSyzW",
            "likes": 11,
            "name": "helical staircase",
            "published": 3,
            "tags": [
                "sdfhelixstairs"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "// derived from :\n\n// \"Melange\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// https://www.shadertoy.com/view/slKXD3\n\n#define PI 3.1415926535\n\nfloat sdHelixStairs( in vec3 p) {\n\n    // parameters :\n \n    float stairsNum = 2.;\n    float slabNum = 40.; // number of slabs per rotation\n    float rotDir = 1.; //1. or -1.\n\n    float height = 10.;\n    float axisWidth = 9.;\n    float underSlab = .5;\n    float slabWidth = 2.;\n        \n    float ang = height * atan (p.x, p.z) / PI * rotDir;\n    float len = length(p.xz);\n        \n    vec2 h2 = height / vec2(slabNum*.5,stairsNum);\n\n    p.xy = vec2(ang - p.y, ang + p.y)*0.5;\n    p.xy = mod(p.xy, h2);\n\n    p.x  = min(p.x, h2.x - p.x);\n    p.y -= h2.y*0.5;\n    \n    float y1 = max( p.y - p.x, -(p.y + underSlab)*2. );\n    float z1 = abs( len - axisWidth ) - slabWidth;\n    \n    //smoother sdf\n    //if (y1>0. && z1>0.) { return length(vec2(y1,z1)); }\n    \n    return max(y1,z1);\n    \n}\n\nfloat getVal ( in vec3 p ) {\n    return sdHelixStairs(p);\n}\n\nfloat rayMarch( vec3 ro, vec3 rd) {\n\n    float t = 0.;\n    int i = 0;\n\n    while ( i<100 && t<999. ) {\n        float r = abs( getVal( ro + rd*t ) );\n        if ( r <= 0.001*t ) break;\n        t += r;\n        i ++;\n    }\n    \n    if (t>999.) { return -1.; }\n\n    return t;\n}\n\nvec3 distance_field_normal(vec3 pos) {\n    vec2 eps = vec2(0.0001,0.0);\n    float nx = getVal(pos + eps.xyy);\n    float ny = getVal(pos + eps.yxy);\n    float nz = getVal(pos + eps.yyx);\n    return normalize(vec3(nx, ny, nz)-getVal(pos));\n}\n\n\n//ambient occlusion\n//https://www.shadertoy.com/view/MtlBWB\nconst vec3 sq = 1./vec3(sqrt(2.),sqrt(3.),sqrt(4.));\nconst float eps = 0.125;\nconst vec3 eps2 = eps*vec3(2.,3.,4.);\nfloat ao(vec3 p, vec3 n) {\n    \n    float c1 = float(abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z));\n    float c2 = float(abs(n.y) < abs(n.z));\n    float c3 = c2 - c2*c1;\n    \n    vec3 t = vec3(c1, c3, 1. - c1 - c3);\n    vec3 u = cross(n, t);\n    vec3 v = cross(n, u);    \n    \n    vec3 epn = eps2[2]*n + p;\n    \n    float occ  = max(getVal(p + eps*n),0.0);\n          occ += max(getVal(p + eps*u),0.0);\n          occ += max(getVal(p - eps*u),0.0);\n          occ += max(getVal(p + eps*v),0.0);\n          occ += max(getVal(p - eps*v),0.0);\n    \n    occ += (max(getVal(epn + eps2[2]*u),0.0)\n        +   max(getVal(epn - eps2[2]*u),0.0)\n        +   max(getVal(epn + eps2[2]*v),0.0)\n        +   max(getVal(epn - eps2[2]*v),0.0))*0.5;\n\n    occ += max(getVal(p + eps2[0]*n)*sq[0],0.0);\n    occ += max(getVal(p + eps2[1]*n)*sq[1],0.0);\n    occ += max(getVal(epn          )*sq[2],0.0);\n\n    return max(1.0 - 1.0/(1.0+2.0*occ), 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (m.x==0. && m.y==0.) { m = vec2(.5,.87); }\n\n    //rotation of the object\n    float time2 = iTime*0.125;\n    mat3 rot = mat3(sin(time2),0., cos(time2),  0.,1.,0., cos(time2),0.,-sin(time2));\n\n    //ray origin + direction\n    vec3 ro = vec3(0., 0., 30. );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd.yz *= mat2(cos(0.4),sin(0.4),-sin(0.4),cos(0.4));\n\n    vec3 ro2 = ro*rot;\n    vec3 rd2 = rd*rot;\n\n    //output color\n    vec3 col = vec3(0.0);\n    \n    \n    //distance to the object\n    float dist = rayMarch( ro2, rd2 );\n\n    vec3 objPos;\n    float tmin = 1e10;\n\n    // if we touch the object :\n    if (dist>0.0) {\n\n        tmin = min(tmin,dist);\n        vec3 hit = ro2 + rd2*dist;\n        vec3 normals = distance_field_normal(hit);        \n        objPos = ro2 + tmin*rd2;\n        \n        float diffuse = mix(normals.y,1.,0.65);\n        float ao = ao(objPos, normals);\n\n        col = vec3(0.8,0.8,1.)*diffuse*ao ;\n    }\n    \n    //signed distance field viewer\n    //inspired by tdhooper : https://www.shadertoy.com/view/MstcWs\n\n    float offset = (m.y-0.5)*25.;\n    if (tmin>9999. || (rot*objPos).z + offset < 0.) {\n        \n        vec3 planeHit = ro2 - rd2*(ro.z+offset)/rd.z;\n\n        float sdf = getVal(planeHit);\n        \n        vec3 view = vec3(0.2,0.,1.)*mod(sdf, 0.5)/(1.+sdf*0.1);\n        \n\n        col = mix(col, view, m.x*0.75 );\n    }\n    \n\n    fragColor = vec4( sqrt(col.rgb), 1.0 );\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}