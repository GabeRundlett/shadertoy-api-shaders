{
    "Shader": {
        "info": {
            "date": "1507305667",
            "description": "Yellow net is equidistant to red & green torus segments. Ditto for cyan/green/blue and magenta/blue/red, respectively. T toggles last torus segment. V toggles Voronoi boundary. H toggles hyperbolic paraboloid.",
            "flags": 16,
            "hasliked": 0,
            "id": "XtSyzh",
            "likes": 17,
            "name": "GVD of cubic Truchet cell",
            "published": 3,
            "tags": [
                "voronoi",
                "truchet",
                "cubic",
                "diagram",
                "generalized",
                "gvd"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 671
        },
        "renderpass": [
            {
                "code": "/* \n    GVD of cubic Truchet cell, by mattz\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tIf you've spent way too much time thinking about cubic Truchet tilings,\n    you might be tempted to ask how the three torus segments divide the cube\n    into three equal volumes.\n\n    The answer is given by the Generalized Voronoi Diagram (GVD) of the cell.\n    This is the set of surfaces that are equidistant to pairs of torii. \n    See, for instance: http://sci.utah.edu/~jedwards/research/gvd/\n\n    These particular Voronoi boundaries appear similar to hyperbolic paraboloids:\n    http://mathworld.wolfram.com/HyperbolicParaboloid.html -- but I don't think\n    they actually are hyperbolic paraboloids. Press H to compare.\n\n    Thanks to Shane for posing the question that took me here!\n\n\n*/\n\n// Bunch of globals/constants:\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nfloat show_t2 = 1.;\n\nfloat show_voronoi = 1.;\nfloat show_hyperb = 0.;\n\nconst float HALFPI = 1.5707963267948966;\n\nconst int HSTEPS = 10;\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* Compute torus distance and normal vector given:\n\n    - p is point in cube with vertices at +/- 0.5:\n    - src is outward facing normal of flow source face \n    - dst is outward facing normal of flow sink face\n\n   Returns a vec4 (nx, ny, nd, d) where:\n\n     - nx, ny, nz is unit normal pointing away from torus\n     - d is distance to torus.\n\n*/\nvec4 checkTorus(vec3 p, vec3 src, vec3 dst) {\n    \n    vec3 z = cross(dst, src);\n    vec3 ctr = 0.5*(src+dst);\n    \n    p -= ctr;\n    \n    vec3 pc = 0.5*normalize(src*dot(p, src) + dst*dot(p, dst));\n    \n    vec3 n = p - pc;\n    float l = length(n);\n    \n    float d = l;\n \n    return vec4(n/l, d);\n    \n}\n\n/* Boolean union of solids for map function below */\nvec2 dmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n/* Sort vec3 coordinates descending - for box edges. */\nvec3 psort(vec3 p) {\n    p = abs(p);\n    if (p.y < p.z) { p.yz = p.zy; } // y & z are sorted\n    if (p.x < p.z) { p.xz = p.zx; } // x & z are sorted\n    if (p.x < p.y) { p.xy = p.yx; } // x & y are sorted\n    return p;\n}\n\n/* Inf. norm for box edges. */\nfloat infnorm(vec3 a) {\n    a = abs(a);\n    return max(a.x, max(a.y, a.z));\n}\n\n/* Make an approximate distance field out of the difference of two \n   distance fields whose gradients (normals) are known. This is \n   exactly the method used in iq's \"Distance estimation to implicits\"\n   article: https://iquilezles.org/articles/distance\n*/\nfloat vdiff(vec4 a, vec4 b) {\n    return abs(a.w - b.w) / length(a.xyz - b.xyz);\n}\n\n/* Construct a doubly-ruled surface - I *think* this is a hyperbolic paraboloid? */\nvec3 psurf(vec2 uv) {\n    \n    const vec3 a = 0.5*vec3(1, 1, -1);\n    const vec3 b = 0.5*vec3(-1, 1, -1);\n    const vec3 c = 0.5*vec3(1, 1, 1);\n    const vec3 d = 0.5*vec3(1, -1, 1);\n    \n    vec3 p = mix(a, b, uv.x);\n    vec3 q = mix(c, d, uv.x);\n\n   \treturn mix(p, q, uv.y);\n    \n}\n\nfloat dline(vec3 p, vec3 a, vec3 b) {\n    \n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    \n    float u = clamp(dot(pa,ba) / dot(ba, ba), 0., 1.);\n    return length(pa - u*ba);\n    \n}\n\n/* Distance function to scene */\nvec2 map(in vec3 pos) {\t\n    \n    // Get distances and normals for each of 3 torus segments \n    vec4 t0 = checkTorus(pos, vec3(0, 1, 0), vec3(0, 0, 1));\n    vec4 t1 = checkTorus(pos, vec3(1, 0, 0), vec3(0, 0, -1));\n \n    // Minimum distance to torus & material color\n    vec2 tm = vec2(t0.w, 0./6.); \n    tm = dmin(tm, vec2(t1.w, 2./6.)); \n    \n\n    \n    // Distance to generalized Voronoi boundaries depends upon closest feature --\n    // we will only check 2 of 3 possible boundaries.\n    vec2 vm = vec2(1e5, -1);\n    \n    if (show_t2 != 0.) {\n        \n        vec4 t2 = checkTorus(pos, vec3(0, -1, 0), vec3(-1, 0, 0));\n        tm = dmin(tm, vec2(t2.w, 4./6.)); \n\n        if (tm.x == t0.w) { \n            vm = dmin(vm, vec2(vdiff(t0, t1), 1./6.));\n            vm = dmin(vm, vec2(vdiff(t2, t0), 5./6.));\n        } else if (tm.x == t1.w) {\n            vm = dmin(vm, vec2(vdiff(t0, t1), 1./6.));\n            vm = dmin(vm, vec2(vdiff(t1, t2), 3./6.));\n        } else {\n            vm = dmin(vm, vec2(vdiff(t1, t2), 3./6.));\n            vm = dmin(vm, vec2(vdiff(t2, t0), 5./6.));\n        }\n        \n    } else {\n        \n        vm = dmin(vm, vec2(vdiff(t0, t1), 1./6.));\n        \n    }\n    \n    // Give torii some radius    \n    tm.x -= 0.04;\n    \n    // Since we are raymarching an implicit, scaling the\n    // estimated distance down a bit gives our raymarcher\n    // more of a chance to intersect.\n    vm.x *= 0.5;\n    \n    // Give implicit surface a bit of thickness\n    vm.x -= 0.004;\n    \n    // Punch some holes in the voronoi boundaries to make netting\n    vec3 cctr = floor(12.0*pos+0.5)/12.0;\n    vec3 cpos = abs(pos - cctr);\n    vm.x = max(vm.x, min(cpos.x, min(cpos.y, cpos.z))-0.01);\n    \n    // Prepare the final return value for the map function\n    vec2 dm = show_voronoi != 0.0 ? dmin(tm, vm) : tm;\n    \n    if (show_hyperb != 0.) {\n        for (int n=0; n<=HSTEPS; ++n) {\n            float i = float(n)/float(HSTEPS);\n            dm = dmin(dm, vec2(dline(pos, psurf(vec2(i, 0)), psurf(vec2(i, 1)))-0.008, 1.5));\n            dm = dmin(dm, vec2(dline(pos, psurf(vec2(0, i)), psurf(vec2(1, i)))-0.008, 1.5));\n        }\n    }\n    \n    // Handle box edge\n    vec3 ps = psort(pos);\n    float u = clamp(ps.z, 0.0, 0.5);\n    vec3 pc = vec3(0.5, 0.5, u);\n    dm = dmin(dm, vec2(infnorm(ps - pc)-0.02, 1.01));\n    \n    // Clamp to cube extents\n    dm.x = max(dm.x, ps.x - 0.5);\n    \n    // Return value\n    return dm;\n\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.001;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h; \n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n/* Pretty standard shading function. */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n    if (tm.y < 0.0) { \n\n        // miss\n        return vec3(1.0);\n\n    } else {        \n\n        // hit\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n\n        vec3 color = hue(tm.y);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        vec3 c = diffamb + spec;\n        \n        return c;\n\n    }\n\n\n}\n\nconst float KEY_H = 72.5 / 256.0;\nconst float KEY_T = 84.5 / 256.0;\nconst float KEY_V = 86.5 / 256.0;\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n/* Finally, our main function: */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n    \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0, 0, 2);\n    const vec3 up = vec3(0, 1, 0);\n    \n   \n    show_t2 = keyState(KEY_T, show_t2);\n    show_voronoi = keyState(KEY_V, show_voronoi);\n    show_hyperb = keyState(KEY_H, show_hyperb);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    vec2 mpos;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        mpos.xy = iMouse.xy;\n    } else {\n        mpos = iResolution.xy * vec2(0.432 + 0.015*iTime, 0.415);\n    }\n    \n    float thetax = (mpos.y - .5*iResolution.y) * -4.0*HALFPI/iResolution.y; \n    float thetay = (mpos.x - .5*iResolution.x) * 8.0*HALFPI/iResolution.x; \n\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n    \n    fragColor.xyz = shade(ro, rd);\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}