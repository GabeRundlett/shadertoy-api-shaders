{
    "Shader": {
        "info": {
            "date": "1666244635",
            "description": "Someone showed me a visual from before a Katy Perry show, so I decided to try to replicate it.\n\nThen I decided to try to make it in anaglyph stereo and to add some extra stuff.",
            "flags": 0,
            "hasliked": 0,
            "id": "mslGWM",
            "likes": 1,
            "name": "anaglyph stereo infinite cave",
            "published": 3,
            "tags": [
                "anaglyph",
                "stereo",
                "depth"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 147
        },
        "renderpass": [
            {
                "code": "#define LIGHT_THICK 0.1\n#define LIGHT_HEIGHT 0.3\n#define GAP_HEIGHT 0.6\n#define CORNER_SCALE 0.02\n#define BLEND_SCALE 0.04\n\n#define PROJECTILE_RAD 0.0125\n\n#define NUM_PROJECTILES 6\nvec3 projectiles[NUM_PROJECTILES] = vec3[](vec3(0.5, 0.1, 0.0), vec3(-0.2, 0.35, 0.0), vec3(-0.5, -0.2, 0.0),\n                                           vec3(0.5, -0.15, 0.0), vec3(-0.2, -0.35, 0.0), vec3(-0.75, -0.2, 0.0));\n\nvoid initializeProjectiles() {\n  float back = -8.0 * iTime;\n  for (int i = 0; i < NUM_PROJECTILES; ++i) {\n    projectiles[i].z = mod(back, 32.0) - 1.;\n    back += 7.0;\n  }\n}\n\nfloat sdfProjectiles(in vec3 pt) {\n  float minDist = 400.0;\n  for (int i = 0; i < NUM_PROJECTILES; ++i) {\n    minDist = min(minDist, 0.95 * (length(vec3(1.0, 1.0, 0.125) * (pt - projectiles[i])) - PROJECTILE_RAD));\n  }\n  return minDist;\n}\n\nfloat sdfZ(in float z) {\n  float zMod = mod(z + iTime, GAP_HEIGHT + LIGHT_HEIGHT);\n  float bottomZ = 0.5 * LIGHT_HEIGHT - zMod;\n  float topZ = zMod - 1.5 * LIGHT_HEIGHT;\n  float zDist = max(topZ, bottomZ);\n  if (z > 15.0) {\n    return max(zDist, 0.1);\n  }\n  return zDist;\n}\n\nfloat sdf(in vec3 pt, in vec2 wh) {\n  vec2 dists = wh - abs(pt.xy);\n  float closest = checked_smooth_min(dists.x, dists.y, CORNER_SCALE);\n  float zDist = sdfZ(pt.z);\n  float zMod = mod(pt.z + iTime, GAP_HEIGHT + LIGHT_HEIGHT);\n  float crinkly = 0.0;\n  if (abs(closest - LIGHT_THICK) < 0.15 * LIGHT_THICK && zDist < 0.15 * LIGHT_THICK) {\n    crinkly = texture(iChannel0, vec2(dot(vec2(1.0), pt.xy), zMod)).r;\n  }\n  float wallsSdf = min(closest, checked_smooth_max(zDist, closest + 0.1 * LIGHT_THICK * crinkly - LIGHT_THICK, BLEND_SCALE));\n  return min(wallsSdf, sdfProjectiles(pt));\n}\n\nvec3 sdfSurfNorm(in vec3 pt, in vec2 wh) {\n  float f = sdf(pt, wh);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0), wh) - f,\n                        sdf(pt + vec3(0.0, h, 0.0), wh) - f,\n                        sdf(pt + vec3(0.0, 0.0, h), wh) - f));\n}\n\nfloat toCorner(in vec3 pt, in vec2 wh) {\n  float zMod = mod(pt.z + iTime, GAP_HEIGHT + LIGHT_HEIGHT);\n  float zDist = max(0.0, 1.5 * LIGHT_HEIGHT - zMod);\n  zDist = min(zDist, 0.5 * (LIGHT_HEIGHT + LIGHT_THICK));\n  vec2 dists = wh - abs(pt.xy);\n  float xyDist = checked_smooth_min(dists.x, dists.y, CORNER_SCALE);\n  return length(vec2(zDist, xyDist));\n}\n\nfloat castRay(in vec3 o, in vec3 d, in vec2 wh, out int hitLight, out float accum) {\n  vec2 dxy = abs(d.xy);\n  vec2 oSign = sign(d.xy);\n  vec2 muls = (wh - oSign * o.xy - 1.5 * LIGHT_THICK) / max(dxy, vec2(1.0e-3));\n  float toLightInner = min(muls.x, muls.y);\n  hitLight = 0;\n  accum = 0.0;\n  float curr = min(sdfProjectiles(o), toLightInner);\n  for (int i = 0; i < 60; ++i) {\n    vec3 p = o + curr * d;\n    float dist = sdf(p, wh);\n    if (dist < 1.0e-3) {\n      if (sdfZ(p.z) < 0.01) {\n        hitLight = 1;\n      }\n      return curr;\n    }\n    if (curr > 50.0) {\n      return 50.0;\n    }\n    curr = curr + 0.9 * dist;\n    accum += 0.7 / max(0.1, dist);\n  }\n  return curr;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n  return max(0.0, min(1.0, (x-a)/(b-a)));\n}\n\nfloat monocularImage( in vec2 fragCoord, float eye )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 wh = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    vec3 orig = vec3(0.0, 0.0, -2.0);\n    \n    // orig.xy = 0.7 * (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    orig.x += eye;\n    \n    vec3 dir = normalize(vec3(uv, 0.0) - orig);\n    \n    int hitLight = 0;\n    \n    float glow = 0.0;\n    \n    float d = castRay(orig, dir, wh, hitLight, glow);\n\n    // Time varying pixel color\n    float col = (1.0);\n    \n    if (hitLight == 0) {\n      col = (0.0);\n    } else {\n      float subD = toCorner(orig + dir * d, wh);\n      float maxDist = length(vec2(LIGHT_HEIGHT, LIGHT_THICK));\n      col *= LIGHT_THICK / subD;\n    }\n    \n    vec3 surfNorm = sdfSurfNorm(orig + dir * d, wh);\n    vec3 bounce = normalize(reflect(dir, surfNorm));\n    float eyeLight = smoothstep(-1.0, 1.0, -dot(bounce, dir));\n    col += eyeLight;\n    \n    \n    col += 1.0e-2 * glow * 2.0;\n    \n    col = mix(0.5, col, smoothstep(15.0, 10.0, d) * max(0.0, min(1.0, 0.75/d)));\n    \n\n    // Output to screen\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  initializeProjectiles();\n  fragColor.r = monocularImage(fragCoord, -0.125);\n  fragColor.gb = vec2(monocularImage(fragCoord, 0.125));\n  fragColor.a = 1.0;\n  }",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_max(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}