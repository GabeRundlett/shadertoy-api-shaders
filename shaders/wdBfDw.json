{
    "Shader": {
        "info": {
            "date": "1590158704",
            "description": "description",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBfDw",
            "likes": 1,
            "name": "3D Metaballs && SDF && BRDF",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "metaball",
                "brdf"
            ],
            "usePreview": 0,
            "username": "EvgenyNeon",
            "viewed": 632
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.0001;\nconst float PI = 3.1415;\n\nstruct light\n{\n \tvec3 brightness;\n    vec3 location;\n    vec3 direction;\n    bool isDirected;\n};\n\nconst int lightsCount = 1;\nlight lights[lightsCount];\n\nstruct materialBRDF\n{\n  \tvec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nfloat distributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = geometrySchlickGGX(NdotV, roughness);\n    float ggx1  = geometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n} \n\nvec3 fresnelSchlick(float cosTheta, vec3 f0)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);\n} \n\nstruct lightInfo\n{\n    vec3 kS;\n    vec3 kD;\n};\n\nlightInfo cookTorrensBRDF(vec3 rayInput, vec3 rayOutput, vec3 normal, materialBRDF material)\n{\n    lightInfo result;\n    \n    vec3 N = normalize(normal);\n    vec3 V = normalize(rayOutput);\n    vec3 L = normalize(rayInput);\n    vec3 H = normalize(V + L);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, material.albedo, material.metallic);\n    \n    float NDF = distributionGGX(N, H, material.roughness);       \n\tfloat G   = geometrySmith(N, V, L, material.roughness);\n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0); \n    \n    vec3 kD = vec3(1.0) - F;\n    kD *= 1.0 - material.metallic;\t  \n    result.kD = kD;\n        \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001); \n    result.kS = specular;\n    \n \treturn result;   \n}\n\nstruct sphere\n{\n \tvec3 location;\n    float radius;\n    materialBRDF material;\n};\n\nconst int spheresCount = 3;\nsphere spheres[spheresCount];\n\nvoid initScene()\n{\n    spheres[0].location = vec3(0.0, 0.0, 0.0);\n    spheres[0].radius = 1.1;\n    spheres[0].material.albedo = vec3(10.0, 0.0, 0.0);\n    spheres[0].material.roughness = 0.5;\n    spheres[0].material.metallic = 0.0;\n    \n    spheres[1].location = vec3(0.0, 0.0, 0.0);\n    spheres[1].radius = 1.0;\n    spheres[1].material.albedo = vec3(0.0, 10.0, 0.0);\n    spheres[1].material.roughness = 0.5;\n    spheres[1].material.metallic = 0.0;\n    \n    spheres[2].location = vec3(0.0, 0.0, 0.0);\n    spheres[2].radius = 1.05;\n    spheres[2].material.albedo = vec3(0.0, 0.0, 10.0);\n    spheres[2].material.roughness = 0.5;\n    spheres[2].material.metallic = 0.0;\n    \n    lights[0].brightness = vec3(10.0);\n    lights[0].location = vec3(0.0);\n    lights[0].direction = normalize(vec3(1.0, 1.0, 0.0));\n    lights[0].isDirected = true;\n}\n\nvoid updateScene()\n{\n\tspheres[1].location = vec3(0.0, sin(iTime * 0.4) * 8.0, 0.0);\n    spheres[2].location = vec3(0.0, 0.0, sin(iTime * 0.8) * 8.0);\n    \n    lights[0].direction = normalize(vec3(sin(iTime), 0.0, cos(iTime)));\n}\n\nstruct resultSDF\n{\n \tfloat sdf;\n    materialBRDF material;\n};\n\nresultSDF sphereSDF(vec3 point, int sphere) \n{\n    resultSDF result;\n    result.sdf = distance(point, spheres[sphere].location) - spheres[sphere].radius;\n    result.material = spheres[sphere].material;\n    return result;\n}\n\nresultSDF sceneSphereSDF(vec3 point)\n{\n    resultSDF result;\n    result.sdf = 1000000.0;\n \tfor(int i = 0; i < spheresCount; i++)\n    {\n        resultSDF buffer = sphereSDF(point, i);\n        if(result.sdf >= buffer.sdf)\n        {\n            result.sdf = buffer.sdf;\n            result.material = buffer.material;\n        }\t   \n    }\n    \n    return result;\n}\n\nresultSDF metaballSDF(vec3 point, int sphere)\n{\n    resultSDF result;\n    result.sdf = pow(spheres[sphere].radius, 2.0) / (pow(point.x - spheres[sphere].location.x, 2.0) + \n                                        pow(point.y - spheres[sphere].location.y, 2.0) + \n                                        pow(point.z - spheres[sphere].location.z, 2.0));\n    result.material = spheres[sphere].material;\n \treturn result;\t   \n}\n\nresultSDF sceneMetaballSDF(vec3 point)\n{\n    resultSDF result;\n    result.sdf = 0.0;\n \tfor(int i = 0; i < spheresCount; i++)\n    {\n        resultSDF buffer = metaballSDF(point, i);\n     \tresult.sdf += buffer.sdf;\t\n        result.material.albedo += (buffer.sdf * buffer.material.albedo);\n        result.material.roughness += (buffer.sdf * buffer.material.roughness);\n        result.material.metallic += (buffer.sdf * buffer.material.metallic);    \n    }\n    return result;\t   \n}\n\nstruct resultRay\n{\n    vec3 location;\n    vec3 normal;\n    float distance;\n    bool isHit;\n    materialBRDF material;\n};\n\nvec3 estimateNormalSphere(vec3 point) \n{\n    resultSDF a = sceneSphereSDF(vec3(point.x + EPSILON, point.y, point.z));\n    resultSDF b = sceneSphereSDF(vec3(point.x - EPSILON, point.y, point.z));\n    resultSDF c = sceneSphereSDF(vec3(point.x, point.y + EPSILON, point.z));\n    resultSDF d = sceneSphereSDF(vec3(point.x, point.y - EPSILON, point.z));\n    resultSDF e = sceneSphereSDF(vec3(point.x, point.y, point.z  + EPSILON));\n    resultSDF f = sceneSphereSDF(vec3(point.x, point.y, point.z - EPSILON));\n    return normalize(vec3(a.sdf - b.sdf, c.sdf - d.sdf, e.sdf - f.sdf));\n}\n    \nresultRay rayMarchingSphere(vec3 originRay, vec3 directionRay)\n{\n    resultRay result;\n    \n    vec3 locationRay = originRay;\n    for(int i = 0; i < 100; i++)\n    {\t\n    \tresultSDF buffer = sceneSphereSDF(locationRay);\n        if(buffer.sdf <= 0.001)\n        {\n            result.location = locationRay;\n            result.distance = distance(originRay, locationRay);\n            result.normal = estimateNormalSphere(locationRay);\n            result.material = buffer.material;\n            result.isHit = true;\n         \tbreak;   \n        }\n        locationRay += directionRay * buffer.sdf;\n        result.isHit = false;\n    }\n    \n    return result;\n}\n\nvec3 estimateNormalMetaball(vec3 point) \n{\n    resultSDF a = sceneMetaballSDF(vec3(point.x + EPSILON, point.y, point.z));\n    a.sdf = (a.sdf - 1.0) * -1.0;\n    resultSDF b = sceneMetaballSDF(vec3(point.x - EPSILON, point.y, point.z));\n    b.sdf = (b.sdf - 1.0) * -1.0;\n    resultSDF c = sceneMetaballSDF(vec3(point.x, point.y + EPSILON, point.z));\n    c.sdf = (c.sdf - 1.0) * -1.0;\n    resultSDF d = sceneMetaballSDF(vec3(point.x, point.y - EPSILON, point.z));\n    d.sdf = (d.sdf - 1.0) * -1.0;\n    resultSDF e = sceneMetaballSDF(vec3(point.x, point.y, point.z  + EPSILON));\n    e.sdf = (e.sdf - 1.0) * -1.0;\n    resultSDF f = sceneMetaballSDF(vec3(point.x, point.y, point.z - EPSILON));\n    f.sdf = (f.sdf - 1.0) * -1.0;\n    return normalize(vec3(a.sdf - b.sdf, c.sdf - d.sdf, e.sdf - f.sdf));\n}\n\nresultRay rayMarchingMetaball(vec3 originRay, vec3 directionRay)\n{\n    resultRay result;\n    \n    vec3 locationRay = originRay;\n    for(int i = 0; i < 50; i++)\n    {\t\n    \tresultSDF buffer = sceneMetaballSDF(locationRay);\n        if(buffer.sdf >= 0.99)\n        {\n            result.location = locationRay;\n            result.distance = distance(originRay, locationRay);\n            result.normal = estimateNormalMetaball(locationRay);\n            result.material = buffer.material;\n            result.isHit = true;\n         \tbreak;   \n        }\n        locationRay += directionRay * ((buffer.sdf - 1.0) * -1.0);\n        result.isHit = false;\n    }\n    \n    return result;\n}\n\nvec3 lightingCalculation(vec3 directionRay, resultRay rayInfo)\n{   \n    vec3 result = vec3(0.0);\n    \n    for(int i = 0; i < lightsCount; i++)\n    {\n        float distance;\n        float attenuation;\n        vec3 radiance;\n        \n        if(lights[i].isDirected)\n        {\n            radiance = lights[i].brightness;\n        }\n        else\n        {\n         \tdistance = length(lights[i].location - rayInfo.location);\n        \tattenuation = 1.0 / (distance * distance);\n        \tradiance = lights[i].brightness * attenuation;\t   \n        }\n        \n     \tlightInfo buffer = cookTorrensBRDF(-lights[i].direction, -directionRay, rayInfo.normal, rayInfo.material);\t\n        float NdotL = max(dot(rayInfo.normal, -lights[i].direction), 0.0);                \n        result += (buffer.kD * rayInfo.material.albedo / PI + buffer.kS) * radiance * NdotL; \n    }\n    \n    result += 0.05 * rayInfo.material.albedo;\n \treturn result;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    float x = iMouse.x / iResolution.x - 0.5;\n    x *= aspectRatio;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= aspectRatio;\n    \n    initScene();\n    updateScene();\n    \n    vec3 originRay = vec3(-6.0, 0.0, 0.0);\n    vec3 directionRay = normalize(vec3(1.0, uv));\n    \n    resultRay result;\n    if(x >= uv.x)\n    {\n        result = rayMarchingSphere(originRay, directionRay); \n    }\n    else\n    {\n     \tresult = rayMarchingMetaball(originRay, directionRay);   \n    }\n\n    vec3 color = lightingCalculation(directionRay, result);\n    \n    color /= color + vec3(1.0);\n    color = pow(color, vec3(1.0/2.2));\n    \n    if((x < uv.x + 0.005) && (x > uv.x - 0.005))\n    {\n     \tcolor = vec3(0.0, 1.0, 0.0);\t   \n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}