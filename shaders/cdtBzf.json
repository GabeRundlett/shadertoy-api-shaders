{
    "Shader": {
        "info": {
            "date": "1697565477",
            "description": "ga",
            "flags": 0,
            "hasliked": 0,
            "id": "cdtBzf",
            "likes": 1,
            "name": "GA2-fract-001",
            "published": 3,
            "tags": [
                "ga"
            ],
            "usePreview": 0,
            "username": "f_x",
            "viewed": 133
        },
        "renderpass": [
            {
                "code": "\nfloat band(int hz) { \n    int ix = int(float(hz)/23.); \n    return texelFetch( iChannel0, ivec2(ix,0), 0 ).x; \n}\n\nfloat it() {\n    return iTime * 1.2;\n}\n\nvec2 init(vec2 fragCoord, vec2 res) {\n    float ratio = res.y/res.x;\n    vec2 mr = vec2(min(res.x, res.y));\n    vec2 uv = (fragCoord/mr) + vec2(-0.5/ratio, -0.5);\n    return uv;\n}\n\nvec2 sq(vec2 c) {\n    float re = c.x*c.x - c.y*c.y;\n    float im = 2.*c.x*c.y;\n    return vec2(re,im);\n}\n\nfloat amount(vec2 c) {\n    return sqrt(c.x*c.x + c.y*c.y);\n}\n\nint mandel(vec2 c0, vec2 c00, int maxIter) {\n    vec2 c = sq(c0);\n    \n    int iter;\n    for (iter=0;iter < maxIter && amount(c) < 4.; iter++) {\n        c = sq(c - c00);\n    }\n    \n    return iter;\n}\n\nfloat sinp(int n) {\n    return sinp(float(n));\n}\n\nfloat nn(int n) {\n    if (n < 8) return float(n);\n    return float(n) + band(80)*200.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = init(fragCoord,iResolution.xy*.1) - vec2(7.3, 3.8);\n    uv.x += sin(it());\n    uv.y += cos(it());\n    GA2 p = ga(.5, uv.x, uv.y, .8);\n    GA2 q = ga(\n        uv.x*band(400)*8., \n        sin(it()) * band(400)*18.,\n        cos(it()) * band(400)*18., \n        uv.y*band(400)*8.);\n\n    GA2 s = invert(mul(mul(band(100),p),q));\n\n    uv = toVec2(s);\n\n    int N = 100;\n    \n    float ra = band(200)*.01;\n    float rb = band(200)*(.35-band(4000))*.09;//sin(iTime * 1.037) * 0.08;\n    \n    int n = mandel(uv.yx, vec2(.57+ra, .57+rb), N);\n    \n    vec3 col = n == N ? vec3(0) : vec3(\n        sinp(nn(n) / 43.), \n        sinp(nn(n) / 27.)/2., \n        sinp(nn(n) * .2)\n    );\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int Idx_GA2_scalar = 0;\nconst int Idx_GA2_e1 = 1;\nconst int Idx_GA2_e2 = 2;\nconst int Idx_GA2_e12 = 3;\n\nstruct GA2 {\n    float scalar;\n    float e1;\n    float e2;\n    float e12;\n};\n\nGA2 fromArray(float X[4]){\n    return GA2(X[0], X[1], X[2], X[3]);\n}\n\nvoid toArray(GA2 X, inout float X_ary[4]){\n    X_ary[0] = X.scalar;\n    X_ary[1] = X.e1;\n    X_ary[2] = X.e2;\n    X_ary[3] = X.e12;\n}\n\nvoid zero(inout float X[4]){\n    X[0] = 0.0;\n    X[1] = 0.0;\n    X[2] = 0.0;\n    X[3] = 0.0;\n}\n\nGA2 add(GA2 X, GA2 Y){\n    return GA2(X.scalar + Y.scalar, X.e1 + Y.e1, X.e2 + Y.e2, X.e12 + Y.e12);\n}\n\nGA2 add(GA2 X, GA2 Y, GA2 Z){\n    return add(add(X, Y), Z);\n}\n\nGA2 add(GA2 X, GA2 Y, GA2 Z, GA2 P){\n    return add(add(add(X, Y), Z), P);\n}\n\n#define ONE_GA2 GA2(1.0, 0.0, 0.0, 0.0)\n\nGA2 mul(float a, GA2 X){\n    return GA2(X.scalar*a, X.e1*a, X.e2*a, X.e12*a);\n}\n\nGA2 sub(GA2 X, GA2 Y){\n    return GA2(X.scalar - Y.scalar, X.e1 - Y.e1, X.e2 - Y.e2, X.e12 - Y.e12);\n}\n\n#define ZERO_GA2 GA2(0.0, 0.0, 0.0, 0.0)\n\n\n\nGA2 mul(int a, GA2 X){\n    return mul(float(a), X);\n}\n\nGA2 mul(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2 - X.e2*Y.e12 + X.scalar*Y.e1, X.e1*Y.e12 - X.e12*Y.e1 + X.e2*Y.scalar + X.scalar*Y.e2, X.e1*Y.e2 + X.e12*Y.scalar - X.e2*Y.e1 + X.scalar*Y.e12);\n}\n\nGA2 scalar_GA2(float a){\n    return mul(a, ONE_GA2);\n}\n\nGA2 mul(GA2 X, GA2 Y, GA2 Z){\n    return mul(mul(X, Y), Z);\n}\n\nGA2 involve(GA2 X){\n    return GA2(X.scalar, -X.e1, -X.e2, X.e12);\n}\n\nGA2 inner(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2, X.e12*Y.e2 - X.e2*Y.e12, X.e1*Y.e12 - X.e12*Y.e1, 0.0);\n}\n\nGA2 lcontract(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2 + X.scalar*Y.scalar, -X.e2*Y.e12 + X.scalar*Y.e1, X.e1*Y.e12 + X.scalar*Y.e2, X.scalar*Y.e12);\n}\n\nGA2 outer(GA2 X, GA2 Y){\n    return GA2(X.scalar*Y.scalar, X.e1*Y.scalar + X.scalar*Y.e1, X.e2*Y.scalar + X.scalar*Y.e2, X.e1*Y.e2 + X.e12*Y.scalar - X.e2*Y.e1 + X.scalar*Y.e12);\n}\n\n#define I_GA2 GA2(0.0, 0.0, 0.0, 1.0)\n\nGA2 rcontract(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2, -X.e12*Y.e1 + X.e2*Y.scalar, X.e12*Y.scalar);\n}\n\nGA2 reverse(GA2 X){\n    return GA2(X.scalar, X.e1, X.e2, -X.e12);\n}\n\n\n\nGA2 conjugate(GA2 X){\n    return reverse(involve(X));\n}\n\nGA2 outer(GA2 X, GA2 Y, GA2 Z){\n    return outer(outer(X, Y), Z);\n}\n\nGA2 invert(GA2 X){\n    return mul(1.0/lcontract(X,conjugate(X)).scalar, conjugate(X));\n}\n\nGA2 div(GA2 X, GA2 Y){\n    return mul(X, invert(Y));\n}\n\nGA2 dual(GA2 X){\n    return div(X, I_GA2);\n}\n\nvec4 toVec4(GA2 p) {\n    return vec4(p.scalar, p.e1, p.e2, p.e12);\n}\n\nvec2 toVec2(GA2 p) {\n    return vec2(p.e1, p.e2);\n}\n\nGA2 ga(float scale, float e1, float e2, float e12) {\n    return fromArray(float[](scale, e1, e2, e12));\n}\n\n\nfloat sinp(float x) {\n    return (1.+sin(x))/2.;\n}\nfloat cosp(float x) {\n    return (1.+sin(x))/2.;\n}\n\nvec4 colors(GA2 s){\n    float a = s.e1 ;\n    float b = s.e12;\n    float c = s.e2 ;\n    \n    vec3 colors = vec3(a,b,c)*s.scalar/-2.;\n    \n    return vec4(colors, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}