{
    "Shader": {
        "info": {
            "date": "1622610108",
            "description": "Update on my first shader. Used smoothmax to combine torus and sphere and made little spheres rotate in the groove. Currently slow due to nested loops for the little subbearings/burgers. Change AA from 2 to 1 for better performance",
            "flags": 0,
            "hasliked": 0,
            "id": "slf3zl",
            "likes": 3,
            "name": "Raymarched SDF \"bearings\"",
            "published": 3,
            "tags": [
                "raymarching",
                "combiningsdfs"
            ],
            "usePreview": 0,
            "username": "Danimtz",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.001\n#define AA 2\n\n#define PI 3.1415926538\n\n#define SPHERECOUNT 4\n#define SPHERE3 4.0\n#define SPHERE2 3.0\n#define SPHERE1 2.0\n#define PLANE 1.0\nfloat sdSphere(vec3 p, float r)//Signed distance function of sphere\n{\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y); //outer and inner radius 2d\n    return length(q)-t.y; //two symetric circles 2d\n}\n\nvec2 minSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 maxSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x>sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 smax(vec2 sdf1, vec2 sdf2, float k)//smooth\n{\n    float h = max(k - abs(sdf1.x - sdf2.x), 0.0)/k;\n    float bf = h*h*0.5;// blend factor \n    float res = bf*k*(1.0/2.0);\n    \n    return (sdf1.x>sdf2.x) ? vec2(sdf1.x+res, sdf1.y/*mix(sdf1.y, sdf2.y, bf)*/) : \n    vec2(sdf2.x+res, sdf2.y/*mix(sdf1.y, sdf2.y, 1.0-bf)*/);\n}\n\n//Returns origin of rotating sphere\nvec3 calcRotSphereXZ(float ofset, vec3 o, float th)\n{\n    vec2 o_2d = o.xz;//ignore height\n    vec2 p = o_2d+vec2(ofset);\n\n    //translate to origin\n    p -= o.xz;\n\n    //calculate rotation\n    vec2 rot_p;\n    rot_p.x = p.x*cos(th) - p.y*sin(th);\n    rot_p.y = p.x*sin(th) + p.y*cos(th);\n\n    //translate back\n    vec3 res = o;\n    res.xz = rot_p + o_2d;\n\n    return res;\n}\n\n\nvec2 sdBurger(vec3 p, vec3 o, float r, float k, float colourID) // Sphere with torus cut out\n{\n    //torus modifiers\n    float t1 = 0.7; \n    float t2 = 0.3;\n\n    vec3 po = p-o;\n\n    vec2 sdf = vec2(sdSphere(po, r), colourID);\n    sdf = smax(sdf, vec2(-sdTorus(po, vec2(r*t1, r*t2)), colourID), k);\n    return sdf;\n} \n\n\nvec2 map(vec3 p) //Scene geometry information\n{\n    \n    vec2 cur_sdf = vec2(1e10, 0.0);\n\n    //Hollowed sphere\n    vec3 sph_o = vec3(0.0, 2.0, 10.0);\n    vec3 torus = vec3(0.0, 2.0, 10.0);\n    float rp = 2.0;\n    float k = 0.4;\n    float ratio = 0.287; //ratio\n    vec2 combined = vec2(1e10, 0.0);\n    \n    cur_sdf = sdBurger(p, sph_o, rp, k,SPHERE1);\n    \n    //Rotating spheres\n    float r = ratio*rp;\n    float rr = ratio*r;\n    float kk = ratio*k;\n    float kkk = ratio*kk;\n    float theta = 1.0*iTime;\n    int sph_count = SPHERECOUNT;\n    \n    //NOTE: these nested loops are very slow with increasing ammount of spheres. \n    //There are surely better ways to optimize this, but wanted to implement fractalike animation naively\n    for(int i = 0; i < sph_count; i++)\n    {\n        vec3 sph_or = calcRotSphereXZ(1.0, sph_o, theta+(2.0*PI*(float(i)/float(sph_count))));\n        cur_sdf = minSDF(cur_sdf,sdBurger(p, sph_or, r, kk,SPHERE2));\n\n        //Rotating spheres\n        float theta2 = 4.0*theta;\n        for(int j = 0; j < sph_count; j++)\n        {\n            vec3 sph_orr = calcRotSphereXZ(ratio, sph_or, theta2+(2.0*PI*(float(j)/float(sph_count))));\n            cur_sdf = minSDF(cur_sdf,sdBurger(p, sph_orr, rr, kkk,SPHERE3));\n        \n        }\n    \n    }\n    \n\n    //plane\n    cur_sdf = minSDF(cur_sdf, vec2(p.y, PLANE)); //plane\n    return cur_sdf;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.001;\n    vec2 res;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd; //Go along ray\n        res = map(p); //Calc distance to surface, res.x\n        if(res.x < SURF_DIST || dO>MAX_DIST) break;\n        dO += res.x ;\n    }\n    if (dO > MAX_DIST) dO = -1.0;\n    return vec2(dO, res.y);\n}\n\nfloat calcSoftShdw(vec3 ro, vec3 rd, float k)\n{\n    //more info: https://iquilezles.org/articles/rmshadows\n    //Circle circle intersection: https://mathworld.wolfram.com/Circle-CircleIntersection.html\n\n    float res = 1.0; //1.0 if hard shadow\n    float prev_d = 1e10; //previous closest distance to surface\n    for(float t = 0.0; t<MAX_DIST;)\n    {\n        float d = map(ro + t*rd).x;\n        if(d < 0.001){ return 0.0; }\n        float y = d*d/(2.0*prev_d); //y: distance from curr pos to ray midpoint \n        float d_ys = sqrt(d*d-y*y); //d_ms: distance from y to closest surface\n        float sh =  clamp(k*d_ys/max(0.0, t-y),0.0,1.0);\n        \n        res = min(res, sh*sh*(3.0-2.0*sh));//apply smoothstep (3-2x)*x^2\n        prev_d = d;\n        t += d;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    //float d = map(p).x; //get distance to surface\n    vec2 e = vec2(0.01, 0);//error bias for difference\n    vec3 n = normalize(vec3( //find normal using small difference\n            map(p+e.xyy).x-map(p-e.xyy).x,    \n            map(p+e.yxy).x-map(p-e.yxy).x,  \n            map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n    return n;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //Raymarch pixel\n    vec2 res = rayMarch(ro, rd); //distance to point p\n    float d = res.x;\n    //sky colour\n    vec3 col = vec3(0.4, 0.6, 0.8) - 0.7*rd.y;\n    if (d > 0.0){\n\n        vec3 p = ro + d*rd;\n        //colour and lights\n        vec3 mat = vec3(0.0);\n        if(res.y<=PLANE){ mat = vec3(0.017, 0.02, 0.03);}\n        else if(res.y<=SPHERE1){ mat = vec3(0.15);}\n        else if(res.y<=SPHERE2){ mat = vec3(0.05);}\n        else if(res.y<=SPHERE3){ mat = vec3(0.11, 0.07, 0.15);}\n        \n        \n\n        vec3 lpos = vec3(1.5, 1.5, -1.0);\n        float speed = 1.0;\n        //lpos.xz += vec2(sin(iTime*speed), cos(iTime*speed))*2.;\n\n        //light & normal vectors\n        vec3 l = normalize(lpos-0.0);\n        vec3 n = calcNormal(p);\n\n        //diffuse light\n        float dif = clamp(dot(n,l), 0.0, 1.0);\n        float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounce_dif = clamp(0.2+0.2*dot(n,vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        float shdw = calcSoftShdw(p+n*0.05, l, 16.0); //step(rayMarch((p+n*SURF_DIST), l).x, 0.0);//hard shadows\n         \n\n\n        //specular light\n        vec3 h = normalize(l + normalize((ro-p)));\n        float spec = pow(max(0.0, dot(n,h)), 128.0);\n        \n\n        vec3 light_in = vec3(0.0);\n        light_in += vec3(7.0, 5.8, 3.6)*dif*shdw;\n        light_in += vec3(0.5, 0.8, 0.6)*sky_dif;\n        light_in += vec3(0.6, 0.3, 0.1)*bounce_dif;\n\n        col = mat*light_in;\n\n        col += mat*spec*shdw;\n    }\n    return (col);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera/Ray origin\n    vec3 ro = vec3(-cos(0.2*iTime), 2.7, -1.2*sin(0.2*iTime));\n\n    vec3 avrg_col = vec3(0.0);\n#if AA>1 //Supersampling AA\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        //Pixel coordinates\n        vec2 of = vec2(float(i),float(j)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord+of)- .5*iResolution.xy)/iResolution.y;\n#else\n        \n        vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n#endif\n        \n        //Ray direction\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n        \n        //Render scene\n        vec3 col = render(ro,rd);\n        \n        \n\n        avrg_col += col;\n\n#if AA>1      \n    }\n    avrg_col /= float(AA*AA);//Apply AA\n#endif\n    //gamma\n    avrg_col = pow(avrg_col, vec3(0.4545));\n\n    fragColor = vec4(avrg_col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}