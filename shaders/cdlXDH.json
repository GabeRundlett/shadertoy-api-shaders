{
    "Shader": {
        "info": {
            "date": "1668974347",
            "description": "Nothing revolutionary here, just dipping my toes barely into soft body simulation using position based dynamics. Collisions (including self-collisions) are resolved via neighbors.\n\n*mouse to attract gummies*\n*space to reset* \n*shift to render neighbors*",
            "flags": 48,
            "hasliked": 0,
            "id": "cdlXDH",
            "likes": 41,
            "name": "Gummy Worm Pachinko",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "simulation",
                "particles",
                "physics",
                "softbody",
                "gummy",
                "pdb"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 1065
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Nothing revolutionary here, just dipping my toes barely into soft body simulation\n//  using position based dynamics. Rendering is substantially the same as Four-Phase\n//  Fluid Mixer, except I render all densities together because I'm not trying to create\n//  oil-in-water droplets. Also, no need to blur the particles means that performance is\n//  a lot better. The particle sim was converted to position-based (verlet) dynamics to\n//  simplify computations.\n//\n//  Collisions (including self-collisions) are resolved via neighbors as before, but the\n//  worm particles are implicitly aware of the other particles within their own worm. Each\n//  particle solves a length constraint with every other particle in each worm, providing\n//  stretching and bending resistance.\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//  Buffer C renders the particles: rgb contains color, alpha contains density\n//\n// ---------------------------------------------------------------------------------------\n\nvec2 gradient(vec2 fragCoord)\n{\n    vec2 delta = vec2(1., 0);\n    float xGrad = texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy).a;\n        \n    float yGrad = texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy).a - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy).a;\n\n    return 10.*(vec2(xGrad, yGrad));\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    fragCoord *= VIEW_RESTRICT;\n    vec2 grad = gradient(fragCoord);\n\n    vec4 color = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec4 background = textureLod(iChannel1, p, 5.0);\n    float density = color.a;\n    const vec3 lightDir = normalize(vec3(1,-1,1));\n    float gummySpec = computeSpecular(0.8, 15.0, normalize(vec3(-grad.x, 1, -grad.y)), lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    color += gummySpec;\n    vec4 water = texture(iChannel1, p + grad * 0.2) * color; // Refract :)\n    fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); // Blur worm edges\n\n    fxState state = fxGetState();\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y) * 0.004);\n\n    float wallDist = distanceFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution);\n    \n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution) * (1.0 - smoothstep(0.007, 0.01, -wallDist));\n\n    steelNorm = normalize(steelNorm);\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(fragColor, steel, vec4(clamp(-wallDist*iResolution.y, 0.0, 1.0)));\n    if (keyDown(KEY_SHIFT))\n        fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgba);\n    fragColor.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int PARTICLES_PER_WORM = 16;\nconst int MAX_PARTICLES = 1600 * PARTICLES_PER_WORM; \nconst float PARTICLE_REPEL_SIZE = .013;\nconst float VIEW_RESTRICT = .82; // don't show entire image since worms get a bit crowded at the very top when collision first kicks in\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat opRepCircle( in vec2 p, in vec2 c, float r )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    if (mod(p.y+.5, c.y*2.) < c.y) q.x = mod(p.x, c.x) - 0.5*c.x;\n    return sdCircle( q, r );\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x);\n    minDist = min(minDist, VIEW_RESTRICT * resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.);\n    //if (point.y > 0. && point.y < 1.)\n        minDist = min(minDist, opRepCircle(point - 0.5, vec2(0.15), 0.02));\n        \n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution )\n{\n\tvec2 delta = vec2( 0.001, 0.0 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + delta.xy, resolution ); \n    float downTinyChangeInX = distanceFromWalls( point - delta.xy, resolution ); \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    float upTinyChangeInY   = distanceFromWalls( point + delta.yx, resolution ); \n    float downTinyChangeInY = distanceFromWalls( point - delta.yx, resolution ); \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n\tvec2 normal = vec2(tinyChangeInX, tinyChangeInY);\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 prev;\n    \n    ivec4 neighbors[4];\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.prev = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS:  \n        return vec4(p.pos, p.prev);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, 0, 0, 0);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p, float ar)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2((p - b * h) * vec2(ar, 1)); // squared dist to segment\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and neighbors\n// ---------------------------------------------------------------------------------------\n\nconst vec2 GRAVITY = vec2(0., -.00002);\nconst float COLLISION_STIFFNESS = .05;\nconst float CONSTRAINT_STIFFNESS = .3;\nconst float BEND_RESISTANCE = .1;\nconst float MAX_VEL = .003;\nconst float DAMPING = .97;\nconst float BOUNDARY_DIST = .004;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate MAX_PARTICLES amount of particles\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=MAX_PARTICLES) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            // init particles\n            int wormId = id / PARTICLES_PER_WORM;\n            vec3 h1 = hash3(uvec3(wormId) * uvec3(3, 6, 9));\n\n            data.pos = .9*VIEW_RESTRICT * vec2(1, 2) * h1.xy * iResolution.x / iResolution.y + vec2(0, 0);\n            data.pos += rot2(h1.z) * vec2(1, 0) * PARTICLE_REPEL_SIZE * float(id % PARTICLES_PER_WORM);\n            data.prev = data.pos;\n        }\n        else\n        {\n            // handle collisions with neighbors\n            for(int i = 0; i < 4; i++)\n            {\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid == id - 1 || cid == id + 1 || cid==-1 || cid == 0 || cid >= MAX_PARTICLES) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    if (dist < PARTICLE_REPEL_SIZE)\n                    {\n                        data.pos = mix(data.pos, n.pos + PARTICLE_REPEL_SIZE * dir, COLLISION_STIFFNESS);\n                    }\n                }\n            }       \n\n            bool offScreen = data.pos.y < -.5;\n\n            // handle internal worm constraints\n            int wormId = id / PARTICLES_PER_WORM;\n            int beginP = wormId * PARTICLES_PER_WORM;\n            int endP = min(MAX_PARTICLES - 1, beginP + PARTICLES_PER_WORM) - 1;\n            \n            for (int i = beginP; i < endP; ++i)\n            {\n                if (i != id && i < MAX_PARTICLES)// && abs(i - id) <= 1)\n                {\n                    float cLen = abs(float(i - id)) * PARTICLE_REPEL_SIZE * .5;\n                    fxParticle w = fxGetParticle(i);\n                    \n                    if (w.pos.y > -.5) offScreen = false;\n                    \n                    float f = 1. / square(abs(float(i - id)));\n                    if (distance(w.pos, data.pos) < cLen)\n                    {\n                        f *= BEND_RESISTANCE;\n                    }\n                    \n                    data.pos = mix(data.pos, w.pos + cLen * normalize(data.pos - w.pos), CONSTRAINT_STIFFNESS * f);\n                }\n            }\n            \n            // handle teleporting back to top after falling off the bottom (has to be entire worms at once)\n            if (offScreen)\n            {\n                float h = hash3(uvec3(wormId, wormId * iFrame, iFrame)).x;\n                data.pos.x = VIEW_RESTRICT * h * iResolution.x / iResolution.y;\n                data.pos.y += 2.5;\n                data.prev = data.pos;\n            }\n            \n            // handle mouse input\n            if (iMouse.z > 0.)\n            {\n                vec2 m = VIEW_RESTRICT * (iMouse.xy) / iResolution.y;\n                const float MOUSE_RANGE = .05;\n                if (distance(m, data.pos) < MOUSE_RANGE)\n                {\n                    const float MOUSE_STRENGTH = .01;\n                    data.pos = mix(data.pos, m, MOUSE_STRENGTH);\n                }\n            }\n            \n            // handle boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution);\n            if (distToScene < BOUNDARY_DIST)\n            {\n                vec2 distNormal = getNormalFromWalls(data.pos, iResolution);\n                data.pos -= 1.0 * distNormal * (distToScene - BOUNDARY_DIST);\n            }\n            \n            // handle position integration\n            vec2 prev = data.prev;\n            vec2 deltaPos = prev - data.pos;\n            float vel2 = length2(deltaPos);\n            if (vel2 > MAX_VEL * MAX_VEL)\n            {\n                prev = data.pos + inversesqrt(vel2) * deltaPos * MAX_VEL;\n            }\n            data.prev = data.pos;\n            data.pos = data.pos + GRAVITY + (data.pos - prev) * DAMPING;\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 2;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k);\n            //pick random id of particle\n            int p = int(mod(h*34534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes neighbors to each screen pixel to accelerate rendering\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord)\n{\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y;\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 8u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    // search the worm associated with the closest particle, because some of those particles\n    // are likely to be nearby\n    int id = old[0];\n    int wormId = id / PARTICLES_PER_WORM;\n    int beginP = wormId * PARTICLES_PER_WORM;\n    int endP = min(MAX_PARTICLES - 1, beginP + PARTICLES_PER_WORM) - 1;\n    beginP += iFrame % 5;\n\n    for (int i = beginP; i < endP; i += 5)\n    {\n        if (i != id && i < MAX_PARTICLES)// && abs(i - id) <= 1)\n        {\n            insertion_sort(new, dis, i, distance2Particle(i, screen2world(fragCoord)));\n        }\n    }\n\n    int searchIterations = 2;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash3(uvec3(fragCoord, iFrame * searchIterations + k)).x;\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Renders particles: rgb contains color, alpha contains density\n// ---------------------------------------------------------------------------------------\n\nconst vec3 lightDir = normalize(vec3(1,-1,1));\n\nconst float PARTICLE_SIZE = .005;\n\nconst vec3[5] MAT_COLORS = vec3[](vec3(0., 1., 0.),\n                                  vec3(1., .7, 0.),\n                                  vec3(1., 0., 0.),\n                                  vec3(1., 1., 0.),\n                                  vec3(.9, .9, .6));\n\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    p.prev.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(fxLinePointDist2(p.pos, p.prev, fragCoord, iResolution.x / iResolution.y));\n   \n    int material = int(id * 4 / PARTICLES_PER_WORM) % 5;\n    fragColor.a = max(fragColor.a, mix(fragColor.a, 1., 1.-smoothstep(PARTICLE_SIZE * .15, PARTICLE_SIZE * 2., dist)));\n    if (dist < PARTICLE_SIZE)\n    {\n        if (fragColor.xyz == vec3(0))\n            fragColor.xyz = MAT_COLORS[material];\n        else\n            fragColor.xyz = mix(fragColor.xyz, MAT_COLORS[material], .5);\n    }\n    \n    // Render neighbor lines\n    if (keyDown(KEY_SHIFT))\n    {\n        for(int i = 0; i < 4; i++){\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==-1 || cid >= MAX_PARTICLES || cid == 0) continue;\n\n                vec2 otherPos = fxGetParticleData(cid, POS).xy;\n                otherPos.x *= iResolution.y / iResolution.x;\n\n                float distToLin = fxLinePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution.x / iResolution.y);\n                fragColor.xyz += iResolution.x* max(0.0, 0.001 - sqrt(distToLin)) / (0.0004);\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fragColor = vec4(0);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n\n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}