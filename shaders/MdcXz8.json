{
    "Shader": {
        "info": {
            "date": "1457589674",
            "description": "experimenting with blending a decal in linear colorspace; left side is logarithmic alpha blending (multiplicative effect). right side is linear alpha blending (additive effect). Exposure & lambert is simulated on the result, followed by a HDR mixdown.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdcXz8",
            "likes": 7,
            "name": "Decal Blending",
            "published": 3,
            "tags": [
                "linear",
                "alphablending",
                "decal",
                "logspace"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1455
        },
        "renderpass": [
            {
                "code": "// attention: not an exponent, but a factor\n#define EXPOSURE 2.0\n\nfloat m; \n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvec3 srgb2lin(vec3 color) {\n    return color * (color * (\n        color * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 lin2srgb(vec3 color) {\n    vec3 S1 = sqrt(color);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\n\nconst float whitepoint = 398.0 / 335.0 + 0.004;\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat decal(float d, float r) {\n    return smoothstep(0.0, 1.0, (r - d) / r);\n}\n\nvoid blend(inout vec3 color, vec2 p, vec2 s, float ph) {\n    float r = min(s.x, s.y);\n    float d = -sdBox(vec3(p,0.0), vec3(s-r,1.0))+r;\n    \n    d /= r * (0.1 + (sin(iTime)*0.5+0.5)*0.9);\n    \n    d = smoothstep(0.0, 1.0, d);\n    //d = clamp(d, 0.0, 1.0);\n    \n    // defined in srgb\n    vec3 albedo = min(hue2rgb(iTime * 0.01 + ph) + 0.1, 1.0);\n    albedo = mix(albedo,vec3(1.0),0.5);\n    albedo = srgb2lin(albedo);\n    \n    if (p.x < m) {\n        float eps = 0.001;\n        color = pow(color, vec3(1.0 - d)) * pow(albedo, vec3(d));\n    } else {\n        color = mix(color, albedo, d);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    m = (((iMouse.z < 0.5)?0.5:iMouse.x / iResolution.x));\n    m = m * 2.0 - 1.0;\n    m *= iResolution.x / iResolution.y;\n    \n    // defined in srgb\n    vec3 background = min(hue2rgb(iTime * 0.017 + 0.5) + 0.1, 1.0);\n    background = mix(background,vec3(1.0),0.5);\n    background = srgb2lin(background);\n    \n    vec3 color = background;\n    \n    blend(color, uv, vec2(0.5,0.9), 0.333);\n    blend(color, uv, vec2(0.9,0.5), 0.0);\n    blend(color, uv, vec2(0.30,0.30), 0.8);\n    blend(color, uv, vec2(0.25,0.25), 0.0);\n    blend(color, uv, vec2(0.20,0.20), 0.8);\n    \n    color = color*(0.2 + max(cos((uv.y-1.0)*1.57),0.0));\n    \n    color *= EXPOSURE * whitepoint;\n    \t\n    fragColor = vec4(ACESFitted(color) * min(1.0, abs(uv.x - m)*80.0),1.0);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}