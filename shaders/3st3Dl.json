{
    "Shader": {
        "info": {
            "date": "1569496730",
            "description": "practice",
            "flags": 0,
            "hasliked": 0,
            "id": "3st3Dl",
            "likes": 4,
            "name": "icebreak",
            "published": 3,
            "tags": [
                "icebreak"
            ],
            "usePreview": 0,
            "username": "tono",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "\n#define M(x,y) mod(x,y) - y/2.\n#define eq(x,y) (1.-sign(abs(x - y))-0.5)*2.\n#define fsin(x) fract(sin(x))\n#define S(a) clamp(a,1.,0.)\n\nconst float pi = acos(-1.);\nconst float pi2 = pi *2.;\nfloat dsphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat dbox(vec3 p,vec3 s)\n{\n\tp = abs(p) - s;\n\treturn max(p.x,max(p.y,p.z));\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a),c = cos(a);\n\treturn mat2(s,c,-c,s);\n}\n\nvec2 pmod(vec2 p , float r)\n{\n\tfloat a = atan(p.x,p.y) + pi/r;\t\n\tfloat n = pi2/r;\n\ta = floor(a/n) * n;\n\treturn p * rot(-a);\n}\n\nvec3 IFS(vec3 p)\n{\n\tfor(int i = 0; i < 5 ; i++)\n\t{\n\t\tp = abs(p) - 1.5;\n\t\tp.xz = rot(1.) * p.xz;\n\t\tp.xy = rot(1.) * p.xy;\n\t}\n\treturn p;\n}\n\nfloat dist(vec3 p)\n{\n\tp = IFS(p);\n\t\n\tvec3 s = vec3(0.55);\n\tfloat bo = dbox(p , s);\n\t\n\tp = M(p,7.);\n\tfor(int i = 0; i < 4 ; i++)\n\t{\n\t\tp = abs(p) - 1.11;\n\t\tp.xz *= rot(1.);\n\t\tp.xy *= rot(1.);\n\t}\n\t\n\t\n\tp.yz = pmod(p.yz  , 4.);\n\tp.xy = pmod(p.xy  , 4.);\n\t\n\treturn (dbox(p,s));\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 d = vec3(0.001,0.,0.);\n\t\n\treturn normalize(vec3(\n\t\tdist(p.x + d) - dist(p.x - d),\n\t\tdist(p.y + d.yxz) - dist(p.y - d.yxz),\n\t\tdist(p.z + d.zyx) - dist(p.z - d.zyx)\n\t));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n\treturn ((clamp(abs(fract(h + vec3(0.,2.,1.)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = ( fragCoord.xy * 2.- iResolution.xy )/min(iResolution.x,iResolution.y) +  iMouse.xy / min(iResolution.x,iResolution.y);\n\tvec3 color = vec3(.0);\n\t\n    float windowMax = max(iResolution.x,iResolution.y);\n    \n\tfloat t = iTime*2.;\n\t\n\t//p *= rot(t/20.);\n\t\n\tvec3 light = vec3(0.,0.,2.);\n\tvec3 cp = vec3(0.,0.,-2.);\n\tvec3 cd = vec3(0.,0.,1.);\n\tvec3 cu = vec3(0.,1.,0.);\n\tvec3 cs = cross(cd , cu);\n\t\n\tcp += cd * t/2.;\n    //cp += cs * cos(t/18.) * 3.4;\n   // cp.xz *= rot(t/200.); \n    //cp.xy *= rot(t/30.);\n    //cp += cu *t/3.;\n    \n    \n\tfloat target = 2.5;\n\tvec3 rd = normalize(vec3(cu * p.y + cs * p.x + cd * target));\n    \n\tcp += cu * 5.5* clamp(cos(t/20.),-0.8,0.8);\n\tcp += cs * 5.5 * clamp(sin((t + 5.)/20.),-0.8,0.8);\n\t//cp.xy += rot(t / 20.) * cp.xy;\n\t\n\t\n\tfloat depth = 0.0;\n\tfloat ac = 0.0;\n\tvec3 normal;\n    float elect = 0.;\n    vec3 rp;\n\tfor(int i = 0; i < 99 ; i++)\n\t{\n\t\trp = cp + rd * depth + vec3(1.);\n        rp.xz *= rot(1.);\n\t\tfloat d = dist(rp);\n       // cp += step(d,0.001) * step(float(i) ,5.) * cu * 2.;\n        //cp += step(distance(rp,cp),100.) * cu * 10.;\n\t\t//d = max(d , 0.001);\n\t\tif(d < 0.001)\n\t\t{\n            \n\t\t\tnormal = getNormal(rp);\n            elect = clamp(length(rp.xy - cp.xy * S(sin(t/1.)*5.) ),0.,10.);\n\t\t\tbreak;\n\t\t}\t\n\t\tac += exp(-d * 3.);\n\t\tdepth += d;\n\t}\n\t\n\tcolor = vec3(ac/100.);\n\t\n\tfloat h = fract(sin(ac/50.));\n\tfloat s = 1.;\n\tfloat v = 3./ac;\n\t\n\tcolor = hsv(h,s,v);\n    \n    color.b = elect;\n\tcolor = color * pow(dot(normal,light),2.);\n\tfragColor = vec4( color, 1. );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}