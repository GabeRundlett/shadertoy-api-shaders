{
    "Shader": {
        "info": {
            "date": "1540607448",
            "description": "iMouse.x sets sphere period (distance.x between spheres)\niMouse.y sets MAX number of spheres\n\nOR there is bounding interval for the middle line.",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3Bzs",
            "likes": 6,
            "name": "pmod extension interval-bound",
            "published": 3,
            "tags": [
                "conveyor",
                "bound",
                "pmod",
                "mstretch",
                "kerning",
                "inverval",
                "followpath"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "//this hand fan polar symmetry was done by gaz before, similar but different\n//https://www.shadertoy.com/view/4tXGDS\n// https://www.shadertoy.com/view/4tX3DS\n//but it did not use an explicir pmox-subroutine\n\n/*\n//this shader improves on pModInterval\nparent: https://www.shadertoy.com/view/4ttyDN\nby adding a bound to pModInterval\nthis is needed for conveyor-arcs/chains/BookBinding as in\nincomplete: https://www.shadertoy.com/view/4l3Bzs\n\nproblem:\n- flipping/moving pages of a book, or items on a conveyor belt\n- should use mod() folding\n- simple approach is only c1 continuous, it shows in the border.\n- to flatten pages on the top arch, i would still need a long mod() neighborhood.\n- - looping over the whole round top half may still be simpler and faster.\n\n- just normalizing a vector field of isoline-pages would likely much simpler here.\n- ,but not stretching the uvw map on that one\n- would involve arclength() calculations aslongside isolines.\n- - quadratic Bezier (20s cartoon kinematic) knee() function would likely be just fine.\n\nthis function can make an array of dots follow along a segmented path\n, like dots that move around the corners of an F-shape.\nyou just have to get the phase right.\nand then you can hash colors via (hash(r.y)) textureID\n\npModR with bound does not behave too well for negative periods (support for that is hacky and bad)\npModR with bound also hints at how you can use a hash to make some dots invisible\n, by shifting their (r.y) identity to (floor(r.y)-floor(n)), and offsetting their fract() gradient equally.\n\n*/\n\n//_start_ constant irrationals\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n//__end__ constant irrationals\n//_start_ basics\n\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n#define norma normalize\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define cosu5(a) u5(cos(a))\n\n#define viewZoom(t,u,r,m) 9.\n#define Aa(t,u,r,m) min(r.x,r.y)\n//(hl2(r)/floor(mix(1.,hl2(r)*.1,u5(-cos(t)))))\n//viewZoom() returns a float; is defined in a local channel context, to quickly modify its scaling\n//divide by/aa for hairline drawing and sharp smoothstep()\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n\nve0 ad(ve3 a){return dot(ve3(1),a);}ve0 ad(vec3 a){return dot(ve2(1),a);}ve0 ad(vec2 a){return a.x+a.y;}//add vector components\n//for deferred shading IDs:\n#define minx(a,b) mix(b,a,step(a.x,b.x))\n#define manx(a,b) mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b) -minx(-a,-b)\n\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\nvec2 ss(vec2 a,float b){return smoothstep(b,-b,a);}\nvec3 ss(vec3 a,float b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,float b){return smoothstep(b,-b,a);}\n#define aA(t,u,r,m) min(r.x,r.y)\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbowt(float a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\nvec4 ut(vec4 a,ve0 b){return a*(1.-b);}//v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,ve0 b){return a*(1.-b);}//v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,ve0 b){return a*(1.-b);}//v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nve0 ut(ve0 a,ve0 b){return a*(1.-b);}//v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n\n/*i am overthinking this, dot radius shall be irrelevant\n//only distance between dots matters.\n*/\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod(inout float p, float size//mercury.sexy hg_sdf \n){float halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 u,float t,float m//mercury.sexy hg_sdf\n){float g=pi/t\n ,a=atan(u.y,u.x)-g-m\n ,r=length(u)\n ,c=floor(a*.5/g)\n ;a=mod(a,g*2.)-g\n ;u=vec2(cos(a),sin(a))*r\n ;//if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\n\n\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),length(a));}\nvec2 p2c(vec2 a){return vec2(cos(a.x),sin(a.x))*a.y;}//.x  to .x is correct!\n\n\nfloat pageshape(vec2 u,float s){\n ;u.y=abs(u.y)\n ;float l=1.6\n ;u.x=abs(u.x-+l*s)\n ;u.x-=l\n ;return max(u.x,u.y)\n ;}\n\nbool bookBound(float e,float p//limits page numbers\n){return abs(e*2.+.5)<p\n ;}\n\nfloat BookBottomLeft(vec2 u,vec4 m,inout vec4 c\n){\n ;vec2 v=u\n ;v.y=v.y-pi       \n ;v.y=v.y+m.y\n ;float e=pMod(v.y,m.x*2.*pi)\n ;if(bookBound(e,m.z)\n ){v=v+vec2(1,0)\n  ;c.x=pageshape(v,-1.)     \n  ;}\n ;return c.x;\n ;}\n\n\nfloat BookBottomRight(vec2 u,vec4 m,inout vec4 c\n){\n   ;vec2 v=u\n   ;v.y-=m.y\n   ;float e=pMod(v.y,m.x*2.*pi)\n       \n   ;if(bookBound(e-1.,m.z)\n   ){v=v-vec2(1,0)\n    ;c.x=pageshape(v,1.)\n   ;}\n    ;return c.x;}\n\nfloat BookTop(vec2 u,vec4 m,inout vec4 c\n){\n  ;vec2 v=u.yx*vec2(1,-1)//quater rotation and quater offset to rotate the atan() discontinuity \"down\"\n  ;float e = pModPolar(v,1./m.x,m.y-pi*.5); v -= vec2(1,0);\n  ;if(bookBound(e,m.z)\n  ){c.y=pageshape(v,1.)\n  ;}\n ;c.z=length(u)\n ;return c.y\n ;}\n\n//return .xy is position of a dot, .zw a normalVector\n//m.x is distance between papers\n//m.y is m.y os phase (what pages are open)\n//m.z is number of pages \n//m.w is paper thickness\n//the upper bow is always a half-unitCircle around vec2(0)\nvec4 bookPaternosterBeta(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(1)\n ;m.y=m.y*2.-1.\n ;m.y=1.-m.y    \n ;//m.x=(m.x*9.+1.)\n ;m.x=1./(abs(m.x*19.)+1.1)\n ;m.z=1./m.x\n ;m.w=min(abs(m.x),1.)\n ;m.x=m.w*.5\n ;float p=2. //p is half the number of pages\n ;float e\n \n   //;if(u.y<0.//bottom\n //){c.z=abs(u.x)\n //;if(u.x<0.)\n ;e=BookBottomLeft(u,m,c)\n // ;else \n  //;e=BookBottomRight(u,m,c)\n/// ;}\n// ;if(u.y>0.)\n ;//e=BookTop(u,m,c)\n ;c.xyzw=vec4(e)\n     /*\n ;c.z=abs(c.z-1.)\n ;c.xy-=m.w\n ;c.z-=.03 */\n ;//c.xy=min(c.xy,min(c.zz,min(c.yx,c.yy)))\n ;c.w=max(c.z,min(c.y,c.x))\n ;c.w=mix(ss(c.w,2./aA(t,u,r,m)),fract(c.w),.1)\n ;c.xyz=mix(ss(c.xyz,2./aA(t,u,r,m)),fract(c.xyz),.1)\n     \n ;c.xy+=c.ww\n ;//initial versions return .rgba to debug this shit\n ;return sat(c)\n ;}\n\n\n                   \n//hg_sdf pmod extensions\n//problem, pMod alone has no good efficient interval bound with gradients outside of the bound interval\n//pmodInterval() exists, but it has (numerically) bad branches.\n//pModr() fixes this\n//[s] sets period-length, n sets number of [c0 discontinuities] == [tileBorderCount]\nfloat pmod(inout float u,float s){float r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \n\nve0 pModr(inout ve0 p,ve0 s,ve0 n//n==number of repeats (discontinuities), where the smallest discontinuity is at [s]\n){float q=p\n ,f=pmod(q,s)\n ;p=p+.5*s\n ;float o=mix(q,p-s*n,step(n,f ))\n ;      o=mix(o,p    ,step(f,0.))\n ;vec2 r=vec2(o,clamp(f,0.,n))\n ;p=r.x;return r.y;}\n//for u<0 and u>s*n the space condinues linearily, without repetition, this is different from hg_sdf.\n//it also does not set a start, you must just shift u instead\nfloat pModR(inout float p,ve0 s,ve0 n){ve0 r=pModr(p,s,n);p-=s*.5\n ;return (r);}//offset the output for more utility. //floor seems necessary\n//minor flaw; for s==0. special linear case, it still splits a line in 2 segments.\n//pModN() is pModR(), but it ensures a fixed maximum bounding interval via halfpace-cuttoff of N\nfloat pModR(inout float p,ve0 s,ve0 n,ve0 bound\n){n=clamp(n,0.,bound/s)////bound*s/n is the maximum number of n with size s that fits within bound\n ;//problem here is that the righmost one remains, and must be oferwritten by its left neighbor.\n ;float g=sign(n);n=abs(n)//my patch is sign-sensetibve.\n ;float q=p// itcan be caught for having a non integer id (as that interpolates for that one)\n ;float f=pModR(q,s,n)//and this sign batched hack still fails, too much, so just avoid negative intervals on this bound-one!\n ;if(fract(f)!=0.){//if the last dot has a non-integer-id\n     if(p*g>s*(n-1.)){//if we are on the tile of the last dot\n         f=floor(n);p=(p-(s*n)+fract(n)*s)*g;}//it iserased by flooring() its id and shifting it to the identity of its left neighbor\n      //this means, there still exists an invisible border, and both of its sides are seamless.\n     \n     \n         ;}else p=q\n ;return f\n ;}//a bound of pi makes sense in polar coords.\n\n#define repeats (floor(abs(m.y*8.))+2.)\n#define period m.x \n\n\n                        \n\nfloat pModPolar2(inout vec2 u,float t,float m//mercury.sexy hg_sdf\n){float g=pi/t\n ,a=atan(u.y,u.x)-g-m//angle\n ,r=length(u)//distance\n ,c=floor(a*.5/g)//segment factor\n ;a=mod(a,g*2.)-g\n ;u=vec2(cos(a),sin(a))*r\n ;//if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\n/**/\n                          \nvec2 top(vec2 u,vec4 m\n){vec2 r=vec2(2)\n ;//r.x=pModPolar2(u,m.x,m.y)\n ;//r.y=pModPolar2(u,3.,4.)\n ;//r.x=u.y\n ;m.x=abs(m.x) \n ;m.y=pi*.5//m.y is phase!!! //only swivel in positive .my, negative ones are a bit buggy!!!\n     //pi*.5 is a quater rotation\n    //i want to add a totation to that, that is a .5/m.x\n ;m.y+=.45/m.x\n      \n      \n ;m.x=abs(m.x)*7. //m.x is number of segments in a full circle\n ;vec2 v=u.yx*vec2(1,-1)//quater rotation and quater offset to rotate the atan() discontinuity \"down\"\n ;r.y = pModPolar(v,m.x,m.y-pi*.5); v -= vec2(1,0);\n ;//if(bookBound(r.x,m.z)\n ;float h=floor((m.x+m.y)/4.)-2.\n ;if(r.y>h){r.y=floor((m.x+m.y)/4.)-2.\n   \n    ;v=u\n    ;//v.x=abs(u.x)\n    ;m.y+=(h+3.)*m.x//m.y/pi/2.//+m.y/pi/8.\n    ;//pModPolar(v,m.x,m.y-pi*.5);\n    ;v.x+=1.\n    ;//v=c2p(v)\n    ;//v=p2c(v)\n     \n ;}\n   ;h=floor((m.x+m.y)/4.)+1.\n ;if(-r.y>h\n ){r.y=-floor((m.x+m.y)/4.)-1.//*floor(m.y/4.)\n    \n     \n    ;v=u\n    ;m.y+=h*m.x//m.y/pi/2.//+m.y/pi/8.\n    ;//pModPolar(v,m.x,m.y-pi*.5);\n    ;v.x-=1.\n     //;r.y-=1.\n\n ;}\n  \n\n ;v=abs(v)\n  ;r.x=max(v.x,v.y)-.05\n ;//}\n\n ;return r;}\n                          \nvec2 right(vec2 u,vec4 m\n){vec2 r=vec2(0)//.x is a distance, .y is a textureID.\n ;u-=vec2(0,m.y)\n ;r.y=pModR(u.x,period,repeats,2.)//2. is a bound max interval, in which all periods occur\n ;u=abs(u)\n ;r.x=length(u)-.1//max(u.x,u.y)\n ;return r;}\n\nvec2 left(vec2 u,vec4 m\n){vec2 r=vec2(1)//.x is a distance, .y is a textureID.\n ;u+=vec2(0,m.y)\n ;r.y=pModR(u.x,period,repeats)\n ;u=abs(u)\n ;r.x=length(u)-.1//max(u.x,u.y)\n ;return r;}\n\n\nvec4 take2(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(0,0,0,1)\n ;m.x=1.//m.x sets period\n ;m.y=0.//m.y sets phase\n ;vec2 a=right(u,m)\n ;return c;}\n\nve3 mainEntry(ve0 t,ve1 u,ve2 r,ve3 m\n){ve3 c=ve3(1)\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.\n ){m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else m.xy=vec2(cos(iTime)*.75,1)\n ;c.xy=top(u+3.,m)\n ;c.xy=minx(c.xy,right(u,m))\n ;c.xy=minx(c.xy,left(u,m))\n     ;c.x-=.02\n ;vec4 col=vec4(rainbow(c.y*u5(sqrt(5.)),2./6.),1)\n ;c=mix(ss(c.xxxx,.04),fract(c.xxxx),.2)*mix(vec4(1),col,cos(iTime*1.61))\n ;return c;}\n\nvoid mainImage(out ve3 o,in ve1 u){o=mainEntry(iTime,u,iResolution,iMouse);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}