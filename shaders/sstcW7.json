{
    "Shader": {
        "info": {
            "date": "1653581252",
            "description": "I was playing around with mirror effects using raymarching, so I decided to make the main mirror of the James Webb Space Telescope! I imagine this is how the mirrors move :)",
            "flags": 0,
            "hasliked": 0,
            "id": "sstcW7",
            "likes": 5,
            "name": "Mirror into the cosmos",
            "published": 3,
            "tags": [
                "raymarching",
                "hexagon",
                "mirror",
                "telescope",
                "webb",
                "jwst"
            ],
            "usePreview": 0,
            "username": "Roninkoi",
            "viewed": 341
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define MAXIT 200\n#define EPSILON 0.05\n#define STEP 0.5\n\n#define MAXRAYS 4\n#define FAR 5.\n\n#define minx4(a, b) ((a.x) < (b.x) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n\nfloat torus(vec3 r, vec3 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\t\n    return length(max(p, 0.));\n}\n\nvec4 boxn(vec3 r, mat3 rot, vec3 a)\n{\n\tfloat h = 0.001;\n\tfloat z = box(r*rot, a);\n\tfloat z1 = box((r+vec3(h, 0., 0.))*rot, a);\n\tfloat z2 = box((r+vec3(0., h, 0.))*rot, a);\n\tfloat z3 = box((r+vec3(0., 0., h))*rot, a);\n\tvec3 n = normalize(vec3(z1 - z, z2 - z, z3 - z));\n\t\n    return vec4(z, n);\n}\n\nfloat hexp(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\tp.x = clamp(abs(r.x)+(p.y-a.x)*0.57735, 0., 5.*a.x);\n\t\n    return length(max(p, 0.));\n}\n\nvec4 hexpn(vec3 r, mat3 rot, vec3 a)\n{\n\tfloat h = 0.001;\n\tfloat z = hexp(r*rot, a);\n\tfloat z1 = hexp((r+vec3(h, 0., 0.))*rot, a);\n\tfloat z2 = hexp((r+vec3(0., h, 0.))*rot, a);\n\tfloat z3 = hexp((r+vec3(0., 0., h))*rot, a);\n\tvec3 n = normalize(vec3(z1 - z, z2 - z, z3 - z));\n\t\n    return vec4(z, n);\n}\n\nfloat star(vec2 r, float a)\n{\n\tr = mod(r, vec2(2.*3.141, 3.141));\n\treturn length(r-a)-a;\n}\n\nvec4 webb(vec3 r, float roty) {\n\tfloat sqrt3 = 1.73205;\n\t\n\tr = rotY(roty) * r;\n\tmat3 rot = mat3(1.);\n\t\n    float m = sin(t) + 1.;\n    \n    // 04\n    rot = rotX(-0.1*m);\n\tvec4 h1 = hexpn(r+vec3(0., 2., 0.), rot, vec3(0.9, 0.9, 0.3));\n    \n    rot = rotX(0.1*m);\n\th1 = minx4(hexpn(r+vec3(0., -2., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    // 15\n    \n    rot = rotX(0.05*m)*rotY(0.1*m);\n\th1 = minx4(hexpn(r+vec3(-sqrt3, -1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    rot = rotX(-0.05*m)*rotY(-0.1*m);\n\th1 = minx4(hexpn(r+vec3(sqrt3, 1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    // 36\n    \n    rot = rotX(0.05*m)*rotY(-0.1*m);\n\th1 = minx4(hexpn(r+vec3(sqrt3, -1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    rot = rotX(-0.05*m)*rotY(0.1*m);\n\th1 = minx4(hexpn(r+vec3(-sqrt3, 1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n\t\n    float lz = 10.+sin(t)*10.;\n    \n    // 06\n    rot = rotX(-0.2*m);\n\tvec4 h2 = hexpn(r+vec3(0., 4., 0.2), rot, vec3(0.9, 0.9, 0.3));\n    \n    rot = rotX(0.2*m);\n\th2 = minx4(hexpn(r+vec3(0., -4., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 39\n    \n    rot = rotY(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(2.*sqrt3, 0., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n     \n    rot = rotY(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-2.*sqrt3, 0., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 28\n    \n    rot = rotX(-0.1*m)*rotY(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(2.*sqrt3, 2., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotX(0.1*m)*rotY(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-2.*sqrt3, -2., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 410\n    \n    rot = rotX(-0.1*m)*rotY(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-2.*sqrt3, 2., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotX(0.1*m)*rotY(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(2.*sqrt3, -2., 0.3), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 17\n    rot = rotY(-0.1*m)*rotX(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(sqrt3, 3., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotY(0.1*m)*rotX(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-sqrt3, -3., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 511\n       \n    rot = rotY(-0.1*m)*rotX(0.2*m);\n\th2 = minx4(hexpn(r+vec3(sqrt3, -3., 0.3), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotY(0.1*m)*rotX(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(-sqrt3, 3., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n\t\n\tvec4 h = minx4(h1, h2);\n\t\n\th.yzw = rotY(-roty) * h.yzw;\n\t\n\treturn h;\n}\n\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\nvec3 r;\nvec3 rd;\nfloat rs;\nint rnum;\n\nvec4 map()\n{\n\tvec4 d = webb(r + vec3(0., 0., -6.), sin(0.2*t)*0.5);\n    \n    vec3 pn = vec3(0., 0., 1.);\n    float p = plane(r, vec3(0., 0., -2.), pn);\n\t\n    if (p < EPSILON && rnum < MAXRAYS) {\n\t\tr -= rd * rs * STEP;\n\t\trd = normalize(rd-2.*dot(rd, -pn)*(-pn));\n\t\t++rnum;\n\t}\n    if (d.x < EPSILON && rnum < MAXRAYS) {\n\t\tr -= rd * d.x * STEP;\n\t\trd = normalize(rd-2.*dot(rd, d.yzw)*d.yzw);\n        rd = rd * 0.5 + d.yzw * 0.5;\n\t\t++rnum;\n\t}\n    \n    rs = min(d.x, p);\n\t\n\treturn vec4(d.x, vec3(1., 0.65, 0.) * 1.4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    mat3 cam = rotY(-PI) * rotX(0.3);\n\n    vec3 ro = vec3(0., 2.5, 0.0);\n    rd = cam * normalize(vec3(uv * 2., -1.));\n    r = ro;\n\n    vec3 bcol = vec3(0.05 + sin(-uv.y) * 0.7, 0., 0.2)*0.3;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n\t\n\trnum = 0;\n    rs = 1.;\n\n    float sh = 1.;\n    float glow = 0.;\n    \n    for (int i = 0; i < MAXIT; ++i) {\n        vec4 d = map();\n        float z = length(r - ro);\n\n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, d.yzw,\n                shade(normalize(r), rd));\n\t\t\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n        }\n        else {\n            glow += exp(-d.x * 2.);\n        }\n        \n        if (z > 2.*FAR)\n            break;\n\n        rs *= 0.8 - 0.2 * hash(uv+vec2(t*uv.x, t*uv.y));\n        r += rd * rs * STEP;\n\n        sh = (float(i) / float(MAXIT));\n\t}\n\tif (length(r) > FAR) {\n\t\tfloat theta = acos(rd.y);\n\t\tfloat phi = atan(rd.z, rd.x);\n\t\tvec3 sky = vec3(0.05 + sin(-rd.y-0.4) * 0.7, 0., 0.2)*0.3;\n\t\t\n\t\tfloat sr1 = hash(vec2(round(2138.*theta)/2138., round(1140.*phi)/1140.));\n\t\tfloat sr2 = hash(vec2(round(1139.*theta)/1139., round(3142.*phi)/3142.));\n\t\tsky += 2. * vec3(1., 1., 0.5) * min(1., max(0., -(100.+(sin(51.*t*sr1)+cos(49.*t*sr2))*50.)*star(vec2(sr1, sr2), 0.02)));\n\n        col.rgb = mix(col.rgb, sky, 0.9);\n\t}\n\n    if (sh < 0.5)\n        col.rgb *= clamp(exp(-sh * 2. + 0.1), 0., 1.);\n    \n    col.rgb = mix(col.rgb, vec3(1.0, 0.5, 0.0), glow * 0.01);\n\n    fragColor = vec4(col.rgb, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}