{
    "Shader": {
        "info": {
            "date": "1512822004",
            "description": "Example ray-tracing using cylinders, disks, sectors, rings and a box\n\npretty messy still",
            "flags": 0,
            "hasliked": 0,
            "id": "4tffRl",
            "likes": 1,
            "name": "Arcs",
            "published": 3,
            "tags": [
                "cylinder"
            ],
            "usePreview": 0,
            "username": "mdonahoe",
            "viewed": 535
        },
        "renderpass": [
            {
                "code": "/*\n * Arcs\n */\n\n#define PI 3.14159265359\n\n// Simple colors\nconst vec3 blue = vec3(0,0,1);\nconst vec3 white = vec3(1,1,1);\nconst vec3 black = vec3(0,0,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 green = vec3(0,.8,0);\n\n\n#define NO_HIT 0\n#define HIT_BOX 1\n#define HIT_HOOP 2\n#define HIT_ORBIT 4\n#define HIT_SECTOR 6\n#define HIT_PULSE 7\n#define HIT_PAD 8\n#define HIT_PATH 9\n\n\n\n\n// the bad example from IQ's article, Haha!\n// https://iquilezles.org/articles/noacos\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c );\n}\n\n\n// Ray-Plane Intersection Test\nfloat iPlane(vec3 ro, vec3 rd, vec4 plane) {\n\tvec3 n = plane.xyz;\n\tfloat dist = -plane.w;\n\tfloat denom = dot(n, rd);\n\treturn - (dot(n, ro) + dist) / denom;\n}\n\n\nvoid swapIfGreater(inout float x, inout float y) {\n\tif(x>y) {\n\t\tfloat temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t}\t\t\n}\n\n\n// Ray-Sphere Intersection Test\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sph, in float rad) {\n    // Thanks for IQ's ray sphere instruction\n\t// https://iquilezles.org/blog/?p=2411\n\t// This is relating directly to parametric equation\n    // where we define a function xyz = ro + t*rd\n    // solving the quadradic equation below\n \tvec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float t = b*b - c;\n    if( t > 0.0) \n        t = -b - sqrt(t);\n    return t;\n}\n\nfloat intersect_triangle(in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2) {                                     \n    vec3 e1 = v1 - v0;                                                                                                     \n    vec3 e2 = v2 - v0;                                                                                                     \n    vec3 pvec = cross(rd, e2);                                                                                             \n    float det = dot(e1, pvec);                                                                                             \n    if (det < 1e-8 && det > -1e-8) {                                                                                       \n       return 0.0;                                                                                                         \n    }                                                                                                                      \n    float inv_det = 1.0 / det;                                                                                             \n    vec3 tvec = ro - v0;                                                                                                   \n    float u = dot(tvec, pvec) * inv_det;                                                                                   \n    if (u < 0.0 || u > 1.0) {                                                                                              \n        return 0.0;                                                                                                        \n    }                                                                                                                      \n    vec3 qvec = cross(tvec, e1);                                                                                           \n    float v = dot(rd, qvec) * inv_det;                                                                                     \n    if (v < 0.0 || u + v > 1.0) {                                                                                          \n        return 0.0;                                                                                                        \n    }                                                                                                                      \n    return dot(e2, qvec) * inv_det;                                                                                        \n}   \n\nfloat iPath(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b) {\n    vec3 pd = b - a;\n    if (length(pd) < 0.1) {\n        return 0.0;\n    }\n    vec3 right = 0.2 * normalize(cross(pd, vec3(0, 1, 0)));\n    float d0 = intersect_triangle(ro, rd, a - right, a + right, b - right);\n    float d1 = intersect_triangle(ro, rd, a + right, b + right, b - right);\n    if (d0 == 0.0) {\n        return d1;\n    }\n    if (d1 == 0.0) {\n        return d0;\n    }\n    return min(d0, d1);\n} \n\nfloat iArrowsPath(in vec3 ro, in vec3 rd) {\n    vec3 path_start = ro - vec3(0, 1.0, 0.0);\n    vec3 goal_point = vec3(4.0, 1.0, 0.0);\n\n    // Draw a path from the camera to the goal point.\n    float dist = iPath(ro, rd, path_start, goal_point);\n    if (dist > 0.0) {\n        vec3 path_ray = normalize(ro - goal_point);\n        vec3 v = dist * rd + ro - goal_point;\n        float projection = dot(v, path_ray);\n        if (projection < 0.0) {\n            dist = 0.0;\n        } else {\n            vec3 path_point = projection * path_ray;\n            vec3 offset = v - path_point;\n            float l = projection - 0.0;   // TODO(matt): adjust based on width to get arrows\n            if (mod(l, 1.0) < 0.1) {\n                // clear it\n                dist = 0.0;                               \n            }                                                                                       \n        }                                                                                                                  \n    }\n\treturn dist;\n}\n\n// Ray-Box Intersection Test\nfloat iBox(vec3 ro, vec3 rd, vec3 sides, out vec3 normal) {\n\tvec3 axis = normalize(vec3(0.0, 1.0, 0.0));\n\tmat3 rot = rotationAxisAngle(axis, PI/2.);\n\tvec3 xn = rot*vec3(1.0, 0.0, 0.0);\n\tvec3 yn = rot*vec3(0.0, 1.0, 0.0);\n\tvec3 zn = rot*vec3(0.0, 0.0, 1.0);\n\taxis = normalize(vec3(0.0, 1.0, 0.0));\n\txn = rot*xn;\n\tyn = rot*yn;\n\tzn = rot*zn;\t\n\tfloat t1, t2;\n\tfloat tNear = -10000.0;\n\tfloat tFar = 10000.0;\n\t\t\n\t// x -> yz-plane\n\tt1 = iPlane(ro, rd, vec4(xn, -0.5*sides.x));\n\tt2 = iPlane(ro, rd, vec4(xn, 0.5*sides.x));\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = xn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\t// y -> xz-plane\n\tt1 = iPlane(ro, rd, vec4(yn, -0.5*sides.y));\n\tt2 = iPlane(ro, rd, vec4(yn, 0.5*sides.y));\t\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = yn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\t// z -> xy-plane\n\tt1 = iPlane(ro, rd, vec4(zn, -0.5*sides.z));\n\tt2 = iPlane(ro, rd, vec4(zn, 0.5*sides.z));\t\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = zn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\treturn tNear;\n}\n\nfloat iRing(in vec3 ro, in vec3 rd, in vec3 center, in float innerRadius, in float outerRadius) {\n    float t = iPlane(ro, rd, vec4(0,1,0,center.y));\n    if (t <= 0.0) {\n        return -1.0;\n    }\n\tvec3 pt = (t * rd) + ro;\n    vec3 delta = (pt - center);\n\tfloat r = length(delta);\n    bool in_radius = r < outerRadius && r > innerRadius;\n    if (in_radius) {\n        return t;\n    } else {\n    \treturn -1.0;\n    }\n}\n\nfloat mod2pi(float a, float b) {\n    float delta = a - b;\n    return mod(delta + PI, 2.0 * PI) - PI;\n}\n\nbool in_sector(in vec2 v, in float offsetAngle, in float centralAngle) {\n    float delta = mod2pi(offsetAngle, atan(v.y, v.x));\n    return abs(delta) < centralAngle / 2.0;\n}\n\nbool in_sector3(in vec3 ro, in vec3 rd, in float t, in vec3 center, in float startAngle, in float endAngle) {\n\tvec2 v = ((ro + t * rd) - center).xz;\n    return in_sector(v, startAngle, endAngle);\n}\n\n\n// Intersect an uncapped cylindrical section\nfloat iTube(in vec3 ro, in vec3 rd, in vec3 base, in float radius, in float height, in float offsetAngle, in float centralAngle) {\n   \t// Thanks to https://www.shadertoy.com/view/4dSGW1 for the cylinder formula.\n    vec3  delta = ro - base;\n    float a = dot(rd.xz, rd.xz);\n    float b = dot(delta.xz, rd.xz);\n    float c = dot(delta.xz, delta.xz) - radius * radius;\n    float bbac = b*b - a*c;\n    if (bbac > 0.0) {\n        float t = (-b-sqrt(bbac)) / a;\n        vec3 p = ro + t * rd - base;\n        if (t > 0.0 && p.y > 0.0 && p.y < height && in_sector(p.xz, offsetAngle, centralAngle)) {\n            return t;\n        }\n        t = (-b+sqrt(bbac)) / a;\n        p = ro + t * rd - base;\n        if (t > 0.0 && p.y > 0.0 && p.y < height && in_sector(p.xz, offsetAngle, centralAngle)) {\n        \treturn t;\n        }\n    }\n    return -1.0;\n}\n\nfloat iArc(in vec3 ro, in vec3 rd, in vec3 center, in float height,\n           in float innerRadius, in float outerRadius,\n           in float offsetAngle, in float centralAngle) {\n    bool hit = false;\n    float depth = 1e6;\n    float tInnerTube = iTube(ro, rd, center, outerRadius, height, offsetAngle, centralAngle);\n    if (tInnerTube > 0.0 && tInnerTube < depth) {\n    \tdepth = tInnerTube;\n        hit = true;\n    }\n    float tOuterTube = iTube(ro, rd, center, innerRadius, height, offsetAngle, centralAngle);\n    if (tOuterTube > 0.0 && tOuterTube < depth) {\n    \tdepth = tOuterTube;\n        hit = true;\n    }\n    float tUpperRing = iRing(ro, rd, center + vec3(0, height, 0), innerRadius, outerRadius);\n    if (tUpperRing > 0.0 && tUpperRing < depth && in_sector3(ro, rd, tUpperRing, center, offsetAngle, centralAngle)) {\n    \tdepth = tUpperRing;\n        hit = true;\n    }\n    float tLowerRing = iRing(ro, rd, center, innerRadius, outerRadius);\n    if (tLowerRing > 0.0 && tLowerRing < depth && in_sector3(ro, rd, tLowerRing, center, offsetAngle, centralAngle)) {\n    \tdepth = tLowerRing;\n        hit = true;\n\t}\n    if (!hit) {\n        depth = -1.0;\n    }\n    return depth;\n}\n\n// Check given ray against the various arcs\nint intersect( in vec3 ro, in vec3 rd, out float depth, out vec3 normal ){\n\tdepth = 1e6;\n\tint hit_id = NO_HIT; \n\tvec3 boxCenter = vec3(0.0, 1.0, 0.0);\n\tvec3 boxSides = vec3(1.0, 2.0, 1.0)*2.0;\n\tfloat t = iBox(ro - boxCenter, rd, boxSides, normal);\n\tif(t > 0.0 && t < depth ) {\n\t\thit_id = HIT_BOX;\n\t\tdepth = t;\n\t}\n    \n    float s = sin(iTime) + 1.0;\n    float c = 0.5 * cos(iTime) + 1.0;\n\n    float r1 = ro.y / 3.0 + 3.0;\n    vec3 p;\n    t = iArc(ro, rd, vec3(0,-1,0), 0.2, 1.8, r1, 0.0, 2.0 * PI);\n    if (iMouse.z > 0.0) {\n        if (t > 0.0 && t < depth) {\n            p = ro + t * rd;\n    \t\tfloat angle = atan(p.z, p.x);\n            float x = iMouse.x / iResolution.x - 0.5;\n        \tfloat cur = 0.0; // mod(2.0 * iMouse.x / iResolution.x * -3.0 + 2.8 + PI, 2.0 * PI) - PI;\n            float wangle = angle + x;\n            if (abs(wangle - cur) < x) {\n        \t\thit_id = HIT_SECTOR;\n                depth = t;\n            } else  if (wangle < 0.0 && wangle > -2.0 * x && mod(p.x, 0.5) < 0.2) {\n        \t\thit_id = HIT_PAD;\n                depth = t;\n        \t} else if (true) {\n        \t\thit_id = HIT_ORBIT;\n                depth = t;\n        \t}\n        }\n    } else {\n    \tfloat r = 3.5 + 1.0 * sin(iTime);\n        vec3 c2 = vec3(0,-1,0);\n    \tt = iArc(ro, rd, c2, 0.02, 2.5, r + 0.3, 0.0, 2.0*PI);\n    \tp = ro + t * rd;\n        if (t > 0.0 && t < depth && mod(0.3 + r - length(p - c2), 1.0) < 0.8) {// mod(atan(p.z, p.x), 0.2) > 0.021) {\n        \tdepth = t;\n        \thit_id = HIT_ORBIT;\n    \t}    \n    }\n    \n    t = iArc(ro, rd, vec3(0,-1,-12), 0.3, sin(iTime) * 0.5 + 0.5, sin(iTime) * 1.0 + 1.0, 10.0 * iTime, s + PI/2.0);\n    if (t > 0.0 && t < depth) {\n        depth = t;\n        hit_id = HIT_PULSE;\n    }\n    \n    t = iArc(ro, rd, vec3(0,-1,12), 0.5, 0.0, 4.0, -iTime * 1.0, mod(3.0 * iTime, 4.0 * PI));\n    if (t > 0.0 && t < depth) {\n        depth = t;\n        hit_id = HIT_PAD;\n    }\n    \n    t = iArc(ro, rd, vec3(0,-1,12), 0.5, 3.9, 4.1, 0.0, 2.0 * PI);\n    if (t > 0.0 && t < depth) {\n        depth = t;\n        hit_id = HIT_PULSE;\n    }\n    \n    \n    t = iArc(ro, rd, vec3(0,0.2,0), 0.4, 2.1, 2.2, 4.0 * iTime, PI/1.5);\n    if (t > 0.0 && t < depth) {\n        depth = t;\n        hit_id = HIT_PULSE;\n    }\n    \n    vec3 c1 = vec3(0,-1.0,-12);\n    t = iArc(ro, rd, c1, 0.1, 2.0, 4.2, 0.0, 2.0 * PI);\n    if (t > 0.0 && t < depth) {\n    \tp = ro + t * rd - c1;\n\t\tfloat angle = atan(p.z, p.x);\n        float x = 0.4 * sin(iTime) * PI;\n        float alpha = angle + (0.6 * x) * (4.2 - length(p));\n        float w1 = PI / 5.0;\n        float w2 = w1 / 5.0;\n        if (abs(mod2pi(alpha, 0.0)) < w2) {\n            hit_id = HIT_SECTOR;\n            depth = t;\n        } else {\n        \thit_id = HIT_ORBIT;\n            depth = t;\n       \t}\n    }\n    t = iArrowsPath(ro, rd);\n    if (t > 0.0 && t < depth) {\n        hit_id = HIT_PATH;\n        depth = t;\n    }\n    \n\treturn hit_id;\n}\n\n\n\n// Transform from spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p) {\n    vec2 s  = sin(p);\n    vec2 c  = cos(p);\n    return normalize(vec3(c.x * s.y, c.y, s.x * s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Look at point (cd)\n    // Fixed\n    vec3 cd = vec3(0.0, 2.0, 0.0);\n    \n    // Camera origin (co)\n    // Rotate around box, decelerating to a stop, while moving backward.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 camSphe;\n    float x = iTime - 5.0;\n    float y = x * x * x;\n    float decelRamp = max(0.0, -0.05 * y);\n    if (iMouse.z < 1.0) {\n        // If the mouse button is not down, spin the camera automatically\n        camSphe = vec2(decelRamp, PI / 2.0);\n    } else {\n        // Otherwise use the mouse to control camera rotation.\n        vec2 centeredMouse = (iMouse.xy / iResolution.xy - 0.5 * vec2(1, 1));\n        centeredMouse.x = 0.0;\n        camSphe = vec2(0.0, PI / 2.0) + centeredMouse * vec2(5.0, 1.2);\n    }\n    float dist = min(15.0 - 4.0 * camSphe.y, 4.0 + 3.0 * iTime);\n    vec3 co = sphe2cart(camSphe) * dist + vec3(5,8,0);\n    \n\n    // Ray direction (rd)\n    vec3 cf = normalize(cd - co);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    vec3 cr = normalize(cross(cf, cu));\n    cu = cross(cr, cf);\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.0;\n    vec3 rd = normalize(cf + cr * uv.x + cu * uv.y);\n\n\t// Intersection test\n    // Send rays to detect intersections with objects\n    // intersect will return the object type \"hit_id\"\n\t// and set the ray depth and normal at the intersection point\n\tfloat depth;\n\tvec3 normal;\n\tint hit_id = intersect(co, rd, depth, normal);\n\n    // Color based on the object hit, ignore normals.\n\tvec3 intersectColor;\n    float alpha = 1.0;\n\tif(hit_id == HIT_BOX) {\n        intersectColor = vec3(0,0,1);\n    } else if (hit_id == HIT_HOOP) {\n        intersectColor = vec3(1);\n    } else if (hit_id == HIT_ORBIT) {\n        intersectColor = vec3(.1);\n        alpha = 0.8;\n    } else if (hit_id == HIT_SECTOR) {\n    \tintersectColor = green;\n        alpha = 0.9;\n    } else if (hit_id == HIT_PULSE) {\n    \tintersectColor = vec3(1);\n        alpha = 0.9;\n     } else if (hit_id == HIT_PAD) {\n        intersectColor = vec3(1,0,0);\n        alpha = 0.8;\n     } else if (hit_id == HIT_PATH) {\n        intersectColor = vec3(1,1,0);\n        alpha = 0.8;\n    } else {\n    \talpha = 0.0;\n    }\n    vec4 im = texture(iChannel0, fragCoord / iResolution.xy);\n\tfragColor = vec4(intersectColor, alpha) + (1.0 - alpha) * im;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}