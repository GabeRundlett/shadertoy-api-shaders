{
    "Shader": {
        "info": {
            "date": "1504739671",
            "description": "Functional version of scanline algorithm with builtin antialiasing",
            "flags": 0,
            "hasliked": 0,
            "id": "XtXcW4",
            "likes": 1,
            "name": "Scanline with full AA",
            "published": 3,
            "tags": [
                "antialiasing",
                "scanline",
                "algorithm"
            ],
            "usePreview": 0,
            "username": "andrut",
            "viewed": 228
        },
        "renderpass": [
            {
                "code": "// Based on slide on scanline algorithm in NILE presented here: \n//  \"Programming and Scaling\" (2011) https://www.youtube.com/watch?v=YyIQKBzIuBY&t=49m46s \n// It's not very fast but it's super clever and compact; may be useful\n\nfloat ro(vec2 pos, vec2 P, vec2 Q) {\n  return (Q.y - P.y)*(pos.x + 1.0 - (Q.x + P.x)/2.0);\n}\n\nvec2 gamma(vec2 pos, vec2 P) {\n  return vec2(\n    min(pos.x + 1.0, max(pos.x, P.x)),\n    min(pos.y + 1.0, max(pos.y, P.y))\n  );\n}\n\nvec2 omega(vec2 pos, float m, vec2 P) {  \n  return vec2(\n    1./m*(gamma(pos, P).y - P.y) + P.x,\n       m*(gamma(pos, P).x - P.x) + P.y\n  );\n}\n\nfloat coverage(vec2 pos, vec2 A, vec2 B) {\n  float m =(A.y - B.y) / (A.x - B.x); \n  return ro(pos, gamma(pos, A), gamma(pos, omega(pos, m, A)))\n       + ro(pos, gamma(pos, omega(pos, m, A)),gamma(pos, omega(pos, m, B)))\n       + ro(pos, gamma(pos, omega(pos, m, B)), gamma(pos, B));\n}\n\n// ^^^-- That's it! And here's how to use it:\n\nconst float PI = 3.141592653589793238462643383;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // prepare the shape:\n    const int ptsN = 32;\n    vec2 pts[ptsN];\n    for (int i = 0; i < ptsN; ++i) {\n        float a = float(i*2)*PI/float(ptsN) + (iTime-6.0)/30.0 + float(i&1)*sin((iTime-6.0)/36.0)*4.0;\n        float R = float(4+4*(i&3))*iResolution.y/(3.0*5.0)/2.0;\n        pts[i] = iResolution.xy/2.0 + R*vec2(cos(a), sin(a));\n    }\n    \n    // scanline algorithm:\n    float sum = 0.0;\n    for (int i = 0, j = ptsN - 1; i < ptsN; j = i++) {\n      sum += coverage(fragCoord.xy, pts[i], pts[j]);\n    }    \n    \n    float out_c = min(1.0, abs(sum));    \n    fragColor = vec4(out_c, out_c/2.0, 0.0, 1.0);\n    \n    \n    // vertices overlay:\n    float minr = 4.0;\n    for (int i = 0; i < ptsN; i++) {      \n      minr = min(minr, dot(pts[i] - fragCoord.xy, pts[i] - fragCoord.xy));\n    }\n    if (minr < 4.0) fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}