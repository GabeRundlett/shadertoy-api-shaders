{
    "Shader": {
        "info": {
            "date": "1657562136",
            "description": "Riemann zeta function using reflection.\nOriginal by Justaway: https://www.shadertoy.com/view/4lcBDs\nRevised by mia: https://www.shadertoy.com/view/wlKXzh\nI modified the algorithms to improve precision : 4 algorithms for zeta and 2 algoritms for loggamma",
            "flags": 16,
            "hasliked": 0,
            "id": "7s3fDs",
            "likes": 5,
            "name": "Zeta++",
            "published": 3,
            "tags": [
                "zeta",
                "riemann"
            ],
            "usePreview": 0,
            "username": "guil",
            "viewed": 243
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Riemann zeta function using reflection.\n// Original by Justaway: https://www.shadertoy.com/view/4lcBDs\n// Revised by mia: https://www.shadertoy.com/view/wlKXzh\n// Use log gamma function to avoid overflow\n//\n// Method: http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\n//\n// Also optimize log sin and log cos:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\n//\n// Grid lines at Re(z) = 10n, Im(z) = 0.5 (the critical line)\n//\n// Seems accurate up to about Re(z) = 50 or so, then the reflection starts\n// to be misaligned and the purported roots come away from the critical line.\n//\n// <mouse> to move\n// g: show grid\n// r: don't do the reflection\n// x: show Borwein zeta\n// y: show zeta2\n// z: zoomed view\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float LOGPI = 1.1447298858494002;\nconst float LOG2PI = 1.8378770664093453;\nconst float LOG2 = 0.6931471805599453;\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z1, vec2 z2) {\n  return cexp(cmul(z2,clog(z1)));\n}\n\nvec2 cpow(int n, vec2 z2) {\n  return cpow(vec2(n,0),z2);\n}\n\nvec2 cpow(float x, vec2 z2) {\n  return cpow(vec2(x,0),z2);\n}\n\nvec2 csin(vec2 z) {\n    return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\nvec2 ccos(vec2 z){\n  z += vec2(0.5*PI,0);\n  return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\n// Approximations to log(sin(z)) and log(cos(z)) from David Young:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\nvec2 clogsin(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(1.5*pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(0.5*pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(sin(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(1.5*PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(0.5*PI+x, 2.0*PI) - PI);\n  else return clog(csin(z));\n}\n\nvec2 clogcos(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(cos(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(PI+x, 2.0*PI) - PI);\n  else return clog(ccos(z));\n}\n\n// Lanczos approximation for Gamma function\n// See Numerical Recipes\nconst float[8] p = float[](\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  9.9843695780195716e-6,\n  1.5056327351493116e-7\n);\n\nvec2 cloggammaR(vec2 z) {\n  z -= vec2(1,0);\n  vec2 x = vec2(-1.9007e-13,0); // 0.99999999999980993 - 1\n  vec2 pval;\n  int N = 8;\n  // Add smallest first for hopefully increased accuracy.\n  for (int i = N-1; i >= 0; i--) {\n    x += p[i]*cinv(z+vec2(float(i+1),0));\n  }\n  x += vec2(1,0);\n  vec2 t = z + vec2(float(N)-0.5,0);\n  // Original non-log function\n  //return cmul(cmul(cmul(vec2(sqrt(2.0*PI),0.0),cpow(t,z+vec2(0.5,0.0))),cexp(-t)),x);\n  vec2 a = vec2(0.5*LOG2PI,0);\n  vec2 b = cmul(clog(t),z+vec2(0.5,0));\n  vec2 c = -t;\n  vec2 y = a+b+c+clog(x);\n  return y;\n}\n\nvec2 cloggammaL(vec2 z) {\n  vec2 a = vec2(LOGPI,0);\n  vec2 b = clogsin(PI*z);\n  vec2 c = cloggammaR(vec2(1,0)-z);\n  vec2 y = a-b-c;\n  return y;\n}\n\nvec2 cloggamma(vec2 z) {\n  if(z.x > 0.0) return cloggammaR(z);\n  else return cloggammaL(z);\n}\n\n// Spouge's method for loggamma\nvec2 logspouge(vec2 z){\n    const int N = 16;\n    float c = sqrt(2.*PI);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    //s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    //return cdiv(s,z);\n    s = clog(s); \n    s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    return s-clog(z);      \n}\n\nvec2 loggamma(vec2 z){\n  if(z.x > 0.5) return cloggammaR(z);\n  return vec2(LOGPI,0)-clogsin(PI*z)-logspouge(vec2(1,0)-z);\n}\n    \n\n//Basic : using eta definition\nvec2 zeta1(vec2 z){\n  const float N = 256.;\n  vec2 eta = vec2(0);\n  float s=1.;\n  for(float i = 0.; i < N; i++)\n    eta += s*cpow(i+1.,-z),s*=-1.;\n  return cdiv(eta,vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\n//Knopp and Hasse\nvec2 zeta2(vec2 z){\n  const float N = 64.;\n  vec2 sum = vec2(0);\n  for(float i = 0.; i < N; i++){\n    vec2 term = vec2(0);\n    float s = 1.;\n    float bnk = 1.;\n    for(float k = 0.; k < i+1.; k++){\n       term += s*bnk* cpow(k+1.,-z);\n       bnk *= (i-k)/(k+1.);\n       s*=-1.;\n       }\n    sum += term/pow(2.,i+1.);\n    }\n  return cdiv(sum,vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\n//Same algorithm as in mia shader but extended to N = 40\n//ek coeff are calculated on the fly\nvec2 zeta3(vec2 s) {\n  const int N = 80;  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\n\n//Borwein method, valid for z.x > 0    \nvec2 zeta4(vec2 z){\n        \n    int n=30;\n    vec2  eta = vec2(0.);\n\tfloat sig = 1.;\n    float dnn = 1.;//pow(2.,-126.);    \n    float val = dnn;\n\tfor(int i = 1; i<=n ;i++){\n\t\tval *= 2.*float((n+i-1)*(n-i+1))/float((2*i-1)*i);\n\t\tdnn+= val;\t\t\n\t}\n    float dni = 1./dnn;\n    val = dni;\n    for (int i = 1; i < n ; i++) {\n        vec2 s = cpow(float(i),-z);\n        float ci = 1.- dni;\n        eta += sig*ci*s;\n        sig *= -1.;\n        val *= 2.*float((n+i-1)*(n-i+1))/float((2*i-1)*i);\n        dni +=val;\n        }\n    return cdiv(eta,vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\nvec3 gradient(float theta) {\n    vec3 color = vec3(0);\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec3 plotDomain(vec2 z) {\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    float  r = length(z);\n    return gradient(theta) * (fract(log2(r)) / 2.0 + 0.5)*exp(-.05*log(r));\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1), rgb, c.y);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 offset = vec2(3.0*iTime,0);\n    if (iMouse.x > 0.0) {\n      offset -= (2.0*iMouse.xy - iResolution.xy)/iResolution.x*100.0;\n    }\n    float zoom = 10.0;\n    if (keypress(CHAR_Z)) zoom = 2.0;\n    vec2 z = (zoom*uv + offset).yx; // Scale and shift\n    vec2 z0 = z; // Starting value of z\n    if (keypress(CHAR_X)) {\n      z = zeta2(z);\n    } else if (keypress(CHAR_Y)){\n      z = zeta4(z);\n    } else if (keypress(CHAR_W)){\n      z = zeta1(z);\n    } else if (keypress(CHAR_R) || z.x > 0.5){\n      z = zeta3(z);\n    } else {\n      // Reflection\n      vec2 temp = zeta3(vec2(1,0)-z);\n      temp = clog(temp);\n      temp -= loggamma(z)+vec2(LOG2,0);\n      temp += LOG2PI*z;\n      temp -= clogcos(0.5*PI*z);\n      temp = cexp(temp);\n      z = temp;\n    }\n    vec3 color = plotDomain(z);\n    //color = hsv2rgb(vec3(atan(z.y,z.x)/(2.0*PI),1,1));\n    //float k = log(length(z));\n    //k = max(k,1.0/k);\n    //color = hsv2rgb(vec3(k,1,1));\n    if (keypress(CHAR_G)) {\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.x-0.5)));\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.y-10.0*round(z0.y/10.0))));\n    }\n    fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}