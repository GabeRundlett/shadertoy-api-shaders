{
    "Shader": {
        "info": {
            "date": "1650651434",
            "description": "Here is my first attempt at working with buffers :) Was interested in using them to pass other data than just pixels. I also applied some very flimsy \"physics\" :P \nSettings to play with is under Common. \n",
            "flags": 32,
            "hasliked": 0,
            "id": "fllfzM",
            "likes": 7,
            "name": "Flimsy Balls",
            "published": 3,
            "tags": [
                "balls",
                "bounce",
                "hue",
                "buffer",
                "data",
                "store"
            ],
            "usePreview": 0,
            "username": "fyisic123",
            "viewed": 302
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{                                  \n    vec3 ballCol = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;  // fetch pixel from buffer C\n    float LumMask = 1. - ((ballCol.r + ballCol.g + ballCol.b) * .333333); // using luminocity to make a mask \n        \n        \n    vec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y; // create background\n    uv *= vec2(8., 16.) * .5;\n    vec2 ID = floor(uv);\n    uv.x += 0.5 * mod(ID.y, 2.); // offsets every other background tile\n    vec2 gv = fract(uv) - .5;    \n    float bg = 0.0 + (0.05 * fract(iTime * 0.1+ log(abs(gv.x + uv.x)))) * LumMask;  \n    \n    \n    fragColor = vec4(ballCol + bg, 1.);\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )\n\n\n// changes require \"Reset time\" to work (back play arrow)\n#define BALLCOUNT 50\n#define BALL_MIN_SIZE 20. \n#define BALL_MAX_SIZE 30. \n\n#define TIME_SCALE 50.\n#define MAX_VELOCITY 6.\n#define TRACER_INTENSITY 3.5\n\n\nvec2 hash21(float p) // random stuff\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\nfloat hash11(float p)// random stuff\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)// random stuff\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);   // fragCoord as integers      \n    if (iCoord.x > BALLCOUNT || iCoord.y > 1)  // skip pixels with no saved data\n        return;             \n    if (iCoord.y == 0)  // if its top pixel, deal with postion and direction\n    {\n        vec2 pos1,dir1;        \n        if(iFrame  == 0)  // initialize balls by setting start position and start velocity (direction)\n        {\n            vec2 n1 = hash21(iDate.w + fragCoord.x * 123.1234 );\n            vec2 n2 = hash21(iDate.w + fragCoord.x * 321.123);\n            float n = (n2.x + n2.y) * .5;\n            pos1 = iResolution.xy * n1;   \n            \n            dir1 = normalize(n2) * (0.3 + (MAX_VELOCITY * n));\n            if (n1.x + n2.x > 1.)\n                dir1.x *= -1.;\n            if (n1.y + n2.y > 1.)\n                dir1.y *= -1.;\n        }\n        else  // if already initialized fetch data from buffer  \n        {\n            vec4 data = texelFetch(iChannel1, ivec2(iCoord.x, 0),0).rgba;\n            pos1 = data.rg;\n            dir1 = data.ba;           \n        }        \n        \n        vec2 oldPos = pos1;\n        \n        float speed = iTimeDelta *  TIME_SCALE;  // move ball                       \n        pos1 += (dir1 *speed);       \n        \n        if (pos1.x >= iResolution.x || pos1.x <= 0.)  // change direction if outside of screen.\n        {\n            dir1.x *=-1.;\n            pos1.x = oldPos.x;\n        }\n        else if (pos1.y >= iResolution.y|| pos1.y <= 0.)\n        {\n            dir1.y *=-1.;    \n            pos1.y = oldPos.y;\n        }   \n        pos1.x = clamp(pos1.x, 0. , iResolution.x);\n        pos1.y = clamp(pos1.y, 0. , iResolution.y);\n        fragColor = vec4(pos1.x, pos1.y, dir1.x, dir1.y); // save data in buffer\n    }          \n    else // if its second from top pixel, deal with size and hue\n    {\n        if (iFrame == 0) // if its first frame, initiate \n        {\n            float ID = hash11(iDate.w + fragCoord.x);            \n            float size = BALL_MIN_SIZE + ((BALL_MAX_SIZE - BALL_MIN_SIZE) * ID);\n            fragColor = vec4(ID, size, 0., 0.);        \n        }\n        else // otherwise just pass same data.\n            fragColor = texelFetch(iChannel0, ivec2(iCoord.x, 1),0).rgba;                        \n    \n    }        \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);   // fragCoord as integers  \n    if (iCoord.x > BALLCOUNT || iCoord.y > 1) // make sure pixel contains data otherwise return\n        return;               \n    if (iCoord.y == 1) // if its second top pixel, just pass the existing data on and return\n    {\n        fragColor = texelFetch(iChannel0,iCoord,0).rgba;\n        return;\n    }    \n    vec4 data = texelFetch(iChannel0, iCoord,0).rgba;  // fetch data from pixel\n    vec2 pos1 = data.rg;\n    vec2 dir1 = data.ba;\n    float r1 = texelFetch(iChannel0, ivec2(iCoord.x, 1),0).g;\n    \n    for(int i=0; i < BALLCOUNT; i++)  // check all the balls for collisions and apply new velocity.\n    {\n        if (i != iCoord.x)\n        {\n            vec4 otherOBJ = texelFetch(iChannel0, ivec2(i, 0),0).rgba;\n            vec2 pos2 = otherOBJ.rg;        \n            \n            float r2 = texelFetch(iChannel0, ivec2(i, 1),0).g;\n                        \n            float edgeDist = length(pos1-pos2) -r1  -r2;\n            if (edgeDist < 0.)                        \n            {\n                vec2 dir2 = otherOBJ.ba;                \n                float angle = atan(pos2.y - pos1.y, pos2.x - pos1.x);                                \n                pos1.x = clamp(pos1.x + cos(angle) * edgeDist, 0., iResolution.x);\n                pos1.y = clamp(pos1.y + sin(angle) * edgeDist, 0., iResolution.y);\n                vec2 tanVec = normalize(vec2(-(pos2.x - pos1.x), pos2.y - pos1.y));                \n                vec2 relVel = dir2 - dir1;                \n                float valLength = min(dot(relVel, tanVec) , MAX_VELOCITY);\n                vec2 velCompOn = tanVec * valLength ;\n                vec2 velCompPerp = relVel - velCompOn ;\n                dir1 += velCompPerp;  \n                break;\n            }            \n        }\n    }\n    fragColor = vec4(pos1.x, pos1.y, dir1.x, dir1.y); // set the data to buffer                         \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);  // fragCoord as integers\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n                   \n    vec3 col = vec3(0.);               // Creating tracers by taking avarage of nearby pixels  \n    for (int x = -1; x <= 1; x++)      // then avaraging them. You can also just darken each frame. \n        for (int y = -1; y <= 1; y++)  // but this makes it smoother.\n            col += texelFetch(iChannel1,iCoord+ ivec2(x,y), 0).rgb ;   \n    col /= 9.;\n    col = mix(col, texelFetch(iChannel1,iCoord, 0).rgb, .5);    \n    float d = TRACER_INTENSITY * (1.0 / iFrameRate);\n    col = mix(col, vec3(0.) , clamp(d, 0., 1.) );\n    \n                \n    vec3 bCol = vec3(0.);   // Drawing balls using data from buffer B\n    float p =0.;    \n    for(int i=0; i <= BALLCOUNT; i++)\n    {\n        vec2 pos =texelFetch(iChannel0, ivec2(i,0),0).rg;\n        if (length(fragCoord-pos) < BALL_MAX_SIZE)\n        {\n            vec2 data = texelFetch(iChannel0, ivec2(i, 1),0).rg;\n            float size = data.g * 1.5;\n            float l = length(fragCoord-pos);\n        \n            float p = smoothstep(size,size*0.7, l) * 0.1 ;\n            p += smoothstep(size*0.7,0., l) ;\n            \n            vec3 bCol = hue(data.r - (p * 0.15)) * p ;\n            p = 1. - p;\n            col = vec3(\n            bCol.r + col.r * p, \n            bCol.g + col.g * p, \n            bCol.b + col.b * p);\n        \n        }                        \n    }    \n    fragColor = clamp(vec4(col, 1.), 0., 1.); // clamping to avoid issues with tracers.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}