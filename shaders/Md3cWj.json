{
    "Shader": {
        "info": {
            "date": "1520181632",
            "description": "I wanted something more precise than SDF marching, so I made this. Will probably use it in another shader at some point but I thought I'd share as-is.",
            "flags": 0,
            "hasliked": 0,
            "id": "Md3cWj",
            "likes": 6,
            "name": "Simple Cylinder Ray Tracer",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1031
        },
        "renderpass": [
            {
                "code": "// Cylinder Ray Tracer\n// by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// list of cylinders\n// Each cylinder is decribed by a pair of vec4's:\n// vec4( start position, radius ), vec4( end pos, ignored )\nvec4 Scene[] = vec4[](\n    vec4(0,-1.3,0,10), vec4(0,-2,0,0),\n    vec4(0,-1,0,3.5), vec4(0,-2,0,0),\n    vec4(-.7071,-1.+.7071,0,1), vec4(.7071,-1.+3.*.7071,0,0),\n    vec4(0,-1,3,.2), vec4(0,4,3,0),\n    vec4(2.12,-1,2.12,.2), vec4(2.12,4,2.12,0),\n    vec4(3,-1,0,.2), vec4(3,4,0,0),\n    vec4(2.12,-1,-2.12,.2), vec4(2.12,4,-2.12,0),\n    vec4(0,-1,-3,.2), vec4(0,4,-3,0),\n    vec4(-2.12,-1,-2.12,.2), vec4(-2.12,4,-2.12,0),\n    vec4(-3,-1,0,.2), vec4(-3,4,0,0),\n    vec4(-2.12,-1,2.12,.2), vec4(-2.12,4,2.12,0),\n    vec4(0,4,0,3.5), vec4(0,5,0,0)\n    );\n\n\nvec3 Sky( vec3 ray )\n{\n    return vec3(.01);\n}\n\n\n\n#define FLT_MAX 1e38\n\nfloat IntersectCylinder( out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )\n{\n    vec3 m = (a.xyz+b.xyz)/2.;\n    \n    pos -= m; // centre all maths on the cylinder\n    \n    float radius = a.w;\n    vec3 n = (a.xyz-b.xyz)/2.;\n    float l = length(n);\n    n /= l;\n    \n    \n    // intersect infinite cylinder\n    // flatten everything along the axis\n    vec3 r = ray-dot(ray,n)*n;\n    vec3 p = pos-dot(pos,n)*n;\n    float rl = length(r);\n    r /= rl;;\n    float rdp = dot(r,p);\n    float pp = dot(p,p);\n    float q = pp - rdp*rdp;\n    if ( q >= radius*radius ) return FLT_MAX;\n    \n    float d = sqrt(radius*radius-q);\n    float front = (-rdp - d)/rl;\n    float back = (-rdp + d)/rl;\n    normal = normalize(p+front*r*rl);\n    \n    \n    // intersect facing plane\n    float rdn = dot(ray,n);\n    float pdn = dot(pos,n);\n    \n    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }\n    \n    float front2 = (-l-pdn)/rdn;\n    \n    if ( front2 > front )\n    {\n        front = front2;\n        normal = -n;\n    }\n\n    \n    // clip the back sides\n    if (\n        front > back || // clip to back of cylinder\n    \tpdn+rdn*front > l // clip to back plane\n        )\n        return FLT_MAX;\n    \n    return front;\n}\n\n\nfloat Trace( out vec3 normal, vec3 pos, vec3 ray )\n{\n    normal = vec3(0);\n    float t = FLT_MAX;\n    for ( int i=0; i < Scene.length(); i += 2 )\n    {\n        vec3 n;\n        float f = IntersectCylinder( n, Scene[i], Scene[i+1], pos, ray );\n        if ( f > 0. && f < t )\n        {\n            t = f;\n            normal = n;\n            // todo: remember object index for material lookup\n        }\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tvec3 ray = vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, 50./36. );\n    ray = normalize(ray);\n    \n    vec2 a = vec2(sin(iTime*.313)*.3+.08,iTime*.5);\n\tvec3 cam = 5.*vec3(sin(a.y)*cos(a.x),sin(a.x),cos(a.y)*cos(a.x));\n    vec3 target = vec3(-.5,.5,0);\n    \n    vec3 camk = normalize(target-cam);\n    vec3 cami = normalize(cross(vec3(0,1,0),camk));\n    vec3 camj = cross(camk,cami);\n    \n    ray = ray.x*cami + ray.y*camj + ray.z*camk;\n    \n    vec3 normal = vec3(0);\n    float t = Trace(normal,cam,ray);\n    \n    vec3 col = Sky(ray);\n    if ( length(normal) > 0. )\n    {\n        vec3 sun = normalize(vec3(-1,2,3));\n        vec3 testn = vec3(0);\n        Trace(testn,cam+ray*t,sun);\n        \n        vec3 light = vec3(.05,.065,.09)*(normal.y*.3+1.); // ambient\n        if ( length(testn) == 0. )\n        {\n        \tlight += max(0.,dot(normal,sun)) * vec3(1,.95,.92);\n        }\n        \n        col = light*vec3(1);\n        col *= smoothstep(.01,.02,abs(fract( cam+t*ray+.001 )-.5));\n    }\n    \n    fragColour = vec4(pow(col,vec3(1./2.2)),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}