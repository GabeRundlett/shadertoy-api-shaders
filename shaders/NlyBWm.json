{
    "Shader": {
        "info": {
            "date": "1664651862",
            "description": "The Recrystalization algorithm applied to terrain. Sky from xor's Nimbostratus: https://www.shadertoy.com/view/Xl\n*mouse to lower terrain*\n*(0-9) + mouse to raise terrain to that height*\n*shift to toggle fast render mode*\n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "NlyBWm",
            "likes": 65,
            "name": "Dynamic Editable Terrain",
            "published": 3,
            "tags": [
                "terrain",
                "automata",
                "cellular",
                "tiltshift",
                "ising",
                "annealing",
                "atomaton"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 943
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is running the same kind of annealing algorithm as my shader a few days ago:\n//\n//   Metal Recrystalization https://www.shadertoy.com/view/flVBRw\n//\n// At the edge of the rendering range, the material is melted and randomized. You can\n// see this sometimes when the camera swings up, there is a sort of rain where the\n// annealing process takes places and the world is created.\n//\n// Closer to the camera, the mutation rate is slowed, but still remains reactive to\n// edits from the player. The idea of the mouse input is that when you hold a number key,\n// you create terrain at that height. Without a number key, you remove terrain.\n//\n// As the camera moves, the area within Buffer A that is melted moves with it, so that by\n// the time you return, any edits will have been erased by the melting and crystalizing\n// process. And return ye shall, since the buffer itself, rendering, etc are all set up\n// to wrap when the camera reaches the edge.\n//\n// The fancy rendering effects are disabled automatically at very high resolutions,\n// because my computer falls over trying to run them. You can click the shift key\n// to toggle them to override my settings. You might want to disable them to push\n// your FPS up to 60 at some resolutions.\n//\n// Buffer A computes the terrain\n// Buffer B renders with ray march\n// Buffer C renders xor's Nimbostratus for the sky: https://www.shadertoy.com/view/Xl\n// Image applies tilt-shift lens effect\n//\n// --------------------------------------------------------------------------------------------\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  7;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float centerDepth = texelFetch(iChannel0, ivec2(iResolution.xy*0.5), 0).w;\n    float depth = texelFetch(iChannel0, ivec2(u), 0).w;\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    w = (abs(depth-centerDepth)) * 0.015;\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n        O = texture(iChannel0, u/iResolution.xy);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --------------------------------------------------------------------------------------------\n// Computes the terrain height by attempting to match nearby pixels when near the camera.\n// This buffer is set up for wrapping, and hopefully there are no visible artifacts when\n// the camera wraps around.\n// --------------------------------------------------------------------------------------------\n\nconst int MAX_DIRECTIONS = 13;\n\nvoid updateState(inout vec4 state)\n{\n    if (iFrame == 0)\n    {\n        state = vec4(0, 0, 0, 1);\n    }\n    else\n    {\n        state.xy = iMouse.xy;\n        \n        if (keyClick(KEY_SPACE) || abs(state.z) != iResolution.x * iResolution.y)\n        {\n            state.z = -iResolution.x * iResolution.y;\n            \n            // Automatically disable shadows when switching to very high resolutions\n            if (iResolution.y > 1000.) state.w = -1.;\n            else state.w = 1.;\n        }\n        else\n        {\n            state.z = abs(state.z);\n        }\n        \n        if (state.w == 0.) state.w = 1.;\n        state.w += sign(state.w);\n        \n        if (keyClick(KEY_SHIFT))\n        {\n            state.w = -state.w;\n        }\n    }\n}\n\nfloat melt(float h)\n{\n    h = floor(h*(float(MAX_DIRECTIONS)));\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame + int(iDate.w)));\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n    \n    if (ifc == ivec2(0))\n    {\n        updateState(fragColor);\n        return;\n    }\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float directions = float(MAX_DIRECTIONS);\n    \n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = melt(h.x);\n        fragColor.yzw = vec3(0);\n    }\n    else\n    {\n        float time = float(iTime);\n        vec2 mouse = iMouse.xy;\n\n        // Apply heat everywhere but a circle around the camera position\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(time, mouse, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n        \n        vec2 p = mod(cameraPos.xz * iResolution.y * 0.1, iResolution.xy);\n\n        float TEMP_SCALE = 3.0 / iResolution.y;\n        float t = distance(p, fragCoord)*TEMP_SCALE;\n        \n        // Copy the circle multiple times to handle wraparound conditions\n        t = min(t, distance(p + iResolution.xy*vec2(1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 0), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(0, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, -1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(-1, 1), fragCoord)*TEMP_SCALE);\n        t = min(t, distance(p + iResolution.xy*vec2(1, -1), fragCoord)*TEMP_SCALE);\n        \n        // Handle mouse input\n        if (iMouse.z > 0. && iMouse.w < 0. && state.xy != vec2(0))\n        {\n            vec3 fromLookAt, fromPos, fromFwd, fromLeft, fromUp;\n            fxCalcCamera(time - iTimeDelta, mouse, fromLookAt, fromPos, fromFwd, fromLeft, fromUp);\n\n        \tvec3 rayFrom = fxCalcRay(state.xy, iResolution, fromFwd, fromUp, fromLeft);\n        \tvec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n            float fromT = cameraPos.y / rayFrom.y;\n            vec3 fromHit = cameraPos - fromT * rayFrom;\n            vec2 projFrom = mod(fromHit.xz * iResolution.y * 0.1, iResolution.xy);\n            float toT = cameraPos.y / rayTo.y;\n            vec3 toHit = cameraPos - toT * rayTo;\n            vec2 projTo = mod(toHit.xz * iResolution.y * 0.1, iResolution.xy);\n            \n            if (distance(projFrom, projTo) < iResolution.y * 0.3)\n            {\n                float dist = linePointDist2(projFrom, projTo, fragCoord);\n\n                float targetHeight = 0.;\n                for (int i = 1; i <= 9; ++i)\n                {\n                    if (keyDown(KEY_0 + i))\n                    {\n                        targetHeight = float(i) + 2.;\n                    }\n                }\n\n                if (dist < iResolution.y*0.25)\n                {\n                    if (fragColor.r > targetHeight)\n                    {\n                        fragColor.r -= 0.01 * iResolution.y / (dist + 1.0);\n                    }\n                    else if (fragColor.r < targetHeight)\n                    {\n                        fragColor.r +=  0.01 * iResolution.y / (dist + 1.0);\n                    }\n                }\n            }\n        }\n        fragColor.r = clamp(fragColor.r, 0., float(MAX_DIRECTIONS));\n    \n        float annealChance = mix(0.02, 0.5, smoothstep(1800., 3000., iResolution.y));\n        if (abs(state.w) < 20.) annealChance *= 10.;\n        if (t > 1.1 + 0.9 * h.x)\n        {\n            // Melting temp\n            fragColor.x = melt(h.y);            \n        }\n        else if (h.y < annealChance)\n        {\n            // Count how many neighbors in range have each possible direction\n            int counts[MAX_DIRECTIONS];\n            for (int i = 0; i < int(directions); ++i)\n            {\n                counts[i] = 0;\n            }\n\n            const int RANGE = 2;\n            for (int x = -RANGE; x <= RANGE; ++x)\n            {\n                for (int y = -RANGE; y <= RANGE; ++y)\n                {\n                    ivec2 ni = ifc + ivec2(x, y);\n                    if (ni == ivec2(0)) continue; // Ignore state pixel\n                    vec4 n = texture(iChannel0, (vec2(ni) + 0.5) / iResolution.xy);\n                    counts[int(n.x)]++;\n                }\n            }\n\n            // Find the direction most popular among neighbors\n            int bestCount = -1;\n            int bestDir;\n            bool unique;\n\n            for (int d = 0; d < int(directions); ++d)\n            {\n                if (counts[d] > bestCount)\n                {\n                    bestCount = counts[d];\n                    bestDir = d;\n                    unique = true;\n                }\n                else if (counts[d] == bestCount)\n                {\n                    unique = false;\n                }\n            }\n\n            if (unique)\n            {\n                if (abs(fragColor.x - float(bestDir)) > h.x * directions*0.001)\n                    fragColor.x = float(bestDir);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid fxCalcCamera(in float time, in vec2 mouse, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    time *= 0.1;\n    \n    cameraLookAt = vec3(time + 0.5*sin(time), 1.0 + 0.6 * sin(time*0.6), time + 0.5*cos(time));\n    cameraPos = vec3(time-0.1 + 0.5*sin(time-0.1), 1.1 + 0.6 * sin(time*0.6-0.02), time-0.1 + 0.5*cos(time-0.1));\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_0 48",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// --------------------------------------------------------------------------------------------\n// Render the scene via ray marching, with shadows.\n// --------------------------------------------------------------------------------------------\n\nconst float LAYER_HEIGHT = 0.004;\n\nfloat scene(vec3 p, float t)\n{\n    p.x *= iResolution.y/iResolution.x;\n    float h = textureLod(iChannel0, p.xz*0.1, 0.).r + textureLod(iChannel0, p.xz*0.1, 1.).x;\n    float height = p.y - max(6.,h)*LAYER_HEIGHT;\n    \n    return min(height, p.y + .05);\n}\n\nvec3 grad(vec3 p, float t, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return normalize(\n           vec3(scene(p + delta.xyy, t) - scene(p - delta.xyy, t),\n                scene(p + delta.yxy, t) - scene(p - delta.yxy, t),\n                scene(p + delta.yyx, t) - scene(p - delta.yyx, t)));\n}\n\nconst float MAX_T = 6.0;\nconst float SDF_EPSILON = 0.002;\nvec3 rayMarch(vec3 pos, vec3 dir, float scale, out float t)\n{\n    t = 0.;\n    for (int i = 0; i < 250; ++i)\n    {\n        float d = scene(pos, scale);\n        \n        if (d < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        float slowdown = max(d * 0.1, 0.2);\n        t += d * slowdown;\n\n        pos += dir * d * slowdown;\n    }\n \n    return pos;\n}\n\nvec4 render(vec3 cameraPos, vec3 rayDir, bool doShadow, out vec3 hitPos, out vec3 normal)\n{\n    float t;\n    hitPos = rayMarch(cameraPos, rayDir, float(iFrame), t);\n\n    normal = grad(hitPos, float(iFrame), 0.01);\n    vec3 offsetPos = hitPos + normal*SDF_EPSILON;\n\n    // Compute color\n    vec3 h = hash(uvec3(100.*vec3(hitPos.x, hitPos.y, hitPos.z)));\n    vec3 hGrass = hash(uvec3(100.*vec3(hitPos.x, hitPos.z, hitPos.x)));\n    float splotches = (h.x * 0.5 + 0.5);\n    float splotchesGrass = (hGrass.x * 0.5 + 0.5); // Use x,z splotch pattern for grass, to fix rendering artifact\n    vec3 color = vec3(0.8, 0.4, 0.1) * splotches;\n    if (dot(normal, vec3(0, 1, 0)) > 0.8) color = vec3(0., 1.0, 0.) * splotchesGrass;\n    if (hitPos.y <= 9.*LAYER_HEIGHT) color = vec3(0.9, 0.9, 0.5) * splotches;\n    if (hitPos.y <= 7.*LAYER_HEIGHT)\n    {\n        color = vec3(0.5, 0.5, 1.0);\n    }\n    \n    // Apply light and shadow\n    vec3 lightDir = normalize(vec3(0, 0.4, 1));\n    const float AMBIENT = 0.3;\n\n    float shadowT = MAX_T;\n    \n    if (doShadow)\n    {\n        rayMarch(offsetPos, lightDir, float(iFrame), shadowT);\n    }    \n    \n    if (shadowT < MAX_T)\n    {\n        color = color * AMBIENT;\n    }\n    else\n    {\n        float dp = max(0., dot(normal, lightDir));\n        color = color * (dp + AMBIENT);\n    }\n    \n    // Fade at distance\n    if (t >= MAX_T*.75)\n    {\n        // Pebble texture == clouds\n        vec3 sky = texture(iChannel1, rayDir.xy * 0.6 + 0.5).xyz;\n        //vec3 sky = mix(vec3(0.0, 0.0, 0.1), vec3(1), texture(iChannel1, rayDir.xy * 0.6 + 0.5 ).rrr);\n        color = mix(color, sky, smoothstep(MAX_T*.75, MAX_T, t));\n    }\n    \n    return vec4(color, t);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float time = float(iTime);\n    vec2 mouse = iMouse.xy;\n    bool doShadow = state.w >= 0.;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(time, mouse, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    \n    vec3 hitPos, normal;\n    vec4 colorT = render(cameraPos, rayDir, doShadow, hitPos, normal);\n\n    // Handle reflections\n    if (hitPos.y <= 7.*LAYER_HEIGHT && doShadow)\n    {\n        float reflectT;\n        vec3 reflectHitPos, reflectNormal;\n        vec4 reflectColorT = render(hitPos + normal*SDF_EPSILON, reflect(rayDir, vec3(0, 1, 0)), state.w== 0., reflectHitPos, reflectNormal);\n        colorT.xyz = mix(colorT.xyz, reflectColorT.xyz, 0.4);\n    }\n    \n    fragColor = colorT;\n    \n#if 0 // Debug terrain texture\n    fragColor = sin(texelFetch(iChannel0, ivec2(fragCoord), 0).r + vec4(2, 3, 4, 5));\n    fragColor.w = 0.;\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// xor's Nimbostratus: https://www.shadertoy.com/view/XlfyD7\n\nfloat Speed = .001;\nvec3 Light = vec3(.6,.2,.8);\n    \nfloat Map(vec3 Position)\n{\n    vec3 P = (Position*0.5+texture(iChannel0,Position*2.+iTime*Speed*.2).xyz*.02);\n    \n    float C = texture(iChannel0,P).r;\n    C *= texture(iChannel0,P*vec3(.5,1,.5)).g;\n    C = C*.9+.1*pow(texture(iChannel0,P*5.1).a,2.);\n    return max((C-.3)*sqrt((Position.z-.1)/.3),0.)/.5;\n}\nvoid mainImage(out vec4 Color,in vec2 Coord)\n{\n    vec3 R = vec3((Coord-.5*iResolution.xy)/iResolution.y,1);\n    vec3 P = vec3(0,iTime*Speed,0);\n    \n    vec4 C = vec4(0);\n    for(float I = .2;I<.5;I+=.01)\n    {\n        float M1 = Map(P+R*I);\n        float M2 = Map(P+R*I+Light*.01);\n        C += vec4((.6+vec3(.6,.5,.4)*(exp(-M2*10.)-M1)),1)*M1*(1.-C.a);\n        if (C.a>.99) break;\n    }\n\tColor = C+vec4(vec3(.5,.7,.9)-R.y*.4,1)*(1.-C.a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}