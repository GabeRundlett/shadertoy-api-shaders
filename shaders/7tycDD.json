{
    "Shader": {
        "info": {
            "date": "1661470617",
            "description": "Implementation of an algorithm for limited repetition of Hexagonal SDFs in a Hexagonal Grid.\nBased on the works of Inigo Quilez (https://iquilezles.org) and Red Blob Games (https://redblobgames.com/grids/hexagons).",
            "flags": 0,
            "hasliked": 0,
            "id": "7tycDD",
            "likes": 10,
            "name": "Hexagonal Limited Repetition SDF",
            "published": 3,
            "tags": [
                "sdf",
                "repetition",
                "hexagon",
                "distance",
                "field",
                "hex",
                "tile",
                "hexagonal",
                "tilling",
                "signed",
                "limited"
            ],
            "usePreview": 0,
            "username": "josaid",
            "viewed": 319
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2022 João Pedro Braz (brazjoaopedro@ymail.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define CAMERA_ZOOM 16.0\n#define GRID_RADIUS 8.0\n#define HEX_RADIUS 0.5\n#define HEX_MARGIN 0.0\n#define ANIMATED 1\n// Modes:\n// 0 - Naive Approach (Clamp and query the closest neighbor, from all sides)\n// 1 - Directed Approach (Similiar to #0, but excludes the opposite neighbor)\n// 2 - SDF Approach (Treat the whole grid as a hexagon and compute the signed distance to it)\n// 3 - Another version of #2, but using Inigo Quilez's SDF function\n#define CLAMPING_MODE 0\n\nconst float PI = 3.141592653589793;\nconst float SQRT_3 = 1.732050807568877;\nconst float HALF_SQRT_3 = 0.8660254037844386;\nconst float THIRD_SQRT_3 = 0.5773502691896258;\nconst float THIRD = 0.33333333333333334;\nconst float TWO_THIRDS = 0.6666666666666667;\nconst float THREE_HALFS = 1.5;\nconst float EPSILON = 0.00000001;\n\nconst vec3 KERNEL = vec3(-HALF_SQRT_3, 0.5, THIRD_SQRT_3);\n\nconst vec3 DIRECTIONS[6] = vec3[6](\n    vec3(1.0, 0.0, -1.0),\n    vec3(0.0, 1.0, -1.0),\n    vec3(-1.0, 1.0, 0.0),\n    vec3(-1.0, 0.0, 1.0),\n    vec3(0.0, -1.0, 1.0),\n    vec3(1.0, -1.0, 0.0)\n);\n\n// Transformation Utilities\nvec2 translate(vec2 point, vec2 by);\nvec2 scale(vec2 point, vec2 scale);\n\n\n// Hex Utilities\nvec3 neighbor(int direction);\nfloat distance_from_center(vec3 hex);\nbool is_inside_grid(vec3 hex, float half_width);\nvec3 cube_round(vec3 cube);\nvec3 uv_to_hex(vec2 uv, float size);\nvec2 hex_to_uv(vec3 hex, float size);\nvec3 uv_to_hex_clamped(vec2 uv, float size, float half_width);\n\n\n// SDF Utilities\nfloat sd_hexagon(vec2 point, float half_size);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Resolution dependent antialiasing, used with smoothstep\n\tfloat aa = 1.0 / min(iResolution.y, iResolution.x) * 10.0 * CAMERA_ZOOM;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Compute zoom taking into account the current aspect ratio\n\tvec2 zoom = iResolution.xy * CAMERA_ZOOM / min(iResolution.y, iResolution.x);\n    \n    // Our camera offset\n    vec2 camera_offset = vec2(0.0, 0.0);\n    if (iMouse.z > EPSILON) {\n        camera_offset = iMouse.xy / iResolution.xy;\n        camera_offset = scale(translate(camera_offset, vec2(0.5, 0.5)), zoom);\n    }\n    \n    // Center and scale the UV\n\tvec2 point = translate(scale(translate(uv, vec2(0.5, 0.5)), zoom), camera_offset);\n    \n    // Compute the current Hexagon in Cube Coordinates\n\tvec3 hex = uv_to_hex_clamped(point, HEX_RADIUS, GRID_RADIUS);\n    \n    // Get the center of the Hexagon\n\tvec2 center = hex_to_uv(hex, HEX_RADIUS);\n    \n    // Transform our UV into the Local Coordinate System of the Hexagon\n\tvec2 relative_point = (point - center) / HEX_RADIUS;\n\t\n    // Compute the SDF\n    float roundness = 0.0;\n#if ANIMATED == 1\n    roundness = cos(iTime * 0.75) * 1.1 + 1.5;\n#endif\n\tfloat signed_distance =\n        sd_hexagon(relative_point * (HEX_MARGIN + HEX_RADIUS + roundness), HEX_RADIUS) - roundness;\n\t\n    // Inigo Quilez's Color Scheme\n    vec3 color = vec3(1.0) - sign(signed_distance) * vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-2.0 * abs(signed_distance));\n\tcolor *= 0.8 + 0.2 * cos(signed_distance);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01 + aa, abs(signed_distance)));\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n// -- Star of the show --\nvec3 uv_to_hex_clamped(vec2 uv, float radius, float grid_radius) {\n    // Compute which Hexagon does the UV maps to\n\tvec3 hex = uv_to_hex(uv, radius);\n\t\n    // Check whether the Hexagon is outside the grid\n    // If so, apply our clamping algorithm\n\tif (!is_inside_grid(hex, grid_radius)) {\n\n#if CLAMPING_MODE == 0\n\n        // Clamp the hex to be just inside the grid\n        vec3 remapped_hex = cube_round(\n\t\t\thex / distance_from_center(hex) * grid_radius\n\t\t);\n\n        // Search for the closest neighbor\n        bool local_minimum_empty = true;\n        vec4 local_minimum = vec4(0.0);\n\n        // Search every neighbord (including itself), except the one in the opposite direction\n        float direction = floor(3.0 * (atan(uv.y, -uv.x) + PI) / PI);\n\t\tvec4 neighbor_hex = vec4(remapped_hex, 0.0);\n        // -2 to 2 + 1 for itself\n\t\tfor (int i = -2; i <= 3; i++) {\n\t\t\t// Pick only those inside the grid\n\t\t\tif (is_inside_grid(neighbor_hex.xyz, grid_radius)) {\n\t\t\t\tneighbor_hex.w = length(hex_to_uv(neighbor_hex.xyz, radius) - uv);\n\t\t\t\t\n\t\t\t\tif (local_minimum_empty || neighbor_hex.w < local_minimum.w) {\n\t\t\t\t\tlocal_minimum = neighbor_hex;\n\t\t\t\t\tlocal_minimum_empty = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tneighbor_hex = vec4(neighbor(int(mod(direction + float(i), 6.0))) + remapped_hex, 0.0);\n\t\t}\n        \n        // Return what we found\n        return local_minimum.xyz;\n        \n#elif CLAMPING_MODE == 1\n\n        // Clamp the hex to be just inside the grid\n        vec3 remapped_hex = cube_round(\n\t\t\thex / distance_from_center(hex) * grid_radius\n\t\t);\n\n        // Search for the closest neighbor\n        bool local_minimum_empty = true;\n        vec4 local_minimum = vec4(0.0);\n        \n        // Search every neighbord and itself\n        for (int i = -1; i < 6; i++) {\n            vec4 neighbor = vec4(neighbor(i) + remapped_hex, 0.0);\n        \n            // Pick only those inside the grid\n            if (is_inside_grid(neighbor.xyz, grid_radius)) {\n                neighbor.w = length(hex_to_uv(neighbor.xyz, radius) - uv);\n\n                if (local_minimum_empty || neighbor.w < local_minimum.w) {\n                    local_minimum = neighbor;\n                    local_minimum_empty = false;\n                }\n            }\n        }\n        \n        // Return what we found\n        return local_minimum.xyz;\n        \n#elif CLAMPING_MODE == 2\n    \n        // Compute the angle from the uv to the center\n        float angle = mod(atan(uv.y, uv.x) - PI / 2.0, PI / 3.0);\n        // Get the distance \n        float dist = SQRT_3 * SQRT_3 * radius * grid_radius + radius;\n        dist /= SQRT_3 * cos(angle) + sin(angle);\n\n        // Instead of returning the result hexagon, we could pass it to the CLAMPING_MODE == 1\n        // Left as an exercise to the reader.\n        return uv_to_hex(\n            uv / length(uv) * dist,\n            radius\n        );\n\n#elif CLAMPING_MODE == 3\n    \n        // vec2(uv.y, uv.x) so that the resulting SDF if of a pointy hexagon\n        float grid_size = SQRT_3 * radius * (grid_radius - 1.0);\n        float signed_distance = sd_hexagon(vec2(uv.y, uv.x), grid_size);\n\n        return uv_to_hex(\n            uv - uv * signed_distance / length(uv),\n            radius\n        );\n\n#endif\n\n\t}\n\n\treturn hex;\n}\n\n\n// -- Transformation Utilities Implementations --\nvec2 translate(vec2 point, vec2 by) {\n    return point - by;\n}\n\nvec2 scale(vec2 point, vec2 scale) {\n    return point * scale;\n}\n\n// -- Hex Utilities Implementations --\n// Please check out https://www.redblobgames.com/grids/hexagons/\n// The source of most these functions.\nfloat distance_from_center(vec3 hex) {\n    return max(max(abs(hex.x), abs(hex.y)), abs(hex.z));\n}\n\nbool is_inside_grid(vec3 hex, float grid_radius) {\n\treturn (\n\t\tabs(hex.x) <= grid_radius && \n\t\tabs(hex.y) <= grid_radius && \n\t\tabs(hex.z) <= grid_radius\n\t);\n}\n\nvec3 neighbor(int direction) {\n    return direction == -1\n        ? vec3(0.0)\n        : DIRECTIONS[direction];\n}\n\n// Justin Pombrio's\n// https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 cube_round(vec3 cube) {\n\tfloat a = ceil(cube.x - cube.y);\n    float b = ceil(cube.y - cube.z);\n    float c = ceil(cube.z - cube.x);\n\t\n\treturn vec3(\n\t\tround((a - c) / 3.0),\n\t\tround((b - a) / 3.0),\n\t\tround((c - b) / 3.0)\n\t);\n}\n\nvec3 uv_to_hex(vec2 uv, float size) {\n\tfloat q = uv.x * TWO_THIRDS / size;\n\tfloat r = (-THIRD * uv.x + THIRD_SQRT_3 * uv.y) / size;\n\tfloat s = -q - r;\n\n\treturn cube_round(vec3(q, r, s));\n}\n\nvec2 hex_to_uv(vec3 hex, float size) {\n\tfloat x = THREE_HALFS * hex.x * size;\n\tfloat y = ((HALF_SQRT_3 * hex.x) + (SQRT_3 * hex.y)) * size;\n\t\n\treturn vec2(x, y);\n}\n\n// -- SDF Utilities Implementations --\n// Please check out https://iquilezles.org/articles/distfunctions2d/\n// For other SDF functions\nfloat sd_hexagon(vec2 point, float radius) {\n    point = abs(point);\n    point -= 2.0 * min(dot(KERNEL.xy, point), 0.0) * KERNEL.xy;\n    point -= vec2(clamp(point.x, -KERNEL.z * radius, KERNEL.z * radius), radius);\n    return length(point) * sign(point.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}