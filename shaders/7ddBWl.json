{
    "Shader": {
        "info": {
            "date": "1657478729",
            "description": "Hex Directional Flow with a cyclone flow map and a Sinewave perpendicular to the Flow Vector like water waves",
            "flags": 0,
            "hasliked": 0,
            "id": "7ddBWl",
            "likes": 1,
            "name": "Wind Waves of Cyclone using SDF",
            "published": 3,
            "tags": [
                "wave",
                "water",
                "hexagon",
                "sine",
                "hex",
                "gabor",
                "gabor",
                "flowmap",
                "vectorfield",
                "viridis",
                "cyclone",
                "directionalflow"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 185
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}