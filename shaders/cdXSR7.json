{
    "Shader": {
        "info": {
            "date": "1668612862",
            "description": "光线追踪",
            "flags": 0,
            "hasliked": 0,
            "id": "cdXSR7",
            "likes": 3,
            "name": "My_Ray_Tracing",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "Lincac",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "const int TRACTING_NUM = 100;\nconst int SEARCH_DEPTH = 28;\nconst float nearPlane = .001;\nconst float farPlane = 1000.0;\n\nconst vec3 lightPos = vec3(2,2,4);\nconst vec3 cameraPos = vec3(0,.5,3);\n\n#define PI 3.1415926535\n\n#define MAT_LAMBERTIAN 0\n#define MAT_METALLIC 1\n#define MAT_DIELECTRIC 2\n\nuint m_u = uint(521288629);\nuint m_v = uint(362436069);\nuint GetUintCore(inout uint u, inout uint v){\n\tv = uint(36969) * (v & uint(65535)) + (v >> 16);\n\tu = uint(18000) * (u & uint(65535)) + (u >> 16);\n\treturn (v << 16) + u;\n}\nfloat GetUniformCore(inout uint u, inout uint v){\n\tuint z = GetUintCore(u, v);\n\t\n\treturn float(z) / float(uint(4294967295));\n}\nfloat GetUniform(){\n\treturn GetUniformCore(m_u, m_v);\n}\nfloat rand(){\n\treturn GetUniform();\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 random_in_unit_sphere(){\n\tvec3 p;\n\t\n\tfloat theta = rand() * 2.0 * PI;\n\tfloat phi   = rand() * PI;\n\tp.y = cos(phi);\n\tp.x = sin(phi) * cos(theta);\n\tp.z = sin(phi) * sin(theta);\n\t\n\treturn p;\n}\n\nbool irefract(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted){\n\tvec3 uv = normalize(v);\n\tfloat dt = dot(uv, n);\n\tfloat discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt * dt);\n\tif (discriminant > 0.0){\n\t\trefracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfloat schlick(float cosine, float ior){\n\tfloat r0 = (1.- ior) / (1.+ ior);\n\tr0 = r0 * r0;\n\treturn r0 + (1.- r0) * pow((1.- cosine), 5.);\n}\n\nvec3 getbackground(vec3 pos){\n    return texture(iChannel0,pos).rgb;\n}\n\nstruct Lambertian{\n\tvec3 albedo;\n};\n\nLambertian lambertians[4];\n\nLambertian createLambertian(vec3 color){\n    Lambertian lambertian;\n    \n    lambertian.albedo = color;\n    \n    return lambertian;\n}\n\nstruct Metallic{\n    vec3 albedo;\n    float roughness;\n};\n\nMetallic metallics[4];\n\nMetallic createMetallic(vec3 color,float rough){\n    Metallic metallic;\n    \n    metallic.albedo = color;\n    metallic.roughness = rough;\n    \n    return metallic;\n}\n\nstruct Dielectric{\n    vec3 albedo;\n    float rate;\n};\n\nDielectric dielectrics[4];\n\nDielectric createDielectric(vec3 color,float rate){\n    Dielectric dielectric;\n    \n    dielectric.albedo = color;\n    dielectric.rate = rate;\n    \n    return dielectric;\n}\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere{\n    float radius;\n    vec3 position;\n    \n    int materialPtr;\n    int materialType;\n};\n\nstruct World{\n    int objnum;\n    Sphere sps[10];\n};\n\nstruct HitRecord{\n    float t;\n    vec3 position;\n    vec3 normal;\n    \n    int materialPtr;  \n    int materialType;\n};\n\nSphere createSphere(vec3 pos,float r,int ptr,int type){\n    Sphere sphere;\n    sphere.position = pos;\n    sphere.radius = r;\n    \n    sphere.materialPtr = ptr;\n    sphere.materialType = type;\n    return sphere;\n}\n\nvoid hitlambertian(Ray ray,HitRecord hit,Lambertian lambertian,out Ray scatray,out vec3 color){\n    color = lambertian.albedo;\n    \n    scatray.origin = hit.position;\n    scatray.direction = hit.normal + random_in_unit_sphere();\n}\n\nvoid hitmetallic(Ray ray,HitRecord hit,Metallic metallic,out Ray scatray,out vec3 color){\n    color = metallic.albedo;\n    \n    scatray.origin = hit.position;\n    scatray.direction = reflect(ray.direction,hit.normal) + metallic.roughness * random_in_unit_sphere();\n}\n\nvoid hitdielectric(Ray ray,HitRecord hit,Dielectric dielectric,out Ray scatray,out vec3 color){\n    color = dielectric.albedo;\n    \n    vec3 outward_normal;\n\tfloat ni_over_nt;\n\tfloat cosine;\n\tif(dot(ray.direction, hit.normal) > 0.0){\n\t\toutward_normal = -hit.normal;\n\t\tni_over_nt = dielectric.rate;\n\t\tcosine = dot(ray.direction, hit.normal) / length(ray.direction);\n\t}\n\telse{\n\t\toutward_normal = hit.normal;\n\t\tni_over_nt = 1.0 / dielectric.rate;\n\t\tcosine = -dot(ray.direction, hit.normal) / length(ray.direction);\n\t}\n    \n    float reflect_prob;\n\tvec3 refracted;\n\tif(irefract(ray.direction, outward_normal, ni_over_nt, refracted)){\n\t\treflect_prob = schlick(cosine, dielectric.rate);\n\t}\n\telse{\n\t\treflect_prob = 1.0;\n\t}\n\n\tif(rand() < reflect_prob){\n\t\tscatray = Ray(hit.position,refracted);\n\t}\n\telse{\n\t\tscatray = Ray(hit.position,refracted);\n\t}\n}\n\nbool HitSphere(Ray ray,float near,float far,Sphere sp,inout HitRecord hit){\n    vec3 oc = ray.origin - sp.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = 2.0 * dot(oc, ray.direction);\n\tfloat c = dot(oc, oc) - sp.radius * sp.radius;\n\n\tfloat delta = b * b - 4. * a * c;\n\n    if(delta > 0.){\n        float temp = (-b - sqrt(delta)) / (2.0 * a);  // 最近的点\n        if(near < temp && temp < far){\n            hit.t = temp;\n            hit.position = ray.origin + temp * ray.direction;\n            hit.normal = normalize((hit.position - sp.position) / sp.radius);\n            \n            hit.materialPtr = sp.materialPtr;\n            hit.materialType = sp.materialType;\n            \n            return true;\n        }\n        \n        temp = (-b + sqrt(delta)) / (2.0 * a);  // 最远的点\n        if(near < temp && temp < far){\n            hit.t = temp;\n            hit.position = ray.origin + temp * ray.direction;\n            hit.normal = normalize((hit.position - sp.position) / sp.radius);\n            \n            hit.materialPtr = sp.materialPtr;\n            hit.materialType = sp.materialType;\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nWorld getScene(){\n    World world;\n    world.objnum = 4;\n    \n    lambertians[0] = createLambertian(vec3(0.1, 0.7, 0.7));\n    lambertians[1] = createLambertian(vec3(0.5, 0.5, 0.5));\n    \n    metallics[0] = createMetallic(vec3(0.8, 0.8, 0.8), 0.3);\n    \n    dielectrics[0] = createDielectric(vec3(1.0, 1.0, 1.0), 1.5);\n    \n    world.sps[0] = createSphere(vec3(0.0, 0.0, -1.0), 0.5,0,MAT_LAMBERTIAN);\n    world.sps[1] = createSphere(vec3(0.0, -100.5, -1.0), 100.0,1,MAT_LAMBERTIAN);\n    world.sps[2] = createSphere(vec3(1.0, 0.0, -1.0), 0.5,0,MAT_METALLIC);\n    world.sps[3] = createSphere(vec3(-1.0, 0.0, -1.0), 0.5,0,MAT_DIELECTRIC);\n\n    return world;\n}\n\n\nbool HitWorld(World world,Ray ray,float near,float far,inout HitRecord hit){\n    HitRecord temphit;\n    bool hit_anything = false;\n    float hit_t_max = far;\n    \n    for(int i=0;i<world.objnum;i++){\n        if(HitSphere(ray,near,hit_t_max,world.sps[i],temphit)){\n            hit = temphit;\n            hit_anything = true;\n            hit_t_max = hit.t;\n        }\n    }\n    \n    return hit_anything;\n}\n\nvec3 raymarch(Ray ray,float near,float far,World world,int iter){\n    HitRecord record;\n    \n    vec3 bgcolor = vec3(1);\n    vec3 sumcolor = vec3(1);\n\n    while(iter > 0){\n        iter--;\n        if(HitWorld(world,ray,near,far,record)){\n            Ray scatterray;\n            vec3 attenuation;\n            if(record.materialType == MAT_LAMBERTIAN){\n                hitlambertian(ray,record,lambertians[record.materialPtr],scatterray,attenuation);\n            }else if(record.materialType == MAT_METALLIC){\n                hitmetallic(ray,record,metallics[record.materialPtr],scatterray,attenuation);\n            }else if(record.materialType == MAT_DIELECTRIC){\n                hitdielectric(ray,record,dielectrics[record.materialPtr],scatterray,attenuation);\n            }\n            \n            ray = scatterray;\n            sumcolor *= attenuation;\n        }else{\n            bgcolor = getbackground(ray.direction);\n            break;\n        }\n    }\n    \n    return sumcolor * bgcolor;\n}\n\nvec3 GammaCorrection(vec3 c){\n\treturn pow(c, vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    World world = getScene();\n    \n    // Time varying pixel color\n    mat3 rotaY = rotateY(iTime);\n    \n    vec3 col = vec3(0.);\n    for(int i=0;i<TRACTING_NUM;i++){\n        vec2 uv = ((fragCoord + vec2(rand(),rand())) - .5 * iResolution.xy) / iResolution.y;\n        \n        Ray ray;\n        ray.origin = cameraPos * rotaY;\n        ray.direction = vec3(uv,-1) * rotaY;\n\n        col+=raymarch(ray,nearPlane,farPlane,world,SEARCH_DEPTH);\n    }\n    col /= float(TRACTING_NUM);\n    \n    col = GammaCorrection(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}