{
    "Shader": {
        "info": {
            "date": "1580670082",
            "description": "first attempt at rendering water\n\nUPDATE: Added caustics\nUPDATE: Added fog for atmosphere",
            "flags": 0,
            "hasliked": 0,
            "id": "WtyGzV",
            "likes": 4,
            "name": "first attempt at rendering water",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 799
        },
        "renderpass": [
            {
                "code": "/*\n * Resources:\n * https://www.shadertoy.com/view/llsXD2\n * https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n * https://medium.com/@evanwallace/rendering-realtime-caustics-i\n * https://www.shadertoy.com/view/MttBRS\n * https://www.shadertoy.com/view/MldfDn\n */\n\n#define PI 3.141592\n#define MAX_STEPS 250\n#define MAX_DIST 250.0\n#define SURF_DIST .001\n\n#define WATER 0\n#define SKY 1\n\n#define LIGHT_POS vec3(0, 5, 25)\n\nstruct Obj {\n\tint type;\n    float d;\n    vec3 hitPos;\n};\n    \nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value noise from the book of shader\nfloat noise(in vec2 uv) {\n     \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves) {\n    \n    // Initial values\n    float value = 0.0;\n    float amplitude = .1;\n    float frequency = 0.;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// --- analytically triangle-filtered checkerboard by iq ---\nvec3 pri(in vec3 x) {    \n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri(in vec3 p, in vec3 ddx, in vec3 ddy) {\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.1 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec3 floorColor(in vec3 pos) {\n\n\tvec3 uvw = 1.2 * pos;\n\n\t// calc texture sampling footprint\t\t\n\tvec3 ddx_uvw = dFdx( uvw ); \n    vec3 ddy_uvw = dFdy( uvw );\n    vec3 color = vec3(checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw));\n  \n    return color;\n}\n\nObj getDistance(vec3 p) {\t\n       \n    float height = fbm(vec2(p.x, p.z) + (iTime/3.), 2);\n    float waterDist = p.y - height;\n    \n    Obj obj = Obj(WATER, waterDist, p);\n    \n    return obj;\n}\n\n// Basic raymarching loop\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.;\n    \n    Obj hitObj = Obj(SKY, t, ro + rd);\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        \n        hitObj = getDistance(p);\n        t += hitObj.d*0.35;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(SKY, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.d) < SURF_DIST) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.d = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getWaterNormal(vec3 p) {\n\tfloat d = getDistance(p).d;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(.5, 0);\n    vec3 n = d - vec3(\n        getDistance(p-e.xyy).d,\n        getDistance(p-e.yxy).d,\n        getDistance(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\n// calculates the intersection of the given plane and ray\nvec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {\n    \n    vec3 planeNormal = vec3(0, 1, 0);\n    \n\tfloat a = dot(dir, planeNormal);\n   \n    float distToPlane = dot(ori-planePos, planeNormal);\n    vec3 intersectPt = ori + dir*abs(distToPlane/a);\n    \n    return intersectPt;\n}\n\n// calculates specular lighting\nfloat specular(vec3 n, vec3 l, vec3 rd, float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(rd, n), l),0.0), s) * nrm;\n}\n\nvec3 getSkyColor(vec3 rd, vec3 light) {\n    \n    vec3 col = vec3(0.4);\n   \t// sun\n   \tfloat sundot = clamp(dot(rd, normalize(light)),0.0,1.0);\n   \t// sun scatter\n\tcol += 0.6*vec3(1.0,0.7,0.3) * pow(sundot, 8.0);\n   \tcol += 0.25*vec3(1.0,0.7,0.4) * pow(sundot, 5.0);\n\tcol += 0.25*vec3(1.0,0.8,0.6) * pow(sundot, 64.0);\n\tcol += 0.2*vec3(1.0,0.8,0.6) * pow(sundot, 512.0);\n    \n    return col;\n}\n\nvec3 getWaterColor(vec3 p, vec3 n, vec3 rd, vec3 distToP) {  \n    \n    // Fresnel is an exponential that gets bigger when the angle between the water\n    // surface normal and camera ray is smaller. It is used to calculate \n    // the amount of reflected vs. refracted light.\n    float fresnel = 1.0 - max(dot(n, -rd), 0.0);\n    fresnel = fresnel*fresnel*fresnel * 0.25;                        \n        \n    // Bounces the camera ray towards the sky and gets its color\n    vec3 reflected = getSkyColor(reflect(rd, n), normalize(LIGHT_POS));    \n    \n    // Calculates refraction effect based on angle between the light and surface normal \n     vec3 refractDir = refract(rd, n, 1.0/1.3);\n     vec3 refractedPos = intersectPlane(p, refractDir, vec3(0.0, -1.0, 0.0));\n    // floor color at the position hit by the refracted ray\n    vec3 refracted = floorColor(refractedPos);\n    \n    // Blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted, reflected, fresnel);\n    \n  \t// Add specular hilight\n    color += vec3(specular(n, normalize(LIGHT_POS), rd, 100.0));    \n    \n    return color;\n}\n\nfloat caustics(vec3 waterHitPos, vec3 lightPos) {\n    \n    vec3 ray = normalize(waterHitPos - lightPos);\n    \n    // Calculate the intersection of the light and the non-deformed water plane\n    vec3 surfacePlaneNormal = vec3(0.0, 1.0, 0.0);    \n    vec3 planePos = vec3(0, 0, 0);\n        \n    vec3 surfacePlaneHitPos = rayMarch(lightPos, ray).hitPos;\n    float height = fbm(vec2(surfacePlaneHitPos.x, surfacePlaneHitPos.z) + (iTime/3.), 2);\n    surfacePlaneHitPos += vec3(0., height, 0.);\n    \n    // Calculate the intersection of the refracted ray and bottom plane   \n    vec3 refractDir = refract(ray, surfacePlaneNormal, 1.0/1.3);   \n    vec3 bottomPlanePos = vec3(0.0, 1.0, 0.0);\n    vec3 beforePos = intersectPlane(surfacePlaneHitPos, refractDir, bottomPlanePos);\n  \tbeforePos += surfacePlaneHitPos;\n    \n  \t// Calculate the intersection of the light and deformed water surface\n    vec3 deformedPlaneHitPos = rayMarch(lightPos, ray).hitPos;\n   \tvec3 normal = getWaterNormal(deformedPlaneHitPos);\n    \n    // Calculate the intersection of the refracted ray and bottom plane   \n    refractDir = refract(ray, normal, 1.0/1.3);\n    vec3 afterPos = intersectPlane(deformedPlaneHitPos, refractDir, bottomPlanePos);\n    afterPos += deformedPlaneHitPos;\n       \n    float beforeArea = length(dFdx(beforePos)) * length(dFdy(beforePos));\n    float afterArea = length(dFdx(afterPos)) * length(dFdy(afterPos));\n    return max(beforeArea / afterArea, .001);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 col = vec3(.05, .25, 0.5);   \n       \n    // camera\n    vec3 ro = vec3(.5, 2, -8);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    Obj hitObj = rayMarch(ro, rd);   \n       \n    if (hitObj.type == SKY) {\n\n\t\tcol = getSkyColor(rd, LIGHT_POS-vec3(0., 3, 0.));\n        \n    } else if (hitObj.type == WATER) {\n    \n   \t\tvec3 normal = getWaterNormal(hitObj.hitPos);       \n        col += getWaterColor(hitObj.hitPos, normal, rd, hitObj.hitPos - ro)*0.6;\n    \tcol *= caustics(hitObj.hitPos, LIGHT_POS);\n        float fogAmount = pow(1.0 - pow(rd.y,2.0), 200.0);\n        col = mix(col, getSkyColor(rd, LIGHT_POS-vec3(0., 3, 0.)), fogAmount);     \n    }\n        \t\n    col = pow(col,vec3(.454545));\n \tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}