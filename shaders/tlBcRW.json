{
    "Shader": {
        "info": {
            "date": "1593812946",
            "description": "Lots of squares. Variation on Fabrice's [url]https://www.shadertoy.com/view/WlByRW[/url]\n\nProbably best full screen.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlBcRW",
            "likes": 5,
            "name": "Square Dance",
            "published": 3,
            "tags": [
                "square",
                "jacobian"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 442
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Variant on https://www.shadertoy.com/view/WlByRW by @FabriceNeyret2\n// mla, 2020\n////////////////////////////////////////////////////////////////////////////////\n\nfloat square(vec2 z, float r) {\n  float d = max(abs(z.x),abs(z.y));\n  return 1.0-smoothstep(0.0,0.1,abs(d-r));\n}\n\nvoid mainImage(out vec4 outcolor, vec2 fragcoord) {\n  vec2 z = (2.0*fragcoord - iResolution.xy)/iResolution.y;\n  float scale = 8.0;\n  z *= scale;\n  float tt = iTime;\n  z += 0.5*z*mat2(cos(0.25*z+tt),sin(0.25*z-tt));\n  \n  // If f(z) is our function, then f(z+dz) = f(z)+J*dz\n  // ie. J approximates f locally as a linear function.\n  mat2 J = mat2(dFdx(z),dFdy(z))*iResolution.y/(2.0*scale);\n\n  // Fold in to [-1,1]\n  z /= 2.0;\n  vec2 index = round(z);\n  z -= round(z);\n  z *= 2.0;\n  vec2 z1 = z;\n\n  // Apply inverse coordinate transform\n  z = inverse(J)*z;\n\n  vec3 col = vec3(0);\n  // red channel shows distances (from the cell centre) in transformed coordinates\n  col.r = (0.5+0.5*sin(length(20.0*z1)))*0.6;\n  // blue shows distances in the inverse transformed coordinates\n  col.b = (0.5+0.5*sin(length(20.0*z)))*0.6;\n  col.g = abs(1.0-pow(abs(determinant(J)),0.5));\n\n  // A square in inverse coordinates, so (approximately) screen aligned\n  // and the same size.\n  //float t = fract(0.5*iTime);\n  // Phased and random square by Fabrice, thanks.\n  //float t = fract(0.5*iTime+0.1*(index.x+10.0*index.y));\n  float t = fract(0.5*iTime+sin(dot(index,iResolution.xy)));\n  col = mix(col,vec3(1),0.75*square(z,t));\n\n  // Transformed cell boundaries\n  z1 = abs(z1);\n  if (z1.y > z1.x) z1 = z1.yx;\n  col *= 0.25+0.75*smoothstep(0.0,0.2,1.0-z1.x);\n\n  // Inverse transformed cell axes.\n  z = abs(z);\n  if (z.y > z.x) z = z.yx;\n  col *= 0.25+0.75*smoothstep(0.0,0.1,z.y);\n  col = pow(col,vec3(0.4545));\n  outcolor = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}