{
    "Shader": {
        "info": {
            "date": "1461104451",
            "description": "Go fullscreen and relax for a bit",
            "flags": 0,
            "hasliked": 0,
            "id": "4dcXDS",
            "likes": 24,
            "name": "Swedish Sunset",
            "published": 3,
            "tags": [
                "raytracing",
                "sunset",
                "water"
            ],
            "usePreview": 0,
            "username": "finalman",
            "viewed": 1607
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\nconst float BIG = 1e30;\nconst float EPSILON = 1e-10;\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Intersection\n{\n    float dist;\n    vec3 normal;\n};\n    \nstruct Trees\n{\n    float dist;\n    float alpha;\n};\n\n\nmat3 rotate3Z(float v)\n{\n    float s = sin(v);\n    float c = cos(v);\n    return mat3(\n        c,-s, 0,\n        s, c, 0,\n        0, 0, 1\n\t);\n}\n\nmat3 rotate3X(float v)\n{\n    float s = sin(v);\n    float c = cos(v);\n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n\t);\n}\n    \nIntersection water(Ray r)\n{\n    Intersection result;\n    result.dist = r.o.y / -r.d.y;\n    vec3 pos = r.o + r.d * result.dist;\n    result.normal = normalize(vec3(\n        sin(pos.z + iTime) * 0.2,\n        10.0 + (pos.z + 15.0) * 0.33,\n        cos(pos.x + iTime * 0.1) * 0.05));\n    return result;\n}\n\nTrees trees(Ray r)\n{\n    Trees result;\n    result.dist = (r.o.z - 200.0) / -r.d.z;\n    vec3 pos = r.o + r.d * result.dist;\n    float n = pos.y;\n    n *= (smoothstep(0.0, 600.0, abs(pos.x + 30.0)) + 0.18);\n    n *= (smoothstep(0.0, 200.0, abs(pos.x + 300.0)));\n    n += sin(pos.x + pos.y * 2.0) * 0.05;\n    n += (texture(iChannel0, vec2(pos.x * 0.004, pos.x * 0.003)).x - 0.5) * 0.5;\n    float t = max(0.1, length(vec2(dFdx(n), dFdy(n))));\n    result.alpha = smoothstep(4.0 + t, 4.0 - t, n);\n    return result;\n}\n\nvec3 palette(vec3 a, vec3 b, vec3 c, float t)\n{\n    float x = smoothstep(0.0, 0.7, t);\n    float y = smoothstep(0.5, 1.0, t);\n    return mix(a, mix(c, b, y), x);\n}\n\nvec3 stars(Ray r)\n{\n    vec3 f = texture(iChannel0, r.d.xy * 2.0).xyz;\n    float p = length(pow(f, vec3(100.0, 75.0, 50.0)) * vec3(0.05, 0.02, 0.01));\n    return vec3(p);\n}\n\nvec3 venus(Ray r)\n{\n    vec2 n = vec2(0.5, 0.1) - r.d.xy;\n    float t = length(dFdx(n));\n    float v = smoothstep(t * 2.2, t * 0.2, length(n));\n    return v * vec3(0.17, 0.16, 0.15);\n}\n\nvec4 clouds(Ray r)\n{\n    float dist = (r.o.y + 2000.0) / r.d.y;\n    vec3 pos = r.o + r.d * dist;\n    pos.z += sin(pos.x * 0.0005 + 2.0) * 500.0;\n    float a = max(0.0, sin(pos.z * 0.003 + pos.x * 0.001) * 0.5 + 0.6);\n    float m = smoothstep(13000.0, 5000.0, distance(pos.xz, vec2(-15000, 10000)));\n    float t = a * m * 0.4;\n    return vec4(mix(vec3(0.0), vec3(0.20, 0.07, 0.01) * 0.4, t), t);\n}\n\nvec3 sun(Ray r)\n{\n    vec3 dir = normalize(vec3(-0.04, -0.26 - iTime * 0.0008, 0.4));\n    float n = dot(normalize(r.d), dir) * 0.5 + 0.62 - r.d.y * 0.3;\n    n = pow(n, 16.0);\n    return palette(vec3(0.003, 0.003, 0.050), vec3(0.95, 0.85, 0.8), vec3(1.2, 0.5, 0.1), n);\n}\n\nvec3 sky(Ray r)\n{\n    vec3 power = vec3(iTime * 0.001 + 1.0);\n    vec4 c = clouds(r);\n    c.xyz = pow(c.xyz, power);\n    vec3 s = pow(sun(r), power) + venus(r) + stars(r);\n    return mix(s, c.xyz, c.w);\n}\n\nvec3 render(Ray r)\n{\n    float b = 1.0;\n    Intersection w = water(r);\n    Trees t = trees(r);\n    \n    if (w.dist > 0.0 && w.dist < t.dist)\n    {\n        b = pow(1.1 - abs(dot(w.normal, r.d)), 5.0);\n        \n        r.o += r.d * w.dist;\n        r.o = min(r.o, 199.9); // Fixes a glitch on Intel\n        r.d = reflect(r.d, w.normal);\n        t = trees(r);\n    }\n    \n    vec3 s = sky(r);\n    \n    return mix(s, vec3(0, 0, 0), t.alpha) * b;\n}\n\nvec3 toneMap(vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray r;\n    r.o = vec3(0.0, 2.0, -10.0);\n    r.d = normalize(vec3((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.8));\n    \n    r.d *= rotate3X(-0.04);\n    \n    vec3 color = render(r);\n    \n    color = toneMap(color);\n    \n    color += texture(iChannel0, fragCoord.xy / 256.0).xyz / 100.0;\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}