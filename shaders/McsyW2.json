{
    "Shader": {
        "info": {
            "date": "1721634611",
            "description": "source https://glslsandbox.com/e#79946.0 https://glslsandbox.com/e#79727.0",
            "flags": 0,
            "hasliked": 0,
            "id": "McsyW2",
            "likes": 4,
            "name": "mengeroid",
            "published": 3,
            "tags": [
                "fractal",
                "menger"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 136
        },
        "renderpass": [
            {
                "code": "\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define time iTime\n#define resolution iResolution.xy\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvec4 getcolor(float x, float y, float a) {\n\tx = 0.5-abs(fract(x)-.5);\n\ty = 0.5-abs(fract(y)-.5);\n\tif (x < .1 || y < .1) {\n\t\tfloat f = 1.-min(x,y)*10.;\n\t\treturn vec4(vec3(f)*vec3(0.3,1.5,0.1),f*f*f*(1.-f)*4.)*min(1.,abs(a)*1.5);\n\t} else {\n\t\treturn vec4(0);\n\t}\n}\n\n\n\n\n\n#define INF 7.0\n\nfloat marched = 10.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat sdSphere( vec3 p, float size)\n{\n  return length(p)-5.2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(INF,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,INF,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,INF));\n  return min(da,min(db,dc));\n}\n\n\n\n\t\nfloat map( vec3 p )\n{\n   vec3 pui;\n   p=R(p,normalize(vec3(1,1,1)),iTime*1.02);\n   pui.x = 1.0;\n   pui.y = 1.0;\n   pui.z = 1.0;\n   float d = sdBox(p,pui);\n   int m;\n   float s = 1.0;\n   for( int m=0; m<2;m++ )\n   {\n   \t  vec3 a;\n   \t  vec3 q;\n   \t  q=p*s;\n      a = mod( q, 1.0 )-0.5;\n     \n      s *= 3.0;\n      \n      vec3 r = .8 - 5.8*abs(a);\n   \n      float c = sdCross(r)/s;\n      d = max(d,-c);\n   }\n\n   return d;\n}\nfloat rm(vec3 origin, vec3 ray, float min_distance, float max_distance) {\n\tint i;\n\tfloat distance_marched = min_distance;\n\tfor (int i=0; i<200; i++) {\n\t\tvec3 indi = ray*distance_marched;\n\t\n\t\tvec3 moi = indi + origin;\n\t\t\n\t\tfloat step_distance = map(moi);\n\t\tif (abs(step_distance) < 0.0001) {\n\t\t\treturn distance_marched/(max_distance-min_distance);\n\t\t}\n\t\tdistance_marched += step_distance;\n\t\tmarched=distance_marched;\n\t\tif (distance_marched > max_distance) {\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\tvec3 render(vec2 q) {\n\tvec3 dir;\n\tvec3 screen;\n\tvec3 ray;\n        \n\tdir.x = 0.0;\n\tdir.y = 0.0;\n\tdir.z = -2.8;\n\n\tscreen.x = q.x;\n\tscreen.y = q.y;\n\tscreen.z = -2.0;\n\tray = screen - dir;\n\t\n\t\n\tfloat s = rm(dir, ray, 1.0, 4.0);\n\t\n\tvec3 col;\n\t\n\t\n\t\n\t\tcol = vec3(s-.8*.8+0.4*q.y *sin(q.x))*marched/1.76;\n\t\t\n\t\n\t\n\treturn col;\n\t\n\t}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec3 pos = vec3(0.5,0.5,1.5+time);\n\n\tvec3 ipos = floor(pos);\n\t\n\tvec3 dir = normalize(vec3(( gl_FragCoord.xy - resolution.xy *.5) / resolution.y, .5));\n\tdir=R(dir,normalize(vec3(1,1,1)),iTime*1.02);\n\tconst float maxstep = 0.13;\n\t\n\tconst int maxiter = 50;\n\t\n\tvec4 color = vec4(0);\n\t vec2 uv = fragCoord/iResolution.xy*-0.5;\n    vec2 pos2 = uv*2.1;\n\npos2.x+=0.55;\npos2.y+=0.55;\n\tconst float pi = 3.14159;\n\tconst float n = 16.0;\n\t\n\tfloat radius = length(pos2) * 2.0 - 0.4;\n\tfloat t = atan(pos2.y, pos2.x);\n\tradius+=0.2*cos(iTime);\n\tfloat color2 = 0.0;\n\t\n\tfor (float i = 9.0; i <= n; i++){\n\t\tcolor2 += 0.002 / abs(0.2 * sin(\n\t\t\t3. * (t + i/n * time * 10.1)\n\t\t    ) - radius\n\t\t);\n\t}\n\tfor (int i = 0; i < maxiter; i++) {\n\t\t// trace until the next cube starts but no further than \"maxstep\"\n\t\tvec3 targetpos = ipos + step(0., dir);\n       \n\t\tvec3 dists = (targetpos - pos) / dir;\n\t\tfloat mindist = min(min(dists.x, dists.y), min(dists.z, maxstep));\n\t\tpos += dir*mindist;\n\t\t\t \n\t\t// apply color if we hit a cube\n\t\tvec4 color0 = vec4(0);\n\t\tif (dists.x == mindist) {\n\t\t\tipos.x += sign(dir.x);\n\t\t\tcolor0 = getcolor(pos.y,pos.z,dir.x);\n\t\t} else if (dists.y == mindist) {\n\t\t\tipos.y += sign(dir.y);\n\t\t\tcolor0 = getcolor(pos.z,pos.x,dir.y);\n\t\t} else if (dists.z == mindist) {\n\t\t\tipos.z += sign(dir.z);\n\t\t\tcolor0 = getcolor(pos.x,pos.y,dir.z);\n\t\t}\n\t\n\t\tcolor += color0*(1.-color.a);\n\t\t\n\t\t\n\t\tdir.z -= mindist*.1;\n\t\tdir = normalize(dir);\n\t}\n\tvec2 q = (2.0*gl_FragCoord.xy - iResolution.xy)/iResolution.x;\n\t\n\tvec3 col = render(q);\n\tcolor += vec4(0,0,1,1)*(1.*color.a);\n\t\n\tfragColor = color;\nfragColor*=vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}