{
    "Shader": {
        "info": {
            "date": "1623032483",
            "description": "A recreation of a shader featuring volumetric procedural white blobs that I've seen around vrchat.\nThis one works by ray marching and using a perlin noise function I've made to determine whether there should be a white blob or not.",
            "flags": 0,
            "hasliked": 0,
            "id": "sllGDX",
            "likes": 2,
            "name": "3d white blobs",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "volumetric",
                "simplex",
                "blob",
                "white"
            ],
            "usePreview": 0,
            "username": "BEN1JEN",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535\n\nfloat rand(vec4 pos) {\n\tpos = pos + vec4(2.35219, 1.51092, 3.01246, 4.8263975209);\n    vec2 pos2d = pos.xy*1.0231 + pos.yz*1.7423 + pos.zw*0.9854 + pos.wx*0.4798;\n\tfloat rand = fract(sin(dot(pos2d, vec2(12.9898, 78.233))) * 43758.5453123);\n\trand = rand - floor(rand);\n\treturn rand;\n}\n\nfloat noise(vec4 pos, int octaves) {\n\tfloat total = 0.0;\n\tfloat multiplier = 0.0;\n\tfor (int o = 1; o <= octaves; o++) {\n\t\tvec4 lin = pos/float(o);\n        lin -= floor(lin);\n\n        float llll = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat hlll = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat lhll = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat hhll = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat llhl = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\t\tfloat hlhl = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\t\tfloat lhhl = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\t\tfloat hhhl = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\n        float lllh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat hllh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat lhlh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat hhlh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat llhh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\t\tfloat hlhh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\t\tfloat lhhh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\t\tfloat hhhh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\n\t\tfloat llzl = llll * (1.0 - lin.z) + llhl * lin.z;\n\t\tfloat hlzl = hlll * (1.0 - lin.z) + hlhl * lin.z;\n        float lhzl = lhll * (1.0 - lin.z) + lhhl * lin.z;\n\t\tfloat hhzl = hhll * (1.0 - lin.z) + hhhl * lin.z;\n\t\tfloat llzh = lllh * (1.0 - lin.z) + llhh * lin.z;\n\t\tfloat hlzh = hllh * (1.0 - lin.z) + hlhh * lin.z;\n\t\tfloat lhzh = lhlh * (1.0 - lin.z) + lhhh * lin.z;\n\t\tfloat hhzh = hhlh * (1.0 - lin.z) + hhhh * lin.z;\n\n        float lyzl = llzl * (1.0 - lin.y) + lhzl * lin.y;\n\t\tfloat hyzl = hlzl * (1.0 - lin.y) + hhzl * lin.y;\n\t\tfloat lyzh = llzh * (1.0 - lin.y) + lhzh * lin.y;\n\t\tfloat hyzh = hlzh * (1.0 - lin.y) + hhzh * lin.y;\n\n        float xyzl = lyzl * (1.0 - lin.x) + hyzl * lin.x;\n        float xyzh = lyzh * (1.0 - lin.x) + hyzh * lin.x;\n\n        float val = xyzl * (1.0 - lin.w) + xyzh * lin.w;\n\n        multiplier = multiplier + float(o);\n\t\ttotal = total + val * float(o);\n\t}\n\treturn total/multiplier;\n}\n\nbool getNoise(vec4 pos, float dist) {\n    return\n        noise(pos*10.0 + vec4(1.5, 0.5, -3.2, 6.5), 12) > 0.56 ||\n        noise(pos*8.0 + vec4(0.5, 6.5, -3.2, 1.5), 12) > 0.56;\n}\n\nvec3 hsv(float hue, float sat, float val) {\n    hue = mod(hue, 1.0);\n    hue *= 6.0;\n    if (hue < 1.0) {\n        return vec3(\n            1.0,\n            hue + (1.0-hue)*sat,\n            sat\n        )*val;\n    } else if (hue < 2.0) {\n        return vec3(\n            2.0-hue + (hue-1.0)*sat,\n            1.0,\n            sat\n        )*val;\n    } else if (hue < 3.0) {\n        return vec3(\n            sat,\n            1.0,\n            hue-2.0 + (3.0-hue)*sat\n        )*val;\n    } else if (hue < 4.0) {\n        return vec3(\n            sat,\n            4.0-hue + (hue-3.0)*sat,\n            1.0\n        )*val;\n    } else if (hue < 5.0) {\n        return vec3(\n            hue-4.0 + (5.0-hue)*sat,\n            sat,\n            1.0\n        )*val;\n    } else {\n        return vec3(\n            1.0,\n            sat,\n            6.0-hue + (hue-5.0)*sat\n        )*val;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float dist = 0.0;\n    vec3 dir = vec3(uv*2.0-1.0, 1.0);\n    vec2 r = iMouse.xy/vec2(640.0/PI/2.0, 360.0/PI) + vec2(0.0, PI/2.0);\n    vec2 tmp = dir.yz;\n    dir.y = tmp.x*cos(r.y) + tmp.y*sin(r.y);\n    dir.z = tmp.y*cos(r.y) - tmp.x*sin(r.y);\n    tmp = dir.xz;\n    dir.x = tmp.x*cos(r.x) - tmp.y*sin(r.x);\n    dir.z = tmp.y*cos(r.x) + tmp.x*sin(r.x);\n    float len = length(dir);\n    dir /= len;\n    vec3 pos = vec3(1.0 + sin(iTime/10.0), 10.0 - iTime/10.0, -2.0 + cos(iTime/10.0));\n    bool seen = false;\n    for (int i = 0; i < 10; i++) {\n        dist += float(i)/10.0;\n        if (getNoise(vec4(pos + dist*dir, iTime/10.0), dist)) {\n            seen = true;\n            break;\n        }\n    }\n    vec3 hit = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (seen) {\n        for (; dist > 0.0; dist -= 0.1) {\n            if (!getNoise(vec4(pos + dist*dir, iTime/10.0), dist)) {\n                hit = pos + dist*dir;\n                break;\n            }\n        }\n        dir *= len;\n        if (seen) {\n            float val = 1.0-pow(dist/5.0, 3.0);\n            col = hsv(hit.y/10.0, 0.8+val*0.1, val);\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}