{
    "Shader": {
        "info": {
            "date": "1452274657",
            "description": "Untitled 05 - \nWeek1 - Shader everyday (style)",
            "flags": 0,
            "hasliked": 0,
            "id": "4dt3W2",
            "likes": 8,
            "name": "Untitled 05",
            "published": 3,
            "tags": [
                "geometry"
            ],
            "usePreview": 0,
            "username": "floz",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "#define PI 3.141592654\n#define EPSILON 0.0000001\n#define AMPLITUDE 0.52\n#define SPEED 0.05\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 24\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n//------------------- FORMULAS/MAGIC\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat smin( float a, float b )\n{\n    float k = .1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{    \n\t// vigneting\n    col *= .9 + .2 * snoise( vec3( sin( iTime + uv.x ), cos( iTime + uv.y ), 0. ) );\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n    col += col * .1 * snoise( vec3( -uv.x * 400., uv.y * 400. , iTime * 2. ) );\n    \n    return col;\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y *.75+q.z*1.5-h)/3.0 );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n//------------------- MAP\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat repeatObj1( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n\n    float idx1 = pModPolar( op.xy, 8. );\n    op.x -= 3.;\n    op.xy = rotate2D( op.xy, PI * .5 + sin( idx1 + iTime + p.x ) * .15 );\n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    op.z += sin( idx2 + p.x + iTime ) * .1;\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx2 ) );\n    //op.zy = rotate2D( op.zy, PI * sin( idx2 ) );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 ) );\n    \n    float idx4 = pModInterval1( op.x, .15, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx4 ) );\n    \n    float obj = fBox( op, vec3( .5, .025, 0.005 ) );\n    return obj;\n    \n}\n\nfloat repeatObj2( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n\n    //op.xy = rotate2D( op.xy, PI  );\n    float idx1 = pModPolar( op.xy, 24. );\n    op.x -= 3.5;\n    op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    float idx2 = pModInterval1( op.y, .4, -2., 2. );\n    op.z += sin( idx2 ) * .1;\n    op.xz = rotate2D( op.xz, PI * .05 * sin( cos( idx2 * idx1 + iTime * 0. ) ) );\n    op.y = rotate2D( op.xy, PI * .05 * sin( idx2 ) ).x;\n    op.xz = rotate2D( op.xz, PI * sin( idx2 + iTime ) );\n    //op.xy = rotate2D( op.xz * 1., PI * sin( idx2 + iTime ) );\n    op.zy = rotate2D( op.zy, PI * sin( idx2 + iTime ) );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime * 0. ) );\n    \n    float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    //op.y -= idx4 * p.y;\n    //op.xz = rotate2D( op.xz, PI * sin( idx4 )* cos( idx4 ) + iTime);\n    \n    //op.x += .25 * sin( idx1 );\n    \n    \n    float obj =  fBox( op, vec3( 1., .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat repeatObj3( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    op.z += 2.0;\n\n    //op.xy = rotate2D( op.xy, PI  );\n    float idx1 = pModPolar( op.xy, 12. );\n    op.x -= 1.5;\n    op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    float idx2 = pModInterval1( op.y, .5, -2., 2. );\n    op.z += sin( idx2 ) * .1;\n    op.xz = rotate2D( op.xz, PI * .05 * sin( cos( idx2 * idx1 + iTime * 5. ) ) );\n    op.y = rotate2D( op.xy, PI * .05 * sin( idx2 ) ).x;\n    op.xz = rotate2D( op.xz, PI * sin( idx2 + iTime ) );\n    //op.xy = rotate2D( op.xz * 1., PI * sin( idx2 + iTime ) );\n    op.zy = rotate2D( op.zy, PI * sin( idx2 + iTime ) );\n    \n    float idx3 = pModInterval1( op.z, .4, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime * 5. ) );\n    \n    float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    //op.y -= idx4 * p.y;\n    //op.xz = rotate2D( op.xz, PI * sin( idx4 )* cos( idx4 ) + iTime);\n    \n    //op.x += .25 * sin( idx1 );\n    \n    \n    float obj =  fBox( op, vec3( 1., .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat map( in vec3 p ) {\n    vec3 np = vec3( p.x, p.y, p.z + .25 );\n    \n    float res;\n    float obj1 = repeatObj1( np );\n    float obj2 = repeatObj2( np );\n    float obj3 = repeatObj3( np );\n    res = obj1;\n    //return obj3;\n    //res = repeatObj1( p );\n    //res = opU( res, repeatObj2( p ) );\n   //res = repeatObj2( p );\n    \n    //float f = p.y - .4;\n    //r = opU( r, f );\n    \n    float k = 1.75;\n    float h = clamp( 0.5 + 0.5 * ( obj1 - obj2 ) / k, 0.0, 1.0 );\n    \n    res = mix( obj1, obj1, h ) - k*h*( 1.0 - h );\n    \n    //k = 2.;\n    h = clamp( 0.5 + 0.5 * ( res - obj2 ) / k, 0.0, 1.0 );\n    res = mix( res, obj2, h ) - k*h*( 1.0 - h );\n    \n    h = clamp( 0.5 + 0.5 * ( res - obj3 ) / k, 0.0, 1.0 );\n    res = mix( res, obj3, h ) - k*h*( 1.0 - h );\n    \n    //res = opU( res, obj3 );\n    //res = obj3;\n    \n    \n    return res;\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .025 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.5,2.,-1.5) );\n\nvec3 addLight( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius, in float specRatio ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    float specular = pow( clamp( dot( ref, posLight ), 0., .5 ), 16. );\n    vec3 col = colLight * intens * att;\n    col += specular * .5 * att;\n    return col;\n}\n    \nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {\n\tvec3 col = vec3( 1., .0, 1. );\n    //vec3 colBg = vec3(0.0, 0., 0.) - rd.y*0.2*vec3(1., 1., 0.) + 0.15*0.5;\n\t//colBg += 0.2*vec3(1.0,0.,0.1)*pow( sun, 2.0 );\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 colBg = vec3( 0.152, 0.898, 0.513 ) -  rd.y * .5*vec3( 0.298, 0.474, 0.494 ) + 0.15 * .55;\n\t//colBg += 0.2*vec3( 0.298, 0.474, 0.494 )*pow( sun, 2.0 );\n    //colBg = vec3(cos( uv.y * uv.x ) * .1,cos( uv.y ) * .95,sin( uv.x ) + cos( uv.y ) * .5 ) / 15.;\n    //colBg = vec3( 1. );\n    //colBg = vec3( 1. - length( rd.xy - vec2( .25, .5 ) ) ) * vec3( 0.152, 0.898, 0.513 );\n    \n    //colBg = mix( vec3( 0.298, 0.474, 0.494 ) * .25, vec3( 0.152, 0.898, 0.513 ) * .9, sin( uv.y ) );\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 ref = reflect( rd, nor );\n    \n    col = colBg;\n    if( t < 20. ) {\n        col = mix( col, vec3( .988, 0.152, .482 ), .8 );\n    }\n    // top blue light\n    //col += addLight( vec3( .3, 5.,1. ), vec3( .498, .898, .952 ), nor, pos, ref, 6., 1. );\n    \n    // right green dark\n    col += addLight( vec3( .0, .0, .1 ), vec3( 0.152, 0.898, 0.513 ), nor, pos, ref, 6.25, 0. );\n    // bottom right blue light\n    col += addLight( vec3( 5., -2., 1.85 ), vec3( .988, 0.152, .482 ), nor, pos, ref, 4., 0. );\n    // bottom left red\n    col += addLight( vec3( -4., 0., 1.85 ), vec3( 0.79, .168, .015 ), nor, pos, ref, 6., 0.25 );\n    \n   // col += addLight( vec3( 0., 1.5, 1.5 ), vec3( 1., .0, 0. ), nor, pos, ref, 3.5, 0.5 );\n    \n   // col += .35 * addLight( vec3( 0.21, 2.85, .0 ), vec3( 1., 0.79, .16 ), nor, pos, ref, 4., .0 );\n   \n    //col += 1.1 * vec3( 1., 0.4, 0.2 ) * abs( pow( sun, 3. ) );\n    //col += 2.1 * vec3( 1., 0.79, .16 ) * abs( pow( sun, 24. ) );\n    col += addLight( vec3( .3, 5.,1. ), vec3( 0.152, 0.898, 0.513 ), nor, pos, ref, 6., 1. );\n    col *= ao;\n    \n    vec3 fog = vec3( EPSILON );\n    col = mix( col, colBg, 1. - exp( -.0255 * t * t ) );   \n    \n    col = col;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n\t\n\t//vec3 ta  = vec3( EPSILON, +.4, .5 );\n    float radius = 4.5;\n    vec3 ro = orbit( PI/2.,PI/2.,radius );\n    //vec3 ro = vec3( 0., 0., 5. );//orbit(0.,EPSILON,radius);\n    vec3 ta = vec3( EPSILON, EPSILON, EPSILON );\n    //ta.y = 1.;\n   \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, EPSILON );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 1. ) );\n    \n    // Raymarching\n    vec3 c = render( ro, rd, uv );\n    c.r = smoothstep(0.2, 1.0, c.r + .12);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.21);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    c = postEffects( c, uv, 0. );\n    fragColor = vec4( c, 1. );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}