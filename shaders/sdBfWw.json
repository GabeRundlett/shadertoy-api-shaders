{
    "Shader": {
        "info": {
            "date": "1697292291",
            "description": "More delights of projective geometry: the eleven point conic, but with defining line at infinity, so only nine finite points. This conic then becomes a circle when one red point is at the orthocentre of the others. Use mouse to drag red and yellow points.",
            "flags": 48,
            "hasliked": 0,
            "id": "sdBfWw",
            "likes": 12,
            "name": "Nine Point Conic and Circle",
            "published": 3,
            "tags": [
                "conic",
                "projective",
                "ninepoint"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Nine Point Conic and Circle. mla, 2023.\n//\n// Take 4 points (red, one with a cross) and the 6 lines (yellow) through\n// pairs of points, forming a complete quadrangle.\n//\n// There are 3 diagonal points where the line through two points meets\n// the line through the other two points (cyan).\n//\n// Given a line l, here the line at infinity, the six quadrangle lines\n// meet l in six points and each point has a harmonic conjugate with\n// the two points of the quadrangle on the same line (green), since\n// l is at infinity, these are the midpoints of the sides.\n//\n// The three diagonal points and the six harmonic points, all lie on\n// a conic, the nine point conic (white).\n//\n// The four points of the quadrangle define a pencil of conics through\n// those points & the pencil contains three degenerate conics composed\n// of two lines (in fact two from the six diagonals of the quadrangle).\n// Furthermore, if one point of the quadrangle, p0 say, is at the \n// orthocentre of the triangle formed by the other points p1-p3, then \n// the 3 degenerate members of the pencil are orthogonal lines, and in\n// fact every member of the pencil is a rectangular hyperbola (ie. \n// has orthogonal asymptotes). In this case, the nine point conic passes\n// through the feet of the altitudes as well as the midpoints, and \n// it becomes the familiar nine point circle.\n//\n// In the shader, position the three plain red points and the yellow point\n// as desired, then move the red point with the cross to the orthocentre,\n// also a cross. At this point, the white conic becomes a circle and the\n// grey asymptotes of the blue hyperbola become orthogonal.\n//\n// Use mouse to drag red and yellow points.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint configuration = 2;\n\nfloat lwidth = 0.007;\nfloat pwidth = 0.03;\n\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 pcolor4 = pcolor1;\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = vec3(1,1,0.2);\nconst vec3 ccolor0 = vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\nconst vec3 ccolor2 = vec3(0.5,0.5,1);\n\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic(float A, float B, float C,\n               out float x1, out float x2) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x1 = (-B-D)/A;\n   x2 = C/(A*x1);\n   return true;\n}\n\n// Return either intersection of lines p and q\n// or line through points p and q, r = kp + jq\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  p3 = m*p3; \n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3[0];\n  m[1] /= p3[1];\n  m[2] /= p3[2];\n  return transpose(m);\n}\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: ax² + by² + cz² + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate.\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 conic5points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  p4 = p*p4;\n  float a = p4.x, b = p4.y, c = p4.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  return transpose(p)*m*p;\n}\n\n// Conic through 4 points and tangent to a line - there are 2 solutions,\n// so need to solve quadratic. I'm sure I didn't invent this but\n// can't remember the source.\n// l.p = l'p == l'(MinvM)p = (Minv'l)'Mp\nbool conic4points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 l4, out mat3 M0, out mat3 M1) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // and then to the square (1,1),(1,-1),(-1,1),(-1,-1)\n  mat3 q = rproject(vec3(1,-1,1), vec3(-1,1,1),vec3(-1,-1,1),vec3(1,1,1));\n  p = inverse(q)*p; // q is constant\n  // Now construct a conic through the images of p0-p3 and l4\n  l4 = transpose(inverse(p))*l4;\n  float i = l4.x, j = l4.y, k = l4.z;\n  float A = -j*j, B = 0.5*(i*i+j*j-k*k), C = -i*i;\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  M0 = mat3(t0, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t0);\n  M0 = transpose(p)*M0*p;\n  if (isnan(determinant(M0))) return false;\n  M1 = mat3(t1, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t1);\n  M1 = transpose(p)*M1*p;\n  if (isnan(determinant(M1))) return false;\n  return true;\n}\n\n// Find the two points of intersection of a line through p0 and\n// p1 with the conic defined by M.\nbool lineconic(vec3 p0, vec3 p1, mat3 M, out vec3 q0, out vec3 q1) {\n  // (tp0 + p1)M(tp0 + p1) == 0\n  float A = dot(p0,M*p0);\n  float B = dot(p0,M*p1);\n  float C = dot(p1,M*p1);\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  q0 = t0*p0+p1;\n  q1 = t1*p0+p1;\n  return true;\n}\n\n// Find the two points of intersection of the line l\n// with the conic defined by c.\nbool lineconic(vec3 l, mat3 M, out vec3 i0, out vec3 i1) {\n  // Intersect l with two of the axes. This might of course\n  // be the same point (1,0,0) here, so really should check\n  // the third axis too.\n  vec3 p0 = join(l,vec3(0,0,1));\n  vec3 p1 = join(l,vec3(0,1,0));\n  return lineconic(p0,p1,M,i0,i1);\n}\n\n// Harmonic conjugate of p,q and intersection of p,q with l.\nvec3 harmonic(vec3 p, vec3 q, vec3 l) {\n  // kp + jq is conjugate of kp - lq:\n  // l.(kp - jq) = 0\n  // k(l.p) = j(l.q)\n  float k = dot(l,q);\n  float j = dot(l,p);\n  return k*p+j*q;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat px;\n\n// Just a point\nfloat point(vec3 pos, vec3 p) {\n  //if (abs(p.z) < 1e-4) return 0.0;\n  pos /= pos.z; p /= p.z; // Normalize\n  float dist = distance(pos,p);\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(-px,px,dist-pwidth);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// A point drawn with a cross.\nfloat point2(vec3 pos, vec3 p) {\n  pos /= pos.z; p /= p.z; // Normalize\n  float t = 0.707*pwidth;\n  float d = segment(pos.xy,p.xy+vec2(t,t),p.xy-vec2(t,t));\n  d = min(d,segment(pos.xy,p.xy+vec2(-t,t),p.xy-vec2(-t,t)));\n  if (isnan(d)) return 0.0;\n  return 1.0-smoothstep(-px,px,d-0.5*lwidth);\n}\n\nfloat line(vec3 pos, vec3 l) {\n  float dist = dot(pos,l)/(pos.z*length(l.xy));\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(-px,px,abs(dist)-lwidth);\n}\n\nfloat conic(vec3 pos, mat3 m) {\n  float dist = dot(pos,m*pos);   // Distance from the conic\n  vec3 grad = m*pos*2.0;         // The gradient uses the same matrix.\n  dist /= pos.z*length(grad.xy); // Normalize for Euclidean distance\n  if (isinf(dist)) return 0.0;\n  return 1.0-smoothstep(-px,px,abs(dist)-lwidth);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = 0.5*iTime;\n  p.x *= 1.0+0.5*sin(t);\n  p.y *= 1.0+0.3*sin(0.618*t);\n  p.xy = rotate(p.xy,0.2*t);\n  //p.yz = rotate(p.yz,0.1*t);\n  return p;\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,0.95*level);\n}\n\nvec2 orthocentre(vec2 p, vec2 q, vec2 r) {\n  p -= r; q -= r;\n  float a = dot(p,q), b = dot(p,p), c = dot(q,q);\n  // (p-h).q = 0 = (q-h).p and h = up+vq\n  // gives linear system\n  vec2 uv = inverse(mat2(a,b,c,a))*vec2(a);\n  return mat2(p,q)*uv+r;\n}\n\n// Find asymptotes of conic, ie. tangents at\n// intersection with line at infinity.\n// Derived from a simplification of the equation,\n// putting z = 0.\nbool asymptotes(mat3 s, out vec3 a0, out vec3 a1) {\n  // Solve quadratic to find (real) intersections\n  // with line at infinity, then take tangents.\n  // Should really check for a = 0 (and b = 0)\n  float a = s[0][0], b = s[1][1], d = s[0][1];\n  float t = d*d-a*b;\n  if (t < 0.0) return false;\n  t = sqrt(t);\n  a0 = s*vec3((-d+t)/a,1,0);\n  a1 = s*vec3((-d-t)/a,1,0);\n  return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  setscale();\n  vec3 pos = vec3(map(fragCoord.xy),1);\n  px = fwidth(pos.x);\n  // p0-p3 are the quadrangle\n  vec3 p0 = vec3(getselection(0),1), p1 = vec3(getselection(1),1);\n  vec3 p2 = vec3(getselection(2),1), p3 = vec3(getselection(3),1);\n  vec3 p4 = vec3(getselection(4),1); // Arbitrary point on pencilconic\n  vec3 h = vec3(orthocentre(p1.xy,p2.xy,p3.xy),1);\n  vec3 l4 = vec3(0,0,1); // line at infinity\n  // pencilconic is a typical conic in the pencil through p0-p3.\n  mat3 pencilconic = conic5points(p0,p1,p2,p3,p4);\n  \n  vec3 l01 = join(p0,p1);\n  vec3 l02 = join(p0,p2);\n  vec3 l03 = join(p0,p3);\n  vec3 l12 = join(p1,p2);\n  vec3 l13 = join(p1,p3);\n  vec3 l23 = join(p2,p3);\n\n  // diagonal points\n  vec3 d0 = join(l01,l23);\n  vec3 d1 = join(l02,l13);\n  vec3 d2 = join(l03,l12);\n\n  // harmonic points\n  vec3 h01 = harmonic(p0,p1,l4);\n  vec3 h02 = harmonic(p0,p2,l4);\n  vec3 h03 = harmonic(p0,p3,l4);\n  vec3 h12 = harmonic(p1,p2,l4);\n  vec3 h13 = harmonic(p1,p3,l4);\n  vec3 h23 = harmonic(p2,p3,l4);\n\n  // conics\n  mat3 ninepoint = conic5points(d0,d1,d2,h01,h23);\n#if 0\n  // Not needed for now\n  mat3 M1,M2;\n  bool doM1M2 = doM1M2 = conic4points(p0,p1,p2,p3,l4,M1,M2); // Don't need these\n  vec3 i0,i1;\n  bool doN = lineconic(l4,elevenpoint,i0,i1);\n#endif\n\n  vec3 tex = texture(iChannel1,0.5*fragCoord/iResolution.y).xyz;\n  vec3 color = 0.1*tex;\n  float t = lwidth*0.5*length(tex);\n  lwidth += t;\n  pwidth += t;\n  \n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,line(pos,l01));\n  color = cmix(color,lcolor2,line(pos,l02));\n  color = cmix(color,lcolor2,line(pos,l03));\n  color = cmix(color,lcolor2,line(pos,l12));\n  color = cmix(color,lcolor2,line(pos,l13));\n  color = cmix(color,lcolor2,line(pos,l23));\n\n  // The moving line\n  //color = cmix(color,lcolor0,line(pos,l4));\n  \n  // The conics\n  color = cmix(color,ccolor0,conic(pos,ninepoint));\n  color = cmix(color,ccolor1,conic(pos,pencilconic));\n  vec3 a0, a1;\n  if (asymptotes(pencilconic,a0,a1)) {\n    color = cmix(color,vec3(0.5),line(pos,a0));\n    color = cmix(color,vec3(0.5),line(pos,a1));\n    color = cmix(color,vec3(1),point(pos,join(a0,a1)));\n  }\n#if 0\n  if (doM1M2) {\n    color = cmix(color,ccolor2,conic(pos,M1));\n    color = cmix(color,ccolor2,conic(pos,M2));\n  }\n#endif\n\n  // The midpoints of the sides of the quadrangle\n  color = cmix(color,pcolor1,point(pos,h01));\n  color = cmix(color,pcolor1,point(pos,h02));\n  color = cmix(color,pcolor1,point(pos,h03));\n  color = cmix(color,pcolor1,point(pos,h12));\n  color = cmix(color,pcolor1,point(pos,h13));\n  color = cmix(color,pcolor1,point(pos,h23));\n\n  // Vertices of the diagonal triangle\n  color = cmix(color,pcolor3,point(pos,d0));\n  color = cmix(color,pcolor3,point(pos,d1));\n  color = cmix(color,pcolor3,point(pos,d2));\n\n  // The six conjugates on each diagonal\n  color = cmix(color,pcolor4,point(pos,join(l01,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l02,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l03,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l12,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l13,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l23,l4)));\n  \n  // The points of the quadrangle\n  color = cmix(color,pcolor0,point(pos,p0));\n  color = cmix(color,pcolor0,point(pos,p1));\n  color = cmix(color,pcolor0,point(pos,p2));\n  color = cmix(color,pcolor0,point(pos,p3));\n  color = cmix(color,pcolor2,point(pos,p4));\n  \n  // Draw a cross at the orthocentre and at p0\n  color = cmix(color,vec3(1),point2(pos,h));\n  color = cmix(color,vec3(1),point2(pos,p0));\n  fragColor = vec4(pow(1.0*color,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\nfloat scale = 1.2;\n\n#define nselections 5\n\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0,0);\n  if (i == 1) return vec2(-0.5,1);\n  if (i == 2) return vec2(-1,-1);\n  if (i == 3) return vec2(1.5,-0.5);\n  if (i == 4) return vec2(1.4,0.6);\n  if (i == 5) return vec2(0.5);\n  return vec2(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}