{
    "Shader": {
        "info": {
            "date": "1596077863",
            "description": "No compromises will nuke your PC",
            "flags": 32,
            "hasliked": 0,
            "id": "3tXfz4",
            "likes": 2,
            "name": "Mandelbulb Super HQ",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "ray",
                "volume",
                "raymarch",
                "mandelbulb",
                "fake",
                "sphere",
                "cheap",
                "marcher",
                "epic",
                "render",
                "volumetrics",
                "yeet",
                "hq",
                "fakevolumetrics"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "// ^^^ Check Buffer A ^^^\n// See https://www.shadertoy.com/view/ttBcWR for full license details\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Pixel Color\n    vec3 col = texture(iChannel0, uv).rgb/float(iFrame+1);\n\n    // sample texture and output to screen\n    fragColor = vec4(acesFilm(col), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// Super HQ Version July 29th, 2020\n// The Original:\n// https://www.shadertoy.com/view/ttBcWR\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You keep the links to source I used (I don't want to get in trouble)\n// You keep the link to this on ShaderToy\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n// If you are absolutely not able to follow these terms, that is OK and I allow you I guess.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Or the exact copy can be found here:\n// https://www.shadertoy.com/view/3tXfz4\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking! (Warning: These are already nuked so\n// I don't recommend bumping them up unless you have a excellent PC)\n#define MAX_MARCHES 1024\n#define MAX_DISTANCE 32.0\n// Fake Volumetric Function\n#define COLLISION_DISTANCE abs(tan(hash11(float(iFrame+1))*3.14159265)/512.0)\n#define Bailout 4.0\n#define Iterations 64\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// Mandelbulb Distance Estimator\nfloat sphere(vec3 pos) {\n\tfloat Power = float(2.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 1.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat distorigin=0.0;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*distorigin;\n        float distsurface = sphere(raypos);\n        distorigin += distsurface;\n        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n    }\n    \n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march) {\n\t// Light Positions\n    vec3 lightpositiona = vec3(-4, 0, -2);\n\tvec3 lightpositionb = vec3(0, 0, -2);\n    vec3 lightpositionc = vec3(4, 0, -2);\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1.0,0.0,0.0);\n\tvec3 ydir = vec3(0.0,1.0,0.0);\n\tvec3 zdir = vec3(0.0,0.0,1.0);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(sin(float(iFrame))/(iResolution.x/(FOV)), cos(float(iFrame))/(iResolution.y/(FOV)), -4.5);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n    vec2 uvb = fragCoord/iResolution.xy;\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Compute and Shade\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    vec3 diffuse = shade(march);\n\n\t// Dither\n\tcol = diffuse*(hash33(vec3((float(iFrame)*fragCoord)+(fragCoord*2.0), iFrame*2)));\n\n    // Output to Screen\n    fragColor = vec4((col+texture(iChannel0, uvb).rgb),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}