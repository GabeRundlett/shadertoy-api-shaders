{
    "Shader": {
        "info": {
            "date": "1571754345",
            "description": "An image is purposely pixelated like the SNES graphics. ",
            "flags": 0,
            "hasliked": 0,
            "id": "td3SWn",
            "likes": 7,
            "name": "SNES style map scroll",
            "published": 3,
            "tags": [
                "snes"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 421
        },
        "renderpass": [
            {
                "code": "vec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n    p = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n    return sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nvec3 RasterScroll(vec2 uv, vec2 uvr) {\n    vec2 uvRef = uvr;\n    vec3 col = vec3(0.);\n\t\n\tfloat d = abs(uv.y);\n\tfloat k = 1. / d;\n\tuv = uv * k + vec2(0, k);\n\t\n    uv.y+= iTime*0.5;\n    float n = perlin_noise(uv);\n    \n    n = 0.5 + 0.55 * n;\n    \n    col += n;\n    \n    if(uvRef.y<0.1){\n        if(col.r>=0.45 && col.r<0.6) { // ground\n        col *= vec3(0.0, 0.7, 0.0);\n        } else if(col.r>=0.6){ // mountain\n            col *= vec3(0.6, 0.5, 0.1);\n        } else { // sea\n            col = vec3(0.1, 0.1, 1);\n        }\n    } else {\n    \t// sky\n        if(col.r<0.5){\n            col = vec3(0.3, 0.6, 1);\n        }\n    }\n    \n\tcol *= d * d*2.0;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =((2. *fragCoord.xy-iResolution.xy)/iResolution.y);\n    \n    float pixelSize = 30.0;\n\tuv.x -= mod(uv.x, 1.0 / pixelSize);\n\tuv.y -= mod(uv.y, 1.0 / pixelSize);\n    vec2 uvRef = uv;\n    \n\tvec3 col = RasterScroll(uv,uvRef);\n    \n\tvec3 uitcol = vec3(0.0);\n    vec2 unitPos = vec2(0.0,sin(iTime*1.8)*0.1);\n    float unitDist = sdRhombus(uvRef+unitPos, vec2(0.2,0.1+(unitPos.y*0.1)))+0.1;\n    uitcol = mix( uitcol, vec3(0.6,0.7,0.9), 1.0-smoothstep(0.1,0.095,unitDist) );\n    uitcol = mix( uitcol, vec3(0.05), 1.0-smoothstep(0.12,0.115,unitDist) );\n    \n    fragColor = vec4(col+uitcol,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}