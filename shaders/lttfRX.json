{
    "Shader": {
        "info": {
            "date": "1540575020",
            "description": "i made this trying to copy shane's [url=https://www.shadertoy.com/view/XttBW7]Tri Scale Truchet[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "lttfRX",
            "likes": 11,
            "name": "quadtree truchet many rings",
            "published": 3,
            "tags": [
                "truchet",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 599
        },
        "renderpass": [
            {
                "code": "#define HASHSCALE3 vec3(.6531, .5563, .7498)\n\n//subdivision limit\n#define limit 3.0\n#define thickness 0.01\n//how many subdivisions\n#define subs 0.4\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(10.0*fract((p3.x + p3.y) * p3.z*15.3023+0.434));\n}\n\nvec2 repeat(float a, float b) {\n    return vec2(mod(a,b),mod(-a,b));\n}\n\nfloat ripple(vec2 p, float rep) {\n    p -= max(dot(p,vec2( 1,1)),0.0);\n    p -= max(dot(p,vec2(-1,1)),0.0)*vec2(-1,1);\n    \n    float l0 = length(p+0.5);\n    \n    float l2 = floor(l0/rep);\n    \n    vec2 lens = repeat(l0+rep*0.5,rep);\n    \n    float len = 1.0;\n    \n    float s = rep*(0.5+l2);\n    \n    float a = s*s-0.5;\n    if (a > 0.0)\n    {\n        vec2 p1 = sqrt(a*0.5)*vec2(1,-1);\n        \n        vec2 p2=p1+0.5;\n        \n        if (dot(vec2(-p2.y,p2.x),p+0.5)>0.0)\n        {\n            lens.y = length(p-p1);\n        }\n    }\n    \n    return min(lens.x,lens.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime*0.1;\n    //normalize fragCoord to uv\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y\n    //some random movement stuff\n        +vec2(sin(T*6.28*exp2(-T)),cos(T*6.28*exp2(-T)))*T*4.0;\n\t\n    //lp is position in cell from 0 to 1\n    vec2 lp = fract(uv);\n    //fp is cell's bottom left corner position\n    vec2 fp = floor(uv);\n    //i is quadtree subdivisions\n    float i;\n    //size is the size of the quadtree cell\n    float size = 1.0;\n    //this is the quadtree loop, finds where the pixel lands on the quadtree\n    for (i = 0.0; i < limit; i++) {\n        //breaks randomly out of the loop (creates a random quadtree)\n        float rand = hash13(vec3(fp,i));\n        if (rand > subs||i==limit) {\n            break;\n        }\n        \n        //doubles the cell position\n        lp *= 2.0;\n        //checks which cell in the subdivision the pixel lands on\n        vec2 q = step(1.0,lp);\n        //if lp is over 1 subtract by 1\n        lp -= q;\n        //half size because of subdivision\n        size *= 0.5;\n        //moves to new cell position\n        fp += q*size;\n    }\n    //flips the truchet cell randomly\n    float rand = hash13(vec3(fp,-i-1.0));\n    if (rand < 0.5) lp.x = 1.0-lp.x;\n    \n    float a = exp2(i-limit-1.0);\n    //length to bottom left corner, or top right (whichever is closest\n    float t = length(lp-step(1.0,lp.x+lp.y));\n    //repeats the length with mod to make many rings\n    float len = ripple(lp-0.5,a*2.0);//abs(mod(t,a*2.0)-a);\n    \n    //normalize len\n    len *= size;\n    len -= thickness;\n    \n    //antialiasing\n    float mask = clamp(len*iResolution.y*0.5-0.5,0.0,1.0);\n    \n    vec2 p2 = abs(lp-0.5);\n    float e = min((1.0-max(p2.x,p2.y)*2.0)*size*iResolution.y*0.125,1.0);\n    \n    vec3 col1 = texture(iChannel0,uv*0.2).rgb;\n    col1 = mix(vec3(0.3,0.8,0.5),col1,e);\n    //shadows\n    col1 /= max(1.0,3.0-len*90.0);\n    \n    vec3 col2 = mix(vec3(0,0.5,0.8),vec3(0.5,0.2,0.76),sin(len/thickness*2.0+1.0));\n    \n    fragColor = vec4(mix(col2,col1,mask),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}