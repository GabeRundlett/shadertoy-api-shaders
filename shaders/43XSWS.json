{
    "Shader": {
        "info": {
            "date": "1709922397",
            "description": "Closest point between a segment and 3D box. The box is assumed to be solid. More here: https://www.shadertoy.com/playlist/fcGBWG\n\nDistance minimized by solving a quadratic function between line and face. Inspired by the work of David Eberly. \n",
            "flags": 0,
            "hasliked": 0,
            "id": "43XSWS",
            "likes": 7,
            "name": "Closest Segment Point - Box",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "box",
                "segment",
                "closest"
            ],
            "usePreview": 1,
            "username": "natevm",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The below is a collection of functions to compute the closest point between \n// a point / line / segment and a box / face. \n\n// Returns the closest point from a 3D point to a 3D box\n// The box is axis aligned, and centered at the origin\n//   o - the query origin\n//   b - the box radius (3 half side lengths)\nvec3 pointBoxQuery( vec3 o, vec3 b ) {\n    vec3 closest = o;\n    for (int i = 0; i < 3; ++i) {\n        if (o[i] < -b[i])\n            closest[i] = -b[i];\n        else if (o[i] > b[i])\n            closest[i] = b[i];\n    }\n    return closest;\n}\n\n// Returns the closest point from an infinite 3D line to 3D box face, plus the closest \"t\" along o+t*d\n// Based on https://www.geometrictools.com/Documentation/DistanceLine3Rectangle3.pdf\n// The box is axis aligned, centered at the origin, and d is expected to point towards \n// the first octant (reflected s.t. all d components are positive).\n//   i - the indirection indices for the face\n//   o - the origin of the segment\n//   d - the direction along the segment (which does not need to be normalized)\n//   b - the box radius (3 half side lengths)\nvec4 lineFaceQuery1(ivec3 i, vec3 o, vec3 d, vec3 b)\n{\n    vec3 PmE = o - b;\n    vec3 PpE = o + b;\n    \n    vec3 bi = vec3(b[i[0]], b[i[1]], b[i[2]]);\n    vec3 oi = vec3(o[i[0]], o[i[1]], o[i[2]]);\n    vec3 di = vec3(d[i[0]], d[i[1]], d[i[2]]);\n    vec3 PmEi = vec3(PmE[i[0]], PmE[i[1]], PmE[i[2]]);\n    vec3 PpEi = vec3(PpE[i[0]], PpE[i[1]], PpE[i[2]]);\n    \n    vec4 c;\n    if (di[0] * PpEi[1] >= di[1] * PmEi[0])\n    {\n        if (di[0] * PpEi[2] >= di[2] * PmEi[0])\n        {\n            // v[i1] >= -e[i1], v[i2] >= -e[i2] (distance = 0)\n            c = vec4(bi[0], oi[1] - di[1] * PmEi[0] / di[0], oi[2] - di[2] * PmEi[0] / di[0], -PmEi[0] / di[0]);\n        }\n        else\n        {\n            // v[i1] >= -e[i1], v[i2] < -e[i2]\n            float lenSqr = di[0] * di[0] + di[2] * di[2];\n            float tmp = lenSqr * PpEi[1] - di[1] * (di[0] * PmEi[0] + di[2] * PpEi[2]);\n            if (tmp <= 2. * lenSqr * bi[1])\n            {\n                float t = tmp / lenSqr;\n                lenSqr += di[1] * di[1];\n                tmp = PpEi[1] - t;\n                float delta = di[0] * PmEi[0] + di[1] * tmp + di[2] * PpEi[2];\n                c = vec4(bi[0], t - bi[1], -bi[2], -delta / lenSqr);\n            }\n            else\n            {\n                lenSqr += di[1] * di[1];\n                float delta = di[0] * PmEi[0] + di[1] * PmEi[1] + di[2] * PpEi[2];\n                c = vec4(bi[0], bi[1], -bi[2], -delta / lenSqr);\n            }\n        }\n    }\n    else\n    {\n        if (di[0] * PpEi[2] >= di[2] * PmEi[0])\n        {\n            // v[i1] < -e[i1], v[i2] >= -e[i2]\n            float lenSqr = di[0] * di[0] + di[1] * di[1];\n            float tmp = lenSqr * PpEi[2] - di[2] * (di[0] * PmEi[0] + di[1] * PpEi[1]);\n            if (tmp <= 2. * lenSqr * bi[2])\n            {\n                float t = tmp / lenSqr;\n                lenSqr += di[2] * di[2];\n                tmp = PpEi[2] - t;\n                float delta = di[0] * PmEi[0] + di[1] * PpEi[1] + di[2] * tmp;\n                c = vec4(bi[0], -bi[1], t - bi[2], -delta / lenSqr);\n            }\n            else\n            {\n                lenSqr += di[2] * di[2];\n                float delta = di[0] * PmEi[0] + di[1] * PpEi[1] + di[2] * PmEi[2];\n                c = vec4(bi[0], -bi[1], bi[2], -delta / lenSqr);\n            }\n        }\n        else\n        {\n            // v[i1] < -e[i1], v[i2] < -e[i2]\n            float lenSqr = di[0] * di[0] + di[2] * di[2];\n            float tmp = lenSqr * PpEi[1] - di[1] * (di[0] * PmEi[0] + di[2] * PpEi[2]);\n            if (tmp >= 0.)\n            {\n                // v[i1]-edge is c\n                if (tmp <= 2. * lenSqr * bi[1])\n                {\n                    float t = tmp / lenSqr;\n                    lenSqr += di[1] * di[1];\n                    tmp = PpEi[1] - t;\n                    float delta = di[0] * PmEi[0] + di[1] * tmp + di[2] * PpEi[2];\n                    c = vec4(bi[0], t - bi[1], -bi[2], -delta / lenSqr);\n                }\n                else\n                {\n                    lenSqr += di[1] * di[1];\n                    float delta = di[0] * PmEi[0] + di[1] * PmEi[1] + di[2] * PpEi[2];\n                    c = vec4(bi[0], bi[1], -bi[2], -delta / lenSqr);\n                }\n            }\n            else {\n                lenSqr = di[0] * di[0] +\n                di[1] * di[1];\n                tmp = lenSqr * PpEi[2] - di[2] * (di[0] * PmEi[0] + di[1] * PpEi[1]);\n                if (tmp >= 0.)\n                {\n                    // v[i2]-edge is c\n                    if (tmp <= 2. * lenSqr * bi[2])\n                    {\n                        float t = tmp / lenSqr;\n                        lenSqr += di[2] * di[2];\n                        tmp = PpEi[2] - t;\n                        float delta = di[0] * PmEi[0] + di[1] * PpEi[1] + di[2] * tmp;\n                        c = vec4(bi[0], -bi[1], t - bi[2], -delta / lenSqr);\n                    }\n                    else\n                    {\n                        lenSqr += di[2] * di[2];\n                        float delta = di[0] * PmEi[0] + di[1] * PpEi[1] + di[2] * PmEi[2];\n                        c = vec4(bi[0], -bi[1], bi[2], -delta / lenSqr);\n                    }\n                }\n                else {\n                    // (v[i1],v[i2])-corner is c\n                    lenSqr += di[2] * di[2];\n                    float delta = di[0] * PmEi[0] + di[1] * PpEi[1] + di[2] * PpEi[2];\n                    c = vec4(bi[0], -bi[1], -bi[2], -delta / lenSqr);\n                }\n            }            \n        }\n    }\n    \n    ivec3 map;\n    map[i[0]] = 0;\n    map[i[1]] = 1;\n    map[i[2]] = 2;\n    return vec4(c[map[0]], c[map[1]], c[map[2]], c.w);\n}\n\n// no branch version\nvec4 lineFaceQuery(in ivec3 i, in vec3 o, in vec3 d, in vec3 b)\n{\n  vec4 c;\n  vec3 omb = (o - b);\n  vec3 opb = (o + b);\n  vec3 bi = vec3(b[i[0]], b[i[1]], b[i[2]]);\n  vec3 oi = vec3(o[i[0]], o[i[1]], o[i[2]]);\n  vec3 di = vec3(d[i[0]], d[i[1]], d[i[2]]);\n  vec3 ombi = vec3(omb[i[0]], omb[i[1]], omb[i[2]]);\n  vec3 opbi = vec3(opb[i[0]], opb[i[1]], opb[i[2]]);\n  bool tmpvar_14 = ((di[0] * opbi[1]) >= (di[1] * ombi[0]));\n  bool tmpvar_15 = (tmpvar_14 && ((di[0] * opbi[2]) >= (di[2] * ombi[0])));\n  if (tmpvar_15) c = vec4(bi[0], (oi[1] + -(((di[1] * ombi[0]) * (1.0/(di[0]))))), (oi[2] + -(((di[2] * ombi[0]) * (1.0/(di[0]))))), (-(ombi[0]) * (1.0/(di[0]))));\n  bool tmpvar_17 = (tmpvar_14 && !(tmpvar_15));\n  float tmp_18;\n  float lenSqr_19;\n  float tmpvar_20;\n  if (tmpvar_17) tmpvar_20 = ((di[0] * di[0]) + (di[2] * di[2]));\n  if (tmpvar_17) lenSqr_19 = tmpvar_20;\n  float tmpvar_21;\n  if (tmpvar_17) tmpvar_21 = ((tmpvar_20 * opbi[1]) + -((di[1] * ((di[0] * ombi[0]) + (di[2] * opbi[2])))));\n  if (tmpvar_17) tmp_18 = tmpvar_21;\n  bool tmpvar_22 = (tmpvar_17 && (((2.0 * tmpvar_20) * bi[1]) >= tmpvar_21));\n  float tmpvar_23;\n  if (tmpvar_22) tmpvar_23 = (tmpvar_21 * (1.0/(tmpvar_20)));\n  if (tmpvar_22) lenSqr_19 = (tmpvar_20 + (di[1] * di[1]));\n  if (tmpvar_22) tmp_18 = (opbi[1] + -(tmpvar_23));\n  vec4 tmpvar_24;\n  if (tmpvar_22) c = vec4(bi[0], (tmpvar_23 + -(bi[1])), -bi[2], (-((((di[0] * ombi[0]) + (di[1] * tmp_18)) + (di[2] * opbi[2]))) * (1.0/(lenSqr_19))));\n  bool tmpvar_25 = (tmpvar_17 && !(tmpvar_22));\n  if (tmpvar_25) lenSqr_19 = (tmpvar_20 + (di[1] * di[1]));\n  if (tmpvar_25) c = vec4(bi[0], bi[1], -bi[2], (-((((di[0] * ombi[0]) + (di[1] * ombi[1])) + (di[2] * opbi[2]))) * (1.0/(lenSqr_19))));\n  bool tmpvar_27 = !(tmpvar_14);\n  bool tmpvar_28 = (tmpvar_27 && ((di[0] * opbi[2]) >= (di[2] * ombi[0])));\n  float tmp_29;\n  float lenSqr_30;\n  float tmpvar_31;\n  if (tmpvar_28) tmpvar_31 = ((di[0] * di[0]) + (di[1] * di[1]));\n  if (tmpvar_28) lenSqr_30 = tmpvar_31;\n  float tmpvar_32;\n  if (tmpvar_28) tmpvar_32 = ((tmpvar_31 * opbi[2]) + -((di[2] * ((di[0] * ombi[0]) + (di[1] * opbi[1])))));\n  if (tmpvar_28) tmp_29 = tmpvar_32;\n  bool tmpvar_33 = (tmpvar_28 && (((2.0 * tmpvar_31) * bi[2]) >= tmpvar_32));\n  float tmpvar_34;\n  if (tmpvar_33) tmpvar_34 = (tmpvar_32 * (1.0/(tmpvar_31)));\n  if (tmpvar_33) lenSqr_30 = (tmpvar_31 + (di[2] * di[2]));\n  if (tmpvar_33) tmp_29 = (opbi[2] + -(tmpvar_34));\n  if (tmpvar_33) c = vec4(bi[0], -bi[1], (tmpvar_34 + -(bi[2])), (-((((di[0] * ombi[0]) + (di[1] * opbi[1])) + (di[2] * tmp_29))) * (1.0/(lenSqr_30))));\n  bool tmpvar_36 = (tmpvar_28 && !(tmpvar_33));\n  if (tmpvar_36) lenSqr_30 = (tmpvar_31 + (di[2] * di[2]));\n  if (tmpvar_36) c = vec4(bi[0], -bi[1], bi[2], (-((((di[0] * ombi[0]) + (di[1] * opbi[1])) + (di[2] * ombi[2]))) * (1.0/(lenSqr_30))));\n  bool tmpvar_38 = (tmpvar_27 && !(tmpvar_28));\n  float tmp_39;\n  float lenSqr_40;\n  float tmpvar_41;\n  if (tmpvar_38) tmpvar_41 = ((di[0] * di[0]) + (di[2] * di[2]));\n  if (tmpvar_38) lenSqr_40 = tmpvar_41;\n  float tmpvar_42;\n  if (tmpvar_38) tmpvar_42 = ((tmpvar_41 * opbi[1]) + -((di[1] * ((di[0] * ombi[0]) + (di[2] * opbi[2])))));\n  if (tmpvar_38) tmp_39 = tmpvar_42;\n  bool tmpvar_43 = (tmpvar_38 && (tmpvar_42 >= 0.0));\n  bool tmpvar_44 = (tmpvar_43 && (((2.0 * tmpvar_41) * bi[1]) >= tmpvar_42));\n  float tmpvar_45;\n  if (tmpvar_44) tmpvar_45 = (tmpvar_42 * (1.0/(tmpvar_41)));\n  if (tmpvar_44) lenSqr_40 = (tmpvar_41 + (di[1] * di[1]));\n  if (tmpvar_44) tmp_39 = (opbi[1] + -(tmpvar_45));\n  if (tmpvar_44) c = vec4(bi[0], (tmpvar_45 + -(bi[1])), -bi[2], (-((((di[0] * ombi[0]) + (di[1] * tmp_39)) + (di[2] * opbi[2]))) * (1.0/(lenSqr_40))));\n  bool tmpvar_47 = (tmpvar_43 && !(tmpvar_44));\n  if (tmpvar_47) lenSqr_40 = (tmpvar_41 + (di[1] * di[1]));\n  if (tmpvar_47) c = vec4(bi[0], bi[1], -bi[2], (-((((di[0] * ombi[0]) + (di[1] * ombi[1])) + (di[2] * opbi[2]))) * (1.0/(lenSqr_40))));\n  bool tmpvar_49 = (tmpvar_38 && !(tmpvar_43));\n  if (tmpvar_49) lenSqr_40 = ((di[0] * di[0]) + (di[1] * di[1]));\n  if (tmpvar_49) tmp_39 = ((lenSqr_40 * opbi[2]) + -((di[2] * ((di[0] * ombi[0]) + (di[1] * opbi[1])))));\n  bool tmpvar_50 = (tmpvar_49 && (tmp_39 >= 0.0));\n  bool tmpvar_51 = (tmpvar_50 && (((2.0 * lenSqr_40) * bi[2]) >= tmp_39));\n  float tmpvar_52;\n  if (tmpvar_51) tmpvar_52 = (tmp_39 * (1.0/(lenSqr_40)));\n  if (tmpvar_51) lenSqr_40 = (lenSqr_40 + (di[2] * di[2]));\n  if (tmpvar_51) tmp_39 = (opbi[2] + -(tmpvar_52));\n  if (tmpvar_51) c = vec4(bi[0], -bi[1], (tmpvar_52 + -(bi[2])), (-((((di[0] * ombi[0]) + (di[1] * opbi[1])) + (di[2] * tmp_39))) * (1.0/(lenSqr_40))));\n  bool tmpvar_54 = (tmpvar_50 && !(tmpvar_51));\n  if (tmpvar_54) lenSqr_40 = (lenSqr_40 + (di[2] * di[2]));\n  if (tmpvar_54) c = vec4(bi[0], -bi[1], bi[2], (-((((di[0] * ombi[0]) + (di[1] * opbi[1])) + (di[2] * ombi[2]))) * (1.0/(lenSqr_40))));\n  bool tmpvar_56 = (tmpvar_49 && !(tmpvar_50));\n  if (tmpvar_56) lenSqr_40 = (lenSqr_40 + (di[2] * di[2]));\n  if (tmpvar_56) c = vec4(bi[0], -bi[1], -bi[2], (-((((di[0] * ombi[0]) + (di[1] * opbi[1])) + (di[2] * opbi[2]))) * (1.0/(lenSqr_40))));\n  ivec3 map;\n  map[i[0]] = 0;\n  map[i[1]] = 1;\n  map[i[2]] = 2;\n  return vec4(c[map[0]], c[map[1]], c[map[2]], c.w);\n}\n\n\n\n\n\n\n            \n// Returns the closest point from an infinite 3D line to a 3D box,  plus the closest \"t\" along o+t*d\n//   o - the origin of the segment\n//   d - the direction along the segment (which does not need to be normalized)\n//   b - the box radius (3 half side lengths)\nvec4 lineBoxQuery( vec3 o, vec3 d, vec3 b )\n{\n    vec4 closest;\n\n    // Transform the line direction to the first octant using reflections.\n    bvec3 reflected = lessThan(d, vec3(0.));\n    o = mix(o, -o, reflected);\n    d = mix(d, -d, reflected);\n    \n    // point minus extent\n    vec3 PmE = o - b;\n    \n    // face indices\n    ivec3 i;\n    \n    // line intersects planes x or z\n    if (d[1] * PmE[0] >= d[0] * PmE[1])\n        // line intersects x = e0 if true, z = e2 if false\n        i = (d[2] * PmE[0] >= d[0] * PmE[2]) ? ivec3(0, 1, 2) : ivec3(2, 0, 1);\n    // line intersects planes y or z\n    else\n        // line intersects y = e1 if true, z = e2 if false\n        i = (d[2] * PmE[1] >= d[1] * PmE[2]) ? ivec3(1, 2, 0) : ivec3(2, 0, 1);\n    \n    // Query closest point on face\n    closest = lineFaceQuery(i, o, d, b);\n    \n    // Account for previously applied reflections.\n    closest.xyz = mix(closest.xyz, -closest.xyz, reflected);\n    return closest;\n}\n\n// Returns the closest point from a finite 3D segment to a 3D box, plus the closest \"t\" along o+t*d\n//   s - the start of the segment\n//   e - the end of the segment\n//   b - the box radius (3 half side lengths)\nvec4 segmentBoxQuery( vec3 s, vec3 e, vec3 b ) {\n    vec3 o = s;\n    vec3 d = e - s;\n    vec4 lbOutput = lineBoxQuery(o, d, b);\n    // If closest is within the segment, return that result directly\n    if (lbOutput.w >= 0. && lbOutput.w <= 1.) \n        return lbOutput;\n    \n    // Otherwise, compute the closest point to either side of the segment\n    float parameter = (lbOutput.w < 0.) ? 0. : 1.;\n    vec3 pbOutput = pointBoxQuery(o + d * parameter, b);\n    return vec4(pbOutput, parameter);\n}\n\n//------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n//------------------------------------------------------------\nconst vec3 box_rad = vec3(0.5,0.4,0.3);\n\nvec2 map( in vec3 pos, bool showBox, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    // compute closest point to the segment on the surace of the box\n    vec4 result = segmentBoxQuery(sampleLineStart, sampleLineStop, box_rad );\n    vec3 closestPointOnLine = mix(sampleLineStart, sampleLineStop, result.w);\n    vec3 closestPointOnBox = result.xyz;\n    \n    vec2 res = vec2(1e38f);\n    \n    // query line\n    {\n    float d = sdCapsule( pos, sampleLineStart, sampleLineStop, 0.015 );\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    // closest point on line\n    {\n    float d = sdSphere( pos, closestPointOnLine, 0.06 );\n    if( d<res.x ) res = vec2( d, 1.0 );\n    }\n    \n    // Closest point on box\n    {\n    float d = sdSphere( pos, closestPointOnBox, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showBox )\n    {\n    float d = sdBox( pos, box_rad );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment from line to box\n    {\n    float d = sdCapsule( pos, closestPointOnLine, closestPointOnBox, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    // box edges\n    {\n    float d = sdBoxFrame( pos, box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    // Capsule demonstrating correctness.\n    if (showCapsule){\n    float radius = distance(closestPointOnBox, closestPointOnLine);   \n    float d = sdCapsule( pos, sampleLineStart, sampleLineStop, radius );\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showBox, in bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showBox, showCapsule, sampleLineStart, sampleLineStop ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showBox, bool showCapsule, in vec3 sampleLineStart, in vec3 sampleLineStop )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showBox, showCapsule, sampleLineStart, sampleLineStop).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate query line\n        vec3 sampleLineStart = -sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 sampleLineStop  = -cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n        // make box transparent\n        bool showBox = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showCapsule = ((samp.x+samp.y+1)&1)==0; \n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showBox,showCapsule,sampleLineStart, sampleLineStop);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showBox,showCapsule,sampleLineStart, sampleLineStop);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            // show distance isolines on box\n            if( abs(m-5.0)<0.5 )\n            {\n                vec4 result = segmentBoxQuery(sampleLineStart, sampleLineStop, box_rad);\n                vec3 closestPointOnLine = mix(sampleLineStart, sampleLineStop, result.w);\n                vec3 closestPointOnBox = result.xyz;\n    \n                float dref = sdBox( closestPointOnLine, box_rad );\n                float dsam = length(pos-closestPointOnLine);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n            // Show distance isolines on open capsule\n            if( abs(m-1.0)<0.6 )\n            {\n                vec4 result = segmentBoxQuery(sampleLineStart, sampleLineStop, box_rad);\n                vec3 closestPointOnLine = mix(sampleLineStart, sampleLineStop, result.w);\n                vec3 closestPointOnBox = result.xyz;\n    \n                float dref = sdCapsule( closestPointOnBox, sampleLineStart, sampleLineStop, .1 );\n                float dsam = length(pos-closestPointOnBox);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n                        \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showBox,showCapsule,sampleLineStart,sampleLineStop);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}