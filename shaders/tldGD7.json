{
    "Shader": {
        "info": {
            "date": "1582842601",
            "description": "Uncomment the solo define to see the phone by itself.",
            "flags": 96,
            "hasliked": 0,
            "id": "tldGD7",
            "likes": 37,
            "name": "iPhone 11",
            "published": 3,
            "tags": [
                "iphone",
                "apple"
            ],
            "usePreview": 0,
            "username": "BigWIngs",
            "viewed": 1097
        },
        "renderpass": [
            {
                "code": "// \"iPhone 11\" by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define MAX_STEPS 300\n#define MIN_DIST .5\n#define MAX_DIST 2400.\n#define SURF_DIST .1\n\n//#define SOLO_MODE\n\n#define PURPLE (vec3(209,205,218)/255.)\n#define YELLOW (vec3(255,230,129)/255.)\n#define GREEN (vec3(174,225,205)/255.)\n#define BLACK (vec3(31,32,32)/255.)\n#define WHITE (vec3(249,246,239)/255.)\n#define RED (vec3(186,12,46)/255.)\n\nvec3 baseCol = BLACK;\n    \nmat2 Rot(float a) {\n    float s = sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\nvec2 sabs(vec2 x,float k) { return vec2(sabs(x.x, k), sabs(x.y,k)); }\nvec3 sabs(vec3 x,float k) { return vec3(sabs(x.x, k), sabs(x.y,k), sabs(x.z,k)); }\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdApple(vec2 p) {    \n    float d;\n    \n    float A = length(p-vec2(-.078,.02))-.52;\n    float B = length(p-vec2(.118,.045))-.552;\n    float sides = max(A, B);\n    \n    float C = length(p-vec2(-.181,.108))-.245;\n    float D = length(p-vec2(.178,.108))-.245;\n    float top = min(C, D);\n    \n    float E = length(p-vec2(-.153,-.29))-.115;\n    float F = length(p-vec2(.176,-.3))-.107;\n    float bottom = min(E, F);\n    \n    d = mix(\n        min(top, bottom),\n        sides,\n        S(.05, -.05, p.y-.188)*S(-.05,.01, p.y+.382)\n    );\n    \n    float G = length(p-vec2(.01, -.608))-.247;\n    d = smin(d, -G, -.03);\n    float H = length(p-vec2(.487, .06))-.222;\n    d = max(d, -H);\n    \n    float I = length(p-vec2(0,.417))-.113;\n    float J = length(p-vec2(0,.17))-.163;\n    d = min(d, max(-I, J));\n    \n    float K = length(p-vec2(.207, .365))-.222;\n    float L = length(p-vec2(-.02, .567))-.222;\n    d = min(d, max(K, L));\n    \n    return d;\n}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(max(d.x,d.y), d.z),0.0) + length(max(d,0.0));\n}\nfloat sdBox2D( vec2 p, vec2 b ){\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCyl(vec3 p, float h, float r, float b) {\n\tfloat d = length(p.xy)-r+b;\n    return length(max(vec2(d, abs(p.z)-h), 0.))-b;\n}\n\nfloat sdCameras(vec3 p) {\n\t// cameras\n    float r2 = 14.7;\n\tvec2 size = vec2(26.2, 29.2);\n    \n    float d = sdBox2D(p.xy, size-r2)-r2;\n    \n    d = max(d, p.z);\t// cut back\n    \n    vec3 h = vec3(size.x, size.y, r2)-r2;\n    vec3 q = p - clamp( p, -h, h );\t\t\t// IQs elongation\n    float t = length(vec2(length(q.xy)-r2, q.z+1.))-1.; // torus\n    d = max(d, -t);\t// cut bevel\n    d = smin(d, -(p.z+1.), -.5); // cut front\n    \n    d = max(d, -sdCyl(p-vec3(11.6,0,-3.8), 1.5, 5.6, 2.));\t// flash\n    d = max(d, -sdCyl(p-vec3(11.6,14.5,-3.), 1.5, 2.8, 1.));\t// mike\n\n    // lenses\n    vec3 lp = vec3(p.x+11.5, abs(p.y)-14.6, p.z);\n    d = min(d, sdCyl(lp, 1.5, 12., .4)); // ring\n    d = min(d, sdCyl(lp, 1.8, 10., .3)); // lens cap\n    \n    d = max(d, (8.-length(lp*vec3(1,1,4)+vec3(0,0,7)))/4.); // hole\n    d = min(d, (length(lp*vec3(1,1,2))-4.)/2.);\n    \n    return d;\n}\n\nvec4 TransformPos(vec3 p) {\n\tfloat id = 0.;\n    #ifndef SOLO_MODE\n    vec3 s = sign(p);\n    vec3 size = vec3(400, 400, 800);\n    \n    float t = mod(iTime, 200.)*.5;\n    \n    p.z -= t*400.;\n    \n    id = floor(p.z/size.z);\n    p.z = mod(p.z, size.z)-size.z*.5;\n    \n    p.xy *= Rot(t*.3+id);\t\t\t// rotate wheel\n    s = sign(p);\n    float flip = s.x==s.y?1.:-1.;\n    p.xy = abs(p.xy)-size.xy*.5;\t// 4-fold \n    p.x *= flip;\n    \n    p.xy *= Rot(3.1415*.25*flip);\t\t// point to center\n    p.xz *= Rot(t+id);\t\t\t\t// spin on axis\n    \n    #endif\n    return vec4(p,id);\n}\n\nfloat GetDist(vec3 p) {\n    p = TransformPos(p).xyz;\n    \n    vec3 size = vec3(75.7, 150.9, 8.3);\n    float r1 = 24.3;\n    \n\tfloat front = sdBox2D(p.xy, size.xy-r1)-r1;\n    float side = sdBox2D(p.yz, vec2(144, 8.1)-8.)-8.;\n    float top = sdBox2D(p.xz, vec2(71.4, 8.1)-8.)-8.;\n   \n    float d = sdBox(p, size-size.z)-size.z;\n    d = smin(d, front, -4.);\n    \n    // front cam and speaker\n    d = smin(d, 1.-sdBox(p-vec3(0,137.8,size.z), vec3(7.95,0, .0)), -.5);\n    \n    vec3 h = size-r1;\n    vec3 q = p-clamp(p, -h, h);\n    float groove = length(q.xy*1.35)-r1-1.;\n    d += S(.5,-.5,groove)*.4;\n    \n    // buttons\n    side = step(0., p.x);\n    \n    float lb = sdBox2D(p.zy-vec2(0, 65.1), vec2(0,16))-3.;\n    lb = S(.3, -1., lb)-S(-.5, -2., lb)*1.5;\n    \n    float rb = sdBox2D(p.zy-vec2(0, 104.1), vec2(.5,6))-2.;\n    rb = S(.3, -1., rb);\n    d += rb * side;\n    rb = sdBox2D(p.zy-vec2(1, 104.1), vec2(0,6))-2.;\n    rb = S(.3, -1., rb);\n    d -= rb * side;\n    \n    vec2 bp = vec2(p.z, abs(p.y-65.1));\n    \n    rb = sdBox2D(bp-vec2(0, 13), vec2(0,9))-3.;\n    rb = S(.3, -1., rb)-S(-.5, -2., rb)*1.5;\n    \n    d += mix(lb, rb, side);\n    \n    // bottom\n    vec3 pb = vec3(abs(p.x), p.y+size.y, p.z); \n    float bb = sdBox(pb, vec3(8, 4, 0))-2.;\n    bb = min(bb, sdCyl((pb-vec3(15, 0, .6)).zxy, 1., 1.76, .5));\n    \n    pb.x = mod(pb.x-2.35, 4.7)-2.35;\n    float mh = sdCyl(pb.zxy, 4., 1.47, .2);\n    mh = max(mh, abs(abs(p.x)-35.4)-13.2);\n    bb = min(bb, mh);\n    \n    d = smin(d, -bb, -1.);\n    \n    // cameras\n    d = min(d, sdCameras(p-vec3(-39.6, 111.4, -size.z)));\n    \n    return d*.7;\n}\n\nfloat AO( in vec3 p, in vec3 n, in float maxDist, in float falloff ) {\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = fract(sin((float(i))*maxDist));\n        vec3 rd = n*l;\n        \n        ao += (l - max(GetDist( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec3(dO, abs(dS), matId);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(1e-2, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Pixelize(sampler2D sampler, vec2 uv, vec2 resolution) {\n   // resolution *= .1;\n    uv *= resolution;\n    \n    vec2 c = fwidth(uv)*100.;\n    \n    vec2 gv = fract(uv)-.5; \n    vec2 id = floor(uv);\n    \n    float rbPixel = length(gv);\n    float gPixel = length(abs(gv)-.5);\n    \n    float checker = mod(id.x+id.y, 2.);\n    vec3 colorMask = vec3(checker, 0., 1.-checker);\n    \n    float rgbShift = smoothstep(.4, .2, gPixel);\n    colorMask = mix(colorMask, vec3(0,1,0), rgbShift);\n    \n    id += rgbShift*.5*sign(gv);\n    vec3 col = texture(sampler, id/resolution).rgb;\n    \n\tfloat pixelMask = smoothstep(.5, .2, rbPixel) + smoothstep(.3, .2, gPixel);\n    \n    float fade = clamp(dot(c,c)/1e4, 0., 1.);\n    col *= mix(pixelMask*colorMask*2., vec3(1.), fade);\n    //col = vec3(fade);\n    \n    return col;\n}\n\nvoid SetBaseCol(float id) {\n     if(id==0.)\n    \tbaseCol = YELLOW;\n    else if(id==1.)\n        baseCol = GREEN;\n    else if(id==2.)\n        baseCol = PURPLE;\n    else if(id==3.)\n        baseCol = BLACK;\n    else if(id==4.)\n        baseCol = RED;\n    else\n        baseCol = WHITE;\n}\n\nvec3 Material(vec3 p, vec3 n, vec3 rd) {    \n    float ao = AO(p, n, .5, .5);\n    \n    vec3 s = sign(p);\n    vec4 P = TransformPos(p);\n    \n    p = P.xyz;\n    \n    float id = mod(P.w, 6.);\n    SetBaseCol(id);\n      \n    vec3 col;\n    \n    vec3 r = reflect(rd, n);\n    float f = 1.+dot(n, rd);\n    float fresnel = pow(max(f, 0.), 2.);\n    \n    vec3 blurRef = texture(iChannel0, r).rgb;\n    vec3 sharpRef = texture(iChannel1, r).rgb;\n    \n    float w = .2;\n    \n    float side = step(0., -p.z);\t// which side 0=front 1=back\n    float bandDist = sdBox2D(p.xy, vec2(51.3, 126.6))-18.7;\n    float band = S(-w, w, bandDist);\n    \n    if(side<.5) {\t// screen side\n        float screenDist = sdBox2D(p.xy, vec2(51.3, 126.6)-1.)-15.;\n        screenDist = smin(screenDist, 10.-sdBox2D(p.xy-vec2(0,139.5), vec2(37, 10.5)-10.), -3.);\n        float screen = S(w, -w, screenDist)*(1.-side);\n        \n        vec2 uv = p.xy/vec2(-150*2, 300) +.5;\n        vec3 scrCol = texture(iChannel2, uv).rgb;\n        scrCol = Pixelize(iChannel2, uv, vec2(828,1792));\n        col = scrCol*screen;\n        col += .002*(1.-screen);\n        vec2 lp = p.xy-vec2(-14.6, 137.8);\n        float d = length(lp)-2.6;\n        if(d<0.) {\n            float z = 1.-rd.y;\n            z = 0.;\n            \n            vec3 ref = vec3(.3, .2, .8)*S(.3, -.3, d+1.)*d*d*.5;\n            ref *= ref;\n            ref *= pow(1.-f, 12.)*.25;\n            \n            col = ref;\n        }\n        \n        col += sharpRef*.05;\n        \n    } else {\t\t\t// back side\n        float logo = S(.01, -.01, sdApple(p.xy*.04));\n    \t\n        col = baseCol*baseCol*ao;\n        col += mix(blurRef, sharpRef, logo)*.5;\n        \n        // camera area \n        vec2 cp = p.xy-vec2(-39.6, 111.4);\n        vec2 lp = vec2(cp.x+11.5, abs(cp.y)-14.6);\n        float d = length(lp);\n        \n        if(d<10.) {\n            col = vec3(col.r*0.1);\n            vec3 ref = sharpRef*vec3(.3, .2, .8)*2.;\n            col += ref*ref*sqrt(f)*S(4., 3., d);\n            ref = texture(iChannel1, reflect(rd,vec3(0,0,-1))).rgb;\n            //col *= ao;\n            col += ref*rd.y;   \n        } else if(d<12.) {\n            band = 1.;\n        }\n        \n        // flash\n        vec2 fp = cp-vec2(11.5,0);\n        d = length(fp);\n        if(d<4.5) {\n            float fd = length(fp+rd.xy);\n            float sep = 2.;\n            float w1d = length(fp-vec2(0, sep));\n            float w2d = length(fp+vec2(0, sep));\n            float freq = 15.;\n            float waves = (sin(w1d*freq)+sin(w2d*freq))*S(.0, -.5, fd-4.3); \n            vec3 flashCol = mix(vec3(1., .5, .2), vec3(.8), fd*.3);\n           \tflashCol += S(3., 1., length(fp-vec2(0.,sep)))*.2;\n            flashCol += waves*.05;\n            col = mix(col, flashCol, S(.3, -.0, d-4.2));\n            col *= S(1., -1., d-4.5);\n        }\n        \n        // mike\n        fp = cp-vec2(11.5,14.5);\n        float fd = length(fp);\n        if(fd<2.2) {\n            float m = S(2.2, 2., fd);\n            fp *= 10.;\n            m *= max(0., sin(fp.x+fp.y))+max(0., sin(fp.x-fp.y));\n        \tfloat distFade = min(1., fwidth(length(p))*3.);\n            col = mix(vec3(m), vec3(.5), distFade);\n            //col = vec3(distFade);\n        }\n    }\n    \n    float gaps = S(w, -w, abs(abs(p.y)-120.)-1.4);\n    gaps *= S(71.7, 72.1, abs(p.x));\n    vec3 bandCol = pow(blurRef, vec3(.4))*baseCol;\n    bandCol *= 1.-gaps*.3;\n    \n    float shadow = clamp(74.2-abs(p.x), 0., 1.);\n    shadow *= clamp(4.-abs(p.z), 0., 1.); \n    float s1 = shadow;\n    shadow *= clamp(115.-abs(p.y), 0., 1.);\n    shadow += S(-149., -146., p.y)*s1*S(52., 50., length(p.xy+vec2(0,150)));\n    bandCol -= shadow;\n    \n    col = mix(col, bandCol, band);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    float t = iTime;\n    \n    vec2 p = uv;\n    float zoom = mix(1., 15., (sin(iTime)*.5+.5)*0.);\n    \n    #ifdef SOLO_MODE\n    vec3 ro = vec3(0,0,-300);\n    if(uv.x>0.) {\n    \tuv.x -= .5;\n    } else {\n    \tuv.x += .3;\n        uv *= .25;\n    }\n    #else\n    vec3 ro = vec3(0,0,-600);\n    #endif\n    \n    ro.xz *= Rot(-M.x*6.2831-3.1415);\n    //ro.yx *= -Rot(M.y*3.1415);\n    ro.y -= M.y*800.;\n    vec3 lookat = vec3(0, ro.y*.3, 0);\n    //lookat = vec3(-39.6, 111.4, 10);\n   // lookat = vec3(-59.6*0., 136.4, 10);\n   // lookat = vec3(0, -140,0);\n    \n    mat2 rot = Rot(iTime);\n    vec3 rd = R(uv, ro, lookat, zoom);\n\tvec3 bg = WHITE;\n    #ifdef SOLO_MODE\n    float f = .01/dot(uv,uv);\n    bg *= 0.;\n    #endif\n    \n    vec3 col = bg;\n    \n    //ro.xz *= rot; rd.xz*=rot;\n    vec3 info = RayMarch(ro, rd);\n    \n    if(info.y<SURF_DIST) {\n        vec3 p = ro + rd*info.x;\n        vec3 n = GetNormal(p);\n        col = Material(p, n, rd);\n    }\n    \n    float fade = min(1., info.x/2400.);\n    col = mix(col, bg, fade*fade*fade);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 20765,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/mrsuicidesheep/novo-amor-anchor"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Into You - by Martijn Steinrucken aka BigWings - 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// You can change the focal plane by moving the mouse up and down.\n\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=lrMiME82Cuk\n\n// Making of video part1:\n// https://www.youtube.com/watch?v=dXyPOLf2MbU\n\n// Android Phone Wallpaper:\n// https://play.google.com/store/apps/details?id=com.TheArtOfCode.FallingHearts\n\n// Music - Novo Amor - Anchor\n// https://soundcloud.com/mrsuicidesheep/novo-amor-anchor\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n#define HEARTCOL vec3(1., .01, .01)\n#define NUM_HEARTS 100.\n#define LIGHT_DIR vec3(.577, -.577, -.577)\n\n// Polynomial smooth max from IQ\nfloat smax( float a, float b, float k ) {\n\tfloat h = sat( .5 + .5*(b-a)/k );\n\treturn mix( a, b, h ) + k*h*(1.-h);\n}\n\n// Quaternion rotation functions from Ollj\nvec4 qmulq(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\nvec4 aa2q(vec3 axis, float angle){return vec4(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dot(q,q);}\nvec3 qmulv(vec4 q, vec3 p){return qmulq(q,qmulq(vec4(p,.0),qinv(q))).xyz;}\n\nvec2 RaySphere(vec3 rd, vec3 p) {\n    float l = dot(rd, p);\n    float det = l*l - dot(p, p) + 1.;\n    if (det < 0.) return vec2(-1);\n\n    float sd = sqrt(det);\n    return vec2(l - sd, l+sd);\n}\n\nstruct sphereInfo {\n\tvec3 p1, p2, n1, n2;\n    vec2 uv1, uv2;\n};\n\nsphereInfo GetSphereUvs(vec3 rd, vec2 i, vec2 rot, vec3 s) {\n\tsphereInfo res;\n    rot *= 6.2831;\n    vec4 q = aa2q(vec3(cos(rot.x),sin(rot.x),0), rot.y);\n    vec3 o = qmulv(q, -s)+s;\n    vec3 d = qmulv(q, rd);\n    \n    res.p1 = rd*i.x;\n    vec3 p = o+d*i.x-s;\n    res.uv1 = vec2(atan(p.x, p.z), p.y);\n    res.n1 = res.p1-s;\n    \n    res.p2 = rd*i.y;\n    p = o+d*i.y-s;\n    res.uv2 = vec2(atan(p.x, p.z), p.y);\n    res.n2 = s-res.p2;\n        \n    return res;\n}\n\nfloat Heart(vec2 uv, float b) {\n\tuv.x*=.5;\n    float shape = smax(sqrt(abs(uv.x)), b, .3*b)*.5;\n    uv.y -= shape*(1.-b);\n\n    return S(b, -b, length(uv)-.5);\n}\n\nvec4 HeartBall(vec3 rd, vec3 p, vec2 rot, float t, float blur) {\n    vec2 d = RaySphere(rd, p);\n    \n   \tvec4 col = vec4(0);\n    if(d.x>0.) {\n    \tsphereInfo info = GetSphereUvs(rd, d, rot, p);\n    \t\n        float sd = length(cross(p, rd));\n        float edge =  S(1., mix(1., 0.1, blur), sd);\n        \n        float backMask = Heart(info.uv2, blur)*edge; \n        float frontMask = Heart(info.uv1, blur)*edge; \n        float frontLight = sat(dot(LIGHT_DIR, info.n1)*.8+.2);\n        float backLight = sat(dot(LIGHT_DIR, info.n2)*.8+.2)*.9;\n\n        col = mix(vec4(backLight*HEARTCOL, backMask), \n                  vec4(frontLight*HEARTCOL, frontMask), \n                  frontMask);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.3;\n  \n    vec3 rd = normalize(vec3(uv, 1));\n    \n    m.y = iMouse.z>0. ? 1.-m.y : .4;\n\n    vec2 rot = t*vec2(.12, .18);\n    vec4 col = vec4(0);\n        \n    for(float i=0.; i<1.; i+=(1./NUM_HEARTS)) {\n        float x = (fract(cos(i*536.3)*7464.4)-.5)*15.;\n        float y = (fract(-t*.2+i*7.64)-.5)*15.;\n        float z = mix(14., 2., i);\n        \n        float blur = mix(.03, .35, S(.0, .4, abs(m.y-i)));\n        \n        rot += (fract(sin(i*vec2(536.3, 23.4))*vec2(764.4, 987.3))-.5);\n        vec4 heart = HeartBall(rd, vec3(x, y, z), rot, t, blur);\n        \n        col = mix(col, heart, heart.a);\n    }\n\t\n    fragColor = col;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}