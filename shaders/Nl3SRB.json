{
    "Shader": {
        "info": {
            "date": "1639298629",
            "description": "I'm sad that I couldn't show everyone what I intended to do in time, but hopefully you like it.\nOriginally coded on Bonzomatic, thank you Nerumae for the music! Congrats to phi16 for advancing.",
            "flags": 32,
            "hasliked": 0,
            "id": "Nl3SRB",
            "likes": 11,
            "name": "TDF Semi Final Plan ",
            "published": 3,
            "tags": [
                "shadershowdown",
                "tdf",
                "tokyodemofest"
            ],
            "usePreview": 0,
            "username": "sp4ghet",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "#define texPreviousFrame iChannel0\nconst vec3 up = vec3(0,1,0);\n\nvoid chmin(inout vec4 a, vec4 b, float k){\n  float h = max(0., k-abs(a.x-b.x))/k;\n  float x = min(a.x, b.x) - h*h*h*k/6.;\n  vec3 aa = a.x < b.x ? a.yzx : b.yzw;\n  vec3 bb = a.x < b.x ? b.yzx : a.yzw;\n\n  a = vec4(x, mix(aa,bb, h*h*h*k/6.));\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return length(max(p,0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nvec4 map(vec3 q){\n  vec4 d = vec4(1000, 0,0,0);\n  vec3 p = q;\n\n  for(int i=0; i<n_part; i++){\n    float sp = length(p - psn[i]) - rad[i];\n    chmin(d, vec4(sp, 1, length(vel[i]), 0.), 3.);\n  }\n\n  float bx = box(p, vec3(12));\n  bx = max(bx, -box(p - vec3(0,0,2), vec3(10)) + .5);\n  chmin(d, vec4(bx, 0,0,0), 0.01);\n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n  return normalize(vec3(\n    map(p + e.xyy).x - map(p - e.xyy).x,\n    map(p + e.yxy).x - map(p - e.yxy).x,\n    map(p + e.yyx).x - map(p - e.yyx).x\n  ));\n}\n\n\n\nfloat shad(vec3 ro, vec3 rd, vec3 sp, float r, float k, float maxt){\n  vec3 oc = ro-sp;\n  float b = dot(oc,rd);\n  float c = dot(oc,oc) - r*r;\n  float h = b*b -c;\n  float d = -r + sqrt(max(0., r*r-h));\n  float t = -b - sqrt(max(0., h));\n  bool hit = (t < 0. || t > maxt);\n  float sh;\n  if(hit){\n      sh =1.;\n  }else{\n      sh = smoothstep(0., 1., k*d/t);\n  }\n  return sh;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 pt = uv - 0.5;\n\tpt /= vec2(iResolution.y / iResolution.x, 1.);\n    vec3 c = vec3(0);\n\n    int seed = int(fragCoord.x + 8000.) * int(fragCoord.y + 7777.) + int(1000. * time);\n\n  for(int i=0; i<n_part; i++){\n    float pu = (float(i)*2. + 0.5) / float(2*n_part);\n    float vu = (float(i)*2. + 1.5) / float(2*n_part);\n    float px = texture(texPreviousFrame, vec2(pu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 3. / 12.)).a / 255.;\n    float py = texture(texPreviousFrame, vec2(pu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 7. / 12.)).a/ 255.;\n    float pz = texture(texPreviousFrame, vec2(pu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 11. / 12.)).a/ 255.;\n    float vx = texture(texPreviousFrame, vec2(vu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 3. / 12.)).a/ 255.;\n    float vy = texture(texPreviousFrame, vec2(vu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 7. / 12.)).a/ 255.;\n    float vz = texture(texPreviousFrame, vec2(vu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 11. / 12.)).a/ 255.;\n\n    psn[i] = vec3(px, py, pz) * pRange - pRange / 2.;\n    vel[i] = vec3(vx, vy, vz) * vRange - vRange / 2.;\n  }\n  \n  vec3 ro = vec3(0,0,30);\n  vec3 rd = normalize(vec3(pt,-1));\n\n  vec3 p = ro;\n  vec4 d;\n  float t=0.;\n  for(int i=0; i<128; i++){\n    p = ro + rd*t;\n    d = map(p);\n    t += d.x;\n    if(abs(d.x) < 0.001 || t > 60.){\n      break;\n    }\n  }\n\n  if(abs(d.x) < 0.001){\n    vec3 n = normal(p, vec2(.01, 0));\n    vec3 al = vec3(.5);\n    vec3 lp = vec3(0,8, 14);\n    vec3 l = normalize(lp-p);\n    float ld = length(lp-p);\n    float li = 30. / pow(ld,2.);\n\n    c = li * al * max(dot(n,l),0.);\n    for(int i=0; i<n_part; i++){\n      c *= shad(p, l, psn[i], rad[i], 15., ld);\n    }\n    c += vec3(.2, .8, .9) * pow(d.z / 15., 3.);\n  }\n\n  c *= (.8 + .4 * rnd(seed));\n  //c += .01 * vec3(a);\n\n  c = pow(c, vec3(.4545));\n  \n  //c = texture(iChannel0, uv).rgb;\n\n  // Output to screen\n  fragColor = vec4(c,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define texPreviousFrame iChannel0\n\nvoid calcVelo(){\n    for(int i=0; i<n_part; i++) for(int j=0; j<n_part; j++){\n      if(i==j){continue;}\n      float m1 = 1.3333 * rad[i]*rad[i]*rad[i];\n      float m2 = 1.3333 * rad[j]*rad[j]*rad[j];\n      vec3 r = psn[j]-psn[i];\n      vec3 rh = normalize(r);\n      float rl = length(r);\n      vel[i] += 0.05 * m2 * rh / max(.005, pow(rl,2.));\n\n      vec3 b = abs(psn[i]);\n      if(b.x > pRange/2.-1.){\n        vel[i].x = .9 * abs(vel[i].x) * -sign(psn[i].x);\n      }\n\n      if(b.y > pRange/2.-1.){\n        vel[i].y = .9 * abs(vel[i].y) * -sign(psn[i].y);\n      }\n\n      if(b.z > pRange/2.-1.){\n        vel[i].z = .9 * abs(vel[i].z) * -sign(psn[i].z);\n      }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    for(int i=0; i<n_part; i++){\n    float pu = (float(i)*2. + 0.5) / float(2*n_part);\n    float vu = (float(i)*2. + 1.5) / float(2*n_part);\n    float px = texture(texPreviousFrame, vec2(pu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 3. / 12.)).a / 255.;\n    float py = texture(texPreviousFrame, vec2(pu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 7. / 12.)).a/ 255.;\n    float pz = texture(texPreviousFrame, vec2(pu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(pu, 11. / 12.)).a/ 255.;\n    float vx = texture(texPreviousFrame, vec2(vu, 1. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 3. / 12.)).a/ 255.;\n    float vy = texture(texPreviousFrame, vec2(vu, 5. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 7. / 12.)).a/ 255.;\n    float vz = texture(texPreviousFrame, vec2(vu, 9. / 12.)).a\n             + texture(texPreviousFrame, vec2(vu, 11. / 12.)).a/ 255.;\n\n    psn[i] = vec3(px, py, pz) * pRange - pRange / 2.;\n    vel[i] = vec3(vx, vy, vz) * vRange - vRange / 2.;\n  }\n  calcVelo();\n\n    vec2 parts = get_id(uv, vec2(n_part, 3)*2.);\n    int id = int(parts.x / 2.);\n    bool isP = mod(parts.x, 2.) == 0.;\n    int xyz = int(parts.y / 2.);\n    bool isU = mod(parts.y, 2.) == 0.;\n    if(mod(time, 1000.) < 0.1){\n        psn[id] = vec3(rnd(id + 17), rnd(id+5), rnd(id+ 23)) * pRange * .8 - pRange/2.3;\n        vel[id] = vec3(0);\n    }\n    \n    psn[id] += dt * vel[id];\n    vec3 val = isP ? clamp(psn[id] + pRange/2., 0., pRange) / pRange : clamp(vel[id] + vRange/2., 0., vRange) / vRange;\n    val = isU ? floor(val * 255.) / 255. : mod(val, 1. / 255.) * 255.;\n    float a = val[xyz];\n    \n    fragColor = vec4(a);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define time iTime\n#define dt iTimeDelta\n#define get_id(x,n) floor((x) * (n))\n\n\nfloat pRange = 20.;\nfloat vRange = 30.;\nconst int n_part = 5;\nvec3 psn[n_part], vel[n_part];\nfloat rad[n_part] = float[](1., 1.5, 2., 3., 0.5);\n\nfloat rnd(int n){\n  n = (n<<13) ^ n;\n  return 1. - float((n * (n*n*12351 + 45803) + 7082934) & 0x7fffffff) / pow(2.,30.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}