{
    "Shader": {
        "info": {
            "date": "1474712260",
            "description": "I just wanted know how DDA algorithm works and make it simple.\nhttp://lodev.org/cgtutor/raycasting.html",
            "flags": 0,
            "hasliked": 0,
            "id": "4lV3WD",
            "likes": 6,
            "name": "DDA Port",
            "published": 3,
            "tags": [
                "voxel",
                "dda"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 900
        },
        "renderpass": [
            {
                "code": "//Porting from DDA c++ code \"http://lodev.org/cgtutor/raycasting.html\"\nfloat posX = 0.5, posY = 0.5;  //x and y start position\nfloat dirX = -1.0, dirY = 0.0; //initial direction vector\nfloat planeX = 0.0, planeY = 0.66; //the 2d raycaster version of camera plane\n\nfloat w = 1.0;\nfloat h = 1.0;\n\n// Map is generated from my own c++ code...\nint getWallMap(int x, int y){\n    int w = 0;\n    if(x == 0 && y == 0){w = 0;}if(x == 0 && y == 1){w = 0;}if(x == 0 && y == 2){w = 0;}if(x == 0 && y == 3){w = 0;}if(x == 0 && y == 4){w = 0;}\n    if(x == 1 && y == 0){w = 0;}if(x == 1 && y == 1){w = 0;}if(x == 1 && y == 2){w = 3;}if(x == 1 && y == 3){w = 1;}if(x == 1 && y == 4){w = 0;}\n    if(x == 2 && y == 0){w = 0;}if(x == 2 && y == 1){w = 2;}if(x == 2 && y == 2){w = 0;}if(x == 2 && y == 3){w = 4;}if(x == 2 && y == 4){w = 0;}\n    if(x == 3 && y == 0){w = 0;}if(x == 3 && y == 1){w = 1;}if(x == 3 && y == 2){w = 1;}if(x == 3 && y == 3){w = 1;}if(x == 3 && y == 4){w = 0;}\n    if(x == 4 && y == 0){w = 0;}if(x == 4 && y == 1){w = 0;}if(x == 4 && y == 2){w = 0;}if(x == 4 && y == 3){w = 0;}if(x == 4 && y == 4){w = 0;}\n    return w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( fragCoord.xy / iResolution.xy );\n    p.y = 1.0-p.y;\n\n    vec3 col = vec3( 0.0 );\n\n    float time = iTime;\n    float oldDirX = dirX;\n    dirX = dirX * cos(-time) - dirY * sin(-time);\n    dirY = oldDirX * sin(-time) + dirY * cos(-time);\n    float oldPlaneX = planeX;\n    planeX = planeX * cos(-time) - planeY * sin(-time);\n    planeY = oldPlaneX * sin(-time) + planeY * cos(-time);\n    \n    //calculate ray position and direction\n    float cameraX = 2.0 * p.x / w - 1.0; //x-coordinate in camera space\n    float rayPosX = posX;\n    float rayPosY = posY;\n    float rayDirX = dirX + planeX * cameraX;\n    float rayDirY = dirY + planeY * cameraX;\n    //which box of the map we're in\n    int mapX = int(rayPosX);\n    int mapY = int(rayPosY);\n\n    //length of ray from current position to next x or y-side\n    float sideDistX;\n    float sideDistY;\n\n    //length of ray from one x or y-side to next x or y-side\n    float deltaDistX = sqrt(1.0 + (rayDirY * rayDirY) / (rayDirX * rayDirX));\n    float deltaDistY = sqrt(1.0 + (rayDirX * rayDirX) / (rayDirY * rayDirY));\n    float perpWallDist;\n\n    //what direction to step in x or y-direction (either +1 or -1)\n    int stepX;\n    int stepY;\n\n    int hit = 0; //was there a wall hit?\n    int side = 0; //was a NS or a EW wall hit?\n    //calculate step and initial sideDist\n    if (rayDirX < 0.0){\n        stepX = -1;\n        sideDistX = (rayPosX - float(mapX)) * deltaDistX;\n    }else{\n        stepX = 1;\n        sideDistX = (float(mapX) + 1.0 - rayPosX) * deltaDistX;\n    }\n\n    if (rayDirY < 0.0){\n        stepY = -1;\n        sideDistY = (rayPosY - float(mapY)) * deltaDistY;\n    }else{\n        stepY = 1;\n        sideDistY = (float(mapY) + 1.0 - rayPosY) * deltaDistY;\n    }\n\n    //perform DDA\n    for(int i = 0; i<10; i++){\n        if (hit == 0){\n            //jump to next map square, OR in x-direction, OR in y-direction\n            if (sideDistX < sideDistY){\n                sideDistX += deltaDistX;\n                mapX += stepX;\n                side = 0;\n            }else{\n                sideDistY += deltaDistY;\n                mapY += stepY;\n                side = 1;\n            }\n            //Check if ray has hit a wall\n            if (getWallMap(mapX,mapY) >= 1) hit = 1;\n        }\n    }\n\n    //Calculate distance projected on camera direction (oblique distance will give fisheye effect!)\n    if (side == 0) perpWallDist = (float(mapX) - rayPosX + (1.0 - float(stepX)) / 2.0) / rayDirX;\n    else           perpWallDist = (float(mapY) - rayPosY + (1.0 - float(stepY)) / 2.0) / rayDirY;\n\n    //Calculate height of line to draw on screen\n    float lineHeight = h / perpWallDist;\n\n    //calculate lowest and highest pixel to fill in current stripe\n    float drawStart = -lineHeight / 2.0 + h / 2.0;\n    if(drawStart < 0.0)drawStart = 0.0;\n    float drawEnd = lineHeight / 2.0 + h / 2.0;\n    if(drawEnd >= h)drawEnd = h - 1.0;\n\n    //choose wall color\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n\n    int wall = getWallMap(mapX,mapY);\n    if(wall == 1){\n        r = 1.0;\n    } else if(wall == 2) {\n        g = 1.0;\n    } else if(wall == 3) {\n        b = 1.0;\n    } else if(wall == 4) {\n        r = 1.0;\n        g = 1.0;\n        b = 1.0;\n    } else {\n        r = 1.0;\n        g = 1.0;\n    }\n\n    //give x and y sides different brightness\n    if (side == 1) {\n        r = r/2.0;\n        g = g/2.0;\n        b = b/2.0;\n    }\n\n    // drawing line\n    if((p.x <= p.x+0.01) && (p.y >= drawStart && p.y <= drawEnd)){\n        col = vec3( r,g,b );\n    }\n\n    fragColor = vec4( col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}