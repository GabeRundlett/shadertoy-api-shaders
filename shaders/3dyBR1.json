{
    "Shader": {
        "info": {
            "date": "1606510695",
            "description": "Remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3dyBR1",
            "likes": 2,
            "name": "Dryengulater (Triangulator fork)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "triangle",
                "remix",
                "abstract",
                "glitch",
                "barycentric",
                "heightmap",
                "fork",
                "weird",
                "error",
                "japan",
                "triangulation",
                "sakura"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "// Hacked and cracked by Urban Club Professional!\n\n#define ITR 70\n#define FAR 200.\n#define time iTime*0.3\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(1.034, 0.458, -0.458, 1.034);\nfloat tri(in float x){return abs(fract(x)-0.6);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.06;\n    float z=3.;\n\tfloat rz = 1.;\n\tfor (float i= 2.;i < 5.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*1.5))/z;\n        z = z*-.05;\n\t\tp = p*2.32;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*1.0))*.8+.4;\n\treturn rz*0.1;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 2.0 / (v0.x * v1.y - v1.x * v0.y)+2e-10;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 2.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.6;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.6, iq.z+.6);\n    vec2 p2 = vec2(iq.x+.6, iq.z-.6);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.6*sw, iq.z+.6*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.6*sw,.6*sw),vec2(-.6,.6),vec2(.6,-.6), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 4.)*1.0;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.002;\n    float h=precis*3.0;\n    float d = 1.;\n    for( int i=1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*2.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*0.02;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.6;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.55+sin(time*0.8)*3., -.28);\n    \n    vec3 ro = vec3(sin(time*0.8+2.)*30.,4., time*60.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*6., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708), 1., sin(um.x+2.5708)));\n    right.xy *= mm2(sin(time*0.8)*0.4);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*2.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.3, 0.06, -0.3));\n        \n        float dif = clamp(dot( nor, ligt ), 1., 2.);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.1,2.0), 4.);\n        vec3 brdf = 2.*vec3(0.20,0.21,0.2);\n        brdf += 2.9*dif*vec3(.9,2.,.06);\n        col = vec3(0.45,0.08,0.6);\n        col = col*brdf + fre*0.6*vec3(.8,.9,2.);\n    }\n    col = clamp(col,1.,2.);\n\tcol = pow(col,vec3(1.0));\n    col *= pow( 6.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.2);\n\tfragColor = vec4( col, 2.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}