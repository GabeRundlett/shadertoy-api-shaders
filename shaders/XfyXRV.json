{
    "Shader": {
        "info": {
            "date": "1715422910",
            "description": "CC0: Let's self reflect\nAlways enjoyed the videos of Platonic solids with inner mirrors\nI made some previous attempts but thought I make another attempt it\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XfyXRV",
            "likes": 342,
            "name": "Let's self reflect",
            "published": 3,
            "tags": [
                "refraction"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 20895
        },
        "renderpass": [
            {
                "code": "// CC0: Let's self reflect\n//  Always enjoyed the videos of Platonic solids with inner mirrors\n//  I made some previous attempts but thought I make another attempt it\n\n// Reducing the alias effects on the inner reflections turned out to be a bit tricky. \n//  Simplest solution is just to run run fullscreen on a 4K screen ;)\n\n// Function to generate the solid found here: https://www.shadertoy.com/view/MsKGzw\n\n// Tinker with these parameters to create different solids\n// -------------------------------------------------------\nconst float rotation_speed= 0.25;\n\nconst float poly_U        = 1.;   // [0, inf]\nconst float poly_V        = 0.5;  // [0, inf]\nconst float poly_W        = 1.0;  // [0, inf]\nconst int   poly_type     = 3;    // [2, 5]\nconst float poly_zoom     = 2.0;\n\nconst float inner_sphere  = 1.;\n\nconst float refr_index    = 0.9;\n\n#define MAX_BOUNCES2        6\n// -------------------------------------------------------\n\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define TOLERANCE2          0.0005\n//#define MAX_RAY_LENGTH2   10.0\n#define MAX_RAY_MARCHES2    50\n#define NORM_OFF2           0.005\n#define BACKSTEP2\n\n#define TOLERANCE3          0.0005\n#define MAX_RAY_LENGTH3     10.0\n#define MAX_RAY_MARCHES3    90\n#define NORM_OFF3           0.005\n\nconst vec3 rayOrigin    = vec3(0.0, 1., -5.);\nconst vec3 sunDir       = normalize(-rayOrigin);\n\n\nconst vec3 sunCol       = HSV2RGB(vec3(0.06 , 0.90, 1E-2))*1.;\nconst vec3 bottomBoxCol = HSV2RGB(vec3(0.66, 0.80, 0.5))*1.;\nconst vec3 topBoxCol    = HSV2RGB(vec3(0.60, 0.90, 1.))*1.;\nconst vec3 glowCol0     = HSV2RGB(vec3(0.05 , 0.7, 1E-3))*1.;\nconst vec3 glowCol1     = HSV2RGB(vec3(0.95, 0.7, 1E-3))*1.;\nconst vec3 beerCol      = -HSV2RGB(vec3(0.15+0.5, 0.7, 2.)); \nconst float rrefr_index = 1./refr_index;\n\n\n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nconst float poly_cospin   = cos(PI/float(poly_type));\nconst float poly_scospin  = sqrt(0.75-poly_cospin*poly_cospin);\nconst vec3  poly_nc       = vec3(-0.5, -poly_cospin, poly_scospin);\nconst vec3  poly_pab      = vec3(0., 0., 1.);\nconst vec3  poly_pbc_     = vec3(poly_scospin, 0., 0.5);\nconst vec3  poly_pca_     = vec3(0., poly_scospin, poly_cospin);\nconst vec3  poly_p        = normalize((poly_U*poly_pab+poly_V*poly_pbc_+poly_W*poly_pca_));\nconst vec3  poly_pbc      = normalize(poly_pbc_);\nconst vec3  poly_pca      = normalize(poly_pca_);\n\nmat3 g_rot;\nvec2 g_gd;\n  \n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/noacos/\nmat3 rot(vec3 d, vec3 z) {\n  vec3  v = cross( z, d );\n  float c = dot( z, d );\n  float k = 1.0/(1.0+c);\n\n  return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n               v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n               v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n  \n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nvoid poly_fold(inout vec3 pos) {\n  vec3 p = pos;\n\n  for(int i = 0; i < poly_type; ++i){\n    p.xy  = abs(p.xy);\n    p    -= 2.*min(0., dot(p,poly_nc)) * poly_nc;\n  }\n  \n  pos = p;\n}\n\nfloat poly_plane(vec3 pos) {\n  float d0 = dot(pos, poly_pab);\n  float d1 = dot(pos, poly_pbc);\n  float d2 = dot(pos, poly_pca);\n  float d = d0;\n  d = max(d, d1);\n  d = max(d, d2);\n  return d;\n}\n\nfloat poly_corner(vec3 pos) {\n  float d = length(pos) - .0125;\n  return d;\n}\n\nfloat dot2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat poly_edge(vec3 pos) {\n  float dla = dot2(pos-min(0., pos.x)*vec3(1., 0., 0.));\n  float dlb = dot2(pos-min(0., pos.y)*vec3(0., 1., 0.));\n  float dlc = dot2(pos-min(0., dot(pos, poly_nc))*poly_nc);\n  return sqrt(min(min(dla, dlb), dlc))-2E-3;\n}\n\nvec3 shape(vec3 pos) {\n  pos *= g_rot;\n  pos /= poly_zoom;\n  poly_fold(pos);\n  pos -= poly_p;\n\n  return vec3(poly_plane(pos), poly_edge(pos), poly_corner(pos))*poly_zoom;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  \n  float srd  = sign(rd.y);\n  float tp   = -(ro.y-6.)/abs(rd.y);\n\n  if (srd < 0.) {\n    col += bottomBoxCol*exp(-0.5*(length((ro + tp*rd).xz)));\n  }\n\n  if (srd > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += topBoxCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += 0.2*topBoxCol*exp(-0.5*max(db, 0.0));\n    col += 0.05*sqrt(topBoxCol)*max(-db, 0.0);\n  }\n\n\n  col += sunCol/(1.001-dot(sunDir, rd));\n  return col; \n}\n\nfloat df2(vec3 p) {\n  vec3 ds = shape(p);\n  float d2 = ds.y-5E-3;\n  float d0 = min(-ds.x, d2);\n  float d1 = sphere(p, inner_sphere);\n  g_gd = min(g_gd, vec2(d2, d1));\n  float d = (min(d0, d1));\n  return d;\n}\n\nfloat rayMarch2(vec3 ro, vec3 rd, float tinit) {\n  float t = tinit;\n#if defined(BACKSTEP2)\n  vec2 dti = vec2(1e10,0.0);\n#endif\n  int i;\n  for (i = 0; i < MAX_RAY_MARCHES2; ++i) {\n    float d = df2(ro + rd*t);\n#if defined(BACKSTEP2)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    // Bouncing in a closed shell, will never miss\n    if (d < TOLERANCE2/* || t > MAX_RAY_LENGTH3 */) {\n      break;\n    }\n    t += d;\n  }\n#if defined(BACKSTEP2)\n  if(i==MAX_RAY_MARCHES2) { t=dti.y; };\n#endif  \n  return t;\n}\n\nvec3 normal2(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF2,0.0);\n  vec3 nor;\n  nor.x = df2(pos+eps.xyy) - df2(pos-eps.xyy);\n  nor.y = df2(pos+eps.yxy) - df2(pos-eps.yxy);\n  nor.z = df2(pos+eps.yyx) - df2(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render2(vec3 ro, vec3 rd, float db) {\n  vec3 agg = vec3(0.0);\n  float ragg = 1.;\n  float tagg = 0.;\n  \n  for (int bounce = 0; bounce < MAX_BOUNCES2; ++bounce) {\n    if (ragg < 0.1) break;\n    g_gd      = vec2(1E3);\n    float t2  = rayMarch2(ro, rd, min(db+0.05, 0.3));\n    vec2 gd2  = g_gd;\n    tagg      += t2;\n    \n    vec3 p2   = ro+rd*t2;\n    vec3 n2   = normal2(p2);\n    vec3 r2   = reflect(rd, n2);\n    vec3 rr2  = refract(rd, n2, rrefr_index);\n    float fre2= 1.+dot(n2,rd);\n    \n    vec3 beer = ragg*exp(0.2*beerCol*tagg);\n    agg += glowCol1*beer*((1.+tagg*tagg*4E-2)*6./max(gd2.x, 5E-4+tagg*tagg*2E-4/ragg));\n    vec3 ocol = 0.2*beer*render0(p2, rr2);\n    if (gd2.y <= TOLERANCE2) {\n      ragg *= 1.-0.9*fre2;\n    } else {\n      agg     += ocol;\n      ragg    *= 0.8;\n    }\n    \n    ro        = p2;\n    rd        = r2;\n    db        = gd2.x; \n  }\n\n\n  return agg;\n}\n\nfloat df3(vec3 p) {\n  vec3 ds = shape(p);\n  g_gd = min(g_gd, ds.yz);\n  const float sw = 0.02;\n  float d1 = min(ds.y, ds.z)-sw;\n  float d0 = ds.x;\n  d0 = min(d0, ds.y);\n  d0 = min(d0, ds.z);\n  return d0;\n}\n\nfloat rayMarch3(vec3 ro, vec3 rd, float tinit, out int iter) {\n  float t = tinit;\n  int i;\n  for (i = 0; i < MAX_RAY_MARCHES3; ++i) {\n    float d = df3(ro + rd*t);\n    if (d < TOLERANCE3 || t > MAX_RAY_LENGTH3) {\n      break;\n    }\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal3(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF3,0.0);\n  vec3 nor;\n  nor.x = df3(pos+eps.xyy) - df3(pos-eps.xyy);\n  nor.y = df3(pos+eps.yxy) - df3(pos-eps.yxy);\n  nor.z = df3(pos+eps.yyx) - df3(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render3(vec3 ro, vec3 rd) {\n  int iter;\n\n  vec3 skyCol = render0(ro, rd);\n  vec3 col  = skyCol;\n\n  g_gd      = vec2(1E3);\n  float t1  = rayMarch3(ro, rd, 0.1, iter);\n  vec2 gd1  = g_gd;\n  vec3 p1   = ro+t1*rd;\n  vec3 n1   = normal3(p1);\n  vec3 r1   = reflect(rd, n1);\n  vec3 rr1  = refract(rd, n1, refr_index);\n  float fre1= 1.+dot(rd, n1);\n  fre1 *= fre1;\n\n  float ifo = mix(0.5, 1., smoothstep(1.0, 0.9, float(iter)/float(MAX_RAY_MARCHES3)));\n\n  if (t1 < MAX_RAY_LENGTH3) {\n    col = render0(p1, r1)*(0.5+0.5*fre1)*ifo;\n    vec3 icol = render2(p1, rr1, gd1.x); \n    if (gd1.x > TOLERANCE3 && gd1.y > TOLERANCE3 && rr1 != vec3(0.)) {\n      col += icol*(1.-0.75*fre1)*ifo;\n    }\n  }\n\n  col += (glowCol0+1.*fre1*(glowCol0))/max(gd1.x, 3E-4);\n  return col;\n\n}\n\n  \nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = 2.0;\n  \n  const vec3 up = vec3(0., 1., 0.);\n  const vec3 la   = vec3(0.0);\n\n  const vec3 ww = normalize(normalize(la-rayOrigin));\n  const vec3 uu = normalize(cross(up, ww));\n  const vec3 vv = cross(ww, uu);\n  \n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = vec3(0.0);\n  col = render3(rayOrigin, rd);\n  \n  col -= 2E-2*vec3(2.,3.,1.)*(length(p)+0.25);\n  col = aces_approx(col);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float a = TIME*rotation_speed;\n  vec3 r0 = vec3(1.0, sin(vec2(sqrt(0.5), 1.0)*a));\n  vec3 r1 = vec3(cos(vec2(sqrt(0.5), 1.0)*0.913*a), 1.0);\n  mat3 rot = rot(normalize(r0), normalize(r1));\n  g_rot = rot;\n\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}