{
    "Shader": {
        "info": {
            "date": "1606077153",
            "description": "A quick demo for the \"biplanar\" texture mapping technique I developed recently (see here: [url]https://www.shadertoy.com/view/ws3Bzf[/url]), comparing it to triplanar.",
            "flags": 0,
            "hasliked": 0,
            "id": "3ddfDj",
            "likes": 53,
            "name": "Biplanar mapping - demo",
            "published": 3,
            "tags": [
                "3d",
                "triplanar",
                "texturing",
                "texturemapping",
                "biplanar"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 2450
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// A quick demo for the \"biplanar\" texture mapping \n// technique I developed to compare biplanar to triplanar\n// texture mapping (https://www.shadertoy.com/view/ws3Bzf):\n//\n// Video: https://www.youtube.com/watch?v=9SMtSrV3Dac\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n//----------------\n\nfloat gShowWeights;\nfloat hShowTriplanar;\n\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\n    vec3 cma = vec3(0,0,0); cma[ma.x] = 1.0; \n    vec3 cme = vec3(0,0,0); cme[me.x] = 1.0;\n    x.xyz = mix( x.xyz, cma, gShowWeights );\n    y.xyz = mix( y.xyz, cme, gShowWeights );\n\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    \n    x.xyz = mix( x.xyz, vec3(1,0,0), gShowWeights );\n    y.xyz = mix( y.xyz, vec3(0,1,0), gShowWeights );\n    z.xyz = mix( z.xyz, vec3(0,0,1), gShowWeights );\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    vec3 col = vec3(0.0);\n    vec2 tm = castRay( ro, rd );\n    if( tm.y>-0.5  )\n    {\n        const float eps = 0.001;\n\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal( pos, eps*tm.x );\n        vec3 dposdx, dposdy;\n        calcDpDxy( ro, rd, rdx, rdy, tm.x, nor, dposdx, dposdy );\n        //dposdx = dFdx(pos);\n        //dposdy = dFdy(pos);\n\n        vec3 mateD = vec3(0.0);\n\n        if( tm.y<1.5 ) // body\n        {\n            vec3 te1 =     biplanar(  iChannel0, 0.15*pos, nor, 0.15*dposdx, 0.15*dposdy ).xyz;\n            te1 *= 0.2+0.8*biplanar(  iChannel1,      pos, nor,      dposdx,      dposdy ).xyz;\n            vec3 te2 =     triplanar( iChannel0, 0.15*pos, nor, 0.15*dposdx, 0.15*dposdy ).xyz;\n            te2 *= 0.2+0.8*triplanar( iChannel1,      pos, nor,      dposdx,      dposdy ).xyz;\n            \n            vec3 te = mix( te1, te2, hShowTriplanar*smoothstep(-0.2,0.2,sin(0.5*6.283185*iTime)) );\n            te = 1.25*(sqrt(te)-0.5)+0.5;\n            te = pow(max(te,0.0),vec3(1.8));\n            mateD = 0.16*te;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        occ *= clamp(0.5+0.5*nor.y,0.0,1.0);\n        occ *= 0.5+0.5*smoothstep(0.0,2.0,pos.y);\n\n        col = vec3(20.0*mateD*occ*exp2(-0.05*tm.x*tm.x));\n    }\n\treturn col;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 tot = vec3(0.0);\n\n    float time = iTime;\n\n    // animation\n    gShowWeights = smoothstep( 2.0*kTau+0.0, 2.0*kTau+1.0, time )-\n                   smoothstep( 4.0*kTau-1.0, 4.0*kTau+0.0, time ) +\n                   smoothstep( 6.0*kTau+0.0, 6.0*kTau+1.0, time ) -\n                   smoothstep( 8.0*kTau-1.0, 8.0*kTau+0.0, time );\n        \n    // camera 1\n    float ss = -cos(time*0.5);\n    float an = -1.0 + 0.5*ss;\n    vec3 ro = vec3(5.8*sin(an),1.65,5.8*cos(an));\n    ro.y = 2.5-0.9*cos(time);\n    ro = 5.8*normalize(ro);\n    vec3 ta = vec3(0.0,1.65,0.0);\n    ro.x += 0.4*smoothstep(-1.0,1.0,ss);\n    ta.x += 0.4*smoothstep(-1.0,1.0,ss);\n\n\t// camera 2\n    float zoom = smoothstep( 4.0*kTau-2.0,4.0*kTau,time) -\n                 smoothstep( 8.0*kTau-2.0,8.0*kTau,time );\n    hShowTriplanar = zoom;\n    ro = mix( ro, vec3(-2.5,3.0,0.3+0.1*sin(0.5*time)), zoom );\n    ta = mix( ta, vec3(-1.0,2.6,0.1), zoom );\n\n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o  = vec2(m,n)/float(AA) - 0.5;\n        vec2 p  = (2.0*(fragCoord+o              )-iResolution.xy)/iResolution.y;\n        vec2 px = (2.0*(fragCoord+o+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+o+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p  = (2.0*(fragCoord              )-iResolution.xy)/iResolution.y;\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray\n        vec3 rd  = normalize( ca * vec3(p ,-3.5) );\n        vec3 rdx = normalize( ca * vec3(px,-3.5) );\n        vec3 rdy = normalize( ca * vec3(py,-3.5) );\n\n        // render\n        vec3 col = render( ro, rd, rdx, rdy);\n\n        // gain\n        col = col*4.5/(4.0+col);\n        // gamma\n        col = pow( col, vec3(0.4545) );\n \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// --- helper functions ----------------------\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv = vec3(0.0,0.0,1.0);\n    vec3  uu = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n#define ZERO (min(iFrame,0))\n\nconst float kTau = 6.283185;\n\n// --- sdf stuff -------------------------------\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    p -= c;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p, out vec2 pos )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n    pos = cp.xy;\n    \n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n\n//--- elephant ---------------------------------------------------------\n//\n// from https://www.shadertoy.com/view/4dKGWm\n//\n\nfloat leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float d3 = b.x - 0.35 + 0.16*smoothstep(0.0,1.0,b.y);\n\n    b = sdSegment( p, pb, pc );\n    d3 = smin( d3, b.x - 0.18, 0.1 );\n\n    // paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    // nails\n    float d6 = sdEllipsoid( fc, vec3(0.14,-0.06,0.0)*(-1.0+2.0*h), vec3(0.1,0.16,0.1));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.13*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.13), vec3(0.09,0.14,0.1)) );\n    d3 = smin( d3, d6, 0.001 );\n\treturn d3;\n}\n\nvec2 map( vec3 p )\n{\n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    vec2 res = vec2( 2.15+p.y, 0.0 );\n    \n    // elephant bounding volume\n    //float bb = length(p-vec3(1.0,-0.75,0))-2.0;\n    //if( bb>res.x )  return res;\n\n    \n    vec3 ph = p;\n    const float cc = 0.995;\n    const float ss = 0.0998745;\n    ph.yz = mat2(cc,-ss,ss,cc)*ph.yz;\n    ph.xy = mat2(cc,-ss,ss,cc)*ph.xy;\n    \n    // head\n    float d1 = sdEllipsoid( ph, vec3(0.0,0.05,0.0), vec3(0.45,0.5,0.3) );\n    d1 = smin( d1, sdEllipsoid( ph, vec3(-0.3,0.15,0.0), vec3(0.2,0.2,0.2) ), 0.1 );\n\n    // nose\n    vec2  kk;\n    vec2  b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,0.0,0.0), vec3(-0.7,-0.8,0.0), ph, kk );\n    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);\n    vec2  b2 = sdBezier( vec3(-0.7,-0.8,0.0), vec3(-0.7,-1.5,0.0), vec3(-0.4,-1.6,0.2), ph, kk );\n    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);\n    float bd1 = b1.x-tr1;\n    float bd2 = b2.x-tr2;\n    float nl = b1.y*0.5;\n    float bd = bd1;\n    if( bd2<bd1 )\n    {\n        nl = 0.5 + 0.5*b2.y;\n        bd = bd2;\n    }\n    float d2 = bd;\n    float xx = nl*120.0;\n    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));\n    d2 += 0.003*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);\n\n    d2 -= 0.005;\n    \n    float d = smin(d1,d2,0.2);\n\n    // teeth\n    vec3 q = vec3( p.xy, abs(p.z) );\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.4,-0.1,0.1), vec3(-0.5,-0.4,0.28) );\n    float d3 = s1.x - 0.18*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.1 );\n    }\n    \n    // eyes\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.26) );\n    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.03 );\n\n    float st = length(qh.xy-vec2(-0.31,-0.02));\n    d += 0.0015*sin(250.0*st)*(1.0-smoothstep(0.0,0.2,st));\n        \n    const mat3 rot = mat3(0.8,-0.6,0.0,\n                          0.6, 0.8,0.0,\n                          0.0, 0.0,1.0 );\n    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n\td = smax(d, -d4, 0.02 );\n    }\n   \n\n    // body\n    {\n    const float co = 0.92106099;\n    const float si = 0.38941834;\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n\n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(2.0,0.6,0.0), vec3(0.9,0.7,0.8) );\n\td = smin(d, d4, 0.1 );\n    }\n\n    // back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.5,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0 );\n    d = smin(d,d3,0.1);\n    }\n    \n    // front-left leg\n    {\n    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    }\n    \n    // ear\n    const float co = 0.8775825619;\n    const float si = 0.4794255386;\n    vec3 w = qh;\n    w.xz = mat2(co,si,-si,co)*w.xz;\n    \n    vec2 ep = w.zy - vec2(0.5,0.4);\n    float aa = atan(ep.x,ep.y);\n    float al = length(ep);\n    w.x += 0.003*sin(24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));\n                      \n    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);\n    r += 0.01*sin(15.0*w.z);\n    // section        \n    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    \n    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    \n    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    \n    d4 = smax( d4, d5, 0.1 );\n    d4 = smax( d4, d6, 0.1 );\n\n    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);\n    w.x += 0.05*cos(6.0*w.y);\n    \n    // cut it!\n    d4 = smax( d4, -w.x, 0.03 ); \n    d4 = smax( d4, w.x-wi, 0.03 );     \n    \n    d = smin( d, d4, 0.3*max(qh.y,0.0) ); // trick -> positional smooth\n    \n    // conection hear/head\n    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );\n    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);\n    d = smin( d, d3, 0.05 );    \n    \n    res.x = min( res.x, d );\n    \n\t//------------------\n    // teeth\n    vec2 b = sdBezier( vec3(-0.5,-0.4,0.28), vec3(-0.5,-0.7,0.32), vec3(-1.0,-0.8,0.45), qh, kk );\n    d2 = b.x - 0.10 + 0.08*b.y;\n    if( d2<res.x ) \n    {\n        res = vec2( d2, 1.0 );\n    }\n    \n\t//------------------\n    //eyeball\n    const mat3 rot = mat3(0.8,-0.6,0.0,\n                          0.6, 0.8,0.0,\n                          0.0, 0.0,1.0 );\n    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n    if( d4<res.x ) res = vec2( d4, 2.0 );\n\n    // floor plane\n    res.x = smax( res.x, -2.2-p.y, 0.1 );\n          \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*eps).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        ap *= sign( dot(ap,nor) );\n        float h = hash1(float(i));\n\t\tap *= h*0.3;\n        ao += clamp( map( pos + nor*0.01 + ap ).x*1.0/h, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*(4.0+nor.y), 0.0, 1.0 );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0);\n\n    const float tmax = 10.0;\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p );\n        res = vec2(t,h.y);\n        if( abs(h.x)<0.0001 || t>tmax ) break;\n        t += h.x*0.8;\n    }\n\n    if( t>tmax ) res = vec2(-1.0);\n\n    return res;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}