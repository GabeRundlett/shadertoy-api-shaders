{
    "Shader": {
        "info": {
            "date": "1494376981",
            "description": "SPREAD is a bias to make the light extend farther across the surface\nORBIT is the radius of the orbit\nSCALE is the scale of the planet\nCOLOR is the color of the planet\nBG is the color of the background",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjyWd",
            "likes": 1,
            "name": "Fake sphere planet lighting",
            "published": 3,
            "tags": [
                "2d",
                "lighting",
                "sphere",
                "planet",
                "fragment"
            ],
            "usePreview": 0,
            "username": "thecodewarrior",
            "viewed": 598
        },
        "renderpass": [
            {
                "code": "#define SPREAD 0.2\n#define ORBIT 0.5\n#define PLANET_SIZE 0.1\n#define RING_BEGIN 0.025\n#define RING_THICKNESS 0.1\n#define SUN_INTENSITY 1.0\n#define MOUSE_INTENSITY 1.0/toMouseDist\n\n#define PLANET_COLOR vec4(0, 1, 0, 1)\n#define RING_COLOR vec4(0, 0, 1, 1)\n#define BACKGROUND_COLOR vec4(1, 0, 0, 1)\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat length2(vec2 v) {\n    return dot(v, v);\n}\n\nfloat length2(vec3 v) {\n    return dot(v, v);\n}\n\n// lighting calculation. +SPREAD biases it so the light will fade out farther from\n// the centerline.\nfloat lightSphere(float existing, vec3 surfaceNormal, vec3 lightNormal, float intensity) {\n    float b = dot( surfaceNormal, -lightNormal )+SPREAD;\n    b *= intensity;\n    return clamp( max(existing, b + existing/2.0), 0.0, 1.0);\n}\n\nfloat lightRings(float existing, vec2 ringPos, vec2 lightNormal, float intensity) {\n    float d = distanceToSegment(vec2(0, 0), lightNormal*10.0, ringPos) / PLANET_SIZE;\n    float b = smoothstep(.8,1.0, d)*0.8*intensity;\n    return clamp( max(existing, b + existing/2.0), 0.0, 1.0);\n}\n\n// make screen coordinates reasonable\nvec2 normalizeScreenCoords(vec2 screenCoords) {\n    vec2 coords = (2.0*(screenCoords / iResolution.xy)) - 1.0;\n    coords.x = coords.x * (iResolution.x / iResolution.y);\n\treturn coords;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = vec3(sin(iTime), cos(iTime), 0); // light direction\n    \n    // normalise coordinates\n    vec2 fragUV = normalizeScreenCoords(fragCoord.xy);\n    \n    // center of circle\n    vec2 center = light.xy * ORBIT;\n    \n    vec2 posRelCircle = fragUV - center;\n    \n    float d2 = dot(posRelCircle, posRelCircle); // distance from center squared\n    \n    if(d2 <= PLANET_SIZE*PLANET_SIZE) {\n        posRelCircle = posRelCircle / PLANET_SIZE;\n        float len = length(posRelCircle); // distance from center\n    \n    \tvec3 normal = normalize(vec3(posRelCircle, cos(len))); // horizontal components + vertical component\n    \n        float lightMultiplier = 0.0;\n        \n        lightMultiplier = lightSphere(lightMultiplier, normal, light, SUN_INTENSITY);\n        \n        if(iMouse.z > 0.0) {\n            vec2 toMouseVec = normalizeScreenCoords(iMouse.xy)-center;\n            float toMouseDist = length(toMouseVec);\n            vec2 mouseNormal = -normalize(toMouseVec);\n            \n            float intensity = MOUSE_INTENSITY;\n            \n        \tlightMultiplier = lightSphere(lightMultiplier, normal, vec3(mouseNormal, 0), intensity);\n        }\n        \n        lightMultiplier = clamp(lightMultiplier, 0.0, 1.0);\n\t\tfragColor = PLANET_COLOR * lightMultiplier;\n    } else if(d2 > (PLANET_SIZE+RING_BEGIN)*(PLANET_SIZE+RING_BEGIN) &&\n         d2 < (PLANET_SIZE+RING_BEGIN+RING_THICKNESS)*(PLANET_SIZE+RING_BEGIN+RING_THICKNESS)) {\n        float lightMultiplier = 0.0;\n        \n        lightMultiplier = lightRings(lightMultiplier, posRelCircle, light.xy, SUN_INTENSITY);\n        \n        if(iMouse.z > 0.0) {\n            vec2 toMouseVec = normalizeScreenCoords(iMouse.xy)-center;\n            float toMouseDist = length(toMouseVec);\n            vec2 mouseNormal = -normalize(toMouseVec);\n            \n            float intensity = MOUSE_INTENSITY;\n            \n        \tlightMultiplier = lightRings(lightMultiplier, posRelCircle, mouseNormal, intensity);\n        }\n        \n        lightMultiplier = clamp(lightMultiplier, 0.0, 1.0);\n        \n        fragColor = RING_COLOR * lightMultiplier;\n    } else {\n        fragColor = BACKGROUND_COLOR;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}