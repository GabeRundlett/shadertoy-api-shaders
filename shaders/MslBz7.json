{
    "Shader": {
        "info": {
            "date": "1495515634",
            "description": "Repeated rounded cubes with moving lines and a background grid",
            "flags": 0,
            "hasliked": 0,
            "id": "MslBz7",
            "likes": 9,
            "name": "lines & cubes",
            "published": 3,
            "tags": [
                "grid",
                "line",
                "proceduralfiltering"
            ],
            "usePreview": 0,
            "username": "fernandomv3",
            "viewed": 718
        },
        "renderpass": [
            {
                "code": "float udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nvec2 map(vec3 p){\n  vec3 c = vec3(9.0,9.0,9.0);\n  vec3 q = mod(p,c) - 0.5*c;\n  float d = udRoundBox(q ,vec3(1.2,0.5,0.7),1.0);\n  float limit = -sdBox(p,vec3(32.0));\n  d = min(d,limit);\n  return vec2(d,limit > d ? 0.0 : 2.0);\n}\n\nvec2 trace(in vec3 camPos, in vec3 rayDir){\n  float s = 0.0;\n  float e = 0.0001;\n  float rMax = 128.0;\n  float m = 1.0;\n  for(int i = 0; i < 64; i++){\n    vec3 pos = camPos + s*rayDir;\n    vec2 d = map(camPos + s*rayDir);\n    if(d.x < e || d.x > rMax) break;\n    s += d.x;\n    m = d.y;\n  }\n  if(s > rMax) m = -1.0;\n  return vec2(s,m);\n}\n\nvec3 gridTexture(vec3 uvw){\n  vec3 res = vec3(0.0);\n  uvw = sin(uvw *0.5);\n  res += 0.2*exp(-16.0*abs(uvw));\n  res += 0.1*exp( -4.0*abs(uvw));\n  return vec3(length(res));\n}\n\nvec3 sampleTexture(vec3 uvw){\n  float dir = uvw.z;\n  dir = sin((-dir*6.0)+iTime*1.5);\n  float d = 1.0*exp(-16.0*abs(dir));\n  d += 0.5*exp(-4.0*abs(dir));\n  return vec3(0.0,d,d) + (1.0 - d)*vec3(0.05);  \n}\n\n//filtering based on https://www.shadertoy.com/view/MdjGR1\nconst int MaxSamples = 10;\nconst float detail = 4.0;\nvec3 sampleTextureWithFilter(vec3 uvw, vec3 dx, vec3 dy){\n  int sx = 1 + int(clamp(detail * length(dx-uvw),0.0,float(MaxSamples-1)));\n  int sy = 1 + int(clamp(detail * length(dy-uvw),0.0,float(MaxSamples-1)));\n  vec3 color = vec3(0.0);\n  for(int i=0;i<MaxSamples;i++){\n    for(int j=0;j<MaxSamples;j++){\n      if(i<sx && j<sy){\n        vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n        color += sampleTexture(uvw + st.x*(dx-uvw) + st.y*(dy-uvw));  \n      }\n    }  \n  }    \n  return color / float(sx*sy);\n}\n\nvec4 render(in vec3 camPos, in vec3 rayDir){\n  vec2 res = trace(camPos,rayDir);\n  if(res.y > -1.0){\n    vec3 pos = camPos + rayDir*res.x;\n    vec3 ddx_uvw = pos + dFdx( pos ); \n    vec3 ddy_uvw = pos + dFdy( pos );\n    //return vec4(sampleTexture(pos),1.0);\n    if (res.y < 1.0) return vec4(sampleTextureWithFilter(pos,ddx_uvw,ddy_uvw),1.0);\n\treturn vec4(gridTexture(pos),1.0);\n  }\n}\n\nmat3 camera(in vec3 position, in vec3 target){\n  vec3 w = normalize(target - position);\n  vec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n  vec3 v = cross(u,w);\n  return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = uv * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n    \n  vec3 camPos =vec3(8.0) + vec3(4.0*cos(iTime*0.1),0.0,4.0*sin(iTime*0.1));\n  vec3 camTarget = vec3(0.0,0.0,0.0);\n  mat3 cam = camera(camPos,camTarget);\n  vec3 rayDir = cam * normalize(vec3(uv,1.0));\n  fragColor = render(camPos,rayDir);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}