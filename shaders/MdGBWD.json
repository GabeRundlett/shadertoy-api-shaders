{
    "Shader": {
        "info": {
            "date": "1528838542",
            "description": "USE MOUSE TO LOOK AROUND.\n\n3D version of  https://www.shadertoy.com/view/4sVcz3\nwith a mix of: https://www.shadertoy.com/view/MllfDX   for variable size voxels.\n\nAnti-aliased due to high contrast. Can be remove in the code line 15 to see the difference.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MdGBWD",
            "likes": 37,
            "name": "Boxlight 3D",
            "published": 3,
            "tags": [
                "grid",
                "light",
                "voxel",
                "antialiasing",
                "fakevolumetric"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 1643
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Boxlight 3D\n\n// Mixing \"Phot'on stage\" (https://www.shadertoy.com/view/4sVcz3)\n// with \"HOPE\" (https://www.shadertoy.com/view/MllfDX)\n// for a 3D version of \"Phot'on stage\".\n//\n// This shader need to be anti-aliased, using the same process as in\n// https://www.shadertoy.com/view/ldyyDh (one ray AA)\n//\n// MOUSE ENABLE\n//\n\n// comment this line to avoid anti-aliasing process\n#define AA\n\n// Increase this if perfos permit (max voxel distance)\n#define MAXSTEP 60\n\n#define PI 3.141592653589793\n#define INFINI 1000000.\n\n\nfloat H(in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\n\n\nfloat H2(in vec2 st) { \t\t\t\t\t\t\n    return fract(sin(dot(st,vec2(12.9898,8.233))) * 43758.5453123);\n}\n\n\nvec4 getNextPlan(in vec2 xz, in vec2 v){\n    vec2 s = sign(v);\n    vec2 d = step(0.,s);\n\tvec2 dtp = (d-fract(xz*.13))/.13/v;\n    vec2 dtq = (d-fract((xz-.7)*.17))/.17/v;\n    vec2 dtr = (d-fract((xz-.3)*.33))/.33/v;\n\n    vec2 dmin = min(min(dtp,dtq),dtr);\n    float tmin = min(dmin.x, dmin.y);\n    \n    s *= -step(dmin,vec2(tmin));\n    \n    return vec4(s.x,0.,s.y,tmin);\n}\n\n\nvec3 grid(in vec2 xz, in float t)\n{\n    t *= .01;\n    vec2 p = floor(xz*.13)/.13+t;\n    vec2 q = floor((xz-.7)*.17)/.17+.7*t;\n    vec2 r = floor((xz-.3)*.33)/.33+1.3*t;\n    \n    vec3 tex =  .8*texture(iChannel0,p).rgb \n    \t\t  + .6*texture(iChannel0,q).rgb\n    \t\t  + .4*texture(iChannel0,r).rgb;\n    \n    tex *= smoothstep(0.,1.8,tex.r);\n    return tex;\n    \n}\n\nfloat map(in vec3 tex){ return 6.*tex.r*tex.r; }\n\nfloat Mmap(in vec3 tex) {return 3.*(tex.r*tex.r\t\t// Music map\n    \t\t\t\t\t\t\t  *(texelFetch(iChannel1,ivec2(1,0),0).x\n                                  + texelFetch(iChannel1,ivec2(400,0),0).x))\n    \t\t\t\t\t;}\n\nvec3 setCol(in vec3 tex, in vec2 xz)\t// box color\n{\n    vec2 bp = \n        \t smoothstep(vec2(.4),vec2(.5),abs(fract(xz*.13)-.5))\n    \t\t+ smoothstep(vec2(.4),vec2(.5),abs(fract((xz-.7)*.17)-.5))\n    \t\t+ smoothstep(vec2(.4),vec2(.5),abs(fract((xz-.3)*.33)-.5));\n            \n    vec3 color = tex.rgb*tex.rgb;//*texture(iChannel0,xz*.0025).rgb;\n    color *= .3*(bp.x+bp.y)+.3;\n    color = clamp(color,0.,1.);\n\n    return color;\n}\n\nvec3 setRayCol(in vec3 tex, in vec2 xz)\t// light ray color\n{\n    vec2 bp = 3.-smoothstep(vec2(.0),vec2(.5),abs(fract(xz*.13)-.5))\n    \t\t- smoothstep(vec2(.0),vec2(.5),abs(fract((xz-.7)*.17)-.5))\n    \t\t- smoothstep(vec2(.0),vec2(.5),abs(fract((xz-.3)*.33)-.5));\n            \n    vec3 color = tex.rgb*tex.rgb;//*texture(iChannel0,xz*.005).rgb;\n    color *= (bp.x+bp.y);\n\n    return color;\n}\n\n\nvec4 trace(in vec3 pos, in vec3 ray, inout vec3 litflux, inout vec3 tex, inout float dAA)\n{\n    float dh = 0.;\n    float t = 0.;\n    \n    dAA = 1.;\t\t\t\t// distance to the border of the voxel\n    \t\t\t\t\t\t// use for AA as transparency factor\n    \n    vec4 wall = vec4(0.);\t// wall.xyz is the normal of the wall. wall.w is the t parameter.\n    \t\t\t\t\t\t// wall is the border of the next voxel\n    \n    for(int i = 0;i<MAXSTEP;i++){\t// entering the voxel run\n        \n        vec3 p = pos+t*ray;\n        \n        tex = grid(p.xz,iTime);\t\t// get texture at current time.\n        float dh = p.y - Mmap(tex);\t// height of the box depend on the red channel of the texture\n        \n        if( abs(dh)<.25){\t\t\t// if a box is hit\n            \n\t\t\t#ifdef AA\n            // finding the closest box border (left/right and up/down) for AA\n            dAA = min( getNextPlan(p.xz,ray.xz).w, (.5-2.*abs(dh))+abs(sign(dh)-sign(ray.y)));\n            #endif\n            \n            return vec4(wall.xyz,t);\t// you are between top and bottom of a box?\n        \t\t\t\t\t\t\t\t// so you hit the previous wall\n        }\n        \n        wall = getNextPlan(p.xz,ray.xz);\t\t// find the next wall\n        \n        float dhdt = map(grid(p.xz,iTime-.02*p.y+.5+.05*H2(floor(p.xz*20.))));\n        \t\t\t\t// height of the box back in time depending on p.y\n        \t\t\t\t// to generate the vertical light flux going up with time\n        \t\t\t\t// + H2() to create a kind of vertical dithering\n        \n        litflux += .1*wall.w*wall.w\t\t\t\t\t// to round corner of light flux\n            \t\t*setRayCol(tex,p.xz)\n            \t\t*smoothstep(6.,20.,dhdt)\t\t// intensity depend on box height reached\n            \t\t*min(1.,30./t)*step(0.,dh);\t\t// cutoff with distance and below the box\n\n        float th = -(dh-sign(dh)*.25)/(ray.y+sign(ray.y)*.0001);\t// find the box floor/ceiling\n        th += step(th,0.)*INFINI;\t// eliminate neg value\n        \n        if(th<wall.w){ // if first hit = floor/ceilling of box\n\t\t\t#ifdef AA\n            // distance to the border of the top/bottom surface used for AA\n            dAA = (wall.w-th)*(.8*abs(ray.y)+.2);\n\t\t\t#endif\n            return vec4(0.,-sign(ray.y),0.,t+th);\n        }\n        \n        t+= wall.w+.0001;\t\t\t// update global t and do again\n    }\n    \n    return vec4(0.,0.,0.,INFINI);\n}\n\n\nvec3 getCamPos(in vec3 camTarget){\n\n    float   rau = 50.,\n            alpha = 1.,\n            theta = .2;\n            \n    if(iMouse.z != 0.){\n            rau = 50.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = iMouse.y/iResolution.y*PI+(PI/2.0001);\t\n    }\n    \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = .5;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = ( fragCoord.xy - .5*iResolution.xy ) / iResolution.y;\n    float ti = iTime*.1;\n    \n    // camera def\n    vec3 camTarget = vec3(-50.*sin(2.*ti),25.*iMouse.y/iResolution.y,-30.*cos(3.*ti));    \n    vec3 pos = getCamPos(camTarget);\n    pos.y = max(pos.y,Mmap(grid(pos.xz,iTime))+1.); // anti-collision\n    \n    vec3 ray = getRay(st, pos,camTarget);\n    \t\n    float t = 0.;\n    vec3 norm = vec3(0.);\n    vec3 color = vec3(0.);\n    vec3 litflux = vec3(0.);\t// color of the light rays\n    vec3 tex;\n    float dAA = 1.;\t\t// distance to border of object, used for anti-aliasing\n        \n    vec4 info = trace(pos, ray, litflux, tex, dAA);\n    t = info.w;\n    norm = info.xyz;\n\tvec3 p = pos + t*ray;\n\n    if(t<INFINI){\n        vec2 h = vec2(0.,Mmap(tex));\n        vec2 side = p.xz*norm.y+(p.xy-h)*abs(norm.z)+(p.zy-h)*abs(norm.x);\n        color += setCol(tex,p.xz)*(.7+.005*p.y*p.y*p.y);\n        color *= min(1.,20./t);\n        color = clamp(color,0.,1.);\n        \n#ifdef AA\n        dAA = min(.2*dAA*iResolution.x/t , 1.);\t\t// anti-aliasing\n        color *= dAA;\t\t\t\t\t\t\t\t// dAA = transparency factor\n#endif\n        \n    }\n    color += litflux*(1.-max(ray.y,0.));\t// adding photon flux (vanishing in the sky)\n    \n    \n#ifdef AA\n    // for AA we need to mix the object color (found above) with the background color\n    // here we find the background color\n\tfloat T = t;\t\t\t// to save global distance\n    float cAA = 1.-dAA;\t\t// complementary color to add\n    \n    if(dAA<1.){\t\t\t\t// if dAA = 1, full object hit, no need for AA\n        \n        vec4 wall = getNextPlan(p.xz,ray.xz);\t// stepping to the next voxel\n        float tt = wall.w+.0001;\n        \n\t\t// adding light flux to the next voxel\n        float dh = p.y - Mmap(tex);\t\t\t\t\n        float dhdt = map(grid(p.xz,iTime-.03*p.y+.5));\n        litflux = .1*wall.w*wall.w*setRayCol(tex,p.xz)*smoothstep(6.,20.,dhdt)*min(1.,30./t)*step(0.,dh);\n        \n        // now we are positionned at the next voxel => tracing again\n        info = trace(p+tt*ray, ray, litflux, tex, dAA);\n        t = info.w;\n        norm = info.xyz;\n\t\tT += t+tt;\t\t// updating global distance\n        \n        if(t<INFINI){\t// a box is hit, setting its color\n            p += (t+tt)*ray;\n            vec2 h = vec2(0.,Mmap(tex));\n            vec2 side = p.xz*norm.y+(p.xy-h)*abs(norm.z)+(p.zy-h)*abs(norm.x);\n            vec3 colAA = setCol(tex,p.xz)*(.7+.005*p.y*p.y*p.y);\n            colAA *= min(1.,20./T);\n            colAA = clamp(colAA,0.,1.);\n            \n\t\t\t// adding the missing amount of color\n            colAA *= cAA;\n            color += colAA;\n        }\n        color += cAA*litflux;\t// adding the missing amount of color light ray\n    }\n#endif    \n\n\n\tfragColor = vec4(color,1.);\n}\n    \n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}