{
    "Shader": {
        "info": {
            "date": "1588109412",
            "description": "Balls are not touching.",
            "flags": 64,
            "hasliked": 0,
            "id": "tsfBWn",
            "likes": 15,
            "name": "Land of Commodore",
            "published": 3,
            "tags": [
                "c64",
                "commodore",
                "64",
                "cbm"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 540
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// crt effect from https://www.shadertoy.com/view/Ms23DR\n// sdf functions and fake AO by iq\n// music Clutter by Induktiv\n// 02.05.2020: used proper normal for reflections\n// 06.05.2020: optimized compilation times a bit\n//\n\nconst int iterationAmount=256;\nconst int numBalls=16;\nvec4 ballsPositions[numBalls];\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 SDF(vec3 r)\n{\n    vec3 rOrig=r;\n    vec3 rDist=rOrig;\n    float mat=0.0;\n    float t=0.0;\n    \n    float logoDepth=.5;\n    float bendAmt=.2;\n\n    //r=roty(r,r.y*sin(iTime)*bendAmt);\n    r=rotx(r,3.141592/2.0);\n    //float cylouter=sdCappedCylinder(r,vec3(0.0,0.0,0.0),vec3(0.0,.6,0.0),1.0);\n    //float cylinner=sdCappedCylinder(r,vec3(0.0,-2.0,0.0),vec3(0.0,1.7,0.0),0.58);\n\n    float cylouter=sdRoundedCylinder(r,0.50,0.05,0.3);\n    float cylinner=sdCappedCylinder(r,vec3(0.0,-2.0,0.0),vec3(0.0,logoDepth,0.0),0.58);\n    \n    t=opSubtraction(cylinner,cylouter);\n    \n    //vec3 rcb=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 rcb=rOrig;\n    float cuttingBox=sdBox(rcb-vec3(0.75,0.0,0.0),vec3(0.5,1.0,logoDepth));\n\tt=opSubtraction(cuttingBox,t);                           \n\n    //vec3 r2=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 r2=rotx(rOrig,3.141592);\n    float upperVent=sdRoundBox(r2-vec3(.58,0.25,0.0),vec3(0.3,0.16,.3),0.03);\n    t=min(t,upperVent);\n    float lowerVent=sdRoundBox(r2-vec3(.58,-0.25,0.0),vec3(0.3,0.16,.3),0.03);\n    t=min(t,lowerVent);\n\n    //vec3 r3=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 r3=rotz(rOrig,3.141592/4.01);\n    float minusCube=sdBox(r3-vec3(0.8,-0.8,0.0),vec3(.45,.45,.5));\n    \n    t=opSubtraction(minusCube,t);\n    float cbmLogo=t;\n\n    float floorPlane=sdPlane(rDist-vec3(0.0,-0.1*sin(rDist.x)*2.0*cos(rDist.z),0.0),\n                             vec4(0.0,1.0,0.0,1.0));\n    t=min(floorPlane,t);\n\n    float teeMin=100.0;\n    for (int i=0;i<numBalls;i++)\n    {\n        float amigaBall=sdSphere(rOrig-vec3(2.0+ballsPositions[i].x,\n                                            -0.7+abs(sin(iTime+ballsPositions[i].w)),\n                                            ballsPositions[i].z),\n                                 \t\t\t0.4+0.2*ballsPositions[i].w);\n        t=min(amigaBall,t);\n        teeMin=min(t,teeMin);\n    }\n    \n    \n    //\n    \n    if (t==cbmLogo) mat=0.0;\n    else if (t==floorPlane) mat=1.0;\n    else if (t==teeMin) mat=2.0;\n    if (t==upperVent) mat=3.0;\n    if (t==lowerVent) mat=4.0;\n    \n    return vec2(t,mat);   \n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        // iOS fix\n        //vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n     \n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    const float FOG_DENSITY = 0.06;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec4 bounceRender(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(.52);\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n\n    if (t>0.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n        vec3 N=calcNormal(rayOrigin + rayDir * t);\n        float NoL = max(dot(N, L), 0.0);\n      \n\t\tif (mat==0.0)\n        {\n            col=vec3(NoL)*0.75;\n            col+=vec3(.15,.15,.15);\n        }        \n        else if (mat==1.0)\n        {\n            float occ = calcAO( pHit, vec3(0.0,1.0,0.0) );\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=vec3(0.5)*occ;\n            \n            float tee = -rayOrigin.y / rayDir.y;\n\n            vec2 P = rayOrigin.xz + t * rayDir.xz;\n            vec2 Q = floor(P);\n            P = mod(P, 1.0);\n\n            const float gridLineWidth = 0.1;\n\n            float res = clamp(2048.0 / iResolution.y, 1.0, 3.0);\n            P = 1.0 - abs(P - 0.5) * 2.0;\n            float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(tee + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n\n            float shade = mix(hash(120.0 + Q * 0.1) * 0.4, 0.3, min(tee * tee * 0.001, 1.0)) + 0.6;\n            vec3 colFloor= vec3(pow(d, \n                           clamp(150.0 / (pow(max(tee - 2.0, 0.1), res) + 1.0), 0.1, 31.0)\n                      )) * shade + 0.1;            \n            colFloor*=vec3(0.51,0.12,0.23);\n            col=mix(colFloor,col,0.5);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==2.0)\n        {\n            vec3 q=N;\n            vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n            vec2 qp = floor(matuv*2.51);\n            float intensity=mod( qp.x+qp.y, 2.0 );\n            if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n            else col=vec3(1.0);\n            //float NoL = max(dot(N, L), 0.2);\n            col*=NoL;\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if ((mat==3.0)||(mat==4.0))\n        {\n            col=vec3(NoL)*0.75;\n            if (mat==4.0) col+=vec3(231.0/256.0,12.0/256.0,52.0/256.0);\n            else col+=vec3(0.0,112.0/256.0,232.0/256.0);\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n            col/=4.0;\n        }\n    }\n    else\n    {\n        vec3 sk=Sky(rayDir);\n        col=vec3(clamp(sk.x,0.0,1.0),clamp(sk.y,0.0,1.0),clamp(sk.z,0.0,1.0));\n        //col=vec3(1.0,0.0,0.0);\n    }\n\n    //col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(4.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n    vec3 N=calcNormal(rayOrigin + rayDir * t);\n    float NoL = max(dot(N, L), 0.0);\n\n    if (t>0.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n      \n        if (mat==0.0) // c= logo\n        {\n            col=vec3(NoL)*0.75;\n            col+=vec3(.25,.25,.25);\n            vec3 refDir = reflect(rayDir,N);\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.6);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==1.0) // floor\n        {\n            float occ = calcAO( pHit, vec3(0.0,1.0,0.0) );\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=vec3(0.5)*occ;\n            \n            float tee = -rayOrigin.y / rayDir.y;\n\n            vec2 P = rayOrigin.xz + t * rayDir.xz;\n            vec2 Q = floor(P);\n            P = mod(P, 1.0);\n\n            const float gridLineWidth = 0.05;\n\n            float res = clamp(2048.0 / iResolution.y, 1.0, 3.0);\n            P = 1.0 - abs(P - 0.5) * 2.0;\n            float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(tee + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n\n            float shade = mix(hash(120.0 + Q * 0.1) * 0.4, 0.3, min(tee * tee * 0.001, 1.0)) + 0.6;\n            vec3 colFloor= vec3(pow(d, \n                           clamp(150.0 / (pow(max(tee - 2.0, 0.1), res) + 1.0), 0.1, 31.0)\n                      )) * shade + 0.1;            \n            \n            colFloor*=vec3(0.51,0.12,0.23);\n            col=mix(colFloor,col,0.5);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==2.0) // amiga balls\n        {\n            vec3 q=N;\n            vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n            vec2 qp = floor(matuv*2.51);\n            float intensity=mod( qp.x+qp.y, 2.0 );\n            if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n            else col=vec3(1.0);\n            float NoL = max(dot(N, L), 0.1);\n            col*=NoL;\n            col+=pow(NoL,32.0);\n            \n            vec3 refDir = reflect(rayDir,N);\n\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.7);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if ((mat==3.0)||(mat==4.0))\n        {\n            col=vec3(NoL)*0.75;\n            if (mat==4.0) col+=vec3(231.0/256.0,12.0/256.0,52.0/256.0);\n            else col+=vec3(0.0,112.0/256.0,232.0/256.0);\n            vec3 refDir = reflect(rayDir,N);\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.6);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else\n        {\n            col=vec3(1.0,1.0,0.0);\n        }\n        \n    }\n    else\n    {\n        col=Sky(rayDir);\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid initBalls()\n{\n    float ballSpread=16.0;\n    int seed=234;\n    for (int b=0;b<numBalls;b++)\n    {\n        float x=-ballSpread/2.0+onelinerRandom(vec2(seed))*ballSpread; seed+=0x42;\n        float y=onelinerRandom(vec2(seed))*3.141592*2.0; seed+=0x42;\n        float z=-ballSpread/2.0+onelinerRandom(vec2(seed))*ballSpread; seed+=0x42;\n        float delta=onelinerRandom(vec2(seed));\n\t\tballsPositions[b]=vec4(x,y,z,delta);        \n    }\n}\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initBalls();\n    \n    float myTime=(iTime+1.34)/2.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float radius=4.0;\n    camPos = vec3(radius*sin(myTime),1.0+cos(myTime/4.0)*0.9,-radius*cos(myTime));\n    camTarget = vec3(0.0,0.,0.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz,1.0);\n\t//vec4 col=finalCol;\n    \n\tvec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\tvec3 col = finalCol.rgb;\n    col=clamp(col*0.6+0.4*col*col*1.0,0.0,1.0);\n    float vig = (0.0 + 1.0*16.0*uv2.x*uv2.y*(1.0-uv2.x)*(1.0-uv2.y));\n\tcol *= vec3(pow(vig,0.3));\n    col *= vec3(0.95,0.90,0.95)*2.7;\n\tfloat scans = clamp( 0.35+0.35*sin(3.5*iTime+uv2.y*iResolution.y*1.5), 0.0, 1.0);\n\tfloat s = pow(scans,1.7);\n\tcol = col*vec3( 0.4+0.7*s) ;\n    col *= 1.0+0.01*sin(110.0*iTime);\n\tcol*=1.0-0.65*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*2.0,0.0,1.0));\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n    \n    //vec3 col2=mix(col,finalCol.rgb,0.5);\n    //col=mix(col,finalCol.rgb,(1.0-pow(distance(uv,vec2(0.0,0.0)),0.039))/1.0);\n\tcol=mix(col,finalCol.rgb,0.4);\n    //vec3 col=finalCol.xyz;\n    \n    fragColor=vec4(col.rgb, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 22483,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/studiodrumandbass/induktiv-clutter-free-download?in=different-drumz/sets/free-drum-bass-downloads-from"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}