{
    "Shader": {
        "info": {
            "date": "1718125752",
            "description": "GLSL implementation of Mie scattering computations.\nMouse x - size parameter.\nMouse y - imaginary part of refractive index.",
            "flags": 0,
            "hasliked": 0,
            "id": "4XK3zc",
            "likes": 6,
            "name": "Mie scattering in GLSL",
            "published": 3,
            "tags": [
                "scattering",
                "mie"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 154
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// GLSL implementation of computations for Mie scattering by a homogeneous\n// sphere, mostly adapted from BHMIE.f by Craig F. Bohren and\n// Donald R. Huffman (with modifications by Bruce T. Draine) with some\n// elements of MIEV0.f by Warren J. Wiscombe.\n\n// Porting to GLSL introduced several known drawbacks, the blame \n// for which (along with whatever unknown ones) is entirely with me.\n// Do be advised against using this code for anything remotely \"serious\",\n// at least not without extensive prior testing.\n\n// In this GLSL port, all calculations are carried in single precision\n// (BHMIE.f uses double precision internally, though input and output\n// are single precision) and all use of arrays is avoided. Said use of\n// arrays in the original is twofold. Firstly, BHMIE computes the\n// coefficients for several angles and uses arrays for both output\n// and intermediates. This is avoided by changing this implementation\n// to provide results for single angle only. This introduces inefficiency,\n// as some things are calulated over and over, but such is the way of the GPU.\n// Secondly, as per [1], Mie scattering calcualtions are fundamentally\n// summations of a number of terms of a series, coefficients of which\n// involve several quantities related to Bessel functions. The problem\n// is that for some of these quantities the stable recurrences to compute\n// them are upwards, and for some of them downwards. Which means that\n// whatever direction your loop is structured, some of the recurrences\n// are backwards, so you end up storing precomputed coefficients for them\n// (or compute them each iteration, increasing run time to O(n^2)).\n// In this implementation we grudgingly use (potentially unstable) upwards\n// recurrences for everything. The investigation in [2] (carried, admittedly,\n// for double precision) indicates that upwards recurences provide acceptable\n// accuracy in certain regions. As a rule of thumb, you need all of the\n//     1. Relatively large (above 1) size parameter.\n//     2. But not too large (below several hundreds).\n//     3. Small imaginary part of refraction index, compared to the real part.\n// to be relatively safe. Functions implementing the condition tests\n// from [2] are provided to test if the input is considered safe.\n// NOTE: limited testing in float32 paints a considerably worse picture,\n// but is broadly similar. As long as you are content with relative error\n// on the scale of 10%, the region\n//     0.125<  x  <25\n//     1.050<Re(m)<10\n//     0.000<Im(m)<10\n// looks safe.\n// NOTE: the above generally holds for e.g. small (1..10 micrometres) water\n// droplets in clouds in visible spectrum.\n// Perhaps fancier calculation methods (see e.g. [3] and [4]) can help\n// mitigating errors.\n// For small x and |m|*x, Rayleigh-style approximation provides adequate\n// accuracy. Formula from [2] is provided.\n\n// NOTE: as run time is roughly proportional to the size parameter,\n// the computations for large particles can be slow.\n\n// References: \n//     [1] Bohren, Craig F. and Donald Ray Huffman. “Absorption and Scattering of Light by Small Particles.” (1998).\n//     [2] W. J. Wiscombe, \"Improved Mie scattering algorithms,\" Appl. Opt. 19, 1505-1509 (1980)\n//         https://opg.optica.org/ao/fulltext.cfm?uri=ao-19-9-1505&id=23949\n//     [3] Lentz, William. (1976). Generating Bessel Functions In Mie Scattering Calculations Using Continued Fractions. Applied optics. 15. 668-71. 10.1364/AO.15.000668. \n//     [4] Du, H. (2004). Mie-scattering calculation. Applied Optics, 43(9), 1951. doi:10.1364/ao.43.001951 \n\n//==============================================================================\n// Functions of complex variables.\n\nvec2 cmul(vec2 l,vec2 r)\n{\n    return vec2(l.x*r.x-l.y*r.y,l.x*r.y+l.y*r.x);\n}\n\nvec2 cdiv(vec2 l,vec2 r)\n{\n    return vec2(l.x*r.x+l.y*r.y,l.y*r.x-l.x*r.y)/(r.x*r.x+r.y*r.y);\n}\n\nvec2 csin(vec2 z)\n{\n    return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y));\n}\n\nvec2 ccos(vec2 z)\n{\n    return vec2(cos(z.x)*cosh(z.y),-sin(z.x)*sinh(z.y));\n}\n\n//==============================================================================\n// Function for calculating Mie scattering.\n\n// Input:\n//     x   - size parameter, 2*pi*r/lambda.\n//           NOTE: 2*pi*Nmedium*r/lambda, for arbitrary medium.\n//     m   - complex relative refraction index, Nparticle/Nmedium.\n//           IMPORTANT: following [1], we expect Im(m)>=0, whereas\n//           many texts adopt Im(m)<=0 convention.\n//     mu  - cosine of the scattering angle.\n// Output: matrix with the following 4 columns:\n//     [0] - S1 element of the amplitude scattering matrix (complex number).\n//     [1] - S2 element of the amplitude scattering matrix (complex number).\n//     [2] - vec2(Qext,Qsca) - efficiency factors for extinction and scattering.\n//     [3] - vec2(Gsca,0) - asymmetry parameter.\nmat4x2 mie(float x,vec2 m,float mu)\n{\n    vec2 y=x*m;\n    float pi0=0.0,pi1=1.0,pi;\n    vec2 s1=vec2(0.0,0.0);\n    vec2 s2=vec2(0.0,0.0);\n    float tau;\n    float psi0= cos(x);\n    float psi1= sin(x);\n    float chi0=-sin(x);\n    float chi1= cos(x);\n    vec2 xi1=vec2(psi1,-chi1);\n    float qext=0.0;\n    float qsca=0.0;\n    float gsca=0.0;\n    vec2 an=vec2(0.0,0.0),bn=vec2(0.0,0.0);\n#if 0\n    vec2 D=cdiv(csin(y)-cmul(y,cmul(y,csin(y))+ccos(y)),cmul(y,cmul(y,ccos(y))-csin(y)));\n#else\n    // The original expression is\n    //     D=(sin(z)-z*cos(z)-z*z*sin(z))/(z*z*cos(z)-z*sin(z))\n    // which we evaluate avoiding overflow.\n    float tc=cos(y.x),ts=sin(y.x);\n    float hc=1.0+exp(-2.0*y.y),hs=1.0-exp(-2.0*y.y);\n    vec2 cs=vec2(ts*hc, tc*hs);\n    vec2 cc=vec2(tc*hc,-ts*hs);\n    vec2 D=cdiv(cs-cmul(y,cmul(y,cs)+cc),cmul(y,cmul(y,cc)-cs));\n#endif\n\n    int nstop=int(round(x+4.0*pow(x,0.3333)+2.0));\n    for(int k=0;k<nstop;++k)\n    {\n        float n=float(k+1);\n        float fn=(2.0*n+1.0)/(n*(n+1.0));\n        float psi=(2.0*n-1.0)*psi1/x-psi0;\n        float chi=(2.0*n-1.0)*chi1/x-chi0;\n        vec2 xi=vec2(psi,-chi);\n        vec2 an1=an,bn1=bn;\n        an=(cdiv(D,m)+vec2(n/x,0.0))*psi-vec2(psi1,0.0);\n        an=cdiv(an,(cmul((cdiv(D,m)+vec2(n/x,0.0)),xi)-xi1));\n        bn=(cmul(m,D)+vec2(n/x,0.0))*psi-vec2(psi1,0.0);\n        bn=cdiv(bn,(cmul(cmul(m,D)+vec2(n/x,0.0),xi)-xi1));\n        qext=qext+((2.*n+1.)*(an.x+bn.x));\n        qsca=qsca+((2.*n+1.)*(dot(an,an)+dot(bn,bn)));\n        gsca=gsca+(((2.*n+1.)/(n*(n+1.)))*\n            (an.x*bn.x+an.y*bn.y));\n        gsca=gsca+(((n-1.)*(n+1.)/n)*\n            (an1.x*an.x+an1.y*an.y+\n            bn1.x*bn.x+bn1.y*bn.y));\n        pi=pi1;\n        tau=n*mu*pi-(n+1.)*pi0;\n        s1=s1+fn*(an*pi+bn*tau);\n        s2=s2+fn*(an*tau+bn*pi);\n        psi0=psi1;\n        psi1=psi;\n        chi0=chi1;\n        chi1=chi;\n        xi1=vec2(psi1,-chi1);\n        pi1=((2.*n+1.)*mu*pi-(n+1.)*pi0)/n;\n        pi0=pi;\n        D=cdiv(vec2(1.0,0.0),(cdiv(vec2(n+1.,0.0),y)-D))-cdiv(vec2(n+1.,0.0),y);\n    }\n    gsca=2.0*(gsca)/qsca;\n    qext=(2.0/(x*x))*qext;\n    qsca=(2.0/(x*x))*qsca;\n    return mat4x2(s1,s2,vec2(qext,qsca),vec2(gsca,0.0));\n}\n\n// Criterion, from [2], for when accuracy of upwards recurrence is\n// good enough for Qext and Qsca.\nbool f1_test(float x,vec2 m)\n{\n    float t=m.x;\n    return\n        x>=1.0&&x<10000.0&&\n        t>=1.05&&t<=9.25&&\n        abs(m.y)<-8.0+t*t*(26.22+t*(-0.4474+t*t*t*(0.00204+t*-0.000175)));\n}\n\n// Criterion, from [2], for when accuracy of upwards recurrence is\n// good enough for S1 and S2.\nbool f2_test(float x,vec2 m)\n{\n    float t=m.x;\n    return\n        x>=1.0&&x<10000.0&&\n        t>=1.05&&t<=9.25&&\n        abs(m.y)<3.9+t*(-10.8+t*13.78);\n}\n\n// Approximation of scattering for small x.\n// Recommended for |m|*x<0.1.\n// Meaning of input and output are the same as above.\nmat4x2 mie_rayleigh(float x,vec2 m,float mu)\n{\n    vec2 D=cmul(m,m)+vec2(2.0,0.0)\n        +(vec2(1.0,0.0)-7.0/10.0*cmul(m,m))*x*x\n        -x*x*x*x/1400.0*(cmul(cmul(m,m),(8.0*cmul(m,m)-vec2(385.0,0.0)))+vec2(350.0,0.0))\n        +x*x*x*cmul(vec2(0.0,2.0/3.0),cmul(m,m)-vec2(1.0,0.0))*(1.0-1.0/10.0*x*x);\n    vec2 a1=cmul(cmul(vec2(0.0,2.0/3.0),cmul(m,m)-vec2(1.0,0.0)),\n        cdiv(vec2(1.0-1.0/10.0*x*x,0.0)+x*x*x*x/1400.0*(4.0*cmul(m,m)+vec2(5.0,0.0)),D));\n    vec2 b1=cmul(cmul(vec2(0.0,x*x/45.0),(cmul(m,m)-vec2(1.0,0.0))),cdiv(\n        vec2(1.0,0.0)+x*x/70.0*(2.0*cmul(m,m)-vec2(5.0,0.0)),\n        vec2(1.0,0.0)-x*x/30.0*(2.0*cmul(m,m)-vec2(5.0,0.0))));\n    vec2 a2=cmul(cmul(vec2(0.0,x*x/15.0),(cmul(m,m)-vec2(1.0,0.0))),cdiv(\n        vec2(1.0-x*x/14.0,0.0),\n        2.0*cmul(m,m)+vec2(3.0,0.0)-x*x/14.0*(2.0*cmul(m,m)-vec2(7.0,0.0))));\n    float T=dot(a1,a1)+dot(b1,b1)+5.0/3.0*dot(a2,a2);\n    float qext=6.0*x*(a1+b1+5.0/3.0*a2).x;\n    float qsca=6.0*x*x*x*x*T;\n    float gsca=1.0/T*dot(a1,a2+b1);\n    vec2 s1=3.0/2.0*x*x*x*(a1+(b1+5.0/3.0*a2)*mu);\n    vec2 s2=3.0/2.0*x*x*x*(b1+a1*mu+5.0/3.0*a2*(2.0*mu*mu-1.0));\n    return mat4x2(s1,s2,vec2(qext,qsca),vec2(gsca,0.0));\n}\n\n//==============================================================================\n\nvec3 plot(vec3 bg,vec3 fg,float x,bool border)\n{\n    float a=smoothstep(2.5*fwidth(x),0.0,abs(x));\n    if(border) fg*=a*a;\n    return mix(bg,fg,a);\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    const float pi=3.14159265358979;\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=vec3(1.0/16.0);\n    float r=1.7;              // Particle radius, in micrometres.\n    float lambda=0.550;       // Light wavelength, in micrometres.\n    float x=2.0*pi*r/lambda;  // Size parameter.\n    vec2 m=vec2(1.334,0.007); // Relative refractive index particle/medium.\n    if(true)\n    {\n        // Mouse-controlled parameters.\n        x=exp(mix(log(1.0),log(100.0),iMouse.x/iResolution.x));\n        m.y=mix(0.0,1.0,iMouse.y/iResolution.y);\n    }\n    float theta=pi*uv.x;      // Scattering angle, in radians.\n    float mu=cos(theta);\n    mat4x2 F=mie(x,m,mu);\n    vec2 s1=F[0],s2=F[1];\n    float Qext=F[2].x,Qsca=F[2].y; // Efficiency factors for extinction and scattering.\n    float Gsca=F[3].x;             // Asymmetry parameter.\n    float SSA=Qsca/Qext;           // Single-scattering albedo.\n    // We compute normalization constant for phase function,\n    // so that 1 = 2*π * ∫ p(θ)*sin(θ) dθ on [0;π].\n    // NOTE: if we average phase functions for several particle sizes,\n    // which is a common case, the computation needs to be different,\n    // since the functions are weighted according to Qsca (as well as\n    // probability denity for given size).\n    float W=pi*x*x*Qsca;\n    float p1=dot(s1,s1)/W; // Phase function for light perpendicular to the scattering plane.\n    float p2=dot(s2,s2)/W; // Phase function for light parallel to the scattering plane.\n    float p=0.5*(p1+p2);   // Phase functoin for unpolarized light.\n    // Grid.\n    float y=mix(-4.0,+6.0,uv.y);\n    if(mod(y,2.0)<1.0) col+=1.0/32.0;\n    col=plot(col,vec3(0.5),y,false);\n    // Test.\n    if(!(f1_test(x,m)&&f2_test(x,m))) col.x+=1.0/16.0;\n    // Phase function.\n    col=plot(col,vec3(0.2,0.7,0.2),log(p)/log(10.0)-y,true);\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}