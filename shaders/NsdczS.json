{
    "Shader": {
        "info": {
            "date": "1653657923",
            "description": "Growing Tree~",
            "flags": 32,
            "hasliked": 0,
            "id": "NsdczS",
            "likes": 9,
            "name": "Growing tree",
            "published": 3,
            "tags": [
                "tree",
                "physics",
                "verlet"
            ],
            "usePreview": 0,
            "username": "lasoy",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "#define P_COLOR 1.0\n#define DC_COLOR 2.0\n#define AC_COLOR 3.0\n#define BOUNDS_COLOR 4.0\n\nvec2 getInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));\n    info.xy = info.xy * 2. - 1.;\n    \n    return info.xy;\n}\n\nvec2 opU( vec2 d1, float d2, float material )\n{\n    return (d1.x<d2) ? d1 : vec2(d2, material);\n}\n\nvec2 map(vec2 p){\n    vec2 d = vec2(99999.9, 0);\n    for(int i = 0;i < P_COUNT;i ++) {\n       d = opU(d, sdCircle(p - getInfo(i), R), P_COLOR);\n    }\n\n    for(int i = 0;i < DC_COUNT;i ++) {\n      int a = int(dc[i][0]);\n      int b = int(dc[i][1]);\n      d = opU(d, sdSegment(p, getInfo(a).xy,  getInfo(b).xy), AC_COLOR);\n    }\n    \n    d = opU(d, sdSegment(p, vec2(-1, -1), vec2(-1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(-1, 1), vec2(1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, 1), vec2(1, -1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, -1), vec2(1, 1)), BOUNDS_COLOR);\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float w = length(fwidth(uv)) * 5.0;\n    \n    vec2 d = map(uv);\n    float c = smoothstep(0.0, w, abs(d.x));\n    vec3 col = vec3(1.0-c);\n    if (d.y == P_COLOR) {\n      col *= vec3(.3, .9, .6);\n    } else if (d.y == DC_COLOR) {\n      col *= vec3(.3, .6, .9);\n    } else if (d.y == AC_COLOR) {\n      col *= vec3(.6, .9, .3);\n    } else if (d.y == BOUNDS_COLOR) {\n      col *= vec3(.5, .5, .5);\n    }\n\n    col = mix(col, vec3(1, 1, .95), c/4.0);\n\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.141592653589793\n#define R .04\n#define STEP 0.1\nfloat friction = 0.9;\n\nstruct AC {\n    int a;\n    int b;\n    int c;\n    float angle;\n    float stiffness;\n};\n\n#define P_COUNT 17\nconst vec2 pos[P_COUNT] = vec2[P_COUNT](\n    vec2(0.5,0.05000000074505806),\n    vec2(0.5,0.050999999046325684),\n    vec2(0.5,0.20000000298023224),\n    vec2(0.42500001192092896,0.32990381121635437),\n    vec2(0.33839747309684753,0.37990379333496094),\n    vec2(0.2883974611759186,0.37990379333496094),\n    vec2(0.31339746713638306,0.42320504784584045),\n    vec2(0.42500001192092896,0.4299038052558899),\n    vec2(0.4000000059604645,0.4732050895690918),\n    vec2(0.45000001788139343,0.4732050895690918),\n    vec2(0.574999988079071,0.32990381121635437),\n    vec2(0.574999988079071,0.4299038052558899),\n    vec2(0.550000011920929,0.4732050895690918),\n    vec2(0.5999999642372131,0.4732050895690918),\n    vec2(0.6616025567054749,0.37990379333496094),\n    vec2(0.6866025328636169,0.42320504784584045),\n    vec2(0.7116025686264038,0.37990379333496094)\n);\n\n#define DC_COUNT 16\nconst vec4 dc[DC_COUNT] = vec4[DC_COUNT](\n    vec4(3,2,0.14999999202035977,0.1),\n    vec4(4,3,0.099999989713187,0.1),\n    vec4(5,4,0.050000011920928955,0.1),\n    vec4(6,4,0.04999998940239111,0.1),\n    vec4(7,3,0.09999999403953552,0.1),\n    vec4(8,7,0.05000001521195773,0.1),\n    vec4(9,7,0.05000001521195773,0.1),\n    vec4(10,2,0.14999999202035977,0.1),\n    vec4(11,10,0.09999999403953552,0.1),\n    vec4(12,11,0.050000000310804184,0.1),\n    vec4(13,11,0.050000000310804184,0.1),\n    vec4(14,10,0.10000001552275858,0.1),\n    vec4(15,14,0.049999974501229866,0.1),\n    vec4(16,14,0.050000011920928955,0.1),\n    vec4(0,1,0.000999998301267624,0.9),\n    vec4(1,2,0.14900000393390656,0.9)\n);\n\n#define AC_COUNT 15\nconst AC ac[AC_COUNT] = AC[AC_COUNT](\n    AC(1,2,3,-2.617993939045201,0.5),\n    AC(2,3,4,-2.6179936698521753,0.5),\n    AC(3,4,5,-2.617994025077107,0.5),\n    AC(6,4,3,-2.617993990927634,0.5),\n    AC(7,3,2,-2.617993939045201,0.5),\n    AC(3,7,8,-2.6179939159930097,0.5),\n    AC(9,7,3,-2.6179939159930097,0.5),\n    AC(10,2,1,-2.617993939045201,0.5),\n    AC(2,10,11,-2.617993939045201,0.5),\n    AC(10,11,12,-2.6179944321843833,0.5),\n    AC(13,11,10,-2.6179944321843833,0.5),\n    AC(14,10,2,-2.617993520840624,0.5),\n    AC(10,14,15,-2.617993325724532,0.5),\n    AC(16,14,10,-2.6179941740886576,0.5),\n    AC(2,1,0,-3.141592653589793,0.8)\n);\n\n#define PC_COUNT 2\nconst vec3 pc[PC_COUNT] = vec3[PC_COUNT](\n    vec3(0,0.5,0.05000000074505806),\n    vec3(1,0.5,0.050999999046325684)\n);\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 getPInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));    \n    return info;\n}\n\nvoid bounds(inout vec4 info) {\n    float min = R/2.0;\n    float max = 1.0 - R/2.0;\n\n    if (info.x < min) {\n        info.x = min;\n    } else if (info.x > max) {\n        info.x = max;\n    }\n\n    if (info.y < min) {\n        info.y = min;\n    } else if (info.y > max) {\n        info.y = max;\n    }\n}\n\nvoid relaxDC(int index, inout vec4 color) {\n  for(int i = 0;i < DC_COUNT;i ++) {\n    vec4 info = dc[i];\n    int a = int(info[0]);\n    int b = int(info[1]);\n    float dist = info[2];\n    float stiffness = info[3];\n\n    if (a == index || b == index) {\n      vec2 d;\n      if(a == index) {\n        d = color.xy - getPInfo(b).xy;\n      } else {\n        d = getPInfo(a).xy - color.xy;\n      }\n      d = getPInfo(a).xy - getPInfo(b).xy;\n      float m = dot(d, d);\n      d *=((dist*dist - m)/m)*stiffness*0.5;\n      if (a == index) {\n        color.xy += d;\n      } else if(b == index) {\n        color.xy -= d;\n      }\n    }\n  }\n}\n\nvoid relaxPC(int index, inout vec4 color) {\n  for(int i = 0;i < PC_COUNT;i ++) {\n    vec3 info = pc[i];\n    if (int(info.x) == index) {\n      color.xy = info.yz;\n    }\n  }\n}\n\nvoid rotate(inout vec2 pos, vec2 origin, float angle) {\n  vec2 offset = pos - origin;\n  float c = cos(angle);\n  float s = sin(angle);\n  pos.x = origin.x + offset.x * c - offset.y * s;\n  pos.y = origin.y + offset.x * s + offset.y * c;\n}\n\nvoid relaxAC(int index, inout vec4 color) {\n  for(int i = 0;i < AC_COUNT;i ++) {\n    AC info = ac[i];\n    if (info.a == index || info.b == index || info.c == index) {\n      vec2 aPos;\n      vec2 bPos;\n      vec2 cPos;\n      if (info.a == index) {\n        aPos = color.xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = getPInfo(info.c).xy;\n      } else if (info.b == index) {\n        aPos = getPInfo(info.a).xy;\n        bPos = color.xy;\n        cPos = getPInfo(info.c).xy;\n      } else {\n        aPos = getPInfo(info.a).xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = color.xy;\n      }\n      vec2 l = aPos-bPos;\n      vec2 r = cPos-bPos;\n\n      float diff = atan(l.x * r.y - l.y * r.x, dot(l,r)) - info.angle;\n      \n      if (diff <= -PI)\n        diff += 2.0 * PI;\n      else if (diff >= PI)\n        diff -= 2.0 * PI;\n\n      diff *= STEP * info.stiffness;\n      rotate(aPos, bPos, diff);\n      rotate(cPos, bPos, -diff);\n      rotate(bPos, aPos, diff);\n      rotate(bPos, cPos, -diff);\n      if (info.a == index) {\n        color.xy = aPos;\n      } else if(info.b == index) {\n        color.xy = bPos;\n      } else if(info.c == index) {\n        color.xy = cPos;\n      }   \n    }\n  }\n}\n\nvoid relaxMouse(int index, inout vec4 color) {\n  if (iMouse.z > 0.) {\n    vec2 target = getPInfo(index).xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x = (mouse.x - 0.5)*iResolution.x/iResolution.y + 0.5;\n    float l = dot(mouse - target, mouse - target);\n\n    if (l < R*R) {\n      color.xy = mouse;\n    }\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord;\n    int col = int(uv.x);\n    int row = int(uv.y);\n    \n    col/=1;\n \n    if (col >= P_COUNT || row > 0) {\n        return;\n    }\n\n    vec4 color = getPInfo(col);\n    \n    if (iFrame == 0) {\n        color.xy = pos[col];\n        color.zw = color.xy;\n    } else {\n        vec2 v = color.xy - color.zw;\n        v *= friction;\n        vec2 g = vec2((sin(iTime*1.))*0.01, sign(cos(iTime*1.5))*0.01);\n        v += g*0.05;\n        \n        color.zw = color.xy;\n        color.xy += v;\n        \n        relaxAC(col, color);\n        relaxDC(col, color);\n        relaxMouse(col, color);\n        relaxPC(col, color);\n        bounds(color);\n    }\n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}