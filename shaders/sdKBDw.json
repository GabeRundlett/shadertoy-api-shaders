{
    "Shader": {
        "info": {
            "date": "1658338252",
            "description": "nfract",
            "flags": 32,
            "hasliked": 0,
            "id": "sdKBDw",
            "likes": 3,
            "name": "newtons_fract_simple",
            "published": 3,
            "tags": [
                "fractal",
                "simple"
            ],
            "usePreview": 0,
            "username": "graygoose",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NROOTS 3\nvec2 roots[NROOTS];\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.753,0.380,0.796,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "int get_nearest_root(vec2 z){\n    int index = 0; float dist = 1000.;\n    \n    for(int i = 0; i < NROOTS; i++){\n        float d = length(z - roots[i]);\n        if(d < dist){\n            index = i; dist = d;\n        }\n    }\n    \n    return index;\n}\n\nvec2 newton_iter(in vec2 z){\n    vec2 sum = vec2(0.);\n\n    for(int j = 0; j < NROOTS; j++){\n        vec2 dist = z - roots[j];\n        float delta = dot(dist, dist);\n        if (delta < 0.0001) return z;\n        \n        sum += vec2(dist.x, -dist.y) / delta;\n    }\n    \n    return z - (vec2(sum.x, -sum.y) / (sum.x*sum.x+sum.y*sum.y));\n}\n\n\n#define ITER_COUNT 15\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Roots associated with Polynomial being iterated.\n    roots = vec2[NROOTS](vec2(  0.0, -1.+sin(iTime)), \n                         vec2(  0.5,          0.866), \n                         vec2( -0.5,          0.866));\n\n    // scale math space\n    vec2 z = scale(fragCoord.xy, iResolution.xy, mat2(-1.25, 1.25, -.5, 1.)); \n    \n    // calculate pixel convergence & color\n    for(int i = 0; i < ITER_COUNT; i++){\n        z = newton_iter(z);\n    }\n    \n    // coloring\n    int col_index = get_nearest_root(z);\n    vec3 col = vec3(col_index-0==0,col_index-1==0,col_index-2==0);\n    \n    fragColor = vec4(hueShift(col, cos(iTime)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 C1 = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n    \n    fragColor = C0 + G1;\n    fragColor *= -L0 / (2.-C0);\n    \n    fragColor += C1 + G1;\n    fragColor *= 0.49;\n    fragColor += -L0 / (2.-C1);\n\n    \n    fragColor += G1 + L0;\n    fragColor *= 0.49;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}