{
    "Shader": {
        "info": {
            "date": "1530595236",
            "description": "I feel this is the kind of thing [url=https://www.shadertoy.com/user/Shane]Shane[/url] would do. Chances are he already made one like this. If so, oh well...",
            "flags": 0,
            "hasliked": 0,
            "id": "4sKBWV",
            "likes": 70,
            "name": "Hexagons on Torus",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "torus",
                "hexagon"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 3290
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 is you have a fast computer\n#endif\n\n//------------------------------------------------------------------\n\nvec3 hexagon_pattern( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n\treturn vec3( pi + ca - cb*ma, dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) ) );\n}\n\n//------------------------------------------------------------------\n\nconst vec2 torus = vec2(0.5,0.2);\n\n#define NumTiles 3\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 p )\n{\n    // torus\n    float d = length( vec2(length(p.xz)-torus.x,p.y) )-torus.y;\n    \n    // displace torus\n    vec2 uv = vec2(atan(p.z,p.x),atan(length(p.xz)-torus.x,p.y) )*vec2(3.0*sqrt(3.0),2.0)/3.14159;\n    uv = uv*float(NumTiles) + vec2(0.0,0.5*iTime);\n    vec3 h = hexagon_pattern( uv );\n    float f = mod(h.x+2.0*h.y,3.0)/2.0;\n    d += f*0.04;\n\n    return d;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    // plane\n    float tmax = (-torus.y-ro.y)/rd.y;\n   \n    // torus\n    float t = 0.7;\n    float m = 2.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res*0.25;\n    }\n\n    if( t>tmax ) { t=tmax; m=1.0; }\n    return vec2( t, m );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for( int i=0; i<128; i++ )\n    {\n\t\tfloat h = map( ro + rd*t )*0.2;\n        res = min( res,24.0*h/t );\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>0.8 ) break;\n    }\n    return smoothstep( 0.0, 1.0, res );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec2  res = castRay(ro,rd);\n    float t   = res.x;\n    vec3  pos = ro + t*rd;\n    vec3  nor = vec3(0.0,1.0,0.0);\n    float occ = 1.0;\n    float ks  = 0.0;\n    vec3  col = vec3(0.0,0.0,0.0);\n\n    // material        \n    if( res.y<1.5 )\n    {\n        // texture\n        vec3 te = texture(iChannel0,pos.xz*0.5).xyz;\n        col = 0.02 + te*0.2;\n        ks = te.x;\n        // fake occlusion\n        occ = smoothstep(0.06,0.4, abs(length(pos.xz)-torus.x) );\n    }\n    else\n    {\n        nor = calcNormal( pos );\n        occ = 0.5+0.5*nor.y;\n\n        vec2 uv = vec2( atan(pos.z,pos.x), atan(length(pos.xz)-torus.x,pos.y) )*\n                  vec2(3.0*sqrt(3.0), 2.0)/3.14159;\n        uv = uv*float(NumTiles) + vec2(0.0,0.5*iTime);\n        vec3 h = hexagon_pattern( uv );\n        float f = mod(h.x+2.0*h.y,3.0)/2.0;\n\n        // cell color\n        col = vec3(1.0-f);\n        float hh = abs(sin(10.0*mod(h.x+h.y*2.0,24.0)));\n        if( f<0.1 ) col = 0.12+0.12*cos(hh+vec3(0.0,2.0,2.0));\n\n        // cell borders\n        col *= 0.7+h.z;\n\n        // texture\n        vec3 te = texture( iChannel0, 0.2*uv ).xyz;\n        col *= 0.08+0.72*te;\n        ks = te.x;\n    }\n\n    // lighting\n    vec3  lig = normalize( vec3(0.4, 0.5, -0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n    //if( dif>0.0001 )\n    dif *= calcSoftshadow( pos, lig );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                dif *\n                (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.00*dif*vec3(1.10,0.90,0.60);\n    lin += 0.40*amb*vec3(0.30,0.60,1.50)*occ;\n    lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n    col = col*lin;\n    col += 5.00*spe*vec3(1.15,0.90,0.70)*ks*ks*4.0;\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    \n    // camera\t\n    vec3 ro = vec3( 1.1*cos(0.05*iTime + 6.0*mo.x), 0.9, 1.1*sin(0.05*iTime + 6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.2, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv = normalize( cross(cu,cw) );\n\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // color grading\n    tot = 1.25*pow(tot,vec3(0.65,0.9,1.0) );\n\n    // vignetting    \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}