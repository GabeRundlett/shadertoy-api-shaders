{
    "Shader": {
        "info": {
            "date": "1506571134",
            "description": "Lights on a sphere.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lfyDX",
            "likes": 1,
            "name": "Sphere I",
            "published": 3,
            "tags": [
                "noise",
                "sphere",
                "raytrace"
            ],
            "usePreview": 0,
            "username": "itishappy",
            "viewed": 136
        },
        "renderpass": [
            {
                "code": "#define    PI 3.1415926\n#define TWOPI 6.2831853\n\n/*\n#define     X vec3(1.0, 0.0, 0.0);\n#define     Y vec3(0.0, 1.0, 0.0);\n#define     Z vec3(0.0, 0.0, 1.0);\n*/\n\n/* Table of contents:                                                    *\\\n\t1. A fuck ton of perlin noise stuff\n\t\tI used this: http://flafla2.github.io/2014/08/09/perlinnoise.html\n\t\n\t2. The rest\n\t\tqMult()\n\t\trotate()\n\t\tlight()\n\t\trender()\n\t\tmainImage()\n\\*                                                                       */\n\n\n// PERLIN NOISE\n\nint whichVec[8] = int[8](0, 3, 8, 8, 6, 3, 0, 2); // Magic. Don't worry about it.\n\nfloat grad(int i, vec3 n) {\n    switch(whichVec[i]) {\n    \tcase 0:  return  n.x + n.y;\n        case 1:  return -n.x + n.y;\n    \tcase 2:  return  n.x - n.y;\n    \tcase 3:  return -n.x - n.y;\n    \tcase 4:  return  n.x + n.z;\n    \tcase 5:  return -n.x + n.z;\n    \tcase 6:  return  n.x - n.z;\n    \tcase 7:  return -n.x - n.z;\n    \tcase 8:  return  n.y + n.z;\n    \tcase 9:  return -n.y + n.z;\n    \tcase 10: return  n.y - n.z;\n    \tcase 11: return -n.y - n.z;\n    \tcase 12: return  n.y + n.x;\n    \tcase 13: return -n.y + n.z;\n    \tcase 14: return  n.y - n.x;\n    \tcase 15: return -n.y - n.z;\n        default: return 0.0;\n    }\n}\n\nfloat lerp(float p1, float p2, float v) {\n    return v * p1 + (1.0 - v) * p2;\n}\n\n\n//still not sure this works...\nfloat noiseSphere(vec3 p) {\n    p = 0.5 * p + 0.5; // shift domain from [-1.0, 1.0] to [0.0, 1.0]\n    float x1, x2, y1, y2;\n    x1 = lerp(grad(0, p), grad(1, p), p.x);\n    x2 = lerp(grad(2, p), grad(3, p), p.x);\n    y1 = lerp(x1, x2, p.y);\n    x1 = lerp(grad(4, p), grad(5, p), p.x);\n    x2 = lerp(grad(6, p), grad(7, p), p.x);\n    y2 = lerp(x1, x2, p.y);\n    return 0.5 * lerp(y1, y2, p.z) + 0.5; // shift range from [-1.0, 1.0] to [0.0, 1.0]\n}\n\n// THE REST\n\nvec3 X = vec3(1.0, 0.0, 0.0);\nvec3 Y = vec3(0.0, 1.0, 0.0);\nvec3 Z = vec3(0.0, 0.0, 1.0);\n\n// Rotates?\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), \n               -sin(a), cos(a));\n}\n\n// Quaternion multiplication\nvec4 qMult(vec4 q1, vec4 q2) {\n    vec4 qr;\n\tqr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n\tqr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n\tqr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n\tqr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n\treturn qr;\n}\n\n// Rotate using quaternions\nvec3 rotate(vec3 point, vec3 axis, float angle) {\n    vec4 p, q1, q2;\n    p.xyz = point;\n    p.w = 0.0;\n    q1.xyz = sin(0.5 * angle) * axis;\n    q1.w = cos(0.5 * angle);\n    q2.xyz = -q1.xyz;\n    q2.w = q1.w;\n    return qMult(qMult(q1, p), q2).xyz;\n}\n\n// Draws some spinning lights\nvec3 light(vec3 n) {\n    float rSpeed = 0.03;\n    float gSpeed = 0.05;\n    float bSpeed = 0.07;\n    vec3 rStart = Z;\n    vec3 gStart = Z;\n    vec3 bStart = Z;\n    vec3 rAxis = rotate(X, Z, 0.0 * TWOPI / 3.0);\n    vec3 gAxis = rotate(X, Z, 1.0 * TWOPI / 3.0);\n    vec3 bAxis = rotate(X, Z, 2.0 * TWOPI / 3.0);\n    vec3 rDir = rotate(rStart, rAxis, TWOPI * iTime * rSpeed);\n    vec3 gDir = rotate(gStart, gAxis, TWOPI * iTime * gSpeed);\n    vec3 bDir = rotate(bStart, bAxis, TWOPI * iTime * bSpeed);\n    return vec3(dot(n, rDir), dot(n, gDir), dot(n, bDir));\n}\n\n// Spins a sphere and lights it\nvec3 render(vec3 p) {\n    float speed = 0.1;\n    vec3 axis = vec3(0.0, 1.0, 0.0);\n    //return light(p);\n    //return vec3(noiseSphere(rotate(p, axis, TWOPI * iTime * speed)));\n    return light(p) * noiseSphere(rotate(p, axis, TWOPI * iTime * speed * 3.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2((2.0 * fragCoord - iResolution.xy) / iResolution.y);\n    fragColor = vec4(0.0);\n    if(length(uv) < 1.0) {\n        fragColor.xyz = render(vec3(uv, sqrt(1.0 - uv.x * uv.x - uv.y * uv.y)));\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}