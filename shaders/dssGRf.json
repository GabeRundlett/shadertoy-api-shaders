{
    "Shader": {
        "info": {
            "date": "1666598231",
            "description": "The Gosper Curve using a simple stack (just storing the offset of the \"current instruction\"). Optimized to skip recursion when far from the point being plotted. 60 fps on Nvidia 1650 at HD resolution.\n\nNeeds to be full screen for the proper effect.",
            "flags": 16,
            "hasliked": 0,
            "id": "dssGRf",
            "likes": 15,
            "name": "Gosper Curve Optimized",
            "published": 3,
            "tags": [
                "optimized",
                "lsystem",
                "stack",
                "winding",
                "gosper"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 221
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Gosper Curve, drawn with stack. mla, 2022.\n//\n// Inspired by https://www.shadertoy.com/view/cdsGRj by FabriceNeyret2\n//\n// Uses an explicit stack to keep track of the recursion.\n// This one keeps track of intermediate segments and avoids recursing far from\n// the point being plotted.\n//\n// Mouse down shows segments actually drawn around mouse position\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define C(turns,offset) (((turns) << 16) | ((offset) & 0xffff))\n// Each instruction is an integer number of turns, followed by\n// either an instruction offset for the recursive call or -1\n// to terminate the current level.\nconst int A = 0, B = 8, END = -1, L = -1, R = 1;\nconst int program[16] =\n  int[] (C(0,A),C(L,B),C(L+L,B),C(R,A), C(R+R,A),C(0,A),C(R,B),C(L,END),\n         C(R,A),C(L,B),C(0,B),C(L+L,B), C(L,A),C(R+R,A),C(R,B),C(0,END));\n\nconst float angle = PI/3.0;\nconst int maxdepth = 5;\n\nvec2 p = vec2(0);     // The drawing point\nvec2 point = vec2(100); // The moving point\nfloat plen = 0.0;     // Cumulative path length\n\nint wind = 0; // Compute winding number here\nvoid polywind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) wind++;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) wind--;\n  }\n}\n\nfloat drawsegment(vec2 pos, float seglen, float theta, float t) {\n  vec2 seg = seglen*vec2(cos(theta),sin(theta));\n  if (t >= plen && t < plen+seglen) point = p + (t-plen)/seglen*seg;\n  vec2 q = p + seg;\n  float d = segment(pos,p,q);\n  polywind(pos,p,q);\n  plen += seglen;\n  p = q;\n  return d;\n}\n\nfloat magic = 0.333473; // Segment rotation at each recursion level\n\nvec2 map(vec2 pos) {\n  pos = (2.0*pos - iResolution.xy)/iResolution.y;\n  pos -= vec2(0.5,0.8);\n  pos *= 1.6;\n  return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = map(fragCoord);\n  vec2 pos2 = (iMouse.z <= 0.0) ? pos : map(iMouse.xy);\n  int stack[maxdepth];\n  int depth = 0;\n  stack[depth++] = 0;\n  float t = mod(iTime,pow(7.0,0.5+0.5*float(maxdepth))); // Moving point\n  float d = 1e8;\n  float seglen = 1.0;\n  float theta = 0.0;    // Cumulative angle\n  while (depth > 0) {\n    int instr = program[stack[depth-1]++];\n    // Decode instruction\n    int turns = instr>>16;\n    int code = instr<<16>>16;\n    theta += float(turns)*angle; // Apply turn\n    if (code == END) {\n      depth--;    // Terminate level & unwind\n      seglen *= sqrt(7.0);\n    } else if (depth == maxdepth) {\n      d = min(d,drawsegment(pos,seglen,theta,t)); // Segment\n    } else {\n      // The segment is a diagonal of a hexagon off to the left or the right,\n      // so centre is at 30° to the segment, at distance radius of hexagon.\n      float offset = float(maxdepth-depth)*magic; // Segment angle adjustment\n      float sign = code == A ? -1.0 : 1.0;\n      float centreangle = sign*PI/6.0 - offset;\n      float radius = seglen/sqrt(3.0); // 0.5*seglen = radius*cos(30°)\n      vec2 centre = p + radius*vec2(cos(theta+centreangle),sin(theta+centreangle));\n      float bound = 1.1*radius; // 1.0 gives some artefacts, 1.05 seems OK. \n      // Press 'x' to compare old and new bounds\n      if (key(CHAR_X)) { centre = p; bound = 1.2*seglen; }\n      if (distance(pos2,centre) > bound) {\n        // Short circuit this segment\n        vec2 seg = seglen*vec2(cos(theta-offset),sin(theta-offset));\n        polywind(pos,p,p+seg);\n        // Show skipped segments on mouse down.\n        if (iMouse.z > 0.0) d = min(d,segment(pos,p,p+seg));\n        p += seg;\n        plen += seglen*pow(7.0,0.5*float(maxdepth-depth));\n      } else {\n        stack[depth++] = code;  // Recurse\n        seglen /= sqrt(7.0);\n      }\n    }\n  }\n  // Add a couple of lines going out of the frame so the winding\n  // number calculation is sensible.\n  vec2 border = vec2(0,100);\n  d = min(d,segment(pos,border,vec2(0)));\n  polywind(pos,border,vec2(0));\n  d = min(d,segment(pos,p,p-border));\n  polywind(pos,p,p-border);\n  float px = fwidth(pos.x);\n  vec3 col = vec3(smoothstep(0.0,px,d));\n  if ((wind&1) == 0) col.gb *= 0.25;\n  col = mix(vec3(0), col,smoothstep(0.0,px,distance(pos,point)-0.01));\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.1415926;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}