{
    "Shader": {
        "info": {
            "date": "1574565417",
            "description": "If sound doesnt load, select iChannel0 music by hand. E.g Most Geometric Person.\nI couldn't yet figure out how to calculat the overall amplitude.. the edge should flicker with overall amp. let me know if you know :)",
            "flags": 0,
            "hasliked": 0,
            "id": "wdGXzV",
            "likes": 8,
            "name": "Loudspeaker",
            "published": 3,
            "tags": [
                "sound",
                "sdf",
                "wireframe",
                "edge"
            ],
            "usePreview": 0,
            "username": "athlete",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "//raymarching code by iq\n//some of the sdf code by mercury\n//raymarched edge detection by https://www.shadertoy.com/view/MsB3W1\n//sound: painstakingly reverse engineered\n\n#define PI 3.1415926535\n#define EDGE_WIDTH 0.01\n#define wireframeColor vec3(.1, 0.7, 0.7)\n#define sky vec3(0.1, 0.1, 0.1)\n#define SHOW_EDGES\n\n////////////SCENE elements and helper functions\n\n//simple rotation\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius)\n{\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height)\n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r)\n{\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n////////////////////\n\nfloat fScrew(in vec3 pos, float radius)\n{\n    float s = fSphere(pos, radius);\n    \n    float flatten = fBox(pos, vec3(radius*0.8, radius*0.8, radius*0.8));\n    \n    float retVal = max(s, flatten);\n    \n    float cross1 = fBox(pos, vec3(radius*0.6, radius*.1, radius));\n    pR(pos.xy, PI*90.0/180.0);\n    float cross2 = fBox(pos, vec3(radius*0.6, radius*.1, radius));\n    \n\tfloat cross = min(cross1, cross2);\n    \n    return max(retVal, -cross);\n}\n\nfloat fWoofer(in vec3 pos, float bass)\n{\n    pR(pos.zy, PI*90.0/180.0);\n    pos.y += 1.0;\n    pos.z += 1.1;\n\tfloat torus = fTorus(pos, 0.1,.7);\n    pos.y += bass*0.05 -0.04;\n    float disc = fCylinder(pos, 0.67, 0.05);\n    \n    return fOpUnionRound(torus, disc, 0.1);\n}\n\nfloat fMidSpeaker(in vec3 pos, float mid)\n{    \n    pR(pos.zy, PI*90.0/180.0);\n    pos.y += .99;\n\tpos.z -= 0.25;\n\tfloat torus = fTorus(pos, 0.08, 0.4);\n    pos.y += mid*0.021;\n    float disc = fCylinder(pos, 0.35, 0.03);\n    \n    float res1 = fOpUnionRound(torus, disc, 0.05);\n    pos.y -= 0.07;\n    float sphere = fSphere(pos, 0.15);\n    \n    return min(res1, sphere);\n}\n\nfloat fTweeter(in vec3 pos, float high)\n{    \n    vec3 plateDim = vec3(0.35, 0.25, 0.03);\n    pos.y -= 1.2;\n    pos.z -= 1.01;\n    float plate = fBox(pos, plateDim);\n\n    float screw1 = fScrew(vec3(pos.x+0.28, pos.y+0.18, pos.z+0.001), 0.05);\n    float screw2 = fScrew(vec3(pos.x-0.28, pos.y+0.18, pos.z+0.001), 0.05);\n    float screw3 = fScrew(vec3(pos.x-0.28, pos.y-0.18, pos.z+0.001), 0.05);\n    float screw4 = fScrew(vec3(pos.x+0.28, pos.y-0.18, pos.z+0.001), 0.05);\n    \n    pos.z += 1.03;\n    pR(pos.zy, PI*90.0/180.0);\n    pos.y += 1.04+high*0.03;\n    float disc = fCylinder(pos, 0.2, 0.03);\n    pos.y -= 0.04;\n    float sphere = fSphere(pos, 0.1);\n\n    return min(sphere, min(plate, min(screw1, min(screw2, min(screw3, min(screw4, disc))))));\n}\n\nfloat map(in vec3 pos, float bass, float mid, float high)\n{   \n    //rotate camera around scene\n    float xAngle = 150.0*((iMouse.x-iResolution.x/2.0) /iResolution.x);\n    \n    pR(pos.zx, (PI*(xAngle+30.))/180.0);\n    \n    //create elements\n    float box = fBox(pos, vec3(1.0, 2.0, 1.0));\n    float woofer = fWoofer(pos, bass);\n    float midSpeaker = fMidSpeaker(pos, mid);\n    float tweeter = fTweeter(pos, high);\n    \n    //combine elements\n    float res = min(box, woofer);\n    res = min(res, midSpeaker);\n    res = min(res, tweeter);\n    \n    return res;\n}\n\n//calc gradient by looking at the local neighborhood\nvec3 calcNormal( in vec3 pos, float bass, float mid, float high )\n{\n\tvec3 nor;\n    \n    vec2 e = vec2(0.01, 0.0);\n    \n    nor.x = map(pos + e.xyy, bass, mid, high) - map(pos - e.xyy, bass, mid, high);\n    nor.y = map(pos + e.yxy, bass, mid, high) - map(pos - e.yxy, bass, mid, high);\n    nor.z = map(pos + e.yyx, bass, mid, high) - map(pos - e.yyx, bass, mid, high);\n    \n    return normalize(nor);\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd, float bass, float mid, float high)\n{\n    float res = 1.0;\n    float t = 0.1; //min t\n\tfor(int i=0; i<64; i++)\n    {\n    \tvec3 pos = ro + t*rd;\n        float h = map(pos, bass, mid, high);\n        res = min(res, h/t);\n        if(res< 0.001)\n            break;\n        \n        t += h;\n    }\n    \n    return res;\n}\n\nvec3 getWaveForm(in vec2 uv)\n{\n\t// second channel is the sound wave, one texel is one mono sample\n    float wave = texture( iChannel0, vec2(uv.x, 1.0)).x;\n    \n    vec3 col = vec3(0);\n    col += 1.0 -  smoothstep( 0.0, 0.1, abs(wave - uv.y) );\n    \n    return col;\n}\n\nvoid analyzeSound(vec2 uv, inout float amp, inout float bass, inout float mid, inout float high)\n{\n    //optimized for Experimental song as iChannel0\n    float RATE = 44100.0/4.0;\n    \n   \tfloat frequency = 500.0;\n    float freqAccess = (frequency/RATE);\n    mid = step(0.6, texture(iChannel0, vec2(freqAccess, 0.25)).x);\n    \n    frequency = 50.0;\n    freqAccess = (frequency/RATE);\n    bass = smoothstep(0.97, 0.99, texture(iChannel0, vec2(freqAccess, 0.25)).x);\n    \n    frequency = 12000.0;\n    freqAccess = (frequency/RATE);\n    high = smoothstep(0.2, 0.6, texture(iChannel0, vec2(freqAccess, 0.25)).x);\n    \n    amp = 0.0;\n    for (float i=0.0; i<512.0; i++)\n    {\n        amp += texture(iChannel0, vec2(i/512.0, 0.75)).y;\n    }\n    amp /= 512.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0 + 2.0*p; //move origin to center of screen\n    q.x *= 1.777; //make square pixels\n    \n    float mid = 0.0;\n    float bass = 0.0;\n    float high = 0.0;\n    float amp = 0.0;\n    analyzeSound(fragCoord, amp, bass, mid, high);\n    \n    //ray\n    vec3 ro = vec3(0.0, 0.3, 4.0); //camera origin\n    vec3 rd = normalize( vec3(q, -1.0) ); //camera view direction\n    \n    //init color.. 'sky'\n    vec3 col = vec3(sky.r+high*0.1, sky.g, sky.b);\n    col *= 1.0 - 0.9*rd.y; //gradient color\n    \n    //overlay waveform\n    col += getWaveForm(p);\n    \n    //used for wireframe:\n    float lastDistEval = 1e10;\n    float dist = 0.0;\n    bool edge = false;\n    \n    //marching\n    float detail = 0.0001;\n    float tmax = 5.0; //max view distance\n    float t = 0.0;//progress along the ray\n    //int maxMarches = 256;\n    for(int i=0; i<256; i++)\n    {\n    \tvec3 pos = ro + rd*t;\n        \n        float h = map(pos, bass, mid, high); //returns positive or negative value\n\n        //used for wireframe calc \n        #ifdef SHOW_EDGES\n        {\n            if (lastDistEval < (EDGE_WIDTH+amp*0.1) && h > lastDistEval + detail)\n            {    \n                edge = true;\n                break;\n            }\n\n            if (h < lastDistEval)\n                lastDistEval = h;\n        }\n        #endif\n        \n        if(h<detail || t>tmax) //clipping planes\n            break;\n        \n        t += h; //variable distance to object, faster but less accurate than using constant step width\n    }\n    \n    //color wireframe in special color and return\n    #ifdef SHOW_EDGES\n    if(edge)\n    {    \n        fragColor = vec4(wireframeColor, 1.0);\n        return;\n    }\n    #endif\n    \n    //define light\n    vec3 light = normalize(vec3(0.0, 0.5, 1.)); //light direction\n    \n    if(t<tmax) //we are inside the view frustum to render\n    {\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormal(pos, bass, mid, high);\n        \n        //ray march soft shadows\n        float sha = calcShadow(pos, light, bass, mid, high);\n        \n        //lighting:\n        float dif = clamp( dot( nor, light ), 0.0, 1.0 );\n        vec3 lig = vec3(1.0, 1.0, 1.0)* dif * 1.5 * sha;\n        //adding light\n        lig += vec3(0.2, 0.2, 0.2)*nor.y*1.5;\n        \n        vec3 material = edge ? wireframeColor : vec3(0.05, 0.05, 0.05);\n        material = mix(material, vec3(0.05, 0.05, 0.05), \n                       smoothstep(0.7, 0.9, nor.y));\n\t\t\n        col = lig * material;\n    }\n    \n    //moving color space in preparation for lighting .. gamma\n    col = sqrt(col);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}