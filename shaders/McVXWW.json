{
    "Shader": {
        "info": {
            "date": "1715206575",
            "description": "This is the sequel to Wug at TaCoS from 2023: https://www.shadertoy.com/view/DdlcRf, motivated by: https://www.shadertoy.com/view/3lsSzf\nThere will be different variants of composite wugs to compare language models for an illustration. Maybe also details:",
            "flags": 0,
            "hasliked": 0,
            "id": "McVXWW",
            "likes": 1,
            "name": "Wug at TaCoS 2024",
            "published": 3,
            "tags": [
                "raymarching",
                "wug"
            ],
            "usePreview": 0,
            "username": "jakel101",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "// Apache 2.0 licnese for this shader :)\n\n#define EPS 0.001\n\n\nmat2 rot2D( float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// root smooth minimum from @iq MIT license: https://www.shadertoy.com/view/DlVcW1\nfloat smin( float a, float b, float k )\n{\n    k *= 2.0;\n    float x = b-a;\n    return 0.5*( a+b-sqrt(x*x+k*k) );\n}\n\n// rounded cone by @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// capsule/stick/linesegment by @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// sphere from @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// solid angle from @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// pyramid from @iq MIT license: https://www.shadertoy.com/view/Xds3zN\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n\n// combine some primative shapes to get a 3D approximation of a Wug, including eyes and legs!\n// res.x is the distance, res.y is the material ID, eyes and legs is ID 1.0; body is 2.0;\nvec2 sdWug( vec3 p ) {\n    float dist = float(0.0);\n    float mat = 1.0;\n    \n    float height = 1.5;\n    float scale = 1.1;\n    \n    //body\n    float body = sdRoundCone(p, 0.7*height, 0.3*height, height);\n    vec3 pyramidPos1 = p;\n    pyramidPos1.xy *= rot2D(1.4);\n    pyramidPos1.x -= -height;\n    float pyramid1 = sdPyramid(pyramidPos1, scale*1.5);\n    \n    vec3 pyramidPos2 = p - vec3(-0.2,-.4,0.0);\n    \n    pyramidPos2.xy *= rot2D(-1.6);\n    \n    float pyramid2 = sdPyramid(pyramidPos2, scale*1.5);\n    float pyramids = smin(pyramid1, pyramid2, 0.1);\n    \n    body = smin(body, pyramids, 0.4);\n    \n    // eyes\n    vec3 eyePos = vec3(p.xy,abs(p.z)) - vec3(0.7, height-0.0, 0.4);\n    float eye = sdSphere(eyePos, .25*scale);\n    if (eye < body) mat = 2.0;\n    dist = min(body, eye);\n    \n    // legs\n    vec3 legPos = vec3(p.xy, abs(p.z)) - vec3(-0.3, -height-0.4, 0.5);\n    float leg = sdCapsule( legPos, vec3(0.0), vec3(0.0,0.6,-0.1), 0.1);\n    \n    float foot = sdCapsule( legPos, vec3(0.0), vec3(0.6, 0.0, 0.1), 0.1);\n    leg = smin(leg, foot, 0.05);\n    if (leg < dist) mat = 2.0;\n    dist = min(leg, dist);\n    \n    return vec2(dist, mat);\n}\n\n\nvec2 map( vec3 p ){\n    float dist = float(0.0);\n    float mat = 0.0;\n    \n    // ground is a plane just now\n    float groundHeight = 2.0;\n    float ground = p.y + groundHeight; \n    \n    vec3 wugPos = vec3(p);\n    // wugPos.z = 1.5 - mod(wugPos.z, 3.0); // <--- uncomment this line to get more of them!\n    vec2 wug = sdWug(wugPos);\n    dist = min(ground, wug.x);\n    \n    if (wug.x < ground) mat = wug.y; // if ground is closer than wug return wug material, else 0.0?\n    \n    return vec2(dist, mat);\n}\n\nvec3 calcNormal( in vec3 pos){\n    vec2 e = vec2(EPS, 0.0);\n    return normalize(vec3(  map(pos+ e.xyy).x - map(pos-e.xyy).x,\n                            map(pos+ e.yxy).x - map(pos-e.yxy).x,\n                            map(pos+ e.yyx).x - map(pos-e.yyx).x ) );\n}\n\n\nvec2 rayCast( in vec3 ro, in vec3 rd){\n    float t = 0.0;                          //total distance travelled\n    float m = -1.0; // base material ID -1.0 will be sky/miss\n    // Raymarching loop\n    int i;\n    for (i=0; i<=100; i++){\n        vec3 pos = ro + rd*t;                 // position along the ray\n        vec2 h = map(pos);             // \"hit\"? currennt distance to next object in the scene\n        m = h.y;\n        if (h.x < EPS) break;               // early stop near\n        t += h.x;                             // marching step\n        \n        if (t > 20.0) break;        // early stop far\n    }\n    if (t>20.0) m=-1.0;\n    \n    return vec2(t,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy * vec2(4.0,2.0) - iResolution.xy)/iResolution.y;\n    m.y -= 0.5;\n    // Initialize\n    vec3 ro = vec3(0.0, 0.0, 4.0);         // rayOrigin\n    vec3 rd = normalize(vec3(uv, -0.8));       // rayDirection, value changes fov\n    vec3 col = vec3(0.55,0.65,0.9) - 0.6*rd.y;           // sky color with gradient\n\n    // mouse control\n    if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){m.x=-.5,m.y=-.4;};//quick hack to detect no mouse input for thumbnail\n    m.x += iTime*0.25;\n    ro.yz *= rot2D(m.y);\n    rd.yz *= rot2D(m.y);\n    \n    ro.xz *= rot2D(m.x);\n    rd.xz *= rot2D(m.x);\n    \n    \n    vec2 res = rayCast(ro, rd);\n    float dist = res.x;\n    float mat = res.y;\n    \n    if (mat > -0.5){\n        vec3 pos = ro + rd*dist;\n        vec3 nor = calcNormal(pos);\n        vec3 material = vec3(0.03,0.18,0.03); // + 0.03*sin(rd.x); // base baterial, albedo low for floor\n        \n        if (mat > 0.5) // ID 1.0 = wug\n        {\n            material = vec3(0.1, 0.1, 0.9); \n        }\n        // should be else if, but I need to have the order correct\n        if (mat > 1.5) // ID 2.0 = eyes, legs\n        {\n            material = vec3(0.03); // near black\n        }\n        \n        \n        vec3 sun_dir = normalize(vec3(1.6, 1.2, 0.7));                   // sun direction\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0);             //diffused keylight?\n        float sun_sha = step(rayCast( pos+nor*EPS, sun_dir ).y, 0.0); \n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0); //diffused sky light, biased?\n        \n        col = material*vec3(1.0, 0.7, 0.5) * sun_dif * sun_sha;   // yellow sunlight\n        col += material*vec3(0.0, 0.2, 0.4) * sky_dif;  // blue skylight\n        \n    }\n    \n    col = pow ( col, vec3(0.4545)); // gamma space - which one?\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}