{
    "Shader": {
        "info": {
            "date": "1721027355",
            "description": "This is a variation of the 2-tap texture tiling breakup shader from Suslik. Playing around with some modifications and rewriting it, so I understand how it works.",
            "flags": 32,
            "hasliked": 0,
            "id": "4flcR4",
            "likes": 8,
            "name": "Phase Texture Variation (2-tap)",
            "published": 3,
            "tags": [
                "noise",
                "blending",
                "tiling",
                "texturing",
                "bombing",
                "stochastic",
                "variation",
                "texturebombing"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI rewrote Suslik’s shader (https://www.shadertoy.com/view/WdVGWG). \nThe purpose was to understand its inner workings and play around with modifications.\n\nThe shader employs a gradient to derive phases to layer two alternating textures on \ntop of each other. Their texture coordinates vary with each phase. Since the edges \nget hidden by the alternating phases, we don't need partial derivatives (DDX, DDY) \nto fix their broken edges. The gradient can be extremly simple and fast, so even \nrepeating sinus hills seem to be enough. \n\nPhase texture variation requires 2 texture samples, an noise sample is optional but\nnot needed. In contrast, stochastic cell texturing, typically used with hexagon \ngrids, necessitates 3 texture samples and 3 hash calls and often an additional \nnoise texture to disrubt visible grid. While the cell approach offers greater \nflexibility, allowing directional flow or different textures. However, when \npurely disrupting tiling, the phase method is more cost-effective, especially in \nproduction scenarios with multiple texture layers and additional textures per \nlayer like normals.\n\nSee the global constants to mess about with different settings and debug views.\nIt also has mouse countrols to zoom in and out. \n\nFor comparison, check out cell stochastic texturing examples:\nhttps://inria.hal.science/hal-01824773\nhttps://www.shadertoy.com/view/7dGfzR\n*/\n\n// How many phases of different texture orientation get layered (1-inf)\n#define PHASE_COUNT 9\n\n// Comment this to disable per phase rotation,so you don't need normal rotation\n#define ROTATION\n\n/* Change this to change texture variation, instead of \n0 = precentage of index / PHASE_COUNT (lol this works too?)\n1 = maximum consecutive differences\n2 = random value from a hash function */\n#define VARIATION 0\n\n// Enable this to enable histogram correction (+1 sample and overdoes it sometimes)\n// But height blend using lightness already kinda does this for almost free\n//#define HISTOGRAM_CORRECTION\n\n/* Change the type of noise controling the phases\n0 = No Noise, a straight line \n1 = Sine hills, very cheap wavy function\n2 = value Noise (from iChannel1)\n3 = perlin Noise (from Buffer A) */ \n#define NOISE_TYPE 1\n\n/* Switch SHOW_VALUES to enable different views\n0 = phase stochastic textures \n1 = 1, with different colored Phases\n2 = just different colored Phases\n3 = Weight values for the interpolation\n4 = Mip levels as colormap with a grid to see the texture size*/\n#define SHOW_VALUES 0\n\n// Generates 2 indexs and a weight from a gradient\n// See https://www.desmos.com/calculator/uypn8kggi6\nvec3 getIndexWeight(float gradient, float count) {\n    \n    // generate partial values for the caculation\n    vec2 phases = vec2(gradient * (count-1.0) * 0.5) + vec2(0.5,0.0);\n    vec2 id = floor(phases);\n    float gridB = phases.y - id.y;\n    \n    // Fold repeating weights for the number of steps\n    float weight = min(gridB, 1.0 - gridB) * 2.0;\n    \n    // add some contrast to the grid for nicer transitions\n    weight = smoothValue(weight);\n    \n    // generate unique indexs for each weight phase\n    vec2 indexes = id * 2.0 + vec2(0.0,1.0);\n    \n    // Return the two indexes then the weight\n    return vec3(indexes, weight);\n}\n\n// Caculates the maximum consecutive difference (I could come up with)\n// https://www.desmos.com/calculator/pf5mkgxi7t\n#define ONE_THIRD 1.0/3.0\nfloat maxDiff(float index, float count) {\n    float third = index * ONE_THIRD; // 1/2 looks fine too\n    return ceil(mod(third * count, count)) + floor(third);\n}\n\n// Rotate and Offset the UV using the index\nvec2 phaseUV(vec2 uv, float id, float count) {\n    \n    #if VARIATION == 0\n        // just the precentage of the id\n        vec2 precentage = vec2(id / count); \n    #elif VARIATION == 1\n        // The original code uses a hash to drive variation, which can lead to \n        // similar phases. Since we have a fixed number of phases and know the \n        // neighboring phases, let's maximize their differences. \n        float maxDiffIndex = maxDiff(id, count);\n        vec2 precentage = vec2(id, maxDiffIndex) / count;        \n    #else\n        // unique random vector per id\n        float seed = 6841.0; // must be larger than 0\n        vec2 precentage = hash21(id + seed);\n    #endif\n    \n    // add slight scale variation to the textures (in %)\n    float scaleVaritation = 0.3; // should probably be an input\n    uv *= (precentage.y - 0.5) * scaleVaritation + 1.0;\n    \n    // offset the coordinates\n    uv += precentage;\n    \n    #ifdef ROTATION\n        // use the evenly spread out ID precentage as angle\n        float angle = TWO_PI * precentage.y;\n        vec2 direction = vec2(sin(angle), cos(angle)); // use this to rotate normals\n\n        // Rotated coordinates (if you use normals they need to be rotated too)\n        uv = rotateUV(uv, direction); // rotation for coords, normals get rotated differently\n    #endif\n    \n    return uv;\n}\n\n// generates a random texturing using phases of a gradient noise\nvec3 phaseTexture(vec2 uv, float count) {   \n    // Sample noise gradient\n    #if NOISE_TYPE == 0\n        // generate a straight alternating gradient\n        float gradient = abs(fract(uv.x / count)-0.5)*2.0;\n        \n    #elif NOISE_TYPE == 1\n        // simple and fast wavy pattern\n        float gradient = sinHills(uv / count * 2.0);\n    \n    #elif NOISE_TYPE == 2    \n        // Scale noise by resolution and layer count \n        float noiseScale = 1./(256. * count) * 5.0;\n        \n        // sample a value noise texture with slightly smoother filtering\n        float gradient = bilinearFilter(iChannel1, uv * noiseScale);\n        \n    #elif NOISE_TYPE >= 3\n        // Scale noise by resolution and layer count \n        float noiseScale = 1./(128. * count) * 5.0;\n        \n        // Sample perlin noise texture\n        float gradient = texture(iChannel2, fract(uv * noiseScale + 0.5)).x;\n    #endif\n\n    // generate the phase index and weights\n    vec3 indexWeight = getIndexWeight(gradient, count);    \n    float weight = indexWeight.z;\n    vec2 indices = indexWeight.xy;\n\n    // generate unique offsets and rotations for each phase\n    vec2 uvA = phaseUV( uv, indices.x, count);\n    vec2 uvB = phaseUV( uv, indices.y, count);\n            \n    // Sample color textures\n    vec3 colorA = texture(iChannel0, uvA).xyz;\n    vec3 colorB = texture(iChannel0, uvB).xyz;\n\n    // Height blend with the same texture makes a kinda histogram preservation  \n    // and it always looks nice no matter the texture and is really cheap\n    // See: https://www.shadertoy.com/view/DtXfD7\n    vec2 lightness = vec2(RGBtoHSV(colorA).z, RGBtoHSV(colorB).z);\n    weight = straightHeightWeight(weight, lightness, 1.);\n    \n    // Debug views\n    #if SHOW_VALUES == 1 \n        // sample the average color from highest mip level\n        vec3 average = textureLod(iChannel0, vec2(0), 99.).xyz;\n\n        // merge rainbow and textures using color modulation\n        colorA = viridis(maxDiff(indices.x, count) / max(1.,count-1.)) + (colorA - average);\n        colorB = viridis(maxDiff(indices.y, count) / max(1.,count-1.)) + (colorB - average);\n        \n    #elif SHOW_VALUES == 2\n        // ignore textures and make colors a rainbow\n        colorA = viridis(maxDiff(indices.x, count) / max(1.,count-1.));\n        colorB = viridis(maxDiff(indices.y, count) / max(1.,count-1.));\n\n    #elif SHOW_VALUES == 4\n        // find the partial derivative for coords for AA blur\n        vec2 ddF = fwidth(uv);\n        float aa = max(ddF.x, ddF.y);\n        \n        // generate a line on outline of uv squares\n        vec2 lines = smoothstep(0.01-aa, 0.01+aa, abs(fract(uv)-0.5));\n        float grid = min(lines.x, lines.y);\n    \n        // Debug feature to show the mip level instead of textures\n        colorA = visualizeMips(iChannel0, uvA) * grid;\n        colorB = visualizeMips(iChannel0, uvB) * grid;\n    #endif\n    \n    // Interpolate color\n    vec3 color = mix(colorA, colorB, weight);\n    \n    #if SHOW_VALUES == 0\n    #ifdef HISTOGRAM_CORRECTION        \n        // sample the average color from highest mip level\n        vec3 average = textureLod(iChannel0, vec2(0), 99.).xyz;\n        \n        // Histogram Blend Correction published in https://hal.inria.fr/inria-00536064v2\n        color = clamp(average + (color - average) / \n                sqrt(weight*weight + (1.-weight)*(1.-weight)),0.,1.);\n    #endif\n    #endif\n        \n    #if SHOW_VALUES == 3\n        // Debug view of the weights using the best colormap\n        color = viridis(weight);\n    #endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    float zoom = 1.1;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with smoothsteps\n        float zoomSteps = 10.0;\n        float mouseZoom = (floor(mouse.y * zoomSteps) + \n                           smoothstep(0.75, 1.0, fract(mouse.y * zoomSteps))) \n                           / zoomSteps;\n        zoom = mix(50.0, 1.0, mouseZoom);\n        \n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(50.0, 2.0, cos(zoomTime) * 0.5 + 0.5);\n    }\n    \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;\n    \n    // sample phase stochastic textureing\n    vec3 color = phaseTexture(uv, float(PHASE_COUNT));\n        \n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERAL FUNCTIONS _____________________________________________________\n\n// Simplified Smoothstep https://www.desmos.com/calculator/un0o21eokv\nfloat smoothValue(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec2 smoothValue(vec2 x) {\n    x = clamp(x, 0.0, 1.0);\n    return x * x * (3.0 - 2.0 * x);\n}\n\n// slighly nicer texture filtering, useful when zooming in a lot\nfloat bilinearFilter(sampler2D tex, vec2 uv) {\n\n    // find the texture resolution\n    vec2 texSize = vec2(textureSize(tex, 0));\n\n    // generate texure coordinates\n    vec2 coords = uv * texSize - 0.5;\n    vec2 id = floor(coords); // cell id\n    vec2 weights = coords - id; // technically also the grid\n    \n    weights = smoothValue(weights); // nicer transitions\n\n    // sample the 4 corners of the texture\n    float a = texelFetch(tex, ivec2(mod(id, texSize)), 0).x;\n    float b = texelFetch(tex, ivec2(mod(id +vec2(1,0), texSize)), 0).x;\n    float c = texelFetch(tex, ivec2(mod(id +vec2(0,1), texSize)), 0).x;\n    float d = texelFetch(tex, ivec2(mod(id +vec2(1,1), texSize)), 0).x;\n\n    // bilinear interpolation between the 4 corners\n    return mix(mix(a, b, weights.x), mix(c, d, weights.x), weights.y);\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Offset weight with height bias by contrast\n// See https://www.desmos.com/calculator/gxhnhzu1cs\nfloat straightHeightWeight (float weight, vec2 heights, float contrast) {\n\n    // apply contrast with offset\n    float heightWeight = weight + contrast * (weight * heights.y - (1.-weight) * heights.x);\n\n    // Ensure the final weight value is clamped to the range [0, 1]\n    return clamp(heightWeight, 0.0, 1.0);\n}\n\n// Converts an RGB color to an HSV color\nvec3 RGBtoHSV(vec3 rgbColor) {\n    // Constants for the conversion process\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    \n    // Determine the minimum and maximum values between the colors\n    vec4 p = mix(vec4(rgbColor.bg, K.wz), vec4(rgbColor.gb, K.xy), step(rgbColor.b, rgbColor.g));\n    vec4 q = mix(vec4(p.xyw, rgbColor.r), vec4(rgbColor.r, p.yzx), step(p.x, rgbColor.r));\n    float d = q.x - min(q.w, q.y);\n    \n    // Small constant to avoid division by zero\n    float e = 1.0e-10;\n    \n    // Calculate the HSV values\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// NOISE FUNCTIONS _________________________________________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define FPRIME 2800852409U\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n    return vec2(q) * SMALLESTFLOAT;\n}\n\nfloat hash12(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tuint n = (q.x & q.y) * FPRIME;\n\treturn float(n) * SMALLESTFLOAT;\n}\n\nvec2 hash21(float p) {\n\tuvec2 n = uint(int(p)) * VPRIME1;\n\tn = (n.x ^ n.y) * VPRIME2;\n\treturn vec2(n) * SMALLESTFLOAT;\n}\n\n// Sinus hill tiling mask, which is faster than a texture lookup\n#define TWO_PI 6.28318530718\nfloat sinHills(vec2 uv) {\n    vec2 d = sin(uv * TWO_PI); // Remove pi-sized grid\n    return (d.x + d.y) * 0.25 + 0.5; // Add and rescale to 0-1\n}\n\n// DEBUG FUNCTIONS __________________________________________________________\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    const vec3 c0 = vec3(0.503560,-0.002932,1.000009);\n    const vec3 c1 = vec3(-1.294985,3.144463,0.001872);\n    const vec3 c2 = vec3(-16.971202,0.031355,-1.232219);\n    const vec3 c3 = vec3(97.134102,-5.180126,-0.029721);\n    const vec3 c4 = vec3(-172.585487,-0.338714,0.316782);\n    const vec3 c5 = vec3(131.971426,3.514534,-0.061568);\n    const vec3 c6 = vec3(-37.784412,-1.171512,0.003376);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Function to calculate the highest mip level based on texture size\nfloat getHighestMipLevel (vec2 texSize) {\n    // Find the maximum dimension of the texture\n    float maxDimension = max(texSize.x, texSize.y);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension) + 1.;\n\n    // Return the highest mip level\n    return highestMipLevel;\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\n// Based on Unreal Engines ComputeMipLevel Material Function \nvec2 getMipLevel(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = duvdx * texSize;\n    vec2 scaledDDY = duvdy * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Calculate the highest possible mip level for the texture\n    float maxMipLevel = getHighestMipLevel(texSize);\n\n    // Clamp the mip level between 0 and the maximum mip level\n    mipLevel = clamp(mipLevel, 0.0, maxMipLevel);\n\n    // Return both the mip level and the maximum mip level\n    return vec2(mipLevel, maxMipLevel);\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\nvec2 getMipLevel(sampler2D sam, vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    // Caculate Mip level\n    return getMipLevel(sam, uv, duvdx, duvdy);\n}\n\n// Visualizes Mip level based on UV coordinates and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv);\n\n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// NOISE BUFFER ___________________________________________________\n\n// Helper Function for Perlin noise\nfloat rndGradient(vec2 grid, vec2 id, vec2 offset, uint gridsize, uvec2 seed) {\n\n    // Current cell coordinates\n    vec2 cell = id + offset;\n\n    // This makes the noise repeat between positions 0 and 1\n    cell = mod(cell, float(gridsize));    \n\n    // Generate a random offset for the current cell\n    vec2 randomOffset = hash22(cell + vec2(seed)) *2.-1.;\n    \n    // generate random gradient    \n    return dot(grid - offset, randomOffset);\n}\n\n// Function to generate Perlin 2D noise\nfloat perlin(vec2 position, uint gridsize, uvec2 seed) {\n\n    // Scale the position by the grid size\n    position *= float(gridsize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 id = floor(position.xy); // Integer coordinates\n    vec2 grid = position.xy - id; // Fractional coordinates    \n    \n    // Sample noise at the corners\n    float a = rndGradient(grid, id, vec2(0,0), gridsize, seed);\n    float b = rndGradient(grid, id, vec2(1,0), gridsize, seed);\n    float c = rndGradient(grid, id, vec2(0,1), gridsize, seed);\n    float d = rndGradient(grid, id, vec2(1,1), gridsize, seed);\n    \n    // generate weight values\n    vec2 weights = smoothValue(grid); // for some contrast\n    \n    // Bilinear interpolation between the corner values\n    float result = mix(mix(a, b, weights.x),  mix(c, d, weights.x), weights.y);\n    \n    // rescale result to 0-1\n    return result *0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // sample the buffer itself\n    vec4 previousFrame = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // translate the current resolution to a hash\n    float hash = hash12(iResolution.xy);\n        \n    // check if the resolution changed, to not caculate more than needed\n    if (abs(previousFrame.y - hash) < 0.0001) {\n    \n        // Use the previously computed result to save performance\n        fragColor = previousFrame;   \n        \n    } else {        \n        // 0-1 normalized coordinates to sample the buffer\n        vec2 uv = fragCoord / iResolution.xy;\n    \n        // Interpolate both sides of the tennis ball mapping\n        uint gridsize = uint(128);\n        float noise = perlin(uv, gridsize, uvec2(421));\n\n        // Artistic increase of the variance, so the noise is not so gray\n        vec2 bounds = vec2(0.3, 0.7);\n        noise = clamp((noise - bounds.x) / (bounds.y - bounds.x), 0.0,1.0);\n                \n        fragColor = vec4(noise, hash, 0, 1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}