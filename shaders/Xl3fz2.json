{
    "Shader": {
        "info": {
            "date": "1540216072",
            "description": "use mouse on slider 3/6 4/6 6/6\nthis may add to intuitive modification of \nhttps://www.shadertoy.com/view/4t3Bz2\nhttps://www.shadertoy.com/view/XsScD1",
            "flags": 32,
            "hasliked": 0,
            "id": "Xl3fz2",
            "likes": 5,
            "name": "galois ellipse bezier chebreyev",
            "published": 3,
            "tags": [
                "bezier",
                "quadratic",
                "ellipse",
                "galois",
                "chebreyev"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 514
        },
        "renderpass": [
            {
                "code": "//parent      : https://www.shadertoy.com/view/4t3Bz2\n//grand parent: https://www.shadertoy.com/view/XsScD1\n\n//i broke the parent shaders slightly\n//, and the remaining code better viasualizes its inherent quadratics:\n\n//slider 4/6 sets interpolates between euclidean and Chebyshev_distance\n//                     https://en.wikipedia.org/wiki/Chebyshev_distance\n//         where \"Chebyshev\" deformse to cubic bezier \n//         where \"eulidean\" deforms to ellipse, by .xy scaling of 2 other sliders:\n//slider 3/6 sets .y of an ellipse/bezier\n//slider 6/6 sets .x of an ellipse/bezier\n//slider 5/6 sets ??? nothing within this degeneration\n//slider 1/6 sets a color offset (translates into hue offset)\n//slider 2/6 sets a color scale  (translates into hue scale)\n\n\n// MODE 0: trilinear-golden-rainbow mix of modes [1..3]\n// MODE 1: Rainbow\n// MODE 2: Greyscale\n// MODE 3: Just the zeros of the equation\n// MODE 4: Just the zeros of the equation, smoothstepped\n#define RENDER_MODE 0\n\n/*\ntodo:\n- remove sliders a and b (top 2/6)\n- ,and represent the other 4 sliders by iMouse\n*/\n\n// For a Galios field, [nef] must be a prime\n// (or prime power). This ensures that multiplicative\n// inverses exist for all non-zero elements\nconst float nef = 1./3.;\nconst int numEl = 97;\nconst float numElf = float(numEl);\n\n// shoutouts to the amazing tool at\n//   http://dev.thi.ng/gradients/\n// for generating these color palettes\nvec3 color(float t)\n{\n    vec3 a = vec3(0.500, 0.500, 0.500);\n    vec3 b = vec3(0.508, 0.508, 0.500);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n    \n    vec3 ret = a + b * cos(2.0 * 3.14159 * (c * t + d));\n    return clamp(ret, 0.0, 1.0);\n}\n\nfloat absCircular(float t)\n{\n    float a = floor(t + 0.5);\n    return mod(abs(a - t), 1.0);\n}\n\nint m(int x)\n{\n\tint n = x/numEl;\n    return x - n * numEl;\n}\n\nint funcInt(int x, int y\n){\n    int a =int(numElf * (texture(iChannel0, vec2(0.5, 1.0/6.0 - 1.0/12.0))).x);\n    int b =int(numElf * (texture(iChannel0, vec2(0.5, 2.0/6.0 - 1.0/12.0))).x);\n    int c =int(numElf * (texture(iChannel0, vec2(0.5, 3.0/6.0 - 1.0/12.0))).x);\n    int d =int(numElf * (texture(iChannel0, vec2(0.5, 4.0/6.0 - 1.0/12.0))).x);\n    int e =int(numElf * (texture(iChannel0, vec2(0.5, 5.0/6.0 - 1.0/12.0))).x);\n    int f =int(numElf * (texture(iChannel0, vec2(0.5, 6.0/6.0 - 1.0/12.0))).x);\n    \n    return m(a*x*x + b*x + c*x*y + d*y*y + e*y + f);\n}\n\n\n// This was going to be used to show the difference between the Gallios \n// field and the real-valued function of the same equation, but I couldn't\n// get it to look nice. If you want to take a crack at it, be my guest.\nfloat funcReal(float x, float y\n){float a=numElf*texture(iChannel0, vec2(.5,1./6.-1./12.0)).x\n ;float b=numElf*texture(iChannel0, vec2(.5,2./6.-1./12.0)).x\n ;float c=numElf*texture(iChannel0, vec2(.5,3./6.-1./12.0)).x\n ;float d=numElf*texture(iChannel0, vec2(.5,4./6.-1./12.0)).x\n ;float e=numElf*texture(iChannel0, vec2(.5,5./6.-1./12.0)).x\n ;float f=numElf*texture(iChannel0, vec2(.5,6./6.-1./12.0)).x\n ;return 2.0* mod(a*x*x + b*x + c*x*y + d*y*y + e*y + f, numElf) \n  //  /length( vec2( 2.0*a*x + b*y + d, 2.0*c*y + b*x + e ) ) \n  //normalization at this point is a bad idea (bad timing)\n ;}\n\n\n//i fail to make sense of this, find no GOOD utility.\n//other then creating some NANs by dividing by a [length of 0]\nfloat funcRealNorm(float x, float y\n){float a = numElf * texture(iChannel0, vec2(0.5, 1.0/6.0 - 1.0/12.0)).x\n ;float b = numElf * texture(iChannel0, vec2(0.5, 2.0/6.0 - 1.0/12.0)).x\n ;float c = numElf * texture(iChannel0, vec2(0.5, 3.0/6.0 - 1.0/12.0)).x\n ;float d = numElf * texture(iChannel0, vec2(0.5, 4.0/6.0 - 1.0/12.0)).x\n ;float e = numElf * texture(iChannel0, vec2(0.5, 5.0/6.0 - 1.0/12.0)).x\n ;float f = numElf * texture(iChannel0, vec2(0.5, 6.0/6.0 - 1.0/12.0)).x\n ;return 2.*mod(a*x*x +b*x+c*x*y +  d*y*y +e*y + f,numElf) \n / length(vec2(2.*a*x +b*y+d    ,2.*c*y  +b*x + e))\n ;}\n\n\n\nvec3 drawFunction(vec2 p\n){vec3 r\n  ;float x = (p.x * numElf)\n  ;float y = (p.y * numElf)\n  ;float f=0.\n  ;int ass =int((x)*numElf)\n  ;int hole=int((y)*numElf)\n  ;f-=float(funcInt(ass,hole)) //optional rasterized      //fast\n  ;//f-=      (funcReal   (floor(x),floor(y)))//optional rasterized real //slow\n  ;//f-=      (funcReal   (     (x),     (y)))//optional            real \n  ;//f+=((funcRealNorm(     (x),     (y))))//optional NAN creator (nonsense?)\n  ;//f=abs((fract(f)))\n  ;float diff = float(f) / numElf\n  ;r=.5+.5*cos(iTime*vec3(1,.61,1.61))//aperiodic golden rainbow\n  ;//ass= smoothstep(256.,0.,float(f))\n  ;if(RENDER_MODE==0)\n   r= mix(vec3(mix(1.-diff    ,smoothstep(256.,0. ,float(f)     ),r.y))\n          ,    mix(color(diff),vec3(mix(0.,1.,step(float(f),0.))),r.x)\n                                                                 ,r.z)//trilinear by [golden rainbow]\n  ;else{\n   ;if      (RENDER_MODE==1)r=color(diff)\n   ;else if (RENDER_MODE==3)r=vec3(mix(0.,1.,step(float(f),0.)))\n   ;else if (RENDER_MODE==2)r=vec3(diff)\n   ;else if (RENDER_MODE==4)r=vec3(ass)  //vec3(mix(0.,1.,ass))\n  ;}\n  ;return r;\n}\n\nvec3 drawSidebar(vec2 p\n){p.x-=1.\n ;p.x*=iResolution.y / iResolution.x\n ;float t=texture(iChannel0,p).x\n ;vec3 r=vec3(0.85)\n ;r=mix(color(1.),r,pow(smoothstep(0.,.004,absCircular(p.x - t)),3.))//lines red\n ;r=mix(color(.4),r,pow(smoothstep(0.,.04 ,absCircular(p.y*6.0)),3.))//lines blue\n ;return r;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat frameWidth = iResolution.y / numElf;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec3 final = vec3(0,0,0);\n    \n    if (uv.x > 1.0)\n        final = drawSidebar(uv);\n    else\n        final = drawFunction(uv);\n    \n\tfragColor = vec4(final,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat final = texture(iChannel0, fragCoord.xy / iResolution.xy).x;\n    \n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.y;\n    mouse.x -= 1.0;\n    mouse.x *= iResolution.y / iResolution.x;\n    \n    float sliderNumMouse = floor(mouse.y * 6.0);\n    float sliderNumUV = floor(uv.y * 6.0);\n    if (mouse.x >= 0.0 && sliderNumMouse == sliderNumUV)\n    {\n        final = mouse.x;\n    }\n    \n    final = clamp(final, 0.0, 1.0);\n    \n    fragColor = vec4(final);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}