{
    "Shader": {
        "info": {
            "date": "1608951332",
            "description": "Inspired by: Some scene in some underrated anime I don't remember.\nDoes it look ok with the flares?",
            "flags": 32,
            "hasliked": 0,
            "id": "tt3cDH",
            "likes": 22,
            "name": "Some Star Towers",
            "published": 3,
            "tags": [
                "sdf",
                "stars",
                "atmosphere",
                "anamorphic",
                "fallingstars"
            ],
            "usePreview": 1,
            "username": "TheNosiriN",
            "viewed": 791
        },
        "renderpass": [
            {
                "code": "#define RES iResolution.xy\n\n\n\nfloat NoiseSeed;\nvec3 filmgrain(){\n    NoiseSeed = fract(sin(NoiseSeed) * 84522.13219145687);\n    return vec3(0.9 + NoiseSeed*0.15);\n}\n\n//anamorphic-ish flares from: https://www.shadertoy.com/view/MlsfRl\nvec3 flares(sampler2D tex, vec2 uv, float threshold, float intensity, float stretch, float brightness)\n{\n    threshold = 1.0 - threshold;\n    \n    vec3 hdr = texture(tex, uv).rgb;\n    hdr = vec3(floor(threshold+pow(hdr.r, 1.0)));\n    \n    float d = intensity; //200.;\n    float c = intensity*stretch; //100.;\n    \n    //horizontal\n    for (float i=c; i>-1.0; i--){\n        float texL = texture(tex, uv+vec2(i/d, 0.0)).r;\n        float texR = texture(tex, uv-vec2(i/d, 0.0)).r;\n        hdr += floor(threshold+pow(max(texL,texR), 4.0))*(1.0-i/c);\n    }\n    \n    hdr *= vec3(0.369,0.200,0.620); //tint\n\treturn hdr*brightness;\n}\n\n\n\n//Single pass mip map bloom: https://www.shadertoy.com/view/Ms2Xz3\nconst float Threshold = 0.2;\nconst float Intensity = 2.0;\nconst float BlurSize = 1.0;\n\nvec3 mipMapBloom(vec3 Screen, in sampler2D Tex, in vec2 Coord, in float MipBias)\n{\n\tvec2 TexelSize = MipBias/iChannelResolution[0].xy;\n    \n    vec3  Color = texture(Tex, Coord, MipBias).rgb;\n    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias).rgb;    \n\n    Color = Color/9.0;\n    vec3 Highlight = clamp(Color-Threshold,0.0,1.0)*1.0/(1.0-Threshold);\n    return 1.0-(1.0-Screen)*saturate(1.0-Highlight*Intensity);\n}\n\n\n\nfloat SCurve (float value, float amount, float correction){\n\tfloat curve = 1.0; \n    if (value < 0.5){ curve = pow(value, amount) * pow(2.0, amount) * 0.5; }   \n    else{ curve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; }\n    return pow(curve, correction);\n}\nvec3 contrast(vec3 color)\n{\n    return saturate(vec3(\n        SCurve(color.r, 3.0, 1.0), \n        SCurve(color.g, 4.0, 0.7), \n        SCurve(color.b, 2.6, 0.6)\n    ));\n}\n\n\n\nvec3 margins(vec3 color, vec2 uv, float marginSize)\n{\n    if(uv.y < marginSize || uv.y > 1.0-marginSize)\n    {\n        return vec3(0.0);\n    }else{\n        return color;\n    }\n}\n\n\n\n//from: https://www.shadertoy.com/view/4l2GWm\nvec3 quincunxAA(sampler2D tex, vec2 fragCoord, float blur)\n{\n\tvec3 pixelColor;\n\tpixelColor =  texture(tex, (fragCoord + vec2( 0.0, 0.0)) / RES).rgb / 2.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur, blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur, blur)) / RES).rgb / 8.0;\n\treturn pixelColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = quincunxAA(iChannel0, fragCoord, 0.5);\n    float dist = texture(iChannel0, uv).a;\n    \n    color += contrast(flares(iChannel0, uv, 1.0, 200.0, 0.1, 0.02) * (dist*dist));\n    color = mipMapBloom(color+(color*dist), iChannel0, uv, BlurSize);\n    color *= filmgrain();\n    \n    color = margins(color, uv, 0.1);\n    \n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415972\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvec3 min3(vec3 a, vec3 b){\n    return min(a.z, b.z) == a.z ? a : b;\n}\n\nvec3 max3(vec3 a, vec3 b){\n    return max(a.z, b.z) == a.z ? a : b;\n}\n\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\n\n\n\n\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\nfloat boundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat cube(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat column(vec3 p, float l, float r)\n{\n    p.y -= l;\n    float r2 = r*2.0;\n    float r12 = (r+r2)/2.0;\n    float cb = cube(vec3(p.x, p.y+(r/2.0), p.z), vec3(r2, r12/2.0, r2));\n    cb = max(cb, -(length(vec3(p.x-r12, p.y+r12, p.z-r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x+r12, p.y+r12, p.z-r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x-r12, p.y+r12, p.z+r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x+r12, p.y+r12, p.z+r12))-(r2/1.25)) );\n    \n    float cy = sdCylinder(p, vec3(0.0), vec3(0.0,-l,0.0), r);\n    //cy = max(cy, -boundingBox(vec3(p.x, p.y+l/2.0, p.z), vec3(r/1.25, l/2.0, r/1.25), 0.25));\n    \n    cb = min(cb, cy)-0.1;\n    \n    return cb;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int MAX_MARCHING_STEPS = 256;\nconst int MAX_SHADOW_STEPS = 32;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 2000.0;\nconst vec3 MIN_VEC = vec3(vec2(0.0), MIN_DIST);\nconst vec3 MAX_VEC = vec3(vec2(0.0), MAX_DIST);\nconst float EPSILON = 0.001;\n\nconst vec3 SUN_DIR = normalize(vec3(0.0, 0.03, 0.5));\n\n\n\n\n\n//atmosphere from: https://www.shadertoy.com/view/wllyW4\n#define PLANET_RADIUS     6371e3\n#define ATMOSPHERE_HEIGHT 100e3\n#define RAYLEIGH_HEIGHT   8e3\n#define MIE_HEIGHT        1.2e3\n#define OZONE_PEAK_LEVEL  30e3\n#define OZONE_FALLOFF     3e3\n\n#define BETA_RAY   vec3(3.8e-6, 13.5e-6, 33.1e-6) // vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define BETA_MIE   vec3(21e-6)\n#define BETA_OZONE vec3(2.04e-5, 4.97e-5, 1.95e-6)\n#define G          0.75\n\n#define SAMPLES          3\n#define LIGHT_SAMPLES    2\n\n\n#define SUN_ILLUMINANCE   128000.0\n#define MOON_ILLUMINANCE  0.32\n#define SPACE_ILLUMINANCE 0.01\n\nconst float ATMOSPHERE_RADIUS = PLANET_RADIUS + ATMOSPHERE_HEIGHT;\n\nvec2 raySphereIntersect(in vec3 origin, in vec3 dir, in float radius) {\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0 * dot(dir, origin);\n\tfloat c = dot(origin, origin) - (radius * radius);\n\tfloat d = (b * b) - 4.0 * a * c;\n    \n\tif(d < 0.0)return vec2(1.0, -1.0);\n\treturn vec2(\n\t\t(-b - sqrt(d)) / (2.0 * a),\n\t\t(-b + sqrt(d)) / (2.0 * a)\n\t);\n}\n\nfloat phaseR(in float cosTheta) {\n    return (3.0 * (1.0 + cosTheta * cosTheta)) / (16.0 * PI);\n}\nfloat phaseM(in float cosTheta, in float g) {\n\tfloat gg = g * g;\n\treturn (1.0 - gg) / (4.0 * PI * pow(1.0 + gg - 2.0 * g * cosTheta, 1.5));\n}\n\nvec3 avgDensities(in vec3 pos) {\n\tfloat height = length(pos) - PLANET_RADIUS; // Height above surface\n\tvec3 density;\n\tdensity.x = exp(-height / RAYLEIGH_HEIGHT);\n\tdensity.y = exp(-height / MIE_HEIGHT);\n    density.z = (1.0 / cosh((OZONE_PEAK_LEVEL - height) / OZONE_FALLOFF)) * density.x; // Ozone absorption scales with rayleigh\n    return density;\n}\nvec3 atmosphere(\n\tin vec3 pos,\n\tin vec3 dir,\n\tin vec3 lightDir\n) {\n\t// Intersect the atmosphere\n    vec2 intersect = raySphereIntersect(pos, dir, ATMOSPHERE_RADIUS);\n\n\tvec3 opticalDepth = vec3(0.0);\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    \n    float rayPos = max(0.0, intersect.x);\n    float maxLen = ATMOSPHERE_HEIGHT;\n    maxLen *= (1.0 - abs(dir.y) * 0.5);\n\tfloat stepSize = min(intersect.y - rayPos, maxLen) / float(SAMPLES);\n    rayPos += stepSize * 0.5;\n    \n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 samplePos = pos + dir * rayPos;\n\n\t\tvec2 lightIntersect = raySphereIntersect(samplePos, lightDir, ATMOSPHERE_RADIUS);\n\n        vec3 lightOpticalDepth = vec3(0.0);\n        float lightStep = lightIntersect.y / float(LIGHT_SAMPLES);\n        float lightRayPos = lightStep * 0.5;\n        \n        for(int j = 0; j < LIGHT_SAMPLES; j++) {\n            vec3 lightSamplePos = samplePos + lightDir * (lightRayPos);\n\n\t\t\tlightOpticalDepth += avgDensities(lightSamplePos) * lightStep;\n\n            lightRayPos += lightStep;\n        }\n\n\t\tvec3 densities = avgDensities(samplePos) * stepSize;\n\t\topticalDepth += densities;\n\n\t\tvec3 scattered = exp(-(BETA_RAY * (opticalDepth.x + lightOpticalDepth.x) + BETA_MIE * (opticalDepth.y + lightOpticalDepth.y) + BETA_OZONE * (opticalDepth.z + lightOpticalDepth.z)));\n        sumR += scattered * densities.x;\n        sumM += scattered * densities.y;\n\n        rayPos += stepSize;\n    }\n\n    float cosTheta = dot(dir, lightDir);\n    \n    return max(\n        phaseR(cosTheta)    * BETA_RAY * sumR + // Rayleigh color\n       \tphaseM(cosTheta, G) * BETA_MIE * sumM,  // Mie color\n    \t0.0\n    );\n}\nvec3 renderBlackbody(in vec3 dir, in vec3 lightDir) {\n    float cosTheta = dot(dir, lightDir);\n    \n    float intensity = smoothstep(0.998, 0.999, cosTheta);\n    float glow = pow(max(cosTheta, 0.0), 4.0) * 0.01;\n\t\n    float fade = smoothstep(0.05, 0.25, dir.y);\n    float glowFade = smoothstep(0.05, 0.25, lightDir.y);\n    \n    return vec3(intensity + glow * glowFade) * fade;\n}\n\n\n\n\n\n\n#define M3 mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\n#define M2 mat2(0.8,-0.6,0.6,0.8)\nvec4 getHashTex(vec2 p)\n{\n    //return fract(cos(P*mat2(-64.2,71.3,81.4,-29.8))*8321.3); \n    return textureLod(iChannel0, p/256.0, 0.0);\n}\nfloat noiseTex( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = getHashTex(uv+0.5).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fbm21Tex(vec2 p)\n{\n\tfloat f = 0.0;\n    f += 0.5000 * noiseTex( vec3(p,0.0) ); p = M2*p*2.02;\n    f += 0.2500 * noiseTex( vec3(p,0.0) ); p = M2*p*2.03;\n    f += 0.1250 * noiseTex( vec3(p,0.0) ); p = M2*p*2.01;\n    f += 0.0625 * noiseTex( vec3(p,0.0) );\n    return (f/0.9375) *2.0 -1.0;\n}\n\n\nfloat pMod(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nvec3 scene(vec3 p)\n{\n    p.z += iTime*50.0;\n    \n    vec3 d = MAX_VEC;\n    float n = fbm21Tex(p.xz*0.025);\n    d = min3(d, vec3(.0,n, \n        p.y + n*7.0\n    ));\n    \n    \n    vec3 cp = p;\n    cp.z -= 400.0;\n    float c = pMod(cp.z, 400.0);\n    cp.x += mod(c, 2.0) == 0.0 ? 60.0 : -30.0;\n    \n    cp.y += 10.0;\n    d = min3(d, vec3(.0,.0, column(cp, 50.0, 4.0)));\n    d = min3(d, vec3(1.,.0, length(vec3(cp.x,cp.y-57.0,cp.z)) - 4.0));\n    \n    vec3 cbp = p;\n    cbp.y -= 10.0;\n    return d;\n}\n\n\nvec3 raymarch(vec3 eye, vec3 dir)\n{\n    vec3 depth = MIN_VEC;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = eye + dir * depth.z;\n        \n        vec3 dist = scene(p);\n        if (dist.z < EPSILON * length(p)) {\n\t\t\treturn vec3(dist.xy, depth.z);\n        }\n        depth.z += dist.z * (dist.z/(MAX_DIST) + 1.0);\n        if (depth.z > MAX_DIST) {\n            return MAX_VEC;\n        }\n    }\n    return MAX_VEC;\n}\n\n\n\n\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * 0.01;\n\n \treturn normalize(\n        scene(p+P.xyy).z * \n        P.xyy + scene(p+P.yxy).z * \n        P.yxy + scene(p+P.yyx).z * \n        P.yyx + scene(p+P.xxx).z * \n        P.xxx\n    );\n}\n\n\n\n\n\n\n\nfloat shadow(in vec3 eye, in vec3 dir) {\n    float res = 1.0;\n    float t = EPSILON;\n    float ph = 1e10;\n        \n    for( int i=0; i<MAX_SHADOW_STEPS && t < MAX_DIST; i++ )\n    {\n     \tvec3 p = eye + dir * t;\n        float h = scene(p).z;\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        \n        t += h;\n    }\n\n    return res;\n}\n\n\n\n\n\nvec3 compose(vec3 eye, vec3 dir, vec3 info)\n{\n    vec3 color = vec3(0.0);\n    vec3 p = eye + dir * info.z;\n    \n    if (info.x == 1.0){ return vec3(1.0); }\n    \n    vec3 n = normal(p);\n    \n    color = n;//vec3(0.5);\n    \n    float shade = saturate(dot(n, SUN_DIR));\n    if (shade > 0.0){\n        //shade *= shadow(p, SUN_DIR);\n    }\n    \n    color *= shade;\n    \n    return saturate(color);\n}\n\n\n\n\n\n// https://www.shadertoy.com/view/Xs2BRc\nfloat Cell(vec2 c) {\n    vec2 uv = fract(c);\n    uv.y -= 0.5;\n    c -= uv;\n    return (1.0 - length(uv)) * step(fract( sin(c.x + c.y*100.0) *1000.0), 0.01);\n}\nvec3 stars(vec3 dir, float time)\n{\n    vec2 ndir = dir.xy * rotate(-45.0);\n    ndir.x += 1.0;\n    ndir.y += 0.5;\n    float projX = fract(ndir.x) / 1.;\n    float projY = pow(ndir.y, 0.05);\n    vec3 color;\n    \n    time -= 0.02;\n    vec2 coord = vec2(projY, projX)*256.0;\n    vec2 delta = vec2(time*7.0, 0.0);\n    float c = Cell(coord -= delta);\n    c += Cell(coord -= delta);\n    color += c;\n    \n    \n    vec3 t = color;\n    return saturate(t) * smoothstep(0.05, 0.3, dir.y);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    //vec3 eye = rotateCamera(200.0, iMouse.xy/iResolution.xy, iMouse); //uncomment this\n    \n    float time = iTime;\n    \n    float tt = sin(time)+cos(-time)*0.5;\n    vec3 eye = vec3(10.0, 20.0, -200.0) + tt;\n    vec3 lookAt = vec3(0.0, 20.0, 0.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(35.0, iResolution.xy, fragCoord);\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    worldDir.xy = worldDir.xy * rotate(-tt * 1.25);\n    \n    vec3 col = vec3(0);\n    \n    \n    float sundot = saturate(dot(worldDir,SUN_DIR));\n    vec3 atm = atmosphere(vec3(eye.x, eye.y+PLANET_RADIUS, eye.z), worldDir, SUN_DIR) * sundot;\n    \n    \n    vec3 dist = raymarch(eye, worldDir);\n    if (dist.z > MAX_DIST-EPSILON)\n    {\n        // sky\t\n        col = atm;\n        vec3 body = renderBlackbody(worldDir, SUN_DIR);// + (sundot*0.2);\n        col += body + stars(worldDir, -time*0.05);\n    }else{\n        vec3 p = eye + worldDir*dist.z;\n        col += saturate((dist.z*1.2)/MAX_DIST) + compose(eye, worldDir, dist);\n        col *= saturate(atm + (dist.x == 1.0 ? 10.0 : 0.0));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,dist.z/MAX_DIST);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}