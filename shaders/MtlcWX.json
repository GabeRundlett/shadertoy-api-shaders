{
    "Shader": {
        "info": {
            "date": "1506747946",
            "description": "Function to render a 2D cartesian coordinate grid and some shapes on it, as a base for further diagram shaders.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtlcWX",
            "likes": 29,
            "name": "Cartesian Grid",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "grid",
                "diagram"
            ],
            "usePreview": 0,
            "username": "Reedbeta",
            "viewed": 1863
        },
        "renderpass": [
            {
                "code": "vec2 rotate(vec2 v, float angle)\n{\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat distLineSeg(vec2 a, vec2 b, vec2 pos)\n{\n    float proj = dot(pos - a, b - a) / dot(b - a, b - a);\n    vec2 posNearest = mix(a, b, clamp(proj, 0.0, 1.0));\n    return length(pos - posNearest);\n}\n\nvoid renderLineSeg(vec2 a, vec2 b, vec3 color, float thickness, vec2 pos, inout vec3 fragColor)\n{\n    stroke(distLineSeg(a, b, pos), color, fragColor, thickness, length(fwidth(pos)));\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderATriangle(vec2 pos, inout vec3 fragColor)\n{\n    float dist = sdistTri(vec2(0.6, 0.4),\n                          vec2(1.1, 0.9),\n                          vec2(0.75, 0.95), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.005, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.3 - vec2((1.3*aspect - 1.0)/2.0, 0.15);\n\n    // animate the grid a bit to test antialiasing\n    pos = vec2(0.5) + rotate(pos - vec2(0.5), cos(iTime) * 0.1 - 0.05) *\n        \t\t\t\t(sin(iTime) * 0.1 + 1.0);\n    pos.y -= 0.1 * sin(iTime);\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n\n    renderATriangle(pos, fragColor.rgb);\n\n    renderAxes(vec2(0), pos, fragColor.rgb);\n    renderAxes(vec2(1, 0), pos, fragColor.rgb);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}