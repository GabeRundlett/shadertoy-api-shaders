{
    "Shader": {
        "info": {
            "date": "1695118003",
            "description": "Perhaps the ancients discovered the Hilbert curve first (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "mscyWM",
            "likes": 33,
            "name": "Ziggurat of Hilbert",
            "published": 3,
            "tags": [
                "fractal",
                "architecture",
                "babylon"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 347
        },
        "renderpass": [
            {
                "code": "// \"Ziggurat of Hilbert\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nvec3 HsvToRgb (vec3 c);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst int nBall = 41;\nvec3 bPos[nBall], pNeb[2], sunDir, qHit;\nvec2 gId, gIdL, csFlor;\nfloat tCur, dstFar, hbSize, wexSize, hInd, cHt, bRad, vFac, iQuad, hFac;\nint nFrame, idObj, ballNum;\nconst int idPil = 1, idWal = 2, idRamp = 3, idPyr = 4, idWalEx = 5, idGrnd = 6, idBall = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nint HilXy2D (ivec2 p, int n)\n{ // (Hilbert indexing from \"Hilbert's Path\" - with bit ops)\n  ivec2 r;\n  int j, td, d;\n  d = 0;\n  td = 1;\n  for (j = n >> 1; j > 1; j >>= 1) td <<= 1;\n  for (j = n >> 1; j >= 1; j >>= 1) {\n    r = (p / td) & 1;\n    d += j * j * ((r.y == 0) ? 3 * r.x : (3 * r.x) ^ 1);\n    if (r.y == 0) {\n      if (r.x != 0) p = n - 1 - p;\n      p = p.yx;\n    }\n    td >>= 1;\n  }\n  return d;\n}\n\nivec2 HilD2Xy (int d, int n)\n{\n  ivec2 p, r;\n  int j, td;\n  td = d;\n  p = ivec2 (0);\n  for (j = 1; j < n; j <<= 1) {\n    r.x = (td >> 1) & 1;\n    r.y = ((r.x == 0) ? td : td ^ 1) & 1;\n    if (r.y == 0) {\n      if (r.x != 0) p = j - 1 - p;\n      p = p.yx;\n    }\n    p += j * r;\n    td >>= 2;\n  }\n  return p;\n}\n\n#define HT(v) 4. * hFac * (1. - Maxv2 (abs ((v) / hbSize - 1.)))\n\nvoid SetGParm ()\n{\n  vec2 gIdLL, g;\n  float bb, iq, hi;\n  int ic, ib;\n  ib = int (hbSize);\n  gIdL = gId;\n  iQuad = step (hbSize, gIdL.x) + 2. * step (hbSize, gIdL.y);\n  if (gIdL.x >= hbSize) gIdL.x -= hbSize;\n  if (gIdL.y >= hbSize) gIdL.y -= hbSize;\n  gIdLL = gIdL;\n  if (iQuad < 2.) gIdLL.y = hbSize - 1. - gIdLL.y;\n  ic = HilXy2D (ivec2 (gIdLL), ib);\n  hInd = float (ic) + iQuad * hbSize * hbSize;\n  if (iQuad < 2.) hInd = 2. * hbSize * hbSize - 1. - hInd;\n  cHt = HT (gId + 0.5);\n  bb = hbSize * hbSize;\n  for (int k = 0; k < 2; k ++) {\n    hi = mod (hInd + 1e-3 + sign (float (k) - 0.5), 4. * bb);\n    iq = step (bb, abs (hi - 2. * bb)) + 2. * step (2. * bb, hi);\n    ic = int (mod (mod (hi, bb) * ((iq == 0. || iq == 3.) ? 1. : -1.), bb));\n    g = (vec2 (HilD2Xy (ic, ib)) + 0.5) * vec2 ((iq == 1. || iq == 3.) ? 1. : -1.,\n       (iq == 2. || iq == 3.) ? 1. : -1.);\n    pNeb[k].xz = g - (gId + 0.5) + hbSize;\n    pNeb[k].y = HT (pNeb[k].xz + gId + 0.5);\n  }\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, qq, ds;\n  float dMin, d, h, hf, sx;\n  dMin = dstFar;\n  p.y -= 0.7;\n  if (Minv2 (gIdL) >= 0. && Maxv2 (gIdL) < hbSize) {\n    q = p;\n    hf = dot (vec2 (q.y, - Maxv2 (abs (q.xz - hbSize)) + hbSize), csFlor) + 0.3;\n    d = abs (hf) - 0.05;\n    DMINQ (idPyr);\n    q = p;\n    q.xz -= hbSize * vec2 (step (abs (abs (iQuad - 2.) - 1.), 0.), step (2., iQuad)) + gIdL + 0.5;\n    if (iQuad < 2.) q.z *= -1.;\n    d = max (SmoothMax (PrBox2Df (q.xz, vec2 (0.2)), q.y - cHt - 0.2, 0.01), - hf);\n    DMINQ (idPil);\n    qq = q;\n    qq.y -= 0.07;\n    q = qq;\n    d = min (PrBox2Df (q.xz - 0.5 * pNeb[0].xz * vec2 (1., sign (iQuad - 1.5)), vec2 (0.2)),\n       PrBox2Df (q.xz - 0.5 * pNeb[1].xz * vec2 (1., sign (iQuad - 1.5)), vec2 (0.2)));\n    d = max (SmoothMax (hf - 0.2, SmoothMax (- PrBox2Df (q.xz, vec2 (0.45)), - d, 0.01), 0.01), - hf);\n    DMINQ (idWal);\n    for (int k = 0; k < 2; k ++) {\n      ds = vec3 (pNeb[k].xz * vec2 (1., sign (iQuad - 1.5)), pNeb[k].y + cHt + 0.05).xzy;\n      q = qq - 0.5 * ds;\n      q.xz = mix (q.xz, q.zx, step (abs (ds.z), abs (ds.x)));\n      sx = (abs (ds.x) > abs (ds.z)) ? sign (ds.x) : sign (ds.z);\n      d = SmoothMax (PrBox2Df (q.xz, vec2 (0.1, 0.3)), - dot (q.yz, CosSin (atan (pNeb[k].y - cHt,\n         -0.55 * sx))) * sx - 0.01, 0.01);\n      d = max (SmoothMax (d, 0.23 - length (vec2 (abs (q.z) + 0.12, max (q.y + 0.4, 0.))),\n         0.01), - hf);\n      DMINQ (idRamp);\n    }\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  float dHit, d, s, sb, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 1e-4;\n  if (rd.z == 0.) rd.z = 1e-4;\n  rdi.xz = 1. / rd.xz;\n  eps = 0.002;\n  cNu = true;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    if (cNu) {\n      gId = floor (p.xz);\n      sb = Minv2 ((gId + step (0., rd.xz) - ro.xz) * rdi.xz);\n      SetGParm ();\n      cNu = false;\n    }\n    d = GObjDf (p);\n    s = max (dHit, sb);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 2e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = floor (p.xz);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGParm ();\n    }\n    h = GObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - vec3 (vec2 (hbSize), 0.15).xzy;\n  q.xz = mix (q.xz, q.zx, step (abs (q.z), abs (q.x)));\n  d = SmoothMax (PrBox2Df (vec2 (q.x, abs (q.z) - (hbSize + 0.1)), vec2 (hbSize + 4.1, 0.1)),\n     abs (q.y) - 0.35, 0.02);\n  DMINQ (idWalEx);\n  q.y -= 0.65;\n  d = SmoothMax (PrBox2Df (vec2 (q.x, abs (q.z) - wexSize), vec2 (wexSize + 0.2, 0.2)),\n     abs (q.y) - 1., 0.02);\n  if (abs (q.x) < wexSize - 0.5) d = SmoothMax (d, min (0.5 - length (vec2 (abs (fract (q.x +\n     0.5) - 0.5) + 0.2, max (q.y - 0.2, 0.))), q.y + 0.7), 0.02);\n  DMINQ (idWalEx);\n  q = p;\n  q.xz -= vec2 (hbSize);\n  d = q.y;\n  DMINQ (idGrnd);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 2e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvoid BPos ()\n{  // (from \"Looping Hilbertian Saltation\")\n  vec3 bp[2];\n  vec2 g;\n  float tc, t, bb, iq;\n  int ib, ic;\n  ib = int (hbSize);\n  bb = hbSize * hbSize;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    tc = 1e-3 + vFac * tCur + (float (k) / float (nBall)) * 4. * bb;\n    for (int j = 0; j < 2; j ++) {\n      t = mod (tc + float (j), 4. * bb);\n      iq = step (bb, abs (t - 2. * bb)) + 2. * step (2. * bb, t);\n      ic = int (mod (mod (t, bb) * ((iq == 0. || iq == 3.) ? 1. : -1.), bb));\n      g = (vec2 (HilD2Xy (ic, ib)) + 0.5) * vec2 ((iq == 1. || iq == 3.) ? 1. : -1.,\n         (iq == 2. || iq == 3.) ? 1. : -1.);\n      bp[j].xz = g + hbSize;\n      bp[j].y = HT (bp[j].xz) + 0.7;\n    }\n    t = clamp (1.3 * fract (tc) - 0.15, 0., 1.);\n    bPos[k] = mix (bp[0], bp[1], t);\n    bPos[k].y += bRad + 0.2 + 2. * t * (1. - t);\n  }\n}\n\nvec4 BallHit (vec3 ro, vec3 rd)\n{\n  vec3 u, vn;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - bPos[k];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + bRad * bRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vn = (u + d * rd) / bRad;\n        ballNum = k;\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec3 u;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - bPos[k];\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + bRad * bRad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return 0.5 + 0.5 * smoothstep (0., rng, dMin);\n}\n\nfloat BlkHitSil (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec3 BallCol (int k)\n{\n  return HsvToRgb (vec3 (fract (4. * float (k) / float (nBall)), 0.7, 1.));\n}\n\nfloat GrndHt (vec2 p)\n{\n  float s, h;\n  s = PrBox2Df (qHit.xz, vec2 (wexSize));\n  h = (s < 0.) ? 0.03 * (0.5 - 0.5 * sin (8. * pi * s)) :  0.2 * Fbm2 (0.05 * p);\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = 0.7 * (0.8 + 0.5 * ff) * (vec3 (1.) - vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  sd = max (dot (rd, sunDir), 0.);\n  fd = smoothstep (0.01, 0.1, rd.y);\n  skCol = mix (vec3 (0.8, 0.8, 0.75), vec3 (0.3, 0.4, 0.7), 0.3 + 0.7 * fd) +\n     step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n  col = mix (skCol, clCol, 0.1 + 0.9 * f * fd);\n  return 0.9 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitG;\n  vec2 b, vf;\n  float dstObj, dstObjG, db, s, sh;\n  int idObjG;\n  hFac = (hbSize == 8.) ? 1.5 : 1.;\n  csFlor = CosSin (- ((hbSize == 4.) ? 0.24 : 0.2) * pi);\n  vFac = 0.5;\n  bRad = 0.2;\n  BPos ();\n  db = BlkHitSil (ro - vec3 (vec2 (hbSize), 2.5 * hFac + 0.7).xzy, rd, vec3 (vec2 (hbSize + 0.2),\n     2.7 * hFac).xzy);\n  if (db < dstFar) {\n    dstObjG = GObjRay (ro, rd);\n    idObjG = idObj;\n    qHitG = qHit;\n    db4 = BallHit (ro, rd);\n  } else {\n    dstObjG = dstFar;\n    db4.x = dstFar;\n  }\n  dstObj = ObjRay (ro, rd);\n  if (min (db4.x, dstObjG)  < min (dstObj, dstFar)) {\n    if (db4.x < dstObjG) {\n      dstObj = db4.x;\n      idObj = idBall + ballNum;\n    } else {\n      dstObj = dstObjG;\n      idObj = idObjG;\n      qHit = qHitG;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjG) {\n      vn = GObjNf (ro);\n    } else if (idObj < idBall) {\n      vn = (idObj == idGrnd) ? GrndNf (ro) : ObjNf (ro);\n    } else {\n      vn = db4.yzw;\n    }\n    vf = vec2 (0.);\n    if (idObj == idPil) {\n      col4 = vec4 (1., 1., 1., 0.1);\n      s = length (qHit.xz);\n      if (s < 0.2) col4 *= 0.93 + 0.07 * sin (32. * pi * s);\n    } else if (idObj == idRamp) {\n      col4 = vec4 (0.95, 1., 0.95, 0.1);\n      if (vn.y > 0.99) col4 *= 0.8 + 0.2 * smoothstep (0.07, 0.1, abs (fract (16. * qHit.z) - 0.5));\n      else if (vn.y > 0.1) col4 *= 0.8 + 0.2 * smoothstep (0.07, 0.1, abs (fract (16. * qHit.y) - 0.5));\n    } else if (idObj == idWal) {\n      col4 = 0.9 * vec4 (1., 0.95, 0.95, 0.1);\n    } else if (idObj == idWalEx) {\n      col4 = 0.9 * vec4 (1., 0.95, 0.95, 0.1);\n      vf = vec2 (16., 0.5);\n    } else if (idObj == idPyr) {\n      col4 = 0.8 * vec4 (1., 1., 0.9, 0.1);\n      vf = vec2 (32., 0.3);\n    } else if (idObj == idGrnd) {\n      col4 = 0.9 * vec4 (1., 1., 0.8, 0.);\n      s = PrBox2Df (qHit.xz, vec2 (wexSize));\n      col4 *= 1. - 0.07 * ((s < 0.) ? (0.5 - 0.5 * sin (8. * pi * s)) : Fbm2 (0.05 * ro.xz));\n      vf = vec2 (8., 0.5);\n      col4 *= 1. - 0.1 * Fbm2 (16. * ro.xz);\n    } else if (idObj >= idBall) {\n      col4 = vec4 (BallCol (idObj - idBall), -1.);\n    }\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      sh = min (min (GObjSShadow (ro + 0.01 * vn, sunDir), ObjSShadow (ro + 0.01 * vn, sunDir)),\n         BallHitSh (ro + 0.01 * vn, sunDir, 8.));\n      col = col4.rgb * (0.15 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.7 * sh * max (dot (vn, sunDir), 0.)) +\n        col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    } else col = col4.rgb * (0.4 + 0.6 * max (- dot (vn, rd), 0.));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    col = 0.9 * vec3 (1., 1., 0.8) * (0.15 + 0.7 * sunDir.y);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    col *= 1. - 0.15 * smoothstep (0.5, 0.7, Fbm2 (0.05 * ro.xz - 0.05 * tCur));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  zmFac = 5.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    zmFac += smoothstep (0.2, 0.5, abs (az)) * min (4. * abs (az), 4.);\n    el = pi * mPtr.y;\n  }\n  el -= 0.12 * pi;\n  el = clamp (el, -0.5 * pi, -0.03 * pi);\n  vuMat = StdVuMat (el, az);\n  hbSize = 8.; //4.;\n  wexSize = hbSize + 4.;\n  ro = vuMat * vec3 (0., 0.5, -6. * hbSize);\n  ro.xz += hbSize;\n  ro.y = max (ro.y, 0.1);\n  dstFar = 300.;\n  sunDir = normalize (vec3 (0.8, 0.9, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}