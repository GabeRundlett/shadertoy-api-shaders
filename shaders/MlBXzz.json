{
    "Shader": {
        "info": {
            "date": "1441034815",
            "description": "a small raymarch",
            "flags": 0,
            "hasliked": 0,
            "id": "MlBXzz",
            "likes": 6,
            "name": "Squirmy cube",
            "published": 3,
            "tags": [
                "raymarch",
                "cube",
                "squirmy"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 565
        },
        "renderpass": [
            {
                "code": "//Ethan Shulman 2015\n\n#define FOV_SCALE .5\n#define ITERATIONS 86\n#define EPSILON .04\n#define NORMAL_EPSILON .04\n\n#define VIEW_DISTANCE 90.\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness;\n};\n    \n    \nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n    \n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nfloat ground(in vec3 rp) {\n    return -rp.y+10.;\n}\nfloat whirlcube(in vec3 rp) {\n    vec3 rotp = rp;\n    rotp.xy = rot(rp.xy,length(rp)*.12 + iTime*.05);\n    rotp.xz = rot(rp.xz,1.-length(rotp.xy)*.06 + iTime*.2);\n    vec3 lp = mod(abs(rotp),vec3(4.))-vec3(2.);\n    float outerBounds = sdBox(rp,vec3(6.))-.6;\n    /*outerBounds = max(-(length(abs(rotp)-vec3(5.))-3.),\n                      outerBounds);\n    */\n    return max(outerBounds,\n               length(lp)-2.);\n}\nfloat whirlcube_marks(in vec3 rp) {\n    vec3 rotp = rp;\n    rotp.xy = rot(rp.xy,length(rp)*.12 + iTime*.3);\n    rotp.xz = rot(rp.xz,1.-length(rotp.xy)*.06 + iTime*.5);\n    vec3 lp = mod(abs(rotp),vec3(4.))-vec3(2.);\n    float outerBounds = sdBox(rp,vec3(6.))-.6;\n   /* outerBounds = max(-(length(abs(rotp)-vec3(5.))-3.),\n                      outerBounds);\n    */\n    return max(outerBounds,\n               length(lp)-2.)-textureProj(iChannel0,rotp).x*.35;\n}\n\nfloat df(in vec3 rp) {\n\n    return min(ground(rp),whirlcube(rp));\n}\nfloat df_hq(in vec3 rp) {\n\n    return min(ground(rp),whirlcube_marks(rp));\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\n\nmaterial mat(vec3 rp) {\n    material m;\n    \n    if (whirlcube(rp) < EPSILON) {\n        \n        vec3 rotp = rp;\n        rotp.xy = rot(rp.xy,length(rp)*.12 + iTime*.2);\n        rotp.xz = rot(rp.xz,1.-length(rotp.xy)*.06 + iTime*.5);\n        float inp = cos(cos(rotp.x) + cos(rotp.y) + cos(rotp.z) + (rp.x+rp.z) + iTime*.3);\n        inp = inp/2.+.5;\n        \n        m = material(mix(vec3(1.),vec3(.4,.2,.3),inp), //diffuse\n                     mix(vec3(.8),vec3(.8,.7,.65),inp), //specular\n                     mix(vec3(0.),vec3(0.),inp), //emissive\n                     mix(0.1,.8,inp),//metallic\n                     mix(.9,.2,inp));//roughness\n    }\n    \n    if (ground(rp) < EPSILON) {\n        m = material(vec3(1.), //diffuse\n                     vec3(1.), //specular\n                     vec3(0.), //emissive\n                     .8,//metallic\n                     0.2);//roughness\n    }\n    \n    return m;\n}\n\n//rp = ray pos\n//rd = ray dir\n//maxDist = max trace distance\n//returns -1 if nothing is hit\nfloat trace(in vec3 rp, in vec3 rd, float maxDist) {\n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        sh += max(0.,min(s,penumbraSize)-d);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh);\n}\n\nvec3 background(in vec3 rd) {\n    return mix(\n        mix(vec3(.14),vec3(.3,.16,.13),clamp(rd.y-rd.x+rd.z,0.,1.)),\n        \tvec3(.6,.34,.55), max(0.,dot(rd,normalize(vec3(1.,1.,1.)))));//rd*.5+.5;\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 td = rp-rd*EPSILON*2.0;\n    \n    //lighting\n    vec3 dlc = vec3(.2);//ambient\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    vec3 globalLightDir = normalize(vec3(1.,5.,3.));\n    vec3 globalLightColor = vec3(.9,.8,.9)*softShadowTrace(td,-globalLightDir,48.,0.4,0.1);\n    \n    dlc += max(0.,dot(-globalLightDir,norm))*globalLightColor;\n\n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tm.emissive ;\n}\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 td = rp-rd*EPSILON*2.0;\n    \n    //lighting\n    vec3 dlc = vec3(.2);//ambient\n    vec3 slc;\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    float rtd = trace(td,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = td+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    \n    \n    vec3 globalLightDir = normalize(vec3(1.,5.,3.));\n    vec3 globalLightColor = vec3(.9,.8,.9)*softShadowTrace(td,-globalLightDir,48.,0.4,0.1);\n    \n    dlc += max(0.,dot(-globalLightDir,norm))*globalLightColor;\n    slc += pow(max(0., dot(globalLightDir,reflDir)),(1.-m.roughness)*64.+4.)*globalLightColor;\n    \n    float fres = m.metallic + (1.-m.metallic)*(1.-max(0., dot(-rd,norm)));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*(.5+m.metallic*.5)*fres +\n        \tm.emissive ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n    \n    vec2 mxy = (iMouse.xy/iResolution.xy)*6.28;\n    \n    cameraLocation = vec3(mxy,5.);\n    cameraRotation = vec2(mxy.x,mxy.y/4.-1.6);//x = yaw ,   y = pitch\n\n\n    vec3 rp = vec3(0.,0.,-45.);\n    vec3 rd = normalize(vec3(uv,1.));\n    //vec3(10.,10.,10.);\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n\n    rp.yz = rot(rp.yz,cameraRotation.y);\n    rp.xz = rot(rp.xz,cameraRotation.x);\n    \n    \n    \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    fragColor = vec4(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}