{
    "Shader": {
        "info": {
            "date": "1722286291",
            "description": "Another ray tracing, but much faster than the others!\nCame for fibonacci? Look in common",
            "flags": 0,
            "hasliked": 0,
            "id": "lcjcRD",
            "likes": 6,
            "name": "Another ray tracing, but faster!",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "cornell",
                "optimization",
                "fibonacci",
                "graphics",
                "cgi"
            ],
            "usePreview": 0,
            "username": "Ric3cir121",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "/*\n    This is an attempt at making a fast ray tracing algorithm,\n    it's not necessarily better than others, and maybe not even faster.\n    Sadly, this is slower than my previous attempt, but it can run faster\n    with some new settings.\n    \n    This attempt is much more readable with many of the variables\n    and functions using longer and more understandable names.\n    \n    I'm looking forward to add a few more optimizations,\n    such as temporal antialiasing, and some stuff from restir gi.\n    \n    What I'm trying to add: https://www.youtube.com/watch?v=gsZiJeaMO48\n    My previous attempt: https://www.shadertoy.com/view/mtsGW8\n    Origin of this cornell box: https://www.shadertoy.com/view/mdX3Wn\n\n    !! Go to common to tweak the settings.\n\n    The scene and the distance functions are generally located in \"Common\".\n    The engine can be found in the buffers and the image.\n    \n    Feel free to contribute to this code, and to use it anywhere in any way!\n*/\n\nvec3 getCamera(vec2 mouse){\n    vec2 rotator = (mouse.xy*2.-iResolution.xy)/min(iResolution.x,iResolution.y)*0.5*PI*vec2(-1,1);\n    if(iMouse.xy == vec2(0)) rotator = vec2(0);\n    return vec3(rotator,0);\n}\nvec3 getStartingPosition(vec3 camera){\n    return rotate3(normalize(vec3(0,0,1)),-camera)*-15.*1.+vec3(0,10.,0)*0.;\n}\nvec3 getRay(vec2 coord, float fov, vec3 camera){\n    vec2 cameraSpace = (coord*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 startingPosition = rotate3(normalize(vec3(0,0,1)),-camera)*-15.*1.+vec3(0,10.,0)*0.;\n    \n    // the formula for the fov may not be correct\n    vec3 ray = normalize(vec3(cameraSpace,tan((.5-fov/360.)*PI)));\n    return rotate3(ray,-camera);\n}\n\nvoid moveToNearest(inout vec3 position, inout vec3 ray, inout Object nearest){\n    position += nearest.Distance*ray;\n    ray = nearest.direction;\n    position += nearest.normal*sign(dot(nearest.normal,ray))*0.025;\n}\n\n#if useSamples == 1\nstruct Bucket{\n    vec3 direction;\n    float weight;\n    float bestScore;\n};\n\nfloat getScore(vec3 position, vec3 ray, inout Object nearest){\n    moveToNearest(position, ray, nearest);\n    Object near = findNearest(position, ray, true);\n\n    return dot(near.color+near.emittedColor,vec3(1))+.01;\n    return 1.;\n}\n#endif\n\nvec3 position;\nvec3 ray;\nvec3 render(vec2 coord){\n    // this is the core of the rendering engine!\n    fibonacciUsed = false;\n    \n    vec3 position = position;\n    vec3 ray = ray;\n    \n    vec3 color = vec3(0);\n    vec3 multipliedColor = vec3(1);\n    float percentageMultiplier = 1.;\n    \n    for(renderIteration=0.; renderIteration<float(reflections); renderIteration++){\n        Object nearest = findNearest(position, ray, false);\n        getDirection(nearest, position, ray);\n        \n#if useSamples == 1\n        if(nearest.color != vec3(0) && renderIteration<float(sampleUntilIteration)\n        && nearest.material.value > .25){\n            /*\n                Took three ages to get this working properly.\n                It just tries multiple rays and chooses the best.\n                As of now it doesn't seem to work right, I can't pin point\n                where the issue is, or if it's even worth to do this.\n            */\n            float bestScore = getScore(position, ray, nearest);\n            Bucket bucket = Bucket(nearest.direction, bestScore, bestScore);\n            for(int j=0; j<samplesPerIteration-1; j++){\n                getDirection(nearest, position, ray);\n                \n                float score = getScore(position, ray, nearest);\n                if(rand(.995)*(bucket.weight+score) > bucket.weight){\n                    bucket.direction = nearest.direction;\n                    bucket.bestScore = score;\n                }\n                bucket.weight += score;\n            }\n            nearest.direction = bucket.direction;\n            percentageMultiplier *= (bucket.weight/float(samplesPerIteration))/bucket.bestScore;\n        }\n#endif\n\n        color += multipliedColor * nearest.emittedColor * percentageMultiplier;\n        if(nearest.color == vec3(0))break;\n        multipliedColor *= nearest.color;\n        \n        moveToNearest(position, ray, nearest);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 coord){\n    vec3 color = vec3(0);\n\n    vec3 camera = getCamera(iMouse.xy);\n    float fov = 53.1;\n    \n    position = getStartingPosition(camera);\n\n#if randomness == NONE && frameRandomness == 1\n    commonIFrame = fract(float(iFrame)/1600.);\n#endif\n    \n#if randomness == RANDOM && frameRandomness == 0\n    seed = fract(dot(cos(vec3(coord,renderId))*10.38149,vec3(1)))*100.;\n#elif randomness == RANDOM\n    seed = fract(dot(cos(vec4(iFrame,coord,renderId))*10.38149,vec4(1)))*100.;\n#endif\n\n    for(renderId=0.; renderId<float(rendersPerPixel); renderId++){\n#if randomness == QUADS && frameRandomness == 0\n        seed = fract(cos(renderId)*10.38149);\n        vec2 cluster = floor(coord/quadSize+vec2(rand(.996),rand(.997))*float(scatterQuads));\n        seed = fract(dot(cos(vec3(cluster,renderId))*10.38149,vec3(1)));\n#elif randomness == QUADS\n        seed = fract(dot(cos(vec2(iFrame,renderId))*10.38149,vec2(1)));\n        vec2 cluster = floor(coord/quadSize+vec2(rand(.996),rand(.997))*float(scatterQuads));\n        seed = fract(dot(cos(vec4(iFrame,cluster,renderId))*10.38149,vec4(1)));\n#endif\n        vec2 randCoord = coord+vec2(rand(.998),rand(.999))-.5;\n        ray = getRay(randCoord, fov, camera);\n        color += render(randCoord)/float(rendersPerPixel);\n    }\n    \n    fragColor = vec4(color, 0);\n    fragColor = pow(fragColor/6.,1./vec4(2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    Settings may or may not be fully explained\n    \n    This project is limited to the local memory of the shader, being able\n    to import textures or objects may help.\n    \n    Try:\n        `rendersPerPixel` to 2000,\n        `randomness` to NONE,\n        `useSamples` to 0,\n        `useFibonacciSphere` to 1,\n        `useScatterInFibonacci` to 0 (or leave it to `(randomness==RANDOM)`),\n        to get a fully rendered scene without any noise\n    \n    Try:\n        `rendersPerPixel` to 20,\n        `randomness` to RANDOM,\n        `useSamples` to 0,\n        `useFibonacciSphere` to 1,\n        `useScatterInFibonacci` to 1 (or leave it to `(randomness==RANDOM)`),\n        to get a scene that renders pretty fast, but with some noise\n*/\n\n/*\n    > Basics\n    \n*/\n#define reflections 10\n#define rendersPerPixel 5\n \n/*\n    > Resampled Importance Sampling (i think) settings\n    \n    Multiple samples may be biased but shouldn't, needs testing.\n    Using samples is also slower and not worth as of now.\n*/\n#define useSamples 0\n#define samplesPerIteration 16\n#define sampleUntilIteration 1\n\n/*\n    > Randomness settings\n\n    `randomness`: NONE is fast, QUADS is medium, RANDOM is slower.\n    NONE and QUADS give around a 60% higher frame rate than RANDOM.\n    \n    Setting `frameRandomness` to 0 is faster, and looks cool with `randomness` to NONE.\n    \n    Setting `scatterQuads` to false will increase the frame rate,\n    due to alignments on the gpu, but it looks worse, and may\n    be better just to go with NONE instead.\n*/\n#define NONE 0\n#define QUADS 1\n#define RANDOM 2\n\n#define randomness RANDOM\n#define frameRandomness 1\n#define quadSize 16.\n#define scatterQuads true\n\n/*\n    > Fibonacci settings\n    \n    It is generally worth to keep this on, as it doesn't slow down\n    much the render, and increases the quality a bit.\n    \n    `useScatterInFibonacci` changes the position of a point randomly\n    by a bit, considering using it with `randomness` set to RANDOM or\n    QUADS.\n*/\n#define useFibonacciSphere 0\n#define useScatterInFibonacci (randomness==RANDOM)\n#define scatterFibonacci (.707*distance(fibonacciSphere(0.,float(rendersPerPixel)),fibonacciSphere(1.,float(rendersPerPixel))))\n\n// !! Settings end here\n\n\n\n// Constants\n#define PI 3.141592653\n#define FAR 1e19\n#define NOHIT -1.\n\n// Oneline functions\n#define dot2(x) dot(x,x)\n#define square(x) (x*x)\n#define line2d(posa, posb, coord) ((dot2(posa-coord) - dot2(posb-coord)) / (square(distance(posa, posb))*2.) + .5)\n\n//\nfloat renderId = 0.;\nfloat renderIteration = 0.;\n\n// Random\n#if randomness != NONE\nfloat seed = 0.;\nfloat rand(float _){\n    return fract(cos(mod(seed++,PI))*15183.);\n}\nfloat randCenter(float _){\n    return fract(cos(mod(seed++,PI))*15183.)-.5;\n}\n#else\nfloat rand(float seed){\n    return fract(cos(mod(renderId*float(reflections)+renderIteration+seed,PI))*15183.);\n}\nfloat randCenter(float seed){\n    return fract(sin(mod(renderId*float(reflections)+renderIteration+seed,PI))*15183.)-.5;\n}\n#if frameRandomness == 1\nfloat commonIFrame = 0.;\n#define rand(x) rand((x)+commonIFrame)\n#define randCenter(x) randCenter((x)+commonIFrame)\n#endif\n#endif\n\n// Rotations\nvec2 rotate2_1(vec2 coord, float angle){\n    float cosine = cos(angle);\n    float sine = sin(angle);\n    return coord * mat2(cosine, sine, -sine, cosine);\n}\nvec3 rotate3_1(vec3 coord, float angle){\n    float cosine = cos(angle);\n    float sine = sin(angle);\n    mat2 matrix = mat2(cosine, sine, -sine, cosine);\n    return vec3(coord.xy * matrix,coord.z);\n}\nvec3 rotate3(vec3 coord, vec3 angle){\n    //return rotate3_1(rotate3_1(rotate3_1(coord,angle.z).yzx,angle.y).yzx,angle.x).yzx;\n    angle = angle.yxz;\n    vec3 cosine = cos(angle);\n    vec3 sine = -sin(angle);\n    return coord\n                 * mat3(1.,0.,0., 0.,cosine.x,-sine.x, 0.,sine.x,cosine.x)\n                 * mat3(cosine.y,0.,sine.y, 0.,1.,0., -sine.y,0.,cosine.y)\n                 * mat3(cosine.z,-sine.z,0., sine.z,cosine.z,0., 0.,0.,1.);\n}\nvec3 unrotate3(vec3 coord, vec3 angle){\n    //return rotate3_1(rotate3_1(rotate3_1(coord.zxy,-angle.x).zxy,-angle.y).zxy,-angle.z);\n    angle = -angle.yxz;\n    vec3 cosine = cos(angle);\n    vec3 sine = -sin(angle);\n    return coord * mat3(cosine.z,-sine.z,0., sine.z,cosine.z,0., 0.,0.,1.)\n                 * mat3(cosine.y,0.,sine.y, 0.,1.,0., -sine.y,0.,cosine.y)\n                 * mat3(1.,0.,0., 0.,cosine.x,-sine.x, 0.,sine.x,cosine.x);\n}\n\n// Opaque materials\nvec3 randomSpherePoint(){\n    vec3 normal;\n    normal.z = randCenter(.001)*2.;\n    float phi = rand(.002)*2.*PI;\n    normal.xy = sqrt(1. - square(normal.z)) * vec2(cos(phi), sin(phi));\n    return normal;\n}\nvec3 fibonacciSphere(float x, float samples) {\n    x += .5;\n    float phi = acos(1.-2.*x/samples);\n    float theta = PI*(1.+sqrt(5.)) * x;\n    return vec3(vec2(cos(theta), sin(theta))*sin(phi), cos(phi));\n}\n\nbool fibonacciUsed;\nvec3 opaqueSurface(vec3 normal, bool useFibonacci){\n#if useFibonacciSphere == 1 && rendersPerPixel != 1\n    if(useFibonacci && !fibonacciUsed){\n        fibonacciUsed = true;\n        return normalize(\n            normal +\n#if useScatterInFibonacci == 1\n            normalize(\n                fibonacciSphere(mod(renderId, float(rendersPerPixel)), float(rendersPerPixel))\n                + scatterFibonacci * randomSpherePoint()\n            )\n#else\n        fibonacciSphere(mod(renderId, float(rendersPerPixel)), float(rendersPerPixel))\n#endif\n        );\n    }\n#endif\n    return normalize(normal + randomSpherePoint());\n}\n\n// Object and distance functions\n\n#define SCATTER 0\n#define GLASS 1\n\nstruct Material{\n    int type;\n    float value;\n    float eta;\n};\n\n/*\n    This is how objects work.\n    They can tint the light with a color, and emit their own.\n    `Distance` and `normal` are needed to identify the object.\n    `isThis` is only used to apply materials only to the last item.\n    `isInside` is used to know if you are inside an Object (like when inside a cube or a sphere)\n*/\nstruct Object{\n    vec3 color;\n    vec3 emittedColor;\n    vec3 normal;\n    vec3 direction;\n    bool isInside;\n    bool isThis;\n    float Distance;\n    Material material;\n};\n\nvoid join(inout Object a, Object b){\n    if(a.Distance == NOHIT\n    || (b.Distance != NOHIT && b.Distance < a.Distance)){\n        a = b;\n        a.isThis = true;\n    } else\n        a.isThis = false;\n}\n\nObject plane(vec3 position, vec3 ray, vec3 coord, vec3 angle){\n    Object object;\n    position = rotate3(coord-position,-angle);\n    ray = rotate3(ray,angle);\n    object.normal = rotate3(vec3(0,sign(position.y),0),-angle);\n    \n    object.Distance = ray.y*position.y > 0. ?\n        sqrt(dot2(ray.xz)+square(ray.y))/ray.y*position.y :\n        NOHIT ;\n    return object;\n}\n\nObject cutPlane(vec3 position, vec3 ray, vec3 coord, vec3 angle, vec2 size){\n    Object object;\n    position = rotate3(coord-position,-angle);\n    ray = rotate3(ray,-angle);\n    object.normal = rotate3(vec3(0,-sign(position.y),0),angle);\n    \n    object.Distance = \n        ray.y*position.y > 0. ?\n        sqrt(dot2(ray.xz)+square(ray.y))/ray.y*position.y :\n        NOHIT;\n    vec2 planeCoord = object.Distance*ray.xz+position.xz;\n    if(any(lessThan(planeCoord,position.xz*2.))\n    || any(greaterThan(planeCoord,position.xz*2.+vec2(size))))\n        object.Distance = NOHIT;\n    return object;\n}\n\nObject cube(vec3 position, vec3 ray, vec3 coord, vec3 angle, vec3 size){\n    position = rotate3(position-coord,-angle)+coord;\n    ray = rotate3(ray,-angle);\n    bool isInside = all(greaterThan(position,coord-.01)) && all(lessThan(position,coord+size+.01));\n    Object near = cutPlane(position, ray, coord+vec3(0.,size.y,0.)*float((ray.y<0.)!=isInside), vec3(0.), size.xz);\n    join(near,    cutPlane(position, ray, coord+vec3(0.,0.,size.z)*float((ray.z<0.)!=isInside), vec3(0.,.5*PI,0.), size.xy));\n    join(near,    cutPlane(position, ray, coord+vec3(size.x,0.,0.)*float((ray.x<0.)!=isInside), vec3(0.,0.,-.5*PI), size.yz));\n    near.isInside = isInside;\n    near.normal = unrotate3(near.normal,-angle);\n    return near;\n}\n\nObject sphere(inout vec3 position, inout vec3 ray, vec3 coord, float size){\n    Object object;\n    object.isInside = distance(position, coord) < size;\n    object.Distance = NOHIT;\n    \n    \n    object.normal = vec3(0);\n    vec3 perpendicular = position + ray*line2d(position, position+ray, coord);\n    \n    if(distance(perpendicular, coord) > size) return object;\n    if(dot(position-coord, ray) > 0. && !object.isInside) return object;\n    \n    object.Distance = distance(position, perpendicular);\n    object.Distance -= cos(asin(distance(perpendicular, coord)/size))*size*sign(distance(position,coord)-size);\n    object.normal = normalize((position + ray*object.Distance) - coord)*(object.isInside?-1.:1.);\n    return object;\n}\n\nObject sky(vec3 position, vec3 ray){\n    Object object;\n    //object.normal = -ray;\n    object.Distance = FAR;\n    object.color = vec3(0);\n    object.emittedColor = vec3(0);\n    return object;\n}\n\n// Materials\n\n/*\n    Scatter values between 0 and 1 may be wrong,\n    and it is noticeable a lot in glass.\n*/\nvoid getDirection(inout Object near, vec3 position, vec3 ray){\n    if(near.material.type == SCATTER){\n        vec3 scatter = opaqueSurface(near.normal, near.material.value > .25);\n        near.direction = mix(reflect(ray, near.normal), scatter, near.material.value);\n    }else if(near.material.type == GLASS){\n        vec3 scatter = opaqueSurface(near.normal, near.material.value > .25);\n        near.direction = mix(refract(ray, near.normal, near.material.eta), scatter, near.material.value);\n        if(near.direction == vec3(0)){\n            // this is a total internal reflection\n            near.color = vec3(1);\n            near.direction = reflect(ray, near.normal);\n        }\n    \n    }\n}\n\nvoid material(inout Object near, vec3 position, vec3 ray, vec3 color, vec3 emittedColor, float scatter, bool colorOnly){\n    if(!near.isThis)return;\n    near.color = color;\n    near.emittedColor = emittedColor;\n    if(!colorOnly)near.material = Material(SCATTER, scatter, 0.);\n}\nvoid glass(inout Object near, vec3 position, vec3 ray, float eta, float scatter, bool colorOnly){\n    if(!near.isThis || colorOnly)return;\n    if(near.isInside)eta = 1./eta;\n    near.material = Material(GLASS, scatter, eta);\n}\n// The fog scatter is still wip\nvoid fog(inout Object near, vec3 position, vec3 ray, vec3 color/*, float scatter*/, bool colorOnly){\n    vec3 amount = 1./pow(vec3(2.),near.Distance/color);\n    near.color *= amount;\n    near.emittedColor *= amount;\n    /*if(rand()>1./pow(2.,near.Distance/scatter)){\n        near.Distance *= rand();\n        near.normal = normalize(randomSpherePoint());\n        near.direction = near.normal;\n        near.color = vec3(1);\n        near.emittedColor = vec3(0);\n    }*/\n}\n\n#define material(a, b, c, d, e, f) material(a, b, c, d, e, f, colorOnly)\n#define glass(a, b, c, d, e) glass(a, b, c, d, e, colorOnly)\n#define fog(a, b, c, d) fog(a, b, c, d, colorOnly)\n\n/* \n    This is the function that substitutes the marching function and the classic triangle lookup.\n    It just takes a `position` and the direction of the `ray`, and returns the distance to it.\n    Nothing new, you can use this to draw triangles too!\n    And if you want, you can add a SDF to it (related to raymarching).\n*/\nObject findNearest(vec3 pos, vec3 ray, bool colorOnly){\n    const vec3 black = vec3(0);\n    const vec3 white = vec3(.90);\n    const vec3 red = vec3(.99,.05,.05);\n    const vec3 blue = vec3(.05,.05,.99);\n    \n    const vec3 yellowL = vec3(10,5,3);\n    const vec3 purpleL = vec3(5,3,10);\n    const vec3 pinkL   = vec3(10,3,5);\n    const vec3 greenL = vec3(5,10,3);\n    const vec3 cyanL   = vec3(3,5,10);\n    \n    Object near = sky(pos, ray);\n    \n    join(near, cutPlane(pos, ray, vec3(-5,-5,-5 ), vec3(0), vec2(10)));\n    material(near, pos, ray, white,black  ,1.);\n    join(near, cutPlane(pos, ray, vec3(-5,5,-5  ), vec3(0), vec2(10)));\n    material(near, pos, ray, white,black  ,1.);\n    \n    if(near.isThis){\n        vec3 nextPos = pos+ray*near.Distance;\n        vec2 colorPos = rotate2_1(nextPos.xz, .628)*.6;\n        vec3 emittedColor = black;\n        if(max(abs(nextPos.x),abs(nextPos.z)) < 4.5){\n            if(max(abs(colorPos.x    ),abs(colorPos.y    )) < 1.) emittedColor = yellowL;\n            if(max(abs(colorPos.x-.45),abs(colorPos.y+2.8)) < 1.) emittedColor = greenL ;\n            if(max(abs(colorPos.x+.45),abs(colorPos.y-2.8)) < 1.) emittedColor = cyanL  ;\n            if(max(abs(colorPos.x+2.8),abs(colorPos.y+.45)) < 1.) emittedColor = pinkL  ;\n            if(max(abs(colorPos.x-2.8),abs(colorPos.y-.45)) < 1.) emittedColor = purpleL;\n        }\n        if(emittedColor != black)\n            near.color = black;\n        near.emittedColor = emittedColor;\n    }\n    \n    join(near, cutPlane(pos, ray, vec3(-5,5,-5 ), vec3(0,0,.5*PI), vec2(10)));\n    material(near, pos, ray, red  ,black  ,1.);\n    join(near, cutPlane(pos, ray, vec3(5,5,-5), vec3(0,0,.5*PI), vec2(10)));\n    material(near, pos, ray, blue ,black  ,1.);\n    join(near, cutPlane(pos, ray, vec3(-5,5,5), vec3(0,-.5*PI,0), vec2(10)));\n    material(near, pos, ray, white,black  ,1.);\n    \n    join(near, sphere(pos, ray, vec3(2.,-3.,0 ), 2.));\n    material(near, pos, ray, white,black  ,0.);\n    join(near, sphere(pos, ray, vec3(-2.5,-3.5, .0 ), 1.5));\n    material(near, pos, ray, white,black  ,0.);\n    if(rand(.100)>.05)glass(near, pos, ray, 1./1.5, 0.);\n    join(near, sphere(pos, ray, vec3(2.,-3.5,2.5), 1.5));\n    material(near, pos, ray, black,yellowL,1.);\n    \n    join(near, cube(pos, ray, vec3(4.9,-4.,-4.), vec3(0), vec3(.1,5,5)));\n    material(near, pos, ray, white,black,0.);\n    \n    //join(near, cube(pos, ray, vec3(0), vec3(.8,.2,.3), vec3(.1,5,5)));\n    //material(near, pos, ray, white,black,0.);\n    \n    return near;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}