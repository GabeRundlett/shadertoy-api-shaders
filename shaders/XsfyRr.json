{
    "Shader": {
        "info": {
            "date": "1486635345",
            "description": "Calcs a subset of pixels, then interpolates the scattered data using (two levels of) mipmaps.\nLMB to control discard, right side to see full.\nbufA: image | bufB,C: mip pull downsampling | bufD/Image: push upsampling\nhttps://www.in.tum.de/fileadmin/w00bws/",
            "flags": 32,
            "hasliked": 0,
            "id": "XsfyRr",
            "likes": 52,
            "name": "reconstruction: pull/push",
            "published": 3,
            "tags": [
                "interpolation",
                "upsampling",
                "pushpull",
                "scattereddata"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 2990
        },
        "renderpass": [
            {
                "code": "//\n// push-upsample 2/2 (and output)\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n\n    // DBG\n    //fragColor = vec4( lin2srgb( textureLod( iChannel0, ssuv, 0.0 ).rgb ), 1.0 ); return;\n   \t//fragColor = vec4( lin2srgb( textureLod( iChannel1, 0.5*ssuv, 0.0 ).rgb ), 1.0 ); return;\n    //fragColor = vec4( lin2srgb( textureLod( iChannel2, 0.25 * ssuv, 0.0 ).rgb ), 1.0 ); return;\n    //fragColor = vec4( lin2srgb( textureLod( iChannel3, 0.5 * ssuv, 0.0 ).rgb ), 1.0 ); return;\n\n    vec2 p = fragCoord.xy;\n    p.x = mod( p.x, iResolution.x/2.0);\n    p.x += iResolution.x/4.0;\n    \n    if ( /*iMouse.z < 0.5 && */ ssuv.x < 0.5 )\n    {\n        fragColor = vec4( lin2srgb( texture( iChannel0, p/iResolution.xy ).rgb ), 1.0 ); return;\n        return;\n    }\n\n    /*\n    if ( iMouse.z > 0.5 && iMouse.x / iResolution.x > 0.5 )\n    {\n        fragColor = vec4( lin2srgb( texture( iChannel0, fragCoord / iResolution.xy ).rgb ), 1.0 ); return;\n        return;\n    }\n\t*/\n    \n    vec2 uv0 = p.xy / iChannelResolution[0].xy;\n    vec4 c0 = textureLod( iChannel0, uv0, 0.0 );\n    if ( c0.a > 0.0 )\n    {\n        //note: base-alpha always 0 or 1, so return immediately\n        fragColor = c0;\n    }\n\telse\n    {\n        vec2 uv3 = 0.5 * p.xy / iChannelResolution[3].xy;\n        vec4 g[4];\n        gather4rgba( iChannel3, uv3, iChannelResolution[3].xy, g[0], g[1], g[2], g[3] );\n\n        g[0].a *= upsample_w[0];\n    \tg[1].a *= upsample_w[1];\n    \tg[2].a *= upsample_w[2];\n    \tg[3].a *= upsample_w[3];\n    \tvec4 c = vec4( g[0].rgb * g[0].a +\n\t             \t   g[1].rgb * g[1].a +\n    \t         \t   g[2].rgb * g[2].a +\n\t                   g[3].rgb * g[3].a,\n\t                   g[0].a + g[1].a + g[2].a + g[3].a );\n        if ( c.a > 0.0 )\n        {\n            fragColor = vec4(0);\n    \t\tc.rgb /= c.a;\n            //fragColor = mix( c, c0, min(1.0,c0.a) );\n            fragColor = c; //note: base-alpha always 0 or 1\n        }\n        else\n            fragColor = c0; //...zero\n    }    \n    fragColor = vec4( lin2srgb(fragColor.rgb), 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///\n// Input image generation (and decimation)\n//\n\nconst float patternduration =  3.0;\nconst float num_sections = 7.0;\nconst float cycle_t = patternduration * num_sections;\n\n//note: siemens star\nfloat pattern_siemens( vec2 p, float aspect )\n{\n    vec2 ctrvec = vec2( p - vec2(0.5, 0.5 ) ); //note: centered\n    ctrvec.x *= aspect;\n    ctrvec /= 2.0;\n    \n    float ctrvec_len = length( ctrvec );\n    ctrvec /= ctrvec_len;\n    \n\tfloat angle = acos( ctrvec.x );\n    \n    if ( sign(ctrvec.y) < 0.0 )\n        angle = 6.283185307 - angle;\n\n    angle += 0.025 * iTime;\n\n    float its = step( 0.0, sin(100.0*angle));\n    its *= step( ctrvec_len, 0.5 ); //bound to circle\n    \n    return its;\n}\n//note: from https://gist.github.com/Reedbeta/893b63390160e33ddb3c\nfloat pattern_reed( vec2 p )\n{\n    // Here's the image function we'll use to test antialiasing; it has infinite-frequency edges,\n    // plus the placement of the edges varies in spatial frequency over the image\n    const float minPeriod = 2e-5;\n    const float maxPeriod = 0.2;\n    p.y = 1.0 - p.y;\n    float period = minPeriod + (maxPeriod - minPeriod) * p.y * p.y;\n    float phase = p.x / period;\n    phase -= floor(phase);\n    return round( phase );\n}\n\nfloat pattern_zoneplate( vec2 p, float aspect )\n{\n    vec2 ctrvec = vec2( p - vec2(0.5, 0.5 ) ); //note: centered\n    ctrvec.x *= aspect;\n    ctrvec /= 2.0;\n    \n    float ctrvec_len = length( ctrvec );\n    \n    float v = cos( 5000.0*ctrvec_len*ctrvec_len*ctrvec_len - 10.0 * iTime );\n    return max(v, 0.0);\n    //return step( v, 0.0 );\n}\n\nvec4 anim_pattern( vec2 in_uv, float aspect )\n{\n        vec2 uv = in_uv * vec2(aspect, 1.0) * 3.0;\n        float t = 0.05 * iTime;\n        vec2 r = vec2( cos(t), sin(t) );\n        uv -= vec2(0.5);\n        uv =  vec2( dot(r, uv), dot(vec2(-r.y, r.x), uv ) );\n        uv += vec2(0.5);\n    \tvec4 c = vec4( textureLod( iChannel2, uv, 0.0 ).xxx, 1.0 );\n\t\n        return c;\n}\n\nvec4 pattern( vec2 uv, int imgidx )\n{\n    if ( imgidx == 1 )\n    {\n        //return vec4( vec3(pattern_siemens( uv, iResolution.x/iResolution.y )), 1.0 );\n        return vec4( vec3(pattern_reed( uv )), 1.0 );\n    }\n    else if ( imgidx == 2 )\n    {\n        return vec4( vec3(pattern_zoneplate( uv, iResolution.x/iResolution.y )), 1.0 );\n    }\n    else if ( imgidx==3 )\n    {\n        return anim_pattern( uv, iResolution.x/iResolution.y );\n    }\n    else if ( imgidx == 4 )\n    {\n        return vec4( srgb2lin( textureLod(iChannel0, uv, 0.0 ).rgb ), 1.0 );\n    }\n    else if ( imgidx == 5 )\n    {\n        return vec4( 0.25 + 0.5 * step( uv.x, 0.5 ) );\n    }\n\telse //if ( imgidx == 6 )\n    {\n        float t = iTime;\n        vec3 c = 0.5 + 0.5 * vec3( cos(0.39*t), sin(0.81*t), sin(0.83*t) );\n        return vec4( c * (0.5 + 0.5*sin( 21.0*uv.y + 11.0*uv.x + 0.75*sin(11.0*uv.x + 4.1*t) )), 1.0 );\n    }\n}\n\nvec4 renderImage( vec2 uv )\n{\n    int imgidx = int( mod(iTime, cycle_t) / patternduration );\n    \n    if ( iMouse.z > 0.5 )\n        imgidx = int( iMouse.x / iResolution.x * num_sections );\n\n    vec4 c;\n    if ( imgidx == 0 )\n    {\n        c = pattern ( uv, 1+int(uv.y*(num_sections-1.0)) );\n    }\n\telse\n    \tc = pattern( uv, imgidx );\n\n    return c;\n}\n\n\nfloat remap( float v, float a, float b )\n{\n    return clamp( (v-a)/(b-a), 0.0, 1.0 );\n}\nvec2 remap( vec2 v, float a, float b )\n{\n    return vec2( remap(v.x, a, b ),\n                 remap(v.y, a, b ) );\n}\nvec2 calc_importance( vec2 ssuv )\n{\n    vec2 mpos = remap(iMouse.xy/iResolution.xy, 0.01, 0.99);\n    \n    float bias01 = (iMouse.z>0.5) ? 1.0-mpos.y : 0.95;\n    float importance01 = bias01;\n\n    //#define RADIAL_IMPORTANCE\n\t#if defined( RADIAL_IMPORTANCE )\n    //float aspect = iResolution.x / iResolution.y;\n    //vec2 ctr = vec2(0.5*aspect, 0.5 );\n    //float r = 0.9 * length(ssuv - ctr);\n    //r = max( 0.0, r);\n    //r = pow( r, 0.5);\n\t//importance01 = r / ((1.0 / bias01 - 2.0) * (1.0 - r) + 1.0);\n    #endif\n    \n    //note: force a circle of max importance\n    //importance = min( importance, step( 0.1, length(ssuv-vec2(0.25,0.25) ) ) );\n \n    //note: force a discontinuous rect of max importance\n    if ( ssuv.x > 0.5 && ssuv.x < 1.25 &&\n         ssuv.y > 0.1 && ssuv.y < 0.125 )\n    {\n        importance01 = 0.2;\n    }\n    \n    vec2 r_ctr = vec2(0.9,0.55);\n    r_ctr += 0.2 * vec2( cos(iTime), sin(iTime) );\n    float radial_falloff = clamp(length(ssuv-r_ctr)/0.25, 0.0, 1.0 );\n    //radial_falloff *= radial_falloff;\n    radial_falloff = pow( radial_falloff, 0.25 );\n    \n    //importance = radial_falloff;\n    importance01 = min( importance01, radial_falloff );\n    \n    importance01 = max( 0.00001, importance01 );\n\n    return vec2( bias01, importance01 );\n}\n\n\nvoid img( out vec4 fragColor, in vec2 uv_nm )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = uv_nm * vec2( aspect, 1.0 );\n\n    ///float bias = (iMouse.z>0.5) ? 1.0-iMouse.y / iResolution.y : 0.925;\n    //float importance = bias;\n\t//\n    //#define RADIAL_IMPORTANCE\n\t//#if defined( RADIAL_IMPORTANCE )\n    //vec2 ctr = vec2(0.5*aspect, 0.5 );\n    //float r = 0.9 * length(uv - ctr);\n    //r = max( 0.0, r);\n\t//importance = r / ((1.0 / bias - 2.0) * (1.0 - r) + 1.0);\n    //#endif\n    \n    vec2 bias_imp = calc_importance( uv );\n    float bias = bias_imp.x;\n    float importance = bias_imp.y;\n    \n    float rnd = textureLod( iChannel1, uv_nm*iResolution.xy/iChannelResolution[1].xy, 0.0 ).x;\n    //float rnd = textureLod( iChannel1, uv_nm*iResolution.xy/iChannelResolution[1].xy + 83.0*fract(1227.0*iTime), 0.0 ).x;\n    bool doDiscard = rnd < importance;\n    \n    if( doDiscard )\n    {\n\t\tfragColor = vec4(0.0); //note: float-buffer\n    }\n\telse\n    \tfragColor = renderImage( uv_nm );\n\n    //note: timer\n    if ( iMouse.z < 0.5 && uv_nm.y < 0.0125 ) \n    {\n        float t = 1.0-mod(iTime,patternduration) / patternduration;\n        if ( uv_nm.x < t )\n           \tfragColor = vec4(1,0,0,1);\n    }\n\n    //note: mouse-sampledensity marker\n    if ( (uv_nm.x < 0.006125 || uv_nm.x > (1.0-0.006125)) && abs(uv_nm.y-1.0+bias)<0.0125 )\n    \tfragColor = vec4(0.06125,0.125,0.7,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_nm = fragCoord.xy / iResolution.xy;\n\timg( fragColor, uv_nm );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// pull-downsample 1/2\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iChannelResolution[0].xy;\n    if ( uv.x > 1.0 || uv.y > 1.0 )\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    //note: manual samples for each texel\n    //\n    //TODO: wrongly sized ofs? iChannelRes is always fullres\n    //\n    vec2 ofs = vec2(0.5) / iChannelResolution[0].xy;\n    vec4 c0 = textureLod( iChannel0, uv + vec2( -ofs.x,  ofs.y), 0.0 );\n    vec4 c1 = textureLod( iChannel0, uv + vec2(  ofs.x, -ofs.y), 0.0 );\n    vec4 c2 = textureLod( iChannel0, uv + vec2(  ofs.x,  ofs.y), 0.0 );\n    vec4 c3 = textureLod( iChannel0, uv + vec2( -ofs.x, -ofs.y), 0.0 );\n    \n    //note: initial pass does not have to deal with weights!={0,1}\n    vec4 c = vec4(0.0);\n    c.a = c0.a + c1.a + c2.a + c3.a;\n    if ( c.a > 0.0 )\n    {\n        c.rgb += c0.rgb * c0.a; //note: the mult-by-alpha redundant is in first iteration\n        c.rgb += c1.rgb * c1.a; //      as rgb=0 implies a=0 (in our case...)\n        c.rgb += c2.rgb * c2.a;\n        c.rgb += c3.rgb * c3.a;\n        c.rgb /= c.a; //TODO: postpone divide to later passes? http://wwwvis.informatik.uni-stuttgart.de/~kraus/preprints/vmv06_strengert.pdf\n    }\n    \n    fragColor = c;\n    \n    //note: single sample-version for first iteration\n    //      samples in middle, avg of texels, get sum by x4\n    //vec4 cc = 4.0 * texture( iChannel0, uv ); \n\t//fragColor = cc;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// pull-downsample 2/2\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iChannelResolution[0].xy;\n    if ( uv.x > 1.0 || uv.y > 1.0 )\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    //note: manual samples for each texel\n    //\n    //TODO: wrongly sized ofs? iChannelRes is always fullres\n    //\n    vec2 ofs = vec2(0.5) / iChannelResolution[0].xy;\n    vec4 c0 = textureLod( iChannel0, uv + vec2( -ofs.x,  ofs.y), 0.0 );\n    vec4 c1 = textureLod( iChannel0, uv + vec2(  ofs.x, -ofs.y), 0.0 );\n    vec4 c2 = textureLod( iChannel0, uv + vec2(  ofs.x,  ofs.y), 0.0 );\n    vec4 c3 = textureLod( iChannel0, uv + vec2( -ofs.x, -ofs.y), 0.0 );\n    \n    //note: average valid pixels\n    //\n    //note: clamping is usually not essential (possibly more in coarser passes)\n    //      VERY essential for entirely uniform areas\n    //note: use \"optimized\" version with fewer calls to min()\n    //      https://wwwcg.in.tum.de/research/research/publications/2009/the-pull-push-algorithm-revisited.html\n    //define OPTIMIZED_CLAMP\n\n\t#if defined( OPTIMIZED_CLAMP )\n    vec4 w = vec4( c0.a, c1.a, c2.a, c3.a );\n    #else\n    vec4 w = vec4( min(1.0, c0.a), min(1.0, c1.a), min(1.0, c2.a), min(1.0, c3.a) );\n    #endif\n    \n    vec4 c = vec4(0.0);\n    float sumw = w[0] + w[1] + w[2] + w[3];\n    if ( sumw > 0.0 )\n    {\n        c.rgb += c0.rgb * w[0];\n        c.rgb += c1.rgb * w[1];\n        c.rgb += c2.rgb * w[2];\n        c.rgb += c3.rgb * w[3];\n        c.a = sumw;\n        #if defined( OPTIMIZED_CLAMP )\n        c.a = min( 1.0, c.a );\n        c.rgb = c.a / sumw * c.rgb;\n        #else\n        c.rgb /= c.a;\n        #endif\n    }\n    \n    fragColor = c;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// push-upsample 1/2\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec4 c0 = textureLod( iChannel0, uv0, 0.0 );\n\n    vec2 uv1 = 0.5 * fragCoord.xy / iChannelResolution[1].xy;\n    vec4 g1[4];\n    gather4rgba( iChannel1, uv1, iChannelResolution[1].xy, g1[0], g1[1], g1[2], g1[3] );\n    \n    g1[0].a *= upsample_w[0];\n    g1[1].a *= upsample_w[1];\n    g1[2].a *= upsample_w[2];\n    g1[3].a *= upsample_w[3];\n    vec4 c1 = vec4( g1[0].rgb * g1[0].a +\n             \t    g1[1].rgb * g1[1].a +\n             \t    g1[2].rgb * g1[2].a +\n                    g1[3].rgb * g1[3].a,\n                    g1[0].a + g1[1].a + g1[2].a + g1[3].a );\n\n    if ( c1.a > 0.0 )\n    {\n        c1.rgb /= c1.a;\n        fragColor = mix( c1, c0, min(1.0, c0.a) ); //note: blend higher-res on top of lower-res\n    }\n    else\n        fragColor = c0; //...zero\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 lin2srgb( vec3 c ) { return pow(c,vec3(1.0/2.4)); }\nvec3 srgb2lin( vec3 c ) { return pow(c,vec3(    2.4)); }\n\nvoid gather4rgba( in sampler2D sampler, in vec2 uv, in vec2 texsiz, \n              \t  out vec4 c0, out vec4 c1, out vec4 c2, out vec4 c3 )\n{\n    vec2 ctr = (floor(uv * texsiz) + vec2(0.5,0.5)) / texsiz;\n    vec2 ofs = (step(ctr,uv)*2.0-1.0) / texsiz;\n    vec2 uv0 = ctr;\n    vec2 uv1 = ctr + vec2(ofs.x, 0.0);\n    vec2 uv2 = ctr + vec2(0.0, ofs.y);\n    vec2 uv3 = ctr + ofs;\n    c0 = textureLod( sampler, uv0, 0.0 );\n    c1 = textureLod( sampler, uv1, 0.0 );\n    c2 = textureLod( sampler, uv2, 0.0 );\n    c3 = textureLod( sampler, uv3, 0.0 );\n}\n\n//note: bilinear weights are constant since ordering/offsets are constant\nconst vec4 upsample_w = vec4(9.0/16.0, 3.0/16.0, 3.0/16.0, 1.0/16.0);\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}