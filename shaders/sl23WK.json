{
    "Shader": {
        "info": {
            "date": "1624771749",
            "description": "We take a normal defined on a path I in R^2 and extend it to the entire plane! The code might be shit! I can probably merge both buffers but I'm lazy.",
            "flags": 32,
            "hasliked": 0,
            "id": "sl23WK",
            "likes": 6,
            "name": "Surface Normals!",
            "published": 3,
            "tags": [
                "2d",
                "light",
                "normal"
            ],
            "usePreview": 0,
            "username": "vchavauty",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "// Given a path I: [0, 1] -> R^n, and a function defined on \n// this path f: [0, 1] -> R^n ->R^m\n// Consider then the extension\n// F: R^n -> R^m defined by\n// F(x) = C * integral_{i in I} f(i) / (dist(X - I(i))) d I(i) \n// C being a normalizing constant, usually the length of the path I in R^n.\n// Then F is a continuous extension of f in the entire space!\n//\n// We are going to extend the normal map.\n// If we have the circle S1 = {x : |x| = 1}, then for each point in S1, it's normal is itself\n// That is: N(x) = x for every point x in S1. \n// On the other hand, for a square, the normal of a point x is (+1, 0), (-1, 0), (0, +1) or (0, -1)\n// depending on which side of the square the point is.\n// Regardless, we have a normal N defined on this path.\n// We are going to extend this normal onto the entire plane and then light using common techniques!\n\nvec4 GetLight(vec2 uv) // Calculates the light of a point given it's normal\n{\n    vec3 ligdir = normalize(vec3(cos(iTime), sin(iTime), -0.4 + 0.4*sin(iTime*0.5))); //Direction of the Light\n    \n    vec2 tex = float(uv.x <= 1.0) *\n                    texture(iChannel0, uv - vec2(0.0, 1.0)).xy + float(!(uv.x <= 1.0))*\n                    texture(iChannel1, uv - vec2(1.0, 1.0)).xy;\n    \n    vec3 normal = normalize(2.0*vec3(tex, 0.0) - 1.0); //Convert RGB Coordinates back into Normal vectors\n    \n    float intensity = dot(ligdir, normal); //Light it\n    \n    vec4 Color = normalize(vec4(1.0, 0.0, 0.5, 0.0));\n    vec4 BColor = vec4(0.0, 0.0, 0.2, 0.0);\n    \n    return intensity*Color + (1.0-intensity)*BColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy;\n    fragColor = float(uv.y <= 1.0) * \n        (uv.x <= 1.0 ? texture(iChannel0, uv) : texture(iChannel1, uv - vec2(1.0, 0.0))) +  float(!(uv.y <= 1.0)) *// uv.y <= 1.0\n        GetLight(uv); // 1.0 <= uv.y <= 2.0\n    \n    float border = 0.005;\n    float condition = float(((uv.x <= 1.0 + border && uv.x >= 1.0 - border) || (uv.y <= 1.0 + border && uv.y >= 1.0 - border)));\n    fragColor = condition *\n                    vec4(0.0) + (1.0 - condition) *fragColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This buffer gets the normal UV map of a circle\n\n#define PI 3.14159265359\n\nvec2 Normal(vec2 pos) //Calculates the normal of a point in the S1 circunference\n{\n    return normalize(pos); // The normal of the S1 circunference is the identity\n}\nvec2 integral(vec2 pos)\n{\n    float interval = 0.01; //Interval of the ingral\n    vec2 sum = vec2(0.0, 0.0); //Value we are going to return\n    \n    for(float alpha = 0.0; alpha < 2.0*PI; alpha += interval)\n    {\n        vec2 circlepos = 0.7*vec2(cos(alpha), sin(alpha)); // Position of the circle given angle alpha\n        vec2 val = (1.0/(max(length(circlepos - pos), 0.001))) * Normal(circlepos); // Normal of point Circlepos multiplied by the weight it has on position pos.\n        sum = sum + interval * val;\n    }\n    return (1.0/(4.0*PI))*sum; // We normalize it by the length of the path, which is precisely the perimeter of S1. That is, 2PI\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0); //Corrects Distortion caused by screen\n    \n    vec2 i = integral(uv); // Gets the extension of the identity of function of the circunference to the entire space\n    fragColor = vec4(0.5) + 0.5*vec4(i.xy, 1.0, 0.0); //Convert normal vector to standard RGB representation.\n\n       \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffers get the normal UV map of a square\n\nvec2 Normal(vec2 pos) //Calculates the normal of a point in the 2D Square\n{\n    return float(pos.y >= 0.5) * vec2(0.0, 1.0) + float(!(pos.y >= 0.5))*(\n               float(pos.y <= -0.5) * vec2(0.0, -1.0) + float(!(pos.y <= -0.5)) * (\n                   float(pos.x >= 0.5) * vec2(1.0, 0.0) + float(!(pos.x >= 0.5))*\n                       vec2(-1.0, 0.0) ));\n}\nvec2 integral(vec2 pos)\n{\n    float interval = 0.01; //Interval of the integral\n    vec2 sum = vec2(0.0, 0.0); \n    \n    for(float alpha = 0.0; alpha < 4.0; alpha += interval)\n    {\n        vec2 squareposition = float(alpha <= 1.0) * vec2(0.5, -0.5 + alpha) + float(!(alpha <= 1.0)) *(\n                                float(alpha <= 2.0) * vec2(0.5 - (alpha - 1.0) , 0.5) + float(!(alpha <= 2.0))*(\n                                  float(alpha <= 3.0) * vec2(-0.5, 0.5 - (alpha - 2.0)) + float(!(alpha <= 3.0))*\n                                    vec2(-0.5 + (alpha - 3.0), -0.5)));\n        \n        vec2 val = (1.0/(max(length(squareposition - pos), 0.001))) * Normal(squareposition); // Normal of point Square multiplied by the weight it has on position pos.\n        \n        sum = sum + interval * val;\n    }\n    return (1.0/(2.0*4.0))*sum; // Normalization of path length\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0); //Corrects Distortion caused by screen\n    \n    vec2 i = integral(uv); // Gets the extension of the identity of function of the circunference to the entire space\n    fragColor = vec4(0.5) + 0.5*vec4(i.xy, 1.0, 0.0); //Convert normal vector to standard RGB representation.\n\n       \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}