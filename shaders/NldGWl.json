{
    "Shader": {
        "info": {
            "date": "1636959721",
            "description": "A continuous cube spiral inspired by bitless' \"Infinite Cube Zoom.\" Mouse y changes the size of each layer.",
            "flags": 0,
            "hasliked": 0,
            "id": "NldGWl",
            "likes": 25,
            "name": "Infinite Cube Spiral",
            "published": 3,
            "tags": [
                "2d",
                "cube",
                "zoom",
                "spiral",
                "infinite"
            ],
            "usePreview": 0,
            "username": "amhall",
            "viewed": 465
        },
        "renderpass": [
            {
                "code": "// Infinite Cube Spiral by Anthony Hall\n// Inspired by \"Infinite Cube Zoom\" by bitless:\n// https://www.shadertoy.com/view/3lc3zH\n\n\n// Transforms the distinct cubes into one continuous spiral.\n// When disabled, it's pretty much a less fancy version of\n// bitless' shader. I can't take any credit for the concept,\n// I just really like how it looks without the spiral.\n#define SPIRAL\n\n// Supersamples pixels near the center. At high resolutions,\n// this doesn't impact performance very much\n#define SS\n\nconst float pi = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Time in seconds to zoom through a full cube\nconst float zoomPeriod = 6.0;\n\n// Globals set in mainImage\nfloat time;\nfloat base;\n\nconst vec3 toLight = normalize(vec3(3, 4, 2));\n\n// Procedural color palette\nvec3 palette(float t)\n{\n    t *= twoPi;\n    \n    vec2 colors = vec2(\n        0.5 + 0.5 * cos(t - 1.0),\n        0.6 - 0.4 * cos(t + 1.9));\n\n    return colors.xxy;\n}\n\n// Returns the scene color\nvec3 image(vec2 point)\n{\n    float r = length(point);\n    float theta = atan(point.y, point.x);\n    \n    // Mapping which of the 6 slices we are in\n    float region = floor((6.0 * theta + pi) / twoPi);\n    \n    // Set each slice to be repeating from -30 to 30 deg\n    theta = (mod(6.0 * theta + pi, twoPi) - pi) / 6.0;\n    \n#ifdef SPIRAL\n\n    // The spiral is achieved by offsetting each slice's radius\n    // by 1/3 of a layer, then rotating each slice so the lines\n    // connect to both neighbors. We can exactly solve for this\n    // rotation using the law of cosines:\n    // a^2 = b^2 + c^2 - 2bc cos A\n    // Here, a is the ccw side and b is the clockwise side.\n    \n    float a = pow(base, -1.0 / 6.0);\n    float b = 1.0 / a;\n    float c = sqrt(a*a + b*b - a*b); // cos C = 0.5\n    \n    float A = acos((a*a - b*b - c*c) / (-2.0*b*c));\n    float correction = pi/3.0 - A;\n    theta -= correction;\n    \n    float level = log(r * cos(theta)) / log(base) - 2.0 * fract(time / zoomPeriod) + region / 3.0;\n\n#else\n\n    float level = log(r * cos(theta)) / log(base) - 2.0 * fract(time / zoomPeriod);\n\n#endif\n\n    // Calculate which direction this surface is facing for lighting.\n    // The face index corresponds to the axis the normal is on\n    float invert = floor(mod(level, 2.0));\n    region = mod(region + 3.0 * invert - 2.0, 6.0);\n    float face = floor(region / 2.0);\n\n    float diffuse = toLight[int(face)];\n    diffuse = 0.4 + 0.6 * diffuse;\n\n    // Unfortunately, this palette only yields good colors for\n    // 0 < t < 0.5\n    vec3 color = palette((fract(level) + face) / 6.0);\n    color *= diffuse;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = iTime;\n\n// I find that different base values are ideal for spiral vs non-spiral\n#ifdef SPIRAL\n\n    if (iMouse.z > 0.0)\n        base = exp2(0.35 + 0.8 * iMouse.y / iResolution.y);\n    else\n        base = 1.52 + 0.08 * cos(0.18 * time);\n    \n#else\n\n    if (iMouse.z > 0.0)\n        base = exp2(0.4 + 1.6 * iMouse.y / iResolution.y);\n    else\n        base = 1.85 + 0.35 * cos(0.18 * time);\n\n#endif\n\n    vec3 color = vec3(0.0);\n    \n#ifdef SS\n    \n    // Since the level of detail is logarithmic, it is dependent\n    // on the number of pixels away from the center, regardless\n    // of resolution. Thus, supersampling is done based on absolute\n    // pixel distance rather than percentage of the viewport.\n    \n    vec2 absPixelCoord = abs(fragCoord - 0.5 * iResolution.xy);\n    float bound = max(absPixelCoord.x, absPixelCoord.y);\n    \n    // This samples 2x2 within 120 pixels of the center, and\n    // 3x3 within 12 pixels. 120 is definitely overkill for\n    // strictly avoiding aliasing, I just find the jaggies\n    // visually unappealing when the threshold is smaller.\n    \n    int samples = 1 + int(bound < 120.0) + int(bound < 12.0);\n    float increment = 1.0 / float(samples);\n    float offset = 0.5 * increment - 0.5;\n    \n    for (int x = 0; x < samples; x++)\n    {\n        for (int y = 0; y < samples; y++)\n        {\n            vec2 ssFragCoord = fragCoord + vec2(x, y) * increment + offset;\n            vec2 ssPoint = (2.0 * ssFragCoord - iResolution.xy) / iResolution.y;\n            color += image(ssPoint);\n        }\n    }\n    color /= float(samples * samples);\n\n#else\n    \n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y; \n    color = image(point);\n    \n#endif\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}