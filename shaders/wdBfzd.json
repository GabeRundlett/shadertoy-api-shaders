{
    "Shader": {
        "info": {
            "date": "1590614411",
            "description": "(camera follow mouse).\n#56: flag for detail free 3D orientation or normal + free surface orientation\nflags SHADED , FOG\nWIP. slow and dirty for now.",
            "flags": 16,
            "hasliked": 0,
            "id": "wdBfzd",
            "likes": 10,
            "name": "3D details distrib on surface",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "hypertexture",
                "trabeculum",
                "mm"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 602
        },
        "renderpass": [
            {
                "code": "// started from \"hypertexture-trabeculum\" by FabriceNeyret2. https://shadertoy.com/view/ltj3Dc\n\n#define SHADED 1      // 1: fast light-dir shading. 0: stepCount pseudo-shading\n#define FOG 0         // activate fog\nbool geoMode = true;  // details 3D free (true) or 2D constrained (false)\n                      // space to toggle.\nconst float skyTrsp = .1;\nconst vec3 skyColor = vec3(.7,.8,1),\n           sunColor = vec3(1,.7,.1) *10.,   \n           lightDir = vec3(.94,.24,.24), // normalize(vec3(.8,.2,-.2));\n           ambient  = vec3(.2), \n           diffuse  = vec3(.8);\n\n// --- utils\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) ) // https://www.shadertoy.com/view/ll2cDc\n#define hash13(n)     fract(sin(n+vec3(0.,12.345,124))*43758.5453)\n#define hash33(n)     hash13(dot(n,vec3(1,13.1,107.7)))\n#define rot(a)        mat2(cos(a),-sin(a),sin(a),cos(a))\n\nmat3 rot3D(vec3 A, float a) {\n    A = normalize(A);\n    float s = sin(a), c = cos(a), C = 1. - c;\n /* return mat3(C* A.x*A.x + c,        C* A.x*A.y - A.z * s,  C* A.z*A.x + A.y * s,\n                C* A.x*A.y + A.z * s,  C* A.y*A.y + c,        C* A.y*A.z - A.x * s,\n                C* A.z*A.x - A.y * s,  C* A.y*A.z + A.x * s,  C* A.z*A.z + c    );\n */ return mat3(c) +  C*outerProduct(A,A) +  mat3(  0  ,-s*A.z, s*A.y,\n                                                  s*A.z,  0   ,-s*A.x,\n                                                 -s*A.y, s*A.x,  0   );\n}                                           // GLSL bug: can't factor s !\n\nfloat distrib( vec3 p, inout vec3 C, inout vec3 id) { // return dist; C=pos, id=detail 3D id\n    float d = 1e15;\n    vec3 ip = floor(p);\n    for (int k=0; k<27; k++) {                    // --- visit 3x3x3 neighborhood\n                vec3  p0 = ip + vec3(k%3,k/3%3,k/9) - 1., // cell id\n                       c = hash33(p0)+p0-p;       // vector-dist to cell sample\n                float d0 = dot(c,c);              // distÂ²\n                if  (d0<d) d=d0, C=c+p, id = p0;  // keep closest sample info\n            }\n    return sqrt(d);\n}\n\nfloat rad = .5,  // macro sphere radius\n     grid = 10., // grid density in each direction\n     size =.03;  // detail radius ( take care of using smaller Eps for hit and normals ) \n\n#if 0 // --- should be the correct one, but gives bad detail scattering\n\nfloat dist2scene(vec3 p, inout vec3 id) {\n    vec3 P=vec3(0); id=vec3(-2);     // for debug\n    float v = length(p) - rad+size,                    // distance to macro sphere\n          d = distrib(grid*p,P,id)/grid ;         // dist to detail center. P=center, id\n          P /= grid;\n // if (dot(p,p)/4. > size*size + rad*rad + size*rad) return v-2.*size;  // bounding sphere: save everything!  \n // if (v > 2.*size) return  v+2.*size;           // bounding sphere: save nothing :-(\n    if  ( abs(length(P)-rad+size)<2.*size ) \n    {\n        P = normalize(P)* rad;\n        vec3 a = p-P, h = hash33(id);                 // detail random rotation\n        if (geoMode)                                  // free 3D rot\n            a.yz *= rot(6.28*h.x), a.xy *= rot(6.28*h.z);\n        else                                          // 2D rot + align along N\n            a *= rot3D(vec3(P.y,-P.x,0),acos(normalize(P).z)),\n            a.xy *= rot(6.28*h.z);\n\n        a = abs(a); d = max(a.x,max(a.y,a.z)) - size; // distance to detail = cube\n\n        if (  d < v ) v = d;                          // we hit a detail\n        else id = vec3(-1);                           // we hit nothing or the surface\n    } //else id=vec3(-1);  \n    float bg = .85-length(p);                     // background sphere\n    if (bg < v ) v = bg, id = vec3(-2);           // we missed the object: id = sky.\n    return v;\n}\n\n#else // --- temporary one with better scattered details... not really on the surface\n\nfloat dist2scene(vec3 p, inout vec3 id) {\n    vec3 P=vec3(0); id=vec3(-2);     // for debug\n    float v = length(p) - rad,                    // distance to macro sphere\n          d = distrib(grid*p,P,id)/grid ;         // dist to detail center. P=center, id\n          P /= grid;\n // if (dot(p,p)/4. > size*size + rad*rad + size*rad) return v-2.*size;  // bounding sphere: save everything!  \n // if (v > 2.*size) return  v+2.*size;           // bounding sphere: save nothing :-(\n                                                  // put detail on surface\n    if  ( abs(length(P)-rad-size)<size ) P = normalize(P)*(rad-size); // [ why -size ? ]\n    vec3 a = p-P, h = hash33(id);                 // detail random rotation\n    if (geoMode)                                  // free 3D rot\n        a.yz *= rot(6.28*h.x), a.xy *= rot(6.28*h.z);\n    else                                          // 2D rot + align along N\n        a *= rot3D(vec3(P.y,-P.x,0),acos(normalize(P).z)),\n        a.xy *= rot(6.28*h.z);\n\n    a = abs(a); d = max(a.x,max(a.y,a.z)) - size; // distance to detail = cube\n    \n    v += 2.*size;           // [ why can't I put all below or around rad ? ]\n    if ( length(P) < rad && d < v ) v = d;        // we hit a detail\n    else id = vec3(-1);                           // we hit nothing or the surface\n    \n    float bg = .85-length(p);                     // background sphere\n    if (bg < v ) v = bg, id = vec3(-2);           // we missed the object: id = sky.\n    return v;\n}\n\n#endif\n\nvec3 calcNormal(vec3 p) { // taken here https://www.shadertoy.com/view/3sBBWy\n  vec3 n = vec3(0), id;\n  for(int i = 0; i < 4; i++){\n      vec3 e = .001*( vec3(9>>i&1, i>>1&1, i&1) *2.-1. );\n      n += e * dist2scene(p+e, id);\n  }\n  return normalize(n);\n}\n\n#define NORM 2    // 0 : full DF normal 1: centered directional 2: even cheaper\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = .005, dx; vec3 id;               // use smaller eps for contrast\n#if NORM == 0\n    dx =  dot(calcNormal(p),lightDir);            // true Lambert with full DF normal\n#elif NORM == 1                                   // centered directional derivative\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\n    dx = ( dist2scene(p+epsL*lightDir, id)\n          -dist2scene(p-epsL*lightDir, id)) / (2.*epsL);\n#else                                             // cheap directional derivative\n    dx = (dist2scene(p+epsL*lightDir, id)-v)/epsL;\n#endif\n    return clamp(dx, 0.,1.);                      // approx Lambert shading    \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         q = ( 2.*u - R ) / R.y,\n         M = iMouse.xy / R;\n    if ( M==vec2(0)) M=vec2(.5);\n    geoMode = !keyToggle(32);\n    \n    // --- set camera\n    float theta = -( M.x - .5 ) *6.28,\n            phi = -( M.y - .5 ) *3.14;\n#if 1 // camera shake \n    float t=10.*iTime,B=.02;   theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi)),   \n      cameraTarget = vec3(0),\n         W = normalize( cameraPos - cameraTarget ),\n         U = normalize(cross( vec3(0,1,0), W )),\n         V = cross(W,U),\n    rayDir = normalize( q.x*U + q.y*V -1.5*W );\n  \n    // --- ray-trace volume\n    float l = .5, d,\n        transp = 1.;\n    vec3 col = vec3(0),\n           p = cameraPos+l*rayDir, p_=p, \n          id = vec3(-2);                      // default = sky\n    \n    float i=0.;\n    for (; i<200.; i++) {                     // ray-march\n        d = dist2scene(p, id); \n        if (id==vec3(-2)) break;              // early exit if sky\n        if (d < .003)     break;              // \"hit\" on an object\n        p += .3*d*rayDir;\n    }\n // O = i/vec4(200,50,12,1); return;          // test: hitmap of iterations\n    \n    // --- shading\n    if ( d < .01 && id != vec3(-2) ) {        // hit\n#if FOG \n\t    float fog = pow(skyTrsp,length(p_-p)); p_=p;\n        col += transp*skyColor*(1.-fog);\n    \ttransp *= fog; \n#endif            \n        vec3 c = id != vec3(-1) \n                  ? .2*hue( hash33(id).x )    // detail color\n                  : ambient;                  // other surface: ambiant\n#if SHADED          \n        c += diffuse* shadedNormal(p,d);      // shading\n#else\n        c += diffuse* (1.-i/40.);             // pseudo-shading\n#endif\n \t    col += transp*c; transp = 0.;\n      }\n      \n   O = vec4(col+ transp*skyColor, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}