{
    "Shader": {
        "info": {
            "date": "1681040338",
            "description": "Spectral Cornell box path tracing with NEE/MIS and basic HWSS\nHas depth of field with 3 bokeh shapes to choose from\nAlso added basic glossy and transmission, change SCENE to 1 in Common to show\n\nClick and drag to move camera",
            "flags": 32,
            "hasliked": 0,
            "id": "clf3DX",
            "likes": 26,
            "name": "Spectral Cornell Box MIS + HWSS",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "box",
                "mis",
                "cornell",
                "wavelength",
                "spectral",
                "hero",
                "hwss"
            ],
            "usePreview": 0,
            "username": "gelami",
            "viewed": 725
        },
        "renderpass": [
            {
                "code": "// Fork of \"Cornell Box MIS\" by gelami. https://shadertoy.com/view/dtlGD2\n// 2022-12-31 17:16:06\n\n// Spectral Cornell Box MIS + HWSS\n// https://www.shadertoy.com/view/clf3DX\n\n/*\n * Spectral Cornell box path tracing with NEE/MIS and basic HWSS\n * \n * Has depth of field with 3 bokeh shapes to choose from\n * Also added basic glossy and transmission, change SCENE to 1 in Common to show\n *\n * Click and drag to move camera\n * Defines in Common\n *\n * Surface reflectances are curve fit from the original data\n * since reading directly from the array was slow\n * Ideally you could also store it in a buffer instead\n * \n * Previous version (RGB):\n * Cornell Box MIS - gelami\n * https://www.shadertoy.com/view/dtlGD2\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n        col = texelFetch(iChannel0, ivec2(1, 0), 0).rgb;\n    \n    col *= exp2(EXPOSURE);\n    col = wavelengthXYZtoRGB(col);\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n// Scene\n// 0 : Cornell Box\n// 1 : Cornell Box +\n#define SCENE 0\n\n#define BOUNCES 6\n#define EXPOSURE 3.0\n\n#define DOF\n// Shape type of depth of field\n// 0 : Circle\n// 1 : Polygon\n// 2 : Star\n#define DOF_TYPE 1\n\n#define DOF_SIDES 5\n#define DOF_STRENGTH 0.05\n#define DOF_FOCUS_DISTANCE 0.35\n\n#define USE_CURVE_FIT_SURFACE_REFLECTANCES\n\n// Illuminant\n// 0 : Cornell box light\n// 1 : D65\n#define ILLUMINANT 0\n\n//#define STATIC_CAM\n//#define NO_ACCUMULATE\n\n#define SKYBOX\n#define SKYBOX_STRENGTH 0.2\n\n#define MAX_DIST 100.\n#define EPSILON 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec4 wv;\n};\n\nstruct Material\n{\n    vec4 color;\n    vec4 emissive;\n    float roughness;\n    float transmission;\n    float ior;\n};\n\nstruct HitInfo\n{\n    float t;\n    vec3 normal;\n    bool inside;\n};\n\n// Ray-Box Intersection\n// https://iquilezles.org/articles/intersectors/\n\nbool boxIntersect( Ray ray, vec3 boxSize, inout HitInfo hit ) \n{\n    vec3 m = 1.0 / ray.direction;\n    vec3 n = m * ray.origin;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    \n    if( tN > tF || tF < 0.0) return false;\n    \n    bool inside = false;\n    vec3 normal;\n    if (tN < 0.0)\n    {\n        tN = tF;\n        normal = -sign(ray.direction)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n        inside = true;\n    } else {\n        normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    }\n    \n    if (tN < hit.t)\n    {\n        hit.t = tN;\n        hit.normal = normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\nbool boxIntersectInsideZ( Ray ray, vec3 boxSize, inout HitInfo hit ) \n{\n    vec3 m = 1.0 / ray.direction;\n    vec3 n = m * ray.origin;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    \n    if( tN > tF || tF < 0.0) return false;\n    \n    vec3 normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    if (tN < 0.0 || normal.z > 0.0)\n    {\n        normal = -sign(ray.direction)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);;\n        if (normal.z < 0.0) return false;\n        tN = tF;\n    }\n    \n    if (tN < hit.t)\n    {\n        hit.t = tN;\n        hit.normal = normal;\n        hit.inside = false;\n        return true;\n    }\n    return false;\n}\n\nbool sphereIntersect(Ray ray, vec3 center, float radius, inout HitInfo hit)\n{\n    vec3 oc = ray.origin - center;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - radius * radius;\n    float h = b*b - c;\n    if( h < 0.0 || b > 0.0) return false;\n    h = sqrt( h );\n    vec2 t = vec2(-b-h, -b+h );\n    \n    bool inside = false;\n    if (t.x < 0.0)\n    {\n        t.x = t.y;\n        inside = true;\n    }\n    \n    if (t.x < hit.t)\n    {\n        hit.t = t.x;\n        hit.normal = normalize(ray.origin - center + ray.direction * hit.t);\n        if (inside) hit.normal = -hit.normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\n\n\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\n\nvec2 sqr(vec2 x) { return x*x; }\n\nvec3 sqr(vec3 x) { return x*x; }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n    vec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(vec2(s),coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\n// Random point in circle\n// Very straightforward, unit circle scaled by sqrt of the radius\nvec2 randomPointInCircle()\n{\n    vec2 rand = hash2(state);\n    \n    float a = rand.x * TAU;\n    float r = sqrt(rand.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Random point in polygon\n// Pick a random side and\n// generate a point in a rhombus (equal quadrilateral),\n// and fold it if the point is outside the inner triangle\nvec2 randomPointInPolygon(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    vec2 p1 = s1 * rand.y + s2 * rand.z;\n    vec2 p2 = s1 * (1.0 - rand.y) + s2 * (1.0 - rand.z);\n    \n    return rand.y + rand.z > 1.0 ? p2 : p1;\n}\n\n// Random point in star\n// Same as the random point in polygon,\n// but without folding the rhombus into a triangle\nvec2 randomPointInStar(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    \n    return s1 * rand.y + s2 * rand.z;\n}\n\n// Random unit vector\n// Generate a random unit circle and scaled the z with a circular mapping\nvec3 randomUnitVector()\n{\n    vec2 rand = hash2(state);\n    rand.y = rand.y*2.-1.;\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\n// Random cosine-weighted unit vector on a hemisphere\n// Unit vector + random unit vector\nvec3 randomCosineHemisphere(vec3 n)\n{\n    return normalize(randomUnitVector() + n);\n}\n\nvec4 generateWavelengths()\n{\n    float x = hash(state);\n    return 400.0 + 300.0 * fract(x + vec4(0.0, 0.25, 0.5, 0.75));\n}\n\n// Curve fit surface reflectances based on the data\n// from the Cornell Box Data site\n// http://www.graphics.cornell.edu/online/box/data.html\nfloat getSurfaceReflectanceWhite(float wv)\n{\n    float x = wv;\n    return -408.105\n            + x * (3.70066\n            + x * (-0.0133045\n            + x * (0.0000237522\n            + x * (-2.10608*1e-8 \n            + 7.4214*1e-12 * x ))));\n}\n\nfloat getSurfaceReflectanceGreen(float wv)\n{\n    float x = wv;\n    return 538.481\n            + x * (-4.86156\n            + x * (0.017303\n            + x * (-0.0000303503\n            + x * (2.62543*1e-8 \n            + -8.96752*1e-12 * x ))));\n}\n\nfloat getSurfaceReflectanceRed(float wv)\n{\n    float x = wv;\n    return 126.229\n            + x * (-1.38886\n            + x * (0.0059851\n            + x * (-0.0000126345\n            + x * (1.30701*1e-8 \n            + -5.29943*1e-12 * x ))));\n}\n\nvec3 getSurfaceReflectanceCurveFit(float wv)\n{\n    wv = clamp(wv, 400.0, 700.0);\n    return vec3(\n        getSurfaceReflectanceWhite(wv),\n        getSurfaceReflectanceGreen(wv),\n        getSurfaceReflectanceRed(wv));\n}\n\nvec4 getSurfaceReflectanceWhite(vec4 wv)\n{\n    vec4 x = wv;\n    return -408.105\n            + x * (3.70066\n            + x * (-0.0133045\n            + x * (0.0000237522\n            + x * (-2.10608*1e-8 \n            + 7.4214*1e-12 * x ))));\n}\n\nvec4 getSurfaceReflectanceGreen(vec4 wv)\n{\n    vec4 x = wv;\n    return 538.481\n            + x * (-4.86156\n            + x * (0.017303\n            + x * (-0.0000303503\n            + x * (2.62543*1e-8 \n            + -8.96752*1e-12 * x ))));\n}\n\nvec4 getSurfaceReflectanceRed(vec4 wv)\n{\n    vec4 x = wv;\n    return 126.229\n            + x * (-1.38886\n            + x * (0.0059851\n            + x * (-0.0000126345\n            + x * (1.30701*1e-8 \n            + -5.29943*1e-12 * x ))));\n}\n\nmat3x4 getSurfaceReflectanceCurveFit(vec4 wv)\n{\n    wv = clamp(wv, 400.0, 700.0);\n    return mat3x4(\n        getSurfaceReflectanceWhite(wv),\n        getSurfaceReflectanceGreen(wv),\n        getSurfaceReflectanceRed(wv));\n}\n\n// Surface reflectances from data\n// http://www.graphics.cornell.edu/online/box/data.html\n// Returns white, red, and green\nvec3 getSurfaceReflectance(float wv)\n{\n    const vec3[76] surfaceReflectances = vec3[](\n        vec3(0.343, 0.092, 0.040),\n        vec3(0.445, 0.096, 0.046),\n        vec3(0.551, 0.098, 0.048),\n        vec3(0.624, 0.097, 0.053),\n        vec3(0.665, 0.098, 0.049),\n        vec3(0.687, 0.095, 0.050),\n        vec3(0.708, 0.095, 0.053),\n        vec3(0.723, 0.097, 0.055),\n        vec3(0.715, 0.095, 0.057),\n        vec3(0.710, 0.094, 0.056),\n        vec3(0.745, 0.097, 0.059),\n        vec3(0.758, 0.098, 0.057),\n        vec3(0.739, 0.096, 0.061),\n        vec3(0.767, 0.101, 0.061),\n        vec3(0.777, 0.103, 0.060),\n        vec3(0.765, 0.104, 0.062),\n        vec3(0.751, 0.107, 0.062),\n        vec3(0.745, 0.109, 0.062),\n        vec3(0.748, 0.112, 0.061),\n        vec3(0.729, 0.115, 0.062),\n        vec3(0.745, 0.125, 0.060),\n        vec3(0.757, 0.140, 0.059),\n        vec3(0.753, 0.160, 0.057),\n        vec3(0.750, 0.187, 0.058),\n        vec3(0.746, 0.229, 0.058),\n        vec3(0.747, 0.285, 0.058),\n        vec3(0.735, 0.343, 0.056),\n        vec3(0.732, 0.390, 0.055),\n        vec3(0.739, 0.435, 0.056),\n        vec3(0.734, 0.464, 0.059),\n        vec3(0.725, 0.472, 0.057),\n        vec3(0.721, 0.476, 0.055),\n        vec3(0.733, 0.481, 0.059),\n        vec3(0.725, 0.462, 0.059),\n        vec3(0.732, 0.447, 0.058),\n        vec3(0.743, 0.441, 0.059),\n        vec3(0.744, 0.426, 0.061),\n        vec3(0.748, 0.406, 0.061),\n        vec3(0.728, 0.373, 0.063),\n        vec3(0.716, 0.347, 0.063),\n        vec3(0.733, 0.337, 0.067),\n        vec3(0.726, 0.314, 0.068),\n        vec3(0.713, 0.285, 0.072),\n        vec3(0.740, 0.277, 0.080),\n        vec3(0.754, 0.266, 0.090),\n        vec3(0.764, 0.250, 0.099),\n        vec3(0.752, 0.230, 0.124),\n        vec3(0.736, 0.207, 0.154),\n        vec3(0.734, 0.186, 0.192),\n        vec3(0.741, 0.171, 0.255),\n        vec3(0.740, 0.160, 0.287),\n        vec3(0.732, 0.148, 0.349),\n        vec3(0.745, 0.141, 0.402),\n        vec3(0.755, 0.136, 0.443),\n        vec3(0.751, 0.130, 0.487),\n        vec3(0.744, 0.126, 0.513),\n        vec3(0.731, 0.123, 0.558),\n        vec3(0.733, 0.121, 0.584),\n        vec3(0.744, 0.122, 0.620),\n        vec3(0.731, 0.119, 0.606),\n        vec3(0.712, 0.114, 0.609),\n        vec3(0.708, 0.115, 0.651),\n        vec3(0.729, 0.117, 0.612),\n        vec3(0.730, 0.117, 0.610),\n        vec3(0.727, 0.118, 0.650),\n        vec3(0.707, 0.120, 0.638),\n        vec3(0.703, 0.122, 0.627),\n        vec3(0.729, 0.128, 0.620),\n        vec3(0.750, 0.132, 0.630),\n        vec3(0.760, 0.139, 0.628),\n        vec3(0.751, 0.144, 0.642),\n        vec3(0.739, 0.146, 0.639),\n        vec3(0.724, 0.150, 0.657),\n        vec3(0.730, 0.152, 0.639),\n        vec3(0.740, 0.157, 0.635),\n        vec3(0.737, 0.159, 0.642)\n    );\n    \n    float floatIdx = clamp((wv - 400.0) / (700.0 - 400.0), 0.0, 1.0) * 75.0;\n    int idx = int(floor(floatIdx));\n    float fac = fract(floatIdx);\n    \n    return mix(surfaceReflectances[idx], surfaceReflectances[idx + 1], fac);\n}\n\nmat3x4 getSurfaceReflectance(vec4 wv)\n{\n    vec3 s0 = getSurfaceReflectance(wv.x);\n    vec3 s1 = getSurfaceReflectance(wv.y);\n    vec3 s2 = getSurfaceReflectance(wv.z);\n    vec3 s3 = getSurfaceReflectance(wv.w);\n    return mat3x4(\n        vec4(s0.x, s1.x, s2.x, s3.x),\n        vec4(s0.y, s1.y, s2.y, s3.y),\n        vec4(s0.z, s1.z, s2.z, s3.z));\n}\n\nfloat getLightStrength(float wv)\n{\n    const float[] lightStrength = float[](0.0, 8.0, 15.6, 18.4);\n    \n    float floatIdx = clamp((wv - 400.0) / (700.0 - 400.0), 0.0, 1.0) * 3.0;\n    int idx = int(floor(floatIdx));\n    float fac = fract(floatIdx);\n    \n    return mix(lightStrength[idx], lightStrength[idx + 1], fac);\n}\n\nvec4 getLightStrength(vec4 wv)\n{\n    return vec4(getLightStrength(wv.x), getLightStrength(wv.y), getLightStrength(wv.z), getLightStrength(wv.w));\n}\n\n// Curve fit CIE Standard Illuminant D65\n// https://en.wikipedia.org/wiki/Illuminant_D65\n// Original data from\n// https://web.archive.org/web/20171122140854/http://www.cie.co.at/publ/abst/datatables15_2004/std65.txt\n// Range [46.4182, 117.812]\nvec4 getLightStrengthD65(vec4 wv)\n{\n    vec4 x = clamp(wv, 380.0, 780.0);\n    return -10906.5 +\n        x * (88.3842 +\n        x * (-0.280601 +\n        x * (0.000441847 + \n        (-3.46017*1e-7+1.07868*1e-10 * x) * x)));\n}\n\nvec3 XYZtoRGB( vec3 xyz ) {\n    const mat3 XYZ_TO_RGB = mat3( 3.2404542, -1.5371385, -0.4985314,\n                                 -0.9692660,  1.8760108,  0.0415560,\n                                  0.0556434, -0.2040259,  1.0572252);\n    return xyz * XYZ_TO_RGB;\n}\n    \nconst vec3 CIE1931ColObs_Sum = vec3(21.371524, 21.371327, 21.371540);\n\nvec3 wavelengthToXYZ( float wv ) {\n    \n    const vec3[] CIE1931ColObs = vec3[](\n        vec3(0.001368, 0.000039, 0.006450),\n        vec3(0.002236, 0.000064, 0.010550),\n        vec3(0.004243, 0.000120, 0.020050),\n        vec3(0.007650, 0.000217, 0.036210),\n        vec3(0.014310, 0.000396, 0.067850),\n        vec3(0.023190, 0.000640, 0.110200),\n        vec3(0.043510, 0.001210, 0.207400),\n        vec3(0.077630, 0.002180, 0.371300),\n        vec3(0.134380, 0.004000, 0.645600),\n        vec3(0.214770, 0.007300, 1.039050),\n        vec3(0.283900, 0.011600, 1.385600),\n        vec3(0.328500, 0.016840, 1.622960),\n        vec3(0.348280, 0.023000, 1.747060),\n        vec3(0.348060, 0.029800, 1.782600),\n        vec3(0.336200, 0.038000, 1.772110),\n        vec3(0.318700, 0.048000, 1.744100),\n        vec3(0.290800, 0.060000, 1.669200),\n        vec3(0.251100, 0.073900, 1.528100),\n        vec3(0.195360, 0.090980, 1.287640),\n        vec3(0.142100, 0.112600, 1.041900),\n        vec3(0.095640, 0.139020, 0.812950),\n        vec3(0.057950, 0.169300, 0.616200),\n        vec3(0.032010, 0.208020, 0.465180),\n        vec3(0.014700, 0.258600, 0.353300),\n        vec3(0.004900, 0.323000, 0.272000),\n        vec3(0.002400, 0.407300, 0.212300),\n        vec3(0.009300, 0.503000, 0.158200),\n        vec3(0.029100, 0.608200, 0.111700),\n        vec3(0.063270, 0.710000, 0.078250),\n        vec3(0.109600, 0.793200, 0.057250),\n        vec3(0.165500, 0.862000, 0.042160),\n        vec3(0.225750, 0.914850, 0.029840),\n        vec3(0.290400, 0.954000, 0.020300),\n        vec3(0.359700, 0.980300, 0.013400),\n        vec3(0.433450, 0.994950, 0.008750),\n        vec3(0.512050, 1.000000, 0.005750),\n        vec3(0.594500, 0.995000, 0.003900),\n        vec3(0.678400, 0.978600, 0.002750),\n        vec3(0.762100, 0.952000, 0.002100),\n        vec3(0.842500, 0.915400, 0.001800),\n        vec3(0.916300, 0.870000, 0.001650),\n        vec3(0.978600, 0.816300, 0.001400),\n        vec3(1.026300, 0.757000, 0.001100),\n        vec3(1.056700, 0.694900, 0.001000),\n        vec3(1.062200, 0.631000, 0.000800),\n        vec3(1.045600, 0.566800, 0.000600),\n        vec3(1.002600, 0.503000, 0.000340),\n        vec3(0.938400, 0.441200, 0.000240),\n        vec3(0.854450, 0.381000, 0.000190),\n        vec3(0.751400, 0.321000, 0.000100),\n        vec3(0.642400, 0.265000, 0.000050),\n        vec3(0.541900, 0.217000, 0.000030),\n        vec3(0.447900, 0.175000, 0.000020),\n        vec3(0.360800, 0.138200, 0.000010),\n        vec3(0.283500, 0.107000, 0.000000),\n        vec3(0.218700, 0.081600, 0.000000),\n        vec3(0.164900, 0.061000, 0.000000),\n        vec3(0.121200, 0.044580, 0.000000),\n        vec3(0.087400, 0.032000, 0.000000),\n        vec3(0.063600, 0.023200, 0.000000),\n        vec3(0.046770, 0.017000, 0.000000),\n        vec3(0.032900, 0.011920, 0.000000),\n        vec3(0.022700, 0.008210, 0.000000),\n        vec3(0.015840, 0.005723, 0.000000),\n        vec3(0.011359, 0.004102, 0.000000),\n        vec3(0.008111, 0.002929, 0.000000),\n        vec3(0.005790, 0.002091, 0.000000),\n        vec3(0.004109, 0.001484, 0.000000),\n        vec3(0.002899, 0.001047, 0.000000),\n        vec3(0.002049, 0.000740, 0.000000),\n        vec3(0.001440, 0.000520, 0.000000),\n        vec3(0.001000, 0.000361, 0.000000),\n        vec3(0.000690, 0.000249, 0.000000),\n        vec3(0.000476, 0.000172, 0.000000),\n        vec3(0.000332, 0.000120, 0.000000),\n        vec3(0.000235, 0.000085, 0.000000),\n        vec3(0.000166, 0.000060, 0.000000),\n        vec3(0.000117, 0.000042, 0.000000),\n        vec3(0.000083, 0.000030, 0.000000),\n        vec3(0.000059, 0.000021, 0.000000),\n        vec3(0.000042, 0.000015, 0.000000)\n    );\n\n    float floatIdx = clamp((wv - 380.0) / (780.0 - 380.0), 0.0, 1.0) * 80.0;\n    int idx = int(floor(floatIdx));\n    float fac = fract(floatIdx);\n    \n    return mix(CIE1931ColObs[idx], CIE1931ColObs[idx + 1], fac);\n}\n\nvec3 wavelengthXYZtoRGB( vec3 xyz )\n{\n    const vec3 avg = vec3(35.24199783, 23.04154372, 21.87036498) / 35.24199783;\n    \n    return max(XYZtoRGB(xyz), vec3(0));\n}\n\nvec3 wavelengthToRGB( float wv )\n{\n    //vec3 avg = XYZtoRGB(CIE1931ColObs_Sum);\n    //avg /= max(max(avg.x, avg.y), avg.z);\n    //Eqv: vec3(25.74837142, 20.2662644, 19.42341068) / 25.74837142;\n    \n    // With max average\n    const vec3 avg = vec3(35.24199783, 23.04154372, 21.87036498) / 35.24199783;\n    \n    return max(XYZtoRGB(wavelengthToXYZ(wv)), vec3(0)) / avg;\n}\n\nfloat tanhCurve( float x, float a, float b, float o, float k )\n{\n    return tanh((x - o) * k) * a + b;\n}\n\nvec2 tanhCurve( vec2 x, vec2 a, vec2 b, vec2 o, vec2 k )\n{\n    return tanh((x - o) * k) * a + b;\n}\n\nvec4 tanhCurve( vec4 x, float a, float b, float o, float k )\n{\n    return tanh((x - o) * k) * a + b;\n}\n\nfloat RGBtoSpectrum(vec3 rgb, float wv)\n{\n    float x = (wv - 380.0) / (730.0 - 380.0);\n    vec2 t = tanhCurve(x + vec2(0, .285), vec2(.475, -.475), vec2(.495), vec2(.585), vec2(30.));\n    vec3 z = vec3(t.x, 1.0 - t.x - t.y, t.y) * rgb;\n    return z.x + z.y + z.z;\n}\n\nvec4 RGBtoSpectrum(vec3 rgb, vec4 wv)\n{\n    vec4 x = (wv - 380.0) / (730.0 - 380.0);\n    vec4 ta = tanhCurve(x + 0.0, 0.475, 0.495, 0.585, 30.0);\n    vec4 tb = tanhCurve(x + 0.285, -0.475, 0.495, 0.585, 30.0);\n    mat3x4 z = mat3x4(ta, 1.0 - ta - tb, tb);\n    return z * rgb;\n}\n\nfloat cauchy(float wv, float b, float c)\n{\n    float x = wv * 0.001;\n    return b + c / (x * x);\n}\n\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2022-12-31 10:10:47\n\n#define LIGHT_POS vec3(0.278, 0.5489, 0.2795)\n#define LIGHT_SIZE vec2(0.13, 0.105)\n\nvec3 sampleLight()\n{\n    vec2 r = (hash2(state) - 0.5) * LIGHT_SIZE;\n    return LIGHT_POS + vec3(r.x, 0, r.y);\n}\n\nvec4 getSkybox(vec3 direction, vec4 wv)\n{\n    vec3 env = sRGBToLinear(texture(iChannel1, direction).rgb);\n    vec4 spd = RGBtoSpectrum(env, wv);\n    return SKYBOX_STRENGTH * spd;\n}\n\nvoid sceneIntersect(Ray ray, out HitInfo hit, out Material mat)\n{\n    hit = HitInfo(MAX_DIST, vec3(0), false);\n    mat = Material(vec4(0), vec4(0), 1.0, 0.0, 1.0);\n    \n    #ifdef USE_CURVE_FIT_SURFACE_REFLECTANCES\n    mat3x4 surfaceRef = getSurfaceReflectanceCurveFit(ray.wv);\n    #else\n    mat3x4 surfaceRef = getSurfaceReflectance(ray.wv);\n    #endif\n    \n    // Walls\n    Ray oldRay = ray;\n    ray.origin -= vec3(0.556, 0.549, 0.559) / 2.0;\n    if (boxIntersectInsideZ(ray, vec3(0.556, 0.549, 0.559) / 2.0, hit))\n    {\n        int idx = 0;\n        vec3 pos = ray.origin + ray.direction * hit.t;\n        if (abs(hit.normal.x) > 0.0)\n        {\n            idx = pos.x < 0.0 ? 2 : 1;\n        }\n        vec4 color = surfaceRef[idx];\n        vec4 emissive = vec4(0);\n        \n        if (!hit.inside && hit.normal.z < 0.0)\n        {\n            vec4 tex = texture(iChannel3, (pos.xy / vec2(0.556, 0.549) + 0.5) / vec2(6, 1));\n            emissive = RGBtoSpectrum(sRGBToLinear(tex.rgb) * tex.a, ray.wv);\n            color *= (1.0 - tex.a);\n        }\n        \n        mat = Material(color, emissive, 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n    // Short box\n    ray.origin -= vec3(0.556 - 0.186, 0.0826, 0.559 - 0.169);\n    mat2 rotMat1 = rot2D(radians(17.0));\n    mat2 rotMat2 = rot2D(radians(-17.0));\n    ray.origin.xz *= rotMat1;\n    ray.direction.xz *= rotMat1;\n    if (boxIntersect(ray, vec3(0.167, 0.165, 0.167) / 2.0, hit))\n    {\n        hit.normal.xz *= rotMat2;\n        //mat = Material(surfaceRef[0], vec4(0.0), 0.0, 0.0, 1.0);\n        mat = Material(surfaceRef[0], vec4(0.0), 1.0, 0.0, 1.333);\n        #if SCENE == 1\n        mat.transmission = 1.0;\n        mat.roughness = 0.4;\n        #endif\n    }\n    ray = oldRay;\n    \n    // Tall box\n    ray.origin -= vec3(0.556 - 0.351, 0.1651, 0.559 - 0.351);\n    ray.origin.xz *= rotMat2;\n    ray.direction.xz *= rotMat2;\n    if (boxIntersect(ray, vec3(0.166, 0.33, 0.168) / 2.0, hit))\n    {\n        hit.normal.xz *= rotMat1;\n        mat = Material(surfaceRef[0], vec4(0.0), 1.0, 0.0, 1.0);\n        #if SCENE == 1\n        mat.roughness = 0.0;\n        #endif\n    }\n    ray = oldRay;\n    \n    // Light\n    ray.origin -= LIGHT_POS;\n    if (boxIntersect(ray, vec3(LIGHT_SIZE.x, 0.0001, LIGHT_SIZE.y) * 0.5, hit))\n    {\n        #if ILLUMINANT == 0\n        vec4 emissive = getLightStrength(ray.wv);\n        #else\n        vec4 emissive = getLightStrengthD65(ray.wv) * 0.18;\n        #endif\n        mat = Material(vec4(0.0), emissive, 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n#if SCENE == 0\n#elif SCENE == 1\n    // Sphere\n    //ray.origin -= vec3(0.2, 0.2, 0.4);\n    if (sphereIntersect(ray, vec3(0.08, 0.15, 0.4), 0.08, hit))\n    {\n        //RGBtoSpectrum(vec3(0.6, 0.2, 0.9), ray.wv)\n        mat = Material(vec4(1), vec4(0.0), 0.0, 1.0, 1.4);\n    }\n    ray = oldRay;\n    \n    /*\n    if (sphereIntersect(ray, vec3(0.2, 0.4, 0.25), 0.005, hit))\n    {\n        mat = Material(vec4(0), getLightStrengthD65(ray.wv), 0.0, 0.0, 1.4);\n    }\n    ray = oldRay;\n    */\n    \n    if (sphereIntersect(ray, vec3(0.44, 0.33, 0.15), 0.1, hit))\n    {\n        mat = Material(surfaceRef[0], vec4(0.0), 0.6, 0.0, 1.0);\n    }\n    ray = oldRay;\n#else\n    \n#endif\n}\n\n#define MIS_HEURISTIC 0\nfloat misWeight(float pdfA, float pdfB)\n{\n    #if MIS_HEURISTIC == 0\n    // Balance heuristic\n    return pdfA / (pdfA + pdfB);\n    #else\n    // Power heuristic\n    return pdfA*pdfA / (pdfA*pdfA + pdfB*pdfB);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    \n    vec2 o = halton(vec2(13, 23) * float(iFrame+1));\n    vec2 pv = (2. * (fragCoord + o - 0.5) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0.278, 0.273, -0.8);\n    vec3 lo = ro + vec3(0, 0, 1.0);\n    \n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame < 2)\n        m = vec4(0.5, 0.5, 0, 0);\n                \n    #ifdef STATIC_CAM\n    m = vec4(0.5, 0.5, 0.0, 0.0);\n    #endif\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(0.5, 0.5, 0, 0);\n        } else\n        {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0)\n            {\n                if (fragColor.zw != vec2(0))\n                    fragColor.xy += (mn - m.zw);\n                fragColor.zw = mn;\n            } else\n            {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    }\n    \n    float ax = -m.x * TAU;\n    float ay = m.y * PI - PI * 0.5;\n    \n    ro -= lo;\n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    #ifdef DOF\n    float dofStrength = DOF_STRENGTH;\n    float dofDist = DOF_FOCUS_DISTANCE;\n    \n    #if DOF_TYPE == 0\n    vec2 rc = randomPointInCircle();\n    #elif DOF_TYPE == 1\n    vec2 rc = randomPointInPolygon(float(DOF_SIDES));\n    #elif DOF_TYPE == 2\n    vec2 rc = randomPointInStar(float(DOF_SIDES));\n    #endif\n    \n    rc *= dofStrength * dofDist;\n    \n    pv -= rc / dofDist;\n    ro += cmat * vec3(rc, 0);\n    #endif\n    \n    vec3 rd = normalize(cmat * vec3(pv, 2.333));\n    \n    vec4 wv = generateWavelengths();\n    \n    vec4 color = vec4(0.0);\n    vec4 throughput = vec4(1.0);\n    \n    Ray ray = Ray(ro, rd, wv);\n    HitInfo hit;\n    Material mat;\n    sceneIntersect(ray, hit, mat);\n    \n    color += mat.emissive;\n    \n    bool dispersed = false;\n    for (int i = 0; i < BOUNCES; i++)\n    {\n    \n        if (hit.t >= MAX_DIST)\n        {\n            #ifdef SKYBOX\n            color += SKYBOX_STRENGTH * throughput * getSkybox(ray.direction, ray.wv);\n            #endif\n            break;\n        }\n        \n        float ior = mat.transmission > 0.0 ? cauchy(wv.x, mat.ior, 0.05) : 1.0;\n        float roughness = mat.roughness * mat.roughness;\n        \n        vec3 diffuseRay = normalize(hit.normal + randomUnitVector());\n        vec3 glossyRay = normalize(mix(reflect(ray.direction, hit.normal), diffuseRay, roughness));\n        vec3 transmissionRay = refract(ray.direction, hit.normal, hit.inside ? ior : 1.0 / ior);\n        transmissionRay = mix(transmissionRay, -diffuseRay, roughness);\n        \n        if (dot(transmissionRay, transmissionRay) < EPSILON)\n            transmissionRay = glossyRay;\n        \n        bool isGlossy = hash(state) > roughness;\n        bool isTransmission = hash(state) < mat.transmission;\n        \n        Ray rayNext;\n        rayNext.origin = ray.origin + ray.direction * hit.t + hit.normal * EPSILON * (1.0 - 2.0 * float(isTransmission));\n        \n        rayNext.direction = isGlossy ? glossyRay : diffuseRay;\n        rayNext.direction = isTransmission ? transmissionRay : rayNext.direction;\n        rayNext.direction = normalize(rayNext.direction);\n        rayNext.wv = ray.wv;\n        \n        HitInfo hitNext;\n        Material matNext;\n        sceneIntersect(rayNext, hitNext, matNext);\n        \n        float G0 = max(dot(rayNext.direction, hit.normal), 0.0) *\n                   max(dot(-rayNext.direction, vec3(0, -sign(rayNext.direction.y), 0)), 0.0) / max(hitNext.t * hitNext.t, EPSILON);\n        \n        // Glossy is un-physical so just made PDF the same as diffuse as well *shrug*\n        vec4 brdf = mat.color / PI;\n        float brdfPdf = 1.0 / PI;\n        float lightPdf = 1.0 / ((LIGHT_SIZE.x * LIGHT_SIZE.y) * G0);\n        \n        float diffuseW = !isTransmission ? misWeight(brdfPdf, lightPdf) : 1.0;\n        \n        vec4 Le = matNext.emissive;\n        color += throughput * Le * diffuseW * brdf / brdfPdf;\n        \n        vec3 lightPos = sampleLight();\n        vec3 lightDir = lightPos - rayNext.origin;\n        float lightDist = length(lightDir);\n        lightDir /= lightDist;\n        \n        float G = max(dot(lightDir, hit.normal), 0.0) *\n                  max(dot(-lightDir, vec3(0, -sign(lightDir.y), 0)), 0.0) / max(lightDist * lightDist, EPSILON);\n        \n        if (!isTransmission && G > 0.0)\n        {\n            Ray rayLight;\n            rayLight.origin = rayNext.origin + lightDir * EPSILON;\n            rayLight.direction = lightDir;\n            rayLight.wv = ray.wv;\n            \n            HitInfo hitLight;\n            Material matLight;\n            sceneIntersect(rayLight, hitLight, matLight);\n            \n            //if (abs(hitLight.t - lightDist) < 1e-3) \n            if (hitLight.t < lightDist && any(greaterThan(matLight.emissive, vec4(0))))\n            {\n                float brdfPdf = 1.0 / PI;\n                float lightPdf = 1.0 / ((LIGHT_SIZE.x * LIGHT_SIZE.y) * G);\n\n                float lightW = misWeight(lightPdf, brdfPdf);\n\n                vec4 lightLe = matLight.emissive;\n                color += throughput * brdf * lightLe / lightPdf;\n            }\n        }\n        \n        throughput *= brdf / brdfPdf;\n        \n        \n        if (isTransmission && !dispersed)\n        {\n            dispersed = true;\n            throughput *= vec4(4, 0, 0, 0);\n        }\n        \n        if (dot(throughput, throughput) < EPSILON)\n            break;\n            \n        ray = rayNext;\n        hit = hitNext;\n        mat = matNext;\n    }\n    \n    #if 1\n    vec3 outColor = wavelengthToXYZ(wv.x) * color.x +\n                    wavelengthToXYZ(wv.y) * color.y +\n                    wavelengthToXYZ(wv.z) * color.z +\n                    wavelengthToXYZ(wv.w) * color.w;\n    outColor /= 4.0;\n    #else\n    vec3 outColor = wavelengthToXYZ(wv.x) * color.x;\n    #endif\n    \n    //outColor = mix(outColor, vec3(0.5), 1.0-saturate(abs(fragCoord.x - iResolution.x * 0.5)));\n    \n#ifndef NO_ACCUMULATE\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    #ifdef STATIC_CAM\n    float blend = iFrame == 0 ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    #else\n    float blend = iFrame == 0 || m.zw != vec2(0) ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    #endif\n    \n    fragColor = vec4(mix(prevColor.rgb, outColor, blend), blend);\n#else\n    fragColor = vec4(outColor, 1);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}