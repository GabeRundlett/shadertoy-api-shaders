{
    "Shader": {
        "info": {
            "date": "1495941084",
            "description": "Hello from Mexico!",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlfW8",
            "likes": 1,
            "name": "18/100",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "yahe",
            "viewed": 544
        },
        "renderpass": [
            {
                "code": "float distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat map_the_world(in vec3 p)\n{\n    float displacement = sin((sin(iTime/4.0)+2.0)*3.0 * p.x) * sin((sin(iTime/4.0)+2.0)*3.0  * p.y) * sin((sin(iTime/4.0)+2.0)*3.0  * p.z) * 0.25;\n    float sphere_0 = distance_from_sphere(p, vec3(0.0), .50* (abs(cos(iTime/4.))+1.));\n\n    return sphere_0 + displacement;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        float distance_to_closest = map_the_world(current_position);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            vec3 light_position = vec3(2.0 * sin(iTime), -5.0 * cos(iTime), 3.0* sin(iTime));\n            vec3 direction_to_light = normalize(current_position - light_position);\n\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n            vec3 green = vec3(0.0, 0.4078, 0.2784);\n            vec3 red = vec3(0.76078, 0.0667, 0.1451);\n            return mix(green, red, sin(iTime)) * diffuse_intensity;\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x -= .8;\n    \n    \n\n    vec3 camera_position = vec3(0.0, 0.0, -2.);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv, 1.0);\n\n    vec3 shaded_color = ray_march(ro, rd);\n\n    vec3 cl = max(shaded_color,vec3(0.0, .012, .12));\n    fragColor = vec4(cl, 1.0) ;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}