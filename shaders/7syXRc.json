{
    "Shader": {
        "info": {
            "date": "1635023594",
            "description": "Another HOLHO 4 animation. https://holhocollection.com",
            "flags": 32,
            "hasliked": 0,
            "id": "7syXRc",
            "likes": 10,
            "name": "HOLHO Twist",
            "published": 3,
            "tags": [
                "holho"
            ],
            "usePreview": 0,
            "username": "shau",
            "viewed": 462
        },
        "renderpass": [
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n * Simple animation for a HOLHO viewer \n * Official HOLHO 4 viewer used to test this animation\n * https://holhocollection.com\n * Tested on official iPhone Shadertoy App using High Quality settings\n * Adjust BOXWIDTH to suite your device\n * Make your own HOLHO viewer \n * https://www.youtube.com/watch?v=Xhu-XjXa4p4\n */\n\n//THIS BUFFER TRANSLATES OUTPUT OF BUFFERS TO 4 VIEWS\n//Most examples I have seen use a single scene projected onto 4 faces of viewer\n//Set USE_PROJECTION to 1 in common to use individual (front,right,rear,left) \n//projected views onto each face of viewer\n\nvec3 renderBox(sampler2D tx, vec2 uv, ivec2 u)\n{\n    if (uv.y>0.0 && abs(uv.x)<uv.y)\n    {\n        return texelFetch(tx,u,0).xyz; \n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0);\n    ivec2 iU = ivec2(U),\n          imageBox = imageDimensions(R);\n    vec2 uv = (U - R*.5) / R.y;\n    \n    \n    //TOP BOX\n    ivec4 box = ivec4(int(R.x)/2-imageBox.x/2,\n                      int(R.x)/2+imageBox.x/2, \n                      int(R.y)/2,\n                      int(R.y)/2+imageBox.y);\n    #if USE_PROJECTIONS==1 \n    //projected rear view\n    col += renderBox(iChannel2,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     uv,\n                     ivec2(iU.x-box.x,\n                           iU.y-box.z));\n    #endif\n    \n    //RIGHT BOX\n    box = ivec4(int(R.x)/2,\n                int(R.x)/2+imageBox.y, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected right view\n    col += renderBox(iChannel1,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     vec2(uv.y,uv.x),\n                     ivec2(box.w-iU.y,\n                           iU.x-box.x)); \n    #endif\n    \n    //BOTTOM BOX\n    box = ivec4(int(R.x)/2-imageBox.x/2,\n                int(R.x)/2+imageBox.x/2, \n                int(R.y)/2-imageBox.y,\n                int(R.y)/2);\n    //default front view - also default projection\n    col += renderBox(iChannel0,\n                     vec2(uv.x,-uv.y),\n                     ivec2(box.y-iU.x,\n                           box.w-iU.y));\n    \n    //LEFT BOX                        \n    box = ivec4(int(R.x)/2-imageBox.y,\n                int(R.x)/2, \n                int(R.y)/2-imageBox.x/2,\n                int(R.y)/2+imageBox.x/2);\n    #if USE_PROJECTIONS==1 \n    //projected left view\n    col += renderBox(iChannel3,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #else\n    //default front view\n    col += renderBox(iChannel0,\n                     vec2(uv.y,-uv.x),\n                     ivec2(iU.y-box.z,\n                           box.y-iU.x)); \n    #endif\n\n    //debug buffer output\n    //col = texture(iChannel3,U/R).xyz;\n\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-------\n\n#define PI 3.141592\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 100.0\n#define FL 2.6\n\n#define LA vec3(0,-3,0.0)\n#define RO vec3(0,3,4.5)\n\n//0 PROJECT FRONT ONTO ALL FACES  \n//1 PROJECT FRONT, REAR, LEFT, RIGHT ONTO EACH FACE  \n#define USE_PROJECTIONS 1\n//PREFERED WIDTH OF RENDERING\n#define BOXWIDTH 1300\n\n//RAYMARCHING AND SHADER IN COMMON TO HANDLE CASES THAT NEED\n//MULTIPLE CAMERA ANGLES (ALSO MULTIPLE BUFFERS)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n/* MODEL START */\n\n//SDF functions IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 6.283185/repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat map(vec3 p, float T) \n{\n    vec3 q = p;\n    q.y -= T;\n    q.xz *= rot((q.y*2.0+sin(T*0.7)*2.1)*0.1);\n    pModPolar(q.xz,3.0);\n    q.yz = mod(q.yz,0.4)-0.2;\n    return length(q-vec3(2,0,0));\n}\n\n/* MODEL END */\n\n\nvec3 march(vec3 ro, vec3 rd, float T)\n{\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i=0; i<100; i++)\n    {\n        vec3 p = ro+rd*t;\n        float ns = map(p,T);\n        \n        col += rotHue(vec3(1.0,0.5,0.2),p.y*0.3-sin(T*1.3)*2.9)*0.2/(1.0+ns*ns*100.0);\n\n        t += ns;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return col;\n}\n\nivec2 imageDimensions(vec2 r)\n{\n    int a = min(BOXWIDTH,min(int(r.x),int(r.y)));\n    return ivec2(a,a/2);\n}\n\nvec3 camera(vec2 U, vec2 r, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - r*.5) / r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER FRONT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    ro.xz *= rot(iTime*-0.2);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    \n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER RIGHT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    #if USE_PROJECTIONS==1      \n    ro.xz *= rot(iTime*-0.2+PI*0.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    #endif\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER REAR VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    #if USE_PROJECTIONS==1     \n    ro.xz *= rot(iTime*-0.2+PI);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    #endif\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//RENDER LEFT VIEW TO BUFFER\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec3 col = vec3(0.0),\n         ro = RO;\n    #if USE_PROJECTIONS==1\n    ro.xz *= rot(iTime*-0.2+PI*1.5);\n    ivec2 imageBox = imageDimensions(R);\n    \n    if (ivec2(U).x<imageBox.x && ivec2(U).y<imageBox.y)\n    {\n        col = march(ro,camera(U,vec2(imageBox),ro,LA,FL),iTime);\n    }\n    #endif\n    C = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}