{
    "Shader": {
        "info": {
            "date": "1669673203",
            "description": "An experiment with a 3D transparent type of raymarcher.\nResults in a chain of constantly morphing kaleidoscopic menger cubes looking kind of sacred.\n\nRotate view by dragging mouse.\n\nsubstance reference: DPT (Dipropyltryptamine)",
            "flags": 0,
            "hasliked": 0,
            "id": "cdsSRf",
            "likes": 18,
            "name": "The Way of Light",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "tunnel",
                "transparent"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 530
        },
        "renderpass": [
            {
                "code": "//                    = The Way of Light =         \n//               by Maximilian Knape  ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(1) //vec3(.4545)\n\n#define MAX_STEPS 300\n#define MAX_DIST 500.\n#define MIN_DIST 10.\n#define STEP_FAC 5.\n\n#define SURF_DIST .001\n#define SURF_MUL 1000.\n#define SURF_EXP 5.\n\n#define PP_ACES 0.\n#define PP_CONT 0.8\n#define PP_VIGN 2.0\n\n#define iTime iTime*1.0\n#define PI 3.14159265358979\n#define TAU 6.28318530717958\n#define S(x,y,t) smoothstep(x,y,t)\n\nvec2 Map(vec3 p) \n{    \n    float d = MAX_DIST, col = 0.;\n    vec3 op = p;\n    \n    float s = 22.; //size\n    float sp = iTime*5.; //speed\n    \n    \n    p.z = mod(abs(s*2. - mod(p.z + sp, s*4.)), s*4.); //mirror\n    p.xy += normalize(p.xy) * (S(0., MAX_DIST, op.z)*40. - S(0., MAX_DIST, -op.z)*30.); //xy size\n    p.xy *= Rot(PI/4. * step(0., sin(PI*(op.z + sp) / (8.*s)))); //rotator\n    \n    float cy = length(op.xy);\n    if (cy < s*5.) //bounding cylinder\n    {\n        vec2 glow = sdKMC( //light fractal\n                p/8., 3, vec3(pow(sin(iTime/32. + op.z/s*.1), 3.)*2.), \n                vec3(pow(sin(iTime/42. + op.z/s*.01), 3.)*PI/4.), \n                vec4(1,3,5,5)); \n\n        float split = 30. + sin(iTime/13.)*10.; //two colors/materials\n        \n        glow.x = pow(glow.x, 1.5 + step(split, glow.y) * (sin(iTime - op.z/s)-1.)*.3); //color waves\n        glow.x -= (pow(sin(-(op.z + sp) / s), 2.) - step(split, glow.y))*.001; //thickness\n        \n        col = mix(col, 1.0 - step(glow.y, split), step(glow.x, d)); //color\n        d = min(glow.x, d); \n    }\n    else d = min(d, cy - s*7.);\n    \n    return vec2(d, col);\n}\n\nvec3 Palette(int index, float depth)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.)*.8;\n        case 1: return hsv2rgb_smooth(vec3(fract(depth), .9, 1.));\n    }\n    return vec3(0.);\n}\n\nvec3 RTM(vec3 ro, vec3 rd) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIST;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0), col = vec3(1);\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIST * (pow(d/MAX_DIST, SURF_EXP)*SURF_MUL+1.)); //can be DOF\n        if (s < sd || d > MAX_DIST) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        \n        vec2 map = Map(p);\n        col = mix(col, Palette(int(floor(map.y)), (p.z-iTime*5.)/MAX_DIST*.5), .02 * (1.-sum)); //color overlap\n        \n        s = max(abs(map.x), 2. * sd);\n        d += s * STEP_FAC * (1.1 - fract(map.y));\n        \n        sum += a;\n    }\n    \n    float dp = pow(1. - (length(ro - p) / MAX_DIST), SURF_EXP);\n    \n    col *= sum - dp;\n    \n    if (dp <= 10e-1) //Background\n    {\n        float dir = dot(vec3(0,0,1), rd)*.5+.5;\n        float bg = pow(dir, 5.)*.2; //glow\n        bg += pow(dir, 5000.)*.8; //core\n        bg *= (1. - S(.99, .9, dir) * //rays\n                    noise(normalize(vec2(abs(rd.x), rd.y)*Rot(iTime/25.)) * \n                    (10.+5.*sin(iTime/17.))));\n        \n        col += bg;\n    }\n    \n    col *= pow(1. - max(0., dot(vec3(0,0,-1.), rd)), .1);\n        \n    return col;\n}\n\nvec4 PP(vec3 col, vec2 uv) //PostProcessing\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES);\n    col = mix(col, S(vec3(0.1), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(0., 0., -10.);\n    ro.yz *= Rot(-m.y * PI + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0., 0., 0.), .7);\n\n    fragColor = PP(RTM(ro, rd), uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//   -----= Inigo Quilez =-----\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat hash(float n) { return fract(sin(n)*43758.5453123); }\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n//   -------= IQ END =-------\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 Rot(in vec3 p, in vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\n\nvec2 sdKMC( in vec3 p,    //KIFS Mengerbox\n            in int iters,\n            in vec3 fTra,\n            in vec3 fRot,\n            in vec4 para)\n{\n    int i;\n    float d, col = 0.;\n    float x1, y1;\n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 10e2; i++)\n    {\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= 0.5 * para.x * (para.y - 1.) / para.y;\n        p.z = -abs(p.z);\n        p.z += 0.5 * para.x * (para.y - 1.) / para.y;\n\n        p.x = para.y * p.x - para.z * (para.y - 1.);\n        p.y = para.y * p.y - para.w * (para.y - 1.);\n        p.z = para.y * p.z;\n\n        col = r;\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n        \n        p -= fTra;\n        p = Rot(p, fRot);\n    }\n    \n    d = length(p) * pow(para.y, float(-i));\n\n    return vec2(d, col);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l, in float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}