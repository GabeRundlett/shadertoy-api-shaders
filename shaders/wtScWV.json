{
    "Shader": {
        "info": {
            "date": "1595360190",
            "description": "using Barycentric coordinates and pointers to predict, what line.segments are closest to a point.\n\norange+teal= correct\nred/purple has false interior, looks like a \"hole\" but ALWAYS needs less divisions.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtScWV",
            "likes": 5,
            "name": "semiBarycentric triangle dist",
            "published": 3,
            "tags": [
                "2d",
                "triangle",
                "distance",
                "barycentric",
                "predict"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 806
        },
        "renderpass": [
            {
                "code": "//sibling   (interactive): https://www.shadertoy.com/view/wl2cRt#\n//parent (smaller canvas): https://www.shadertoy.com/view/XsXSz4\n//but still:\n// The MIT License\n// Copyright Â© 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nPointDistanceToStriangle naively has [3 divisions] and [9 dot()] for 3 line distances.\nsemiBaricentric quite efficiently uses barycentric coordinates to exclude\nthe triangle borders that are NOT nearest to the uv, with lots of if(a>b)\n,that are still quite similar within most branching paths\n\nconverting to barycentric adds 1 division\n, to get the same BaricentricDeterminantReciprocal for every fragment \n(this is a fragment shader precomputing task\n;1 determinant foreach unique triangleShape)\n\nThan semiBaricentric has [1 to 3 divisions] and [3 to 9 dot].\nThe inside of the triangle is the only place with the highest complexity.\nMost of the area outside of the triangle will only do 1 division and 3 dot.\n\nsemiBaricentric        is roughly 16 to 22 substractions/additions (and lots of swivels and negations)\nparent (common method) is         13       substractions/additions\nBoth only ned 1 deferred sqrt()\nsemiBaricentric is one less sign()\n*/\n\n//addendum 2020-11\n//me dumb, if(inside  triangle) the smallest barycentricCoord value tells me what line is closest to the point\n//me dumb, if(outside triangle && only one <1) the only barycentricCoordinate that is <0 tells me the closest line\n//me dumb, if(outside triangle && only one >0) the only barycentricCoordinate that is >0 tells the the closest corner\n\n\nconst float twothirds=2./3.;//is not a division on runtime.\n\nconst vec3 vs=vec3(-1,0,1);\nvec2 perp(vec2 a){return a.yx*vs.xz;}\nvec3 sat(vec3 a){return clamp(a,vec3(0),vec3(1));}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat suv(vec2 a){return a.x+a.y;}\nfloat sat(float a){return clamp(a,0.,1.);}\n\n#define dd(a) dot(a,a)\n/*\n//segment(() is a very general distance to line segment (Uv Origin Target):\n#define segment2(a,c,d) dd((a-(c*d((dot(a,c)/dd(c))))))      \n#define segments(u,o,t,d) (segment2((u-o),(t-o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n*/\n//same as above, but in batches, too have less sqrt()\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\nfloat segment(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segment(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segment(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n//carthesian transform, duped for transposed-inputs variants\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant, you may want to buffer this more globally\nfloat c2bdet(vec3 X,vec3 Y){return 1./suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//return barycentric of carthesian point (l) over triangle (a,b,c)==(X,Y)\nvec3 c2b(vec2 p,vec3 X,vec3 Y,float d){p-=vec2(X.z,Y.z)\n ;vec4 a=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*p.xyxy\n ;p=vec2(suv(a.xy),suv(a.zw))*d;return vec3(p,1.-p.x-p.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float carthesianDet=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //carthesianDet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //carthesianDet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,carthesianDet)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segment(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segment(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segment(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segment(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}}\n  //min of 3 line distances only inside the triangle\n\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}//put corners in matrix, to point at them\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n ;vec2 v1=cos(iTime+vec2(0.,2.00)+0.)\n ;vec2 v2=cos(iTime+vec2(0.,1.50)+1.5)\n ;vec2 v3=cos(iTime+vec2(0.,3.00)+4.)\n ;float d=sdTriangle(v1,v2,v3,p)\n ;vec3 blue=vec3(1,4,7)*.1\n ;if(mod(iTime*.3,2.)<1.)blue=vec3(6,2,6)*.1\n ;vec3 c=vec3(1)-sign(d)*blue\n ;c*=1.-exp(-2.0*abs(d))\n ;c*=.8+.2*cos(120.*d)\n ;c=mix(c,vec3(1),1.-smoothstep(0.,.02,abs(d)))\n ;fragColor=vec4(c,1)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}