{
    "Shader": {
        "info": {
            "date": "1463421002",
            "description": "Description of the process used to make this video:\n[url]https://vimeo.com/defgsus/shadertoy[/url]\nDrag mouse up/down to blend between flat browser and fulldome view. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms3SR2",
            "likes": 17,
            "name": "Shadertoy on Dome",
            "published": 3,
            "tags": [
                "3d",
                "fulldome"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 1187
        },
        "renderpass": [
            {
                "code": "/*\tShadertoy on Dome - https://www.shadertoy.com/view/Ms3SR2\n  \t(cc) 2016, Stefan Berke / berke@cymatrix.org\n\n  \tA little making-of of my https://vimeo.com/defgsus/shadertoy video. \n   \n  \tThis uses the \"Voxel Edges\" shader from iq as example\n  \thttps://www.shadertoy.com/view/4dfGzs\n\n    The typical Shadertoy mainImage() function is extended to \n\t\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord, \n                   in vec3 sphereDir, in float sphereMix)\n\n\twhere sphereDir is the normalized ray direction of the spherical\n\tfulldome view and sphereMix is a mix variable between 0 and 1. \n\n\tIn order to view a particular 3d-shader on the dome i overwrite the\n\tray direction before the ray-marching. To make the transition between\n\tthe flat screen and the fulldome/fisheye view seamless the sphereMix\n\tvariable is used. \n\t\n\tAlso all post-processing wich depends on the uv-screen-coordinate\n\t(like vignetting) is mixed out, because there is no screen coordinate\n\tin fulldome view.\n\n\tSee the _uv_to_sphere(in vec2 uv, in float angle) function below in\n\tthe helper section for the screen-to-fulldome conversion. \n\tIn my video above, i used a skybox and the 5-camera-rig model to \n\trender the fulldome master.\n\n\tTo get the right fulldome ray direction for the 'shader' in the virtual browser,\n\ti simply use the direction of the ray which hits the browser plane in the \n\tfirst place. If your 3d environment supports fulldome rendering via 5-camera-rigs\n\tor other means that should be no problem. Otherwise you can use the approach\n\tfrom this shader and simply render everything on the screen-quad using _uv_to_sphere().\n\t\n\t\n\tThank you Shadertoyers around the world for all your effort and inspiration!\n*/\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 ed = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 co = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 ep = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 cp = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        vec4 ee = 1.0-ep*(1.0-ed);\n        float www = 1.0;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.x )*ee.x;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.x )*ee.y;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.y )*ee.z;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.y )*ee.w;\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x))*(1.0-ee.x)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y))*(1.0-ee.y)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z))*(1.0-ee.y)*(1.0-ee.w);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w))*(1.0-ee.x)*(1.0-ee.w);\n\t\t\n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = 2.0*texture( iChannel1,0.01*pos.xz ).zyx; \n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = 0.0; \n        // (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        // (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-ep.x*(1.0-ed.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-ep.y*(1.0-ed.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-ep.z*(1.0-ed.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-ep.w*(1.0-ed.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.90, 0.95, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImageST(out vec4 fragColor, in vec2 fragCoord, \n                 in vec3 sphereDir, in float sphereMix)\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n    \n    // XXX Here the ray-direction is mixed\n    rd = mix(rd, cam * sphereDir, sphereMix); \n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\n    vec3 ppcol = col * (0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ) );\n\t\n    // XXX Here we mix the color with the post-processed color\n    // which depends on the screen uv\n    col = mix(col, ppcol, 1.-sphereMix);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n// -------------- helper -----------------------------------\n\n/* Insert cartesian [-1,1], receive sphere surface [-1,1].\n   @p angle is in degree */\nvec3 _uv_to_sphere(in vec2 uv, in float angle)\n{\n    // distance from center\n    float dist = length(uv);\n\n    if (dist > 1.0)\n        return vec3(0.);\n\n    float   // cartesian screen-space to spherical\n            theta = dist * 3.14159265 * angle / 360.0,\n            phi = atan(uv.y, uv.x);\n\n    // spherical-to-cartesian\n    return vec3(sin(theta) * cos(phi),\n                sin(theta) * sin(phi),\n                -cos(theta));\n}\n\n/** Returns intersection position along the ray ro -> rd\n    for a plane with normal plane.xyz and position plane.xyz * plane.w.\n    Result is either negative for no hit\n    or the distance between ro and the intersection point. */\nfloat _intersect_plane(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    float dir = dot(plane.xyz, rd);\n    if (abs(dir) < 0.0001) return -1.;\n    return dot(plane.xyz, plane.xyz * plane.w - ro) / dir;\n}\n\nfloat _hash1(in vec2 x) { return fract(sin(x.x*11.+x.y*17.)*(17162.31+111.*x.y)); }\nvec2 _hash2(in vec2 x) { return vec2(_hash1(x),_hash1(x*1.1-3.13)); }\n\n\n// ----- chars ---------------------------------------------\n\n// uv = [-1,1]\nfloat _random_char(in vec2 uv, in vec2 seed)\n{\n    float l = length(uv);\n    float d = 100.;\n#define SEG(prob, di) d = min(d, floor(1./(prob)*_hash1(seed+=.1*seed-.1)) + di);\n    SEG(.3 , abs(uv.x - uv.y*.8)-.2)\n    SEG(.3 , abs(uv.x + uv.y*.8)-.2)\n    SEG(.3 , abs(uv.x)-.15)\n    SEG(.1 , abs(uv.y)-.15)\n    SEG(.1 , abs(uv.y-.7)-.15)\n    SEG(.1 , abs(uv.x-.7)-.2)\n    SEG(.1 , abs(uv.x+.7)-.2)\n    SEG(.07, max(l-.8, -l+.5))\n    SEG(.1 , max(max(l-.8, -l+.5), -uv.x))\n    SEG(.1 , max(max(l-.8, -l+.5),  uv.x))\n#undef SEG\n    d = max(d, -uv.x-.8);    \n    d = max(d,  uv.x-.8);    \n    d = max(d, -uv.y-.8);    \n    d = max(d,  uv.y-.8);    \n        \n\t//d = max(d, -d); // edge\n        \n    return smoothstep(.1, .0, d);\n}\n\n/** creates left-bounded text, one char per uv-unit */\nfloat _random_text(in vec2 uv, in vec2 seed, in float max_len)\n{\n    vec2 cell = floor(uv); \n    if (uv.x >= max_len || _hash1(vec2(cell.y)) < cell.x / max_len) \n        return 0.;\n    \n    return _random_char(fract(uv)*2. - 1., cell + seed);\n\t     \n}\n// --------------------------------------------------\n\n\n// --------------- fake browser ---------------------\n\nfloat _rect(in vec2 uv, in vec2 si)\n{\n    return uv.x >= 0. && uv.y >= 0. && uv.x <= si.x && uv.y <= si.y ? 1. : 0.; \n}\n\nvec4 _codeWindow(in vec2 uv, in vec2 si)\n{\n    vec4 col = vec4(1,1,1, _rect(uv,si));\n    col.xyz *= 1.-_random_text(uv*40., vec2(1.), 40.);\n\treturn col;\n}\n\nvec4 _browserWindow(in vec2 uv, in float aspect, \n                    in float sphereMix, in vec3 sphereDir)\n{\n    vec2 si = vec2(aspect, 1.);\n    vec4 col = vec4(.8,.8,.8, _rect(uv, si));\n\t\n    // header\n    float head = _rect(uv-vec2(0.,.92), si * vec2(1.,.08));\n    col.xyz += head * (vec3(.4) - col.xyz);\n\tcol.xyz += head * _random_text(uv*12.-vec2(0,10), vec2(5), 10.);\n    vec2 headuv = (uv-vec2(si.x/1.7,0.11)) * 24.;\n    if (headuv.x > 0. && int(headuv.y) == 20)\n\tcol.xyz += head * _random_text(headuv, vec2(.1), 50.);\n    \n    // code window\n    vec4 cCode = _codeWindow(uv-si/vec2(2.1,5.), si*vec2(.5,.63));\n    col += cCode.w * (cCode - col);\n    col.xyz *= 1.-.3*_rect(uv-si/vec2(2.1,1.2), vec2(.06, .05));\n    col.xyz += _rect(uv-si/vec2(1.95,1.2), vec2(.09, .05)) * (vec3(1.,.7,0) - col.xyz);\n    \n    // texture inputs\n    for (float i=0.; i<4.; ++i)\n    \tcol.xyz *= 1. - _rect(uv - vec2(si.x/2.1 + si.x*i/8.,.02), si/8.5);\n    \n    // messages\n    if (uv.x > 0.02 && uv.y < .3)\n    \tcol.xyz *= 1. - _random_text((uv-vec2(0.02,0))*40., vec2(.1), 30.);\n    \n    // shader window\n    vec2 suv = (uv - vec2(.03, .38)) * vec2(2.3/si.x, 2.);\n    if (suv.x >= 0. && suv.y >= 0. && suv.x < 1. && suv.y < 1.)\n        mainImageST(col, suv * iResolution.xy, sphereDir, sphereMix);\n    \n    return col;\n}\n\n// --------------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float onDome = .5+.6*sin(iTime/4.+.3);\n    if (iMouse.z > .5)\n        onDome = iMouse.y / iResolution.y * 1.1;\n    onDome = clamp(onDome, 0., 1.);\n    \n    \n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n    if (length(uv) > 1.)\n        fragColor = vec4(0,0,0,1);\n    else\n    {\n        // fulldome/fisheye ray direction \n        vec3 sphereDir = _uv_to_sphere(uv, 180.);\n\n        // render dome image\n       \tmainImageST(fragColor, fragCoord, sphereDir, 1.);\n        fragColor.xyz *= onDome * onDome;\n\t\t\n        // render browser window\n        if (onDome < 1.)\n        {\n            vec3 planeNorm = normalize(vec3(0,1,2.-onDome));\n            float t = _intersect_plane(vec3(0.), sphereDir, vec4(planeNorm,-(1.-onDome)));\n            if (t > 0.)\n            {\n                vec2 puv = (sphereDir * t).xy+1.-.4*onDome;\n                vec4 c = _browserWindow(puv, 1.9, onDome, sphereDir);\n                fragColor.xyz += c.w * (c.xyz - fragColor.xyz);\n            }\n        }\n        \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}