{
    "Shader": {
        "info": {
            "date": "1675579617",
            "description": "3D Circle music spectre",
            "flags": 64,
            "hasliked": 0,
            "id": "DtjSRz",
            "likes": 7,
            "name": "3D Circle music spectre",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "MiniByte",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "// ##############################\n// BEGIN\tIQ methods\n// ##############################\n\n// Calculate matrix for camera looking at a specific target\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.2);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n// ##############################\n// END\t\tIQ methods\n// ##############################\n\n\n#define PI 3.14159265\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 5.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/1.5)) c = abs(c);\n\treturn c;\n}\n\n\n// ##############################\n// BEGIN\tCamera helpers\n// ##############################\nuniform float iCamPosX;\nuniform float iCamPosY;\nuniform float iCamPosZ;\nuniform float iCamRotX;\nuniform float iCamRotY;\nuniform float iCamRotZ;\n\nvec3 calcCameraPos()\n{\n\treturn vec3(iCamPosX, iCamPosY, iCamPosZ);\n}\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov/5.5*3.14159/180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 5.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 3.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n// ##############################\n// END\t\tCamera helpers\n// ##############################\n\n// Change this to change repetition interval\nfloat afFrequencies[20];\n\nfloat cubeCircle(vec3 point, float radius, int count, vec3 cubeSize)\n{\n\tfloat c = pModPolar(point.xz, float(count));\n\tfloat index = floor(c + float(count)/2. -1.);\n\n\treturn fBox( point-vec3(radius,0,0), cubeSize + vec3(0, 0.2 + 0.7*afFrequencies[int(mod(index,float(afFrequencies.length())))] , 0));\n}\n\n//\tCalculates distance to nearest object given a point\nfloat distFunc( vec3 point )\n{\n\t//\tparameters\n\tint circleTiles = 400;\n\tfloat radius = 5.;\n\tvec3 cubeSize = vec3(0.02);\n\n\t//\tdistance to floor plane\n\tfloat planeDist = sdPlane(point);\n\n\t//\tdistances to the cube circles\n\tfloat cubesCircleBigDist = cubeCircle(point, radius, circleTiles, cubeSize);\n\tfloat cubesCircleSmallDist = cubeCircle(point, radius/2., circleTiles/2, cubeSize);\n\n\t//\tblack cube in the center\n\tpoint.y -= 1.0;\n\trotateAxis(point.yz, radians(45.0));\n\trotateAxis(point.xy, PI/4.);\n\tfloat boxDist = fBox( point, 5.*cubeSize*afFrequencies[2] );\n\n\t//\treturn closest object\n\treturn min(min(min(cubesCircleBigDist, boxDist), cubesCircleSmallDist), planeDist);\n}\n\nvec3 getNormal( in vec3 pos )\n{\n\t// IQ\n\tvec2 e = vec2( 1.0,-1.0 ) * 0.001;\n\treturn normalize( e.xyy*distFunc( pos + e.xyy ) +\n\te.yyx*distFunc( pos + e.yyx ) +\n\te.yxy*distFunc( pos + e.yxy ) +\n\te.xxx*distFunc( pos + e.xxx ) );\n}\n\nvec3 getMaterialColor(vec3 point)\n{\n\t//\tfloor color\n\tif(point.y < 0.0001)\n\t{\n\t\treturn vec3( 0.5 );\n\t}\n\n\t//\tcolor for center area\n\tif(length(point.xz) < 1.0)\n\t{\n\t\treturn vec3( 0.0, 0.0, 0.0 );\n\t}\n\n\t//\totherwise determine color based on angle\n\tfloat count = 64.;\n\n\t//\tCalculate ID for each segment of the circular rotation\n\tfloat c = pModPolar(point.xz, count);\n\n\treturn vec3(0.45*sin(((c+iTime)/count)*2.*PI)+0.55);\n}\n\nfloat softshadow(const vec3 origin, in vec3 dir, in float mint, in float tmax, float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = distFunc( origin + dir*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat ambientOcclusion(vec3 point, float delta, int samples)\n{\n\tvec3 normal = getNormal(point);\n\tfloat occ = 0.;\n\tfor(float i = 1.; i < float(samples); ++i)\n\t{\n\t\tocc += (2.0/i) * (i * delta - distFunc(point + i * delta * normal));\n\t}\n\t// occ = clamp(occ, 0, 1);\n\treturn 1. - occ;\n}\n\n\n//\tLighting settings\n#define ENABLE_SHADOWS\n//#define ENABLE_OCCLUSION\n\nconst float lightAttenuation = 0.00;\n\nvec3 getShadedColor( vec3 hitPosition, vec3 normal, vec3 cameraPosition )\n{\n\t//\tlight relative to camera position\n\tvec3 lightPosition = vec3(sin(iTime), 3.0, cos(iTime));\n\n\t//\tSpecular highlight factor\n\tfloat materialShininess = 64.0;\n\tvec3 materialSpecularColor = vec3( 1.0 );\n\n\t//\tOutput color\n\tvec3 outputColor = vec3( 0.0 );\n\n\t//\tCalculate eye vector and its reflection\n\tvec3 surfaceToLight = normalize(lightPosition - hitPosition);\n\tvec3 surfaceToCamera = normalize(cameraPosition - hitPosition);\n\n\t//\tsurface color\n\tvec3 surfaceColor = getMaterialColor(hitPosition);\n\n\t//\tambient component\n    vec3 lightColor = vec3(abs(sin(iTime*0.84)), abs(cos(iTime)), abs(sin(iTime*1.337)))*smoothstep(-0.3, 1.0, afFrequencies[0]);\n\tvec3 ambientColor = surfaceColor * lightColor * 0.0; // ambient factor\n\n\t//\tdiffuse component\n\tfloat diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));\n\tvec3 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;\n\n\t//\tspecular component\n\tfloat specularCoefficient = 0.0;\n\tif(diffuseCoefficient > 0.0) {\n\t\t//specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);\n\t}\n\tvec3 specularColor = specularCoefficient * materialSpecularColor * lightColor;\n\n\t//\tlight attenuation (falloff based on distance, fog)\n\tfloat distanceToLight = length(lightPosition - hitPosition);\n\tfloat attenuation = 1.0 / (1.0 + lightAttenuation * pow(distanceToLight, 2.0));\n\n\t//\tsoft shadows (optional)\n\tfloat shadow = 1.0;\n\t#ifdef ENABLE_SHADOWS\n\tshadow = max(0.2, softshadow(hitPosition, surfaceToLight, 0.01, 5.0, 8.0));\n\t#endif\n\n\t//\tambient occlusion (optional)\n\tfloat occlusionCoefficient = 1.0;\n\t#ifdef ENABLE_OCCLUSION\n\tocclusionCoefficient = ambientOcclusion(hitPosition, 0.01, 10);\n\t#endif\n\n\t//\tcalculate final color\n\toutputColor = ambientColor + occlusionCoefficient * shadow * attenuation*(diffuseColor + specularColor);\n\n\t//\tgamma correction\n\t//vec3 gamma = vec3(1.0/2.2);\n\t//outputColor = vec3(pow(outputColor, gamma));\n\n\t//\treturn shading result\n\treturn outputColor;\n}\n\nconst float epsilon = 0.0001;\nconst int maxSteps = 256;\nconst float maxT = 20.0;\nfloat trace(vec3 ro, vec3 rd, out vec3 point, out bool objectHit)\n{\n\tfloat t = 0.0;\n\tpoint = ro;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n\t{\n\t\t//check how far the point is from the nearest surface\n\t\tfloat dist = distFunc(point);\n\t\t//if we are very close\n\t\tif(epsilon > dist)\n\t\t{\n\t\t\tobjectHit = true;\n\t\t\tbreak;\n\t\t}\n\t\t//not so close -> we can step at least dist without hitting anything\n\t\tt += dist;\n\t\t// return immediately if maximum t is reached\n\t\tif(t > maxT)\n\t\t{\n\t\t\tobjectHit = false;\n\t\t\treturn maxT;\n\t\t}\n\t\t//calculate new point\n\t\tpoint = ro + t * rd;\n\t}\n\n\treturn t;\n}\n\nvoid populateSoundArray()\n{\n    // Get FFT values from texture\n    for (int i = 0; i < afFrequencies.length(); i++)\n    {\n        afFrequencies[i] = texture( iChannel0, vec2(float(i)/float(afFrequencies.length()), 0.25) ).x;\n    }\n}\n\nconst int reflectionBounces = 1;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fill arrays for sound things\n    populateSoundArray();\n    \n\t//\tSet up Camera\n\tvec3 camP = calcCameraPos(); // Camera position\n\n\t//\tMove camera in a circle\n\tcamP += vec3(5.0*cos(iTime*0.25), 1.5*cos(iTime*0.2)+2.5,  5.0*sin(iTime*0.25));\n\n\t//\tAlways look at center\n\tvec3 target = vec3(0.0);\n\tmat3 cameraMatrix = setCamera( camP, target, 0.0 );\n\tvec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n\tvec3 camDir = cameraMatrix * normalize( vec3(p.xy, 2.0) );\n\n\t//\tSet up ray\n\tvec3 point;\t\t// Set in trace()\n\tbool objectHit;\t// Set in trace()\n\n\t//\tInitialize color\n\tvec3 color = vec3(0.0);\n\n\tfloat t = trace(camP, camDir, point, objectHit);\n\tif(objectHit)\n\t{\n\t\t//\tLighting calculations\n\t\tvec3 normal = getNormal(point);\n\t\tcolor = getShadedColor( point, normal, camP );\n\n\t\t//\tReflections\n\t\tfor(int i = 0; i < reflectionBounces; i++)\n\t\t{\n\t\t\tvec3 pointRef;\t// Set in trace()\n\t\t\tcamDir = reflect(camDir, normal);\n\t\t\ttrace(point + camDir*0.001, camDir, pointRef, objectHit);\n\t\t\tif(objectHit)\n\t\t\t{\n\t\t\t\t// Get color of reflection\n\t\t\t\tcolor += 0.1 * getShadedColor( pointRef, getNormal(pointRef), point );\n\t\t\t}\n\t\t\tpoint = pointRef;\n\t\t}\n\t}\n\n\t//\tfog\n\tvec3 fogColor = vec3( 0.1, 0.3, 0.8);\n\tfloat FogDensity = 0.005;\n\tfloat fogFactor = 1.0 /exp(t * FogDensity);\n\tfogFactor = clamp( fogFactor, 0.0, 1.0 );\n\tcolor = mix(fogColor, color, fogFactor);\n\n\tfragColor = vec4(color, clamp((t-6.0)/15.0, 0.0, 1.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 32222,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/cristi-covlea/trance-uplifting-progressive-all-time-favorites-minibyte-2022-vol-2"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}