{
    "Shader": {
        "info": {
            "date": "1460486574",
            "description": "My first ray tracer! Only spheres now. \nUse the mouse to drag around the scene a bit.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "ldtSR2",
            "likes": 18,
            "name": "Ray tracing spheres",
            "published": 3,
            "tags": [
                "ray",
                "spheres",
                "tracer",
                "monte",
                "carlo"
            ],
            "usePreview": 1,
            "username": "frzi",
            "viewed": 2412
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Decrease for faster final result. Increase for a less noisey result.\n#define MAX_WEIGHT 200\n\n#define MAX_BOUNCES 10\n#define NUM_SPHERES 5\n#define SAMPLES 1\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n#define LAMB 0\n#define METAL 1\n#define DIEL 2\n\nconst float GAMMA = 2.2;\n\nstruct Material {\n\tint type;\n    vec3 albedo;\n    float parameter;\n};\n    \nstruct Sphere {\n\tvec3 center;\n    float radius;\n    Material material;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nSphere scene[NUM_SPHERES];\n\nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\n\n// Helper functions.\nfloat random() {\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\nvec3 randomUnitVector() {\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\nvec3 rayPointAt(Ray ray, float t) {\n \treturn ray.origin + t * ray.direction;   \n}\n\nfloat schlick(float cosine, float IOR) {\n \tfloat r0 = (1.0 - IOR) / (1.0 + IOR);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\n\n// Ray tracing function.\nbool hitScene(Ray ray, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out Material material)\n{\n    float closestSoFar = tMax;\n    bool hitAnything = false;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n     \tSphere sphere = scene[i];\n        \n        vec3 oc = ray.origin - sphere.center;\n        float a = dot(ray.direction, ray.direction);\n        float b = dot(oc, ray.direction);\n        float c = dot(oc, oc) - sphere.radius * sphere.radius;\n        float discriminant = b * b - a * c;\n        \n        if (discriminant > 0.0001) {\n\t\t\tfloat t = (-b - sqrt(discriminant)) / a;\n            if (t < tMin) {\n                t = (-b + sqrt(discriminant)) / a;\n            }\n            \n            if (t > tMin && t < closestSoFar) {\n                closestSoFar = t;\n                hitAnything = true;\n                \n                vec3 p = rayPointAt(ray, t);\n                position = p;\n                normal = (p - sphere.center) / sphere.radius;\n                material = sphere.material;\n            }\n        }\n    }\n    \n \treturn hitAnything;\n}\n\nvec3 trace(Ray ray) {\n  \t// Pass these to the `hitScene` function.\n    vec3 normal, position;\n    Material material;\n    \n    vec3 color = vec3(0.0);\n    vec3 mask = vec3(1.0);\n        \n    for (int b = 0; b < MAX_BOUNCES; b++) {\n        if (hitScene(ray, 0.001, 5000.0, position, normal, material)) {\n            if (material.type == LAMB) {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(position, direction);\n                color *= material.albedo * mask;\n                mask *= material.albedo;\n            }\n            else if (material.type == METAL) {\n                vec3 reflected = reflect(ray.direction, normal);\n                vec3 direction = randomUnitVector() * material.parameter + reflected;\n                \n                if (dot(direction, normal) > 0.0) {\n               \t\tray = Ray(position, direction);\n                \tcolor *= material.albedo * mask;\n               \t \tmask *= material.albedo;\n                }\n            }\n            else if (material.type == DIEL) {\n                vec3 reflected = reflect(ray.direction, normal);\n                vec3 attenuation = vec3(1.0);\n                \n                vec3 refracted, outwardNormal;\n                float eta, reflectProb, cosine;\n                \n                float dt = dot(ray.direction, normal);\n                \n                if (dt > 0.0) {\n\t\t\t\t\toutwardNormal = -normal;\n                    eta = material.parameter;\n                    cosine = eta * dt / length(ray.direction);\n                }\n                else {\n                    outwardNormal = normal;\n                    eta = 1.0 / material.parameter;\n                    cosine = -dt / length(ray.direction);\n                }\n                \n                refracted = refract(normalize(ray.direction), normalize(outwardNormal), eta);\n                if (all(notEqual(refracted, vec3(0.0)))) {\n                    reflectProb = schlick(cosine, material.parameter);\n                }\n                else {\n                \treflectProb = 1.0;\n                }\n                \n                if (random() < reflectProb) {\n                    ray = Ray(position, reflected);\n                }\n                else {\n                    ray = Ray(position, refracted);\n                }\n                \n                color *= mask * attenuation;\n                mask *= attenuation;\n            }\n        }\n        else {\n            vec3 skyColor = texture(iChannel1, -ray.direction).rgb;\n            skyColor = pow(skyColor, vec3(GAMMA));\n            color = mask * skyColor;\n        }\n    }\n        \n \treturn color;\n}\n\nvoid initScene() {\n\tscene[0] = Sphere(vec3(0, 1, 0), 1.0, Material(LAMB, vec3(0, 0.9, 0.05), 0.0));\n    scene[1] = Sphere(vec3(0, 1, 2.5), 1.0, Material(METAL, vec3(0.9, 0.9, 0.9), 0.01));\n    scene[2] = Sphere(vec3(0, 1, -2.5), 1.0, Material(DIEL, vec3(0, 0, 0), 1.5));\n    scene[3] = Sphere(vec3(0, 1, -2.5), -0.92, Material(DIEL, vec3(0.9, 0.9, 0.9), 1.5));\n    scene[4] = Sphere(vec3(0, -1e3, 0), 1e3, Material(METAL, vec3(0.7, 0.75, 0.8), 0.4));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    initScene();\n    \n    seed = iTime;\n    \n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / ratio;\n    \n    // Camera vectors.\n    const float dist = 6.5;\n    vec2 mousePos = iMouse.xy / iResolution.xy;  \n    if (all(equal(mousePos, vec2(0.0)))) {\n        mousePos = vec2(0.55, 0.2); // Default position.\n    }\n    \n    float x = cos(mousePos.x * 10.0) * dist;\n    float z = sin(mousePos.x * 10.0) * dist;\n    float y = mousePos.y * 10.0;\n        \n    vec3 origin = vec3(x, y, z);\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n        \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n        \n    vec3 color = vec3(0.0);\n    \n    for (int s = 0; s < SAMPLES; s++) {        \n     \tvec3 direction = lowerLeft - origin; \n        direction += horizontal * (pixelSize.x * random() + UV.x);\n        direction += vertical * (pixelSize.y * random() + UV.y);\n        color += trace(Ray(origin, direction));\n    }\n    \n    color /= float(SAMPLES);\n    \n    // Gamma correct.\n    color = pow(color, vec3(1.0 / GAMMA));\n       \n    vec3 previousColor = texture(iChannel0, UV).rgb;\n    \n    float weight = min(float(iFrame + 1), float(MAX_WEIGHT));\n    \n    // Reset weight on interaction.\n    if (!all(lessThanEqual(iMouse.zw, vec2(0.0)))) {\n        weight = 1.0;\n    }\n    \n    vec3 newColor = mix(previousColor, color, 1.0 / weight);\n    \n    fragColor = vec4(newColor, 1.0);\n    //fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}