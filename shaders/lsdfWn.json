{
    "Shader": {
        "info": {
            "date": "1524851887",
            "description": "Press mouse to activate! Drag to move foveal.\nMinimal KFR demo. Best viewed fullscreen. 2-3x speedup!\n[url=https://goo.gl/1noXYE]Xiaoxu Meng, Ruofei Du, Matthias Zwicker, and Amitabh Varshney. (2018). Kernel Foveated Rendering. I3D 2018, 1(5), 1-20.[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "lsdfWn",
            "likes": 5,
            "name": "Kernel Foveated Rendering",
            "published": 3,
            "tags": [
                "rendering",
                "foveated",
                "foveation",
                "kfr",
                "foveal"
            ],
            "usePreview": 1,
            "username": "starea",
            "viewed": 1968
        },
        "renderpass": [
            {
                "code": "/**\n * This shader is a minimal demonstration of the Kernel Foveated Rendering paper.\n * Full screen on GTX 1080+ for best performance!\n *\n * However, this pilot demo has NOT dealed with x=0 artifacts and removed TAA, FXAA etc.\n * In fullscreen and Windows, there is almost no artifact even without filtering.\n * \n * Link to demo: https://www.shadertoy.com/view/lsdfWn\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n * For more details, please visit: http://duruofei.com/Public/papers/Meng_KernelFoveatedRendering_PACM_2018.pdf\n * \n * You can swap the code in Buf A between EXTERNEL SHADER BEGIN / END for a new scene.\n * Note that the best practice is to resize the framebuffer instead of hacking through discard in Buf A.\n * This is minimum demo without anti-aliasing nor deferred shading. Please refer to the paper for more details.\n * https://goo.gl/1noXYE\n *\n * To further complete this demo, you need to:\n * 1. Have one pixel or 1+eps vertical margin in the quad of vertex shader, so uv coordinates will be continuous from bottom to top.\n * 2. Apply Gaussian filters to the log-polar & postprocessed buffers.\n * 3. TAA, refer to the code for more details.\n * 4. Use FOVE or other eye tracking HMDs\n *\n * In ShaderToy, this could also be hacked by fragment shader tricks...\n *\n * Courtesy of iq's LadyBug shader\n * https://www.shadertoy.com/view/4tByz3\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n *\n * Citation: Xiaoxu Meng, Ruofei Du, Matthias Zwicker, and Amitabh Varshney. (2018). Kernel Foveated Rendering. I3D '2018, 1(5), 1-20.\n *\n */\n\n// perform gaussian blur, disabled for now for performance issue\n// Gaussian blur should be done in two passes rather than one...\n// See my shader for two-pass Gaussian vs. one: https://www.shadertoy.com/view/ltBXRh\nvec3 performGaussBlur(vec2 pos) \n{\n\tconst float PARA1 = 0.2042, PARA2 = 0.1238, PARA3 = 0.0751;\n\tvec3 fragColor11 = texture(logTexture, pos - PIXEL_SIZE).xyz;\n\tvec3 fragColor12 = texture(logTexture, pos - vec2(0.0f, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor13 = texture(logTexture, pos + vec2(PIXEL_SIZE.x, -PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor21 = texture(logTexture, pos - vec2(PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColor22 = texture(logTexture, pos + vec2(0.0f, 0.0f)).xyz;\n\tvec3 fragColor23 = texture(logTexture, pos + vec2(PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColor31 = texture(logTexture, pos + vec2(-PIXEL_SIZE.x, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor32 = texture(logTexture, pos + vec2(0.0f, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor33 = texture(logTexture, pos + PIXEL_SIZE).xyz;\n\n\tvec3 fragColore1 = texture(logTexture, pos + 2.0*vec2(PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColore2 = texture(logTexture, pos + 2.0*vec2(-PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColore3 = texture(logTexture, pos + 2.0*vec2(0.0f, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColore4 = texture(logTexture, pos + 2.0*vec2(0.0f, -PIXEL_SIZE.y)).xyz;\n\n\tvec3 newColor = PARA3 * (fragColor11 + fragColor13 + fragColor31 + fragColor33) +\n\t\tPARA2 * (fragColor12 + fragColor21 + fragColor23 + fragColor32) +\n\t\tPARA1 * fragColor22;\n\treturn newColor;\n}\n\nvec3 FXAA(vec2 pos) {\n\t/*---------------------------------------------------------*/\n\t//#define FXAA_REDUCE_MUL   (1.0/8.0)\n\t//#define FXAA_SPAN_MAX     8.0\n\t/*---------------------------------------------------------*/\n\tvec3 rgbNW = texture(logTexture, pos - vec2(PIXEL_SIZE.x, 0)).xyz;\n\tvec3 rgbNE = texture(logTexture, pos + vec2(PIXEL_SIZE.x, 0)).xyz;\n\tvec3 rgbSW = texture(logTexture, pos - vec2(0, PIXEL_SIZE.y)).xyz;\n\tvec3 rgbSE = texture(logTexture, pos + vec2(0, PIXEL_SIZE.y)).xyz;\n\tvec3 rgbM = texture(logTexture, pos).xyz;\n\trgbNW = rgbM;\n\t/*---------------------------------------------------------*/\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM = dot(rgbM, luma);\n\t/*---------------------------------------------------------*/\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\tfloat range = lumaMax - lumaMin;\n\t/*---------------------------------------------------------*/\n\t//if (range < max(FXAA_EDGE_THRESHOLD_MIN, lumaMax * FXAA_EDGE_THRESHOLD))\n\t//\treturn rgbM;\n\t//return (rgbNW + rgbNE + rgbSW + rgbSE + rgbM) * 0.2;\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t/*---------------------------------------------------------*/\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * 0.125),\n\t\t1.0 / 128.0);\n\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) * PIXEL_SIZE.xy;\n\t/*--------------------------------------------------------*/\n\tvec3 rgbA = (1.0 / 2.0) * (\n\t\ttexture(logTexture, pos + dir * (1.0 / 3.0 - 0.5)).xyz +\n\t\ttexture(logTexture, pos + dir * (2.0 / 3.0 - 0.5)).xyz);\n\tvec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (\n\t\ttexture(logTexture, pos + dir * (0.0 / 3.0 - 0.5)).xyz +\n\t\ttexture(logTexture, pos + dir * (3.0 / 3.0 - 0.5)).xyz);\n\tfloat lumaB = dot(rgbB, luma);\n\n\tif ((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n\treturn rgbB;\n}\n\nfloat powFunc(float lr) {\n\treturn pow(lr, ALPHA);\n}\n\nfloat expFunc(float lr) {\n\treturn (exp(lr) - 1.0) / (exp(1.0) - 1.0);\n}\n\nfloat selfFunc(float lr) {\n\treturn 0.5 * lr * lr * lr * lr + 0.5 * lr * lr;\n}\n\nfloat sinFunc(float lr) {\n\treturn asin(lr) * 4.0 / TWOPI;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat SCALE_RATIO = iMouse.z > 0.0 ? 1.0 : DEFAULT_SIGMA;\n    vec2 iRes = iResolution.xy, foveal = FOVEAL, foveal2 = FOVEAL2;\n    if (iMouse.x < 1.0) {\n        foveal = FOVEAL2;\n    }\n    // Equation (12) and (13)\n\tfloat maxL = max(\n\t\tmax(length((vec2(1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(1, -1) - foveal) * iRes)\n\t\t\t),\n\t\tmax(length((vec2(-1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(-1, -1) - foveal) * iRes)\n\t\t\t)\n\t\t);\n\tfloat L = log(maxL * 0.5);\n\tvec2 uv = fragCoord / iRes; // [0, 1]\n    vec2 pq = uv * 2.0 - 1.0 - foveal;\n\tfloat r = length(pq * iRes * 0.5); // [-1, 1] * length(iResolution.xy * 0.5)\n\tfloat lr = log(r) / L;\n\tfloat theta = atan(pq.y * iRes.y, pq.x * iRes.x) + step(pq.y, 0.0) * TWOPI;\n\tfloat theta2 = atan(pq.y * iRes.y, -abs(pq.x) * iRes.x) + step(pq.y, 0.0) * TWOPI;\n    \n\tif (KERNEL_FUNCTION_TYPE < 1.0)\n\t\tlr = lr;\n\telse if (KERNEL_FUNCTION_TYPE < 2.0)\n\t\tlr = expFunc(lr);\n\telse if (KERNEL_FUNCTION_TYPE < 3.0)\n\t\tlr = sinFunc(lr);\n\telse if (KERNEL_FUNCTION_TYPE < 4.0)\n\t\tlr = powFunc(lr);\n\n\ttheta /= MAX_THETA;\n    theta2 /= MAX_THETA;\n        \n\tvec2 logCoord = vec2(lr, theta) / SCALE_RATIO;\n    vec2 logCoordGrad = vec2(lr, theta2) / SCALE_RATIO;\n    \n    if (!iApplyLogMap2)\n        logCoord = uv;\n\n\tvec3 col = textureGrad(logTexture, logCoord, dFdx(logCoordGrad), dFdy(logCoordGrad)).rgb;\n    //col = vec3(dFdx(logCoordGrad), 0.0);\n    // https://iquilezles.org/articles/tunnel\n    //col = textureGrad(logTexture, logCoord, dFdx(logCoord), dFdy(logCoord)).rgb;\n    //col = vec3((dFdx(logCoord)*500.0 + vec2(1.0)) * 0.5, 0.0);\n    //col = vec3((dFdx(logCoordGrad)*500.0 + vec2(1.0)) * 0.5, 0.0);\n    //col = texture(logTexture, logCoord).rgb;\n    \n#if USE_FXAA\n\tif (AdjustRegion > 1 && newCoord.y < 0.995 / SCALE_RATIO)\n\t\tcol = FXAA(logCoord);\n\telse if (length(uv - foveal2) > 0.1 && AdjustRegion > 0 && logCoord.y < 0.995 / SCALE_RATIO)\n\t\tcol = performGaussBlur(logCoord);\n#endif\n\n    // In KFR paper, we enlarge the rect geometry with one extra pixel for mirror wraping.\n    // This trick eliminates the artifacts very well.\n\n\t// Usually if the size of framebuffer is scaled with SCALE_RATIO correctly, \n    // the mipmap filtering and mirror wraping could solve the polar issue.\n        \n    // In ShaderToy, we have to use the following trick:\n    float y = logCoord.y * SCALE_RATIO * iRes.y;\n    if (y > iRes.y - 1.0) {\n        col = texelFetch(logTexture, ivec2(logCoord*iResolution.xy), 0).rgb;\n        //col = FXAA(logCoord);\n        //mainShader(fragColor, fragCoord);\n    }\n\t//col = FXAA(logCoord);\n\tvec2 uv2 = uv * 2.0 - 1.0;\n    uv2.x *= iResolution.x / iResolution.y;\n    foveal.x *= iResolution.x / iResolution.y;\n\tif (length(foveal - uv2) < 0.05 && length(foveal - uv2) > 0.03)\n\t\tcol = mix(col, vec3(1.0), 0.2);\n\n\tfragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * This shader is a minimum demonstration of the Kernel Foveated Rendering paper\n\n * Link to demo: https://www.shadertoy.com/view/lsdfWn\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n * For more details, please visit: http://duruofei.com/Public/papers/Meng_KernelFoveatedRendering_PACM_2018.pdf\n * \n * Courtesy of iq's LadyBug shader\n * https://www.shadertoy.com/view/4tByz3\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n *\n * Xiaoxu Meng and Ruofei Du\n *\n */\n\n// KFR BEGIN\nfloat powInvFunc(float lr) {\n\treturn pow(lr, 1.0 / ALPHA);\n}\n\nfloat expInvFunc(float lr) {\n\treturn log((exp(1.0) - 1.0) * lr + 1.0);\n}\n\nfloat selfInvFunc(float lr) {\n\treturn sqrt(sqrt(2.0 * lr + 0.25) - 0.5);\n}\n\nfloat sinInvFunc(float lr) {\n\treturn sin(lr * 4.0 / TWOPI);\n}\n\nvec2 logMap(float SCALE_RATIO, vec2 coord, vec2 iRes) {\n    vec2 foveal = FOVEAL;\n    if (iMouse.x < 1.0) {\n        foveal = FOVEAL2;\n    }\n    \n    // Equation (12) and (13)\n\tfloat maxL = max(\n\t\tmax(length((vec2(1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(1, -1) - foveal) * iRes)\n\t\t\t),\n\t\tmax(length((vec2(-1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(-1, -1) - foveal) * iRes)\n\t\t\t)\n\t\t);\n\tfloat L = log(maxL * 0.5);\n\tvec2 uv = SCALE_RATIO * coord / iRes;\n\t\n\tif (KERNEL_FUNCTION_TYPE < 1.0)\n\t\tuv.x = uv.x;\n\telse if (KERNEL_FUNCTION_TYPE < 2.0)\n\t\tuv.x = expInvFunc(uv.x);\n\telse if (KERNEL_FUNCTION_TYPE < 3.0)\n\t\tuv.x = selfInvFunc(uv.x);\n\telse if (KERNEL_FUNCTION_TYPE < 4.0)\n\t\tuv.x = powInvFunc(uv.x);\n\n    // Algorithm 2. Line 5 + 6.\n\tfloat x = exp(uv.x * L) * cos(uv.y * TWOPI);\n\tfloat y = exp(uv.x * L) * sin(uv.y * TWOPI);\n\tvec2 logCoord = vec2(x, y) + FOVEAL2 * iRes;\n    \n\treturn iApplyLogMap1 ? logCoord : (coord * SCALE_RATIO);\n}\n// KFR END\n\n\n// EXTERNEL SHADER BEGIN\n\n// https://www.shadertoy.com/view/4tByz3\n// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define MAT_MUSH_HEAD 1.0\n#define MAT_MUSH_NECK 2.0\n#define MAT_LADY_BODY 3.0\n#define MAT_LADY_HEAD 4.0\n#define MAT_LADY_LEGS 5.0\n#define MAT_GRASS     6.0\n#define MAT_GROUND    7.0\n#define MAT_MOSS      8.0\n#define MAT_CITA      9.0\n\nvec2 hash2(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return fract(sin(p)*18.5453); }\nvec3 hash3(float n) { return fract(sin(vec3(n, n + 1.0, n + 2.0))*vec3(338.5453123, 278.1459123, 191.1234)); }\n\n\nfloat sdEllipsoid(in vec3 pos, in vec3 cen, in vec3 rad) {\n\tvec3 p = pos - cen;\n\tfloat d = length(p / rad) - 1.0;\n\treturn d * min(min(rad.x, rad.y), rad.z);\n}\n\nvec2 sdLine(in vec3 pos, in vec3 a, in vec3 b) {\n\tvec3 pa = pos - a;\n\tvec3 ba = b - a;\n\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n\treturn vec2(length(pa - h*ba), h);\n}\n\nvec2 sdLineOri(in vec3 p, in vec3 b) {\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);\n\n\treturn vec2(length(p - h*b), h);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k*h*(1.0 - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k*h*(1.0 - h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n\tvec3 h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k*h*(1.0 - h);\n}\n\nfloat length2(in vec2 p) { return dot(p, p); }\nfloat length2(in vec3 p) { return dot(p, p); }\n\nvec3 rotateY(in vec3 p, float t) {\n\tfloat co = cos(t);\n\tfloat si = sin(t);\n\tp.xz = mat2(co, -si, si, co)*p.xz;\n\treturn p;\n}\n\nvec3 rotateX(in vec3 p, float t) {\n\tfloat co = cos(t);\n\tfloat si = sin(t);\n\tp.yz = mat2(co, -si, si, co)*p.yz;\n\treturn p;\n}\nvec3 rotateZ(in vec3 p, float t) {\n\tfloat co = cos(t);\n\tfloat si = sin(t);\n\tp.xy = mat2(co, -si, si, co)*p.xy;\n\treturn p;\n}\n\n//==================================================\n\nvec3 mapLadyBug(vec3 p, float curmin) {\n\n\tfloat db = length(p - vec3(0.0, -0.35, 0.05)) - 1.3;\n\tif (db > curmin) return vec3(10000.0, 0.0, 0.0);\n\n\tfloat dBody = sdEllipsoid(p, vec3(0.0), vec3(0.8, 0.75, 1.0));\n\tdBody = smax(dBody, -sdEllipsoid(p, vec3(0.0, -0.1, 0.0), vec3(0.75, 0.7, 0.95)), 0.05);\n\tdBody = smax(dBody, -sdEllipsoid(p, vec3(0.0, 0.0, 0.8), vec3(0.35, 0.35, 0.5)), 0.05);\n\tdBody = smax(dBody, sdEllipsoid(p, vec3(0.0, 1.7, -0.1), vec3(2.0, 2.0, 2.0)), 0.05);\n\tdBody = smax(dBody, -abs(p.x) + 0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z, 0.0, 1.0));\n\n\tvec3 res = vec3(dBody, MAT_LADY_BODY, 0.0);\n\n\t// --------\n\tvec3 hc = vec3(0.0, 0.1, 0.8);\n\tvec3 ph = rotateX(p - hc, 0.5);\n\tfloat dHead = sdEllipsoid(ph, vec3(0.0, 0.0, 0.0), vec3(0.35, 0.25, 0.3));\n\tdHead = smax(dHead, -sdEllipsoid(ph, vec3(0.0, -0.95, 0.0), vec3(1.0)), 0.03);\n\tdHead = min(dHead, sdEllipsoid(ph, vec3(0.0, 0.1, 0.3), vec3(0.15, 0.08, 0.15)));\n\n\tif (dHead < res.x) res = vec3(dHead, MAT_LADY_HEAD, 0.0);\n\n\tres.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // -------------\n\n\tvec3 k1 = vec3(0.42, -0.05, 0.92);\n\tvec3 k2 = vec3(0.49, -0.2, 1.05);\n\tfloat dLegs = 10.0;\n\n\tfloat sx = sign(p.x);\n\tp.x = abs(p.x);\n\tfor (int k = 0; k < 3; k++) {\n\t\tvec3 q = p;\n\t\tq.y -= min(sx, 0.0)*0.1;\n\t\tif (k == 0) q += vec3(0.0, 0.11, 0.0);\n\t\tif (k == 1) q += vec3(-0.3, 0.1, 0.2);\n\t\tif (k == 2) q += vec3(-0.3, 0.1, 0.6);\n\n\t\tvec2 se = sdLine(q, vec3(0.3, 0.1, 0.8), k1);\n\t\tse.x -= 0.015 + 0.15*se.y*se.y*(1.0 - se.y);\n\t\tdLegs = min(dLegs, se.x);\n\n\t\tse = sdLine(q, k1, k2);\n\t\tse.x -= 0.01 + 0.01*se.y;\n\t\tdLegs = min(dLegs, se.x);\n\n\t\tse = sdLine(q, k2, k2 + vec3(0.1, 0.0, 0.1));\n\t\tse.x -= 0.02 - 0.01*se.y;\n\t\tdLegs = min(dLegs, se.x);\n\t}\n\n\tif (dLegs < res.x) res = vec3(dLegs, MAT_LADY_LEGS, 0.0);\n\n\n\treturn res;\n}\n\n\nvec3 worldToMushrom(in vec3 pos) {\n\tvec3 qos = pos;\n\tqos.xy = (mat2(60, 11, -11, 60) / 61.0) * qos.xy;\n\tqos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n\tqos.y -= 0.4;\n\treturn qos;\n}\n\nvec3 mapMushroom(in vec3 pos, in vec3 cur) {\n\tvec3 res = cur;\n\n\tvec3 qos = worldToMushrom(pos);\n\tfloat db = length(qos - vec3(0.0, 1.2, 0.0)) - 1.3;\n\tif (db < cur.x) {\n\t\t{\n\t\t\tfloat d1 = sdEllipsoid(qos, vec3(0.0, 1.4, 0.0), vec3(0.8, 1.0, 0.8));\n\n\t\t\td1 -= 0.025*textureLod(iChannel0, 0.05*qos.xz, 0.0).x - 0.02;\n\n\t\t\tfloat d2 = sdEllipsoid(qos, vec3(0.0, 0.5, 0.0), vec3(1.3, 1.2, 1.3));\n\t\t\tfloat d = smax(d1, -d2, 0.1);\n\t\t\td *= 0.8;\n\t\t\tif (d < res.x) {\n\t\t\t\tres = vec3(d, MAT_MUSH_HEAD, 0.0);\n\t\t\t}\n\t\t}\n\n\n\t\t{\n\t\t\tpos.x += 0.3*sin(pos.y) - 0.65;\n\t\t\tfloat pa = sin(20.0*atan(pos.z, pos.x));\n\t\t\tvec2 se = sdLine(pos, vec3(0.0, 2.0, 0.0), vec3(0.0, 0.0, 0.0));\n\n\t\t\tfloat tt = 0.25 - 0.1*4.0*se.y*(1.0 - se.y);\n\n\t\t\tfloat d3 = se.x - tt;\n\n\t\t\td3 = smin(d3, sdEllipsoid(pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz), 0.0), vec3(0.3, 0.05, 0.3)), 0.05);\n\t\t\td3 += 0.003*pa;\n\t\t\td3 *= 0.7;\n\n\t\t\tif (d3 < res.x)\n\t\t\t\tres = vec3(d3, MAT_MUSH_NECK, 0.0);\n\t\t}\n\n\t}\n\treturn res;\n}\n\n\n\nvec3 mapGrass(in vec3 pos, float h, in vec3 cur) {\n\tvec3 res = cur;\n\n\tfloat db = pos.y - 2.6;\n\n\tif (db < cur.x && pos.z > -1.65) {\n\t\tconst float gf = 4.0;\n\n\t\tvec3 qos = pos * gf;\n\n\t\tvec2 n = floor(qos.xz);\n\t\tvec2 f = fract(qos.xz);\n\t\tfor (int j = -2; j <= 2; j++)\n\t\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\t\tvec2  g = vec2(float(i), float(j));\n\n\t\t\t\tvec2 ra2 = hash2(n + g + vec2(31.0, 57.0));\n\n\t\t\t\tif (ra2.x < 0.73) continue;\n\n\t\t\t\tvec2  o = hash2(n + g);\n\t\t\t\tvec2  r = g - f + o;\n\t\t\t\tvec2 ra = hash2(n + g + vec2(11.0, 37.0));\n\n\t\t\t\tfloat gh = 2.0*(0.3 + 0.7*ra.x);\n\n\t\t\t\tfloat rosy = qos.y - h*gf;\n\n\t\t\t\tr.xy = reflect(r.xy, normalize(-1.0 + 2.0*ra));\n\t\t\t\tr.x -= 0.03*rosy*rosy;\n\n\t\t\t\tr.x *= 4.0;\n\n\t\t\t\tfloat mo = 0.1*sin(2.0*iTime + 20.0*ra.y)*(0.2 + 0.8*ra.x);\n\t\t\t\tvec2 se = sdLineOri(vec3(r.x, rosy, r.y), vec3(4.0 + mo, gh*gf, mo));\n\n\t\t\t\tfloat gr = 0.3*sqrt(1.0 - 0.99*se.y);\n\t\t\t\tfloat d = se.x - gr;\n\t\t\t\td /= 4.0;\n\n\t\t\t\td /= gf;\n\t\t\t\tif (d < res.x) {\n\t\t\t\t\tres.x = d;\n\t\t\t\t\tres.y = MAT_GRASS;\n\t\t\t\t\tres.z = r.y;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\treturn res;\n}\n\n\nvec3 mapCrapInTheAir(in vec3 pos, in vec3 cur) {\n\tvec3 res = cur;\n\n\tivec2 id = ivec2(floor((pos.xz + 2.0) / 4.0));\n\tpos.xz = mod(pos.xz + 2.0, 4.0) - 2.0;\n\tfloat dm = 1e10;\n\tfor (int i = 0; i < 4; i++) {\n\t\tvec3 o = vec3(0.0, 3.2, 0.0);\n\t\to += vec3(1.7, 1.50, 1.7)*(-1.0 + 2.0*hash3(float(i)));\n\t\to += vec3(0.3, 0.15, 0.3)*sin(0.3*iTime + vec3(float(i + id.y), float(i + 3 + id.x), float(i * 2 + 1 + 2 * id.x)));\n\t\tfloat d = length2(pos - o);\n\t\tdm = min(d, dm);\n\t}\n\tdm = sqrt(dm) - 0.02;\n\n\tif (dm < res.x)\n\t\tres = vec3(dm, MAT_CITA, 0);\n\n\treturn res;\n}\n\nvec3 mapMoss(in vec3 pos, float h, vec3 cur) {\n\tvec3 res = cur;\n\n\tfloat db = pos.y - 2.2;\n\tif (db < res.x) {\n\t\tconst float gf = 2.0;\n\n\t\tvec3 qos = pos * gf;\n\t\tvec2 n = floor(qos.xz);\n\t\tvec2 f = fract(qos.xz);\n\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tfor (int j = -1; j <= 1; j++)\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tvec2  g = vec2(float(i), float(j));\n\t\t\t\t\tvec2  o = hash2(n + g + vec2(float(k), float(k * 5)));\n\t\t\t\t\tvec2  r = g - f + o;\n\n\t\t\t\t\tvec2 ra = hash2(n + g + vec2(11.0, 37.0) + float(2 * k));\n\t\t\t\t\tvec2 ra2 = hash2(n + g + vec2(41.0, 137.0) + float(3 * k));\n\n\t\t\t\t\tfloat mh = 0.5 + 1.0*ra2.y;\n\t\t\t\t\tvec3 ros = qos - vec3(0.0, h*gf, 0.0);\n\n\t\t\t\t\tvec3 rr = vec3(r.x, ros.y, r.y);\n\n\t\t\t\t\trr.xz = reflect(rr.xz, normalize(-1.0 + 2.0*ra));\n\n\t\t\t\t\trr.xz += 0.5*(-1.0 + 2.0*ra2);\n\t\t\t\t\tvec2 se = sdLineOri(rr, vec3(0.0, gf*mh, 0.0));\n\t\t\t\t\tfloat sey = se.y;\n\t\t\t\t\tfloat d = se.x - 0.05*(2.0 - smoothstep(0.0, 0.1, abs(se.y - 0.9)));\n\n\t\t\t\t\tvec3 pp = vec3(rr.x, mod(rr.y + 0.2*0.0, 0.4) - 0.2*0.0, rr.z);\n\n\t\t\t\t\tfloat an = mod(21.0*floor((rr.y + 0.2*0.0) / 0.4), 1.57);\n\t\t\t\t\tfloat cc = cos(an);\n\t\t\t\t\tfloat ss = sin(an);\n\t\t\t\t\tpp.xz = mat2(cc, ss, -ss, cc)*pp.xz;\n\n\t\t\t\t\tpp.xz = abs(pp.xz);\n\t\t\t\t\tvec3 ppp = (pp.z > pp.x) ? pp.zyx : pp;\n\t\t\t\t\tvec2 se2 = sdLineOri(ppp, vec3(0.4, 0.3, 0.0));\n\t\t\t\t\tvec2 se3 = sdLineOri(pp, vec3(0.2, 0.3, 0.2)); if (se3.x < se2.x) se2 = se3;\n\t\t\t\t\tfloat d2 = se2.x - (0.02 + 0.03*se2.y);\n\n\t\t\t\t\td2 = max(d2, (rr.y - 0.83*gf*mh));\n\t\t\t\t\td = smin(d, d2, 0.05);\n\n\t\t\t\t\td /= gf;\n\t\t\t\t\td *= 0.9;\n\t\t\t\t\tif (d<res.x) {\n\t\t\t\t\t\tres.x = d;\n\t\t\t\t\t\tres.y = MAT_MOSS;\n\t\t\t\t\t\tres.z = clamp(length(rr.xz)*4.0 + rr.y*0.2, 0.0, 1.0);\n\t\t\t\t\t\tfloat e = clamp((pos.y - h) / 1.0, 0.0, 1.0);\n\t\t\t\t\t\tres.z *= 0.02 + 0.98*e*e;\n\n\t\t\t\t\t\tif (ra.y>0.85 && abs(se.y - 0.95) < 0.1) res.z = -res.z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\treturn res;\n}\n\nvec3 worldToLadyBug(in vec3 p) {\n\tp = 4.0*(p - vec3(-0.0, 3.2 - 0.6, -0.57));\n\tp = rotateY(rotateZ(rotateX(p, -0.92), 0.49), 3.5);\n\tp.y += 0.2;\n\treturn p;\n}\n\n\nconst vec3 mushroomPos1 = vec3(0.0, 0.1, 0.0);\nconst vec3 mushroomPos2 = vec3(-3.0, 0.0, 3.0);\n\nfloat terrain(in vec2 pos) {\n\treturn 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\n}\n\nvec3 mapShadow(in vec3 pos) {\n\tfloat h = terrain(pos.xz);\n\tfloat d = pos.y - h;\n\tvec3 res = vec3(d, MAT_GROUND, 0.0);\n\n\tres = mapGrass(pos, h, res);\n\tres = mapMoss(pos, h, res);\n\n\tvec3 m1 = pos - mushroomPos1;\n\tvec3 m2 = (pos - mushroomPos2).zyx;\n\tif (length2(m2.xz) < length2(m1.xz)) m1 = m2;\n\tres = mapMushroom(m1, res);\n\n\n\tvec3 q = worldToLadyBug(pos);\n\tvec3 d3 = mapLadyBug(q, res.x*4.0); d3.x /= 4.0;\n\tif (d3.x < res.x) res = d3;\n\n\treturn res;\n}\n\n\nvec3 map(in vec3 pos) {\n\tvec3 res = mapShadow(pos);\n\n\tres = mapCrapInTheAir(pos, res);\n\n\treturn res;\n}\n\n\nvec3 calcNormal(in vec3 pos) {\n\tvec2 e = vec2(0.002, 0.0);\n\n\treturn normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n\t\tmap(pos + e.yxy).x - map(pos - e.yxy).x,\n\t\tmap(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n\tfloat res = 1.0;\n\tfloat t = 0.01;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + rd*t;\n\t\tfloat h = mapShadow(pos).x;\n\t\tres = min(res, 16.0*max(h, 0.0) / t);\n\t\tif (h<0.0001 || pos.y>3.0) break;\n\n\t\tt += clamp(h, 0.01, 0.2);\n\t}\n\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 intersect(in vec3 ro, in vec3 rd) {\n\tconst float tmax = 12.0;\n\n\tvec3 res = vec3(1.0, -1.0, 0.0);\n\n\tfor (int i = 0; i < 256; i++) {\n\t\tvec3 h = map(ro + rd*res.x);\n\t\tif (h.x<(0.00015*res.x) || res.x>tmax)\n\t\t\tbreak;\n\t\tres.x += h.x;\n\t\tres.y = h.y;\n\t\tres.z = h.z;\n\t}\n\n\tif (res.x >= tmax) res.y = -1.0;\n\n\treturn res;\n}\n\nvoid materials(in float matID, in float matID2, in vec3 pos, in vec3 nor,\n\tout vec3 matColor, out float matRough,\n\tout vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma) {\n\tmatNor = nor;\n\tmatOcc = 1.0;\n\tmatSSS = 0.0;\n\tmatRough = 1.0;\n\tmatRefOcc = 1.0;\n\tmatGamma = vec3(1.0);\n\n\tif (matID < MAT_MUSH_HEAD + 0.5) {\n\t\tvec3 m1 = pos - mushroomPos1;\n\t\tvec3 m2 = (pos - mushroomPos2).zyx;\n\t\tif (length2(m2.xz) < length2(m1.xz)) m1 = m2;\n\n\t\tvec3 qos = worldToMushrom(m1);\n\n\t\tmatColor = vec3(0.26, 0.21, 0.15);\n\t\tmatColor -= 0.2*smoothstep(0.4, 0.9, texture(iChannel0, 0.8*qos.xz).x);\n\t\tmatColor = mix(vec3(0.35, 0.35, 0.35), matColor, smoothstep(1.5, 2.4, qos.y));\n\t\tmatColor = mix(vec3(0.05, 0.02, 0.01), matColor, smoothstep(1.5, 1.65, qos.y));\n\t\tmatColor -= 0.2*texture(iChannel0, 0.1*qos.xz).zyx;\n\t\tmatColor *= 0.4*0.45;\n\t\tmatColor = max(matColor, 0.0);\n\n\t\tmatColor += matColor*vec3(0.3, 0.6, 0.0)*(1.0 - smoothstep(0.8, 1.4, length(m1 - vec3(0.5, 1.1, -0.3))));\n\n\t\tmatRough = 0.6;\n\t\tmatSSS = 1.0;\n\t\tmatOcc = smoothstep(0.4, 1.5, length(worldToLadyBug(pos).xz));\n\t\tmatRefOcc = matOcc;\n\t\tmatGamma = vec3(0.75, 0.87, 1.0);\n\t} else if (matID < MAT_MUSH_NECK + 0.5) {\n\t\tvec2 uv = vec2(pos.y*0.5, atan(pos.x, pos.z)*(3.0 / 3.14159));\n\n\t\tmatColor = vec3(0.42, 0.35, 0.15);\n\n\t\tfloat pa = smoothstep(0.3, 0.8, pos.y);\n\n\t\tmatColor -= pa*0.2*texture(iChannel0, 0.5*uv).xxx;\n\t\tmatColor = max(vec3(0.0), matColor);\n\n\t\tmatColor *= 0.22;\n\t\tmatColor = clamp(matColor, 0.0, 1.0);\n\n\t\tmatRough = 0.7;\n\t\tmatSSS = 1.0;\n\n\t\tmatOcc = clamp((pos.y - 0.5) / 1.3, 0.0, 1.0);\n\t\tmatOcc = matOcc*matOcc;\n\t\tmatOcc *= clamp(1.0 - (pos.y - 1.2) / 1.2, 0.0, 1.0);\n\t\tmatOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\n\t\tmatRefOcc = matOcc;\n\t\tmatGamma = vec3(0.75, 0.95, 1.0);\n\n\t} else if (matID < MAT_LADY_BODY + .5) {\n\t\tvec3 qos = worldToLadyBug(pos);\n\n\t\t// red\n\t\tmatColor = vec3(0.16, 0.008, 0.0);\n\n\t\tfloat f = texture(iChannel0, 0.1*qos.xz).x;\n\t\tmatColor = mix(matColor, vec3(0.15, 0.07, 0.0), f*f);\n\n\t\tqos.x = abs(qos.x);\n\t\tvec2 uv = vec2(atan(qos.x, qos.y), 1.57*qos.z)*0.1;\n\n\t\t// white\n\t\tfloat p = length((qos.xz - vec2(0.0, 0.9))*vec2(0.5, 1.0));\n\t\tmatColor = mix(matColor, vec3(1.0, 0.8, 0.6)*0.6, 1.0 - smoothstep(0.09, 0.14, p));\n\n\t\t// black\n\t\tp = cos(uv.x*40.0)*cos(uv.y*40.0 + 1.57);\n\t\tmatColor *= 1.0 - smoothstep(0.35, 0.45, p);\n\n\n\t\tf = texture(iChannel0, qos.xz*vec2(0.8, 0.1)).x;\n\t\tmatColor *= 1.0 - 0.5*f;\n\t\tf = texture(iChannel0, 4.0*qos.xz).x;\n\t\tmatColor *= 1.0 - 0.99*f*f;\n\n\n\t\tmatColor *= 1.3;\n\t\tmatRough = 0.15;\n\t\tmatOcc = 0.6 + 0.4*smoothstep(0.0, 0.3, qos.y);\n\t\tmatRefOcc = 0.2 + 0.8*smoothstep(0.0, 0.35, qos.y);\n\t} else if (matID < MAT_LADY_HEAD + .5) {\n\t\tvec3 qos = worldToLadyBug(pos);\n\n\t\tmatColor = vec3(0.001);\n\n\t\tqos.z += -0.22;\n\t\tqos.y += -0.7;\n\t\tfloat p = cos(12.0*qos.z)*cos(5.0*qos.y);\n\t\tp += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\n\t\tmatColor = mix(matColor, vec3(1.0, 0.9, 0.8)*0.8, smoothstep(0.8, 1.0, p));\n\t\tmatRough = 0.2;\n\t\tmatRefOcc = matOcc;\n\t} else if (matID < MAT_LADY_LEGS + .5) {\n\t\tmatColor = vec3(0.0, 0.0, 0.0);\n\t\tmatRough = 0.8;\n\t\tmatRefOcc = matOcc;\n\t} else if (matID < MAT_GRASS + 0.5) {\n\t\tmatColor = vec3(0.1, 0.15, 0.03);\n\n\t\tfloat h = terrain(pos.xz);\n\t\tfloat e = clamp(pos.y - h, 0.0, 1.0);\n\t\tmatOcc = 0.01 + 0.99*e*e;\n\n\t\tmatColor *= 1.0 - 0.3*cos(matID2*23.0);\n\t\tmatColor += 0.04*sin(matID2*41.0);\n\n\t\tmatSSS = 0.2;\n\t\tmatColor *= 0.75;\n\t\tmatRough = 0.5;\n\t\tmatOcc *= 0.1 + 0.9*smoothstep(0.0, 2.0, length(pos.xz - mushroomPos1.xz - vec2(0.3, 0.3)));\n\t\t//matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\n\t\tmatRefOcc = matOcc;\n\t\tmatGamma = vec3(0.9, 0.9, 1.0);\n\t} else if (matID < MAT_GROUND + 0.5) {\n\t\tmatColor = vec3(0.2, 0.2, 0.0);\n\t\tmatRough = 1.0;\n\t\tmatOcc = 0.02;\n\t\tmatRefOcc = matOcc;\n\t} else if (matID < MAT_MOSS + 0.5) {\n\t\tmatColor = vec3(0.18, 0.15, 0.02);\n\n\n\t\tif (matID2 < 0.0) matColor = vec3(0.1, 0.05, 0.005);\n\n\n\t\tfloat f = texture(iChannel0, pos.xy*8.0).x;\n\t\tmatColor *= 0.55 + f;\n\n\t\tmatOcc = abs(matID2);\n\t\tmatOcc *= 0.2 + 0.8*smoothstep(0.0, 1.5, length(pos.xz - mushroomPos1.xz - vec2(0.3, 0.3)));\n\t\tmatOcc *= 0.2 + 0.8*smoothstep(0.0, 1.5, length(pos.xz - mushroomPos2.xz - vec2(0.0, 0.0)));\n\t\tmatRough = 0.25;\n\t\tmatSSS = 0.5;\n\t\tmatRefOcc = matOcc;\n\t\tmatGamma = vec3(0.7, 0.7, 1.0);\n\n\t\tif (matID2 < 0.0) { matGamma = vec3(0.7, 0.9, 1.0); matRough = 0.75; }\n\t} else //if( matID<MAT_CITA+0.5 )\n\t{\n\t\tmatColor = vec3(1.0);\n\t\tmatSSS = 1.0;\n\t\tmatRough = 1.0;\n\t\tmatGamma = vec3(0.5);\n\t}\n}\n\n\nvec3 lighting(in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\n\tin float occ,\n\tin vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\n\tin vec3 matGamma) {\n\tvec3 col = vec3(0.0);\n\n\tfloat fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0);\n\n\tfloat sfre = 0.04 + 0.96*pow(fre, 5.0);\n\n\tfloat pn = exp2(10.0*(1.0 - matRough));\n\n\n\t// sun light\n\t{\n\t\tvec3 sunColor = vec3(7.0, 4.0, 3.0)*1.4;\n\t\tvec3 sun = normalize(vec3(-0.8, 0.35, -0.3));\n\t\tfloat dif = clamp(dot(sun, nor), 0.0, 1.0);\n\t\tfloat sha = 0.0; if (dif > 0.0) sha = calcShadow(pos, sun);\n\t\tvec3 hal = normalize(sun - rd);\n\t\tfloat spe = pow(clamp(dot(hal, nor), 0.0, 1.0), pn);\n\t\tcol += matColor * sunColor * dif * vec3(sha, 0.5*sha*(1.0 + sha), sha*sha);\n\t\tcol += (1.0 - matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\n\t}\n\n\t// sky light\n\t{\n\t\tvec3 skyColor = vec3(0.3, 0.4, 0.7)*1.0;\n\t\tfloat dif = 0.5 + 0.5*nor.y;\n\t\tcol += matColor * skyColor * dif * occ;\n\t\tcol += skyColor * (1.0 - matRough) * smoothstep(0.0, 0.2, reflect(rd, nor).y) * sfre * 2.5 * matRefOcc;\n\t}\n\n\t// bounce light\n\t{\n\t\tvec3 bouColor = vec3(0.2, 0.4, 0.0)*1.2;\n\t\tfloat dif = clamp(0.5 - 0.5*nor.y, 0.0, 1.0);\n\t\tcol += matColor * bouColor * dif * occ;\n\t}\n\n\tcol += fre*matColor*occ*matSSS;\n\tcol = pow(max(col, 0.0), matGamma);\n\n\treturn col;\n}\n\nvec3 background(in vec3 d) {\n\t// cheap cubemap\n\tvec3 n = abs(d);\n\tvec2 uv = (n.x > n.y && n.x > n.z) ? d.yz / d.x :\n\t\t(n.y > n.x && n.y > n.z) ? d.zx / d.y :\n\t\td.xy / d.z;\n\n\treturn vec3(0.02, 0.01, 0.00) + vec3(2.5)*pow(texture(iChannel0, 0.1*uv, 1.0).yxz, vec3(2.6, 4.0, 4.2));\n}\n\nmat3 calcCamera(in vec3 ro, in vec3 ta) {\n\tvec3 w = normalize(ro - ta);\n\tvec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n\tvec3 v = normalize(cross(w, u));\n\n\treturn mat3(u, v, w);\n}\n\n\nvoid mainShader(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n\t// camera\n\tvec3 ro = vec3(0.0, 2.7, -3.0);\n\tvec3 ta = vec3(0.0, 1.9, 0.0);\n\tro.x += 0.3*sin(0.03*iTime);\n\tmat3 camRot = calcCamera(ro, ta);\n\n\t// ray\n\tvec3 rd = normalize(camRot * vec3(p, -2.0));\n\n\t// background\n\tvec3 col = background(rd);\n\n\t// scene\n\tvec3 tm = intersect(ro, rd);\n\tfloat t = tm.x;\n\tfloat matID = tm.y;\n\tif (matID > 0.5) {\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\tvec3 matNormal, matColor, matGamma;\n\t\tfloat matRough, matOcc, matSSS, matRefOcc;\n\n\t\tmaterials(matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma);\n\t\tcol = lighting(t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma);\n\t} else {\n\t\tt = 30.0;\n\t}\n\n\tcol = pow(col, vec3(0.4545));\n\tfragColor = vec4(col, t*dot(rd, normalize(ta - ro)));\n}\n\n// EXTERNEL SHADER END\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat SCALE_RATIO = iMouse.z > 0.0 ? 1.0 : DEFAULT_SIGMA;\n\tvec2 uv = SCALE_RATIO * fragCoord / iResolution.xy;\n\n\tif (uv.x > 1.0 || uv.y > 1.0) {\n        if (uv.y > 1.0 && uv.y < 1.0 + 1.0/iResolution.y) {\n        \tfragCoord -= iResolution.xy / SCALE_RATIO;\n        } else {\n\t\t\tdiscard;\n        }\n\t}\n\tvec2 logCoord = logMap(SCALE_RATIO, fragCoord, iResolution.xy);\n\t\n\tmainShader(fragColor, logCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define FOVEAL_WITH_MOUSE 1\n#define DEBUG_LOG_SPACE 0\n#define SEE_GROUNDTRUTH 0\n\n#define ALPHA 4.0\n#define DEFAULT_SIGMA 1.8\n//#define DEFAULT_SIGMA 1.0\n\n#if DEBUG_LOG_SPACE\n\t#define iApplyLogMap1 true\n\t#define iApplyLogMap2 false\n#else\n    #if SEE_GROUNDTRUTH\n        #define iApplyLogMap1 (iMouse.z < 0.5)\n        #define iApplyLogMap2 (iMouse.z < 0.5)\n    #else\n        #define iApplyLogMap1 true\n        #define iApplyLogMap2 true\n    #endif\n#endif\n\n#define logTexture iChannel0\n#define AdjustRegion 2\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n\n#define MOVECENTER\n//#define NONLINEAR_LOGMAP\n\n#define MAX_THETA TWOPI\n#define PIXEL_SIZE (vec2(1,1) / iResolution.xy)\n\n#define USE_FXAA 0\n// FXAA parameterS\n#define FXAA_EDGE_THRESHOLD_MIN (1.0/12.0)\n#define FXAA_EDGE_THRESHOLD (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\n#define KERNEL_FUNCTION_TYPE 3.0\n\n\n// foveal position\n#if FOVEAL_WITH_MOUSE\n    #define FOVEAL ((iMouse.xy / iResolution.xy) * 2.0 - 1.0)\n    #define FOVEAL2 (iMouse.xy / iResolution.xy)\n#else\n    #define FOVEAL vec2(0.0, 0.0)\n    #define FOVEAL2 vec2(0.5, 0.5)\n#endif\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}