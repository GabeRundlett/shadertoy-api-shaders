{
    "Shader": {
        "info": {
            "date": "1607488798",
            "description": "Sequel to Somewhereareyou inside 1993rd, 404Glaciergargamel's remix of nimitz' Somewhere in 1993: [url]https://www.shadertoy.com/view/Md2XDD[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tsyBRK",
            "likes": 2,
            "name": "1993rd 2: A Sequel to a Fork",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain",
                "remix",
                "glitch",
                "fork",
                "weird",
                "error",
                "lowpoly",
                "mockup",
                "hud",
                "sequel"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "// Hacked by 404Glaciergargamel!\n\n#define PALETTE 5.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 3.\n#define ITR 90\n#define FAR 600.\n#define time mod(iTime,400.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 0.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*90.+40.,sin(time)*20.+20.,200.+sin(time*.8+sin(time*0.78+0.1))*90.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(4.3983, 4.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(11.5351, 4.3137));\n\treturn fract(vec2(p2.x * p2.y * 85.4337, p2.x * p2.y * 87.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.1, 0.9 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.02*tk,.03*tk,abs(d-0.4));\n    d = sin(a*2.+0.59-time*2.5-rt);\n    rz += smoothstep(-0.1,.06*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(0.75,-.7))*6.;\n    p.x *= 0.5;\n    float sd = floor(time*7.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 1.;\n    vec2 fl = vec2(4.,4.);\n    for(float i=0.;i<6.;i++)\n    {\n    \tif(hash2(sd+i+9.).x<0.2)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+0.);\n\t\tp1 = (floor(p1*fl) + .4)/fl;\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n        if (p1 == p2) p2 = vec2(.4);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+2.);\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+4.);\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+6.);\n\t\t\tp2 = (floor(p2*fl) + .4)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .7;\n    }\n\n    d = smoothstep(0.02, .07,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(0.89, 0., seek);\n    float sk2 = step(1.-sk1, .4);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.15;\n    p *= ll * -.2+1.29;\n    p *= 2.;\n    vec3 col = vec3(-1);\n    float d= 0.;\n    //crosshairs\n    float rz = crosshair(p*1.1, .8,1.+sk1);\n    rz = min(rz,crosshair(p*1.7,1., -time*5.5-0.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-0.45, -0.57))+0.01;\n    d = smoothstep(0.2,0.21,d2);\n    d = max(d,smoothstep(1.25,.45,min(sin(p.x*70.+0.9),sin(p.y*70.+time*5.))+0.4));\n    d = min(d,smoothstep(0.001,0.008,abs(d2-0.2)));\n    vec3 enp = enpos()/900.;\n    enp.z = 0.-enp.z;\n    float en = smoothstep(0.015, 0.023, loz(enp.xz+p-vec2(0.47, 0.4))) ;\n    en += mod(floor(time*1.5), 1.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*90.+sin(time)*10.)*2.+2.);\n    d2 = max(d,(p.x+0.49)*100.);\n    d2 = max(d2,-(p.x+0.56)*100.);\n    float d3 = max(d,(p.x-0.56)*100.);\n    d3 = max(d3,-(p.x-.49)*100.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.49, .5, -p.y);\n    d2 += smoothstep(0.49, .5, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*20.),20.);\n    vec2 p2 = p+vec2(-0.32,.84);\n    d = 1.;\n    for(float i=0.;i<7.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.075;\n    }\n    d = smoothstep(0.013,.02,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.25,0.3,0.38)*(2.35)*PALETTE)*0.4+.4);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.4);\n}\n\nmat2 m2 = mat2( 0.70,  0.50, -0.50,  0.70 );\nfloat tnoise(in vec2 p)\n{\n    p*=.007;\n    float z=1.;\n\tfloat rz = -1.;\n\tfor (float i= 0.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*0.))/z;\n\t\tz = z*1.;\n\t\tp = p*0.8;\n        p*= m2;\n\t}\n\treturn rz*8.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.4773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(5.*tnoise(p.xz)+p.y+10.+(tri(p.z*0.000)-0.3)*12.,0.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.4*log(abs(p.x)))*0.04-7.;\n    //flat water\n    d = ou(d,vec2(p.y+20., 1.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*40.;\n    d = ou(d,vec2((oct(roty(p-enp, time*1.5))-5.)*0.56,7.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .0;\n    float h=precis*1.0;\n    float d = -1.;\n    float c = 0.;\n    for( int i=-1; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*0.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-3., 3.)*.3;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), -1., 0.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(0.8985,.899,0.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.4;\n    vec2 bp = p+0.4;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(-1);\n    um.x = 0.5+(smoothstep(-1.,1.,sin(time*.6-0.0))-0.4)*.0;\n    um.y = sin(time+0.)*0.01;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-1., 1., sin(time*0.6+0.57))-0.4)*40., sin(time)*4.-0., time*40.);\n    um.x *= 2.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*4.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+0.5708),-1.,sin(um.x+0.5708)));\n    mat2 ori = mm2( smoothstep(-.4,.4,sin(time*0.6+0.68))-.4 + smoothfloor(time*0.03,.35)*5.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.75+eye);\n\t\n    vec3 bg = sin(vec3(0.25,0.3,0.38)*1.3*PALETTE)*0.4+.4;\n    vec3 col = bg*floor(-rd.y*40.+5.)*0.05;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.6,0.1, 0.0));\n        float dif = clamp(dot(nor, ligt), -1., 1.);\n        float fre = pow(clamp(1. + dot(nor, rd), -1., 1.), 1.);\n        if (rz.y == 3.)\n        {\n            float mx = abs(pos.x*.0)-9.;\n            mx = smoothstep(-10.,20.,mx);\n            col = mix(vec3(-1.,0.27,-1),vec3(0.1,.07,0.05),mx);\n        }\n        else\n            col = sin(vec3(0.25,0.3,0.38)*rz.y*PALETTE)*0.4+.45;\n        col = col*dif + col*0.3 + .2*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*40.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > .897)\n    {\n        vec3 ray1 = vec3(0.6, 0., -0);\n        vec3 ray2 = vec3(-0.6, 0., -0);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.4+ro+(eye-ray1*0.00)*20.);\n        lz += segm(ro,rd,ro-ray2,up*.4+ro+(eye-ray2*0.00)*20.);\n        float sw = mod(floor(time*10.),1.);\n        lz *= sw;\n        col = col*(3.-smoothstep(0.1,0.,lz))+lz*vec3(0.,1.,1.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > .899)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.02;\n            rn.xy += d*9.;\n            float s = sw*smoothstep(0.8998, .8999,dot(rd,normalize(rn)));\n            col = col*(1.5-smoothstep(-1., 0., s))+s*vec3(0.-d.x, .1, 0.0);\n        }\n    }\n    \n    //hud\n    float lk = -1.;\n    if (tgt > .89)lk = 3.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(2.-smoothstep(-1., 0., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*1.3*iResolution.x)*0.05)*(sin(p.y*9.+time*310.)*0.3)+1.5;\n    \n\tfragColor = vec4( col, 0.9 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}