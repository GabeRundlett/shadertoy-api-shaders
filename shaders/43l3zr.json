{
    "Shader": {
        "info": {
            "date": "1707086975",
            "description": "getting up close and personal with converting space into a ring,\nfor a follow-up to [url=https://www.shadertoy.com/view/XfBXDt]SDF Runner[/url].\n",
            "flags": 0,
            "hasliked": 0,
            "id": "43l3zr",
            "likes": 14,
            "name": "angular repetition study",
            "published": 3,
            "tags": [
                "opring"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "/*\n    getting up close and personal with converting space into a ring,\n    for a follow-up to [url=https://www.shadertoy.com/view/XfBXDt]SDF Runner[/url].\n    orion elenzil 2024\n*/\n\nconst float gZoom       = 0.8;\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n\n// Orion Elenzil\n// From https://www.shadertoy.com/view/43l3zr\n//\n// repeats the origin 'reps' times\n// around a ring of radius 'rad'.\n//\n// reps must be a positive integer.\n//\n// returns:\n//   v.xy = new coordinates\n//   v.z  = cell index, [0, reps - 1].   \nvec3 opRing(in vec2 p, float rad, float reps) {\n    float scale = pi * 2.0 / reps;\n    float theta;\n    float cell;\n    float isEven;\n    \n    // theta in [-ðœ‹, ðœ‹]\n    theta  = atan(p.y, p.x);\n    \n    // scale theta to [-reps/2, reps/2]\n    theta /= scale;\n\n    // determine cell index\n    isEven = float((int(reps) + 1) % 2);\n    cell   = theta + (reps + isEven) / 2.0;\n    cell   = floor(mod(cell, reps));\n\n    // repeat space. theta in [-1/2, 1/2]\n    theta  = fract(theta + 0.5) - 0.5;\n    \n    // scale up again\n    theta *= scale;\n    \n    // polar to cartesian\n    p      = vec2(cos(theta), sin(theta)) * length(p);\n\n    // move the origin onto the ring\n    p.x   -= rad;\n\n    // align +x to be counter-clockwise along the ring.\n    // this might not be what you want,\n    // but it seems natural to me.\n    p      = vec2(p.y, -p.x);\n\n    return vec3(p, cell);\n}\n\nfloat gBoxSize = 0.1;\n\nvoid addShape(inout float d, in vec2 p) {\n    float b;\n    b  = sdBox (p, vec2(gBoxSize));\n    // chop out the inside\n    d  = max(d, -b);\n    // draw the outline\n    d  = min(d, abs(b));\n    \n    // add markers to reveal any mirroring going on\n    float markerSize = gBoxSize * 0.3;\n    b  = sdDisk(p - vX * gBoxSize, gBoxSize * 0.2);\n    \n    b  = sdEquilateralTriangle((p - vX * (gBoxSize + markerSize * 0.6)).yx, markerSize);\n    \n    d  = min(d, b);\n    b  = sdBox (p - vY * gBoxSize, v1 * markerSize);\n    d  = min(d, b);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    SETTIME;\n    gLineWidth = VIEWFROMSCREEN_DIST(2.0);\n    gAAEps     = VIEWFROMSCREEN_DIST(2.0);\n    vec2 p     = VIEWFROMSCREEN     (XY );\n\n    float ringRad  = 1.0;\n    float ringReps = 7.0;\n    \n    if (length(iMouse.xy) > 100.0) {\n        ringRad  = smoothstep(0.0, 1.0, iMouse.y / RES.y);\n        ringReps = smoothstep(0.0, 1.0, iMouse.x / RES.x);\n        ringReps = mix(1.0, 30.0, ringReps);\n        ringReps = round(ringReps);\n    }\n    \n    float d = 1e9;\n    float b;\n    float c = 1.0;\n    vec3  q;\n    \n    float beat = 0.0;\n    beat = max(beat, abs(sin(gT * 2.0 + 0.0)));\n    beat = max(beat, abs(sin(gT * 2.0 + 0.6)));\n    beat = pow(beat, 30.0) * 0.01 + 1.0;\n\n    d = min(d, abs(sdDisk(p, ringRad * beat)));\n\n    addShape(d, p);\n\n    // overall rotation\n    p *= rot2(gT * 0.1);\n\n    // repeat the origin numReps times\n    // around a ring of size ringRad.\n    q  = opRing(p, ringRad, ringReps);\n\n    // wiggle in place\n    float wiggle = sin(gT * pi * 2.0 * (1.0 + q.z / ringReps));\n    wiggle = smoothstep(-1.1, 1.1, wiggle) * 2.0 - 1.0;\n    q.xy *= rot2(wiggle * 0.3);\n    \n    // draw second single instance magically repeated\n    addShape(d, q.xy);\n\n    // fill region\n    d  = d - gLineWidth * 2.0;\n    c  = mix(c, 0.7, smoothstep(gAAEps, -gAAEps, d));\n\n    // stroke\n    d  = abs(d) - gLineWidth;\n    c  = mix(c, 0.0, smoothstep(gAAEps, -gAAEps, d));\n    \n    RGBA.rgb  = vec3(c);\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(dot2(XY/RES - 0.5) * 1.5, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec2  vX  = v01.yx;\nconst vec2  vY  = v01.xy;\nconst vec2  v0  = v01.xx;\nconst vec2  v1  = v01.yy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \nfloat dot2(float a) { return dot(a, a); }\nfloat dot2(vec2  a) { return dot(a, a); }\n\n//------------------------------------------------------------\n// each pass should include SETTIME in main.\nfloat gT;\n#define SETTIME gT = (iTime * 1.0);\n\n\n//------------------------------------------------------------\n// distance functions\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdDisk(in vec2 p, in float rad) {\n    return length(p) - rad;\n}\n\n\n//------------------------------------------------------------\n\nmat2 rot2(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n//------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}