{
    "Shader": {
        "info": {
            "date": "1559532390",
            "description": "Click on colored points to drag them. Press SPACE or arrows to navigate between examples, R to reset draggable objects, C to swap between cases.",
            "flags": 48,
            "hasliked": 0,
            "id": "3tBGDD",
            "likes": 29,
            "name": "Fun with the Poincaré disk",
            "published": 3,
            "tags": [
                "tutorial",
                "geometry",
                "hyperbolic"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1501
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//\n// Fun with the Poincaré Disk by mattz\n// License CC-NC-BY-SA 3.0\n// \n//////////////////////////////////////////////////////////////////////\n//\n// Implementing ideas from\n//\n//   \"Compass and Straightedge in the Poincaré Disk\"\n//   Chaim Goodman-Strauss\n//   The American Mathematical Monthly\n//   Vol. 108, No. 1 (Jan., 2001), pp. 38-49\n//\n// Available at https://www.jstor.org/stable/2695674\n// and also at https://strauss.hosted.uark.edu/papers/hypcomp.pdf\n//\n// See also: https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model\n//\n//////////////////////////////////////////////////////////////////////\n//\n// Currently implements these demos (use SPACE/arrows advance thru):\n//\n//   * Construction 1.1: circle from 3 points\n//   * Construction 1.2: inverting a point through a circle\n//   * Construction 1.6: orthogonal circle from point\n//   * Figure 4: poles and polars\n//   * Construction 2.2: geodesic from points & polars\n//   * Construction 2.3: hyperbolic circle\n//   * Construction 3.1: perpendicular bisector\n//   * Construction 3.2: triangle translation\n//   * Construction 3.3: congruent circles\n//   * Construction 3.4: line from point & direction\n//   * Robust intersection testing\n//\n//////////////////////////////////////////////////////////////////////\n//\n// Data types:\n//\n// points are represented as vec2's x, y such that x^2 + y^2 <= 1\n// (points with x^2 + y^2 = 1 are ideal points/points at infinity)\n//\n// lines/circles are represented as vec3's u, v, r2: \n//   * either a circle centered at (u, v) with squared radius r if r2 > 0\n//   * or a diameter of the unit circle with normal (u, v) if r2 == 0\n//\n// a pure 2D line can also be represented as a vec3 a, b, c to \n// represent the implicit line equation ax + by + c = 0\n//\n//////////////////////////////////////////////////////////////////////\n\n// for deciding between lines and diameters below\nconst float tol = 1e-5;\n\nfloat textDist;\nvec2 textPos;\n\nfloat inkDist;\nvec3 colorOut;\n\nconst vec4 NO_INTERSECT = vec4(-1e5);\n\n//////////////////////////////////////////////////\n// geometric utility functions\n\n// are two points on the same diameter of the unit circle?\nbool alongDiameter(vec2 p, vec2 q) {\n   \n    vec4 pq = abs(vec4(p, q));\n    float m = max(max(pq.x, pq.y), max(pq.z, pq.w));\n    \n    float k = abs(p.x*q.y - p.y*q.x);\n    \n    return k < TOL*m;\n    \n}\n\n// are two points the same length?\nbool sameLength(float pp, float qq) {\n    return abs(pp - qq) < TOL*max(pp, qq);\n}\n\n// any special geometric cases for these two points?\nbool inGeneralPosition(vec2 p, vec2 q) {\n    \n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    return (pp > TOL_SQR &&\n            qq > TOL_SQR &&\n            !alongDiameter(p, q) &&\n            !sameLength(pp, qq));\n    \n}\n\n\n// rotate by 90 degrees\nvec2 perp(vec2 p) {\n    return vec2(-p.y, p.x);\n}\n\n// return the closer of two points to point p\nvec2 closer(vec4 ab, vec2 p) {\n    vec4 diff = ab - vec4(p, p);\n    return dot(diff.xy, diff.xy) < dot(diff.zw, diff.zw) ? ab.xy : ab.zw;\n}\n\n// return the point of the pair with the smaller norm\nvec3 smaller(vec4 ab) {\n    return vec3(dot(ab.xy, ab.xy) < dot(ab.zw, ab.zw) ? ab.xy : ab.zw,\n                ab == NO_INTERSECT ? 0 : 1);\n}\n\n// intersection of a circle with a line thru the origin perpendicular\n// to normal n (must be a unit vector)\nvec4 intersectCL(vec3 c, vec2 n) {\n\n    float d = dot(n, c.xy);\n    vec2 p = c.xy - d * n;\n    \n    float d2 = d*d;\n    \n    if (d2 >= c.z) {\n        return NO_INTERSECT;\n    }\n    \n    vec2 t = perp(n);\n    \n    float a = sqrt(c.z - d2);\n    \n    return vec4(p + a*t, p - a*t);\n    \n}\n\n// intersection of two circles\nvec4 intersectCC(vec3 c1, vec3 c2) {\n    \n    vec2 diff = c2.xy - c1.xy;\n    \n    float d2 = dot(diff, diff);\n    float d2inv = 1.0/d2;\n\n    vec2 n = perp(diff);\n\n    float ad = 0.5*(c1.z - c2.z + d2);\n\n    float a2 = ad*ad*d2inv;\n    \n    if (c1.z < a2) {\n        return NO_INTERSECT;\n    }\n\n    float h = sqrt((c1.z - a2)*d2inv);\n\n    vec2 mid = c1.xy + (ad*d2inv)*diff;\n    \n    return vec4(mid + h*n, mid - h*n);\n    \n}\n\n// homogeneous 2D coordinates of line that perpendicularly bisects a & b\nvec3 bisector2D(vec2 a, vec2 b) {\n    vec2 midpoint = 0.5*(a + b);\n    vec2 diff = b-a;\n    return vec3(diff, -dot(diff, midpoint));\n}\n\n// circle centered at center containing point p\nvec3 compass2D(vec2 ctr, vec2 p) {\n    vec2 diff = p - ctr;\n    return vec3(ctr, dot(diff, diff));\n}\n\n// Construction 1.1: circle passing through 3 points a, b, c\nvec3 circle3(vec2 a, vec2 b, vec2 c) {\n    vec3 lab = bisector2D(a, b);\n    vec3 lbc = bisector2D(b, c);\n    vec3 ctr = cross(lab, lbc);\n    return compass2D(ctr.xy/ctr.z, a);\n}\t\n\n// Construction 1.2: invert a point through a circle\nvec2 invertPC(vec2 p, vec3 c) {\n    vec2 po = p - c.xy;    \n    return c.xy + po * c.z / dot(po, po);\n}\n\n// Special case of Construction 1.2 for unit circle\nvec2 invertUnit(vec2 p) {\n    return p / dot(p, p);\n}\n\n///////////////////////////////////////////////////\n// utility functions for drawing:\n\n// distance from a point to a line or circle\nfloat geodesicDist(vec3 l, vec2 p) {\n\tif (l.z > 0.0) {\n\t\treturn length(p-l.xy) - sqrt(l.z);\n\t} else {\n\t\treturn dot(p, normalize(l.xy));\n\t}\n}\n\n// mix src into dst by smoothstepping k with threshold d\nvoid ink(vec3 src) {\n    colorOut = mix(src, colorOut, smoothstep(0.0, scl, inkDist));\n    inkDist = 1e5;\n}\n\n// draw either line or circle (using geodesicDist above)\nvoid drawLine(in vec3 l, in vec2 p) {\n    inkDist = min(inkDist, abs(geodesicDist(l, p)));\n}\n\n// draw either line or circle and clip to unit circle\nvoid drawGeodesic(in vec3 l, in vec2 p) {\n    inkDist = min(inkDist, max(abs(geodesicDist(l, p)), length(p)-1.));\n}\n\n// draw a 2D point\nvoid drawPoint(in vec2 x, in vec2 p) {\n\tinkDist = min(inkDist, length(x-p)-pointSize);\n}\n\n// outline a 2D point\nvoid drawDot(in vec2 x, in vec2 p) {\n    float d = length(x-p)-(pointSize-+0.5*scl);\n\tcolorOut = mix(vec3(1), colorOut, smoothstep(0.0, scl, d));\n    inkDist = min(inkDist, abs(d));\n}\n\n// draw a 2D infinite line in homogeneous format ax + by + c = 0\nvoid drawLine2D(in vec3 l, in vec2 p) {\n    l /= length(l.xy);\n    inkDist = min(inkDist, abs(dot(p, l.xy)+l.z));\n}\n\n// draw a 2D line segment between two points\nvoid drawSeg2D(in vec2 a, in vec2 b, in vec2 p) {\n    p -= a;\n    b -= a;\n    float u = clamp(dot(p,b)/dot(b,b), 0., 1.);\n    inkDist = min(inkDist, length(p - u*b));\n}\n\n// draw a geodesic segment between two points\nvoid drawSeg(vec2 p, vec2 q, vec3 cpq, vec2 uv) {\n    \n    float d = abs(geodesicDist(cpq, uv));\n    \n    vec2 diff = normalize(q - p);\n    \n    d = max(d, dot(p - uv, diff));\n    d = max(d, dot(uv - q, diff));\n    d = max(d, length(uv)-1.);\n    \n    inkDist = min(inkDist, d);\n}\n\n// draw a perpendicular marker at point x in direction d\nvoid drawPerp(vec2 x, vec2 d, in vec2 p) {\n    \n    d = normalize(d)*perpSize;\n    vec2 t = perp(d);\n    \n    vec2 x1 = x + d;\n    vec2 x2 = x1 + t;\n    vec2 x3 = x + t;\n    \n    drawSeg2D(x1, x2, p);\n    drawSeg2D(x2, x3, p);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// text drawing functions\n\n// distance to character in SDF font texture\nfloat fontDist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n      \n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv)-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n// a character encodes a position in the font texture\nvoid drawChar(uint c) {\n    \n    uint lo = c & 0xFU;\n    uint hi = (c >> 4) & 0xFU;\n    \n    vec2 offset = vec2(float(lo), 15.-float(hi));\n    \n    textDist = min(textDist, fontDist(textPos, textSize, offset));\n    textPos -= vec2(0.8*textSize, 0);\n\n}\n\n// a chunk has 4 8-bit characters\nvoid drawChar4(uint c) {\n    \n    uvec4 chars = uvec4(c) >> uvec4(0, 8, 16, 24);\n    \n    drawChar(chars.x);\n    drawChar(chars.y);\n    drawChar(chars.z);\n    drawChar(chars.w);\n    \n}\n\n// a string is a group of 4-character chunks\nvoid drawChar16(uvec4 chars) {  \n    \n    drawChar4(chars.x);\n    drawChar4(chars.y);\n    drawChar4(chars.z);\n    drawChar4(chars.w);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// hyperbolic geometry functions\n\n// Construction 1.6: orthogonal circle passing thru point\nvec3 orthogonalCircle(vec3 c, vec2 p) {\n    vec2 po = p - c.xy;\n    float h2 = dot(po, po);\n    float r2 = (h2 - c.z);\n    return vec3(p, r2);\n}\n\n// special case of Construction 1.6 for unit circle\nvec3 geodesicFromPole(vec2 p) {\n    float h2 = dot(p, p);\n    float r2 = (h2 - 1.);\n    return vec3(p, r2);\n}\n\n// Polar of a point p about the unit circle\n// 2D line passing thru the midpoint of p and its inverse, perp. to p.\nvec3 polarFromPoint(vec2 p) {\n    return vec3(p, -0.5*dot(p, p) - 0.5);\n}\n\n// intersection of geodesic and circle\nvec4 intersectGC(vec3 g, vec3 c) {\n    if (g.z == 0.) {\n        return intersectCL(c, g.xy);\n    } else {\n        return intersectCC(g, c);\n    }\n}\n\n// intersection of two geodesics\nvec3 intersectGG(vec3 c1, vec3 c2) {\n    if (c1.z == 0.) {\n        if (c2.z == 0.) {\n            return vec3(0, 0, 1);\n        } else {\n            return smaller(intersectCL(c2, c1.xy));\n        }\n    } else if (c2.z == 0.) {\n        return smaller(intersectCL(c1, c2.xy));\n    } else {\n        return smaller(intersectCC(c1, c2));\n    }\n}\n\n// invert point about geodesic (either arc or line)\nvec2 reflectPG(vec2 p, vec3 c) {\n    if (c.z == 0.) {\n        return p - (2.*dot(p, c.xy))*c.xy;\n    } else {\n        return invertPC(p, c);\n    }\n}\n\n// Construction 2.2: geodesic from polars of points\nvec3 geodesicFromPoints(vec2 p, vec2 q) {\n    \n    if (alongDiameter(p, q)) {\n        vec2 n = normalize(perp(p - q));\n        return vec3(n, 0);\n    }\n\n    vec3 ppolar = polarFromPoint(p);\n    vec3 qpolar = polarFromPoint(q);\n    vec3 inter = cross(ppolar, qpolar);\n\n    return compass2D(inter.xy/inter.z, p);\n    \n}\n\n// return a geodesic passing thru p perpendicular to the diameter\n// through p - undefined if p == (0, 0)\nvec3 geodesicPerpTo(vec2 p) {\n    \n    float a2 = dot(p, p);\n    float x = a2 + 1.;\n    \n    float h_over_a = x / (2.*a2);\n    float h2 = 0.5*x*h_over_a;\n    \n    vec2 c = p * h_over_a;\n    \n    return vec3(c, (h2 - 1.));\n    \n}\n\n// Construction 2.3: hyperbolic compass. \n// construct hyperbolic circle with center p that passes thru q\nvec3 hyperbolicCompass(vec2 p, vec2 q) {\n    \n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) {\n        return vec3(p, (qq));\n    } \n    \n    if (alongDiameter(p, q)) {\n        vec3 pperp = geodesicPerpTo(p);\n        vec2 qp = invertPC(q, pperp);\n        vec2 qmid = 0.5*(q + qp);\n        return compass2D(qmid, q);\n    }\n    \n    // get polars of p and q\n    vec3 ppolar = vec3(p, -0.5*pp - 0.5);\n    vec3 qpolar = vec3(q, -0.5*qq - 0.5);\n    \n    // homogeneous coords of pole of geodesic pq\n    vec3 pole = cross(ppolar, qpolar);\n    \n    // this is the direction from point q to the pole\n    vec2 dqpole = pole.xy - pole.z*q; \n    \n    // 2D line tangent to geodesic pq at q\n    vec3 lq = vec3(dqpole, -dot(dqpole, q));\n    \n    // 2D line containing p and the origin\n    vec3 lp = vec3(perp(p), 0);\n    \n    // homogeneous coords of intersection of these lines\n    vec3 rval = cross(lq, lp);\n    \n    // return circle\n    return compass2D(rval.xy/rval.z, q);\n    \n}\n\n// Construction 3.1: Perpendicular bisector\nvec3 hyperbolicBisector(vec2 p, vec2 q) {\n\n    float pp = dot(p, p);\n    float qq = dot(q, q);\n    \n    if (pp < TOL_SQR) { \n        \n        // p is at origin\n        float h2 = 1.0/qq;\n        return vec3(q*h2, (h2 - 1.));\n       \n    } else if (qq < TOL_SQR) { \n        \n        // q is at origin                \n        float h2 = 1.0/pp;\n        return vec3(p*h2, (h2 - 1.));\n        \n    } else if (sameLength(pp, qq)) {\n        \n        // p and q are same length, return the diameter\n        return vec3(normalize(p - q), 0);\n        \n    }\n    \n    // this remarkably small piece of code reflects the following algebra:\n    //\n    // let d = q - p be the difference between p & q\n    // let x be the pole of the bisector\n    //\n    // since the pole of the bisector is on the line from p to q, we know\n    //\n    //   x = p + k*d\n    //\n    // for some unknown k with abs(k) > 1 (because the pole isn't between p & q)\n    //\n    // now let's try to solve for k.\n    //\n    // we know that since the pole x is orthogonal to the unit circle, \n    // the radius of the bisector circle is governed by\n    //\n    //   r^2 = ||x||^2 - 1\n    //       = ||p + k*d ||^2 - 1\n    //       = p.p + 2k*p.d + k^2*d.d\n    //\n    // also since p and q are inverted through the bisector circle with radius\n    // r we know\n    //\n    //   r^2 = || x-p || * || x-q || = ||d|| * || k*d - d ||\n    //       = k*(k-1)*d.d \n    //\n    // now we can set the two equations equal and solve for k\n\n    vec2 d = q - p;\n    float k = (1.0 - dot(p,p))/(dot(d,d) + 2.0*dot(p,d));\n    \n    return geodesicFromPole( p + k*d );\n    \n}\n\n// Construction 3.3 from paper\nvec3 hyperbolicCircleCopy(vec2 a, vec2 b, vec2 c) {\n    \n    vec3 bisector = hyperbolicBisector(a, b);\n    vec2 cp = reflectPG(c, bisector);\n    return hyperbolicCompass(a, cp);\n    \n}\n\n// Construction 3.4: geodesic from point & direction\nvec3 geodesicFromPointDir(vec2 p, vec2 d) {\n    \n    if (alongDiameter(p, d)) {\n        return vec3(normalize(perp(d)), 0);\n    } \n        \n    vec3 ppolar = polarFromPoint(p);\n    vec3 l = vec3(d, -dot(d, p));\n    \n    vec3 pinter = cross(ppolar, l);\n    \n    return geodesicFromPole(pinter.xy/pinter.z);\n    \n}   \n\n//////////////////////////////////////////////////////////////////////\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float demo = LOAD(DEMO).x;\n\n    setupScene(iResolution.xy, demo);\n    vec2 uv = sceneFromFrag(fragCoord);\n    \n    const vec3 unitCircle = vec3(0.0, 0.0, 1.0);\n\tconst vec2 o = vec2(0);\n    \n    colorOut = vec3(1);\n    \n    textDist = 1e5;\n    inkDist = 1e5;\n    \n    textPos = fragCoord - vec2(textSize, iResolution.y - textSize);\n    \n    if (demo == DEMO_CIRCLE_FROM_POINTS) {\n\n        vec2 p = LOAD(EX1_P).xy;\n        vec2 q = LOAD(EX1_Q).xy;\n        vec2 r = LOAD(EX1_R).xy;\n\n        vec3 c = circle3(p, q, r);\n        \n        // everything below here just for visualization!\n        \n        perpSize = min(perpSize, 0.25 * c.z);\n\n        drawPerp(0.5*(p+q), q-p, uv);\n        drawPerp(0.5*(q+r), r-q, uv);\n        drawLine2D(bisector2D(p, q), uv);\n        drawLine2D(bisector2D(q, r), uv);\n        \n        ink(LIGHTGRAY);\n        \n        drawSeg2D(p, q, uv);\n        drawSeg2D(q, r, uv);\n        drawPoint(c.xy, uv);\n        \n        ink(GRAY);\n\n        drawLine(c, uv);\n        \n        ink(BLACK);\n \n        drawPoint(p, uv); ink(RED);\n        drawPoint(q, uv); ink(GREEN);\n        drawPoint(r, uv); ink(BLUE);\n        \n        drawChar16(uvec4(0x312e3143U,0x6943203aU,0x656c6372U,0x6f726620U));\n        drawChar16(uvec4(0x2033206dU,0x6e696f70U,0x20207374U,0x20202020U));        \n        \n    \n    } else if (demo == DEMO_INVERT_THRU_CIRCLE) {\n        \n        vec2 p = LOAD(EX2_P).xy;\n        vec2 pinv = invertUnit(p);\n        \n        // everything below here just for visualization!\n\n        vec3 c = compass2D(0.5*(pinv + o), o);\n        \n        vec4 qr = intersectCC(c, unitCircle);\n\n        perpSize = min(perpSize, min(0.25*length(qr.xy - p), 0.5*length(p)));\n\n        drawLine(c, uv);\n        drawPerp(qr.xy, pinv-qr.xy, uv);\n        drawPerp(p, p-pinv, uv);\n        ink(LIGHTGRAY);\n       \n        drawSeg2D(o, pinv, uv);\n        drawSeg2D(o, qr.xy, uv);\n        drawSeg2D(pinv, qr.xy, uv);\n        drawSeg2D(p, qr.xy, uv);\n        ink(GRAY);\n\n        drawPoint(o, uv);\n        drawPoint(qr.xy, uv);\n        drawLine(unitCircle, uv);\n        ink(BLACK);\n \n        drawDot(pinv, uv);\n        drawPoint(p, uv);\n        ink(RED);\n\n        drawChar16(uvec4(0x322e3143U,0x6e49203aU,0x74726576U,0x696f7020U));\n        drawChar16(uvec4(0x7420746eU,0x20757268U,0x63726963U,0x2020656cU));\n        \n    } else if (demo == DEMO_ORTHO_CIRCLE_FROM_POINT) {\n        \n        vec2 p = LOAD(EX3_P).xy;\n        vec3 c = geodesicFromPole(p);        \n        \n        // everything below here just for visualization!\n       \n        vec3 cc = compass2D(0.5*p, p);\n        \n        vec4 qr = intersectCC(cc, unitCircle);\n        \n        perpSize = min(perpSize, 0.25*c.z);\n\n        drawLine(cc, uv);\n        drawPerp(qr.xy, perp(qr.xy), uv);\n        drawPerp(qr.zw, -qr.zw, uv);\n        drawSeg2D(o, p, uv);\n        ink(LIGHTGRAY);\n        \n        drawGeodesic(c, uv);\n        ink(RED);\n        \n        drawLine(unitCircle, uv);\n        drawPoint(o, uv);\n        ink(BLACK);\n\n        drawPoint(p, uv);\n        ink(RED);\n\n        drawChar16(uvec4(0x362e3143U,0x724f203aU,0x2e6f6874U,0x72696320U));\n        drawChar16(uvec4(0x20656c63U,0x6d6f7266U,0x696f7020U,0x2020746eU));\n        \n    } else if (demo ==DEMO_POLES_AND_POLARS) {\n        \n        vec2 p = LOAD(EX4_P).xy;\n        vec2 q = LOAD(EX4_Q).xy;\n        \n        vec3 qpole = geodesicFromPole(q);        \n        vec3 ppolar = polarFromPoint(p);\n        \n        // everything below here just for visualization!\n\n        vec2 pinv = invertUnit(p);\n        vec2 p1 = 0.5*(p + pinv);\n        \n        vec2 t = perp(normalize(p)) * (0.5*length(pinv-p1) + 0.125);\n        \n        vec2 p0 = p1 - t;\n        vec2 p2 = p1 + t;\n        \n        vec3 c0 = geodesicFromPole(p0);\n        vec3 c1 = geodesicFromPole(p1);\n        vec3 c2 = geodesicFromPole(p2);\n        \n        drawLine2D(ppolar, uv);\n        ink(RED);\n        \n        drawPoint(p1, uv);\n        drawPoint(p0, uv);\n        drawPoint(p2, uv);\n        drawGeodesic(c0, uv);\n        drawGeodesic(c1, uv);\n        drawGeodesic(c2, uv);\n        drawSeg2D(p, normalize(p), uv);\n        ink(GRAY);\n\n        drawGeodesic(qpole, uv);\n        ink(BLUE);\n\n        drawLine(unitCircle, uv);\n        ink(BLACK);\n        \n        drawPoint(p, uv);\n        drawDot(pinv, uv);\n        ink(RED);\n   \n        drawPoint(q, uv);\n        ink(BLUE);\n\n        drawChar16(uvec4(0x75676946U,0x34206572U,0x6f50202eU,0x2073656cU));\n        drawChar16(uvec4(0x20646e61U,0x616c6f70U,0x202e7372U,0x20202020U));\n        \n    } else if (demo == DEMO_GEODESIC_FROM_POINTS) {\n        \n        vec2 p = LOAD(EX5_P).xy;\n        vec2 q = LOAD(EX5_Q).xy;\n        \n        vec3 c = geodesicFromPoints(p, q);\n        \n        // everything below here just for visualization!\n\n        vec4 r = intersectCC(c, unitCircle);\n        \n        vec3 ppolar = polarFromPoint(p);\n        vec3 qpolar = polarFromPoint(q);\n        \n        vec3 pinter = cross(ppolar, qpolar);\n        pinter /= pinter.z;\n        \n        perpSize = min(perpSize, 0.25*c.z);\n\n        drawPerp(r.xy, perp(r.xy), uv);\n        drawPerp(r.zw, -r.zw, uv);\n        ink(LIGHTGRAY);\n        \n        drawLine2D(ppolar, uv);\n        ink(RED);\n\n        drawLine2D(qpolar, uv);\n        ink(BLUE);\n        \n        drawLine(unitCircle, uv);\n        drawPoint(pinter.xy, uv);\n        ink(BLACK);\n        \n        drawGeodesic(c, uv);\n        ink(GRAY);\n\n\n        drawPoint(p, uv);\n        ink(RED);\n   \n        drawPoint(q, uv);\n        ink(BLUE);\n        \n        drawChar16(uvec4(0x312e3243U,0x3243202cU,0x203a322eU,0x646f6547U));\n        drawChar16(uvec4(0x63697365U,0x6f726620U,0x6f70206dU,0x73746e69U));\n        \n    } else if (demo == DEMO_HYPERBOLIC_CIRCLE) {\n        \n        vec2 p = LOAD(EX6_P).xy;\n        vec2 q = LOAD(EX6_Q).xy;\n        \n        vec3 cp = hyperbolicCompass(p, q);\n\n        // everything below here just for visualization!\n\n        vec3 c = geodesicFromPoints(p, q);\n                \n        if (inGeneralPosition(p, q)) {\n        \n            vec2 dqc = q - c.xy;\n            vec3 lq = vec3(dqc, -dot(dqc, q));\n            vec3 lp = vec3(perp(p), 0);\n            vec3 pinter = cross(lq, lp);\n            pinter /= pinter.z;\n        \n            drawPerp(q, perp(dqc), uv);\n            ink(LIGHTGRAY);\n        \n            drawSeg2D(normalize(p), o, uv);\n            drawSeg2D(c.xy, q, uv);\n            drawSeg2D(pinter.xy, q, uv);\n            drawPoint(c.xy, uv);\n            drawPoint(pinter.xy, uv);\n            ink(GRAY);\n            \n        }\n        \n        drawGeodesic(c, uv);\n        ink(GRAY);\n\n        drawLine(unitCircle, uv);\n        drawPoint(o, uv);\n        ink(BLACK);\n\n        drawLine(cp, uv);    \n        ink(RED);\n   \n        drawPoint(q, uv);\n        ink(BLUE);\n\n        drawPoint(p, uv);\n        ink(RED);      \n\n        drawChar16(uvec4(0x332e3243U,0x7948203aU,0x62726570U,0x63696c6fU));\n        drawChar16(uvec4(0x72696320U,0x20656c63U,0x20202020U,0x20202020U));\n        \n    } else if (demo == DEMO_PERP_BISECTOR) {\n        \n        vec2 p = LOAD(EX7_P).xy;\n        vec2 q = LOAD(EX7_Q).xy;\n        \n        vec3 bisector = hyperbolicBisector(p, q);\n                \n        // everything below here just for visualization!        \n        vec3 cpq = geodesicFromPoints(p, q);\n        \n        vec2 mid = intersectGG(bisector, cpq).xy;\n        \n        if (inGeneralPosition(p, q)) {\n\n            vec2 pinv = invertUnit(p);\n            vec2 qinv = invertUnit(q);\n        \n            vec3 l = cross(vec3(p, 1), vec3(q, 1));\n            vec3 linv = cross(vec3(pinv, 1), vec3(qinv, 1));\n        \n            vec3 pinter = cross(l, linv);\n            pinter /= pinter.z;\n            \n            drawSeg2D(pinv, pinter.xy, uv);\n            drawSeg2D(qinv, pinter.xy, uv);\n            \n            drawSeg2D(p, pinter.xy, uv);\n            drawSeg2D(q, pinter.xy, uv);\n            \n            ink(LIGHTGRAY);\n            \n            drawPoint(pinter.xy, uv);\n\t\t\tink(GRAY);\n            \n            drawDot(qinv, uv);\n            ink(BLUE);\n\n            drawDot(pinv, uv);\n            ink(RED);\n            \n        }\n        \n        vec3 cmid = hyperbolicCompass(mid, p);\n        \n        drawLine(cmid, uv);\n        ink(LIGHTGRAY);\n        \n        drawSeg(p, q, cpq, uv);\n        drawGeodesic(bisector, uv);\n        drawPoint(mid, uv);\n\n        ink(GRAY);\n        \n        drawLine(unitCircle, uv);\n        ink(BLACK);\n   \n        drawPoint(q, uv);\n        ink(BLUE);\n\n        drawPoint(p, uv);\n        ink(RED);\n        \n        drawChar16(uvec4(0x312e3343U,0x6550203aU,0x6e657072U,0x75636964U));\n        drawChar16(uvec4(0x2072616cU,0x65736962U,0x726f7463U,0x20202020U));\n        \n    } else if (demo == DEMO_TRI_TRANSLATE) {\n\n        vec2 a = LOAD(EX8_A).xy;\n        vec2 b = LOAD(EX8_B).xy;\n        vec2 c = LOAD(EX8_C).xy;\n        \n        vec2 ap = LOAD(EX8_P).xy;\n        vec2 q = LOAD(EX8_Q).xy;\n        \n        vec3 cab = hyperbolicCircleCopy(ap, a, b);\n        vec3 pq = geodesicFromPoints(ap, q);\n        vec4 r = intersectGC(pq, cab);\n        vec2 bp = closer(r, q);\n        \n        vec3 g1 = hyperbolicBisector(a, ap);\n        vec2 bpp = reflectPG(b, g1);\n        vec3 g2 = hyperbolicBisector(bpp, bp);\n        \n        vec2 cp = reflectPG(reflectPG(c, g1), g2);\n        \n        vec3 gab = geodesicFromPoints(a, b);\n        vec3 gbc = geodesicFromPoints(b, c);\n        vec3 gca = geodesicFromPoints(c, a);\n\n        vec3 gabp = geodesicFromPoints(ap, bp);\n        vec3 gbcp = geodesicFromPoints(bp, cp);\n        vec3 gcap = geodesicFromPoints(cp, ap);\n\n        drawLine(cab, uv);\n        drawGeodesic(pq, uv);\n        ink(LIGHTGRAY);\n        \n        drawGeodesic(g1, uv);\n        ink(RED);\n        \n        drawGeodesic(g2, uv);\n        ink(GREEN);\n        \n        drawPoint(bpp, uv);\n        ink(GRAY);\n        \n        drawLine(unitCircle, uv);\n        \n        drawSeg(a, b, gab, uv);\n        drawSeg(b, c, gbc, uv);\n        drawSeg(c, a, gca, uv);\n\n        drawSeg(ap, bp, gabp, uv);\n        drawSeg(bp, cp, gbcp, uv);\n        drawSeg(cp, ap, gcap, uv);\n\n        ink(BLACK);\n\n        drawPoint(a, uv);\n        ink(RED);\n        drawPoint(b, uv);\n        drawDot(bp, uv);\n        ink(GREEN);\n        drawPoint(c, uv);\n        drawDot(cp, uv);\n        ink(BLUE);\n        \n        drawPoint(ap, uv);\n        ink(PURPLE);\n        \n        drawPoint(q, uv);\n        ink(CYAN);\n\n        drawChar16(uvec4(0x322e3343U,0x7254203aU,0x676e6169U,0x7420656cU));\n        drawChar16(uvec4(0x736e6172U,0x6974616cU,0x20206e6fU,0x20202020U));\n\n    } else if (demo == DEMO_CONGRUENT_CIRCLES) {\n        \n        vec2 a = LOAD(EX9_A).xy;\n        vec2 b = LOAD(EX9_B).xy;\n        vec2 c = LOAD(EX9_C).xy;\n        \n        vec3 ca = hyperbolicCircleCopy(a, b, c);\n        \n        // everything below here just for visualization!        \n        \n     \tvec3 cbc = geodesicFromPoints(b, c);\n        vec3 cb = hyperbolicCompass(b, c);\n\n        vec3 bisector = hyperbolicBisector(a, b);\n        vec2 cp = reflectPG(c, bisector);\n        \n        vec3 cseg = geodesicFromPoints(c, cp);\n        vec3 abseg = geodesicFromPoints(a, b);\n        \n        drawLine(unitCircle, uv);\n        ink(BLACK);\n        \n        drawGeodesic(bisector, uv);\n        drawSeg(c, cp, cseg, uv);\n        drawSeg(a, b, abseg, uv);\n        ink(LIGHTGRAY);\n        \n        drawLine(cb, uv);\n        drawLine(ca, uv);\n        drawPoint(cp, uv);\n        ink(GRAY);\n          \n        drawPoint(a, uv);\n        ink(RED);\n        drawPoint(b, uv);\n        ink(GREEN);\n        drawPoint(c, uv);\n        ink(BLUE);\n\n        drawChar16(uvec4(0x332e3343U,0x6f43203aU,0x7572676eU,0x20746e65U));\n        drawChar16(uvec4(0x63726963U,0x2073656cU,0x20202020U,0x20202020U));\n\n    } else if (demo == DEMO_POINT_DIR) {\n        \n        vec2 p = LOAD(EX10_P).xy;\n        vec2 q = LOAD(EX10_Q).xy;\n        \n        vec2 diff = p-q;\n        \n        vec3 g = geodesicFromPointDir(p, diff);\n        \n        // below here for visualization\n\n        vec2 ldir = perp(diff);\n        vec3 ltangent = vec3(ldir, -dot(ldir, p));\n\n        drawLine2D(ltangent, uv);\n        ink(LIGHTGRAY);\n\n        if (!alongDiameter(p, diff)) {\n\n            vec3 ppolar = polarFromPoint(p);\n            vec3 ltopolar = vec3(diff, -dot(diff, p));\n            \n            vec3 pinter = cross(ltopolar, ppolar);\n            pinter.xy /= pinter.z;\n\n            drawPerp(p, pinter.xy-p, uv);\n            drawSeg2D(p, pinter.xy, uv);\n            ink(LIGHTGRAY);\n\n            drawLine2D(ppolar, uv);\n            ink(RED);\n            \n            drawPoint(pinter.xy, uv);\n\n        }\n        \n        drawGeodesic(g, uv);\n        \n        drawLine(unitCircle, uv);\n        ink(BLACK);\n        \n        drawPoint(p, uv);\n        ink(RED);\n        \n        drawPoint(q, uv);\n        ink(BLUE);\n\n        drawChar16(uvec4(0x342e3343U,0x6547203aU,0x7365646fU,0x66206369U));\n        drawChar16(uvec4(0x206d6f72U,0x6e696f70U,0x20262074U,0x2e726964U));\n        \n    } else if (demo == DEMO_INTERSECTION_TEST) {\n        \n        vec2 p = LOAD(EX11_P).xy;\n        vec2 q = LOAD(EX11_Q).xy;\n        vec2 a = LOAD(EX11_A).xy;\n        vec2 b = LOAD(EX11_B).xy;\n        \n        vec3 g1 = geodesicFromPoints(p,q);\n        vec3 g2 = geodesicFromPoints(a,b);\n        \n        vec3 x = intersectGG(g1, g2);\n        \n        drawGeodesic(g1, uv);\n        drawGeodesic(g2, uv);\n        ink(GRAY);\n        \n        drawChar16(uvec4(0x75626f52U,0x69207473U,0x7265746eU,0x74636573U));\n        drawChar16(uvec4(0x206e6f69U,0x74736574U,0x20202020U,0x20202020U));\n\n        textPos = fragCoord - vec2(textSize, iResolution.y-2.5*textSize);\n        \n        if (x.z != 0.) {\n            drawPoint(x.xy, uv);\n            drawChar16(uvec4(0x65746e49U,0x63657372U,0x79203a74U,0x20207365U));\n        } else {\n            drawChar16(uvec4(0x65746e49U,0x63657372U,0x6e203a74U,0x2020206fU));\n        }\n\n        drawLine(unitCircle, uv);\n        ink(BLACK);\n        \n        drawPoint(p, uv);\n        ink(RED);\n        drawPoint(q, uv);\n        ink(BLUE);\n        drawPoint(a, uv);\n        ink(GREEN);\n        drawPoint(b, uv);\n        ink(PURPLE);\n\n    }\n    \n    colorOut *= smoothstep(-0.5, 0.5, textDist);\n    textDist = 1e5;\n\n    uint numCases = uint(getNumCases(demo));\n    \n    if (numCases > 1U) {\n        \n        ivec2 DEMO_CASE = ivec2(int(demo)+1, 0);\n        vec2 dcm = LOAD(DEMO_CASE).xy;\n        \n        uint demoCase = uint(dcm.x);\n\n        uvec4 caseString;\n        \n        if (dcm.y == 0.) {\n            caseString = uvec4(0x65736143U,0x302f3020U,0x20202020U,0x20202020U);\n        } else {\n            caseString = uvec4(0x65736143U,0x302f3020U,0x6f6d5b20U,0x5d646576U);\n        }\n\n        caseString.y |= ((demoCase + 1U) << 8U) | ((numCases) << 24U);\n\n        textPos = fragCoord - vec2(textSize);\n        drawChar16(caseString);\n        \n        vec3 tcolor = dcm.y == 0. ? BLACK : GRAY;\n        \n        colorOut = mix(tcolor, colorOut, smoothstep(-0.5, 0.5, textDist));\n        \n    }\n\n    fragColor = vec4(colorOut, 1);\n\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 data;\nivec2 fc;\nfloat demoCaseIsModified;\n\nbool mouseIsDown;\nvec2 mxy, mzw;\n\n#define STORE(oc, value) if(fc == (oc)) { data = (value); }\n\nvoid mouse(ivec2 var, int clamp) {\n    \n    vec4 mstate = LOAD(MSTATE);\n    \n    if (mstate.xy == vec2(0) && iMouse.xy == iMouse.zw) {\n        \n        vec2 p = LOAD(var).xy;\n        vec2 offset = p - mxy;\n        \n        if (length(offset) < pointSize + 16.0*scl) {\n            STORE(MSTATE, vec4(vec2(var), offset));\n        }\n        \n    } else if (mstate.xy == vec2(var)) {\n        \n        if (mouseIsDown) {\n            vec2 pos = mxy + mstate.zw;\n            if (clamp == 1) { \n                pos = clampCircle(pos); \n            } else if (clamp != 0) {\n                pos = blockCircle(pos);\n            }\n            demoCaseIsModified = 1.;\n            STORE(var, vec4(pos, 0, 0));\n        } else {\n            STORE(MSTATE, vec4(0));\n        } \n        \n    }\n\n}\n\nvec2 cartFromPolar(float r, float theta) {\n    theta *= 3.14159265359/180.;\n    return r*vec2(cos(theta), sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    fc = ivec2(fragCoord);\n    \n    data = texelFetch(iChannel0, fc, 0);\n    \n    float demo = LOAD(DEMO).x;\n    \n    bool firstFrame = (iFrame == 0);\n    bool rHit = (texelFetch(iChannel1, ivec2(82, 1), 0).x > 0.);\n    bool cHit = (texelFetch(iChannel1, ivec2(67, 1), 0).x > 0.);\n\n    if (fc == DEMO) {\n                    \n        float prev_demo = demo;\n        demo += texelFetch(iChannel1, ivec2(32, 1), 0).x;\n        demo += texelFetch(iChannel1, ivec2(39, 1), 0).x;\n        demo += NUM_DEMOS - texelFetch(iChannel1, ivec2(37, 1), 0).x;\n        demo = mod(demo, NUM_DEMOS);\n                   \n        STORE(DEMO, vec4(demo, 0, 0, 0));\n\n    }\n    \n    ivec2 DEMO_CASE = ivec2(int(demo)+1, 0);\n    \n    vec2 pd = LOAD(DEMO_CASE).xy;\n    \n    float demoCase = pd.x;\n    demoCaseIsModified = pd.y;\n    \n    float numCases = getNumCases(demo);\n        \n    if (cHit) {\n        demoCase = mod(demoCase + 1., numCases);\n    }\n               \n    if (firstFrame || rHit || (cHit && numCases > 1.)) {\n        \n        demoCaseIsModified = 0.;\n        \n        if (firstFrame || demo == DEMO_CIRCLE_FROM_POINTS) {\n            STORE(EX1_P, vec4(cartFromPolar(1., -180.), 0, 0));\n            STORE(EX1_Q, vec4(cartFromPolar(1., -88.), 0, 0));\n            STORE(EX1_R, vec4(cartFromPolar(1., 40.), 0, 0));\n        }\n\n        if (firstFrame || demo == DEMO_INVERT_THRU_CIRCLE) {\n            STORE(EX2_P, vec4(0.5, 0.2, 0, 0));\n        }\n        \n        if (firstFrame || demo == DEMO_ORTHO_CIRCLE_FROM_POINT) {\n            STORE(EX3_P, vec4(1.3, 0.6, 0, 0));\n        }\n        \n        if (firstFrame || demo == DEMO_POLES_AND_POLARS) {\n            STORE(EX4_P, vec4(0.5, -0.3, 0, 0));\n            STORE(EX4_Q, vec4(-1.1, -0.95, 0, 0));\n        }\n        \n        if (firstFrame || demo == DEMO_GEODESIC_FROM_POINTS) {\n            if (demoCase == 0.) {\n                STORE(EX5_P, vec4(cartFromPolar(0.60, -80.), 0, 0));\n                STORE(EX5_Q, vec4(cartFromPolar(0.55, -10.), 0, 0));\n            } else {\n                STORE(EX5_P, vec4(cartFromPolar(0.60, -80.), 0, 0));\n                STORE(EX5_Q, vec4(cartFromPolar(-0.75, -80.), 0, 0));\n            }\n        }\n        \n        if (firstFrame || demo == DEMO_HYPERBOLIC_CIRCLE) {\n            \n            if (demoCase == 0.) {\n                STORE(EX6_P, vec4(cartFromPolar(0.65, 150.), 0, 0));\n                STORE(EX6_Q, vec4(cartFromPolar(0.45, 195.), 0, 0));\n            } else if (demoCase == 1.) {\n                STORE(EX6_P, vec4(cartFromPolar(0.65, 150.), 0, 0));\n                STORE(EX6_Q, vec4(cartFromPolar(0.15, 150.), 0, 0));\n            } else if (demoCase == 2.) {\n                STORE(EX6_P, vec4(0, 0, 0, 0));\n                STORE(EX6_Q, vec4(cartFromPolar(0.15, 150.), 0, 0));\n            }\n                \n        }\n        \n        if (firstFrame || demo == DEMO_PERP_BISECTOR) {\n            if (demoCase == 0.) {\n                STORE(EX7_Q, vec4(cartFromPolar(0.50, 35.), 0, 0));\n                STORE(EX7_P, vec4(cartFromPolar(0.75, -20.), 0, 0));\n            } else if (demoCase == 1.) {\n                STORE(EX7_Q, vec4(cartFromPolar(0.5, 35.), 0, 0));\n                STORE(EX7_P, vec4(cartFromPolar(0.5, -20.), 0, 0));\n            } else if (demoCase == 2.) {\n                STORE(EX7_Q, vec4(cartFromPolar(0.5, 35.), 0, 0));\n                STORE(EX7_P, vec4(0, 0, 0, 0));\n            }\n        }\n        \n        if (firstFrame || demo == DEMO_TRI_TRANSLATE) {\n            STORE(EX8_A, vec4(0.1, 0.1, 0, 0));\n            STORE(EX8_B, vec4(0.3, 0.1, 0, 0));\n            STORE(EX8_C, vec4(0.1, 0.4, 0, 0));\n            STORE(EX8_P, vec4(cartFromPolar(0.142, -135.), 0, 0));\n            STORE(EX8_Q, vec4(-0.6, 0.3, 0, 0));\n        }\n        \n        if (firstFrame || demo == DEMO_CONGRUENT_CIRCLES) {\n            STORE(EX9_A, vec4(-0.5, 0.5, 0, 0));\n            STORE(EX9_B, vec4(0.5, 0.4, 0, 0));\n            STORE(EX9_C, vec4(0.4, 0.6, 0, 0));\n        }\n        \n        if (firstFrame || demo == DEMO_POINT_DIR) {\n            \n            if (demoCase == 0.) {\n                STORE(EX10_P, vec4(0.5, -0.1, 0, 0));\n                STORE(EX10_Q, vec4(1.2, 1.0, 0, 0));\n            } else {\n                STORE(EX10_P, vec4(0.3, 0.25, 0, 0));\n                STORE(EX10_Q, vec4(1.2, 1.0, 0, 0));                      \n            }\n        }\n        \n        if (firstFrame || demo == DEMO_INTERSECTION_TEST) {\n            \n            if (demoCase == 0.) {\n                \n                STORE(EX11_P, vec4(-0.5, 0.3, 0, 0));\n                STORE(EX11_Q, vec4(0.7, 0.35, 0 ,0));\n                STORE(EX11_A, vec4(-0.2, -0.8, 0, 0));\n                STORE(EX11_B, vec4(-0.1, -0.1, 0, 0));\n                \n            } else if (demoCase == 1.) {\n                \n                STORE(EX11_P, vec4(-0.5, 0.3, 0, 0));\n                STORE(EX11_Q, vec4(0.7, 0.35, 0 ,0));\n                STORE(EX11_A, vec4(-0.2, -0.8, 0, 0));\n                STORE(EX11_B, vec4(-0.4, -0.1, 0, 0));\n                \n            } else if (demoCase == 2.) {\n                \n                STORE(EX11_P, vec4(-0.5, 0.3, 0, 0));\n                STORE(EX11_Q, vec4(0.7, 0.35, 0 ,0));\n                STORE(EX11_A, vec4(-0.2, -0.8, 0, 0));\n                STORE(EX11_B, vec4(-0.1, -0.4, 0, 0));\n\n            } else if (demoCase == 3.) {\n                \n                STORE(EX11_P, vec4(-0.5, 0.3, 0, 0));\n                STORE(EX11_Q, vec4(0.0, 0.6, 0 ,0));\n                STORE(EX11_A, vec4(-0.2, -0.8, 0, 0));\n                STORE(EX11_B, vec4(-0.1, -0.4, 0, 0));\n\n            } else {\n\n                STORE(EX11_P, vec4(-0.5, 0.3, 0, 0));\n                STORE(EX11_Q, vec4(-0.25, 0.15, 0 ,0));\n                STORE(EX11_A, vec4(-0.2, -0.8, 0, 0));\n                STORE(EX11_B, vec4(-0.1, -0.4, 0, 0));\n\n            }\n            \n        }\n        \n    } \n        \n    setupScene(iResolution.xy, demo);\n    \n    mouseIsDown = min(iMouse.z, iMouse.w) > 0.;\n    \n    mxy = sceneFromFrag(iMouse.xy);\n    mzw = sceneFromFrag(iMouse.zw);\n\n    if (demo == 0.) {\n        mouse(EX1_P, 0);\n        mouse(EX1_Q, 0);\n        mouse(EX1_R, 0);\n    } else if (demo == 1.) {\n        mouse(EX2_P, 1);\n    } else if (demo == 2.) {\n        mouse(EX3_P, 2);\n    } else if (demo == 3.) {\n        mouse(EX4_P, 1);\n        mouse(EX4_Q, 2);\n    } else if (demo == 4.) {\n        mouse(EX5_P, 1);\n        mouse(EX5_Q, 1);\n    } else if (demo == 5.) {\n        mouse(EX6_P, 1);\n        mouse(EX6_Q, 1);\n    } else if (demo == 6.) {\n        mouse(EX7_P, 1);\n        mouse(EX7_Q, 1);\n    } else if (demo == 7.) {\n        mouse(EX8_A, 1);\n        mouse(EX8_B, 1);\n        mouse(EX8_C, 1);\n        mouse(EX8_P, 1);\n        mouse(EX8_Q, 1);\n    } else if (demo == 8.) {\n        mouse(EX9_A, 1);\n        mouse(EX9_B, 1);\n        mouse(EX9_C, 1);\n    } else if (demo == 9.) {\n        mouse(EX10_P, 1);\n        mouse(EX10_Q, 0);\n    } else if (demo == 10.) {\n        mouse(EX11_P, 1);\n        mouse(EX11_Q, 1);\n        mouse(EX11_A, 1);\n        mouse(EX11_B, 1);\n    }\n    \n    STORE(DEMO_CASE, vec4(demoCase, demoCaseIsModified, 0, 0));    \n\n    fragColor = data;\n                \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DEMO ivec2(0, 0)\n#define MSTATE ivec2(0, 1)\n\n#define EX1_P ivec2(1,1)\n#define EX1_Q ivec2(1,2)\n#define EX1_R ivec2(1,3)\n\n#define EX2_P ivec2(2,1)\n\n#define EX3_P ivec2(3,1)\n\n#define EX4_P ivec2(4,1)\n#define EX4_Q ivec2(4,2)\n\n#define EX5_P ivec2(5,1)\n#define EX5_Q ivec2(5,2)\n\n#define EX6_P ivec2(6,1)\n#define EX6_Q ivec2(6,2)\n\n#define EX7_P ivec2(7,1)\n#define EX7_Q ivec2(7,2)\n\n#define EX8_A ivec2(8,1)\n#define EX8_B ivec2(8,2)\n#define EX8_C ivec2(8,3)\n#define EX8_P ivec2(8,4)\n#define EX8_Q ivec2(8,5)\n\n#define EX9_A ivec2(9,1)\n#define EX9_B ivec2(9,2)\n#define EX9_C ivec2(9,3)\n\n#define EX10_P ivec2(10,1)\n#define EX10_Q ivec2(10,2)\n\n#define EX11_P ivec2(11,1)\n#define EX11_Q ivec2(11,2)\n#define EX11_A ivec2(11,3)\n#define EX11_B ivec2(11,4)\n\n#define RED vec3(0.8, 0, 0)\n#define GREEN vec3(0, 0.6, 0)\n#define BLUE vec3(0, 0, 0.8)\n#define CYAN vec3(0, 0.6, 0.8)\n#define PURPLE vec3(0.8, 0, 0.8)\n\n#define BLACK vec3(0)\n#define GRAY vec3(.5)\n#define LIGHTGRAY vec3(.8)\n#define WHITE vec3(1)\n\n#define LOAD(var) texelFetch(iChannel0, var, 0)\n\n\n#define DEMO_CIRCLE_FROM_POINTS 0.\n#define DEMO_INVERT_THRU_CIRCLE 1.\n#define DEMO_ORTHO_CIRCLE_FROM_POINT 2.\n#define DEMO_POLES_AND_POLARS 3.\n#define DEMO_GEODESIC_FROM_POINTS 4.\n#define DEMO_HYPERBOLIC_CIRCLE 5.\n#define DEMO_PERP_BISECTOR 6.\n#define DEMO_TRI_TRANSLATE 7.\n#define DEMO_CONGRUENT_CIRCLES 8.\n#define DEMO_POINT_DIR 9.\n#define DEMO_INTERSECTION_TEST 10.\n\n#define NUM_DEMOS 11.\n\nconst float TOL = 1e-6;\nconst float TOL_SQR = TOL*TOL;\n\nfloat scl;\nfloat perpSize;\n\nvec2 theResolution;\n\nfloat textSize;\nfloat pointSize;\n\nfloat getNumCases(float demo) {\n    \n    if (demo == DEMO_GEODESIC_FROM_POINTS) {\n        return 2.;\n    } else if (demo == DEMO_HYPERBOLIC_CIRCLE) {\n        return 3.;\n    } else if (demo == DEMO_PERP_BISECTOR) {\n        return 3.;\n    } else if (demo == DEMO_POINT_DIR) {\n        return 2.;\n    } else if (demo == DEMO_INTERSECTION_TEST) {\n        return 5.;\n    }\n    \n    return 1.;\n    \n}\n\n\nvoid setupScene(vec2 res, float demo) {\n    \n    float diam = demo < 7. ? 2.5 : 2.0;\n    \n    theResolution = res;\n    \n    textSize = max(10., 0.03*res.y);\n\n    scl = diam / (res.y - 4. * textSize);\n    pointSize = textSize * 0.35 * scl;\n    perpSize = textSize * scl;\n    \n}\n\nvec2 sceneFromFrag(vec2 frag) {\n    return (frag.xy + 0.5 - 0.5*theResolution.xy) * scl;\n}\n\nvec2 clampCircle(vec2 p) {\n    float l = length(p);\n    return l < 0.999 ? p : 0.999 * p / l;\n}\n\nvec2 blockCircle(vec2 p) {\n    float l = length(p);\n    return l > 1.001 ?  p : 1.001 * p / l;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}