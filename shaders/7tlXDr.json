{
    "Shader": {
        "info": {
            "date": "1631982567",
            "description": "I made this shader to make it easier to visualize Bezier curves in 3D and linear time algorithm.\nYou can find more shaders to learn about Bezier curves\non my playlist: https://www.shadertoy.com/pl\nMore info in comment below (sorry, characters limit).",
            "flags": 48,
            "hasliked": 0,
            "id": "7tlXDr",
            "likes": 3,
            "name": "3D Bezier: linear-time algorithm",
            "published": 3,
            "tags": [
                "3d",
                "bezier",
                "camera",
                "curve",
                "learning"
            ],
            "usePreview": 0,
            "username": "maras",
            "viewed": 350
        },
        "renderpass": [
            {
                "code": "/* \n Hi. I made this shader to make it easier to visualize Bezier curves in 3D and de Casteljau's algorithm.\n You can find more shaders to learn about Bezier curves\n on my playlist: https://www.shadertoy.com/playlist/X3XfWf (still WiP)\n Enjoy <3\n*/\n\n#define BEZIER_CURVE_POINTS 3 // int, minimum = 2, maximum = 13\n// After changing BEZIER_CURVE_POINTS peremeter you need to reset shader's time (button on the bottom of shader window)\n// PS: higher values can be imposible to compile if your GPU is weak. Sorry\n\n#define BACKWARDS_ANIMATION true // bool\n\n#define SLOW_DOWN 2.0 // float, need to be typed with decimal point (.)\n\n// sorry for naming the parameter \"SLOW_DOWN\" instead of \"SPEED\", but default speed is really fast\n// and it's easier for you to slow down things by an integer instead of speeding up by for example 0.25.\n// If you want to speed up the animation you can use a float lower than 1.0\n\n// Information on the parameters below is provided in the comment\n\n#define SHOW_RED_DOTS true // bool\n#define SHOW_BLUE_DOT true // bool\n#define SHOW_FINAL_DOT true // bool\n\n#define SHOW_BLACK_LINE true // bool\n#define SHOW_GREY_LINES true // bool\n\n#define ALWAYS_SHOW_BEZIER_CURVE false // bool\n\n#define DRAWING_STEPS 50 // int, more than 1000 can really slow down your computer, be careful\n\n#define SHOW_1_SUPPORT_POINT true // bool\n#define SHOW_2_SUPPORT_POINT true // bool\n#define SHOW_3_SUPPORT_POINT true // bool\n#define SHOW_4_SUPPORT_POINT true // bool\n#define SHOW_5_SUPPORT_POINT true // bool\n#define SHOW_6_SUPPORT_POINT true // bool\n#define SHOW_7_SUPPORT_POINT true // bool\n#define SHOW_8_SUPPORT_POINT true // bool\n#define SHOW_9_SUPPORT_POINT true // bool\n#define SHOW_10_SUPPORT_POINT true // bool\n#define SHOW_11_SUPPORT_POINT true // bool\n\n#define SHOW_1_SUPPORT_LINE true // bool\n#define SHOW_2_SUPPORT_LINE true // bool\n#define SHOW_3_SUPPORT_LINE true // bool\n#define SHOW_4_SUPPORT_LINE true // bool\n#define SHOW_5_SUPPORT_LINE true // bool\n#define SHOW_6_SUPPORT_LINE true // bool\n#define SHOW_7_SUPPORT_LINE true // bool\n#define SHOW_8_SUPPORT_LINE true // bool\n#define SHOW_9_SUPPORT_LINE true // bool\n#define SHOW_10_SUPPORT_LINE true // bool\n#define SHOW_11_SUPPORT_LINE true // bool\n\n// non-changeable parameters (don't get me wrong, feel free to experiment with the entire code,\n// but you can screw something up :D )\n\n#define EDGE   0.05   // anti-aliasing\n#define EDGE_LINE 0.0003\n#define SMOOTH_LINE 0.01\n#define SMOOTH 0.001  // anti-aliasing \n\nconst int max_count = BEZIER_CURVE_POINTS;\n\nconst vec3 support_lines_colors[11] = vec3[](\n                                      vec3(1.0, 0.839, 0.458),\n                                      vec3(1.0, 0.674, 0.478),\n                                      vec3(1.0, 0.658, 0.560),\n                                      vec3(1.0, 0.541, 0.788),\n                                      vec3(0.992, 0.380, 1.0),\n                                      vec3(0.788, 0.458, 1.0),\n                                      vec3(0.635, 0.541, 1.0),\n                                      vec3(0.380, 0.788, 1.0),\n                                      vec3(0.321, 1.0, 0.803),\n                                      vec3(0.807, 0.705, 0.592),\n                                      vec3(0.509, 0.482, 0.678));\n     \nconst vec3 support_points_colors[11]= vec3[](\n                                      vec3(0.992, 0.792, 0.325),\n                                      vec3(1.0, 0.639, 0.341),\n                                      vec3(1.0, 0.454, 0.301),\n                                      vec3(1.0, 0.039, 0.560),\n                                      vec3(0.807, 0.0, 0.819),\n                                      vec3(0.560, 0.0, 0.921),\n                                      vec3(0.333, 0.160, 1.0),\n                                      vec3(0.019, 0.662, 1.0),\n                                      vec3(0.0, 0.980, 0.694),\n                                      vec3(0.549, 0.443, 0.329),\n                                      vec3(0.270, 0.250, 0.392));                                       \n                                      \nconst vec3 final_dot_color = vec3(0.0,1.0,0.0);\n\nconst bool show_support_points[11] = bool[](\n                                     SHOW_1_SUPPORT_POINT,\n                                     SHOW_2_SUPPORT_POINT,\n                                     SHOW_3_SUPPORT_POINT,\n                                     SHOW_4_SUPPORT_POINT,\n                                     SHOW_5_SUPPORT_POINT,\n                                     SHOW_6_SUPPORT_POINT,\n                                     SHOW_7_SUPPORT_POINT,\n                                     SHOW_8_SUPPORT_POINT,\n                                     SHOW_9_SUPPORT_POINT,\n                                     SHOW_10_SUPPORT_POINT,\n                                     SHOW_11_SUPPORT_POINT);\n                                     \nconst bool show_support_lines[11] = bool[](\n                                    SHOW_1_SUPPORT_LINE,\n                                    SHOW_2_SUPPORT_LINE,\n                                    SHOW_3_SUPPORT_LINE,\n                                    SHOW_4_SUPPORT_LINE,\n                                    SHOW_5_SUPPORT_LINE,\n                                    SHOW_6_SUPPORT_LINE,\n                                    SHOW_7_SUPPORT_LINE,\n                                    SHOW_8_SUPPORT_LINE,\n                                    SHOW_9_SUPPORT_LINE,\n                                    SHOW_10_SUPPORT_LINE,\n                                    SHOW_11_SUPPORT_LINE);\n\nconst float coPlanerThreshold = 0.7; // Some threshold value that is application dependent\nconst float lengthErrorThreshold = 0.1;\n\nvec3 control_points[13] = vec3[](\n                        vec3(-0.5, -0.5, 0.0),\n                        vec3(0.0, 2.0, 0.5),\n                        vec3(0.0, -1.0, 1.5),\n                        vec3(0.4, 1.6, 1.3),\n                        vec3(-1.4, 0.6, 0.3),\n                        vec3(0.4, -1.0, 2.8),\n                        vec3(-0.8, 1.0, 0.8),\n                        vec3(1.2, -0.2, 0.4),\n                        vec3(0.0, 0.0, -1.0),\n                        vec3(3.0, -1.0, 0.7),\n                        vec3(5.4, -4.0, 1.8),\n                        vec3(0.4, 4.0, 3.2),\n                        vec3(0.0, 0.0, 2.0)\n                        );\n\n// link to video explaining below function:\n// https://www.youtube.com/watch?v=ELQG5OvmAE8&ab_channel=EgoMoose\nfloat RaySegmentDistance(vec3 start, vec3 end, vec3 ray_origin, vec3 ray_screen_intersection) { \n\tvec3 q = start - ray_origin;\n    vec3 r = end - start;\n    vec3 s = ray_screen_intersection - ray_origin;\n    \n    float t = (dot(q, s) * dot(r, s)) - (dot(q, r) * dot(s, s));\n    t = t / ((dot(r, r) * dot(s, s)) - (dot(r, s) * dot(s, r)));\n    \n    float u = dot(q, s) + (t * dot(r, s)); \n    u = u / dot(s, s);\n    \n    if (t > 1.0 || t < 0.0 || u < 0.0) { return 100.0; }\n    \n    vec3 P0 = start + t * r;\n    vec3 P1 = ray_origin + u * s;\n    \n    return distance(P0, P1);\n}\n\nfloat DistLine(vec3 ray_origin, vec3 ray_direction, vec3 point) {\n    return length(cross(point - ray_origin, ray_direction)) / length(ray_direction);\n}\n\nfloat DrawPoint(vec3 ray_origin, vec3 ray_direction, vec3 point) {\n    float dist = DistLine(ray_origin, ray_direction, point);\n    //dist = 1.0 - smoothstep(0.01, 0.09, dist);\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    \n    vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n    vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 )*6.28318530718;\n\n    float zoom = 1.0;\n    zoom = textureLod( iChannel2, vec2(1.5,.5)/iResolution.xy, 0.0 ).x;\n    vec3 ray_origin = vec3(0.0,  0.0, -3.0);     // camera point\n    \n    //ray_origin = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)/iResolution.x, 1.0 ) );\n    \n    ray_origin.zy = ray_origin.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray_origin.yz;\n    ray_origin.xz = ray_origin.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray_origin.zx;\n    \n    vec3 lookat = vec3(0.5); // center of scene\n    vec3 forward_vector = normalize(lookat - ray_origin);\n    vec3 right_vector = cross(vec3(0.0, 1.0, 0.0), forward_vector);\n    vec3 up_vector = cross(forward_vector, right_vector);\n\n    vec3 screen_center = ray_origin + forward_vector * zoom;\n\n    vec3 ray_screen_intersection = screen_center + uv.x * right_vector + uv.y * up_vector;\n    vec3 ray_direction = ray_screen_intersection - ray_origin; // point at screen\n    \n    float t = fract(iTime / SLOW_DOWN);\n\n    if (int(iTime / SLOW_DOWN) % 2 == 1 && BACKWARDS_ANIMATION) {\n        t = 1.0 - t;\n    }\n    \n    control_points[max_count - 1] = control_points[control_points.length() - 1];\n    \n    vec3 final_point = vec3(0.0);\n        \n    float t2 = (1.0 - t);\n                \n    float draw_start_point = DrawPoint(ray_origin, ray_direction, control_points[0]);\n    float draw_end_point = DrawPoint(ray_origin, ray_direction, control_points[max_count - 1]);\n    \n    vec3 col = vec3(1.0);\n    \n    // draw start point\n    if (draw_start_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_start_point = (EDGE - draw_start_point + EDGE / 2.0) / EDGE;\n        col *= vec3(1.0,0.0,0.0) * draw_start_point;\n    }\n    \n    // draw end point\n    if (draw_end_point < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        draw_end_point = (EDGE - draw_end_point + EDGE / 2.0) / EDGE;\n        col *= vec3(1.0,0.0,0.0) * draw_end_point;\n    }\n\n    // draw bezier curve using linear-time algorithm\n    if (SHOW_BLACK_LINE) {\n        float end_algorithm = t;\n        float drawing_steps = float(DRAWING_STEPS);\n\n        if(ALWAYS_SHOW_BEZIER_CURVE) { end_algorithm = 1.0; }\n        else { drawing_steps *= t; } // without this big DRAWING_STEPS and small t couses visual glitch (i don't know why :D)\n\n        float increaser = end_algorithm / drawing_steps;\n\n        end_algorithm += 0.001; // without it some small values of CASTELJAUS_STEPS couses ending curve before endpoint\n                                // (i don't know why)\n                                \n        vec3 prev_point = control_points[0];\n        \n        for (float i = 0.0; i <= end_algorithm; i += increaser) {\n            float i2 = 1.0 - i;\n            \n            float h = 1.0;\n            float u = (1.0 - i);\n            int n = max_count - 1;\n            int n1 = n + 1;\n            vec3 Q = control_points[0];\n            \n            if (i != 0.0) {\n                if (i <= 0.5) {\n                    u = i / u;\n                    for (int k = 1; k <= n; ++k) {\n                        float prev_h = h;\n                        h = h * u * (float(n1) - float(k));\n                        h = h / (float(k) + h);\n                        float h1 = (h / prev_h) * ((float(k) * (1.0 - i)) / (i * float(n - k + 1)));\n                        Q = h1 * Q + h * control_points[k];\n                    }\n                }\n                else {\n                    u = u / i;\n                    for (int k = 1; k <= n; ++k) {\n                        float prev_h = h;\n                        h = h * (float(n1) - float(k));\n                        h = h / (float(k) * u + h);\n                        float h1 = (h / prev_h) * ((float(k) * (1.0 - i)) / (i * float(n - k + 1)));\n                        Q = h1 * Q + h * control_points[k];\n                    }\n                }\n            }\n            \n            vec3 point = Q;\n            \n            float dist = RaySegmentDistance(prev_point, point, ray_origin, ray_screen_intersection);\n            \n            if (dist < EDGE_LINE + SMOOTH_LINE)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= dist;\n            }\n            \n            prev_point = point;\n        }\n    }\n        \n    // draw control points\n    for (int i = 1; i < max_count - 1; ++i) {\n        float dist = DrawPoint(ray_origin, ray_direction, control_points[i]);\n        \n        if (dist < EDGE + SMOOTH && show_support_points[i])\n        {\n            dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n            col *= vec3(0.0,0.0, float(max_count - i) / float(max_count) + 0.1) * dist;\n        }\n    }\n\n    // draw lines between control points\n    if (SHOW_GREY_LINES) {\n        for (int i = 0; i < max_count - 1; ++i) {\n            float dist = RaySegmentDistance(control_points[i], control_points[i + 1], ray_origin, ray_screen_intersection);\n\n            if (dist < EDGE_LINE + SMOOTH_LINE)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                col *= mix(vec3(0.8),vec3(1.0,1.0,1.0),dist);\n            }\n        }\n    }\n\n    // draw support lines and points\n    float h = 1.0;\n    float u = (1.0 - t);\n    int n = max_count - 1;\n    int n1 = n + 1;\n    vec3 Q = control_points[0];\n    vec3 prev_Q = Q;\n\n    if (t != 0.0) {\n        if (t <= 0.5) {\n            u = t / u;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * u * (float(n1) - float(k));\n                h = h / (float(k) + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n                \n                float dist = RaySegmentDistance(prev_Q, control_points[k], ray_origin, ray_screen_intersection) * 2.0;\n                if (dist < EDGE_LINE + SMOOTH_LINE && show_support_lines[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                    col *= mix(support_lines_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n\n                dist = DrawPoint(ray_origin, ray_direction, Q);\n                if (dist < EDGE + SMOOTH && show_support_points[k-1] && k < n)\n                {\n                    dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n                    col *= support_points_colors[k-1] * dist;\n                }\n                \n                prev_Q = Q;\n            }\n        }\n        else {\n            u = u / t;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * (float(n1) - float(k));\n                h = h / (float(k) * u + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n                \n                float dist =  RaySegmentDistance(prev_Q, control_points[k], ray_origin, ray_screen_intersection) * 2.0;\n                if (dist < EDGE_LINE + SMOOTH_LINE && show_support_lines[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE_LINE,EDGE_LINE + SMOOTH_LINE, dist);\n                    col *= mix(support_lines_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n\n                dist = DrawPoint(ray_origin, ray_direction, Q);\n                if (dist < EDGE + SMOOTH && show_support_points[k-1] && k < n)\n                {\n                    dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n                    col *= support_points_colors[k-1] * dist;\n                }\n                \n                prev_Q = Q;\n            }\n        }     \n    }\n    \n    // draw final point \n    h = 1.0;\n    u = (1.0 - t);\n    n = max_count - 1;\n    n1 = n + 1;\n    Q = control_points[0];\n\n    if (t != 0.0) {\n        if (t <= 0.5) {\n            u = t / u;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * u * (float(n1) - float(k));\n                h = h / (float(k) + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n            }\n        }\n        else {\n            u = u / t;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * (float(n1) - float(k));\n                h = h / (float(k) * u + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n            }\n        }\n    }\n\n    vec3 point = Q;\n    \n    float dist = DrawPoint(ray_origin, ray_direction, point);\n    if (dist < EDGE + SMOOTH && SHOW_FINAL_DOT)\n    {\n        dist = (EDGE - dist + EDGE / 2.0) / EDGE;\n        col *= final_dot_color * dist;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// camera \"drag and rotate\" system\n// taken almost directly from https://www.shadertoy.com/view/ldyGzW\n\nconst float accel = .01;\nconst float decay = .95; // how much velocity is preserved per frame (proportionally)\n\nconst float yMul = -1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = textureLod( iChannel0, vec2(.5,.5)/iResolution.xy, 0.0 );\n            vec4 camVel = textureLod( iChannel0, vec2(3.5,.5)/iResolution.xy, 0.0 );\n            \n            fragColor = camPos + camVel;\n\n            if ( camPos.y < .0 ) { fragColor.y = .0; }\n\n            \n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = textureLod( iChannel0, vec2(2.5,.5)/iResolution.xy, 0.0 );\n            vec4 camRot = textureLod( iChannel0, vec2(1.5,.5)/iResolution.xy, 0.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// zooming system\n// taken almost directly from https://www.shadertoy.com/view/4sVSDm\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.0;\n    \n    if(iFrame>0) {\n        //read previous state\n        vec4 zoom_vec = textureLod( iChannel2, vec2(1.5,.5)/iResolution.xy, 0.0 );\n        zoom = zoom_vec.x;\n    }\n    \n    //read arrow button press and update state via changing the texture \n    if( texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x>0.1 ) { zoom *= 1.2; }\n    if( texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x>0.1 ) { zoom /= 1.2; }\n\n    fragColor = vec4(zoom);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}