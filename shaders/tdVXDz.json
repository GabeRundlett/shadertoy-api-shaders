{
    "Shader": {
        "info": {
            "date": "1573830723",
            "description": "A tiny template.\nMicro-engine for sphere-tracing, to easy visualize or work on SDF.\nI try to keep it simple.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tdVXDz",
            "likes": 6,
            "name": "A tiny template",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "template",
                "engine"
            ],
            "usePreview": 0,
            "username": "lsdlive",
            "viewed": 512
        },
        "renderpass": [
            {
                "code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nA tiny template.\nMicro-engine for sphere-tracing, to easy visualize or work on SDF.\nI try to keep it simple.\n\nIf you use this template and add features to it, please share in the comments :)\n\nSome notation:\np: position (usually in world space)\nn: normal\nrd: ray direction (eye or view vector)\nld: light direction\n\n*/\n\n\n#define PI 3.14159\n#define TAU 6.28318\n\n\nconst float gamma = 2.2;\n\n\n/** Libs **/\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n\treturn a + b * cos(TAU * (c * t + d));\n}\n\nfloat checker( vec2 p ) {\n    p = mod(floor(p), 2.);\n    return mod(p.x + p.y, 2.) < 1. ? .25 : .1;\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nfloat sphere(vec3 p, float d) {\n\treturn length(p) - d;\n}\n\nfloat octahedron(vec3 p, float d) {\n\treturn dot(p, normalize(sign(p))) - d;\n}\n\nvec2 line(vec3 pos, vec3 a, vec3 b ) {\n    vec3 pa = pos - a, ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n    return vec2(length(pa - h * ba), h);\n}\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// PARAMS: You can change the viewport here:\nfloat bg_factor = .1;// darker to lighter\nfloat bg_scale = 15.;// background\nvec3 target = vec3(0); // camera target\nconst float dist_to = 5.;// distance to the sdf's center\nconst float ypos = 1.;// y position of the camera\nconst float fudge = 1.;\nconst int mode_cam = 4;//0: rotate, 1:face, 2: side, 3: top, 4: multiview\n\nfloat de(vec3 p) {\n    return box(p, vec3(1));\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 normal(vec3 pos) {\n\tvec3 eps = vec3(.0001, 0, 0);\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += de(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x*left + up * uv.y);\n}\n\nvec3 shading(vec3 p, vec3 rd, vec3 n) {\n    //vec3 ld = normalize(vec3(1));\n    //float dotNL = .5+.5*max(0., dot(n, ld));\n    return .5+.5*(n);\n}\n\n\n/** Parameters **/\nconst int ANTIALIAS = 1; // put this to 1 if it's too slow\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 ray_ori;\n    \n    float time = iTime;\n\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    if (iMouse.z > 0.) {\n        // not a real orbit camera, I should work on this\n        float xm = (-iMouse.x*10. / iResolution.x);\n        float ym = (-iMouse.y*10. / iResolution.x);\n        ray_ori = vec3(dist_to * cos(xm), cos(ym) * 5., dist_to * sin(xm));\n\t} else if (mode_cam == 4) {\n        \n        vec2 q = uv;\n        uv = fract((fragCoord.xy) / iResolution.xy*2.) - .5;\n    \tuv.x *= iResolution.x / iResolution.y;\n        \n        if(q.x < 0. && q.y >= .01)\n            ray_ori = vec3(0., 0., dist_to);\n        else if(q.x >= .01 && q.y >= .01)\n            ray_ori = vec3(-dist_to, 0., 0);\n\t\telse if(q.x < 0. && q.y < 0.)\n        \tray_ori = vec3(0, dist_to, .0001);\n\t\telse if(q.x >= .01 && q.y < 0.)\n            ray_ori = vec3(dist_to * cos(time * .5), ypos, dist_to * sin(time * .5));\n        else {\n            fragColor = vec4(.9, .5, .1, 1);\n            return;\n\t\t}\n        \n    } else {\n        switch(mode_cam) {\n            case 0:\n            \tray_ori = vec3(dist_to * cos(time * .5), ypos, dist_to * sin(time * .5));\n            \tbreak;\n            case 1:\n            \tray_ori = vec3(0., 0., dist_to);\n            \tbreak;\n            case 2:\n            \tray_ori = vec3(-dist_to, 0., 0);\n            \tbreak;\n            case 3:\n            \tray_ori = vec3(0, dist_to, .0001);\n            \tbreak;\n        }\n    }\n    \n\t\n    vec3 col = vec3(0);\n    \n    /*for (int j = 0; j < ANTIALIAS; j++) {\n\t\tfor (int i = 0; i < ANTIALIAS; i++) {\n\t\t\tvec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);\n\n\t\t\tvec2 uv = (fragCoord.xy + off) / iResolution.xy - .5;\n\t\t\tuv.x *= iResolution.x / iResolution.y;*/\n            \n    vec3 ray_dir = camera(ray_ori, uv, target);\n    vec3 pos;\n\n    \n    float tdist = 0.; // total distance from the ray origin to the point\n    float tmax = 60.; // max distance\n    // Sphere-tracing\n    for (float i = 0.; i < 1.; i += .01) {// 100 iterations\n        pos = ray_ori + ray_dir * tdist;\n        float dist = de(pos); // signed distance field\n        if (dist < .001 || tdist > tmax)\n            break;\n        tdist += dist * fudge;\n    }\n\n    if (tdist <= tmax) {\n        vec3 nor = normal(pos);\n        col += shading(pos, ray_dir, nor);\n    } else {\n        //col += vec3(.9, .9, .94); // background\n        col += bg_factor*checker(uv * bg_scale);\n    }\n    \n    // }} // antialias\n    // col /= float(ANTIALIAS * ANTIALIAS);\n    \n\n\t// gamma\n\tcol = pow(col, vec3(1. / gamma));\n\n\t// vignetting (from iq)\n\t//vec2 q = fragCoord / iResolution.xy;\n\t//col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .25);\n\n\tfragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}