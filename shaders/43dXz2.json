{
    "Shader": {
        "info": {
            "date": "1719313740",
            "description": "Use keyboard to control: ZC to look left and right (AD to turn around), SX to look up and down; arrow keys for moving around; space will reset your pitch, in case you get lost. See comment for portal rules.",
            "flags": 48,
            "hasliked": 0,
            "id": "43dXz2",
            "likes": 9,
            "name": "Knotted portal",
            "published": 3,
            "tags": [
                "3d",
                "topology"
            ],
            "usePreview": 0,
            "username": "TreborHuang",
            "viewed": 551
        },
        "renderpass": [
            {
                "code": "void plane(in vec4 val, in vec3 color, in int world, inout vec4 rval) {\n    if (val.z < eps) {\n    } else if (val.z < rval.w) {\n        rval.w = val.z;\n        switch (world) {\n          case 3:\n            rval.xyz = color * 0.5 * (1. -\n                sign(sin(5. * PI * max(abs(val.x), abs(val.y)))\n            ));\n            break;\n          case 0:\n            rval.xyz = color * 0.5 * (1. + sign(\n                sin(5. * PI * val.x) * sin(5. * PI * val.y)\n            ));\n            break;\n          case 1:\n            rval.xyz = color * 0.6 * (1. + sign(\n                sin(10. * pow(pow(val.y,4.) + pow(val.x,4.),.25))\n            )) - 0.05;\n            break;\n          case 2:\n            rval.xyz = color * (1.0 + sign(length(val.xy) - 1.0)) * 0.45;\n            break;\n          case 5:\n            ivec2 P = ivec2((val.xy + 1.) * 23. * 0.5);\n            int R = (8 * P.x * P.x * P.x\n                    - 3 * P.x\n                    - 7 * P.x * P.x\n                    - P.y * P.y\n                    + 13 * P.y * P.x\n                    + 2 * P.y\n                    + 11) % 23;  // an elliptic curve\n            rval.xyz = 1.5 * color * (1. - pow(float(R) / 23.0, 0.1));\n            break;\n          case 4:\n            rval.xyz = 0.55 * color * (1.0 + sign(sin(5. * PI *\n                pow(distance(val.xy, vec2(-2, -2))\n                   /distance(val.xy, vec2(-1, 1))\n                   *distance(val.xy, vec2(0., 0.))\n                   /distance(val.xy, vec2(1, -1))\n                   *distance(val.xy, vec2(2, 2)) + 0.1, 0.3))\n            ));\n            break;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = 0.3 * (fragCoord * 2.0 - iResolution.xy)/iResolution.yy;\n\n    // camera position\n    vec3 camera = texelFetch(iChannel1, ivec2(0,0), 0).xyz;\n\n    vec2 yp = texelFetch(iChannel1, ivec2(0,1), 0).xy;\n    float yaw = yp.x;\n    float pitch = yp.y;\n    \n    // rotate the ray\n    vec3 ray = \n          mat3( cos(yaw), 0., sin(yaw),\n                      0., 1.,       0.,\n               -sin(yaw), 0., cos(yaw))\n        * mat3(1.,         0.,         0.,\n               0., cos(pitch), sin(pitch),\n               0.,-sin(pitch), cos(pitch))\n        * vec3(uv, 1.);\n    \n    vec3 normal = vec3(0., 0., 0.);\n    vec4 ruv = vec4(0., 0., 0., 100.);\n    // intersect the portals\n    float p1 = portal(camera, ray, pos1, pos2, ruv);\n    int P1 = 4;\n    float p2 = portal(camera, ray, pos2, pos3, ruv);\n    int P2 = P1;\n    float p3 = portal(camera, ray, pos3, pos4, ruv);\n    int P3 = 5;\n    float p4 = portal(camera, ray, pos4, pos5, ruv);\n    int P4 = P3;\n    float p5 = portal(camera, ray, pos5, pos6, ruv);\n    int P5 = 5;\n    float p6 = portal(camera, ray, pos6, pos7, ruv);\n    int P6 = P5;\n    float p7 = portal(camera, ray, pos7, pos8, ruv);\n    int P7 = 3;\n    float p8 = portal(camera, ray, pos8, pos9, ruv);\n    int P8 = P7;\n    float p9 = portal(camera, ray, pos9, pos10, ruv);\n    int P9 = 3;\n    float p10 = portal(camera, ray, pos10, pos11, ruv);\n    int P10 = P9;\n    float p11 = portal(camera, ray, pos11, pos12, ruv);\n    int P11 = 4;\n    float p12 = portal(camera, ray, pos12, pos1, ruv);\n    int P12 = P11;\n    // sort the intersections and apply portals\n    EXC(p12, P12, p8, P8);\n    EXC(p1, P1, p7, P7);\n    EXC(p2, P2, p6, P6);\n    EXC(p3, P3, p11, P11);\n    EXC(p4, P4, p10, P10);\n    EXC(p5, P5, p9, P9);\n    EXC(p12, P12, p1, P1);\n    EXC(p2, P2, p5, P5);\n    EXC(p3, P3, p4, P4);\n    EXC(p6, P6, p9, P9);\n    EXC(p7, P7, p8, P8);\n    EXC(p10, P10, p11, P11);\n    EXC(p12, P12, p2, P2);\n    EXC(p1, P1, p6, P6);\n    EXC(p5, P5, p10, P10);\n    EXC(p9, P9, p11, P11);\n    EXC(p12, P12, p3, P3);\n    EXC(p1, P1, p2, P2);\n    EXC(p4, P4, p6, P6);\n    EXC(p5, P5, p7, P7);\n    EXC(p8, P8, p11, P11);\n    EXC(p9, P9, p10, P10);\n    EXC(p1, P1, p4, P4);\n    EXC(p3, P3, p5, P5);\n    EXC(p6, P6, p8, P8);\n    EXC(p7, P7, p10, P10);\n    EXC(p1, P1, p3, P3);\n    EXC(p2, P2, p5, P5);\n    EXC(p6, P6, p9, P9);\n    EXC(p8, P8, p10, P10);\n    EXC(p2, P2, p3, P3);\n    EXC(p4, P4, p5, P5);\n    EXC(p6, P6, p7, P7);\n    EXC(p8, P8, p9, P9);\n    EXC(p4, P4, p6, P6);\n    EXC(p5, P5, p7, P7);\n    EXC(p3, P3, p4, P4);\n    EXC(p5, P5, p6, P6);\n    EXC(p7, P7, p8, P8);\n    \n    int world = int(texelFetch(iChannel1, ivec2(0,0), 0).w);\n    // Order: (largest) 11 - 10 - 9 - ... - 1 - 12 (smallest, zero)\n    go(p12, P12, world);\n    go(p1, P1, world);\n    go(p2, P2, world);\n    go(p3, P3, world);\n    go(p4, P4, world);\n    go(p5, P5, world);\n    go(p6, P6, world);\n    go(p7, P7, world);\n    go(p8, P8, world);\n    go(p9, P9, world);\n    go(p10, P10, world);\n    go(p11, P11, world);\n    \n    // intersect the walls\n    plane(intersect(camera, ray,\n        vec3(2,0,0), vec3(0,1,0), vec3(0,0,1)),\n        vec3(0.9,0.1,0.1), world, ruv);\n    plane(intersect(camera, ray,\n        vec3(-2,0,0), vec3(0,-1,0), vec3(0,0,1)),\n        vec3(0.1, 0.7, 0.7), world, ruv);\n    plane(intersect(camera, ray,\n        vec3(0,2,0), vec3(0,0,-1), vec3(1,0,0)),\n        vec3(0.1,0.9,0.1), world, ruv);\n    plane(intersect(camera, ray,\n        vec3(0,-2,0), vec3(0,0,1), vec3(1,0,0)),\n        vec3(0.7,0.1,0.7), world, ruv);\n    plane(intersect(camera, ray,\n        vec3(0,0,2), vec3(0,1,0), vec3(-1,0,0)),\n        vec3(0.1,0.1,0.9), world, ruv);\n    plane(intersect(camera, ray,\n        vec3(0,0,-2), vec3(0,1,0), vec3(1,0,0)),\n        vec3(0.7,0.7,0.1), world, ruv);\n    // Output to screen\n    fragColor = vec4(clamp(ruv.xyz, 0., 1.2) + (abs(uv.x) * abs(uv.y) + 0.01 * dot(uv, uv) < 0.000003 ? 1. : 0.), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define eps 0.00001\n#define PI 3.14159265359\n\nvoid EXC(inout float p1,inout int P1,inout float p2,inout int P2) {\n    // puts the one with smaller absolute p to the front\n    if (abs(p2) < abs(p1)) {\n        float p3 = p2;\n        p2 = p1; p1 = p3;\n        int P3 = P2;\n        P2 = P1; P1 = P3;\n    }\n}\n\n// dihedral group\nint d3(int a, int b) {\n    if (a < 3 && b < 3) {\n        return (a + b) % 3;\n    } else if (a < 3 && b >= 3) {\n        return 3 + (a + b) % 3;\n    } else if (a >= 3 && b < 3) {\n        return 3 + (a - b) % 3;\n    } else {\n        return (6 + a - b) % 3;\n    }\n}\n\nint id3(int a) {\n    if (a < 3) {\n        return (3 - a) % 3;\n    } else {\n        return a;\n    }\n}\n\nvoid go(in float p, in int P, inout int world) {\n    if (p == 0.) return;\n    if (p < 0.) P = id3(P);\n    world = d3(world, P);\n}\n\nfloat toRay(vec3 pos, vec3 origin, vec3 ray) {\n    return dot(pos - origin, ray) / dot(ray, ray);\n}\n\nvec4 intersect(vec3 origin, vec3 ray, vec3 root, vec3 p, vec3 q) {\n    // returns uv coordinates of the intersection,\n    // and z is the position on the ray.\n    // w = 1.0 if it's head on, -1.0 if butt on\n    vec3 rayxq = cross(ray, q);\n    float det = dot(p, rayxq);\n    \n    if (abs(det) < eps) {\n        return vec4(0., 0., -1., 0.);\n    }\n    \n    float idet = 1.0 / det;\n    vec3 s = origin - root;\n    float u = idet * dot(s, rayxq);\n\n    vec3 sxp = cross(s, p);\n    float v = idet * dot(ray, sxp);\n\n    float t = idet * dot(q, sxp);\n    return vec4(u, v, t, sign(det));\n}\n\n// make the portal move? requires more collisionc\n#define pos1 vec3(0.8, -0.4, -0.4)\n#define pos2 vec3(0.4, -0.2, 0.4)\n#define pos3 vec3(-0.2, -0.2, 0.4)\n#define pos4 vec3(-0.6, 0., 0.)\n#define pos5 vec3(-0.4, 0.8, -0.4)\n#define pos6 vec3(0.4, 0.4, -0.2)\n#define pos7 vec3(0.4, -0.2, -0.2)\n#define pos8 vec3(0., -0.6, 0.)\n#define pos9 vec3(-0.4, -0.4, 0.8)\n#define pos10 vec3(-0.2, 0.4, 0.4)\n#define pos11 vec3(-0.2, 0.4, -0.2)\n#define pos12 vec3(0., 0., -0.6)\n\nfloat sectPortal(vec3 origin, vec3 ray, vec3 posA, vec3 posB) {\n    vec4 sect = intersect(origin, ray, vec3(0), posA, posB);\n    if (sect.x < 0. || sect.y < 0. || sect.x + sect.y > 1. || sect.z < eps) {\n        return 0.;\n    }\n    // look at direction of intersection\n    return sect.z * sect.w;\n}\n\nfloat norm_oo(vec3 v) {\n    return max(max(abs(v.x), abs(v.y)), abs(v.z));\n}\n\nfloat portal(\n    in vec3 origin, in vec3 ray, in vec3 posA, in vec3 posB,\n    inout vec4 color) {\n    // intersects edge cylinder\n    float sqRay = dot(ray, ray);\n    vec3 planeA = posA - ((dot(posA - origin, ray)/sqRay) * ray);\n    vec3 planeB = posB - ((dot(posB - origin, ray)/sqRay) * ray);\n    vec3 planeBA = planeB - planeA;\n    float delta = dot(planeBA, planeBA);\n    if (delta > 0.) {\n        float t = clamp(dot(origin - planeA, planeBA) / delta, 0., 1.);\n        vec3 RaytoAB = mix(posA, posB, t);\n        float rayPos = toRay(RaytoAB, origin, ray);\n        vec3 ABtoRay = rayPos * ray + origin;\n        float dist = distance(ABtoRay, RaytoAB);\n        if (rayPos > eps && rayPos < color.w && dist < 0.01) {\n            color = vec4(0.45 + 0.4 * normalize(RaytoAB) + .4 / pow(0.6 + rayPos, 0.8), rayPos);\n        }\n    }\n    \n    // intersects portal triangle\n    return sectPortal(origin, ray, posA, posB);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int KeyZ = 90;\nconst int KeyA = 65;\nconst int KeyD = 68;\nconst int KeyC = 67;\nconst int KeyS = 83;\nconst int KeyX = 88;\nconst int Left = 37;\nconst int Up = 38;\nconst int Right = 39;\nconst int Down = 40;\nconst int Space = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord == ivec2(1,0)) {\n      if (iFrame == 0) {\n          fragColor = vec4(1.85, 1.6, 1.8501, 0);\n      } else {\n          // target position\n          vec3 pos = texelFetch(iChannel1, ivec2(1,0), 0).xyz;\n          vec2 yp = texelFetch(iChannel1, ivec2(0,1), 0).xy;\n          vec3 direction = vec3(-cos(yp.x), 0., -sin(yp.x));\n          vec3 direction2 = vec3(-sin(yp.x)*cos(yp.y), -sin(yp.y), cos(yp.x)*cos(yp.y));\n          if (texelFetch(iChannel0, ivec2(Left, 0), 0).x != 0.0) {\n              pos += iTimeDelta * 2.8 * direction;\n          }\n          if (texelFetch(iChannel0, ivec2(Right, 0), 0).x != 0.0) {\n              pos -= iTimeDelta * 2.8 * direction;\n          }\n          if (texelFetch(iChannel0, ivec2(Up, 0), 0).x != 0.0) {\n              pos += iTimeDelta * 3.5 * direction2;\n          }\n          if (texelFetch(iChannel0, ivec2(Down, 0), 0).x != 0.0) {\n              pos -= iTimeDelta * 3.5 * direction2;\n          }\n          fragColor = vec4(clamp(pos, -1.9, 1.9), 0.0);\n      }\n    } else if (coord == ivec2(0,0)) {\n      // camera position and world number\n      if (iFrame == 0) {\n          fragColor = vec4(1.85, 1.6, 1.8501, 0.5);\n          // world number +0.5 to avoid float issues;\n      } else {\n          vec4 oldpos = texelFetch(iChannel1, ivec2(0,0), 0);\n          vec3 target = texelFetch(iChannel1, ivec2(1,0), 0).xyz;\n          // the world can't be interpolated\n          vec3 pos = mix(oldpos.xyz, target, iTimeDelta * 5.2);\n          vec3 posRay = pos - oldpos.xyz;\n          \n          \n            // intersect the portals\n            float p1 = sectPortal(oldpos.xyz, posRay, pos1, pos2);\n            int P1 = 4;\n            float p2 = sectPortal(oldpos.xyz, posRay, pos2, pos3);\n            int P2 = P1;\n            float p3 = sectPortal(oldpos.xyz, posRay, pos3, pos4);\n            int P3 = 5;\n            float p4 = sectPortal(oldpos.xyz, posRay, pos4, pos5);\n            int P4 = P3;\n            float p5 = sectPortal(oldpos.xyz, posRay, pos5, pos6);\n            int P5 = 5;\n            float p6 = sectPortal(oldpos.xyz, posRay, pos6, pos7);\n            int P6 = P5;\n            float p7 = sectPortal(oldpos.xyz, posRay, pos7, pos8);\n            int P7 = 3;\n            float p8 = sectPortal(oldpos.xyz, posRay, pos8, pos9);\n            int P8 = P7;\n            float p9 = sectPortal(oldpos.xyz, posRay, pos9, pos10);\n            int P9 = 3;\n            float p10 = sectPortal(oldpos.xyz, posRay, pos10, pos11);\n            int P10 = P9;\n            float p11 = sectPortal(oldpos.xyz, posRay, pos11, pos12);\n            int P11 = 4;\n            float p12 = sectPortal(oldpos.xyz, posRay, pos12, pos1);\n            int P12 = P11;\n            // we don't want large positions\n            if (abs(p1) > 1.) p1 = 0.;\n            if (abs(p2) > 1.) p2 = 0.;\n            if (abs(p3) > 1.) p3 = 0.;\n            if (abs(p4) > 1.) p4 = 0.;\n            if (abs(p5) > 1.) p5 = 0.;\n            if (abs(p6) > 1.) p6 = 0.;\n            if (abs(p7) > 1.) p7 = 0.;\n            if (abs(p8) > 1.) p8 = 0.;\n            if (abs(p9) > 1.) p9 = 0.;\n            if (abs(p10) > 1.) p10 = 0.;\n            if (abs(p11) > 1.) p11 = 0.;\n            if (abs(p12) > 1.) p12 = 0.;\n            \n            // sort the intersections and apply portals\n            EXC(p12, P12, p8, P8);\n            EXC(p1, P1, p7, P7);\n            EXC(p2, P2, p6, P6);\n            EXC(p3, P3, p11, P11);\n            EXC(p4, P4, p10, P10);\n            EXC(p5, P5, p9, P9);\n            EXC(p12, P12, p1, P1);\n            EXC(p2, P2, p5, P5);\n            EXC(p3, P3, p4, P4);\n            EXC(p6, P6, p9, P9);\n            EXC(p7, P7, p8, P8);\n            EXC(p10, P10, p11, P11);\n            EXC(p12, P12, p2, P2);\n            EXC(p1, P1, p6, P6);\n            EXC(p5, P5, p10, P10);\n            EXC(p9, P9, p11, P11);\n            EXC(p12, P12, p3, P3);\n            EXC(p1, P1, p2, P2);\n            EXC(p4, P4, p6, P6);\n            EXC(p5, P5, p7, P7);\n            EXC(p8, P8, p11, P11);\n            EXC(p9, P9, p10, P10);\n            EXC(p1, P1, p4, P4);\n            EXC(p3, P3, p5, P5);\n            EXC(p6, P6, p8, P8);\n            EXC(p7, P7, p10, P10);\n            EXC(p1, P1, p3, P3);\n            EXC(p2, P2, p5, P5);\n            EXC(p6, P6, p9, P9);\n            EXC(p8, P8, p10, P10);\n            EXC(p2, P2, p3, P3);\n            EXC(p4, P4, p5, P5);\n            EXC(p6, P6, p7, P7);\n            EXC(p8, P8, p9, P9);\n            EXC(p4, P4, p6, P6);\n            EXC(p5, P5, p7, P7);\n            EXC(p3, P3, p4, P4);\n            EXC(p5, P5, p6, P6);\n            EXC(p7, P7, p8, P8);\n\n            int world = int(oldpos.w);\n            // Order: (largest) 11 - 10 - 9 - ... - 1 - 12 (smallest, zero)\n            go(p12, P12, world);\n            go(p1, P1, world);\n            go(p2, P2, world);\n            go(p3, P3, world);\n            go(p4, P4, world);\n            go(p5, P5, world);\n            go(p6, P6, world);\n            go(p7, P7, world);\n            go(p8, P8, world);\n            go(p9, P9, world);\n            go(p10, P10, world);\n            go(p11, P11, world);\n          \n          fragColor = vec4(pos, float(world) + 0.5);\n      }\n    } else if (coord == ivec2(0,1)) {\n      if (iFrame == 0) {\n          fragColor = vec4(PI*0.75,0.4,0,0);\n      } else {\n          vec4 yp = texelFetch(iChannel1, ivec2(0,1), 0);\n          vec4 target = texelFetch(iChannel1, ivec2(1,1), 0);\n          fragColor = mix(yp, target, iTimeDelta * 4.2);\n      }\n    } else if (coord == ivec2(1,1)) {\n      // target yaw and pitch\n      if (iFrame == 0) {\n          fragColor = vec4(PI*0.75,0.5,0,0);\n      } else {\n          vec4 yp = texelFetch(iChannel1, ivec2(1,1), 0);\n          float temp = 0.0;\n          if (texelFetch(iChannel0, ivec2(KeyZ, 0), 0).x != 0.0) {\n              yp.x += iTimeDelta * 1.7;\n          }\n          temp = texelFetch(iChannel0, ivec2(KeyA, 0), 0).x;\n          if (yp.z == 0.0 &&\n              temp != 0.0) {\n              yp.x += PI;\n              yp.y *= -1.0;\n          }\n          yp.z = temp;\n          if (texelFetch(iChannel0, ivec2(KeyC, 0), 0).x != 0.0) {\n              yp.x -= iTimeDelta * 1.7;\n          }\n          temp = texelFetch(iChannel0, ivec2(KeyD, 0), 0).x;\n          if (yp.w == 0.0 &&\n              temp != 0.0) {\n              yp.x -= PI;\n              yp.y *= -1.0;\n          }\n          yp.w = temp;\n          if (texelFetch(iChannel0, ivec2(KeyS, 0), 0).x != 0.0) {\n              yp.y -= iTimeDelta * 1.1;\n          }\n          if (texelFetch(iChannel0, ivec2(KeyX, 0), 0).x != 0.0) {\n              yp.y += iTimeDelta * 1.1;\n          }\n          if (texelFetch(iChannel0, ivec2(Space, 0), 0).x != 0.0) {\n              yp.y = 0.;\n          }\n          yp.y = clamp(yp.y, -1.3, 1.3);\n          fragColor = yp;\n      }\n    } else {\n        fragColor = vec4(0.0,0.0,1.0,1.0);   \n    }\n    // TODO move with keyboard\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}