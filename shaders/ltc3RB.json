{
    "Shader": {
        "info": {
            "date": "1470143672",
            "description": "Look at Buf A line 129 for the scene distance/material function.\n\nControls:\nlook - mouse\nmove - arrow keys\n\nAdded material to the volumetric path tracer i used in my last shader toy.",
            "flags": 48,
            "hasliked": 0,
            "id": "ltc3RB",
            "likes": 46,
            "name": "basic volume pathtracer",
            "published": 3,
            "tags": [
                "basic",
                "volume",
                "tracer",
                "path",
                "pt"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 1852
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n/*\nLook at Buf A line 129 for the scene distance/material function.\n\nControls:\nlook - mouse\nmove - arrow keys\n\nAdded material to the volumetric path tracer i used in my last Shadertoy.\n*/\n\n\n\n\n//display montecarlo path trace result\n\n\n#define devrender 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if devrender == 0\n    vec4 csamp = texture(iChannel0, 0.5/iResolution.xy);\n    vec4 samp = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = pow(samp/samp.w/*/(float(iFrame-int(csamp.x*4096.)))*/, vec4(1./2.2));\n    \n    //used for exporting image in the format of r=lighting, g=opacity\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy)/(float(iFrame-120));\n    //fragColor.x = pow(fragColor.x, 1./2.2);\n    \n\t#else\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(1./2.2));\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n//rendering pass\n\n\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n#define camera_fisheye 2.0\n\n#define iterations 256\n#define minDelta .2\n#define maxDelta 1.\n#define skipDelta .1\n\n#define range 256.\n\n#define sunImportance 0.25\n\n#define camerarange 256.\n\n\n\nvec3 sunDirection = normalize(vec3(0.2,5.,10.5));\nconst vec3 sunColor = vec3(1.,.74,.94)*2.,\n    \t   skyColor = vec3(0.04,0.06,0.14)*0.0,\n    \t   ambientColor = vec3(1.);\n\nconst float sunSize = 0.004,//0-1\n    \t\tambientDensity = 0.;//0-2, global mist\n\n\n#define devrender 0\n\n\n\nstruct ctx {\n    vec3 point;\n    float distance_,\n          density, fluff, deformRoughness, deformAmount, deformScale, emission;\n    vec3 color;\n};\n\n\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\n\n\n//scene function, returns distance + material data at point\nctx scene(ctx i) {\n    vec3 rp = i.point;\n    \n    //floor\n    i.distance_ = abs(rp.y)-6.;\n    i.color = vec3(0.95);\n    i.density = 1.;\n    i.deformAmount = 0.;\n    i.deformScale = .1;\n    i.deformRoughness = 0.15;\n    i.fluff = 0.0;\n    i.emission = 0.0;\n    \n    //courtyard walls\n    float cwalls = max(rp.y-20., abs(length(rp.xz)-30.)-2.);\n    if (cwalls < i.distance_) {\n        i.distance_ = cwalls;\n    }\n    \n    //sphere examples\n    vec3 lp = vec3(rp.y-8., mod(abs(rp.xz),8.)-4.).yxz;\n    float sexp = max(-(cwalls-11.), length(lp)-3.);\n    if (sexp < i.distance_) {\n        i.distance_ = sexp;\n        \n        float id = floor(rp.x/8.)*4.+floor(rp.z/8.)*128.;\n        i.density = pow(fract(abs(id)/6.)*.9+0.1,2.2);\n        i.deformAmount = fract(abs(id)/4.+.2985)*.25;\n        i.color = vec3(cos(id/2.),sin(id/8.+.6934),-cos(id/8.+1.295))*.5+.5;\n    }\n    \n    return i;\n}\n\n\n\n//backgrund\nvec3 background(vec3 d) {\n    float sun = dot(normalize(sunDirection), d);\n    return mix(skyColor,\n               sunColor,\n               pow(max(0., sun-(1.-sunSize))/sunSize,.3));\n}\n\n\n\n//apply cloud warping and distance modifiers\nctx scene_warp(ctx cx) {\n    \n    cx = scene(cx);\n   \tfloat d = cx.distance_;\n    \n    vec3 p = cx.point;\n\n    //cloud shape deform\n    if (cx.deformAmount > 0.0) {\n\t#define ldst d\n    for (int i = 1; i < 4; i++) {\n        float pfi = pow(float(i),2.)*cx.deformScale;\n        ldst += abs(cos(p.x/pfi+cos(26.2348+ldst*cx.deformRoughness*p.z/pfi+(p.y*.39)/pfi)*4.)*\n     \t\t     cos(p.y/pfi+cos(29.8937+ldst*cx.deformRoughness*p.x/pfi+(p.z*.37)/pfi)*4.)*\n       \t\t     cos(p.z/pfi+cos(14.972+ldst*cx.deformRoughness*p.y/pfi+(p.x*.41)/pfi)*4.))*pfi*(cx.deformAmount/cx.deformScale);\n    }\n    }\n    \n    cx.distance_ = max(skipDelta, d);\n    return cx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 camtex = texture(iChannel1, 0.5/iResolution.xy);\n    float frame = texture(iChannel2, 0.5/iResolution.xy).x*4096.;\n       \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //ray direction from uvs and ray position at origin\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)*vec2(-1.,1.)/iResolution.x,1./camera_fisheye)),\n         ird,\n         rp = camtex.xyz-camerarange;\n    \n    vec2 cameraRot = decodeRot(camtex.w);\n    rd.yz = rot(rd.yz,cameraRot.y);\n    rd.xz = rot(rd.xz,cameraRot.x);\n    \n    ird = rd;\n    float ifrm = float(iFrame);\n    #define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n    \n    vec4 c = vec4(1,1,1,0);\n    \n    ctx cx;\n    \n    #if devrender == 0\n    \n    vec3 l = vec3(0.0);\n    \n    //render\n    for (int i = 0; i < iterations; i++) {\n        cx.point = rp;\n        cx = scene_warp(cx);\n        float d = cx.distance_,\n              dt = d*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta)),\n              k = min(1., (d-skipDelta)*10.*(1.-cx.fluff));\n        if (mix(cx.density,ambientDensity,k)*max(1.,dt*.1) > hash3(rp+rndifrm(rp)*256.)) {\n            c.xyz *= mix(cx.color,ambientColor,floor(k));\n            c.w = 1.;\n            l += cx.color*cx.emission*(1.0-floor(k));\n            rd = mix(randomRay(rp+rndifrm(rp*1024.)*1024.), sunDirection, floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+sunImportance-1e-6));\n        }\n        \n        rp += rd*dt;\n        if (length(rp) > range) break;\n    }\n   \n    c.xyz = c.xyz*background(rd)*float(length(rp)/range > 1.)+ //if light ray makes it too edge of world illuminate it  \n    \t\tc.xyz*l;\n    fragColor = mix(vec4(background(ird),1.), c, c.w)+\n    texture(iChannel0, uv)*float(float(iFrame)-frame > 1.0);//blend result with background and add to buffer\n\n    //used for exporting image in the format of r=lighting, g=opacity\n    /*(fragColor = vec4(c.x*float(max(length(rp)/range,max(0.,-rp.y)/yRange) > 1.),c.w,0,0)+\n                     texture(iChannel0, uv);\n    */\n    \n    #else\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp);\n        if (d < .2 || c.w > range) break;\n        \n        rp += rd*d;\n        c.w += d;\n    }\n    if (df(rp) < .2) {\n       c = vec4(cloudColor*(.3+max(0.,(df(rp)-df(rp-sunDirection)))),1.);\n    } else {\n       c = vec4(background(ird),1.); \n    }\n    fragColor = c+texture(iChannel0,uv);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n\n//camera move and look\n\n\n\n#define uv (.5/iResolution.xy)\n#define camerarange 256.\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n\n#define mouse_sensitivity 0.025 * 60.0\n#define movement_sensitivity 0.2 * 60.0\n\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n\n\nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    if (iFrame < 10) {\n     \t//set default camera\n        vec3 camPos = vec3(11., 17., 6.),\n             camRot = vec3(3.5, 3.14/1.2, 0.0);\n        \n        fragColor = vec4(camPos+camerarange, encodeRot(mod(camRot.xy,pi2)));\n        return;\n    }\n        \n   \tvec4 samp = texture(iChannel0, uv);\n    vec3 camPos = samp.xyz,\n             camRot = decodeRot(samp.w).xyy;\n    \n    //movement\n    float movementA = texture(iChannel1, vec2(38.5, 25.5)/255.).x-\n                                 texture(iChannel1, vec2(40.5, 25.5)/255.).x;\n    if (movementA != 0.) {\n        vec3 rdB = vec3(0.,0.,1.);    \n        rdB.yz = rot(rdB.yz,camRot.y);\n        rdB.xz = rot(rdB.xz,camRot.x);\n    \tcamPos.xyz += movementA*rdB*iTimeDelta*movement_sensitivity;\n    }\n    float movementB = texture(iChannel1, vec2(37.5, 25.5)/255.).x-\n                      texture(iChannel1, vec2(39.5, 25.5)/255.).x;\n    if (movementB != 0.) {\n         vec3 rdB = vec3(1.,0.,0.);    \n         rdB.yz = rot(rdB.yz,camRot.y);\n         rdB.xz = rot(rdB.xz,camRot.x);\n         camPos.xyz += movementB*rdB*iTimeDelta*movement_sensitivity;\n    }\n                \n    //rotation\n    if (iMouse.w > 0.) {\n    \tvec2 muv = (iMouse.xy/iResolution.xy)-.5;\n        camRot.xy += muv*vec2(1.,-1.)*mouse_sensitivity*iTimeDelta;\n    }\n\n    fragColor = vec4(max(camPos, 0.0), encodeRot(mod(camRot.xy,pi2)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n//frame of last camera change\n\n\n#define uv (.5/iResolution.xy)\n#define change_epsilon 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    vec4 csamp = texture(iChannel0, uv),\n         bsamp = texture(iChannel1, uv);\n    \n    float hash = fract(length(bsamp)+bsamp.w);\n    if (abs(hash-csamp.y) > change_epsilon) {\n     \tcsamp.y = hash;\n        csamp.x = float(iFrame)/4096.;\n    }\n    \n    fragColor = csamp;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}