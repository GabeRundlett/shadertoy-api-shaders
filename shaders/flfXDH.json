{
    "Shader": {
        "info": {
            "date": "1625553688",
            "description": "Still haven't figured out a way to compute the tightest bbox of a quadratic bezier that seems surefire. Instead using linear regression on the bezier curve to try approximating the optimal orientation.",
            "flags": 0,
            "hasliked": 0,
            "id": "flfXDH",
            "likes": 9,
            "name": "Oriented BBox of QBezier I",
            "published": 3,
            "tags": [
                "bezier",
                "quadratic",
                "boundingbox",
                "obb",
                "oriented",
                "linearregression"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 184
        },
        "renderpass": [
            {
                "code": "/*\nStill haven't figured out a way to compute the tightest bbox of a\nquadratic bezier that seems surefire. Instead using analytical\nlinear regression of the bezier curve to try guessing an orientation.\n\nBased on and inspired by @fizzer's approach:\n\"Cubic Bezier Analytic OBB\": https://www.shadertoy.com/view/stfSR7\n\nWhen the OBB is red, it has a larger area than the axis aligned bbox.\nWhen the OBB is green, it has a smaller area than the axis aligned bbox.\n\nThe axis aligned bbox is yellow.\n(I think I need to modify my color scheme, somewhat low contrast :))\n*/\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nstruct AxisAlignedBBox { vec2 bmin; vec2 bmax; };\nstruct OrientedBBox { mat2 ori; vec2 bmin; vec2 bmax; };\n\n// SDFs\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdBBox(in vec2 p, in AxisAlignedBBox bbox) {\n    p = abs(p - 0.5 * (bbox.bmin + bbox.bmax)) - 0.5 * (bbox.bmax - bbox.bmin);\n    return abs(length(max(p, 0.0)) + min(0.0, max(p.x, p.y)));\n}\n\nfloat sdBBox(in vec2 p, in OrientedBBox bbox) {\n    return sdBBox(p * bbox.ori, AxisAlignedBBox(bbox.bmin, bbox.bmax));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// Best linear fit of discrete points on a qudratic bezier curve (not optimal)\n//#define N 50\n//vec2 linearFitBezierDiscrete(in vec2 v1, in vec2 v2, in vec2 v3) {\n//    vec4 w = vec4(0.0);\n//    for (float t=0.0; t < 1.0; t += 1.0 / float(N)) {\n//        vec2 p = mix(mix(v1, v2, t), mix(v2, v3, t), t);\n//        w += vec4(p, p * p.xx);\n//    }\n//\n//    float b = (w.y * w.z - w.x * w.w) / (float(N) * w.z - w.x * w.x);\n//    return vec2((w.w - w.x * b) / w.z, b);\n//}\n\n// Integrals instead of summations of discrete points\nvec2 linearFitBezierContinuous(in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1;\n\n    vec4 w;\n    w.x = a.x / 3.0 + 0.5 * b.x + c.x;\n    w.y = a.y / 3.0 + 0.5 * b.y + c.y;\n    w.z = (0.2 * a.x + 0.5 * b.x) * a.x + (2.0 * a.x * c.x + b.x * b.x) / 3.0 + (b.x + c.x) * c.x;\n    w.w = 0.2 * (a.x * a.y) + 0.25 * dot(a, b.yx) + (dot(a, c.yx) + b.x * b.y) / 3.0 + 0.5 * dot(b, c.yx) + c.x * c.y;\n\n    float rb = (w.y * w.z - w.x * w.w) / (w.z - w.x * w.x);\n    return vec2((w.w - w.x * rb) / w.z, rb);\n}\n\n// Axis aligned\nAxisAlignedBBox bezierAABB(in vec2 v1, in vec2 v2, in vec2 v3) {\n    AxisAlignedBBox bbox;\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n\n    vec2 extrema = -0.5 * b / a;\n    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n    if (abs(extrema.x - 0.5) < 0.5) {\n        vec2 p = (a * extrema.x + b) * extrema.x + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    if (abs(extrema.y - 0.5) < 0.5) {\n        vec2 p = (a * extrema.y + b) * extrema.y + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    return bbox;\n}\n\n// Oriented\nOrientedBBox bezierOBB(in vec2 v1, in vec2 v2, in vec2 v3) {\n    OrientedBBox bbox;\n    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n\n    // Linear regression\n    vec4 w;\n    w.x = a.x / 3.0 + 0.5 * b.x + c.x;\n    w.y = a.y / 3.0 + 0.5 * b.y + c.y;\n    w.z = (0.2 * a.x + 0.5 * b.x) * a.x + (2.0 * a.x * c.x + b.x * b.x) / 3.0 + (b.x + c.x) * c.x;\n    w.w = 0.2 * (a.x * a.y) + 0.25 * dot(a, b.yx) + (dot(a, c.yx) + b.x * b.y) / 3.0 + 0.5 * dot(b, c.yx) + c.x * c.y;\n\n    float rb = (w.y * w.z - w.x * w.w) / (w.z - w.x * w.x);\n    vec2 fit = vec2((w.w - w.x * rb) / w.z, rb);\n\n    // Compute the orientation matrix from the fitting\n    vec2 p1 = vec2(0.0, fit.y), p2 = vec2(1.0, fit.x + fit.y);\n    vec2 dir = normalize(p2 - p1);\n    bbox.ori = mat2(dir, -dir.y, dir.x);\n\n    // Reposition and reorient, then compute new a, b, and c\n    v1 -= p1, v2 -= p1, v3 -= p1;\n    v1 *= bbox.ori, v2 *= bbox.ori, v3 *= bbox.ori;\n    a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1;\n\n    // Axis aligned bbox in new coordinate frame\n    vec2 extrema = -0.5 * b / a;\n    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n    if (abs(extrema.x - 0.5) < 0.5) {\n        vec2 p = (a * extrema.x + b) * extrema.x + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    if (abs(extrema.y - 0.5) < 0.5) {\n        vec2 p = (a * extrema.y + b) * extrema.y + c;\n        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n    }\n\n    vec2 offs = p1 * bbox.ori;\n    bbox.bmin += offs, bbox.bmax += offs;\n\n    return bbox;\n}\n\n// --- Insert exact minimal area OBB code here. ---\n// Still haven't got it figured out but at least its only a parabola segment :/\n//OrientedBBox bezierOBB2(in vec2 v1, in vec2 v2, in vec2 v3) {\n//    OrientedBBox bbox;\n//\n//    \n//\n//    vec2 a = v1 - 2.0 * v2 + v3, b = 2.0 * (v2 - v1), c = v1; // Coefficients\n//\n//    vec2 extrema = -0.5 * b / a;\n//    bbox.bmin = min(v1, v3), bbox.bmax = max(v1, v3);\n//    if (abs(extrema.x - 0.5) < 0.5) {\n//        vec2 p = (a * extrema.x + b) * extrema.x + c;\n//        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n//    }\n//\n//    if (abs(extrema.y - 0.5) < 0.5) {\n//        vec2 p = (a * extrema.y + b) * extrema.y + c;\n//        bbox.bmin = min(bbox.bmin, p), bbox.bmax = max(bbox.bmax, p);\n//    }\n//\n//    return bbox;\n//}\n\n// // https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 getPoint(in float id) {\n    float freq = Hash11(id * 393.84 + 673.48) * 4.0 - 2.0;\n    float phase = Hash11(id * 348.46 + 183.37);\n    float amp = Hash11(id * 275.35 + 741.69) * 4.0;\n    float ang = iTime * freq + phase;\n    return vec2(cos(ang), sin(ang)) * amp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.0);\n\n    // Grid\n    //drawSDF(abs(mod(uv.x + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    //drawSDF(abs(mod(uv.y + 0.25, 0.5) - 0.25), vec3(0.0, 0.0, 1.0));\n    //drawSDF(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    //drawSDF(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Vignette\n    color -= pow(length(fragCoord / iResolution.xy - 0.5), 1.5);\n\n    // Bezier control points\n    vec2 a = getPoint(10.0);\n    vec2 b = getPoint(8.0);\n    vec2 c = getPoint(4.0);\n\n    // Fit it with a line\n    vec2 fit = linearFitBezierContinuous(a, b, c);\n    drawSDF(abs(uv.y - (fit.x * uv.x + fit.y)) / sqrt(1.0 + fit.x * fit.x), vec3(1.0, 0.0, 1.0));\n\n    // Draw the different bounding boxes\n    AxisAlignedBBox aabb = bezierAABB(a, b, c);\n    float aabbArea = (aabb.bmax.x - aabb.bmin.x) * (aabb.bmax.y - aabb.bmin.y);\n    drawSDF(sdBBox(uv, aabb), vec3(1.0, 0.8, 0.0));\n\n    OrientedBBox obb = bezierOBB(a, b, c);\n    float obbArea = (obb.bmax.x - obb.bmin.x) * (obb.bmax.y - obb.bmin.y);\n    drawSDF(sdBBox(uv, obb), obbArea > aabbArea ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n\n    // Draw hull\n    drawSDF(sdLine(uv, a, b, 0.001), vec3(0.5, 0.0, 1.0));\n    drawSDF(sdLine(uv, b, c, 0.001), vec3(0.5, 0.0, 1.0));\n\n    // Draw bezier\n    drawSDF(sdBezier(uv, a, b, c) - 0.01, vec3(0.0));\n\n    // Draw control points\n    drawSDF(sdDisk(uv, a, 0.05), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, b, 0.05), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, c, 0.05), vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}