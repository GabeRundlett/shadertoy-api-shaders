{
    "Shader": {
        "info": {
            "date": "1538691540",
            "description": "somewhat souped up version of https://www.shadertoy.com/view/Xl3fR4\nkey toggles (all ON for default):\nM - movement\nA - 2x AA\nS - adaptive 16x AA\nR - temporal randomization for 16x AA\n\n",
            "flags": 16,
            "hasliked": 0,
            "id": "4lcfR4",
            "likes": 5,
            "name": "raytrace fancy",
            "published": 3,
            "tags": [
                "raytrace"
            ],
            "usePreview": 0,
            "username": "dabadab",
            "viewed": 407
        },
        "renderpass": [
            {
                "code": "const float PI_2 = 1.57079632679489661923; \n\n\n// ---------------------------------------------------\n\n// taken from https://www.shadertoy.com/view/XsBXRV\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n\nbool keyToggled(int key)\n{\n\treturn texture(iChannel2, vec2((float(key)+0.5)/256.0,0.75)).x>0.0;\n}\n\n\n// ---------------------------------------------------\n\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n   vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n   vec3 ww = normalize(target - origin);\n   vec3 uu = normalize(cross(ww, rr));\n   vec3 vv = normalize(cross(uu, ww));\n\n   return mat3(uu, vv, ww);\n}\n\n\n// ---------------------------------------------------\n\n// taken from IQ: https://iquilezles.org/articles/warp\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                  fbm( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),\n                  fbm( p + 4.0*q + vec2(8.3,2.8) ) );\n\n    return fbm( p + 4.0*r )/4.0;\n}\n\n// ------------------------------------------------------\n\n// the classic random function\nfloat rand(vec2 st) {\n    st.x += iTime;\n    st.y += iTime;\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// ------------------------------------------------------\n\nbool isMoving() { return(!keyToggled(KEY_M)); }\nbool isAdaptiveAAEnabled() { return(!keyToggled(KEY_S)); }\nbool isSimpleAAEnabled() { return(!keyToggled(KEY_A)); }\nbool isRandomAAEnabled() { return(!keyToggled(KEY_R)); }\n\n\n// ------------------------------------------------------\n\nvec3 getSkyColor(in vec3 ray) {\n    float sinAngle = ray.y / length(ray);\n    vec3 bottom = vec3(0.54, 0.77, 0.98);\n    vec3 top = vec3(0.13, 0.39, 0.68);\n    return mix(bottom, top, sinAngle/2.0);\n}\n\nvec3 getGroundColor(vec2 uv, float distance, float shadow) {\n    vec3 col;\n    \n    // get ground pattern with the checkerboards\n    if ( abs(mod(uv.x,12.0)) > 6.0 ||  abs(mod(uv.y,12.0)) > 6.0 ) {\n        col = vec3(0.1);\n    } else {\n        if ( (fract(uv.x) > 0.5) != (fract(uv.y) > 0.5) ) {\n            // white floor tile\n            col = vec3(0.9);\n        } else {\n            // black floor tile\n            col = vec3(0.2);\n        }\n    }\n    \n    // apply perlin noise-based pattern\n    float p = pattern(uv);\n    col += vec3(p, p*0.7, p*0.2);\n    \n    // fade to blue in the distance\n    vec3 far = vec3(0.54, 0.77, 0.98);\n    col = mix(col, far, atan(distance/30.0)/PI_2);\n    \n    // apply shadow\n    col = mix(col,col * ( 0.35 * shadow ), shadow);\n    return col;\n}\n\n\nvec3 renderPixel(in vec2 fragCoord) {\n    // number of spheres\n    const int SPHERES=3;\n\n    // sphere data: x, y, z\n    vec3 SPHERE_COORD[SPHERES]= vec3[3](\n        vec3(0.0,            1.1-sin(iTime*1.3)*0.5, 0.0),\n        vec3(0.0+sin(iTime), 0.9,                    0.0+cos(iTime)),\n        vec3(1.5,            1.2,                    0.5)\n    );\n\n    // sphere data: radius\n    float SPHERE_RADIUS[SPHERES]= float[3](\n        0.6,\n        0.2,\n        0.3\n    );\n\n    vec3 SPHERE_COLOR[SPHERES]= vec3[3](\n        vec3(0.9, 0.9, 0.9),\n        vec3(0.64, 0.74, 0.86),\n        vec3(1.0, 0.84, 0.0)\n    );    \n    \n  \n    vec3 eye = isMoving() ? vec3(0.0+sin(iTime*0.2)*3.0, 1.0-sin(iTime*0.2)*0.5, 0.0+cos(iTime*0.2)*7.0) :  vec3(0.0, 1.0, 3.0);\n    vec3 ray=vec3(fragCoord.x-iResolution.x/2.0, fragCoord.y-iResolution.y/2.0, iResolution.x*1.0);\n    \n    // depth of field\n    float rnd = rand(fragCoord+vec2(float(iTime)));\n    vec3 displacement = vec3(sin(rnd), 0.0, cos(rnd));\n    \n    // TODO: it's buggy but still looks good\n    mat3 lookAt=calcLookAtMatrix(eye, vec3(1.0, 0.5, 0.0), 0.0);\n    ray = ray * lookAt;\n    \n    vec3 pos=eye;\n    \n    \n    vec3 colorCor=vec3(1.0);\n    float totalDistance = 0.0;\n    \n    while ( true ) {\n        float s=0.0;\n        int n = -1;\n\n        // check if we hit the floor\n        if ( ray.y < 0.0 ) {\n            s = -pos.y/ray.y;\n            n = 0;\n        }\n\n        // check the spheres\n        for ( int k=0 ; k < SPHERES ; k++ ) {\n            vec3 to_sphere = SPHERE_COORD[k]-pos;\n            float sc = dot(to_sphere, ray);\n            if ( sc > 0.0 ) { // the angle between to_sphere and ray is between -90 and +90 degrees\n                float pp = dot(to_sphere, to_sphere); // TODO: length?\n                float bb = sc * sc / (length(ray) * length(ray));\n                float aa = SPHERE_RADIUS[k]*SPHERE_RADIUS[k] - pp + bb;\n                if ( aa > 0.0 ) { // sphere is hit\n                    sc = (sqrt(bb) - sqrt(aa)) / length(ray);\n                    if ( sc < s || n < 0 ) { // if nothing else is hit or this is the nearest hit so far then remember this object\n                        n = k+1;\n                        s = sc;\n                    }\n                }\n            }\n        }\n\n        \n        \n        if ( n < 0 ) { // we hit the sky \n            return getSkyColor(ray) * colorCor;\n        }\n\n        // we hit something\n        ray = ray * s; // set the ray to the correct length\n        totalDistance += length(ray);\n        pos += ray; // go where the ray hit\n        \n        \n        if ( n == 0 ) { // we hit the floor - finally!                      \n            // calculate soft shadows\n            const float penumbra_outer = 0.2 ; // choosen by the vote of the family\n            const float penumbra_inner = 0.05 ;\n            float shadow = 0.0;\n            // check the shadows - the check is done just on the xz plane not in 3D\n            for ( int k=0 ; k < SPHERES ; k++ ) {\n                float dist_from_sphere = length(SPHERE_COORD[k].xz-pos.xz);\n                float penumbra_radius = SPHERE_RADIUS[k] + (SPHERE_COORD[k].y * penumbra_outer );\n                float umbra_radius = SPHERE_RADIUS[k] - ( SPHERE_COORD[k].y * penumbra_inner );\n\n                shadow += ( 1.0 - smoothstep(umbra_radius, penumbra_radius, dist_from_sphere) );\n            }\n            shadow = min(shadow, 1.0);\n                                                          \n            vec2 uv=vec2(pos.x+3.0, pos.z + ( isMoving() ? iTime*1.5 : 0.0 ) ); // to add an illusion of movement\n            return getGroundColor(uv, totalDistance, shadow) * colorCor;\n            \n            \n        } else { // we hit a sphere - bounce the ray\n            \n            colorCor = colorCor * SPHERE_COLOR[n-1];\n            \n            // calculate normal vector\n            vec3 normal =pos - SPHERE_COORD[n-1];\n            float l = 2.0*dot(ray, normal)/dot(normal, normal);\n            ray = ray - ( l * normal );\n            totalDistance += length(ray);\n        }\n    }\n}\n\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // primitive adaptive sampling\n    vec3 col = renderPixel(fragCoord);\n    vec3 col2 = renderPixel(fragCoord+vec2(0.5));\n    if ( isAdaptiveAAEnabled() || length(col-col2) > 0.2 ) {\n        // there be antialiasing, sample more with slightly randomized offsets (frankly, it's not worth the hassle)\n        for ( int i = 1 ; i < 16 ; i++ ) {\n            if ( i == 10 ) {\n                col += col2;\n            } else {\n                vec2 coord = fragCoord + vec2(float(i & 3 )*0.25, float((i>>2) & 3 )*0.25);\n                if ( isRandomAAEnabled() )\n                \tcoord += vec2( rand(fragCoord+vec2(float(i))) )*0.2;\n         \n        \t\tcol += renderPixel(coord);\n            }\n        }\n        col = col / 16.0;\n    } else if ( isSimpleAAEnabled() ) {\n        col += col2;\n    \tcol = col / 2.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}