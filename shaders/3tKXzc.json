{
    "Shader": {
        "info": {
            "date": "1583700855",
            "description": "Сhamomile",
            "flags": 0,
            "hasliked": 0,
            "id": "3tKXzc",
            "likes": 1,
            "name": "СhamomileFlowr",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Arseny",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "\n\n\n\nfloat N21(vec2 p) {  // https://youtu.be/zXsWftRdsvU\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) { // https://youtu.be/zXsWftRdsvU\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) { // https://youtu.be/zXsWftRdsvU\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nconst float innerR = 0.2;\nfloat seed = 228.322;\n\nfloat circGrid(vec2 uv, float offset, float blur){\n    vec2 lv = fract(uv);\n    lv -= 0.5;\n    return 1. - smoothstep(0., blur, abs(length(lv) - (0.5 - offset - blur)));\n}\n\nfloat inv(float x){\n    return 1. - x;\n}\n\n/*vec3 cent(vec2 uv){\n    vec3 yel = vec3(1., 1., 0.);\n    vec3 col = vec3(0);\n    float rnd1 = SmoothNoise2(uv * 5.);\n    float rnd2 = SmoothNoise2(uv * 5. + vec2(5112.41, 4241.123));\n    vec2 trans = uv * rot(length(uv) / R);\n    //float mult = circGrid(2. * uv / (length(trans) + 0.3) * 10., 0., 0.1);\n    trans = trans / (length(trans) + 0.3) * 10.;\n    float mult = circGrid(trans, 0., 0.1);\n    //return vec3(mult);\n    mult = (2. - mult) / 2.;\n    float rnd = min(rnd1, rnd2);\n    //return vec3(rnd);\n    vec3 mxclr = vec3(0);\n    mxclr = mix(vec3(0), yel, inv(inv(mult) * rnd));\n    \n    col = mix(mxclr, yel, (length(uv) / R));\n    //cont_rand(cont_rand(uv, seed), seed).x;\n    col *= 1. - smoothstep(R - 0.01, R, length(uv));\n    return col;\n}*/\n\n\nfloat circ(vec2 uv, vec2 cen, float r, float thick){\n    return 1. - smoothstep(0., thick, abs(r - length(uv - cen)));\n}\n\n\n    #define PI 3.14159265359\n    #define centR 0.1\n    #define k 0.4\n    #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2 getcent(float indx, float indy){\n    indx += N21(vec2(indx, indy)) * 0.2;\n    vec2 cent = vec2(centR + (indy + 0.5) / 7., 0.);\n    float agl = (indy + 0.5) / 7. / k;\n    cent *= rot(agl);\n    agl = 2. * PI / 12. * -(indx + 0.5);\n    cent *= rot(agl);\n    return cent;\n}\n\n/*float polargreed(vec2 uv){\n    float ans = 0.;\n    //uv *= 3.;\n    float len = length(uv);\n    if (len < centR){\n        return 0.;\n    }\n    //vec2 pv1 = vec2(atan(uv.y, uv.x) / 6.2831 + 0.5 + pow(len, 0.5) / 5., len);\n    vec2 pv = vec2(-atan(-uv.y, -uv.x) / (2. * PI) + 0.5 + (len - centR) * k, len);\n    float indx = floor(mod(pv.x, 1.) * 12.);\n    float indy = floor((len - centR) * 7.);\n    \n    //return abs(1. / 14. - length(uv - cent))*10.;\n    //return 1. - length(uv - cent)*10.;\n    \n    for (float i = -1.; i <= 1.; i++){\n        for (float j = -1.; j <= 1.; j++){\n            ans = max(ans, circ(uv, getcent(indx + i, indy + j), 0.07, 0.01));\n        }\n    }\n    //return circ(uv, cent, 0.07, 0.01);\n    return (1. - ans) * fract((len - centR) * 7.);\n    return indy * indx / 7. / 12.;//ind / 12. * fract((len - centR) * 7.);\n    if (fract(pv.x * 12.) < 0.1){\n        return 1.;\n    } else {\n        return 0.;\n    }\n    return abs(pv.x), 0.1;\n    //float m = min(fract(x), fract(1. - x));\n    //ans = smoothstep(0., 0.1, m * 0.5 + .2 - pv.y);\n    float m;\n    //float dst = abs(fract(pv1.x * 23.) - 0.5) * 2.;\n    //dst = min(dst, abs(fract(pow(len, 0.7) * 7. + iTime) - 0.5) * 2.);\n    //m = fract(pv1.x * 23.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    //m = fract(sqrt(len) * 7.);\n    //ans = max(ans, 1. - smoothstep(0., 0.1, abs(m - 0.5)));\n    //ans = dst;//max(ans, 1. - smoothstep(0., 0.1, dst));\n    return ans;\n}*/\n\n    #define N (7.)\n    #define R 0.1\n\nfloat sectorsAmount(float indy, float Num){\n    return floor((2. * PI * (indy / Num + centR) / R));\n}\n\nvec2 getCntr(float indx, float indy){\n    vec2 ans = vec2(indy + 0.5, 0.);\n    ans /= N;\n    ans.x += centR;\n    float agl = (indx + 0.5) / sectorsAmount(indy, N) * 2. * PI;\n  \tans *= rot(agl);\n    ans += (N21(vec2(indx + fract(floor(iTime * 3.) * 1.42), indy + fract(floor(iTime * 3.) * 4.25))) - 0.5) * 0.02;\n    return ans;\n}\n\nfloat anotherone(vec2 uv){\n    float ans = 0.;\n    uv *= 3.;\n    float len = length(uv);\n    if (len < centR){\n        return 0.;\n    }\n    //vec2 pv1 = vec2(atan(uv.y, uv.x) / 6.2831 + 0.5 + pow(len, 0.5) / 5., len);\n    float indy = floor((len - centR) * N);\n    vec2 pv = vec2(atan(-uv.y, -uv.x) / (2. * PI) + 0.5, len);\n    //float indx = floor(mod(pv.x, 1.) * 12.);\n    //indy += centR;\n    float sctrsAmount = sectorsAmount(indy, N);\n    float indx = floor(mod(pv.x, 1.) * sctrsAmount);\n    //return indx / sctrsAmount;\n    return 1. - circ(uv, getCntr(indx, indy), 0.13, 0.1);\n    //indy -= centR;\n    //return abs(1. / 14. - length(uv - cent))*10.;\n    //return 1. - length(uv - cent)*10.;\n    \n    for (float i = -1.; i <= 1.; i++){\n        for (float j = -1.; j <= 1.; j++){\n            ans = max(ans, circ(uv, getcent(indx + i, indy + j), 0.07, 0.01));\n        }\n    }\n    return (1. - ans) * fract((len - centR) * 7.);\n    return ans;\n}\n\nvec3 petal(vec2 beg, vec2 end, vec2 uv){\n    vec2 lv = uv;\n    lv -= beg;\n    end -= beg;\n    beg -= beg;\n    lv /= length(end);\n    //end /= length(end);\n    float agl = -atan(end.y, end.x);\n    lv *= rot(agl);\n    //end *= rot(-atan(end.y, end.x));\n    //if (abs(end.x - 1.)< 0.01){\n    //    return vec3(1.);\n   \t//}\n    if (lv.x < 0. || lv.x > 1.) return vec3(0.);\n    float t = 0.;\n    float bord = min(\n        1. / (-50. * lv.x), \n        1. / (50. * (lv.x - 1.))\n    ) + 0.3;\n    bord *= 0.7;\n    t = smoothstep(0., 0.1, bord - abs(lv.y));\n    //if (-(lv.x - 1.) * lv.x > abs(lv.y)){\n//        return vec3(1.);\n  //  }\n    return vec3(t);\n}\n\n#define needperpetal 0.13\n\nvec3 getPet(float indx, vec2 uv){\n    //float needperpetal = 0.13;\n    float amou = floor((innerR + 0.1) * 2. * PI / needperpetal);\n    vec2 beg = vec2(innerR, 0.);\n    float agl = (indx + 0.5) / amou * 2. * PI; \n    beg *= rot(agl);\n    vec2 end = beg * 5.;\n    agl = N21(vec2(indx * .6235, indx * .241)) * 0.1;\n    end *= rot(agl);\n    return petal(beg, end, uv);\n}\n\nvec3 petalzz(vec2 uv){\n    float len = length(uv);\n    if (len < (innerR + 0.1)) return vec3(0.);\n    vec2 pv = vec2(atan(-uv.y, -uv.x) / (2. * PI) + 0.5, len);\n    float amou = floor((innerR + 0.1) * 2. * PI / needperpetal);\n    float indx = floor(pv.x * amou);\n    \n    vec3 ans = vec3(0.);\n    for (float i = -1.; i <= 1.; i++){\n        ans = max(ans, getPet(indx + i, uv));\n        //ans = max(ans, vec3(0));\n   \t}\n    return ans;\n    //return vec3(indx / amou);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    vec3 col = vec3(0.);\n    \n    \n    if (length(uv) < innerR + 0.1){\n        vec3 yel = vec3(255., 207., 13.) / 256.;\n    \tcol = vec3(mix(vec3(0), yel, anotherone(uv)));\n    }\n    if (length(col) < 0.01){\n        //vec2 b = vec2(innerR, 0.);\n        //b *= rot(0.5);\n        //col = petal(b, b * 5., uv);\n        col = petalzz(uv);        \n    }\n    //vec3 yel = vec3(1., 0.64, 0.);\n    \n    if (length(uv) < 0.01){\n        col = vec3(.24, .52, .25);\n    }\n    \n    //col = vec3(circGrid(uv / (length(uv) + 0.3) * 10., 0., 0.1));\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //col = vec3(thisrand(uv, iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}