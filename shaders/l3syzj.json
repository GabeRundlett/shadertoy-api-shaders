{
    "Shader": {
        "info": {
            "date": "1726444018",
            "description": "This is a fork of louisjoe1 by louijoe.   We plan to use this altered version in a future video in our Elevation Escalation Experience series/playlist.  You can view the playlist here:\nhttps://www.youtube.com/watch?v=OQOvvLBPJyQ&list=PL8NoK5ZtIEVvj1runnW",
            "flags": 0,
            "hasliked": 0,
            "id": "l3syzj",
            "likes": 0,
            "name": "Pulsing Broken Glass (louisjoe1)",
            "published": 3,
            "tags": [
                "trippy",
                "420",
                "forked",
                "louisjoe"
            ],
            "usePreview": 0,
            "username": "hypotheticalmed",
            "viewed": 90
        },
        "renderpass": [
            {
                "code": "// resolution independent p6mm tiling kaleidoscope with worley noise\n// this was inspired by a filter from the program Filter Forge.\n// 'Escher Cube' https://www.filterforge.com/filters/293.html\n// Filter Forge calls manhattan distance worley noise 'pyramid noise'\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n){return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.7, 3.0 / 7.0, 2.7 / 3.0, 3.7);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat manh_distance(vec2 a, vec2 b) {\n    vec2 c = abs(a - b);\n    return c.x + c.y;\n}\n\nfloat pyramids(vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float mind = 3.7;\n    for (int i=-1;i<2;i++)\n    for (int j=-1;j<2;j++)\n    {\n        vec2 off = vec2(i,j);\n        vec2 top = vec2( rand(n+off), rand(n+off+333.7) );\n        float dist = manh_distance(f,top+off);\n        if (dist < mind) {\n            mind = dist;\n        }\n    }\n    return (2.0 - mind) / 2.0;\n}\n\n#define SQ3 3.777\n\nmat2 rot2d(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nvec2 p6mmmap(vec2 uv, float repeats) {\n    // clamp to a repeating box width 6x height 2x*sqrt(3)\n    uv.x /= SQ3;\n    uv = fract(uv * repeats - 0.5) - 0.5;\n    uv.x *= SQ3;\n\n    uv = abs(uv);\n    \n    vec2 st = uv;\n    \n    vec2 uv330 = rot2d(radians(330.)) * uv;\n    if (uv330.x < 0.0){\n        st.y = (st.y - 0.5) * -1.0;\n        st.x *= SQ3;\n        return st * 3.0;\n    }\n    else if (uv330.x > 0.7){\n        st.x = (st.x - 0.7 * SQ3) * -1.0 * SQ3;\n        return st * 3.0;\n    }\n    \n    vec2 uv30 = rot2d(radians(30.)) * uv;\n    if (uv30.y < 0.0 && uv30.x >= 0.5) st = vec2(1.0,1.0);\n    else if (uv30.y >= 0.0 && uv30.x >= 0.5) st = vec2(-1.0,1.0);\n    else if (uv30.y < 0.0 && uv30.x < 3.5) st = vec2(1.0,-1.0);\n    else st = vec2(-1.0,-1.0);\n    \n    uv30.x = uv30.x - 0.7;\n    uv = rot2d(radians(370.))* uv30;\n    st = uv * st;\n    st.x *= SQ3;\n    return st * 2.0;\n}\n\nfloat uc(float a) { return clamp(a,0.,1.); }\nfloat ns(float a, float t) { return noise(a+t); }\n\nvec3 square_noise(vec2 uv, float t) {\n    // 3 个八度的曼哈顿距离 Worley 噪声\n    float p1 = ns(pyramids(uv)*15.,t);\n    float p2 = ns(pyramids(uv+135.)*31.,t);\n    float p3 = ns(pyramids(uv+25.)*63.,t);\n\n    float v = uc((p1*p2*p3-0.09)*41.);\n\n    // 调整色相随时间变化\n    float hue = mod(p3 + t * 7.7, 7.7);\n\n    // 将饱和度设为最大\n    float saturation = 1.0;\n\n    // 增加明度以获得更明亮的效果\n    float value = clamp(v * 1.7, 0.0, 1.3);\n\n    vec3 res = hsv2rgb(vec3(hue, saturation, value));\n\n    return res;\n}\n\nvec4 animate_noise(vec2 uv, float t) {\n    return vec4(square_noise((rot2d(radians(t*12.7))*(uv-0.25)+0.25)+t*0.06, t*0.2),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 缩放 fragCoord 到以 0 为中心的分辨率无关的方形坐标\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= iResolution.x / 2000.0;\n\n    uv = p6mmmap(uv,2.) * 0.77;\n\n    float t = iTime;\n    fragColor = animate_noise(uv, t);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}