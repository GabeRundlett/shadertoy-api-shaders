{
    "Shader": {
        "info": {
            "date": "1457315759",
            "description": "Screen space parallel lines intersection (vanishing point) is used in order to compute a world space parallelogram. One of the basic principles of automated 3D scene reconstruction. Only a screen space quad input required (3D position is inferred).",
            "flags": 0,
            "hasliked": 0,
            "id": "MscSRr",
            "likes": 68,
            "name": "PerspectiveReprojection",
            "published": 3,
            "tags": [
                "3d",
                "perspective",
                "reprojection",
                "vanishingpoint"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 2919
        },
        "renderpass": [
            {
                "code": "// Author : Sebastien Berube\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// This shader uses the vanishing point on the image plane in order to infer the world space direction of parallel lines.\n// From 4 points (2D) on the image plane, it will use projective geometry properties in order to generate 4 points (3D) world space.\n// \n// This is a very important concept for 3D scene reconstruction from 2D images.\n//\n// The one line that is important in this shader is : \"p1_to_p2 = dirVanishingPoint\", in function \"resolveAdjacentCorner()\".\n// What this means is : the 3D line starting from the camera center and going towards the vanishing point of 2 parallel lines \n//                      are all parallel with each other (as all lines directed towards this vanishing point are parallel).\n//                      Although parallel lines are nerver supposed to cross each other in reality, they however do on the \n//                      projected image plane, and this allows computation of the vanishing point intersection in 2D first,\n//                      and then inferring 3D direction by casting a ray from the camera center through this vanishing point\n//                      on the image plane.\n//\n// License : Creative Commons Non-commercial (NC) license\n//\nconst vec2 SS1_BOTTOM_LEFT  = vec2( 0.180, 0.320);\nconst vec2 SS1_BOTTOM_RIGHT = vec2( 0.332, 0.360);\nconst vec2 SS1_TOP_RIGHT    = vec2( 0.332, 0.640);\nconst vec2 SS1_TOP_LEFT     = vec2( 0.180, 0.766);\n\nconst vec2 SS2_BOTTOM_LEFT  = vec2( 0.820, 0.343);\nconst vec2 SS2_BOTTOM_RIGHT = vec2( 0.970, 0.33);\nconst vec2 SS2_TOP_RIGHT    = vec2( 0.965, 0.745);\nconst vec2 SS2_TOP_LEFT     = vec2( 0.815, 0.675);\n    \nstruct Cam { vec3 R; vec3 U; vec3 D; vec3 O;}; //R=Right, U=Up, D=Direction, O=Origin\nCam    CAM_lookAt(vec3 target, float pitchAngleRad, float dist, float theta);\nCam    CAM_mouseLookAt(vec3 at, float dst);\n\n//Function to cast a ray through a given coordinate (uv) on the image plane.\n//It returns the direction of a 3D Ray.\n//Note : screen center is uv=[0,0]\nvec3 ray(vec2 uv, Cam cam)\n{\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\n//Function which does the opposite of the previous function:\n//It receives a 3D world space position, then flattens it on the image plane \n//and returns its [uv] coordinates.\n//Note : screen center is uv=[0,0]\nvec2 camProj(Cam c, vec3 p)\n{\n    p = p-c.O;\n    float cZ = dot(p,c.D);\n    float cX = dot(p,c.R);\n\tfloat cY = dot(p,c.U);\n    return vec2(cX/cZ,cY/cZ);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//Utility function returning the intersection point of two 2D lines\n//[p1a,p1b] = line1\n//[p2a,p2b] = line1\nvec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)\n{\n    vec2 d1 = (p1b-p1a); //Direction Line 1\n    vec2 d2 = (p2b-p2a); //Direction Line 2\n    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere\n    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance\n    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)\n    float t = 10000000.0 ; //INFINITY! (rare parallel case)\n    if(rate != 0.0)\n\t\tt = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.\n    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.\n}\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray to the plane intersection.\n//o = ray origin\n//d = ray direction\n//po = plane origin\n//pn = plane normal\nfloat rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) \n{\n    //Same principle as lineLineIntersection() :\n    //\"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(po-o,pn)/dot(d,pn);\n}\n\nstruct screenSpaceQuad{ vec2 a; vec2 b; vec2 c; vec2 d; };\nstruct worldSpaceQuad{  vec3 a; vec3 b; vec3 c; vec3 d; };\n\n//perspectiveCam : the camera from which the points in screen space come from\n//P1 : known world space position of p1\n//p1 : screen space p1 (which is resolved, already)\n//p2 : screen space p2 (which must be adjacent to p1 - cannot be the opposite corner)\n//parallel_a : first point (screen space) in the other line parallel to (p1,p2)\n//parallel_b : second point (screen space) in the other line parallel to (p1,p2)\nvec3 resolveAdjacentCorner(in Cam perspectiveCam, vec3 P1, vec2 p1_resolved, vec2 p2_adjacent, vec2 parallel_a, vec2 parallel_b)\n{\n    //screen space intersection (vanishing point on the projection plane)\n    vec2 ssIntersec = lineLineIntersection(p1_resolved,p2_adjacent,parallel_a,parallel_b);\n    //Vanishing point direction, from camera, in world space.\n    vec3 dirVanishingPoint = ray(ssIntersec, perspectiveCam);\n    vec3 p1_to_p2 = dirVanishingPoint; //Since vanishing point is at \"infinity\", p1_to_p2 == dirVanishingPoint\n    vec3 r2 = ray(p2_adjacent, perspectiveCam);//Ray from camera to p2, in world space\n    \n    //<Line3D intersection : where p1_to_p2 crosses r2>\n    //(Note : this could probably be made simpler with a proper 3D line intersection formula)\n    //Find (rb,p1_to_p2) intersection:\n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2); //normal to the triangle formed by point p1, point p2 and the camera origin\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2); //normal to the plane which is crossed by line p1-p2 at point p2\n    float t = rayPlaneIntersec(P1,p1_to_p2,perspectiveCam.O,n_plane_p2);\n    vec3 p2_ws = P1+t*p1_to_p2;\n    //</Line3D intersection>\n    return p2_ws;\n}\n    \n//Finds each corner, one by one.\nvoid resolvePerspective(in Cam perspectiveCam, in screenSpaceQuad ssQuad, out worldSpaceQuad wsQuad)\n{\n    vec3 ra = ray(ssQuad.a, perspectiveCam); //Find the direction of the ray passing by point a in screen space.\n\t                                      //For the sake of simplicity, screenspace [uv.x,uv.y] = worldspace [x,y]. Z = depth.\n    //Let's place point a in an arbitrary position along the ray ra. \n    //It does not matter at which distance exactly, as it is the relationship between\n    //the corners that is important. The first corner distance simply defines the scaling of the 3D scene.\n    wsQuad.a = perspectiveCam.O + 5.5*ra; //5.5 = arbitrary scaling. Projective geometry does not preserve world space scaling.\n    wsQuad.b = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.b, ssQuad.c, ssQuad.d);\n    wsQuad.c = resolveAdjacentCorner(perspectiveCam, wsQuad.b, ssQuad.b, ssQuad.c, ssQuad.a, ssQuad.d);\n    wsQuad.d = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.d, ssQuad.b, ssQuad.c);\n}\n\nvec3 apply_atmosphere(float travelDist, in vec3 color, in vec3 p)\n{\n    //From this nice article on fog:\n    //https://iquilezles.org/articles/fog\n    //or this PowerPoint from Crytek:\n\t//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17\n\tvec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));\n    float c = 1.08;\n    float b = 0.06;\n\n    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;\n    cumul_density = clamp(cumul_density,0.0,1.0);\n    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);\n    return FinalColor;\n}\n\nvec3 alphaBlend(vec3 c1, vec3 c2, float alpha)\n{\n    return mix(c1,c2,clamp(alpha,0.0,1.0));\n}\n\nvec2 pixel2uv(vec2 px, bool bRecenter, bool bUniformSpace)\n{\n    if(bRecenter)\n    {\n        px.xy-=iResolution.xy*0.5;\n\t}\n    \n    vec2 resolution = bUniformSpace?iResolution.xx:iResolution.xy;\n    vec2 uv = px.xy / resolution;\n    return uv;\n}\n\nvec3 drawPoint(vec2 uv, vec2 point, vec3 cBack, vec3 cPoint, float radius, float fZoom)\n{\n    radius /= fZoom;\n    float distPt = length(uv-point);\n    float alphaPt = 1.0-smoothstep(radius-.003/fZoom,radius,distPt);\n    return alphaBlend(cBack,cPoint,alphaPt);\n}\n\nvec3 drawLine(vec2 uv, vec2 pa, vec2 pb, vec3 cBack, vec3 cLine, float radius, float fZoom)\n{\n    radius /= fZoom;\n    float distLine = distanceToLineSeg(uv,pa,pb);\n    float alphaLine = 1.0-smoothstep(radius-.003/fZoom,radius,distLine);\n    return alphaBlend(cBack,cLine,alphaLine);\n}\n\n//wsQuad.a = origin (lower left corner)\n//wsQuad.a,b,c,d = CCW point order.\nvec2 findParallelogramUV(vec3 o, vec3 d, worldSpaceQuad wsQuad)\n{\n    //Note : This is tricky because axis are not orthogonal.\n    vec3 uvX_ref = wsQuad.b-wsQuad.a; //horitonal axis\n    vec3 uvY_ref = wsQuad.d-wsQuad.a; //vertical axis\n    vec3 quadN = cross(uvY_ref,uvX_ref);\n    float t = rayPlaneIntersec(o, d, wsQuad.a, quadN);\n        \n    vec3 p = o+t*d;\n    vec3 X0_N = cross(uvY_ref,quadN);\n    vec3 Y0_N = cross(uvX_ref,quadN);\n    \n    //Vertical component : find the point where plane X0 is crossed\n    float t_x0 = rayPlaneIntersec(p, uvX_ref, wsQuad.a, X0_N);\n    vec3 pY = p+t_x0*uvX_ref-wsQuad.a;\n    //Horizontal component : find the point where plane Y0 is crossed\n    float t_y0 = rayPlaneIntersec(p, uvY_ref, wsQuad.a, Y0_N);\n    vec3 pX = p+t_y0*uvY_ref-wsQuad.a;\n    \n    //All is left to find is the relative length ot pX, pY compared to each axis reference\n    return vec2(dot(pX,uvX_ref)/dot(uvX_ref,uvX_ref),\n\t            dot(pY,uvY_ref)/dot(uvY_ref,uvY_ref));\n}\n\nvec3 drawPerspectiveScene(Cam perspectiveCam, vec2 uv, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, vec3 cBackground, float fZoom)\n{\n    vec3 cScene = cBackground;\n    cScene = texture(iChannel0,uv+0.5).xyz;\n    \n\tfloat fLineWidth = 0.0025;\n    cScene = drawLine(uv, ssQuad.a, ssQuad.b, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.b, ssQuad.c, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.c, ssQuad.d, cScene, vec3(0), fLineWidth, fZoom);\n    cScene = drawLine(uv, ssQuad.d, ssQuad.a, cScene, vec3(0), fLineWidth, fZoom);\n    \n    float fPointRad = 0.006;\n    cScene = drawPoint(uv, ssQuad.a, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.b, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.c, cScene, vec3(0,1,0), fPointRad, fZoom);\n    cScene = drawPoint(uv, ssQuad.d, cScene, vec3(0,1,0), fPointRad, fZoom);\n    \n    //Show results\n    fPointRad = 0.004;\n    vec2 aDebug = camProj(perspectiveCam,wsQuad.a);\n    vec2 bDebug = camProj(perspectiveCam,wsQuad.b);\n    vec2 cDebug = camProj(perspectiveCam,wsQuad.c);\n    vec2 dDebug = camProj(perspectiveCam,wsQuad.d);\n    cScene = drawPoint(uv, aDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, bDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, cDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    cScene = drawPoint(uv, dDebug, cScene, vec3(0,0,1), fPointRad, fZoom);\n    \n    return cScene;\n}\n\nCam setupPerspectiveCamera()\n{\n    Cam cam;\n    cam.O = vec3(0,0,0);\n    cam.R = vec3(1,0,0);\n    cam.U = vec3(0,1,0);\n    cam.D = vec3(0,0,-1);\n    return cam;\n}\n\nscreenSpaceQuad setupPerspectiveQuad(vec2 mouse_uv)\n{\n    screenSpaceQuad ssQuad;\n    \n    //Arbitrary screen-space parallelograms.\n    if(fract(iTime/4.0)> 0.5)\n    {\n        ssQuad.a = SS1_BOTTOM_LEFT-0.5;\n    \tssQuad.b = SS1_BOTTOM_RIGHT-0.5;\n    \tssQuad.c = SS1_TOP_RIGHT-0.5;\n    \tssQuad.d = SS1_TOP_LEFT-0.5;\n    }\n    else\n    {\n     \tssQuad.a = SS2_BOTTOM_LEFT-0.5;\n    \tssQuad.b = SS2_BOTTOM_RIGHT-0.5;\n    \tssQuad.c = SS2_TOP_RIGHT-0.5;\n    \tssQuad.d = SS2_TOP_LEFT-0.5;   \n    }\n    \n    if(iMouse.z > 0.0 && mouse_uv.x < 0.5 && mouse_uv.y < 0.5) //if mouse btn down\n    {\n\t\tssQuad.d = mouse_uv;\n    }\n    \n    return ssQuad;\n}\n\nvec2 inversePerspective_uv(Cam perspectiveCam, vec2 uv_01, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad )\n{\n    vec3 x_ws = wsQuad.b-wsQuad.a;\n    vec3 y_ws = wsQuad.d-wsQuad.a;\n    vec3 p_ws = wsQuad.a+uv_01.x*x_ws + uv_01.y*y_ws;\n    vec2 puv = camProj(perspectiveCam,p_ws);\n\treturn puv;\n}\n\nCam setupSceneCamera()\n{\n    float targetDistance = 10.5;\n    vec3 cam_tgt = vec3(0,0,-3.0);\n    Cam cam = CAM_lookAt(cam_tgt, -0.2, targetDistance, -0.75+iTime*0.1);\n    if(iMouse.xz != vec2(0.0,0.0) && ( iMouse.x > iResolution.x/4.0 || iMouse.y > iResolution.y/4.0) ) //Mouse button down : user control\n    {\n    \tcam = CAM_mouseLookAt(cam_tgt, targetDistance);\n    }\n    return cam;\n}\n\nvec3 draw3DScene(Cam perspectiveCam, Cam sceneCam, vec2 uv, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad)\n{\n    vec3 o = sceneCam.O;\n    vec3 d = ray(uv,sceneCam);\n    \n    vec3 cScene = vec3(0);\n    \n    float t = rayPlaneIntersec(o,d, vec3(0,-1.0,0), vec3(0,1,0));\n    if(t<0.0)\n    {\n        t = 1000.0;\n        cScene = apply_atmosphere(t,vec3(1),o+t*d);\n    }\n    else\n    {\n\t\tvec3 pFloor = o+t*d;\n    \tvec3 cFloor = texture(iChannel1,pFloor.xz*0.25).xyz;\n    \tcScene = apply_atmosphere(t,cFloor,pFloor);\n    }\n    \n    float fZoom = 3.0*iResolution.x/1920.;\n    vec2 aDebug = camProj(sceneCam,wsQuad.a);\n    vec2 bDebug = camProj(sceneCam,wsQuad.b);\n    vec2 cDebug = camProj(sceneCam,wsQuad.c);\n    vec2 dDebug = camProj(sceneCam,wsQuad.d);\n    vec2 oDebug = camProj(sceneCam,perspectiveCam.O);\n    cScene = drawPoint(uv,aDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,bDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,cDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,dDebug,cScene,vec3(1,0,0),0.005, fZoom);\n    cScene = drawPoint(uv,oDebug,cScene,vec3(0,0,1),0.005, fZoom);\n    cScene = drawLine(uv,aDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,bDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,cDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,dDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);\n    cScene = drawLine(uv,aDebug,bDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,bDebug,cDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,cDebug,dDebug,cScene,vec3(0),0.0025, fZoom);\n    cScene = drawLine(uv,dDebug,aDebug,cScene,vec3(0),0.0025, fZoom);\n    \n    //Projection Plane (camera near plane)\n    float tImage = rayPlaneIntersec(o,d, perspectiveCam.O+normalize(perspectiveCam.D), perspectiveCam.D);\n    if(tImage>0.0) //tImage < 0 when the ray never intersects the floor plane (intersection happens behind camera)\n    {\n        vec3 pImage = o+tImage*d;\n        vec2 uv = camProj(perspectiveCam,pImage);\n        \n        if(abs(uv.x)<0.5 && abs(uv.y)<0.5*iResolution.y/iResolution.x)\n        {\n            vec3 cPersp = drawPerspectiveScene(perspectiveCam, uv, ssQuad, wsQuad, vec3(0.55), fZoom*0.1);\n            cScene = alphaBlend(cScene,cPersp,0.5);\n        }\n    }\n    \n    //\n    vec3 nQuad = cross((wsQuad.b-wsQuad.a),(wsQuad.d-wsQuad.a));\n    float tQuad = rayPlaneIntersec(o,d, wsQuad.a, nQuad);\n    if(tQuad>0.0) //tQuad < 0 when the ray never intersects the floor plane (intersection happens behind camera)\n    {\n        vec2 uv = findParallelogramUV(o,d,wsQuad);\n        if(uv.x>0.0 && uv.x<1.0 &&\n           uv.y>0.0 && uv.y<1.0 )\n        {\n            vec2 tuv = inversePerspective_uv(perspectiveCam, uv, ssQuad, wsQuad);\n        \tvec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*0.25);\n            cScene = alphaBlend(cScene,cTest,0.5);\n        }\n    }\n    \n    return cScene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float perspectiveImageSize = 0.25;\n    float fZoom = 3.0*iResolution.x/1920.;\n    \n    vec2 perspective_uv = pixel2uv(fragCoord/perspectiveImageSize, true, true);\n    vec2 perspective_mouse_uv = pixel2uv(iMouse.xy/perspectiveImageSize, true, true);\n\t\n    worldSpaceQuad wsQuad;\n    screenSpaceQuad ssQuad = setupPerspectiveQuad(perspective_mouse_uv);\n    Cam perspectiveCam = setupPerspectiveCamera();\n    resolvePerspective(perspectiveCam,ssQuad,wsQuad);\n    \n    //Perspective view\n    if(fragCoord.x<iResolution.x*perspectiveImageSize && fragCoord.y<iResolution.y*perspectiveImageSize)\n    {\n        vec3 cPerspective = drawPerspectiveScene(perspectiveCam, perspective_uv, ssQuad, wsQuad, vec3(0.55), fZoom*perspectiveImageSize);\n        fragColor = vec4(cPerspective,1.0);\n    }\n    //Inverse view\n    else if(fragCoord.x>iResolution.x*(1.0-perspectiveImageSize) && fragCoord.y<iResolution.y*perspectiveImageSize)\n    {\n        vec2 fragCoordLocal = vec2( fragCoord.x-iResolution.x*(1.0-perspectiveImageSize),fragCoord.y);\n        vec2 inverse_perspective_uv = pixel2uv(fragCoordLocal/perspectiveImageSize, false, false);\n        \n        vec2 tuv = inversePerspective_uv(perspectiveCam, inverse_perspective_uv, ssQuad, wsQuad);\n        vec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*perspectiveImageSize);\n        fragColor = vec4(cTest,1.0);\n    }\n    //3D Scene\n    else\n    {\n        vec2 uvScene = pixel2uv(fragCoord, true, true);\n\t    Cam sceneCam = setupSceneCamera();\n\t    vec3 cScene = draw3DScene(perspectiveCam, sceneCam, uvScene, wsQuad, ssQuad);\n        fragColor = vec4(cScene,1.0);\n    }\n}\n\nCam CAM_lookAt(vec3 at, float fPitch, float dst, float rot) \n{ \n    Cam cam;\n    cam.D = vec3(cos(rot)*cos(fPitch),sin(fPitch),sin(rot)*cos(fPitch));\n    cam.U = vec3(-sin(fPitch)*cos(rot),cos(fPitch),-sin(fPitch)*sin(rot));\n    cam.R = cross(cam.D,cam.U); cam.O = at-cam.D*dst;\n    return cam;\n}\nCam CAM_mouseLookAt(vec3 at, float dst)\n{\n    vec2 res = iResolution.xy; vec2 spdXY = vec2(15.1416,4.0);\n    float fMvtX = (iMouse.x/res.x)-0.535;\n    if(fMvtX>0.3) dst *= (1.0+(fMvtX-0.3)/0.03);\n    else if(fMvtX<-0.3) dst *= (1.0-(fMvtX+0.3)/(-0.2));\n\tfMvtX += iTime*0.0150;//Auto turn\n    return CAM_lookAt(at,spdXY.y*((iMouse.y/res.y)-0.5),dst,spdXY.x*fMvtX);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}