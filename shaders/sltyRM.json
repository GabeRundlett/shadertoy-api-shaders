{
    "Shader": {
        "info": {
            "date": "1659480184",
            "description": "The original 15 marching cubes configurations realized using 8 slopels per cell.\nhttps://en.wikipedia.org/wiki/Marching_cubes#/media/File:MarchingCubes.svg\n\ncamera controls via mouse + shift key",
            "flags": 48,
            "hasliked": 0,
            "id": "sltyRM",
            "likes": 31,
            "name": "Binary Marching Cubes",
            "published": 3,
            "tags": [
                "cubes",
                "marching"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 1019
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    The original 15 marching cubes configurations realized using 8 slopels per case.\n    A slopel is a cube with a part of it cut away by a plane, creating a slope (hence the name).\n    Besides a simple cube only 3 additional slopel types are needed here.\n    \n    For comparison, you can find an image of the original, triangulation based topology here: \n    https://en.wikipedia.org/wiki/Marching_cubes#/media/File:MarchingCubes.svg\n    \n    The configuration all the way at the bottom right is redundant (the one right above it is just a mirrored version).\n    It is also the one configuration where the surface of the slopel based approach is different from the original.\n    \n    The GetSlopelPlane(...) method (Common tab) returns the slopel plane for a given \n    marching cubes configuration and octant id. It can be used either directly or to prepare a lookup table.\n    \n    A raymarching demo using binary marching cubes can found here: https://www.shadertoy.com/view/fttyzM\n    \n    W - toggle wireframe\n    S - toggle shading style\n    \n    camera controls via mouse + shift key\n*/\n\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nbool IntersectMCCell(vec3 rp, vec3 rd, uint data, bvec3 oct, inout vec2 tt, inout vec3 N0)\n{\n    if(data == 0u) return false;\n\n    vec3 N; float D;\n    if(!GetSlopelPlane(data, oct, /*out:*/ N, D)) return false;\n\n    float PdN = dot(rp, N) - D;\n    float DdN = dot(rd, N);\n\n    float t = -1.0/DdN * PdN;\n\n    bool hit = true;\n\n    if(t < 0.0)\n    {\n        hit = PdN < 0.0;\n    }\n    else if(PdN < 0.0)\n    {\n        hit = t >= tt.x;\n    }\n    else\n    if(t > tt.x)\n    {\n        hit = t <= tt.y;\n\n        tt.x = t;\n\n        N0 = N;\n    }\n    \n    return hit;\n}\n\nuint Byte(int bits[8])\n{\n    uint byte = 0u;\n    for(uint i = 0u; i < 8u; ++i)\n        byte |= (uint(bits[i]) & 1u) << i;\n        \n    return byte;\n}\n\nbool VoxelRaycast(vec3 ro, vec3 rd, uint id, out vec3 vp, out vec3 N0, out float t)\n{\n    // the original 15 marching cubes configurations\n    uint data0[5*3] = uint[]\n    (\n        Byte(int[](1, 0, 0, 0, 0, 0, 0, 1)),\n        Byte(int[](1, 0, 0, 0, 1, 0, 0, 1)),\n        Byte(int[](0, 0, 1, 0, 1, 0, 0, 1)),\n        Byte(int[](1, 0, 1, 0, 0, 1, 0, 1)),\n        Byte(int[](1, 1, 0, 0, 0, 1, 0, 1)),\n        \n        Byte(int[](1, 1, 0, 0, 1, 1, 0, 0)),\n        Byte(int[](0, 1, 1, 0, 1, 1, 0, 0)),\n        Byte(int[](1, 0, 0, 1, 0, 1, 1, 0)),\n        Byte(int[](1, 1, 0, 1, 0, 1, 0, 0)),\n        Byte(int[](0, 1, 0, 1, 1, 1, 0, 0)),\n        \n        Byte(int[](0, 0, 0, 0, 0, 0, 0, 0)),\n        Byte(int[](1, 0, 0, 0, 0, 0, 0, 0)),\n        Byte(int[](1, 0, 0, 0, 1, 0, 0, 0)),\n        Byte(int[](1, 0, 0, 0, 0, 0, 1, 0)),\n        Byte(int[](0, 1, 0, 0, 1, 1, 0, 0))\n    );\n    \n    uint data = data0[id];\n        \n    N0 = vec3(0.0);\n    t = 0.0;\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 4; i++) \n\t{\n        vec3 t30 = vp * ri + off;\n\t\t\n        vec3 mm0 = vec3(minmask(t30));\n        \n        uvec3 tc0 = uvec3(ivec3(vp));\n       \n        if(tc0.x >= 2u || tc0.y >= 2u || tc0.z >= 2u) return false;\n\n        uvec3 tc = ((tc0 + 1u) >> 1u) - 1u;\n\n        if(data != 0u)\n        {\n            vec2 tt = vec2(dot(t3 , mm ), \n                           dot(t30, mm0));\n\n            N0 = -rs * mm;\n\n            vec3 rp = ro - (vp + 0.5);\n        \n            bvec3 oct = equal(tc0 & 1u, uvec3(1u));\n        \n            if(IntersectMCCell(rp, rd, data, oct, /*inout*/ tt, N0))\n            {\n                t = tt.x;\n                \n                return true;\n            }\n        }\n       \n        t3 = t30;\n        mm = mm0;\n        \n        vp += mm * rs;\n\t}\n\t\n\tN0 = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n\nvec3 EvalCol(vec3 rd, vec3 p, vec3 n)\n{\n    vec3  fm  = abs(n);\n    float fmc = dot(mix(vec3(1.0), vec3(0.0), equal(fm, vec3(0.0))), vec3(1.0));\n    \n    float wf;\n    {\n        bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n\n        if(fmc != 1.0)\n        {\n            wf = b.x || b.y || b.z ? 0.0 : 1.0;\n        }\n        else\n        {\n            bvec3 l = bvec3(b.y && b.z, b.z && b.x, b.y && b.x);\n            wf = l.x || l.y || l.z ? 0.0 : 1.0;\n        }\n    }\n    \n    float err = 0.0;\n    {\n        bvec3 b = greaterThan(abs(fract(p*0.5) - 0.5), vec3(0.47));\n    \n        if(fmc == 1.0)\n        if((b.x && n.x != 0.0) ||\n           (b.y && n.y != 0.0) ||\n           (b.z && n.z != 0.0)) err = 1.0; \n    }     \n     \n    vec3 c;\n    if(ReadKeyToggle(KEY_S) != 0.0)\n    {\n        c = n * 0.5 + 0.5;\n    }\n    else\n    {\n        c = vec3(0.125);\n        c = vec3(1.0, 0.5, 0.25);\n        \n        if(err == 1.0) c = vec3(1.0, 0.25, 0.5);\n        if(fmc == 2.0) c = vec3(0.5, 0.9, 0.25);\n        if(fmc == 3.0) c = vec3(0.25, 0.5, 1.0);\n    }\n    \n    c *= sqrt(clamp01(-dot(n, rd)));\n   \n    if(ReadKeyToggle(KEY_W) == 0.0)\n    c *= wf;\n    \n    return c;\n}\n\nbool SceneRayCast(vec3 rp, vec3 rd, uint id, out vec3 c, out vec3 n, out vec3 p)\n{\n    p = rp;\n\n    // intersect bounding box\n    vec2 tt; vec3 n0 = vec3(0.0);\n    float res = Intersect_Ray_Cube(rp - vec3(1.0), rd, vec3(1.0 - 1.0/1024.0), /*out:*/ tt);\n\n    if(res == -1.0) { return false; }\n    \n    if(res == 1.0)\n    {\n    \tp += rd * tt.x;\n        \n        n0 = vec3(maxmask(abs(p - 1.0))) * -sign(rd);\n    }\n    \n    float lthr = 0.95;\n    vec3 lcol = vec3(0.6);\n    {\n        bool mA = false;\n        if(res == 1.0)\n        {\n            bvec3 m = greaterThan(abs(p - 1.0), vec3(lthr));\n            mA = m.x && m.y || m.y && m.z || m.z && m.x;\n        }\n\n        if(mA)\n        {\n            n = n0;\n            \n            c = lcol;\n            \n            return true;\n        }\n    }\n    \n    // intersect 2x2x2 slopels setup\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(p, rd, id, /*out:*/ vp, n, t);\n    \n    if(!hit)\n    {\n        p = rp + rd * tt.y;\n        \n        bool mB = false;\n        {\n            bvec3 m = greaterThan(abs(p - 1.0), vec3(lthr));\n            mB = m.x && m.y || m.y && m.z || m.z && m.x;\n        }\n\n        if(mB)\n        {\n            n = n0;\n            \n            c = lcol;\n            \n            return true;\n        }\n        \n        return false;\n    }\n\n    if(n.x == 0.0 && n.y == 0.0 && n.z == 0.0)\n    {\n        n = n0;\n    }\n    \n    n = normalize(n);\n    \n    p += rd * t;\n    \n    c = EvalCol(rd, p, n);\n    \n    return true;\n}\n\n\nvoid GetCameraRay(vec2 uv, sampler2D stateChannel, vec2 pixelCount, out vec3 rp, out vec3 rd, out vec2 tc)\n{\n    vec4 mouseAccu = texelFetch(stateChannel, ivec2(1, 0), 0); \n\n    vec2 ang = vec2(-0.1 * Pi, -Pi * 0.13);\n    ang += mouseAccu.xy * 0.008;\n\n    float focalLen = 4.0;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    rp = -cmat[2] * exp2(3. + mouseAccu.w * 0.02);\n    \n    rp += 1.0;\n    \n    tc = uv * (1.0 / (pixelCount.xx*0.5)) - vec2(1.0, pixelCount.y/pixelCount.x);\n    \n    rd = normalize(cmat * vec3(tc, focalLen));     \n}\n\n\nvec3 EvalSceneCol(vec2 uv)\n{    \n    vec3 col0 = vec3(0.005);  \n    vec3 col = col0;  \n    \n   #if 0\n   \n    vec3 rp, rd; vec2 tc;\n    GetCameraRay(uv, iChannel0, iResolution.xy, /*out*/ rp, /*out*/ rd, /*out*/ tc);\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, 9u, /*out:*/ c, n, p))\n    {\n        col = c;\n    }\n    \n   #else\n   \n    // multi-view setup\n    vec2 count = vec2(5.0, 3.0);\n    vec2 res = iResolution.xy / count;\n    vec2 tc = uv / res;\n    vec2 tcI = floor(tc);\n    vec2 tcF = tc - tcI;\n    \n    uv = tcF * res;\n    uint id = uint(tcI.x + tcI.y * count.x);\n    \n    vec3 rp, rd; vec2 tc0;\n    GetCameraRay(uv, iChannel0, res, /*out*/ rp, /*out*/ rd, /*out*/ tc0);\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, id, /*out:*/ c, n, p))\n    {\n        col = c;\n    }\n    \n   #endif\n   \n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;    \n  \n#if 0\n    // 1 sample\n    col = vec3(EvalSceneCol(uv0));\n#elif 1\n    // 3 samples\n    float count = 3.0;\n    for(float i = 0.0; i < count; ++i) \n    {\n        vec2 off = GetUVOffset(uv, count, i);\n      \n        col += vec3(EvalSceneCol(uv0 + off));\n    }\n    col /= count; \n#endif\n    \n    \n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n\n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n    data: the lower 8 bits hold the values of the binary implicit evaluated at the 8 vertices of the current grid cell\n    oct:  the octant of the current grid cell for which the slopel type is queried\n    \n  out N:  normal of the slopel plane\n  out D:  offset of the slopel plane along its normal from the slopel center\n  \n  return: is octant not empty\n*/\nbool GetSlopelPlane(uint data, bvec3 oct, out vec3 N, out float D)\n{   \n    // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n    uint d = data;\n    d -= (d >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    d = (d & 0x33333333u) + ((d >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    d = (d + (d >> 4u)) & 0xfu;// put count of each 8 bits into those 8 bits  \n    \n    bool flip = d < 5u;\n    \n    if(flip) data = data ^ 0xFFu;\n    \n    if(oct.x) data = ((data & 0x55u) << 1u) ^ ((data & 0xAAu) >> 1u);\n    if(oct.y) data = ((data & 0x33u) << 2u) ^ ((data & 0xCCu) >> 2u);\n    if(oct.z) data = ((data & 0x0Fu) << 4u) ^ ((data & 0xF0u) >> 4u);\n\n    \n    uint m = data;\n    \n    uint my = data & 0x55u;\n    my = (my ^ (my >>  1u)) & 0x33u;\n    my =  my ^ (my >>  2u);\n    m  =  m  ^ (my << 8u);\n    \n    uint mz = data & 0x33u;\n    mz = (mz ^ (mz <<  1u)) & 0x55u;\n    mz =  mz ^ (mz >>  3u);\n    m  =  m  ^ (mz << 16u);\n    \n    \n    // k will contain the quantized interpolation results + some garbage bits\n    uint k = (m | (m >> 1u)) & 0x010101u;// edges\n    \n     // bit counting: https://en.wikipedia.org/wiki/Hamming_weight\n     m -= (m >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n     m = (m & 0x33333333u) + ((m >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    \n    k = k ^ ((m | (m >> 1u)) & 0x020202u);// faces\n    \n    // compact scattered bits\n    k = k ^ (k >> 6u);\n    k = k ^ (k >> 4u);\n    \n    // clean up\n    k = k & 0xCFu;\n    \n    // add the 2 missing bits \n    k = k ^ ((data & 1u) << 4u);// origin\n    // (0 | 0 | k | 0)\n    \n    // expand to 4 blocks\n    k = k ^ (k <<  8u);\n    k = k ^ (k << 16u);\n    // (k | k | k | k)\n    \n    // apply bit flips \n    k = k ^ 0xDF37F17Cu;\n    // (D | N.z | N.y | N.x)\n    \n    // counts bits in each byte block (https://en.wikipedia.org/wiki/Hamming_weight)\n    k -= (k >> 1u) & 0x55555555u;// put count of each 2 bits into those 2 bits\n    k = (k & 0x33333333u) + ((k >> 2u) & 0x33333333u);// put count of each 4 bits into those 4 bits \n    k = (k + (k >> 4u)) & 0x0f0f0f0fu;// put count of each 8 bits into those 8 bits  \n    \n    \n    uvec3 N0 = (uvec3(k) >> uvec3(0u, 8u, 16u)) & uvec3(0xFu);\n\n#if 1\n    N0 -= 4u;\n    \n    N = vec3(N0.x == 0u ? 0.0 : 1.0,\n             N0.y == 0u ? 0.0 : 1.0,\n             N0.z == 0u ? 0.0 : 1.0);\n\n    if(oct.x != flip != ((N0.x & 0x80000000u) == 0u)) N.x = -N.x;\n    if(oct.y != flip != ((N0.y & 0x80000000u) == 0u)) N.y = -N.y;\n    if(oct.z != flip != ((N0.z & 0x80000000u) == 0u)) N.z = -N.z;\n#else\n    N = vec3(N0.x < 4u ? 1.0 : N0.x > 4u ? -1.0 : 0.0,\n             N0.y < 4u ? 1.0 : N0.y > 4u ? -1.0 : 0.0,\n             N0.z < 4u ? 1.0 : N0.z > 4u ? -1.0 : 0.0);\n\n    if(oct.x != flip) N.x = -N.x;\n    if(oct.y != flip) N.y = -N.y;\n    if(oct.z != flip) N.z = -N.z;\n#endif\n\n    float count = abs(N.x) + abs(N.y) + abs(N.z);\n\n    if(count < 2.0) N.x = 1.0;\n\n    uint D0 = k >> 24u;\n    {\n        uint th = count == 3.0 ? 4u : 2u;\n\n        float v2 = D0 > 2u ? -0.5 : 0.5;\n\n        if(count  < 2.0) v2 = 128.0;\n        if(count == 2.0) v2 = 0.0;\n\n        D = D0 > th ? -128.0 : v2;\n    }\n    \n    if(flip) \n    { \n        D = -D; \n    }\n    \n    return D > -128.0;\n}\n\n\nvec4 GetMCLookupEntry(uvec2 uv)\n{\n    uint data = uv.x;\n    bvec3 oct = equal((uv.yyy >> uvec3(0u, 1u, 2u)) & 1u, uvec3(1u));\n    \n    vec3 N; float D;\n    GetSlopelPlane(data, oct, /*out*/ N, D);\n    \n    return vec4(N, D);\n}\n\nbool ReadMCLookupEntry(sampler2D sampler, uint data, bvec3 oct, out vec3 N, out float D)\n{\n    uvec2 uv;\n    uv.x = data;\n    uv.y = (oct.x ? 1u : 0u) | (oct.y ? 2u : 0u) | (oct.z ? 4u : 0u);\n    \n    vec4 res = texelFetch(sampler, ivec2(uv), 0);\n    \n    N = res.xyz;\n    D = res.w;\n    \n    return D > -128.0;\n}\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nvec3 GammaDecode(vec3 x) {return pow(x, vec3(      2.2));}   \nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nbvec3 maxmask(vec3 v)\n{\n    bool x = v.x >  v.y && v.x >  v.z;\n    bool y = v.y >= v.z && v.y >= v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n\nbvec3 minmask(vec3 v)\n{\n    bool x = v.x <= v.y && v.x <= v.z;\n    bool y = v.y <  v.z && v.y <  v.x;\n    bool z = !x && !y;\n    \n    return bvec3(x, y, z);\n}\n\n\n// https://www.shadertoy.com/view/3tdBWM\nvec2 GetUVOffset(vec2 uv, float count, float smplNum)\n{\n    uvec2 uvi = uvec2(uv);\n\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n    if(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    float i = smplNum;\n    \n    float ang = (Pi*(2.0/count)) * (i+u);\n\n    vec2 off = vec2(cos(ang), sin(ang));\n\n    float l = float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n    \n    return off * l;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// persistent state stuff\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n\n    if(uv.y >= 1.0) discard;\n    \n    vec4 iMouseLast      = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast  = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast    = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool ctrl  = texelFetch(iChannel1, ivec2(17, 0), 0).x != 0.0;\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    \n    if(ctrl) cond0 = false;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}