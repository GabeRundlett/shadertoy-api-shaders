{
    "Shader": {
        "info": {
            "date": "1715608612",
            "description": "This was supposed to be 'botanical' themed for #WCCChallenge but I somehow ended up with a slow, glitchy city ü§∑‚Äç‚ôÄÔ∏è \nHappens",
            "flags": 0,
            "hasliked": 0,
            "id": "lcySWW",
            "likes": 7,
            "name": "Fracture city",
            "published": 3,
            "tags": [
                "raymarching",
                "city",
                "fracture"
            ],
            "usePreview": 0,
            "username": "Alie",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "#define r2d(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\nvec3 norm(vec3 p);\n\nvec3 hash(vec3 p) {\n    p = fract(p * vec3(443.897,441.423,437.195));\n\tp += dot(p, p.yxz + 19.19);\n\treturn fract((p.xxy + p.yxx) * p.zyx);\n}\n\nmat3x3 pointToVectorAligned(vec3 dir) {\n\tvec3 tangent = cross(vec3(0,-1,0), dir);\n\tvec3 biTangent = cross(tangent, dir);\n\t\n\treturn mat3x3(\n\t\t\ttangent,\n\t\t\tbiTangent,\n\t\t\tdir\n\t\t\t);\n}\n\nfloat box(vec3 p, vec3 o, vec3 b, float r) {\n  vec3 q = abs(p - o) - b + r;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r;\n}\n\nfloat line(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length( pa - ba*h ) - r;\n}\n\nfloat fdist(vec3 p) {\n    p.y += sin(p.x / 3. + sin(p.z / 3.)) / 1.;\n    return p.y;\n}\n\nvec3 fnorm(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n        fdist(p+e.xyy) - fdist(p-e.xyy),\n        fdist(p+e.yxy) - fdist(p-e.yxy),\n        fdist(p+e.yyx) - fdist(p-e.yyx)\n    ));\n}\n\nfloat df(vec3 p) {\n    r2d(p.xz, floor(p.y));\n    float d = 1000.;\n    for (int i=0; i<10; i++) {\n        d = min(d, fdist(p));\n        vec3 fp = floor(p);\n        vec3 k = hash(fp) - .5, n = vec3(0);\n        if (fdist(fp) < 0.5) {\n            n = fnorm(fp);\n        }\n        p.xz += k.xz*8.;\n        p -= n * vec3(2,.25,2);\n        r2d(p.xz, k.y + fp.x);\n    }\n    return d * .02;\n}\n\nvec3 norm(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n        df(p+e.xyy) - df(p-e.xyy),\n        df(p+e.yxy) - df(p-e.yxy),\n        df(p+e.yyx) - df(p-e.yyx)\n    ));\n}\n\nvec3 rm(vec3 p, vec3 d) {\n    for (int i=0; i<800; i++) {\n        float dist = df(p);\n        if (dist<0.001) {\n            vec3 n = norm(p);\n            //return distance(norm(p-.001).y, norm(p+.001).y)>0.1 ? vec3(1) : vec3(0);\n            return vec3(\n                pow(\n                    max(0., dot(abs(n), normalize(vec3(1)))),\n                    4.\n                )\n             ) * vec3(.2,.4,1.) * 1.5 + vec3(1,.5,0) * 1.5 * float(i)/400.;\n        }\n        p += d * 0.01;//dist;\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.yy;\n    \n    vec3 p = vec3(0,2.5, iTime),\n    d = normalize(vec3(uv, 1));\n    r2d(d.yz,1.);\n    \n    //r2d(p.xz,sin(iTime/3.)/3.);\n    r2d(d.xz,sin(iTime/3.)/3.);\n    //r2d(p.xy,iTime/3.);\n    //r2d(d.xy,iTime/3.);\n    \n    vec3 col = rm(p, d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}