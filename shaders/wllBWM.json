{
    "Shader": {
        "info": {
            "date": "1596912767",
            "description": "floating noise",
            "flags": 1,
            "hasliked": 0,
            "id": "wllBWM",
            "likes": 3,
            "name": "floating_noise",
            "published": 3,
            "tags": [
                "noise"
            ],
            "usePreview": 0,
            "username": "slackmage",
            "viewed": 362
        },
        "renderpass": [
            {
                "code": "//\n// APOLLONIAN NET FRACTAL\n//\n// shader inspiration and help\n// https://www.shadertoy.com/view/llG3Dt @Gijs\n// https://www.shadertoy.com/view/Xtlyzl @GregRostami / @Fabrice\n\n#define MAX_DIST \t15.0\n#define MIN_DIST \t.001\n#define MAX_STEPS \t158\n\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831853\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define kf(a,b) a*(1.2/b)\n#define pfract(a) -1.+2.*fract(.5*a+.5)\n\n// Antialiasing \"module\" by FabriceNeyret2 \n// https://www.shadertoy.com/view/WlfyW8\n// set at bottom AA = 1 is off\n\nvec3 get_mouse( vec3 ro ) {\n    float x = iMouse.xy==vec2(0) ? -1. :\n    \t(iMouse.y / iResolution.y * 1. - .5) * PI;\n    float y = iMouse.xy==vec2(0) ? .5 :\n    \t-(iMouse.x / iResolution.x * 1. - .5) * PI;\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    return ro;\n}\n\n\nvec4 orb = vec4(0.0); \n\nvec2 apollo (vec3 p) {\n\tfloat scale = 1.;\n\torb = vec4(0.0);\n\tfor( int i=0; i<4;i++ ) {\n\t\tp = pfract(p);\n\t\tfloat r2 = dot(p,p);  \n        orb = min( orb, vec4(abs(p),r2) );\n\t\tp = kf(p,r2);\n        scale = kf(scale,r2);\n\t}\n    \n    float tubes = length(mod(p.xz+.5,1.)-.5)-.025;\n    tubes =   min(length(mod(p.xy+.5,1.)-.5)-.025,tubes);\n    tubes =   min(length(mod(p.zy+.5,1.)-.5)-.025,tubes);\n    float d = (tubes)/scale;\n    \n\treturn vec2(d*.65,scale);\n}\n\nvec2 map (in vec3 p) {\n    p.x += .5 - iTime *.02;\n    p.y+=1.25;\n    vec2 d = apollo(p);\n\treturn d;\n}\n\n//@iq calNormal using distance - fixes issues\nvec3 get_normal(in vec3 pos, in float t ){\n    float precis = 0.0001 * t * 0.57;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd ) {\n    float depth = 0.0;\n    float m = -1.;\n    for (int i = 0; i<MAX_STEPS;i++)\n    {\n        vec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        m = dist.y;\n        if(abs(dist.x)<MIN_DIST*depth) break;\n        depth += dist.x*.7;\n        if(depth>MAX_DIST) break;\n    } \n    return vec2(depth,m);\n}\n\nfloat get_diff(vec3 p, vec3 lpos, float t) {\n    vec3 l = normalize(lpos-p);\n    vec3 n = get_normal(p, t);\n    float dif = clamp(dot(n,l),0. , 1.);\n    \n    vec2 shadow = ray_march(p + n * MIN_DIST * 2., l);\n    if(shadow.x < length(p -  lpos)) {\n        dif *= .1;\n    }\n    return dif;\n}\n\n//@iq/@shane\nfloat get_ao(vec3 p, vec3 n){\n    float r = 0., w = 1., d;\n    for (float i=1.; i<5.+1.1; i++){\n        d = i/5.;\n        r += w*(d - map(p + n*d).x);\n        w *= .5;\n    }\n    return 1.-clamp(r,.0,1.);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(6.0), rgb, c.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 color = vec3(0.);\n    vec3 fadeColor = vec3(0.5);\n    vec2 ray = ray_march(ro, rd);\n    \n    if(ray.x<MAX_DIST) {\n        vec3 p = ro + ray.x * rd;\n        vec3 n = get_normal(p, ray.x);\n        \n        vec3 lpos1 = vec3(-1.05, -.03, 1.1);\n        vec3 lpos2 = vec3(.05, .01, -.5);\n\n        vec3 tint = hsv2rgb(vec3(ray.y*.006,1.,.5));\n        \n        vec3 diff = vec3(.7)*get_diff(p, lpos1, ray.x);\n             diff+= vec3(.7)*get_diff(p, lpos2, ray.x);\n  \t\tfloat ao = get_ao(p,n);\n\n        color += tint * diff * ao;\n\n    } else {\n    \tcolor = fadeColor;   \n    }\n    \n    color = mix( color, fadeColor, 1.-exp(-1.0015*ray.x*ray.x*ray.x));\n    return color;\n}\n\nvec3 ray( in vec3 ro, in vec3 lp, in vec2 uv ) {\n    vec3 cf = normalize(lp-ro);\n    vec3 cp = vec3(4.,1.,0.);\n    vec3 cr = normalize(cross(cp, cf));\n    vec3 cu = normalize(cross(cf, cr));\n    vec3 c = ro + cf * 6.85;\n    \n    vec3 i = c + uv.x * cr + uv.y * cu;\n    return i-ro; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n    vec3 ro = vec3(0.,0.1,1.02);\n    vec3 lp = vec3(0.,0.,0.);\n    ro = get_mouse(ro);\n\tvec3 rd = ray(ro, lp, uv);\n\n    vec3 col = render(ro, rd, uv);\n    col= pow(col, vec3(0.4545));\n    fragColor = vec4(col,45.0);\n}\n   \nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n  \tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n    vec3 color = render(fragRayOri, fragRayDir, uv);\n\tcolor = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}