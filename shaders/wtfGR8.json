{
    "Shader": {
        "info": {
            "date": "1555610148",
            "description": "Inspired by this: https://twitter.com/sasj_nl/status/1118844071756357633",
            "flags": 0,
            "hasliked": 0,
            "id": "wtfGR8",
            "likes": 46,
            "name": "Cube Plot Doodle",
            "published": 3,
            "tags": [
                "wireframe",
                "rotation",
                "plotter"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1246
        },
        "renderpass": [
            {
                "code": "// Created by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\nconst int numCubes = 32;\nconst float twistStep = .06;\nconst float scaleStep = 0.96;\nconst float zoom = 3.7;\nconst float lineThickness = 1.2; // in pixels\n\n/*\n// alternative settings for full-screen\nconst int numCubes = 64;\nconst float twistStep = .03;\nconst float scaleStep = 0.98;\nconst float zoom = 2.8;\nconst float lineThickness = .8; // in pixels\n*/\n\n\n// input in range [-1,1] to span iResolution.y pixels\nfloat RenderLine( vec2 a, vec2 b, vec2 fragCoord )\n{\n    a = (iResolution.y*a + iResolution.xy)*.5;\n    b = (iResolution.y*b + iResolution.xy)*.5;\n    \n    const float halfThickness = lineThickness*.5; \n\n    const float halfAASoftening = .7; // in pixels (don't change this much)\n    \n    float t = dot(fragCoord-a,b-a);\n    t /= dot(b-a,b-a);\n    t = clamp( t, 0., 1. );\n    return smoothstep( halfThickness-halfAASoftening, halfThickness+halfAASoftening, length(fragCoord - mix(a,b,t)) );\n}\n\n    \nfloat RenderLine3D( vec3 a, vec3 b, vec2 fragCoord )\n{\n    vec3 camPos = vec3(0,0,-5);\n    \n    a -= camPos;\n    b -= camPos;\n    \n    // todo: transform by camera matrix\n\n    a.z /= zoom;\n    b.z /= zoom;\n    \n    // perspective projection\n    return RenderLine( a.xy/a.z, b.xy/b.z, fragCoord );\n}\n\n\n// combine 2 anti-aliased values\nfloat BlendAA( float a, float b )\n{\n    // a and b values represent what proportion of the pixel is covered by each line,\n    // but they don't contain enough information to accurately combine them!\n    // if both lines are covering the same part of the pixel the result should be min(a,b)\n    // if they cover non-overlapping parts of the pixel the result is a-(1-b)\n\t// a*b assumes the proportion of overlap is the same in the solid and clear regions\n    // this is the safest assumption given the lack of any other info\n\n    // but, tune it until it looks good\n    return mix( min(a,b), a*b, .5 );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour.rgb = vec3(.8);\n    \n    vec3 a = vec3(twistStep*cos(iTime*3./vec3(11,13,17)+1.5));\n    mat3 stepTransform =\n        scaleStep *\n        mat3( cos(a.z), sin(a.z), 0,\n             -sin(a.z), cos(a.z), 0,\n              0, 0, 1 ) *\n        mat3( cos(a.y), 0, sin(a.y),\n             0, 1, 0,\n             -sin(a.y), 0, cos(a.y) ) *\n        mat3( 1, 0, 0,\n              0, cos(a.x), sin(a.x),\n              0,-sin(a.x), cos(a.x) );\n\n    vec3 b = vec3(.7+iTime/6.,.7+iTime/6.,.6);\n    mat3 transform = //mat3(1,0,0,0,1,0,0,0,1); // identity\n        mat3( cos(b.z), sin(b.z), 0,\n             -sin(b.z), cos(b.z), 0,\n              0, 0, 1 ) *\n        mat3( cos(b.y), 0, sin(b.y),\n             0, 1, 0,\n             -sin(b.y), 0, cos(b.y) ) *\n        mat3( 1, 0, 0,\n              0, cos(b.x), sin(b.x),\n              0,-sin(b.x), cos(b.x) );\n\n    float line = 1.;\n    #define DrawLine(a,b) line = BlendAA( line, RenderLine3D(a,b,fragCoord) );\n    \n    for ( int cube=0; cube < numCubes; cube++ )\n    {\n        vec3 vertices[8];\n        for ( int i=0; i < 8; i++ )\n        {\n            vertices[i] = transform*(vec3(i>>2,(i>>1)&1,i&1)*2.-1.);\n        }\n        \n        DrawLine( vertices[0], vertices[1] );\n        DrawLine( vertices[2], vertices[3] );\n        DrawLine( vertices[4], vertices[5] );\n        DrawLine( vertices[6], vertices[7] );\n        DrawLine( vertices[0], vertices[2] );\n        DrawLine( vertices[1], vertices[3] );\n        DrawLine( vertices[4], vertices[6] );\n        DrawLine( vertices[5], vertices[7] );\n        DrawLine( vertices[0], vertices[4] );\n        DrawLine( vertices[1], vertices[5] );\n        DrawLine( vertices[2], vertices[6] );\n        DrawLine( vertices[3], vertices[7] );\n        \n        transform *= stepTransform;\n    }\n    \n    fragColour.rgb = mix( vec3(.02), vec3(.8), line );\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}