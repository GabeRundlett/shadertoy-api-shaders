{
    "Shader": {
        "info": {
            "date": "1677197847",
            "description": "Keys:\nR - reset\nA/D - move\nW/S - height\nQ/E - stride width\nSPACE - shoot\nF/G - hip size\n\nBugs included!",
            "flags": 48,
            "hasliked": 0,
            "id": "dscGWH",
            "likes": 22,
            "name": "Test Walker (WIP)",
            "published": 3,
            "tags": [
                "interactive",
                "walk",
                "person",
                "legs"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 242
        },
        "renderpass": [
            {
                "code": "#define green vec3(0.5,1,0)\n#define blue vec3(0,0.5,1)\n#define orange vec3(1,0.5,0.5)\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// maybe overkill but might want other styles\nvoid style1(inout vec3 col, vec3 col2, float d) {\n    float s = smoothstep(-k, k, 2.*k - abs(d));\n    float s2 = smoothstep(-k, k, d);\n    col = mix(col * (1.-s2), col2, s);\n}\n\nvoid line(vec2 uv, inout vec3 col, vec3 col2, vec2 p, vec2 q, float r) {\n    float d = r - seg(uv, p, q);\n    style1(col, col2, d);\n}\n\nvoid circle(vec2 uv, inout vec3 col, vec3 col2, vec2 p, float r) {\n    float d = r - length(uv - p);\n    style1(col, col2, d);\n}\n\nvoid box(vec2 uv, inout vec3 col, vec3 col2, vec2 p, vec2 q, float th, float r) {\n    float d = r - sdBox(uv, p, q, th);\n    style1(col, col2, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    uv.y += 0.35;\n\n\n    // --- DATA / PARAMETERS ---\n    vec4 tx  = texelFetch(iChannel0, ivec2(0,0), 0); // Right foot\n    vec4 tx2 = texelFetch(iChannel0, ivec2(0,1), 0); // Left foot\n    vec4 tx3 = texelFetch(iChannel0, ivec2(0,2), 0); // Dimension data\n    float sw = mix(swMin, swMax, tx3.z);\n    \n   \n    // --- POINTS ---\n    // clamp to avoid flicker bug (maybe not needed)\n    float mx  = abs(tx.x-tx2.x)/sw;\n    float mxL = clamp(max(mx, tx.y), 0., 1.);    \n    float mxR = clamp(max(mx, tx2.y), 0., 1.);    \n    mxL = .5 + .5 * cos(pi*mxL);\n    mxR = .5 + .5 * cos(pi*mxR);\n    vec2 pFootL = vec2(tx2.x, r0 + 3. * mxL * r0);\n    vec2 pFootR = vec2(tx.x, r0 + 3. * mxR * r0);\n    \n    vec2 pTarget = vec2(mix(tx.x,tx2.x,.5), pFootL.y + pFootR.y + 2.*r1);   \n    float aL = angle(pTarget, pFootL);\n    float aR = angle(pTarget, pFootR);\n    vec2 pKneeL = pFootL + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aL);\n    vec2 pKneeR = pFootR + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aR);\n\n    vec2 pHipL = pKneeL + (6.*tx3.y+2.*mx) * r0 * Dir(aL);\n    vec2 pHipR = pKneeR + (6.*tx3.y+2.*mx) * r0 * Dir(aR); \n    vec2 pBody = mix(pHipL, pHipR, 0.5);\n    pHipL = mix(pHipL, pBody, tx3.w);\n    pHipR = mix(pHipR, pBody, tx3.w);\n    \n    vec2 dirOrbit = Dir(tx3.x*pi*(0.5-0.1*mx) - 0.5*pi);\n    vec2 pOrbit1 = pBody + r1 * dirOrbit;\n    vec2 pOrbit2 = pOrbit1 + 2.01 * r0 * dirOrbit;\n        \n    // --- DRAW ---\n    \n    // Plane\n    float pl = smoothstep(-k, k, -uv.y);\n    vec3 col = mix(vec3(0), vec3(0.25), pl);\n    \n    // Right leg (blue)\n    line(uv, col, orange, pFootR, pKneeR, 0.5 * r0);\n    line(uv, col, orange, pKneeR, pHipR, 0.5 * r0);    \n    circle(uv, col, mix(blue,vec3(1),.5*(tx2.y+1.)), pFootR, r0);\n    circle(uv, col, blue, pKneeR, r0);\n    circle(uv, col, blue, pHipR, r0);\n    \n    // Buffer B (lasers)\n    vec4 txB = texelFetch(iChannel1, ivec2(px), 0);\n    vec3 laserCol = mix(green, blue, (1.-txB.y)*txB.x); \n    col = mix(col, laserCol, txB.y*(1.-pl));\n    \n    // Centre ball\n    line(uv, col, orange, pHipR, pBody, 0.5 * r0);   \n    //line(uv, col, orange, pOrbit1, pOrbit2, 0.5* r0);\n    circle(uv, col, orange, pBody, r1);\n    pOrbit2 += -pow(txB.x, 4.)*2.*r0*dirOrbit;\n    box(uv, col, orange, pOrbit1, pOrbit2, 2.*r0 * (1.-0.*txB.x), 0.);\n    line(uv, col, orange, pBody, pHipL, 0.5 * r0);\n     \n    // Left leg (red)\n    line(uv, col, orange, pFootL, pKneeL, 0.5 * r0);\n    line(uv, col, orange, pKneeL, pHipL, 0.5 * r0);       \n    circle(uv, col, mix(green,vec3(1),.5*(tx.y+1.)), pFootL, r0);\n    circle(uv, col, green, pKneeL, r0);\n    circle(uv, col, green, pHipL, r0);    \n    \n    // UI (tx3 data)\n    line(ouv, col, vec3(1), vec2(-0.45,0.45), vec2(-0.45,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.45, mix(.3,.45,.5*(tx3.x+1.))), 0.01);\n    line(ouv, col, vec3(1), vec2(-0.4,0.45), vec2(-0.4,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.4, mix(.3,.45,tx3.z)), 0.01);\n    line(ouv, col, vec3(1), vec2(-0.35,0.45), vec2(-0.35,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.35, mix(.3,.45,tx3.y)), 0.01);\n    line(ouv, col, vec3(1), vec2(-0.3,0.45), vec2(-0.3,0.3), .02);\n    circle(ouv, col, vec3(1), vec2(-0.3, mix(.3,.45,tx3.w)), 0.01);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n\n// probably don't need wrapping\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nfloat key_val(int key) {\n    return texelFetch(KEYBOARD, ivec2(key, 0), 0).x;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n// Texels:\n// (0,0) Right foot\n// (0,1) Left foot \n// (0,2) Dimension data\n\n// Dimension data:\n// x = left/rightness, [-1,1] range\n// y = height,         [0,1] range\n// z = stride width,   [0,1] range\n// w = hip size,       [0,1] range\n\n// Feet:\n// x = x position\n// y = priority value, 0 or 1\n// z = x velocity\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    vec4 tx = cell(ipx);\n    \n    // Initialize data on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        if (ipx == ivec2(0,0)) {        // Right foot\n            tx.xyz = vec3(0,1,0);\n        } else if (ipx == ivec2(0,1)) { // Left foot\n            tx.xyz = vec3(0,-1,0);\n        } else if (ipx == ivec2(0,2)) { // Dimension data\n            tx.x = 0.;\n            if (iFrame < 1) \n                tx.yzw = vec3(0.7, 0.8, 0);\n        }\n    }\n    \n    // Dimension data input\n    if (ipx == ivec2(0,2)) {\n        float dirChange = 0.1 * (key_val(KEY_D) - key_val(KEY_A));\n        //if (dirChange == 0.)\n        //    dirChange = -sign(tx.x) * 0.025;\n        tx.x = clamp(tx.x + dirChange, -1., 1.);  \n        \n        tx.y += 0.05  * (key_val(KEY_W) - key_val(KEY_S));\n        tx.z += 0.025 * (key_val(KEY_E) - key_val(KEY_Q));\n        tx.w += 0.05  * (key_val(KEY_G) - key_val(KEY_F));\n        tx.yzw = clamp(tx.yzw, 0., 1.);\n    }\n    else {\n        // The other foot \n        vec4 tx2 = cell(ivec2(0, 1-ipx.y));\n        \n        // Dimension info (stride width)\n        vec4 tx3 = cell(ivec2(0,2));\n        float sw = mix(swMin, swMax, tx3.z);\n    \n        // If feet are further than stride width apart,\n        // change foot priority and pass velocity to the other foot\n        if (abs(tx.x - tx2.x) > sw) { \n            tx.y = -tx.y;\n            tx.z = tx2.z;\n        }\n\n        // If this foot has priority, update it's motion\n        if (tx.y == 1.) {\n            if (key_down(KEY_A))\n                tx.z -= dx;\n            if (key_down(KEY_D))\n                tx.z += dx;\n            tx.z *= 0.9;\n            tx.x += tx.z;\n        }\n\n       if (abs(tx.x) > 0.5)\n           tx.x *= 0.99;\n   } \n   \n   fragColor = tx;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Thanks to:\n\n// elenzil for this really helpful shader:\n// https://www.shadertoy.com/view/DscGRH\n\n// IQ for sd functions :)\n\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define angle(a,b) atan(a.y-b.y, a.x-b.x)\n\n#define res iResolution.xy\n#define k (1./res.y)\n\n// Stride width min/max values\n#define swMin 0.1\n#define swMax 0.4\n\n// Radii of points\n#define r0 0.02\n#define r1 0.06\n\n// Stride acceleration increment\n#define dx (0.005 * sw)\n\nfloat sdBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n#define KEY_SPACE 32\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat laser(vec2 ress, vec2 px, vec4 tx3) {\n        vec2 uv = (px - 0.5 * ress) / ress.y;\n        uv.y += 0.35;\n        vec4 tx  = texelFetch(iChannel0, ivec2(0,0), 0); // Right foot\n        vec4 tx2 = texelFetch(iChannel0, ivec2(0,1), 0); // Left foot\n        float sw = mix(swMin, swMax, tx3.z);\n        float mx  = abs(tx.x-tx2.x)/sw;\n        float mxL = clamp(max(mx, tx.y), 0., 1.);    \n        float mxR = clamp(max(mx, tx2.y), 0., 1.);    \n        mxL = .5 + .5 * cos(pi*mxL);\n        mxR = .5 + .5 * cos(pi*mxR);\n        vec2 pFootL = vec2(tx2.x, r0 + 3. * mxL * r0);\n        vec2 pFootR = vec2(tx.x, r0 + 3. * mxR * r0);\n        vec2 pTarget = vec2(mix(tx.x,tx2.x,.5), pFootL.y + pFootR.y + 2.*r1);   \n        float aL = angle(pTarget, pFootL);\n        float aR = angle(pTarget, pFootR);\n        vec2 pKneeL = pFootL + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aL);\n        vec2 pKneeR = pFootR + (6.*tx3.y+2.*mx) * r0 * Dir(tx3.x*pi/8.+aR);\n        vec2 pHipL = pKneeL + (6.*tx3.y+2.*mx) * r0 * Dir(aL);\n        vec2 pHipR = pKneeR + (6.*tx3.y+2.*mx) * r0 * Dir(aR); \n        vec2 pBody = mix(pHipL, pHipR, 0.5);\n        vec2 dirOrbit = Dir(tx3.x*pi*(0.5-0.1*mx) - 0.5*pi);\n        vec2 pOrbit2 = pBody + (2.*r0+r1) * dirOrbit;\n        vec2 pOrbit3 = pOrbit2 + 2. * dirOrbit;\n        return exp(-1.*sdBox(uv, pOrbit2, pOrbit3, 0.));\n        //return smoothstep(-k, k, 0.0 - sdBox(uv,pOrbit2,pOrbit3,0.01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{    \n    // Dimension data\n    vec4 tx3 = cell(ivec2(0,2));\n    \n    vec4 txB = texelFetch(iChannel2, ivec2(px), 0);   \n    \n    // x checks if space is pressed, has a cooldown\n    txB.x = max(0., txB.x - 1./30. - 0.*px.x/res.x);\n    \n    // y draws laser and fades\n    //if (txB.y < 1.)\n    txB.y *= mix(1., txB.y, 1. );    \n    if (txB.y >= 1.)\n        txB.y = 0.;\n        \n    txB.y = clamp(txB.y, 0., 1.);\n    if (key_down(KEY_SPACE) && txB.x == 0.) {\n        // reset countdown\n        txB.x = 1.;       \n        \n        // --bad-- draw laser --bad--\n        txB.y = max(txB.y, laser(res, px, tx3));       \n    }\n               \n    fragColor = txB;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}