{
    "Shader": {
        "info": {
            "date": "1517102592",
            "description": "Render any downsampled texture as a dot matrix. \nScaled to fit and centred with aspect ratio preserved\nMatrix dimension is set by iChannel0  texture (one dot per pixel)\nHalftoning is optional (uncomment). Test F12+fullscreen [ ] and drag border.",
            "flags": 0,
            "hasliked": 0,
            "id": "lt2BDy",
            "likes": 3,
            "name": "Scaled Dot Matrix (Halftone)",
            "published": 3,
            "tags": [
                "grid",
                "halftone",
                "matrix",
                "dot",
                "scaled",
                "fit"
            ],
            "usePreview": 0,
            "username": "dcerisano",
            "viewed": 972
        },
        "renderpass": [
            {
                "code": "// Scaled Dot Matrix. See comments for Fabrice's excellent optimizations.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float twidth   = iChannelResolution[0].x; // Texture width\n    float theight  = iChannelResolution[0].y; // Texture height\n    float cwidth   = iResolution.x;           // Canvas  width\n    float cheight  = iResolution.y;           // Canvas  height\n    float x        = fragCoord.x;             // Canvas  x\n    float y        = fragCoord.y;             // Canvas  y\n    float size     = 0.0;                     // Cell    size\n    \n    //Scale (preserving aspect ratio)\n   \tfloat gridWidth  = cwidth/twidth;\n\tfloat gridHeight = cheight/theight; \n    \n    //Fit\n \tif (gridWidth> gridHeight)\n\t\tsize = gridHeight;\n\telse\n\t\tsize = gridWidth;\n    \n    //Center\n\tfloat xoff = (cwidth-twidth*size)*0.5;\t   \n\tfloat yoff = (cheight-theight*size)*0.5;\n    \n    //Render dot matrix, scaled to fit and centered with aspect ratio preserved\n    if(x>xoff && y>yoff && x<xoff+twidth*size && y<yoff+theight*size){\n        vec3  col      = texture(iChannel0, vec2((x-xoff)/(twidth*size),(y-yoff)/(theight*size))).rgb;\n        float halftone = 1.0; // = max(0.2, dot(col, vec3(0.2125, 0.7154, 0.0721)))*1.2;\n\t    vec2  center   = floor((vec2(x-xoff, y-yoff))/size)*size+size*0.5;\n    \tfloat dist     = distance(center, vec2(x-xoff, y-yoff))/(size*0.4);\n    \tfloat alpha    = smoothstep(1.0, 0.95, dist/halftone);\n      \tfragColor.rgb  = col.rgb*alpha;\n        fragColor.a    = 1.0; // In case you port this to webGL\n    }\n    else\n        fragColor      = vec4(0, 0, 0, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}