{
    "Shader": {
        "info": {
            "date": "1493536159",
            "description": "Bytebeat bass test",
            "flags": 8,
            "hasliked": 0,
            "id": "MsScWG",
            "likes": 10,
            "name": "Bytebeat bass test",
            "published": 3,
            "tags": [
                "bytebeatsound"
            ],
            "usePreview": 1,
            "username": "FractalCurious",
            "viewed": 771
        },
        "renderpass": [
            {
                "code": "vec2 globCoord;\nvec4 globColor;\n\n/// A sine approximation via a fourth-order cosine approx.\n/// http://www.coranac.com/2009/07/sines/\n/// @param x   angle (with 2^15 units/circle)\n/// @return     Sine value (Q12)\nint isin2(int x)\n{\n    int c, x2, y;\n    const int qN= 13, qA= 12, B=19900, C=3516;\n\n    c= x<<(30-qN);              // Semi-circle info into carry.\n    x -= 1<<qN;                 // sine -> cosine calc\n\n    x= x<<(31-qN);              // Mask with PI\n    x= x>>(31-qN);              // Note: SIGNED shift! (to qN)\n    x= x*x>>(2*qN-14);          // x=x^2 To Q14\n\n    y= B - (x*C>>14);           // B - x^2*C\n    y= (1<<qA)-(x*y>>16);       // A - x^2*(B-x^2*C)\n\n    return c>=0 ? y : -y;\n}\n\nint l(int t)\n{\n    return isin2(t);\n        \n}\n\n\nvoid rect(float x1, float y1, float x2, float y2, vec4 color)\n{\n    if (globCoord.x > x1 && globCoord.x < x2 && globCoord.y > y1 && globCoord.y < y2) {\n    \tglobColor = color;\n    }\n}\n\nvoid rectByL(float x, float y, float w, float h, vec4 color) {\n\trect(x, y, x + w, y + h, color);\n}\n\nvoid drawDigit(int digit, float x, float y, vec4 color)\n{\n    float scale = 1.99;\n    \n    if (digit == 2 || digit == 6 || digit == 8 || digit == 0) {\n    \trectByL(x             , y + 1. * scale, 1. * scale, 2. * scale, color); // segment 5\n    }\n    \n    if (digit == 4 || digit == 5 || digit == 6 || digit == 8 || digit == 9 || digit == 0) {\n    \trectByL(x             , y + 4. * scale, 1. * scale, 2. * scale, color); // segment 6\n    }\n    \n    if (digit == 1 || digit == 2 || digit == 3 || digit == 4 || digit == 7 || digit == 8 || digit == 9 || digit == 0) {\n    \trectByL(x + 3. * scale, y + 4. * scale, 1. * scale, 2. * scale, color); // segment 2\n    }\n    \n    if (digit == 1 || digit == 3 || digit == 4 || digit == 5 || digit == 6 || digit == 7 || digit == 8 || digit == 9 || digit == 0) {\n    \trectByL(x + 3. * scale, y + 1. * scale, 1. * scale, 2. * scale, color); // segment 3\n    }\n    \n    if (digit == 2 || digit == 3 || digit == 5 || digit == 6 || digit == 8 || digit == 9 || digit == 0) {\n    \trectByL(x + 1. * scale, y             , 2. * scale, 1. * scale, color); // segment 4\n    }\n    \n    if (digit == 2 || digit == 3 || digit == 4 || digit == 5 || digit == 6 || digit == 8 || digit == 9 ) {\n    \trectByL(x + 1. * scale, y + 3. * scale, 2. * scale, 1. * scale, color); // segment 7\n    }\n    \n    if (digit == 2 || digit == 3 || digit == 5 || digit == 6 || digit == 7 ||digit == 8 || digit == 9 || digit == 0) {\n    \trectByL(x + 1. * scale, y + 6. * scale, 2. * scale, 1. * scale, color); // segment 1\n    }\n}\n\nvoid drawInt(int number, float x, float y, vec4 color)\n{\n    float scale = 1.99;\n    \n    drawDigit(number % 10, x + 50. * scale, y, color);\n    drawDigit(number / 10 % 10, x + 45. * scale, y, color);\n    drawDigit(number / 100 % 10, x + 40.* scale, y, color);\n    drawDigit(number / 1000 % 10, x + 35.* scale, y, color);\n    drawDigit(number / 10000 % 10, x + 30.* scale, y, color);\n    drawDigit(number / 100000 % 10, x + 25.* scale, y, color);\n    drawDigit(number / 1000000 % 10, x + 20.* scale, y, color);\n    drawDigit(number / 10000000 % 10, x + 15.* scale, y, color);\n    drawDigit(number / 100000000 % 10, x + 10.* scale, y, color);\n    drawDigit(number / 1000000000 % 10, x + 5.* scale, y, color);\n}\n\nvoid drawFloat(float number, float x, float y, vec4 color)\n{\n    float scale = 1.99;\n    \n    int intPart = int(floor(number));\n    \n    drawDigit(intPart % 10, x + 54.5 * scale, y, color);\n    drawDigit(intPart / 10 % 10, x + 48.5 * scale, y, color);\n    drawDigit(intPart / 100 % 10, x + 42.5 * scale, y, color);\n    drawDigit(intPart / 1000 % 10, x + 36.5 * scale, y, color);\n    drawDigit(intPart / 10000 % 10, x + 30.5 * scale, y, color);\n    drawDigit(intPart / 100000 % 10, x + 24.5 * scale, y, color);\n    drawDigit(intPart / 1000000 % 10, x + 18.5 * scale, y, color);\n    drawDigit(intPart / 10000000 % 10, x + 12.5 * scale, y, color);\n    drawDigit(intPart / 100000000 % 10, x + 6.5 * scale, y, color);\n    drawDigit(intPart / 1000000000 % 10, x + 0.5 * scale, y, color);\n    \n    rectByL(x + 66.5 * scale, y, 1. * scale, 1. * scale, color);\n    \n    drawDigit(int(floor(number * 10.)) % 10, x + 69.5 * scale, y, color);\n    drawDigit(int(floor(number * 100.)) % 10, x + 75.5 * scale, y, color);\n    drawDigit(int(floor(number * 1000.)) % 10, x + 81.5 * scale, y, color);\n    drawDigit(int(floor(number * 10000.)) % 10, x + 87.5 * scale, y, color);\n    drawDigit(int(floor(number * 100000.)) % 10, x + 93.5 * scale, y, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    globCoord = fragCoord;\n    globColor = fragColor;\n    \n    int t = int(round(iTime * iSampleRate));\n    \n    float t2 = float(t) + fragCoord.x;\n   \n\tfloat x = float(isin2(int(t2) * 100)) / 4000.;\n    float x2 = t2;\n    \n    \n    float xf = (float(int(x) % 256) / 128.) - 1.;\n    float x2f = (float(int(x2) % 256) / 128.) - 1.;\n    \n    float c = abs(int((x * 0.5 + 0.5) * iResolution.y) - int(fragCoord.y)) < 1 ? 1. : 0.;\n   \n    globColor = vec4(0., c, 0., 1.0);\n    \n    rect(10., 10., 20., 100., vec4(0, 0, 1, 1));\n    rect(5., 5., 10., 10., vec4(1, 0, 0, 1));\n    \n    drawFloat(iSampleRate, 50., 110., vec4(0, 1, 1, 1));\n    drawFloat(x, 50., 80., vec4(0, 1, 1, 1));\n    drawFloat(float(t), 50., 50., vec4(0, 1, 1, 1));\n    drawFloat(iTime, 50., 10., vec4(0, 1, 1, 1));\n    \n    fragColor = globColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int signal_range_bits = 12;\nconst int signal_range = 1 << signal_range_bits;\n\nint gt;\n\n/**\n * Adds two signals and normalizes the result by dividing by 2\n */\nint norm(int x, int y)\n{\n    return (x + y) / 2;\n}\n\nint sigrange(int x)\n{\n    return x << signal_range_bits;\n}\n\nint sq(int period)\n{\n    return (gt / period + 1) % 2;\n}\n\nint bassline()\n{\n    int t2 = gt / 80000 + 1;\n    int b4325 = 5 - t2 % 4;\n    int b1100 = (t2 & 2) / 2;\n    int b4300 = b4325 * b1100;\n    int b8_8_12_12 = 12 - b4300;\n    \n    // alternates between 1 and 2 4 times more often then chord changes\n    int octave_multiplier = (gt / 10000 + 1) % 2 + 1;\n    \n    return b8_8_12_12 * octave_multiplier;\n}\n\nint metronome()\n{\n    return sigrange((gt * 10112 / 221120 + 1) % 2 * sq(10000)) / 200;\n}\n\nint kick()\n{\n    int t2 = gt % 10000;\n    int t3 = (gt / 10000 + 1) % 8;\n    int pattern = (t3 - 7) / 6;\n    \n    return ((200001 / (t2 * 8 / 20)) % 256) * pattern * 64;\n}\n\nint noise()\n{\n    return (gt * gt * gt * gt) % 800000000;\n}\n\nint snare()\n{\n    return noise() * int((gt + 20000) % 40000 < 2500);\n}\n\nint l(int t)\n{\n    int bass_signal = sigrange(sq(22 * bassline()));\n    \n\treturn norm(norm(1 * bass_signal, kick()), norm(snare(), metronome()));\n        \n}\n\nvec2 mainSound( in int samp,float time)\n{\n    int t = int(round(time * iSampleRate));\n    \n    gt = t;\n    \n    float x = (2. * (float(l(t) % (signal_range + 1)) / float(signal_range + 1)) - 1.) / 2.;\n    \n    vec2 v = vec2(x, x);    \n\t \n\treturn clamp(v,-1.0,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}