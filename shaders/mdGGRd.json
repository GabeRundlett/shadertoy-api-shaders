{
    "Shader": {
        "info": {
            "date": "1678936444",
            "description": "red green color test",
            "flags": 0,
            "hasliked": 0,
            "id": "mdGGRd",
            "likes": 0,
            "name": "red green color test",
            "published": 3,
            "tags": [
                "redgreencolortest"
            ],
            "usePreview": 0,
            "username": "tianluo97",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    //cubicPulse动态混合过程\n    //earthmap\n    float divisionLine1 = 1.3/19.0 + 0.02;\n    //digital hardware\n    float divisionLine2 = 3.5/19.0;\n    //machine social network\n    float divisionLine3 = 6.6/19.0;\n    //FE\n    float divisionLine4 = 10.0/19.0;\n    //operation center\n    float divisionLine5 = 13.0/19.0 - 0.01;\n    //logo\n    float divisionLine6 = 16.0/19.0;\n    \n    float divisonTime;\n    float divisionLine;\n    int count; \n    \n    count = 5;\n    \n    //from earthmap to digital hardware\n    if(count == 1){\n    divisionLine = divisionLine1 + (divisionLine2 - divisionLine1) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from digital hardware to machine social network\n    if(count == 2){\n    divisionLine = divisionLine2 + (divisionLine3 - divisionLine2) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from machine social network to FE\n    if(count == 3){\n    divisionLine = divisionLine3 + (divisionLine4 - divisionLine3) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from FE to operation center\n    if(count == 4){\n    divisionLine = divisionLine4 + (divisionLine5 - divisionLine4) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    //from operation center to logo\n    if(count == 5){\n    divisionLine = divisionLine5 + (divisionLine6 - divisionLine5) * smoothstep(0.0,1.0, iTime*0.2);}\n    \n    float d = cubicPulse(divisionLine1,0.21,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //加上标识曲线\n    maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    //maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.025; \n    float scale = 0.3;\n    \n    vec4 vcolor0 = vec4(1.0,0.,0.,1.0);\n    vec4 vcolor1 = vec4(0.,1.,0.,1.0);\n    \n    float step0 = 0.5 * scale;\n    \n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    //darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    else {\n    float dist1 = smoothstep(step0, 1.0*scale, y);\n    darkColor = mix(vcolor1, vcolor0, dist1);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //浅色色板\n    float qscale = 0.25;\n    float qtime = iTime* 0.025;\n    \n    float qstep0 = 0.5 * qscale;\n    \n    vec4 qcolor0 = vec4(1.0,1.,1.,1.0);\n    vec4 qcolor1 = vec4(1.,1.,1.,1.0);\n    \n    float qoffset = uv.x-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    lightColor = mix(qcolor0, qcolor1, dist0);\n    //darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    else {\n    float dist1 = smoothstep(step0, 1.0*scale, y);\n    lightColor = mix(qcolor1, qcolor0, dist1);\n    }\n  \n    lightColor = sqrt(lightColor);\n    \n    //start to move\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //adding mask\n    //float endMask = smoothstep(0.6,1.0,uv.x);\n    //vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    //night激活状态\n    vec4 nightColor1 = vec4(0.000,0.067,0.259,1.0);\n    vec4 nightColor0 = vec4(0.000,0.165,0.620,1.0);\n    vec4 nightColor = mix(nightColor0, nightColor1, pow(uv.x,1.));\n    nightColor = sqrt(nightColor);\n    \n    //iStart是一个从零逐步增加的时间，点击之后时间从零开始累加\n    float iStart = 5.0;\n    \n    //night to awake\n\tfragColor = mix(nightColor, fragColor, smoothstep(0.0,1.0,iStart*0.2));\n    \n    //Debug\n    //fragColor = vec4(maskColor,1.0);\n    //fragColor = vec4(lightColor);\n    //fragColor = vec4(darkColor);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n    if (uv.y<-0.1&&uv.y > -1.2){\n    fragColor = vec4(darkColor);\n    }\n    if (uv.y<-1.3&&uv.y > -2.4){\n    fragColor = vec4(lightColor);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}