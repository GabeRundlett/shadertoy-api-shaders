{
    "Shader": {
        "info": {
            "date": "1518012655",
            "description": "Using the polygons from my \"octagonal abstract\" shader to create futuristic building silhouettes.",
            "flags": 0,
            "hasliked": 0,
            "id": "Md3yzH",
            "likes": 22,
            "name": "Sci-Fi Skyline",
            "published": 3,
            "tags": [
                "city",
                "polygon"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1080
        },
        "renderpass": [
            {
                "code": "uint seed = 31713U;\n\nfloat rand( void )\n{\n    // integer hash from Hugo Elias\n\tseed = (seed << 13U) ^ seed;\n    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;\n// this final step seems to stop the randomness after a few repeats\n// => don't feed it back into seed\n    uint seed2 = seed * seed;//uvec4(seed,seed*16807U,seed*48271U,seed*31713U);\n    return float(seed2&0x7fffffffU)/float(0x7fffffffU);\n}\n\nfloat Polygon( vec2 uv, float h )\n{\n    float mid = (rand()-.5)*exp2(-h*2.);\n    float f = abs(uv.y-rand()+.5)-rand()-2.; //2.*mix(1.,rand(),.5+.5*h); // so 1.+rand->2.*rand\n    f = max(f,abs(uv.x-mid)-rand()-.5+h*.4); //1.5*mix(1.,rand(),.7+.3*h);\n    f = max(f,abs(dot(uv,vec2(1,1)/sqrt(2.))-rand()+.5)-rand()-1.);\n    f = max(f,abs(dot(uv,vec2(1,-1)/sqrt(2.))-rand()+.5)-rand()-1.);\n    \n    // support-stalk\n    //f = min(f,max(uv.y,abs(uv.x-mid)-.1));\n    \n    return f;\n}\n\nvec3 Buildings( vec2 uv, int layer )\n{\n    seed = uint( 2. + uv.x/4. );\n    uv.x =(fract(uv.x/4.)-.5)*4.;\n    \n    bool cull = ( pow(float(layer+1)/8.,.3) < rand() );\n\n    seed += 0x1001U*uint(layer);\n\n\t// octahedral, but with random distances so some planes won't be seen\n    float a = Polygon( uv-vec2(0,0), 0. );\n    float b = Polygon( uv-vec2(0,2), .5 );\n    float c = Polygon( uv-vec2(0,4), 1. );\n\n    if ( cull ) { a = 1.; b = 1.; c = 1.; }\n    \n    // ground\n\ta = min( a, uv.y+.5 );    \n    \n    vec3 f = vec3(a,min(a,b),min(min(a,b),c)).zyx;//min(min(a,b),c));//a,b,c);//\n    vec3 col = vec3(.5+.5*f/(.01+abs(f)));\n    \n    return vec3(dot(col,vec3(.985,.01,.005)));\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*vec2(.5,.5))/iResolution.y;\n    \n    uv *= 10.;\n    uv.y += 3.;\n    \n    uv.x -= 8.; // offset the vanishing point where they all line up\n    \n    //fragColour.rgb = Buildings(uv+iTime*vec2(4,0),0u);\n    fragColour.rgb = vec3(1);\n    \n    float size = .18; // *exp2(sin(iTime/8.)); // dolly zoom!\n    float fog = .2;\n    for ( int i=0; i < 12; i++ )\n    {\n\t    fragColour.rgb = min(fragColour.rgb, mix( vec3(1), Buildings(uv*exp2(size*float(i))+iTime*vec2(4,0),i), exp2(-fog*float(i)) ));\n    }\n    \n\t// signature   \n\t#define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n\tfloat sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n    fragColour.rgb = mix( 1.-fragColour.rgb, fragColour.rgb, .5+.5*sig/(.1+abs(sig)) );\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}