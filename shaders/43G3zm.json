{
    "Shader": {
        "info": {
            "date": "1717423501",
            "description": "Simple ray tracing",
            "flags": 0,
            "hasliked": 0,
            "id": "43G3zm",
            "likes": 0,
            "name": "Shiny planet",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "Sansthecomic",
            "viewed": 72
        },
        "renderpass": [
            {
                "code": "#define CAMERA_DISTANCE 2.\n#define STEP_SIZE 0.005\n#define STEP_COUNT 2000\n#define MAX_BOUNCE 5\n#define SHADOW_SAMPLE_STEPS 5000\n#define SHADOW_SOFTNESS .0\n#define DIRECT_REFLECTION_INTENSITY 5.\n#define DIRECT_REFLECTION_COLOR_MULTIPLIER 0.5\n#define REFLECTION_STRENGTH 0.4\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 lightsource = vec3(2.1 * sin(iTime / 10.), 0., 2.1 * cos(iTime / 10.));\n    vec3 cameraPoint3D = vec3(uv, 0);\n\n    vec3 camera = vec3(0, 0, -CAMERA_DISTANCE);\n    vec3 ro = camera;\n    vec3 rd = normalize(cameraPoint3D - camera);\n\n    vec3 sphere1 = vec3(0.);\n    vec3 spherecolor1 = vec3(0, 0.1, 0.7);\n    float radius1 = 0.4;\n\n    vec3 sphere2 = vec3(.8 * cos(-iTime), (iMouse.y / iResolution.y - .5) * 2., 0.6 * sin(-iTime));\n    vec3 spherecolor2 = vec3(0.6, 0.6, 0.6);\n    float radius2 = 0.07;\n\n    vec3 col = vec3(0.0);\n\n    bool reflected = false;\n    int bounce = 0;\n\n    for (int i = 0; i < STEP_COUNT; i++)\n    {\n        ro += rd * STEP_SIZE;\n        if (bounce == MAX_BOUNCE)\n        {\n            break;\n        }\n\n        if (distance(ro, lightsource) < 0.1 && !reflected)\n        {\n            col = vec3(1.0);\n            break;\n        }\n\n        bool hit = false;\n        vec3 normal, sphereColor;\n        float radius;\n        \n        if (distance(ro, sphere1) < radius1)\n        {\n            hit = true;\n            normal = normalize(ro - sphere1);\n            sphereColor = spherecolor1;\n            radius = radius1;\n        }\n        else if (distance(ro, sphere2) < radius2)\n        {\n            hit = true;\n            normal = normalize(ro - sphere2);\n            sphereColor = spherecolor2;\n            radius = radius2;\n        }\n\n        if (hit)\n        {\n            reflected = true;\n            vec3 lightDir = normalize(lightsource - ro);\n            float diff = max(dot(normal, lightDir), 0.0);\n            \n            bool inShadow = false;\n            vec3 shadowRayOrigin = ro + normal * 0.01;\n            vec3 shadowRayDir = normalize(lightsource - shadowRayOrigin);\n            vec3 shadowRo = shadowRayOrigin;\n            \n            for (int j = 0; j < SHADOW_SAMPLE_STEPS; j++)\n            {\n                shadowRo += shadowRayDir * STEP_SIZE;\n                if (distance(shadowRo, sphere1) < radius1 || distance(shadowRo, sphere2) < radius2)\n                {\n                    inShadow = true;\n                    break;\n                }\n                if (distance(shadowRo, lightsource) < 0.1)\n                {\n                    break;\n                }\n            }\n            \n            if (inShadow)\n            {\n                diff *= SHADOW_SOFTNESS;\n            }\n\n            col += diff * (sphereColor * pow(REFLECTION_STRENGTH, float(bounce)));\n\n            vec3 viewDir = normalize(camera - ro);\n            vec3 reflectDir = reflect(-lightDir, normal);\n            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 50.0) / 5.0 * DIRECT_REFLECTION_INTENSITY;\n            if(!inShadow){\n                col += spec * ((sphereColor * DIRECT_REFLECTION_COLOR_MULTIPLIER) + (vec3(1.0) * (1. - DIRECT_REFLECTION_COLOR_MULTIPLIER)));\n            }\n\n            rd = reflect(rd, normal);\n            ro += normal * STEP_SIZE;\n            bounce++;\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}