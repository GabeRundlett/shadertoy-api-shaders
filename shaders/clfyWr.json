{
    "Shader": {
        "info": {
            "date": "1690876438",
            "description": "Simple 2D skeletal animation with some distance field lines and noise to render a stick figure.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "clfyWr",
            "likes": 6,
            "name": "Sekhmet",
            "published": 3,
            "tags": [
                "lines",
                "skeleton",
                "stickfigure",
                "skeletal"
            ],
            "usePreview": 0,
            "username": "virne",
            "viewed": 145
        },
        "renderpass": [
            {
                "code": "#define getuv (2.0*fragCoord-iResolution.xy)/iResolution.y\n#define _main void mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n#define time iTime\n\n\n// Stolen code ------\n\nfloat udSegment( vec2 pos, vec2 a, vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = pos-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvec2 hash( vec2 pos ) // replace this by something better\n{\n\tpos = vec2( dot(pos,vec2(127.1,311.7)), dot(pos,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(pos)*43758.5453123);\n}\n\nfloat noise( vec2 pos )\n{\n    const float K1 = 0.366025; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( pos + (pos.x+pos.y)*K1 );\n    vec2  a = pos - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x);\n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// Stolen code ------\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\n\n\n_main\n{\n\tvec2 pos = getuv;\n\n\n  \n    \n    float posx = pos.x;\n\n    vec2 uv = pos;\n    \n    float bgWave = 0.4;\n    float disMul = 1.0;\n    float globalFade = 1.;\n    float it = time*4.;\n    float headTilt = it*0.5; // 4\n    float headTiltMul = 0.1;\n    vec2 offset = vec2(-0.2, (sin(pow(abs(sin(time*3.)), 3.0)))*0.05 + 0.05);\n    float scale = 1.0;\n\n    vec2 ds = vec2(sin(pos.y*1.6+pos.x*.3 + time*0.2), cos(pos.x*2.7+pos.y*1.3 + time*0.3));\n\n    \n    ds = ds*noise(pos*pos+ds);\n    \n    vec3 col;\n    \n  \n    const int verlen = 23;\n  \n    vec2 verts[verlen] = vec2[verlen](\n            \n            // Root / Neck\n            vec2(0, 0.5),  // 0\n            // Head top\n            vec2(0.1, 0.8), // 1\n            // Hair\n            vec2(-0.3, 0.3), vec2(-0.4, 0.5), vec2(-0.4, 0.4), // 2,3,4\n            // eye\n            vec2(0.1, 0.7), vec2(0.15, 0.68), // 5,6\n            // body bottom\n            vec2(0, -0.1), // 7\n            // left leg\n            vec2(0, -0.5), vec2(0, -0.9), // 8,9\n            // right leg\n            vec2(0, -0.5), vec2(0, -0.9), // 10,11\n            // left arm\n            vec2(-0.3, 0), vec2(-0.2, -0.3), // 12, 13\n            // right arm\n            vec2(0.3, 0), vec2(0.7, 0), // 14, 15\n            // staff\n            vec2(0.7, -0.7), vec2(0.7, 0.5), // 16, 17\n            // face\n            vec2(0.05, 0.75), vec2(0.2, 0.66), vec2(0.18, 0.6), vec2(0.1, 0.6),\n            // right hand\n            vec2(0.75, 0)\n            \n     \n    );\n        \n        \n    vec2 tverts[verlen];\n \n    const int linelen = (3+1+1+2+2+2+2+1+4+1)*2;\n \n    int lines[linelen] = int[linelen]( \n            // hair\n            1, 2, 1, 3, 1, 4,\n            // eye\n            5, 6,\n            // body bottom\n            0, 7, \n            // left leg\n            7, 8, 8, 9,\n            // right leg\n            7, 10, 10, 11,\n            // left arm\n            0, 12, 12, 13,\n            // right arm\n            0, 14, 14, 15,\n            // staff\n            17, 16,\n            // face\n            18, 19, 19, 20, 20, 21, 21, 0,\n            // right arm\n            15, 22\n            );\n            \n           \n            \n    float widths[linelen] = float[linelen]    \n    (\n            // hair\n            0.0, 0.5, 0.0, 0.5, 0.0, 0.5,\n            // eye\n            0.1, 0.,\n            // body bottom\n            0.3, -0.5, \n            // left leg\n            0.2, 0.5, -0.4, 0.2,\n            // right leg\n            0.2, 0.5, -0.4, 0.2,\n            // left arm\n            0.1, 0.15, 0.15, 0.1,\n            // right arm\n            0.1, 0.15, 0.15, 0.1,\n            // staff\n            -0.1, 0.1,\n            // face\n            0.05, 0.0, 0.0, -0.25, -0.05, 0.0, 0.0, 0.05,\n            // right arm\n            -0.1, 0.3\n    \n    );\n            \n    const int skellen = (1+3+2+1+2+2+2+2+2+4+1)*2;\n\n\n    int skel[skellen] = int[skellen](\n        // head\n        0, 1,\n        // hair\n        1,2,1,3,1,4,\n        // eye\n        1,5,5,6,\n        // body bottom\n        0, 7,\n        // left leg\n        7, 8, 8, 9,\n        // right leg\n        7, 10, 10, 11,\n        // left arm\n        0, 12, 12, 13,\n        // right arm\n        0, 14, 14, 15,\n        // staff\n        15, 16, 15, 17,\n        // face\n        1, 18, 1, 19, 1, 20, 1, 21,\n        // right arm\n        15, 22\n        );\n\n\n    // root 0\n    // head 1 -> 0\n\n\n    mat2 mats[skellen];\n\n    for (int i = 0; i < verts.length(); i++)\n        tverts[i] = verts[i];\n\n    for (int i = 0; i < skellen; i++)\n        mats[i] = mat2(1, 0, 0, 1);\n        \n    mats[0] = r2d(ds.x*0.1);\n   \n    mats[0][0] += sin(time)*0.2;\n    \n    // legs\n    mats[8] = r2d(cos(it)*0.3);\n    mats[9] = r2d((-cos(it)+1.)*-0.2);\n    \n    mats[10] = r2d(-cos(it)*0.3);\n    mats[11] = r2d((-sin(it)+1.)*-0.2);\n    \n    // more noise\n    it += ds.x;\n    \n    // head\n    mats[1] = r2d(-sin(headTilt)*headTiltMul);\n\n\n    // arms\n    mats[12] = r2d(sin(it)*0.25);\n    \n    mats[13] = r2d(sin(it)*0.25);\n   \n    mats[14] = r2d(cos(it)*0.25);\n    mats[15] = r2d(sin(it)*0.2);\n   \n    // some noise\n    mats[2] = r2d(ds.x);\n    mats[3] = r2d(ds.x);\n    mats[4] = r2d(ds.x);\n    \n\n    for (int i = 0; i < skellen; i+=2)\n    {\n        int mi=skel[i],mi2=skel[i+1];\n\n        mats[mi2] *= mats[mi];\n       \n        vec2 dir = verts[mi2] - verts[mi];\n\n        dir = mats[mi2] * dir;\n\n        tverts[mi2] = tverts[mi] + dir;\n\n    }\n\n    for (int i = 0; i < verlen; i++)\n        tverts[i] = tverts[i]*scale + offset;\n\n\n    float d = 0.;\n    float c = 0.;\n    float thh = 0.;\n\n    for (int i = 0; i < linelen; i += 2)\n    {\n        vec2 p0 = tverts[lines[i]];\n        vec2 p1 = tverts[lines[i+1]];\n\n\n        float dist = length(p0 - pos);\n\n        vec2 dir = p1 - p0;\n        float len = length(dir);\n\n        float nlen = length(pos - p0);\n\n        vec2 ndir = normalize(dir);\n        \n        float normalizedDist = nlen / len;\n        \n        float distToCenter = length(pos - (p0+p1)*0.5) / len;\n\n        float w0 = widths[i];\n        float w1 = widths[i+1];\n\n        float tdist = length(pos + ds - p0);\n            \n        float width = mix(w0, w1, tdist)*0.2;\n\n\n\n        for (float th = -0.8; th <= 0.8; th += 0.2)\n        {\n\n            \n\n            \n            vec2 dis = vec2(-ndir.y, ndir.x)*th*width; // *(1.0-dist);\n            \n            dis += dis.x+cos(abs(pos.x*3.)*0.21 + time + th*3.0 + ds.y)*0.1*(1.0 - distToCenter*distToCenter);\n            \n           \n            dis *= 20.*width;\n\n\n\n            float dd = udSegment(pos + ds*len*0.04 + dis, p0, p1);\n            float dd2 = dd;\n            \n            \n            dd = 0.0 - dd;\n            dd = smoothstep(-0.01, 0.03, dd); \n            dd = dd*(1.0 - dist)*2.0*th;\n            dd = abs(dd);\n            \n\n            d = d + dd * max(1.0-distToCenter*distToCenter*4., 0.); // (d2 + ddd*0.02)*min(d + dd*0.1, 0.5);\n\n            c += smoothstep(-0.25, 0.45, -dd2 + ds.x*0.1)*0.15 + th*4.0*d;\n\n             thh += sin(th*24.0+ds.x)*d;\n        }\n        \n        thh = clamp(thh, -0.7, 0.7);\n\n\n\n    }\n   \n\n    col = mix(vec3(1.0, 0.3, 0.1)*(1.0 + cos(1.2+ds.y+thh)*0.7), vec3(0.8, 0.9, 0.2),min(d*c, 1.0))*(d + c*0.1); // + sin(c*0.4+d*0.3+time)*0.3); //*(d + noise(pos*1.0+d)*c*0.2);\n    col = mix(col, vec3(0.3, 0.2, 0.9)*d, thh); //min(noise(pos+c)*2.9, 1.0) );\n   \n    col += pow(c, 0.8 + sin(it+ds.y)*0.2)*0.2;\n\n\n    \n    float staffBall = smoothstep(0.6, 1.1, 1.-length(pos - tverts[17]));\n    staffBall *= staffBall;\n    \n    float wall = noise((pos*vec2(0.25, 24.0) + vec2(time, 0)));\n    wall = smoothstep(-0.5, 2.4, wall+noise(pos + vec2(time*0.5, 0)))*3.0;\n    wall *= wall;\n    \n    vec3 bg = mix(vec3(0.7, 0.2, 0.1), vec3(0.4, 0.4, 0.55), \n        \n        wall + staffBall + \n        noise(vec2(0.1 + time, 0.4+uv.y + c)*0.2)\n        );\n   \n   bg = mix(bg, bg*bg*c, 0.5 + 1.0-c);\n   \n   col.rgb += staffBall*vec3(0.95, 0.9, 0.2);;\n    \n    col.rgb = mix(bg, col.rgb, min(0.5 + c, 1.0))*globalFade;\n    \n\n    fragColor = vec4(col,1.0);\n}             ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}