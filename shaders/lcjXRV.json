{
    "Shader": {
        "info": {
            "date": "1706576419",
            "description": "Pixel-perfect integer pixel<->hex conversions, suitable for tilemaps.\nHold LMB for vertical orientation.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcjXRV",
            "likes": 7,
            "name": "Integer pixel<->hex",
            "published": 3,
            "tags": [
                "pixel",
                "map",
                "hexagon",
                "tile"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Pixel-perfect integer pixel<->hex conversions, suitable\n// for tilemaps.\n//\n// Conventions.\n// Pixel corners are at integers, pixel centers\n// are at half-integers. Pixel indexed (0,0)\n// spans [0;1]x[0;1] and has center at (0.5,0.5).\n// Hexes are indexed by cube coordinates, see\n// https://www.redblobgames.com/grids/hexagons/ for\n// detailed explainations. Briefly, cube coordinates\n// are (x,y,z) subject to x+y+z=0, with hex centers at\n// all-integer points (NOTE: the specific choice\n// of x,y,z directions is different from the above\n// article).\n// Cartesian coordinates are +x=right, +y=up.\n// Two hexagon orientations are denoted LONG (⬣)\n// and TALL (⬢), and their corresponding cube\n// coordinate systems are:\n//     LONG           TALL\n//      +x=E           +x=SE\n//      +y=NW          +y=N\n//      +z=SW          +z=SW\n// Requirements for tile sizes are (m,n integer):\n//     LONG           TALL\n//      width =4*m     width =2*m\n//      height=2*n     height=4*n\n// NOTE: the proportions of the regular\n// hexagon's AABB in topdown and isometric (1:1:1)\n// view are:\n//                LONG           TALL\n//     Topdown    2:sqrt(3)      sqrt(3):2\n//     Isometric  sqrt(2):1      3:sqrt(8)\n// Some of the integer ratios closely approximating\n// these are:\n//       2:sqrt(3)          sqrt(2):1           3/sqrt(8)\n//     4x4,    15.47%     4x2,    29.29%      4x4,     5.72%\n//     8x6,    13.40%     8x6,     6.07%      22x20,   3.71%\n//     12x10,   3.77%     12x8,    5.72%      26x24,   2.14%\n//     16x14,   1.04%     20x14,   1.01%      30x28,   1.02%\n//     28x24,   1.03%     48x34,   0.17%      34x32,   0.17%\n//     32x28,   1.04%     68x48,   0.17%      72x68,   0.17%\n//     44x38,   0.28%     84x60,   1.01%      106x100, 0.062%\n//     48x42,   1.04%     88x62,   0.36%      140x132, 0.0051%\n//     60x52,   0.074%    116x82,  0.030%     174x164, 0.030%\n//     72x62,   0.56%     256x182, 0.54%      208x196, 0.053%\n//     76x66,   0.27%     280x198, 0.0051%    242x228, 0.070%\n//     80x70,   1.04%     284x200, 0.41%      246x232, 0.030%\n//     84x72,   1.03%     300x212, 0.062%     314x296, 0.014%\n//     92x80,   0.41%     396x280, 0.0051%    454x428, 0.0082%\n//     100x86,  0.70%     512x362, 0.011%     594x560, 0.0051%\n//     104x90,  0.074%    676x478, 0.00087%   734x692, 0.0032%\n//     128x110, 0.77%\n//     148x128, 0.13%\n//     160x138, 0.41%\n//     164x142, 0.019%\n//     180x156, 0.074%\n//     200x174, 0.46%\n//     220x190, 0.28%\n//     224x194, 0.0053%\n//     256x222, 0.13%\n//     300x260, 0.074%\n//     388x336, 0.0053%\n// Of course, you may choose another ratio entirely.\n// Tie-breaking rules (for pixel centers exactly on hex edges)\n// are (but you can adjust them to your preferred ones):\n//     LONG: pixel belongs to the left edge.\n//     TALL: pixel belongs to the top edge.\n// NOTE: this is NOT the same as top-left rule in rasterization.\n\n// Euclidean division.\n// See https://www.shadertoy.com/view/lcSXRG\n// for a more general version.\nivec2 DIV(int x,int y)\n{\n    int q=abs(x)/abs(y),r=abs(x)%abs(y);\n    if(x<0&&r!=0) {q=q+1;r=int(abs(y))-r;}\n    return ivec2((x^y)<0?-q:q,r);\n}\n\n#define LONG 0\n#define TALL 1\n\n// NOTE: in the code below:\n//     o - orientation (LONG/TALL)\n//     s - tile size (width,height)\n//     p - pixel coordinates (or pixel index; center=index+(0.5,0.5))\n//     h - hex index (in cube coordinates)\n\n// Returns pixel coordinates of hex's center.\n// NOTE: center is at pixel corner, and\n// has integer coordinates.\nivec2 hex2pixel(int o,ivec2 s,ivec3 h)\n{\n    return o==TALL?\n        ivec2((s.x*(h.x-h.z))>>1,(3*s.y*h.y)>>2):\n        ivec2((3*s.x*h.x)>>2,(s.y*(h.y-h.z))>>1);\n}\n\n// Returns hex containing the pixel indexed p.\n// NOTE: pixel2hex(...)==ivec3(0) is a useful\n// way to test if pixel is within hex (when\n// generating spritesheet, etc.).\nivec3 pixel2hex(int o,ivec2 s,ivec2 p)\n{\n    if(o==TALL)\n    {\n        ivec2 x=DIV(2*p.x+1,s.x);\n        ivec2 y=DIV(4*p.y+2,s.y);\n        int X=x.x,Y=y.x;\n        int d=(((X^Y)&1)==0?x.y*s.y-y.y*s.x:s.x*s.y-(x.y*s.y+y.y*s.x));\n        // Other comparisons, e.g. d-((X^Y)&1)>=0,\n        // yield different tie-breaking rules.\n        Y=DIV(Y+(d>=0?1:2),3).x;\n        X=((X-Y+1)>>1);\n        return ivec3(X,Y,-X-Y);\n    }\n    else\n    {\n        ivec2 x=DIV(4*p.x+2,s.x);\n        ivec2 y=DIV(2*p.y+1,s.y);\n        int X=x.x,Y=y.x;\n        int d=(((X^Y)&1)==0?y.y*s.x-x.y*s.y:s.x*s.y-(y.y*s.x+x.y*s.y));\n        // Other comparisons, e.g. d+((X^Y)&1)>0,\n        // yield different tie-breaking rules.\n        X=DIV(X+(d>0?1:2),3).x;\n        Y=((Y-X+1)>>1);\n        return ivec3(X,Y,-X-Y);\n    }\n    return ivec3(0);\n}\n\n// Convert (floating-point!) pixel coordinates\n// to cube coordinates. Useful coordinate system\n// for generating things inside a hex.\nvec3 pixel2cube(int o,ivec2 s,vec2 p)\n{\n    return o==TALL?\n        (mat2x3(+3,0,-3,-2,+4,-2)/3.0)*(p/vec2(s)):\n        (mat2x3(+4,-2,-2,0,+3,-3)/3.0)*(p/vec2(s));\n}\n\nvec3 pixel2cube(int o,ivec2 s,ivec2 p) {return pixel2cube(o,s,vec2(p)+0.5);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float PIXEL_SIZE=8.0;\n    vec2 xy=(fragCoord-0.5*iResolution.xy)/PIXEL_SIZE;\n    int o=(iMouse.z>0.0?TALL:LONG);\n    // Size chosen to showcase tie-breaking. 12:10 is another one.\n    ivec2 s=(o==1?ivec2(8,16):ivec2(16,8));\n    ivec2 p=ivec2(floor(xy));\n    ivec3 h=pixel2hex(o,s,p);\n    // h=ivec3(roundEven(pixel2cube(o,s,vec2(hex2pixel(o,s,h)))));\n    ivec2 c=hex2pixel(o,s,h);\n    vec3 col=vec3(0.5);\n    col+=0.25*sin(2.0*vec3(h)+vec3(0,2,4));\n    col+=(0.5+0.25*sin(2.0*vec3(h)+vec3(0,2,4)))*smoothstep(0.5,0.25,length(xy-vec2(c)));\n    if(true) // Pixel grid.\n    {\n        col*=0.25+0.75*smoothstep(0.0,1.0*fwidth(xy.x),0.5-abs(fract(xy.x)-0.5));\n        col*=0.25+0.75*smoothstep(0.0,1.0*fwidth(xy.x),0.5-abs(fract(xy.y)-0.5));\n    }\n    if(true) // Hex grid.\n    {\n        vec3 r=pixel2cube(o,s,xy);\n        // See https://www.shadertoy.com/view/dtySDy\n        vec3 c=r+round((floor(r.zxy-r)-floor(r-r.yzx))/3.0);\n        c=abs(c-c.yzx);\n        col=mix(col,vec3(0.25,0.25,0.75),smoothstep(1.0-0.25*length(fwidth(xy)),1.0,max(max(c.x,c.y),c.z)));\n    }\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}