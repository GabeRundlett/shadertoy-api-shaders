{
    "Shader": {
        "info": {
            "date": "1700639362",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "DtyyWK",
            "likes": 10,
            "name": "spqr hilbert satelite",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nfloat hash12(vec2 p ) {\n  float a = fract(sin(p.x * 4321.531) * 9831.113);\n float b = fract(sin(p.y * 5959.951) * 7891.517);\n float c = fract(\n sin(a * 4523.232 + b * 5490.954) * 9954.234);\n return c;\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\n\n\n\n\n\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  r = smoothstep(0.,1.,r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\n\n\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    //return max(max(q.x,q.y),q.z);\n   return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\n\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n\n\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(sin((p3.x + p3.y) * p3.z)*3523.252);\n}\nvec3 hash33 (vec3 p) {\n    float x = hash31(p);\n    float y = hash31(p + vec3(1231.41, 48.42, 77.12));\n    float z = hash31(p + vec3(17.94, 111.42, 212.55));\n    return vec3(x,y,z);\n    \n}\n\n\nfloat confine(vec3 p, vec3 r, vec3 d) {\n \n    vec3 bot = (-d * 0.5 - p)/r;\n    vec3 top =  (d * 0.5 - p)/r;\n\n    vec3 min = min(top, bot);\n\n    float t = max(max(min.x, min.y), min.z);\n\n    return max(t, 0.0); \n}\n\n\n\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise_fast(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\n\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat noise_trig(vec3 p) {\n    \n    vec3 u = vec3(0.);\n    u += sin(p.x) + cos(p.y/2.42) + sin(p.z/5.151);\n    return length(u);\n    \n\n}\nfloat fbm_fast( vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise_trig(freq * p);\n        //res += amp * noise(freq * p);\n      \n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n \nfloat fbm( vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 2; ++i)\n    {\n        //res += amp * noise_fast(freq * p);\n        res += amp * noise(freq * p);\n      \n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat field ( vec3 p , vec3 r) {\n\n   \n  \n  \n\n\n    vec3 dom = vec3(2.);\n    vec2 id = floor(p.xz/dom.xz-0.5);\n    p.xz = (fract(p.xz/dom.xz-0.5)-0.5)*dom.xz;\n   \n    vec3 size = hash33(vec3(id,9.324));\n    float prob = hash21(id);\n    \n    //float lim = .3;\n    \n    //lim += sin(id.x*17.41 + id.y * 21.31)/1.;\n    \n    if ( prob > (sin(tick(iTime*.41))*.5+.5 )*.5 + .5) { \n        size *= -1.;\n    }\n\n \n   \n  \n    float b1 = box(p, size);\n    float bound = confine(p, r, dom)+.2;\n    b1 = min(b1,bound);\n    \n    return b1;\n     \n\n}\n\nfloat map(vec3 p, vec3 r) {\n\n\n\n\n    // geo\n    \n    \n    // cylinder map\n    //vec3 q1  = -vec3(atan(p.y,p.x)*3., length(p.xy)-10.,p.z);\n    \n    // sphere map\n    p  =  vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\n   \n  \n\n    float z = 1e4;\n    float f = 1.;\n    \n    for ( float i = 0.; i < 4.; i++) {\n        p *= f;\n        p += vec3(12.341,0.,41.343)* i;\n        f *= 1.4;\n        float u = field(p,r)/f;\n        z = min(z,u);\n    \n    }\n    return z;\n    \n   \n}\n\n\n\n\n\n\nvec3 norm(vec3 p,vec2 d, vec3 r)\n{\n  return normalize(vec3(\n    map(p+d.yxx,r)-map(p-d.yxx,r),\n    map(p+d.xyx,r)-map(p-d.xyx,r),\n    map(p+d.xxy,r)-map(p-d.xxy,r)\n  ));\n}\n\n\nvec3 norm3(vec3 p,vec3 r) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p,r)-vec3(map(p-off.xyy,r), map(p-off.yxy,r), map(p-off.yyx,r))+0.000001);\n}\nfloat hash( float p )\n{\n\tfloat h = dot(p,127.1);\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nvec3 hash13( float p )\n{\n\treturn vec3( hash(p), hash(p+653.13), hash(p+211.22) );\n    \n}\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\n\nvec3 norm(vec3 p, vec3 r) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p,r)-vec3(map(p-off.xyy,r), map(p-off.yxy,r), map(p-off.yyx,r))+0.000001);\n}\nfloat sinz(float t){ \n    t *= .6;\n    return \n        sin(t) + \n        cos((t+22.5)*2.1)/2.3 + \n        sin((t+40.11)*5.15)/6.1 + \n        cos((t+333.2)*11.)/10.1\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n \n // nav\n \n float tt = iTime;\n \n  vec3 s = vec3(0,0,-20);\n  vec3 t = vec3(0);\n\n  \n  s.xz *= rot(tick(iTime*.4));\n  s.yz *= rot(cos(tick(iTime*.31)));\n \n  \n  //s.z += sinz(tt*1.)*1.;\n  //t.y += sinz((tt+.1)*4.)*.2;\n  \n \n \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(vec3(0,1,0),cz));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz -= dot(uv,uv)/10.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // mar\n \n  for(float z=0.;z<500.;z++){ \n    //p += (fbm(p))/100.;\n    i = z;\n    d = map(p,r);\n\n    if ( d < .01 ) {\n      hit = true;\n      break;\n    } \n    if ( dd > 100.) {\n        break;\n    }\n    dd += d;\n    p += r * d;\n    \n    \n\n  }\n \n  \n  \n  // hue\n  \n  vec3 col = vec3(0);\n\n\n\n  \n  \n     vec3 n = norm(p,r);\n     vec3 l1 = normalize(vec3(-1,-4,-1));\n     l1.xz *= rot(tt);\n     \n     \n\n   \n     \n        \n     if ( dot(n,l1) < 0.) {\n              l1 = -l1;\n     }\n\n     vec3 h1 = normalize(l1-r);\n     \n     \n     float spec1 =( 0.4 + pow(max(0., dot(n,h1)),41.));\n    \n     float diff = max(0., dot(n,l1));\n     \n     col += diff * (spec1*2.);\n     \n\n\n     if (!hit) {\n        col =  mix( vec3(.2,.3,.5)*2., vec3(.1,.2,.3), pow(dot(vec3(0,0,1), r)*.5+.5, 3.)    );\n    \n     }\n  \n \n     fragColor = vec4(col, 1.0);\n\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}