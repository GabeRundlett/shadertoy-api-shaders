{
    "Shader": {
        "info": {
            "date": "1517213261",
            "description": "Making order :: wraped grid\n\nArt shader.Cineshader support\n[url] https://cineshader.com/view/ltSBDV",
            "flags": 0,
            "hasliked": 0,
            "id": "ltSBDV",
            "likes": 6,
            "name": "Making order :: wraped grid",
            "published": 3,
            "tags": [
                "wrapegrid",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "kojdj0811",
            "viewed": 1783
        },
        "renderpass": [
            {
                "code": "//Chose output mode.\n// 0 : Grid.\n// 1 : Gradient circle.\n// 2 : Wave.\n// 3 : Gradiented wave.\n// 4 : Wraped wave.\n// 5 : Gradient wraped wave.\n// 6 : Wraped grid.\nint outputMode = 6;\n\n\n\n//Read \"mainImage\" first.\n\n//Reading order : mainImage -> GetWave -> GetGrid\n\n\n\nvec4 GetWave (vec2 origin, vec2 fragCoord, float amplitude, float waveFactor, float wavelength ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float screenRatio = iResolution.x / iResolution.y;\n    \n    //Make uv to regular quadrilateral.\n    uv.x = uv.x * screenRatio;\n    uv.x -= (iResolution.x - iResolution.y)/iResolution.y * 0.5;\n    \n    float dist = 1.0 - distance(origin, uv)*2.0;\n    \n    return vec4( amplitude*(sin(waveFactor + dist * wavelength) + 1.0) * 0.5 );\n}\n\n\n\nbool GetGrid (vec2 fragCoord, float gap, float thickness) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float screenRatio = iResolution.x / iResolution.y;\n\n    //Make uv to regular quadrilateral.\n    uv.x = uv.x * screenRatio;\n    uv.x -= (iResolution.x - iResolution.y)/iResolution.y * 0.5;\n    \n    bool culm = abs( sin(uv.x * gap) ) > thickness;\n    bool row  = abs( sin(uv.y * gap) ) > thickness;\n    return culm || row;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat screenRatio = iResolution.x / iResolution.y;\n    vec2 origin = vec2(0.5, 0.5);\n    \n    origin = iMouse.xy / iResolution.xy;\n    origin.x = origin.x * screenRatio;\n    origin.x -= (iResolution.x - iResolution.y)/iResolution.y * 0.5;\n    \n    \n    //Make uv to regular quadrilateral.\n    uv.x = uv.x * screenRatio;\n    uv.x -= (iResolution.x - iResolution.y)/iResolution.y * 0.5;\n    \n    \n    \n    //Create squared grid.\n    float gap = 35.0;\n    float thickness = 0.997;\n    bool culm = abs( sin(uv.x * gap) ) > thickness;\n    bool row  = abs( sin(uv.y * gap) ) > thickness;\n    vec4 grid = vec4(culm || row);\n   \n    \n    \n    //Create gradient circle.\n    float dist = 1.0 - distance(origin, uv) * 2.0;\n    vec4 gradientCircle = vec4(dist);\n    \n    \n    \n    //Create wave.\n    float amplitude  = 10.0;            //Usually, 0.0 ~ 1.0\n    float waveFactor = iTime * 6.0;\n    float wavelength = 18.0;\n    vec4 wave = vec4(amplitude*(sin(waveFactor + dist * wavelength) + 1.0) * 0.5 );\n    \n    \n    \n    //Create gradiented wave.\n    vec4 gradientedWave = gradientCircle * wave;\n    \n    \n    \n    //Create wrap direction.\n    vec2 top    = vec2( 0.0,  1.0);\n    vec2 bottom = vec2( 0.0, -1.0);\n    vec2 right  = vec2( 1.0,  0.0);\n    vec2 left   = vec2(-1.0,  0.0);\n    \n    vec4 wave_top    = gradientCircle * GetWave (origin, fragCoord.xy + top,    amplitude, waveFactor, wavelength );\n    vec4 wave_buttom = gradientCircle * GetWave (origin, fragCoord.xy + bottom, amplitude, waveFactor, wavelength );\n    vec4 wave_right  = gradientCircle * GetWave (origin, fragCoord.xy + right,  amplitude, waveFactor, wavelength );\n    vec4 wave_left   = gradientCircle * GetWave (origin, fragCoord.xy + left,   amplitude, waveFactor, wavelength );\n    \n    float wrapPower = 100.0;\n    vec2 wrapDir = vec2(wave_top.r - wave_buttom.r, wave_right.r - wave_left.r) * vec2(wrapPower);\n    \n    \n    \n    //Create wraped wave\n    vec4 wrapedWave = GetWave (origin, fragCoord.xy + wrapDir, amplitude, waveFactor, wavelength ); \n    \n    \n    \n    //Create wraped gradiented wave\n    vec4 gradientWrapedWave = gradientCircle * wrapedWave;\n    \n    \n    //Create wraped grid.\n    vec4 wrapedGrid = float(gradientCircle.r > 0.0) * vec4(GetGrid (fragCoord.xy + wrapDir, gap, thickness))\n        + float(gradientCircle.r < 0.0) * grid;\n        \n    \n    \n    \n     /*\n    vec3 grad = vec3(wave_right.x - wave_left.x, wave_top.x - wave_buttom.x, 1.0);\n    grad = normalize(grad);\n    vec4 c = wrapedGrid;\n    vec3 light = normalize(vec3(.2,-.5,.7));\n    float diffuse = dot(grad,light);\n    float spec = pow(max(0.,-reflect(light,grad).z),32.);\n    vec4 lighted = mix(c,vec4(.7,.8,1.,1.),.25)*max(diffuse,0.) + spec;\n    */\n    \n    \n    \n    \n    \n    \n    vec4 outputColor;\n\n    \n    if (outputMode == 0)\n    \toutputColor = grid;\n    else if (outputMode == 1)\n        outputColor = gradientCircle;\n    else if (outputMode == 2)\n        outputColor = wave;\n    else if (outputMode == 3)\n        outputColor = gradientedWave;\n    else if (outputMode == 4)\n        outputColor = wrapedWave;\n    else if (outputMode == 5)\n        outputColor = gradientWrapedWave;\n    else if (outputMode == 6)\n        outputColor = wrapedGrid;\n\n    fragColor = outputColor;\n    fragColor.a *= 0.03;\n\t//fragColor = vec4(lighted);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}