{
    "Shader": {
        "info": {
            "date": "1595371362",
            "description": "These stars will help mellow you out.\n\nMess around with some constants, PALETTE, or STARS to change behavior.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlBcDV",
            "likes": 3,
            "name": "Drunk Stars",
            "published": 3,
            "tags": [
                "lines",
                "intersection",
                "star",
                "rotating",
                "expanding"
            ],
            "usePreview": 0,
            "username": "timeisbeautifulhere",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "\n//Grab a slice\n#define PI 3.14159\n\n//How thicc the lines are.\n#define LINE_WIDTH 0.01\n\n//How fast the stars expand.\n//Higher value is more \"explosive\"\n#define EXPAND_RATE 0.1\n\n//Decide when stars should start to loop back.\n//Affects how close each star renders.\n#define MAX_RADIUS 8.0\n\n//How fast the stars spin.\n#define ROTATION_RATE 0.25\n\n//Arrays of stars, in order, to display\n#define NUM_STARS 6\nint STARS[NUM_STARS] = int[](5,6,7,8,9,10);\n\n//Color palette to cycle through for lines.\n#define PALETTE_LENGTH 7\nvec3[PALETTE_LENGTH] PALETTE = vec3[](\n    vec3(1.0,0.0,0.0),\n    vec3(0.0,1.0,0.0),\n    vec3(0.0,0.0,1.0),\n    vec3(1.0,1.0,0.0),\n    vec3(0.0,1.0,1.0),\n    vec3(1.0,0.0,1.0),\n    vec3(1.0,1.0,1.0)\n);\n\n//Equations for finding coefficients for line\n//ax + by + c = 0\n//https://math.stackexchange.com/questions/637922/how-can-i-find-coefficients-a-b-c-given-two-points\nfloat line_a(vec2 pa, vec2 pb){\n    return pa.y-pb.y;\n}\nfloat line_b(vec2 pa, vec2 pb){\n    return (-1.0) * (pa.x-pb.x);\n}\nfloat line_c(vec2 pa, vec2 pb){\n    return (pa.x*pb.y)-(pb.x*pa.y);\n}\n\n//True if (x,y) is on a line between pa and pb\nbool onLine(float x, float y, vec2 pa, vec2 pb){\n    float a = line_a(pa,pb),\n        b = line_b(pa,pb),\n        c = line_c(pa,pb);\n    \n    if(abs(a)<0.0001 && abs(b)>0.0001){\n        //Horizontal line\n        return abs(pa.y-y) < LINE_WIDTH;\n    }\n    \n    if(abs(b)<0.0001){\n    \t//Vertical line\n        return abs(pa.x-x) < LINE_WIDTH;\n    }\n    \n    //Distance from line: |ax0+by0+c| / sqrt(a^2 + b^2)\n    float dist = abs(a*x + b*y + c) / sqrt((a*a)+(b*b));\n    \n    return dist < LINE_WIDTH;\n}\n\n//Expect [-1,1]\nvec2 to_polar(vec2 uv){\n    return vec2(\n        atan(uv.y/uv.x), //degree\n        length(uv) //radius\n    );\n}\n\nvec2 to_cartesian(vec2 pc){\n    return vec2(\n        pc.y * cos(pc.x),\n        pc.y * sin(pc.x)\n    );\n}\n\n//Get point x of a star defined by n points around the origin,\n//with a certain radius.\nvec2 star_point(int total_points, int current_point, float radius, float rotation){\n    float angle = (2.0*PI*float(current_point))/float(total_points);\n    \n    vec2 point = vec2(\n        angle + rotation,\n        radius\n    );\n    \n    return to_cartesian(point);\n}\n\n//Get the color of a point if it happens to be on a star\n//defined by n points around the origin, of a specified radius.\n//Expect uv to be normalized [-1,1].\n//Returns a color if it collides with a star point, with nonzero alpha.\n//Returns black, with 0 alpha if no collision.\nvec4 star_collision(vec2 uv, int total_points, float radius, float rotation){\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    \n    for(int i=0; i<total_points; i++){\n        int target = (i+2)%total_points;\n        \n        vec2 p1 = star_point(total_points, i, radius, rotation);\n        vec2 p2 = star_point(total_points, target, radius, rotation);\n        \n        if(onLine(uv.x,uv.y,p1,p2)){\n            col = vec4(PALETTE[i%PALETTE_LENGTH], 1.0);\n            \n            float combined_dist =\n                distance(uv, p1) +\n                distance(uv, p2);\n            \n            col*=(1.0/pow(combined_dist*1.0, 2.0));\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = ((2.0)*fragCoord)/iResolution.xy - 1.0;\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // How large of a radius between each star rendered.\n    float dist_between_stars = MAX_RADIUS / float(NUM_STARS);\n    \n    float first_radius = iTime*EXPAND_RATE;\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    //Check each star in STARS for an intersection\n    for(int i=0; i<NUM_STARS; i++){\n        int cur_points = STARS[i];\n        float cur_radius = first_radius - (float(i)*dist_between_stars);\n        \n        if(cur_radius<0.0)\n            break;\n        \n        cur_radius = mod(cur_radius, MAX_RADIUS);\n        \n        float cur_rotation = mod(iTime*ROTATION_RATE, 2.0*PI);\n        if(i%2==1)\n            cur_rotation*=-1.0;\n        \n        vec4 result = star_collision(uv, cur_points, cur_radius,cur_rotation);\n        vec4 result2 = star_collision(uv, cur_points, cur_radius,(-1.0)*cur_rotation);\n        if(result.a > 0.0)\n            col = result.xyz;\n        if(result2.a > 0.0)\n            col = result2.xyz;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}