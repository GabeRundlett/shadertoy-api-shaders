{
    "Shader": {
        "info": {
            "date": "1700558295",
            "description": "mandelhub",
            "flags": 0,
            "hasliked": 0,
            "id": "DdtfD8",
            "likes": 0,
            "name": "mandelhub",
            "published": 3,
            "tags": [
                "mandelhub"
            ],
            "usePreview": 0,
            "username": "simplexqwe",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define Power 4.\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n    }\n\nfloat DE(vec3 pos,float time) {\n\tvec3 z = pos;\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.)*Power*dr + 1.;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta+time)*cos(phi+time), sin(phi+time)*sin(theta+time), cos(theta+time));\n\t\tz+=pos;\n\t}\n\treturn .5*log(r)*r/dr;\n}\n\nfloat GetDist(vec3 p){\n    return DE(p,0.);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n    \n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p = ro+rd*dO;\n    float ds=GetDist(p);\n    dO+=ds;\n    if(dO>MAX_DIST || abs(ds)<SURF_DIST) {\n      break;\n    }\n  }  \n  return dO;\n}\n\nvec3 GetNormal (vec3 p){\n    float d = GetDist(p);\n    vec2  e = vec2(.01,0.);\n    \n    vec3  n =d-vec3(\n    GetDist(p-e.xyy),\n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 LightPos = vec3 (0,1,-2);\n    //LightPos.xz  += vec2(sin(iTime),cos(iTime))*10.;\n    vec3 l        = normalize(LightPos-p);\n    vec3 n        = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),.5,1.);\n    float d   = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(LightPos-p))dif*=.25;\n    return dif;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro  = vec3(0,0.01,-3);\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1));\n    rd.yz*=Rot(iTime/50.);\n    ro.yz=(ro.yz)*Rot(iTime/50.);\n    \n    rd.xz*=Rot(iTime/10.);\n    ro.xz=(ro.xz)*Rot(iTime/10.);\n\n\n\n    float d = RayMarch(ro,rd);\n    vec3 p  = ro+rd*d;\n    \n    float dif =GetLight(p);\n    col = vec3(dif);\n    \n    vec3 n=vec3(length(GetNormal(p).xy));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}