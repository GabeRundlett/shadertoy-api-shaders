{
    "Shader": {
        "info": {
            "date": "1418094040",
            "description": "Experimenting with voxel... Use the mouse to rotate the camera.\nNote: the new PRNG function (hash) is from Dave_Hoskins (thanks!).",
            "flags": 0,
            "hasliked": 0,
            "id": "XtlGRr",
            "likes": 30,
            "name": "Voxel land",
            "published": 3,
            "tags": [
                "voxel"
            ],
            "usePreview": 0,
            "username": "Nrx",
            "viewed": 1424
        },
        "renderpass": [
            {
                "code": "// Parameters\n#define CAMERA_FOCAL_LENGTH\t\t1.5\n#define REFLECT_COUNT \t\t\t1\n#define REFLECT_INDEX\t\t\t0.4\n#define VOXEL_STEP_INCIDENT\t\t80.0\n#define VOXEL_STEP_REFLECTED\t20.0\n#define SOUND\n#define MOUSE\n#define HSV2RGB_FAST\n\n// Constants\n#define PI\t\t3.14159265359\n#define SQRT2\t1.41421356237\n#define DELTA\t0.01\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Get the music info\n\t#ifdef SOUND\n\tfloat soundBass = texture (iChannel0, vec2 (0.0)).x;\n\tfloat soundTreble = texture (iChannel0, vec2 (0.9, 0.0)).x;\n\t#else\n\tfloat soundBass = 0.6 + 0.4 * cos (iTime * 0.2);\n\tfloat soundTreble = 0.5 + 0.5 * cos (iTime * 1.2);\n\t#endif\n\n\t// Set the camera\n\tvec3 origin = vec3 (0.0, 10.0 - 8.0 * cos (iTime * 0.3), iTime * 10.0);\n\tfloat cameraAngle = iTime * 0.1;\n\t#ifdef MOUSE\n\tcameraAngle += 2.0 * PI * iMouse.x / iResolution.x;\n\t#endif\n\tvec3 cameraForward = vec3 (cos (cameraAngle), cos (iTime * 0.3) - 1.5, sin (cameraAngle));\n\tvec3 cameraUp = vec3 (0.2 * cos (iTime * 0.7), 1.0, 0.0);\n\tmat3 cameraRotation;\n\tcameraRotation [2] = normalize (cameraForward);\n\tcameraRotation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraRotation [1] = cross (cameraRotation [2], cameraRotation [0]);\n\tray = cameraRotation * ray;\n\n\t// Handle reflections\n\tvec3 colorMixed = vec3 (0.0);\n\tfloat absorb = 1.0;\n\tfloat voxelStepStop = VOXEL_STEP_INCIDENT;\n\tfor (int reflectNumber = 0; reflectNumber <= REFLECT_COUNT; ++reflectNumber) {\n\n\t\t// Voxel\n\t\tvec2 voxelSign = sign (ray.xz);\n\t\tvec2 voxelIncrement = voxelSign / ray.xz;\n\t\tfloat voxelTimeCurrent = 0.0;\n\t\tvec2 voxelTimeNext = (0.5 + voxelSign * (0.5 - fract (origin.xz + 0.5))) * voxelIncrement;\n\t\tvec2 voxelPosition = floor (origin.xz + 0.5);\n\t\tfloat voxelHeight = 0.0;\n\t\tbool voxelDone = false;\n\t\tvec3 voxelNormal = vec3 (0.0);\n\t\tfor (float voxelStep = 1.0; voxelStep <= VOXEL_STEP_INCIDENT; ++voxelStep) {\n\n\t\t\t// Compute the height of this column\n\t\t\tvoxelHeight = 4.0 * rand (voxelPosition)* smoothstep (0.2, 0.8, soundBass) * sin (soundTreble * PI * 0.5 + voxelPosition.x * voxelPosition.y);\n\n\t\t\t// Check whether we hit the side of the column\n\t\t\tif (voxelDone = voxelHeight > origin.y + voxelTimeCurrent * ray.y) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Check whether we hit the top of the column\n\t\t\tfloat timeNext = min (voxelTimeNext.x, voxelTimeNext.y);\n\t\t\tfloat timeIntersect = (voxelHeight - origin.y) / ray.y;\n\t\t\tif (voxelDone = timeIntersect > voxelTimeCurrent && timeIntersect < timeNext) {\n\t\t\t\tvoxelTimeCurrent = timeIntersect;\n\t\t\t\tvoxelNormal = vec3 (0.0, 1.0, 0.0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Next voxel...\n\t\t\t#if REFLECT_COUNT > 0\n\t\t\tif (voxelStep >= voxelStepStop) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t#endif\n\t\t\tvoxelTimeCurrent = timeNext;\n\t\t\tvoxelNormal.xz = step (voxelTimeNext.xy, voxelTimeNext.yx);\n\t\t\tvoxelTimeNext += voxelNormal.xz * voxelIncrement;\n\t\t\tvoxelPosition += voxelNormal.xz * voxelSign;\n\t\t}\n\t\tif (!voxelDone) {\n\t\t\tbreak;\n\t\t}\n\t\torigin += voxelTimeCurrent * ray;\n\n\t\t// Compute the local color\n\t\tvec3 mapping = origin;\n\t\tmapping.y -= voxelHeight + 0.5;\n\t\tmapping *= 1.0 - voxelNormal;\n\t\tmapping += 0.5;\n\t\tfloat id = rand (voxelPosition);\n\t\tvec3 color = hsv2rgb (vec3 (id + (iTime + floor (mapping.y)) * 0.05, 1.0, 0.7 + 0.3 * cos (id * iTime + PI * soundTreble)));\n\t\tcolor *= smoothstep (1.0 - 0.4 * cos (soundBass * PI), 0.1, length (fract (mapping) - 0.5));\n\t\tcolor *= 0.5 + smoothstep (0.5, 0.9, cos (id * 100.0 + iTime * 0.5));\n\t\tcolor *= 1.0 - voxelTimeCurrent / voxelStepStop * SQRT2;\n\n\t\t// Mix the colors\n\t\t#if REFLECT_COUNT == 0\n\t\tcolorMixed = color;\n\t\t#else\n\t\tcolorMixed += color * absorb;\n\t\tabsorb *= REFLECT_INDEX;\n\n\t\t// Reflection\n\t\tray = reflect (ray, voxelNormal);\n\t\torigin += ray * DELTA;\n\t\tvoxelStepStop = VOXEL_STEP_REFLECTED;\n\t\t#endif\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (colorMixed, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 13,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}