{
    "Shader": {
        "info": {
            "date": "1466409886",
            "description": "Second raymarching thing",
            "flags": 0,
            "hasliked": 0,
            "id": "lsVSWG",
            "likes": 3,
            "name": "Blob Raymarch",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "gunnarclovis",
            "viewed": 685
        },
        "renderpass": [
            {
                "code": "// whether or not to animate the raymarch\n#define ANIMATED true\n// 0 - 5 color modes\n// 0 white 2D\n// 1 light one-directional 2D shading\n// 2 3D shading greyscale\n// 3 inverted 3D shading\n// 4 rainbow 3D color shading\n// 5 final 3D color shading\n#define COLOR_MODE 5\n// whether or not to alter form vertically\n#define VERTICAL true\n// whether or not to alter form horizontally\n#define HORIZONTAL true\n// speed of animation, approach 0.0 to slow significantly\n// anything >= ~3.0 causes decay\n#define SPEED 2.5\n// the y-scale, alter to cause extreme stretch deformations\n#define Y_SCALE 0.15\n// the x-scale, alter to cause extreme stretch deformations\n#define X_SCALE 0.15\n// the maximum s-value that determines the complexity of the form\n// try high values like 50.0 or 150.0\n#define MAX_S 15.0\n// raymarch iterations\n// higher values make the form sharper while taking more processing time\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n\nfloat map(vec3 p)\n{\n    float v = SPEED * iTime;\n    float r = 2.75 * (iMouse.xy == vec2(0.0) ? 0.55 : smoothstep(0.0, iResolution.y, iMouse.y)),\n        s = MAX_S * (iMouse.xy == vec2(0.0) ? 0.75 : smoothstep(0.0, iResolution.x, iMouse.x));\n    float py = HORIZONTAL ? p.y : 1.0,\n        px = VERTICAL ? p.x : 1.0;\n    \n    if(ANIMATED)\n    \tr += Y_SCALE * cos(s * py + v) + X_SCALE * cos(s * px + v);\n    else\n        r += Y_SCALE * cos(s * py) + X_SCALE * cos(s * px);\n    \n    return length(p) - r;\n}\n\nvec3 grad(vec3 p)\n{\n    vec2 q = vec2(0.0, 0.05 * EPS);\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n               \tmap(p + q.xyx) - map(p - q.xyx),\n               \tmap(p + q.xxy) - map(p - q.xxy));\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t)\n{\n    if(COLOR_MODE == 0)\n        return vec3(1.0);\n    \n    else if(COLOR_MODE == 1)\n        return vec3(1.0) * dot(-rd, vec3(1.0));\n        \n    else if(COLOR_MODE == 2)\n        return vec3(1.0) * dot(-rd, normalize(grad(ro + t * rd)));\n        \n    else if(COLOR_MODE == 3)\n        return vec3(1.0) * (1.0 - dot(-rd, normalize(grad(ro + t * rd))));\n        \n    else if(COLOR_MODE == 4)\n        return normalize(grad(ro + t * rd));\n        \n    else // 5+\n        return vec3(0.3, 0.5, 0.7) * pow((1.0 - dot(-rd, normalize(grad(ro + t * rd)))), 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = 0.0, d = EPS;\n    for(int i = 0; i < STEPS; ++i)\n    {\n        d = map(ro + t * rd);\n        if(d < EPS || t > FAR) break;\n        t += d;\n    }\n    \n    // shading\n    vec3 col = d < EPS ? shade(ro, rd, t) : mix(vec3(0.0), vec3(0.7, 0.5, 0.2), 2.0 - length(uv));\n    \n    col = pow(col, vec3(0.45));\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}