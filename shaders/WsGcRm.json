{
    "Shader": {
        "info": {
            "date": "1602445408",
            "description": "I wanted to try out iq's box function to create rooms out of cube maps, just a quick doodle.. sorry for messy code.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsGcRm",
            "likes": 24,
            "name": "RoomsFromCubeMap",
            "published": 3,
            "tags": [
                "cubemap",
                "window",
                "room"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 733
        },
        "renderpass": [
            {
                "code": "// I wanted to try out iq's box function to create room/windows out of cube maps, \n// just a quick doodle.. sorry for messy code.\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst vec4 tint = vec4(0.4, 0.6, 0.9, 0.0);\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat tracePlane(in vec3 ro, in vec3 rd, in vec3 pp, in vec3 pn)\n{\n    float a = dot(pp - ro, pn);\n    float b = dot(rd, pn);\n    float t = a / b;    \n    return t;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n\nvec4 getWindow(vec3 worldSpacePos, vec3 rp, vec3 rd)\n{\n    float windowSize = 0.95;\n    vec3 n = vec3(0.0);\n    vec3 position_id = vec3(floor(worldSpacePos.xy * .5) * 2., 0.0);    \n    \n    vec3 relative_position = mod(worldSpacePos, 2.0)-1.0;    \n    vec3 boxCoordinate = -vec3(1., 1., .0) - position_id;\n\n    \n    vec2 hitp = boxIntersection(rp + boxCoordinate, rd, vec3(windowSize, windowSize, windowSize), n);\n    \n    \n    float id = rand(position_id.xy);\n    \n    if (hitp.x > 0.0 && abs(relative_position.x) < windowSize && abs(relative_position.y) < windowSize)\n    {\n        vec3 p = rp + rd * hitp.y;\n\t\tvec4 color = vec4(0.0);\n        \n        vec3 cubeCoordinate = p + boxCoordinate;\n        if (id > 0.5)\n        {\n        \tcolor = texture(iChannel3, cubeCoordinate);\n        }\n        else\n        {\n        \tcolor = texture(iChannel0, cubeCoordinate);\n        }\n\t\tcolor *= tint;\n        vec3 refl = reflect(rd, vec3(0.0, 0.0, -1.0));\n        color += texture(iChannel2, refl, 4.)*tint*.5;\n\n\t\t// light        \n        vec3 lightPos = vec3(0.0, .75, 0.0);\n        float flicker = rand(position_id.xy*.01);\n        float flickerPhase = 1.0;\n        if (flicker > 0.9)\n        {\n            flickerPhase = sin(cubeCoordinate.x*.1+cubeCoordinate.y*.4 + iTime * 4.0) + sin(iTime * 114.0);\n            flickerPhase = flickerPhase * 0.5 + 0.5;\n            flickerPhase = mix(flickerPhase, 1.0, clamp(sin(boxCoordinate.y*.1)+(rp.y - worldSpacePos.y)+1.5, 0.0, 1.0));\n        }\n        color += smoothstep(.4, -0., length(lightPos - cubeCoordinate)) * flickerPhase;\n        \n        color *= smoothstep(2.2, -0., length(lightPos - cubeCoordinate))*flickerPhase;\n        \n        // dirt\n        float dirt = rand(position_id.yx*.21);\n        if(dirt > 0.8)\n        {\n            color *= smoothstep(vec4(.0), vec4(.3), texture(iChannel1, position_id.xy*.4 + relative_position.xy*.1));\n        }            \n        \n        // balcony\n        float balcony = rand(position_id.xy*.15);\n        if(balcony > 0.7)\n        {\n            if(relative_position.y < -0.5)\n            {\n                color *= mod(relative_position.x, 0.05) * 1.;\n            }\n        }        \n        \n        // shades\n        float win = rand(position_id.yx*.3);\n        if(win < 0.4 && relative_position.y+1.> win)\n        {\n            color *= mod(relative_position.y, 0.1) * .5;\n        }\n        \n        // shading\n        color *= relative_position.y+1.;\n        return color;\n    }\n   \treturn vec4(.002);\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    color = vec4(.0);\n    \n    float t = tracePlane(rp, rd, vec3(0.0, 0.0, -.5), vec3(0.0, 0.0, 1.0));\n    vec3 plane_hit = rp + rd * t;\n    color = getWindow(plane_hit, rp, rd);\n}\n\n\n    \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    vec2 im = ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    if(iMouse.z <= 0.0)\n    {\n        im.xy = vec2(.25);\n    }      \n    im *= vec2(1.2, .5);\n    float T = iTime;\n\n    fragColor = vec4(0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, T, -10.5);\n    vec3 _rp = rp;\n    rp = roty(im.x) * rp;\n    rp.y = (rotx(im.y) *_rp).y;\n    rp.z += sin(iTime)*.2;\n    rp.xy += sin(iTime)* .2;\n    rd = lookat(rp, vec3(0.0, T, 0.0)) * rd;\n    trace(rp, rd, fragColor);\n    \n    fragColor *= 1.-length(uv*vec2(.99, 1.8))*1.;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}