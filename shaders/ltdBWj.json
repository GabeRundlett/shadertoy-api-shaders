{
    "Shader": {
        "info": {
            "date": "1541180623",
            "description": "drag mouse to set 2 note-blocks (centers and widths)\neasing and note-kerning is automated. (overlapping note-keys fuse to 1 long note)\n\ni need help with phase(-scaling)!\n\nsee CommonTab",
            "flags": 0,
            "hasliked": 0,
            "id": "ltdBWj",
            "likes": 3,
            "name": "starguitar 5",
            "published": 3,
            "tags": [
                "intersect",
                "synthesis",
                "aperiodic",
                "culling",
                "aabv",
                "kerning",
                "starguitar",
                "quadraticfield",
                "hash41",
                "nancarrow"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "void mainImage(out ve3 o,ve1 u\n){o=entryImage(iTime,u,iResolution,iMouse)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//lesson:\n//just use sg7 [ Xl3fWf ] and evaluate each frequency in a VERY seperate floor() context\n//that disregards all other frequencies.\n//meaning, a note that is not in a frewuency is a \"null-note\" for THIS frequency!\n//this \"null note\" is defined by range[-noteinf,-noteinf]\n//\n// sg11: https://www.shadertoy.com/view/4ltBWl   <- 2d xor failure , realization that sg7 is best and simplest\n// sg10: https://www.shadertoy.com/view/Ml3BDs   <- 2d xor failure\n//  sg9: https://www.shadertoy.com/view/llcfWl   <- 2d 2 notes fine, 3 notes fail (cheesy)\n//  sg8: https://www.shadertoy.com/view/llcfDX   <- 2d xor attempt 1 (looks smart but is just false)\n//  SG7: https://www.shadertoy.com/view/Xl3fWf   <- 1d SOLUTION (with 2 and 3...)   <-!!!!!!!!\n//  sg5: https://www.shadertoy.com/view/ltdBWj   <- 1d badphase & abs()\n//  sg4: https://www.shadertoy.com/view/XlcBDj   <- 1d kerning arithmetic works!\n//  sg3: https://www.shadertoy.com/view/lldfDB   <- 1d kerning arithmetic beta\n//  sg2: https://www.shadertoy.com/view/MttfWB   <- 2d very experimental\n//  sg1: https://www.shadertoy.com/view/MtdBWB   <- 2d concept analysis\n\n//kerning, synthesis, aperiodic, culling, aabv, starguitar, quadraticfield, hash41, nancarrow,intersect\n\n/*\ndrag mouse to set blue boxes  (starguitar 5 folds to 1d)\n- source is 2 blue boxes, that either\n- - contain another\n- - intersect\n- - are seperate\n- target is 1 red box; iff(not seperate) return AABV; else return box that is closer to uv.\n- - composites of all red boxes become a hull-curve, that auto-merge where they overlap\n\niMouse.xz set centers of 2 boxes\niMouse.zw set 2 halfwidths of 2 boxes\ncan be represented as triangles (red and green)\n, where imouse.xy sets +one triangle top\n, where imouse.zw sets +one triangle top\nline intersections (2 o 3 yellow dots) equate box intersections\n//if (bottom intersection.y<=0) the boxes intersect ([<=] for closedInterval, [<] for openInterval boxes)\n//top intersection.xy sets an AABV upper bound of both boxes\n\nIt alway bugged me how to define midi sheets, but also as distance field.x\n, where a note stops and another note starts, often at the same moment\nthis is a min() of 2 notes, that may or may not be the same single long note.\nthe whole .y domain is only relevant for visualization here.\nin a \nhttps://www.shadertoy.com/results?query=starguitar\nshader the .y domain will be \"frequency\" or \"keyboard key\" == frequency, scaled by a note key using;\nhttps://www.shadertoy.com/view/4ttBD4\n*/\n\n/*\nassume uv.x to be time\nassume uv.y to be frequency (piano key id)\n\nblue is a usual distance field, for now only rectangles are defined with this the \"starguitar\" extension\n- bright blue  means negative distance to a box surface\n- bright green means \"-(green) more iTime till first note starts\" (it counts up)\n\ngreen or red only measure Distance.x\ngreen is the (negative) distance to the nearest box to the right.\nred   is the (negative) distance to the nearest box to the left.\n\nuv.xy taps one point in time for one freuency. if its blue, there is a note played at iTime.x\n- green == how long this note has been played (till iTime == now)\n- red   == how long till this note ends       (till iTime == now) //not needed for pluck/percussion instruments\n\nred and green are negated (!)\n- to avoid overlap, when using the same fract() or smin() functions as for \"blue\"\n- to make the inherent (parallel projection) frustrum culling debugging easier.\n\nand only an min() union is defined, that was tricky enough\n- any break between 2 notes will appear yellow (or black with negateRG)\n- , this the negative-color of the note in terms of duration.\nred and green are negated to use the same smin() function to make them visible\n, without overlapping too much.\n*/\n\n//invert redGreen\n//#define negateRG\n\n//alternative color sceme fallof; *=1.-log(abs())\n//#define showGradLog\n\n/*\n\"starguitar\" defines shapes, where .w is the usual distance field as in the hg_sdf collection\nwhile .xy define center and (half)length of a note\nthe min() max() mixing cases for this had to be debugged in here\nbecause there are multiple different ways to bound this.\n\na possible extension to this, with derivatives, may even generate\nhttps://www.youtube.com/watch?v=4t0jDUQ2aJ4\nhttps://www.youtube.com/watch?v=RIz3klPET3o\nhttps://www.youtube.com/watch?v=XJpVbUICUb4\nbut procedurally\n*/\n\n\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n\n//2d zoom\n#define ViewZoom 8.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(r) (min(r.x,r.y)/ViewZoom)\n#define fra(t,u,r,m)(u-.5*r.xy)*ViewZoom/r.y\n\n//array indexing srarts at 0 within chinese remainders.\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n\nve0 ma(ve1 a){return max(a.x,a.y);}\n\n#define inf 99999.\n\n/*\nve2 box(ve1 u,ve1 w\n){w=abs(w)//no negative width\n ;ve2 r=ve2(-inf,-inf,1)\n ;r.z =ma(abs(u)-w)\n  ;r.y=w.x\n  ;r.x=u.x//this is much different for other shapes, only for simple shapes its close to r.z\n ;return r;}\n\n//t is time.x, we ned that to be able to only return 1 of 2 boxes, the one that is cloder to t.\nvec3 misg(float t,vec3 a,vec3 b){//.x stores center.x , .y stores halfwidth.x  , .z stores a \"distance\"\n ;vec3 r=vec3(0)\n ;return r\n ;}\n\n\nvec3 masg(vec3 a,vec3 b){\n ;vec3 r=vec3(0)\n ;r.x=min(a.x,b.x)\n ;r.y=min(a.y,b.y)\n ;r.z=max(a.z,b.z)\n ;//if(r.x<r.y)r.z-r.z\n ;return r\n ;}\n\n\nvec3 composition(float t,vec2 u,vec3 r,vec4 m){\n ;vec3 c=vec3(0)\n ;c.xyz=box(u-m.xy,vec2(0.61))\n ;//c.xyz=box(u-m.xy,vec2(1.25,.5))\n ;//c.xyz=box(u-m.xy,vec2(.5))\n ;c.xyz=misg(u.x,c.xyz,box(u,vec2(1.61))  )\n ;//c.xyz=masg(c.xyz,box(u-m.xy,vec2(1.)))\n ;return c\n ;}\n/**/\n\nvec4 segmentToTriangle(float t,vec2 u,vec3 r,vec2 m){\n ;vec4 c=vec4(0)\n ;c.x=-u.x+u.y+m.x-m.y\n ;c.y=-u.x-u.y+m.x+m.y\n ;c.z=u.y\n ;c=abs(c)\n ;return c;}\n\n#define tiny 0.0001\n    \nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D//get intersection of line[a,b] and line[c,d]\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//http://wiki.secondlife.com/wiki/Geometric\n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\n\n#define ls2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2((a-b),(c-b)))//pointAdistance to (diagonal) lineSegment from B to C\n\n//misg() is a 1d version of calculating the circumcircle of 2 circles , OR returning the closer circle.\nvec2 misg(float t,vec2 a,vec2 b\n){//a.x a.x are 2 centers , a.y b.y are 2 epsolin (radius.x)\n ;//if (a and b do not overlap) return minx(a,b,([t] skewed by a.y and b.y))//return box, closest to t\n ;//else if one completley surrounds the other) return maxx(b,a,step(a.y,b.c)) //return aabv\n ;//else (if they intersect) //return aabv\n ;return a;\n ;}\n\n//m.x m.z == centers of 2 notes#\n//m.y m.w ==halfwidths of 2 notes\n//t = uv.x=iTime, our input is 2 notes, but we fold it to the one note closest to t.\n\n\n\nvec4 gLLxXnp(vec4 n//return 2 intersections of 4 diagonals (2x 2d pyramid tips)\n){return vec4(vec2(n.x-n.y,0)-( n.x-n.y-n.z-n.w)*.5\n             ,vec2(n.z-n.w,0)-(-n.x-n.y+n.z-n.w)*.5);}\n\n\nvec2 miNote(float t,vec4 m//parent: https://www.shadertoy.com/view/XlcBDj\n){if(m.x>m.z)m=m.zwxy//must be sorted\n ;m.yw=abs(m.yw)//below code only allows for width>=0\n ;vec4 k=gLLxXnp(m)\n ;if(k.w<0.//2 ranges are speerate, return tange that is closest to u.x\n ){m.xy=mix(m.zw,m.xy,step(t,k.z))      \n  ;return vec2(max(abs(t-m.x),0.),m.y)\n ;}else{//else( 2 ranges intersect  (open intervals) (or one is inside the other))\n  ;if(max(k.y,k.w)<max(m.w,m.y) //iff (one ranges is completely inside the other) return larger range\n  ){m.xy=mix(m.xy,m.zw,step(m.y,m.w));return vec2(max(abs(t-m.x),0.),m.y)\n  ;}else return vec2(abs(t-k.x),k.y)//else 2 ranges intersect, return  AABV upper bound\n ;}\n ;}\n\nvec3 miNote(float t,vec3 a,vec3 b){return vec3(miNote(t,vec4(a.xy,b.xy)),min(a.z,b.z));}\n//i should possibly devinr a maNote (max()) \n//but usually componists do not define music with boolean_AND!\n\nvec3 note(float u,float c,float w\n){return vec3(abs(u-c)-w)\n ;}\n\n//skeletons and intervals:\n//an interval defines start and end point, a skeleton defines center and width.\n//intervals are asserted to be sorted. start< end , otherwise reversed\n//skeleton widths are assumed >=0                 , otherwise reversed\n//i2s() or a2i() to NOT sort outputs, but maintain the reversed-state.\nvec2 i2s(vec2 a){return (a.y+vec2(1,-1)*a.x)*.5;}//interval vec2(start,end)    to skeleton vec2(center,width)\nvec2 s2i(vec2 a){return (a.x+vec2(-1,1)*a.y);}//skeleton vec2(center,width) to interval vec2(start,end)\n    \n \n\nve3 entryImage(ve0 t,ve1 u,ve2 r,ve3 m){\n ;ve3 c=ve3(0,0,0,1)\n ;u   =fra(t,u   ,r,m)\n ;if(m.z>0.){\n  ;m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else{//iMouse is cos(hash41Aperiodic())\n   ;m=sqrt(vec4(5,11,3,13))-vec4(21,2,1,17) //QuadraticField: see: https://www.shadertoy.com/view/Xt3BDB\n   ;m=sin(m*t*.15)//time as seed for hash m.\n   ;//m=fract(m*4500.)//optional obfuscation\n   ;m.yw=m.yw*.5+.5//mirror symmetry on y=0\n   ;m.yw=m.yw*.5+.3//minimum key width\n   ;m*=ViewZoom*.4//view scale\n ;}\n ;vec2 centers=vec2(0,1) //centers of 2 boxes\n ;vec2 widthx=vec2(.5,.6)//width.x of 2 boxes\n ;vec2 widthy=vec2(.5,.6)//width.y of 2 boxes\n   \n     \n ;m.yw=abs(m.yw)//below code only allows for width>=0\n ;vec3 a=note(u.x,m.x,m.y)-.1    ;a.xy=m.xy\n ;vec3 b=note(u.x,m.z,m.w)-.1    ;b.xy=m.zw\n ;c.w=        abs(ma(abs(u-vec2(m.x,.1))-vec2(m.y,.8)))\n ;c.w=min(c.w,abs(ma(abs(u-vec2(m.z,.1))-vec2(m.w,.9))))\n ;c.w-=.02\n     \n ;a=miNote(u.x,a,b)   //not quite optional yet, but planned structure!\n     \n     \n\n //;b=note(u.x,1.,1.)-.1    ;b.xy=m.zw//3rd note          \n// ;a=miNote(u.x,a,b)   //not quite optional yet, but planned structure! complete fail!\n     \n //above we composite multiple notes (1d, one frequency for now)\n //usually notes are mostly mod() fract(), but you often have the issue of needing to mix silly note lengths\n //this is where miNote(u.x,a,b)    unifies 2 notes to 2 long note, IFF they overlap \n //(open interval overlap allows 1 note too start the same moment another note ends)\n //which allows for more flexibility in composing\n //,but the main purpose is to define notes & frequencies\n // in terms of defining an sdf (blue/yellow area)\n //\n //below we turn that into a waaveform,multiplied by a hull/ease.\n \n ;c.xyz=a\n ;float frequency=8.\n ;float phase=0.  //clobal phase  is lazy, silly, usefull\n ;//phase=  (u.x-abs(c.x-c.y))//phase shifted, but i have an uffly mirror symmetry i fail to resolve.\n\n ;float h=c.x-c.y+1.//hull function is automated, scaling is below:\n ;h=h*2.-1.//other easing tempo\n ;//h=sat(h)//optional clamp volume\n ;h=(h-1.) //c.x sets amplitude\n ;h=-smoothstep(0.,1.,-h)//optional easing polynomial (smoothstep() includes clamp())\n ;\n// ;if(snap>0.)\n          c.y=(u.y-sin((u.x-phase)*frequency)*h)\n// ;else    c.y=(u.y-sin((u.x-phase)*frequency)*h)\n\n ;c.x=h\n\n ;c.y=abs(c.y)\n ;c.x=abs(c.x+u.y)\n ;c.xy-=.1   \n\n\n     \n #ifdef negateRG\n ;c.xy=-c.xy\n #endif\n ;vec4 l=vec4(1)\n #ifdef showGradLog\n ;l=(1.-log(abs(c.xyzw*.4)))\n #endif\n ;c.x=mix(smoothstep(.01,-.01,c.x)*l.x,fract(c.x)*l.x,.6)\n ;c.y=mix(smoothstep(.01,-.01,c.y)*l.y,fract(c.y)*l.y,.2)\n ;c.z=mix(smoothstep(.01,-.01,c.z)*l.z,fract(c.z)*l.z,.2)\n ;c.w=mix(smoothstep(.01,-.01,c.w)*l.w,fract(c.w)*l.w,.3)\n \n ;//c.xy*=(1.-log(abs(c.xy)))//nah, just too confucing\n ;//c.y=0.\n     //;c.xy=vec2(0)\n ;c.xy=mix(c.xy,sat(c.ww),.3)\n ;c.w=1.\n ;c=sat(c)\n ;return c\n ;}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}