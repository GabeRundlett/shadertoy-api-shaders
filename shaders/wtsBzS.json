{
    "Shader": {
        "info": {
            "date": "1597084518",
            "description": "License CC0: Double Ended Truchet Experiment\nBeen looking at some double ended truchets by BigWings and Shane. After some experiments I got something I felt was interesting enough to share.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtsBzS",
            "likes": 16,
            "name": "Double Ended Truchet Experiment",
            "published": 3,
            "tags": [
                "truchet"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 391
        },
        "renderpass": [
            {
                "code": "// License CC0: Double Ended Truchet Experiment\n// Been looking at some double ended truchets by BigWings and Shane. \n// After some experiments I got something I felt was interesting enough to share.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nconst vec2 coords[8] = vec2[8](\n  0.5*vec2(-1.0, -0.5),\n  0.5*vec2(-1.0, +0.5),\n  0.5*vec2(-0.5, +1.0),\n  0.5*vec2(+0.5, +1.0),\n  0.5*vec2(+1.0, +0.5),\n  0.5*vec2(+1.0, -0.5),\n  0.5*vec2(+0.5, -1.0),\n  0.5*vec2(-0.5, -1.0)\n  );\n\nconst vec2 dcoords[8] = vec2[8](\n  vec2(+1.0, +0.0),\n  vec2(+1.0, +0.0),\n  vec2(+0.0, -1.0),\n  vec2(+0.0, -1.0),\n  vec2(-1.0, +0.0),\n  vec2(-1.0, +0.0),\n  vec2(+0.0, +1.0),\n  vec2(+0.0, +1.0)\n  );\n\nconst int noCorners = 105;\n// Using symmetries and reflections should be possible to reduce this \n//  array alot, but that is hard ;)\nconst int corners[105*8] = int[105*8](\n  0, 1, 2, 3, 4, 5, 6, 7, \n  0, 1, 2, 3, 4, 6, 5, 7, \n  0, 1, 2, 3, 4, 7, 5, 6, \n  0, 1, 2, 4, 3, 5, 6, 7, \n  0, 1, 2, 4, 3, 6, 5, 7, \n  0, 1, 2, 4, 3, 7, 5, 6, \n  0, 1, 2, 5, 3, 4, 6, 7, \n  0, 1, 2, 5, 3, 6, 4, 7, \n  0, 1, 2, 5, 3, 7, 4, 6, \n  0, 1, 2, 6, 3, 4, 5, 7, \n  0, 1, 2, 6, 3, 5, 4, 7, \n  0, 1, 2, 6, 3, 7, 4, 5, \n  0, 1, 2, 7, 3, 4, 5, 6, \n  0, 1, 2, 7, 3, 5, 4, 6, \n  0, 1, 2, 7, 3, 6, 4, 5, \n  0, 2, 1, 3, 4, 5, 6, 7, \n  0, 2, 1, 3, 4, 6, 5, 7, \n  0, 2, 1, 3, 4, 7, 5, 6, \n  0, 2, 1, 4, 3, 5, 6, 7, \n  0, 2, 1, 4, 3, 6, 5, 7, \n  0, 2, 1, 4, 3, 7, 5, 6, \n  0, 2, 1, 5, 3, 4, 6, 7, \n  0, 2, 1, 5, 3, 6, 4, 7, \n  0, 2, 1, 5, 3, 7, 4, 6, \n  0, 2, 1, 6, 3, 4, 5, 7, \n  0, 2, 1, 6, 3, 5, 4, 7, \n  0, 2, 1, 6, 3, 7, 4, 5, \n  0, 2, 1, 7, 3, 4, 5, 6, \n  0, 2, 1, 7, 3, 5, 4, 6, \n  0, 2, 1, 7, 3, 6, 4, 5, \n  0, 3, 1, 2, 4, 5, 6, 7, \n  0, 3, 1, 2, 4, 6, 5, 7, \n  0, 3, 1, 2, 4, 7, 5, 6, \n  0, 3, 1, 4, 2, 5, 6, 7, \n  0, 3, 1, 4, 2, 6, 5, 7, \n  0, 3, 1, 4, 2, 7, 5, 6, \n  0, 3, 1, 5, 2, 4, 6, 7, \n  0, 3, 1, 5, 2, 6, 4, 7, \n  0, 3, 1, 5, 2, 7, 4, 6, \n  0, 3, 1, 6, 2, 4, 5, 7, \n  0, 3, 1, 6, 2, 5, 4, 7, \n  0, 3, 1, 6, 2, 7, 4, 5, \n  0, 3, 1, 7, 2, 4, 5, 6, \n  0, 3, 1, 7, 2, 5, 4, 6, \n  0, 3, 1, 7, 2, 6, 4, 5, \n  0, 4, 1, 2, 3, 5, 6, 7, \n  0, 4, 1, 2, 3, 6, 5, 7, \n  0, 4, 1, 2, 3, 7, 5, 6, \n  0, 4, 1, 3, 2, 5, 6, 7, \n  0, 4, 1, 3, 2, 6, 5, 7, \n  0, 4, 1, 3, 2, 7, 5, 6, \n  0, 4, 1, 5, 2, 3, 6, 7, \n  0, 4, 1, 5, 2, 6, 3, 7, \n  0, 4, 1, 5, 2, 7, 3, 6, \n  0, 4, 1, 6, 2, 3, 5, 7, \n  0, 4, 1, 6, 2, 5, 3, 7, \n  0, 4, 1, 6, 2, 7, 3, 5, \n  0, 4, 1, 7, 2, 3, 5, 6, \n  0, 4, 1, 7, 2, 5, 3, 6, \n  0, 4, 1, 7, 2, 6, 3, 5, \n  0, 5, 1, 2, 3, 4, 6, 7, \n  0, 5, 1, 2, 3, 6, 4, 7, \n  0, 5, 1, 2, 3, 7, 4, 6, \n  0, 5, 1, 3, 2, 4, 6, 7, \n  0, 5, 1, 3, 2, 6, 4, 7, \n  0, 5, 1, 3, 2, 7, 4, 6, \n  0, 5, 1, 4, 2, 3, 6, 7, \n  0, 5, 1, 4, 2, 6, 3, 7, \n  0, 5, 1, 4, 2, 7, 3, 6, \n  0, 5, 1, 6, 2, 3, 4, 7, \n  0, 5, 1, 6, 2, 4, 3, 7, \n  0, 5, 1, 6, 2, 7, 3, 4, \n  0, 5, 1, 7, 2, 3, 4, 6, \n  0, 5, 1, 7, 2, 4, 3, 6, \n  0, 5, 1, 7, 2, 6, 3, 4, \n  0, 6, 1, 2, 3, 4, 5, 7, \n  0, 6, 1, 2, 3, 5, 4, 7, \n  0, 6, 1, 2, 3, 7, 4, 5, \n  0, 6, 1, 3, 2, 4, 5, 7, \n  0, 6, 1, 3, 2, 5, 4, 7, \n  0, 6, 1, 3, 2, 7, 4, 5, \n  0, 6, 1, 4, 2, 3, 5, 7, \n  0, 6, 1, 4, 2, 5, 3, 7, \n  0, 6, 1, 4, 2, 7, 3, 5, \n  0, 6, 1, 5, 2, 3, 4, 7, \n  0, 6, 1, 5, 2, 4, 3, 7, \n  0, 6, 1, 5, 2, 7, 3, 4, \n  0, 6, 1, 7, 2, 3, 4, 5, \n  0, 6, 1, 7, 2, 4, 3, 5, \n  0, 6, 1, 7, 2, 5, 3, 4, \n  0, 7, 1, 2, 3, 4, 5, 6, \n  0, 7, 1, 2, 3, 5, 4, 6, \n  0, 7, 1, 2, 3, 6, 4, 5, \n  0, 7, 1, 3, 2, 4, 5, 6, \n  0, 7, 1, 3, 2, 5, 4, 6, \n  0, 7, 1, 3, 2, 6, 4, 5, \n  0, 7, 1, 4, 2, 3, 5, 6, \n  0, 7, 1, 4, 2, 5, 3, 6, \n  0, 7, 1, 4, 2, 6, 3, 5, \n  0, 7, 1, 5, 2, 3, 4, 6, \n  0, 7, 1, 5, 2, 4, 3, 6, \n  0, 7, 1, 5, 2, 6, 3, 4, \n  0, 7, 1, 6, 2, 3, 4, 5, \n  0, 7, 1, 6, 2, 4, 3, 5, \n  0, 7, 1, 6, 2, 5, 3, 4\n  );\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n  const float sqrt3 = sqrt(3.0);\n  vec2 a = B - A;\n  vec2 b = A - 2.0*B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0/dot(b,b);\n  float kx = kk * dot(a,b);\n  float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n  float kz = kk * dot(d,a);      \n\n  float res = 0.0;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n  float h = q*q + 4.0*p3;\n\n  if(h>=0.0) {   // 1 root\n      h = sqrt(h);\n      vec2 x = (vec2(h,-h)-q)/2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n      res = dot2(d+(c+b*t)*t);\n  } else {   // 3 roots\n      float z = sqrt(-p);\n      float v = acos(q/(p*z*2.0))/3.0;\n      float m = cos(v);\n      float n = sin(v)*sqrt3;\n      vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n      res = min(dot2(d+(c+b*t.x)*t.x), dot2(d+(c+b*t.y)*t.y));\n      // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n      // res = min(res,dot2(d+(c+b*t.z)*t.z));\n  }\n  \n  return sqrt(res);\n}\n\nfloat bezier2(vec2 p, float f, vec2 off, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5+off;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 color(vec2 p, float s, float aa, vec3 col) {\n  p /= s;\n  vec2 cp = p;\n  vec2 cn = mod2_1(cp);\n  float rr = hash(cn);\n  int sel = int(float(noCorners)*rr);\n  int off = sel*8;\n  \n  const vec3 scol = vec3(0.25);\n  const vec3 bcol = vec3(1.0);\n  const float sw = 0.05;\n  \n  for (int i = 0; i < 4; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];    \n    int odd = min(c0, c1) & 1;\n    \n    float r = fract(rr*13.0*float(i+1));\n    \n    int l = abs(c0 - c1) + odd*8;\n    float f = 0.71;\n    vec2 off = vec2(0.0, 0.0);\n\n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n    \n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n\n    vec2 dp = mix(dp0, dp1, r);\n\n    switch(l) {\n    // Mid shape\n    case 1:\n    case 15:\n      f = mix(0.75, 2.5, r);\n      break;\n    // L - shape\n    case 2:\n    case 6:\n    case 10:\n    case 14:\n      f = r > 0.5 ? 0.35 : 1.25;\n      break;\n    // Big corner shape\n    case 3:\n    case 13:\n      f = mix(0.5, 1.0, r);\n      break;\n    // Cross line\n    case 4:\n    case 12:\n      f = r>0.5 ? 0.5 : 1.5;\n      break;\n    // Straight line\n    case 5:\n    case 11:\n      f = 1.5;\n      off = (r > 0.5 ? 1.0 : -1.0)*0.15*vec2(dp0.y, -dp0.x);\n      break;\n    // Small corner shape\n    case 7:\n    case 9:\n      f = r>0.5 ? 0.75 : 2.75;\n      break;\n    default:\n      f = 0.5;\n      break;\n    }\n    \n    float dd = (bezier2(cp, f, off, p0, dp0, p1, dp1)-0.025)*s;\n    \n    vec4 sc = vec4(scol, smoothstep(-sw, sw, -dd));\n    vec4 bc = vec4(bcol, smoothstep(-aa, aa, -dd));\n\n    col = alphaBlend(col, sc);\n    col = alphaBlend(col, bc);\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  p += vec2(0.5, sqrt(0.5))*TIME*0.1;\n \n  float aa = 2.0/RESOLUTION.y;\n  float s = 0.25;\n\n  vec3 col = vec3(0.1);\n  col = color(p, s, aa, col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}