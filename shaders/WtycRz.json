{
    "Shader": {
        "info": {
            "date": "1613932114",
            "description": "An endless array of abstract screens. \nPress to zoom and move around. Still some artifacts to fix when zooming in.\n\nUsed Inigo Quilezs distance functions page as references:\nhttps://iquilezles.org/articles/distfunctions/distfunctions.htm",
            "flags": 32,
            "hasliked": 0,
            "id": "WtycRz",
            "likes": 9,
            "name": "Screens",
            "published": 3,
            "tags": [
                "2d",
                "raymarching",
                "interactive",
                "animated",
                "glow",
                "flash",
                "neon",
                "screens"
            ],
            "usePreview": 0,
            "username": "afaq",
            "viewed": 602
        },
        "renderpass": [
            {
                "code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define BPM 120.0\n#define _beat (iTime * BPM / 1000.0)\n#define beat (mod(_beat, 32.0))\n\n// Taken from. https://www.shadertoy.com/view/3ls3zM\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Zoom\n    uv = uv * 2.0 - 1.0;\n    uv *= 0.9 - (sin(iTime) * 0.005);\n    uv = (uv + 1.0) * 0.5;\n    \n    // Camera shake\n    uv += 0.02 * sin(PI2 * beat / 32. * 10.0) + 0.01 * sin(PI2 * beat / 32. * 20.0);\n    \n    // Lens distortion\n    vec2 dir = uv - vec2(0.5);\n    uv += dir * dot(dir, dir) * 0.2;\n    \n    vec3 colour = texture(iChannel0, uv).rgb;\n    \n    // Vignette\n    vec2 d = abs(uv - vec2(0.5)) * 1.6;\n    d = pow(d, vec2(2.0));\n    colour.rgb *= pow(saturate(1.0 - dot(d, d)), 3.0);\n\n    fragColor = vec4(colour, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RAYMARCHING_MAX_STEPS 200\n#define RAYMARCHING_MAX_DEPTH 1000.0\n#define RAYMARCHING_THRESHOLD 0.01\n#define REPEAT_AMOUNT 500.0\n#define REPEAT_DIST 3.0\n#define REPEAT_HALF_DIST REPEAT_DIST * 0.5\n\nint layerID = 0;\n\nfloat SceneSD(vec3 position)\n{\n    float distance = 1.0;\n    \n    vec3 repeat = RepeatLimited(position, REPEAT_DIST, vec2(-REPEAT_AMOUNT, REPEAT_AMOUNT));\n    \n    repeat = Elongate(repeat, vec3(0.5, 0.0, 0.35));\n    repeat.y = position.y;\n    \n    vec3 id = GetID(position, REPEAT_DIST, REPEAT_HALF_DIST);\n    \n    if(Rand(id.xx) <= Rand(id.zx))\n    {\n        vec3 offset = repeat + vec3(0.0, -1.0, 0.0);  \n        offset.y += sin(iTime * Rand(id.xz));\n        \n        float newDistance = TorusSD(offset, vec2(0.25, 0.1));\n        if(distance > newDistance)\n        {\n            distance = newDistance;\n            layerID = 3;\n        }\n    }\n    \n    if(Rand(id.zz) <= Rand(id.xz))\n    {\n        vec3 offset = repeat + vec3(0.0, -0.5, 0.0);  \n        offset.y += sin((iTime * 0.75) * Rand(id.xz));\n        \n        float newDistance = TorusSD(offset, vec2(0.5, 0.1));\n        if(distance > newDistance)\n        {\n            distance = newDistance;\n            layerID = 2;\n        }\n    }\n\n    {\n        vec3 offset = repeat + vec3(0.0, -0.25, 0.0);  \n        offset.y += cos((iTime * 0.15) * Rand(id.xz));\n\n        float newDistance =  TorusSD(offset, vec2(0.75, 0.1));\n        if(distance > newDistance)\n        {\n            distance = newDistance;\n            layerID = 1;\n        }\n    }\n    \n    float newDistance = PlaneSD(position, vec3(0.0, 1.0, 0.0), 2.25);\n    if(distance > newDistance)\n    {\n        distance = newDistance;\n        layerID = 0;\n    }\n    \n    return distance;\n}\n\nvec4 Raymarch(Ray ray)\n{\n    float depth = 0.0;\n    vec3 position = vec3(0.0);\n    for(int i = 0; i < RAYMARCHING_MAX_STEPS; ++i)\n    {\n        position = ray.origin + (depth * ray.direction);\n        float distance = SceneSD(position);\n        \n        if(distance < RAYMARCHING_THRESHOLD || distance >= RAYMARCHING_MAX_DEPTH)\n        {\n            break;\n        }\n        \n        depth += distance;\n    }\n    \n    return vec4(position, depth);\n}\n\nvec3 Normal(vec3 position)\n{\n    float distance = SceneSD(position);\n    vec2 offset = vec2(0.001, 0.0);\n    \n    vec3 normal = distance - vec3(\n        SceneSD(position-offset.xyy),\n        SceneSD(position-offset.yxy),\n        SceneSD(position-offset.yyx));\n    \n    return normalize(normal);\n}\n\nfloat Shadow(Ray ray, vec3 light)\n{\n    float depth = Raymarch(ray).w;\n    if(depth < length(light))\n    {\n        return 0.1;\n    }\n    return 1.0;\n}\n\nvec3 Light(vec3 position, float depth)\n{   \n    vec3 colours[4];\n    colours[0] = vec3( 1.0, 1.0, 1.0 );\n    colours[1] = vec3( 0.839, 0.450, 0.337 );\n    colours[2] = vec3( 0.631, 0.839, 0.427 );\n    colours[3] = vec3( 0.294, 0.403, 0.839 );\n    \n    vec3 id = GetID(position, REPEAT_DIST, REPEAT_HALF_DIST);\n    vec3 offset = position + ((floor(sin(Rand(id.xz) * (iTime * 0.2)) * 80.0) - (40.0)) * REPEAT_DIST);\n    offset.y = position.y;\n    \n    vec3 diffuse = colours[layerID];\n    vec3 colour = (diffuse * position.y) * 0.5;\n    float glow = Glow(offset.xyx, 50.0, 0.2);\n\n    return colour + (diffuse * glow);\n}\n\nvec3 Render(Ray ray)\n{\n    vec4 position = Raymarch(ray);\n    vec3 colour = Light(position.xyz, position.w);\n    return colour;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 m = iMouse / iResolution.x;\n    \n    vec3 origin = vec3(0.0, 120.0, 0.0);\n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    \n\tif(m.z > 0.0)\n\t{\n        origin = vec3(m.x * 50.0, 30.0, m.y * 50.0);\n        target = vec3(origin.x, 1.0, origin.y);\n    }\n    \n    Ray ray = LookAt(uv, origin, target, up);\n    fragColor = vec4(Render(ray), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define EPSILON 1e-5f\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nmat3 Transform(vec3 direction, vec3 up)\n{\n    vec3 z = direction;\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return mat3(x, y, z);\n}\n\nfloat PlaneSD(vec3 position, vec3 normal, float height)\n{\n    return dot(position, normal) + height;\n}\n\nfloat SphereSD(vec3 position, vec3 center, float radius)\n{\n    return length(position - center) - radius;\n}\n\nfloat BoxSD(vec3 position, vec3 bounds)\n{\n    vec3 q = abs(position) - bounds;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat BoundingBoxSD(vec3 position, vec3 bounds, float edge, float bevel)\n{\n    position = abs(position) - bounds;\n    vec3 q = abs(position + edge) - edge;\n    return min(min(\n        length(max(vec3(position.x, q.y, q.z), 0.0)) + min(max(position.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, position.y, q.z), 0.0)) + min(max(q.x, max(position.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, position.z), 0.0)) + min(max(q.x, max(q.y, position.z)), 0.0))- bevel;\n}\n\nfloat TorusSD(vec3 position, vec2 dimensions)\n{\n    vec2 q = vec2(length(position.xz) - dimensions.x, position.y);\n    return length(q) - dimensions.y;\n}\n\nvec3 RepeatLimited(vec3 position, float dist, vec2 limits)\n{\n    return position-dist*clamp(round(position/dist), vec3(limits.x), vec3(limits.y));\n}\n\nvec3 Repeat(vec3 p, vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec3 Elongate(vec3 position, vec3 amount)\n{\n     return position - clamp(position, -amount, amount);\n}\n\nvec3 GetID(vec3 position, float dist, float halfDist)\n{\n    return floor((position + halfDist) / dist);\n}\n\nfloat Glow(vec3 position, float strength, float radius)\n{\n    float glow = 1.0 / length(position);\n    glow *= strength;\n    return pow(glow, radius);\n}\n\nfloat Rand(vec2 v)\n{\n    return fract(sin(dot(v.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Hash(float n) \n{ \n    return fract(sin(n)*43758.5453123); \n}\n\nfloat CheckerPattern(vec3 position)\n{\n    float sx = sin(2.0 * position.x);\n\tfloat cy = cos(2.0 * position.z);\n    return sx * cy / 0.001;\n}\n\nRay LookAt(vec2 uv, vec3 origin, vec3 target, vec3 up)\n{   \n    vec3 direction = normalize(target - origin);\n    mat3 transform = Transform(direction, up);\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = transform * normalize(vec3(uv.x, uv.y, 1.0));\n    return ray;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}