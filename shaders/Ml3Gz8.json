{
    "Shader": {
        "info": {
            "date": "1467997379",
            "description": "A tutorial explaining the derivation of the polynomial smooth minimum commonly used in Shadertoy.\nSee http://viniciusgraciano.com/blog/smin/ for a full explanation.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ml3Gz8",
            "likes": 59,
            "name": "Smooth Min Explained",
            "published": 3,
            "tags": [
                "tutorial",
                "smooth",
                "min",
                "smoothmin"
            ],
            "usePreview": 0,
            "username": "vgs",
            "viewed": 8806
        },
        "renderpass": [
            {
                "code": "/* Created by Vinicius Graciano Santos - vgs/2015 \n * This is a tutorial that explains the polynomial smooth minimum.\n *\n * Read my blog post at http://viniciusgraciano.com/blog/smin/ \n * for a complete description including all the maths!\n * \n * This function is a polynomial approximation to the min function,\n * and it is widely used by \"shadertoyers\" to do smooth unions of \n * distance functions that represent objects in raymarchers.\n * There are some nice, simple, and beautiful mathematical ideas in it!\n *\n * Polynomial smin was introduced by iq in the following article:\n * https://iquilezles.org/articles/smin\n */\n\n// Polynomial smooth min (for copying and pasting into your shaders)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n// Polynomial smooth min (commented version)\n// @input a: first value\n// @input b: second value\n// @float k: 'Smoothness value', usually in the range (0,1].\n//           Values close to zero makes smin converge to min.\n//           Warning: the function is NOT defined at k = 0!\n//           Tip: negative values turn the funtion into smooth max!\nfloat sminExplained(float a, float b, float k) {\n    \n    // Compute the difference between the two values.\n    // This is used to interpolate both values inside the range (-k, k).\n    // Smaller ranges give a better approximation of the min function.\n    float h = a - b;\n    \n    // The interval [-k, k] is mapped to [0, 1],\n    // and clamping takes place only after this transformation.\n    \n    // Map [-k, k] to [0, 1] and clamp if outside the latter.\n    h = clamp(0.5 + 0.5*h/k, 0.0, 1.0);    \n    \n    // Linearly interpolate the input values using h inside (0, 1).\n    // The second term ensures continuous derivatives at the boundaries of [0,1],\n    // but this is not completely obvious! See my blog post for details.\n    return mix(a, b, h) - k*h*(1.0-h);    \n}\n\n// Only rendering functions below this line...\nvec2 gradsmin(vec2 p, float k);\nvec3 plot(vec2 uv, vec2 st) {     \n    float a = cos(uv.x), b = exp(-uv.x);\n    \n    // Distance estimate to f(x) = sin(x)\n    float d1 = abs(uv.y - a) / length(vec2(1.0, sin(uv.x)));\n    \n    // Distance estimate to g(x) = exp(-x)\n    float d2 = abs(uv.y - b) / length(vec2(1.0, -b));\n    \n    // Distance estimate to h(x) = smin(f(x), g(x))    \n    float k = 0.5*(cos(iTime)+1.0)+0.01;\n    float d3 = abs(uv.y - smin(a, b, k)) / length(gradsmin(uv, k));        \n    \n    // Background    \n    vec3 col = vec3(1.0);\n    col *= 0.1 + 0.9*pow(st.x*st.y*(1.0-st.x)*(1.0-st.y), 0.85);\n    \n    // Mix graphs with background\n    const vec3 blue = vec3(29. , 115., 170.)/255.;\n\tconst vec3 yellow = vec3(140., 188., 79.)/255.;\n    const vec3 red = vec3(196., 68., 65.)/255.;    \n    float eps = 8.0/min(iResolution.x, iResolution.y) + 0.008;\n    col = mix(blue, col, smoothstep(0.0, eps, d1));\n    col = mix(yellow, col, smoothstep(0.0, eps, d2));\n    col = mix(red, col, smoothstep(0.0, 1.25*eps, d3));\n        \n    return col;\n}\n\nvec2 gradsmin(vec2 p, float k) {\n    const float eps = 0.01;\n    float dy = smin(cos(p.x+eps), exp(-(p.x+eps)), k)\n    \t\t - smin(cos(p.x-eps), exp(-(p.x-eps)), k);\n    return vec2(1.0, 0.5*dy/eps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;    \n    vec2 uv = vec2(-1.07, -0.75) + vec2(10.0, 1.5)*st;\n    uv.y *= iResolution.x / iResolution.y;\n    \n    vec3 col = plot(uv, st);\n    col = pow(col, vec3(0.45));\n    col = smoothstep(0.0, 1.0, col);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}