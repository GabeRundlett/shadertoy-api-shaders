{
    "Shader": {
        "info": {
            "date": "1473934458",
            "description": "parsing & compressing https://www.shadertoy.com/view/ldl3W8\nsmaller source code,  removed 1mult at the end of voronoi()\n\ni want to calculate the center of a cell but am not sure if thats worth the calculations.\nand then i made a phi-hash that helps a bit.",
            "flags": 0,
            "hasliked": 0,
            "id": "llVGzw",
            "likes": 4,
            "name": "voronoi distance learndening2",
            "published": 3,
            "tags": [
                "voronoi",
                "distance",
                "phi",
                "hash"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 701
        },
        "renderpass": [
            {
                "code": "////based on:\n//https://www.shadertoy.com/view/ldl3W8\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n// https://iquilezles.org/articles/voronoilines\n\n#define ANIMATE\n\n//i want to calculate the center of a cell btut am not sure if its worth the calculations.\n//then again, my custom phi-hash is wobbly and has voronoi.point very close to cell.center\n//and defining const float phi2=sqrt(5.)*pi-pi;/makes voronoi.point closer to cell.center\n\n#define dot2(a)dot(a,a)\n#define dotp(a)dot(p,a)\n#define s01(a)(.5+.5*sin(a))\n//smallest positive 16 bit float in hexadecimal\n#define smallest \n\nconst float tau=asin(1.)*4.;//full rotation in radians\nconst float pi=asin(1.)*2.;//half rotation in radians\nconst float phi=sqrt(5.)*tau-tau;//golden half-angle=golden*ratiopi ratio; \nfloat hash21(vec2 p){return fract(p.x+phi*p.y);}//i kinda love this minimalistic hash function.\n\n\nvec2 hash2(vec2 p){//return texture(iChannel0,(p+.5)/256.,-100.).xy;//noise.white.texture   \n return vec2(hash21(p),hash21(p.yx));\n //maybe do quaternion rotation around 2 axes by multiples of PHI???\n //return fract(sin(vec2(dotp(vec2(127.1,311.7)),dotp(vec2(269.5,183.3)))));//noise.white.b\n}\n\n#define ani o=s01(iTime+asin(1.)*4.*o);\n#define loop2(a)md=8.;for(int j=-a;j<=a;j++)for(int i=-a;i<=a;i++){vec2 g\n#define rof vec2 r=g+o-f;\n#define ij vec2(float(i),float(j));vec2 o=hash2(n+g);\n//return .x=distance to border , .yz=voronoi point\nvec3 vor(in vec2 x){//pass0: voronoi\n vec2 n=floor(x), f=fract(x),mg,mr;\n float loop2(1)=ij\n#ifdef ANIMATE\n ani\n#endif\t\n rof float d=dot2(r);if(d<md){md=d;mr=r;mg=g;}}//pass1: distance.borders\n loop2(2)=mg+ij\n#ifdef ANIMATE\n ani\n#endif\n rof\n if(dot2(mr-r)>.0000000001)md=min(md,dot(mr+r,normalize(r-mr)));\n }return vec3(md,mr);}\n\nvoid mainImage( out vec4 r, in vec2 i){\n vec2 n=vec2(0,1);\n vec2 p=i.xy/iResolution.xx;\n vec3 v=vor(59.*length(iMouse.xy)*p/length(iResolution));\n vec3 c=n.xxx;\n c=v.x*(s01(64.*v.x))*vec3(1);//distance.inner\n c=mix(n.yyx,c,smoothstep(.09,.1,v.x));//border.orange\n c+=n.yxy*(1.-smoothstep(.0,.1,length(v.yz)));//voronoi.point\n r=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}