{
    "Shader": {
        "info": {
            "date": "1510315182",
            "description": "land",
            "flags": 0,
            "hasliked": 0,
            "id": "MlScD3",
            "likes": 2,
            "name": "NewLand",
            "published": 3,
            "tags": [
                "land"
            ],
            "usePreview": 0,
            "username": "mbixo",
            "viewed": 476
        },
        "renderpass": [
            {
                "code": "// Constants ----------\n#define PI 3.14159265358979\n#define P2 6.28318530717959\n\nconst int   MAX_TRACE_STEP = 60;\nconst float MAX_TRACE_DIST = 180.;\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR = .82;\nconst vec3  GAMMA = vec3(1.3/2.2);\n\nconst float GI_LENGTH = .8;\nconst float GI_STRENGTH = .4;\nconst float AO_STRENGTH = .4;\nconst int   MAX_SHADOW_TRACE_STEP = 110;\nconst float MAX_SHADOW_TRACE_DIST = 10.;\nconst float MIN_SHADOW_MARCHING = .2;\nconst float SHADOW_SHARPNESS = 4.;\n\nconst float LENS_BLUR = .3;\n\n\n// Structures ----------\nstruct Surface {\n  float d;\n  vec4 kd;  // should be \"kd.w=1\" for ao shadow strength\n};\nSurface _min(Surface s,Surface t) {if(s.d<t.d)return s;return t;}\n\nstruct Ray {\n  vec3 org, dir;\n  float len, stp;\n};\nvec3 _pos(Ray r) {return r.org+r.dir*r.len;}\n\nstruct Hit {\n  vec3 pos;\n  Ray ray;\n  Surface srf;\n};\n\nstruct Camera {\n  vec3 pos, tgt;\n  float rol, fcs;\n};\nmat3 _mat3(Camera c) {\n  vec3 w = normalize(c.pos-c.tgt);\n  vec3 u = normalize(cross(w,vec3(sin(c.rol),cos(c.rol),0)));\n  return mat3(u,normalize(cross(u,w)),w);\n}\n\nstruct AmbientLight {\n  vec3 dir, col;\n};\nvec3 _lit(vec3 n, AmbientLight l){return clamp((dot(n, l.dir)+1.)*.5,0.,1.)*l.col;}\n\n\n// Grobal valiables ----------\nconst float bpm = 144.;\nconst AmbientLight amb = AmbientLight(vec3(0,1,0), vec3(.7,.7,.7));\nconst AmbientLight dif = AmbientLight(normalize(vec3(1,2,1)), vec3(.7,.7,.7));\nfloat phase;\n\n\n// Utilities ----------\nvec3 _rgb(vec3 v) {\n  return ((clamp(abs(fract(v.x+vec3(0,2./3.,1./3.))*2.-1.)*3.-1.,0.,1.)-1.)*v.y+1.)*v.z;\n}\n\nmat3 _sMat(float th, float ph) {\n  float x=cos(th), y=cos(ph), z=sin(th), w=sin(ph);\n  return mat3(y,w*z,-w*x,0,x,z,w,-y*z,y*x);\n}\n\n\n// Distance Functions ----------\nfloat fPlane(vec3 p, vec3 n, float d) {\n  return dot(p,n) + d;\n}\n\nfloat fBox(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.)) - r;\n}\n\nvec3 repXZ(vec3 p, vec2 r){\n  vec2 hr = r * .5;\n  return vec3(mod(p.x+hr.x, r.x)-hr.x, p.y, mod(p.z+hr.y, r.y)-hr.y);\n}\n\nfloat fHex(vec3 p, vec2 h, float r) {\n  vec3 q = abs(p);\n  q.x = max(q.x*0.866025+q.z*0.5,q.z);\n  return length(max(q.xy-h.xy,0.)) - r;\n}\n\n// World Mapping ----------\nSurface map(vec3 p){\n  float lv = min(1., iTime / 16.);\n  float es = exp(sin(phase*.5-length(p)*.2));\n  vec2  bs = vec2(.6/es,.6*es);\n  vec3  hx = vec3(1.73205081,1,0)*4.;\n  vec3  rp =  repXZ(p, hx.xy);\n  vec3  rp2 = repXZ(p+hx.xzy*.5, hx.xy);\n  vec3  col = _rgb(vec3(phase/256.,1.4,1.4));\n  rp.y -= bs.y+.4-length(p)*.01;\n  rp2.y -= bs.y+.4-length(p)*.01;\n\n  return _min(\n    Surface(fPlane(p, vec3(0,1,0), lv*3.8-3.8), vec4(col,1)), \n    _min(\n      Surface(fHex(rp,  bs, .4), vec4(.7,.7,.7,1)),\n      Surface(fHex(rp2, bs, .4), vec4(.3,.3,.3,1))\n    )\n  );\n}\n\n\n// Lighting ----------\nvec3 calcNormal(in vec3 p){\n  vec3 v=vec3(.001,0,map(p).d);\n  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));\n}\n\nfloat ss(in vec3 pos, in vec3 dir) {\n  float sdw=1., len=.01;\n  for( int i=0; i<MAX_SHADOW_TRACE_STEP; i++ ) {\n    float d = map(pos + dir*len).d;\n    sdw = min(sdw, SHADOW_SHARPNESS*d/len);\n    len += max(d, MIN_SHADOW_MARCHING);\n    if (d<TRACE_PRECISION || len>MAX_SHADOW_TRACE_DIST) break;\n  }\n  return clamp(sdw, 0., 1.);\n}\n\nvec4 gi(in vec3 p, in vec3 n) {\n  vec4 col = vec4(0);\n  for (int i=0; i<4; i++) {\n    float hr = .01 + float(i) * GI_LENGTH / 4.;\n    Surface s = map(n * hr + p);\n    col += s.kd * (hr - s.d);\n  }\n  col.rgb *= GI_STRENGTH / GI_LENGTH;\n  col.w = clamp(1.-col.w * AO_STRENGTH / GI_LENGTH, 0., 1.);\n  return col;\n}\n\nvec3 lighting(in Hit h) {\n  vec3 n = calcNormal(h.pos);\n  vec4 gin = gi(h.pos, n);\n  //   lin = ([Ambient]    + [Diffuse]    * [Soft shadow])      * [A.O] + [G.I.]\n  vec3 lin = (_lit(n, amb) + _lit(n, dif) * ss(h.pos, dif.dir)) * gin.w + gin.rgb;\n  return  h.srf.kd.rgb * lin;\n}\n\n\n// Ray tracing ----------\nRay ray(in vec2 p, in Camera c) {\n  return Ray(c.pos, normalize(_mat3(c) * vec3(p.xy, -c.fcs)), .0, .0);\n}\n\nRay bray(in Ray r, Camera c, float b) {\n  vec3 p = c.pos + normalize(cross(r.dir, vec3(1))) * b;\n  return Ray(p, normalize(r.org + r.dir * length(c.tgt - c.pos) - p), .0, .0);\n}\n\nHit trace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION || r.len > MAX_TRACE_DIST) break;\n  }\n  return Hit(_pos(r), r, s);\n}\n\nvec4 render(in Hit h){\n  if (h.ray.len > MAX_TRACE_DIST) return vec4(1.8,2.8,.8,h.ray.len);\n  return vec4(lighting(h), h.ray.len);\n}\n\nvec4 gamma(in vec4 i) {\n  return vec4(pow(i.xyz, GAMMA), i.w);\n}\n\n\n// Entry point ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  phase = iTime * bpm / 60. * P2;\n\n  Camera c = Camera(vec3(sin(phase/32.)*20., exp(cos(phase/64.)*1.2)*40., cos(phase/32.)*20.), vec3(0), .4, 1.73205081);\n  Ray    r = ray((fragCoord.xy * 2. - iResolution.xy) / iResolution.x, c);\n\n  vec4 col = render(trace(r));\n  col += render(trace(bray(r, c, LENS_BLUR)));\n  col += render(trace(bray(r, c, -LENS_BLUR)));\n  fragColor = gamma(col/3.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}