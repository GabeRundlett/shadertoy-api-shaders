{
    "Shader": {
        "info": {
            "date": "1649379874",
            "description": "Car Light,you can click and move mouse",
            "flags": 0,
            "hasliked": 0,
            "id": "ftjcRm",
            "likes": 5,
            "name": "08 Car Light ",
            "published": 3,
            "tags": [
                "carlight"
            ],
            "usePreview": 0,
            "username": "ccc9527",
            "viewed": 274
        },
        "renderpass": [
            {
                "code": "//I learn from:https://www.youtube.com/watch?v=eKtsY7hYTPg\nstruct Ray   //射线结构体\n{\n    vec3 origin;//射线原点origin\n    vec3 direction;//射线方向direction\n};\n\n//伪随机,t乘以一个大的数,使得sin值伪随机,再乘以一个大的数,然后取小数部分,得到伪随机的小数部分\nfloat Noise(float t)\n{\n    return fract(sin(t*3456.0)*6547.0);\n}\n//输入一个数，返回一个伪随机的vec4\nvec4 Noise14(float t)\n{\n    return fract(sin(t*vec4(123.0,1024.0,3456.0,9821.0))*vec4(6547.0,345.0,9123.0,2431.0));\n}\n\n//设置摄像机的三个基向量以及摄像机点到屏幕上每个像素点的方向\nRay SetCamera(vec2 uv,vec3 camPos,vec3 lookat,float zoom)\n{\n    Ray ray;\n    ray.origin = camPos;\n    //摄像机的三个基向量\n    vec3 forward = normalize(lookat-camPos);\n    vec3 right = cross(vec3(0.0,1.0,0.0),forward);\n    vec3 up = cross(forward,right);\n    \n    vec3 center = ray.origin+forward*zoom;//屏幕中心点坐标\n    vec3 i = center+right*uv.x+up*uv.y;//屏幕上的每个点坐标\n    ray.direction = normalize(i-ray.origin);//摄像机点到屏幕每个像素点的方向\n    \n    return ray;\n}\n\n//求点p到射线的距离\nfloat GetDistance(Ray ray,vec3 p)\n{\n    return length(cross(p-ray.origin,ray.direction));\n}\n\n//绘制圆效果,size为圆的大小,blur是模糊程度,百分比\nfloat Bokeh(Ray ray,vec3 p,float size,float blur)\n{\n    float d = GetDistance(ray,p);//求点p到每条射线(每个像素点-射线原点)的距离\n    size *= length(p);//点p距离越近,大小乘以距离,使得圆在靠近摄像机时大小不变\n    float c = smoothstep(size,size-blur*size,d);//绘制小圆\n    c *= mix(0.6,1.0,smoothstep(0.8*size,size,d));//边缘过度效果(0.8,1.0)的时候\n    \n    return c;\n}\n\n//绘制一系列圆，组成一个移动的效果\nvec3 Light(Ray ray,float t)\n{\n    float side = step(ray.direction.x,0.0);//在左半边是为1\n    ray.direction.x = abs(ray.direction.x);//关于y对称\n    float s = 1.0/10.0;//for循环间隔\n    float mask = 0.0;\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        float ti = fract(t+i+side*s*0.5);//fract取小数部分的函数,左半边比右半边快一些\n        vec3 p = vec3(2.0,2.0,100.0-ti*100.0);//10个深度不同的圆\n        mask += Bokeh(ray,p,0.05,0.1)*ti*ti*ti;//乘以t^3减少初始地区圆的数量\n    }\n    \n    return vec3(1.0,0.7,0.3)*mask;\n}\n\n//环境光\nvec3 EnvLight(Ray ray,float t)\n{\n    float side = step(ray.direction.x,0.0);//在左半边是为1\n    ray.direction.x = abs(ray.direction.x);//关于y对称\n    float s = 1.0/10.0;//for循环间隔\n    vec3 col = vec3(0.0);\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        vec4 n = Noise14(i+side*100.0);//+side*100可以使得左右两边颜色不同\n        float ti = fract(t+i+side*s*0.5);//fract取小数部分的函数,左半边比右半边快一些\n        float fade = ti*ti*ti;//乘以t^3减少初始地区圆的数量\n        \n        float occlusion = sin(ti*6.28*10.0*n.x)*0.5+0.5;//结果为(0,1),乘以n.x达到随机某个圆消失\n        fade = occlusion;\n        \n        float x = mix(2.5,10.0,n.x);\n        float y = mix(0.1,1.0,n.y);\n        vec3 p = vec3(x,y,50.0-ti*50.0);//10个深度不同的圆\n        \n        col += Bokeh(ray,p,0.05,0.1)*fade*n.wzy*0.5;\n    }\n    \n    return col;\n}\n\n//与Light类似,没有对称边,头灯\nvec3 HeadLight(Ray ray,float t)\n{\n    t *= 2.0;\n    vec3 w1 = vec3(0.25,0.0,0.0);\n    vec3 w2 = w1*1.2;\n    float s = 1.0/10.0;//for循环间隔\n    float mask = 0.0;\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        float n = Noise(i);\n        if(n>0.1) continue;//去掉一些随机值小于0.1的部分，达到一个随机效果\n        \n        float ti = fract(t+i);//fract取小数部分的函数,左半边比右半边快一些\n        float focus = smoothstep(0.9,1.0,ti);\n        float size = mix(0.05,0.04,focus);\n        \n        float fade = ti*ti*ti*ti*ti;\n        vec3 p = vec3(-1.0,0.15,100.0-ti*100.0);//10个深度不同的圆\n        mask += Bokeh(ray,p-w1,size,0.1)*fade;//乘以t^n减少初始地区圆的数量\n        mask += Bokeh(ray,p+w1,size,0.1)*fade;\n        \n        mask += Bokeh(ray,p-w2,size,0.1)*fade;\n        mask += Bokeh(ray,p+w2,size,0.1)*fade;\n        \n        float ref = 0.0;//反射,y取相反,然后模糊百分比是1,size大一些\n        ref += Bokeh(ray,(p-w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade;\n        ref += Bokeh(ray,(p+w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade;\n        \n        mask += ref*focus;\n    }\n    \n    return vec3(0.9,0.9,1.0)*mask;\n}\n\n//尾灯\nvec3 TailLight(Ray ray,float t)\n{\n    t *= 0.25;\n    vec3 w1 = vec3(0.25,0.0,0.0);\n    vec3 w2 = w1*1.2;\n    float s = 1.0/15.0;//for循环间隔\n    float mask = 0.0;\n    for(float i=0.0;i<1.0;i+=s)\n    {\n        float n = Noise(i);\n        if(n>0.5) continue;//去掉一些随机值小于0.1的部分，达到一个随机效果\n        \n        float lane = step(0.25,n)+0.4;//用于红色偏移\n        \n        float ti = fract(t+i);//fract取小数部分的函数,左半边比右半边快一些\n        float focus = smoothstep(0.8,1.0,ti);\n        float size = mix(0.05,0.04,focus);\n        \n        float laneShift = smoothstep(1.0,0.96,ti);//部分红色转弯\n        \n        float fade = ti*ti*ti*ti*ti;\n        float z = 100.0-ti*100.0;\n        vec3 p = vec3(1.5-lane*laneShift,0.15,z);//10个深度不同的圆\n        mask += Bokeh(ray,p-w1,size,0.1)*fade;//乘以t^n减少初始地区圆的数量\n        mask += Bokeh(ray,p+w1,size,0.1)*fade;\n        \n        float blink = step(0.,sin(1000.0*t))*7.0*step(0.25,n)*step(0.96,ti);//乘以step(0.96,ti)让红色转弯时才闪烁\n        mask += Bokeh(ray,p-w2,size,0.1)*fade;\n        mask += Bokeh(ray,p+w2,size,0.1)*fade*(1.0+blink);\n        \n        float ref = 0.0;//反射,y取相反,然后模糊百分比是1,size大一些\n        ref += Bokeh(ray,(p-w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade;\n        ref += Bokeh(ray,(p+w2)*vec3(1.0,-1.0,1.0),size*3.0,1.0)*fade*(1.0+blink*0.1);\n        \n        mask += ref*focus;\n    }\n    \n    return vec3(1.0,0.1,0.03)*mask;\n}\n\n//rain雨,在挡风玻璃前的雨\nvec2 Rain(vec2 uv,float t)\n{\n    t *= 40.0;\n    vec2 a = vec2(3.0,1.0);//分出多行多列\n    vec2 st = uv*a;\n    \n    vec2 id = floor(st);//获得每个雨滴是第几行第几列\n    st.y += t*0.22;   //网格下降,和雨滴上升抵消,达到雨滴先下落后暂停的循环\n    \n    float n = fract(sin(id.x*716.34)*768.34);//根据不同的列获得不同的随机数\n    //对y进行偏移,使得不同列起始位置不同\n    st.y += n;\n    uv.y += n;\n    \n    id = floor(st);//根据偏移后的坐标重新计算行数和列数\n    st = fract(st)-0.5;//st范围变为(-0.5,-0.5)-(0.5,0.5)\n    \n    //根据不同行,不同列队t进行偏移,使得不同雨滴下落时间不同\n    t += fract(sin(id.x*76.34+id.y*1453.7)*768.34)*6.283;\n    float offsetY = -sin(t+sin(t+sin(t)*0.5))*0.43;\n    vec2 offset = vec2(0.0,offsetY);//大雨滴的滑落偏移\n    \n    vec2 o1 = (st-offset)/a;//除以横纵比,不再是椭圆\n    float d = length(o1);\n    float m1 = smoothstep(0.07,0.0,d);\n    \n    //大雨滴后面的小雨滴\n    vec2 o2 = (fract(uv*a.x*vec2(1.0,2.0))-0.5)/vec2(1.0,2.0);\n    d = length(o2);//除以横纵比,将x,y方向间距相同\n    \n    float mask = smoothstep(-0.1,0.1,st.y-offset.y);//去除大雨滴下面的小雨滴\n    \n    //模拟大雨滴划过之后留在原地的小雨滴\n    float m2 = smoothstep(0.2*(0.6-st.y),0.0,d)*mask;//距离大雨滴越远的水滴越小\n    \n    //if(st.x>0.46 || st.y>0.49) m1=1.0;//边界线\n    \n    return vec2(m1*o1*5.0+m2*o2*5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;//鼠标点击位置\n    \n    //虚拟摄像机\n    vec3 camPos = vec3(0.0,0.2,0.0);\n    vec3 lookat = vec3(0.0,0.2,1.0);\n    float zoom = 2.0;//可以调整摄像机与屏幕的距离\n    \n    float t = iTime*0.1+m.x;//时间和鼠标点击位置的x值共同决定\n    \n    vec2 rainDistort = Rain(uv*7.0,t)*0.5;//扭曲的uv\n    rainDistort += Rain(uv*9.0,t)*0.5;\n    \n    //对uv的xy进行小幅度的偏移,让圆不那么规则\n    uv.x += sin(uv.y*70.0)*0.005;\n    uv.y += sin(uv.x*170.0)*0.003;\n    \n    //uv.x -= 0.5;\n    Ray ray = SetCamera(uv-rainDistort,camPos,lookat,zoom);\n    \n    vec3 col = vec3(0.0);\n    col += Light(ray,t);//黄色部分\n    col += HeadLight(ray,t);//白色部分\n    col += TailLight(ray,t);//红色部分\n    col += EnvLight(ray,t);//随机颜色部分\n    \n    col += (ray.direction.y+0.15)*vec3(0.3,0.4,0.7);//渐变天空\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}