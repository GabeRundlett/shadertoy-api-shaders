{
    "Shader": {
        "info": {
            "date": "1611927499",
            "description": "A variation of mattz's [url]https://www.shadertoy.com/view/XdKyRR[/url], with a different solver and showing the quartic in the complex plane and solving for complex roots. Same root generation as original, but can use mouse to override two of the roots.",
            "flags": 16,
            "hasliked": 0,
            "id": "tlVcD3",
            "likes": 15,
            "name": "Analytic Quartic Solver",
            "published": 3,
            "tags": [
                "domain",
                "complex",
                "solver",
                "quartic",
                "analytic",
                "polynomial"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 526
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Analytic Quartic Solver remix by mla, 2021, original by mattz, 2018.\n//\n// * different quartic solver\n// * finds all solutions, real and complex\n// * shows domain mapping for polynomial\n// * select two roots with mouse (upper half for complex, lower for real).\n//\n// 'x': show unmapped domain\n//\n// As usual, multiple roots can be problematic. It might be a good idea\n// to add some special case code for triple and quadruple roots, \n// as in mattz's original, but for now there are no tricks.\n//\n// quartic solver is from Lanczos\n// cubic solver is choice of analytic solver from Numerical Recipes (qcubic0)\n// or semi-iterative solver by Kahan (qcubic1)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n///////////// mattz header /////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n/* \"analytic quartic solver\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   I hunted around a little bit on Shadertoy but couldn't find any\n   examples of a standalone, single-function quartic solver \n   capable of returning all real roots of a 4th-degree polynomial.\n\n   The result is the solve_quartic function below, feel free to \n   use it in your own projects under the license linked above.\n\n   With respect to testing, I wanted to make sure to test\n   all eight cases of root distribution (see generate_roots below).\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a quartic polynomial whose first coefficient is 1.\n\n#define qcubic qcubic1 // Which cubic solver to use\n\nfloat poly4(vec4 p, float x) {\n  return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\n\nvec3 polycolor(vec2 z) {\n  vec2 z0 = z;\n  float h = 0.5+0.5*atan(z.y,z.x)/PI;\n  vec3 col = hsv2rgb(min(h,1.0-h),1.0,sqrt(1.0/(1.0+length(z))));\n  z -= floor(z);\n  z = min(z,1.0-z);\n  col *= mix(0.5+0.5*smoothstep(0.0,0.1,min(z.x,z.y)),1.0,min(1.0,length(z0)/20.0));\n  return col;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\nvec2 complex(float x) {\n  return vec2(x,0);\n}\nvec2 cpoly4(vec4 p, vec2 x) {\n  return cmul(cmul(cmul(x+complex(p[0]),x) + complex(p[1]),x) + complex(p[2]),x) + complex(p[3]);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Complex quadratic\nvoid cquadratic(float A, float B, float C, out vec4 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) {\n    float r = sqrt(-q);\n    res[0] = res[2] = b/A;\n    res[1] = -r/A;\n    res[3] = r/A;\n    return;\n  }\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A; res[1] = 0.0;\n    res[2] = -res[0]; res[3] = 0.0;\n  } else {\n    res[0] = C/r; res[1] = 0.0;\n    res[2] = r/A; res[3] = 0.0;\n  }\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic0(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // And select the largest\n  float psi = roots[0];\n  if (nroots > 1 && roots[1] > psi) psi = roots[1];\n  if (nroots > 2 && roots[2] > psi) psi = roots[2];\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float DQ, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  DQ = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Kahan cubic solver.\n// Semi iterative, no trig.\n// Probably best, particularly if cos is poor quality.\nfloat qcubic1(float B, float C, float D) {\n  float A = 1.0;\n  float X,b1,c2;\n  if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      X = x0;\n      for (int i = 0; i < 4; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        X -= q/dq;\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  vec2 res;\n  if (quadratic(A,b1,c2,res) != 0) {\n    X = max(X,res.x);\n    X = max(X,res.y);\n  }\n  return X;\n}\n\n// The Lanczos quartic method\nvoid lquartic(float c1, float c2, float c3, float c4, out vec4 roots0, out vec4 roots1) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi == 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  cquadratic(1.0,alpha+a,beta+b,roots0);\n  cquadratic(1.0,alpha-a,beta-b,roots1);\n}\n\nvoid solve_quartic(vec4 coeffs, out vec2 roots[4]) {\n  float B = coeffs[0], C = coeffs[1], D = coeffs[2], E = coeffs[3];\n  vec4 roots0, roots1;\n  lquartic(B,C,D,E,roots0,roots1);\n  roots[0] = roots0.xy;\n  roots[1] = roots0.zw;\n  roots[2] = roots1.xy;\n  roots[3] = roots1.zw;\n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a cubic polynomial with given coefficients\n\nfloat poly3(vec4 p, float x) {\n  return ((p[0]*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// from Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n\nfloat hash12(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat noise(vec2 xc) {\n    \n  float x0 = floor(xc.x);\n  float t = fract(xc.x);\n    \n  float a = hash12(vec2(x0-1., xc.y));\n  float b = hash12(vec2(x0, xc.y));\n  float c = hash12(vec2(x0+1., xc.y));\n  float d = hash12(vec2(x0+2., xc.y));\n    \n  float t2 = t*t;\n  float t3 = t2*t;\n    \n  float h00 = (2.*t3 - 3.*t2 + 1.);\n  float h01 = (t3 - 2.*t2 + t);\n  float h10 = (-2.*t3 + 3.*t2);\n  float h11 = (t3 - t2);\n    \n  return (h00*b + h01*(c-a) + h10*c + h11*(d-b))*2. - 1.;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// generate coefficients for 4th degree quartic from roots\n// note that c is the complex part of roots 0 & 1 and 2 & 3\n// if c[0] != 0, then we expect r[0] == r[1] and similarly\n// if c[1] != 0\n\nvec4 poly_from_roots(vec4 r, vec2 c) {\n    \n  float s01 = r[0] + r[1];\n  float p01 = r[0] * r[1] + c[0] * c[0];\n  float s23 = r[2] + r[3];\n  float p23 = r[2] * r[3] + c[1] * c[1];\n    \n  return vec4(-s01 - s23,\n              p01 + s01*s23 + p23,\n              -p01*s23 - s01*p23,\n              p01*p23);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// for a quartic with real coefficients, there are eight different\n// cases for roots, which we cycle through over time:\n//               \n//   case timestep #real multiplicity\n//     A  0-0.99       4   4 single           \n//     B  1-1.99       4   1 double, 2 single \n//     C  2-2.99       4   2 double\n//     D  3-3.99       4   1 triple, 1 single \n//     E  4-4.99       4   1 quad\n//     F  5-5.99       2   2 single\n//     G  6-6.99       2   1 double\n//     H  7-7.99       0   no real roots\n//\n//        8-8.99   repeat case C to move smoothly back to A\n//\n\nvoid generate_roots(out vec4 r, out vec2 c) {\n    \n  float t = 0.1*iTime;\n  float d = 2.2;\n\n  r = vec4(noise(vec2(t, 10.)),\n           noise(vec2(t, 1.)),\n           noise(vec2(t, 12.)),\n           noise(vec2(t, 3.)))*d;\n    \n  vec3 cc = vec3(noise(vec2(t, 14.))+0.2*d,\n                 noise(vec2(t, 5.))+0.2*d,\n                 0);\n    \n  t = 0.05*iTime;\n  float rep = floor(t/9.);\n    \n  float phase = mod(t, 9.);\n  float u = smoothstep(0.8, 1.0, fract(phase));\n    \n  c = vec2(0);\n            \n  if (phase < 1.) { \n    r = mix(r, r.xxzw, u); // A -> B\n  } else if (phase < 2.) {\n    r = mix(r.xxzw, r.xxzz, u); // B -> C\n  } else if (phase < 3.) {\n    r = mix(r.xxzz, r.xxxz, u); // C -> D\n  } else if (phase < 4.) {\n    r = mix(r.xxxz, r.xxxx, u); // D -> E\n  } else if (phase < 5.) {\n    r = mix(r.xxxx, r.xxzw, u); // E -> F\n    c = mix(cc.zz, cc.xz, u);\n  } else if (phase < 6.) {\n    r = mix(r.xxzw, r.xxzz, u); // F -> G\n    c = cc.xz;\n  } else if (phase < 7.) {\n    r = r.xxzz; // G -> H\n    c = mix(cc.xz, cc.xy, u);\n  } else if (phase < 8.) {\n    r = r.xxzz; // H -> C\n    c = mix(cc.xy, cc.zz, u);\n  } else {\n    r = mix(r.xxzz, r, u); // C -> A\n  }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given point p, function value at p.x and function derivative at\n// p.x, determine estimated distance to curve of function plot.\n\nfloat dist_to_plot(vec2 p, vec2 fdf) {\n    \n  vec2 p0 = vec2(p.x, fdf.x);\n  vec2 n = normalize(vec2(-fdf.y, 1));\n  return abs(dot(p - p0, n));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  float scl = 6.0 / iResolution.x;\n    \n  vec2 p = (fragCoord - 0.5 - vec2(0.5, 0.5)*iResolution.xy)*scl;\n    \n  vec4 r; vec2 c;\n  generate_roots(r, c);\n\n  if (iMouse.z > 0.0) {\n    vec2 q = (iMouse.xy - 0.5 - vec2(0.5, 0.5)*iResolution.xy)*scl;\n    if (q.y > 0.0) {\n      r.zw = vec2(q.x,q.x);\n      c.y = q.y;\n    } else {\n      r.zw = vec2(q.x+q.y,q.x-q.y);\n      c.y = 0.0;\n    }\n  }\n  \n  vec4 poly = poly_from_roots(r, c);\n    \n  vec2 solved_roots[4];\n  solve_quartic(poly, solved_roots);\n    \n  vec4 pder = vec4(4,3,2,1) * vec4(1, poly.xyz);\n    \n  const float Y_ZOOM = 0.5;\n\n  vec2 fdf = Y_ZOOM*vec2(poly4(poly, p.x),poly3(pder, p.x));\n\n  vec3 color = polycolor(cpoly4(poly,p));\n  if (key(CHAR_X)) color = polycolor(p);\n\n  // grid lines\n  vec2 gp0 = .5*floor(2.*p + 0.5);\n  vec2 gp = fract(abs(p - gp0));\n  color = mix(vec3(1), color, 0.9+0.1*smoothstep(0.0, scl, min(gp.x, gp.y)));\n    \n  // axis line\n  vec2 ap = abs(p);\n  //color = mix(vec3(0.37, 0.55, 0.37)*.9, color, 0.8+0.2*smoothstep(0.0, scl, min(ap.x, ap.y)-0.5*scl));      \n    \n  // plot line\n  float dline = dist_to_plot(p, fdf);\n  color = mix(color, vec3(.03, .03, .03), smoothstep(scl, 0., dline-.5*scl));\n    \n  // known roots\n  for (int i=0; i<4; ++i){\n    int j = i/2;\n    float sign = i%2==0 ? -1.0 : 1.0;\n    float dc = length(p - vec2(r[i], sign*c[j]));\n    color = mix(color, vec3(.25, .02, .02), smoothstep(scl, 0., dc-3.*scl));\n  }\n    \n  // solved roots\n  for (int i=0; i<4; ++i){\n    //if (solved_roots[i].y != 0.0) continue;\n    float dc = length(p - solved_roots[i]);\n    color = mix(color, vec3(0, 0, 0.4), smoothstep(scl, 0., abs(dc-8.*scl)-.25*scl));\n  }\n\n  // stole iq's vignette code\n  vec2 q = fragCoord.xy / iResolution.xy;\n  color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n  //color *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n\n  color = pow(color, vec3(1.0/2.2));\n  fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nconst float PI = 3.1415927;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_X = 88;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}