{
    "Shader": {
        "info": {
            "date": "1546457867",
            "description": "Giant flying Vegetable",
            "flags": 0,
            "hasliked": 0,
            "id": "WdX3D7",
            "likes": 3,
            "name": "Flying Cucumber",
            "published": 3,
            "tags": [
                "sdf",
                "veg"
            ],
            "usePreview": 0,
            "username": "jj99",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "// Cucumber\n\nfloat rect(vec2 p, vec2 c, vec2 rad)\n{\n    vec2 d = abs(p - c) - rad;\n    return max(d.x, d.y);\n}\n\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return v*mat2(c, -s, s, c);\n}\n\nfloat lg(vec2 p)\n{\n    float s = 0.08;\n    float sd = rect(p, vec2(0.0), vec2(0.65)*s);\n    sd = sub(sd, rect(p, vec2(-0.3, +0.5)*s, vec2(0.2, 0.35)*s));\n    sd = sub(sd, rect(p, vec2(+0.3, -0.5)*s, vec2(0.2, 0.35)*s));\n    sd = sub(sd, rect(p, vec2(-0.5, -0.3)*s, vec2(0.35, 0.2)*s));\n    sd = sub(sd, rect(p, vec2(+0.5, +0.3)*s, vec2(0.35, 0.2)*s));\n    return sd;\n}\n\nfloat TIO(vec4 v)\n{\n    return smoothstep(v.y,v.y+v.w,v.x) - smoothstep(v.z-v.w,v.z,v.x);\n}\nfloat TIN(vec3 v)\n{\n    return smoothstep(v.y,v.y+v.z,v.x);\n}\n\n\nfloat intersect(float a, float b){return max(a,b);}\n\nfloat box( vec3 p, vec3 b ){\n\tvec3  di = abs(p) - b;\n\tfloat mc = max(di.x, max(di.y, di.z));\n\treturn min(mc,length(max(di,0.0)));}\nfloat sphere(vec3 p, float r){return length(p) - r;}\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 clouds(vec3 rd)\n{\n    float ctime = iTime *0.01;\n    vec2 uv = rd.xz / (rd.y + 0.4);\n    vec3 clouds = vec3(fbm(vec3(uv.yx * 1.4 + vec2(ctime, 0.), ctime) ) * 2.5);\n    clouds = pow(clouds, vec3(2.));\n\tvec3 other = vec3(0.2,0.0,0.3);\n    // lightning\n    float tt = mod(iTime-rd.x*0.05-rd.y*0.1,36.6);\n    float vv = TIO(vec4(tt,3.4,3.66,0.09)) + TIO(vec4(tt+0.1,3.4,3.66,0.08));\n    other = mix(other,vec3(1.1,0.8,0.8),vv);\n\tfloat m = clamp(rd.y+0.2,0.0,1.0);\n\treturn mix(other,clouds,m);\n}\n\n#define TAU 6.283185\n\nfloat ground(vec3 p)\n{\n    float t = fract(iTime*0.41)*TAU;\n    float t2 = fract(iTime*0.24)*TAU;\n    float t3 = fract(iTime*0.332)*TAU;\n    float h = -4.;\n    h += sin(p.z*0.1+t3-p.x*0.23)*0.25;\n    h += sin(t2+p.x*0.231)*0.42;\n    h += cos(t+0.55+p.z*0.31)*0.83;\n    h += sin(t+0.+p.z*0.16)*0.45;\n    return p.y-h;\n}\n\nfloat objID;\n\nfloat map(vec3 p)\n{\n   float g = ground(p);\n   float vv = TIO(vec4(mod(iTime,30.0),5.0,25.0,3.5));\n   p.x += (sin(iTime+p.z)*0.2)*vv;\n   p.y += (cos(iTime+p.z)*0.2)*vv;\n    \n   p.y -= 20.0;\n   float d = 1e10;\n   d = sphere(p*vec3(4.0, 4.0, 1.0), 1.0)*0.25;\n   float a = atan(p.x/p.y);\n   float m = (1.0-abs(p.z))*0.75;\n   d+=abs(sin(a*20.0)*(0.005*m));\n   //float f1 = box(p+vec3(0.0,-0.15,0.5), vec3(0.01, 0.25, 0.2));\n   //float f2 = box(p+vec3(0.0,0.0,0.5), vec3(0.5, 0.01, 0.2));\n   //f1 = min(f1,f2);\n   //f1 = intersect(f1, sphere(p - vec3(0.0, -0.1, -1.55), 1.2));\n   //d = smin(f1, d, 0.025);\n   //vec2 pp = rot(p.yz+vec2(-0.305, 0.56),1.0);\n   //float d2 = lg(pp);\n   //float dep = 0.015 * TIN(vec3(iTime,14.0,1.0));\n   //vec2 e = vec2( d2, abs(p.x) - dep );\n   //d2 = min(max(e.x,e.y),0.0) + length(max(e,0.0))- 0.005;\n   //float d3 = sdRoundBox(p+vec3(0.0,0.23,-0.4),vec3(0.025,0.025,0.161),0.03);\n   //d = smin(d3,d,0.01);\n   objID=2.0;\n   if (d<g)\n   {\n       objID=1.0;\n//       if (d2<d)\n//           objID=3.0;\n   }\n//   d = min(d2,d);\n   return min(d,g);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvec3 render( vec2 p )\n{\n    objID=0.0;\n    float time = iTime;\n\tfloat zoom = sin(time*0.33)*0.2;\n\tfloat an = -1.05+sin(time*0.1)*0.21;\n    \n    float mm = TIO(vec4(mod(iTime,70.0),35.0,55.0,5.0));\n\tan -= mm*0.2;\n    \n    \n\tfloat y = 0.5+sin(time*0.45)*0.29;\n\tvec3 ro = vec3( mm+zoom+2.0*cos(an), (0.7-y*0.5)+20.0+mm*0.15, mm+zoom+2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 20.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.5*ww );\n    // raymarch\n    const float tmax = 490.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.0001 || t>tmax ) break;\n        t += h;\n    }\n\tfloat id = objID;\n\tvec3 objcol = vec3(0.2,1.1,0.05);\n\tobjcol = mix(objcol,vec3(0.9,0.3,0.3),TIO(vec4(mod(iTime+t*0.5,21.0),14.0,18.0,2.0)));\n\tif (id>1.0)\n\t\tobjcol = vec3(0.13,0.23,1.1);\n\t//if (id>2.0)\n\t//\tobjcol = vec3(0.7+sin(fract(time)*TAU)*0.15,0.04,0.04);\n    \n\t\n    // shading/lighting\t\n    vec3 background = clouds(rd);\n    vec3 col = background;\n    if( t<tmax )\n    {\n\t\tvec3 l = vec3(0.0,1.0,0.0);\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n        float amb = 0.5 + 0.5*dot(nor,l);\n\t\tfloat spe = pow(clamp(dot(reflect(l, nor), rd), 0.0, 1.0), 16.0);\n        col = vec3(0.1,0.1,0.1)*amb + objcol*dif;\n\t\tcol += spe;\n        float m = exp(-0.00001*(t*t));\n        col = mix(background,col,m);\n    }\n    // gamma        \n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\tvec3 col = render(p);\n\tfloat m = step(length(col),0.0);\n    if (iMouse.z<0.5)\n    {\n        float r = clamp(hash12(p+fract(iTime*0.7))+0.5,0.0,1.0);\n        float rr = 0.5+sin(sin(r+iTime*0.9-p.y*3.14*p.x)+p.x*(1.2+r)+fract(iTime*0.3-r)*TAU)*0.5;\n        col += (rr+0.3)*0.141;\n        col -= 0.571 * max( sin(fragCoord.y*0.85 - iTime * 12.1)-r*0.79, 0.1);\n        col *= clamp(mod(fragCoord.x*fragCoord.y, 1.0),0.85,1.0);\n    }\n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}