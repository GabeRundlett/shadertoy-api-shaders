{
    "Shader": {
        "info": {
            "date": "1640968761",
            "description": "Trying to draw a sphere made of points which can be zoomed in on to reveal spheres that repeat this pattern when also zoomed on, forever. Please let me know if anyone has posted anything close to attempting this. Thank you Shadertoy community!",
            "flags": 0,
            "hasliked": 0,
            "id": "NlyXRK",
            "likes": 0,
            "name": "Causality",
            "published": 3,
            "tags": [
                "reason"
            ],
            "usePreview": 0,
            "username": "zovox",
            "viewed": 116
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 t1 = marchScene(uv, iTime);\n    vec4 t2 = marchScene(vec2(atan(t1.x, t1.z)/PI*2., t1.y), iTime);\n    fragColor = t1+t2;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define FAR (10.)\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere( vec3 p, vec3 s, float r )\n{\n    return length(p-s)-r;\n}\nfloat smooth_floor(float x) {\n    return smoothstep(0.5, 1., fract(x))+floor(x);\n}\n\nfloat dfScene(in vec3 z0){\n    float mind = 1E32;\n    \n    const float detail = 8.;\n    for(float vert = 0.; vert < detail; vert += 1.) {\n        for(float horiz = 0.; horiz < detail; horiz += 1.) {\n            float alpha = (vert/detail)*PI;\n            float omega = (horiz/detail*2.-1.)*PI;\n            \n            vec3 o = vec3(sin(alpha)*cos(omega), sin(alpha)*sin(omega), cos(alpha));\n            float d = sdSphere(z0, o, .125);\n            if(d < mind) mind = d;\n        }\n    }\n    \n\treturn mind;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / 1024., 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec4 marchScene(vec2 uv, float time) {\n    \n    float movement = time/PI;\n    //camera\n    vec3 rd = normalize(vec3(uv, -2.+cos(movement)));\n    vec3 ro = vec3(0.0, 0., 2.);\n    \n    //rotate camera\n    rd.xz *= rot(-movement);\n    ro.xz *= rot(-movement);\n    ro += rd/512.;\n    \n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i <16; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR)\n        {\n            break;\n        }\n        \n    }\n    float fog = smoothstep(.75, .9, d/FAR);\n    vec3 n = surfaceNormal(p);\n    return vec4(n, 1.)*(1.-fog);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}