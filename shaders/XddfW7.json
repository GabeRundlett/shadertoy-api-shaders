{
    "Shader": {
        "info": {
            "date": "1527032402",
            "description": "Testing different people's quartic roots algorithms in the context of a couple simple quartic shapes + some quadric ones too\n\nhad big dreams for this one, but it looks like shiny unstable poo\n\nShane wins for best quartic solver!",
            "flags": 0,
            "hasliked": 0,
            "id": "XddfW7",
            "likes": 16,
            "name": "Quartic Intersection",
            "published": 3,
            "tags": [
                "torus",
                "sphere",
                "intersection",
                "quartic",
                "parabola"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 1131
        },
        "renderpass": [
            {
                "code": "#define SHANE 1\n#define MATTZ 2\n#define WYATT 0\n#define METHOD SHANE\nmat3 M;\nmat3 rot (vec3 u) {\n\t\tvec3 s = sin(u), c = cos(u);\n\t\tmat3 x = mat3(1,0,0, \t\t0,c.x,s.x, \t\t0,-s.x,c.x);\n\t\tmat3 y = mat3(c.y,0,s.y, \t0,1,0, \t\t\t-s.y,0,c.y);\n\t\tmat3 z = mat3(s.z,c.z,0,\t-c.z,s.z,0,\t\t0,0,1);\n\t\treturn x*y*z;}\n\n#if METHOD == WYATT\n\t//https://www.shadertoy.com/view/4dlcDN\n\tfloat cbrt (float a) {\n        return sign(a)*exp(log(abs(a))/3.);\n    }\n    vec2 cbrt (vec2 a) {\n        return vec2(cbrt(a.x),cbrt(a.y));\n    }\n    vec2 cbrti (vec2 v) {\n        float a = length(v);\n        a = exp(log(a)/3.);\n        float theta = atan(v.y/v.x)/3.;\n        return a*vec2(cos(theta), sin(theta));\n    }\n    float cubic (float b, float c, float d) {\n        float p = -b/3.;\n        float q = p*p*p + b*c/6. - 0.5*d;\n        float r = c/3.;\n        float s = r-p*p;\n        float u = q*q + s*s*s;\n        if (u < 0.) {\n            vec2 t = vec2(0., sqrt(-u));\n            vec2 Q = vec2(q, 0.);\n            return (cbrti(Q + t) + cbrti(Q - t)).x + p; \n        } else {\n            float t = sqrt(u);\n            return cbrt(q + t) + cbrt(q - t) + p; \n        }\n    }\n\tbvec4 solve_quartic (in vec4 coe, out vec4 roots) {\n        //https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n        float b = coe.x;float c = coe.y; float d = coe.z; float e = coe.w;\n        float p = c - 3.*b*b/8.;\n        float q = 0.125*b*b*b - 0.5*b*c + d;\n        float r = (-3.*b*b*b*b + 256.*e - 64.*b*d + 16.*b*b*c)/256.;\n        float m = cubic(p, 0.25*p*p - r, -0.125*q*q);\n        if (m<=0.) return bvec4(false);\n        float A = -0.25*b;\n        float B = 0.5*sqrt(2.*m);\n        float C = -2.*p - 2.*m;\n        float D = -sqrt(2.)*q/sqrt(m);\n        float x = 10.;\n        roots = vec4(\n            A + B + 0.5*sqrt(C + D),\n            A + B - 0.5*sqrt(C + D),\n            A - B + 0.5*sqrt(C - D),\n            A - B - 0.5*sqrt(C - D)\n        );\n        return bvec4(vec2(C+D>=0.),vec2(C-D>=0.));\n    }\n#elif METHOD == MATTZ\n\t//https://www.shadertoy.com/view/4dVcR1\n\tbvec4 solve_quartic(in vec4 coeffs,out vec4 roots) {\n        //Mattz version of quartic solver\n\t\t//https://www.shadertoy.com/view/XdKyRR\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n#elif METHOD == SHANE\n\t//https://www.shadertoy.com/view/XsGyDh\n\tint solve_quadric(vec2 coeffs, inout vec2 roots){\n        float p = coeffs.y / 2.;\n        float D = p*p - coeffs.x;\n        if (D <= 0.) return 0;\n        else {\n            roots = vec2(-1, 1)*sqrt(D) - p;\n            return 2;\n        }\n    }\n    int solve_cubic(vec3 coeffs, inout vec3 r){\n        float a = coeffs[2];\n        float b = coeffs[1];\n        float c = coeffs[0];\n        float p = b - a*a/3.;\n        float q = a * (2.*a*a - 9.*b)/27. + c;\n        float p3 = p*p*p;\n        float d = q*q + 4.*p3/27.;\n        float offset = -a/3.;\n        if(d >= 0.0) { \n            vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n            uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n            r[0] = offset + uv.x + uv.y;\t\n            float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n            float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n            r[0] -= f/f1;\n            return 1;\n        }\n        float u = sqrt(-p/3.);\n        float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n        float m = cos(v), n = sin(v)*1.732050808;\n        float f,f1;\n        r[0] = offset + u * (m + m);\n        f = ((r[0] + a)*r[0] + b)*r[0] + c;\n        f1 = (3.*r[0] + 2. * a)*r[0] + b;\n        r[0] -= f / f1;\n        r[1] = offset - u * (n + m);\n        f = ((r[1] + a)*r[1] + b) * r[1] + c;\n        f1=(3.*r[1] + 2. * a)*r[1] + b;\n        r[1] -= f / f1;\n        r[2] = offset + u * (n - m);\n        f = ((r[2] + a)*r[2] + b)*r[2] + c;\n        f1 = (3.*r[2] + 2. * a)*r[2] + b;\n        r[2] -= f / f1;\n        return 3;\n    }\n    bvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n        bvec4 broots;\n        float a = coeffs[0];\n        float b = coeffs[1];\n        float c = coeffs[2];\n        float d = coeffs[3];\n        float sq_a = a * a;\n        float p = - 3./8. * sq_a + b;\n        float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n        float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n        int num;\n        vec3 cubic_coeffs;\n        cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n        cubic_coeffs[1] = - r;\n        cubic_coeffs[2] = - 1.0/2. * p;\n        solve_cubic(cubic_coeffs, s.xyz);\n        float z = s[0];\n        float u = z * z - r;\n        float v = 2. * z - p;\n        if(u > 0.) u = sqrt(abs(u));\n        else return bvec4(false);\n        if(v > 0.) v = sqrt(abs(v));\n        else return bvec4(false);\n        vec2 quad_coeffs;\n        quad_coeffs[0] = z - u;\n        quad_coeffs[1] = q < 0. ? -v : v;\n        num = solve_quadric(quad_coeffs, s.xy);\n        if (num == 0) broots.xy = bvec2(false);\n        if (num == 2) broots.xy = bvec2(true);\n        quad_coeffs[0] = z + u;\n        quad_coeffs[1] = q < 0. ? v : -v;\n        vec2 tmp = vec2(1e8);\n        int old_num = num;\n        num = solve_quadric(quad_coeffs, s.zw);\n        if (num == 0) broots.zw = bvec2(false);\n        if (num == 2) broots.zw = bvec2(true);\n        s -= a/4.;\n        return broots;\n    }\n#endif\n\nfloat absmin(float a, float b) {\n\tif (b>0.) return min(a,b);\n    return a;\n}\nfloat intersect (vec4 coes) {\n    vec4 roots;\n    bvec4 br = solve_quartic(coes, roots);\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}\nfloat intersect (vec2 coes) {\n\tfloat i=1e4;\n    float det = coes.x*coes.x-4.*coes.y;\n    if (det < 0.) return i;\n    det =sqrt(det);\n    i = absmin(i,0.5*(-coes.x+det));\n    i = absmin(i,0.5*(-coes.x-det));\n    return i;\n}\nvec4 torus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r) {\n\tfloat dn = dot(d,n);\n    float wn = dot(p-c,n);\n    vec3 s = p-c-wn*n;\n    vec3 q = d - dn*n;\n    float qq = dot(q,q);\n    float sq = dot(s,q);\n    float ss = dot(s,s);\n    float A = (dn*dn+qq)*0.5/r.x;\n    float B = (wn*dn+sq)/r.x;\n    float C = (r.x*r.x-r.y*r.y+wn*wn+ss)*0.5/r.x;\n    return vec4(2.*A*B,B*B+2.*A*C-qq,2.*C*B-2.*sq,C*C-ss)/(A*A);\n    \n}\nvec4 cube (vec3 p, vec3 d, vec3 c, mat3 n, float r) {\n\tvec3 a = vec3(dot(p-c,n[0]),dot(p-c,n[1]),dot(p-c,n[2]));\n    vec3 b = vec3(dot(d,n[0]),dot(d,n[1]),dot(d,n[2]));\n    return vec4(\n        4.*dot(a*b,b*b),\n        6.*dot(a*a,b*b),\n        4.*dot(a*a,a*b),\n           dot(a*a,a*a)-r*r*r*r\n    )/dot(b*b,b*b);\n}\nvec2 ellipse (vec3 p, vec3 d, vec3 a, vec3 b, float r) {\n\ta = p-a;b = p-b;\n    float \n        rr = r*r,\n        ad = dot(a,d),\n        bd = dot(b,d),\n        aa = dot(a,a),\n        bb = dot(b,b);\n    return vec2(\n    \tad*aa-ad*bb+bd*bb-bd*aa-rr*(ad+bd),\n        -aa*bb+0.25*(aa*aa+bb*bb+rr*rr)+0.5*(aa*bb-rr*(aa+bb))\n    )/(ad*ad+bd*bd-rr-2.*ad*bd);\n}\nvec2 sphere (vec3 p, vec3 d, vec3 c, float r) {\n\tc = p-c;\n    return vec2(2.*dot(c,d),dot(c,c)-r*r);\n}\nvec2 parabola (vec3 p, vec3 d, vec3 a, vec3 b) {\n\tvec3 n = normalize(b-a);\n    a = p-a;\n    b = p-b;\n    float\n        dn = dot(d,n),\n        an = dot(a,n),\n        bd = dot(b,d),\n        bb = dot(b,b);\n   \treturn vec2(\n    \t2.*(an*dn-bd),\n        an*an-bb\n    )/(dn*dn-1.);\n}\nfloat scene (vec3 p, vec3 d) {\n    float i = 1e3;\n    i = min(i,intersect(torus (p,d,vec3(0),vec3(0,0,1),vec2(0.15,0.02))));\n    i = min(i,intersect(ellipse(p,d,vec3(-.1,-.08,0.04),vec3(0.1,-.08,-.04),.23)));\n    i = min(i,intersect(cube (p,d,vec3(0),mat3(1,0,0,0,1,0,0,0,1),0.5)));\n    i = min(i,intersect(cube (p,d,vec3(.1),mat3(1,0,0,0,1,0,0,0,1),0.08)));\n  \ti = min(i,intersect(sphere(p,d,vec3(0,.1,0),0.03)));\n    i = min(i,intersect(parabola(p,d,vec3(-0.02,0,0),vec3(0))));\n    return i;\n    \n}\nvec3 nor (vec3 p, vec3 d, float i) {\n\tfloat e = 1e-4;\n    vec3 t = normalize(cross(d,vec3(1,0,0)));\n    vec3 a = p+e*t+d*scene(p+e*t,d);\n    t = normalize(cross(d,t));\n    vec3 b = p+e*t+d*scene(p+e*t,d);\n    p = p+d*i;\n\treturn normalize(cross(b-p,a-p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy*2.-1.)*iResolution.xy/iResolution.yy;\n\tM = rot(0.3*iTime*vec3(0,vec2(1)+0.3*(iMouse.xy/iResolution.xy*2.-1.)));\n    vec3 p = M*vec3(0.01*uv,-.3);\n    vec3 d = M*normalize(vec3(uv,2));\n    float i;\n    vec3 n;\n    vec3 col = vec3(0);\n    for (int o = 0; o < 6; o++) {\n    \ti = scene(p,d);\n        n = nor(p,d,i);\n        p += i*d;\n       \td = reflect(d,n);\n        p += 0.001*d;\n        col += (0.3+0.7*n)/float(2*o/3+2);\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}