{
    "Shader": {
        "info": {
            "date": "1708884956",
            "description": "quick plotter for any function",
            "flags": 0,
            "hasliked": 0,
            "id": "4Xj3Rc",
            "likes": 2,
            "name": "Grapher_hb",
            "published": 3,
            "tags": [
                "graph",
                "function",
                "plot"
            ],
            "usePreview": 0,
            "username": "haxe",
            "viewed": 120
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define H_PI 1.5707963268\n\n// Settings:\n#define PLOT_VECTOR\n//#define X_MIN_ONE_TO_ONE\n\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// http://www.vendian.org/mncharity/dir3/blackbody/\nvec3 temp2rgb(float T) {\n    \n    float t = T/6550.; // CIE-1964 10 deg\n    \n    // low temp\n    vec4 tl = vec4(1.0, t, t*t, t*t*t);\n    \n    vec4 gcoefl = vec4(-0.20375, 1.62293, -0.29004, -0.17784); // CIE-1964 10 deg\n    vec4 bcoefl = vec4(0.04977, -1.1097, 3.6150, -1.5551); // CIE-1964 10 deg\n    \n    vec3 rgbl = vec3(1.0, dot(gcoefl, tl), dot(bcoefl, tl) );\n    \n    // high temp\n    vec3 th = vec3( 1.0, 1.0/t, 1.0/(t*t) );\n    \n    vec3 rcoefh = vec3(0.31294, 0.009150, 0.67791); // CIE-1964 10 deg\n    vec3 gcoefh = vec3(0.46983, 0.17257, 0.30819); // CIE-1964 10 deg\n    \n    vec3 rgbh = vec3(dot(rcoefh, th), dot(gcoefh, th), 1.0 );\n    \n    // CIE 1964 is for large areas, CIE1932 is for bright spots.\n    // If you really want CIE-1932, the values should be as per below:\n    // float t = T/6670.; // CIE-1932 2 deg\n    // vec4 gcoefl = vec4(-0.2461, 1.9432, -0.6786, -0.06727); // CIE-1932 2 deg\n    // vec4 bcoefl = vec4(0.06415, -1.2143, 3.8684, -1.7182); // CIE-1932 2 deg\n    // vec3 rcoefh = vec3(0.34472, -0.01064, 0.66593); // CIE-1932 2 deg\n    // vec3 gcoefh = vec3(0.43651, 0.17674, 0.33894); // CIE-1932 2 deg\n    \n    return mix(rgbl, rgbh, step(1.0, t));\n}\n\n// Based on code by Dan Bruton\n// http://www.physics.sfasu.edu/astro/color/spectra.html\nvec3 wl2rgb( float wl, float gamma) {\n    // original, with sharp edges\n\tfloat att = clamp(0.3 + 0.7*(wl-375.) / (440.-375.),0.,1.);\n\tfloat k = clamp((440.-wl) / (440.-375.),0.,1.) * att;\n\tfloat r = clamp((wl-510.) / (580.-510.),0.,1.) - clamp((wl-645.) / (750.-645.),0.,1.);\n\tfloat g = clamp((wl-440.) / (490.-440.),0.,1.) - clamp((wl-580.) / (645.-580.),0.,1.);\n\tfloat b = att - clamp((wl-490.) / (510.-490.),0.,1.);\n    r = mix(k, r, step(480., wl));\n\treturn pow(vec3(r,g,b), vec3(abs(gamma)));\n}\n\nvec3 wl2rgb2( float wl, float gamma) {\n    // with smoothstep, adapted width\n    float att = clamp(0.3 + 0.7*(wl-375.) / (440.-375.),0.,1.);\n    //        -lowshelf...               + highshelf\n    float k = clamp((440.-wl) / (440.-375.),0.,1.) * att;\n    float r = -smoothstep(505.,585., wl) + smoothstep(640.,760.,wl);\n\tfloat g = -smoothstep(440.,490., wl) + smoothstep(580.,654.,wl);\n\tfloat b = -smoothstep(340.,450., wl) + smoothstep(485.,515.,wl);\n    float x = (wl-300.)/(800.-300.);\n    r = mix(k, r, step(480., wl));\n    return pow(vec3(r,g,b), vec3(abs(gamma)));\n}\n\n\nvec3 plot3(vec2 uv, vec3 y){\n#ifdef X_MIN_ONE_TO_ONE\n  uv.y = 0.5*(uv.y + 1.);\n#endif\n  \n  if (uv.y > 0.5) {\n      return y;\n  }\n  \n  float a = smoothstep( y.x-0.01, y.x, 2.1*uv.y) - smoothstep( y.x, y.x+0.01, 2.1*uv.y);\n  float b = smoothstep( y.y-0.01, y.y, 2.1*uv.y) - smoothstep( y.y, y.y+0.01, 2.1*uv.y);\n  float c = smoothstep( y.z-0.01, y.z, 2.1*uv.y) - smoothstep( y.z, y.z+0.01, 2.1*uv.y);\n  vec3 gr = 0.25*vec3(int(500.*uv.x+0.5)%100==0) + 0.25*vec3(int(500.*uv.x+0.5)%20==0);\n  vec3 f = vec3(a,b,c) + gr;\n  return f;\n}\n\nvec3 plot(vec2 uv, float y){\n#ifdef X_MIN_ONE_TO_ONE\n  uv.y = 0.5*(uv.y + 1.);\n  y = 0.5*(y + 1.);\n#endif\n  float f = smoothstep( y-0.01, y, uv.y) - smoothstep( y, y+0.01, uv.y);\n  //return (1.-f)*vec3(y) + f*vec3(1,0,0);\n  return mix(vec3(y),vec3(1,0,0), f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef X_MIN_ONE_TO_ONE\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord/iResolution.xy) - 1.0;\n#else\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n#endif\n    \n    float x = uv.x, y,z,w, t = iTime;\n    vec3 col;\n    \n#ifdef PLOT_VECTOR\n    // ******** your 3D function here: ********\n    y = smoothstep(0.,1.,x);\n    z = 0.5*cos(PI*x)+0.5;\n    w = -0.5;\n    col = plot3(uv, 0.5 + 0.5*vec3(y,z,w));\n    \n    // palette\n    //col = plot3(uv, palette(x));\n    \n    // temp2rgb\n    //col = plot3(uv, temp2rgb(0.+9000.*x));\n    \n    // wl2rgb\n    col = plot3(uv, wl2rgb2(300.+500.*x, 0.8));\n    \n    // hsl2rgb\n    //col = plot3(uv, hsb2rgb(vec3(1.-uv.x,1.,1.)));\n    \n#else\n    // ******** your scalar function here: ********\n    y = 1.0 - pow(abs(x),2.5);\n    y = exp(-PI*x*x);\n    y = (cos(PI*x/2.), 2.5);\n    \n    //y = x;\n    col = plot(uv, y);\n    \n#endif\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}