{
    "Shader": {
        "info": {
            "date": "1609959905",
            "description": "Tool for designing 3D SDFs.",
            "flags": 48,
            "hasliked": 0,
            "id": "Wlcczs",
            "likes": 3,
            "name": "3D SDF Designer Tool",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "modelling",
                "tool",
                "design"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "/*\nI originally designed this for myself but it turned out so well I decided to share it :)\nMouse rotates the camera and the arrow keys move it.\nSettings are in common (at the top).\n*/\n\n// Build your SDF here\nfloat mapScene(in vec3 p) {\n    float innerCup = sdCylinder(p - vec3(0.0, 0.1, 0.0), 0.99, 0.99);\n    float cup = opSmoothSubtraction(sdCylinder(p, 1.0, 1.0), innerCup, 0.05) - 0.05;\n    float handle = sdTorus(p.xzy * vec3(1.4, 1.5, 1.0) - vec3(1.8, 0.0, 0.0), vec2(0.75, 0.2)) - 0.01;\n    cup = opSmoothUnion(cup, opSmoothSubtraction(handle, innerCup, 0.1), 0.2);\n    return cup * 0.5;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    vec3 rd = normalize(camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n\n    float t = MIN_TRACE_DIST;\n    for (int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < MIN_HIT_DIST) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(LIGHT_DIRECTION);\n\n            fragColor.rgb += 1.0;\n            #ifdef SHOW_NORMALS\n            fragColor.rgb = n;\n            #endif\n\n            #ifdef SHOW_DEPTH\n            fragColor.rgb *= (p.z - Z_FAR) / (Z_NEAR - Z_FAR);\n            #endif\n\n            #ifdef LIGHTING\n            fragColor.rgb *= max(0.2, dot(n, l));\n            #endif\n\n            break;\n        }\n\n        #ifdef SHOW_AXES\n        float xAxis = sdVerticalCapsule(p.yxz, 5.0, 0.1);\n        float yAxis = sdVerticalCapsule(p, 5.0, 0.1);\n        float zAxis = sdVerticalCapsule(p.xzy, 5.0, 0.1);\n        if (xAxis < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n\n        if (yAxis < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(0.0, 1.0, 0.0);\n            break;\n        }\n\n        if (zAxis < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(0.0, 0.0, 1.0);\n            break;\n        }\n\n        d = min(d, min(xAxis, min(yAxis, zAxis)));\n        #endif\n\n        #ifdef SHOW_GROUNDPLANE\n        float groundplane = p.y;\n        if (groundplane < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(0.6, 0.4, 0.0);\n\n            #ifdef SHOW_DISTANCE_FIELD\n            fragColor.rgb *= 0.5 + 0.5 * sin(mapScene(vec3(p.x, 0.0, p.z)) * 100.0);\n            #endif\n\n            break;\n        }\n\n        d = min(d, groundplane);\n        #endif\n\n        if (t > MAX_TRACE_DIST) {\n            break;\n        }\n\n        t += d;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Scene settings\nconst vec3 LIGHT_DIRECTION = vec3(-1.0, 1.0, 1.0);\n#define LIGHTING\n\n#define SHOW_AXES\n//#define SHOW_GROUNDPLANE\n//#define SHOW_DISTANCE_FIELD\n\n//#define SHOW_NORMALS\n#define SHOW_DEPTH\n#define Z_NEAR 5.0\n#define Z_FAR -5.0\n\n// Raymarching settings\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MIN_TRACE_DIST = 0.0;\nconst float MAX_TRACE_DIST = 50.0;\nconst float MIN_HIT_DIST = 0.001;\nconst int MAX_STEPS = 150;\n\n// Math constants\nconst float TWO_PI = 6.2832;\n\n// Interface settings\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 0.5;\n\n// Data fetching\nconst ivec2  VIEW_POSITION_ADDR = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int KEY_LEFT = 37;\n\n#define getViewPosition() texelFetch(iChannel0, VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection() texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define keyUpPressed() texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5\n#define keyDownPressed() texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5\n#define keyRightPressed() texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5\n#define keyLeftPressed() texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5\n\n// Helper functions\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),\n                vec3(s.x *  c.y, s.y, -c.x *  c.y));\n}\n\n/*\nLots and lots of stuff from Inigo Quilez's distance functions article:\nhttps://iquilezles.org/articles/distfunctions\n*/\n\n// SDFs (for more, I recommend Inigo Quilez's distance functions article: https://iquilezles.org/articles/distfunctions)\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x);\n    float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n    return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat sdLink(in vec3 p, in float le, in float r1, in float r2) {\n    vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n    return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat sdCone(in vec3 p, in vec2 c, in float h) {\n    // [Inigo Quilez]\n    // c is the sin/cos of the angle, h is height\n    // Alternatively pass q instead of (c,h),\n    // which is the point at the base in 2D\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n, in float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdTriPrism(in vec3 p, in vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdVerticalCapsule(in vec3 p, in float h, in float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSolidAngle(in vec3 p, in vec2 c, in float ra) {\n    // [Inigo Quilez]\n    // c is the sin/cos of the angle\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q, c), 0.0, ra));\n    return max(l, m * sign(c.y * q.x - c.x * q.y));\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n// Distance function operators:\nvec3 opElongate(in vec3 p, in vec3 h) {\n    return p - clamp(p, -h, h);\n}\n\nfloat opRound(in float d, in float r) {\n    return d - r;\n}\n\nfloat opLayer(in float d, in float thickness) {\n    return abs(d) - thickness;\n}\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nvec2 opRevolution(in vec3 p, in float o) {\n    return vec2(length(p.xz) - o, p.y);\n}\n\n// Boolean distance function operators\nfloat opUnion(in float a, in float b) {\n    return min(a, b);\n}\n\nfloat opSubtraction(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opIntersection(in float a, in float b) {\n    return max(a, b);\n}\n\n// Smooth distance operators:\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smax(in float a, in float b, in float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat opSmoothUnion(in float a, in float b, in float k) {\n    return smin(a, b, k);\n}\n\nfloat opSmoothSubtraction(in float a, in float b, in float k) {\n    return smax(a, -b, k);\n}\n\nfloat opSmoothIntersection(in float a, in float b, in float k) {\n    return smax(a, b, k);\n}\n\n// Transformations:\nvec3 opTransform(in vec3 p, in mat3 t) {\n    return inverse(t) * p;\n}\n\nfloat opDecompressScale(in float d, in vec3 s) {\n    return d * max(s.x, max(s.y, s.z));\n}\n\nfloat opSymmetry1D(in float x) {\n    return abs(x);\n}\n\nvec2 opSymmetry2D(in vec2 x) {\n    return abs(x);\n}\n\nvec3 opSymmetry3D(in vec3 x) {\n    return abs(x);\n}\n\nvec3 opRep(in vec3 p, in vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nvec3 opRepLim(in vec3 p, in float c, in vec3 l) {\n    return p - c * clamp(round(p / c), -l, l);\n}\n\n// Distance field distortions and displacements\nfloat opDisplace(in float d, in float disp) {\n    return d - disp;\n}\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(in vec3 p, in float b) {\n    float c = cos(b * p.x);\n    float s = sin(b * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 address = ivec2(fragCoord);\n    if (address == VIEW_POSITION_ADDR) {\n        fragColor = vec4(3.0, 3.0, 5.0, 1.0);\n    }\n\n    if (address == VIEW_DIRECTION_ADDR) {\n        fragColor = vec4(-0.5, -0.5, 0.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(getViewPosition(), 1.0);\n            mat3 camera = getCamera(getViewDirection());\n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = getViewDirection();\n            if (iMouse.z > 0.0) {\n                viewDirection = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            }\n\n            fragColor = vec4(viewDirection, 0.0, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}