{
    "Shader": {
        "info": {
            "date": "1652191872",
            "description": "Orbits of the Mandelbrot fractal (z = z^d + c)\nHold the mouse in the canvas to calculate the orbit of c corresponding to the mouse (White).",
            "flags": 0,
            "hasliked": 0,
            "id": "flSfWD",
            "likes": 1,
            "name": "Mandelbrot Set Orbits",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "orbit",
                "complex"
            ],
            "usePreview": 0,
            "username": "Fraktoler",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "#define MAX_ITER 256\n#define BAILOUT 16.\n#define THICKNESS 6.0e-7\nconst int orbitIters = 32;\nvec3 HSLtoRGB(vec3 hsl) {\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nfloat sdfSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return mag2(pa - t * ba);\n}\n\nvec2 pixelToComplex(float zoom, vec2 center, vec2 pixel) {\n    return zoom * (pixel - 0.5 * iResolution.xy) / iResolution.x + center;\n}\n\nvec2 f(vec2 z, vec2 c, float exponent) {\n    return power(z, exponent) + c; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.0;\n    vec2 center = vec2(0.0);\n    vec2 uv = pixelToComplex(zoom, center, fragCoord);\n    vec3 col;\n    float exponent = iTime * 0.02 + 2.0;\n    float r;\n    bool b = true;\n    int k = 0;\n    vec2 c = pixelToComplex(zoom, center, iMouse.xy);\n    vec2 z = c;\n    while (k < orbitIters) {\n        r = dot(z, z);\n        if (r > BAILOUT * 2.0) break;\n        vec2 oldz = z;\n        z = f(z, c, exponent);\n        k++;\n        if (sdfSegment(uv, z, oldz) < THICKNESS * zoom * zoom) {\n            col = vec3(1.0);\n            b = !b;\n            break;\n        }\n    }\n    if (b) {\n        c = uv, z = c;\n        k = 0;\n        while (k < MAX_ITER) {\n            r = dot(z, z);\n            if (r > BAILOUT) break;\n            z = f(z, c, exponent);\n            k++;\n        }\n        if (k == MAX_ITER) {\n            col = vec3(0.0);\n        } else {\n            float invln = 1.0 / log(exponent);\n            float lnlnb = log(log(BAILOUT));\n            float u = 5.0 * log(float(k) + invln*lnlnb - invln*log(0.5 * log(r))) - 5.0;\n            col = HSLtoRGB(vec3(mod(10.0 * u, 360.0), 1.0, (sin(u) + 1.2) * 0.4));\n        }\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nComplex functions\n\n mag(z) = |z|\n mag2(z) = |z|^2\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n swap(z) = z.yx\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n cube(z) = z^3\n power4(z) = z^4\n power5(z) = z^5\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n linearroot(a, b) = -b / a (Solution of a * z + b = 0)\n*/\nconst vec2 one = vec2(1., 0.);\nconst vec2 i = vec2(0., 1.);\nconst float pi = 3.14159265358979;\nconst float e = 2.718281828459045;\n\nfloat mag(vec2 z) {\n    return length(z);\n}\n\nfloat mag2(vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 swap(vec2 z) {\n    return z.yx;\n}\n\nvec2 rabs(vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(vec2 z, vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / mag2(w);\n}\n\nvec2 recip(vec2 z) {\n    return conj(z) / mag2(z);\n}\n\nvec2 sqr(vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 cube(vec2 z) {\n    vec2 z2 = z * z;\n    return z * vec2(z2.x - 3. * z2.y, 3. * z2.x - z2.y);\n}\n\nvec2 power4(vec2 z) {\n    return sqr(sqr(z));\n}\n\nvec2 power5(vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power(vec2 z, float p) {\n    return pow(mag2(z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(vec2 z, vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(mag2(z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 sqrtp(vec2 z) {\n    float r = mag(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 powexp(vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(vec2 z, vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(squ_exp - one, mulI(squ_exp + one));\n}\n\nvec2 tangent(vec2 z) {\n    if (z.y < -21.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(mulI(squ_exp + one), squ_exp - one);\n}\n\nvec2 cot(vec2 z) {\n    if (z.y < -21.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp - one, squ_exp + one);\n}\n\nvec2 tanhyp(vec2 z) {\n    if (z.x > 21.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp + one, squ_exp - one);\n}\n\nvec2 coth(vec2 z) {\n    if (z.x > 21.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(vec2 z) {\n    return 0.5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(vec2 z) {\n    return 0.5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(vec2 z, vec2 a, vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(vec2 z, vec2 a, vec2 b, vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 linearroot(vec2 a, vec2 b) {\n    return div(-b, a);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}