{
    "Shader": {
        "info": {
            "date": "1587152834",
            "description": "It was about time I created my very own raymarcher.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsByRd",
            "likes": 0,
            "name": "n4uj_raymarcher",
            "published": 3,
            "tags": [
                "ray",
                "sphere",
                "raymarcher",
                "march"
            ],
            "usePreview": 0,
            "username": "n4uj",
            "viewed": 317
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define ACCURACY 0.001\n#define MAX_DIST 100.0\n\n\nfloat GetDist(vec3 p)\n{\n\tvec4 s = vec4(0, 1, 6, 1); //(posx, posy, poz, radius)\n\tfloat sphereDist =  length(p - s.xyz) - s.w;\n\t\n\tfloat planeDist = p.y; //Plane formed by world x and world z\n\tfloat d = min(sphereDist, planeDist);\n\t\n\treturn d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p);\n\tvec2 e = vec2(.01, 0);\n\t\n\tvec3 n = d - vec3(\tGetDist(p-e.xyy),\n\t\t\t\t\t\tGetDist(p-e.yxy),\n\t\t\t\t\t\tGetDist(p-e.yyx)\n\t\t\t\t\t );\n\t\n\treturn normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat traveled = 0.;\n\n\tfor (int i=0; i<MAX_STEPS; i++)\n\t{\n\t\tvec3 p = ro + rd*traveled;\n\t\tfloat dist = GetDist(p);\n\t\ttraveled += dist;\n\t\tif(traveled > MAX_DIST || dist < ACCURACY) break;\n\t}\n\n\treturn traveled;\n}\n\nfloat GetLight(vec3 p)\n{\n\n\tvec3 lightDir = normalize(vec3 (sin(iTime), 1.0 , cos(iTime)));\n\tvec3 normal = GetNormal(p);\n\tfloat diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n\n\tfloat d = rayMarch(p + normal * ACCURACY * 2.0, lightDir);\t//If we didn't add normal * ACCURACY * 2.0, the whole plane will be in shade,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//since the rayMarch will return the min dist between dSphere and dPlane, that's why we offset it.\n\tif (d < length(lightDir)) diffuse *= .1;\n\n\treturn diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\t\n\tfloat fov = 1.0;\n\tvec3 ro = vec3(0.0, 1.0, 0.0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, fov));\n\n\tfloat d = rayMarch(ro, rd);\n\tvec3 p = ro + rd * d;\n\t\n\tvec3 col = vec3(uv.x, uv.y, 0.0);\n\tcol = vec3(p/10.0);\n\t// Output to screen\n\t//fragColor = vec4(col,1.0);\n\tfragColor = vec4(GetLight(p));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}