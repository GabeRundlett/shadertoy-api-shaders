{
    "Shader": {
        "info": {
            "date": "1631534996",
            "description": "Possibly the undesigned Mk.II version; flies about as well",
            "flags": 0,
            "hasliked": 0,
            "id": "fdy3DW",
            "likes": 23,
            "name": "Spruce Goose",
            "published": 3,
            "tags": [
                "airplane",
                "wake",
                "hughes",
                "seaplane"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 458
        },
        "renderpass": [
            {
                "code": "// \"Spruce Goose\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 17 in \"Aeroplane\" series\n    \"River Flight\"              (4sSXDG)\n    \"Spitfire Pursuit\"          (4dSSWV)\n    \"Alpine Jets\"               (Xll3Rr)\n    \"Canyon Roller\"             (4tlGDM)\n    \"Biplanes in the Badlands\"  (MlX3Rf)\n    \"Albert's Canyon\"           (4lXGRl)\n    \"Yellow Moth\"               (MtXGzs)\n    \"Shootout in Red Canyon\"    (XsVXWG)\n    \"Aerobatics\"                (XltGRM)\n    \"Pack Ice\"                  (ldScDt)\n    \"Red Canyon 2\"              (ldlBRM)\n    \"Cockpit View\"              (MsffWn)\n    \"Arctic Patrol\"             (lsBfzy)\n    \"River Flight 2\"            (4l3cz8)\n    \"Ekranoplan\"                (Wd3fDH)\n    \"Suborbital Flight\"         (stXSDs)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, flyPos, flyVel;\nfloat tCur, dstFar, flyRol, wkFac;\nint idObj;\nconst int idFus = 1, idCkp = 2, idEng = 3, idHul = 4, idWngM = 5, idWngT = 6, idTail = 7,\n   idFlt = 8, idLeg = 9, idAnt = 10;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wsp, wcr, s, w, t, dy;\n  dMin = dstFar;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  w = 1.;\n  dy = 0.;\n  if (q.z < -1.5) {\n    s = q.z + 1.5;\n    s *= s;\n    w *= 1. - 0.025 * s;\n    dy = 0.02 * s;\n  } else if (q.z > 3.5) {\n    s = q.z - 3.5;\n    s *= s;\n    w *= 1. - 0.04 * s;\n    dy = -0.02 * s;\n  }\n  d = PrCapsDf (q - vec3 (0., dy, 0.), w, 7.);\n  DMINQ (idFus);\n  q = p;\n  q.yz -= vec2 (0.4, 3.7);\n  d = PrCapsDf (q, 0.6, 1.5);\n  DMINQ (idCkp);\n  wsp = 5.;\n  wcr = 1.4;\n  q = p;\n  q.x = abs (q.x);\n  t = wcr * (1. - 0.25 * q.x / wsp);\n  q -= vec3 (wsp, 0.8, 1.);\n  s = (q.z - 0.3) / wcr;\n  d = min (wsp - q.x, abs (PrBox2Df (vec2 (abs (q.x - 0.45) - 2.15, q.z - 0.065 * q.x + 1.),\n     vec2 (2., 0.2))));\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idWngM);\n  wsp = 2.4;\n  wcr = 0.65;\n  q = p;\n  q.x = abs (q.x);\n  t = wcr * (1. - 0.25 * q.x / wsp);\n  q -= vec3 (0., 1.4, -6.2);\n  s = (q.z - 0.1) / wcr;\n  d = min (wsp - q.x, abs (PrBox2Df (vec2 (q.x - 1.4, q.z - 0.03 * q.x + 0.35),\n     vec2 (0.8, 0.15))));\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idWngT);\n  wsp = 1.3;\n  wcr = 1.;\n  q = p;\n  t = wcr * (1. - 0.25 * q.y / wsp);\n  q.yz -= vec2 (1.6, -6.3);\n  s = (q.z + 0.2 * q.y / wsp - 0.1) / wcr;\n  d = min (wsp - abs (q.y), abs (PrBox2Df (vec2 (q.y - 0.25, q.z + (0.2 / wsp - 0.19) * q.y + 0.57),\n     vec2 (0.75, 0.17))));\n  d = SmoothMax (PrCaps2Df (vec2 (q.x, q.z + 0.2 * q.y / wsp), 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 3.5) - 1.2);\n  q -= vec3 (0.6, 0.8, 2.1);\n  w = 0.2 * (1. - 0.5 * q.z * q.z);\n  d = min (max (PrCapsDf (q, w, 0.9), q.z - 0.5), PrCapsDf (q, 0.13, 0.55));\n  DMINQ (idEng);\n  q = p;\n  q.yz -= vec2 (-0.8, 4.);\n  w = 0.55;\n  t = 0.3;\n  s = q.z * q.z;\n  if (q.z > 0.) {\n    w *= 1. - 0.1 * s;\n    q.y -= 0.025 * s;\n    t -= 0.05 * s;\n  } else {\n    w *= 1. - 0.01 * s;\n  }\n  w *= 1. + q.y;\n  d = PrRoundBoxDf (q, vec3 (w, t, 5.5 + 0.1 * q.y), 0.1);\n  DMINQ (idHul);\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= vec2 (6.5, 1.1);\n  q.z = dot (vec2 (abs (q.z) - 0.3, q.y), sin (0.03 * pi * sign (q.z) + vec2 (0.5 * pi, 0.)));\n  d = max (PrCaps2Df (q.xz, 0.03, 0.12), abs (q.y) - 0.75);\n  DMINQ (idLeg);\n  q.yz -= vec2 (-0.83, 0.1);\n  d = max (PrCapsDf (q, 0.25, 0.5), q.y - 0.13);\n  DMINQ (idFlt);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 1.1, 3.);\n  d = PrCapsDf (q.xzy, 0.03, 0.15);\n  DMINQ (idAnt);\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 3.5) - 1.2);\n  q -= vec3 (0.6, 0.8, 2.65);\n  d = PrCylDf (q, 0.55, 0.02);\n  qHit = q;\n  return d;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, gCol4;\n  float s;\n  col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n  gCol4 = vec4 (0.9, 0.5, 0.2, 0.2);\n  if (idObj == idFus) {\n    col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (PrRoundBox2Df (vec2 (qHit.y - 0.2,\n       abs (qHit.z - 1.) - 2.5), vec2 (0.35, 0.12), 0.05)));\n    if (PrRoundBox2Df (vec2 (qHit.y - 0.3, mod (qHit.z + 0.5, 1.) - 0.5),\n       vec2 (0.15, 0.08), 0.05) < 0. && abs (qHit.z) < 4.5) col4 = vec4 (0., 0., 0., -2.);\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025, abs (abs (qHit.y + 0.4) - 0.04)));\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.5 && qHit.y < 0.53 && abs (abs (qHit.x) - 0.2) > 0.03 &&\n       abs (abs (qHit.z - 1.25) - 0.25) > 0.03) col4 = vec4 (0., 0., 0., -2.);\n  } else if (idObj == idWngM) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025,\n       abs (abs (length (vec2 (qHit.x - 2., qHit.z - 0.1)) - 0.4) - 0.1) - 0.02));\n    if (length (vec2 (abs (qHit.x - 5.), qHit.z - 0.8)) < 0.1) col4 = vec4 (0.8, 0., 0., -1.);\n  } else if (idObj == idTail) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025,\n       abs (abs (length (vec2 (qHit.y - 0.5, qHit.z - 0.05)) - 0.2) - 0.05) - 0.02));\n    if (length (vec2 (qHit.y - 1.3, qHit.z + 0.65)) < 0.12) col4 = vec4 (0.9, 0.9, 0.3, -1.);       \n  } else if (idObj == idEng) {\n     col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (qHit.z - 0.35) - 0.03);\n     col4 = mix (col4, gCol4, step (0.52, qHit.z));\n  } else if (idObj == idHul || idObj == idFlt) {\n    col4 *= 0.93 + 0.07 * sin (128. * sin (qHit.y));\n  } else if (idObj == idLeg) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025, abs (qHit.z) - 0.01));\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 q, t, tw, cs;\n  float wFreq, wAmp, h;\n  h = 0.;\n  if (d < 0.3 * dstFar) {\n    qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n    wFreq = 0.4;\n    wAmp = 0.1;\n    tw = 0.5 * tCur * vec2 (1., -1.);\n    q = p;\n    q += flyVel.xz * tCur;\n    for (int j = 0; j < 5; j ++) {\n      q *= qRot;\n      t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n      v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n      t = 1. - sqrt (v4.xz * v4.yw);\n      t *= t;\n      t *= t;\n      h += wAmp * (t.x + t.y);\n      wFreq *= 2.;\n      wAmp *= 0.5;\n    }\n    h += 0.3 * wkFac * (1. - smoothstep (0.3, 1.5, length (vec2 (abs (p.x) - 1.3, 0.1 * p.y + 1.1))));\n    h *= 1. - smoothstep (0.1, 0.3, d / dstFar);\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz, s)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  h = WaveHt (p.xz, d);\n  return vec4 (normalize (vec3 (h - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy, h);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.4, 1.) + 0.2 * pow (1. - rd.y, 5.),\n     vec3 (0.9), clamp (Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz +\n     0.5 * tCur)) * rd.y + 0.2, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vh4;\n  vec3 col, vn, rw, vnw, row, rdw, roo, rdo, watCol, c;\n  float dstObj, dstWat, f, sh, hw, wkFacF, nDotL;\n  bool waterRefl;\n  flyVel = vec3 (0., 0., 7.);\n  flyRol = 0.005 * pi * sin (0.1 * pi * tCur);\n  wkFac = 1. - smoothstep (0., 0.5, flyPos.y - 1.2);\n  wkFacF = 0.7 * (1. - smoothstep (0., 0.5, flyPos.y - 0.95));\n  roo = ro;\n  rdo = rd;\n  if (rd.y < 0.) {\n    dstWat = - ro.y / rd.y;\n    if (dstWat < 0.3 * dstFar) dstWat = WaveRay (ro, rd);\n  } else dstWat = dstFar;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    if (k == 0 || waterRefl) dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      waterRefl = (dstWat < min (dstFar, dstObj));\n      if (waterRefl) {\n        ro += dstWat * rd;\n        vh4 = WaveNf (ro, dstWat);\n        vnw = vh4.xyz;\n        hw = vh4.w;\n        row = ro;\n        rdw = rd;\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n      }\n    }\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol ();\n    if (col4.a >= 0.) {\n      sh = waterRefl ? 1. : ObjSShadow (ro + 0.01 * vn, sunDir);\n      nDotL = max (dot (vn, sunDir), 0.);\n      col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n         0.8 * sh * nDotL * nDotL) + col4.a * step (0.95, sh) * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.7 + 0.3 * max (- dot (rd, vn), 0.));\n    }\n    if (col4.a == -2. || col4.a >= 0.) {\n      rd = reflect (rd, vn);\n      c = SkyCol (ro, rd);\n      if (col4.a == -2.) col = 0.4 * (c * c + 0.5);\n      else if (rd.y > 0.) col = mix (col, c, 0.05);\n    }\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    f = (1. - smoothstep (0.1, 1.5, length (vec2 (0.3 * row.x, 0.06 * row.z + 1.)))) * wkFac;\n    f = max (f, (1. - smoothstep (0.1, 1., length (vec2 (0.8 * (abs (row.x) - 6.5),\n       0.1 * row.z + 0.5)))) * wkFacF);\n    rw = row + flyVel * tCur;\n    vnw = VaryNf (rw, vnw, (1. + 5. * f) * (1. - smoothstep (0.1, 0.4, dstWat / dstFar)));\n    watCol = mix (vec3 (0.1, 0.35, 0.4), vec3 (0.1, 0.3, 0.25),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * rw.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.8 * col, 0.2 + 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (1.), 0.5 * (1. - smoothstep (0., 0.1, f)) * pow (clamp (0.1 * hw +\n         Fbm2 (0.5 * rw.xz), 0., 1.), 8.));\n    col = mix (col, vec3 (1.) * (0.7 + 0.3 * Fbm2 (64. * rw.xz)), f);\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.6, 0.95, dstWat / dstFar));\n  }\n  if (TrObjRay (roo, rdo) < min (min (dstObj, dstWat), dstFar)) col = mix (col,\n     mix (vec3 (1., 0.6, 0.3), vec3 (1.), step (0.05, abs (length (qHit.xy) - 0.45))), 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  } else {\n    az -= 0.025 * pi * tCur;\n    el -= 0.05 * pi * sin (0.04 * pi * tCur);\n  }\n  el = clamp (el, 0.07 * pi, 0.3 * pi);\n  flyPos = vec3 (0., 1.2 + 4. * SmoothBump (0.25, 0.75, 0.15, mod (0.02 * tCur, 1.)), 0.);\n  ro = 35. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.).xzy;\n  vuMat = DirVuMat (normalize (flyPos - ro));\n  zmFac = 5.5;\n  dstFar = 250.;\n  sunDir = normalize (vec3 (1., 1.5, 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}