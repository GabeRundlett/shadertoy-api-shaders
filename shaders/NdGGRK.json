{
    "Shader": {
        "info": {
            "date": "1631802342",
            "description": "A test to see the behavior of cross ()",
            "flags": 0,
            "hasliked": 0,
            "id": "NdGGRK",
            "likes": 13,
            "name": "Cross function piston",
            "published": 3,
            "tags": [
                "cross"
            ],
            "usePreview": 0,
            "username": "gaz",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "const float maxd=80.0;\n\nvec3 rot(inout vec3 p,vec3 axis,float theta){\n\taxis=normalize(axis);\n\treturn mix(axis*dot(p,axis),p,cos(theta))+sin(theta)*cross(p,axis);\n}\n\n\nvec2 polarAbs(vec2 p,float n)\n{\n  n*=0.5;\n  float a = asin(sin(atan(p.x,p.y)*n))/n;\n  return vec2(sin(a),cos(a))*length(p);\n}\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\n\n#define hash(p)fract(sin(p*12345.5))\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+2315.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++){\n        p+=randVec(n+=365.)*sin((t*=1.3)+sin(t*.6)*.5);\n    }\n    return p;\n}\n\nvec3 targetVector0()\n{\n    return randVec(32892.+floor(iTime/2.));\n}\n\nvec3 axisVector()\n{\n    vec3 a = targetVector0();\n    vec3 b = a.yzx;\n    for(int i=0;i<100;i++)\n    {\n        if (all(equal(a, b))==false) break;\n        b.z += 0.1;\n        b = normalize(b);\n    }\n    vec3 w = a;\n    vec3 u = normalize(cross(b,w));\n    vec3 v = cross(w,u);\n    return v;\n}\n\nvec3 targetVectorA()\n{\n    vec3 v = targetVector0();\n    vec3 a = axisVector();\n    float t = -iTime;\n    return rot(v,a,t);    \n}\n\nvec3 targetVectorB()\n{\n    vec3 v = targetVector0();\n    vec3 a = axisVector();\n    float t = iTime;\n    return rot(v,a,t);\n}\n\n\nfloat deA(vec3 p)\n{\n    float de =1.;\n    vec3 target = targetVectorA();\n    vec3 axis = axisVector();\n    vec3 w = normalize(target);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    //p = inverse(mat3(u,v,w)) * p;\n    p = p * mat3(u,v,w);\n    vec3 q=p;\n    p.x -= clamp(p.x, -0.1, 0.1);\n    p.y -= clamp(p.y, -0.02, 0.02);\n    p.z -= clamp(p.z, 0.1, 1.0);\n    de = min(de,length(p)-.01);\n    q.xz=polarAbs(q.xz,24.);\n    q.z-=1.12;\n    return min(de,(lpNorm(q,5.0)-.091+q.z*.3)*.8);\n}\n\nfloat deB(vec3 p)\n{\n    float de=1.;\n    vec3 target = targetVectorB();\n    vec3 axis = axisVector();\n    vec3 w = normalize(target);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    p = vec3(dot(p,u), dot(p,v), dot(p,w));\n    de=min(de,lpNorm(vec2(length(p.yz)-.95,p.x),5.0)-.07);\n    de=min(de,lpNorm(vec2(length(p.xz)-1.,p.y),5.0)-.1);\n    de=min(de,lpNorm(vec2(length(p.xz)-.15,p.y),5.0)-.07);\n    p.x -= clamp(p.x, -0.1, 0.1);\n    p.y -= clamp(p.y, -0.02, 0.02);\n    p.z -= clamp(p.z, 0.1, 1.0);\n    de=min(de, length(p)-.01);\n    return de;\n}\n\nfloat deC(vec3 p)\n{\n    vec3 targetA = normalize(targetVectorA());\n    vec3 targetB = normalize(targetVectorB());\n    // cross() test\n    vec3 cx = cross(targetA, targetB);\n    vec3 axis = targetA;\n    vec3 w = normalize(cx);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    p = transpose(mat3(u,v,w)) * p;\n    //p = p * mat3(u,v,w);       \n    float len = length(cx); \n    p.z -= clamp(p.z, 0.0, len);\n    return lpNorm(p,3.)-.1;\n}\n\nfloat map(vec3 p)\n{\n    float de = 1.;\n    de = min(de, deA(p));\n    de = min(de, deB(p));\n    de = min(de, deC(p));\n    de = min(de, p.y + 1.2);\n    return de;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n    if(deC(p)<0.001) return vec3(1.8,0.5,0.2);\n    return vec3(0.3,0.5,0.8)+cos(p*0.5)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(1.5);\n    vec3 ta = randCurve(iTime*.3,1234.6)*.4;\n    vec3 rd = normalize(vec3(uv,2.0));\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 v = cross(u,w);\n    rd = mat3(u,v,w) * rd;\n    vec3 col= vec3(0.05,0.05,0.1);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n    \tvec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,5,1);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n    \tfloat sha = min(1.,calcShadow( lightPos, -li, len )+.8);\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.5;\n    \tcol *= max(0.5+0.5*n.y, 0.0);\n    \tcol *= exp2(-1.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n    \tcol += vec3(0.8,0.6,0.2)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 10.0);\n    \tcol = mix(vec3(0.1,0.1,0.2),col, exp(-0.03*t*t));\n    }\n    fragColor.xyz = col;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}