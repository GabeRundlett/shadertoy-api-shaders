{
    "Shader": {
        "info": {
            "date": "1701966396",
            "description": "Performance Test to see how one can sample different amount of textures for different pixels.",
            "flags": 0,
            "hasliked": 0,
            "id": "ctGBDR",
            "likes": 1,
            "name": "PerfTest GPU Branching",
            "published": 3,
            "tags": [
                "test",
                "texture",
                "performance",
                "sample",
                "speed"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 268
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to check methods for variable sample count \nbetween pixels. I find the results below a bit surprising, I would have\nexpected \"if\" to be worse than 3 samples since I read that both sides \nare executed, but apparently not. Branch prediction may be the reason.\nFeel free to correct mistakes or add notes. \n\nAlso, don't be hasty comparing the non-branching tests to branching \nones, as the distribution of samples changes the performance will \nchange a lot so it may or may not work for your application, so testing\nis adviced.\n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n*/\n\n// Number of repeats of the test, 5000 should be enough for RTX3080\n#define REPEAT 1\n    \n// switch between the test cases\n//  0 = sample 1 texture                             ~ 112 fps\n//  1 = sample 2 textures                            ~  56 fps\n//  2 = sample 3 textures                            ~  39 fps\n//  3 = sample 1-3 textures using if (broken mips)   ~  51 fps\n//  4 = sample 1-3 textures using if with chess mask ~   8 fps\n//  5 = sample 1-3 textures using for (broken mips)  ~  47 fps\n//  6 = sample 1 textureGrad                         ~  56 fps\n//  7 = sample 3 textureGrad                         ~  20 fps\n//  8 = sample 1-3 textureGrad using if              ~  26 fps\n//  9 = sample 1 texture using LOD 0                 ~ 106 fps\n// 10 = first sample 3 texture, then use 1-3 tex     ~  38 fps\n// 11 = 3, but quantizing 2x2                        ~  51 fps\n// 12 = 3, but fwidth||branch 2x2 (?broken mips?)    ~  49 fps\n// 13 = sample 1-3 textures with switch (broken mips)~  51 fps\n#define TEST 13\n\n// Debug view visualing the mip level. Disable for Testing!\n//#define SHOWMIPLEVEL\n\n// 1. / sqrt(2. * pi) ratio between a square and a cirle area\n// See: https://www.desmos.com/calculator/l7nqvcpajk\n#define INFSQRTHLFPI 0.398942280401\n\n// samples a Texture with some debug features\nvec3 sampleTex(sampler2D sam, vec2 uv) {\n    #ifdef SHOWMIPLEVEL\n        return visualizeMips(sam, uv);      \n        \n    #else\n        return texture(sam, uv).xyz;\n    #endif\n}\n\n// samples a Texture with some debug features\nvec3 sampleTex(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    #ifdef SHOWMIPLEVEL\n        return visualizeMips(sam, uv, duvdx, duvdy);\n        \n    #else\n        return textureGrad(sam, uv, duvdx, duvdy).xyz;\n    #endif\n}\n\n// samples a Texture with some debug features\nvec3 sampleTex(sampler2D sam, vec2 uv, float mipLevel) {\n    #ifdef SHOWMIPLEVEL\n        return visualizeMips(sam, uv, mipLevel);\n        \n    #else\n        return textureLod(sam, uv, mipLevel).xyz;\n    #endif\n}\n\n// sample 1 texture\nvec3 singleTex(vec2 uv) {\n    return sampleTex(iChannel0, uv);\n}\n\n// sample two textures\nvec3 doubleTex(vec2 uv) {\n    // sample two textures with different uvss\n    vec3 a = sampleTex(iChannel0, uv);\n    vec3 b = sampleTex(iChannel0, uv.yx);\n    \n    // 50/50 lerp between them\n    return mix(a,b,0.5);\n}\n\n// sample three textures\nvec3 tripleTex(vec2 uv) {\n    // sample three textures with different uv rotations\n    vec3 a = sampleTex(iChannel0, uv);\n    vec3 b = sampleTex(iChannel0, uv.yx);\n    vec3 c = sampleTex(iChannel0, -uv);\n\n    // 1/3 lerp between them\n    float weight = 1./3.;\n    return a * weight + b * weight + c * weight;\n}\n\n// switch 50/50 between 1 and 3 samples using if\nvec3 ifTex(vec2 uv) {\n    if (length(uv) < INFSQRTHLFPI * 5.) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));//uv);\n        \n    } else {    \n        return tripleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using if and chess pattern\nvec3 ifChessTex(vec2 uv, vec2 fragCoord) {\n    // amplify the pixels for debugging\n    //fragCoord = floor(fragCoord /16.); \n\n    // chess mask\n    float chess = mod(fragCoord.x+fragCoord.y,2.);\n    \n    if (chess < 0.5) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));\n        \n    } else {    \n        return tripleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using for\nvec3 forTex(vec2 uv) {\n    // alternate between 1 and 3 repeats\n    int n =  length(uv) < INFSQRTHLFPI * 5. ? 1 : 3;\n    \n    // weight for interpolation\n    float weight = 1./float(n); \n\n    // repeat this n times\n    vec3 result;\n    for (int i=0; i<n ; i++) { \n        // sample texture\n        vec3 color = sampleTex(iChannel0, uv);\n        \n        // interpolate the result\n        result += color * weight;\n        \n        // mutate the uvs\n        uv = vec2(uv.y, -uv.x);\n    }    \n    return result;\n}\n\n// sample 1 texture with partial derivatives mips\nvec3 singleTexGrad(vec2 uv) {\n    // Mip caculation for testing\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );\n\n    return sampleTex(iChannel0, uv, duvdx, duvdy);\n}\n\n// sample three textures with partial derivatives mips\nvec3 tripleTexGrad(vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n\n    // sample three textures with different uv rotations\n    vec3 a = sampleTex(iChannel0, uv, duvdx, duvdy);\n    vec3 b = sampleTex(iChannel0, uv.yx, duvdx, duvdy);\n    vec3 c = sampleTex(iChannel0, -uv, duvdx, duvdy);\n\n    // 1/3 lerp between them\n    float weight = 1./3.;\n    return a * weight + b * weight + c * weight;\n}\n\n// switch 50/50 between 1 and 2 samples using if with partial derivatives mips\nvec3 ifTexGrad(vec2 uv) {\n    // Mip caculation for testing\n    vec2 duvdx = dFdx( uv );\n    vec2 duvdy = dFdy( uv );    \n\n    if (length(uv) < INFSQRTHLFPI * 5.) {\n        // rotating this texture to make even harder\n        return sampleTex(iChannel0, vec2(uv.y, -uv.x), duvdx, duvdy);        \n    } else {    \n        // sample three textures with different uv rotations\n        vec3 a = sampleTex(iChannel0, uv, duvdx, duvdy);\n        vec3 b = sampleTex(iChannel0, uv.yx, duvdx, duvdy);\n        vec3 c = sampleTex(iChannel0, -uv, duvdx, duvdy);\n\n        // 1/3 lerp between them\n        float weight = 1./3.;\n        return a * weight + b * weight + c * weight;\n    }\n}\n\n// sample 1 texture with Texture LOD\nvec3 singleTexLOD(vec2 uv) {\n    vec2 miplevel = getMipLevel(iChannel0, uv);\n    return sampleTex(iChannel0, uv, miplevel.x);\n}\n\n// First sample three textures but only use one or three\nvec3 retroactiveTex(vec2 uv) {\n    // sample three textures with different uv rotations\n    vec3 a = sampleTex(iChannel0, uv);\n    vec3 b = sampleTex(iChannel0, uv.yx);\n    vec3 c = sampleTex(iChannel0, -uv);\n    \n    if (length(uv) < INFSQRTHLFPI * 5.) {\n        // use only one texture\n        return a;\n        \n    } else {\n        // 1/3 lerp between the three\n        float weight = 1./3.;\n        return a * weight + b * weight + c * weight;\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using if in 2x2 segemnts\nvec3 ifTex2x2(vec2 uv, vec2 fragCoord) {    \n    // Round UV coordinates to the nearest 2x2 segment\n    fragCoord = floor(fragCoord / 2.) * 2.;\n    vec2 roundedUV = fragCoord / iResolution.xy - 0.5;\n        \n    if (length(roundedUV) < 1. * INFSQRTHLFPI) {\n        // rotating this texture to make even harder\n        return singleTex(vec2(uv.y, -uv.x));//uv);\n        \n    } else {    \n        return tripleTex(uv);\n    }\n}\n\n// switch 50/50 between 1 and 3 samples using fwidth to check neighbor branches\nvec3 ifTex2x2Width(vec2 uv, vec2 fragCoord) {\n    // Arbitary condition for branching\n    bool condition = length(uv) < INFSQRTHLFPI * 5.;\n    \n    // Check difference of neighbors with fwidth\n    float fWidthTest = fwidth(float(condition));\n    \n    vec3 color;\n    // Branching but border cases become 1 samples\n    if (fWidthTest > 0.5 || condition) { \n        // rotating this texture to make even harder\n        color = singleTex(vec2(uv.y, -uv.x));//uv);\n        \n    } else {\n        color = tripleTex(uv);\n    }\n        \n    return color;\n}\n\n// use switch case to switch between 1 and 3 samples\nvec3 switchTex(vec2 uv) {\n    vec3 color;    \n    switch(int(length(uv) < INFSQRTHLFPI * 5.)) {\n    \n        case 0: // Equivalent to 'else' in your original function\n            color = tripleTex(uv);\n            break;\n            \n        case 1: // Equivalent to 'if' in your original function\n            color = singleTex(vec2(uv.y, -uv.x));\n            break;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    // The mip level breaking is not visible at lower scales\n    uv *= 5.;\n\n    // if you get around 144 fps use a higher repeat value\n    vec3 test;\n    for(int i=0; i<REPEAT; i++) {\n    \n        // unique permutation each iteration\n        float mut = (float(i)/float(REPEAT)); \n          \n        // use which ever you wish to test\n        #if TEST == 0\n            test += singleTex(uv + mut);\n        #elif TEST == 1\n            test += doubleTex(uv + mut);\n        #elif TEST == 2\n            test += tripleTex(uv + mut);\n        #elif TEST == 3\n            test += ifTex(uv + mut);\n        #elif TEST == 4\n            test += ifChessTex(uv + mut, fragCoord);            \n        #elif TEST == 5\n            test += forTex(uv + mut);         \n        #elif TEST == 6\n            test += singleTexGrad(uv + mut);\n        #elif TEST == 7\n            test += tripleTexGrad(uv + mut);            \n        #elif TEST == 8       \n            test += ifTexGrad(uv + mut);\n        #elif TEST == 9\n            test += singleTexLOD(uv + mut);  \n        #elif TEST == 10   \n            test += retroactiveTex(uv + mut);\n        #elif TEST == 11\n            test += ifTex2x2(uv + mut, fragCoord);\n        #elif TEST == 11\n            test += ifTex2x2Width(uv + mut, fragCoord);\n        #else \n            test += switchTex(uv + mut);\n        #endif   \n    }\n    \n    #if REPEAT > 1\n        // Ensure test vector stays in visible range\n        test = fract(test);\n    #endif\n\n    // Output to screen\n    fragColor = vec4(test, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Generic Function ________________________________________________________________\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    const vec3 c0 = vec3(0.503560,-0.002932,1.000009);\n    const vec3 c1 = vec3(-1.294985,3.144463,0.001872);\n    const vec3 c2 = vec3(-16.971202,0.031355,-1.232219);\n    const vec3 c3 = vec3(97.134102,-5.180126,-0.029721);\n    const vec3 c4 = vec3(-172.585487,-0.338714,0.316782);\n    const vec3 c5 = vec3(131.971426,3.514534,-0.061568);\n    const vec3 c6 = vec3(-37.784412,-1.171512,0.003376);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        -direction.x, direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// Mip Functions __________________________________________________________________\n\n// Function to calculate the highest mip level based on texture size\nfloat getHighestMipLevel (vec2 texSize) {\n    // Find the maximum dimension of the texture\n    float maxDimension = max(texSize.x, texSize.y);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension);\n\n    // Return the highest mip level\n    return highestMipLevel;\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\n// Based on Unreal Engines ComputeMipLevel Material Function \nvec2 getMipLevel(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = duvdx * texSize;\n    vec2 scaledDDY = duvdy * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Calculate the highest possible mip level for the texture\n    float maxMipLevel = getHighestMipLevel(texSize);\n\n    // Clamp the mip level between 0 and the maximum mip level\n    mipLevel = clamp(mipLevel, 0.0, maxMipLevel);\n\n    // Return both the mip level and the maximum mip level\n    return vec2(mipLevel, maxMipLevel);\n}\n\n// Function to calculate the mip level and the maximum mip level for a texture\nvec2 getMipLevel(sampler2D sam, vec2 uv) {\n    // Mip calculation for testing\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    // Caculate Mip level\n    return getMipLevel(sam, uv, duvdx, duvdy);\n}\n\n// Visualizes Mip level based on UV coordinates and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv);\n\n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}\n\n// Visualizes Mip level based on UV coordinates, texture size, and DDX/DDY\nvec3 visualizeMips(sampler2D sam, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    // Caculate Mip level\n    vec2 mipLevel = getMipLevel(sam, uv, duvdx, duvdy);\n    \n    // colorize Mip level with colormap\n    return rainbow(mipLevel.x / mipLevel.y);\n}\n\n// Visualizes Mip level based on miplevel and texture size\nvec3 visualizeMips(sampler2D sam, vec2 uv, float mipLevel) {\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));\n    \n    // colorize Mip level with colormap\n    return rainbow(mipLevel / getHighestMipLevel(texSize));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}