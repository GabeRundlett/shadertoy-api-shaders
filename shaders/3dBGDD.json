{
    "Shader": {
        "info": {
            "date": "1548825924",
            "description": "Terrain based on 3sSGzW.\n\nCurl noise on a sphere should make it easy to get the clouds to interact with the terrain. The normal method for doing this didn't work, so I hacked together my own way. It would be great if someone pointed out a better algo.",
            "flags": 32,
            "hasliked": 0,
            "id": "3dBGDD",
            "likes": 10,
            "name": "Earthlike Planetoid",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "terrain",
                "raymarch",
                "clouds",
                "fbm",
                "curl",
                "planet"
            ],
            "usePreview": 0,
            "username": "Ebanflo",
            "viewed": 850
        },
        "renderpass": [
            {
                "code": "// Earthlike Planetoid by Eben Kadile aka Ebanflo - 2019\n// ebencowley.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Special thanks to rodolphito, Dave_Hoskins, nikat, and knarkowciz\n//Respective licenses, as well as all the macros, are in the common tab\n\nvec2 iSphere(vec3 ro, vec3 rd, float r){\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2(-b - h, 2.0*h);\n}\n\nfloat sdPlanet(vec3 p){\n    return length(p) - planetRad + texture(iChannel1, octEncode(p)).r;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e = vec2(normalEps, 0);\n    return normalize(vec3(sdPlanet(p + e.xyy),\n                          sdPlanet(p + e.yxy),\n                          sdPlanet(p + e.yyx))\n                     - sdPlanet(p));\n}\n\nvec4 marchPlanet(vec3 ro, vec3 rd, float far){\n\n    vec3 p = ro;\n    float d = 0.0;\n    bool hit = false;\n\n    for(int i = 0; i < steps; i++){\n\n        float sd = sdPlanet(p);\n        if(sd < close){\n            hit = true;\n            break;\n        }\n\n        sd *= 0.5;\n        p += sd*rd;\n        d += sd;\n\n        if(d > far) break;\n    }\n\n    if(hit) return vec4(p, d);\n    else return vec4(p, -1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 m = 2.0*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 0, -camDist);\n    vec3 rd = normalize(vec3(xy, 2));\n\n    ro = r(ro, m);\n    rd = r(rd, m);\n\n    vec3 light = normalize(ro);\n    \n    vec2 is = iSphere(ro, rd, maxHeight);\n    \n    if(is.x > 0.0){\n        vec4 pd = marchPlanet(ro + is.x*rd, rd, is.y);\n\n        if(pd.w > 0.0){\n            vec3 n = calcNormal(pd.xyz);  \n\n            float polar = abs(pd.y);\n            float alt = length(pd.xyz);\n\n            if(alt < waterlevel){\n                float shine = dot(pd.xyz, light);\n                shine *= shine*shine;\n                shine = clamp(shine, 0.1, 1.0);\n                if(polar > arctic) fragColor.rgb = vec3(0.9*shine);\n                else fragColor.rgb = shine*watercolor;\n            }\n            else {         \n                float lambert = max(0.2, dot(n, light));\n                fragColor.rgb = lambert*landcolor;\n\n\n                lambert -= 0.2;\n                lambert *= 1.25;\n                float ap = 1.0 - arctic + polar;\n                fragColor.rgb +=\n                    vec3(1, 0.6, 1)*lambert*max(0.0, 8.0*(alt - snowlevel) + ap*ap);\n            }\n\n            if(alt < atmoslevel){\n                vec2 atmos = iSphere(ro, rd, atmoslevel);\n                fragColor.rgb += texture(iChannel0, ro + atmos.x*rd).rgb;\n            }\n        }\n        else fragColor = vec4(0, 0, 0, 1);\n    }\n    else fragColor = vec4(0, 0, 0, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//PARAMS//////////////////////////////////////////////////////////////////////\n\n//planet\n#define landcolor vec3(0.2, 0.6, 0.1)\n#define watercolor vec3(0.2, 0.3, 0.9)\n#define atmoslevel 1.24\n#define waterlevel 1.2\n#define snowlevel 1.28\n#define arctic 1.1\n#define planetRad 1.2\n#define noiseRad 1.2\n#define maxHeight 1.5\n#define noiseAmp 0.08\n\n//marching\n#define camDist 3.0\n#define close 0.01\n#define steps 60\n#define normalEps 0.01\n\n//clouds\n#define cloudcolor vec3(0.7, 0.7, 0.8)\n#define cloudBrightness 48.0\n\n#define noiseScale1 15.0\n#define noiseScale2 12.0\n#define noiseScale3 10.0\n#define noiseScale4 8.0\n\n#define pointScale1 1.0\n#define pointScale2 2.0\n#define pointScale3 4.0\n#define pointScale4 6.0\n\n#define cloudSpeed 0.6\n\n#define angularVelocity 0.02\n\n#define curlEps 0.001\n\n#define contrast 0.0001\n\n//Quincuncial mapping///////////////////////////////////////////////////////////\nvec3 octDecode(vec2 p){\n    vec3 n = vec3(p.x, p.y, 1.0 - abs(p.x) - abs(p.y));\n    float t = max(0.0, -n.z);\n    n.x += n.x >= 0.0 ? -t : t;\n    n.y += n.y >= 0.0 ? -t : t;\n    return normalize(n);\n}\n\nvec2 octWrap(vec2 v){return (1.0 - abs(v.yx))*sign(v);}\n \nvec2 octEncode(vec3 n){\n    n /= abs(n.x) + abs(n.y) + abs(n.z);\n    n.xy = n.z >= 0.0 ? n.xy : octWrap(n.xy);\n    n.xy = 0.5*n.xy + 0.5;\n    return n.xy;\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\nvec4 hash43(vec3 p){\n\tvec4 p4 = fract(vec4(p.xyzx)*HASHSCALE4);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw)*p4.zywx);\n}\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3*HASHSCALE4.x);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n//rodolphito and nikat's code///////////////////////////////////////////////////\n\nvec3 r(vec3 v, vec2 r){\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\n/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright Â© 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n//exponentially distributed random function\nvec3 random3(vec3 p3){\n    vec4 v = hash43(p3);\n    return 0.5*normalize(v.xyz - .5)*log(1.0-v.w);\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n//Exponentially distributed simplex noise\n//Based on nikat's simplex noise\nfloat expSimplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\n\t vec4 w, d;\n\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\n\t w = max(0.6 - w, 0.0);\n\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\n\t return dot(d, vec4(52.0));\n}\n\nfloat expFbm(vec3 m, int octaves){\n    float l = 2.0;\n    float il = 1.0/l;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float result = 0.0f;\n    for (int i = 0; i < octaves; i++)\n    {\n    \tresult += expSimplex3d(m*frequency)*amplitude;\n        frequency *= l;\n        amplitude *= il;\n    }\n    return result;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//This buffer stores the noise for the terrain\n//Unfortunately, didn't provide much of a speedup on my machine\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    fragColor = vec4(0);\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(iFrame < 12) fragColor.r = noiseAmp*expFbm(noiseRad*octDecode(2.0*uv - 1.0), 6);\n    else discard;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//For storing and updating the clouds\n\nfloat valNoise(vec3 p){\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix(hash13(i + vec3(0, 0, 0)),\n                       hash13(i + vec3(1, 0, 0)), u.x),\n                   mix(hash13(i + vec3(0, 1, 0)), \n                       hash13(i + vec3(1, 1, 0)), u.x), u.y),\n               mix(mix(hash13(i + vec3(0, 0, 1)),\n                       hash13(i + vec3(1, 0, 1)), u.x),\n                   mix(hash13(i + vec3(0, 1, 1)), \n                       hash13(i + vec3(1, 1, 1)), u.x), u.y), u.z);\n}\n\nfloat initClouds(vec3 p){\n    return max(0.0, cloudBrightness*texture(iChannel1, octEncode(p)).r);\n}\n\nfloat fractalNoise(vec3 p){\n\n    p += vec3(0, 0.05*iTime, 0);\n\n    float result = noiseScale1*valNoise(pointScale1*p);\n    result += noiseScale2*valNoise(pointScale2*p);\n    result += noiseScale3*valNoise(pointScale3*p);\n    result += noiseScale4*valNoise(pointScale4*p);\n\n    return cloudSpeed*result;\n}\n\nfloat sdLand(vec3 p){return atmoslevel - planetRad + texture(iChannel1, octEncode(p)).r;}\n\n//the potential of the vector field in an ordinary curl-noise setting (not in use)\nfloat potential(vec3 p){return smoothstep(0.0, 0.001, sdLand(p))*fractalNoise(p);}\n\n//vector perpendicular to the spherical gradient of the heightmap\nvec3 perpGrad(vec3 p, vec3 t, vec3 bt, float sd){\n    vec3 dx = (sdLand(p + curlEps*t) - sd)*bt;\n    vec3 dy = (sdLand(p + curlEps*bt) - sd)*t;\n    return dx - dy;\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n\n    if(iFrame < 8) fragColor.rgb = cloudcolor*smoothstep(0.5, 1.0, initClouds(rayDir));\n    else {\n        vec3 tangent = normalize(vec3(rayDir.z, 0, -rayDir.x));\n        vec3 bitangent = cross(tangent, rayDir);\n\n        //potential is simply fractal noise\n        float pot = fractalNoise(rayDir);\n\n        float dx = fractalNoise(rayDir + curlEps*tangent) - pot;\n        float dy = fractalNoise(rayDir + curlEps*bitangent) - pot;\n        vec3 curl = dy*tangent - dx*bitangent;\n\n        float sd = sdLand(rayDir);\n\n        //the vector which deflects it off the land is tangent to the \"shoreline\"\n        vec3 deflect = perpGrad(rayDir, tangent, bitangent, sd);\n\n        //interpolate between curl noise vector field and vector field that pushes it away\n        vec3 delta = mix(8.0*deflect, curl + angularVelocity*tangent, sd);\n\n        //an attempt to keep them from dissipating quickly\n        //by pushing the away from the poles\n        delta.y += sign(rayDir.y)*angularVelocity*angularVelocity\n                  /(planetRad*planetRad - rayDir.y*rayDir.y);\n\n        fragColor = texture(iChannel0, rayDir + delta);\n\n        fragColor -= contrast;\n        fragColor *= 1.0 + 2.0*contrast;\n        fragColor = max(vec4(0), fragColor);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}