{
    "Shader": {
        "info": {
            "date": "1620927942",
            "description": "A fun project designing a 5th element / cyberpunk ish city. I really enjoyed doing it, I went through a lot of non working things, doubts... but the final thing is really cool, I learned the lot in the process, and I hope you'll like it !",
            "flags": 96,
            "hasliked": 0,
            "id": "sss3Wj",
            "likes": 101,
            "name": "Cyberpunk city",
            "published": 3,
            "tags": [
                "city",
                "cyberpunk",
                "2077",
                "5thelement"
            ],
            "usePreview": 0,
            "username": "z0rg",
            "viewed": 8922
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 50;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 5.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\nvec3 chromaFlare(vec2 uv, vec2 ouv, float sz, float id)\n{\n    vec3 col = vec3(0.);// = texture(iChannel0, uv).xyz;\n    \n    float c = abs(length(ouv)-.3-id*sz*8.-sz*9.)-sz;\n    vec3 rgb;\n    float a = atan(ouv.y, ouv.x)*1.;\n    float cnt = 16.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n           \n        rgb += vec3(1.)*\n        (sat((sin(a*400.)+sin(a*200.)+sin(a*100.))*.2+.5)*.5+.5)*\n        texture(iChannel0, vec2(.5)+((uv-vec2(.5))*(i+1.)*0.01*r2d((i-cnt/2.)*.025)*-1.*sat(length(ouv*2.)))).x;\n    }\n    col += pow((1.-sat(c*5.))*pow(rgb/cnt, vec3(1.)), vec3(1.));\n    \n    return col*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 424./640.;  \n    vec3 bloomSample = doBloom(uv, 40./360., 237./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n\n    col += chromaFlare(uv, cuv, 0.01, 0.)*vec3(1.,0.,0.);\n    col += chromaFlare(uv, cuv, 0.01, -1.)*vec3(0.,1.,0.);\n    col += chromaFlare(uv, cuv, 0.01, -2.)*vec3(0.,0.,1.);\n\n    col = mix(col, col.zyx, pow(sat(length(cuv*2.)),4.));\n\n    col = pow(col, vec3(1.95));\n\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define UPSIDEDOWN // Comment to see not only the dow side\n\n#define FFT(f) (texture(iChannel1, vec2(f, 0.)).x)\n\n\nfloat _speed = 20.;\nfloat _time;\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nfloat _cars(vec3 op, vec3 s)\n{\n    op.z+=_time*20.;\n    float carStp = 10.5;\n    vec3 pcar = op;\n    float idxCar = floor((pcar.z+.5*carStp)/carStp);\n    pcar.z = mod(pcar.z+.5*carStp, carStp)-.5*carStp;\n    pcar.x += sin(idxCar);\n#ifndef UPSIDEDOWN\n    pcar.y += 90.;\n#endif\n    pcar.y += sin(idxCar*5.+_time);\n    return _cube(pcar, s*(sin(idxCar)*.5+.5));\n}\n\nvec2 map(vec3 p)\n{\n\n    p.z += _time*_speed;\n    vec3 op = p;\n    \n#ifdef UPSIDEDOWN\n    p.y = abs(p.y)-100.;\n#endif\n    vec2 acc = vec2(100., -1.);\n    vec2 ground = vec2(_cube(p, vec3(50., .1, 50.)), 0.);\n    vec3 pBat = p;\n    vec2 repBat = vec2(10.);\n    vec2 idxBat = floor((pBat.xz+repBat*.5)/ repBat); \n    pBat.xz = mod(pBat.xz+repBat*.5, repBat)-repBat*.5;\n    float height = mix(1., 8., (sin(idxBat.x+idxBat.y*10.)*.5+.5));\n    height += (texture(iChannel0, idxBat*.1).x-.5)*5.;\n    float width = texture(iChannel0, idxBat/10.).x*.75;\n    pBat.xz += sin(idxBat*10.)*.5;\n    vec2 bat = vec2(_cube(pBat, vec3(5.5*width,height*8.,3.7)), 0.);\n    \n    acc = _min(acc, ground);\n    acc = _min(acc, bat);\n    acc = _min(acc, vec2(_cars(op-vec3(0.,10.,0.), vec3(.5,.5,1.5)), 1.));\n    acc = _min(acc, vec2(_cars(op-vec3(50.,10.,0.), vec3(.5,.5,1.5)), 1.));\n    \n    float repz = 50.;\n    float idxz = op.z / repz;\n    op.z = mod(op.z+.5*repz, repz)-repz*.5;\n    op.xz *= r2d(1.57);\n    op.y += sin(idxz)*25.;\n    acc = _min(acc, vec2(_cars(op, vec3(.5,.5,2.5)), 1.));\n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, float dist, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && ((dist > 0.0 && distance(ro, p) < dist) || dist < 0.0); ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return vec3(res.x, distance(ro, p), res.y);\n        }\n        // We allow march step to be false if far enough from origin\n        p += rd * min(res.x,.5+(distance(ro, p)/120.));\n    }\n    return vec3(-1.);\n}\n\nfloat traceShadow(vec3 ro, vec3 rd, float dist, int steps)\n{\n    float rad = 1.5;\n    vec3 p = ro;\n    float acc = 1.;//rad;//rad*50.;\n    for (int i = 0; i < steps && distance(p, ro) < dist; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return 0.;\n        }\n        float d =min(res.x,1.5);\n        acc = min(acc, 30.*d/distance(p, ro));\n        p += rd * d;\n         // check this https://www.shadertoy.com/view/3tVBRV\n        //acc += sat(d/rad*dist*.005);\n    }\n    return acc;\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    float fov = 4.;\n    return normalize(rd+(uv.x*r+uv.y*u)*fov);\n}\n\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.04, 0.);\n    //return -normalize(cross(dFdx(p), dFdy(p)));\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n#ifdef UPSIDEDOWN\n    vec3 ro = vec3(sin(_time*.3)*15.,15.+sin(_time*.15)*15.,-75.)*.75;\n    vec3 ta = vec3(0.,-10.,0.)*.5;\n#else\n    vec3 ro = vec3(sin(_time*.3)*15.,-105.+sin(_time*.15)*15.,-75.)*.75;\n    vec3 ta = vec3(0.,-110.,0.)*.5;\n#endif\n\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    vec3 res = trace(ro, rd, -1., 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNormal(res.x, p);\n        \n        \n        col = n*.5+.5;\n        float rad = 50.;\n        float tsun = iMouse.x/100.;//_time*.25;\n        float lDist = 550.;\n        //vec3 lpos = vec3(cos(tsun)*lDist, lDist,sin(tsun)*lDist);\n        vec3 shadowO = p+n*0.01;\n        vec3 ldir = vec3(1.,-2.,5.)*lDist;//lpos-shadowO;\n        vec3 lCol = vec3(1.,0.,0.);\n        \n        \n        float shadowRes = traceShadow(shadowO, normalize(ldir), lDist, int(650.*(1.-sat((length(p.xz)-150.)*.01))));\n        vec3 ambientCol = vec3(0.569,0.675,0.714);\n        vec3 diffuseCol = vec3(0.678,0.878,0.902);\n        col = ambientCol; // Ambient col\n        \n        col *= sat(pow(sat(shadowRes),.5)+.15);\n        if (shadowRes > 0.01)\n        {\n            \n            vec3 h = normalize(ldir+rd);\n            // diffuse\n            col += 500.*sat(dot(n, normalize(ldir)))*diffuseCol/lDist;\n            float specPower = mix(1.,.01, sat(sin(p.y*2.)*50.));\n            // spec\n            col += (.025/specPower)*100.*vec3(1.000,0.584,0.000)*pow(sat(abs(dot(n, h))),specPower)/lDist;\n        }\n\n        col += mix(vec3(0.), mix(vec3(1.000,0.000,0.400), vec3(1.), sat(abs(length(p.xz)*.0025))), 1.-sat(exp(-distance(p, ro)/500.)));\n        p.z += _time*_speed;\n\n\n       col += float(dot(n, vec3(0.,-1.,0.)) < 0.1)*vec3(0.851,0.690,0.506)*pow(texture(iChannel2, p*.02).x,20.)*2.;\n       col += .3*vec3(0.729,0.565,0.212)*(sat(p.y*.1+5.))*pow(texture(iChannel2, vec3(1.,4.,1.)*p*.02+vec3(.5*_time*sign(sin(p.z*5.)), 0., 0.)).x,20.);\n\n    }\n    else\n        col = sat(mix(mix(vec3(.75), vec3(1.000,0.000,0.400)*.75, .1),texture(iChannel3, vec2(-rd.x, rd.y)*vec2(2.,-8.)-vec2(0.,.7)).xyz,(sat((rd.y-.175)*40.))*.5*sat(length(uv*2.))));//*sat(-rd.y*2.+1.);\n\n    col += (1.-sat(lenny(rd.xy*vec2(1.,4.)*.5)))*vec3(1.000,0.000,0.400)*.5*float(res.y<0.);\n    col += 3.*pow(1.-sat(lenny(rd.xy*.15*vec2(1.,8.))),5.)*vec3(1.000,0.000,0.400)*.5;//*float(res.y<0.);\n    col *= mix(.75,1.5,pow(sat(FFT(0.5)),2.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This helps a bit decreasing aliasing by doing a no sampling motion blur\n    _time =  iTime + texture(iChannel0, fragCoord/8.).x*.25;\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    vec3 col = rdr(uv);\n\n    \n    col = pow(col, vec3(.85));\n    col *= (1.-sat(lenny(uv*2.)-.5));\n    \n    col = mix(col, texture(iChannel3, fragCoord/iResolution.xy).xyz, sat(.9)*sat(length(uv*2.)));\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 26933,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/aasish-rajendran/tron-legacy-soundtrack-12-end-of-line-daft-punk"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n\nfloat lenny(vec2 v) { return abs(v.x)+abs(v.y); }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}