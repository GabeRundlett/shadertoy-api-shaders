{
    "Shader": {
        "info": {
            "date": "1557695586",
            "description": "Shadow ray marching algorithm additionally searches for \\/ and \\__ patterns and calculates minimal distance at this points.\nMay be used for shadow anti-aliasing and fake soft shadows.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lsGWj",
            "likes": 8,
            "name": "Soft shadow example",
            "published": 3,
            "tags": [
                "example",
                "simple",
                "basic",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "_A_",
            "viewed": 646
        },
        "renderpass": [
            {
                "code": "// forked from https://www.shadertoy.com/view/Wtf3Wj\n\n#define MAX_STEPS 200\n#define MAX_DIST 250.\n#define SURF_DIST .01\n\n\nfloat sphereDist(vec3 p) {\n    float sphere = length(p) - 1.;\n\treturn sphere;\n}\n\n\n//get the distance to the closest\n//point on the closest object\nfloat sceneDist(vec3 p) {\n\tfloat planeDist = p.y;\n    vec3 spherePos = vec3(0,1,8);\n    float sphereRadius = 1.;\n    \n    float objDist = sphereDist(p-spherePos);\n    \n    float dist = min(planeDist, objDist);\n    \n    return dist;\n}\n\n\nfloat rayMarch(vec3 rayOrig, vec3 rayDir) {\n\tfloat dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = rayOrig + dist * rayDir;\n\t\tfloat sceneDist = sceneDist(p);\n        \n        dist += sceneDist;\n       \n        if (dist > MAX_DIST || sceneDist < SURF_DIST) {\n        \tbreak;\n        }\n\t}\n    \n    return dist;\n}\n\n\n//get the normal of a point in 3d space,\n//only valid if the point is on the surface\n//of an object\nvec3 getNormal(vec3 p) {\n\tfloat d = sceneDist(p);\n    \n    //just a helper variable\n    vec2 e = vec2(.01, 0);\n    \n    //shift the point by a small\n    //amount along each axis\n    vec3 n = d - vec3(\n        sceneDist(p - e.xyy),\n        sceneDist(p - e.yxy),\n        sceneDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\n//get the strength of the light\n//at a 3d point\nfloat getLight(vec3 p) {\n\tvec3 lightPos = vec3(-2, 5, 8);\n    \n    //move the light in a circle\n    lightPos.xz += vec2(cos(iTime), sin(iTime)) * 10.;\n    \n \tvec3 normal = getNormal(p);\n    vec3 toLight = normalize(lightPos - p);\n    \n    float angle = dot(normal, toLight);\n    angle = clamp(angle, 0., 1.);\n    \n    vec3 rayOrig = p+normal*.02;\n    vec3 rayDir = toLight;\n    float dist = 0.;\n    float maxDist = length(p-lightPos)+0.1;\n    \n    // contains last 3 distances\n\tvec3 history = vec3(0.);\n    \n    const float maxDistToObject = 0.3;\n    \n    // minimal distance to object for penumbra calculation\n\tfloat md = 1.0e+10;\n    \n    //add shadows\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = rayOrig + dist * rayDir;\n        \n        history.yz = history.xy;\n\t\thistory.x = sceneDist(p);\n        dist += history.x;\n     \n        // detect V pattern\n        if (history.y < maxDistToObject && history.x >= history.y && history.z > history.y)\n            md = min(md, history.y);\n        \n        if (dist < 0.0 || dist > maxDist) {\n        \tbreak;\n        }\n        \n        if (history.x < SURF_DIST) {\n            md = 0.0;\n            break;\n        }\n\t}\n    \n    angle = angle * smoothstep(0.0, maxDistToObject, md);\n    return angle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    //ray origin is the camera position\n    vec3 rayOrig = vec3(0, 5, -12);\n    vec3 rayDir = vec3(uv.x, uv.y, 1.0);\n    \n    float dist = rayMarch(rayOrig, rayDir);\n    \n    //get the point that the ray hit\n    //to use for lighting\n    vec3 rayHitPos = rayOrig + rayDir * dist;\n    float diff = getLight(rayHitPos);\n    \n    //grayscale colour based on lighting value\n    vec3 col = vec3(diff);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}