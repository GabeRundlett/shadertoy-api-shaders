{
    "Shader": {
        "info": {
            "date": "1573871696",
            "description": "fiddling with primitives and fake global illumination/AO. the title is a topology joke :3\n\ntwitch recording: https://www.twitch.tv/videos/508931099",
            "flags": 0,
            "hasliked": 0,
            "id": "wsGXDh",
            "likes": 18,
            "name": "Twitch: Two Spheres and a Torus",
            "published": 3,
            "tags": [
                "liveshader"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 836
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p , vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x);int y = FK(p.y);\n  return float((x*x+y)*(y*y-x)-x)/2.147e9;\n}\n\nvec2 linedist(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  float s = sign(dot(vec2(-pa.y,pa.x),b-a));\n  float d = distance(p, mix(a,b,clamp(k,0.,1.)));\n  return vec2(d,s);\n}\n\nfloat triangle(vec2 p, vec2 dim) {\n  vec2 a = vec2(0,dim.y);\n  vec2 b = vec2(dim.x,-dim.y);\n  vec2 ldx = min(linedist(p, a, b), linedist(p, b, vec2(-b.x,b.y)));\n  return -ldx.x*ldx.y;\n}\n\nfloat torus(vec3 p, vec2 di) {\n  vec2 crd = vec2(length(p.xy), p.z);\n  return length(crd-vec2(di.x,0)) - di.y;\n}\n\nfloat cylinder(vec3 p, vec2 di) {\n  vec2 crd = vec2(length(p.xy), p.z);\n  crd.y = abs(crd.y)-di.y;\n  crd.x -= di.x;\n  \n  float sg = sign(crd.x)+sign(crd.y);\n  return sg == 2. ? length(crd) : max(crd.x,crd.y);\n}\n\nfloat cone(vec3 p, vec2 di) {\n  vec2 crd = vec2(length(p.xy), p.z);\n  return triangle(crd, di);\n}\n\nfloat scene(vec3 p) {\n  vec3 tor = p;\n  tor = erot(tor, vec3(0,0,1), iTime);\n  tor = erot(tor, vec3(0,1,0), 0.6);\n  \n  vec3 cyl = p - vec3(0,-1,0);\n  cyl = erot(cyl, vec3(0,1,0), iTime);\n  \n  vec3 con = p - vec3(0,1,0);\n  con = erot(con, vec3(0,1,0), -iTime);\n  \n  float best = cylinder(cyl, vec2(0.3, 0.8))-0.01;\n  best = min(best, torus(tor, vec2(0.8,0.2)));\n  best = min(best, cone(con, vec2(0.5,0.7)))-0.01;\n  return min(best, p.z+0.9);\n}\n\nbool flor(vec3 cam, vec3 init, inout vec3 inter) {\n  vec3 flooror = vec3(0,0,-0.9);\n  vec3 floornor = vec3(0,0,1);\n  float d = dot(cam, vec3(0,0,1));\n  if (d > 0.) return false;\n  \n  float t = dot(flooror-init, floornor)/d;\n  inter = t*cam+init;\n  return true;\n}\n\nmat3 eps = mat3(0.001);\n#define AP(f,k) vec3(f(k[0]),f(k[1]),f(k[2]))\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-eps;\n  return normalize(scene(p) - AP(scene, k));\n}\n\nvec3 shade(float d) {\n  float str = cos(d*200.+3.1415)*0.2+0.8 * pow((exp(0.)-exp(-abs(d))), 0.3);\n  return d > 0. ? vec3(1,0.5,0)*str : vec3(0,0.5,1)*str;\n}\n\nfloat skycol(vec3 angl) {\n  return sqrt(max(angl.z,0.))*0.5+0.5;\n}\n\nfloat skyshade(vec3 norm) {\n  float d = pow(norm.z+0.3,2.)*pow(norm.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n  return sqrt(sqrt(d))*0.8+0.2;\n}\n\nfloat ao(vec3 p, vec3 n, float sc) {\n  float d1 = 0.001;\n  float d2 = scene(p+n*sc);\n  return sqrt(((d2-d1)/sc)*0.5+0.5);\n}\n\nfloat comp(float p) {\n  //return p;\n  return pow(abs(p),5.)*sign(p);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(1.4, uv));\n  vec3 init = vec3(-4.,0.,0.);\n  bool hit = false;\n  vec3 p = init;\n  for (int i = 0; i < 150; i++) {\n    float dist = scene(p);\n    if ( abs(dist) < 0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) break;\n    p+=cam*dist;\n  }\n  vec3 inter;\n  if (flor(cam, init, inter)) {\n    if (distance(inter, init) < distance(init, p) || !hit) {hit=true; p = inter;}\n  }\n  float noise = comp(hash(uv*iTime));\n  if (!hit) {\n    fragColor.xyz = vec3(skycol(cam)) + noise*0.05;\n    return;\n  }\n  vec3 n = norm(p);\n  float fog = exp(-distance(init,p)*0.03)/exp(0.)*0.4+0.6;\n  float aoo = pow(ao(p, n, 0.1)*ao(p, n, 0.2)*ao(p, n, 0.33)*ao(p, n, 0.66)*ao(p, n, 1.),1./5.);\n  fragColor.xyz = vec3(skyshade(n)*0.8*aoo)*fog;\n  fragColor.xyz += noise*0.05;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}