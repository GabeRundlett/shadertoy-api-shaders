{
    "Shader": {
        "info": {
            "date": "1685620213",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "DtcXRX",
            "likes": 24,
            "name": "4 Splines ",
            "published": 3,
            "tags": [
                "bezier",
                "spline",
                "curve",
                "cubic",
                "catmullrom",
                "hermite",
                "bspline"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 392
        },
        "renderpass": [
            {
                "code": "// Coefficients from Freya Holmer's video https://www.youtube.com/watch?v=jvPPXbo87ds\n\n// orange\n#define BEZIER 0\n// green\n#define HERMITE 1\n// purple\n#define CATMULL_ROM 2\n// blue\n#define B_SPLINE 3\n\nvec2[] pts = vec2[](\n    vec2(0.1,0.2),\n    vec2(0.5,0.1),\n    vec2(0.2,-0.3),\n    vec2(-0.2,0.2),\n    vec2(-0.4,0.2),\n    vec2(-0.5,0.4),\n    vec2(-0.6,-0.2),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4),\n    vec2(-0.2,-0.3),\n    vec2(-0.8,-0.3),\n    vec2(-0.3,-0.4)\n);\n\nvec2 get_pt(int i){\n    return pts[(i+pts.length())%pts.length()];\n}\n\n// Characteristic matrices\nconst float[] bezier = float[16](\n    1.,  0.,  0.,  0.,\n    -3., 3.,  0.,  0.,\n    3., -6.,  3.,  0.,\n    -1., 3., -3.,  1.\n);\nconst float[] hermite = float[16](\n    1.,  0.,  0.,  0.,\n    0.,  1.,  0.,  0.,\n    -3.,-2.,  3., -1.,\n    2.,  1., -2.,  1.\n);\n\nconst float[] b_spline = float[16](\n    1.,  4.,  1.,  0.,\n    -3., 0.,  3.,  0.,\n    3., -6.,  3.,  0.,\n    -1., 3., -3.,  1.\n);\n\nfloat sdLine(vec2 uv, vec2 a, vec2 b){\n    vec2 ab = b - a;\n    vec2 p = a + ab*clamp(dot(uv-a, ab)/dot(ab,ab),0.,1.);\n    return length(uv-p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.95);\n    \n    // Draw background\n    vec2 uvb = mod(uv, 0.1) - 0.05;\n    float sd_bg = 1000.;\n    sd_bg = min(sd_bg,abs(uvb.x));\n    sd_bg = min(sd_bg,abs(uvb.y));\n    col = mix(col,vec3(0.6),smoothstep(fwidth(uv.y),0.,sd_bg));\n    \n    \n    // Offset points\n    for(float i = 0.; i < float(pts.length()); i++){\n        pts[int(i)] += vec2(sin(i+iTime*cos(i)),cos(i+iTime*sin(i)))*0.1;\n    }\n    \n    // Modify points so bezier is C1 continuous\n    for(int i = 4; i < pts.length(); i+=3){\n        pts[i] = pts[i-1] - normalize(pts[i-2] - pts[i-1])*0.1;\n    }\n    pts[pts.length()-1] = pts[0] - normalize(pts[1] - pts[0])*0.2;\n    \n    \n    float its = 44.;\n    float sd_lines = 1000.;\n    \n    for(int spline = 0; spline < 4; spline++){\n        int inc = 3;\n        if (spline == BEZIER){\n            inc = 3;\n        } else if (spline == HERMITE){\n            inc = 2;\n        } else if (spline == CATMULL_ROM || spline == B_SPLINE){\n            inc = 1;\n        }\n        \n        for(int pid = 0; pid < pts.length() + min(iFrame,0); pid+=inc){\n            vec2 P0;\n            vec2 P1;\n            vec2 P2;\n            vec2 P3;\n            if (spline == BEZIER || spline == B_SPLINE){\n                P0 = get_pt(pid  );\n                P1 = get_pt(pid+1);\n                P2 = get_pt(pid+2);\n                P3 = get_pt(pid+3);\n            } else if (spline == HERMITE) {\n                P0 = get_pt(pid  );\n                P1 = get_pt(pid+1) - P0;\n                P2 = get_pt(pid+2);\n                P3 = get_pt(pid+3) - P2;\n            } else if (spline == CATMULL_ROM) {\n                P0 = get_pt(pid  );\n                P1 = get_pt(pid+1) - get_pt(pid-1);\n                P2 = get_pt(pid+1);\n                P3 = get_pt(pid+2) - P0;\n                const float visc = 0.5;\n                P1 *= visc;\n                P3 *= visc;\n            }\n            \n            if(spline == 0){\n                sd_lines = min(sd_lines,sdLine(uv,P0,P1));\n                sd_lines = min(sd_lines,sdLine(uv,P1,P2));\n                sd_lines = min(sd_lines,sdLine(uv,P2,P3));\n            }\n            \n            float[16] m;\n            if(spline == 0)\n                m = bezier;\n            else if(spline == 1)\n                m = hermite;\n            else if(spline == 2)\n                m = hermite;\n            else \n                m = b_spline;\n            \n            float sd_curve = 1000.;\n            vec2 prev_p;\n            for(float t = 0. ; t <= 1. + 0.01/its; t+=1./its){\n                vec2 p =   (P0*m[0]  + P1*m[1]  + P2*m[2]  + P3*m[3] ) +\n                    t*     (P0*m[4]  + P1*m[5]  + P2*m[6]  + P3*m[7] ) +\n                    t*t*   (P0*m[8]  + P1*m[9]  + P2*m[10] + P3*m[11]) +\n                    t*t*t* (P0*m[12] + P1*m[13] + P2*m[14] + P3*m[15]);\n                    \n                if(spline == B_SPLINE)\n                    p /= 6.; // this can be added to the coefficients lolz\n                \n                if(t < 0.01/its)\n                    prev_p = p;\n                    \n                sd_curve = min(sd_curve,sdLine(uv,prev_p,p) - 0.002);   \n                prev_p = p;\n            }\n            vec3 curve_col = vec3(0);\n            \n            if (spline == BEZIER)\n                curve_col = vec3(1,0.2,0);\n            else if(spline == HERMITE)\n                curve_col = vec3(0.1,0.5,0.);\n            else if(spline == CATMULL_ROM)\n                curve_col = vec3(0.2,0.,1);\n            else if(spline == B_SPLINE)\n                curve_col = vec3(0.1,0.5,0.9);\n            col = mix(col,curve_col,smoothstep(fwidth(uv.y),0.,sd_curve));\n        }\n    }\n    \n    \n    float sd_points = 1000.;\n    for(int p = 0; p < pts.length(); p++){\n        sd_points = min(sd_points,length(uv - pts[p]) - 0.01);\n    }\n    sd_points = min(sd_points,sd_lines);\n    col = mix(col,vec3(0.0),smoothstep(fwidth(uv.y),0.,sd_points));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}