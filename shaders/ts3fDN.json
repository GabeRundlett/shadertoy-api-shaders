{
    "Shader": {
        "info": {
            "date": "1605958281",
            "description": "scale sequencer version 3\nnew features:\n★added chord sequence\n★non-diatonic chord\n★auto inversion\n★a song can use up to 4 scales\n★new:vec2 getNoteByChord(t,l)\n★new:float getChord(n)",
            "flags": 40,
            "hasliked": 0,
            "id": "ts3fDN",
            "likes": 15,
            "name": "[♪]Scale Sequencer 3",
            "published": 3,
            "tags": [
                "music"
            ],
            "usePreview": 0,
            "username": "Catzpaw",
            "viewed": 485
        },
        "renderpass": [
            {
                "code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n//Image:animation\n\n//SNIPPETS\n#define ZERO min(iFrame,0)\nconst float pi=acos(-1.);\nconst float ip=1./pi;\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//BUFFER\nvec4 tx0(int x){return texture(iChannel0,vec2((float(x)+.5)/iResolution.x,.5/iResolution.y));}\n\n//FONT SDF\n//5x6 dot matrix font\nconst int[64] font=int[](\n0x00000000,0x08e71004,0x14a00000,0x15f52bea,0x19ca10e7,0x26b21359,0x1823462e,0x08400000,\n0x10421088,0x04421082,0x01157d51,0x00427c84,0x00000082,0x00007c00,0x00000002,0x20821041,\n0x1d19e62e,0x0862108e,0x1d18383f,0x1d16422e,0x18a4a7e8,0x1e17c22e,0x1c17c62e,0x3f041084,\n0x1d17462e,0x1d18fa0e,0x00400080,0x00400082,0x00820888,0x000f83e0,0x00222082,0x1d141004,\n0x1d9ad722,0x1d18fe31,0x1f17c62f,0x1d10862e,0x1f18c62f,0x3e17843f,0x3e10bc21,0x1d10e63e,\n0x231fc631,0x1c42108e,0x2108422e,0x2293a631,0x0210843f,0x23bac631,0x233ad731,0x1d18c62e,\n0x1f18bc21,0x1d18c536,0x1f18be31,0x1d13222e,0x3e421084,0x2318c62e,0x2318c544,0x2318d771,\n0x22a22a31,0x23151084,0x3f06083f,0x1842108c,0x02221110,0x0c421086,0x08a88000,0x0000001f);\nfloat get1bit(int pos,int data){int b=(data>>(pos&31))&1;b=pos<0?0:b;b=pos>31?0:b;return b>0?1.:0.;}\nfloat sdPixel(vec2 p){p=abs(p)-.45;return length(max(p,0.))+min(max(p.x,p.y),0.);}\nfloat sdLetter(vec2 p,int char){vec2 q=floor(p);if(q.x<0.||q.x>4.||q.y<-0.||q.y>5.)return 2.;\n      p=fract(p)-.5;p.x+=step(get1bit(int(q.x+q.y*5.),font[char]),.5);return sdPixel(p);}\n\n//TEXTAREA SDF\n//      HELL YEAH!      I AM SCALE SEQUENCER 3 (44chars)\nconst int[9] text=int[](0x00000000,0x2cb25a00,0x28865e40,0x00000001,0x21029000,0x218f302d,0x25cc096c,0x23ba5d71,0x004c0ca5);\nconst int textChars=44;\nint   textChar(int pos){if(pos<0||pos>=textChars)return 0;return int((text[pos/5]>>(pos%5)*6)&63);}\nfloat sdTextArea(vec2 p,vec2 r,float pos,float num){\n    p.x*=6./5.;p+=r*.5;\n    if(p.x<0.||p.x>r.x||p.y<0.||p.y>r.y)return 2.;\n    vec2 q=floor(p);p=fract(p);\n    int char=textChar(int((r.y-q.y-1.)*r.x+mod(q.x,r.x)));\n    return sdLetter(p*vec2(6.,7.),char);\n}\n\n//TEXTURE\nvec2 tr(vec2 p){\n    p=fract(p*ip)*pi-pi*.5;\n    for(int i=ZERO;i<4;i++)p=abs(p)/dot(p,p)-vec2(sin(iTime*.13),sin(iTime*.27))*.05-.8;\n    return p;\n}\nvec3 tx(vec2 p){\n\tp.y+=iTime;\n\tfloat h=(floor(p.x)+iTime)*.05;\n\tfloat v=fract(floor(abs(sin(p.x*3.)*sin(p.y*17.))*6.)*.7);\n\treturn hsv(h,.3,v*.7+.3);\n}\n\n//MAIN\nfloat[6] wavfreq=float[](3.,8.,4.,5.,50.,31.);\n#define SSAA_BEGIN float spp=.5/iResolution.x;vec3 fcol=vec3(0);for(int ssx=0;ssx<2;ssx++)for(int ssy=0;ssy<2;ssy++){uv.x+=ssx>0?spp:0.;uv.y+=ssy>0?spp:0.;vec3 col=vec3(0);\n#define SSAA_END   fcol+=col;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord*2.-iResolution.xy)/iResolution.x;        \n    SSAA_BEGIN //==================================================\n\n\t//tunnel\n    float l=length(uv),a=atan(uv.x,uv.y),t=fract(iTime*.1)*pi*2.;\n    vec2 p=vec2(l,a+.5/length(uv)+t);\n    col=tx(tr(p))-l*l*.3;\n\n    //wave\n    float vol=tx0(0).r;\n    vec2 wav=vec2(0);\n    for(int i=ZERO;i<6;i++){\n        vec4 g=tx0(i+1);\n        vec2 v=g.xy*.6;\n        float x=float(i+1);\n        wav+=sin(x+(uv.x*wavfreq[i])+iTime*41.)*v*.2;\n        col-=smoothstep(.05,.04,abs(uv.x-x*.1))*smoothstep(.01,.00,abs(uv.y)-v.x)*.3*vol;\n        col-=smoothstep(.05,.04,abs(-uv.x-x*.1))*smoothstep(.01,.00,abs(uv.y)-v.y)*.3*vol;\n    }\n    col-=smoothstep(.02,.01,abs(uv.y-wav.x))*.5*vol;\n    col-=smoothstep(.02,.01,abs(uv.y-wav.y))*.5*vol;\n    col=clamp(col,0.,1.);\n\n    //text\n    float d=sdTextArea(uv*float(textChars/2)*.51,vec2(textChars/2,2),0.,float(textChars));\n    col+=d<=0.?vec3(1):vec3(0);\n    col=clamp(col,0.,1.);\n\n    SSAA_END //====================================================\n    fragColor = vec4(fcol*.25,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n// See \"Common\" tab\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n//Common:scale sequencer 3\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =120.;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst float gateSeed=885.; //random seed for gate generator;\nconst float noteSeed=278.; //random seed for note generator;\n\n//SCALE\nint key=0; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\n//const uint[4] scl=uint[](0xcb975420u,0xcb975420u,0xcb975420u,0xcb975420u); //major,major,major,major\nconst uint[4] scl=uint[](0xcb975420u,0xca875320u,0xcb875320u,0xcb975320u); //major,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xca875320u,0xca875320u,0xcb875320u,0xcb975320u); //minor,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xc9974420u,0xca775530u,0xca775530u,0xca775530u); //pentatonic(major,minor)\n//const uint[4] scl=uint[](0xcb775540u,0xcb755420u,0xcb755420u,0xcb755420u); //ryukyu(pentatonic,hexatonic)\n//const uint[4] scl=uint[](0xba875410u,0xba875410u,0xba875410u,0xba875410u); //maqam hijaz octatonic\n//const uint[4] scl=uint[](0xba876320u,0xba876320u,0xba876320u,0xba876320u); //gypsy minor octatonic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\n//div1(2),scale2(2),div2(2),scale3(2),chord1(8),chord2(8),chord3(8)\n//chord:\n//  00-07:I,I,II,III,IV,V,VI,VII\n//  +00:triad\n//  +10:-3\t  +18:+3\n//\t+20:-5\t  +28:+5\n//\t+30:-3-5  +38:+3+5\n//\t+40:add9\n//\t+80:diatonic6(m6 or 6)\n//\t+c0:diatonic7(7 or M7)\n//  Example...symbol:C7 = key:C,scale:minor,chord:Im7+3 = 0x01+0x18+0xc0 = 0xd9\nconst int chordlen=16;const uint chordseq[chordlen]=uint[](\n\t0x01000041u,0x01000001u,0x010000c1u,0x01000081u,\n\t0x01000041u,0x01000001u,0x010000c1u,0x01000081u,\n\t0x01000046u,0x01000004u,0x010000c5u,0x01000081u,\n\t0x01000044u,0x01000005u,0x020000c2u,0x03000085u\n);\n\n//PATTERN (version 3)\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\n// You can set up to 256 patterns.\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x08008001u,0x070af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x36605713u,0x46746589u,0x56183614u,0x360e1510u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973175u,0x36390710u,  //08-0B melody\n    0x460e121cu,0x00000000u,0x00000000u,0x00000000u,  //0C-0F melody\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,  //10-13 \n    0x70333444u,0x00000000u,0x63111232u,0x00000000u,  //14-17 accompaniment,bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//PATTERN SEQUENCE (version 3)\n// speed1(2),speed2(2),division(4),top1(4),pattern1(8),top2(4),pattern2(8)\n// speed    0:1x 1:2x 2:0.25x 3:0.5x\n// top      0-e ... auto inversion amount (0:no inversion 7:octave)\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2 8:half)\n// The length of each sequence is unlimited.\nconst int len1= 8;const uint[len1] seq1=uint[]( //snare+hihat\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,\n    0x00000018u,0x00000018u,0x00000019u,0x0000001bu);\nconst int len2=16;const uint[len2] seq2=uint[]( //bassdrum+conga\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0e01e01fu,\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0801e01fu,\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0801e01fu,\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0000001fu);\nconst int len3= 1;const uint[len3] seq3=uint[]( //bass\n    0x00000616u);\nconst int len4=16;const uint[len4] seq4=uint[]( //chord\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u);\nconst int len5= 2;const uint[len5] seq5=uint[]( //accompaniment\n    0xa0000814u,0xe8814814u);\nconst int len6=16;const uint[len6] seq6=uint[]( //melody\n    0x00000004u,0x00000005u,0x00000006u,0x00000007u,\n    0x00000004u,0x00000005u,0x00000006u,0x0000000cu,\n    0x00000008u,0x00000009u,0x0000000au,0x0000000bu,\n    0x00000008u,0x00000009u,0x0000000au,0x0000000bu);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//FOLDBACK DISTORTION (input,threshould,ratio)\n//float fbdist(float v,float t,float f){return abs(v)>t?sign(v)+(t-v)*f:v;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\nfloat osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\n//vec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\n//vec2 c30piano(float f,float x){return vec2(osc_c30(f*(1.-detune),3),osc_c30(f*(1.+detune),3))*max(env_d(x,.05),env_d(x,2.5)*.6);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6))*env_d(x,.5);}\n\n//CHIPTUNE PERCUSSION (time)\nfloat nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(7./(x*.4+.1),.25)*env_d(x,.03);}\nfloat neshc(float x){return osc_duty(9./(x*.4+.1),.25)*env_d(x,.03);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\n//float lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);ch=st<d?ch:get8(p,0);sc=st<d?sc:get2(p,12);scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateSeed)*50.)<(float(get4(pt,6))*.0625)?-99:\n        imod(int(abs(sin(float(s+s1+s*s2)*noteSeed)*float(s2))),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n// track(t,l,s)\n//   t...time\n//   l...measure length (steps/bpm)\n//   s...step now playing\n//\n//   getPattern(t,patternSequence)...get pattern data now playing\n//   getGate(t,l)...get noteTime and noteNum from percussive pattern\n//   getNote(t,l)...get noteTime and noteNum from melodic pattern\n//   getNoteByChord(t,l)...noteNum will restricted by chord\n//   getChord(n)...get chord noteNum 0:root 2:3rd 4:5th 6:7th\n//\n// render(t,l,inout o,e)\n//   o...audio output\n//   e...false:render is called by delay effect\n//\n//   scaleChord(t,l,chordSequence)...set scale & chord for following tracks\n//\n//--------------------------------------------------------------------------------\n//TRACK 1 NES noise snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nessd(n.x)*.6:0.;\n    o+=(n.y==2.)?neshh(n.x,.08)*.3:0.;\n    o+=(n.y==3.)?neshh(n.x,.2)*.4:0.;\n    return o;\n}\n//TRACK 2 NES sqr bassdrum,lowconga,highconga\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*.4:0.;\n    o+=(n.y==2.)?neslc(n.x)*.3:0.;\n    o+=(n.y==3.)?neshc(n.x)*.3:0.;\n    return o;\n}\n//TRACK 3 NES sqr bass and LPF saw\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?dutybass(freq(n.y+36.)*n.x,n.x)*.3:vec2(0);\n    o+=(n.y>-50.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/480.)*.3+.34,.9)*vec2(.2)*env_d(n.x,.6):vec2(0);\n    return o;\n}\n//TRACK 4 N163 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30chord(freq(n.y+36.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(2)+48.02)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(4)+36.01)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(6)+48.01)*n.x,n.x)*.25:vec2(0);\n    return o;\n}\n//TRACK 5 N163 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30bell(freq(n.y+72.)*n.x,n.x)*.30:vec2(0);\n    return o;\n}\n//TRACK 6 N163 & NES tri melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?c30lead(freq(n.y+36.03)*n.x,n.x)*.6+tri4lead(freq(n.y+48.)*n.x,n.x)*.5:vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):vec2(0); //TRACK 1 snaredrum,closehh,openhh\n    o+=  track2(t,l,s);         //TRACK 2 bassdrum,lowconga,highconga\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 accompaniment\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.65\n#define MASTER_PRESSURE 1.0\n#define DELAY_REPEAT    4\n#define DELAY_WET       0.5\n#define DELAY_FEEDBACK  0.85\n#define DELAY_TIME      0.11\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n        o+=a*d;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//--- Scale Sequencer 3\n//by Catzpaw 2020\n\n//BufferA:samples for level indicator\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p=fragCoord;\n    int x=int(p.x),y=int(p.y);\n    if((x>6)||(y>0))discard;\n    vec2 o=vec2(0);\n    float t=iTime,l=steps/bpm,vol=1.;\n    if(t>sec-fade){vol=(sec-min(t,sec))/fade;}\n    t-=start*60./bpm;\n    if(t>0.){\n        int s=int(t/l);\n        if(x==0){o=vec2(1);}\n        if(x==1){o=abs(track1(t,l,s));}\n        if(x==2){o=abs(track2(t,l,s));}\n        if(x==3){o=abs(track3(t,l,s));}\n        if(x==4){o=abs(track4(t,l,s));}\n        if(x==5){o=abs(track5(t,l,s));}\n        if(x==6){o=abs(track6(t,l,s));}\n        o*=vol;\n    }\n    fragColor=vec4(o,o);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}