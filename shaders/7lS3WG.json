{
    "Shader": {
        "info": {
            "date": "1624643218",
            "description": "A Cubic Bezier Splitting Segment Visualization\nMouse Enabled using the X axis\nFrom Pomax Chapter 11. https://pomax.github.io/bezierinfo/\nAll the new stuff is in main\nThe first and second half of the split are flipped. I haven't figured out why yet.\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7lS3WG",
            "likes": 4,
            "name": "Bezier Splitting Hull Points",
            "published": 3,
            "tags": [
                "bezier",
                "cubic",
                "casteljau",
                "splitting",
                "beziersplitting"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": "\n\n//updated: Got rid of the original draw segment function since\n//it's already here: https://www.shadertoy.com/view/fljGR3\n\n//I'm learning this stuff from ----> https://pomax.github.io/bezierinfo/\n\n#define numSegments 20.\n#define showSeg\n\n//black and light blue\n#define bgCol   vec3(20.)/255.\n#define lineCol vec3(133, 10.,10.)/255.\n#define segCol vec3(202.)/255.\n#define circleCol vec3(133, 10.,10.)/255.\n#define segCircleCol vec3(100.)/255.\n#define magikCol vec3(142,142,246)/255.\n\n\n/*\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define leftLineCol vec3(68, 66,133)/255.\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n*/\n\n#define segThickness 0.002\n#define segRingRadius 0.003\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float thick){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - thick);\n    return mix(col, lineColor, dist);\n}\n\n\n\n//shorten version thx iapafo\n//original version with notes is here:https://www.shadertoy.com/view/fljGR3\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g, prev = p4;\n    float dt = 1./numSegments;  \n    \n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n    \n        //Matrix Representation\n        vec4 T = vec4(1, t, t*t, t*t*t);\n        \n        //nice looking upper triangular matrix there. \n        \n        mat4 M = mat4(1,0,0,0, \n                     -3,3,0,0, \n                      3,-6,3,0, \n                     -1,3,-3,1);\n                     \n        //I wonder what's gonna happen...             \n        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);\n        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot\n        //when the time comes! After the initial M*T (or P*M apparently?)\n        g.x = dot(M*T,Px); // is the same as dot(P*M,T)\n        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference\n        \n        \n        //or\n        //Mix functions, much smaller\n        //g = mix(p3,p2,t);\n        //g = mix(mix(mix(p4,p3,t), g, t), \n        //            mix(g, mix(p2,p1,t), t), t);\n        \n        \n        //or \n        //Binomial\n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol,segThickness);\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n\n//draw the hull of a bezsier part\nvec3 drawHull(float t, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec2 uv, vec3 col){\n\n//all of this must happen for each new hull\n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    vec2 dLinePoint3 = p3*t + (1.0-t)*p4;\n    \n    vec2 ddPoint1 = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    vec2 ddPoint2 = dLinePoint2*t + (1.0-t)*dLinePoint3;\n    \n    vec2 dddPoint = ddPoint1*t + (1.0-t)*ddPoint2;\n    \n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n\n    col = drawLine(p1,p2,uv,col,lineCol*0.5,0.004);\n    col = drawLine(p2,p3,uv,col,lineCol*0.5,0.004);\n    col = drawLine(p3,p4,uv,col,lineCol*0.5,0.004);\n    col = drawLine(dLinePoint1,dLinePoint2,uv,col,lineCol*0.7,0.004);\n    col = drawLine(dLinePoint2,dLinePoint3,uv,col,lineCol*0.7,0.004);\n    col = drawLine(ddPoint1,ddPoint2,uv,col,lineCol,0.004);\n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p4, col, lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint3, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint2, col, circleCol);\n        \n    return col;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n   \n    float xOff =0.4, yOff=1.2, zOff=2.6, wOff=3.;\n    float eps = 1./min(iResolution.x, iResolution.y);\n    \n    \n    //Original Bezier\n    vec2 p1 = vec2(-0.6, -0.3) + vec2(sin(iTime/2.+xOff),cos(iTime/2.+xOff))/5.;\n    vec2 p2 = vec2(-0.5, 0.3) + vec2(sin(iTime+yOff),cos(iTime+yOff))/10.;\n    vec2 p3 = vec2(0.5, 0.3) + vec2(sin(iTime+zOff),cos(iTime+zOff))/7.;\n    vec2 p4 = vec2(0.1, -0.2) + vec2(sin(iTime/2.+wOff),cos(iTime/2.+wOff))/2.;\n    \n    \n    //All the possible split values for only one split (0. to 1 )\n    float splitPoint = fract(iTime)/numSegments;\n    \n    //an animated t so we see all the values and how the hull moves\n    float t = sin(iTime/2.)*0.5+0.5;\n    \n    vec3 col = bgCol;\n    \n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n    \n    //Determining the Hull points of the first half of the bezier Curve\n    //Matrix Representation\n    \n    //the cubic function\n    vec4 T = vec4(1, t, t*t, t*t*t);\n        \n    //cooefficient matrix\n    //nice looking upper triangular matrix there. \n    mat4 M = mat4(1,0,0,0, \n                  -3,3,0,0, \n                  3,-6,3,0, \n                  -1,3,-3,1);\n                     \n    //I wonder what's gonna happen...             \n    vec4 px = vec4(p4.x,p3.x,p2.x,p1.x);\n    vec4 py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n    mat4 Mi = inverse(M);\n    \n    float z = 0.5+sin(iTime)*0.3;\n    \n    if(iMouse.z > 0.0){\n        z = 1.0-iMouse.x/iResolution.x;\n    }\n    //the Z matrix that comes from going only from 0 to z instead of 0 to 1\n    mat4 Z = mat4(1.,0.,0.,0.,\n                  0.,z,0.,0.,\n                  0.,0.,z*z,0.,\n                  0.,0.,0.,z*z*z);\n   \n   //B(t) = vt*Z*M*vp = vt*M*Mi*Z*M*vp \n   //Q = Mi*Z*M   so...\n   //B(t) = vt*M*Q*vp \n   //and the matrix form of a bezier curve is vt*M*vp \n   //so we jsut do vt*M*[Q*vp] and [Q*vp] are the new coordinates!\n   \n   vec4 vpx = px*(M*Z*Mi);\n   vec4 vpy = py*(M*Z*Mi);\n   \n   vec2 pp1 = vec2(vpx.r,vpy.r);\n   vec2 pp2 = vec2(vpx.g,vpy.g);\n   vec2 pp3 = vec2(vpx.b,vpy.b);\n   vec2 pp4 = vec2(vpx.a,vpy.a);\n  \n        \n    col = drawHull(t,pp1,pp2,pp3,pp4,uv,col);\n    col = drawSegments(uv, pp1, pp2, pp3, pp4, col);\n    \n    \n    //\n    //Repeat all of that but with the Zprimg matrix that descibes the other half\n    \n    // T prime is [1, (z+(1-z)*t), (z+(1-z)*t)*(z+(1-z)*t), (z+(1-z)*t)*(z+(1-z)*t)*(z+(1-z)*t))]\n    \n    //that because:\n    //ok this is a bezier function with two variables\n    //z is an offset, t is an input that will varie from 0 to 1 sa usual \n    //but it's contrained between z and 1\n    // z +(1-z)*t the percentage of t = z + the percentage of t that \n    // for example, with z = 0.5 and t = 0.2: (0.5 + (1 - 0.5)*0.2 = 0.6\n    //basically the prportion is thesame but it is scaled to the room beyond z\n    //AND offset by z. Pretty cool.\n    //Then this happends for every t term in the curve with the matching order(exponent)\n   \n   \n    //now we take z out of t and give it it's own matrix by expanding every component\n    //and using the terms as matrix entries and the order determins the row,\n    //just like in the first Z matrix\n    \n    //and the exansion follows basically all the patterns from 1, to linear to quadratic to cubic\n    \n    // 1, =                              1,0,0,0\n    \n    // z+(1-z))=                         z, (1-z), 0, 0\n    \n    // z+(1-z))(z+(1-z))=                z*z, 2*z*(1-z), (1-z)*(1-z), 0\n    \n    // z+(1-z))*(z+(1-z))*(z+(1-z))) =   z*z*z, 3*z*(1-z)*(1-z), 3*(1-z)*z*z, (1-z)*(1-z)*(1-z)\n    \n    mat4 Zprime = mat4(1.,  z,        z*z,             z*z*z,\n                       0.,  (1.-z),   2.*z*(1.-z),       3.*z*z*(1.-z),\n                       0.,   0.,      (1.-z)*(1.-z),   3.*z*(1.-z)*(1.-z),\n                       0.,   0.,      0.,              (1.-z)*(1.-z)*(1.-z));\n\n    //the order of every column in this matrix is critical\n    //it needs to be exactly as it would come out of an expansion from the binomial\n    \n    //Awesome, now calculate the points for the first half(should be second?)\n    \n    vpx = px*(M*Zprime*Mi);\n    vpy = py*(M*Zprime*Mi);\n   \n    pp1 = vec2(vpx.r,vpy.r);\n    pp2 = vec2(vpx.g,vpy.g);\n    pp3 = vec2(vpx.b,vpy.b);\n    pp4 = vec2(vpx.a,vpy.a);\n  \n        \n    col = drawHull(t,pp1,pp2,pp3,pp4,uv,col);\n    col = drawSegments(uv, pp1, pp2, pp3, pp4, col);\n    \n    //col = drawSegments(uv, p1, p2, p3, p4, col);\n    col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, pp1, col, magik_farber);\n    \n    col = pow(col, vec3(0.75));\n    //vignett from ApoorvalJ https://www.shadertoy.com/view/4lSXDm\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig*1.1,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}