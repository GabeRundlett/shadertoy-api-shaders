{
    "Shader": {
        "info": {
            "date": "1626155173",
            "description": "Another shader for Sableraph's weekly creative coding challenge, the prompt this time being \"64\". \n\nI sorta ran out of ideas after finishing the pipes and cubes but maybe I will come back to this and add some background details idk. ",
            "flags": 0,
            "hasliked": 0,
            "id": "NlXSRX",
            "likes": 14,
            "name": "64 Cubes",
            "published": 3,
            "tags": [
                "3d",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n#define STEPS 96.0\n#define MDIST 50.0\n#define aspect (iResolution.y/iResolution.x)\n\n\nfloat rand1(float a){\n    return fract(sin(dot(vec2(a),vec2(43.234,21.4343)))*94544.3434343)-0.5;\n}\n//cylinder from iq\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 bezier4p(vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t){\n    vec2 p = pow(1.0-t,3.0)*p1+\n           3.0*pow(1.0-t,2.0)*t*p2+ \n           3.0*(1.0-t)*t*t*p3+\n           pow(t,3.0)*p4;  \n    return p;\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat pipe(vec3 p){\n    float a = 0.0;\n    a = cyl(p+vec3(0,9,0),1.0,10.0);\n    a = min(a,cyl(p-vec3(0,1,0),1.2,0.2));\n    a = max(-(length(p.xz)-0.9),a);\n    a-=0.02;\n    return a;\n}\nvec2 aspectize(vec2 a){\n    a.x*=aspect;\n    a.y/=aspect;\n    return a;\n}\nvec2 map(vec3 p){//oops this became a huge mess, oh well\n\n    vec3 po = p;\n    float t = iTime;\n    \n    vec2 a = vec2(0);\n    vec2 b = vec2(1);\n    \n    float ps = 0.5; //Pipe Smooth Time\n    float prt = 3.0;//Pipe Repeat Time\n    \n    vec2 pipe1Pos = vec2(0);\n    vec2 pipe2Pos = vec2(0);\n    float cycleInt = floor(t/prt+1.0);\n    \n    //Pipe Up/Down Movement\n    pipe1Pos.y = 10.0-5.0*smoothstep(0.0,ps,mod(t,prt))*smoothstep(prt,prt-ps,mod(t,prt));\n    //Side to Side randomize\n    float sideScale = 11.75;\n    \n    pipe1Pos.x+=rand1(cycleInt)*sideScale;\n    pipe2Pos.x+=rand1(cycleInt*1.01)*sideScale;\n    \n    pipe2Pos.y = pipe1Pos.y;\n    \n    \n    float pipe1Rot = floor((rand1(cycleInt*1.02)+0.5)*4.0);\n    float pipe2Rot = floor((rand1(cycleInt*1.03)+0.5)*4.0);\n    \n    if(pipe1Rot==pipe2Rot){\n        pipe1Pos.x = abs(pipe1Pos.x)-sideScale*0.5-1.5;\n        pipe2Pos.x = -abs(pipe2Pos.x)+sideScale*0.5+1.5;\n    }\n    \n    if(pipe1Rot==1.0||pipe1Rot==3.0){\n        pipe1Pos.x*=aspect;\n        pipe1Pos.y/=aspect;\n    }\n    \n    p.xy*=rot((pi/2.0)*pipe1Rot);\n    p.xy+=pipe1Pos;\n    a.x = pipe(p);\n    \n    p = po;\n    \n    if(pipe2Rot==1.0||pipe2Rot==3.0){\n        pipe2Pos.x*=aspect;\n        pipe2Pos.y/=aspect;\n    }\n    \n    p.xy*=rot((pi/2.0)*pipe2Rot);\n    p.xy+=pipe2Pos;\n    \n    b = vec2(pipe(p),0.0);\n    \n    a=(a.x<b.x)?a:b;    \n    \n    float pathDisp = 8.5; //Try increasing this :)\n    vec2 p1 = pipe1Pos*rot(3.0*(pi/2.0)*pipe1Rot);\n    vec2 p2 = (pipe1Pos+vec2(0,-pathDisp))*rot(3.0*(pi/2.0)*pipe1Rot);\n    vec2 p3 = pipe2Pos*rot(3.0*(pi/2.0)*pipe2Rot);\n    vec2 p4 = (pipe2Pos+vec2(0,-pathDisp))*rot(3.0*(pi/2.0)*pipe2Rot);\n    \n    float loops =16.0;\n    for(float i = 0.0; i <loops; i ++){\n        float tp = min(-prt*0.5+fract(t/prt)*prt+i/loops,1.1);\n        vec2 boxp = bezier4p(p1,p2,p4,p3,tp);\n        p = po;\n        p+=vec3(boxp,0);\n        p.xy*=rot(t+(i/16.0)*13.0);\n        p.xz*=rot(t+(i/16.0)*13.0);\n        p = abs(p)-vec3(0.45,0.45,0.0);\n        b = vec2(box(p,vec3(0.15)),1.0);\n        if(fract(t/prt)*3.0>ps) a=(a.x<b.x)?a:b;\n    }\n    \n    return a;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col =vec3(0);\n    \n    vec3 ro = vec3(0,0,-30);\n    vec3 rd = normalize(vec3(uv,3.0));\n    \n    vec3 p;\n    vec2 d;\n    float dO, shad;\n    bool hit = false;\n    \n    for(float i = 0.0; i < STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        \n        if(abs(d.x)<0.01){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            p = ro+rd*MDIST;\n            break;\n        }\n    }\n    if(hit){\n    vec3 n = norm(p);\n    vec3 ld = vec3(-0.5,0.5,-1);\n    vec3 h = normalize(ld-rd);\n    float spec = pow(max(dot(n,h),0.0),30.0);\n    float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n    float diff = max(dot(n, ld),0.);\n    \n    \n    vec3 al;\n    if(d.y == 0.0) al = vec3(0.035,0.757,0.216);\n    if(d.y == 1.0) al = vec3(0.792,0.247,0.255);\n    col = vec3(diff*0.5);\n    col += spec*0.5;\n    col+=fres*0.2;\n    col+=(1.0-shad)*0.5;\n    col*=al;\n    \n    }\n    \n    //vec3 sky = mix(vec3(0.180,0.616,1.000),vec3(0.278,0.235,0.843),clamp(-p.y*0.1+0.4,0.0,1.0));\n    \n    if(!hit)col = vec3(0.302,0.545,1.000)*(1.0-0.5*length(uv*uv));\n    col*=clamp(sin(18.0* uv.y*iResolution.y+iTime*2.0)*0.5+0.5,0.8,1.0);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}