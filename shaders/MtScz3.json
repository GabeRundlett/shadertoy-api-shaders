{
    "Shader": {
        "info": {
            "date": "1509483480",
            "description": "Mouse to move.\nUpdates using 3D cellular automata. Change the delay if you're in a hurry to see the endgame.",
            "flags": 32,
            "hasliked": 0,
            "id": "MtScz3",
            "likes": 19,
            "name": "Living Pipes",
            "published": 3,
            "tags": [
                "raymarching",
                "voxels",
                "automata",
                "cellular",
                "multipass",
                "pipes",
                "falsehilbert"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 1196
        },
        "renderpass": [
            {
                "code": "//\"postprocessing buffer\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //note: I don't actually know how to do bloom. So I did this.\n    vec3 blur = textureLod(iChannel0, fragCoord/iResolution.xy, 5.0).xyz;\n    vec3 original = textureLod(iChannel0, fragCoord/iResolution.xy, 0.0).xyz;\n    fragColor = vec4(blur/3. + original, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//VOXEL UPDATE BUFFER\n\n#define sizeX 24\n#define sizeY 24\n#define sizeZ 24\n#define stackPerRow 24\n#define cellthreshold 0.5\n#define attenuation 25.\n#define delay 100\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nivec2 getcoords(ivec3 cell) {\n    return ivec2(cell.x + (cell.z % stackPerRow) * sizeX, cell.y + (cell.z / stackPerRow) * sizeY);\n}\n\nbool boundscheck(ivec3 cell) {\n    return (cell.x >= 0 && cell.x < sizeX && cell.y >= 0 && cell.y < sizeY && cell.z >= 0 && cell.z < sizeZ);\n}\n\nivec3 getcell(ivec2 xy) {\n    int x = xy.x % sizeX;\n    int y = xy.y % sizeY;\n    int z = xy.x/sizeX + stackPerRow*(xy.y/sizeY);\n    return ivec3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 xy = ivec2(fragCoord);\n    if (xy.x >= sizeX * stackPerRow || xy.y >= sizeY * (sizeZ / stackPerRow)) discard;\n    \n    ivec3 cell = getcell(xy);\n    vec4 curr = texelFetch(iChannel0, xy, 0);\n    float state = curr.r;\n    \n    int neighbors = 0;\n    if (iFrame % delay == 0) {\n        ivec2 diff = ivec2(1., 0.);\n    \tivec3 icell = cell + diff.xyy;\n        if (boundscheck(icell) && texelFetch(iChannel0, getcoords(icell), 0).r > cellthreshold) neighbors += 1;\n        icell = cell - diff.xyy;\n        if (boundscheck(icell) && texelFetch(iChannel0, getcoords(icell), 0).r > cellthreshold) neighbors += 1;\n        icell = cell + diff.yxy;\n        if (boundscheck(icell) && texelFetch(iChannel0, getcoords(icell), 0).r > cellthreshold) neighbors += 1;\n        icell = cell - diff.yxy;\n        if (boundscheck(icell) && texelFetch(iChannel0, getcoords(icell), 0).r > cellthreshold) neighbors += 1;\n        icell = cell + diff.yyx;\n        if (boundscheck(icell) && texelFetch(iChannel0, getcoords(icell), 0).r > cellthreshold) neighbors += 1;\n        icell = cell - diff.yyx;\n        if (boundscheck(icell) && texelFetch(iChannel0, getcoords(icell), 0).r > cellthreshold) neighbors += 1;\n        \n        if (state > cellthreshold) {\n            //alive\n            if (neighbors < 2)\n                state = 0.;\n            else if (neighbors < 4)\n                state = 1.;\n            else\n                state = 0.;\n        } else {\n            //dead\n            if (neighbors == 3 || neighbors == 4)\n                state = 1.;\n        }\n        fragColor = vec4(state, curr.g, 0., 1.);\n    } else {\n        curr.g += ((curr.r*1.1-0.1) - curr.g)/attenuation;\n        fragColor = curr;\n    }\n    \n    \n    //initialization\n    if (iFrame == 0) {\n        /* a spherical blob\n\t\tif (length(vec3(cell) - vec3(sizeX/2, sizeY/2, sizeZ/2)) > 4.)\n            fragColor = vec4(0., 0., 0., 1.);\n        else\n            fragColor = vec4(1., 0., 0., 1.);*/\n        float init = rand(vec2(cell.x*cell.y, cell.z*cell.y));\n        fragColor = vec4(step(init, cellthreshold), 0., 0., 1.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//RENDERING BUFFER\n\n#define piperadius 0.25\n#define fdist 0.4\n#define floorheight -6.\n#define iter 100\n#define shadowiter 10\n#define shadoweps 0.1\n#define sharpness 5.\n#define tol 0.05\n#define maxdist 40.\n#define eps 0.01\n#define sidelength 1.\n#define minradius 0.001\n#define lightdir normalize(vec3(1., 2., 3.))\n#define lightdir2 normalize(vec3(-1, -2., -3))\n\n#define sizeX 24\n#define sizeY 24\n#define sizeZ 24\n#define stackPerRow 24\n#define cellthreshold 0.05\n\n\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nivec2 getcoords(ivec3 cell) {\n    if (cell.x >= 0 && cell.x < sizeX && cell.y >= 0 && cell.y < sizeY && cell.z >= 0 && cell.z < sizeZ)\n    \treturn ivec2(cell.x + (cell.z % stackPerRow) * sizeX, cell.y + (cell.z / stackPerRow) * sizeY);\n    else\n        return ivec2(sizeX*stackPerRow, 0);\n}\n\nfloat boundscheck(ivec3 cell) {\n    return (cell.x >= 0 && cell.x < sizeX && cell.y >= 0 && cell.y < sizeY && cell.z >= 0 && cell.z < sizeZ) ? 1. : 0.;\n}\n\n/*\n\nthe box:\n +y-----(s,s)\n  |      |\n  |      |\n  |      |\n  0---- +x\n\n*/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//ray box (exit only) in centered, normalized coordinates\nfloat box(vec3 ro, vec3 rd) {\n    ro = mod(ro, sidelength) - sidelength/2.;\n    vec3 t = -ro/rd + abs(sidelength/rd/2.);\n    return min(t.x, min(t.y, t.z));\n}\n\nfloat pipexp(vec3 ro, float r) {\n    if (r < minradius)\n        return maxdist;\n    float h = clamp(ro.x, 0., sidelength/piperadius * r);\n    ro.x -= h;\n    return length(ro) - r;\n}\n\n\nfloat pipes(vec3 ro, vec3 tp, vec3 tm) {\n    float d = maxdist;\n    tp *= piperadius;\n    tm *= piperadius;\n    d = min(d, pipexp(ro, tp.x));\n    d = min(d, pipexp(-ro, tm.x));\n    d = min(d, pipexp(ro.yzx, tp.y));\n    d = min(d, pipexp(-ro.yzx, tm.y));\n    d = min(d, pipexp(ro.zxy, tp.z));\n    d = min(d, pipexp(-ro.zxy, tm.z));\n    return d;\n}\n\n\nfloat map(vec3 ro) {\n    vec3 roo = ro/sidelength;\n    vec3 b = vec3(floor(roo.x), floor(roo.y), floor(roo.z));\n    float h = maxdist;\n    float mat = 0.; //empty space (bounding box exit)\n    //find the texel for this voxel\n    ivec3 cell = ivec3(b+vec3(sizeX/2, sizeY/2, sizeZ/2));\n    ivec2 xy = getcoords(cell);\n    vec4 pix = texelFetch(iChannel0, xy, 0);\n    if (pix.g < cellthreshold) return maxdist;\n    //query adjacent voxels\n\n    vec3 tp;\n    vec3 tm;\n    ivec2 diff = ivec2(1., 0.);\n    ivec3 icell = cell + diff.xyy;\n    tp.x = boundscheck(icell) * texelFetch(iChannel0, getcoords(icell), 0).g;\n    icell = cell - diff.xyy;\n    tm.x = boundscheck(icell) * texelFetch(iChannel0, getcoords(icell), 0).g; \n    icell = cell + diff.yxy;\n    tp.y = boundscheck(icell) * texelFetch(iChannel0, getcoords(icell), 0).g; \n    icell = cell - diff.yxy;\n    tm.y = boundscheck(icell) * texelFetch(iChannel0, getcoords(icell), 0).g;\n    icell = cell + diff.yyx;\n    tp.z = boundscheck(icell) * texelFetch(iChannel0, getcoords(icell), 0).g;\n    icell = cell - diff.yyx;\n    tm.z = boundscheck(icell) * texelFetch(iChannel0, getcoords(icell), 0).g;\n    ro = ro-(b+0.5)*sidelength;\n    //smooth transition\n    h = min(h, max(pipes(ro, tp*pix.g, tm*pix.g), length(ro)-(pix.g-0.1)*sidelength*0.7));\n\n    return h;\n}\n\nvec2 map(vec3 ro, vec3 rd) {\n    float h = box(ro, rd)+tol; //not sure if adding tol is needed\n    float mat = 0.; //empty space (bounding box exit)\n    float h2 = map(ro);\n    if (h2 < h) {\n        h = h2;\n        mat = 1.;\n    }\n    return vec2(h, mat);\n}\n\nvec3 normal(vec3 ro) {\n    //who needs central finite differences anyway?\n    vec2 h = vec2(eps, 0.);\n    float curr = map(ro);\n    float dx = map(ro+h.xyy)-curr;\n    float dy = map(ro+h.yxy)-curr;\n    float dz = map(ro+h.yyx)-curr;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec2 raytrace(vec3 ro, vec3 rd) {\n    float t = 0.;\n    vec2 d = map(ro, rd);\n    int i;\n    for (i=0; i<iter; i++) {\n        t += d.x;\n        d = map(ro + t*rd, rd);\n        if (abs(d.x) < tol && d.y > 0.5) {\n            return vec2(t, 1.);\n        } else if (t > maxdist) {\n            break;\n        }\n    }\n    return vec2(t, 0.);\n}\n\nfloat shadowtrace(vec3 ro, vec3 rd) {\n    int i;\n    float t = shadoweps;\n    vec2 d = map(ro+t*rd, rd);\n    float fac = 1.0;\n    float fac2 = 1.0;\n    for (i=0; i<shadowiter; i++) {\n        //t += clamp(d.x/10., 0.1, 0.2);\n        t += 0.1;\n        d = map(ro + t*rd, rd);\n        if (d.y > 0.5)\n        \tfac = min(fac, d.x * sharpness / t);\n    }\n    return fac > 0. ? mix(0.5, 1., fac) : mix(0.5, 0., -fac);\n}\n\n//the actual fresnel term died on the way back to its home planet\nfloat fresnel(vec3 n, vec3 rd) {\n    float c = dot(n, -rd);\n    return 0.1 + 0.6*pow(1.-c, 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float alt = clamp((iMouse.y/iResolution.y-0.5), -0.25, 0.4) * PI;\n    float azi = (iMouse.x/iResolution.x+0.05) * TWO_PI;\n    float cphi = cos(alt);\n    vec3 eye = 10. * vec3(sin(azi)*cphi, sin(alt), cos(azi)*cphi);\n    //vec3 eye = 8.*vec3(cos(iTime/8.), 1., sin(iTime/8.));\n    vec3 w = normalize(-eye);\n    eye.z += float(sizeZ)/5.;\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(fdist*w + (fragCoord.x/iResolution.x-0.5)*u + (fragCoord.y - iResolution.y/2.)/iResolution.x*v);\n\tvec2 d = raytrace(eye, rd);\n    vec3 skycolor = mix(vec3(0.8, 0.9, 1.), vec3(0.2, 0.2, 0.3), pow(abs(rd.y), 3.5));\n    if (d.y < 0.5 && d.x > 0.) {\n        fragColor = vec4(skycolor, 1.);\n    } else {\n        vec3 hit = eye + d.x*rd;\n        vec3 n = normal(hit);\n        float fac = dot(n, lightdir);\n        fac = min(fac, shadowtrace(hit, lightdir));\n        vec3 col1 = max(0.2, fac) * vec3(1., 1., 0.9);\n        vec3 col2 = max(0., dot(n, lightdir2)) * vec3(0.3, 0.3, 0.4);\n        vec3 texx = texture(iChannel2, hit.yz).xyz;\n        vec3 texy = texture(iChannel2, hit.zx).xyz;\n        vec3 texz = texture(iChannel2, hit.xy).xyz;\n        vec3 n2 = abs(n);\n        vec3 tex = (n2.x * texx + n2.y * texy + n2.z * texz)/dot(n2, vec3(1.));\n        vec3 k = mix(tex, mix(vec3(1., 0.4, 0.4), vec3(0.4, 0.4, 1.), (hit.y + sidelength*float(sizeY)/2.)/(sidelength*float(sizeY))), 0.5);\n        vec3 refl = reflect(rd, n);\n        float fres = fresnel(n, rd);\n        vec3 col3 = texture(iChannel1, refl).xyz;\n        fragColor = vec4(mix(mix(k*(col1+col2), col3, fres), skycolor, clamp((d.x-5.)/25., 0., 1.)), 0.9);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}