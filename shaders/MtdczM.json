{
    "Shader": {
        "info": {
            "date": "1532085516",
            "description": "one oif my favourite sss code shaders, \"cleaned up\" and simplified, as in, no buffers.\n\nhmm, why is time frozen, some day shadertoy stopped using iGlobalTime.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdczM",
            "likes": 8,
            "name": "SubSurface cleaned",
            "published": 3,
            "tags": [
                "subsurfacescattering",
                "sss"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 672
        },
        "renderpass": [
            {
                "code": "\n#define NINF 65536.\n\n\n#define iGlobalTime (iTime*9.)\n\n\n//parent shader by \n//Ben Quantock 2014\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//artefacts from noise texture interpolation\n#define FAST\n\n//keys\n/*\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77;\nconst int kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n//key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey(int key,bool toggle){ float keyVal=0.5;return(keyVal>.5)?true:false;}\nbool Toggle(int val){ return !ReadKey(val,true);}\n//TOGGLES:\n\n#define kAmbientOcclusion 65\n#define kReflectionOcclusion 39\n#define kSubsurface 32\n#define kLensFX 37\n#define kDarkScene 40\n*/\n\n\nconst float tau=6.2831853;\nconst float phi=1.61803398875;\nconst vec3 darkEnvBrightness=vec3(.02,.03,.05);\n\nvec3 envBrightness=vec3(1);//global var\n\nvec2 Noise(vec3 x){return vec2(.5);}//butchered bumpmapping\n/* #ifdef FAST\n ;vec3 p=floor(x);x=fract(x);x*=x*(3.-2.*x);vec2 uv=(p.xy+vec2(37.,17.)*p.z)+x.xy\n ;vec4 rg=vec4(.5);//texture2D(iChannel0,(uv+0.5)/256.0,-100.0);\n #else \n ;//high precision interpolation,if needed,requires reading from self\n ;vec4 rg=mix(mix(\n texture2D(iChannel0,(floor(uv)+0.5)/256.0,-100.0),\n texture2D(iChannel0,(floor(uv)+vec2(1,0)+0.5)/256.0,-100.0),\n fract(uv.x)),\n  mix(\n texture2D(iChannel0,(floor(uv)+vec2(0,1)+0.5)/256.0,-100.0),\n texture2D(iChannel0,(floor(uv)+1.5)/256.0,-100.0),\n fract(uv.x)),\n fract(uv.y));\n #endif \n;return mix(rg.yw,rg.xz,x.z);}*/\n\nfloat mav(vec2 a){return max(a.x,a.y);}\nfloat mav(vec4 a){return max(mav(a.xy),mav(a.zw));}\n#define miv(a)-mav(-a)\n\nvec4 octFold(vec3 p,vec2 s){return vec4(dot(p,s.xxx),dot(p,s.yyx),dot(p,s.yxy),dot(p,s.xyy));}\nfloat Oct(vec3 u){return mav(abs(octFold(u,vec2(1,-1)/sqrt(3.))));}\n\n//Ben Quantock 2014\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nfloat CubeFrame(vec3 p,float r\n){p=abs(p)\n ;float s=r*.1\n ;p-=vec3(r-s)\n ;p=mix(p,p.zyx,step(p.x,p.z))\n ;p=mix(p,p.xzy,step(p.y,p.z))\n ;p.z=max(0.,p.z)\n ;return length(p)-s;}\n\nfloat df(vec3 p){\n return miv(vec4\n(length(p-vec3(0,.48,0))-.1\n ,Oct(p-vec3(0,.2,0))-.15\n ,CubeFrame(p-vec3(0,-.05,0),.26)\n ,length(p-vec3(0,-.6,0))-.4));}\n /*\n//spiral candle has bad lipscchitz,putting sss to a stress test.\n ;p.xz=p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);\n ;return max(max(p.y-.5,-p.y-1.)\n ,(min(max(abs(p.x),abs(p.z))\n ,max(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0))-.15)*.8);}*/\n\nvec3 Sky(vec3 ray){return envBrightness*mix(vec3(.8),vec3(0),exp2(-(1./max(ray.y,.01))*vec3(.4,.6,1.)));}\n\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\nvec3 Shade(vec3 u,vec3 ray,vec3 normal,vec3 ligDir1,vec3 ligDir2,vec3 ligCol1,vec3 ligCol2,float shadowMask1,float shadowMask2,float distance \n){vec3 amb=envBrightness*mix(vec3(.2,.27,.4),vec3(.4),(-normal.y*.5+.5))//amb\n ;//amb=mix(vec3(.03,.05,.08),vec3(.1),(-normal.y+1.0));//amb\n ;//amb occlusion,based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n ;float aoRange=distance/20.\n ;float occlusion=max(0.,1.-df(u+normal*aoRange)/aoRange)//can be>1.0\n ;occlusion=exp2(-2.0*pow(occlusion,2.0));//tweak the curve\n \n //mat init for loops\n ;mat4 a;\n ;a[0].xyz=ligCol1\n ;a[1].xyz=ligCol2\n ;a[0].w=max(.0,dot(normal,ligDir1))\n ;a[1].w=max(.0,dot(normal,ligDir2))\n ;mat4 b;\n ;b[0].xyz=ligDir1\n ;b[1].xyz=ligDir2\n ;b[0].w=shadowMask1\n ;b[1].w=shadowMask2\n \n //acc1\n ;vec3 lig=vec3(0)//accumulator\n \n //acc2\n ;vec3 s//accumulate subsurface color\n ;float t=distance/10.//this really should be constant... right? //t\n \n //acc3\n ;float spe=Noise(u/vec3(.05,.2,.05)).x//specular\n ;float specPower=exp2(3.+5.*spe)\n \n\n ;for(int i=0;i<2;i++//for each light\n){lig+=a[i].xyz*b[i].w*a[i].w\n  ;s=s+a[i].xyz*ss01(df(u+b[i].xyz*t)/t)\n  ;a[i].xyz=a[i].xyz*b[i].w*pow(max(.0,dot(normal,normalize(b[i].xyz-ray)))*ss01(a[i].w),specPower)*specPower/32.\n ;}\n \n  ;if(true)amb*=occlusion*.8+.2//reduce occlusion to imply indirect sub surface scattering\n\n \n ;vec3 rray=reflect(ray,normal)\n ;vec3 ref=Sky(rray)\n \n ;//specular occlusion,adjust the divisor for the gradient we expect\n ;float so=max(0.,1.-df(u+rray*aoRange)/(aoRange*max(.01,dot(rray,normal))))//can be>1.0 //specOcclusion\n ;so=exp2(-2.*so*so)//tweak the curve\n ;so*=occlusion ;//prevent sparkles in heavily occluded areas\n ;if(true)ref*=so//could fire an additional ray for more accurate results\n ;float fre=pow(1.0+dot(normal,ray),5.)\n ;fre=mix(mix(.0,.01,spe),mix(.4,1.,spe),fre)\n ;//vec3 alb=vec3(1,.95,.9)\n ;vec3 alb=vec3(.7,.5,1)\n ;//vec3 alb=vec3(.5,.3,.13)\n ;vec3 c=vec3(0)\n ;//comment these out to toggle various parts of the effect\n ;lig+=amb\n ;if(true)lig+=s\n ;c=lig*alb\n ;c=mix(c,ref,fre)\n ;c+=a[0].xyz+a[1].xyz   //okay here we sum up the bugger of the foreach light loop,this is fine!\n ;return c;}\n \n \n\n\n//Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif \n\nfloat Trace(vec3 u,vec3 d,float a,float b//ray,ray,start,end\n){float h,t=a\n ;for(int i=0;i<traceLimit;i++\n){h=df(u+t*d);if(h<traceSize||t>b)break\n  ;t=t+h;}\n ;if(t>b)return 0.0;//(...|| h>.001)\n ;return t;}\n\nfloat TraceMin(vec3 u,vec3 d,float a,float b//ray,ray,start,end\n){float Min=b\n ;float t=a\n ;float h\n ;for(int i=0;i<traceLimit;i++\n){h=df(u+t*d)\n  ;Min=min(h,Min)\n  ;if(/*h<.001 ||*/ t>b)break;\n t=t+max(h,.1);}\n ;return Min;}\n\nvec3 Normal(vec3 u,vec3 d,float t//should be able to get a good gradient with 4x sampling\n){float pitch=.2*t/iResolution.x\n #ifdef FAST\n ;pitch=max(pitch,.005)//don't sample smaller than the interpolation errors in Noise()\n #endif\n ;vec2 e=vec2(-1,1)*pitch\n ;vec3 p0=u+e.xxx,p1=u+e.xyy,p2=u+e.yxy,p3=u+e.yyx\n ;float f0=df(p0),f1=df(p1),f2=df(p2),f3=df(p3)\n ;vec3 grad=p0*f0+p1*f1+p2*f2+p3*f3-u*(f0+f1+f2+f3)\n ;grad-=max(.0,dot(grad,d))*d//prevent normals pointing away from camera(caused by precision errors)\n ;return normalize(grad);}\n\nvec3 Ray(float zoom,in vec2 fragCoord){return vec3(fragCoord.xy-iResolution.xy*.5,iResolution.x*zoom);}\n\nvec3 Rotate(inout vec3 v,vec2 a){vec4 cs=vec4(cos(a.x),sin(a.x),cos(a.y),sin(a.y))\n ;v.yz=v.yz*cs.x+v.zy*cs.y*vec2(-1,1)\n ;v.xz=v.xz*cs.z+v.zx*cs.w*vec2(1,-1)\n ;return vec3(vec2(-cs.w,-cs.z)*cs.x,cs.y).xzy;}\n\n//would love to get some disperson on this,but that means more rays\nvoid BarrelDistortion(inout vec3 d,float t){d.z/=t;d.z=(d.z*d.z-dot(d.xy,d.xy));d.z=t*sqrt(d.z);}//direction,degree_of_fisheye\n\nvec3 LensFlare(vec3 ray,vec3 lightCol,vec3 light,float lightVisible,float sky,vec2 fragCoord\n){vec2 dirtuv=fragCoord.xy/iResolution.x\n ;float dirt=1.-.5;//-texture2D(iChannel1,dirtuv).r\n ;float l=(dot(light,ray)*.5+.5)\n ;return((pow(l,30.)+.05)*dirt*.1\n  +pow(l,200.)*lightVisible+sky*pow(l,5000.))*lightCol\n  +5.*pow(smoothstep(.9999,1.,l),20.0)* smoothstep(.5,1.,lightVisible)* normalize(lightCol);}\n\n\nfloat SmoothMax(float a,float b,float smoothing\n){return a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.));}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord\n){if(true)envBrightness=darkEnvBrightness\n ;vec3 ray=Ray(1.0,fragCoord)\n ;if(true)BarrelDistortion(ray,.5)\n ;ray=normalize(ray)\n ;vec3 lr=ray\n ;vec2 m=vec2(0)\n ;m=.5-iMouse.yx/iResolution.yx//if(iMouse.z>0.0)\n ;float T=iGlobalTime*.1\n ;vec3 u=3.0*Rotate(ray,vec2(.2,1.0-T)+vec2(-1.0,-6.3)*m)\n ;//u+=vec3(0,.3,0)+T*vec3(0,0,-1);\n ;vec3 col\n ;vec3 lightDir1=normalize(vec3(3,1,-2))\n ;float lt=iGlobalTime\n ;vec3 lightu=vec3(cos(lt*.9),sin(lt/phi),sin(lt))*vec3(.6,1.2,.6)\n ;vec3 lightCol1=vec3(1.1,1,.9)*.7*envBrightness\n ;vec3 lightCol2=vec3(.8,.4,.2)\n ;float lightRange2=.4//distance of intensity=1.0\n ;float traceStart=.5\n ;float traceEnd=40.\n ;float t=Trace(u,ray,traceStart,traceEnd)\n ;if(t>.0\n){vec3 p=u+ray*t\n  ;vec3 lightDir2=lightu-p//shadow test\n  ;float lightIntensity2=length(lightDir2);\n  ;lightDir2/=lightIntensity2\n  ;lightIntensity2=lightRange2/(.1+lightIntensity2*lightIntensity2)\n  ;float s1=0.\n  ;s1=Trace(p,lightDir1,.05,2.)\n  ;float s2=0.\n  ;s2=Trace(p,lightDir2,.05,2.)\n  ;vec3 n=Normal(p,ray,t)\n  ;col=Shade(p,ray,n,lightDir1,lightDir2,lightCol1,lightCol2*lightIntensity2,(s1>.0)?0.:1.,(s2>.0)?0.:1.,t)\n  ;float f=200.\n  ;col=mix(vec3(.8),col,exp2(-t*vec3(.4,.6,1.)/f))\n  ;}else col=Sky(ray)\n ;if(true\n){vec3 lightDir2=lightu-u\n  ;float lightIntensity2=length(lightDir2)\n  ;lightDir2/=lightIntensity2\n  ;lightIntensity2=lightRange2/(.1+lightIntensity2*lightIntensity2)\n  ;//lens flare\n  ;float s1=TraceMin(u,lightDir1,.5,40.0)\n  ;float s2=TraceMin(u,lightDir2,.5,40.0)\n  ;col+=LensFlare(ray,lightCol1,lightDir1,smoothstep(-.04,.1,s1),step(t,.0),fragCoord)\n  ;col+=LensFlare(ray,lightCol2*lightIntensity2,lightDir2,smoothstep(-.04,.1,s2),step(t,.0),fragCoord)\n  ;col*=smoothstep(.5,.0,dot(lr.xy,lr.xy))//vignetting\n  ;//compress bright colors,(because bloom vanishes in vignette)\n  ;vec3 c=(col-1.)\n  ;c=sqrt(c*c+.05)//soft abs\n  ;col=mix(col,1.0-c,.48)//.5=never saturate,.0=linear\n  ;vec2 grainuv=fragCoord.xy+floor(iGlobalTime*60.0)*vec2(37,41)//grain\n  ;vec2 filmNoise=vec2(0.5);//texture2D(iChannel0,.5*grainuv/iChannelResolution[0].xy).rb\n  ;col*=mix(vec3(1),mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x),.1*filmNoise.y);}\n ;//compress bright colours\n ;float l=max(col.x,max(col.y,col.z))//dot(col,normalize(vec3(2,4,1)));\n ;l=max(l,.01)//prevent div by zero,darker colours will have no curve\n ;float l2=SmoothMax(l,1.0,.01)\n ;col*=l2/l\n ;fragColor=vec4(pow(col,vec3(1./2.2)),1);}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}