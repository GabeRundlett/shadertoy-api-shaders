{
    "Shader": {
        "info": {
            "date": "1667004838",
            "description": "Attempting a better rigid body physics simulation.\nq - fire upper left thruster\na - fire lower left thruster\ns - fire main (bottom) thruster\nd - fire lower right thruster\ne - fire upper right thruster\nspace - increase main thrust",
            "flags": 48,
            "hasliked": 0,
            "id": "fsXcRl",
            "likes": 15,
            "name": "Rocket Simulation I",
            "published": 3,
            "tags": [
                "2d",
                "physics",
                "flying",
                "rockets"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec4 stateBlock1 = load(iChannel0, ivec2(0, 1));\n    vec4 stateBlock2 = load(iChannel0, ivec2(1, 1));\n\n    vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n    float angle = stateBlock2.x, angVel = stateBlock2.y;\n\n    uv += pos;\n\n    // Draw grid\n    drawSDF(abs(mod(uv.x, 0.25) - 0.125), vec3(1.0));\n    drawSDF(abs(mod(uv.y, 0.25) - 0.125), vec3(1.0));\n\n    // Draw ground\n    drawSDF(uv.y - GROUND, vec3(0.8, 0.5, 0.0));\n\n    // Thruster animation\n    vec2 rocketUv = Rotate2D(-angle) * (uv - pos);\n\n    float flameSize = 0.04;\n    float ratio = 0.4; // Changes the size of the inner flame\n\n    // Draw upper right thruster flame\n    if (texelFetch(iChannel1, ivec2(69, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[0].xy, thrusters[0].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower right thruster flame\n    if (texelFetch(iChannel1, ivec2(68, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[1].xy, thrusters[1].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw main thruster flame\n    if (texelFetch(iChannel1, ivec2(83, 0), 0).x > 0.5) {\n        float mainFlameSize = flameSize * 1.5;\n        if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n            mainFlameSize *= 1.5;\n        }\n\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[2].xy, thrusters[2].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, mainFlameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, mainFlameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw lower left thruster flame\n    if (texelFetch(iChannel1, ivec2(65, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[3].xy, thrusters[3].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw upper left thruster flame\n    if (texelFetch(iChannel1, ivec2(81, 0), 0).x > 0.5) {\n        vec2 thrusterUv = axisAlign(rocketUv - thrusters[4].xy, thrusters[4].zw);\n        drawSDF(sdIsosceles2(thrusterUv, vec2(0.02, flameSize)), vec3(1.0, 0.3, 0.0));\n        drawSDF(sdIsosceles2(thrusterUv, ratio * vec2(0.02, flameSize)), vec3(1.0, 1.0, 0.0));\n    }\n\n    // Draw rocket\n    rocketUv = vec2(abs(rocketUv.x), rocketUv.y - 0.0243594417401);\n    drawSDF(sdIsosceles(rocketUv + vec2(0.0, 0.09), vec2(0.03, 0.08)), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-0.7) * (rocketUv - vec2(0.08, -0.06)), vec2(0.03, 0.08)), vec3(0.0, 1.0, 0.0));\n    drawSDF(sdIsosceles(Rotate2D(-1.8) * (rocketUv - vec2(0.07, 0.03)), vec2(0.03, 0.08)), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdIsosceles(rocketUv, vec2(0.08, 0.2)), vec3(1.0));\n\n    // Draw velocity vector\n    vec2 vectorBase = normalize(vel) * 0.2;\n    drawSDF(sdVectorArrow(uv - pos - vectorBase, 0.005 * vel), vec3(1.0));\n\n    /**\n    // Draw center\n    drawSDF(length(uv - pos) - 0.01, vec3(1.0, 0.7, 0.0));\n\n    // Draw contact points\n    mat2 basis = Rotate2D(angle);\n    vec2[convexHull.length()] curConvHull;\n    for (int i=0; i < convexHull.length(); i++) {\n        curConvHull[i] = basis * convexHull[i] + pos;\n        drawSDF(length(uv - curConvHull[i]) - 0.01, vec3(1.0, 0.7, 0.0));\n    }\n    /**/\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Constants\n#define PI 3.1415926536\n\n#define GRAVITY 9.8\n#define GROUND -0.12\n\n#define MAIN_THRUST 60.0\n#define MAX_THRUST 100.0 // For main thruster\n#define CORRECTION_THRUST 0.2\n\n#define MASS 5.0\n#define MOI 0.000144426534534\n#define FRICTION 0.5\n\n#define dt 0.01 //0.001\n\nconst vec2[] convexHull = vec2[](\n    vec2( 0.0000000000,  0.1576927751),\n    vec2(-0.0891532073,  0.0896335932),\n    vec2(-0.1027853330,  0.0312027353),\n    vec2(-0.1201244039, -0.0367098193),\n    vec2(-0.0742338727, -0.0753628805),\n    vec2(-0.0300000000, -0.0923072249),\n    vec2( 0.0300000000, -0.0923072249),\n    vec2( 0.0742338727, -0.0753628805),\n    vec2( 0.1201244039, -0.0367098193),\n    vec2( 0.1027853330,  0.0312027353),\n    vec2( 0.0891532073,  0.0896335932)\n);\n\n// vec4(pos, dir)\n// 0: top right, 1: bottom right, 2: bottom\n// 3: bottom left, 4: top left\nconst vec4[] thrusters = vec4[](\n    vec4( 0.0959692702,  0.0604181643,  0.9738476309,  0.2272020947),\n    vec4( 0.0971791383, -0.0560363500,  0.6442176872, -0.7648421873),\n    vec4( 0.0000000000, -0.0923072249,  0.0000000000, -1.0000000000),\n    vec4(-0.0971791383, -0.0560363499, -0.6442176872, -0.7648421873),\n    vec4(-0.0959692702,  0.0604181643, -0.9738476309,  0.2272020947)\n);\n\n// Utilities\n#define load(buf, addr) texelFetch(buf, addr, 0)\n\nvec2 perp(in vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return p * mat2(up.y, -up.x, up);\n}\n\n// SDFs\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), 2.0 * q.y / 3.0 - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// Uncentered isosceles triangle\nfloat sdIsosceles2(in vec2 p, in vec2 q) {\n    p = vec2(abs(p.x), q.y - p.y);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)), vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float mag = length(v);\n    p = axisAlign(p, v / mag);\n    return min(sdVerticalLine(p, mag), sdIsosceles(p - vec2(0.0, mag), vec2(0.02, 0.03)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iAddr = ivec2(fragCoord);\n    if (iFrame == 0) {\n        // Initialize position, velocity\n    }\n\n    if (iFrame > 0) {\n        if (iAddr.x < 2 && iAddr.y == 1) {\n            // Load state\n            vec4 stateBlock1 = load(iChannel0, ivec2(0, 1));\n            vec4 stateBlock2 = load(iChannel0, ivec2(1, 1));\n\n            vec2 pos = stateBlock1.xy, vel = stateBlock1.zw;\n            float angle = stateBlock2.x, angVel = stateBlock2.y;\n            float flag1 = stateBlock2.z, flag2 = stateBlock2.w;\n            mat2 basis = Rotate2D(angle);\n\n            // Conversion to object space\n            vec4[5] curThrusters;\n            for (int i=0; i < 5; i++) {\n                curThrusters[i].xy = basis * thrusters[i].xy;\n                curThrusters[i].zw = basis * thrusters[i].zw;\n            }\n\n            // Conversion to world space\n            vec2[11] curConvexHull;\n            for (int i=0; i < 11; i++) {\n                curConvexHull[i] = basis * convexHull[i] + pos;\n            }\n\n            // Calculate lowest point on the rocket\n            vec2 contact = curConvexHull[0];\n            for (int i=1; i < 11; i++) {\n                if (curConvexHull[i].y < contact.y) {\n                    contact = curConvexHull[i];\n                }\n            }\n\n            // Linear and angular forces\n            vec2 force = vec2(0.0);\n            float torque = 0.0;\n\n            // Apply forces\n            force.y -= GRAVITY * MASS;\n\n            // Upper right thruster\n            if (texelFetch(iChannel1, ivec2(69, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[0].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[0].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower right thruster\n            if (texelFetch(iChannel1, ivec2(68, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[1].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[1].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Main thruster\n            if (texelFetch(iChannel1, ivec2(83, 0), 0).x > 0.5) {\n                float mainThrust = MAIN_THRUST;\n                if (texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.5) {\n                    mainThrust = MAX_THRUST;\n                }\n\n                vec2 newForce = -curThrusters[2].zw * mainThrust;\n                force += newForce;\n                torque += cross(vec3(curThrusters[2].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Lower left thruster\n            if (texelFetch(iChannel1, ivec2(65, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[3].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[3].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Upper left thruster\n            if (texelFetch(iChannel1, ivec2(81, 0), 0).x > 0.5) {\n                vec2 newForce = -curThrusters[4].zw * CORRECTION_THRUST;\n                force += newForce;\n                torque += cross(vec3(curThrusters[4].xy, 0.0), vec3(newForce, 0.0)).z;\n            }\n\n            // Handle ground collision\n            if (contact.y < GROUND) {\n                vec2 contactNormal = vec2(0.0, 1.0);\n                pos.y += GROUND - contact.y;\n                contact -= pos;\n\n                // Calculate force required to reflect contact point's velocity\n                // I'm not sure if this is correct, but it gives reasonable behavior\n                vec2 contactVel = vel + vec2(-contact.y, contact.x) * angVel;\n                mat2 sys = mat2(\n                    MOI / MASS + contact.y * contact.y, -contact.x * contact.y,\n                    -contact.x * contact.y, MOI / MASS + contact.x * contact.x\n                );\n\n                vec2 deltaV = FRICTION * reflect(contactVel, contactNormal) - contactVel;\n                vec2 collisionForce = inverse(sys) * (deltaV * MOI / dt); // TODO: convert to velocity and acceleration changes directly\n\n                // Apply force\n                force += collisionForce;\n                torque += cross(vec3(contact, 0.0), vec3(collisionForce, 0.0)).z;\n            }\n\n            // Simulation step\n            vel += force / MASS * dt;\n            pos += vel * dt;\n\n            angVel += torque / MOI * dt;\n            angle += angVel * dt;\n\n            // Store state\n            if (iAddr == ivec2(0, 1)) fragColor = vec4(pos, vel);\n            if (iAddr == ivec2(1, 1)) fragColor = vec4(angle, angVel, flag1, flag2);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}