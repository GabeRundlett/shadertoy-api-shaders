{
    "Shader": {
        "info": {
            "date": "1618657742",
            "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nUse the mouse to pan around, toying with the constants is also pretty fun!\nSpecial thanks to Nameless on discord for his explanation of beer's law and fixed step marching",
            "flags": 0,
            "hasliked": 0,
            "id": "NdXXWH",
            "likes": 8,
            "name": "Simple volumetrics test",
            "published": 3,
            "tags": [
                "3d",
                "volumetrics"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 503
        },
        "renderpass": [
            {
                "code": "const Box box = Box(vec3(-1.), vec3(1.));\nconst DirectionLight sun = DirectionLight(normalize(vec3(1.0)), vec3(.98, .48, .38));\n#define time (iTime+30.0)\nfloat getCameraAngle()\n{\n    if(useMouse)\n        return startingCameraAngle + 9.0*iMouse.x/iResolution.x;\n    else \n        return iTime*.1;\n}\nRay getHitRay(vec2 uv)\n{\n    const vec3 cameraPosition = vec3(cameraDistance, cameraHeight, cameraDistance);\n    \n    float angle = getCameraAngle();\n    vec3 pos = cameraPosition;\n    pos.x *= sin(angle);\n    pos.z *= cos(angle);\n    //camera calculations\n    vec3 target = vec3(.0);\n    vec3 rayOrigin = target + pos;\n    vec3 front = normalize(target-rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    return Ray(rayOrigin, rayDir);\n}\n\nvec3 sky(vec3 direction)\n{\n    return vec3(.2,.4,.9)-vec3(.4,.4,.9)*direction.y;\n}\n\nfloat calculateLightDensity(vec3 point)\n{\n    float result = .0;\n    \n    vec3 samplePoint = point;\n    vec3 fixedStep = sun.direction * lightStepSize;\n    \n    for(int i = 0; i < lightMaxSteps; i++)\n    {\n        result += sampleCloud(samplePoint, time);\n        \n        samplePoint += fixedStep;\n        \n        if(!insideBox(box, samplePoint))\n        {\n            break;\n        }\n    }\n    return result;\n}\n\nfloat sampleBlueNoise(vec2 uv)\n{\n    return texture(iChannel0, uv)[int(mod(float(iFrame), 3.0))];\n}\n\nvec3 Image(vec2 uv)\n{\n    Ray hitRay = getHitRay(uv);\n    float distanceToBox = boxIntersection(hitRay, box);\n    \n    if(insideBox(box, hitRay.origin) || distanceToBox > .0)\n    {\n        float blueNoiseOffset = sampleBlueNoise(uv)*cloudStepSize;\n        vec3 samplePoint = pointAt(hitRay, distanceToBox+blueNoiseOffset);\n        vec3 fixedStep = hitRay.direction * cloudStepSize;\n        \n        float transmittance = 1.0;\n        vec3 lightEnergy = vec3(.0);\n        for(int i = 0; i < cloudMaxSteps; i++)\n        {\n            float density = sampleCloud(samplePoint, time);\n            if(density > notDenseEnough)\n            {\n               transmittance *= 1.-density;\n               \n               float lightDensity = calculateLightDensity(samplePoint);\n               float beer = exp(-lightDensity*densityMultiplier)*density*transmittance;\n               float powder = 1.0-beer;\n               lightEnergy += beer*powder*sun.color;\n            }\n            samplePoint += fixedStep;\n            if(!insideBox(box, samplePoint) || transmittance <= .0001) \n            {\n                break;\n            }\n        }\n        \n        return lightEnergy+transmittance*sky(hitRay.direction);\n    } else \n    {\n        return sky(hitRay.direction);\n    }\n}\n\n\nMAIN_FUNCTION(Image)\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ----- constants ----\nconst int aa = 2;\n\nconst float notDenseEnough = .01;\n\nconst float cloudStepSize = .1;\nconst int cloudMaxSteps = 100;\n\nconst float lightStepSize = .2;\nconst int lightMaxSteps = 10;\n\nconst float densityMultiplier = 1.;\nconst float noiseCutoff = .4;\n\nconst float cameraDistance = 4.6;\nconst float cameraHeight = .0;\n\nconst bool useMouse = false;\nconst float startingCameraAngle = 3.14*.5;\n\n// ----- noise ----\n//all from iq: https://www.shadertoy.com/view/4sfGzS\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat sampleCloud(vec3 point, float time)\n{\n    const mat3 m = mat3( \n                 0.00,  0.80,  0.60,\n                -0.80,  0.36, -0.48,\n                -0.60, -0.48,  0.64 );\n    vec3 q = point+time*.1;\n    float f = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n\treturn max(.0, f-noiseCutoff);\n}\n\n// ----- structs ----\n\nstruct DirectionLight\n{\n    vec3 direction;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 minimum;\n    vec3 maximum;\n};\nbool insideBox(Box box, vec3 point)\n{\n    return all(greaterThanEqual(point, box.minimum)) && all(lessThanEqual(point, box.maximum));\n}\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\nvec3 pointAt(Ray ray, float distanceAlong)\n{\n    return ray.origin + ray.direction * distanceAlong;\n}\n\n// ----- intersection -----\n\nfloat boxIntersection(Ray ray, Box box)\n{\n    //from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n    bool xSign = ray.direction.x >= 0.;\n    bool ySign = ray.direction.y >= 0.;\n    vec3 inverseDir = 1.0/ray.direction;\n    \n    float nearest = ((xSign ? box.minimum : box.maximum).x - ray.origin.x) * inverseDir.x; \n    float nextNearest = ((xSign ? box.maximum : box.minimum).x - ray.origin.x) * inverseDir.x; \n    float nearestY = ((ySign ? box.minimum : box.maximum).y - ray.origin.y) * inverseDir.y; \n    float nextNearestY = ((ySign ? box.maximum : box.minimum).y - ray.origin.y) * inverseDir.y; \n \n    if (nearest > nextNearestY || nearestY > nextNearest) \n        return -1.0;\n    \n    nearest = max(nearestY, nearest);\n    nextNearest = min(nextNearestY, nextNearest);\n    \n    bool zSign = ray.direction.z >= 0.;\n    float nearestZ = ((zSign ? box.minimum : box.maximum).z - ray.origin.z) * inverseDir.z;\n    float nextNearestZ = ((zSign ? box.maximum : box.minimum).z - ray.origin.z) * inverseDir.z; \n    \n    if ((nearest > nextNearestZ) || (nearestZ > nextNearest)) \n        return -1.0;\n    \n    nearest = max(nearest, nearestZ);\n    nextNearest = min(nextNearestZ, nextNearest);\n    \n    return nearest;\n}\n\n\n// ----- boilerplate -----\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \t\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    \\\n    /*Output to screen*/\\\n    fragColor = colorCorrect(total);\\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}