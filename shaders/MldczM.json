{
    "Shader": {
        "info": {
            "date": "1532085866",
            "description": "my off-line version has a working iMouse inoput, but it did not translate at all into the shadertoy.com canvas.\nhere the camera is a bad port, needs a better camera matrix with mouse input.\n\nstill works as demo.",
            "flags": 0,
            "hasliked": 0,
            "id": "MldczM",
            "likes": 7,
            "name": "Bi-Triangular B-Spline patch",
            "published": 3,
            "tags": [
                "triangle",
                "bezier",
                "quadratic",
                "surface",
                "analytic",
                "patch"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1051
        },
        "renderpass": [
            {
                "code": "//#define iGlobalTime iTime\n\n#define ViewZoom 2.\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n\n//self  : https://www.shadertoy.com/view/MldczM\n//parent: https://www.shadertoy.com/view/XsjSDt\n\n//original shader not by ollj\n//this is just a slightly improved variant, with more bounding volume visualization.\n//ollj tried to improve precision\n//, but this root solver case is trickier in its barycentric symmetry than mirror axes of an ellipse\n\n//there is a great trick to this one, uvw projection of space, to wrap this around a sphere:\n//this also works with tracing, right? you can trace an orbit in piecewise segments, right?\n//this would scale by a frustrum, should be doable.\n//and it vould work on the ficonacciSphereinverse() function, right?\n\n//oh the potential of this shader...\n\n//you need to start with 3 rotations,that set the surface notmals at 3 points\n//from that you calculate the intersection point heights and interpolate with a bezier patch.\n//i am not sure if this makes 2 adjacent patches continuoous or haaave a corner.\n//pretty suure it will have a corner.\n//i should be able to force a corner,to show that i can make a corner.\n//but i cant think of a way now.\n//yeah i need to double this one up!\n\n//okay i get it now,\n//to make it seamless,for every coener,all 3-pairs of nearby coplanar CVS must also be colinear.\n//otherwise you have a corner.\n//this reduces my math to a simple \"mirror a midpoints height on the corner-points height\" solution for seamless patching.\n//oh wait,this seems to be a cascading problem.\n//yeah,and the solution against that is 3 2d rotations,which means,there may not be a solution.\n\n\n//curve 3d bezier quadratic triangle patch\n//this does not return the distance to the shape,\n//  It traces a ray intersection!\n//\n// [Ray-intersection for uni-variate quadratic Bezier triangle]\n// 3 one-dimensional(quadratic)-bezier-splines make a triangular patch\n// ,from 6 CVs(3 on corners,3 on midpoints.)\n//\n// [Uni-variate] because the spline is interpolating(6 CV)scalar values\n// ,interpreted as the [height] of the spline at that location.  \n//\n// [Quadratic] because the basis functions are quadratic Bernstein-polynomials\n// basis functions are intrinsically 2D and quadratic,unlike rectangular Bezier forms.\n// This is then root-solved analytically\n// ,but it uses branching to get the smallest positive root(simpler slower gpou code)\n//\n// [Bezier triangle] because simplex(triangle,tetrahedra,etc)lend \n// themselves to ray-intersection more easily than rectangular Bezier forms. \n// Because(when trying to solve non-axis-aligned ray-intersection)\n// the basis functions in the rectangular case are combinations of \n// 1D basis functions that multiply out into higher powers.\n// Simplex-forms avoided by using intrinsically 2D basis functions.\n//\n//  -John Kloetzli,Jr\n//  @JJcoolkl\n// crunched by @Ollj\n\n#define H_FOV_RADIANS 0.785\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n#define dd(a)dot(a,a)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(vec2(-a.y,a.x),b)\nv0 suv(vec2 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nvec4 minx(vec4 a,vec4 b){return mix(b,a,step(a.x,b.x));}//return the vec4 with the smaller .x\n\nconst vec2 p1=vec2(0,4),p2=vec2(-4,-4),p3=vec2(4,-4);//corners.xy of a triangle\nconst float f200=2.,f020=2.,f002=2.,f011=-2.,f101=-2.,f110=-2.;//6 Control points,named by index\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nvec3 BezierTriangle_Quadratic_Normal(const vec3 u,const vec3 a,const vec3 b//get normal(2nd derivative)of quadradicBezier triangularPatch\n){return normalize(cross(vec3(p1-p2,suv(u*vec3(a.x-b.z,b.z-a.y,b.y-b.x))),vec3(p1-p3,suv(u*vec3(a.x-b.y,b.z-b.x,b.y-a.z)))));}\nfloat det2d(vec2 a,vec2 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))==perpendicular dotproduct\n//Cartesian to barycentric(relative to spline verts)\nvec3 CartToBary(vec2 c){c-=p1;vec2 a=p2-p1,b=p3-p1,d=vec2(dot(c,b),dot(c,a));\n ;vec3 r=vec3(dd(a),dd(b),dot(a,b));r=vec3(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx);return vec3(1.-r.y-r.z,r.yz);}\n//Intersect 2d line segment with 2d bezier,set by 2 first derivatives,placed at vec2(0)and vvec2(1,0)\nvec2 LineISect(vec2 a,vec2 b,vec2 u,vec2 d  //rayOrigin,RayTarget\n){b=vec2(b.y-a.y,a.x-b.x);a.x=dot(b,a);d=vec2(d.y-u.y,u.x-d.x);u=vec2(dot(d,u),det2d(b,d))\n ;if(u.y==0.)return vec2(0);b*=u.x;d*=a.x;return vec2(d.y-b.y,b.x-d.x)/u.y;}\n\n//by @JJcoolkl ,crunched by ollj\n//analytical intersection of ray [u,d]=[origin,direction] and quadratic-bezier triangular-patch(6 CV-heights [a,b]=[cornerHeights,MidpointHeights])\nvec3 cd=vec3(0);//debug color vector is very optional\nvec4 BezierTriISect(const vec3 u,const vec3 d,vec3 c1,vec3 c0\n){float mi=min(miv(c1),miv(c0))\n ;vec2 L=u.xy+d.xy,a=LineISect(p1,p2,u.xy,L),b=LineISect(p2,p3,u.xy,L),c=LineISect(p3,p1,u.xy,L)\n ;vec4 q=vec4(-1,-1,1,1)*1./(iResolution.x+2.)//a tiny epsilon is necessary to account for precision loss.\n ,g=vec4(min(p1.x,p2.x),min(p1.y,p2.y),max(p1.x,p2.x),max(p1.y,p2.y))+q\n ,h=vec4(min(p2.x,p3.x),min(p2.y,p3.y),max(p2.x,p3.x),max(p2.y,p3.y))+q\n ,o=vec4(min(p3.x,p1.x),min(p3.y,p1.y),max(p3.x,p1.x),max(p3.y,p1.y))+q\n #define altm(a,b)any(lessThan(vec4(a,b.zw),vec4(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h);vec3 f,e=(vec3(a.x,b.x,c.x)-u.x)/d.x\n ;if(!(bA||bB)){cd+=vec3(.7,0,0)\n  ;f=u+d*miv(e.xy);e=u-d*miv(-e.xy);//intersection with 1/3 sides of a \"triangle prism\"(we hit it only from the inside)\n ;}else{bool bC=altm(c.xy,o)//restructured,1/4 cases skips the calculation of cB\n  ;if(!(bB||bC)){f=u+d*miv(e.yz);e=u-d*miv(-e.yz);cd+=vec3(0,.7,0)//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){f=u+d*miv(e.zx);e=u-d*miv(-e.zx);cd+=vec3(0,0,.7)//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else return vec4(0,0,0,2);}//no intersection with the tirngle prism!\n ;vec3 S=CartToBary(f.xy)\n ;vec3 E=CartToBary(e.xy)-S//Plug in eye ray and solve variables for root finding.\n ;o.xyz=vec3(2.*(dot(E*E,c1)+2.*dot(vec3(E.y*E.z,E.x*E.z,E.x*E.y),c0))\n    ,f.z-e.z+2.*(dot(E*S,c1)+dot(vec3(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0))//i smell a cross()\n    ,dot(S*S,c1)+2.*dot(vec3(S.y*S.z,S.x*S.z,S.x*S.y),c0)-f.z)\n ;o.z=o.y*o.y-2.*o.x*o.z;\n ;if(o.z>=0.){a=(vec2(1.,-1.)*sqrt(o.z)-o.y)/o.x;\n  ;if(abs(a.x-.5)<=.5//;if(a.x>=0.&&a.x<=1.\n ){if(a.y>=0.)a.x=miv(a);cd+=vec3(.3,.3,0);return vec4(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=vec3(0,.3,.3);return vec4(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n ;}};cd+=vec3(.3,0,.3);return vec4(0,0,0,2);}//all intersections are behind the camera\nvec4 ComputeBezierColor(vec3 u,vec3 d,vec3 a,vec3 b//get color based on bezier tri intersection + lighting\n){vec4 v4ISect=BezierTriISect(u,d,a,b)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;vec3 hotPos=normalize(vec3(.7)),hot=vec3(1.,.5,.3),cold=vec3(.3,.4,.8),c=vec3(0);float A=0.\n ;if(v4ISect.w<=1.\n){vec3 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b)//analytical first derivative\n  ;c=hot *max(0.,dot(n,hotPos))+cold*max(0.,dot(n,-hotPos))+.2*vec3(.5)\n  ;A=1.;}return vec4(c,A);}\nfloat sp(vec3 u,vec3 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera. //cameraPos,Sphere\n){u-=s.xyz;float a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nfloat ComputeOverlay(vec3 u,vec3 d,vec3 a,vec3 b){return sp(u,d,vec4(p1,a.x,.2))+sp(u,d,vec4((p1+p2)*.5,b.z,.2))\n +sp(u,d,vec4(p2,a.y,.2))+sp(u,d,vec4((p3+p1)*.5,b.y,.2))+sp(u,d,vec4(p3,a.z,.2))+sp(u,d,vec4((p2+p3)*.5,b.x,.2));}\nvec3 GetCameraPos(//mouse.xy moves camera\n){vec2 v2Mouse=vec2(0);return normalize(vec3(sin(iTime*.1),cos(iTime*.1),-1.))*10.;}\nvec3 GetLookDir(vec3 u,vec2 fragCoord \n){float fScale=tan(H_FOV_RADIANS),r=iResolution.x/iResolution.y\n ;vec2 v2Screen=(2.*(fragCoord.xy/iResolution.xy)-1.)*vec2(r,1.)*fScale\n ;vec3 l=normalize(-u),e=cross(vec3(0,0,1),l)\n ;return normalize(l+e*v2Screen.x+cross(l,e)*v2Screen.y);}\n \nvoid mainImage(out vec4 o,vec2 u \n){vec3 v=GetCameraPos()\n ;vec3 d=GetLookDir(v,u)//next 2 vec3 set the heoights of 6 cv.\n ;vec3 a=vec3(f200*sin(iTime),f020*sin(iTime*1.2),f002*sin(iTime)*.9)//set 3 corrner CV-heights\n ;vec3 b=vec3(f011*sin(iTime*2.0),f101*sin(iTime*1.1),f110*sin(iTime))//set 3 midpoint CV-heights\n ;vec4 c=ComputeBezierColor(v,d,a,b)\n ;c=mix(vec4(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;c.xyz=mix(c.xyz,cd,.2)//debug color coding\n ;o=mix(c,vec4(.7,.7,.7,1),ComputeOverlay(v,d,a,b));}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}