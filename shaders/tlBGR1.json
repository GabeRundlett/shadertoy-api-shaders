{
    "Shader": {
        "info": {
            "date": "1558530508",
            "description": "I was curious how many reflections and shadow tests I can with a simple ray-marcher. I've avoided doing this kind of scene before because I thought the shader would be too slow and take too long to compile, but actually it's fine!",
            "flags": 0,
            "hasliked": 0,
            "id": "tlBGR1",
            "likes": 34,
            "name": "Blob in a Mirrored Room",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "blob"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1534
        },
        "renderpass": [
            {
                "code": "// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// how deep do the reflections go\nconst int maxBounces = 15;\n\n\n// control the tracer precision and efficiency\nconst float traceStartDistance = .01;\nconst int traceLoopCount = 200;\nconst float shadowStartDistance = .1;\nconst int shadowLoopCount = 50;\n\n\n// polished copper\n//const vec3 blobAlbedo = vec3(0); const vec3 blobSpecColour = vec3(.8,.3,.2); const float blobMaxSpecular = 1.;\n// shiny white\nconst vec3 blobAlbedo = vec3(1); const vec3 blobSpecColour = vec3(.02); const float blobMaxSpecular = 1.;  //.02 = schlick(1.33)\n// chocolate\n//const vec3 blobAlbedo = vec3(.2,.03,.01); const vec3 blobSpecColour = vec3(.007); const float blobMaxSpecular = .5;\n\n\n\nconst vec2 quasirand2 = vec2(.754877666247,.569840290998); // from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n\nstruct Light\n{\n    vec3 pos;\n    vec3 colour;\n};\n    \nLight lights[] = Light[]\n    (\n         Light( vec3(1,2,-3), vec3(1)*8. )\n        ,Light( vec3(-1,-.5,-1), vec3(1,.1,0)*1. )\n        ,Light( vec3(.5,-.9,-.5), vec3(0,.3,1)*.3 )\n\t);\n\n\nfloat Mat1SDF( vec3 p )\n{\n    // 4 walls\n    float f = -abs(p.x-2.5)-(-4.);\n    f = min(f, -abs(p.z+1.)-(-5.) );\n    \n    // 4 more walls at 45 degrees for more interesting reflections!\n    f = min(f, -abs((p.z+p.x)*.7071+1.)-(-5.) );\n    f = min(f, -abs((p.z-+p.x)*.7071+1.5)-(-4.5) );\n\n    return f;\n}\n\n\nfloat Mat2SDF( vec3 p )\n{\n    // blob\n    vec3 p1 = p - .7*sin(vec3(1,quasirand2)*iTime);\n\tvec3 p2 = p - .7*sin(vec3(1,quasirand2)*iTime*quasirand2.x);\n\tvec3 p3 = p - .7*sin(vec3(1,quasirand2)*iTime*quasirand2.y);\n    \n    float r = .0;\n    float a = length(p )-.8+.4;\n    float b = length(p1)-.5+.4;\n    float c = length(p2)-.5+.4;\n    float d = length(p3)-.5+.4;\n    \n    // I based this on a smooth-min function, it didn't work as intended but it's pretty!\n    float avg = (a+b+c+d)/4.;\n    a -= avg;\n    b -= avg;\n    c -= avg;\n    d -= avg;\n    return (avg - sqrt( a*a+b*b+c*c+d*d+r*r ))*.8;\n}\n\nfloat Mat3SDF( vec3 p )\n{\n    // floor\n    return -abs(p.y-1.)-(-2.);\n}\n\nfloat SDF( vec3 p )\n{\n    return min(min(Mat1SDF(p),Mat2SDF(p)),Mat3SDF(p));\n}\n\n\nvec3 Trace( in vec3 p, in vec3 ray )\n{\n    p += ray*traceStartDistance;\n    float epsilon = .001;\n    float h = 1.;\n    for ( int i=0; i < traceLoopCount; i++ )\n    {\n        if ( h < epsilon )\n            break;\n        h = SDF(p);\n        p += ray*h;\n    }\n    return p;\n}\n\n\nfloat Shadow( in vec3 p, in vec3 toLight )\n{\n    const float softness = 1.;\n    toLight = toLight-p;\n    float l = length(toLight);\n    vec3 ray = toLight/l;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float minh = 1e30;\n    for ( int i=0; i < shadowLoopCount; i++ )\n    {\n        if ( h < epsilon || t > l )\n            break;\n        h = SDF(p+ray*t);\n        minh = min(minh,h/max(t*softness,1.));\n        t += h;\n    }\n    return smoothstep(epsilon,.03,minh);\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*.001;\n    return normalize(\n            SDF(p+d.xxx)*d.xxx +\n            SDF(p+d.yyx)*d.yyx +\n            SDF(p+d.yxy)*d.yxy +\n            SDF(p+d.xyy)*d.xyy\n        );\n}\n\n\nvoid Shading( out vec3 bounce, out vec3 bounceTint, out vec3 diffuse, in vec3 p, in vec3 ray )\n{\n    vec3 normal = GetNormal(p);\n    \n    vec3 light = vec3(0);\n    for( int i=0; i < lights.length(); i++ )\n    {\n        vec3 toLight = lights[i].pos - p;\n\n        float nDotL = dot(normal,toLight);\n        if ( nDotL <= 0. ) continue;\n\n        float l = max(nDotL/pow(dot(toLight,toLight),3./2.),0.);\n\n        l *= Shadow(p,lights[i].pos);\n        \n        light += lights[i].colour * l;\n    }\n    \n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0.,SDF(p+normal*.3)/.3-1.));\n    ao *= exp2(min(0.,SDF(p+normal*.15)/.15-1.));\n    ao *= exp2(min(0.,SDF(p+normal*.07)/.07-1.));\n    light += ao;\n    \n    // get material\n    vec3 albedo = vec3(.3,.5,.6)*.4;\n    vec4 specLevel = vec4(vec3(.9),1);\n    \n    // put a pattern on the walls, so they're visible\n//    albedo *= 1.-.5*pow(texture(iChannel0,vec2(p.y,p.x+p.z)/2.).rgb,vec3(.2));\n    specLevel.rgb = vec3(mix( .8, .95, texture(iChannel0,vec2(p.y,p.x+p.z)/2.).g ));\n//    normal = normalize( normal + (texture(iChannel0,vec2(p.y,p.x+p.z)/2.).rgb-.5)*.002 );\n    \n    // frame the mirrors - so we can read the scene better\n    float frame = .07;\n    if ( abs(p.y-1.) > 2.-frame )//|| abs(p.x-2.5)+abs(p.z+1.) > 9.-frame )\n    {\n        albedo = vec3(.1);\n        specLevel = vec4(0);\n    }\n    \n    float mat1sdf = Mat1SDF(p);\n    float mat2sdf = Mat2SDF(p);\n    if ( mat2sdf < mat1sdf )\n    {\n        // main object\n        albedo = blobAlbedo;\n        specLevel = vec4(blobSpecColour,blobMaxSpecular);\n    }\n    \n    if ( Mat3SDF(p) < min(mat1sdf,mat2sdf) )\n    {\n        // floor\n        vec2 uv = p.xz;\n        uv = uv*cos(.3)+sin(.3)*vec2(-1,1)*uv.yx;\n        albedo = mix( vec3(.01), vec3(1), step(.0,(fract(uv.x/1.)-.5)*(fract(uv.y/1.)-.5)) );\n        float ior = 1.33;\n        float schlick = pow((ior-1.)/(ior+1.),2.);\n\t    specLevel = vec4(vec3(schlick),1);\n    \tspecLevel *= mix( .2, .7, texture(iChannel0,vec2(p.xz)/2.).g );\n    \tnormal = normalize( normal + (texture(iChannel0,vec2(p.xz)/2.).rgb-.5)*.005 );\n    }\n\n    float fresnel = pow(dot(normal,ray)+1.,5.);\n    \n    vec3 spec = mix( specLevel.xyz, specLevel.www, fresnel );\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1)-spec) * light;\n    bounce = reflect(ray,normal);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,2.);\n    ray = normalize(ray);\n    \n    vec3 camPos = vec3(1,0,-4.5) + vec3(1.5,.5,1)*cos(vec3(1,quasirand2).zyx*iTime*.618);\n    \n    vec3 camK = normalize(vec3(0,-.3,0)-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    \n    vec3 pos = camPos;\n    vec3 tint = vec3(1);\n\n    fragColour = vec4(0);\n    for( int bounce=0; bounce < maxBounces; bounce++ ) // gosh this can handle a lot of bounces!\n    {\n        pos = Trace( pos, ray );\n\n        vec3 bounceTint, diffuse;\n        Shading( ray, bounceTint, diffuse, pos, ray );\n        fragColour.rgb += diffuse*tint;\n        tint *= bounceTint;\n        if ( length(tint) < .01 ) break; // early out if reflections aren't visible\n    }\n    \n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    \n    fragColour.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}