{
    "Shader": {
        "info": {
            "date": "1561178992",
            "description": "Baldavenger ACES 1.1 Shadertoy Shader\n\nFull selection of ACES 1.1 transforms, including custom LMT PFE and Output Transforms.\nPorted from ACES source code (CTL) via CUDA, Resolve DCTL, and Matchbox Shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wl23WV",
            "likes": 6,
            "name": "Baldavenger ACES Shadertoy",
            "published": 3,
            "tags": [
                "hdr",
                "aces",
                "colourspace",
                "rrt",
                "idt",
                "odt",
                "colourmanagement",
                "lmt",
                "hlg",
                "st2084",
                "pq",
                "scenereferred",
                "bt1886",
                "p3d60",
                "rec2020"
            ],
            "usePreview": 0,
            "username": "baldavenger",
            "viewed": 961
        },
        "renderpass": [
            {
                "code": "// Baldavenger ACES ShaderToy Shader \n\n// Enter reference code for ACES transforms. Entering 'Bypass' or '00' for\n// last 2 digits enables passthrough. EXPOSURE value is in stops. Custom LMT,\n// RRTODT, and InvRRTODT transform paramaters are also accessible below.\n\n#define ACES_IDT\t\t\t\tIDT100\n#define EXPOSURE\t\t\t\t0.0\n#define ACES_LMT\t\t\t\tLMT200\n#define ACES_RRT\t\t\t\tRRT300\n#define ACES_ODT\t\t\t\tODT400\n\n#define ACES_INVODT\t\t\t\tINVODT500\n#define ACES_INVRRT\t\t\t\tINVRRT600\n#define ACES_RRTODT\t\t\t\tRRTODT700\n#define ACES_INVRRTODT\t\t\tINVRRTODT800\n\n//\n// See mainImage function at bottom of shader for order of opperationa\n//\n\n#define IDT100\t\t\t\tBypass\n#define IDT101\t\t\t\tACEScc_to_ACES(aces)\n#define IDT102\t\t\t\tACEScct_to_ACES(aces)\n#define IDT103\t\t\t\tACEScg_to_ACES(aces)\n#define IDT104\t\t\t\tADX10_to_ACES(aces)\n#define IDT105\t\t\t\tIDT_rec709(aces)\n#define IDT106\t\t\t\tIDT_sRGB(aces)\n#define IDT107\t\t\t\tIDT_Alexa_v3_logC_EI800(aces)\n#define IDT108\t\t\t\tIDT_Alexa_v3_raw_EI800_CCT6500(aces)\n#define IDT109\t\t\t\tIDT_Panasonic_V35(aces)\n#define IDT110\t\t\t\tIDT_REDWideGamutRGB_Log3G10(aces)\n#define IDT111\t\t\t\tIDT_Canon_C100_A_D55(aces)\n#define IDT112\t\t\t\tIDT_Canon_C100_A_Tng(aces)\n#define IDT113\t\t\t\tIDT_Canon_C100mk2_A_D55(aces)\n#define IDT114\t\t\t\tIDT_Canon_C100mk2_A_Tng(aces)\n#define IDT115\t\t\t\tIDT_Canon_C300_A_D55(aces)\n#define IDT116\t\t\t\tIDT_Canon_C300_A_Tng(aces)\n#define IDT117\t\t\t\tIDT_Canon_C500_A_D55(aces)\n#define IDT118\t\t\t\tIDT_Canon_C500_A_Tng(aces)\n#define IDT119\t\t\t\tIDT_Canon_C500_B_D55(aces)\n#define IDT120\t\t\t\tIDT_Canon_C500_B_Tng(aces)\n#define IDT121\t\t\t\tIDT_Canon_C500_CinemaGamut_A_D55(aces)\n#define IDT122\t\t\t\tIDT_Canon_C500_CinemaGamut_A_Tng(aces)\n#define IDT123\t\t\t\tIDT_Canon_C500_DCI_P3_A_D55(aces)\n#define IDT124\t\t\t\tIDT_Canon_C500_DCI_P3_A_Tng(aces)\n#define IDT125\t\t\t\tIDT_Canon_C300mk2_CanonLog_BT2020_D_D55(aces)\n#define IDT126\t\t\t\tIDT_Canon_C300mk2_CanonLog_BT2020_D_Tng(aces)\n#define IDT127\t\t\t\tIDT_Canon_C300mk2_CanonLog_CinemaGamut_C_D55(aces)\n#define IDT128\t\t\t\tIDT_Canon_C300mk2_CanonLog_CinemaGamut_C_Tng(aces)\n#define IDT129\t\t\t\tIDT_Canon_C300mk2_CanonLog2_BT2020_B_D55(aces)\n#define IDT130\t\t\t\tIDT_Canon_C300mk2_CanonLog2_BT2020_B_Tng(aces)\n#define IDT131\t\t\t\tIDT_Canon_C300mk2_CanonLog2_CinemaGamut_A_D55(aces)\n#define IDT132\t\t\t\tIDT_Canon_C300mk2_CanonLog2_CinemaGamut_A_Tng(aces)\n#define IDT133\t\t\t\tIDT_Canon_C300mk2_CanonLog3_BT2020_F_D55(aces)\n#define IDT134\t\t\t\tIDT_Canon_C300mk2_CanonLog3_BT2020_F_Tng(aces)\n#define IDT135\t\t\t\tIDT_Canon_C300mk2_CanonLog3_CinemaGamut_E_D55(aces)\n#define IDT136\t\t\t\tIDT_Canon_C300mk2_CanonLog3_CinemaGamut_E_Tng(aces)\n#define IDT137\t\t\t\tIDT_Sony_SLog1_SGamut_10(aces)\n#define IDT138\t\t\t\tIDT_Sony_SLog1_SGamut_12(aces)\n#define IDT139\t\t\t\tIDT_Sony_SLog2_SGamut_Daylight_10(aces)\n#define IDT140\t\t\t\tIDT_Sony_SLog2_SGamut_Daylight_12(aces)\n#define IDT141\t\t\t\tIDT_Sony_SLog2_SGamut_Tungsten_10(aces)\n#define IDT142\t\t\t\tIDT_Sony_SLog2_SGamut_Tungsten_12(aces)\n#define IDT143\t\t\t\tIDT_Sony_SLog3_SGamut3(aces)\n#define IDT144\t\t\t\tIDT_Sony_SLog3_SGamut3Cine(aces)\n\n#define LMT200\t\t\t\tBypass\n#define LMT201\t\t\t\tLMT_PFE(aces)\n#define LMT202\t\t\t\tLMT_Bleach(aces)\n#define LMT203\t\t\t\tLMT_BlueLightArtifactFix(aces)\n#define LMT204\t\t\t\tLMT_PFE_Custom(aces)\n\n#define RRT300\t\t\t\tBypass\n#define RRT301\t\t\t\tRRT(aces)\n\n#define ODT400\t\t\t\tBypass\n#define ODT401\t\t\t\tACES_to_ACEScc(aces)\n#define ODT402\t\t\t\tACES_to_ACEScct(aces)\n#define ODT403\t\t\t\tACES_to_ACEScg(aces)\n#define ODT404\t\t\t\tODT_Rec709_100nits_dim(aces)\n#define ODT405\t\t\t\tODT_Rec709_D60sim_100nits_dim(aces)\n#define ODT406\t\t\t\tODT_Rec2020_100nits_dim(aces)\n#define ODT407\t\t\t\tODT_Rec2020_ST2084_1000nits(aces)\n#define ODT408\t\t\t\tODT_Rec2020_Rec709limited_100nits_dim(aces)\n#define ODT409\t\t\t\tODT_Rec2020_P3D65limited_100nits_dim(aces)\n#define ODT410\t\t\t\tODT_sRGB_100nits_dim(aces)\n#define ODT411\t\t\t\tODT_sRGB_D60sim_100nits_dim(aces)\n#define ODT412\t\t\t\tODT_P3DCI_48nits(aces)\n#define ODT413\t\t\t\tODT_P3DCI_D60sim_48nits(aces)\n#define ODT414\t\t\t\tODT_P3DCI_D65sim_48nits(aces)\n#define ODT415\t\t\t\tODT_P3D60_48nits(aces)\n#define ODT416\t\t\t\tODT_P3D65_48nits(aces)\n#define ODT417\t\t\t\tODT_P3D65_D60sim_48nits(aces)\n#define ODT418\t\t\t\tODT_P3D65_Rec709limited_48nits(aces)\n#define ODT419\t\t\t\tODT_DCDM(aces)\n#define ODT420\t\t\t\tODT_DCDM_P3D60limited(aces)\n#define ODT421\t\t\t\tODT_DCDM_P3D65limited(aces)\n#define ODT422\t\t\t\tODT_RGBmonitor_100nits_dim(aces)\n#define ODT423\t\t\t\tODT_RGBmonitor_D60sim_100nits_dim(aces)\n\n#define INVODT500\t\t\tBypass\n#define INVODT501\t\t\tInvODT_Rec709_100nits_dim(aces)\n#define INVODT502\t\t\tInvODT_Rec709_D60sim_100nits_dim(aces)\n#define INVODT503\t\t\tInvODT_Rec2020_100nits_dim(aces)\n#define INVODT504\t\t\tInvODT_Rec2020_ST2084_1000nits(aces)\n#define INVODT505\t\t\tInvODT_sRGB_100nits_dim(aces)\n#define INVODT506\t\t\tInvODT_sRGB_D60sim_100nits_dim(aces)\n#define INVODT507\t\t\tInvODT_P3DCI_48nits(aces)\n#define INVODT508\t\t\tInvODT_P3DCI_D60sim_48nits(aces)\n#define INVODT509\t\t\tInvODT_P3DCI_D65sim_48nits(aces)\n#define INVODT510\t\t\tInvODT_P3D60_48nits(aces)\n#define INVODT511\t\t\tInvODT_P3D65_48nits(aces)\n#define INVODT512\t\t\tInvODT_P3D65_D60sim_48nits(aces)\n#define INVODT513\t\t\tInvODT_DCDM(aces)\n#define INVODT514\t\t\tInvODT_DCDM_P3D65limited(aces)\n#define INVODT515\t\t\tInvODT_RGBmonitor_100nits_dim(aces)\n#define INVODT516\t\t\tInvODT_RGBmonitor_D60sim_100nits_dim(aces)\n\n#define INVRRT600\t\t\tBypass\n#define INVRRT601\t\t\tInvRRT(aces)\n\n#define RRTODT700\t\t\tBypass\n#define RRTODT701\t\t\tRRTODT_P3D65_108nits_7_2nits_ST2084(aces)\n#define RRTODT702\t\t\tRRTODT_Rec2020_1000nits_15nits_HLG(aces)\n#define RRTODT703\t\t\tRRTODT_Rec2020_1000nits_15nits_ST2084(aces)\n#define RRTODT704\t\t\tRRTODT_Rec2020_2000nits_15nits_ST2084(aces)\n#define RRTODT705\t\t\tRRTODT_Rec2020_4000nits_15nits_ST2084(aces)\n#define RRTODT706\t\t\tRRTODT_Rec709_100nits_10nits_BT1886(aces)\n#define RRTODT707\t\t\tRRTODT_Rec709_100nits_10nits_sRGB(aces)\n#define RRTODT708\t\t\tCustom_OutputTransform(aces, p_OT_Y_MIN, p_OT_Y_MID, p_OT_Y_MAX, p_OT_Display, p_OT_Limit, p_OT_EOTF, p_OT_SURROUND, p_OT_Stretch, p_OT_D60_SIM, p_OT_Legal)\n\n#define INVRRTODT800\t\tBypass\n#define INVRRTODT801\t\tInvRRTODT_P3D65_108nits_7_2nits_ST2084(aces)\n#define INVRRTODT802\t\tInvRRTODT_Rec2020_1000nits_15nits_HLG(aces)\n#define INVRRTODT803\t\tInvRRTODT_Rec2020_1000nits_15nits_ST2084(aces)\n#define INVRRTODT804\t\tInvRRTODT_Rec2020_2000nits_15nits_ST2084(aces)\n#define INVRRTODT805\t\tInvRRTODT_Rec2020_4000nits_15nits_ST2084(aces)\n#define INVRRTODT806\t\tInvRRTODT_Rec709_100nits_10nits_BT1886(aces)\n#define INVRRTODT807\t\tInvRRTODT_Rec709_100nits_10nits_sRGB(aces)\n#define INVRRTODT808\t\tCustom_InvOutputTransform(aces, p_InvOT_Y_MIN, p_InvOT_Y_MID, p_InvOT_Y_MAX, p_InvOT_Display, p_InvOT_Limit, p_InvOT_EOTF, p_InvOT_SURROUND, p_InvOT_Stretch, p_InvOT_D60_SIM, p_InvOT_Legal)\n\n#define Bypass\t\t\t\taces\n\n//\n//\tCustom LMT parameters\n//\nfloat p_LMTScale1 = 1.0;\t//\tScale Colour\nfloat p_LMTScale2 = 1.0;\t// \tSlope\nfloat p_LMTScale3 = 0.0;\t// \tOffset\nfloat p_LMTScale4 = 1.0;\t//\tPower\nfloat p_LMTScale5 = 1.0;\t//\tSaturation\nfloat p_LMTScale6 = 1.0;\t//\tContrast\nfloat p_LMTScale7 = 0.18;\t//\tPivot\nfloat p_LMTScale8 = 30.0;\t//\tHue Vs Hue Hue1\nfloat p_LMTScale9 = 60.0;\t//\tHue Vs Hue Range1\nfloat p_LMTScale10 = 0.0;\t//\tHue Vs Hue Rotation1\nfloat p_LMTScale11 = 210.0;\t//\tHue Vs Hue Hue2\nfloat p_LMTScale12 = 60.0;\t//\tHue Vs Hue Range2\nfloat p_LMTScale13 = 0.0;\t//\tHue Vs Hue Rotation2\nfloat p_LMTScale14 = 120.0;\t//\tHue Vs Hue Hue3\nfloat p_LMTScale15 = 60.0;\t//\tHue Vs Hue Range3\nfloat p_LMTScale16 = 0.0;\t//\tHue Vs Hue Rotation3\nfloat p_LMTScale17 = 30.0;\t// \tHue Vs Sat Hue1\nfloat p_LMTScale18 = 60.0;\t// \tHue Vs Sat Range1\nfloat p_LMTScale19 = 1.0;\t// \tHue Vs Sat Saturation Scale1\nfloat p_LMTScale20 = 0.0;\t//\tHue Vs Hue Hue4\nfloat p_LMTScale21 = 60.0;\t//\tHue Vs Hue Range4\nfloat p_LMTScale22 = 0.0;\t//\tHue Vs Hue Rotation4\nfloat p_LMTScale23 = 210.0;\t// \tHue Vs Sat Hue2\nfloat p_LMTScale24 = 60.0;\t// \tHue Vs Sat Range1\nfloat p_LMTScale25 = 1.0;\t// \tHue Vs Sat Saturation Scale2\n\n//\n//\tCustom RRTODT parameters\n//\nfloat p_OT_Y_MIN = 0.0001;\nfloat p_OT_Y_MID = 15.0;\nfloat p_OT_Y_MAX = 10000.0;\nint p_OT_Display = 0; \t\t// (0 = REC2020_PRI) (1 = P3D60_PRI) (2 = P3D65_PRI) (3 = P3DCI_PRI) (4 = REC709_PRI)\nint p_OT_Limit = 0;\t  \t\t// (0 = REC2020_PRI) (1 = P3D60_PRI) (2 = P3D65_PRI) (3 = P3DCI_PRI) (4 = REC709_PRI)\nint p_OT_EOTF = 0;\t\t\t// (0 = ST2084) (1 = BT1886) (2 = sRGB) (3 = Gamma 2.6) (4 = Linear) (5 = HLG)\nint p_OT_SURROUND = 1;\t\t// (0 = DARK) (1 = DIM) (2 = NORMAL)\nbool p_OT_Stretch = false;\nbool p_OT_D60_SIM = false;\nbool p_OT_Legal = false;\n\n//\n//\tCustom InvRRTODT parameters\n//\nfloat p_InvOT_Y_MIN = 0.0001;\nfloat p_InvOT_Y_MID = 15.0;\nfloat p_InvOT_Y_MAX = 10000.0;\nint p_InvOT_Display = 0;\t// (0 = REC2020_PRI) (1 = P3D60_PRI) (2 = P3D65_PRI) (3 = P3DCI_PRI) (4 = REC709_PRI)\nint p_InvOT_Limit = 0;\t\t// (0 = REC2020_PRI) (1 = P3D60_PRI) (2 = P3D65_PRI) (3 = P3DCI_PRI) (4 = REC709_PRI)\nint p_InvOT_EOTF = 0;\t\t// (0 = ST2084) (1 = BT1886) (2 = sRGB) (3 = Gamma 2.6) (4 = Linear) (5 = HLG)\nint p_InvOT_SURROUND = 1;\t// (0 = DARK) (1 = DIM) (2 = NORMAL)\nbool p_InvOT_Stretch = false;\nbool p_InvOT_D60_SIM = false;\nbool p_InvOT_Legal = false;\n\nstruct Chromaticities {\nvec2 red,green,blue,white;\n};\n\nstruct SplineMapPoint {\nfloat x,y;\n};\n    \nstruct float5 {\nfloat x,y,z,w,m;\n};\n\nstruct float6 {\nfloat a,b,c,d,e,f;\n};\n\nstruct float10 {\nfloat a,b,c,d,e,f,g,h,i,j;\n};\n\nstruct SegmentedSplineParams_c5 {\nfloat6 coefsLow,coefsHigh;\nSplineMapPoint minPoint,midPoint,maxPoint;\nfloat slopeLow,slopeHigh;\n};\n    \nstruct SegmentedSplineParams_c9 {\nfloat10 coefsLow,coefsHigh;\nSplineMapPoint minPoint,midPoint,maxPoint;\nfloat slopeLow,slopeHigh;\n};\n\nstruct TsPoint {\nfloat x; float y; float slope;\n};\n\nstruct TsParams {\nTsPoint Min; TsPoint Mid; TsPoint Max;\nfloat6 coefsLow; float6 coefsHigh;\n};\n\n#define REF_PT\t\t\t\t((7120.0 - 1520.0) / 8000.0 * (100.0 / 55.0) - log10(0.18)) * 1.0\n#define AP0_2_XYZ_MAT\t\tRGBtoXYZ(AP0)\n#define XYZ_2_AP0_MAT\t\tXYZtoRGB(AP0)\n#define AP1_2_XYZ_MAT\t\tRGBtoXYZ(AP1)\n#define XYZ_2_AP1_MAT\t\tXYZtoRGB(AP1)\n#define AP0_2_AP1_MAT\t\tXYZ_2_AP1_MAT * AP0_2_XYZ_MAT\n#define AP1_2_AP0_MAT\t\tXYZ_2_AP0_MAT * AP1_2_XYZ_MAT\n#define AP1_RGB2Y\t\t\tvec3(AP1_2_XYZ_MAT[0][1], AP1_2_XYZ_MAT[1][1], AP1_2_XYZ_MAT[2][1])\n#define ODT_SAT_MAT\t\t\tcalc_sat_adjust_matrix( ODT_SAT_FACTOR, AP1_RGB2Y)\n#define D60_2_D65_CAT\t\tcalculate_cat_matrix( AP0.white, REC709_PRI.white)\n#define RRT_SAT_MAT\t\t\tcalc_sat_adjust_matrix( RRT_SAT_FACTOR, AP1_RGB2Y)\n#define CINEMA_WHITE\t\t48.0\n#define CINEMA_BLACK\t\tpow(10.0, log10(0.02))\n\nmat3 MM = mat3( vec3(0.5, -1.0, 0.5), vec3(-1.0, 1.0, 0.5), vec3(0.5, 0.0, 0.0) );\nfloat TINY = 1e-10;\nfloat DIM_SURROUND_GAMMA = 0.9811;\nfloat ODT_SAT_FACTOR = 0.93;\nfloat MIN_STOP_SDR = -6.5;\nfloat MAX_STOP_SDR = 6.5;\nfloat MIN_STOP_RRT = -15.0;\nfloat MAX_STOP_RRT = 18.0;\nfloat MIN_LUM_SDR = 0.02;\nfloat MAX_LUM_SDR = 48.0;\nfloat MIN_LUM_RRT = 0.0001;\nfloat MAX_LUM_RRT = 10000.0;\nfloat RRT_GLOW_GAIN = 0.05;\nfloat RRT_GLOW_MID = 0.08;\nfloat RRT_RED_SCALE = 0.82;\nfloat RRT_RED_PIVOT = 0.03;\nfloat RRT_RED_HUE = 0.0;\nfloat RRT_RED_WIDTH = 135.0;\nfloat RRT_SAT_FACTOR = 0.96;\nfloat X_BRK = 0.0078125;\nfloat Y_BRK = 0.155251141552511;\nfloat A = 10.5402377416545;\nfloat B = 0.0729055341958355;\nfloat sqrt3over4 = 0.433012701892219;\nfloat pq_m1 = 0.1593017578125;\nfloat pq_m2 = 78.84375;\nfloat pq_c1 = 0.8359375;\nfloat pq_c2 = 18.8515625;\nfloat pq_c3 = 18.6875;\nfloat pq_C = 10000.0;\n\nmat3 CDD_TO_CID = mat3(\nvec3(0.75573, 0.05901, 0.16134),\nvec3(0.22197, 0.96928, 0.07406), \nvec3(0.02230, -0.02829, 0.76460)\n);\n\nmat3 EXP_TO_ACES = mat3(\nvec3(0.72286, 0.11923, 0.01427),\nvec3(0.12630, 0.76418, 0.08213),\nvec3(0.15084, 0.11659, 0.90359)\n);\n\nChromaticities AP0 = Chromaticities(\nvec2(0.7347, 0.2653),vec2(0.0, 1.0),\nvec2(0.0001, -0.077),vec2(0.32168, 0.33767)\n);\n\nChromaticities AP1 = Chromaticities(\nvec2(0.713, 0.293),vec2(0.165, 0.83),\nvec2(0.128, 0.044),vec2(0.32168, 0.33767)\n);\n\nChromaticities REC709_PRI = Chromaticities(\nvec2(0.64, 0.33),vec2(0.3, 0.6),\nvec2(0.15, 0.06),vec2(0.3127, 0.329)\n);\n\nChromaticities P3D60_PRI = Chromaticities(\nvec2(0.68, 0.32),vec2(0.265, 0.69),\nvec2(0.15, 0.06),vec2(0.32168, 0.33767)\n);\nChromaticities P3D65_PRI = Chromaticities(\nvec2(0.68, 0.32),vec2(0.265, 0.69),\nvec2(0.15, 0.06),vec2(0.3127, 0.329)\n);\n\nChromaticities P3DCI_PRI = Chromaticities(\nvec2(0.68, 0.32),vec2(0.265, 0.69),\nvec2(0.15, 0.06),vec2(0.314, 0.351)\n);\n\nChromaticities ARRI_ALEXA_WG_PRI = Chromaticities(\nvec2(0.684, 0.313),vec2(0.221, 0.848),\nvec2(0.0861, -0.102),vec2(0.3127, 0.329)\n);\n\nChromaticities REC2020_PRI = Chromaticities(\nvec2(0.708, 0.292),vec2(0.17, 0.797),\nvec2(0.131, 0.046),vec2(0.3127, 0.329)\n);\n\nChromaticities RIMMROMM_PRI = Chromaticities(\nvec2(0.7347, 0.2653),vec2(0.1596, 0.8404),\nvec2(0.0366, 0.0001),vec2(0.3457, 0.3585)\n);\n\nmat3 CONE_RESP_MAT_BRADFORD = mat3(\nvec3(0.8951, -0.7502, 0.0389),\nvec3(0.2664, 1.7135, -0.0685),\nvec3(-0.1614, 0.0367, 1.0296)\n);\n\nmat3 CONE_RESP_MAT_CAT02 = mat3(\nvec3(0.7328, -0.7036, 0.003),\nvec3(0.4296, 1.6975, 0.0136),\nvec3(-0.1624, 0.0061, 0.9834)\n);\n\nmat3 AP1_2_AP0_MAT_B = mat3(\nvec3(0.6954522414, 0.0447945634, -0.0055258826), \nvec3(0.1406786965, 0.8596711185, 0.0040252103), \nvec3(0.1638690622, 0.0955343182, 1.0015006723) );\n\n\nfloat data6[6];\nfloat data10[10];\n\nfloat getData6(int id) {\nfor (int i=0; i<6; i++) {\nif (i == id) return data6[i];\n}}\n\nfloat getData10(int id) {\nfor (int i=0; i<10; i++) {\nif (i == id) return data10[i];\n}}\n\nfloat min_f3( vec3 a)\n{\nreturn min( a.x, min( a.y, a.z));\n}\n\nfloat max_f3( vec3 a)\n{\nreturn max( a.x, max( a.y, a.z));\n}\n\nfloat log10( float x) {\nreturn (1.0 / log(10.0)) * log(x);\n}\n\nfloat clip( float v)\n{\nreturn min(v, 1.0);\n}\n\nvec3 clip_f3( vec3 ya)\n{\nvec3 Out;\nOut.x = clip( ya.x); Out.y = clip( ya.y); Out.z = clip( ya.z);\nreturn Out;\n}\n\nvec3 pow_f3( vec3 a, float b)\n{\nvec3 Out;\nOut.x = pow(a.x, b); Out.y = pow(a.y, b); Out.z = pow(a.z, b);\nreturn Out;\n}\n\nfloat pow10( float x)\n{\nreturn pow(10.0, x);\n}\n\nvec3 pow10_f3( vec3 a)\n{\nvec3 Out;\nOut.x = pow10(a.x); Out.y = pow10(a.y); Out.z = pow10(a.z);\nreturn Out;\n}\n\nvec3 log10_f3( vec3 a)\n{\nvec3 Out;\nOut.x = log10(a.x); Out.y = log10(a.y); Out.z = log10(a.z);\nreturn Out;\n}\n\nfloat _sign( float x)\n{\nfloat y;\nif (x < 0.0) y = -1.0;\nelse if (x > 0.0) y = 1.0;\nelse y = 0.0;\nreturn y;\n}\n\nmat3 invert_f33( mat3 A) {\nmat3 R;\nmat3 result;\nmat3 a = mat3(vec3(A[0][0], A[0][1], A[0][2]),\nvec3(A[1][0], A[1][1], A[1][2]),\nvec3(A[2][0], A[2][1], A[2][2]));\nfloat det =   a[0][0] * a[1][1] * a[2][2]\n+ a[0][1] * a[1][2] * a[2][0]\n+ a[0][2] * a[1][0] * a[2][1]\n- a[2][0] * a[1][1] * a[0][2]\n- a[2][1] * a[1][2] * a[0][0]\n- a[2][2] * a[1][0] * a[0][1];\nif( det != 0.0 )\n{\nresult[0][0] = a[1][1] * a[2][2] - a[1][2] * a[2][1];\nresult[0][1] = a[2][1] * a[0][2] - a[2][2] * a[0][1];\nresult[0][2] = a[0][1] * a[1][2] - a[0][2] * a[1][1];\nresult[1][0] = a[2][0] * a[1][2] - a[1][0] * a[2][2];\nresult[1][1] = a[0][0] * a[2][2] - a[2][0] * a[0][2];\nresult[1][2] = a[1][0] * a[0][2] - a[0][0] * a[1][2];\nresult[2][0] = a[1][0] * a[2][1] - a[2][0] * a[1][1];\nresult[2][1] = a[2][0] * a[0][1] - a[0][0] * a[2][1];\nresult[2][2] = a[0][0] * a[1][1] - a[1][0] * a[0][1];\nR = mat3(vec3(result[0][0], result[0][1], result[0][2]), \nvec3(result[1][0], result[1][1], result[1][2]), vec3(result[2][0], result[2][1], result[2][2]));\nreturn (1.0 / det) * R;\n}\nR = mat3(vec3(1.0, 0.0, 0.0), \nvec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\nreturn R;\n}\n\nfloat interpolate1D( mat2 table, float p) {\nif( p <= table[0][0] ) return table[0][1];\nif( p >= table[1][0] ) return table[1][1];\nif( table[0][0] <= p && p < table[1][0] ){\nfloat s = (p - table[0][0]) / (table[1][0] - table[0][0]);\nreturn table[0][1] * ( 1.0 - s ) + table[1][1] * s;\n}\nreturn 0.0;\n}\n\nfloat interpolate1D11( float tableIN[11], float tableOUT[11], float p) {\nif( p <= tableIN[0] ) return tableOUT[0];\nif( p >= tableIN[10] ) return tableOUT[10];\nfor( int i = 0; i < 10; ++i ){\nif( tableIN[i] <= p && p < tableIN[i+1] )\n{\nfloat s = (p - tableIN[i]) / (tableIN[i+1] - tableIN[i]);\nreturn tableOUT[i] * ( 1.0 - s ) + tableOUT[i+1] * s;\n}}\nreturn 0.0;\n}\n\nmat3 RGBtoXYZ( Chromaticities N) {\nmat3 M = mat3(vec3(N.red.x, N.red.y, 1.0 - (N.red.x + N.red.y)),\nvec3(N.green.x, N.green.y, 1.0 - (N.green.x + N.green.y)),\nvec3(N.blue.x, N.blue.y, 1.0 - (N.blue.x + N.blue.y)));\nvec3 wh = vec3(N.white.x / N.white.y, 1.0, (1.0 - (N.white.x + N.white.y)) / N.white.y);\nwh = invert_f33(M) * wh;\nmat3 WH = mat3(vec3(wh.x, 0.0, 0.0), \nvec3(0.0, wh.y, 0.0), vec3(0.0, 0.0, wh.z));\nM = M * WH;\nreturn M;\n}\n\nmat3 XYZtoRGB( Chromaticities N)\n{\nmat3 M = invert_f33(RGBtoXYZ(N));\nreturn M;\n}\n\nfloat SLog3_to_linear( float SLog )\n{\nfloat Out = 0.0;\nif (SLog >= 171.2102946929 / 1023.0){\nOut = pow(10.0, (SLog * 1023.0 - 420.0) / 261.5) * (0.18 + 0.01) - 0.01;\n} else {\nOut = (SLog * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);}\nreturn Out;\n}\n\nfloat vLogToLinScene( float x)\n{\nfloat cutInv = 0.181;\nfloat b = 0.00873;\nfloat c = 0.241514;\nfloat d = 0.598206;\nif (x <= cutInv)\nreturn (x - 0.125) / 5.6;\nelse\nreturn pow(10.0, (x - d) / c) - b;\n}\n\nfloat SLog1_to_lin( float SLog, float b, float ab, float w)\n{\nfloat lin = 0.0;\nif (SLog >= ab)\nlin = ( pow(10.0, ( ( ( SLog - b) / ( w - b) - 0.616596 - 0.03) / 0.432699)) - 0.037584) * 0.9;\nelse if (SLog < ab)\nlin = ( ( ( SLog - b) / ( w - b) - 0.030001222851889303) / 5.0) * 0.9;\nreturn lin;\n}\n\nfloat SLog2_to_lin( float SLog, float b, float ab, float w)\n{\nfloat lin = 0.0;\nif (SLog >= ab)\nlin = ( 219.0 * ( pow(10.0, ( ( ( SLog - b) / ( w - b) - 0.616596 - 0.03) / 0.432699)) - 0.037584) / 155.0) * 0.9;\nelse if (SLog < ab)\nlin = ( ( ( SLog - b) / ( w - b) - 0.030001222851889303) / 3.53881278538813) * 0.9;\nreturn lin;\n}\n\nfloat CanonLog_to_linear ( float clog)\n{\nfloat Out = 0.0;\nif(clog < 0.12512248)\nOut = -( pow( 10.0, ( 0.12512248 - clog ) / 0.45310179 ) - 1.0 ) / 10.1596;\nelse\nOut = ( pow( 10.0, ( clog - 0.12512248 ) / 0.45310179 ) - 1.0 ) / 10.1596;\nreturn Out;\n}\n\nfloat CanonLog2_to_linear ( float clog2)\n{\nfloat Out = 0.0;\nif(clog2 < 0.092864125)\nOut = -( pow( 10.0, ( 0.092864125 - clog2 ) / 0.24136077 ) - 1.0 ) / 87.099375;\nelse\nOut = ( pow( 10.0, ( clog2 - 0.092864125 ) / 0.24136077 ) - 1.0 ) / 87.099375;\nreturn Out;\n}\n\nfloat CanonLog3_to_linear ( float clog3)\n{\nfloat Out = 0.0;\nif(clog3 < 0.097465473)\nOut = -( pow( 10.0, ( 0.12783901 - clog3 ) / 0.36726845 ) - 1.0 ) / 14.98325;\nelse if(clog3 <= 0.15277891)\nOut = ( clog3 - 0.12512219 ) / 1.9754798;\nelse\nOut = ( pow( 10.0, ( clog3 - 0.12240537 ) / 0.36726845 ) - 1.0 ) / 14.98325;\nreturn Out;\n}\n\nfloat Log3G10_to_linear_2016 ( float log3g10)\n{\nfloat a, b, c, mirror, linear;\na = 0.224282;\nb = 155.975327;\nc = 0.01;\nmirror = 1.0;\nif (log3g10 < 0.0){\nmirror = -1.0;\nlog3g10 = -log3g10;}\nlinear = (pow(10.0, log3g10 / a) - 1.0) / b;\nlinear = linear * mirror - c;\nreturn linear;\n}\n\nfloat Log3G10_to_linear ( float log3g10)\n{\nfloat a, b, c, g, linear;\na = 0.224282; b = 155.975327; c = 0.01; g = 15.1927;\nlinear = log3g10 < 0.0 ? (log3g10 / g) : (pow(10.0, log3g10 / a) - 1.0) / b;\nlinear = linear - c;\nreturn linear;\n}\n\nvec3 XYZ_2_xyY( vec3 XYZ)\n{\nvec3 xyY;\nfloat divisor = (XYZ.x + XYZ.y + XYZ.z);\nif (divisor == 0.0) divisor = 1e-10;\nxyY.x = XYZ.x / divisor;\nxyY.y = XYZ.y / divisor;\nxyY.z = XYZ.y;\nreturn xyY;\n}\n\nvec3 xyY_2_XYZ( vec3 xyY)\n{\nvec3 XYZ;\nXYZ.x = xyY.x * xyY.z / max( xyY.y, 1e-10);\nXYZ.y = xyY.z;\nXYZ.z = (1.0 - xyY.x - xyY.y) * xyY.z / max( xyY.y, 1e-10);\nreturn XYZ;\n}\n\nfloat rgb_2_hue( vec3 rgb)\n{\nfloat hue = 0.0;\nif (rgb.x == rgb.y && rgb.y == rgb.z) {\nhue = 0.0;\n} else {\nhue = (180.0/3.14159265358979323846264338327950288) * atan( sqrt(3.0) * (rgb.y - rgb.z), 2.0 * rgb.x - rgb.y - rgb.z);\n}\nif (hue < 0.0) hue = hue + 360.0;\nreturn hue;\n}\n\nfloat rgb_2_yc( vec3 rgb)\n{\nfloat ycRadiusWeight = 1.75;\nfloat r = rgb.x;\nfloat g = rgb.y;\nfloat b = rgb.z;\nfloat chroma = sqrt(b * (b - g) + g * (g - r) + r * (r - b));\nreturn ( b + g + r + ycRadiusWeight * chroma) / 3.0;\n}\n\nmat3 calculate_cat_matrix( vec2 src_xy, vec2 des_xy) {\nmat3 coneRespMat = CONE_RESP_MAT_BRADFORD;\nvec3 src_xyY = vec3( src_xy.x, src_xy.y, 1.0 );\nvec3 des_xyY = vec3( des_xy.x, des_xy.y, 1.0 );\nvec3 src_XYZ = xyY_2_XYZ( src_xyY );\nvec3 des_XYZ = xyY_2_XYZ( des_xyY );\nvec3 src_coneResp = coneRespMat * src_XYZ;\nvec3 des_coneResp = coneRespMat * des_XYZ;\nmat3 vkMat = mat3(\nvec3( des_coneResp.x / src_coneResp.x, 0.0, 0.0 ),\nvec3( 0.0, des_coneResp.y / src_coneResp.y, 0.0 ),\nvec3( 0.0, 0.0, des_coneResp.z / src_coneResp.z ) );\nmat3 cat_matrix = (vkMat * invert_f33(coneRespMat)) * coneRespMat;\nreturn cat_matrix;\n}\n\nmat3 calc_sat_adjust_matrix( float sat, vec3 rgb2Y) {\nmat3 M;\nM[0][0] = (1.0 - sat) * rgb2Y.x + sat;\nM[1][0] = (1.0 - sat) * rgb2Y.x;\nM[2][0] = (1.0 - sat) * rgb2Y.x;\nM[0][1] = (1.0 - sat) * rgb2Y.y;\nM[1][1] = (1.0 - sat) * rgb2Y.y + sat;\nM[2][1] = (1.0 - sat) * rgb2Y.y;\nM[0][2] = (1.0 - sat) * rgb2Y.z;\nM[1][2] = (1.0 - sat) * rgb2Y.z;\nM[2][2] = (1.0 - sat) * rgb2Y.z + sat;\nmat3 R = mat3(vec3(M[0][0], M[0][1], M[0][2]), \nvec3(M[1][0], M[1][1], M[1][2]), vec3(M[2][0], M[2][1], M[2][2]));\nR = transpose(R);    \nreturn R;\n}\n\nfloat moncurve_f( float x, float gamma, float offs )\n{\nfloat y;\nfloat fs = (( gamma - 1.0) / offs) * pow( offs * gamma / ( ( gamma - 1.0) * ( 1.0 + offs)), gamma);\nfloat xb = offs / ( gamma - 1.0);\nif ( x >= xb)\ny = pow( ( x + offs) / ( 1.0 + offs), gamma);\nelse\ny = x * fs;\nreturn y;\n}\n\nfloat moncurve_r( float y, float gamma, float offs )\n{\nfloat x;\nfloat yb = pow( offs * gamma / ( ( gamma - 1.0) * ( 1.0 + offs)), gamma);\nfloat rs = pow( ( gamma - 1.0) / offs, gamma - 1.0) * pow( ( 1.0 + offs) / gamma, gamma);\nif ( y >= yb)\nx = ( 1.0 + offs) * pow( y, 1.0 / gamma) - offs;\nelse\nx = y * rs;\nreturn x;\n}\n\nvec3 moncurve_f_f3( vec3 x, float gamma, float offs)\n{\nvec3 y;\ny.x = moncurve_f( x.x, gamma, offs); y.y = moncurve_f( x.y, gamma, offs); y.z = moncurve_f( x.z, gamma, offs);\nreturn y;\n}\n\nvec3 moncurve_r_f3( vec3 y, float gamma, float offs)\n{\nvec3 x;\nx.x = moncurve_r( y.x, gamma, offs); x.y = moncurve_r( y.y, gamma, offs); x.z = moncurve_r( y.z, gamma, offs);\nreturn x;\n}\n\nfloat bt1886_f( float V, float gamma, float Lw, float Lb)\n{\nfloat a = pow( pow( Lw, 1.0/gamma) - pow( Lb, 1.0/gamma), gamma);\nfloat b = pow( Lb, 1.0/gamma) / ( pow( Lw, 1.0/gamma) - pow( Lb, 1.0/gamma));\nfloat L = a * pow( max( V + b, 0.0), gamma);\nreturn L;\n}\n\nfloat bt1886_r( float L, float gamma, float Lw, float Lb)\n{\nfloat a = pow( pow( Lw, 1.0/gamma) - pow( Lb, 1.0/gamma), gamma);\nfloat b = pow( Lb, 1.0/gamma) / ( pow( Lw, 1.0/gamma) - pow( Lb, 1.0/gamma));\nfloat V = pow( max( L / a, 0.0), 1.0/gamma) - b;\nreturn V;\n}\n\nvec3 bt1886_f_f3( vec3 V, float gamma, float Lw, float Lb)\n{\nvec3 L;\nL.x = bt1886_f( V.x, gamma, Lw, Lb); L.y = bt1886_f( V.y, gamma, Lw, Lb); L.z = bt1886_f( V.z, gamma, Lw, Lb);\nreturn L;\n}\n\nvec3 bt1886_r_f3( vec3 L, float gamma, float Lw, float Lb)\n{\nvec3 V;\nV.x = bt1886_r( L.x, gamma, Lw, Lb); V.y = bt1886_r( L.y, gamma, Lw, Lb); V.z = bt1886_r( L.z, gamma, Lw, Lb);\nreturn V;\n}\n\nfloat smpteRange_to_fullRange( float ya)\n{\nfloat REFBLACK = ( 64.0 / 1023.0);\nfloat REFWHITE = ( 940.0 / 1023.0);\nreturn (( ya - REFBLACK) / ( REFWHITE - REFBLACK));\n}\n\nfloat fullRange_to_smpteRange( float ya)\n{\nfloat REFBLACK = ( 64.0 / 1023.0);\nfloat REFWHITE = ( 940.0 / 1023.0);\nreturn ( ya * ( REFWHITE - REFBLACK) + REFBLACK );\n}\n\nvec3 smpteRange_to_fullRange_f3( vec3 rgbIn)\n{\nvec3 rgbOut;\nrgbOut.x = smpteRange_to_fullRange( rgbIn.x); rgbOut.y = smpteRange_to_fullRange( rgbIn.y); rgbOut.z = smpteRange_to_fullRange( rgbIn.z);\nreturn rgbOut;\n}\n\nvec3 fullRange_to_smpteRange_f3( vec3 rgbIn)\n{\nvec3 rgbOut;\nrgbOut.x = fullRange_to_smpteRange( rgbIn.x); rgbOut.y = fullRange_to_smpteRange( rgbIn.y); rgbOut.z = fullRange_to_smpteRange( rgbIn.z);\nreturn rgbOut;\n}\n\nvec3 dcdm_decode( vec3 XYZp)\n{\nvec3 XYZ;\nXYZ.x = (52.37/48.0) * pow( XYZp.x, 2.6);\nXYZ.y = (52.37/48.0) * pow( XYZp.y, 2.6);\nXYZ.z = (52.37/48.0) * pow( XYZp.z, 2.6);\nreturn XYZ;\n}\n\nvec3 dcdm_encode( vec3 XYZ)\n{\nvec3 XYZp;\nXYZp.x = pow( (48.0/52.37) * XYZ.x, 1.0/2.6);\nXYZp.y = pow( (48.0/52.37) * XYZ.y, 1.0/2.6);\nXYZp.z = pow( (48.0/52.37) * XYZ.z, 1.0/2.6);\nreturn XYZp;\n}\n\nfloat ST2084_2_Y( float N )\n{\nfloat Np = pow( N, 1.0 / pq_m2 );\nfloat L = Np - pq_c1;\nif ( L < 0.0 )\nL = 0.0;\nL = L / ( pq_c2 - pq_c3 * Np );\nL = pow( L, 1.0 / pq_m1 );\nreturn L * pq_C;\n}\n\nfloat Y_2_ST2084( float C )\n{\nfloat L = C / pq_C;\nfloat Lm = pow( L, pq_m1 );\nfloat N = ( pq_c1 + pq_c2 * Lm ) / ( 1.0 + pq_c3 * Lm );\nN = pow( N, pq_m2 );\nreturn N;\n}\n\nvec3 Y_2_ST2084_f3( vec3 ya)\n{\nvec3 Out;\nOut.x = Y_2_ST2084( ya.x); Out.y = Y_2_ST2084( ya.y); Out.z = Y_2_ST2084( ya.z);\nreturn Out;\n}\n\nvec3 ST2084_2_Y_f3( vec3 ya)\n{\nvec3 Out;\nOut.x = ST2084_2_Y( ya.x); Out.y = ST2084_2_Y( ya.y); Out.z = ST2084_2_Y( ya.z);\nreturn Out;\n}\n\nvec3 ST2084_2_HLG_1000nits_f3( vec3 PQ)\n{\nvec3 displayLinear = ST2084_2_Y_f3( PQ);\nfloat Y_d = 0.2627 * displayLinear.x + 0.6780 * displayLinear.y + 0.0593 * displayLinear.z;\nfloat L_w = 1000.0;\nfloat L_b = 0.0;\nfloat alpha = (L_w - L_b);\nfloat beta = L_b;\nfloat gamma = 1.2;\nvec3 sceneLinear;\nif (Y_d == 0.0) {\nsceneLinear.x = 0.0; sceneLinear.y = 0.0; sceneLinear.z = 0.0;\n} else {\nsceneLinear.x = pow( (Y_d - beta) / alpha, (1.0 - gamma) / gamma) * ((displayLinear.x - beta) / alpha);\nsceneLinear.y = pow( (Y_d - beta) / alpha, (1.0 - gamma) / gamma) * ((displayLinear.y - beta) / alpha);\nsceneLinear.z = pow( (Y_d - beta) / alpha, (1.0 - gamma) / gamma) * ((displayLinear.z - beta) / alpha);\n}\nfloat a = 0.17883277;\nfloat b = 0.28466892;\nfloat c = 0.55991073;\nvec3 HLG;\nif (sceneLinear.x <= 1.0 / 12.0) {\nHLG.x = sqrt(3.0 * sceneLinear.x);\n} else {\nHLG.x = a * log(12.0 * sceneLinear.x-b)+c;\n}\nif (sceneLinear.y <= 1.0 / 12.0) {\nHLG.y = sqrt(3.0 * sceneLinear.y);\n} else {\nHLG.y = a * log(12.0 * sceneLinear.y-b)+c;\n}\nif (sceneLinear.z <= 1.0 / 12.0) {\nHLG.z = sqrt(3.0 * sceneLinear.z);\n} else {\nHLG.z = a * log(12.0 * sceneLinear.z - b) + c;\n}\nreturn HLG;\n}\n\nvec3 HLG_2_ST2084_1000nits_f3( vec3 HLG)\n{\nfloat a = 0.17883277;\nfloat b = 0.28466892;\nfloat c = 0.55991073;\nfloat L_w = 1000.0;\nfloat L_b = 0.0;\nfloat alpha = (L_w - L_b);\nfloat beta = L_b;\nfloat gamma = 1.2;\nvec3 sceneLinear;\nif ( HLG.x >= 0.0 && HLG.x <= 0.5) {\nsceneLinear.x = pow(HLG.x, 2.0) / 3.0;\n} else {\nsceneLinear.x = (exp((HLG.x - c) / a) + b) / 12.0;\n}\nif ( HLG.y >= 0.0 && HLG.y <= 0.5) {\nsceneLinear.y = pow(HLG.y, 2.0) / 3.0;\n} else {\nsceneLinear.y = (exp((HLG.y - c) / a) + b) / 12.0;\n}\nif ( HLG.z >= 0.0 && HLG.z <= 0.5) {\nsceneLinear.z = pow(HLG.z, 2.0) / 3.0;\n} else {\nsceneLinear.z = (exp((HLG.z - c) / a) + b) / 12.0;\n}\nfloat Y_s = 0.2627 * sceneLinear.x + 0.6780 * sceneLinear.y + 0.0593 * sceneLinear.z;\nvec3 displayLinear;\ndisplayLinear.x = alpha * pow( Y_s, gamma - 1.0) * sceneLinear.x + beta;\ndisplayLinear.y = alpha * pow( Y_s, gamma - 1.0) * sceneLinear.y + beta;\ndisplayLinear.z = alpha * pow( Y_s, gamma - 1.0) * sceneLinear.z + beta;\nvec3 PQ = Y_2_ST2084_f3( displayLinear);\nreturn PQ;\n}\nfloat rgb_2_saturation( vec3 rgb)\n{\nreturn ( max( max_f3(rgb), TINY) - max( min_f3(rgb), TINY)) / max( max_f3(rgb), 1e-2);\n}\n\nSegmentedSplineParams_c5 RRT_PARAMS() {\nSegmentedSplineParams_c5 A = SegmentedSplineParams_c5(float6( -4.0, -4.0, -3.1573765773, -0.4852499958, 1.8477324706, 1.8477324706), \nfloat6( -0.7185482425, 2.0810307172, 3.6681241237, 4.0, 4.0, 4.0), SplineMapPoint(0.18 * pow(2.0, -15.0), 0.0001), \nSplineMapPoint(0.18, 4.8), SplineMapPoint(0.18 * pow(2.0, 18.0), 10000.0), 0.0, 0.0);\nreturn A;\n}\n\nfloat segmented_spline_c5_fwd( float x) {\nSegmentedSplineParams_c5 C = RRT_PARAMS();\nconst int N_KNOTS_LOW = 4;\nconst int N_KNOTS_HIGH = 4;\nfloat X = max(x, 0.0);\nfloat logx = log10(X);\nfloat coefsLow[6];\ncoefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;\ncoefsLow[3] = C.coefsLow.d;coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;\nfloat coefsHigh[6];\ncoefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;\ncoefsHigh[3] = C.coefsHigh.d;coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;\nfloat logy;\nif ( logx <= log10(C.minPoint.x) ) { \nlogy = logx * C.slopeLow + (log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );\n} else if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) )) {\nfloat knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(C.minPoint.x))/(log10(C.midPoint.x) - log10(C.minPoint.x));\nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec3 cf;\ndata6[0] = coefsLow[0];data6[1] = coefsLow[1];data6[2] = coefsLow[2];\ndata6[3] = coefsLow[3];data6[4] = coefsLow[4];data6[5] = coefsLow[5];\ncf.x = getData6(j); cf.y = getData6(j + 1); cf.z = getData6(j + 2);\nvec3 monomials = vec3( t * t, t, 1.0 );\nlogy = dot( monomials, cf * transpose(MM));\n} else if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) )) {\nfloat knot_coord = float(N_KNOTS_HIGH-1) * (logx-log10(C.midPoint.x))/(log10(C.maxPoint.x) - log10(C.midPoint.x));\nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec3 cf;\ndata6[0] = coefsHigh[0];data6[1] = coefsHigh[1];data6[2] = coefsHigh[2];\ndata6[3] = coefsHigh[3];data6[4] = coefsHigh[4];data6[5] = coefsHigh[5];\ncf.x = getData6(j); cf.y = getData6(j + 1); cf.z = getData6(j + 2); \nvec3 monomials = vec3(t * t, t, 1.0);\nlogy = dot( monomials, cf * transpose(MM));\n} else {\nlogy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );\n}\nreturn pow(10.0, logy);\n}\n\nSegmentedSplineParams_c9 ODT_48nits() {\nSegmentedSplineParams_c9 A =\nSegmentedSplineParams_c9(float10( -1.6989700043, -1.6989700043, -1.4779, -1.2291, -0.8648, -0.448, 0.00518, 0.4511080334, 0.9113744414, 0.9113744414),\nfloat10( 0.5154386965, 0.8470437783, 1.1358, 1.3802, 1.5197, 1.5985, 1.6467, 1.6746091357, 1.6878733390, 1.6878733390 ),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, -6.5) ),  0.02),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 ), 4.8),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, 6.5) ), 48.0), 0.0, 0.04);\nreturn A;\n}\n\nSegmentedSplineParams_c9 ODT_1000nits() {\nSegmentedSplineParams_c9 A =\nSegmentedSplineParams_c9(float10( -4.9706219331, -3.0293780669, -2.1262, -1.5105, -1.0578, -0.4668, 0.11938, 0.7088134201, 1.2911865799, 1.2911865799 ),\nfloat10( 0.8089132070, 1.1910867930, 1.5683, 1.9483, 2.3083, 2.6384, 2.8595, 2.9872608805, 3.0127391195, 3.0127391195 ),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, -12.0) ), 0.0001),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 ), 10.0),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, 10.0) ), 1000.0), 3.0, 0.06);\nreturn A;\n}\n\nSegmentedSplineParams_c9 ODT_2000nits() {\nSegmentedSplineParams_c9 A =\nSegmentedSplineParams_c9(float10( -4.9706219331, -3.0293780669, -2.1262, -1.5105, -1.0578, -0.4668, 0.11938, 0.7088134201, 1.2911865799, 1.2911865799 ),\nfloat10( 0.8019952042, 1.1980047958, 1.5943, 1.9973, 2.3783, 2.7684, 3.0515, 3.2746293562, 3.3274306351, 3.3274306351 ),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, -12.0) ), 0.0001),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 ), 10.0),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, 11.0) ), 2000.0), 3.0, 0.12);\nreturn A;\n}\n\nSegmentedSplineParams_c9 ODT_4000nits() {\nSegmentedSplineParams_c9 A =\nSegmentedSplineParams_c9(float10( -4.9706219331, -3.0293780669, -2.1262, -1.5105, -1.0578, -0.4668, 0.11938, 0.7088134201, 1.2911865799, 1.2911865799 ),\nfloat10( 0.7973186613, 1.2026813387, 1.6093, 2.0108, 2.4148, 2.8179, 3.1725, 3.5344995451, 3.6696204376, 3.6696204376 ),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, -12.0) ), 0.0001), \nSplineMapPoint(segmented_spline_c5_fwd( 0.18 ), 10.0),\nSplineMapPoint(segmented_spline_c5_fwd( 0.18 * pow(2.0, 12.0) ), 4000.0), 3.0, 0.3);\nreturn A;\n}\n\nfloat segmented_spline_c5_rev( float y) {  \nSegmentedSplineParams_c5 C = RRT_PARAMS();\nconst int N_KNOTS_LOW = 4;\nconst int N_KNOTS_HIGH = 4;\nfloat coefsLow[6];\ncoefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;\ncoefsLow[3] = C.coefsLow.d;coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;\nfloat coefsHigh[6];\ncoefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;\ncoefsHigh[3] = C.coefsHigh.d;coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;\nfloat KNOT_INC_LOW = (log10(C.midPoint.x) - log10(C.minPoint.x)) / float(N_KNOTS_LOW - 1);\nfloat KNOT_INC_HIGH = (log10(C.maxPoint.x) - log10(C.midPoint.x)) / float(N_KNOTS_HIGH - 1);\nfloat KNOT_Y_LOW[ N_KNOTS_LOW];\nfor (int i = 0; i < N_KNOTS_LOW; i += 1) {\nKNOT_Y_LOW[ i] = ( coefsLow[i] + coefsLow[i+1]) / 2.0;};\nfloat KNOT_Y_HIGH[ N_KNOTS_HIGH];\nfor (int i = 0; i < N_KNOTS_HIGH; i += 1) {\nKNOT_Y_HIGH[ i] = ( coefsHigh[i] + coefsHigh[i+1]) / 2.0;};\nfloat logy = log10( max(y,TINY));\nfloat logx;\nif (logy <= log10(C.minPoint.y)) {\nlogx = log10(C.minPoint.x);\n} else if ( (logy > log10(C.minPoint.y)) && (logy <= log10(C.midPoint.y)) ) {\nint j;\nvec3 cf;\nif ( logy > KNOT_Y_LOW[ 0] && logy <= KNOT_Y_LOW[ 1]) {\ncf.x = coefsLow[0];  cf.y = coefsLow[1];  cf.z = coefsLow[2];  j = 0;\n} else if ( logy > KNOT_Y_LOW[ 1] && logy <= KNOT_Y_LOW[ 2]) {\ncf.x = coefsLow[1];  cf[ 1] = coefsLow[2];  cf.z = coefsLow[3];  j = 1;\n} else if ( logy > KNOT_Y_LOW[ 2] && logy <= KNOT_Y_LOW[ 3]) {\ncf.x = coefsLow[2];  cf.y = coefsLow[3];  cf.z = coefsLow[4];  j = 2;\n} \nvec3 tmp = MM * cf;\nfloat a = tmp.x;\nfloat b = tmp.y;\nfloat c = tmp.z;\nc = c - logy;\nfloat d = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -d - b);\nlogx = log10(C.minPoint.x) + ( t + float(j)) * KNOT_INC_LOW;\n} else if ( (logy > log10(C.midPoint.y)) && (logy < log10(C.maxPoint.y)) ) {\nint j;\nvec3 cf;\nif ( logy > KNOT_Y_HIGH[ 0] && logy <= KNOT_Y_HIGH[ 1]) {\ncf.x = coefsHigh[0];  cf.y = coefsHigh[1];  cf.z = coefsHigh[2];  j = 0;\n} else if ( logy > KNOT_Y_HIGH[ 1] && logy <= KNOT_Y_HIGH[ 2]) {\ncf.x = coefsHigh[1];  cf.y = coefsHigh[2];  cf.z = coefsHigh[3];  j = 1;\n} else if ( logy > KNOT_Y_HIGH[ 2] && logy <= KNOT_Y_HIGH[ 3]) {\ncf.x = coefsHigh[2];  cf.y = coefsHigh[3];  cf.z = coefsHigh[4];  j = 2;\n} \nvec3 tmp = MM * cf;\nfloat a = tmp.x;\nfloat b = tmp.y;\nfloat c = tmp.z;\nc = c - logy;\nfloat d = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -d - b);\nlogx = log10(C.midPoint.x) + ( t + float(j)) * KNOT_INC_HIGH;\n} else {\nlogx = log10(C.maxPoint.x);\n}\nreturn pow(10.0, logx);\n}\n\nfloat segmented_spline_c9_fwd( float x, SegmentedSplineParams_c9 C) {    \nconst int N_KNOTS_LOW = 8;\nconst int N_KNOTS_HIGH = 8;\nfloat logx = log10( max(x, 0.0 ));\nfloat coefsLow[10];\ncoefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;coefsLow[3] = C.coefsLow.d;\ncoefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;coefsLow[6] = C.coefsLow.g;\ncoefsLow[7] = C.coefsLow.h;coefsLow[8] = C.coefsLow.i;coefsLow[9] = C.coefsLow.j;\nfloat coefsHigh[10];\ncoefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;coefsHigh[3] = C.coefsHigh.d;\ncoefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;coefsHigh[6] = C.coefsHigh.g;\ncoefsHigh[7] = C.coefsHigh.h;coefsHigh[8] = C.coefsHigh.i;coefsHigh[9] = C.coefsHigh.j;\nfloat logy;\nif ( logx <= log10(C.minPoint.x) ) { \nlogy = logx * C.slopeLow + ( log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );\n} else if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) )) {\nfloat knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(C.minPoint.x)) / (log10(C.midPoint.x) - log10(C.minPoint.x));\nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec3 cf;\ndata10[0] = coefsLow[0];data10[1] = coefsLow[1];data10[2] = coefsLow[2];data10[3] = coefsLow[3];\ndata10[4] = coefsLow[4];data10[5] = coefsLow[5];data10[6] = coefsLow[6];\ndata10[7] = coefsLow[7];data10[8] = coefsLow[8];data10[9] = coefsLow[9];\ncf.x = getData10(j); cf.y = getData10(j + 1); cf.z = getData10(j + 2);\nvec3 monomials = vec3( t * t, t, 1.0 );\nlogy = dot( monomials, MM * cf);\n} else if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) )) {\nfloat knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(C.midPoint.x)) / (log10(C.maxPoint.x) - log10(C.midPoint.x));\nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec3 cf;\ndata10[0] = coefsHigh[0];data10[1] = coefsHigh[1];data10[2] = coefsHigh[2];data10[3] = coefsHigh[3];\ndata10[4] = coefsHigh[4];data10[5] = coefsHigh[5];data10[6] = coefsHigh[6];\ndata10[7] = coefsHigh[7];data10[8] = coefsHigh[8];data10[9] = coefsHigh[9];\ncf.x = getData10(j); cf.y = getData10(j + 1); cf.z = getData10(j + 2); \nvec3 monomials = vec3( t * t, t, 1.0 );\nlogy = dot( monomials, MM * cf);\n} else {\nlogy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );\n}\nreturn pow(10.0, logy);\n}\n\nfloat segmented_spline_c9_rev( float y, SegmentedSplineParams_c9 C) {  \n//SegmentedSplineParams_c9 C = ODT_48nits();\nconst int N_KNOTS_LOW = 8;\nconst int N_KNOTS_HIGH = 8;\nfloat KNOT_INC_LOW = (log10(C.midPoint.x) - log10(C.minPoint.x)) / float(N_KNOTS_LOW - 1);\nfloat KNOT_INC_HIGH = (log10(C.maxPoint.x) - log10(C.midPoint.x)) / float(N_KNOTS_HIGH - 1);\nfloat coefsLow[10];\ncoefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;coefsLow[3] = C.coefsLow.d;\ncoefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;coefsLow[6] = C.coefsLow.g;\ncoefsLow[7] = C.coefsLow.h;coefsLow[8] = C.coefsLow.i;coefsLow[9] = C.coefsLow.j;\nfloat coefsHigh[10];\ncoefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;coefsHigh[3] = C.coefsHigh.d;\ncoefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;coefsHigh[6] = C.coefsHigh.g;\ncoefsHigh[7] = C.coefsHigh.h;coefsHigh[8] = C.coefsHigh.i;coefsHigh[9] = C.coefsHigh.j;   \nfloat KNOT_Y_LOW[ N_KNOTS_LOW];\nfor (int i = 0; i < N_KNOTS_LOW; i += 1) {\nKNOT_Y_LOW[ i] = ( coefsLow[i] + coefsLow[i+1]) / 2.0;\n};\nfloat KNOT_Y_HIGH[ N_KNOTS_HIGH];\nfor (int i = 0; i < N_KNOTS_HIGH; i += 1) {\nKNOT_Y_HIGH[ i] = ( coefsHigh[i] + coefsHigh[i+1]) / 2.0;\n};\nfloat logy = log10( max( y, TINY));\nfloat logx;\nif (logy <= log10(C.minPoint.y)) {\nlogx = log10(C.minPoint.x);\n} else if ( (logy > log10(C.minPoint.y)) && (logy <= log10(C.midPoint.y)) ) {\nint j;\nvec3 cf;\nif ( logy > KNOT_Y_LOW[ 0] && logy <= KNOT_Y_LOW[ 1]) {\ncf.x = coefsLow[0];  cf.y = coefsLow[1];  cf.z = coefsLow[2];  j = 0;\n} else if ( logy > KNOT_Y_LOW[ 1] && logy <= KNOT_Y_LOW[ 2]) {\ncf.x = coefsLow[1];  cf.y = coefsLow[2];  cf.z = coefsLow[3];  j = 1;\n} else if ( logy > KNOT_Y_LOW[ 2] && logy <= KNOT_Y_LOW[ 3]) {\ncf.x = coefsLow[2];  cf.y = coefsLow[3];  cf.z = coefsLow[4];  j = 2;\n} else if ( logy > KNOT_Y_LOW[ 3] && logy <= KNOT_Y_LOW[ 4]) {\ncf.x = coefsLow[3];  cf.y = coefsLow[4];  cf.z = coefsLow[5];  j = 3;\n} else if ( logy > KNOT_Y_LOW[ 4] && logy <= KNOT_Y_LOW[ 5]) {\ncf.x = coefsLow[4];  cf.y = coefsLow[5];  cf.z = coefsLow[6];  j = 4;\n} else if ( logy > KNOT_Y_LOW[ 5] && logy <= KNOT_Y_LOW[ 6]) {\ncf.x = coefsLow[5];  cf.y = coefsLow[6];  cf.z = coefsLow[7];  j = 5;\n} else if ( logy > KNOT_Y_LOW[ 6] && logy <= KNOT_Y_LOW[ 7]) {\ncf.x = coefsLow[6];  cf.y = coefsLow[7];  cf.z = coefsLow[8];  j = 6;\n}\nvec3 tmp = MM * cf;\nfloat a = tmp.x;\nfloat b = tmp.y;\nfloat c = tmp.z;\nc = c - logy;\nfloat d = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -d - b);\nlogx = log10(C.minPoint.x) + ( t + float(j)) * KNOT_INC_LOW;\n} else if ( (logy > log10(C.midPoint.y)) && (logy < log10(C.maxPoint.y)) ) {\nint j;\nvec3 cf;\nif ( logy > KNOT_Y_HIGH[ 0] && logy <= KNOT_Y_HIGH[ 1]) {\ncf.x = coefsHigh[0];  cf.y = coefsHigh[1];  cf.z = coefsHigh[2];  j = 0;\n} else if ( logy > KNOT_Y_HIGH[ 1] && logy <= KNOT_Y_HIGH[ 2]) {\ncf.x = coefsHigh[1];  cf.y = coefsHigh[2];  cf.z = coefsHigh[3];  j = 1;\n} else if ( logy > KNOT_Y_HIGH[ 2] && logy <= KNOT_Y_HIGH[ 3]) {\ncf.x = coefsHigh[2];  cf.y = coefsHigh[3];  cf.z = coefsHigh[4];  j = 2;\n} else if ( logy > KNOT_Y_HIGH[ 3] && logy <= KNOT_Y_HIGH[ 4]) {\ncf.x = coefsHigh[3];  cf.y = coefsHigh[4];  cf.z = coefsHigh[5];  j = 3;\n} else if ( logy > KNOT_Y_HIGH[ 4] && logy <= KNOT_Y_HIGH[ 5]) {\ncf.x = coefsHigh[4];  cf.y = coefsHigh[5];  cf.z = coefsHigh[6];  j = 4;\n} else if ( logy > KNOT_Y_HIGH[ 5] && logy <= KNOT_Y_HIGH[ 6]) {\ncf.x = coefsHigh[5];  cf.y = coefsHigh[6];  cf.z = coefsHigh[7];  j = 5;\n} else if ( logy > KNOT_Y_HIGH[ 6] && logy <= KNOT_Y_HIGH[ 7]) {\ncf.x = coefsHigh[6];  cf.y = coefsHigh[7];  cf.z = coefsHigh[8];  j = 6;\n}\nvec3 tmp = MM * cf;\nfloat a = tmp.x;\nfloat b = tmp.y;\nfloat c = tmp.z;\nc = c - logy;\nfloat d = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -d - b);\nlogx = log10(C.midPoint.x) + ( t + float(j)) * KNOT_INC_HIGH;\n} else {\nlogx = log10(C.maxPoint.x);\n}\nreturn pow(10.0, logx);\n}\n\nvec3 segmented_spline_c9_rev_f3( vec3 rgbPre) {\nSegmentedSplineParams_c9 C = ODT_48nits();\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, C);\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, C);\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, C);\nreturn rgbPost;\n}\n\nvec3 segmented_spline_c5_rev_f3( vec3 rgbPre) {\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c5_rev( rgbPre.x);\nrgbPost.y = segmented_spline_c5_rev( rgbPre.y);\nrgbPost.z = segmented_spline_c5_rev( rgbPre.z);\nreturn rgbPost;\n}\n\nfloat lin_to_ACEScc( float ya) {\nif (ya <= 0.0)\nreturn -0.3584474886;\nelse if (ya < pow(2.0, -15.0))\nreturn (log2( pow(2.0, -16.0) + ya * 0.5) + 9.72) / 17.52;\nelse\nreturn (log2(ya) + 9.72) / 17.52;\n}\n\nvec3 ACES_to_ACEScc( vec3 ACES) {\nACES = max( ACES, 0.0);\nvec3 lin_AP1 = AP0_2_AP1_MAT * ACES;\nvec3 Out;\nOut.x = lin_to_ACEScc( lin_AP1.x); Out.y = lin_to_ACEScc( lin_AP1.y); Out.z = lin_to_ACEScc( lin_AP1.z);\nreturn Out;\n}\n\nfloat ACEScc_to_lin( float ya) {\nif (ya < -0.3013698630)\nreturn (pow( 2.0, ya * 17.52 - 9.72) - pow( 2.0, -16.0)) * 2.0;\nelse\nreturn pow( 2.0, ya * 17.52 - 9.72);\n}\n\nvec3 ACEScc_to_ACES( vec3 ACEScc) {\nvec3 lin_AP1;\nlin_AP1.x = ACEScc_to_lin( ACEScc.x); lin_AP1.y = ACEScc_to_lin( ACEScc.y); lin_AP1.z = ACEScc_to_lin( ACEScc.z);\nvec3 ACES = AP1_2_AP0_MAT * lin_AP1;\nreturn ACES;\n}\n\nvec3 ACES_to_ACEScg( vec3 ACES) {\nACES = max( ACES, 0.0);\nvec3 ACEScg = AP0_2_AP1_MAT * ACES;\nreturn ACEScg;\n}\n\nvec3 ACEScg_to_ACES( vec3 ACEScg) {\nvec3 ACES = AP1_2_AP0_MAT * ACEScg;\nreturn ACES;\n}\n\nfloat ACESproxy10_to_lin( float ya)\n{\nfloat StepsPerStop = 50.0;\nfloat MidCVoffset = 425.0;\n//float CVmin = 64.0;\n//float CVmax = 940.0;\nreturn pow( 2.0, ( ya - MidCVoffset)/StepsPerStop - 2.5);\n}\n\nvec3 ACESproxy10_to_ACES( vec3 In)\n{\nvec3 ACESproxy;\nACESproxy.x = In.x * 1023.0;\nACESproxy.y = In.y * 1023.0;\nACESproxy.z = In.z * 1023.0;\nvec3 lin_AP1;\nlin_AP1.x = ACESproxy10_to_lin( ACESproxy.x);\nlin_AP1.y = ACESproxy10_to_lin( ACESproxy.y);\nlin_AP1.z = ACESproxy10_to_lin( ACESproxy.z);\nvec3 ACES = AP1_2_AP0_MAT * lin_AP1;\nreturn ACES;\n}\n\nfloat ACESproxy12_to_lin( float ya)\n{\nfloat StepsPerStop = 200.0;\nfloat MidCVoffset = 1700.0;\n//float CVmin = 256.0;\n//float CVmax = 3760.0;\nreturn pow( 2.0, ( ya - MidCVoffset)/StepsPerStop - 2.5);\n}\n\nvec3 ACESproxy12_to_ACES( vec3 In)\n{\nvec3 ACESproxy;\nACESproxy.x = In.x * 4095.0;\nACESproxy.y = In.y * 4095.0;\nACESproxy.z = In.z * 4095.0;\nvec3 lin_AP1;\nlin_AP1.x = ACESproxy12_to_lin( ACESproxy.x);\nlin_AP1.y = ACESproxy12_to_lin( ACESproxy.y);\nlin_AP1.z = ACESproxy12_to_lin( ACESproxy.z);\nvec3 ACES = AP1_2_AP0_MAT * lin_AP1;\nreturn ACES;\n}\n\nfloat lin_to_ACESproxy10( float ya)\n{\nfloat StepsPerStop = 50.0;\nfloat MidCVoffset = 425.0;\nfloat CVmin = 64.0;\nfloat CVmax = 940.0;\nif (ya <= pow(2.0, -9.72))\nreturn CVmin;\nelse\nreturn max( CVmin, min( CVmax, floor( (log2(ya) + 2.5) * StepsPerStop + MidCVoffset + 0.5)) );\n}\n\nvec3 ACES_to_ACESproxy10( vec3 ACES)\n{\nACES = max( ACES, 0.0); \nvec3 lin_AP1 = AP0_2_AP1_MAT * ACES;\nfloat ACESproxy[3];\nACESproxy[0] = lin_to_ACESproxy10( lin_AP1.x );\nACESproxy[1] = lin_to_ACESproxy10( lin_AP1.y );\nACESproxy[2] = lin_to_ACESproxy10( lin_AP1.z );\nvec3 Out;    \nOut.x = ACESproxy[0] / 1023.0;\nOut.y = ACESproxy[1] / 1023.0;\nOut.z = ACESproxy[2] / 1023.0;\nreturn Out;\n}\n\nfloat lin_to_ACESproxy12( float ya)\n{\nfloat StepsPerStop = 200.0;\nfloat MidCVoffset = 1700.0;\nfloat CVmin = 256.0;\nfloat CVmax = 3760.0;\nif (ya <= pow(2.0, -9.72))\nreturn CVmin;\nelse\nreturn max( CVmin, min( CVmax, floor( (log2(ya) + 2.5) * StepsPerStop + MidCVoffset + 0.5)));\n}\n\nvec3 ACES_to_ACESproxy12( vec3 ACES)\n{\nACES = max( ACES, 0.0);\nvec3 lin_AP1 = AP0_2_AP1_MAT * ACES;\nfloat ACESproxy[3];\nACESproxy[0] = lin_to_ACESproxy12( lin_AP1.x );\nACESproxy[1] = lin_to_ACESproxy12( lin_AP1.y );\nACESproxy[2] = lin_to_ACESproxy12( lin_AP1.z );\nvec3 Out;\nOut.x = ACESproxy[0] / 4095.0;\nOut.y = ACESproxy[1] / 4095.0;\nOut.z = ACESproxy[2] / 4095.0;\nreturn Out;\n}\n\nvec3 ADX10_to_ACES( vec3 ADX10)\n{\nfloat LUT_IN[11];\nLUT_IN[0] = -0.19;\nLUT_IN[1] = 0.01;\nLUT_IN[2] = 0.028;\nLUT_IN[3] = 0.054;\nLUT_IN[4] = 0.095;\nLUT_IN[5] = 0.145;\nLUT_IN[6] = 0.22;\nLUT_IN[7] = 0.3;\nLUT_IN[8] = 0.4;\nLUT_IN[9] = 0.5;\nLUT_IN[10] = 0.6;\nfloat LUT_OUT[11];\nLUT_OUT[0] = -6.0;\nLUT_OUT[1] = -2.721718645;\nLUT_OUT[2] = -2.521718645;\nLUT_OUT[3] = -2.321718645;\nLUT_OUT[4] = -2.121718645;\nLUT_OUT[5] = -1.921718645;\nLUT_OUT[6] = -1.721718645;\nLUT_OUT[7] = -1.521718645;\nLUT_OUT[8] = -1.321718645;\nLUT_OUT[9] = -1.121718645;\nLUT_OUT[10] = -0.926545676714876;\nvec3 adx;\nadx.x = ADX10.x * 1023.0;\nadx.y = ADX10.y * 1023.0;\nadx.z = ADX10.z * 1023.0;\nvec3 cdd = ( adx - 95.0) / 500.0;\nvec3 cid = CDD_TO_CID * cdd;\nvec3 logE;\nif ( cid.x <= 0.6) logE.x = interpolate1D11( LUT_IN, LUT_OUT, cid.x);\nif ( cid.y <= 0.6) logE.y = interpolate1D11( LUT_IN, LUT_OUT, cid.y);\nif ( cid.z <= 0.6) logE.z = interpolate1D11( LUT_IN, LUT_OUT, cid.z);\nif ( cid.x > 0.6) logE.x = ( 100.0 / 55.0) * cid.x - REF_PT;\nif ( cid.y > 0.6) logE.y = ( 100.0 / 55.0) * cid.y - REF_PT;\nif ( cid.z > 0.6) logE.z = ( 100.0 / 55.0) * cid.z - REF_PT;\nvec3 exp;\nexp.x = pow( 10.0, logE.x);\nexp.y = pow( 10.0, logE.y);\nexp.z = pow( 10.0, logE.z);\nvec3 aces = EXP_TO_ACES * exp;\nreturn aces;\n}\n\nvec3 ADX16_to_ACES( vec3 ADX16)\n{\nfloat LUT_IN[11];\nLUT_IN[0] = -0.19;\nLUT_IN[1] = 0.01;\nLUT_IN[2] = 0.028;\nLUT_IN[3] = 0.054;\nLUT_IN[4] = 0.095;\nLUT_IN[5] = 0.145;\nLUT_IN[6] = 0.22;\nLUT_IN[7] = 0.3;\nLUT_IN[8] = 0.4;\nLUT_IN[9] = 0.5;\nLUT_IN[10] = 0.6;\nfloat LUT_OUT[11];\nLUT_OUT[0] = -6.0;\nLUT_OUT[1] = -2.721718645;\nLUT_OUT[2] = -2.521718645;\nLUT_OUT[3] = -2.321718645;\nLUT_OUT[4] = -2.121718645;\nLUT_OUT[5] = -1.921718645;\nLUT_OUT[6] = -1.721718645;\nLUT_OUT[7] = -1.521718645;\nLUT_OUT[8] = -1.321718645;\nLUT_OUT[9] = -1.121718645;\nLUT_OUT[10] = -0.926545676714876;\nvec3 adx;\nadx.x = ADX16.x * 65535.0;\nadx.y = ADX16.y * 65535.0;\nadx.z = ADX16.z * 65535.0;\nvec3 cdd = ( adx - 1520.0) / 8000.0;\nvec3 cid = CDD_TO_CID * cdd;\nvec3 logE;\nif ( cid.x <= 0.6) logE.x = interpolate1D11( LUT_IN, LUT_OUT, cid.x);\nif ( cid.y <= 0.6) logE.y = interpolate1D11( LUT_IN, LUT_OUT, cid.y);\nif ( cid.z <= 0.6) logE.z = interpolate1D11( LUT_IN, LUT_OUT, cid.z);\nif ( cid.x > 0.6) logE.x = ( 100.0 / 55.0) * cid.x - REF_PT;\nif ( cid.y > 0.6) logE.y = ( 100.0 / 55.0) * cid.y - REF_PT;\nif ( cid.z > 0.6) logE.z = ( 100.0 / 55.0) * cid.z - REF_PT;\nvec3 exp;\nexp.x = pow( 10.0, logE.x);\nexp.y = pow( 10.0, logE.y);\nexp.z = pow( 10.0, logE.z);\nvec3 aces = EXP_TO_ACES * exp;\nreturn aces;\n}\n\nfloat normalizedLogCToRelativeExposure(float x)\n{\nif (x > 0.149659)\nreturn (pow(10.0, (x - 0.385537) / 0.247189) - 0.052272) / 5.555556;\nelse\nreturn (x - 0.092809) / 5.367650;\n}\n\nvec3 IDT_Alexa_v3_logC_EI800( vec3 Alexa)\n{\nfloat r_lin = normalizedLogCToRelativeExposure(Alexa.x);\nfloat g_lin = normalizedLogCToRelativeExposure(Alexa.y);\nfloat b_lin = normalizedLogCToRelativeExposure(Alexa.z);\n\nvec3 aces;\naces.x = r_lin * 0.680206 + g_lin * 0.236137 + b_lin * 0.083658;\naces.y = r_lin * 0.085415 + g_lin * 1.017471 + b_lin * -0.102886;\naces.z = r_lin * 0.002057 + g_lin * -0.062563 + b_lin * 1.060506;\n\nreturn aces;\n}\n\nvec3 IDT_Alexa_v3_raw_EI800_CCT6500( vec3 In)\n{\n//float EI = 800.0;\nfloat black = 256.0 / 65535.0;\n//float exp_factor = 0.18 / (0.01 * (400.0 / EI));\nfloat r_lin = (In.x - black);// * exp_factor;\nfloat g_lin = (In.y - black);// * exp_factor;\nfloat b_lin = (In.z - black);// * exp_factor;\n\nvec3 aces;\naces.x = r_lin * 0.809931 + g_lin * 0.162741 + b_lin * 0.027328;\naces.y = r_lin * 0.083731 + g_lin * 1.108667 + b_lin * -0.192397;\naces.z = r_lin * 0.044166 + g_lin * -0.272038 + b_lin * 1.227872;\n\nreturn aces;\n}\n\nvec3 IDT_Panasonic_V35( vec3 VLog)\n{\nmat3 mat = mat3(vec3(0.724382758, 0.166748484, 0.108497411), vec3(0.021354009, 0.985138372, -0.006319092), vec3(-0.009234278, -0.00104295, 1.010272625) );\n\nfloat rLin = vLogToLinScene(VLog.x);\nfloat gLin = vLogToLinScene(VLog.y);\nfloat bLin = vLogToLinScene(VLog.z);\n\nvec3 Out;\nOut.x = mat[0][0] * rLin + mat[0][1] * gLin + mat[0][2] * bLin;\nOut.y = mat[1][0] * rLin + mat[1][1] * gLin + mat[1][2] * bLin;\nOut.z = mat[2][0] * rLin + mat[2][1] * gLin + mat[2][2] * bLin;\n\nreturn Out;\n}\n\nvec3 IDT_REDWideGamutRGB_Log3G10( vec3 log3G10)\n{\nfloat r_lin = Log3G10_to_linear(log3G10.x);\nfloat g_lin = Log3G10_to_linear(log3G10.y);\nfloat b_lin = Log3G10_to_linear(log3G10.z);\n\nvec3 aces;\naces.x = r_lin * 0.785043 + g_lin * 0.083844 + b_lin * 0.131118;\naces.y = r_lin * 0.023172 + g_lin * 1.087892 + b_lin * -0.111055;\naces.z = r_lin * -0.073769 + g_lin * -0.314639 + b_lin * 1.388537;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C100_A_D55( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 1.08190037262167 * iR -0.180298701368782 * iG +0.0983983287471069 * iB\n+1.9458545364518 * iR*iG -0.509539936937375 * iG*iB -0.47489567735516 * iB*iR\n-0.778086752197068 * iR*iR -0.7412266070049 * iG*iG +0.557894437042701 * iB*iB\n-3.27787395719078 * iR*iR*iG +0.254878417638717 * iR*iR*iB +3.45581530576474 * iR*iG*iG\n+0.335471713974739 * iR*iG*iB -0.43352125478476 * iR*iB*iB -1.65050137344141 * iG*iG*iB +1.46581418175682 * iG*iB*iB\n+0.944646566605676 * iR*iR*iR -0.723653099155881 * iG*iG*iG -0.371076501167857 * iB*iB*iB;\n\npmtx.y = -0.00858997792576314 * iR +1.00673740119621 * iG +0.00185257672955608 * iB\n+0.0848736138296452 * iR*iG +0.347626906448902 * iG*iB +0.0020230274463939 * iB*iR\n-0.0790508414091524 * iR*iR -0.179497582958716 * iG*iG -0.175975123357072 * iB*iB\n+2.30205579706951 * iR*iR*iG -0.627257613385219 * iR*iR*iB -2.90795250918851 * iR*iG*iG\n+1.37002437502321 * iR*iG*iB -0.108668158565563 * iR*iB*iB -2.21150552827555 * iG*iG*iB + 1.53315057595445 * iG*iB*iB\n-0.543188706699505 * iR*iR*iR +1.63793038490376 * iG*iG*iG -0.444588616836587 * iB*iB*iB;\n\npmtx.z = 0.12696639806511 * iR -0.011891441127869 * iG +0.884925043062759 * iB\n+1.34780279822258 * iR*iG +1.03647352257365 * iG*iB +0.459113289955922 * iB*iR\n-0.878157422295268 * iR*iR -1.3066278750436 * iG*iG -0.658604313413283 * iB*iB\n-1.4444077996703 * iR*iR*iG +0.556676588785173 * iR*iR*iB +2.18798497054968 * iR*iG*iG\n-1.43030768398665 * iR*iG*iB -0.0388323570817641 * iR*iB*iB +2.63698573112453 * iG*iG*iB -1.66598882056039 * iG*iB*iB\n+0.33450249360103 * iR*iR*iR -1.65856930730901 * iG*iG*iG +0.521956184547685 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( pmtx.x);\nlin.y = CanonLog_to_linear( pmtx.y);\nlin.z = CanonLog_to_linear( pmtx.z);\n\nvec3 aces;\naces.x = 0.561538969 * lin.x + 0.402060105 * lin.y + 0.036400926 * lin.z;\naces.y = 0.092739623 * lin.x + 0.924121198 * lin.y - 0.016860821 * lin.z;\naces.z = 0.084812961 * lin.x + 0.006373835 * lin.y + 0.908813204 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C100_A_Tng( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 0.963803004454899 * iR - 0.160722202570655 * iG + 0.196919198115756 * iB\n+2.03444685639819 * iR*iG - 0.442676931451021 * iG*iB - 0.407983781537509 * iB*iR\n-0.640703323129254 * iR*iR - 0.860242798247848 * iG*iG + 0.317159977967446 * iB*iB\n-4.80567080102966 * iR*iR*iG + 0.27118370397567 * iR*iR*iB + 5.1069005049557 * iR*iG*iG\n+0.340895816920585 * iR*iG*iB - 0.486941738507862 * iR*iB*iB - 2.23737935753692 * iG*iG*iB + 1.96647555251297 * iG*iB*iB\n+1.30204051766243 * iR*iR*iR - 1.06503117628554 * iG*iG*iG - 0.392473022667378 * iB*iB*iB;\n\npmtx.y = -0.0421935892309314 * iR +1.04845959175183 * iG - 0.00626600252090315 * iB\n-0.106438896887216 * iR*iG + 0.362908621470781 * iG*iB + 0.118070700472261 * iB*iR\n+0.0193542539838734 * iR*iR - 0.156083029543267 * iG*iG - 0.237811649496433 * iB*iB\n+1.67916420582198 * iR*iR*iG - 0.632835327167897 * iR*iR*iB - 1.95984471387461 * iR*iG*iG\n+0.953221464562814 * iR*iG*iB + 0.0599085176294623 * iR*iB*iB - 1.66452046236246 * iG*iG*iB + 1.14041188349761 * iG*iB*iB\n-0.387552623550308 * iR*iR*iR + 1.14820099685512 * iG*iG*iG - 0.336153941411709 * iB*iB*iB;\n\npmtx.z = 0.170295033135028 * iR - 0.0682984448537245 * iG + 0.898003411718697 * iB\n+1.22106821992399 * iR*iG + 1.60194865922925 * iG*iB + 0.377599191137124 * iB*iR\n-0.825781428487531 * iR*iR - 1.44590868076749 * iG*iG - 0.928925961035344 * iB*iB\n-0.838548997455852 * iR*iR*iG + 0.75809397217116 * iR*iR*iB + 1.32966795243196 * iR*iG*iG\n-1.20021905668355 * iR*iG*iB - 0.254838995845129 * iR*iB*iB + 2.33232411639308 * iG*iG*iB - 1.86381505762773 * iG*iB*iB\n+0.111576038956423 * iR*iR*iR - 1.12593315849766 * iG*iG*iG + 0.751693186157287 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( pmtx.x);\nlin.y = CanonLog_to_linear( pmtx.y);\nlin.z = CanonLog_to_linear( pmtx.z);\n\nvec3 aces;\naces.x = 0.566996399 * lin.x + 0.365079418 * lin.y + 0.067924183 * lin.z;\naces.y = 0.070901044 * lin.x + 0.880331008 * lin.y + 0.048767948 * lin.z;\naces.z = 0.073013542 * lin.x - 0.066540862 * lin.y + 0.99352732 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C100mk2_A_D55( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 1.08190037262167 * iR -0.180298701368782 * iG +0.0983983287471069 * iB\n+1.9458545364518 * iR*iG -0.509539936937375 * iG*iB -0.47489567735516 * iB*iR\n-0.778086752197068 * iR*iR -0.7412266070049 * iG*iG +0.557894437042701 * iB*iB\n-3.27787395719078 * iR*iR*iG +0.254878417638717 * iR*iR*iB +3.45581530576474 * iR*iG*iG\n+0.335471713974739 * iR*iG*iB -0.43352125478476 * iR*iB*iB -1.65050137344141 * iG*iG*iB +1.46581418175682 * iG*iB*iB\n+0.944646566605676 * iR*iR*iR -0.723653099155881 * iG*iG*iG -0.371076501167857 * iB*iB*iB;\n\npmtx.y = -0.00858997792576314 * iR +1.00673740119621 * iG +0.00185257672955608 * iB\n+0.0848736138296452 * iR*iG +0.347626906448902 * iG*iB +0.0020230274463939 * iB*iR\n-0.0790508414091524 * iR*iR -0.179497582958716 * iG*iG -0.175975123357072 * iB*iB\n+2.30205579706951 * iR*iR*iG -0.627257613385219 * iR*iR*iB -2.90795250918851 * iR*iG*iG\n+1.37002437502321 * iR*iG*iB -0.108668158565563 * iR*iB*iB -2.21150552827555 * iG*iG*iB + 1.53315057595445 * iG*iB*iB\n-0.543188706699505 * iR*iR*iR +1.63793038490376 * iG*iG*iG -0.444588616836587 * iB*iB*iB;\n\npmtx.z = 0.12696639806511 * iR -0.011891441127869 * iG +0.884925043062759 * iB\n+1.34780279822258 * iR*iG +1.03647352257365 * iG*iB +0.459113289955922 * iB*iR\n-0.878157422295268 * iR*iR -1.3066278750436 * iG*iG -0.658604313413283 * iB*iB\n-1.4444077996703 * iR*iR*iG +0.556676588785173 * iR*iR*iB +2.18798497054968 * iR*iG*iG\n-1.43030768398665 * iR*iG*iB -0.0388323570817641 * iR*iB*iB +2.63698573112453 * iG*iG*iB -1.66598882056039 * iG*iB*iB\n+0.33450249360103 * iR*iR*iR -1.65856930730901 * iG*iG*iG +0.521956184547685 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( (pmtx.x * 876.0 + 64.0) / 1023.0 );\nlin.y = CanonLog_to_linear( (pmtx.y * 876.0 + 64.0) / 1023.0 );\nlin.z = CanonLog_to_linear( (pmtx.z * 876.0 + 64.0) / 1023.0 );\nvec3 aces;\naces.x = 0.561538969 * lin.x + 0.402060105 * lin.y + 0.036400926 * lin.z;\naces.y = 0.092739623 * lin.x + 0.924121198 * lin.y - 0.016860821 * lin.z;\naces.z = 0.084812961 * lin.x + 0.006373835 * lin.y + 0.908813204 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C100mk2_A_Tng( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 0.963803004454899 * iR -0.160722202570655 * iG +0.196919198115756 * iB\n+2.03444685639819 * iR*iG -0.442676931451021 * iG*iB -0.407983781537509 * iB*iR\n-0.640703323129254 * iR*iR -0.860242798247848 * iG*iG +0.317159977967446 * iB*iB\n-4.80567080102966 * iR*iR*iG +0.27118370397567 * iR*iR*iB +5.1069005049557 * iR*iG*iG\n+0.340895816920585 * iR*iG*iB -0.486941738507862 * iR*iB*iB -2.23737935753692 * iG*iG*iB +1.96647555251297 * iG*iB*iB\n+1.30204051766243 * iR*iR*iR -1.06503117628554 * iG*iG*iG -0.392473022667378 * iB*iB*iB;\n\npmtx.y = -0.0421935892309314 * iR +1.04845959175183 * iG -0.00626600252090315 * iB\n-0.106438896887216 * iR*iG +0.362908621470781 * iG*iB +0.118070700472261 * iB*iR\n+0.0193542539838734 * iR*iR -0.156083029543267 * iG*iG -0.237811649496433 * iB*iB\n+1.67916420582198 * iR*iR*iG -0.632835327167897 * iR*iR*iB -1.95984471387461 * iR*iG*iG\n+0.953221464562814 * iR*iG*iB +0.0599085176294623 * iR*iB*iB -1.66452046236246 * iG*iG*iB +1.14041188349761 * iG*iB*iB\n-0.387552623550308 * iR*iR*iR +1.14820099685512 * iG*iG*iG -0.336153941411709 * iB*iB*iB;\n\npmtx.z = 0.170295033135028 * iR -0.0682984448537245 * iG +0.898003411718697 * iB\n+1.22106821992399 * iR*iG +1.60194865922925 * iG*iB +0.377599191137124 * iB*iR\n-0.825781428487531 * iR*iR -1.44590868076749 * iG*iG -0.928925961035344 * iB*iB\n-0.838548997455852 * iR*iR*iG +0.75809397217116 * iR*iR*iB +1.32966795243196 * iR*iG*iG\n-1.20021905668355 * iR*iG*iB -0.254838995845129 * iR*iB*iB +2.33232411639308 * iG*iG*iB -1.86381505762773 * iG*iB*iB\n+0.111576038956423 * iR*iR*iR -1.12593315849766 * iG*iG*iG +0.751693186157287 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( (pmtx.x * 876.0 + 64.0) / 1023.0 );\nlin.y = CanonLog_to_linear( (pmtx.y * 876.0 + 64.0) / 1023.0 );\nlin.z = CanonLog_to_linear( (pmtx.z * 876.0 + 64.0) / 1023.0 );\nvec3 aces;\naces.x = 0.566996399 * lin.x + 0.365079418 * lin.y + 0.067924183 * lin.z;\naces.y = 0.070901044 * lin.x + 0.880331008 * lin.y + 0.048767948 * lin.z;\naces.z = 0.073013542 * lin.x - 0.066540862 * lin.y + 0.99352732 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300_A_D55( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 1.08190037262167 * iR -0.180298701368782 * iG +0.0983983287471069 * iB\n+1.9458545364518 * iR*iG -0.509539936937375 * iG*iB -0.47489567735516 * iB*iR\n-0.778086752197068 * iR*iR -0.7412266070049 * iG*iG +0.557894437042701 * iB*iB\n-3.27787395719078 * iR*iR*iG +0.254878417638717 * iR*iR*iB +3.45581530576474 * iR*iG*iG\n+0.335471713974739 * iR*iG*iB -0.43352125478476 * iR*iB*iB -1.65050137344141 * iG*iG*iB +1.46581418175682 * iG*iB*iB\n+0.944646566605676 * iR*iR*iR -0.723653099155881 * iG*iG*iG -0.371076501167857 * iB*iB*iB;\n\npmtx.y = -0.00858997792576314 * iR +1.00673740119621 * iG +0.00185257672955608 * iB\n+0.0848736138296452 * iR*iG +0.347626906448902 * iG*iB +0.0020230274463939 * iB*iR\n-0.0790508414091524 * iR*iR -0.179497582958716 * iG*iG -0.175975123357072 * iB*iB\n+2.30205579706951 * iR*iR*iG -0.627257613385219 * iR*iR*iB -2.90795250918851 * iR*iG*iG\n+1.37002437502321 * iR*iG*iB -0.108668158565563 * iR*iB*iB -2.21150552827555 * iG*iG*iB + 1.53315057595445 * iG*iB*iB\n-0.543188706699505 * iR*iR*iR +1.63793038490376 * iG*iG*iG -0.444588616836587 * iB*iB*iB;\n\npmtx.z = 0.12696639806511 * iR -0.011891441127869 * iG +0.884925043062759 * iB\n+1.34780279822258 * iR*iG +1.03647352257365 * iG*iB +0.459113289955922 * iB*iR\n-0.878157422295268 * iR*iR -1.3066278750436 * iG*iG -0.658604313413283 * iB*iB\n-1.4444077996703 * iR*iR*iG +0.556676588785173 * iR*iR*iB +2.18798497054968 * iR*iG*iG\n-1.43030768398665 * iR*iG*iB -0.0388323570817641 * iR*iB*iB +2.63698573112453 * iG*iG*iB -1.66598882056039 * iG*iB*iB\n+0.33450249360103 * iR*iR*iR -1.65856930730901 * iG*iG*iG +0.521956184547685 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( pmtx.x);\nlin.y = CanonLog_to_linear( pmtx.y);\nlin.z = CanonLog_to_linear( pmtx.z);\n\nvec3 aces;\naces.x = 0.561538969 * lin.x + 0.402060105 * lin.y + 0.036400926 * lin.z;\naces.y = 0.092739623 * lin.x + 0.924121198 * lin.y - 0.016860821 * lin.z;\naces.z = 0.084812961 * lin.x + 0.006373835 * lin.y + 0.908813204 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300_A_Tng( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 0.963803004454899 * iR -0.160722202570655 * iG +0.196919198115756 * iB\n+2.03444685639819 * iR*iG -0.442676931451021 * iG*iB -0.407983781537509 * iB*iR\n-0.640703323129254 * iR*iR -0.860242798247848 * iG*iG +0.317159977967446 * iB*iB\n-4.80567080102966 * iR*iR*iG +0.27118370397567 * iR*iR*iB +5.1069005049557 * iR*iG*iG\n+0.340895816920585 * iR*iG*iB -0.486941738507862 * iR*iB*iB -2.23737935753692 * iG*iG*iB +1.96647555251297 * iG*iB*iB\n+1.30204051766243 * iR*iR*iR -1.06503117628554 * iG*iG*iG -0.392473022667378 * iB*iB*iB;\n\npmtx.y = -0.0421935892309314 * iR +1.04845959175183 * iG -0.00626600252090315 * iB\n-0.106438896887216 * iR*iG +0.362908621470781 * iG*iB +0.118070700472261 * iB*iR\n+0.0193542539838734 * iR*iR -0.156083029543267 * iG*iG -0.237811649496433 * iB*iB\n+1.67916420582198 * iR*iR*iG -0.632835327167897 * iR*iR*iB -1.95984471387461 * iR*iG*iG\n+0.953221464562814 * iR*iG*iB +0.0599085176294623 * iR*iB*iB -1.66452046236246 * iG*iG*iB +1.14041188349761 * iG*iB*iB\n-0.387552623550308 * iR*iR*iR +1.14820099685512 * iG*iG*iG -0.336153941411709 * iB*iB*iB;\n\npmtx.z = 0.170295033135028 * iR -0.0682984448537245 * iG +0.898003411718697 * iB\n+1.22106821992399 * iR*iG +1.60194865922925 * iG*iB +0.377599191137124 * iB*iR\n-0.825781428487531 * iR*iR -1.44590868076749 * iG*iG -0.928925961035344 * iB*iB\n-0.838548997455852 * iR*iR*iG +0.75809397217116 * iR*iR*iB +1.32966795243196 * iR*iG*iG\n-1.20021905668355 * iR*iG*iB -0.254838995845129 * iR*iB*iB +2.33232411639308 * iG*iG*iB -1.86381505762773 * iG*iB*iB\n+0.111576038956423 * iR*iR*iR -1.12593315849766 * iG*iG*iG +0.751693186157287 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( pmtx.x);\nlin.y = CanonLog_to_linear( pmtx.y);\nlin.z = CanonLog_to_linear( pmtx.z);\n\nvec3 aces;\naces.x = 0.566996399 * lin.x +0.365079418 * lin.y + 0.067924183 * lin.z;\naces.y = 0.070901044 * lin.x +0.880331008 * lin.y + 0.048767948 * lin.z;\naces.z = 0.073013542 * lin.x -0.066540862 * lin.y + 0.99352732 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_A_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( CLogIRE.x);\nlin.y = CanonLog_to_linear( CLogIRE.y);\nlin.z = CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.561538969 * lin.x +0.402060105 * lin.y + 0.036400926 * lin.z;\naces.y = 0.092739623 * lin.x +0.924121198 * lin.y - 0.016860821 * lin.z;\naces.z = 0.084812961 * lin.x +0.006373835 * lin.y + 0.908813204 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_A_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( CLogIRE.x);\nlin.y = CanonLog_to_linear( CLogIRE.y);\nlin.z = CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.566996399 * lin.x +0.365079418 * lin.y + 0.067924183 * lin.z;\naces.y = 0.070901044 * lin.x +0.880331008 * lin.y + 0.048767948 * lin.z;\naces.z = 0.073013542 * lin.x -0.066540862 * lin.y + 0.99352732 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_B_D55( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 1.08190037262167 * iR -0.180298701368782 * iG +0.0983983287471069 * iB\n+1.9458545364518 * iR*iG -0.509539936937375 * iG*iB -0.47489567735516 * iB*iR\n-0.778086752197068 * iR*iR -0.7412266070049 * iG*iG +0.557894437042701 * iB*iB\n-3.27787395719078 * iR*iR*iG +0.254878417638717 * iR*iR*iB +3.45581530576474 * iR*iG*iG\n+0.335471713974739 * iR*iG*iB -0.43352125478476 * iR*iB*iB -1.65050137344141 * iG*iG*iB + 1.46581418175682 * iG*iB*iB\n+0.944646566605676 * iR*iR*iR -0.723653099155881 * iG*iG*iG -0.371076501167857 * iB*iB*iB;\n\npmtx.y = -0.00858997792576314 * iR +1.00673740119621 * iG +0.00185257672955608 * iB\n+0.0848736138296452 * iR*iG +0.347626906448902 * iG*iB +0.0020230274463939 * iB*iR\n-0.0790508414091524 * iR*iR -0.179497582958716 * iG*iG -0.175975123357072 * iB*iB\n+2.30205579706951 * iR*iR*iG -0.627257613385219 * iR*iR*iB -2.90795250918851 * iR*iG*iG\n+1.37002437502321 * iR*iG*iB -0.108668158565563 * iR*iB*iB -2.21150552827555 * iG*iG*iB + 1.53315057595445 * iG*iB*iB\n-0.543188706699505 * iR*iR*iR +1.63793038490376 * iG*iG*iG -0.444588616836587 * iB*iB*iB;\n\npmtx.z = 0.12696639806511 * iR -0.011891441127869 * iG +0.884925043062759 * iB\n+1.34780279822258 * iR*iG +1.03647352257365 * iG*iB +0.459113289955922 * iB*iR\n-0.878157422295268 * iR*iR -1.3066278750436 * iG*iG -0.658604313413283 * iB*iB\n-1.4444077996703 * iR*iR*iG +0.556676588785173 * iR*iR*iB +2.18798497054968 * iR*iG*iG\n-1.43030768398665 * iR*iG*iB -0.0388323570817641 * iR*iB*iB +2.63698573112453 * iG*iG*iB - 1.66598882056039 * iG*iB*iB\n+0.33450249360103 * iR*iR*iR -1.65856930730901 * iG*iG*iG +0.521956184547685 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( pmtx.x);\nlin.y = CanonLog_to_linear( pmtx.y);\nlin.z = CanonLog_to_linear( pmtx.z);\n\nvec3 aces;\naces.x = 0.561538969 * lin.x + 0.402060105 * lin.y + 0.036400926 * lin.z;\naces.y = 0.092739623 * lin.x + 0.924121198 * lin.y - 0.016860821 * lin.z;\naces.z = 0.084812961 * lin.x + 0.006373835 * lin.y + 0.908813204 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_B_Tng( vec3 In)\n{\nfloat iR, iG, iB;\niR = (In.x * 1023.0 - 64.0) / 876.0;\niG = (In.y * 1023.0 - 64.0) / 876.0;\niB = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 pmtx;\npmtx.x = 0.963803004454899 * iR -0.160722202570655 * iG +0.196919198115756 * iB\n+2.03444685639819 * iR*iG -0.442676931451021 * iG*iB -0.407983781537509 * iB*iR\n-0.640703323129254 * iR*iR -0.860242798247848 * iG*iG +0.317159977967446 * iB*iB\n-4.80567080102966 * iR*iR*iG +0.27118370397567 * iR*iR*iB +5.1069005049557 * iR*iG*iG\n+0.340895816920585 * iR*iG*iB -0.486941738507862 * iR*iB*iB -2.23737935753692 * iG*iG*iB + 1.96647555251297 * iG*iB*iB\n+1.30204051766243 * iR*iR*iR -1.06503117628554 * iG*iG*iG -0.392473022667378 * iB*iB*iB;\n\npmtx.y = -0.0421935892309314 * iR +1.04845959175183 * iG -0.00626600252090315 * iB\n-0.106438896887216 * iR*iG +0.362908621470781 * iG*iB +0.118070700472261 * iB*iR\n+0.0193542539838734 * iR*iR -0.156083029543267 * iG*iG -0.237811649496433 * iB*iB\n+1.67916420582198 * iR*iR*iG -0.632835327167897 * iR*iR*iB -1.95984471387461 * iR*iG*iG\n+0.953221464562814 * iR*iG*iB +0.0599085176294623 * iR*iB*iB -1.66452046236246 * iG*iG*iB + 1.14041188349761 * iG*iB*iB\n-0.387552623550308 * iR*iR*iR +1.14820099685512 * iG*iG*iG -0.336153941411709 * iB*iB*iB;\n\npmtx.z = 0.170295033135028 * iR -0.0682984448537245 * iG +0.898003411718697 * iB\n+1.22106821992399 * iR*iG +1.60194865922925 * iG*iB +0.377599191137124 * iB*iR\n-0.825781428487531 * iR*iR -1.44590868076749 * iG*iG -0.928925961035344 * iB*iB\n-0.838548997455852 * iR*iR*iG +0.75809397217116 * iR*iR*iB +1.32966795243196 * iR*iG*iG\n-1.20021905668355 * iR*iG*iB -0.254838995845129 * iR*iB*iB +2.33232411639308 * iG*iG*iB - 1.86381505762773 * iG*iB*iB\n+0.111576038956423 * iR*iR*iR -1.12593315849766 * iG*iG*iG +0.751693186157287 * iB*iB*iB;\n\nvec3 lin;\nlin.x = CanonLog_to_linear( pmtx.x);\nlin.y = CanonLog_to_linear( pmtx.y);\nlin.z = CanonLog_to_linear( pmtx.z);\n\nvec3 aces;\naces.x = 0.566996399 * lin.x +0.365079418 * lin.y + 0.067924183 * lin.z;\naces.y = 0.070901044 * lin.x +0.880331008 * lin.y + 0.048767948 * lin.z;\naces.z = 0.073013542 * lin.x -0.066540862 * lin.y + 0.99352732 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_CinemaGamut_A_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.763064455 * lin.x + 0.149021161 * lin.y + 0.087914384 * lin.z;\naces.y = 0.003657457 * lin.x + 1.10696038 * lin.y - 0.110617837 * lin.z;\naces.z = -0.009407794 * lin.x - 0.218383305 * lin.y + 1.227791099 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_CinemaGamut_A_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.817416293 * lin.x + 0.090755698 * lin.y + 0.091828009 * lin.z;\naces.y = -0.035361374 * lin.x + 1.065690585 * lin.y - 0.030329211 * lin.z;\naces.z = 0.010390366 * lin.x - 0.299271107 * lin.y + 1.288880741 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_DCI_P3_A_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.607160575 * lin.x + 0.299507286 * lin.y + 0.093332140 * lin.z;\naces.y = 0.004968120 * lin.x + 1.050982224 * lin.y - 0.055950343 * lin.z;\naces.z = -0.007839939 * lin.x + 0.000809127 * lin.y + 1.007030813 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C500_DCI_P3_A_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.650279125 * lin.x + 0.253880169 * lin.y + 0.095840706 * lin.z;\naces.y = -0.026137986 * lin.x + 1.017900530 * lin.y + 0.008237456 * lin.z;\naces.z = 0.007757558 * lin.x - 0.063081669 * lin.y + 1.055324110 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog_BT2020_D_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.678891151 * lin.x + 0.158868422 * lin.y + 0.162240427 * lin.z;\naces.y = 0.045570831 * lin.x + 0.860712772 * lin.y + 0.093716397 * lin.z;\naces.z = -0.000485710 * lin.x + 0.025060196 * lin.y + 0.975425515 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog_BT2020_D_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.724488568 * lin.x + 0.115140904 * lin.y + 0.160370529 * lin.z;\naces.y = 0.010659276 * lin.x + 0.839605344 * lin.y + 0.149735380 * lin.z;\naces.z = 0.014560161 * lin.x - 0.028562057 * lin.y + 1.014001897 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog_CinemaGamut_C_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.763064455 * lin.x + 0.149021161 * lin.y + 0.087914384 * lin.z;\naces.y = 0.003657457 * lin.x + 1.10696038 * lin.y - 0.110617837 * lin.z;\naces.z = -0.009407794 * lin.x - 0.218383305 * lin.y + 1.227791099 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog_CinemaGamut_C_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.817416293 * lin.x + 0.090755698 * lin.y + 0.091828009 * lin.z;\naces.y = -0.035361374 * lin.x + 1.065690585 * lin.y - 0.030329211 * lin.z;\naces.z = 0.010390366 * lin.x - 0.299271107 * lin.y + 1.288880741 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog2_BT2020_B_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog2_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog2_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog2_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.678891151 * lin.x + 0.158868422 * lin.y + 0.162240427 * lin.z;\naces.y = 0.045570831 * lin.x + 0.860712772 * lin.y + 0.093716397 * lin.z;\naces.z = -0.000485710 * lin.x + 0.025060196 * lin.y + 0.975425515 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog2_BT2020_B_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog2_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog2_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog2_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.724488568 * lin.x + 0.115140904 * lin.y + 0.160370529 * lin.z;\naces.y = 0.010659276 * lin.x + 0.839605344 * lin.y + 0.149735380 * lin.z;\naces.z = 0.014560161 * lin.x - 0.028562057 * lin.y + 1.014001897 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog2_CinemaGamut_A_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog2_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog2_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog2_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.763064455 * lin.x + 0.149021161 * lin.y + 0.087914384 * lin.z;\naces.y = 0.003657457 * lin.x + 1.10696038 * lin.y - 0.110617837 * lin.z;\naces.z = -0.009407794 * lin.x - 0.218383305 * lin.y + 1.227791099 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog2_CinemaGamut_A_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog2_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog2_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog2_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.817416293 * lin.x + 0.090755698 * lin.y + 0.091828009 * lin.z;\naces.y = -0.035361374 * lin.x + 1.065690585 * lin.y - 0.030329211 * lin.z;\naces.z = 0.010390366 * lin.x - 0.299271107 * lin.y + 1.288880741 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog3_BT2020_F_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog3_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog3_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog3_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.678891151 * lin.x + 0.158868422 * lin.y + 0.162240427 * lin.z;\naces.y = 0.045570831 * lin.x + 0.860712772 * lin.y + 0.093716397 * lin.z;\naces.z = -0.000485710 * lin.x + 0.025060196 * lin.y + 0.975425515 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog3_BT2020_F_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog3_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog3_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog3_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.724488568 * lin.x + 0.115140904 * lin.y + 0.160370529 * lin.z;\naces.y = 0.010659276 * lin.x + 0.839605344 * lin.y + 0.149735380 * lin.z;\naces.z = 0.014560161 * lin.x - 0.028562057 * lin.y + 1.014001897 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog3_CinemaGamut_E_D55( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog3_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog3_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog3_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.763064455 * lin.x + 0.149021161 * lin.y + 0.087914384 * lin.z;\naces.y = 0.003657457 * lin.x + 1.10696038 * lin.y - 0.110617837 * lin.z;\naces.z = -0.009407794 * lin.x - 0.218383305 * lin.y + 1.227791099 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Canon_C300mk2_CanonLog3_CinemaGamut_E_Tng( vec3 In)\n{\nvec3 CLogIRE;\nCLogIRE.x = (In.x * 1023.0 - 64.0) / 876.0;\nCLogIRE.y = (In.y * 1023.0 - 64.0) / 876.0;\nCLogIRE.z = (In.z * 1023.0 - 64.0) / 876.0;\n\nvec3 lin;\nlin.x = 0.9 * CanonLog3_to_linear( CLogIRE.x);\nlin.y = 0.9 * CanonLog3_to_linear( CLogIRE.y);\nlin.z = 0.9 * CanonLog3_to_linear( CLogIRE.z);\n\nvec3 aces;\naces.x = 0.817416293 * lin.x + 0.090755698 * lin.y + 0.091828009 * lin.z;\naces.y = -0.035361374 * lin.x + 1.065690585 * lin.y - 0.030329211 * lin.z;\naces.z = 0.010390366 * lin.x - 0.299271107 * lin.y + 1.288880741 * lin.z;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog1_SGamut_10( vec3 In)\n{\nmat3 SGAMUT_TO_ACES_MTX = mat3( vec3( 0.754338638, 0.021198141, -0.009756991 ), vec3( 0.133697046, 1.005410934, 0.004508563 ), vec3( 0.111968437, -0.026610548, 1.005253201 ) );\n\nfloat B = 64.0;\nfloat AB = 90.0;\nfloat W = 940.0;\n\nvec3 SLog;\nSLog.x = In.x * 1023.0;\nSLog.y = In.y * 1023.0;\nSLog.z = In.z * 1023.0;\n\nvec3 lin;\nlin.x = SLog1_to_lin( SLog.x, B, AB, W);\nlin.y = SLog1_to_lin( SLog.y, B, AB, W);\nlin.z = SLog1_to_lin( SLog.z, B, AB, W);\n\nvec3 aces = SGAMUT_TO_ACES_MTX * lin;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog1_SGamut_12( vec3 In)\n{\nmat3 SGAMUT_TO_ACES_MTX = mat3( vec3( 0.754338638, 0.021198141, -0.009756991 ), vec3( 0.133697046, 1.005410934, 0.004508563 ), vec3( 0.111968437, -0.026610548, 1.005253201 ) );\n\nfloat B = 256.0;\nfloat AB = 360.0;\nfloat W = 3760.0;\n\nvec3 SLog;\nSLog.x = In.x * 4095.0;\nSLog.y = In.y * 4095.0;\nSLog.z = In.z * 4095.0;\n\nvec3 lin;\nlin.x = SLog1_to_lin( SLog.x, B, AB, W);\nlin.y = SLog1_to_lin( SLog.y, B, AB, W);\nlin.z = SLog1_to_lin( SLog.z, B, AB, W);\n\nvec3 aces = SGAMUT_TO_ACES_MTX * lin;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog2_SGamut_Daylight_10( vec3 In)\n{\nmat3 SGAMUT_DAYLIGHT_TO_ACES_MTX = mat3( vec3( 0.8764457030, 0.0774075345, 0.0573564351), vec3( 0.0145411681, 0.9529571767, -0.1151066335), vec3( 0.1090131290, -0.0303647111, 1.0577501984) );\n\nfloat B = 64.0;\nfloat AB = 90.0;\nfloat W = 940.0;\n\nvec3 SLog;\nSLog.x = In.x * 1023.0;\nSLog.y = In.y * 1023.0;\nSLog.z = In.z * 1023.0;\n\nvec3 lin;\nlin.x = SLog2_to_lin( SLog.x, B, AB, W);\nlin.y = SLog2_to_lin( SLog.y, B, AB, W);\nlin.z = SLog2_to_lin( SLog.z, B, AB, W);\n\nvec3 aces = SGAMUT_DAYLIGHT_TO_ACES_MTX * lin;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog2_SGamut_Daylight_12( vec3 In)\n{\nmat3 SGAMUT_DAYLIGHT_TO_ACES_MTX = mat3(vec3(0.8764457030, 0.0774075345, 0.0573564351), vec3(0.0145411681, 0.9529571767, -0.1151066335), vec3(0.1090131290, -0.0303647111, 1.0577501984));\n\nfloat B = 256.0;\nfloat AB = 360.0;\nfloat W = 3760.0;\n\nvec3 SLog;\nSLog.x = In.x * 4095.0;\nSLog.y = In.y * 4095.0;\nSLog.z = In.z * 4095.0;\n\nvec3 lin;\nlin.x = SLog2_to_lin( SLog.x, B, AB, W);\nlin.y = SLog2_to_lin( SLog.y, B, AB, W);\nlin.z = SLog2_to_lin( SLog.z, B, AB, W);\n\nvec3 aces = SGAMUT_DAYLIGHT_TO_ACES_MTX * lin;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog2_SGamut_Tungsten_10( vec3 In)\n{\nmat3 SGAMUT_TUNG_TO_ACES_MTX = mat3( vec3( 1.0110238740, 0.1011994504, 0.0600766530), vec3( -0.1362526051, 0.9562196265, -0.1010185315), vec3( 0.1252287310, -0.0574190769, 1.0409418785) );\n\nfloat B = 64.0;\nfloat AB = 90.0;\nfloat W = 940.0;\n\nvec3 SLog;\nSLog.x = In.x * 1023.0;\nSLog.y = In.y * 1023.0;\nSLog.z = In.z * 1023.0;\n\nvec3 lin;\nlin.x = SLog2_to_lin( SLog.x, B, AB, W);\nlin.y = SLog2_to_lin( SLog.y, B, AB, W);\nlin.z = SLog2_to_lin( SLog.z, B, AB, W);\n\nvec3 aces = SGAMUT_TUNG_TO_ACES_MTX * lin;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog2_SGamut_Tungsten_12( vec3 In)\n{\nmat3 SGAMUT_TUNG_TO_ACES_MTX = mat3( vec3( 1.011023874, 0.1011994504, 0.060076653), vec3( -0.1362526051, 0.9562196265, -0.1010185315), vec3( 0.125228731, -0.0574190769, 1.0409418785) );\n\nfloat B = 256.0;\nfloat AB = 360.0;\nfloat W = 3760.0;\n\nvec3 SLog;\nSLog.x = In.x * 4095.0;\nSLog.y = In.y * 4095.0;\nSLog.z = In.z * 4095.0;\n\nvec3 lin;\nlin.x = SLog2_to_lin( SLog.x, B, AB, W);\nlin.y = SLog2_to_lin( SLog.y, B, AB, W);\nlin.z = SLog2_to_lin( SLog.z, B, AB, W);\n\nvec3 aces = SGAMUT_TUNG_TO_ACES_MTX * lin;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog3_SGamut3( vec3 SLog3)\n{\nmat3 matrixCoef = mat3( vec3(0.7529825954, 0.0217076974, -0.0094160528), vec3(0.1433702162, 1.0153188355, 0.0033704179), vec3(0.1036471884, -0.0370265329, 1.0060456349) );\n\nvec3 linear;\nlinear.x = SLog3_to_linear( SLog3.x );\nlinear.y = SLog3_to_linear( SLog3.y );\nlinear.z = SLog3_to_linear( SLog3.z );\n\nvec3 aces = matrixCoef * linear;\n\nreturn aces;\n}\n\nvec3 IDT_Sony_SLog3_SGamut3Cine( vec3 SLog3)\n{\nmat3 matrixCoef = mat3( vec3(0.6387886672, -0.003915906, -0.0299072021), vec3(0.2723514337, 1.0880732309, -0.0264325799), vec3(0.0888598991, -0.0841573249, 1.056339782) );\n\nvec3 linear;\nlinear.x = SLog3_to_linear( SLog3.x );\nlinear.y = SLog3_to_linear( SLog3.y );\nlinear.z = SLog3_to_linear( SLog3.z );\n\nvec3 aces = matrixCoef * linear;\n\nreturn aces;\n}\n\nfloat Y_2_linCV( float Y, float Ymax, float Ymin)\n{\nreturn (Y - Ymin) / (Ymax - Ymin);\n}\n\nfloat linCV_2_Y( float linCV, float Ymax, float Ymin)\n{\nreturn linCV * (Ymax - Ymin) + Ymin;\n}\n\nvec3 Y_2_linCV_f3( vec3 Y, float Ymax, float Ymin)\n{\nvec3 linCV;\nlinCV.x = Y_2_linCV( Y.x, Ymax, Ymin); linCV.y = Y_2_linCV( Y.y, Ymax, Ymin); linCV.z = Y_2_linCV( Y.z, Ymax, Ymin);\nreturn linCV;\n}\n\nvec3 linCV_2_Y_f3( vec3 linCV, float Ymax, float Ymin)\n{\nvec3 Y;\nY.x = linCV_2_Y( linCV.x, Ymax, Ymin); Y.y = linCV_2_Y( linCV.y, Ymax, Ymin); Y.z = linCV_2_Y( linCV.z, Ymax, Ymin);\nreturn Y;\n}\n\nvec3 darkSurround_to_dimSurround( vec3 linearCV)\n{\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nvec3 xyY = XYZ_2_xyY(XYZ);\nxyY.z = max( xyY.z, 0.0);\nxyY.z = pow( xyY.z, DIM_SURROUND_GAMMA);\nXYZ = xyY_2_XYZ(xyY);\nreturn XYZtoRGB(AP1) * XYZ;\n}\n\nvec3 dimSurround_to_darkSurround( vec3 linearCV)\n{\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nvec3 xyY = XYZ_2_xyY(XYZ);\nxyY.z = max( xyY.z, 0.0);\nxyY.z = pow( xyY.z, 1.0 / DIM_SURROUND_GAMMA);\nXYZ = xyY_2_XYZ(xyY);\nreturn XYZtoRGB(AP1) * XYZ;\n}\n\nfloat roll_white_fwd( float In, float new_wht, float width)\n{\nfloat x0 = -1.0;\nfloat x1 = x0 + width;\nfloat y0 = -new_wht;\nfloat y1 = x1;\nfloat m1 = (x1 - x0);\nfloat a = y0 - y1 + m1;\nfloat b = 2.0 * ( y1 - y0) - m1;\nfloat c = y0;\nfloat t = (-In - x0) / (x1 - x0);\nfloat Out = 0.0;\nif ( t < 0.0)\nOut = -(t * b + c);\nelse if ( t > 1.0)\nOut = In;\nelse\nOut = -(( t * a + b) * t + c);\nreturn Out;\n}\n\nfloat roll_white_rev( float In, float new_wht, float width)\n{\nfloat x0 = -1.0;\nfloat x1 = x0 + width;\nfloat y0 = -new_wht;\nfloat y1 = x1;\nfloat m1 = (x1 - x0);\nfloat a = y0 - y1 + m1;\nfloat b = 2.0 * ( y1 - y0) - m1;\nfloat c = y0;\nfloat Out = 0.0;\nif ( -In < y0)\nOut = -x0;\nelse if ( -In > y1)\nOut = In;\nelse {\nc = c + In;\nfloat discrim = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -discrim - b);\nOut = -(( t * ( x1 - x0)) + x0);\n}\nreturn Out;\n}\n\nfloat lookup_ACESmin( float minLum )\n{\nmat2 minTable = mat2( vec2(log10(MIN_LUM_RRT), MIN_STOP_RRT ), vec2( log10(MIN_LUM_SDR), MIN_STOP_SDR ) );\nreturn 0.18 * pow( 2.0, interpolate1D( minTable, log10( minLum)));\n}\n\nfloat lookup_ACESmax( float maxLum )\n{\nmat2 maxTable = mat2( vec2(log10(MAX_LUM_SDR), MAX_STOP_SDR ), vec2( log10(MAX_LUM_RRT), MAX_STOP_RRT ) );\nreturn 0.18 * pow( 2.0, interpolate1D( maxTable, log10( maxLum)));\n}\n\nfloat5 init_coefsLow( TsPoint TsPointLow, TsPoint TsPointMid)\n{\nfloat5 coefsLow;\nfloat knotIncLow = (log10(TsPointMid.x) - log10(TsPointLow.x)) / 3.0;\ncoefsLow.x = (TsPointLow.slope * (log10(TsPointLow.x) - 0.5 * knotIncLow)) + ( log10(TsPointLow.y) - TsPointLow.slope * log10(TsPointLow.x));\ncoefsLow.y = (TsPointLow.slope * (log10(TsPointLow.x) + 0.5 * knotIncLow)) + ( log10(TsPointLow.y) - TsPointLow.slope * log10(TsPointLow.x));\ncoefsLow.w = (TsPointMid.slope * (log10(TsPointMid.x) - 0.5 * knotIncLow)) + ( log10(TsPointMid.y) - TsPointMid.slope * log10(TsPointMid.x));\ncoefsLow.m = (TsPointMid.slope * (log10(TsPointMid.x) + 0.5 * knotIncLow)) + ( log10(TsPointMid.y) - TsPointMid.slope * log10(TsPointMid.x));\nmat2 bendsLow = mat2( vec2(MIN_STOP_RRT, 0.18), vec2(MIN_STOP_SDR, 0.35) );\nfloat pctLow = interpolate1D( bendsLow, log2(TsPointLow.x / 0.18));\ncoefsLow.z = log10(TsPointLow.y) + pctLow * (log10(TsPointMid.y) - log10(TsPointLow.y));\nreturn coefsLow;\n}\n\nfloat5 init_coefsHigh( TsPoint TsPointMid, TsPoint TsPointMax)\n{\nfloat5 coefsHigh;\nfloat knotIncHigh = (log10(TsPointMax.x) - log10(TsPointMid.x)) / 3.0;\ncoefsHigh.x = (TsPointMid.slope * (log10(TsPointMid.x) - 0.5 * knotIncHigh)) + ( log10(TsPointMid.y) - TsPointMid.slope * log10(TsPointMid.x));\ncoefsHigh.y = (TsPointMid.slope * (log10(TsPointMid.x) + 0.5 * knotIncHigh)) + ( log10(TsPointMid.y) - TsPointMid.slope * log10(TsPointMid.x));\ncoefsHigh.w = (TsPointMax.slope * (log10(TsPointMax.x) - 0.5 * knotIncHigh)) + ( log10(TsPointMax.y) - TsPointMax.slope * log10(TsPointMax.x));\ncoefsHigh.m = (TsPointMax.slope * (log10(TsPointMax.x) + 0.5 * knotIncHigh)) + ( log10(TsPointMax.y) - TsPointMax.slope * log10(TsPointMax.x));\nmat2 bendsHigh = mat2( vec2(MAX_STOP_SDR, 0.89), vec2(MAX_STOP_RRT, 0.90) );\nfloat pctHigh = interpolate1D( bendsHigh, log2(TsPointMax.x / 0.18));\ncoefsHigh.z = log10(TsPointMid.y) + pctHigh*(log10(TsPointMax.y) - log10(TsPointMid.y));\nreturn coefsHigh;\n}\n\nfloat shift( float In, float expShift)\n{\nreturn pow(2.0, (log2(In) - expShift));\n}\n\nTsParams init_TsParams( float minLum, float maxLum, float expShift)\n{\nTsPoint MIN_PT = TsPoint( lookup_ACESmin(minLum), minLum, 0.0);\nTsPoint MID_PT = TsPoint( 0.18, 4.8, 1.55);\nTsPoint MAX_PT = TsPoint( lookup_ACESmax(maxLum), maxLum, 0.0);\nfloat5 cLow;\ncLow = init_coefsLow( MIN_PT, MID_PT);\nfloat5 cHigh;\ncHigh = init_coefsHigh( MID_PT, MAX_PT);\nMIN_PT.x = shift(lookup_ACESmin(minLum),expShift);\nMID_PT.x = shift(0.18, expShift);\nMAX_PT.x = shift(lookup_ACESmax(maxLum),expShift);\nTsParams P = TsParams( TsPoint(MIN_PT.x, MIN_PT.y, MIN_PT.slope), TsPoint(MID_PT.x, MID_PT.y, MID_PT.slope),\nTsPoint(MAX_PT.x, MAX_PT.y, MAX_PT.slope), float6(cLow.x, cLow.y, cLow.z, cLow.w, cLow.m, cLow.m),\nfloat6(cHigh.x, cHigh.y, cHigh.z, cHigh.w, cHigh.m, cHigh.m) );\nreturn P;\n}\n\nfloat ssts( float x, TsParams C)\n{\nconst int N_KNOTS_LOW = 4;\nconst int N_KNOTS_HIGH = 4;\nfloat logx = log10( max(x, 1e-10));\nfloat logy = 0.0;\nfloat coefsLow[6];\ncoefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;\ncoefsLow[3] = C.coefsLow.d;coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;\nfloat coefsHigh[6];\ncoefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;\ncoefsHigh[3] = C.coefsHigh.d;coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;\nif ( logx <= log10(C.Min.x) ) {\nlogy = logx * C.Min.slope + ( log10(C.Min.y) - C.Min.slope * log10(C.Min.x) );\n} else if (( logx > log10(C.Min.x) ) && ( logx < log10(C.Mid.x) )) {\nfloat knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(C.Min.x)) / (log10(C.Mid.x) - log10(C.Min.x));\nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec3 cf = vec3( coefsLow[ j], coefsLow[ j + 1], coefsLow[ j + 2]);\nvec3 monomials = vec3( t * t, t, 1.0 );\nlogy = dot( monomials, MM * cf);\n} else if (( logx >= log10(C.Mid.x) ) && ( logx < log10(C.Max.x) )) {\nfloat knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(C.Mid.x)) / (log10(C.Max.x) - log10(C.Mid.x));\nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec3 cf = vec3( coefsHigh[ j], coefsHigh[ j + 1], coefsHigh[ j + 2]);\nvec3 monomials = vec3( t * t, t, 1.0 );\nlogy = dot( monomials, MM * cf);\n} else {\nlogy = logx * C.Max.slope + ( log10(C.Max.y) - C.Max.slope * log10(C.Max.x) );\n}\nreturn pow10(logy);\n}\n\nfloat inv_ssts( float y, TsParams C)\n{\nconst int N_KNOTS_LOW = 4;\nconst int N_KNOTS_HIGH = 4;\nfloat KNOT_INC_LOW = (log10(C.Mid.x) - log10(C.Min.x)) / float(N_KNOTS_LOW - 1);\nfloat KNOT_INC_HIGH = (log10(C.Max.x) - log10(C.Mid.x)) / float(N_KNOTS_HIGH - 1);\nfloat KNOT_Y_LOW[ N_KNOTS_LOW];\nfloat coefsLow[6];\ncoefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;\ncoefsLow[3] = C.coefsLow.d;coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;\nfloat coefsHigh[6];\ncoefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;\ncoefsHigh[3] = C.coefsHigh.d;coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;\nfor (int i = 0; i < N_KNOTS_LOW; i = i + 1) {\nKNOT_Y_LOW[ i] = ( coefsLow[i] + coefsLow[i + 1]) / 2.0;\n};\nfloat KNOT_Y_HIGH[ N_KNOTS_HIGH];\nfor (int i = 0; i < N_KNOTS_HIGH; i = i + 1) {\nKNOT_Y_HIGH[ i] = ( coefsHigh[i] + coefsHigh[i + 1]) / 2.0;\n};\nfloat logy = log10( max(y, 1e-10));\nfloat logx;\nif (logy <= log10(C.Min.y)) {\nlogx = log10(C.Min.x);\n} else if ( (logy > log10(C.Min.y)) && (logy <= log10(C.Mid.y)) ) {\nint j = 0;\nvec3 cf = vec3(0.0, 0.0, 0.0);\nif ( logy > KNOT_Y_LOW[ 0] && logy <= KNOT_Y_LOW[ 1]) {\ncf.x = coefsLow[0]; cf.y = coefsLow[1]; cf.z = coefsLow[2]; j = 0;\n} else if ( logy > KNOT_Y_LOW[ 1] && logy <= KNOT_Y_LOW[ 2]) {\ncf.x = coefsLow[1]; cf.y = coefsLow[2]; cf.z = coefsLow[3]; j = 1;\n} else if ( logy > KNOT_Y_LOW[ 2] && logy <= KNOT_Y_LOW[ 3]) {\ncf.x = coefsLow[2]; cf.y = coefsLow[3]; cf.z = coefsLow[4]; j = 2;\n}\nvec3 tmp = MM * cf;\nfloat a = tmp.x; float b = tmp.y; float c = tmp.z;\nc = c - logy;\nfloat d = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -d - b);\nlogx = log10(C.Min.x) + ( t + float(j)) * float(KNOT_INC_LOW);\n} else if ( (logy > log10(C.Mid.y)) && (logy < log10(C.Max.y)) ) {\nint j = 0;\nvec3 cf = vec3(0.0, 0.0, 0.0);\nif ( logy >= KNOT_Y_HIGH[ 0] && logy <= KNOT_Y_HIGH[ 1]) {\ncf.x = coefsHigh[0]; cf.y = coefsHigh[1]; cf.z = coefsHigh[2]; j = 0;\n} else if ( logy > KNOT_Y_HIGH[ 1] && logy <= KNOT_Y_HIGH[ 2]) {\ncf.x = coefsHigh[1]; cf.y = coefsHigh[2]; cf.z = coefsHigh[3]; j = 1;\n} else if ( logy > KNOT_Y_HIGH[ 2] && logy <= KNOT_Y_HIGH[ 3]) {\ncf.x = coefsHigh[2]; cf.y = coefsHigh[3]; cf.z = coefsHigh[4]; j = 2;\n}\nvec3 tmp = MM * cf;\nfloat a = tmp.x; float b = tmp.y; float c = tmp.z;\nc = c - logy;\nfloat d = sqrt( b * b - 4.0 * a * c);\nfloat t = ( 2.0 * c) / ( -d - b);\nlogx = log10(C.Mid.x) + ( t + float(j)) * float(KNOT_INC_HIGH);\n} else {\nlogx = log10(C.Max.x);\n}\nreturn pow10(logx);\n}\n\nvec3 ssts_f3( vec3 x, TsParams C)\n{\nvec3 Out;\nOut.x = ssts( x.x, C); Out.y = ssts( x.y, C); Out.z = ssts( x.z, C);\nreturn Out;\n}\n\nvec3 inv_ssts_f3( vec3 x, TsParams C)\n{\nvec3 Out;\nOut.x = inv_ssts( x.x, C); Out.y = inv_ssts( x.y, C); Out.z = inv_ssts( x.z, C);\nreturn Out;\n}\n\nfloat glow_fwd( float ycIn, float glowGainIn, float glowMid)\n{\nfloat glowGainOut;\nif (ycIn <= 2.0/3.0 * glowMid) {\nglowGainOut = glowGainIn;\n} else if ( ycIn >= 2.0 * glowMid) {\nglowGainOut = 0.0;\n} else {\nglowGainOut = glowGainIn * (glowMid / ycIn - 1.0/2.0);\n}\nreturn glowGainOut;\n}\n\nfloat glow_inv( float ycOut, float glowGainIn, float glowMid)\n{\nfloat glowGainOut;\nif (ycOut <= ((1.0 + glowGainIn) * 2.0/3.0 * glowMid)) {\nglowGainOut = -glowGainIn / (1.0 + glowGainIn);\n} else if ( ycOut >= (2.0 * glowMid)) {\nglowGainOut = 0.0;\n} else {\nglowGainOut = glowGainIn * (glowMid / ycOut - 1.0/2.0) / (glowGainIn / 2.0 - 1.0);\n}\nreturn glowGainOut;\n}\n\nfloat sigmoid_shaper( float x)\n{\nfloat t = max( 1.0 - abs( x / 2.0), 0.0);\nfloat y = 1.0 + _sign(x) * (1.0 - t * t);\nreturn y / 2.0;\n}\n\nfloat cubic_basis_shaper( float x, float w) {\nmat4 M = mat4(vec4( -1.0/6.0, 3.0/6.0, -3.0/6.0, 1.0/6.0 ),\nvec4( 3.0/6.0, -6.0/6.0, 3.0/6.0, 0.0/6.0 ),\nvec4( -3.0/6.0, 0.0/6.0, 3.0/6.0, 0.0/6.0 ),\nvec4( 1.0/6.0, 4.0/6.0, 1.0/6.0, 0.0/6.0 ) );\nfloat knots[5];\nknots[0] = -w/2.0; knots[1] = -w/4.0; knots[2] = 0.0;\nknots[3] = w/4.0; knots[4] = w/2.0;\nfloat y = 0.0;\nif ((x > knots[0]) && (x < knots[4])) {  \nfloat knot_coord = (x - knots[0]) * 4.0/w;  \nint j = int(knot_coord);\nfloat t = knot_coord - float(j);\nvec4 monomials = vec4( t*t*t, t*t, t, 1.0);\nif ( j == 3) {\ny = monomials.x * M[0][0] + monomials.y * M[1][0] + \nmonomials.z * M[2][0] + monomials.w * M[3][0];\n} else if ( j == 2) {\ny = monomials.x * M[0][1] + monomials.y * M[1][1] + \nmonomials.z * M[2][1] + monomials.w * M[3][1];\n} else if ( j == 1) {\ny = monomials.x * M[0][2] + monomials.y * M[1][2] + \nmonomials.z * M[2][2] + monomials.w * M[3][2];\n} else if ( j == 0) {\ny = monomials.x * M[0][3] + monomials.y * M[1][3] + \nmonomials.z * M[2][3] + monomials.w * M[3][3];\n} else {\ny = 0.0;}}\nreturn y * 3.0/2.0;\n}\n\nfloat center_hue( float hue, float centerH)\n{\nfloat hueCentered = hue - centerH;\nif (hueCentered < -180.0) hueCentered = hueCentered + 360.0;\nelse if (hueCentered > 180.0) hueCentered = hueCentered - 360.0;\nreturn hueCentered;\n}\n\nfloat uncenter_hue( float hueCentered, float centerH)\n{\nfloat hue = hueCentered + centerH;\nif (hue < 0.0) hue = hue + 360.0;\nelse if (hue > 360.0) hue = hue - 360.0;\nreturn hue;\n}\n\nvec3 rrt_sweeteners( vec3 In)\n{\nvec3 aces = In;\nfloat saturation = rgb_2_saturation( aces);\nfloat ycIn = rgb_2_yc( aces);\nfloat s = sigmoid_shaper( (saturation - 0.4) / 0.2);\nfloat addedGlow = 1.0 + glow_fwd( ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\naces = aces * addedGlow;\nfloat hue = rgb_2_hue( aces);\nfloat centeredHue = center_hue( hue, RRT_RED_HUE);\nfloat hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH);\naces.x = aces.x + hueWeight * saturation * (RRT_RED_PIVOT - aces.x) * (1.0 - RRT_RED_SCALE);\naces = max( aces, 0.0);\nvec3 rgbPre = AP0_2_AP1_MAT * aces;\nrgbPre = max( rgbPre, 0.0);\nrgbPre = calc_sat_adjust_matrix( RRT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * rgbPre;\nreturn rgbPre;\n}\n\nvec3 inv_rrt_sweeteners( vec3 In)\n{\nvec3 rgbPost = In;\nrgbPost = invert_f33(calc_sat_adjust_matrix( RRT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * rgbPost;\nrgbPost = max( rgbPost, 0.0);\nvec3 aces = AP1_2_AP0_MAT * rgbPost;\naces = max( aces, 0.0);\nfloat hue = rgb_2_hue( aces);\nfloat centeredHue = center_hue( hue, RRT_RED_HUE);\nfloat hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH);\nfloat minChan;\nif (centeredHue < 0.0) {\nminChan = aces.y;\n} else {\nminChan = aces.z;\n}\nfloat a = hueWeight * (1.0 - RRT_RED_SCALE) - 1.0;\nfloat b = aces.x - hueWeight * (RRT_RED_PIVOT + minChan) * (1.0 - RRT_RED_SCALE);\nfloat c = hueWeight * RRT_RED_PIVOT * minChan * (1.0 - RRT_RED_SCALE);\naces.x = ( -b - sqrt( b * b - 4.0 * a * c)) / ( 2.0 * a);\nfloat saturation = rgb_2_saturation( aces);\nfloat ycOut = rgb_2_yc( aces);\nfloat s = sigmoid_shaper( (saturation - 0.4) / 0.2);\nfloat reducedGlow = 1.0 + glow_inv( ycOut, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\naces = aces * reducedGlow;\nreturn aces;\n}\n\nvec3 limit_to_primaries( vec3 XYZ, Chromaticities LIMITING_PRI)\n{\nmat3 XYZ_2_LIMITING_PRI_MAT = XYZtoRGB( LIMITING_PRI);\nmat3 LIMITING_PRI_2_XYZ_MAT = RGBtoXYZ( LIMITING_PRI);\nvec3 rgb = XYZ_2_LIMITING_PRI_MAT * XYZ;\nvec3 limitedRgb = clamp( rgb, 0.0, 1.0);\nreturn LIMITING_PRI_2_XYZ_MAT * limitedRgb;\n}\n\nvec3 dark_to_dim( vec3 XYZ)\n{\nvec3 xyY = XYZ_2_xyY(XYZ);\nxyY.z = max( xyY.z, 0.0);\nxyY.z = pow( xyY.z, DIM_SURROUND_GAMMA);\nreturn xyY_2_XYZ(xyY);\n}\n\nvec3 dim_to_dark( vec3 XYZ)\n{\nvec3 xyY = XYZ_2_xyY(XYZ);\nxyY.z = max( xyY.z, 0.0);\nxyY.z = pow( xyY.z, 1.0 / DIM_SURROUND_GAMMA);\nreturn xyY_2_XYZ(xyY);\n}\n\nvec3 outputTransform\n(\nvec3 In,\nfloat Y_MIN,\nfloat Y_MID,\nfloat Y_MAX,\nChromaticities DISPLAY_PRI,\nChromaticities LIMITING_PRI,\nint EOTF,\nint SURROUND,\nbool STRETCH_BLACK,\nbool D60_SIM,\nbool LEGAL_RANGE\n)\n{\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nTsParams PARAMS_DEFAULT = init_TsParams( Y_MIN, Y_MAX, 0.0);\nfloat expShift = log2(inv_ssts(Y_MID, PARAMS_DEFAULT)) - log2(0.18);\nTsParams PARAMS = init_TsParams( Y_MIN, Y_MAX, expShift);\nvec3 rgbPre = rrt_sweeteners(In);\nvec3 rgbPost = ssts_f3(rgbPre, PARAMS);\nvec3 linearCV = Y_2_linCV_f3( rgbPost, Y_MAX, Y_MIN);\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nif (SURROUND == 0) {\n} else if (SURROUND == 1) {\nif ((EOTF == 1) || (EOTF == 2) || (EOTF == 3)) {\nXYZ = dark_to_dim( XYZ);\n}\n} else if (SURROUND == 2) {\n}\nXYZ = limit_to_primaries( XYZ, LIMITING_PRI);\nif (D60_SIM == false) {\nif ((DISPLAY_PRI.white.x != AP0.white.x) && (DISPLAY_PRI.white.y != AP0.white.y)) {\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\n}\n}\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nif (D60_SIM == true) {\nfloat SCALE = 1.0;\nif ((DISPLAY_PRI.white.x == 0.3127) && (DISPLAY_PRI.white.y == 0.329)) {\nSCALE = 0.96362;\n}\nelse if ((DISPLAY_PRI.white.x == 0.314) && (DISPLAY_PRI.white.y == 0.351)) {\nlinearCV.x = roll_white_fwd( linearCV.x, 0.918, 0.5);\nlinearCV.y = roll_white_fwd( linearCV.y, 0.918, 0.5);\nlinearCV.z = roll_white_fwd( linearCV.z, 0.918, 0.5);\nSCALE = 0.96;\n}\nlinearCV = linearCV * SCALE;\n}\nlinearCV = max( linearCV, 0.0);\nvec3 outputCV;\nif (EOTF == 0) {\nif (STRETCH_BLACK == true) {\noutputCV = Y_2_ST2084_f3( max( linCV_2_Y_f3(linearCV, Y_MAX, 0.0), 0.0) );\n} else {\noutputCV = Y_2_ST2084_f3( linCV_2_Y_f3(linearCV, Y_MAX, Y_MIN) );\n}\n} else if (EOTF == 1) {\noutputCV = bt1886_r_f3( linearCV, 2.4, 1.0, 0.0);\n} else if (EOTF == 2) {\noutputCV = moncurve_r_f3( linearCV, 2.4, 0.055);\n} else if (EOTF == 3) {\noutputCV = pow_f3( linearCV, 1.0/2.6);\n} else if (EOTF == 4) {\noutputCV = linCV_2_Y_f3(linearCV, Y_MAX, Y_MIN);\n} else if (EOTF == 5) {\nif (STRETCH_BLACK == true) {\noutputCV = Y_2_ST2084_f3( max( linCV_2_Y_f3(linearCV, Y_MAX, 0.0), 0.0) );\n}\nelse {\noutputCV = Y_2_ST2084_f3( linCV_2_Y_f3(linearCV, Y_MAX, Y_MIN) );\n}\noutputCV = ST2084_2_HLG_1000nits_f3( outputCV);\n}\nif (LEGAL_RANGE == true) {\noutputCV = fullRange_to_smpteRange_f3( outputCV);\n}\nreturn outputCV;\n}\n\nvec3 Custom_OutputTransform(vec3 aces, float Y_MIN, float Y_MID, float Y_MAX, int p_OT_Display, int p_OT_Limit, int EOTF, int SURROUND, bool STRETCH_BLACK, bool D60_SIM, bool LEGAL_RANGE)\n{\nChromaticities OT_DISPLAY_PRI, OT_LIMIT_PRI;\nOT_DISPLAY_PRI = REC2020_PRI;\nOT_LIMIT_PRI = REC2020_PRI;\n\nif(p_OT_Display == 1)\nOT_DISPLAY_PRI = P3D60_PRI;\nif(p_OT_Display == 2)\nOT_DISPLAY_PRI = P3D65_PRI;\nif(p_OT_Display == 3)\nOT_DISPLAY_PRI = P3DCI_PRI;\nif(p_OT_Display == 1)\nOT_DISPLAY_PRI = REC709_PRI;\n\nif(p_OT_Limit == 1)\nOT_LIMIT_PRI = P3D60_PRI;\nif(p_OT_Limit == 2)\nOT_LIMIT_PRI = P3D65_PRI;\nif(p_OT_Limit == 3)\nOT_LIMIT_PRI = P3DCI_PRI;\nif(p_OT_Limit == 1)\nOT_LIMIT_PRI = REC709_PRI;\n\nreturn outputTransform(aces, Y_MIN, Y_MID, Y_MAX, OT_DISPLAY_PRI, OT_LIMIT_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE);\n}\n\nvec3 invOutputTransform\n(\nvec3 In,\nfloat Y_MIN,\nfloat Y_MID,\nfloat Y_MAX,\nChromaticities DISPLAY_PRI,\nChromaticities LIMITING_PRI,\nint EOTF,\nint SURROUND,\nbool STRETCH_BLACK,\nbool D60_SIM,\nbool LEGAL_RANGE\n)\n{\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ( DISPLAY_PRI);\nTsParams PARAMS_DEFAULT = init_TsParams( Y_MIN, Y_MAX, 0.0);\nfloat expShift = log2(inv_ssts(Y_MID, PARAMS_DEFAULT)) - log2(0.18);\nTsParams PARAMS = init_TsParams( Y_MIN, Y_MAX, expShift);\nvec3 outputCV = In;\nif (LEGAL_RANGE == true) {\noutputCV = smpteRange_to_fullRange_f3( outputCV);\n}\nvec3 linearCV;\nif (EOTF == 0) {\nif (STRETCH_BLACK == true) {\nlinearCV = Y_2_linCV_f3( ST2084_2_Y_f3( outputCV), Y_MAX, 0.0);\n} else {\nlinearCV = Y_2_linCV_f3( ST2084_2_Y_f3( outputCV), Y_MAX, Y_MIN);\n}\n} else if (EOTF == 1) {\nlinearCV = bt1886_f_f3( outputCV, 2.4, 1.0, 0.0);\n} else if (EOTF == 2) {\nlinearCV = moncurve_f_f3( outputCV, 2.4, 0.055);\n} else if (EOTF == 3) {\nlinearCV = pow_f3( outputCV, 2.6);\n} else if (EOTF == 4) {\nlinearCV = Y_2_linCV_f3( outputCV, Y_MAX, Y_MIN);\n} else if (EOTF == 5) {\noutputCV = HLG_2_ST2084_1000nits_f3( outputCV);\nif (STRETCH_BLACK == true) {\nlinearCV = Y_2_linCV_f3( ST2084_2_Y_f3( outputCV), Y_MAX, 0.0);\n} else {\nlinearCV = Y_2_linCV_f3( ST2084_2_Y_f3( outputCV), Y_MAX, Y_MIN);\n}\n}\nif (D60_SIM == true) {\nfloat SCALE = 1.0;\nif ((DISPLAY_PRI.white.x == 0.3127) && (DISPLAY_PRI.white.y == 0.329)) {\nSCALE = 0.96362;\nlinearCV = linearCV * (1.0 / SCALE);\n}\nelse if ((DISPLAY_PRI.white.x == 0.314) && (DISPLAY_PRI.white.y == 0.351)) {\nSCALE = 0.96;\nlinearCV.x = roll_white_rev( linearCV.x / SCALE, 0.918, 0.5);\nlinearCV.y = roll_white_rev( linearCV.y / SCALE, 0.918, 0.5);\nlinearCV.z = roll_white_rev( linearCV.z / SCALE, 0.918, 0.5);\n}\n}\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nif (D60_SIM == false) {\nif ((DISPLAY_PRI.white.x != AP0.white.x) && (DISPLAY_PRI.white.y != AP0.white.y)) {\nXYZ = invert_f33(calculate_cat_matrix(AP0.white, REC709_PRI.white)) * XYZ;\n}\n}\nif (SURROUND == 0) {\n} else if (SURROUND == 1) {\n\nif ((EOTF == 1) || (EOTF == 2) || (EOTF == 3)) {\nXYZ = dim_to_dark( XYZ);\n}\n} else if (SURROUND == 2) {\n}\nlinearCV = XYZtoRGB(AP1) * XYZ;\nvec3 rgbPost = linCV_2_Y_f3( linearCV, Y_MAX, Y_MIN);\nvec3 rgbPre = inv_ssts_f3( rgbPost, PARAMS);\nvec3 aces = inv_rrt_sweeteners( rgbPre);\nreturn aces;\n}\n\nvec3 Custom_InvOutputTransform(vec3 aces, float Y_MIN, float Y_MID, float Y_MAX, int OT_Display, int OT_Limit, int EOTF, int SURROUND, bool STRETCH_BLACK, bool D60_SIM, bool LEGAL_RANGE)\n{\nChromaticities OT_DISPLAY_PRI, OT_LIMIT_PRI;\nOT_DISPLAY_PRI = REC2020_PRI;\nOT_LIMIT_PRI = REC2020_PRI;\nif(OT_Display == 1)\nOT_DISPLAY_PRI = P3D60_PRI;\nif(OT_Display == 2)\nOT_DISPLAY_PRI = P3D65_PRI;\nif(OT_Display == 3)\nOT_DISPLAY_PRI = P3DCI_PRI;\nif(OT_Display == 1)\nOT_DISPLAY_PRI = REC709_PRI;\n\nif(OT_Limit == 1)\nOT_LIMIT_PRI = P3D60_PRI;\nif(OT_Limit == 2)\nOT_LIMIT_PRI = P3D65_PRI;\nif(OT_Limit == 3)\nOT_LIMIT_PRI = P3DCI_PRI;\nif(OT_Limit == 1)\nOT_LIMIT_PRI = REC709_PRI;\n\nreturn invOutputTransform(aces, Y_MIN, Y_MID, Y_MAX, OT_DISPLAY_PRI, OT_LIMIT_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE);\n}\n\nvec3 InvODT_Rec709( vec3 outputCV) {\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(REC709_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nvec3 linearCV = bt1886_f_f3( outputCV, DISPGAMMA, L_W, L_B);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nXYZ = XYZ * invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white));\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nvec3 rgbPre = linCV_2_Y_f3( linearCV, 48.0, pow(10.0, log10(0.02)));\nvec3 rgbPost;\nrgbPost = segmented_spline_c9_rev_f3( rgbPre);\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\nreturn oces;\n}\n\nvec3 InvODT_sRGB( vec3 outputCV) {\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(REC709_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\nvec3 linearCV;\nlinearCV = moncurve_f_f3( outputCV, DISPGAMMA, OFFSET);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nXYZ = XYZ * invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white));\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nvec3 rgbPre = linCV_2_Y_f3( linearCV, 48.0, pow(10.0, log10(0.02)));\nvec3 rgbPost;\nrgbPost = segmented_spline_c9_rev_f3( rgbPre);\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\nreturn oces;\n}\n\nvec3 IDT_sRGB( vec3 rgb) {\nvec3 aces;\naces = InvODT_sRGB(rgb);\naces = segmented_spline_c5_rev_f3( aces);\naces = max(aces, 0.0);\nreturn aces;\n}\n\nvec3 IDT_rec709( vec3 rgb) {\nvec3 aces;\naces = InvODT_Rec709(rgb);\naces = segmented_spline_c5_rev_f3( aces);\naces = max(aces, 0.0);\nreturn aces;\n}\n\nfloat lin_to_ACEScct( float In)\n{\nif (In <= X_BRK)\nreturn A * In + B;\nelse\nreturn (log2(In) + 9.72) / 17.52;\n}\n\nfloat ACEScct_to_lin( float In)\n{\nif (In > Y_BRK)\nreturn pow( 2.0, In * 17.52 - 9.72);\nelse\nreturn (In - B) / A;\n}\n\nvec3 ACES_to_ACEScct( vec3 In)\n{\nvec3 ap1_lin = AP0_2_AP1_MAT * In;\nvec3 acescct;\nacescct.x = lin_to_ACEScct( ap1_lin.x); acescct.y = lin_to_ACEScct( ap1_lin.y); acescct.z = lin_to_ACEScct( ap1_lin.z);\nreturn acescct;\n}\n\nvec3 ACEScct_to_ACES( vec3 In)\n{\nvec3 ap1_lin;\nap1_lin.x = ACEScct_to_lin( In.x); ap1_lin.y = ACEScct_to_lin( In.y); ap1_lin.z = ACEScct_to_lin( In.z);\nreturn AP1_2_AP0_MAT * ap1_lin;\n}\n\nvec3 ASCCDL_inACEScct\n(\nvec3 acesIn,\nvec3 SLOPE,\nvec3 OFFSET,\nvec3 POWER,\nfloat SAT\n)\n{\nvec3 acescct = ACES_to_ACEScct( acesIn);\nacescct.x = pow( clamp( (acescct.x * SLOPE.x) + OFFSET.x, 0.0, 1.0), 1.0 / POWER.x);\nacescct.y = pow( clamp( (acescct.y * SLOPE.y) + OFFSET.y, 0.0, 1.0), 1.0 / POWER.y);\nacescct.z = pow( clamp( (acescct.z * SLOPE.z) + OFFSET.z, 0.0, 1.0), 1.0 / POWER.z);\nfloat luma = 0.2126 * acescct.x + 0.7152 * acescct.y + 0.0722 * acescct.z;\nfloat satClamp = max(SAT, 0.0);\nacescct.x = luma + satClamp * (acescct.x - luma);\nacescct.y = luma + satClamp * (acescct.y - luma);\nacescct.z = luma + satClamp * (acescct.z - luma);\nreturn ACEScct_to_ACES( acescct);\n}\n\nvec3 gamma_adjust_linear( vec3 rgbIn, float GAMMA, float PIVOT)\n{\nfloat SCALAR = PIVOT / pow( PIVOT, GAMMA);\nvec3 rgbOut = rgbIn;\nif (rgbIn.x > 0.0) rgbOut.x = pow( rgbIn.x, GAMMA) * SCALAR;\nif (rgbIn.y > 0.0) rgbOut.y = pow( rgbIn.y, GAMMA) * SCALAR;\nif (rgbIn.z > 0.0) rgbOut.z = pow( rgbIn.z, GAMMA) * SCALAR;\nreturn rgbOut;\n}\n\nvec3 sat_adjust( vec3 rgbIn, float SAT_FACTOR)\n{\nvec3 RGB2Y = vec3(RGBtoXYZ( REC709_PRI)[0][1], RGBtoXYZ( REC709_PRI)[1][1], RGBtoXYZ( REC709_PRI)[2][1]);\nmat3 SAT_MAT = calc_sat_adjust_matrix( SAT_FACTOR, RGB2Y);\nreturn SAT_MAT * rgbIn;\n}\n\nvec3 rgb_2_yab( vec3 rgb)\n{\nvec3 yab = mat3(vec3(1.0/3.0, 1.0/2.0, 0.0), vec3(1.0/3.0, -1.0/4.0, sqrt3over4), vec3(1.0/3.0, -1.0/4.0, -sqrt3over4)) * rgb;\nreturn yab;\n}\n\nvec3 yab_2_rgb( vec3 yab)\n{\nvec3 rgb = invert_f33(mat3(vec3(1.0/3.0, 1.0/2.0, 0.0), vec3(1.0/3.0, -1.0/4.0, sqrt3over4), vec3(1.0/3.0, -1.0/4.0, -sqrt3over4))) * yab;\nreturn rgb;\n}\n\nvec3 yab_2_ych(vec3 yab)\n{\nvec3 ych = yab;\nfloat yb = yab.y * yab.y + yab.z * yab.z;\nych.y = sqrt(yb);\nych.z = atan(yab.z, yab.y) * (180.0 / 3.14159265358979323846264338327950288);\nif (ych.z < 0.0) ych.z += 360.0;\nreturn ych;\n}\n\nvec3 ych_2_yab( vec3 ych )\n{\nvec3 yab;\nyab.x = ych.x;\nfloat h = ych.z * (3.14159265358979323846264338327950288 / 180.0);\nyab.y = ych.y * cos(h);\nyab.z = ych.y * sin(h);\nreturn yab;\n}\n\nvec3 rgb_2_ych( vec3 rgb)\n{\nreturn yab_2_ych( rgb_2_yab( rgb));\n}\n\nvec3 ych_2_rgb( vec3 ych)\n{\nreturn yab_2_rgb( ych_2_yab( ych));\n}\n\nvec3 scale_C_at_H( vec3 rgb, float centerH, float widthH, float percentC)\n{\nvec3 new_rgb = rgb;\nvec3 ych = rgb_2_ych( rgb);\nif (ych.y > 0.0) {\nfloat centeredHue = center_hue( ych.z, centerH);\nfloat f_H = cubic_basis_shaper( centeredHue, widthH);\nif (f_H > 0.0) {\nvec3 new_ych = ych;\nnew_ych.y = ych.y * (f_H * (percentC - 1.0) + 1.0);\nnew_rgb = ych_2_rgb( new_ych);\n} else {\nnew_rgb = rgb;\n}}\nreturn new_rgb;\n}\n\nvec3 scale_C_at_H_ych( vec3 ych, float centerH, float widthH, float percentC)\n{\nvec3 new_ych = ych;\nif (ych.y > 0.0) {\nfloat centeredHue = center_hue( ych.z, centerH);\nfloat f_H = cubic_basis_shaper( centeredHue, widthH);\nif (f_H > 0.0)\nnew_ych.y = ych.y * (f_H * (percentC - 1.0) + 1.0);\n}\nreturn new_ych;\n}\n\nvec3 rotate_H_in_H( vec3 rgb, float centerH, float widthH, float degreesShift)\n{\nvec3 ych = rgb_2_ych( rgb);\nvec3 new_ych = ych;\nfloat centeredHue = center_hue( ych.z, centerH);\nfloat f_H = cubic_basis_shaper( centeredHue, widthH);\nfloat old_hue = centeredHue;\nfloat new_hue = centeredHue + degreesShift;\nmat2 table = mat2( vec2(0.0, old_hue), vec2(1.0, new_hue) );\nfloat blended_hue = interpolate1D( table, f_H);\nif (f_H > 0.0) new_ych.z = uncenter_hue(blended_hue, centerH);\nreturn ych_2_rgb( new_ych);\n}\n\nvec3 rotate_H_in_H_ych( vec3 ych, float centerH, float widthH, float degreesShift)\n{\nvec3 new_ych = ych;\nfloat centeredHue = center_hue( ych.z, centerH);\nfloat f_H = cubic_basis_shaper( centeredHue, widthH);\nfloat old_hue = centeredHue;\nfloat new_hue = centeredHue + degreesShift;\nmat2 table = mat2( vec2(0.0, old_hue), vec2(1.0, new_hue) );\nfloat blended_hue = interpolate1D( table, f_H);\nif (f_H > 0.0) new_ych.z = uncenter_hue(blended_hue, centerH);\nreturn new_ych;\n}\n\nvec3 scale_C( vec3 rgb, float percentC)\n{\nvec3 ych = rgb_2_ych( rgb);\nych.y = ych.y * percentC;\nreturn ych_2_rgb( ych);\n}\n\nvec3 scale_C_ych( vec3 ych, float percentC)\n{\nvec3 new_ych = ych;\nnew_ych.y = ych.y * percentC;\nreturn new_ych;\n}\n\nvec3 overlay_f3( vec3 a, vec3 b)\n{\nfloat LUMA_CUT = lin_to_ACEScct( 0.5);\nfloat luma = 0.2126 * a.x + 0.7152 * a.y + 0.0722 * a.z;\nvec3 Out;\nif (luma < LUMA_CUT) {\nOut.x = 2.0 * a.x * b.x;\nOut.y = 2.0 * a.y * b.y;\nOut.z = 2.0 * a.z * b.z;\n} else {\nOut.x = 1.0 - (2.0 * (1.0 - a.x) * (1.0 - b.x));\nOut.y = 1.0 - (2.0 * (1.0 - a.y) * (1.0 - b.y));\nOut.z = 1.0 - (2.0 * (1.0 - a.z) * (1.0 - b.z));\n}\nreturn Out;\n}\n\nvec3 LMT_PFE( vec3 aces)\n{\naces = scale_C(aces, 0.7);\nvec3 SLOPE = vec3(1.0, 1.0, 0.94);\nvec3 OFFSET = vec3(0.0, 0.0, 0.02);\nvec3 POWER = vec3(1.0, 1.0, 1.0);\nfloat SAT = 1.0;\naces = ASCCDL_inACEScct(aces, SLOPE, OFFSET, POWER, SAT);\naces = gamma_adjust_linear(aces, 1.5, 0.18);\naces = rgb_2_ych(aces);\naces = rotate_H_in_H_ych(aces, 0.0, 30.0, 5.0);\naces = rotate_H_in_H_ych(aces, 80.0, 60.0, -15.0);\naces = rotate_H_in_H_ych(aces, 52.0, 50.0, -14.0);\naces = scale_C_at_H_ych(aces, 45.0, 40.0, 1.4);\naces = rotate_H_in_H_ych(aces, 190.0, 40.0, 30.0);\naces = scale_C_at_H_ych(aces, 240.0, 120.0, 1.4);\naces = ych_2_rgb(aces);\nreturn aces;\n}\n\nvec3 LMT_PFE_Custom( vec3 aces)\n{\nif(p_LMTScale1 != 1.0)\naces = scale_C(aces, p_LMTScale1);\nif(!(p_LMTScale2 == 1.0 && p_LMTScale3 == 0.0 && p_LMTScale4 == 1.0))\n{\nvec3 SLOPE = vec3(p_LMTScale2, p_LMTScale2, p_LMTScale2);\nvec3 OFFSET = vec3(p_LMTScale3, p_LMTScale3, p_LMTScale3);\nvec3 POWER = vec3(p_LMTScale4, p_LMTScale4, p_LMTScale4);\naces = ASCCDL_inACEScct(aces, SLOPE, OFFSET, POWER, p_LMTScale5);\n}\nif(p_LMTScale5 != 1.0)\naces = gamma_adjust_linear(aces, p_LMTScale6, p_LMTScale7);\naces = rgb_2_ych(aces);\nif(p_LMTScale9 != 0.0)\naces = rotate_H_in_H_ych(aces, p_LMTScale8, p_LMTScale9, p_LMTScale10);\nif(p_LMTScale12 != 0.0)\naces = rotate_H_in_H_ych(aces, p_LMTScale11, p_LMTScale12, p_LMTScale13);\nif(p_LMTScale15 != 0.0)\naces = rotate_H_in_H_ych(aces, p_LMTScale14, p_LMTScale15, p_LMTScale16);\nif(p_LMTScale18 != 1.0)\naces = scale_C_at_H_ych(aces, p_LMTScale17, p_LMTScale18, p_LMTScale19);\nif(p_LMTScale21 != 0.0)\naces = rotate_H_in_H_ych(aces, p_LMTScale20, p_LMTScale21, p_LMTScale22);\nif(p_LMTScale24 != 1.0)\naces = scale_C_at_H_ych(aces, p_LMTScale23, p_LMTScale24, p_LMTScale25);\naces = ych_2_rgb(aces);\nreturn aces;\n}\n\nvec3 LMT_Bleach( vec3 aces)\n{\nvec3 a, b, blend;\na = sat_adjust( aces, 0.9);\na = a * 2.0;\nb = sat_adjust( aces, 0.0);\nb = gamma_adjust_linear( b, 1.2, 0.18);\na = ACES_to_ACEScct( a);\nb = ACES_to_ACEScct( b);\nblend = overlay_f3( a, b);\naces = ACEScct_to_ACES( blend);\n\nreturn aces;\n}\n\nvec3 LMT_BlueLightArtifactFix( vec3 aces)\n{\nmat3 correctionMatrix = mat3(\nvec3(0.9404372683, 0.0083786969, 0.0005471261 ),\nvec3(-0.0183068787, 0.8286599939, -0.0008833746 ),\nvec3( 0.0778696104, 0.1629613092, 1.0003362486 ) );\nvec3 acesMod = correctionMatrix * aces;\nreturn acesMod;\n}\n\nvec3 RRT( vec3 aces)\n{\nfloat saturation = rgb_2_saturation( aces);\nfloat ycIn = rgb_2_yc( aces);\nfloat s = sigmoid_shaper( (saturation - 0.4) / 0.2);\nfloat addedGlow = 1.0 + glow_fwd( ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\naces = aces * addedGlow;\nfloat hue = rgb_2_hue( aces);\nfloat centeredHue = center_hue( hue, RRT_RED_HUE);\nfloat hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH);\naces.x = aces.x + hueWeight * saturation * (RRT_RED_PIVOT - aces.x) * (1.0 - RRT_RED_SCALE);\naces = max( aces, 0.0);\nvec3 rgbPre = AP0_2_AP1_MAT * aces;\nrgbPre = max( rgbPre, 0.0);\nrgbPre = calc_sat_adjust_matrix( RRT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * rgbPre;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c5_fwd( rgbPre.x);\nrgbPost.y = segmented_spline_c5_fwd( rgbPre.y);\nrgbPost.z = segmented_spline_c5_fwd( rgbPre.z);\nvec3 rgbOces = AP1_2_AP0_MAT * rgbPost;\nreturn rgbOces;\n}\n\nvec3 InvRRT( vec3 oces)\n{\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c5_rev( rgbPre.x);\nrgbPost.y = segmented_spline_c5_rev( rgbPre.y);\nrgbPost.z = segmented_spline_c5_rev( rgbPre.z);\nrgbPost = invert_f33(RRT_SAT_MAT) * rgbPost;\nrgbPost = max( rgbPost, 0.0);\nvec3 aces = AP1_2_AP0_MAT * rgbPost;\naces = max( aces, 0.0);\nfloat hue = rgb_2_hue( aces);\nfloat centeredHue = center_hue( hue, RRT_RED_HUE);\nfloat hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH);\nfloat minChan;\nif (centeredHue < 0.0) {\nminChan = aces.y;\n} else {\nminChan = aces.z;\n}\nfloat a = hueWeight * (1.0 - RRT_RED_SCALE) - 1.0;\nfloat b = aces.x - hueWeight * (RRT_RED_PIVOT + minChan) * (1.0 - RRT_RED_SCALE);\nfloat c = hueWeight * RRT_RED_PIVOT * minChan * (1.0 - RRT_RED_SCALE);\naces.x = ( -b - sqrt( b * b - 4.0 * a * c)) / ( 2.0 * a);\nfloat saturation = rgb_2_saturation( aces);\nfloat ycOut = rgb_2_yc( aces);\nfloat s = sigmoid_shaper( (saturation - 0.4) / 0.2);\nfloat reducedGlow = 1.0 + glow_inv( ycOut, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\naces = aces * reducedGlow;\n\nreturn aces;\n}\n\nvec3 ODT_Rec709_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nbool legalRange = false;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\n\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\n\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = bt1886_r( linearCV.x, DISPGAMMA, L_W, L_B);\noutputCV.y = bt1886_r( linearCV.y, DISPGAMMA, L_W, L_B);\noutputCV.z = bt1886_r( linearCV.z, DISPGAMMA, L_W, L_B);\n\nif(legalRange) outputCV = fullRange_to_smpteRange_f3( outputCV);\n\nreturn outputCV;\n}\n\nvec3 ODT_Rec709_D60sim_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nfloat SCALE = 0.955;\nbool legalRange = false;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = min( linearCV.x, 1.0) * SCALE;\nlinearCV.y = min( linearCV.y, 1.0) * SCALE;\nlinearCV.z = min( linearCV.z, 1.0) * SCALE;\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = bt1886_r( linearCV.x, DISPGAMMA, L_W, L_B);\noutputCV.y = bt1886_r( linearCV.y, DISPGAMMA, L_W, L_B);\noutputCV.z = bt1886_r( linearCV.z, DISPGAMMA, L_W, L_B);\n\nif (legalRange) {\noutputCV = fullRange_to_smpteRange_f3( outputCV);\n}\n\nreturn outputCV;\n}\n\nvec3 ODT_Rec2020_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC2020_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nbool legalRange = false;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = bt1886_r( linearCV.x, DISPGAMMA, L_W, L_B);\noutputCV.y = bt1886_r( linearCV.y, DISPGAMMA, L_W, L_B);\noutputCV.z = bt1886_r( linearCV.z, DISPGAMMA, L_W, L_B);\n\nif (legalRange) {\noutputCV = fullRange_to_smpteRange_f3( outputCV);\n}\n\nreturn outputCV;\n}\n\nvec3 ODT_Rec2020_ST2084_1000nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC2020_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_1000nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_1000nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_1000nits());\nrgbPost = rgbPost -pow10(-4.4550166483);\n\nvec3 XYZ = RGBtoXYZ(AP1) * rgbPost;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nvec3 rgb = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nrgb = max( rgb, 0.0);\nvec3 outputCV = Y_2_ST2084_f3( rgb);\n\nreturn outputCV;\n}\n\nvec3 ODT_Rec2020_Rec709limited_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC2020_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nChromaticities LIMITING_PRI = REC709_PRI;\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nbool legalRange = false;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nXYZ = limit_to_primaries( XYZ, LIMITING_PRI);\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = bt1886_r( linearCV.x, DISPGAMMA, L_W, L_B);\noutputCV.y = bt1886_r( linearCV.y, DISPGAMMA, L_W, L_B);\noutputCV.z = bt1886_r( linearCV.z, DISPGAMMA, L_W, L_B);\n\nif (legalRange) {\noutputCV = fullRange_to_smpteRange_f3( outputCV);\n}\n\nreturn outputCV;\n}\n\nvec3 ODT_Rec2020_P3D65limited_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC2020_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nChromaticities LIMITING_PRI = P3D65_PRI;\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nbool legalRange = false;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nXYZ = limit_to_primaries( XYZ, LIMITING_PRI);\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = bt1886_r( linearCV.x, DISPGAMMA, L_W, L_B);\noutputCV.y = bt1886_r( linearCV.y, DISPGAMMA, L_W, L_B);\noutputCV.z = bt1886_r( linearCV.z, DISPGAMMA, L_W, L_B);\n\nif (legalRange) {\noutputCV = fullRange_to_smpteRange_f3( outputCV);\n}\n\nreturn outputCV;\n}\n\nvec3 ODT_sRGB_D60sim_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\nfloat SCALE = 0.955;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = min( linearCV.x, 1.0) * SCALE;\nlinearCV.y = min( linearCV.y, 1.0) * SCALE;\nlinearCV.z = min( linearCV.z, 1.0) * SCALE;\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = moncurve_r( linearCV.x, DISPGAMMA, OFFSET);\noutputCV.y = moncurve_r( linearCV.y, DISPGAMMA, OFFSET);\noutputCV.z = moncurve_r( linearCV.z, DISPGAMMA, OFFSET);\n\nreturn outputCV;\n}\n\nvec3 ODT_sRGB_100nits_dim( vec3 oces) {\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4; \nfloat OFFSET = 0.055;\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, CINEMA_WHITE, CINEMA_BLACK);\nlinearCV.y = Y_2_linCV( rgbPost.y, CINEMA_WHITE, CINEMA_BLACK);\nlinearCV.z = Y_2_linCV( rgbPost.z, CINEMA_WHITE, CINEMA_BLACK);    \nlinearCV = darkSurround_to_dimSurround(linearCV);\nlinearCV = ODT_SAT_MAT * linearCV;\nvec3 XYZ = AP1_2_XYZ_MAT * linearCV;\nXYZ = D60_2_D65_CAT * XYZ;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV;\noutputCV = moncurve_r_f3( linearCV, DISPGAMMA, OFFSET);\nreturn outputCV;\n}\n\nvec3 ODT_P3DCI_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3DCI_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat NEW_WHT = 0.918;\nfloat ROLL_WIDTH = 0.5;\nfloat SCALE = 0.96;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = roll_white_fwd( linearCV.x, NEW_WHT, ROLL_WIDTH);\nlinearCV.y = roll_white_fwd( linearCV.y, NEW_WHT, ROLL_WIDTH);\nlinearCV.z = roll_white_fwd( linearCV.z, NEW_WHT, ROLL_WIDTH);\n\nlinearCV.x = min( linearCV.x, NEW_WHT) * SCALE;\nlinearCV.y = min( linearCV.y, NEW_WHT) * SCALE;\nlinearCV.z = min( linearCV.z, NEW_WHT) * SCALE;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_P3DCI_D60sim_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3DCI_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat NEW_WHT = 0.918;\nfloat ROLL_WIDTH = 0.5;\nfloat SCALE = 0.96;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = roll_white_fwd( linearCV.x, NEW_WHT, ROLL_WIDTH);\nlinearCV.y = roll_white_fwd( linearCV.y, NEW_WHT, ROLL_WIDTH);\nlinearCV.z = roll_white_fwd( linearCV.z, NEW_WHT, ROLL_WIDTH);\n\nlinearCV.x = min( linearCV.x, NEW_WHT) * SCALE;\nlinearCV.y = min( linearCV.y, NEW_WHT) * SCALE;\nlinearCV.z = min( linearCV.z, NEW_WHT) * SCALE;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_P3DCI_D65sim_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3DCI_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat NEW_WHT = 0.908;\nfloat ROLL_WIDTH = 0.5;\nfloat SCALE = 0.9575;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = roll_white_fwd( linearCV.x, NEW_WHT, ROLL_WIDTH);\nlinearCV.y = roll_white_fwd( linearCV.y, NEW_WHT, ROLL_WIDTH);\nlinearCV.z = roll_white_fwd( linearCV.z, NEW_WHT, ROLL_WIDTH);\n\nlinearCV.x = min( linearCV.x, NEW_WHT) * SCALE;\nlinearCV.y = min( linearCV.y, NEW_WHT) * SCALE;\nlinearCV.z = min( linearCV.z, NEW_WHT) * SCALE;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_P3D60_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3D60_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_P3D65_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3D65_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_P3D65_D60sim_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3D65_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat SCALE = 0.964;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = min( linearCV.x, 1.0) * SCALE;\nlinearCV.y = min( linearCV.y, 1.0) * SCALE;\nlinearCV.z = min( linearCV.z, 1.0) * SCALE;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_P3D65_Rec709limited_48nits( vec3 oces)\n{\nChromaticities DISPLAY_PRI = P3D65_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nChromaticities LIMITING_PRI = REC709_PRI;\nfloat DISPGAMMA = 2.6;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nXYZ = limit_to_primaries( XYZ, LIMITING_PRI);\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\nvec3 outputCV = pow_f3( linearCV, 1.0 / DISPGAMMA);\n\nreturn outputCV;\n}\n\nvec3 ODT_DCDM( vec3 oces)\n{\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\n\nXYZ = max( XYZ, 0.0);\nvec3 outputCV = dcdm_encode( XYZ);\n\nreturn outputCV;\n}\n\nvec3 ODT_DCDM_P3D60limited( vec3 oces)\n{\nChromaticities LIMITING_PRI = P3D60_PRI;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = limit_to_primaries( XYZ, LIMITING_PRI);\nvec3 outputCV = dcdm_encode( XYZ);\n\nreturn outputCV;\n}\n\nvec3 ODT_DCDM_P3D65limited( vec3 oces)\n{\nChromaticities LIMITING_PRI = P3D65_PRI;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = limit_to_primaries( XYZ, LIMITING_PRI);\nvec3 outputCV = dcdm_encode( XYZ);\n\nreturn outputCV;\n}\n\nvec3 ODT_RGBmonitor_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\n\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nXYZ = calculate_cat_matrix( AP0.white, REC709_PRI.white) * XYZ;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = moncurve_r( linearCV.x, DISPGAMMA, OFFSET);\noutputCV.y = moncurve_r( linearCV.y, DISPGAMMA, OFFSET);\noutputCV.z = moncurve_r( linearCV.z, DISPGAMMA, OFFSET);\n\nreturn outputCV;\n}\n\nvec3 ODT_RGBmonitor_D60sim_100nits_dim( vec3 oces)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 XYZ_2_DISPLAY_PRI_MAT = XYZtoRGB(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\nfloat SCALE = 0.955;\n\nvec3 rgbPre = AP0_2_AP1_MAT * oces;\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_fwd( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_fwd( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_fwd( rgbPre.z, ODT_48nits());\n\nvec3 linearCV;\nlinearCV.x = Y_2_linCV( rgbPost.x, 48.0, pow(10.0, log10(0.02)));\nlinearCV.y = Y_2_linCV( rgbPost.y, 48.0, pow(10.0, log10(0.02)));\nlinearCV.z = Y_2_linCV( rgbPost.z, 48.0, pow(10.0, log10(0.02)));\n\nlinearCV.x = min( linearCV.x, 1.0) * SCALE;\nlinearCV.y = min( linearCV.y, 1.0) * SCALE;\nlinearCV.z = min( linearCV.z, 1.0) * SCALE;\n\nlinearCV = darkSurround_to_dimSurround( linearCV);\nlinearCV = calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1])) * linearCV;\nvec3 XYZ = RGBtoXYZ(AP1) * linearCV;\nlinearCV = XYZ_2_DISPLAY_PRI_MAT * XYZ;\nlinearCV = clamp( linearCV, 0.0, 1.0);\n\nvec3 outputCV;\noutputCV.x = moncurve_r( linearCV.x, DISPGAMMA, OFFSET);\noutputCV.y = moncurve_r( linearCV.y, DISPGAMMA, OFFSET);\noutputCV.z = moncurve_r( linearCV.z, DISPGAMMA, OFFSET);\n\nreturn outputCV;\n}\n\nvec3 InvODT_Rec709_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nbool legalRange = false;\n\nif (legalRange) {\noutputCV = smpteRange_to_fullRange_f3( outputCV);\n}\n\nvec3 linearCV;\nlinearCV.x = bt1886_f( outputCV.x, DISPGAMMA, L_W, L_B);\nlinearCV.y = bt1886_f( outputCV.y, DISPGAMMA, L_W, L_B);\nlinearCV.z = bt1886_f( outputCV.z, DISPGAMMA, L_W, L_B);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nXYZ = invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white)) * XYZ;\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_Rec709_D60sim_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nfloat SCALE = 0.955;\nbool legalRange = false;\n\nif (legalRange) {\noutputCV = smpteRange_to_fullRange_f3( outputCV);\n}\n\nvec3 linearCV;\nlinearCV.x = bt1886_f( outputCV.x, DISPGAMMA, L_W, L_B);\nlinearCV.y = bt1886_f( outputCV.y, DISPGAMMA, L_W, L_B);\nlinearCV.z = bt1886_f( outputCV.z, DISPGAMMA, L_W, L_B);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\nlinearCV.x = linearCV.x / SCALE;\nlinearCV.y = linearCV.y / SCALE;\nlinearCV.z = linearCV.z / SCALE;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_Rec2020_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC2020_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat L_W = 1.0;\nfloat L_B = 0.0;\nbool legalRange = false;\n\nif (legalRange) {\noutputCV = smpteRange_to_fullRange_f3( outputCV);\n}\n\nvec3 linearCV;\nlinearCV.x = bt1886_f( outputCV.x, DISPGAMMA, L_W, L_B);\nlinearCV.y = bt1886_f( outputCV.y, DISPGAMMA, L_W, L_B);\nlinearCV.z = bt1886_f( outputCV.z, DISPGAMMA, L_W, L_B);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nXYZ = invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white)) * XYZ;\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_Rec2020_ST2084_1000nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC2020_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\n\nvec3 rgb = ST2084_2_Y_f3( outputCV);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * rgb;\nXYZ = invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white)) * XYZ;\n\nvec3 rgbPre = XYZtoRGB(AP1) * XYZ;\nrgbPre = rgbPre - pow10(-4.4550166483);\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_1000nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_1000nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_1000nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_sRGB_D60sim_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\nfloat SCALE = 0.955;\n\nvec3 linearCV;\nlinearCV.x = moncurve_f( outputCV.x, DISPGAMMA, OFFSET);\nlinearCV.y = moncurve_f( outputCV.y, DISPGAMMA, OFFSET);\nlinearCV.z = moncurve_f( outputCV.z, DISPGAMMA, OFFSET);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\nlinearCV.x = linearCV.x / SCALE;\nlinearCV.y = linearCV.y / SCALE;\nlinearCV.z = linearCV.z / SCALE;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_sRGB_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\n\nvec3 linearCV;\nlinearCV.x = moncurve_f( outputCV.x, DISPGAMMA, OFFSET);\nlinearCV.y = moncurve_f( outputCV.y, DISPGAMMA, OFFSET);\nlinearCV.z = moncurve_f( outputCV.z, DISPGAMMA, OFFSET);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nXYZ = XYZ * invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white));\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_P3DCI_48nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = P3DCI_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat NEW_WHT = 0.918;\nfloat ROLL_WIDTH = 0.5;\nfloat SCALE = 0.96;\n\nvec3 linearCV = pow_f3( outputCV, DISPGAMMA);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\n\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV.x = roll_white_rev( linearCV.x / SCALE, NEW_WHT, ROLL_WIDTH);\nlinearCV.y = roll_white_rev( linearCV.y / SCALE, NEW_WHT, ROLL_WIDTH);\nlinearCV.z = roll_white_rev( linearCV.z / SCALE, NEW_WHT, ROLL_WIDTH);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_P3DCI_D60sim_48nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = P3DCI_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat NEW_WHT = 0.918;\nfloat ROLL_WIDTH = 0.5;\nfloat SCALE = 0.96;\n\nvec3 linearCV = pow_f3( outputCV, DISPGAMMA);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\n\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV.x = roll_white_rev( linearCV.x / SCALE, NEW_WHT, ROLL_WIDTH);\nlinearCV.y = roll_white_rev( linearCV.y / SCALE, NEW_WHT, ROLL_WIDTH);\nlinearCV.z = roll_white_rev( linearCV.z / SCALE, NEW_WHT, ROLL_WIDTH);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_P3DCI_D65sim_48nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = P3DCI_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat NEW_WHT = 0.908;\nfloat ROLL_WIDTH = 0.5;\nfloat SCALE = 0.9575;\n\nvec3 linearCV = pow_f3( outputCV, DISPGAMMA);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\n\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV.x = roll_white_rev( linearCV.x / SCALE, NEW_WHT, ROLL_WIDTH);\nlinearCV.y = roll_white_rev( linearCV.y / SCALE, NEW_WHT, ROLL_WIDTH);\nlinearCV.z = roll_white_rev( linearCV.z / SCALE, NEW_WHT, ROLL_WIDTH);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_P3D60_48nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = P3D60_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\n\nvec3 linearCV = pow_f3( outputCV, DISPGAMMA);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nlinearCV = XYZtoRGB(AP1) * XYZ;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_P3D65_48nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = P3D65_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\n\nvec3 linearCV = pow_f3( outputCV, DISPGAMMA);\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nlinearCV = XYZtoRGB(AP1) * XYZ;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_P3D65_D60sim_48nits( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = P3D65_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ( DISPLAY_PRI);\nfloat DISPGAMMA = 2.6;\nfloat SCALE = 0.964;\n\nvec3 linearCV = pow_f3( outputCV, DISPGAMMA);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\n\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV.x = linearCV.x / SCALE;\nlinearCV.y = linearCV.y / SCALE;\nlinearCV.z = linearCV.z / SCALE;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_DCDM( vec3 outputCV)\n{\nvec3 XYZ = dcdm_decode( outputCV);\nvec3 linearCV = XYZtoRGB(AP1) * XYZ;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_DCDM_P3D65limited( vec3 outputCV)\n{\nvec3 XYZ = dcdm_decode( outputCV);\nXYZ = XYZ * invert_f33(calculate_cat_matrix( AP0.white, REC709_PRI.white));\nvec3 linearCV = XYZtoRGB(AP1) * XYZ;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_RGBmonitor_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\n\nvec3 linearCV;\nlinearCV.x = moncurve_f( outputCV.x, DISPGAMMA, OFFSET);\nlinearCV.y = moncurve_f( outputCV.y, DISPGAMMA, OFFSET);\nlinearCV.z = moncurve_f( outputCV.z, DISPGAMMA, OFFSET);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nXYZ = XYZ * invert_f33( calculate_cat_matrix( AP0.white, REC709_PRI.white));\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 InvODT_RGBmonitor_D60sim_100nits_dim( vec3 outputCV)\n{\nChromaticities DISPLAY_PRI = REC709_PRI;\nmat3 DISPLAY_PRI_2_XYZ_MAT = RGBtoXYZ(DISPLAY_PRI);\nfloat DISPGAMMA = 2.4;\nfloat OFFSET = 0.055;\nfloat SCALE = 0.955;\n\nvec3 linearCV;\nlinearCV.x = moncurve_f( outputCV.x, DISPGAMMA, OFFSET);\nlinearCV.y = moncurve_f( outputCV.y, DISPGAMMA, OFFSET);\nlinearCV.z = moncurve_f( outputCV.z, DISPGAMMA, OFFSET);\n\nvec3 XYZ = DISPLAY_PRI_2_XYZ_MAT * linearCV;\nlinearCV = XYZtoRGB(AP1) * XYZ;\nlinearCV = invert_f33( calc_sat_adjust_matrix( ODT_SAT_FACTOR, vec3(RGBtoXYZ( AP1)[0][1], RGBtoXYZ( AP1)[1][1], RGBtoXYZ( AP1)[2][1]))) * linearCV;\nlinearCV = dimSurround_to_darkSurround( linearCV);\nlinearCV.x = linearCV.x / SCALE;\nlinearCV.y = linearCV.y / SCALE;\nlinearCV.z = linearCV.z / SCALE;\n\nvec3 rgbPre;\nrgbPre.x = linCV_2_Y( linearCV.x, 48.0, pow(10.0, log10(0.02)));\nrgbPre.y = linCV_2_Y( linearCV.y, 48.0, pow(10.0, log10(0.02)));\nrgbPre.z = linCV_2_Y( linearCV.z, 48.0, pow(10.0, log10(0.02)));\n\nvec3 rgbPost;\nrgbPost.x = segmented_spline_c9_rev( rgbPre.x, ODT_48nits());\nrgbPost.y = segmented_spline_c9_rev( rgbPre.y, ODT_48nits());\nrgbPost.z = segmented_spline_c9_rev( rgbPre.z, ODT_48nits());\n\nvec3 oces = AP1_2_AP0_MAT * rgbPost;\n\nreturn oces;\n}\n\nvec3 RRTODT_P3D65_108nits_7_2nits_ST2084( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 7.2;\nfloat Y_MAX = 108.0;\nChromaticities DISPLAY_PRI = P3D65_PRI;\nChromaticities LIMITING_PRI = P3D65_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\n\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\n\nreturn cv;\n}\n\nvec3 RRTODT_Rec2020_1000nits_15nits_HLG( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 1000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 5;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\n\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\n\nreturn cv;\n}\n\nvec3 RRTODT_Rec2020_1000nits_15nits_ST2084( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 1000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 RRTODT_Rec2020_2000nits_15nits_ST2084( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 2000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 RRTODT_Rec2020_4000nits_15nits_ST2084( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 4000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 RRTODT_Rec709_100nits_10nits_BT1886( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 10.0;\nfloat Y_MAX = 100.0;\nChromaticities DISPLAY_PRI = REC709_PRI;\nChromaticities LIMITING_PRI = REC709_PRI;\nint EOTF = 1;\nint SURROUND = 1;\nbool STRETCH_BLACK = false;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 RRTODT_Rec709_100nits_10nits_sRGB( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 10.0;\nfloat Y_MAX = 100.0;\nChromaticities DISPLAY_PRI = REC709_PRI;\nChromaticities LIMITING_PRI = REC709_PRI;\nint EOTF = 2;\nint SURROUND = 1;\nbool STRETCH_BLACK = false;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 InvRRTODT_P3D65_108nits_7_2nits_ST2084( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 7.2;\nfloat Y_MAX = 108.0;\nChromaticities DISPLAY_PRI = P3D65_PRI;\nChromaticities LIMITING_PRI = P3D65_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = invOutputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 InvRRTODT_Rec2020_1000nits_15nits_HLG( vec3 cv)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 1000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 5;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 aces = invOutputTransform( cv, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn aces;\n}\n\nvec3 InvRRTODT_Rec2020_1000nits_15nits_ST2084( vec3 cv)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 1000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 aces = invOutputTransform( cv, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn aces;\n}\n\nvec3 InvRRTODT_Rec2020_2000nits_15nits_ST2084( vec3 cv)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 2000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 aces = invOutputTransform( cv, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn aces;\n}\n\nvec3 InvRRTODT_Rec2020_4000nits_15nits_ST2084( vec3 cv)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 15.0;\nfloat Y_MAX = 4000.0;\nChromaticities DISPLAY_PRI = REC2020_PRI;\nChromaticities LIMITING_PRI = REC2020_PRI;\nint EOTF = 0;\nint SURROUND = 0;\nbool STRETCH_BLACK = true;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 aces = invOutputTransform( cv, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn aces;\n}\n\nvec3 InvRRTODT_Rec709_100nits_10nits_BT1886( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 10.0;\nfloat Y_MAX = 100.0;\nChromaticities DISPLAY_PRI = REC709_PRI;\nChromaticities LIMITING_PRI = REC709_PRI;\nint EOTF = 1;\nint SURROUND = 1;\nbool STRETCH_BLACK = false;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvec3 InvRRTODT_Rec709_100nits_10nits_sRGB( vec3 aces)\n{\nfloat Y_MIN = 0.0001;\nfloat Y_MID = 10.0;\nfloat Y_MAX = 100.0;\nChromaticities DISPLAY_PRI = REC709_PRI;\nChromaticities LIMITING_PRI = REC709_PRI;\nint EOTF = 2;\nint SURROUND = 1;\nbool STRETCH_BLACK = false;\nbool D60_SIM = false;\nbool LEGAL_RANGE = false;\nvec3 cv = outputTransform( aces, Y_MIN, Y_MID, Y_MAX, DISPLAY_PRI,\nLIMITING_PRI, EOTF, SURROUND, STRETCH_BLACK, D60_SIM, LEGAL_RANGE );\nreturn cv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;\nvec3 aces = texture(iChannel0, uv).xyz;\nfloat exposure = float(EXPOSURE);\n\naces = ACES_IDT;\n    \naces = ACES_INVODT;\naces = ACES_INVRRT;\naces = ACES_INVRRTODT;\n\naces = exposure != 0.0 ? aces * exp2(exposure) : aces;\naces = ACES_LMT;\n\naces = ACES_RRT;\naces = ACES_ODT;\naces = ACES_RRTODT;\n\nfragColor = vec4(aces, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}