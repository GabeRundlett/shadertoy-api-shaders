{
    "Shader": {
        "info": {
            "date": "1532192346",
            "description": "From the Eldur demo released at Edison 2018\nFull demo: https://www.youtube.com/watch?v=jvqahkoMs40",
            "flags": 32,
            "hasliked": 0,
            "id": "MtccDn",
            "likes": 9,
            "name": "Light the beacons",
            "published": 3,
            "tags": [
                "3d",
                "mountains",
                "lightning"
            ],
            "usePreview": 0,
            "username": "rammoskar",
            "viewed": 630
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfragColor = texture(iChannel0, uv);\n\t\n\n\tvec2 dir = normalize(uv - vec2(0.5));\n\tfloat l = length(vec2(0.5) - uv);\n\tfragColor.g = texture(iChannel0, uv + dir * 0.005*l).g;\n\tfragColor.b = texture(iChannel0,  uv + dir * 0.01*l).b;\n\n\tfragColor.rgb *=  0.95 + 0.05*clamp(sin(uv.y*1000.0) + 0.8, 0.0, 1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash( in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noiseOctave(in vec2 p, int octaves, float persistence)\n{\n\tfloat n = 0.;\n\tfloat amplitude = 1.;\n\tfloat frequency = 1.;\n\tfloat maxValue = 0.;\n\n\tfor(int i = 0; i < octaves; i++)\n\t{\n\t\tn += noise((p+float(i)) * frequency) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= persistence;\n\t\tfrequency *= 2.0;\n\t}\n\treturn n / maxValue; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (uv.x > 0.5) {\n    \tuv.x = 1.0 - uv.x;\n    }\n    \n    if (uv.y > 0.5) {\n    \tuv.y = 1.0 - uv.y;\n    }\n\n    fragColor = vec4(vec3(noiseOctave(uv * 10.0, 20, 0.6)),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define iTime (mod(iTime, 77.0))\n\nfloat hash( in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noiseOctave(in vec2 p, int octaves, float persistence)\n{\n\tfloat n = 0.;\n\tfloat amplitude = 1.;\n\tfloat frequency = 1.;\n\tfloat maxValue = 0.;\n\n\tfor(int i = 0; i < octaves; i++)\n\t{\n\t\tn += noise((p+float(i)) * frequency) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= persistence;\n\t\tfrequency *= 2.0;\n\t}\n\treturn n / maxValue; \n}\n\n\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Union with smink\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n#define PI 3.14159265\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n#define MAT_MOUNTAIN 1.0\n#define MAT_TOWER 2.0\n\n#define PART_FLY 10.0\n#define PART_BOTTOM (PART_FLY + 8.0)\n#define PART_SPIN (PART_BOTTOM + 10.0)\n#define PART_LIGHT_UP ( PART_SPIN + 15.0)\n#define PART_FAR (PART_LIGHT_UP + 15.0)\n#define PART_TRAVEL (PART_FAR + 30.0)\n\n\nvec2 un(vec2 a, vec2 b)\n{\n\tif(a.x < b.x) \n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\n\nfloat pyrField(vec2 p, float base, float h )\n{\n\tvec2 pyr = min(mod(p, base), base -  mod(p, base));\n\treturn min(pyr.x, pyr.y) * h;\n}\n\nvec2 mountains(vec2 p)\n{\n\tp *= 0.5;\n\tfloat t = 5.0 * texture(iChannel0, p.xy/50.0).x + \n\t\t\t\t50.0 * texture(iChannel0, p.xy/300.0).x + \n\t\t\t\t200.0 * texture(iChannel0, p.xy/6000.0).x;\n\n\tfloat pyr = max(pyrField(p, 100.0, 1.3), pyrField(p + 10.0, 90.0, 1.3));\n\tpyr = max(pyr, pyrField(p + 60.0, 110.0, 1.3));\n\tfloat h = t + pyr;\n\t\n\t\n\treturn vec2(h, 1.0);\n}\n\n\n\nvec2 scene(vec3 p, float t, vec3 rd)\n{  \n\tvec2 res = vec2(99999999.0, -1.0);\n\n\tvec2 m = mountains(p.xz);\n\tres = un(res, vec2(p.y -m.x, m.y));\n\tres.x *= 0.5;\n\n\t\n\tvec3 o = p;\n\tfloat s = 400.0;\n\tp.x = mod(p.x + s * 0.5, s) - s * 0.5;\n\tfloat bound = sdBox(p - vec3(0.0, 150.0, 0.0), vec3(15.0, 70.0, 15.0));\n\tif (bound < 1.0) {\n\t\tp.y -= mountains(round((o.xz) / 50.0) * 50.0).x;\n\n\t\tfloat d = sdCappedCylinder(p, vec2(7.0, 30.0));\n\t\tfloat top = max(sdCappedCylinder(p - vec3(0, 31, 0), vec2(8.0, 3.0)), -sdCappedCylinder(p - vec3(0, 30, 0), vec2(6.0, 20.0)));\n\t\t\n\n\t\tvec2 q = p.xz;\n\t\tpModPolar(q, 8.0);\n\t\tfloat b = sdBox(vec3(q.x, p.y, q.y) - vec3(10, 33, 0), vec3(5.0, 2.0, 1.0));\n\t\td = min(d, max(top, -b));\n\t\t\n\t\tres = sunk(res, vec2(d, MAT_MOUNTAIN), 10.0);\n\t}\n    return res;\n}\n\nvec4 evaluateLight(vec3 p)\n{\n\tvec3 o = p;\n\tfloat s = 400.0;\n\tp.x = mod(p.x + s * 0.5, s) - s * 0.5;\n\n\tp.y -= mountains(floor((o.xz +10.0) / 40.0) * 40.0).x + 33.0;\n\tfloat dis = length(p) - 0.0;\n\tfloat strength = 0.0;\n\t\n\tvec3 col = vec3(1.0, 0.1, 0.0);\n\t\n\n\tstrength = 0.0;\n\tif (iTime > PART_SPIN) {\n\t\tfloat p = iTime - PART_SPIN;\n\t\tif (o.x < -2500.0)\n\t\t\tp += 1.0;\n\t\tfloat c = floor((o.x - 350.0) / 400.0);\n\t\tstrength = 20000.0 * smoothstep(2.0, 5.0, p +  c * 5.0 );\n\t}\n\tif (iTime > PART_FAR && o.x < -2500.0) {\n\t\tfloat t = iTime - PART_FAR;\n\t\tfloat s = smoothstep(15.0, 17.0, t);\n\n\t\tdis = min(dis, sdCylinder(p + vec3(0.0, 0.0, \n\t\t\t\t\tsin(o.y + iTime * 13.0) * 0.7 +\n\t\t\t\t\tsin(o.y * 0.5 + iTime * 10.0) * 1.5 +\n\t\t\t\t\tsin(o.y * 0.9 + iTime * 14.0) * 1.5 +\n\t\t\t\t\tsin(o.y * 0.4 + iTime * 8.0) * 2.5) * s, vec3(2.0, 0.0 , 0.0)));\n\t\tstrength *= 10.0;\n\t}\n\tif (o.x < -2800.0) {\n\t\tstrength = 0.0;\n\t}\n\n\tvec3 res = col * strength / (dis * dis * dis);\n    \n\tvec3 col2 = vec3(0.8);\n\tfloat strength2 = 1.0;\n\tif (iTime < PART_FLY) {\n\t\tstrength2 = smoothstep(2.0, 8.0, iTime);\n\t}\n\n\tvec3 res2 = col2 * strength2;\n\t\n\treturn vec4((res + res2), dis);\n}\n\n\nvec3 getNormal(vec3 p, float t, vec3 rd)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.1,0,0);\n    normal.x = scene(p + ep.xyz, t, rd).x - scene(p - ep.xyz, t, rd).x;\n    normal.y = scene(p + ep.yxz, t, rd).x - scene(p - ep.yxz, t, rd).x;\n    normal.z = scene(p + ep.yzx, t, rd).x - scene(p - ep.yzx, t, rd).x;\n    return normalize(normal);\n}\n\nvec3 getNormalEps(vec3 p, float t, vec3 rd, float eps)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz, t, rd).x - scene(p - ep.xyz, t, rd).x;\n    normal.y = scene(p + ep.yxz, t, rd).x - scene(p - ep.yxz, t, rd).x;\n    normal.z = scene(p + ep.yzx, t, rd).x - scene(p - ep.yzx, t, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return pow(k, s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec3 eye = vec3(300.0, 200.0, 90.0) + vec3(60.0 * cos(iTime * 0.1), 0.0, 60.0 * sin(iTime * 0.1));\n\tvec3 tar = vec3(300.0, 180.0, 90.0);\n\n\tif (iTime < PART_FLY) {\n\t\teye = vec3(700.0 + iTime * 10.0, 300.0, 1000.0);\n\t\ttar = eye + vec3(1.0, -0.5, 0.0);\n\t} else if (iTime < PART_BOTTOM) {\n\t\tfloat p = iTime - PART_FLY;\n\t\teye = vec3(400.0, 140.0 + p * 5.0, 150.0);\n\t\ttar = vec3(400.0, 200.0, 0.0);\n\t} else if (iTime < PART_SPIN) {\n\t\tfloat p = iTime - PART_BOTTOM;\n\t\teye = vec3(400.0, 230.0, 0.0);\n\t\teye += vec3(120.0 * cos(iTime * 0.1), 0.0, 120.0 * sin(iTime * 0.1));\n\t\ttar = vec3(400.0, 200.0, 0.0);\n\t} else if (iTime < PART_LIGHT_UP) {\n\t\tfloat p = iTime - PART_SPIN;\n\t\teye = vec3(450.0 + p, 230.0, 50.0 + p);\n\t\ttar = vec3(400.0 - max(0.0, (p - 4.0) * 10.0), 200.0, 0.0);\n\t} else  if (iTime < PART_FAR) {\n\t\tfloat p = iTime - PART_SPIN;\n\t\teye = vec3(-1800.0 - p * 2.0, 280.0, 200.0 - p * 2.0);\n\t\ttar = vec3(-1500.0 , 200.0, 0.0);\n\t} else if (iTime < PART_TRAVEL) {\n\t\tfloat p = iTime - PART_FAR;\n\t\teye = vec3(-1800.0 - p*50.0, 280.0, 30.0);\n\t\ttar = eye + vec3(-1.0, -0.5, 0.0);\n\t\ttar = mix(tar, vec3(-2800.0, 300.0, 0.0), smoothstep(12.0, 35.0,p));\n\t\ttar += + vec3(sin(p * 3.0) * 0.005, sin(p * 5.0) * 0.004, sin(p * 7.0) * 0.003);\n\t}\n\n\t vec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(vec3(0, 1, 0), dir));  \n \tvec3 up = cross(dir, right);\n\n    \n    float f = 1.5;\n\n\tfloat u = fragCoord.x / iResolution.x * 2.0 - 1.0;\n\tfloat v = fragCoord.y / iResolution.y * 2.0 - 1.0;\n\tv *= iResolution.y / iResolution.x;    \n\n\n    vec3 color = vec3(0.8); \n   \tvec3 ambient = vec3(0.2, 0.5,0.1);\n    vec3 invLight = -normalize(vec3(1, -0.2, 0)); \n    bool sky = true;\n           \n    float t = 0.0;\n    \n    vec3 ro = eye;\t\n    vec3 rd = normalize(dir + right*u + up*v);\n\n    vec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n    \n\tfloat ref = 0.0;\n\t\n\tconst float maxDis = 1000.0;\n\tconst int maxIter = 1000;\n\n\t for(int i = 0; i < maxIter && t < maxDis; ++i) \n\t {\n\t   \tvec3 p = ro + rd * t;\n\t    vec2 dm = scene(p, iTime, rd);\n\t    float d = dm.x;\n\t    float m = dm.y;\n         \n         float fogAmount = 0.004 + 0.07 * (1.0 - smoothstep(100.0, 160.0, p.y));\n         if (iTime > PART_FAR) {\n\t\t\tfloat p = iTime - PART_FAR - 15.0;\n\t\t\tif (p > 0.0)\n\t\t\t\tfogAmount += p*0.02;\n\t\t }\n         vec4 lightColDis = evaluateLight(p);\n         vec3 light = lightColDis.rgb;\n         d = min(d, max(0.01, lightColDis.w * 0.25));\n\t\t if (iTime < PART_BOTTOM && iTime > PART_FLY)\n\t\t\td *= 0.7;\n\n         vec3 lightIntegrated = light - light * exp(-fogAmount * d);\n         scatteredLight += transmittance * lightIntegrated;\t\n         transmittance *= exp(-fogAmount * d);\n         \n\t\tt += d;\n\n        bool end = i == maxIter - 1 || t >= maxDis;\n\t    if(d < 0.01 || end) \n\t    {\n\t    \tfloat spec = 1.0;\n\t    \tvec3 normal = getNormal(p, iTime, rd);\n\t    \t\n\t    \tif (m == 1.0)\n\t    \t{\n\t    \t\tvec3 n = getNormalEps(p, iTime, rd, 1.0);\n\t    \t\t\n\t    \t\tcolor =  mix(vec3(smoothstep(0.6, 0.9, normal.y) * 0.7), vec3(n.y), 0.2);\n\t    \t\tspec = normal.y;\n\t\n            } \n\t\t\t\n\t\t\tif (end) {\n\t\t\t\tcolor = vec3(0.0);\n\t\t\t} else {\n\t\t\t\tfloat diffuse = max(0., dot(invLight, normal));\n\t\t\t\tfloat s = smoothstep(2.0, 8.0, iTime);\n\t\t\t\tif (iTime < PART_FLY) {\n\t\t\t\t\t\n\t\t\t\t\tdiffuse *= s;\n\t\t\t\t\tspec *= s;\n\t\t\t\t}\n\t\t\t\tcolor = 0.7 * color * (s + diffuse);\n\t    \t\tcolor += spec * specular(normal, -invLight, normalize(eye - p), 70.0);\n\t\t\t\t\n\t\t\t}\n            \n\n            color = transmittance * color + scatteredLight;\n\t    \t\n\t        sky = false;\n\t       \tbreak;\n\t    }\n\t    \n\t }\n\n    \n    color /= (color + vec3(1.0));\n    fragColor = vec4(color, 0.0);\n\tfloat e = iTime - PART_FAR - 16.0;\n\tif (e > 0.0) {\n\t\tfragColor.rgb *= 1.0 -  e * 0.5;\n\t}\n\n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}