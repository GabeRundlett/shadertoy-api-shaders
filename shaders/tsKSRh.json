{
    "Shader": {
        "info": {
            "date": "1573445252",
            "description": "A less hellish version for easy viewing.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsKSRh",
            "likes": 9,
            "name": "Glass Refuge 2",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "reflection",
                "refraction",
                "glossy"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "#define MAX_STEP 25\n#define TOL 0.01\n#define FDIST 0.5\n#define MAXDIST 50.\n#define PI 3.1415927\n\n#define PLANE_HEIGHT -0.6\n\n#define SAMPLES 10\n#define GRID_SCALE 40.\n#define GRID_MAGNITUDE 0.025\n#define RADIUS 0.6\n#define SPACING 1.5\n#define OSC_MAGNITUDE 0.75\n#define OSC_SPEED 0.75\n#define ROT_SPEED 2.\n#define STRIPE_WIDTH 0.5\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat rand(in vec2 uv) {\n    return fract(865.1445*sin(dot(vec2(-1995.11, 144.969), uv)));\n}\n\nfloat map(in vec3 ro, out vec2 uv) {\n    vec2 id = floor(ro.xy/SPACING + 0.5);\n\tfloat offset = rand(id) * 2.*PI;\n    float angle = ROT_SPEED * iTime + offset;\n    //float angle = iTime*(ROT_SPEED*(offset-0.5));\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    ro.xy = mod(ro.xy + SPACING*0.5, vec2(SPACING))-SPACING*0.5;\n\tuv = rot * ro.xy;\n    return length(ro - vec3(0., 0., OSC_MAGNITUDE) * abs(sin(iTime * OSC_SPEED*0.75 + offset)))-RADIUS;\n}\n\nvec3 getnormal(vec3 ro) {\n    vec2 uv;\n    vec2 d = vec2(TOL, 0.0);\n    float x1 = map(ro+d.xyy, uv);\n    float x2 = map(ro-d.xyy, uv);\n    float y1 = map(ro+d.yxy, uv);\n    float y2 = map(ro-d.yxy, uv);\n    float z1 = map(ro+d.yyx, uv);\n    float z2 = map(ro-d.yyx, uv);\n    return normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2));\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd, out vec2 uv) {\n    float t = 0.;\n    for (int i=0; i<MAX_STEP; i++) {\n        float dist = map(ro+t*rd, uv);\n        t += dist;\n        if (dist < TOL) {\n            return vec2(t, 1.);\n        } else if (dist > MAXDIST) break;\n    }\n    return vec2(t, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 eye = vec3(iTime, 10.*sin(iTime*0.2), 0.5);\n    float mouseX = iMouse.z > 1. ? 2.*iMouse.x/iResolution.x-0.5 : 0.;\n    float mouseY = iMouse.w > 1. ? 2.*iMouse.y/iResolution.y-0.5 : 0.;\n    vec3 w = normalize(vec3(1., cos(iTime*0.2) - mouseX, mouseY + 0.5*sin(iTime*0.1367)));\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    rd.z = -abs(rd.z);\n    \n    //project onto plane\n    vec3 ro = eye + ((PLANE_HEIGHT-eye.z)/rd.z) * rd;\n    \n    vec3 col = vec3(0.);\n    vec3 bgcol = mix(vec3(1.), vec3(0., 1., 1.), abs(rd.z));\n    \n    float horiz = length(ro.xy - eye.xy);\n    if (rd.z > 0. || horiz > MAXDIST) {\n        fragColor = vec4(bgcol, 1.);\n        return;\n    }\n\n    for (int i=0; i<SAMPLES; i++) {\n        vec2 theta = rand2d(ro.xy + float(i) * vec2(104., -30.6));\n        theta *= vec2(2.*PI, 0.02*PI);\n        vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n        n = normalize(n + vec3(vec2(GRID_MAGNITUDE, GRID_MAGNITUDE)*cos(ro.xy*GRID_SCALE), 0.));\n        vec3 newrd = reflect(rd, n);\n        vec2 uv2;\n        vec2 t = raymarch(ro, newrd, uv2);\n\t\tvec3 newro = ro + newrd*t.x;\n        //lighting\n        if (t.y > 0.5) {\n            //shapes\n            vec3 normal = getnormal(newro);\n            float fac = max(0., dot(normal, vec3(0., 0., -1.)));\n            vec2 stripe = step(vec2(STRIPE_WIDTH), mod(uv2, vec2(STRIPE_WIDTH*2.)));\n            vec3 tex = mix(vec3(0., 0.6, 1.), vec3(1., 1., 0.), abs(stripe.x - stripe.y));\n            col += tex * fac;\n        } else {\n            //background color\n            col += bgcol;\n        }\n    }\n    col /= float(SAMPLES);\n    col = mix(bgcol, col, smoothstep(MAXDIST, MAXDIST-50., horiz));\n    \n    fragColor = vec4(pow(col, vec3(0.5)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}