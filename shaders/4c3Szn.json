{
    "Shader": {
        "info": {
            "date": "1713461311",
            "description": "Use the mouse to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "4c3Szn",
            "likes": 12,
            "name": "Field of flowers in the summer",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "ray",
                "raymarch",
                "march",
                "summer",
                "flowers"
            ],
            "usePreview": 1,
            "username": "ianertson",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n#define ZERO min(0, iFrame)\n#define NEAR 0.003\n#define FAR 60.0\n#define STEPS 70\n#define AMBIENT 0.0076\n\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat ssign(float x, float k) { float s = smoothstep(-k, k, x); return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));}\n\nvec3 pointRot(vec3 p, vec3 r) { p.yz *= rot(r.z); p.xz *= rot(r.y); p.xy *= rot(r.x); return p; }\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\nfloat hash21(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(hash21(id+vec2(0,0),s),hash21(id+vec2(1,0),s),lv.x),\n             mix(hash21(id+vec2(0,1),s),hash21(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nfloat noise(vec2 p, float s, float freq, float dec, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= dec;\n    freq *= exp(dec*1.386294401);\n    tx += warp * vec2(sin(n*6.28), cos(n*6.28));\n    \n  }\n  return n / div;\n}\n\nstruct Light {\n  vec3 p;\n  vec3 dir;\n  vec3 color;\n  float strength;\n  int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTIONAL 2\n\nvec3 getLightDir(Light light, vec3 p) {\n  switch (light.type) {\n    case LIGHT_AMBIENT: return normalize(light.p); break;\n    case LIGHT_POINT: return normalize(light.p - p); break;\n    case LIGHT_DIRECTIONAL: return normalize(-light.dir); break;\n    default: return normalize(vec3(1, 2, 3)); break;\n  }\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(N, L));\n  switch (light.type) {\n    case LIGHT_AMBIENT: return NdotL * light.strength * light.color; break;\n    case LIGHT_POINT: return pow(NdotL * light.strength * light.color, vec3(2.0)) / max(0.0000353, pow(distance(light.p, p), 2.0));\n    case LIGHT_DIRECTIONAL: {\n      return light.color * light.strength * NdotL * smoothstep(0.8, 1.0, dot(\n        normalize(light.p - p),\n        L\n      )); break;\n    }\n  }\n\n  return vec3(0.5);\n}\n\nstruct Material {\n  float rough;\n  float spec;\n  float z;\n};\n\n#define NEW_MATERIAL Material(0.0, 0.0, 0.0)\n\nstruct Object {\n  int id;\n  vec3 p;\n  vec3 q;\n};\n\n#define NEW_OBJECT Object(-1, vec3(0.0), vec3(0.0))\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  Object o;\n  Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, NEW_OBJECT, NEW_MATERIAL)\n\n\nfloat boxSDF(vec3 p, vec3 s) {\n  return length(max(abs(p)-s, 0.0));\n}\n\nfloat lineSDF(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - h * ba)-r;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n#define SAMPLE(OBJ, DIST) if (DIST < dist) { dist = DIST; data.o = OBJ; }\n\n#define ID_BOX 0\n#define ID_GROUND 1\n#define ID_PEDICEL 2\n#define ID_FLOWER 3\nfloat getGroundHeight(vec3 p) {\n  vec3 n1 = tnoise(p.xz, 0.039123, 0.05, 0.5, 2);\n  \n  return n1.x * 10.;\n}\n\nfloat groundSDF(vec3 p, inout float h) {\n  h = getGroundHeight(p);\n  \n  \n  \n  return p.y - h;\n}\nvec3 repeatX(in vec3 p, in float size) {\n    return vec3(p.x - size*round(p.x/size), p.yz);\n}\nvec3 repeatY(in vec3 p, in float size) {\n    return vec3(p.x, p.y - size*round(p.y/size), p.z);\n}\nvec3 repeatZ(in vec3 p, in float size) {\n    return vec3(p.xy, p.z- size*round(p.z/size));\n}\n\nfloat sdf(vec3 p, vec3 rd, inout Data data) {\n  float dist = FAR;\n  \n  float h = 0.0;\n  Object oGround = Object(ID_GROUND, vec3(0.0), vec3(0.0));\n  float ground = groundSDF(p - oGround.p, h);\n  \n  vec3 bp = p;\n  float freq = 2.0;\n  vec2 lid = floor((p.xz/freq)+0.15);//-(freq*0.5);\n  p.x = (mod(p.x, freq)-(freq*0.5));\n  p.z = (mod(p.z, freq)-(freq*0.5));\n\n  \n  float r1 = hash21(lid*16.9238123, 3.32124);\n  float r2 = fract(r1*10.4984923);\n  float r4 = fract(r1*30.2918121+r2*5.602919);\n  float r5 = fract((r1+r2+r4)*10.0583823);\n  \n  float lineH = mix(0.05, 0.3, r1);\n  float lineR = mix(0.01, 0.03, r2)*0.5;\n  float flowerR = mix(0.02, 0.04, r4)*0.5;\n  \n  \n  if (ceil(r1-0.4) > 0.9) {\n      Object oPedicel = Object(ID_PEDICEL, vec3(0.0), vec3(0.0));\n      float pedicel = lineSDF(p, vec3(-r5, 0.0, r5), vec3(0, h+lineH, 0), lineR)*0.6;\n      SAMPLE(oPedicel, pedicel);\n      \n      Object oFlower = Object(ID_FLOWER, vec3(0, h+lineH, 0), vec3(0.0));\n      vec3 fdir1 = normalize(vec3(r1, 1.0, sin(p.x)));\n      vec3 fdir2 = normalize(vec3(cos(p.z), 1.0, r2));\n      float flower1 = lineSDF(vec3(abs(p.x), p.y, p.z), oFlower.p, vec3(0, h+0.5*lineH, 0) + fdir1*lineH, flowerR);\n      float flower2 = lineSDF(vec3(p.x, p.y, abs(p.z)), oFlower.p, vec3(0, h+0.5*lineH, 0) + fdir2*lineH, flowerR);\n    \n      float flower = min(flower1, flower2);\n      \n      flower *= 0.9;\n      \n      SAMPLE(oFlower, flower);\n      \n  }\n  SAMPLE(oGround, ground);\n\n  return dist;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n  float d = 0.0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro+rd*d;\n    float next = sdf(p, rd, data);\n    if (next >= FAR) return false;\n    if (next <= (NEAR*(1.0+0.5*abs(d)))) break;\n    d += next;\n  }\n\n  vec3 p = ro+rd*d;\n  vec2 e = vec2(NEAR, 0.0);\n  vec3 n = normalize(sdf(p, rd, data) - vec3(\n    sdf(p - e.xyy, rd, data),\n    sdf(p - e.yxy, rd, data),\n    sdf(p - e.yyx, rd, data)\n  ));\n\n  data.p = p;\n  data.n = n;\n  data.d = d;\n\n  return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, vec3 n) {\n  Data data = NEW_DATA;\n  float NdotL = dot(n, rd);\n  if (NdotL <= 0.00003) return AMBIENT;\n  const int steps = 30;\n  float d = 0.0;\n  float t = NEAR * (1.0 + 2.0*max(0.0, NdotL));\n  float s = 0.0;\n  float k = 0.0;\n\n  for (int i = ZERO; i < steps; i++) {\n    vec3 p = ro+rd*t;//0.999*((t + 00.25*NdotL)*rd);\n    float next = sdf(p, rd, data);\n    //if (next >= FAR) return 1.0;\n    if (next < -0.05) break;\n    d += next;\n    t += clamp(next, 0.005, 0.5);\n    k += 1.0;\n  }\n  \n  d /= max(1.0, k);\n\n  s = smoothstep(0.5, 1.0, clamp(1.0-(d / (1.0+d)), 0.0, 1.0));\n  s = 1.0-s;\n  s = exp(s-1.0);\n  return clamp(s, AMBIENT, 1.0);\n}\n\nvec3 getAlbedoBox(inout Data data) {\n  vec3 p = data.p;\n  vec3 n = data.n;\n  vec2 uv = mix(mix(p.xy, p.yz, round(abs(dot(n, vec3(1, 0, 0))))),\n                p.xz,round(abs(dot(n, vec3(0, 1, 0)))));\n\n  vec2 id = floor(uv*2.0);\n  return vec3(1.0)*mod(id.x-id.y, 2.0);\n}\n\nvec3 getAlbedoFlower(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 n1 = tnoise(data.p.xz*24., 3.209123);\n    col += vec3(n1.x, n1.y*0.89, n1.z*0.1);\n    return col;\n}\n\nvec3 getAlbedoPedicel(inout Data data) {\n    vec3 col = vec3(0.0);\n     vec3 n1 = tnoise(data.p.xz*24., 10.209123);\n\n    col += vec3(n1.x*0.36, max(0.5, n1.y), n1.z*0.15);\n    col = col*col;\n    return col;\n}\n\n//#define DEBUG_TEXTURE getAlbedoGround\n\nfloat line(vec2 p, vec2 a, vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return 1.0-clamp(length((pa - ba * h)/t), 0.0, 1.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec3 p = data.p;\n    vec2 uv = p.xz*1.;\n    \n    vec3 n1 = tnoise(uv, 2.44312, 9.2, 0.01, 4);\n    vec3 n2 = tnoise(uv, 10.00444, 0.9, 0.005, 2);\n    vec3 n3 = clamp(abs(cross(n1*2.0-1.0, n2*2.0-1.0)), 0.0, 1.0);\n    vec3 n4 = tnoise(uv*0.1, 16.693825+2.0*n1.x);\n    \n    vec3 g1 = vec3(n1.x*0.6, max(0.39, n1.z), n1.y*0.15);\n    vec3 g2 = vec3(n1.y*0.6, max(0.39, n1.x), n1.x*0.15);\n    vec3 g3 = vec3(n1.z*0.6, max(0.39, n1.y), n1.y*0.15);\n    \n   \n    \n    float pat = 0.0;\n    float seed = 33.3212;\n    \n    const int iterations = 4;\n    const float invIter = 1.0 / float(iterations);\n    \n    \n    for (int i = ZERO; i < iterations; i++)\n    {\n        float k = float(i)*invIter*6.28;\n        uv *= rot(k);\n        vec2 id = floor(uv);\n        vec2 lv = fract(uv);\n        vec2 cv = lv*2.0-1.0;\n        vec2 slv = abs(cv);\n//        float grid = \n  //          max(smoothstep(0.05, 0.0, abs(cv.x+1.)),\n    //            smoothstep(0.05, 0.0, abs(cv.y+1.)));\n\n        vec2 angid = id+floor(cv);\n        \n        float ang = mix(\n            mix(hash21(angid+vec2(0, 0), seed), hash21(angid+vec2(1, 0), seed), slv.x),\n            mix(hash21(angid+vec2(0, 1), seed), hash21(angid+vec2(1, 1), seed), slv.x),\n            slv.y\n        );\n        pat += line(vec2(abs(cv.x), abs(cv.y)), vec2(0.0), 2.0*vec2(sin(ang), cos(ang)), mix(0.05, 3., n3.y*n3.y));\n        uv *= 1.5;\n        seed += 0.15489338;\n    }\n    col = mix(g1,  g1, n1.x);\n    col = mix(col, g2, n1.y);\n    col = mix(col, g3, n1.z);\n    \n    col = mix(col, col*col, smoothstep(0.0, 0.05+n3.y+0.25*(n2.y*n2.y), pat*n3.x));\n    col = mix(col, col*col, smoothstep(0.4, 0.7, n4.x));\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n  switch (data.o.id) {\n    case ID_BOX: return getAlbedoBox(data); break;\n    case ID_GROUND: return getAlbedoGround(data); break;\n    case ID_FLOWER: return getAlbedoFlower(data); break;\n    case ID_PEDICEL: return getAlbedoPedicel(data); break;\n  }\n\n  return vec3(0.93);\n}\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, Data data, vec3 diffuse) {\n  vec3 p = data.p;\n  vec3 N = data.n;\n  vec3 L = getLightDir(light, p);\n  vec3 att = getLightAtt(light, p, N);\n  vec3 ref = reflect(N, L);\n  float VdotR = max(0.0, dot(rd, ref));\n  float spec = pow(VdotR, 24.0) * data.m.spec;\n  float shadow = data.d > (FAR*0.5) ? 1.0 : getShadow(data.p, getLightDir(light, data.p), data.n);\n  return max(((diffuse + spec) * att) * shadow, vec3(0.0));\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    vec3 blue = vec3(0.04, 0.4, 0.8);\n    \n    col += pow(blue, vec3(1.0 + 9.*dotup));\n    \n    if (rd.y <= 0.0) return col;\n    \n    float t = T*0.25;\n    \n    vec2 uv = rd.xz / rd.y;\n    \n    vec3 n1 = tnoise(uv-vec2(sin(t), cos(t)), 4.49218, 2.2, 0.03, 4);\n    vec3 n2 = tnoise(uv+vec2(sin(t+n1.y), cos(t+n1.z)), 10.593, 1.6, 0.03, 3);\n    col += ((n1.x * smoothstep(0.4, 0.7, n1.z)) + (n2.x * smoothstep(0.4, 0.7, n2.z)))*0.5;\n    \n    return col;\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n  #define NUM_LIGHTS 1\n\n  Light lights[NUM_LIGHTS] = Light[](\n    Light(vec3(1, 2, -3), vec3(0.0, 1, 1), vec3(0.97, 0.79, 0.69), 4.0, LIGHT_AMBIENT)\n  );\n  \n  vec3 col = vec3(0.0);\n  Data data = NEW_DATA;\n\n  if (march(ro, rd, data)) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n      Light light = lights[i];\n      col += forEachLight(light, ro, rd, data, diffuse);\n    }\n  } else {\n      col += getSky(ro, rd);\n  }\n  \n  \n  vec3 L = getLightDir(lights[0], ro);\n  float VdotL = max(0.0, dot(rd, L));\n  \n  col += lights[0].color * lights[0].strength * pow(VdotL, 16.0);\n  \n  return max(col, vec3(0.0));\n}\n\nvoid getRay(vec2 uv, vec4 m, inout vec3 ro, inout vec3 rd) {\n  float Y = 3.5;\n  ro = vec3(0.0, 0.0, -6.0);\n  rd = normalize(vec3(uv, 1.0));\n\n  if (m.z > 0.01) {\n    ro.yz *= rot(m.y*TAU);\n    ro.xz *= rot(m.x*TAU);\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n  }\n  \n  ro.z += T;\n  \n  Y += getGroundHeight(ro);\n  ro.y += Y;\n  \n  ro.y = max(ro.y, Y);\n}\n\n////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n\n  vec3 ro = vec3(0.0);\n  vec3 rd = vec3(0.0);\n  getRay(uv, m, ro, rd);\n\n  #ifdef DEBUG_TEXTURE\n  Data data = NEW_DATA;\n  data.p = (fc.xy / R.y).xyy;\n  col += DEBUG_TEXTURE(data);\n  #else\n  col += scene(ro, rd);\n  #endif\n  col = aces(col);\n  col = pow(col, vec3(1.0 / 2.2));\n  \n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}