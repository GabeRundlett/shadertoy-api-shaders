{
    "Shader": {
        "info": {
            "date": "1468494314",
            "description": "FFT is very useful to get frequency information.here is FFT by GPU and FFT by CPU.\n1.you can easy encode into and decode form frequency,then have many ways to compress and uncompress RGB data if you want to code image form audio.",
            "flags": 32,
            "hasliked": 0,
            "id": "lsVXWt",
            "likes": 48,
            "name": "Pixel Shader FFT",
            "published": 3,
            "tags": [
                "math",
                "fft",
                "dynamicbuffer"
            ],
            "usePreview": 0,
            "username": "834144373",
            "viewed": 6243
        },
        "renderpass": [
            {
                "code": "//inspire from (Secret) https://www.shadertoy.com/view/Xs3XzN by 834144373\n/*\n*\tBufferA is Pixel Shader FFT \n*\tBufferB is Bit Reverse table look-up\n*\tBufferC is UI Viewer\n*/\n/*\n*\tGPU Do 512 point value fft from audio time domain data\n\t\tFFT Sample Size:512\n\t\tFFT useful data length:256\n\t\tFFT resolution : (44.1kHz/1024)*2 \n*\tCPU Do 2048 point value fft from webkit\n\t\tFFT Sample Size:2048 \n\t\tFFT useful data length:1024\n\t\tFFT resolution : (44.1kHz/2048)\n*/\n/*\n* Their visual don't look a bit like,because here use a \"dynamic buffer\" on bufferA and \n* different sampler data length then time is delay.\n* But I am sure that the Pixel Shader FFT is correct with my lots of test,\n* you can test it on my BufferA,where you can see \"debug_visual\",try to test energy and frequency.\n*/\n//but the shodertoy audio buffer just have half of the really entire data \n\n//More about audio information,suggust you to check \"effect.js\",I hard describe in English.\n\n\n//GPU Pixel Shader FFT visual\nvoid GPU_FFT_Visual(vec2 u,inout vec4 c){\n\t//u.x -= 100.;\n    //u.y -= (0.55*iResolution.y); //128.\n    u.x = floor(u.x/iResolution.y*180.)-30.;\n    u.y = u.y/iResolution.y*350.-170.;\n    //show visual effect\n    if(u.x-0.5 < 256. && u.x>=0. && u.y>0.){\n        vec2 xy = texture(iChannel0,vec2(u.x+0.5,9.5)/iChannelResolution[0].xy).xy;\n        //Energy\n        vec4 cc = vec4(length(xy));\n        //Really Energy \n    \tcc = u.x == 0. ? cc/512. : cc/256.;\n        cc *= u.x == 0. ? 2.: 20.;\n        cc = 20.*log(cc);\n        cc = vec4(clamp(cc.r,1.,120.),0.,0.,0.);\n        //show visual effect\n        if(floor(u.y) < cc.r ){\n    \t\tc.g = 1.;\n        }\n    }   \n}\n\n//CPU FFT visual\nvoid CPU_FFT_Visual(vec2 u,inout vec4 c){\n\t//u.x -= 100.;\n    u.x = floor(u.x/iResolution.y*360.)-60.;\n    u.y = u.y/iResolution.y*350.-50.;\n    if(u.x-0.5 < 256. && u.x>=0. && u.y>0.){\n        float enegy = texture(iChannel0,vec2(u.x,10.5)/iChannelResolution[0].xy).y*50.;\n        if(u.y < enegy){\n            c.b = 1.;\n        }\n    }\n}\n\n//So far,frequency transfer information is always so good while you get data from.\nvoid mainImage( out vec4 c, in vec2 u)\n{\n    c -= c;\n    GPU_FFT_Visual(u,c);\n    \n    CPU_FFT_Visual(u,c);\n    \n    c = max(c,texture(iChannel1,u/iResolution.xy));\n    //uncomment it to see dynamic buffer work\n    //c = max(c,texture(iChannel0,u/iResolution.xy));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////\n//Bit Reverse table look-up for 512-situation\n//////////////////////////////////////////////\n#define R_512 512.  \n#define num_bits 9.\n#define Self_sampler iChannel1\n#define Self_Resolution iChannelResolution[1].xy\n#define size iResolution.xy\n#define SetPointValue(xy,data) c = xy.x==u.x && xy.y==u.y ? data : c\n\nfloat ToBinary(float n,float y){\n    return mod(floor(n/(exp2(y))),2.);\n}\n\nvec4 GetSelf(float x,float y){\n\treturn texture(Self_sampler,vec2(x+0.5,y+0.5)/Self_Resolution.xy);\n}\n\nvoid mainImage(out vec4 c,in vec2 u)\n{\n    //for store point value\n    u = floor(u);//or u -= 0.5 \n    //SetPointValue(vec2(10.,10.),vec4(0,1,0,0));\n    //SetPointValue(vec2(512.,11.),vec4(1.,1,0,0));\n\t\n    if(u.x<R_512 && u.y< num_bits+1. ){\n    \tfloat y = u.y - 1.;\t\n        if(y > -1.){\n            //\n        \tc = vec4(ToBinary(u.x,y),0.,0.,0.);\n        }\n        else{\n            //when the y == -1,get value\n            float total = 0.;\n            float index_x = u.x;\n            float value = GetSelf(index_x,9.).r;\n                    total += value>0.5 ? 1.  : 0.;\n                  value = GetSelf(index_x,8.).r;\n                    total += value>0.5 ? 2.  : 0.;\n                  value = GetSelf(index_x,7.).r;\n                    total += value>0.5 ? 4.  : 0.;\n                  value = GetSelf(index_x,6.).r;\n                    total += value>0.5 ? 8.  : 0.;\n                  value = GetSelf(index_x,5.).r;\n                    total += value>0.5 ? 16. : 0.;\n                  value = GetSelf(index_x,4.).r;\n                    total += value>0.5 ? 32. : 0.;    \t  \n                  value = GetSelf(index_x,3.).r;\n                    total += value>0.5 ? 64. : 0.;\n                  value = GetSelf(index_x,2.).r;\n                    total += value>0.5 ? 128.: 0.;\n                  value = GetSelf(index_x,1.).r;\n                    total += value>0.5 ? 256.: 0.;\n            c.y = total;\n        }\n    }\n    else{discard;}\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "///////////////////////////////////////////\n//Pixel Shader FFT \n///////////////////////////////////////////\n//here (Audio Channal) Channel[0] resolution is 512 x 2,\n#define DomainChannel iChannel0\n#define BitReverseChannel iChannel1\n#define SelfBuffer iChannel2\n#define SelfResolution iChannelResolution[2].xy\n#define R_512 iChannelResolution[0].x\n#define B_Size iChannelResolution[1].xy\n\n#define _2PI 6.2831853\n\n//to visual debug\n//#define debug_visual\n//if 200Hz/s\n#define debug_frequency 255.\n\n//Get the Audio Time Domain array value form this iChannel texture buffer\nfloat GetTimeDomain(float index){\n\treturn texture(DomainChannel,vec2((index+0.5)/R_512,1.)).s*256. - 128.\n        \n    #ifdef debug_visual\n        + 5.*sin(debug_frequency*index/512.*_2PI)\n    #endif\n    ;\n}\n\nvec4 GetBufferValue(float x,float y){\n\treturn texture(BitReverseChannel,vec2(x+0.5,y+0.5)/B_Size);\n}\n\nvec4 GetFFT(float x,float y){\n\tvec4 FFTBuffer = texture(SelfBuffer,vec2(x+0.5,y+0.5)/SelfResolution);\n    //++i;\n    return FFTBuffer;\n}\n//store time domain & frequency domain form this cpu audio data to next shader for visual\nvoid Store_T_F(float x,float y,inout vec4 c){\n    if(y == 9.){\n    \t//Store Time domain value form cpu\n        c.x = texture(DomainChannel,vec2((x+0.5)/R_512,1.)).s;\n        //Store Frequency domain value form cpu\n        c.y = texture(DomainChannel,vec2((x+0.5)/R_512,0.)).s;\n    }\n}\n\n//GPU Pixel Shader Do FFT\nvec2 DO_FFT(float u_x,float u_y,inout vec4 c)\n{\n    //current index\n    u_x = floor(u_x);u_y = floor(u_y) - 1.;\n    if(u_x >= R_512){return vec2(0.);}\n    //store for next shader to visual\n    Store_T_F(u_x,u_y,c);\n    //FFT.x is real value,y is imagin value\n    //Bit Reverse Index Value\n    float index = GetBufferValue(u_x,0.).t;\n    //get domain value form Audio buffer texture and sort it\n    if(u_y == -1.){\n    \tc.st = vec2(GetTimeDomain(index),0.);\n    }\n    //Do Buttfly\n    //0,1,2,3,4,5,6,7,8 is FFT Step Buttfly\n    if(u_y >= 0. && u_y <= 8.)\n    {\n        //calculate\n        float mystep = u_y;\n        bool Is_E_data = mod(floor(u_x/exp2(mystep)),2.) == 0.;\n        //è®¡ç®—æ—‹è½¬å› å­\n        float kn = mod(u_x,exp2(mystep));\n        //Cä¸ºeçš„æŒ‡æ•°\n        float C = -(_2PI/exp2(mystep+1.))*kn;\n        vec2 W = vec2(cos(C),sin(C));\n        \n        float burb = exp2(mystep);\n        \n        vec2 buffer = vec2(0.);\n        if(Is_E_data){\n\t\t\t//tR[i] = FFT[i].Re+FFT[i+(1<<step)].Re*W_Re-FFT[i+(1<<step)].Im*W_Im;\n            //tI[i] = FFT[i].Im+FFT[i+(1<<step)].Re*W_Im+FFT[i+(1<<step)].Im*W_Re;\n            //Get Next pixel buffer\n \t\t\tbuffer.x = GetFFT(u_x,u_y).x + GetFFT(u_x+burb,u_y).x*W.x - GetFFT(u_x+burb,u_y).y*W.y;\n \t\t\tbuffer.y = GetFFT(u_x,u_y).y + GetFFT(u_x+burb,u_y).x*W.y + GetFFT(u_x+burb,u_y).y*W.x;\n            c.xy = buffer;\n        }\n        else{\n            //tR[i] = FFT[i-(1<<step)].Re-(FFT[i].Re*W_Re-FFT[i].Im*W_Im);\n            //tI[i] = FFT[i-(1<<step)].Im-(FFT[i].Re*W_Im+FFT[i].Im*W_Re);\n            //Get The Next Pixel Buffer \n            buffer.x = GetFFT(u_x-burb,u_y).x-(GetFFT(u_x,u_y).x*W.x - GetFFT(u_x,u_y).y*W.y);\n            buffer.y = GetFFT(u_x-burb,u_y).y-(GetFFT(u_x,u_y).x*W.y + GetFFT(u_x,u_y).y*W.x);\n\t\t\tc.xy = buffer;\n        }\n        \n    }\n\treturn GetFFT(u_x,9.).xy;\n}\n\nvoid mainImage( out vec4 col,in vec2 u )\n{\n    //float for_u = u.x/R_512;\n    //float num_bits = log2(R_512);\n    vec4 c = vec4(0.);\n    \n    //GPU Pixel Shader Do FFT\n    DO_FFT(u.x,u.y,c);\n    col = c;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "///////////////////////////////////////\n//UI View \n///////////////////////////////////////\n//source font from: https://www.shadertoy.com/view/XsGXzt\nvec2 uv = vec2(0.);\n\nconst vec2 font_size = vec2(15.,16);\nconst int content_size = 15;\nint num4row = 0;\n#define start_pos(where_x,where_y) uv.x=u.x-=where_x;uv.y-=16.*(float(num4row)-1.)-where_y;\n#define adjacency_width -5\n#define adjacency_height 2\n#define first_word_pos(with) uv.x-= float(15+adjacency_width)*float(with);\n\n#define H w.a=vec3(0x84FC04,0x848080,0x4FC);w.b=vec2(0,0);w.c=vec3(0x101F10,0x100000,0x101F);w.d=vec2(0,0);Font\n#define z w.a=vec3(0xC8400,0x844434,0xC);w.b=vec2(0,0);w.c=vec3(0x10100,0x10101,0x1);w.d=vec2(0,0);Font\n#define G w.a=vec3(0x418E0,0x784404,0x40);w.b=vec2(0,0);w.c=vec3(0x100C03,0x1C1010,0);w.d=vec2(0,0);Font\n#define P w.a=vec3(0x84FC04,0x808080,0);w.b=vec2(0,0);w.c=vec3(0x101F10,0x101010,0xF);w.d=vec2(0,0);Font\n#define U w.a=vec3(0x4F800,0x40404,0xF8);w.b=vec2(0,0);w.c=vec3(0x101F10,0x100000,0x101F);w.d=vec2(0,0);Font\n#define C w.a=vec3(0x418E0,0x80404,0x10);w.b=vec2(0,0);w.c=vec3(0x100C03,0x101010,0x1C);w.d=vec2(0,0);Font\n#define _0 w.a=vec3(0x8F000,0x80404,0xF0);w.b=vec2(0,0);w.c=vec3(0x80700,0x81010,0x7);w.d=vec2(0,0);Font\n#define _1 w.a=vec3(0x40000,0x4FC04,0x4);w.b=vec2(0,0);w.c=vec3(0x80000,0x1F08,0);w.d=vec2(0,0);Font\n#define _2 w.a=vec3(0x140C00,0x844424,0xC);w.b=vec2(0,0);w.c=vec3(0x100E00,0x101010,0xF);w.d=vec2(0,0);Font\n#define k w.a=vec3(0x24FC04,0xC9460,0x4);w.b=vec2(0,0);w.c=vec3(0xF08,0x10100,0x1);w.d=vec2(0,0);Font\nstruct Data{\n    vec3 a,c;\n    vec2 b,d;\n};\n\nData w;\n#define Font c+=font(w);\n\n#define next uv.x = u.x;uv.y += 16.+ float(adjacency_height);\n#define Next(step) uv.x = u.x;uv.y += 16.*float(step)+ float(adjacency_height);\n\nfloat Bin(float n,float u,float v,inout float c){\n    return (u>=0. && v>=0. && u<=2. && v<=7.) ? mod(floor(n/(exp2(8.*u+v))),2.) : c;\n}\n\nfloat arrayBin(Data f){\n    float c = 0.,o = 3., y = uv.y-8.;\n    uv.x -= 0.;c= Bin(f.a.r,uv.x,uv.y,c);c = Bin(f.c.r,uv.x,y,c);\n    uv.x -= o;c = Bin(f.a.g,uv.x,uv.y,c);c = Bin(f.c.g,uv.x,y,c);\n    uv.x -= o;c = Bin(f.a.b,uv.x,uv.y,c);c = Bin(f.c.b,uv.x,y,c);\n    uv.x -= o;c = Bin(f.b.r,uv.x,uv.y,c);c = Bin(f.d.r,uv.x,y,c);\n    uv.x -= o;c = Bin(f.b.g,uv.x,uv.y,c);c = Bin(f.d.g,uv.x,y,c);\n    return c;\n}\n\nfloat font(Data f){\n    float c = 0.;\n    c = arrayBin(f);\n    uv.x -= 3.+ float(adjacency_width);\n    return c;\n}\n\nvoid mainImage( out vec4 f, in vec2 uu )\n{\n    float c = 0.;\n    vec2 u = vec2(0.);\n    u = floor(uu)/(iResolution.y-1.);\n    u *= float(content_size);\n    u = floor(u*font_size);\n    num4row = content_size-num4row;\n\n    uv = u;\n    \n    start_pos(60.,26.);\n       \n    Next(1)\n    \tG P U\n    Next(5)\n       first_word_pos(-2.5) _0 first_word_pos(30.5) _2 _2 k H z\n    Next(1)\n\t\tC P U\n    Next(4)\n       first_word_pos(-2.5) _0 first_word_pos(14.5) _1 _1 k H z\n    f = vec4(c);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}