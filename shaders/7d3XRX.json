{
    "Shader": {
        "info": {
            "date": "1633958592",
            "description": "Ghost Shader ver 01 - Mouseable - I have some ideas but need to experiment more - however thought this was cute..",
            "flags": 0,
            "hasliked": 0,
            "id": "7d3XRX",
            "likes": 17,
            "name": "Ghost Shader ver 01",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "ghost",
                "isometric",
                "glitter"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 406
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Ghostsssss\n    10/09/21 @byt3_m3chanic\n    \n    Again we're just moving one domain / then loops\n    but I'm making the ID's advace using floor(T*.1)\n    which matching the timing for the loop movement.\n\n    I started doing this to prevent artifacts that \n    seem to distort the more you move a scene with time\n    / distance or large values.\n    \n    Just playing - like the ghost from a previous\n    shader / anisiotropic effects for glitter and\n    some transparency / refraction.\n    \n    thanks @blackle / @iq / @tachyonflux\n\n*/\n\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq sdf shapes\t\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cap( vec3 p, float r,float h ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat vcap( vec3 p, float h, float r ){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sunion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// globals\nvec3 hit,hitPoint;\nvec2 gid,sid;\nmat2 r45,rn45,r25,turn;\nfloat tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,glow=0.;\n\nfloat eyes(vec3 p) {\n    float res = 1e5;\n    vec3 q = p-vec3(0,.5,0);\n    vec3 e1 = vec3(abs(q.x),q.yz);\n\n    float eye = length(e1-vec3(.57,.65,.8))-.15;\n    if(eye<res) {\n        res = eye;\n    } \n    glow += smoothstep(.1,.25,.003/(.0145+eye*eye)); \n    return res;\n}\n\nfloat ghost(vec3 p, float hs) {\n    float res = 1e5;\n    vec3 q = p-vec3(0,-1.25,0);\n    \n    vec3 q2=q-vec3(0,1.5,.25);\n    vec3 q3=vec3(abs(q.x),q.yz)-vec3(.5,2.72,1.25);\n    vec3 q4 = q-vec3(0,2.72,1.65);\n    q4.x=abs(q4.x);q4.xz*=r25;\n    \n    float ghst = vcap(q,2.75,1.6);\n    float eyes = length(q3)-.45;\n    float lids = torus(q4-vec3(.53,0,0),vec2(.4,.05));\n    float chst = vcap(q,2.7,1.25);\n\n    float a = atan(q.z,q.x);\n    float tw = .2*sin(a*6.);\n    tw *=pow(length(q.xz),1.);\n    \n    float cuting = cap(q+vec3(0,1.,0),1.-tw,1.65)*.75;\n    \n    ghst = max(ghst,-cuting);\n    ghst = max(ghst,-eyes);\n    ghst = sunion(lids,ghst,.08);\n    ghst = max(ghst,-chst);\n    \n    if(ghst<res ) {\n        res = ghst;\n    }\n\n    return res;\n}\n\nconst float size = 6.;\nconst float hlf = size/2.;\nconst float blx = hlf*.95;\nconst float hlx = hlf*.825;\nconst float dbb = size*4.;\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n    \n    //prevent scene from moving\n    //just having ID's change\n    if(ga4>0.) q.z+=ga4*dbb;\n    vec3 tq = q;\n    tq.z+=floor(T*.1)*dbb;\n    \n    vec2 id = floor((tq.xz+hlf)/size);\n\n    q.xz=mod(q.xz+hlf,size)-hlf;\n    float hs = hash21(id+floor(T*.1));\n\n    float th = .7;\n    float ofs = ga2*10.;\n    vec3 q4 = q+vec3(0,6.85,0);\n\n    float tile = box(q4,vec3(blx,5.1,blx))-.125;\n    if(ga1>0.&&hs>th) {\n        tile=max(tile,-(length(q4.xz)-(hlx*(ga1-ga3))) );\n    }\n    \n    if(tile<res.x) {\n        res = vec2(tile,2.);\n        hitPoint=q4;\n        gid=id;\n    } \n\n    float mof = hs*3.+T*hs;\n    q.xz*=rot(hs*36.);\n    float hp = .6*sin(T*3.+mof);\n    \n    vec3 q2=q-vec3(.1*sin(q.x+T*3.5),-7.7+ofs+hp,.6+.15*cos(q.x+T*2.5));\n    vec3 q1=q-vec3(0,-8.+ofs+hp,0);\n\n    float ghst = hs>th?ghost(q1,hs):1.;\n    if(ghst<res.x && (p.y>-3.75)) {\n        res = vec2(ghst,1.);\n        hitPoint=q1;\n    }  \n\n    float brain = hs>th?eyes(q2):1.;\n    if(brain<res.x && (p.y>-3.75)) {\n        res = vec2(brain,4.);\n        hitPoint=q2;\n    } \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n// cheap hash noise\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), .001);\n    n /= dot(n, vec3(1));\n\tfloat tx = hash21(floor(p.xy));\n    float ty = hash21(floor(p.zx));\n    float tz = hash21(floor(p.yz));\n    return vec3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n// glintz adapted and redux - original @tachyonflux\n// https://www.shadertoy.com/view/ll2fzt\nvec3 glintz( vec3 lcol, vec3 hitPoint, vec3 n, vec3 rd, vec3 lpos) {\n    vec3 mate;\n    vec3 pos = hitPoint;\n    \n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    \n    for(int i = 0; i < 2;i++) {\n        float pw = i==0?.20*R.x:.10*R.x;\n        vec3 tcoord = i==0?coord:coord2;\n        vec3 aniso = vec3(vor3D(2.-tcoord*pw,n).yy, vor3D(3.-tcoord.zyx*pw,n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n        float anisotropy = i==0?.55:.6;\n        float ah = abs(dot(h,aniso));\n        float q = exp2(((i==0?1.15:.1)-anisotropy)*1.5);\n        nh = pow( nh, q*(i==0?4.:.4) );\n        nh *= pow( 1.-ah*anisotropy, i==0?10.:150. );\n        glints += \n        (lcol*nh*exp2(((i==0?1.2:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n\n    float fresnel = pow(1.0 + dot(n,rd), 2.0);\n    fresnel = mix( 0.0, 0.95, fresnel );\n\n    vec3 reflection = vec3(0);\n    return \n        mix(light*vec3(0.3), reflection, fresnel) +\n        glints +\n        reflection*0.015*(clamp(nl,0.,1.))+ reflection*0.05 +\n        lcol * .3;\n}\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 c = vec3(0.953,0.929,0.886),\n         d = vec3(0.553,0.227,0.949);\n    return vec3(.35) + vec3(.25)*cos( PI*(c*t+d) ); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.001);\n    float csx = 17.*sin(T*.35);\n    vec3 lpos = vec3(0,25,0);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.5);\n    fresnel = mix(.01, .7, fresnel);\n\n    vec3 h = vec3(.5);\n\n    if(m==1.) h=glintz(hue(55.323+hash21(sid+2.))*.5, hit*.075, n, rd, l);\n    if(m==2.) {\n        float chk = mod(sid.y+sid.x,2.)*2.-1.;\n        vec3 clr = chk>.5?vec3(0.282,0.082,0.337):hue(sid.y+sid.y);\n        clr=mix(clr,vec3(.1),hit.y<4.55?clamp(.5-(hit.y-3.55)*.5,0.,1.):0.);\n        h=glintz(clr, hit*.075, n, rd, l);\n    }\n\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) { \n\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    // precal all your vars!\n    r25=rot(-.28);\n    float time = T;\n    \n    tmod = mod(time, 10.);\n    float t1 = lsp(0.5, 1.0, tmod);\n    float t2 = lsp(7.5, 8.0, tmod);\n    \n    float t3 = lsp(1.0, 1.5, tmod);\n    float t4 = lsp(6.5, 7.5, tmod);\n    \n    float t5 = lsp(1.5, 2.5, tmod);\n    float t6 = lsp(5.5, 6.5, tmod);\n    \n    float t7 = lsp(8.0,10., tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n    \n    ga2 = eoc(t3-t4);\n    ga2 = ga2*ga2*ga2;\n    \n    ga3 = eoc(t5-t6);\n    ga3 = ga3*ga3*ga3;\n    \n    ga4 = eoc(t7);\n    ga4 = ga4*ga4*ga4;\n\n    //zoom slice per uv.x\n    float dz = .38+.18*sin(uv.y*2.3+T);\n    //zoom levels\n    float zoom = 14.;\n    if(uv.x> dz) zoom=21.;\n    if(uv.x<-dz) zoom=42.;\n    \n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n    \n    // mouse\n    float y = M.xy == vec2(0) ? 0. :  (M.x/R.x * 2. - 1. ) * PI;\n\n    mat2 rx =rot(.485);\n    mat2 ry =rot(-2.45+y-T*.125);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n    \n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    float k = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<200;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = ray.x * .7;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n            hit=hitPoint;\n            sid=gid;\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m==2.) break;\n            \n            atten *= .65;\n            p += rd*.1;\n            k = sign(map(p).x)*.9;\n            \n            fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n            fresnel = mix(.0, .9, fresnel);\n\n            vec3 rr = refract(rd,n,.8);\n            rd=mix(rr,rd,.5-fresnel);\n  \n        }  \n        if(distance(p,rd)>80.) { break; }\n    }\n    \n    float glowMask = clamp(glow,.0,1.);\n    C = mix(C,vec3(0.145,0.659,0.914)*glow,glowMask);\n    float px = fwidth(uv.x);\n    if(uv.x<px-dz&& uv.x>-(dz+px)) C = vec3(1);\n    if(uv.x>(dz-px)&& uv.x<(dz+px)) C = vec3(1);\n    C=clamp(C,vec3(0),vec3(1));\n    \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n//end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}