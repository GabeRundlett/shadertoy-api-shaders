{
    "Shader": {
        "info": {
            "date": "1636477901",
            "description": "a basic raycast scene.ready for game. \nWASD or arrow keys to move around.",
            "flags": 48,
            "hasliked": 0,
            "id": "7lc3zj",
            "likes": 10,
            "name": "raycast scene",
            "published": 3,
            "tags": [
                "raycast"
            ],
            "usePreview": 0,
            "username": "rockhard",
            "viewed": 252
        },
        "renderpass": [
            {
                "code": "//https://www.shadertoy.com/view/stlSDB\nvoid raywall(vec2 ro,vec2 rd,inout float side,inout float endDist)\n{\n    float currentX,currentY; \n    float firstX,firstY;\n    \n    float dx,dy;\n    float stepX,stepY;\n   \n    firstX = floor(ro.x);\n    firstY = floor(ro.y);\n \n    dx = rd.x != 0.0 ? abs(1./rd.x) : abs(1./(rd.x + 0.00001));\n    dy = rd.y != 0.0 ? abs(1./rd.y) : abs(1./(rd.y + 0.00001));\n    \n    currentX = rd.x < 0.0 ? (ro.x - firstX)*dx : (firstX + 1. - ro.x)*dx;\n    currentY = rd.y < 0.0 ? (ro.y - firstY)*dy : (firstY + 1. - ro.y)*dy;    \n\n    stepX = rd.x > 0.0 ? 1. : -1.; \n    stepY = rd.y > 0.0 ? 1. : -1.;     \n\n    side = 0.0;\n    \n    for(int i = 1; i < 10; i++){\n        //the distane to closest x or closest y grid line.            \n        if(currentX < currentY){        \n            currentX += dx;\n            firstX += stepX;\n            side = 0.;\n        }\n        else {\n            currentY += dy;\n            firstY += stepY;\n            side = 1.;\n        }\n       \n        if(map2(int(firstX),int(firstY))>0){\n           break;\n        }\n    }\n   //Perpendicular Distnace\n   if(side == 1.0)       \n       endDist = abs((firstY - ro.y + (1. - stepY)/2.)/rd.y);\n   else \n       endDist = abs((firstX - ro.x + (1. - stepX)/2.)/rd.x);\n}\n \n//conditional noticeable math erro,not perfect...\nvoid lightfog(vec3 ori,vec3 dir,float ed,vec3 p, vec3 nor,\n              vec3 lp,vec3 lc,inout vec3 col){\n    vec3 l2o=ori-lp;\n    float c=dot(l2o,l2o);\n    float b=dot(l2o,dir);\n    //if(c<0.0) return;   \n    float h = sqrt(c-b*b);\n    float len=sqrt(c);\n    float t =clamp(ed-len,-1.0,1.0);  \n    //https://www.shadertoy.com/view/slXXD4\n    if(t>0.0) col+= clamp(1.57-atan(b / h),0.0,1.0)/ h*.03*t*lc;      \n    \n    vec3 d2l=lp-p;\n    len =length(d2l); \n    if(len<1.0){ d2l /=len;\n       col+=max(0.0,dot(d2l,nor))*(1.0- sqrt(len))*lc;\n    }  \n}\n\nvoid drawEnemy(inout vec3 col,vec3 ro,vec3 rd,float d,enemy e,float fog){\n    vec2 suv;\n    float d2ene0 = raySprite(ro,rd,e.p,vec2(0.27,0.3)+sin(iTime*10.0)*0.01,suv);\n    if(d2ene0>0.0&&d2ene0<d)\n    { \n       col+=ghost(vec2(suv.x,suv.y),iTime)*(1.0-suv.x)*fog; \n    }\n}\n\nvoid drawBullet(inout vec3 col,vec3 ro,vec3 rd,float d){\n    \n    vec4 bltpos = texture(iChannel3,vec2(0.5/iResolution.x, 1.0)); \n    vec3 p=vec3(bltpos.x,0.5,bltpos.z);\n    vec2 suv;\n    float d2ene0 = raySprite(ro,rd,p,vec2(0.2,0.2),suv);\n    if(d2ene0>0.0&&d2ene0<d)\n    { \n       col+=length(suv);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    float asp=iResolution.x/iResolution.y;\n    uv.x*=asp;\n      \n    //these 2 texture is bufferA for user control and collision\n    vec4 inputdir = texture(iChannel3,vec2(2.5/iResolution.x, 0));\n    if(inputdir.x+inputdir.y==0.0)\n    {\n      inputdir.x= cos(0.0);inputdir.y=sin(0.0);\n    }\n    vec4 inputpos = texture(iChannel3,vec2(3.5/iResolution.x, 0)); \n    //player position xz\n    vec2 ro = inipos+inputpos.xy;\n    //player direction xz and rotate 90degs to project to screen \n    vec3 d=vec3(inputdir.x-inputdir.y*uv.x,uv.y,inputdir.y+inputdir.x*uv.x);\n    //normalize ray direction will cause fish eye \n    //and got some drunk feeling. maybe good for now :>\n    d=normalize(d);\n    vec2 rd =d.xz;\n    \n    //raycast test\n    float side,endDist;    \n    raywall(ro,rd,side,endDist);  \n \n    //endDist 1 = full height\n    float height = endDist>0.0?1.0/(endDist*asp):0.0;        \n  \n    float h= step(height,abs(uv.y));\n    vec2 tuv;//tiled uv space\n    \n    int matid = 0;\n   \n    //render colors& position 3d\n    vec3 col=vec3(0.0),p=vec3(0.0),n=vec3(0.0);\n    \n    if(h<1.0){  //wall or wall\n       tuv.y=uv.y*0.5/height;\n       p=vec3(ro.x+ endDist*rd.x,tuv.y,ro.y + endDist*rd.y);\n       float wallP = side == 1.0?p.x : p.z;\n       tuv.x=fract(wallP);      \n       \n       col = texture(iChannel0,tuv).xyz;\n       n = normalize(cross(dFdx(p), dFdy(p)));\n    }\n    else {//ceil or floor\n      float ty=uv.y*asp;\n      endDist = sign(ty)/(ty); \n      p=vec3(ro.x+ endDist*rd.x,0.0,ro.y + endDist*rd.y);\n      \n      tuv = fract(p.xz); \n     \n      vec3 roof=texture(iChannel1,tuv).xyz;\n      vec3 ground=texture(iChannel2,tuv).xyz;\n      /********\n      do some treatment such as blood,hole or painting on the wall\n      ********/\n      \n      if(uv.y>0.0){        \n        col=roof; n.y=-1.0; p.y=1.0; matid=1;\n      }\n      else{         \n        col=ground; n.y=1.0; matid=2;\n      }       \n    }  \n     float fog=1.0/(1.0+endDist*endDist);\n    //kind of fog\n    col*=vec3(clamp(p*0.3*fog,0.0,1.0));       \n    \n    vec3 ori=vec3(ro.x,0.5,ro.y);   \n    //  fish eye \n    vec3 dir=normalize(vec3(rd.x,uv.y,rd.y));\n    //reconstruct fish eye world position\n    p = ori+dir*endDist;\n    \n    drawEnemy(col,ori,dir,endDist,ene0,fog);\n      drawEnemy(col,ori,dir,endDist,ene1,fog);\n       drawEnemy(col,ori,dir,endDist,ene2,fog);       \n  \n    //lights\n    float flash= hash1(iTime)<0.98?1.0:0.3;\n    \n    lightfog(ori,dir,endDist,p,n,vec3(5.5,0.995,5.5),vec3(1.0,0.3,0.1)*flash,col);\n    lightfog(ori,dir,endDist,p,n,vec3(1.5,0.995,8.0),vec3(0.0,0.1,0.5)*flash,col);\n    lightfog(ori,dir,endDist,p,n,vec3(8.0,0.995,1.5),vec3(0.3,0.1,0.0)*flash,col);\n    \n    drawBullet(col,ori,dir,endDist);\n       \n    fragColor = vec4(sqrt(col),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define turnSpeed 3.5 \n#define moveSpeed 1.5\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT   = 37;\nconst int KEY_UP     = 38;\nconst int KEY_RIGHT  = 39;\nconst int KEY_DOWN   = 40;\n\nfloat KeyPressed(int key) \n{\n  return texture(iChannel1, vec2(key,0.25) / 256.0).x;\n}\n//https://www.shadertoy.com/view/XtfyWs\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{   \n    col = vec4(0.0);\n   \n    vec2 uv = uv0 - 0.5; \n    //the first 4 pixels for mousedelta and keyborad record\n    if(uv.x<5.0&&uv.y<2.0){ \n    \n    vec4 iMouseLast     = texture(iChannel0, vec2(0.0));\n    vec4 iMouseAccuLast = texture(iChannel0, vec2(1.5/iResolution.x,0.0));\n\n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    \n    vec4 dirLast = texture(iChannel0,vec2(2.5/iResolution.x,0.0));\n    vec4 posLast = texture(iChannel0, vec2(3.5/iResolution.x,0.0));\n    \n    if(uv.x == 0.0) col = iMouse;  \n    if(uv.x == 1.0) col = vec4(iMouseAccu1,mouseDelta2);\n    if(uv.x == 2.0){ \n         float ax=turnSpeed*iMouseAccuLast.x/iResolution.x;\n         float ay=turnSpeed*iMouseAccuLast.y/iResolution.y;\n         col = vec4(cos(ax),sin(ax),cos(ay),sin(ay));    \n      } \n    if(uv.x == 3.0){ \n       \n         //W S key\n         float updown = (KeyPressed(87)-KeyPressed(83))*0.007;\n         //UP down key\n         updown += (KeyPressed(38)-KeyPressed(40))*0.007;\n         //A D key\n         float leftright= (KeyPressed(65)-KeyPressed(68))*0.007;\n         //left right key\n         leftright += (KeyPressed(37)-KeyPressed(39))*0.007;\n                \n         float ddx=(dirLast.x*updown)*moveSpeed+(dirLast.y*leftright)*moveSpeed;\n         float ddy=(dirLast.y*updown)*moveSpeed-(dirLast.x*leftright)*moveSpeed;\n       \n         posLast.x+=ddx;\n         posLast.y+=ddy;         \n      \n         if(map2(int(posLast.x+inipos.x),int(posLast.y+inipos.y))>0)\n          { posLast.x-=ddx; posLast.z=ddx; }\n         if(map2(int(posLast.x+inipos.x),int(posLast.y+inipos.y))>0)\n          { posLast.y-=ddy; posLast.w=ddy; }   \n         \n         //spring style collision              \n         posLast.xy-=posLast.zw; \n         posLast.zw*=0.95;  \n         \n         col = posLast;    \n      } \n      /*********\n      fire bullet\n      ********/\n      if(uv.y==1.0){         \n         vec4 bltpos = texture(iChannel0, vec2(0.5/iResolution.x,1.0));\n         vec4 bltstate = texture(iChannel0, vec2(1.5/iResolution.x,1.0));\n         float life=bltstate.x;\n        if(uv.x==0.0){\n           bltpos.xy+=bltpos.zw;\n           if(KeyPressed(32)>0.0){ \n              bltpos.xy= posLast.xy; \n              bltpos.zw= dirLast.xy; \n           }\n         }\n          col = bltpos;   \n      }      \n    }\n    else discard;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 inipos=vec2(3.5,5.01);\n\n//The map is from MonkeyIsBack: https://www.shadertoy.com/view/4dG3RD\nint map2(int x,int y){\n   //why not working? Does the map must be 0-1?\n   //if(x<=-5||x>=11||y<=-5||y>=11)return true;\n   \n    if (y >= 0 && y <= 9) {   \n        if (x == 0 || x == 9) return 1;\n    }\n    if (x >= 0 && x <= 9) {\n        if (y == 0 || y == 9) return 1;\n    }\n\n    if (x == 2 && y == 2) return 1;\n    if (x == 2 && y == 4) return 1;\n    if (x == 2 && y == 6) return 1;\n    if (x == 2 && y == 7) return 1;\n    \n    if (x == 4 && y == 2) return 1;\n    if (x == 4 && y == 4) return 1;\n    if (x == 4 && y == 6) return 1;\n    if (x == 4 && y == 7) return 1;\n    \n    if (x == 6 && y == 2) return 1;\n    if (x == 6 && y == 4) return 1;\n    if (x == 6 && y == 6) return 1;\n    if (x == 6 && y == 7) return 1;\n\n\treturn 0;\n}\n \nfloat hash1(float p){ return fract(sin(p)*43758.5); }\n\n#define Epsilon 1e-4\nvec4 pointNormal(vec3 p,vec3 n){ return vec4(n,-dot(p,n)); }\nfloat pointPlane(vec3 p,vec4 pl){ return dot(p,pl.xyz)+pl.w; }\nfloat rayPlane(vec3 ro,vec3 rd,vec4 pl){\n   float d = dot(pl.xyz,rd);\n   if(abs(d)<Epsilon) return 0.0;\n   return -(dot(ro,pl.xyz)+pl.w)/d;\n}\n//view aligned square with size of \"s\" \nfloat raySprite(vec3 ro,vec3 rd,vec3 p,vec2 s,inout vec2 uv){\n   vec4 plane=pointNormal(p,normalize(ro-p));\n   float d=rayPlane(ro,rd,plane);\n   vec3 ddp=ro+rd*d-p;\n   if(ddp.y>s.y||ddp.y<-s.y)return 0.0;\n   float dx=length(ddp.xz);\n   if(dx>s.x)return 0.0;   \n   uv.x=0.5*dx/s.x;\n   uv.y=ddp.y/s.y*0.5; return d;   \n}\n//https://shadertoy.com/view/tljGDh\nfloat ghost(vec2 p,float time){\n    float rx = abs(p.x);  \n    float rx2 = rx*rx;   \n    float rx4 = pow(rx,4.0);\n    float pds = p.y+0.55; \n    \n    float logo = abs(pds*pds)*2.0 + rx*4.0 - 1.5; //sides  \n    logo = max(logo, rx*rx- p.y*2.2 - 0.5); // bottommost\n         \n    float sinVal = (.35-(abs(sin(fract(time)*3.14))*.5-.25)+ .5 ); // lol sine    \n    logo = max(logo, (.5-abs(p.y*6.7 + 1.8 - 7.*rx2))*sinVal- rx4*16. + 0.21); // mouth\n    logo = max(logo, (.5 - abs(p.y*7. - 1.85 + 6.5*rx2))*0.5 - rx4*17.5 + 0.21); // brow\n    \n    float upEyes = sinVal*-.025; // nudge eyes up\n       \n    logo =min(1.0-logo,(2.0+sinVal)*length(vec2(abs(p.x*1.12)-0.16, p.y+.05+upEyes))+.25); //eyes\n    return smoothstep(0.4, 0.5, logo);\n}\n\nstruct enemy{ vec3 p; };\n\nenemy ene0=enemy(vec3(5.5,0.35,5.5));\nenemy ene1=enemy(vec3(1.5,0.35,8.0));\nenemy ene2=enemy(vec3(8.0,0.35,1.5));\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}