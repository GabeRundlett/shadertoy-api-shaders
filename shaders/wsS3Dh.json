{
    "Shader": {
        "info": {
            "date": "1548728598",
            "description": "I've coded this on my phone, so why not port it to Shadertoy.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsS3Dh",
            "likes": 7,
            "name": "SlickTunnel",
            "published": 3,
            "tags": [
                "3d",
                "ray",
                "sdf",
                "marching"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 444
        },
        "renderpass": [
            {
                "code": "#define STEPS  512\n#define FAR    10.\n#define EPS   1e-3\n// Uncomment for a hexagon, rather than a box.\n//#define HEX\n\nmat2 rot( float a )\n{\n\n\treturn mat2( cos( a ), -sin( a ),\n\t\t         sin( a ),  cos( a )\n\t\t        );\n\n}\n\nvec3 twiZ( vec3 p, float f )\n{\n\n    float a = p.z * 1.2 * f;\n\n    p.yx = cos( a ) * p.yx + sin( a ) * vec2( -p.x, p.y );\n\n    return p;\n\n}\n\nfloat vmax(vec2 v)\n{\n\n\treturn max(v.x, v.y);\n\n}\n\nfloat fBox2Cheap(vec2 p, vec2 b)\n{\n\n \treturn vmax(abs(p)-b);\n\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n\n\tconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2( length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x), p.z-h.y );\n\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\n}\n\nfloat path( float z )\n{\n\n    vec2 mou = iMouse.xy / iResolution.y;\n\treturn ( 1.5 * sin( z ) * 1.2 * cos( z ) );\n\n}\n\nvec2 map( vec3 p )\n{\n\n    vec2 spe = vec2( length( p -\n                            vec3( 0.3 * -path( p.z ),\n                                 0,\n                                 1.5 + iTime\n                                )\n                           ) - 0.2, 0.0 );\n\n    vec3 tem = p;\n\n    p.x += path( p.z );\n    tem.x += path( p.z );\n    tem = twiZ( p, 1.0 );\n\n    float hex = sdHexPrism( tem, vec2( 1, iTime + 8.7 ) );\n\n    float box = fBox2Cheap( p.xy, vec2( 3 ) );\n    float boxO = fBox2Cheap( tem.xy, vec2( 1 ) );\n\n\n    #ifdef HEX\n    vec2 tun = vec2 ( max( -hex, box ), 1.0 );\n    \n    #else\n    vec2 tun = vec2 ( max( -boxO, box ), 1.0 );\n    \n    #endif\n\n    if( spe.x < tun.x ) tun = spe;\n\n    return tun;\n\n}\n\nvec3 norm( vec3 p )\n{\n\n\tvec2 e = vec2( 1e-3, 0 );\n\n\treturn normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n\t\t                      map( p + e.yxy ).x - map( p - e.yxy ).x,\n\t\t                      map( p + e.yyx ).x - map( p - e.yyx ).x\n\t\t                    )\n\t\t              );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n\tfloat t = 0.0;\n\n\tfor( int i = 0; i < STEPS; ++i )\n\t{\n\n\t\tvec3 p = ro + rd * t, pO = vec3( 0 ), \n        roO = vec3( 0 ), rdO = vec3( 0 );\n        float tO = 0.0;\n\n        vec3 n = norm( p );\n        \n\t\td = 0.5 * map( p ).x;\n\n\t\tif( d < EPS || t > FAR ) break;\n\n\t\tt += d;\n\n\t}\n\n\treturn t;\n\n}\n\nvec3 sha( vec3 ro, vec3 rd )\n{\n\n\tfloat d = 0.0, t = ray( ro, rd, d );\n\n\tvec3 p = ro + rd * t;\n\tvec3 n = norm( p );\n\tvec3 lig = normalize( vec3( 0, 0, -iTime - 1.1 ) );\n    lig.x -= 0.3 * path( lig.z );\n    lig = normalize( lig );\n    vec3 ref = reflect( rd, n );\n\n\tfloat amb = 0.5 + 0.5 * n.y;\n    float nam = 0.5 + 0.5 * -n.y;\n\tfloat dif = max( 0.0, dot( lig, n ) );\n\tfloat spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n\n\tvec3 col = vec3( 0 );\n    col += 0.1 * nam;\n\tcol += 0.1 * amb;\n\tcol += 0.2 * dif;\n\tcol += 1.0 * spe;\n    \n    if( map( p ).y == 0.0 )\n    col.r += 0.2;\n    \n    col += 1.0 * 0.025 * t * t;\n    \n    col *= sqrt( col );\n\n\treturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n\n    vec3 ro = vec3( 0, 0, 0.9 + iTime );\n    ro = twiZ( ro, 1.0 );\n    ro.x -= 0.3 * path( ro.z );\n\n    vec3 rd = normalize( vec3( uv, 1 ) );\n    rd = twiZ( rd, 1.0 );\n    rd.x -= 0.3 * path( ro.y);\n\n    float d = 0.0, t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n\n    vec3 col = d < EPS ? sha( ro, rd ) : vec3( 1 );\n        \n    //if( map( p ).y == 0.0 )\n    for( int j = 0; j < 5; ++j )\n    {\n\n        p += ro * 1e-5;\n        ro = p + rd;\n        rd = ( reflect( rd, n ) );\n        \n        if( d < EPS ) col += 0.25 * sha( ro, rd );\n        \n    \n    }\n\n\n    fragColor = vec4( col, 1 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}