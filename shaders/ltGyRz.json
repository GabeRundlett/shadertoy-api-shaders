{
    "Shader": {
        "info": {
            "date": "1534818226",
            "description": "Getting closer to what I want. Runs too slowly. Need to figure out a way to compute the layering with a for loop I guess.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltGyRz",
            "likes": 38,
            "name": "Rainbow (WIP)",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "momoro",
            "viewed": 1504
        },
        "renderpass": [
            {
                "code": "mat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898, 78.233)))*\n        \t\t\t\t 43758.5453123);\n}\n\nfloat random1 (float f) {\n    return random(vec2(f, -0.128));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., 0.)), \n                  smoothstep(0.0, 1., f)); \n   \n    return n;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n} \n\n\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm(vec2 x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 0.;\n    float gain = 0.;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(frequency*x);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = vec4(0., 0., 0., 1.);\n\n\n    for(float k=0.; k<2.; k++) {\n        vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n        vec2 uv = st;\n        \n        st *=2.788;\n        st *= rotate(k/10.936);\n\n        // Tile\n        vec2 i_st = floor(st);\n        vec2 f_st = fract(st);\n\n        float m_dist = 1.; // min distance\n\n        for(int j=-3; j<=3; j++) {\n            for(int i=-3; i<=3; i++) {\n                vec2 neighbor = vec2(float(i), float(j));\n                vec2 offset = random2(i_st + neighbor);\n\n                offset = 0.5 + 0.5 * sin(iTime/1.5 + 6.2831 * offset );\n              //  offset = (iMouse - .5 * iResolution.xy) / iResolution.y * 2. * offset;\n               // offset += sin(iTime/2. + 6.2831 * offset);\n\n                vec2 pos = neighbor + offset - f_st;\n                float dist = length(pos);\n\n                // Metaball\n                float diff = k/2. + 0.084;\n                diff = k/9.120;\n                m_dist = smin(m_dist, dist, 1.640 + diff);            \n            }\n        }\n\n\n        float f = m_dist;\n        f *= 5.;\n        #define steps 4.\n        f = ceil(f *steps) / steps;\n        f = map(f, -3., 0., 1., 0.000);\n\n                \n        float incr = (1./(steps*3.));\n\n        // Map colors to height\n       for(float q = 0.; q<steps*3.; q++) {\n\n\t\t\t// Get the current height\n            float fc = smoothstep(q * incr, q*incr+-0.062, f);\n          \tfc = step(q * incr, f);\n            \n\t\t\t// Base color\n            float h =  map(q*incr, 0., 1., 0.160, 0.844);\n\t\t\th +=  + fc + k/3.392;\n           float co = sin01(iTime);\n           co = map(co, 0., 1., .5, .2);\n           h += uv.x * uv.y + co;\n           \n            // Blend it\n            vec4 c = vec4(h, 0.864, 1., 0.0);\n       \t\tc = vec4(hsv2rgb(c.xyz), 0.444);\n            color = blend(color, c * fc);\n        }\n        \n\n    }\n    \n    float p = 0.;\n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    p = fbm(st, 100., .7, iTime/10.);\n    p = map(p, 0., 0.432, 0.664, 1.040);\n   // color = vec4(color.xyz * p, 1.);\n\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}