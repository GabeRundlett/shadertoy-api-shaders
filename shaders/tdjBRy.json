{
    "Shader": {
        "info": {
            "date": "1590315495",
            "description": "Simplified cloud shader with my learning memo in comments\nbased on: https://www.shadertoy.com/view/4tdSWr",
            "flags": 0,
            "hasliked": 0,
            "id": "tdjBRy",
            "likes": 15,
            "name": "My 2D Clouds",
            "published": 3,
            "tags": [
                "fractal",
                "noise",
                "clouds",
                "fbm"
            ],
            "usePreview": 0,
            "username": "takahiroando",
            "viewed": 1403
        },
        "renderpass": [
            {
                "code": "const float cloudscale = 2.5; // 1.1\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n// <personal favorite noise funcs>\nfloat hash(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(123.45, 678.9))) * 987654.321);\n}\n\nfloat noise(vec2 uv) {\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 b = smoothstep(0.0, 1.0, f);\n\treturn 2.0 * mix(\n\t\tmix(hash(i), hash(i + vec2(1.0, 0.0)), b.x),\n\t\tmix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), b.x), b.y) - 1.0;\n}\n// </personal favorite noise funcs>\n\n// common part of FBMs...\nfloat fbm(bool do_abs, vec2 n, float amp_init, float amp_step, float q, float base_octave) {\n    float time = iTime * speed * base_octave;\n    \n    n *= vec2(iResolution.x/iResolution.y,1.0) * cloudscale * base_octave;\n    n -= q - time;\n    \n\tfloat total = 0.0, amplitude = amp_init;\n\tfor (int i = 0; i < 7; i++) {\n        float v = noise(n) * amplitude;\n        v = do_abs ? abs(v) : v;\n        \n\t\ttotal += v;\n        \n\t\tn = m * n + time;\n\t\tamplitude *= amp_step;\n\t}\n\treturn total;\n}\n\nfloat calcF(vec2 p, float q) {\n    //ridged noise shape\n\tfloat r = fbm(true, p, 0.8, 0.7, q, 1.0);\n\n    //noise shape\n\tfloat f = fbm(false, p, 0.7, 0.6, q, 1.0);\n    \n    f *= r + f;\n    f = cloudcover + cloudalpha*f*r;\n    return f;\n}\n\nfloat calcC(vec2 p, float q) {\n    //noise colour\n    float c = fbm(false, p, 0.4, 0.6, q, 2.0);\n    \n    //noise ridge colour\n    float c1 = fbm(true, p, 0.4, 0.6, q, 3.0);\n\t\n    return c + c1;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    // f, c, q are not sure yet...\n    \n    // q is used to subtract from uv with time in fbm()...???\n    float q = fbm(false, p, 0.1, 0.4, 0.0, 1.0);\n        \n    // f part(?)\n\tfloat f = calcF(p, q);\n    \n    // c part(color?)\n    float c = calcC(p, q);\n    \n    // sky color is just a vertical screen gradietion\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n\n    // The key strategy of shader would be here:\n    // mix sky color and cloud color by (f + c).\n    // The cloud color is calculated from darken sky color (by skytint) + cloud color.\n    // Not sure f + c meaning yet...\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}