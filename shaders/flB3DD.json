{
    "Shader": {
        "info": {
            "date": "1623881401",
            "description": "Maybe not so useful but it can help in avoiding unneccessary matrix inverse computations or maybe in collision detections. I was mainly interested in trying to generalize [url=https://www.shadertoy.com/view/stSGDh]this[/url] SDF to 3D.",
            "flags": 0,
            "hasliked": 0,
            "id": "flB3DD",
            "likes": 9,
            "name": "Transformed Box AABB",
            "published": 3,
            "tags": [
                "3d",
                "aabb",
                "boundingbox",
                "transformed"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "// Desmos graph: https://www.desmos.com/calculator/peu1crmp2n\n\n// Constants\n#define EPSILON 1e-3\n#define INFINITY 1e20\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Settings\n#define ZOOM 1.0\n#define AA 2\n\n// Convenience structs\nstruct Ray { vec3 pos; vec3 dir; };\nstruct Light { vec3 pos; vec3 color; };\nstruct TraceInfo { bool hit; float dist; vec3 pos; vec3 nor; vec3 mat; };\n\n// Axis aligned bbox of a transformed box\n// The vector returned gives the upper and lower bounds\n// relative to the box's center\nvec3 transformedBoxAABB(in vec3 dims, in mat3 mat) {\n    vec3 w = mat[0] * dims.x;\n    vec3 h = mat[1] * dims.y;\n    vec3 d = mat[2] * dims.z;\n    vec3 a = w + h, b = w - h;\n    return max(max(abs(a + d), abs(a - d)),\n               max(abs(b + d), abs(b - d)));\n}\n\n// Box intersector adapted from https://www.shadertoy.com/view/ld23DV\nbool testAABB(in vec3 pos, in vec3 dims, in Ray ray) {\n    ray.pos -= pos;\n    vec3 n = ray.pos / ray.dir;\n    vec3 k = dims / abs(ray.dir);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nvoid addBox(in vec3 pos, in vec3 dims, in mat3 transform, in vec3 mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    mat3 inv = inverse(transform);\n    ray.pos = inv * ray.pos;\n    ray.dir = inv * ray.dir;\n\n    vec3 n = ray.pos / ray.dir;\n    vec3 k = dims / abs(ray.dir);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    vec3 nor = -sign(ray.dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    if (tN > 0.0 && (scene.hit ? tN < scene.dist : true)) {\n        scene.hit = true;\n        scene.dist = tN;\n        scene.pos = transform * (ray.pos + ray.dir * tN);\n        scene.nor = transform * nor;\n        scene.mat = mat;\n        scene.pos += pos;\n    }\n}\n\n// Very inefficient\nvoid addCylinder(in vec3 pos, in int align, in float height, in float radius, in vec3 mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n    if (align == 0) {\n        ray.pos.xy = ray.pos.yx;\n        ray.dir.xy = ray.dir.yx;\n    }\n\n    if (align == 2) {\n        ray.pos.yz = ray.pos.zy;\n        ray.dir.yz = ray.dir.zy;\n    }\n\n    // Quadratic coefficients\n    float a = dot(ray.dir.xz, ray.dir.xz);\n    float b = 2.0 * dot(ray.pos.xz, ray.dir.xz);\n    float c = dot(ray.pos.xz, ray.pos.xz) - radius * radius;\n\n    // Solve with a plane for the base and top\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float hh = 0.5 * height;\n        float tBase = +(hh - ray.pos.y) / ray.dir.y;\n        float tTop  = -(hh + ray.pos.y) / ray.dir.y;\n        vec4 roots = vec4(-(vec2(-1, 1) * sqrt(discr) + b) / a * 0.5, tBase, tTop);\n\n        float t = INFINITY;\n        vec3 hitPos, nor = vec3(0.0, -1.0, 0.0);\n        int nClosest;\n        for (int n=0; n < 4; n++) {\n            vec3 hitCandid = ray.pos + ray.dir * roots[n];\n            if (roots[n] > 0.0 && roots[n] < t  && abs(hitCandid.y) < hh + EPSILON && dot(hitCandid.xz, hitCandid.xz) < radius * radius + EPSILON) {\n                t = roots[n];\n                hitPos = hitCandid;\n                nClosest = n;\n            }\n        }\n\n        if (nClosest < 2) nor = vec3(hitPos.xz / radius, 0.0).xzy; // Sides\n        else nor.y = sign(2.5 - float(nClosest)); // Base and top\n        if (t > 0.0 && t < INFINITY && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = hitPos + pos;\n            scene.nor = nor;\n            scene.mat = mat;\n            if (align == 0) {\n                scene.pos.xy = scene.pos.yx;\n                scene.nor.xy = scene.nor.yx;\n            }\n\n            if (align == 2) {\n                scene.pos.yz = scene.pos.zy;\n                scene.nor.yz = scene.nor.zy;\n            }\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(false, -1.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\n    vec3 dims = vec3(1.0);\n    dims = vec3(0.75, 1.5, 0.75);\n\n    float y = iTime; // Yaw\n    float p = 0.5;   // Pitch\n    float r = iTime; // Roll\n\n    float cy = cos(y), sy = sin(y);\n    float cp = cos(p), sp = sin(p);\n    float cr = cos(r), sr = sin(r);\n\n    mat3 mat = mat3(cy * cr + sy * sp * sr, cp * sr,  sy * cr - cy * sp * sr,\n                    sy * sp * cr - cy * sr, cp * cr, -sy * sr - cy * sp * cr,\n                                  -sy * cp,      sp,                 cy * cp);\n\n    mat[0].x += sin(iTime);\n    mat[2].y += cos(iTime);\n\n    vec3 bbox = transformedBoxAABB(dims, mat);\n    if (testAABB(vec3(0.0), bbox, ray)) addBox(vec3(0.0), dims, mat, vec3(1.0, 0.5, 0.0), ray, scene);\n\n    float width = 2.0 * bbox.x;\n    addCylinder(vec3(0.0, -bbox.y, -bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0,  bbox.y, -bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0,  bbox.y,  bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0, -bbox.y,  bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n\n    float height = 2.0 * bbox.y;\n    addCylinder(vec3(-bbox.x, 0.0, -bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, 0.0, -bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, 0.0,  bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(-bbox.x, 0.0,  bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n\n    float depth = 2.0 * bbox.z;\n    addCylinder(vec3(-bbox.x, -bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, -bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x,  bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(-bbox.x,  bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Light light = Light(vec3(-10.0, 10.0, 10.0), vec3(0.8, 0.2, 0.2));\n\n    // Mouse rotation\n    vec2 c = cos(mouse), s = sin(mouse);\n    mat2 yaw = mat2(c.x, -s.x, s.x, c.x);\n    mat2 pitch = mat2(c.y, -s.y, s.y, c.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -ZOOM)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Render the scene\n            TraceInfo scene = traceScene(camRay);\n            if (scene.hit) {\n                vec3 lightDir = normalize(light.pos - scene.pos);\n                float shade = max(0.0, dot(scene.nor, lightDir));\n                fragColor.rgb += light.color * scene.mat * shade;\n            }\n\n            // Sample the background on a miss\n            else fragColor += 1.15 - length(uv);\n        }\n    }\n\n    // Average and tonemap\n    fragColor.rgb = pow(fragColor.rgb / float(AA * AA), vec3(0.75));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}