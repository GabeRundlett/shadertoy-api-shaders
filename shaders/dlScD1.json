{
    "Shader": {
        "info": {
            "date": "1691780940",
            "description": "Electron orbitals\nChange the paramters; N, L and M to see different orbitals. \nRemember that N should be between 1 and 7, L should be between 0 and N - 1 and M should be between -L and L.\nHowever, for N=7 only L=1 is a possible orbit.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlScD1",
            "likes": 10,
            "name": "ElectronOrbitals",
            "published": 3,
            "tags": [
                "electrons",
                "physics",
                "orbitals",
                "atoms",
                "quantomphysics"
            ],
            "usePreview": 0,
            "username": "NoddyDirksen",
            "viewed": 192
        },
        "renderpass": [
            {
                "code": "// CHANGE THESE PARAMETERS:\nint N = 6; int L = 3; int M = 1;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat a_0 = 0.01;\nint Z = 1;\n\n//table generated in processing (For normalization)\nfloat weights[140] = float[140](343202.12, 186275.58, 155640.55, 298882.8, 155640.55, 44121.52, 41445.11, 141595.47, 41445.11, 47218.89, 64757.6, 207019.28, 64757.65, 47218.9, 14995.13, 13113.93, 51138.72, 13113.93, 14940.22, 20488.86, 87305.66, 20488.85, 14940.22, 18380.66, 18301.49, 28210.77, 123963.88, 28210.81, 18301.51, 16776.45, 6308.71, 5371.58, 21486.21, 5371.58, 6119.35, 8392.0, 36287.42, 8392.02, 6119.35, 18145.31, 7496.24, 11554.66, 51002.49, 11554.69, 7496.23, 6871.55, 170316.92, 62744.87, 9221.62, 14756.83, 65682.28, 14756.81, 9221.03, 7454.48, 7571.13, 3084.05, 2590.6, 10362.29, 2590.6, 2951.02, 4047.15, 17499.04, 4047.15, 2951.02, 23026.0, 3615.0, 5572.12, 24595.08, 5572.12, 3615.0, 3313.8, 207514.52, 76178.31, 4448.44, 7116.36, 31675.59, 7116.37, 4446.68, 3594.87, 3651.09, 500000.0, 491490.47, 132158.58, 5541.46, 8668.55, 38745.6, 8668.2, 5324.26, 4122.79, 3681.53, 3963.87, 1680.02, 1398.46, 5593.84, 1398.46, 1592.83, 2184.42, 9445.42, 2184.42, 1592.83, 26426.35, 1951.25, 3007.64, 13275.7, 3007.64, 1951.25, 1788.67, 239601.66, 89075.74, 2403.16, 3841.15, 17095.78, 3841.14, 2400.15, 1940.4, 1970.76, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 500000.0, 500000.0, 500000.0, 500000.0, 290962.38, 369260.75, 500000.0, 369250.9, 228901.84, 173593.95, 148123.94, 140033.84, 156570.36);\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec2 complexDivision(vec2 a, vec2 b){\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / float(b.x * b.x + b.y * b.y);\n}\n\nint factorial(int n){\n    int product = 1;\n    for(int i = 2; i <= n; i++){\n        product *= i;\n    }\n    return product;\n}\n\nfloat laguerre(int n, int alpha, float x){\n    if(n == 0)\n        return 1.0;\n    \n    float lsub = 1.0;\n    float l = float(alpha) - x + 1.0;\n    float ladd = 0.0;\n    for(int k = 1; k < n; k++){\n        ladd = ((2.0 * float(k) + 1.0 + float(alpha) - x) * l \n            - (float(k) + float(alpha)) * lsub) / (float(k) + 1.0);\n        lsub = l;\n        l = ladd;\n    }\n    \n    return l;\n}\n\nint pochhammer(int x, int n){\n    int product = 1;\n    \n    for(int i = 0; i < n; i++){\n        product *= (x + i);\n    }\n    \n    return product;\n}\n\nvec2 associatedLegendrePolynomial(int l, int m, float x){\n    float sum = 0.0;\n    for(int k = 0; k <= l; k++){\n        if(k - m < 0)\n            continue;\n        sum += float(pochhammer(-l, k) * pochhammer(l + 1, k)) / \n            float(factorial(k - m) * factorial(k)) * pow((1.0 - x) / 2.0, float(k));\n    }\n    float imTop = 0.0, reTop = 0.0, imBottom = 0.0, reBottom = 0.0;\n    \n    if(1.0 + x < 0.0){\n        imTop = pow(abs(1.0+x), float(m) / 2.0);\n    }\n    else{\n        reTop = pow(1.0+x, float(m) / 2.0);\n    }\n    if(1.0 - x < 0.0){\n        imBottom = pow(abs(1.0-x), float(m) / 2.0);\n    }\n    else{\n        reBottom = pow(1.0-x, float(m) / 2.0);\n    }\n        \n    vec2 fraction = complexDivision(vec2(reTop, imTop), vec2(reBottom, imBottom));\n    float frac = pow(abs(1.0+x), float(m) / 2.0) / pow(abs(1.0-x), float(m) / 2.0);\n    \n    return fraction * sum;\n}\n\nvec2 sphericalHarmonics(int l, int m, float theta){\n    float c = sqrt(float(2 * l + 1) * float(factorial(l - m)) \n        / (4.0 * 3.14 * float(factorial(l + m))));\n    vec2 polynomial = associatedLegendrePolynomial(l, m, cos(theta));\n    return c * polynomial;\n}\n\nfloat waveFunction(int n, int l, int m, float r, float theta, float phi){\n    float underSqrt = sqrt(pow(2.0 / (float(n) * a_0), 3.0) \n        * float(factorial(n - l - 1)) / float(2 * n * factorial(n + l)));\n    float rho = float(Z) * r / a_0;\n    float exponents = exp(-rho / 2.0) * pow(rho, float(l));\n    float laguerre = laguerre(n - l - 1, 2 * l + 1, rho);\n    float harmonics = length(sphericalHarmonics(l, m, theta));\n        \n    return underSqrt * laguerre * exponents * harmonics;\n}\n\nint location(int n, int l, int m){\n    return n * (n-1) * (2 * n - 1) / 6 + l * (l+1) + m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / (iResolution.y + 0.0);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = vec3(uv.y + 0.5) * vec3(84, 22, 235) / 255.0;\n    \n    // Output to screen\n    \n    vec3 sphereCenter = vec3(0, 0, 8);\n    float radius = 1.5;\n    \n    vec3 ray = vec3(vec2(uv.x * aspectRatio, uv.y) - vec2(0.5 * aspectRatio, 0.5), 2);\n    float rz = ray.z;\n    float rx = ray.x;\n    /*ray.x = rx * cos(iTime) - rz * sin(iTime);\n    ray.z = rz * cos(iTime) + rx * sin(iTime);*/\n    ray /= length(ray);\n    vec3 rayOrigin = vec3(0, sin(0.0), 0);\n    \n    float t = dot(sphereCenter - rayOrigin, ray);\n    vec3 p = rayOrigin + ray * t;\n    \n    float y = length(sphereCenter - p);\n    float x = sqrt(radius * radius - y * y);\n    float absorption = 0.0;\n    vec3 colorGained = vec3(0); \n    if(y < radius){\n        float t1 = t-x;\n        float t2 = t+x;\n        float distanceTravelled = abs(t1 - t2);\n        absorption = 1.0 - exp(-distanceTravelled * 1.0);\n        float stepSize = 0.01;\n        \n        float dist = 0.0;\n        float prevWaveFunction = 0.0;\n        for(int i = 1; float(i) < distanceTravelled / stepSize; i++){\n            vec3 pos = rayOrigin + ray * t1 + ray * stepSize * float(i);\n            vec3 prevPos = rayOrigin + ray * t1 + ray * stepSize * float(i - 1);\n            vec3 toCenter = normalize(pos - sphereCenter);\n            float theta = acos(dot(vec3(0, 1, 0), toCenter));\n            float phi = atan(toCenter.x, toCenter.z);\n            float multiplier = 1.0;\n            float totalWeight = weights[location(N, L, M)];\n            if(totalWeight > 0.001)\n                multiplier = 1.0 / totalWeight;\n            \n            float signedWaveFunction = waveFunction(N, L, M, length(pos - sphereCenter) \n                / 5.0, theta, 0.0);\n            float waveFunction = pow(signedWaveFunction, 2.0) * multiplier * 7500.0;\n                \n            float avr = (waveFunction + prevWaveFunction) / 2.0;\n            dist += avr * stepSize;\n            prevWaveFunction = waveFunction;\n            \n            float hue = (cos(float(M) * (phi + iTime)) + 1.0) / 2.0;\n            \n            vec2 harmonics = sphericalHarmonics(L, M, theta);\n            float colorMultiplier = 1.0;\n            if(harmonics.x < 0.0)\n                colorMultiplier *= -1.0;\n            if(signedWaveFunction < 0.0)\n                colorMultiplier *= -1.0;\n            //colorGained += HSVtoRGB(vec3(hue, 1.0, avr * stepSize));\n            colorGained += vec3(max(0.0, colorMultiplier), 0, max(0.0, -colorMultiplier)) * 0.005;\n        }\n        absorption = 1.0 - exp(-dist / 10.0);\n        \n    } else {\n        \n    }\n    col = mix(col * 0.5, colorGained, absorption);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}