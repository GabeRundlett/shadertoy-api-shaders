{
    "Shader": {
        "info": {
            "date": "1693070828",
            "description": "Tried to make something similiar to this image of the milky way: https://solarsystem.nasa.gov/internal_resources/125/ . Based on previous shader I made, but now im using a logarithmic spiral + some other new stuff.",
            "flags": 0,
            "hasliked": 0,
            "id": "mtsBzH",
            "likes": 16,
            "name": "Single spiral galaxy 2",
            "published": 3,
            "tags": [
                "spiral",
                "space",
                "galaxy",
                "milkyway",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "Mermersk",
            "viewed": 1596
        },
        "renderpass": [
            {
                "code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n#define PI 3.1415926\n#define PI2 6.283186\n#define e 2.71828\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat noise1d(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\t\n\treturn mix(hashwithoutsine11(i), hashwithoutsine11(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,711.7)),\n              dot(st,vec2(619.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*23758.545123);\n}\n\nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    //vec2 u = smoothstep(0.0, 1.0, f);//f*f*(3.0-2.0*f);\n    // Quintic interpolation curve\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 rotZ(vec3 p, float angle) {\n\t\n\tmat3 m = mat3(cos(angle), -sin(angle), 0.0,\n\t\t\t\t  sin(angle), cos(angle), 0.0,\n\t\t\t\t  0.0, 0.0, 1.0);\n\t\t\t\t  \n\treturn m * p;\n}\n\n\n/*\nFractal brownian motion\nIs about adding noise together. From book of shaders:\nBy adding different iterations of noise (octaves), where we successively \nincrement the frequencies in regular steps (lacunarity) and decrease the amplitude (gain) \nof the noise we can obtain a finer granularity in the noise and get more fine detail. \nThis technique is called \"fractal Brownian Motion\" (fBM), or simply \"fractal noise\".\n\nFor each octave(iteration): Increase the frequency of the wave(by 2.0) -> Called the lacunarity value.\n\t\t\t\t\t\t\tDecrease the amplitude of the wave(by 0.5) -> Called the gain.\n*/\nfloat fbm(vec2 uv, float seed, int o, float l, float g, float a, float f, bool rot, bool absolute) {\n\tfloat fbm = 0.0;\n\t\n\t//Constant value, octaves is the number of iterations.\n\tint octaves = o;//16;\n\tfloat lacunarity = l;//8.0;\n\tfloat gain = g;//0.85;\n\t\n\t//Initial values, are changed on each ocatve/iteration.\n\tfloat amplitude = a;//0.5;\n\tfloat frequency = f;//10.0;\n    \n    uv += seed;\n\t\n\tfor (int i = 0; i < octaves; i++) {\n        float newVal = amplitude * noise(uv * frequency);\n        \n        if (absolute) newVal = abs(newVal);\n        \n\t\tfbm += newVal;\n\n        if (rot) uv = rotZ(vec3(uv.x, uv.y, 0.0), float(i)).xy;\n        \n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t\n\t}\n\t\n\treturn fbm;\n}\n\n\nfloat logarithmicSpiral(vec2 polarUV, float a, float b) {\n    float len = polarUV.x;\n    float angle = polarUV.y;\n    \n    /*\n        logSpiralAngle is the angle it must be given the length of the vector. It is the logaritmhic spiral formula used above, but rearranged/isolated for the value of angle.\n        Output can go from 0 to infinity. So if we draw a line from origin, then until it crosses the spiral for the 1 time, the anglue value will be\n        somewhere between 0 and 2PI. As soon as the line crosses the spiral the first time, then the angle value must be between 2PI and 4PI.\n        Fromt his value we can know in what revolution it is currently in, 1 rev: 0 to 2PI, 2 rev: 2PI to 4PI.\n        Dividing by 2PI and flooring gives us a neat revolution counter -> 0.0: 1 rev, 1.0: 2 rev...\n    */\n    //float a = 0.59;\n    //float b = 0.25;\n    float logSpiralAngle = log(len/a)/b;\n    //Working solution for infinete revolutions - Without a for loop!\n    float intersectMain = a * pow(e, b * (angle + (PI2*floor(logSpiralAngle/PI2))));\n    //Intersect next revolution\n    float intersectNextRev = a * pow(e, b * (angle + (PI2*floor(logSpiralAngle/PI2+1.0))));\n    float intersectPreviousRev = a * pow(e, b * (angle + (PI2*floor(logSpiralAngle/PI2-1.0))));\n  \n    float fr = min(abs(len-intersectMain), abs(len-intersectNextRev));//min(len - r, len - r2);\n    fr = min(fr, abs(len - intersectPreviousRev));\n    \n    //float d = abs(fr - (maxxi*0.5));//mod(fr, r);\n    float d = fr;\n    \n    return d;\n}\n//Vesica sdf from IQ: https://iquilezles.org/articles/distfunctions2d/\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w )\n{\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n}\n\nvec3 galaxy(vec2 uv, vec2 polarUV, vec3 col) {\n    \n    float size = 5.0;\n    float len = polarUV.x*size;\n    float angle = polarUV.y;\n    \n    //SpiralAngle from 0 to infinty\n    //float spiralAngle = angle + (PI2 * floor(len/PI2));\n    float spiralAngle = angle + (PI2 * len/PI2);\n    \n    /* Create different spirals and cut them off at some length */\n    //1. spiral\n    float spiralD = logarithmicSpiral(vec2(len, angle), 0.59, 0.25);\n    spiralD += len * smoothstep(5.5, 8.3, len);\n    //2. spiral\n    float spiralD2 = logarithmicSpiral(vec2(len, angle), 0.41, 0.26);\n    float logSpiralD2Angle = log(len/0.41)/0.26;\n    //Cut of spiral arm at x length\n    spiralD2 += len * smoothstep(5.6, 8.1, len);\n    //3. spiral\n    float spiralD3 = logarithmicSpiral(vec2(len, atan(uv.y, uv.x)), 0.59, 0.25);\n    spiralD3 += len * smoothstep(5.5, 8.0, len);\n    //4. spiral\n    float spiralD4 = logarithmicSpiral(vec2(len, atan(uv.y, uv.x)), 0.41, 0.25);\n    spiralD4 += len * smoothstep(5.0, 7.5, len);\n    \n    //Combine all spirals to single SDF\n    spiralD = min(spiralD, min(spiralD2, min(spiralD3, spiralD4)));\n    \n    //Haze spiralD, make them radius bigger than the spiral with the stars\n    float hazeSpiralD = spiralD;\n    float hazeSpiralArmRadius = 1.4;\n    hazeSpiralD = 1.0-smoothstep(0.0, hazeSpiralArmRadius, hazeSpiralD); \n    \n    //Control distance between each spiral arm, need more blackess between\n    float spiralArmRadius = 0.65;\n    spiralD = 1.0-smoothstep(0.0, spiralArmRadius, spiralD);\n     \n    float starN = fbm(uv, 244.0, 8, 2.0, 0.5, 0.68, 2.7, true, true);\n    float starN2 = fbm(uv, 69.0, 8, 1.6, 0.85, 0.5, 13.0, true, true); \n    float innerBandN = fbm(uv, 539.0, 6, 1.4, 0.85, 0.55, 17.0, true, true);\n    \n    innerBandN = innerBandN * innerBandN * innerBandN;\n    starN = starN * starN * starN * starN;\n    starN2 = starN2 * starN2 * starN2;\n       \n    //galaxyColor is color of the stars in this area\n    float galaxyColorInput = len*0.1 + 499.2 + noise1d(angle*1.0+55.0);\n    vec3 galaxyCol =  hash31(ceil(galaxyColorInput));\n    vec3 nextGalaxyCol = hash31(ceil(galaxyColorInput + 1.0));\n    \n    galaxyCol = mix(galaxyCol, nextGalaxyCol, smoothstep(0.5, 1.0, fract(galaxyColorInput)));\n    \n    galaxyCol *= vec3(1.0, 0.4, 1.74);\n    \n    vec3 starCol = mix(vec3(0.0), galaxyCol, 1.0-exp(starN*50.0));\n    \n    vec3 starCol2 = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), 1.0-exp(starN2*10.0));\n    \n    vec3 combinedStarCol = max(starCol/starCol2, 0.0);\n    \n    //Add main starfield\n    vec3 finalCol = mix(vec3(0.0), combinedStarCol, spiralD);\n    \n    //Background haze color\n    vec3 bgHazeCol = vec3(59.0/255.0, 69.0/255.0, 101.0/255.0);\n    \n    //Add the hazy outline of spirals\n    finalCol += mix(vec3(0.0), bgHazeCol*vec3(1.1, 1.0, 2.0), smoothstep(1.7, 0.33, length(uv)))*0.1;\n    finalCol += mix(vec3(0.0), bgHazeCol*vec3(1.0, 1.2, 1.75), hazeSpiralD*hazeSpiralD*0.12);\n    \n    float vesicaD = sdOrientedVesica(uv, vec2(0.085, -0.085), vec2(-0.085, 0.085), 0.025);\n    \n    vec3 centerCol = vec3(387.0/255.0,252.0/255.0,197.0/255.0);\n    vec3 galaxyCenterCol = 1.0/max(vesicaD, 0.0)*0.005 * (mix(galaxyCol, centerCol, 0.3)*1.0);\n    \n    galaxyCenterCol *= smoothstep(2.0, 0.0, length(uv)); \n    //Add glowing vesica in the middle\n    finalCol += galaxyCenterCol;\n    \n    \n    vec3 backgroundCol = vec3(0.0, 0.0, 0.0);\n    vec3 redCol = vec3(1.5, 0.0, 0.0);\n    vec3 whiteCol = vec3(1.0, 1.0, 1.0)*2.0;\n    //Narrow band of stars located mostly at origin of spiral arms\n    vec3 narrowStarsCol = mix(backgroundCol, redCol, smoothstep(0.1, 0.2, innerBandN));\n    narrowStarsCol = mix(narrowStarsCol, whiteCol, smoothstep(0.2, 0.25, innerBandN));\n    //Add narrow band of stars\n    finalCol += narrowStarsCol * smoothstep(0.7, 0.9, spiralD);\n    \n    return finalCol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv * 2.0) - 1.0;\n    \n    vec3 col = vec3(0.0);\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x *= ar;\n    \n    uv = rotZ(vec3(uv.x, uv.y, 0.0), -iTime*0.018).xy;\n    \n    uv *= 1.3;\n    \n    vec2 polarUV = vec2(length(uv), atan(uv.y, uv.x)+PI);\n    \n    col = galaxy(uv, polarUV, col);\n    \n    //Saturation\n    float grayscale = dot(min(col, 1.0), vec3(0.299, 0.587, 0.114));\n    float saturation = 0.77;\n    col = clamp(mix(vec3(grayscale), col, saturation), 0.0, 1.0);\n    \n    //gamma correction\n    col = pow(col, vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}