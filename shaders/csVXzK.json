{
    "Shader": {
        "info": {
            "date": "1681325362",
            "description": "Compo entry to 4k Executable Graphics at Revision 2023, placed 5th. Converted to WebGL 2 and use to Shadertoy uniforms.",
            "flags": 32,
            "hasliked": 0,
            "id": "csVXzK",
            "likes": 38,
            "name": "Knits & Sips",
            "published": 3,
            "tags": [
                "4k",
                "teapot",
                "revision",
                "executablegraphics"
            ],
            "usePreview": 1,
            "username": "Bercon",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "// Copyright Jerry Ylilammi\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvec3 D(vec3 p) { // By David Hoskins, MIT License https://www.shadertoy.com/view/4djSRW\n\tp = fract(p * vec3(.1031, .1030, .0973));\n  p += dot(p, p.yxz + 33.33);\n  return fract((p.xxy + p.yxx) * p.zyx) * 2. - 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n  fragColor = vec4(fragColor.xyz / (fragColor.xyz + .1667) * 1.25 + D(fragCoord.xxy) * .002, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copyright Jerry Ylilammi\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//////////////////// RANDOM ////////////////////\n\nvec3 D(vec3 p) { // By David Hoskins, MIT License https://www.shadertoy.com/view/4djSRW\n\tp = fract(p * vec3(.1031, .1030, .0973));\n  p += dot(p, p.yxz + 33.33);\n  return fract((p.xxy + p.yxx) * p.zyx) * 2. - 1.;\n}\n\n// Globals\nfloat time;\nfloat curDist;\nfloat inside = 1.;\nfloat PI = acos(-1.);\nfloat tmp;\nvec4 material;\nvec3 rand;\n\nvec3 cosineSampleHemisphere(vec3 n){\n  float r = sqrt(rand.x);\n  float theta = 2. * PI * rand.y;\n  vec3 B = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n  return normalize(r * sin(theta) * B + sqrt(1.0 - rand.x) * n + r * cos(theta) * cross( B, n ));\n}\n\n//////////////////// MATH ////////////////////\n\nvec3 qRotate(vec3 p, vec4 q) {\n  return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\n//////////////////// TEXTURE ////////////////////\n\nfloat noise(vec3 p) { // Simplex 3D noise\n  vec3 s = floor(p + (p.x + p.y + p.z) / 3.);\n  vec3 x = p - s + (s.x + s.y + s.z) / 6.;\n  vec3 i = step(x.yzx, x);\n\tvec3 i1 = i * (1. - i.zxy);\n  vec3 i2 = 1. - i.zxy * (1. - i);\n\tvec3 x1 = x - i1 + 1. / 6.;\n\tvec3 x2 = x - i2 + 1. / 3.;\n\tvec3 x3 = x - .5;\n\tvec4 w = max(\n    .6 - vec4(\n      dot(x, x),\n      dot(x1, x1),\n      dot(x2, x2),\n      dot(x3, x3)\n    ),\n    0.\n  );\n\treturn .5 + 18. * dot(\n    vec4(\n      dot(D(s), x),\n      dot(D(s + i1), x1),\n      dot(D(s + i2), x2),\n      dot(D(s + 1.), x3)\n    ),\n    w * w * w * w\n  );\n}\n\n//////////////////// BEZIER ////////////////////\n\n// By iq, MIT License: https://www.shadertoy.com/view/ldj3Wh\nvec2 fBezier(vec3 pos, vec3 A, vec3 B, vec3 C) {\n  vec3 a = B - A;\n  vec3 b = A - 2. * B + C;\n  vec3 c = a * 2.;\n  vec3 d = A - pos;\n  vec3 t;\n\n  float kk = 1. / dot(b, b);\n  float kx = kk * dot(a, b);\n  float ky = kk * (2. * dot(a, a) + dot(d, b)) / 3.;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kk * dot(d, a);\n  float h = q * q + 4.0 * p3;\n\n  if(h >= 0.0) {\n    h = sqrt(h);\n    p3 /= q;\n    vec2 x = abs(p) < 0.001 ? vec2(p3, -p3 - q) :  (vec2(h, -h) - q) * .5;\n    x = sign(x) * pow(abs(x), vec2(1./3.));\n    kk = clamp(x.x + x.y - kx, 0.0, 1.);\n    t = d + (c + b * kk) * kk;\n    return vec2(sqrt(dot(t, t)), kk);\n  }\n  float z = sqrt(-p);\n  float v = acos(q / (p * z * 2.)) / 3.;\n  float m = cos(v);\n  float n = sin(v) * 1.732050808;\n  a = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0., 1.);\n  t = d + (c + b * a.x) * a.x;\n  kx = dot(t, t);\n  t = d + (c + b * a.y) * a.y;\n  ky = dot(t, t);\n  if( ky < kx )\n    return vec2(sqrt(ky), a.y );\n\n  return vec2(sqrt(kx), a.x);\n}\n\nfloat fBezier4(vec3 p, vec3 A, vec3 AB, vec3 BC, vec3 C) {\n  vec3 B = (AB + BC) * .5;\n  return min(fBezier(p, A, AB, B), fBezier(p, B, BC, C)).x;\n}\n\n//////////////////// PRIMITIVES ////////////////////\n\nfloat fEllipsoid( vec3 p, vec3 r ) {\n  return (tmp = length(p/r)) < 1. ? (tmp - 1.) * min(min(r.x, r.y), r.z) : tmp * (tmp - 1.) / length( p / (r * r));\n}\n\nfloat fCylinder(vec3 p, float r, float h) {\n  p.xy = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(p.x,p.y),0.0) + length(max(p.xy,0.0));\n}\n\nfloat fCircle(vec3 p, float r) {\n\treturn length(vec2(p.z, length(p.xy) - r));\n}\n\n//////////////////// OPERATIONS ////////////////////\n\nfloat unionSmooth(float d1, float d2, float k) {\n  return mix( d2, d1, (tmp = clamp( .5 + .5*(d2-d1)/k, .0, 1. )) ) - k * tmp * (1. - tmp);\n}\n\nfloat diffSmooth(float d2, float d1, float k) {\n  return mix( d2, -d1, (tmp = clamp( .5 - .5*(d2+d1)/k, .0, 1. )) ) + k * tmp * (1. - tmp);\n}\n\nvoid closest(float f, vec4 m) {\n  if (curDist > f) {\n    curDist = f;\n    material = m;\n  }\n}\n\n//////////////////// OBJECTS ////////////////////\n\nvoid fNeedle(vec3 p) {\n  vec2 c = vec2(sin(.12), cos(.12));\n  vec2 q = vec2( length(p.xy), -(p.z - 1.2) );\n  closest(max(\n    fCylinder(p, .03, 1.2),\n    length(q - c * max(dot(q, c), 0.0)) * sign(q.x * c.y - q.y * c.x)\n  ) - .0105, vec4(p, 0));\n}\n\nvoid fCup(vec3 p) {\n  if ((tmp = length(p) - .9) > .2) { closest(tmp, vec4(0)); return; }\n  p /= 1.3;\n  closest(\n    unionSmooth(\n      diffSmooth(\n        unionSmooth(\n          fBezier(vec3(length(p.xy), 0, p.z), vec3(.4, 0, .4), vec3(.4, 0, 0), vec3(0)).x - 0.015,\n          fCircle(p - vec3(0,0,.01), .2) - .03,\n          .025\n        ),\n        length(vec3(abs(p.xy) - vec2(.141, .141), p.z + .02)) - .03,\n        0.03),\n      fBezier4(p - clamp( p, -.02,.02), vec3(.4, 0, .34), vec3(.56, 0, .41), vec3(0.54, 0, .13), vec3(0.3, 0, .1))  - .025,\n      .03\n    ) * 1.3,\n    vec4(5)\n  );\n}\n\nvoid fPlate(vec3 p) {\n  if ((tmp = length(p) - .8) > .2) { closest(tmp, vec4(0)); return; }\n  p /= 1.3;\n  closest(\n    unionSmooth(\n      fBezier(vec3(length(p.xy), 0, p.z), vec3(.6, 0, .12), vec3(.39, 0,  -0.01), vec3(0)).x - 0.0125,\n      fCircle(p - vec3(0,0,.01), .25) - .03,\n      .02\n    ) * 1.3,\n    vec4(5)\n  );\n}\n\nvoid fSpoon(vec3 p) {\n  if ((tmp = length(p - vec3(.8,0,0)) - 1.) > .2) { closest(tmp, vec4(0)); return; }\n  float e = fEllipsoid(p, vec3(.45, .3, .3));\n  vec2 b = fBezier(p, vec3(.33, 0, -.305), vec3(.36, 0, .08), vec3(1.6, 0, .26));\n  vec2 b2 = fBezier(p, vec3(.456, 0, -0.53) , vec3(.5, 0, -.09), vec3(1.8, 0, .08));\n  closest(\n    diffSmooth(\n      diffSmooth(\n        unionSmooth(\n          diffSmooth(\n            abs(e) - .012,\n            -fEllipsoid(p + vec3(0,0,.4), vec3(.45, .3, .3)),\n            .01),\n          diffSmooth(\n            b.x - .09 + (1. - b.y * b.y) * .05,\n            b2.x - .25,\n            .01),\n          .05),\n        e + .012,\n        .005),\n      -min(e - .012, -p.z - .18),\n      .01),\n    vec4(6)\n  );\n}\n\nvoid fLid(vec3 p) {\n  if ((tmp = length(p) - .8) > .2) { closest(tmp, vec4(0)); return; }\n  closest(\n    unionSmooth(\n      unionSmooth(\n        fBezier(vec3(length(p.xy), 0, p.z), vec3(.49, .0, 0), vec3(.25, .0,  .21), vec3(0, 0, .2)).x - 0.015,\n        length(p - vec3(0,0,.32)) - .1,\n        .07\n      ),\n      fCircle(p - vec3(0,0,-.03), .43) - .04,\n      0.03\n    ),\n    vec4(p, 4)\n  );\n}\n\nvoid fTeapot(vec3 p) {\n  // Body\n  float ellipsoid = diffSmooth(\n    fEllipsoid(p + vec3(0,0,.1), vec3(1, 1, .8)), // Body\n    p.z + .8, // Slice bottom\n    .2);\n\n  if (ellipsoid > .9)\n    closest(ellipsoid - .7, vec4(0));\n  else {\n    // Spout\n    vec3 sp = qRotate(p + vec3(.7,0,.1), vec4(0, 0.342, 0, 0.939));\n    float spout = diffSmooth(\n      fBezier4(vec3(length(sp.xy), 0.0001, sp.z),\n        vec3(.3, .0, 0),\n        vec3(.4, .0, .1),\n        vec3(.0, .0, .9),\n        vec3(.09, .0, 1.2)\n      ) - 0.035,\n      dot(sp - vec3(0,0,1.1), normalize(vec3(-.5, 0, -.8))),\n      0.035);\n\n    // Handle\n    vec2 seg1 = fBezier(p, vec3(1.1, 0, .65), vec3(.9, 0, .65), vec3(.77, 0, .43));\n    float handle = seg1.x - seg1.y * seg1.y * .03;\n    seg1 = fBezier(p, vec3(1.1, 0, .65), vec3(1.36, 0, .65), vec3(1.4, 0, .3));\n    handle = min(handle, seg1.x);\n    seg1 = fBezier(p, vec3(1.4, 0, .3), vec3(1.46, 0, -.2), vec3(.77, 0, -.4));\n    handle = min(handle, seg1.x - seg1.y * seg1.y * .04);\n    handle = unionSmooth(handle - .085, length(p - vec3(1.17,0,.71)) - .055, .06); // Handle bump\n\n    float body =\n      unionSmooth(\n        diffSmooth(\n          unionSmooth(\n            ellipsoid, // Body\n            fCylinder(p - vec3(0, 0, .68), .55, .015) - .05, // Top lip\n          .1),\n          fCylinder(p - vec3(0, 0, .68), .5, .3), .03), // Drill top hole,\n        fCylinder(p + vec3(0, 0, .7), .55, .015) - .05,  // Bottom foot\n      .2);\n\n    float res = max(unionSmooth(unionSmooth(body, handle, .1), spout, .1), -(ellipsoid + .06)); // Hollow out\n\n    if (res < .05) // Only evaluate noise if close enough that it would matter\n      res += noise(p * 10.) * .002; // Noise\n\n    closest(res, vec4(p + vec3(0, 0, .1), handle < min(spout, body) ? 2 : 3));\n  }\n}\n\nvoid fKnitting(vec3 p) {\n  p.x += noise(p * 4.) * .05;\n  p.y += noise(p * 4. + vec3(10)) * .05;\n\n  p.z += sin(p.y * 8. + p.x * 4.) * .03;\n  p.z -= 1. - cos(clamp(p.x * .3, -1., 1.));\n  p.z -= 1. - cos(clamp(p.y * (.45 + .05 * time), -2., 2.));\n\n  for (float i = 0.; i < 4.; i++) {\n    float phase = floor(i * .5 + .1);\n    vec3 q = p * 15. + vec3(mod(i,2.),phase,0);\n    vec2 c = vec2(1, 2) * clamp(floor(q.xy / vec2(1, 2) + .5), -vec2(19,26), vec2(20, 27));\n    q.xy = q.xy - c;\n    q.x *= mod(c.x, 2.) * 2. - 1.;\n    if (i == 0.) { // If we are far away, just approximate distance with sphere and skip 8x bezier curve\n      if ((tmp = length(q) - 2.) > 1.) {\n        closest(tmp * .066, vec4(0)); // 1. / 15. * .9 == 0.06\n        break;\n      }\n    }\n    c.x =\n      fBezier4(q, vec3(.5, .4, 0), vec3(-.2, .4, 0), vec3(-.3, -.2, .5), vec3(0, -.5, .5)) - .3 + .1 * noise(q * vec3(12,2,12));\n    closest(c.x * .06, vec4(c.x, abs((c.y * 2. - i - phase) * (1. - phase * 2.)) + 150., 0, 1)); // 1. / 15. * .9 == 0.06 Safety factor to account for space deformation\n    p *= vec3(1, -1, 1);\n  }\n}\n\n//////////////////// TRACING ////////////////////\n\n\nvoid field(vec3 p) {\n  curDist = 100.;\n\n  fTeapot(qRotate(p - vec3(-1.4, 0.34, 0.67), vec4(-0.195, 0.106, -0.975, -.0045)));\n  fLid(qRotate(p - mix(vec3(-0.77, -.013, 1.9), vec3(-.81, -.013, 1.85), time), vec4(-0.266, -0.103, -0.307, 0.908)));\n  fKnitting(qRotate(p - vec3(1.3, -.27, -0.87), vec4(-.00432, 0.108, 0.632, 0.767)));\n  fNeedle(qRotate(p - vec3(0.082, 0.3, -0.11), mix(vec4(0.777, -0.15, -0.17, -0.587), vec4(0.745, -0.148, -0.261, -0.596), time)));\n  fNeedle(qRotate(p - vec3(0.92, -0.61, -0.5), vec4(0.632, -0.457, -0.616, -0.109)));\n  if (p.x > 0.) {\n    float teaThickness =\n      .05\n      + sin(p.x * 15. + time * 1.5) * .01\n      + cos(p.y * 15. + time * 1.5) * .01;\n    closest(fBezier(p, vec3(.16, 0.25, .78), vec3(1.1, .1, 1.4), vec3(2.2, -.1, .2)).x - teaThickness, vec4(7));\n    closest(fBezier(p, vec3(2.5, -.3, .4), vec3(2.7, -.8, 2), mix(vec3(1.3, -.3, 1.7), vec3(1.4, -.3, 1.8), time)).x - teaThickness, vec4(7));\n\n    fCup(qRotate(p - vec3(2.6, -0.18, 0.25), vec4(-0.119, 0.301, 0.325, 0.889)));\n    fPlate(qRotate(p - vec3(2.7, -0.17, -0.08), mix(vec4(-0.106, 0.156, 0.497, 0.847), vec4(-0.0788, 0.125, 0.486, 0.861), time)));\n    fSpoon(qRotate(p - mix(vec3(3.2, -0.71, 0.84), vec3(3.3, -0.75, 0.87), time), mix(vec4(-0.415, 0.0586, 0.904, 0.0811), vec4(-0.408, 0.0718, 0.909, 0.0511), time)));\n  } else {\n    fCup(qRotate(p - mix(vec3(-1.9, -1.6, .18), vec3(-2, -1.6, .22), time), vec4(-0.0414, -0.164, 0.314, 0.934)));\n    fPlate(qRotate(p - mix(vec3(-1.9, -1.5, -.18), vec3(-1.9, -1.5, -0.14), time), vec4(0.12, -0.168, -0.206, 0.956)));\n    fSpoon(qRotate(p - mix(vec3(-.86, -0.92, -0.27), vec3(-.91, -0.92, -.24), time), vec4(-0.05, -0.109, 0.983, -0.137)));\n  }\n}\n\n// Compiles fast and works with WebGL 1\nvec3 calcNormal(vec3 p) {\n  vec4 e = vec4(0.0005, 0, 0, 0);\n  vec4 v;\n  for(int i=0; i<4; i++) {\n    field(p + e.xyz);\n    v.x = curDist;\n    e = e.wxyz;\n    v = v.wxyz;\n  }\n  return normalize(v.xwz - v.y);\n}\n\n//////////////////// SHADING ////////////////////\n\nfloat flowers(vec4 mat, float a, float b) {\n  b = atan(sqrt(mat.x * mat.x + mat.y * mat.y), mat.z) / PI * b  + .6;\n  vec2 uv = .5 - fract(abs(vec2(atan(mat.y, mat.x) / PI * a, b) + vec2(floor(mod(b, 2.)), .0) * .5));\n  a = mod(atan(uv.y, uv.x) + PI * .2, PI * .4) - PI * .2;\n  uv = vec2(cos(a), sin(a)) * length(uv);\n  uv.x -= noise(mat.xyz * 10.) * .08;\n  return min(\n    length(uv) - .05,\n    diffSmooth(\n      length(uv - vec2(.28,0)) - .13,\n      fEllipsoid(vec3(uv - vec2(.3,0), 0) + vec3(.1,0,0), vec3(.1, .025, 1)),\n      0.05\n    )\n  );\n}\n\n//////////////////// MAIN ////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n  rand = D(vec3(fragCoord.xy, fragColor.w));\n  time = fract(rand.z * 1000.); // Motion blur\n  vec2 np = (gl_FragCoord.xy + rand.xy * 0.5) / iResolution.xy * 2. - 1.;\n  np.y *= iResolution.y/iResolution.x;\n  rand = abs(D(rand*2.));\n  \n  ////////// CAMERA \n  \n  // Used in entry\n  //vec3 origin = vec3(-0.3990, -3.0709, 0.5419);\n  \n  // Add to support camera movement  \n  vec4 mouse = iMouse;\n  if (mouse.z > 1.) fragColor = vec4(0);\n  if (mouse.x < 1. && mouse.y < 1.) mouse = vec4(iResolution.xy * .5, 0, 0); // Default mouse to center\n  vec3 X = vec3(-1.7 + (.5 - mouse.x / iResolution.x) * 2. * PI, 1.525 + (mouse.y / iResolution.y - .5) * PI, 3.1);  \n  vec3 origin = vec3(sin(X.y) * cos(X.x), sin(X.y) * sin(X.x), cos(X.y)) * X.z + vec3(0,0,.4);\n  // End of addition  \n  \n  \n  vec3 fw = normalize(vec3(0,0,.4) - origin);\n  vec3 rt = normalize(cross(fw, normalize(vec3(0,0,1))));\n  mat3 transform = mat3(rt, fw, cross(rt, fw));\n  float len = length(np);\n  vec3 dir = normalize(transform * vec3(np / len * sin(len), cos(len)).xzy);\n  vec3 color = vec3(1);\n  vec3 result = vec3(0);\n\n  fw = origin + dir * 3.; // Focus distance\n  origin += transform * vec3(rand.x, 0, rand.y) * .05; // Depth of field\n  dir = normalize(fw - origin);\n\n  for (int i = 0; i < 4; i++) { // Bounces\n    float dist = .001;\n    for (int i = 0; i <150; i++) { // Shadows i from surrounding loop, but we don't care\n      field(origin + dir * dist);\n      curDist *= inside;\n      dist += max(curDist, 0.0005);\n      if (curDist < 0.0001 || dist > 9.) break;\n    }\n\n    if (dist > 0.0 && dist < 9.) {\n      rand = abs(D(rand*2.));\n      vec3 pos = origin + dir * dist;\n      vec3 normal = calcNormal(pos);\n      vec3 diffuse = vec3(.56);\n      float eta = 1.08 - 0.42 * inside;\n      float spots = 0.;\n      float fresnel = 0.;\n      float blue = 0.;\n\n      if (material.w == 3. && length(material.xy) > .52) { // body + spout\n        if (flowers(material, 7.5, 10.) > .0) blue = 1.;\n        if (material.z > .64) blue = 1.; // Near rim solid blue\n        if (material.z < -.63) blue = 0.; // White bottom\n        if (length(material.xyz) > 1.17) blue = 1.; // Tip of spout solid blue\n        else if (material.z > .69 ) spots = 1.;\n      } else if (material.w == 4.) { // lid\n        if (flowers(material - vec4(0,0,-.25,0), 2.5, 4.) > 0.) blue = 1.;\n        if (material.z > .205) spots = 1.;\n        if (material.z < -.01) blue = 0.;\n      } else if (material.w == 2.)  // handle\n        spots = dot(normal, normalize(pos-vec3(-2.3, .2, 1.4)));\n      else if (material.w == 0.) { // needle\n        float n = noise(material.xyz * vec3(150,150,2));\n        diffuse = mix(vec3(0.97, 0.8, 0.7), vec3(.72, .49, .28), n * n) * .6;\n      } else if (material.w == 1.) // knitting\n        diffuse = mix(\n          vec3(1, .2, 0),\n          vec3(1,0.718,0.012),\n          fract(material.y * PI)\n        ) * .4;\n\n      if (material.w > 1.) { // Not needle, knitting\n        float cosThetaI = abs(dot(dir, normal));\n        float sinThetaTSq = eta * eta * (1.0 - cosThetaI * cosThetaI);\n        if (sinThetaTSq > 1.0) fresnel = 1.0; // Total internal reflection\n        else {\n          float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));\n          float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);\n          float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n          fresnel = mix(0.04, 1.0, (rs * rs + rp * rp) * .5);\n        }\n      }\n\n      if (rand.z < fresnel || material.w == 6.) { // Reflect / clear coat or spoon\n        dir = reflect(dir, normal);\n        if (material.w < 5.) // Blurry teapot + lid\n          dir = normalize(dir + cosineSampleHemisphere(normal) * .06);\n      } else if (material.w == 7.) { // Refract\n        if (inside < 0.)\n          color *= exp(-(1. - vec3(1., .4, .2)) * dist * 35.); // Absorption\n        dir = refract(dir, normal * inside, eta);\n        inside *= -1.;\n      } else {\n        if (spots > 0.) {\n          vec3 a = material.xyz  * 20.;\n          vec3 fp = floor(a);\n          blue = 1. - smoothstep(.3, .1, length(.5 - (a - fp) - D(fp) * .3));\n        }\n        color *= mix(diffuse, vec3(.035, .1, .314), blue);\n        dir = cosineSampleHemisphere(normal);\n      }\n\n      origin = pos + normal * 0.005 * inside;\n\n    } else {\n      float coord = atan(dir.y, dir.x);\n      float f = (1. + dir.z) * .5 + .1;\n      if (abs(dir.z) < .6 && coord > -1. && coord < .2)\n        result = color * 2.5; // Fill Right side\n      else if (abs(dir.z) < .6 && coord < -2.2)\n        result = color * 6.5; // Primary\n      else {\n        dir = qRotate(dir, normalize(vec4(0, 0,  -0.14, 0.99 + time *.3)));\n        result = color\n          * f * f * f * (.5 + .5 * dir.y)\n          * (sin(atan(dir.z, dir.x) * 12.) < 0. ? vec3(.3,.27,.24) : vec3(.19,.22,.24));\n      }\n\n      break;\n    }\n  }\n\n  fragColor = vec4(\n    mix(fragColor.rgb, result, 1. / (fragColor.w + 1.)),\n    fragColor.w + 1.\n  );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}