{
    "Shader": {
        "info": {
            "date": "1589934107",
            "description": "Can be used to render any implicit surface!\nWASD to move",
            "flags": 48,
            "hasliked": 0,
            "id": "3d2BDz",
            "likes": 22,
            "name": "Stochastic ray marching ",
            "published": 3,
            "tags": [
                "random",
                "marching"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 710
        },
        "renderpass": [
            {
                "code": "//Shading \n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 HDRmapping(vec3 color, float exposure)\n{\n\t// Exposure tone mapping\n    vec3 mapped = ACESFilm(color * exposure);\n    // Gamma correction \n    return pow(mapped, vec3(1.0 / 2.2));\n}\n\nfloat cos_step(float x, float a, float b)\n{\n    x = clamp((x-a)/(b-a), 0., 1.);\n    return 0.5-0.5*cos(PI*x);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    INIT\n    \n    ivec2 pi = ivec2(pos);\n    vec2 uv = (pos - R*0.5)/max(R.x,R.y);\n    \n    vec2 angles = get(ANGLE).xy;\n \tvec3 r = getRay(angles, uv);\n    vec3 p = get(POS).xyz;\n    \n    vec4 B = texel(ch1, pi);\n    float td = B.x;\n\n    p += r*td;\n    float DE = map(p);\n   \n    col.xyz = vec3(0.);\n    \n    \n    #define rescale 0.7\n    \n    if(DE > 5.*td*LOD) //sky\n    {\n        col.xyz = sky(r);\n    }\n    else\n    {\n        \n        vec4 n = normal(p, 2.*td*LOD);\n    \tmat a = mat(color(p), vec3(0), 0.5,0.);\n        \n        vec3 ld = light_d;\n        col.xyz += 10.*cos_step(B.z, -0.00, 0.02)*BRDF(-r, ld, n.xyz, a);\n        //fake GI\n        ld = normalize(mix(ld, n.xyz, 0.5));\n        col.xyz += 0.7*cos_step(B.z, -0.1*rescale, 0.1)*BRDF(-r, ld, n.xyz, a);\n        col.xyz += 0.3*cos_step(B.z, -0.2*rescale, 0.2)*BRDF(-r, ld, n.xyz, a);\n        col.xyz += 0.35*cos_step(B.z, -0.8, 0.8)*BRDF(-r, ld, n.xyz, a);\n\n      \n        col.xyz *= sky(vec3(1.,0.,0.));\n    }\n   // col.x = log(0.5*td+1.);\n   // col.y = 100.*max(abs(DE) - LOD*td,0.)*td;\n    col = vec4(HDRmapping(col.xyz, 6.),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define bilin(a, p) texture(a, p/R, 0)\n#define get(i)  texelFetch(iChannel0, ivec2(i, 0), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n\n//random iterations\n#define RIT 4\n//marches per iteration \n#define MPI 2\n//shadow steps per iteration \n#define SMPI 2\n\n#define dt 0.001\n\n\n\n\n#define MAXD 256.\n#define MAXI 256\n#define MIND 0.0000001\n#define FOV 2.3\nfloat LOD;\nfloat time;\nvec2 R;\n\n//stochastic optimization score\nfloat score(float td, float d)\n{\n    return (td<0.)?1e10:(td + 60.*max(abs(d), LOD*td)/LOD);\n}\n\n#define INIT time = iTime; R = iResolution.xy; \\\n\t\tLOD = 1./max(iResolution.x,iResolution.y); \\\n        fshift = get(FRACSHIFT).xyz;\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n\n#define light_d vec3(sin(1.4)*cos(0.5+0.*iTime),sin(1.4)*sin(0.5+0.*iTime),cos(1.4))\n#define N_instructions 9.\n\n#define MOUSE 0\n#define ANGLE 1\n#define POS   2\n#define VEL   3\n#define LIGHT 4\n#define SPEED 5\n#define PREVANGLE 6\n#define PREVPOS 7\n#define FRACSHIFT 8\n\n/*//fractal terrain\nconst int fracit = 20;\nconst float iFracScale = 1.6;\nconst float iFracAng1 = 2.7315;\nconst float iFracAng2 = -0.2082;\nconst vec3 iFracShift = vec3(-8.92, 3.66, 5.49);\nconst vec3 iFracCol = vec3(0.3, 0.3, -0.2);\n*/\n//how much does the terrain change in large scale\n#define PERLIN_SCALE 2\n/*\n\n//Everest\nconst int fracit = 10;\nconst float iFracScale = 1.9151;\nconst float iFracAng1 = -9.8300;\nconst float iFracAng2 = -1.1600;\nconst vec3 iFracShift = vec3(-2.56, -4.53, 2.94);\nconst vec3 iFracCol = vec3(1.97, 0.11, -0.31);\n*/\nvec3 fshift;\n\n\n//mega citadel \nconst int fracit = 16;\nconst float iFracScale = 1.4731;\nconst float iFracAng1 = 0.0;\nconst float iFracAng2 = 0.0;\nconst vec3 iFracShift = vec3(-10.4, 3.28, -1.90);\nconst vec3 iFracCol = vec3(1.f, 1.f, 1.f);\n\n\n\n\n//////Random number generation part\n#define INIT_RAND(pos) seed = vec4(pos.xy, iFrame, PI*iTime); sp = pos;\n#define BLUE(pos) texture(iChannel3, pos);\nvec2 sp;\nvec4 seed;\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat rand()\n{\n    seed.x = hash11(seed.x);\n    return seed.x;\n}\n\nvec2 rand2()\n{\n    seed.xy = hash22(seed.xy);\n    return seed.xy;\n}\n\n\nvec4 rand4() \n{\n    seed = hash44(seed);\n    return seed;\n}\n\n//normally distributed random numbers\nvec2 randn2()\n{\n    vec2 rand = rand2();\n    vec2 box_muller = sqrt(-2.*min(log(max(rand.x,1e-10)), 0.))*vec2(sin(2.*PI*rand.y),cos(2.*PI*rand.y));\n    return box_muller;\n}\n\nvec4 randn4()\n{\n    vec4 rand = rand4();\n    vec2 l1 = sqrt(-2.*min(log(max(rand.xy,1e-10)), 0.));\n    vec4 angular = vec4(sin(2.*PI*rand.z), cos(2.*PI*rand.z), sin(2.*PI*rand.w), cos(2.*PI*rand.w));\n\treturn l1.xxyy*angular;\n}\n\nvec4 perlin_octave(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 a = vec2(0.,1.);\n   \n   vec4 a00 = hash42(pi+a.xx);\n   vec4 a01 = hash42(pi+a.xy);\n   vec4 a10 = hash42(pi+a.yx);\n   vec4 a11 = hash42(pi+a.yy);\n   \n   vec4 i1 = mix(a00, a01, pfc.y);\n   vec4 i2 = mix(a10, a11, pfc.y);\n   \n   return mix(i1, i2, pfc.x);  \n}\n\nmat2 rotat = mat2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5));\n\nvec4 perlin4(vec2 p)\n{\n\tfloat a = 1.;\n\tvec4 res = vec4(0.);\n\tfor(int i = 0; i < PERLIN_SCALE; i++)\n\t{\n\t\tres += a*(perlin_octave(p)-0.5);\n        //inverse perlin\n\t\tp *= 0.6*rotat;\n\t\ta *= 1.2;\n\t}\n\treturn res;\n}\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sdSph( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvoid mengerFold(inout vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\n\n\n\nfloat sdFract(vec3 p)\n{\n     p.xyz = p.xzy;\n  //  vec3 p0 = p.xyz;\n    float scale = 1.;\n    float c1 = cos(iFracAng1); float c2 = cos(iFracAng2);\n    float s1 = sin(iFracAng1); float s2 = sin(iFracAng2);\n\tmat2 rmZ = mat2(c1, s1, -s1, c1);\n\tmat2 rmX = mat2(c2, s2, -s2, c2);\n    \n    //p.xz = mod(p.xz + vec2(0.5), vec2(1.)) - vec2(0.5); \n\t//vec4 perlin1 = perlin4(p0.xz);\n\tvec3 shift = fshift;// + 0.35*perlin1.xyz;\n    \n\tfor (int i = 0; i < fracit; i++)\n    {\n\t\tp = abs(p);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale;\n        scale *= iFracScale;\n\t\tp += shift;\n\t}\n\treturn sdBox(p, vec3(6.))/scale;\n}\n\nvec3 col_fractal(vec3 p) \n{\n     p.xyz = p.xzy;\n    vec3 orbit = vec3(0.);\n\tfloat scale = 1.;\n    float c1 = cos(iFracAng1); float c2 = cos(iFracAng2);\n    float s1 = sin(iFracAng1); float s2 = sin(iFracAng2);\n\tmat2 rmZ = mat2(c1, s1, -s1, c1);\n\tmat2 rmX = mat2(c2, s2, -s2, c2);\n\tfor (int i = 0; i < fracit; i++)\n    {\n\t\tp = abs(p);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale;\n        scale *= iFracScale;\n\t\tp += iFracShift;\n        orbit = max(orbit, p*iFracCol);\n\t}\n\treturn tanh(abs(orbit));\n}\n\nvec3 Aarr[4] = vec3[4](vec3(0.5,0,0), vec3(0,1,0), \n                       vec3(0,0,0.3), vec3(0.4,-0.4,1.));\nvec3 Barr[4] = vec3[4](vec3(1,0,-1), vec3(-1.3,0.5,0), \n                       vec3(-0.4,-0.5,-0.7), vec3(-0.4,-0.2,0.3));\n\n//divergence free field\nvec3 CurlF(vec3 p)\n{\n    p *= 6.;\n\tvec3 A = vec3(0);\n    vec3 B = vec3(0);\n    loop(i, 4)\n    {\n        A += Aarr[i]*sin(dot(Aarr[i], p))/dot(Aarr[i],Aarr[i]);\n        B += Barr[i]*cos(dot(Barr[i], p))/dot(Barr[i],Barr[i]);\n    }\n    return cross(A,B);\n}\n\n#define H 0.0*sin(time*0.4)\n\nfloat map(vec3 p)\n{\n    //advection through a field\n    loop(i, 2)\n    {\n        p += H*CurlF(p);\n    }\n    \n    float d = sdFract(p);\n    return d;\n}\n\nvec4 normal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\tvec4 r = k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx);\n    //the normal and the averaged distance\n    return vec4(normalize(r.xyz), r.w*0.25);\n}\n\nvec3 color(vec3 p)\n{\n   return col_fractal(p);\n}\n\nstruct mat\n{\n    vec3 albedo;\n    vec3 emiss;\n    float rough;\n    float metal;\n};\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat NGGX(vec3 n, vec3 h, float a)\n{\n    float a2 = sqr(a);\n    return a2/(PI*sqr( sqr( max(dot(n,h),0.) )*(a2-1.) + 1.));\n}\n\nfloat GGX(vec3 n, vec3 o, float a)\n{\n    float ndoto = max(dot(n,o),0.);\n    return ndoto/mix(1., ndoto, sqr(a+1.)*0.125);\n}\n\nfloat GS(vec3 n, vec3 i, vec3 o, float a)\n{\n    return GGX(n,i,a)*GGX(n,o,a);\n}\n\nvec3 IR(float D, float k0, vec3 k1)\n{\n    //interference effect here ->\n    return (0.25+ k0*( 1. - cos(2.*PI*pow(vec3(D), -k1)) ))/D ;\n}\n\nvec3 BRDF(vec3 i, vec3 o, vec3 n, mat m)\n{\n    vec3 h = normalize(i + o);\n    vec3 F0 = mix(vec3(0.04), m.albedo, m.metal);\n    vec3 FS = F0 + (1.0 - F0) * pow(1.0 - max(dot(h, i), 0.0), 5.0);\n    vec3 DFG = NGGX(n,h,m.rough)*GS(n,i,o,m.rough)*FS;\n    float denom = max(dot(n, i), 0.001) * max(dot(n, o), 0.001);\n    return (m.albedo*(1.-FS)/PI +\n            DFG*IR(denom, 0.1, vec3(1.,1.1,1.2)))*max(0., dot(n,o));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nvec3 sky(vec3 r)\n{\n    vec3 c = vec3(.009, .288, .828);\n\tc = mix(vec3(1.), c, .9);\n\tc *= .5;\n    float atmo = tanh(10.*(r.z-0.05))*0.4 + 0.5 + 0.1*r.z;\n    \n    vec3 g = vec3(atmo);  \n    vec3 A0 = pow(c, g);\n    vec3 B0 = 1.-pow(vec3(1.)-c, 1.-g);\n    \n    vec3 A = A0*(1.-A0);\n    vec3 B = B0*(1.-B0);\n    \n    return mix(A, B, g);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\n\n\n///Newton marching\n\nfloat btd; \nfloat bsc;\n\n\n//camera ray\nvoid march(vec3 p, vec3 r, float td0, float td1)\n{\n    float d1 = 0., d0 = map(p + td0*r) - 1.*td0*LOD;\n    loop(j, MPI)\n    {\n        d1 = map(p + td1*r) - 1.*td1*LOD;\n        float dx = td1 - td0;\n        td0 = td1;\n        td1 -= 1.*d1 * dx / (d1 - d0); //secant method\n        d0 = d1;\n    }\n\n    //score found intersection\n    float csc = score(td1, d1);\n\n    if(csc < bsc)\n    {\n        btd = td1;\n        bsc = csc;\n    }\n}\n\n//shadow marching \nvoid smarch(vec3 p, vec3 r, float td)\n{\n    float d0 = 0., d1 = 0.;\n    loop(j, SMPI)\n    {\n        d0 = map(p + (td-dt)*r);\n        d1 = map(p + (td+dt)*r);\n        td -= 0.001*td*LOD*(d1 - d0)/dt ; //gradient descent\n        if(td > MAXD) break;\n    }\n\n    //score found angle\n    float angle = 0.5*(d0+d1)/td;  \n\n    if(angle < bsc && td > 0.)\n    {\n        btd = td;\n        bsc = angle;\n    }\n}\n\n\n//usual marching \n\nfloat march1(vec3 p, vec3 r)\n{\n    float td = 0.;\n    float d;\n    for(int i = 0; i < MAXI; i++)\n    {\n        d = map(p + td*r);\n        if(d <= LOD*td) break;\n        if(td > MAXD) \n        {\n            break;\n        }\n        td += d;\n    }\n    td += d - LOD*td; //better surface\n    return td; //position and ID\n}\n\n\n\n\n\n//prev frame pos reprojection\n\nmat3 rmat;\nvec3 ppos;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/// UTILITY\n///\n/// Using the GPU as the CPU here\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT  \n    fragColor = vec4(0.);\n    if(fragCoord.x <= N_instructions && fragCoord.y <= 1.)\n    {\n        INIT_RAND(fragCoord);\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = get(I);\n        vec4 mouse = get(MOUSE);\n        vec2 mousespeed = mouse.xy;\n        vec4 angles = get(ANGLE);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = get(POS);\n        vec4 vel = get(VEL);\n\t\tvec4 speed = get(SPEED);\n        vec4 norm = normal(posit.xyz, MIND);\n        \n        switch(I)\n        {\n        case MOUSE:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(0.,0.2);\n            }\n            break;\n            \n        case POS:  //position\n            fragColor.xyz += vel.xyz*speed.x;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(0.,-11.,6.);\n            }\n           \n            break;\n         case VEL:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*speed.x;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //fractal collision detection, removing the normal velocity component \n          \t//fragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n            break;\n          case SPEED: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tfragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = CAMERA_SPEED;\n            }\n            break; \n          case PREVANGLE:\n            fragColor = angles;\n            break;\n          case PREVPOS:\n            fragColor = posit;\n            break;\n          case FRACSHIFT:\n            if(isKeyPressed(KEY_P))\n   \t   \t\t{\n            \tfragColor.x += 0.01;   \n            }\n            if(isKeyPressed(KEY_O))\n   \t   \t\t{\n                fragColor.x -= 0.01;\n            }\n            \n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n            \tfragColor.y += 0.01;   \n            }\n            if(isKeyPressed(KEY_K))\n   \t   \t\t{\n                fragColor.y -= 0.01;\n            }\n            \n            if(isKeyPressed(KEY_M))\n   \t   \t\t{\n            \tfragColor.z += 0.01;   \n            }\n            if(isKeyPressed(KEY_N))\n   \t   \t\t{\n                fragColor.z -= 0.01;\n            }\n           \n            if(iFrame < 1)\n            {\n                fragColor = vec4(iFracShift, 0.);\n            }\n        }   \n    } else discard; \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//stochastic ray marching pass 1\nvec2 reprojection(vec3 p)\n{\n    vec3 dp = normalize(p - ppos);\n    float zp = FOV*dot(dp, rmat[1]);\n    vec2 prj = max(R.x,R.y)*zp*vec2(dot(dp, rmat[0]), dot(dp, rmat[2]))/(0.001+zp*zp);\n    return clamp(prj + R*0.5, vec2(0.), R); \n}\n\nfloat randomarch(vec3 p, vec3 r)\n{  \n    btd = 1e10; bsc = 1e10;\n    float ptd_guess = texel(ch1, sp).x;\n    vec2 prev_p = reprojection(ppos + r*ptd_guess);\n    float CAMd = distance(ppos, p);\n    float LODd = 10.*LOD*ptd_guess + MIND;\n    float gtd = texel(ch1, prev_p).x;\n    march(p, r, gtd - LODd-CAMd, gtd-CAMd);\n    loop(i, RIT)\n    {\n        vec4 rn4 = randn4();\n        int d = (i + 2*iFrame + int(sp.x + sp.y))%4;\n        //depth guess\n        ivec2 pp = ivec2(prev_p) + cross_distribution(d + i*int(4.*abs(rn4.x)));\n        gtd = (1. - 0.05*float(i)*abs(rn4.x))*texel(ch1, pp).x; \n        march(p, r, gtd - LODd - CAMd, gtd - CAMd);\n        prev_p = reprojection(p + r*btd);\n    }\n    \n    return btd;\n}\n\nfloat shadowmarch(vec3 p, vec3 r)\n{  \n    btd = 1e10; bsc = 1e10;\n    vec2 prev_p = reprojection(p);\n    smarch(p, r, texel(ch1, prev_p).y);\n    loop(i, RIT)\n    {\n        vec4 rn4 = randn4();\n        //depth guess\n        ivec2 pp = ivec2(prev_p) + cross_distribution(i +  int(16.*abs(rn4.x)));\n        float gtd = (1. - 0.4*rn4.y)*texel(ch1, pp).y;\n        smarch(p, r, gtd);\n    }\n    \n    return btd;\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    INIT\n    INIT_RAND(pos);\n    \n    rmat = transpose(getCamera(get(PREVANGLE).xy));\n    ppos = get(PREVPOS).xyz;\n    \n   \tivec2 pi = ivec2(pos);\n    vec2 uv = (pos - R*0.5)/max(R.x,R.y);\n    \n    vec2 angles = get(ANGLE).xy;\n \tvec3 r = getRay(angles, uv);\n    vec3 p = get(POS).xyz;\n    \n   \n    float td = randomarch(p, r);\n   \n    p += (1. - 2.*LOD)*td*r;\n    \n    float DE = map(p);\n    float tds = 0.;\n   \n    if(DE > 3.*td*LOD) //use old shadow data if surface is not converged\n    {\n        vec2 prev_p = reprojection(p);\n        vec2 pp = texel(ch1, prev_p).yz;\n        tds = pp.x;\n        bsc = pp.y;\n    }\n    else\n    {\n        tds = shadowmarch(p, normalize(light_d));\n    }\n    \n    Q.xyz = vec3(td, tds, bsc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}