{
    "Shader": {
        "info": {
            "date": "1692902392",
            "description": "Very simple soft shadow approximation test. ",
            "flags": 0,
            "hasliked": 0,
            "id": "ctXfW4",
            "likes": 3,
            "name": "Approx sphere soft shadow",
            "published": 3,
            "tags": [
                "shadow",
                "sphere"
            ],
            "usePreview": 0,
            "username": "Blindman67",
            "viewed": 163
        },
        "renderpass": [
            {
                "code": "#define PLANET_RADIUS 4.0\n#define ATMOSPHERE_DEPTH 0.25\n#define CAMERA_OFFSET 80.0\n#define CAMERA_LENGTH 0.2\n\n#define RAY_SRC_SPHERE 2u\n#define RAY_SRC_SPACE 3u\n#define RAY_SRC_AIR   4u\n\nconst vec4 COL_SUN          = vec4(1, 1, 1, 62.0);\nconst vec4 COL_AMBIENT      = vec4(0.005, 0.01, 0.02, 1.0) * 5.0;\n\nRay camera = Ray(vec3(0), vec3(0));\nRay ray = Ray(vec3(0), vec3(0));\nSphere world = Sphere(vec3(0), PLANET_RADIUS, PLANET_RADIUS * PLANET_RADIUS);\nSphere world1 = Sphere(vec3(6, 0, 0), PLANET_RADIUS * 0.5, pow(PLANET_RADIUS * 0.5,  2.0));\nSphere world2 = Sphere(vec3(9, 0, 0), PLANET_RADIUS * 0.25, pow(PLANET_RADIUS * 0.25,  2.0));\nconst Sphere sun = Sphere(vec3(1000,520, 10), PLANET_RADIUS, pow(PLANET_RADIUS, 2.0));\nuint type = RAY_SRC_SPACE;\nvec2 invRes;\nvec3 srcPos;\nvec3 srcPosN;\nbool shadow = true;\nfloat soft = 0.0;\nbool TraceShadow(Ray ray, Sphere w) {\n    vec3 d = DistAllSphere(ray, w); \n    if (d.x >= FAR || d.x < 0.0) { return false; }\n\n    soft -= clamp(w.radius -length(ray.origin + ray.dir * d.z - w.origin), 0.0, 0.5) * 2.0;\n\n    return true;\n}\nvec2 Trace(Ray camera) {\n    shadow = false;\n\tfloat wDist = DistToSphere(camera, world); \n    float wDist1 = DistToSphere(camera, world1); \n    float wDist2 = DistToSphere(camera, world2); \n    float mDist = min(wDist, min(wDist1, wDist2));\n    if (mDist >= FAR) {\n        type = RAY_SRC_SPACE;\n        return vec2(0);\n    \n    }\n    type = RAY_SRC_SPHERE;\n    srcPos = camera.origin + camera.dir * mDist;\n    soft = 1.0;\n    if (wDist < wDist1 && wDist < wDist2) {\n        srcPosN = normalize(srcPos - world.origin);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world1);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world2) || shadow;\n    } else if (wDist1 < wDist2) {   \n        srcPosN = normalize(srcPos - world1.origin);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world2) || shadow;\n    } else {\n        srcPosN = normalize(srcPos - world2.origin);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world1) || shadow;\n    }\n\n    soft = UClamp(soft);\n    return vec2(atan(srcPosN.z, srcPosN.x) * INV_TAU, acos(-srcPosN.y) * INV_TAU);  \n}\n\nvec3 Light(vec3 col) {    \n    vec3 L = normalize(sun.origin - srcPos);\n    vec3 R = reflect(L, srcPosN);\n    float light = UClamp(dot(normalize(srcPosN), L)) * soft;\n    vec3 a = col * COL_AMBIENT.rgb;\n    float spec = pow((col.r + col.g + col.b) * (1.0 / 3.0), 0.5);\n    col *= light;            \n    col += spec * soft * pow(UClamp(dot(camera.dir, R)) * COL_SUN.rgb, vec3(COL_SUN.a)) ;\n    col += a;\n    return col + COL_AMBIENT.rgb;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 px ) {\n    world1.origin = vec3(sin(iTime*0.133) * 5.5, cos(iTime*0.133) * 5.5, 0);\n    world2.origin = vec3(sin(iTime) * 2.75 + world1.origin.x, + world1.origin.y, cos(iTime) * 2.75 + world1.origin.z);\n    invRes = InvRes(iResolution.xy);\n    vec2 look = iMouse.x < 1.0 && iMouse.y < 1.0 ? iResolution.xy * vec2(0.5, 0.45) : iMouse.xy;\n    mat3 vmat = lookMouse(look / iResolution.xy * vec2(4.0, 2.0));\n    vec2 uv = (px - iResolution.xy * 0.5) * invRes.y;\n    camera.origin =  - vmat[2] * CAMERA_OFFSET;\n    camera.dir = normalize(vmat * vec3(uv  * CAMERA_LENGTH, 1.0));\n    vec2 coord = Trace(camera);\n    uv = coord / iResolution.xy;\n    if (type == RAY_SRC_SPHERE) {\n        col = vec4(Light(texture(iChannel0, coord).xyz), 1);\n    } else {\n        col = vec4(0);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define EPSILON 0.0001\n#define TINY 0.001\n#define FAR  10000.0\n\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float ANG_90 = PI * 0.5;\nconst float INV_PI = 1.0 / PI;\nconst float INV_ANG_90 = 1.0 / ANG_90;\nconst float INV_TAU = 1.0 / TAU;\nconst float INV_60 = 1.0 / 60.0;\nconst float INV_64 = 1.0 / 64.0;\nconst float INV_255 = 1.0 / 255.0;\n\n\nstruct Ray {vec3 origin; vec3 dir;};\nstruct Sphere {vec3 origin; float radius; float radiusSqr;};\nvec3 Uint2RGB(uint c) { return vec3(float((c >> 16u) & 255u) * INV_255, float((c >> 8u) & 255u) * INV_255, float(c & 255u) * INV_255); }\nfloat UClamp(in float v) { return clamp(v, 0.0, 1.0); } /* U for unit */\nvec2 Rotate(in vec2 uv, float a) {\n    float c = cos(a), s = sin(a);\n    return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 InvRes(in vec3 res) { return 1.0 / res; }\nvec2 InvRes(in vec2 res) { return 1.0 / res; }\nvec2 FixUV(in vec2 uv, in vec3 res) { return (2.0 * uv - res.xy); }\nfloat Time(in int f) { return float(f) * INV_60; }\nfloat Time(in int f, in float scale) { return float(f) * INV_60 * scale; }\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\nmat3 lookMouse(in vec2 unitMouse) {  return camMatrix((unitMouse.x * 1.0 + 0.0) * PI, (unitMouse.y * 0.5 + 0.5) * PI); }\n\n\n\nfloat DistOutSphere(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin - ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return FAR; }\n    return d + sqrt(sphere.radiusSqr - d2);\n}\nfloat DistToSphere(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin - ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return FAR; }\n    return d - sqrt(sphere.radiusSqr - d2);\n}\nvec2 DistToSphereInOut(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin -ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return vec2(FAR); }\n    float t = sqrt(sphere.radiusSqr - d2);\n    return vec2(d - t, d + t);\n}\nvec3 DistAllSphere(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin -ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return vec3(FAR); }\n    float t = sqrt(sphere.radiusSqr - d2);\n    return vec3(d - t, d + t, d);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}