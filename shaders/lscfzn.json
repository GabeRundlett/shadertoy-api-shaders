{
    "Shader": {
        "info": {
            "date": "1523918661",
            "description": "Try to recreate fractal noise from after effects.\nIt's Value noise",
            "flags": 0,
            "hasliked": 0,
            "id": "lscfzn",
            "likes": 18,
            "name": "Fractal Noise - After Effects",
            "published": 3,
            "tags": [
                "fractal",
                "noise"
            ],
            "usePreview": 0,
            "username": "alijaya",
            "viewed": 1516
        },
        "renderpass": [
            {
                "code": "/*\n * 0: basic\n * 1: turbulent smooth\n * 2: turbulent basic\n * 3: turbulent sharp\n * 4: dynamic\n */\nint fractalType = 3;\n/*\n * 0: block\n * 1: linear\n * 2: softlinear\n * 3: spline\n */\nint noiseType = 3;\n\nbool invert = false;\nfloat contrast = 1.;\nfloat brightness = 0.;\n/*\n * 0: clip\n * 1: soft clamp\n * 2: wrap back\n * 3: allow hdr results\n */\nint overflow = 3;\n\n// transform\nfloat rotation = 0.; // in Periode\nvec2 scale = vec2(32., 32.);\nvec2 offsetTurbulence = vec2(0., 0.);\n\nfloat complexity = 5.;\n\n// sub settings\nfloat subInfluence = 0.7;\nfloat subScaling = 0.57;\nfloat subRotation = 0.; // in Periode\nvec2 subOffset = vec2(0., 0.);\nbool centerSubscale = false;\n\nfloat evolution = 0.; // in Periode\nbool cycleRevolution = false;\nint cycle = 1; // not used if cycleRevolution is false\n\nint randomSeed = 0;\n\n#define SIZE 64.0\n#define PI acos(-1.)\n#define TAU 2.*PI\n#define toRad PI/180.\n#define toDeg 180./PI\n\n// copy from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec2 flip(vec2 coord) {\n    return vec2(coord.x, iResolution.y - coord.y);\n}\n\nfloat bicubic(float a, float b, float c, float d, float t) {\n    float p = - a / 2. + b * 3./2. - c * 3./2. + d / 2.;\n    float q = a - b * 5./2. + c * 2. - d / 2.;\n    float r = - a / 2. + c / 2.;\n    float s = b;\n    \n    return p * t*t*t + q * t*t + r * t + s;\n}\n\nfloat wrap(float value, float minValue, float maxValue) {\n    return mod((value - minValue), (maxValue - minValue)) + minValue;\n}\n\n// Fractal Type\n\nfloat basic(float f) {\n    return f;\n}\n\nfloat turbulentBasic(float f) {\n    return abs(f - 0.5) * 2.;\n}\n\nfloat turbulentSmooth(float f) {\n    float x = turbulentBasic(f);\n    return x*x;\n}\n\nfloat turbulentSharp(float f) {\n    float x = turbulentBasic(f);\n    return sqrt(x);\n}\n\nfloat selectFractal(float f) {\n    float ret = 0.;\n    if (fractalType == 0) {\n        ret = basic(f);\n    } else if (fractalType == 1) {\n        ret = turbulentSmooth(f);\n    } else if (fractalType == 2) {\n        ret = turbulentBasic(f);\n    } else if (fractalType == 3) {\n        ret = turbulentSharp(f);\n    } else {\n        ret = basic(f);\n    }\n    return ret;\n}\n\n// Cycle\n\nfloat selectCycle(float value, float base, float periode) {\n    float ret = 0.;\n    if (cycleRevolution) {\n        ret = wrap(value, base, base + periode);\n    } else {\n        ret = value;\n    }\n    return ret;\n}\n\n// Noise Type\n\nfloat block(vec2 fragCoord, float depth) {\n    float randf = float(randomSeed);\n    if (centerSubscale) randf += depth;\n    vec3 hash = hash33(vec3(floor(fragCoord), randf));\n    float freq = hash.x; // random freq for each coord\n    float periode = 1. + floor(freq * float(cycle + 1));\n    if (cycleRevolution) {\n        freq = periode / float(cycle);\n    }\n    float evo = evolution * freq + hash.y;\n    float e = randf + floor(evo); // evolution here\n    float f = fract(evo);\n    \n    float a = hash33(vec3(floor(fragCoord), selectCycle(e - 1., randf, periode))).x;\n    float b = hash33(vec3(floor(fragCoord), selectCycle(e + 0., randf, periode))).x;\n    float c = hash33(vec3(floor(fragCoord), selectCycle(e + 1., randf, periode))).x;\n    float d = hash33(vec3(floor(fragCoord), selectCycle(e + 2., randf, periode))).x;\n    \n    return bicubic(a, b, c, d, f);\n}\n\nfloat linear(vec2 fragCoord, float depth) {\n    fragCoord -= 0.5;\n    float tl = block(fragCoord, depth);\n    float tr = block(fragCoord + vec2(1., 0.), depth);\n    float bl = block(fragCoord + vec2(0., 1.), depth);\n    float br = block(fragCoord + vec2(1., 1.), depth);\n    \n    vec2 f = fract(fragCoord);\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n\nfloat softLinear(vec2 fragCoord, float depth) {\n    fragCoord -= 0.5;\n    float tl = block(fragCoord, depth);\n    float tr = block(fragCoord + vec2(1., 0.), depth);\n    float bl = block(fragCoord + vec2(0., 1.), depth);\n    float br = block(fragCoord + vec2(1., 1.), depth);\n    \n    vec2 f = fract(fragCoord);\n    f = smoothstep(0., 1., f);\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n\nfloat spline(vec2 fragCoord, float depth) {\n    fragCoord -= 0.5;\n    \n    float ttll = block(fragCoord + vec2(-1., -1.), depth);\n    float ttl = block(fragCoord + vec2(0., -1.), depth);\n    float ttr = block(fragCoord + vec2(1., -1.), depth);\n    float ttrr = block(fragCoord + vec2(2., -1.), depth);\n                       \n    float tll = block(fragCoord + vec2(-1, 0.), depth);\n    float tl = block(fragCoord, depth);\n    float tr = block(fragCoord + vec2(1., 0.), depth);\n    float trr = block(fragCoord + vec2(2, 0.), depth);\n    \n    float bll = block(fragCoord + vec2(-1., 1.), depth);\n    float bl = block(fragCoord + vec2(0., 1.), depth);\n    float br = block(fragCoord + vec2(1., 1.), depth);\n    float brr = block(fragCoord + vec2(2., 1.), depth);\n    \n    float bbll = block(fragCoord + vec2(-1., 2.), depth);\n    float bbl = block(fragCoord + vec2(0., 2.), depth);\n    float bbr = block(fragCoord + vec2(1., 2.), depth);\n    float bbrr = block(fragCoord + vec2(2., 2.), depth);\n                       \n    vec2 f = fract(fragCoord);\n    \n    float tt = bicubic(ttll, ttl, ttr, ttrr, f.x);\n    float t = bicubic(tll, tl, tr, trr, f.x);\n    float b = bicubic(bll, bl, br, brr, f.x);\n    float bb = bicubic(bbll, bbl, bbr, bbrr, f.x);\n    \n    return bicubic(tt, t, b, bb, f.y);\n}\n\n// Overflow\n\nfloat clipOverflow(float value) {\n    return clamp(value, 0., 1.);\n}\n\nfloat softClampOverflow(float value) {\n    return 1. / (1. + exp(2. - 4.*value));\n}\n\nfloat wrapBackOverflow(float value) {\n    return abs(value - 2.*floor(value*0.5 + 0.5));\n}\n\nfloat allowHdrResultsOverflow(float value) {\n    return value;\n}\n\nfloat selectOverflow(float value) {\n    float ret = 0.;\n    if (overflow == 0) {\n        ret = clipOverflow(value);\n    } else if (overflow == 1) {\n        ret = softClampOverflow(value);\n    } else if (overflow == 2) {\n        ret = wrapBackOverflow(value);\n    } else if (overflow == 3) {\n        ret = allowHdrResultsOverflow(value);\n    } else {\n        ret = allowHdrResultsOverflow(value);\n    }\n    return ret;\n}\n\nfloat layer(vec2 fragCoord, float depth) {\n    float ret = 0.;\n    if (noiseType == 0) {\n        ret = block(fragCoord, depth);\n    } else if (noiseType == 1) {\n        ret = linear(fragCoord, depth);\n    } else if (noiseType == 2) {\n        ret = softLinear(fragCoord, depth);\n    } else if (noiseType == 3) {\n        ret = spline(fragCoord, depth);\n    } else {\n        ret = spline(fragCoord, depth);\n    }\n    return selectFractal(ret);\n}\n\nmat3 inverseMatrix(vec2 translate, float rotate, vec2 scale) {\n    return transpose(mat3(\n        cos(-rotate)/scale.x, -sin(-rotate)/scale.x, -translate.x,\n        sin(-rotate)/scale.y, cos(-rotate)/scale.y, -translate.y,\n        0., 0., 1.\n    ));\n}\n\nvoid transformed( out vec4 fragColor, in vec2 fragCoord ) {\n    mat3 matrix = inverseMatrix(subOffset, subRotation * TAU, vec2(subScaling));\n    \n    float val = 0.;\n    \n    float totalWeight = 0.;\n    mat3 trans = mat3(1.);\n    float weight = 1.;\n    for (float i=1.; i<complexity; i++) {\n        vec2 newCoord = (trans * vec3(fragCoord, 1.)).xy;\n        val  += layer(newCoord, i) * weight;\n        \n        totalWeight += weight;\n        \n        trans = matrix * trans;\n        weight *= subInfluence;\n    }\n    \n    float f = fract(complexity);\n    if (f == 0.) f = 1.;\n    \n    vec2 newCoord = (trans * vec3(fragCoord, 1.)).xy;\n    val  += layer(newCoord, floor(complexity)+1.) * weight * f;\n\n    totalWeight += weight * f;\n    \n    val /= totalWeight;\n\n    // color\n    \n    if (invert) {\n        val = 1. - val;\n    }\n    val = (val - 0.5) * contrast + 0.5;\n    val += brightness;\n    \n    val = selectOverflow(val);\n    \n    fragColor = vec4(vec3(val),1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    evolution = iTime;\n    \n    vec2 flipCoord = flip(fragCoord);\n    mat3 trans = inverseMatrix(offsetTurbulence, rotation * TAU, scale);\n    flipCoord = (trans * vec3(flipCoord, 1.)).xy;\n    transformed(fragColor, flipCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}