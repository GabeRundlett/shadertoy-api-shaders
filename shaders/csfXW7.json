{
    "Shader": {
        "info": {
            "date": "1668986740",
            "description": "Building off of https://www.shadertoy.com/view/XsfyDl by ChuckNorris, I implemented a text thingy. I meant to use this for debugging.",
            "flags": 0,
            "hasliked": 0,
            "id": "csfXW7",
            "likes": 2,
            "name": "Text Console",
            "published": 3,
            "tags": [
                "draw",
                "debug",
                "int",
                "float",
                "debugging",
                "write"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 733
        },
        "renderpass": [
            {
                "code": "#define fontTex iChannel3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    Font f;\n    f.texSize = iChannelResolution[3].xy;\n    f.charSize = iChannelResolution[3].xy / vec2(16, 16);\n    \n    const vec2 charScale = vec2(20, 20);\n    TextCursor t;\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0);\n    t.font = f;\n    t.color = vec4(1,1,0,1);\n    t.charSize = vec2(1,1) * charScale;\n    t.charSpace = vec2(0.475, 0.8) * charScale;\n    t.pageWidth = 40;\n\n    declString(s, 11, (cH, cE, cL, cL, cO, cSp, cW, cO, cR, cL, cD));  \n    \n    for(int i = 0; i < 10; i++)\n    {\n        pline(s, t);\n    }\n    \n    pnl(t);\n    \n    for(int i = 0; i < 10; i++)\n    {\n        pstr(s, t);\n        pch(cSp, t);\n    }\n    \n    t.color = vec4(0,1,1,1);\n    \n    for(int i = 0; i < 10; i++)\n    {\n        pch(Digits[i], t);\n    }\n    \n    pch(cNl, t);\n    \n    for(int i = 0; i < 26; i++)\n    {\n        pch(Uppercase[i], t);\n        pch(Lowercase[i], t);\n    }\n    \n    t.color = vec4(1,1,1,1);\n    \n    pnl(t);\n    pint(int(iTime * 1000.0), t);\n    pnl(t);\n    pfloat(iTime, t);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\n// To use, #define fontTex and have local vars named fragCoord and fragColor\n#define pch(c, t) printChar(c, t, fontTex, fragCoord, fragColor)\n#define pstr(s, t) printString(s, t, fontTex, fragCoord, fragColor)\n#define pline(s, t) printLine(s, t, fontTex, fragCoord, fragColor)\n#define pnl(t) printChar(cNl, t, fontTex, fragCoord, fragColor)\n#define pint(i, t) printInt(i, t, fontTex, fragCoord, fragColor)\n#define pfloat(f, t) printFloat(f, t, fontTex, fragCoord, fragColor)\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String\n{\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font\n{\n    vec2 texSize;\n    vec2 charSize;\n};\n\nstruct TextCursor\n{\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n    vec2 uvSize = f.charSize / f.texSize;\n    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvec4 getCharFrag(ivec2 char, in TextCursor t, sampler2D tex, in vec2 fragCoord)\n{\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV)\n        return vec4(0);\n    \n    vec2 fontRectUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    \n    float opacity = texture(tex, fontRectUV).r;\n    \n    vec4 color = t.color;\n    color.a *= opacity;\n    return color;\n}\n\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    blend(getCharFrag(char, t, tex, fragCoord), fragColor);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t, tex, fragCoord, fragColor);\n    }\n}\n\nvoid printLine(String s, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t, tex, fragCoord, fragColor);\n    }\n    printChar(cNl, t, tex, fragCoord, fragColor);\n}\n\nvoid printInt(int val, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t, tex, fragCoord, fragColor);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t, tex, fragCoord, fragColor);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t, sampler2D tex, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t, tex, fragCoord, fragColor);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t, tex, fragCoord, fragColor);\n    } \n    \n    printChar(cDot, t, tex, fragCoord, fragColor);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t, tex, fragCoord, fragColor);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nint idiv(int a, int b){\n    // If you encounter precision loss, this is probably the reason.\n    return int(float(a)/float(b));\n    \n    String s;\n    setString(s, 11, (cH, cE, cL, cL, cO, cSp, cW, cO, cR, cL, cD));  \n}\n\nint imod(int a, int b){\n    return a - idiv(a, b)*b;\n}\n\n\n\n\n\n\n#if 0\n// draw a character where p is bottom left\nfloat draw_char(vec2 p, vec2 char_position)\n{\n    vec2 uv = (gl_FragCoord.xy - p)/vec2(DIGIT_WIDTH, DIGIT_HEIGHT);\n    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0){\n        return texture(iChannel3, (uv + char_position)/16.0).r;\n    }\n    return 0.0;\n}\n\n// draw a digit between 0-9\nfloat draw_digit(vec2 p, int digit)\n{\n    return draw_char(p, vec2(float(digit), 12.0));\n}\n\n// draw an unsigned integer\nfloat draw_uint(vec2 p, int number)\n{\n    number = abs(number);\n    \n    // we draw numbers from right to left because we get digits in that order\n    p.x += float(MAX_DIGITS - 1)*DIGIT_WIDTH;\n    \n    float color = 0.0;\n    \n    // decompose number into digits\n    for (int i = 0; i < MAX_DIGITS; i++){\n        int digit = imod(number, BASE);\n        number = idiv(number, BASE);\n        \n        color += draw_digit(p, digit);\n        \n        p.x -= DIGIT_WIDTH;\n    }\n    \n    return color;\n}\n\n// draw an unsigned integer with a sign in front\nfloat draw_uint_with_sign(vec2 p, int number, bool negative){\n    // draw sign\n    float color = draw_char(p, negative ? MINUS_SIGN : PLUS_SIGN);\n    p.x += DIGIT_WIDTH;\n    \n    // draw uint\n    color += draw_uint(p, number);\n    \n    return color;\n}\n\nfloat draw_int(vec2 p, int number){\n    return draw_uint_with_sign(p, number, number < 0);\n}\n\nfloat draw_float(vec2 p, float f){\n    float color = draw_uint_with_sign(p, int(f), f < 0.0);\n    p.x += float(MAX_DIGITS + 1)*DIGIT_WIDTH;\n    \n    // draw dot\n    color += draw_char(p, DOT);\n    p.x += DIGIT_WIDTH;\n    \n    // remove integer part\n    f -= float(int(f));\n    // shift fractional part into integer part\n    f *= pow(float(BASE), float(MAX_DIGITS));\n    \n    // draw fractional part\n    color += draw_uint(p, int(f));\n    \n    return color;\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}