{
    "Shader": {
        "info": {
            "date": "1577749262",
            "description": "MDTMJVM = Middecembertomidjanuaryvember\nA month of coding stuff.\nCoding some of the days at http://twitch.tv/wwrighter",
            "flags": 32,
            "hasliked": 0,
            "id": "3ld3WX",
            "likes": 4,
            "name": "Day 12 OF MDTMJVM - pathtracer 2",
            "published": 3,
            "tags": [
                "pathtracer",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "// Depth of Field pass. Code from https://www.shadertoy.com/view/Xd3GDl\n// which is an implementation of DICE's depth of field paper\n\n//#define USE_RANDOM\n\n\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\n\nconst float blurdist_px = 64.0;\n\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n\n    //float srnd = hash12n(uv+fract(iTime))-0.5;\n    \n   \tvec3 sumcol0 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( 1.0, 0.577350269189626 );\n    \tvec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    \tvec2 p1 = uv + 0.5 * blurdist * blurvec;\n    \tvec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    \tvec2 p = p0;\n        p += stepvec;\n    \n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol0 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol0 /= float(NUM_SAMPLES);\n    }\n    \n    vec3 sumcol1 = vec3(0.0);\n    {\n        vec2 blurdir = vec2( -1.0, 0.577350269189626 );\n        vec2 blurvec = normalize(blurdir) / iResolution.xy;\n        vec2 p0 = uv - 0.5 * blurdist * blurvec;\n        vec2 p1 = uv + 0.5 * blurdist * blurvec;\n        vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n        vec2 p = p0;\n        p +=  stepvec;\n\n        for (int i=0;i<NUM_SAMPLES;++i)\n        {\n        \tsumcol1 += sampletex(p);\n            p += stepvec;\n        }\n        sumcol1 /= float(NUM_SAMPLES);\n    }\n\n    vec3 sumcol = min( sumcol0, sumcol1 );\n\n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol ), 1.0 );\n    #else\n    \tfragColor = vec4( sumcol , 1.0 );\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define fov 0.6\n#define BOUNCES 2\n#define MARCH_ITERATIONS 460\n\n\n\n#define mx (20.*iMouse.x/iResolution.x)\n#define pmod(p,x) mod(p, x) - x*0.5\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\n\nvec3 getRd(vec3 o, vec3 lookAt, vec2 uv) {\n    uv += hash(uv.x + uv.y + float(iFrame))*0.0004;\t\t\t// thx slerpy\n    vec3 dir = normalize(lookAt - o);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\n// ----------------- SDFs ----------------- //\nfloat sdBox (vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y, p.z));\n}    \nfloat sdSphere (vec3 p, float s){\n\treturn length(p) - s;\n}\n\nfloat sdRoom (vec3 p, float s){\n    p = pmod(p, 1.);\n    float d;\n    float w = 0.001;\n    return length(p) - w;\n}\n\nfloat sdColumns (vec3 p, float s){\n    float distBetween = 1.6;\n    p = pmod(p, distBetween );\n    vec3 id = (floor(p/distBetween - 0.5*distBetween));\n    for(float i = 0.; i< 5.; i++){\n        p.yz *= rot(-0.1 - id.x*0.92 - id.z*0.9);\n        p.xz *= rot(-0.08 + id.x * 0.6);\n        p.x -= 0.4;\n        p.y -= 0.01;\n    p = abs(p);\n    }\n    float d;\n    float w = 0.01;\n    p.x -= w;\n    p.z -= w;\n    return max(p.x, p.z);\n}\n\nfloat sdFloorA (vec3 p){\n    return p.y;\n}\nfloat sdWall (vec3 p){\n    return -p.x;\n}\nfloat sdBackWall (vec3 p){\n    return -p.z;\n}\n\n\n\n#define lineW 0.005\nObject sdBallThingie(vec3 p, float r, in Object o) {\n    Object oBallThingie = NewObject;\n    oBallThingie = omin(oBallThingie,sdSphere(p, r),materials[0]);\n    oBallThingie = omax(oBallThingie,-sdSphere(p - vec3(0,0.82*r,0), r*0.55),materials[0] );\n \n    float dHole = (abs(length(p.x)) - lineW);\n    dHole = max(dHole, -sdSphere(p, r*0.95));\n    oBallThingie = omax(oBallThingie,-dHole,materials[1] );\n    \n    oBallThingie = omin(oBallThingie,sdSphere(p - vec3(0,r*2.,0), r*0.4),materials[2] );\n\n    oBallThingie.d *= 1.;\n\treturn oBallThingie;\n}\n\n\nfloat sdAaaa(vec3 p, vec3 s) {\n\tp = abs(p);\n    p -= s;\n\tfloat d = dot(p + s*0.5, normalize(vec3(1,1,0))) ;\n    d = max(d, dot(p + s*0.5, normalize(vec3(0,1,1))));\n    p += s*0.2;\n    d = max(d, max(p.x, max(p.y, p.z)));\n    return d;\n}\n\nfloat sdOcta(vec3 p, vec3 s) {\n\tp = abs(p);\n    p -= s;\n\tfloat d = dot(p + s*0.5, normalize(vec3(1,1,0)));\n    d = max(d, dot(p + s*0.5, normalize(vec3(0,1,1))));\n    return d;\n}\n\n\n#define ASIZE 1.6\n\nObject sdThingieA(vec3 p) {\n    \n    Object oThingieA = NewObject;\n    p.xz *= rot(0.3 * PI);\n    p.y -= 0.2;\n    oThingieA = omin(oThingieA,sdOcta(p, vec3(0.1)),materials[3]);\n     \n\treturn oThingieA;\n}\n\nObject sdThingieB(vec3 p) {\n    \n    Object oThingieA = NewObject;\n    //p.xz *= rot(0.3 * PI);\n    //p.y -= 0.2;\n    p.y += 0.04;\n    \n    p = abs(p);\n    p.xy *= rot(0.08);\n    for(float i = 0.; i < 3.; i ++) {\n    \tp = abs(p);\n        p.yz *= rot(0.4);\n        p.xy *= rot(0.1 + i*0.04);\n        p.x -= 0.15;\n    }\n    \n    p.x += 0.04;\n    oThingieA = omin(oThingieA,sdOcta(p , vec3(ASIZE*0.03)),materials[3]);\n\n\treturn oThingieA;\n}\n\n\n// ----------------- MAP ----------------- //\n#define HEIGHT\nObject map(vec3 p) {\n    Object o = NewObject;\n    \n\n    o = omin(o, sdFloorA(p - vec3(0.,-0.14,0)), materials[0]);\n    \n    o = omin(o, sdWall(p - vec3(0.9,0.,0)), materials[0]);\n    \n    o = omin(o, -sdWall(p - vec3(-0.4,0.,0)), materials[0]);\n    o = omin(o, sdWall(p - vec3(0.4,0.,0)), materials[0]);\n    o = omin(o, sdBackWall(p - vec3(-0.0,0.0,4.1)), materials[0]);\n    \n    o = omax(o, -max(abs(p.x) - lineW, -p.y - 0.15), materials[1]); // hole in ground middle\n    \n    \n    vec3 pSize = p;\n    pSize.y -= 0.2;\n    for (int i = 0;i < 4;i++) {\n        pSize = abs(pSize);\n        pSize.z -= 0.12;\n    \tpSize.yz *= rot(0.11);\n    \tpSize.yx *= rot(-0.5);\n    }\n    \n    o = omax(o, -max(abs(pSize.y) - lineW, -100.), materials[4]); // hole in ground side\n\n    pSize = p;\n    \n    for (int i = 0;i < 4;i++) {\n        pSize = abs(pSize);\n        pSize.y -= 0.2;\n        pSize.yz *= rot(0.25*PI);\n    }\n    \n    \n    o = omax(o, -max(abs(pSize.y) - lineW, -100.), materials[4]); // hole in ground side 2\n    \n    // wall fixes\n    o = omin(o, sdWall(p - vec3(0.41,0.,0)), materials[0]);\n    o = omin(o, -sdWall(p + vec3(0.41,0.,0)), materials[0]);\n    o = omin(o, sdFloorA(p - vec3(0.,-0.16,0)), materials[0]);\n    o = omin(o, sdBackWall(p - vec3(-0.0,0.0,4.12)), materials[0]);\n        \n    \n    \n    o = omin(o,sdBallThingie(p - vec3(-0.0,-0.14,0.4), 0.05,  o));    \n    \n    \n\n    \n    vec3 pA = p - vec3(-0.2,-0.14,0.4);\n    pA.z = pmod(pA.z + 0.5, ASIZE);\n    pA.x = pmod(pA.x - ASIZE*0.126  , ASIZE*1.3);\n    \n    for (int i = 0; i < 3; i++){\n        pA = abs(pA);\n        pA.yz *= rot(0.125*PI);\n        pA.z -= 0.45;\n        pA.x -= 0.61;\n    }\n    Object oThingieA = sdThingieA(pA);\n    o = omin(o,oThingieA); \n    \n    o = omin(o,sdThingieB(p - vec3(0,0,0.4)));   // robothingies\n    \n    \n    \n    o.didHit = true;\n    o.d *= 0.8;\n    return o;\n}\n\nObject trace(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.1;\n    float t = 0.;\n    for (int i = 0; i < MARCH_ITERATIONS; i++) {\n    \tObject obj = map(p);\n        \n        if (obj.d < 0.001) {\n            obj.d = t;\n        \treturn obj;\n            break;\n        }\n        \n        if (t > 100.) {\n            obj.didHit = false;\n            return obj;\n        \tbreak;\n        }\n    \n        t += obj.d;\n        p = ro + rd*t;\n    }\n\n\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 t = vec2(0.0001,0.);    \n    return normalize(vec3(\n    \tmap(p + t.xyy).d - map(p - t.xyy).d,\n    \tmap(p + t.yxy).d - map(p - t.yxy).d,\n    \tmap(p + t.yyx).d - map(p - t.yyx).d\n    ));\n}\n\n// ----------------- MAIN ----------------- //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv -= normalize(uv)*pow(length(uv)*0.34,3.);\n    vec2 uvs = (fragCoord/iResolution.xy);\n\n    vec4 col = texture(iChannel0, uvs);\n \n    vec3 accum = vec3(0);\n    float attenuation = 1.;\n    \n    vec3 ro = vec3(0,-0.09,0.);\n    vec3 lookAt = vec3(0.,0,1);\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float seed = hash(float(iFrame) + uv.x*24.124 + uv.y*412.512);\n    \n    float dFirst = 0.;\n    \n    for (int i = 0; i < BOUNCES; i++){\n    \tObject obj = trace(ro, rd);\n        if (obj.didHit) {       \n            if (i == 0){\n                dFirst = obj.d;\n            }\n            vec3 p = ro + rd * obj.d;  \t\t\t\t\n    \t\tvec3 N = getNormal(p);\n            attenuation /= PI; // thx slerpy\n            accum += obj.material.albedo * attenuation;\n            seed += 14.5;\n            //seed = hash(float(iFrame) + uv.x*24.124 + uv.y*412.512 + float(i)*12.);\n            ro = p;\n            rd = mix(cosineDirection(seed, N),N,obj.material.metalness);\n        } else {\n            break;\n        }\n        \n    }\n    col.xyz += accum;\n    col.w = dFirst;\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RAND 1\n\n#define NUM_SAMPLES 20\n#define bdist 0.01\n\n\n#define BLUR_AMT (2.3)\n//#define FOCUS_DISTANCE (0.1 + (0.5 + sin(iTime)*0.5))\n#define FOCUS_DIV 2.\n//#define FOCUS_DISTANCE (0.1 + (FOCUS_DIV + sin(iTime)*FOCUS_DIV))\n#define FOCUS_DISTANCE (0.1)\n#define SRGBLIN\n\n#if RAND == 1\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*415125.1 + u.x *12425.125125 + u.z*12525.215215215)*124115.125235);\n}\n#elif RAND == 2\n// by Dave Hoskins\nfloat r31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\n\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// hg_sdf\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\nstruct Material {\n    vec3 albedo;\n\tfloat metalness; \n\tfloat roughness;\n};\nMaterial materials[5] = Material[](\n\tMaterial(vec3(0.)*0.001,0.2,1.), // wall\n\tMaterial(vec3(2.,1.2,0.4)*10.5,0.0,0.9), // light A\n\tMaterial(vec3(2.)*10.,0.9,0.1), // mid Sphere\n\tMaterial(vec3(0.001)*1.,0.9,0.1),\n\tMaterial(vec3(0.3,0.4,1.4)*3.5,0.9,2.0)\n);  \n\nstruct Light {\n\tvec3 colour;\n    vec3 pos;\n\tfloat intensity;\n};\nLight lights[1] = Light[](\n    Light(vec3(1.2,1.2,1), vec3(-0.,10.,0.), 0.)\n);    \n\nstruct Object {\n\tfloat d;\n    bool didHit;\n\tMaterial material;\n};\nObject omin(Object a, float bdistance, Material bmaterial) {\n    if (a.d < bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\nObject omin(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, Object b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\nObject omax(Object a, float bdistance, Material bmaterial) {\n    if (a.d > bdistance) {\n    \treturn a;\n    } else {\n    \treturn Object(bdistance, true, bmaterial);\n    }\n}\n\n\n#define NewObject Object(1e8,false,materials[0])\n\n\n\n#define PI acos(-1.)\n\n\n// by fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex;\n    fragColor.xyz /= float(iFrame);\n    fragColor.xyz = pow(fragColor.xyz,vec3(1.1,1.18,1.1));\n    fragColor.xyz = clamp(fragColor.xyz, 0. ,1.);\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545));\n} ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Depth of Field pass. Code from https://www.shadertoy.com/view/Xd3GDl\n// which is an implementation of DICE's depth of field paper\n\n//#define USE_RANDOM\nconst vec2 blurdir = vec2( 1.0, 1.0 );\n\nconst float blurdist_px = 64.0;\n\n\n//#define FOCUS_FORMULA (abs(texture(iChannel0,uv).w - 2.))\n#define FOCUS_FORMULA ((abs(texture(iChannel0,uv).w - FOCUS_DISTANCE)*BLUR_AMT ))\nconst float MULT = 4.0;\n\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvec3 sampletex( vec2 uv )\n{\n    #ifdef SRGBLIN\n    \treturn srgb2lin( texture( iChannel0, uv, -10.0 ).rgb );\n    #else\n    \treturn  texture( iChannel0, uv, -10.0 ).rgb ;\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec2 blurdir = vec2( 0.0, 1.0 );\n    vec2 blurvec = normalize(blurdir) / iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    float blurdist = FOCUS_FORMULA;\n    \n    vec2 p0 = uv - 0.5 * blurdist * blurvec;\n    vec2 p1 = uv + 0.5 * blurdist * blurvec;\n    vec2 stepvec = (p1-p0) / float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iTime))-0.5) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        vec3 smpl = sampletex(p);\n        sumcol += smpl;\n        p += stepvec;\n    }\n    sumcol /= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n    \n    \n    #ifdef SRGBLIN\n    \tfragColor = vec4( lin2srgb( sumcol * MULT ), texture( iChannel0,uv).w );\n    #else\n    \tfragColor = vec4( sumcol * MULT , texture( iChannel0,uv).w );\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}