{
    "Shader": {
        "info": {
            "date": "1466777379",
            "description": "Performing a Mobius transform and spiral zoom on a regular 2D Sierpinski pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsGXDV",
            "likes": 50,
            "name": "Mobius Sierpinski",
            "published": 3,
            "tags": [
                "mobius",
                "sierpinski"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2180
        },
        "renderpass": [
            {
                "code": "/*\n\n\tMobius Sierpinski\n\t-----------------\n\n\tApplying a Mobius transform and spiral zoom to a Sierpinski Carpet pattern.\n\n\n\tRelated examples:\n\n\t// Nice and simple.\n\tSierpinskiCarpet - jt\n\thttps://www.shadertoy.com/view/ldc3WH\n\t\n\tMobius Eggs - Shane\n\thttps://www.shadertoy.com/view/ldVXDG\n\n*/\n\n// Standard Mobius transform: f(z) = (az + b)/(cz + d). Slightly obfuscated.\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2){\n\n\tz1 = p - z1; p -= z2;\n\treturn vec2(dot(z1, p), z1.y*p.x - z1.x*p.y)/dot(p, p);\n}\n\n// Standard spiral zoom.\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase){\n\t\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283 - iTime*.25;\n\tfloat d = log(length(p));\n\treturn vec2(a*n + d*spiral, a - d*zoom) + phase;\n}\n\n// Mobius, spiral zoomed, Sierpinski Carpet pattern.\nvec3 pattern(vec2 uv){\n    \n    // A subtlely spot-lit background. Performed on uv prior to tranformation,\n    float bg = max(1. - length(uv), 0.)*.025; \n    \n    // Transform the screen coordinates. Comment out the following two lines and \n    // you'll be left with a standard Sierpinski pattern.\n    uv = Mobius(uv, vec2(-.75, cos(iTime)*.25), vec2(.5, sin(iTime)*.25));\n    uv = spiralZoom(uv, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n    \n     \n    vec3 col = vec3(bg); // Set the canvas to the background.\n    \n    // Sierpinski Carpet - Essentially, space is divided into 3 each iteration, and a \n    // shape of some kind is rendered. In this case, it's a smooth rectangle\n    // with a bit of shading around the side.\n    //\n    // There's some extra steps in there (the \"l\" and \"mod\" bits) due to the \n    // shading and coloring, but it's pretty simple.\n    //\n    // By the way, there are other combinations you could use.\n    //\n    for(float i=0.; i<4.; i++){\n        \n        uv = fract(uv)*3.; // Subdividing space.\n        \n        vec2 w = .5 - abs(uv - 1.5); // Prepare to make a square. Other shapes are also possible.\n        \n        float l = sqrt(max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.)); // Vignetting (edge shading).\n        \n        w = smoothstep(0., length(fwidth(w)), w); // Smooth edge stepping.\n        \n        vec3 lCol = vec3(1)*w.x*w.y*l; // White shaded square with smooth edges.\n        \n        if(mod(i, 3.)<.5) lCol *= vec3(0.1, 0.8, 1); // Color layers zero and three blue.\n        \n        col = max(col, lCol); // Taking the max of the four layers.\n        \n    } \n    \n    return col;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){ // my attempt to code-golf it (137chars)\n\n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Transformed Sierpinski pattern.\n    vec3 col = pattern(uv);\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(col), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}