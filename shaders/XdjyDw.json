{
    "Shader": {
        "info": {
            "date": "1492384229",
            "description": "Sorry about making another scene with spheres :) Can look around with mouse, image becomes less noisy if no mouse input.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdjyDw",
            "likes": 16,
            "name": "SomeMoreSpheres",
            "published": 3,
            "tags": [
                "raytracing",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 791
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n\treferences:\n\t---------------\t\n\thttps://iquilezles.org/articles/simplepathtracing\n\thttps://en.wikipedia.org/wiki/Path_tracing\n*/\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nconst float PI = 3.14159265;\n\nconst int SPHERES=5;\nvec3 sp[SPHERES];\nfloat spSizes[SPHERES];\nvec3 spColors[SPHERES];\n\nvec3 lp = vec3(-1.5, 1.8, 0.0); // light position\nvec3 ld = normalize(vec3(0.0, 1.0, 1.0)); // light direction\n\nconst float LIGHT_SIZE = 0.2;\nconst int GROUND = 100;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 getRandomDir(in vec3 rd, vec2 seed)\n{\n    vec3 r = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 u = cross(r, rd);\n    mat3 m; m[0] = r;m[1] = u;m[2] = rd;\n    vec3 fw = normalize(vec3(rand(seed), rand(seed.yx), 2.5)); \n    return m * fw;\n}\n\nbool traceSphere(in vec3 ro, in vec3 rd, in vec3 sp, float r, inout float t)\n{\n    float d = dot(rd, sp-ro);\n    if (d < 0.0) return false;\n    \n    vec3 x = (ro+rd*d) - sp;\n    float disc = length(x);\n    if (disc >= r) return false;\n    \n    float b = sqrt(r*r-disc*disc);\n    t = length(rd*d)-b;\n    return true;\n}\n\nbool tracePlane(in vec3 ro, in vec3 rd, in vec3 n, in float D, inout float t)\n{\n    float f = dot(rd, n);\n    if (f > 0.) return false;\n    t = -(D+dot(n, ro))/f;\n    return t >=0.;\n}\n\nbool intersectScene(in vec3 ro, in vec3 rd, inout float t, inout int ID)\n{\n    float MIN_T = 9999.0;\n    bool hitSphere = false;\n    float dist = 0.;\n    \n    for (int i = 0; i < SPHERES; ++i)\n    {\n        if (traceSphere(ro, rd, sp[i], spSizes[i], dist))\n        {\n            hitSphere = true;\n            if (dist < MIN_T) \n            { \n                MIN_T = dist; \n                ID = i;\n            }\n        }\n    }\n    \n    if (hitSphere)\n    {\n        t = MIN_T;\n    \treturn true;\n    } \n    \n    if (tracePlane(ro, rd, vec3(0.0, 1.0, 0.0), .0, t))\n    {\n        ID = GROUND;\n        return true;\n    }    \n    return false;\n}\n\n\nbool traceLight(in vec3 ro)\n{\n    float t = 0.;\n    int ID = 0;\n    float b = iTime;\n    vec3 offset = vec3(rand(ro.xz+b), rand(ro.zx+b), rand(ro.yz+b))*LIGHT_SIZE;\n    vec3 dir = normalize((lp+offset)-ro);\n    \n    if(!intersectScene(ro, dir, t, ID))\n    {\n        return traceSphere(ro, dir, lp, LIGHT_SIZE, t);\n    }\n    \n    return false;\n}\n\nvec3 getMaterialColor(int ID, in vec3 rp)\n{\n    \n    if (ID == GROUND)\n    {\n        return texture(iChannel1, ( (rp.xz+vec2(5.4, 1.0))*.1)).rgb;\n    }\n    return spColors[ID];\n}\n\nvec3 getDirectIlluminationColor(int ID, in vec3 rp)\n{\n    if(!traceLight(rp)) return vec3(.0);\n    \n    if (ID == GROUND)\n    {\n        return max(0.0, dot(ld, vec3(0.0, 1.0, 0.0)))*vec3(1.0);\n    }\n    \n    float d = max(0.0, dot(normalize(rp-sp[ID]), ld));\n    return vec3(1.0)*d;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n \tvec3 ro = rp;   \n    vec3 ord = rd;\n    float t = 0.;\n    vec3 fcol = vec3(1.0);\n    vec3 tcol = vec3(0.0);\n    \n    const int STEPS = 8; // max bounces\n    int i = 0;\n    \n    for (i = 0; i < STEPS; ++i)\n    {\n        int ID = 0;\n        \n        bool intersect = intersectScene(rp,rd, t, ID);\n        if (intersect)\n        {\n            rp += rd*t;\n            vec3 col = getMaterialColor(ID, rp);\n            vec3 dcol = getDirectIlluminationColor(ID, rp);\n\n            vec3 n = vec3(0.0, 1.0, 0.0);\n            if (ID != GROUND) n = normalize(rp-sp[ID]);\n\n            rd = getRandomDir( reflect(rd, n), float(i)*0.1+rd.xy+iTime);\n\n            fcol *= col;\n            tcol += fcol*dcol;\n        }\n        else\n        {\n            fcol *= vec3(0.2, 0.4, .75)*texture(iChannel2, rd.xz*.1).rrr;\n            tcol += fcol;\n            break;\n        }\n        \n    }\n    color.rgb = tcol;\n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 _uv = uv;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\tvec4 mouse = iMouse+vec4(iResolution.xy*vec2(-0.1, 1.0), .0, .0);\n    \n    vec2 im = 4.0 * ((mouse.xy / iResolution.xy) - vec2(0.5));\n    spSizes[0] = 0.8;\n    spSizes[1] = 0.15;\n    spSizes[2] = 0.25;\n    spSizes[3] = 0.5;\n    spSizes[4] = 0.4;\n    \n    sp[0] = vec3(.0, spSizes[0], .0);\n    sp[1] = vec3(-1.2, spSizes[1],.0);\n    sp[2] = vec3(-.9, spSizes[2], -.6);\n    sp[3] = vec3(-.2, spSizes[3], 1.4);\n    sp[4] = vec3(-1.1, spSizes[4], .6);\n    \n    spColors[0] = vec3(1.0);\n    spColors[1] = vec3(.5, .5, 0.0);\n    spColors[2] = vec3(.6, .1, 0.);\n    spColors[3] = vec3(.1, .4, 0.95);\n    spColors[4] = vec3(.2, 1., 0.);\n    \n    fragColor = vec4(1.0);\n    vec3 rp = vec3(0.0, -0., -5.0);\n    rp = roty(-im.x*2.) * rp;\n    rp.y = im.y;\n    \n    vec2 offset = vec2(rand(vec2(iTime*0.1)), rand(vec2(iTime*.4)));\n    \n    vec3 rd = normalize(vec3(uv+offset*dFdx(uv.x), 1.));\n    rd = lookat(rp, vec3(0.0, 0.5, 0.0)) * rd;\n    trace(rp, rd, fragColor);\n    \n    float convergeSpeed = iMouse.z>0.0 || iFrame < 20 ? 0.9:0.996;\n\tif (iFrame <= 1) convergeSpeed = 0.;\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, _uv).rgb, convergeSpeed);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}