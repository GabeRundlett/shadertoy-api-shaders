{
    "Shader": {
        "info": {
            "date": "1717206396",
            "description": "saw people getting real confused about this so I figured I'd give it a try myself with my naive implementation ideas. It ended up being pretty performant since it's just a whole bunch of lerps!",
            "flags": 0,
            "hasliked": 0,
            "id": "XXK3zR",
            "likes": 6,
            "name": "trilinear distortion",
            "published": 3,
            "tags": [
                "thing"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 124
        },
        "renderpass": [
            {
                "code": "#define time (iTime * .1)\n\nvec3 textureCoord;\nbool fg = false;\n\nvec3[] corners = vec3[8](\n    vec3(-1,-1,-1),\n    vec3( 1,-1,-1),\n    vec3(-1, 1,-1),\n    vec3( 1, 1,-1),\n    vec3(-1,-1, 1),\n    vec3( 1,-1, 1),\n    vec3(-1, 1, 1),\n    vec3( 1, 1, 1)\n);\n\nvec3[] acorns = vec3[8](\n    vec3(1),vec3(1),vec3(1),vec3(1),vec3(1),vec3(1),vec3(1),vec3(1)\n);\n\n#define n(x) m=min(m,x)\nfloat df(vec3 p){\n    float m = 1e9;\n    \n    n(p.z + 1.5);\n        \n    if (length(p) < 3.){\n        for (int i = 8; i-->0;){        \n            acorns[i] = corners[i]\n                + vec3(\n                    sin((time + float(i))*15.), \n                    cos((time + float(i))*7.), \n                    cos((time + float(i))*11.)\n                )*.2;\n\n            n(\n                length(\n                    p \n                    - acorns[i]\n                )-.2\n            );\n        }\n\n        // Too lazy to figure out the inverse, so gradient descent!\n        // Plus I've heard it's tricky and I'm not too great at math\n        vec3 coord = vec3(.5), interp, a,b,c,d,e,f;\n        for (int i = 0; i++<2;){ // two iterations are sufficient to be incredibly close.\n                                // but it's kinda just one iteration because the first loop\n                               // is essentially an identity lol\n            a = mix(acorns[0], acorns[1], coord.x);\n            b = mix(acorns[2], acorns[3], coord.x);\n            c = mix(acorns[4], acorns[5], coord.x);\n            d = mix(acorns[6], acorns[7], coord.x);\n            e = mix(a, b, coord.y);\n            f = mix(c, d, coord.y);\n            interp = mix(e, f, coord.z);\n\n            coord += (p - interp)*.5;\n\n        }\n\n        p = coord*2.-1.;\n        textureCoord = coord*2.;\n        //*\n        float x = min(\n            length(p) - .5,\n            max(\n                max(abs(p.x), max(abs(p.y), abs(p.z)))-1.,\n                -length(p)+1.2\n            )\n        );\n        if (x < m){\n            if (x < 1e-2){\n                fg = true;\n            } else {\n                fg = false;\n            }\n            m = x;\n        }\n        //*/\n\n    } else {\n        n(length(p) - 2.8);\n    }\n    \n\n    \n    return m;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = (2.*iMouse.xy-r)/r.y;\n    if (iMouse.xy == vec2(0)) muv = vec2(iTime*.2, .1);\n    \n    vec3 dir = vec3(sin(muv.x)*cos(muv.y), cos(muv.x)*cos(muv.y), sin(muv.y));\n    vec3 rgt = normalize(cross(dir, vec3(0,0,1)));\n    vec3 upw = cross(rgt, dir);\n    vec3 dirV = normalize(dir*5. + rgt * cuv.x + upw * cuv.y);\n    \n    vec3 o = -dir * 11.;\n    \n    \n    int steps = 512;\n    float d, t;\n    vec3 p = o;\n    for(;steps-->0;){\n        p = o + dirV * t;\n        d = df(p);\n        t += d;\n        if (d < 1e-2) steps--;\n    }\n    \n    //O.xyz = p;\n    vec3 pos = fg?textureCoord*4.-1e-4:p;\n    //O.xyz = textureCoord;\n    //O = vec4(fg);\n    \n    \n    O = vec4(\n        mod(floor(pos.x) + floor(pos.y) + floor(pos.z), 2.)\n    );\n    O *= exp(-t/5.+2.);\n    \n    p *= .5;\n    if (pos.z < -1.4) O *= 1.-.5/(1.+p.x*p.x+p.y*p.y);\n    \n    if (fg) O = mix(O, textureCoord.xyzz*.5, sin(iTime)*.5+.5);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.14159265\n#define phi 1.6180339887\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n} //hash by IQ https://www.shadertoy.com/view/XlXcW4\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}