{
    "Shader": {
        "info": {
            "date": "1672608140",
            "description": "CC0 : Matrix maelstrom\nCode is a bit of a mess, lots of hacking without thought and some lingering alias effects\nStill... want to get something out before bed.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlsGDf",
            "likes": 48,
            "name": "Matrix maelstrom",
            "published": 3,
            "tags": [
                "2d",
                "matrix"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 638
        },
        "renderpass": [
            {
                "code": "// CC0 : Matrix maelstrom\n//  Code is a bit of a mess, lots of hacking without thought and some lingering alias effects\n//  Still... want to get something out before bed.\n\n//#define CURSOR\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3  bcol        = vec3(0., 1.0, 0.25)*0.8;\n\nconst float logo_radius = 0.25;\nconst float logo_off    = 0.25;\nconst float logo_width  = 0.10;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\nvoid spiralMod(inout vec2 p, float a) {\n  vec2 op     = p;\n  float b     = a/TAU;\n  float  rr   = length(op);\n  float  aa   = atan(op.y, op.x);\n  rr         -= aa*b;\n  float nn    = mod1(rr, a);\n  float sa    = aa + TAU*nn;\n  float sl    = spiralLength(b, sa);\n  p           = vec2(sl, rr);\n}\n\nfloat dsegmentx(vec2 p, vec2 dim) {\n  p.x = abs(p.x);\n  float o = 0.5*max(dim.x-dim.y, 0.0);\n  if (p.x < o) {\n    return abs(p.y) - dim.y;\n  }\n  return length(p-vec2(o, 0.0))-dim.y;\n}\n\nvec3 digit(vec3 col, vec2 p, vec3 acol, vec3 icol, float aa, float n, float t) {\n  const int[16] digits = int[16](\n    0x7D // 0\n  , 0x50 // 1\n  , 0x4F // 2\n  , 0x57 // 3\n  , 0x72 // 4\n  , 0x37 // 5\n  , 0x3F // 2\n  , 0x51 // 7\n  , 0x7F // 8\n  , 0x77 // 9\n  , 0x7B // A\n  , 0x3E // B\n  , 0x2D // C\n  , 0x5E // D\n  , 0x2F // E\n  , 0x2B // F\n  ); \n  const vec2 dim = vec2(0.75, 0.075);\n  const float eps = 0.1;\n  vec2 ap = abs(p);\n  if (ap.x > (0.5+dim.y+eps)) return col;\n  if (ap.y > (1.0+dim.y+eps)) return col;\n  float m = mod(floor(n), 16.0);\n  int digit = digits[int(m)];\n\n  vec2 cp = (p-0.5);\n  vec2 cn = round(cp);\n\n  vec2 p0 = p;\n  p0.y -= 0.5;\n  p0.y = p0.y-0.5;\n  float n0 = round(p0.y);\n  p0.y -= n0;\n  float d0 = dsegmentx(p0, dim);\n\n  vec2 p1 = p;\n  vec2 n1 = sign(p1); \n  p1 = abs(p1);\n  p1 -= 0.5;\n  p1 = p1.yx;\n  float d1 = dsegmentx(p1, dim);\n  \n  vec2 p2 = p;\n  p2.y = abs(p.y);\n  p2.y -= 0.5;\n  p2 = abs(p2);\n  float d2 = dot(normalize(vec2(1.0, -1.0)), p2);\n\n  float d = d0;\n  d = min(d, d1);\n\n  float sx = 0.5*(n1.x+1.0) + (n1.y+1.0);\n  float sy = -n0;\n  float s  = d2 > 0.0 ? (3.0+sx) : sy;\n  // Praying bit shift operations aren't TOO slow\n  vec3 scol = ((digit & (1 << int(s))) == 0) ? icol : acol;  \n\n  col = mix(col, scol, smoothstep(aa, -aa, d)*t);\n  return col;\n}\nvec3 digit(vec3 col, vec2 p, vec3 acol, vec3 icol, float n, float t) {\n  vec2 aa2 = fwidth(p);\n  float aa = max(aa2.x, aa2.y);\n  return digit(col, p, acol, icol, aa, n, t);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash2(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0 - exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(vec2 p, float aa) {\n  vec2  p1 = p-vec2(logo_off, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = atan_approx(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_off, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = atan_approx(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 clogo(vec2 p, float aa, out float d) {\n  const mat2 rot0 = ROT(PI/4.0);\n  const mat2 rot1 = ROT(5.0*PI/4.0);\n\n//#define SINGLE8\n\n  float sgn = sign(p.y);\n#if !defined(SINGLE8)\n  p *= sgn;\n#endif\n  vec4 s0 = figure_8(p, aa);\n  vec4 s1 = figure_8(p*rot0, aa);\n  vec4 s2 = figure_8(p-vec2(-0.5, 0.0), aa);\n  vec4 s3 = figure_8(p*rot1, aa);\n  \n  // This is very hackish to get it to look reasonable\n  \n  const float off = -PI;\n  s1.z -= off;\n  s3.z -= off;\n  \n  vec4 s = s0;\n#if !defined(SINGLE8)\n  s = merge(s, s1);\n  s = merge(s, s2);\n  s = merge(s, s3);\n#endif\n\n  d = s.w;\n  return vec4(mix(0.025*bcol, bcol, s.x), s.y);\n}\n\nvec3 logoEffect(vec3 col, vec2 p, vec2 pp, float aa) {\n  float d;\n  vec4 ccol = clogo(p, aa, d);\n\n  const float period = TAU*10.0;\n  float ss = sin(period*d-TIME*TAU/10.0);\n  const float off = 0.2;\n  float doff = period*aa*cos(off); \n//  col = mix(col, col*0.125, smoothstep(doff, -doff, abs(ss)-off));\n  col = mix(col, ccol.xyz, ccol.w);\n  return col;\n}\n\nvec3 spiralEffect(vec3 col, vec2 p, vec2 pp, float aa) {\n  vec2 sp = p;\n  spiralMod(sp, .5);\n\n  vec2 dp = sp;\n  float dz = 0.0125;\n  dp /= dz;\n  aa /= dz;\n  float dny = mod1(dp.y, 3.06);\n  float dhy = hash(dny+1234.5);\n  dp.x = -dp.x;\n  float ltm = (TIME+1234.5)*mix(2.0, 10.0, (dhy))*0.125;\n  dp.x -= ltm;\n  float opx = dp.x;\n  float dnx = mod1(dp.x, 1.5);\n  const float stepfx = 0.125*0.25;\n  float fx  = -2.0*stepfx*ltm+stepfx*dnx;\n  float fnx = floor(fx);\n  float ffx = fract(fx);\n  float dht = hash(fnx);\n  float dhx = hash(dnx);\n  float dh  = fract(dht+dhx+dhy);\n  \n  float l = length(p);\n  float t = smoothstep(0.4, 0.5, l);\n\n  const vec3 hcol = clamp(1.5*sqrt(bcol)+vec3(0.2), 0.0, 1.0);\n  const vec3 acol = bcol;\n  const vec3 icol = acol*0.1;\n  \n  float fo = (smoothstep(0.0, 1.0, ffx));\n  float ff = smoothstep(1.0-2.0*sqrt(stepfx), 1.0, ffx*ffx);\n  col = digit(col, dp, mix(acol, hcol, ff), icol, aa, 100.0*dh, fo*t);\n\n#if defined(CURSOR)\n  float fc = smoothstep(1.0-stepfx, 1.0, ffx);\n  const float rb = 0.2;\n\n  float db = box(dp, vec2(0.5, 1.0))-rb;\n  \n  col = mix(col, mix(col, hcol, 0.33*fc*fc), smoothstep(aa, -aa, db)*t);\n#endif\n\n  return col;\n}\n\nvec3 glowEffect(vec3 col, vec2 p, vec2 pp, float aa) {\n  float d = length(p);\n  col += 0.25*bcol*exp(-9.0*max(d-2.0/3.0, 0.0));\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 col  = vec3(0.0);\n  col = spiralEffect(col, p, pp, aa);\n  col = glowEffect(col,p, pp, aa);\n  col = logoEffect(col, p*ROT(-0.05*TIME), pp, aa);\n  col *= smoothstep(1.25, 0.5, length(pp));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);  \n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}