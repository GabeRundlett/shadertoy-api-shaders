{
    "Shader": {
        "info": {
            "date": "1706044385",
            "description": "Intro to symm\nwait for transitions ",
            "flags": 8,
            "hasliked": 0,
            "id": "lfB3RD",
            "likes": 29,
            "name": "Intro SYMM",
            "published": 3,
            "tags": [
                "neonsoundsynthsynthwavesynthgalaxyreflection"
            ],
            "usePreview": 1,
            "username": "User228",
            "viewed": 879
        },
        "renderpass": [
            {
                "code": "// Includes and constants\n#define PI          3.141592654\n#define HSV2RGB_K  vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0)\n#define HSV2RGB(c) (c.z * mix(HSV2RGB_K.xxx, clamp(abs(fract(c.xxx + HSV2RGB_K.xyz) * 6.0 - HSV2RGB_K.www) - HSV2RGB_K.xxx, 0.0, 1.0), c.y))\nconst ivec2 char_I = ivec2(-2130247680, 470818880);\nconst ivec2 char_M = ivec2(608731136, 577546578);\nconst ivec2 char_O = ivec2(608632832, 474253586);\nconst ivec2 char_S = ivec2(71761920, 474220770);\nconst ivec2 char_Y = ivec2(-2130575360, 574902336);\n\nivec2 text_box_chars = ivec2(62, 16);\n\nfloat draw_char(vec2 coord, ivec2 char) {\n    int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;\n    int num = pos_id < 32 ? char.x : char.y;\n    int val;\n\n    if(pos_id < 32) {\n        val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));\n    } else {\n        // Handle the case where pos_id is greater than or equal to 32\n        // by using a different bit manipulation technique.\n        int shifted_pos_id = pos_id - 32;\n        int pow_val = int(pow(2.0, float(shifted_pos_id)));\n        val = (num / pow_val);\n        val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1\n    }\n\n    float col = val == 0 ? 0.0 : 1.0;\n\n    return col;\n}\n\nvec3 draw_text(vec2 coord, vec2 pos) {\n    coord += pos;\n    coord *= 2.0;\n    int charIndex = int(coord.x);\n    coord.x -= float(int(coord.x));\n\n    ivec2 text_string_2[7];\n    ivec2 current_char = text_string_2[0]; // Initialize with a default character\n\n    if(charIndex == 1)\n        current_char = ivec2(char_S);\n    else if(charIndex == 2)\n        current_char = ivec2(char_Y);\n    else if(charIndex == 3)\n        current_char = ivec2(char_M);\n    else if(charIndex == 4)\n        current_char = ivec2(char_M);\n    else if(charIndex == 5)\n        current_char = ivec2(char_I);\n    else if(charIndex == 6)\n        current_char = ivec2(char_O);\n\n    // Calculate the color for the character and return it as a vec3.\n    return vec3(draw_char(coord, current_char));\n}\n\nfloat scoreTime() {\n    return iTime - 4.;\n}\nfloat drumTime() {\n    return iTime - 4. - 8. * beatdur;\n}\nfloat timeSinceKick() {\n    float t = drumTime();\n    return (t > 0.) ? mod(t, 2. * beatdur) : 20.;\n}\nfloat timeSinceSnare() {\n    float t = drumTime() - beatdur;\n    return (t > 0.) ? mod(t, 2. * beatdur) : 20.;\n}\nvec4 Noise(in ivec2 x) {\n    return texture(iChannel0, (vec2(x) + 0.5) / 256.0, -100.0);\n}\nvec2 lensDistortion(vec2 p, float dist) {\n    return (dist > 0.) ? p * (1. + dist * length(p)) : p / (1. - dist * length(p));\n}\n\n// Function for rendering the outer sky\nvec3 outerSkyRender(vec3 rd, vec2 uv) {\n// Sun direction and color\n    float intensity = 1. + 5.*exp(-5.*timeSinceKick());\n\n    vec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));\n    vec3 sunCol = HSV2RGB(vec3(0.01, 0.5, 0.0002 * smoothstep(1.0, 4.0, iTime) + (intensity * 0.0001)));\n\n    vec3 col = HSV2RGB(vec3(0.5, 0.00, 0.004));\n   // Arpeggio animation\n\n    for(float i = 0.; i < 17.; i++) {\n\n        float timeSinceArpUp = mod(scoreTime() - i * 0.125 * beatdur, 4. * beatdur);\n        float timeSinceArpDown = mod(scoreTime() - 4. * beatdur + i * 0.125 * beatdur, 4. * beatdur);\n        float timeSinceNote = min(timeSinceArpUp, timeSinceArpDown);\n        timeSinceNote = (scoreTime() >= i * 0.125 * beatdur) ? timeSinceNote : 10.;\n\n        intensity = 1. * exp(-10. * timeSinceNote) + exp(-8. * timeSinceNote);\n        float d = length(uv + vec2(1.62, 0.0) - vec2(0., 0.05 * (i - 8.))) - 0.01;\n        d = min(d, length(uv + vec2(-1.62, 0.0) - vec2(0., 0.05 * (i - 8.))) - 0.01);\n\n        col += intensity * smoothstep(0.01, 0.0, d) * vec3(1.0, 0.5, 0.5) * 2.;\n        col += intensity * smoothstep(0.0, 0.01, d) * vec3(1.0, 0.5, 0.5) * 0.001 / (d * d + 0.01);\n    }\n\n  // Sun add to col\n    col += sunCol / pow((1.002 - dot(sunDir, rd)), 1.9);\n\n  // Horizon light modifier\n    vec3 gcol = HSV2RGB(vec3(1.0, 0.4, 0.001 * smoothstep(1.0, 4.0, iTime) + intensity * 0.0005));\n\n  // Atmosphere air color\n    col += HSV2RGB(vec3(0.97, 0.0, 0.1 * smoothstep(1.0, 4.0, iTime)));\n  // add glow to sky\n    col += gcol / max(abs(rd.y), 0.0);\n\n  // add stars to sky\n    vec3 ray = vec3(2.0 * rd.xy, 1.0);\n    float offset = iTime * 0.06;\n    float speed = 0.2;\n    vec3 stp = ray / max(abs(ray.x), abs(ray.y));\n    vec3 pos = stp + 0.5;\n    for(int i = 0; i < 10; i++) {\n        vec2 noise = Noise(ivec2(pos.xy)).xy;\n        float z = fract(noise.x - offset);\n        float d = 20.0 * smoothstep(1.0, 4.0, iTime) * z - pos.z;\n        float w = pow(max(0.0, 1.0 - 2.0 * length(fract(pos.xy) - 0.5)), 15.0);\n        vec3 c = max(vec3(0), vec3(1.0 - abs(d + speed * 0.5) / speed, 1.0 - abs(d) / speed, 1.0 - abs(d) / speed));\n        col += (1.0 - z) * c * w;\n        pos += stp;\n    }\n\n    return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 dim) {\n  vec3 ce = dim.xyz;\n  float ra = dim.w;\n  vec3 oc = ro - ce;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - ra*ra;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0); // no intersection\n  h = sqrt( h );\n  return vec2( -b-h, -b+h );\n}\n\nfloat heightFactor(vec2 p) {\n  return 4.0*smoothstep(7.0, 0.5, abs(p.x))+.5;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\nfloat hifbm(vec2 p) {\n  p *= 0.25;\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nfloat hiheight(vec2 p) {\n  return hifbm(p);\n}\nfloat lofbm(vec2 p) {\n  p *= 0.25;\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\nfloat loheight(vec2 p) {\n  return lofbm(p)-0.5;\n}\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length(pa - ba*h);\n}\n\nconst float mountainPos = -30.0;\n\n\nvec3 mountainRender(vec3 col, vec3 ro, vec3 rd, bool flip) {\nvec3 sunDir= normalize(vec3(0.0, 0.25, 1.0));\n\n  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));\n  const vec4 tpdim = vec4(tpn, mountainPos);\n  float tpd = rayPlane(ro, rd, tpdim);\n\n\n  vec3 pp = ro+rd*tpd;\n  vec2 p = pp.xy;\n  const float cw = 1.0-0.25;\n  float hz = 0.0*iTime+1.0;\n  float lo = loheight(vec2(p.x, hz));\n  vec2 cp = p;\n  float cn = mod1(cp.x, cw);\n\n\n  const float reps = 1.0;\n\n  float d = 1E3;\n\n  for (float i = -reps; i <= reps; ++i) {\n    float x0 = (cn -0.5 + (i))*cw;\n    float x1 = (cn -0.5 + (i + 1.0))*cw;\n  \n    float y0 = hiheight(vec2(x0, hz));\n    float y1 = hiheight(vec2(x1, hz));\n    \n    float dd = segment(cp, vec2(-cw*0.5 + cw * float(i), y0), vec2(cw*0.5 + cw * float(i), y1));\n    \n    d = min(d, dd);\n  }\n\n  vec3 mcol = col;\n  float aa = fwidth(p.y);\n  if ((dFdy(d) < 0.0) == !flip) {\n    mcol *= mix(0.0, 1.0, smoothstep(aa, -aa, d-aa));\n    mcol += HSV2RGB(vec3(0.0, 0.35, 0.0))*smoothstep(0.0, 5.0, lo-p.y);\n    col = mcol;\n  }\n  vec3 rcol = HSV2RGB(vec3(clamp((0.5*(rd.x)), 0.0, 0.008), 0.75, 0.125));\n\n  float sd = 1.0001-((dot(sunDir, rd)));\n\n\n  col += rcol/(abs(d)+0.002+800.*sd*sd* timeSinceKick()/5.0);\n\n  return col;  \n}\n vec3 skyCol       = HSV2RGB(vec3(0.58, 0.86, 1.0));\n vec3 sunDir2      = normalize(vec3(0., 0.82, 1.0));\n\nvec3 skyRender(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col += 0.025*skyCol;\n  col += skyCol*0.0033/pow((1.001+((dot(sunDir2, rd)))), 2.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += (0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\nconst vec3 speCol1      = HSV2RGB(vec3(0.60, 0.25, 1.0));\nconst vec3 speCol2      = HSV2RGB(vec3(0.55, 0.25, 1.0));\nconst vec3 diffCol1     = HSV2RGB(vec3(0.60, 0.90, 1.0));\nconst vec3 diffCol2     = HSV2RGB(vec3(0.55, 0.90, 1.0));\n\nvec4 sphere(vec3 ro, vec3 rd, vec4 sdim) {\n  vec2 si = raySphere(ro, rd, sdim);\n  \n  vec3 nsp = ro + rd*si.x;\n\n  const vec3 lightPos1   = vec3(0.0, 10.0, 10.0);\n  const vec3 lightPos2   = vec3(0.0, -80.0, 10.0);\n  \n  vec3 nld1   = normalize(lightPos1-nsp); \n  vec3 nld2   = normalize(lightPos2-nsp); \n  \n  vec3 nnor   = normalize(nsp - sdim.xyz);\n\n  vec3 nref   = reflect(rd, nnor);\n\n  const float sf = 4.0;\n  float ndif1 = max(dot(nld1, nnor), 0.0);\n  ndif1       *= ndif1;\n  vec3 nspe1  = pow(speCol1*max(dot(nld1, nref), 0.0), sf*vec3(1.0, 0.8, 0.5));\n\n  float ndif2 = max(dot(nld2, nnor), 0.0);\n  ndif2       *= ndif2;\n  vec3 nspe2  = pow(speCol2*max(dot(nld2, nref), 0.0), sf*vec3(0.9, 0.5, 0.5));\n\n  vec3 nsky   = skyRender(nsp, nref);\n  float nfre  = 1.0+dot(rd, nnor);\n  nfre        *= nfre;\n\n  vec3 scol = vec3(0.0); \n  scol += nsky*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);\n  scol += diffCol1*ndif1;\n  scol += diffCol2*ndif2;\n  scol += nspe1;\n  scol += nspe2;\n  \n  float t = tanh_approx(2.0*(si.y-si.x)/sdim.w);\n  \n  return vec4(scol, t);\n}\n\nvec3 sphereRender(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyRender(ro, rd);\n  vec3 col = skyCol;\n  const vec4 sdim0 = vec4(vec3(0.0), 2.0);\n  vec4 scol0 = sphere(ro, rd, sdim0);\n  col = mix(col, scol0.xyz, scol0.w);\n  return col;\n}\n\nvec3 sphereEffect(vec2 p) {\n  const float fov = tan(TAU/6.0);\n  const vec3 ro = 1.0*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = sphereRender(ro, rd);\n  \n  return col;\n}\n\n\nvec3 cityOfKali(vec2 p) {\n  vec2 c = -vec2(0.5, 0.5)*1.12;\n\n  float s = 2.0;\n  vec2 kp = p/s;\n \n  const float a = PI/4.0;\n  const vec2 n = vec2(cos(a), sin(a));\n\n  float ot2 = 1E6;\n  float ot3 = 1E6;\n  float n2 = 0.0;\n  float n3 = 0.0;\n\n  const float mx = 12.0;\n  for (float i = 0.0; i < mx; ++i) {\n    float m = (dot(kp, kp));\n    s *= m;\n    kp = abs(kp)/m + c;\n    float d2 = (abs(dot(kp,n)))*s;\n    if (d2 < ot2) {\n      n2 = i;\n      ot2 = d2;\n    }\n    float d3 = (dot(kp, kp));\n    if (d3 < ot3) {\n      n3 = i;\n      ot3 = d3;\n    }\n  }\n  vec3 col = vec3(0.0);\n  n2 /= mx;\n  n3 /= mx;\n  col += 0.15*(HSV2RGB(vec3(0.0, 0.90, 0.025)));\n  col += HSV2RGB(vec3(0.0, 0.85, 0.00000025))/(ot3*ot3+0.000000025);\n  return col;\n}\n#define PI_2        (0.5*PI)\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan_approx(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n \n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\nvec3 outerSkyRender2(vec3 ro, vec3 rd) {\n vec3 sunCol = HSV2RGB(vec3(0.01, 0.5, 0.0002 * smoothstep(1.0, 4.0, iTime) ));\n  vec3 center = ro+vec3(-100.0, 40.0, 100.0);\n  vec4 sdim = vec4(center, 50);\n  vec2 pi = raySphere(ro, rd, sdim);\n  const vec3 pn = normalize(vec3(0., 1.0, -0.8));\n  vec4 pdim = vec4(pn, -dot(pn, center)); \n  float ri = rayPlane(ro, rd, pdim);\n\n  vec3 col = vec3(0.0);\n  vec3 sunDir= normalize(vec3(0.0, 0.1-sin(iTime/5.)/3.0, 1.0));\n  //atmosphere light\n   col += HSV2RGB(vec3(0.97, 0.0, 0.1 * smoothstep(1.0, 4.0, iTime)));\n\n  col += sunCol/pow((1.001-((dot(sunDir, rd)))), 2.0);\n\n  if (pi.x != -1.0) {\n    vec3 pp = ro + rd*pi.x;\n    vec3 psp= pp-sdim.xyz;\n    vec3 pn = normalize(pp-sdim.xyz);\n    psp = psp.zxy;\n    psp.yz *= ROT(-0.5);\n    psp.xy *= ROT(0.025*iTime);\n    vec3 pss= toSpherical(psp);\n    vec3 pcol = vec3(0.0);\n    float dif = max(dot(pn, sunDir), 0.0);\n    vec3 sc = 2000.0*sunCol;\n    pcol += sc*dif;\n    pcol += (cityOfKali(pss.yz))*smoothstep(0.125, 0.0, dif);\n    pcol += pow(max(dot(reflect(rd, pn), sunDir), 0.0), 9.0)*sc;\n    col = mix(col, pcol, tanh_approx(0.125*(pi.y-pi.x)));\n    \n  }\n\n  vec3 gcol = vec3(0.0);\n\n  vec3 rp = ro + rd*ri;\n  float rl = length(rp-center);\n  float rb = 1.55*sdim.w;\n  float re = 2.45*sdim.w;\n  float rw = 0.1*sdim.w;\n\n\n  col += gcol/max(abs(rd.y), 0.0033);\n\nreturn col;\n}\n\n\n// Function to calculate the value of an equilateral triangle\nfloat equilateralTriangle(vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if(p.x + k * p.y > 0.0)\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\n// Function for rendering the triangle\nvec3 triRender(vec3 col, vec3 ro, vec3 rd) {\n  // Triangle fill color\n    vec3 fillColor = vec3(0.005, 0.0, 0.0);\n\n  // Triangle calculations\n    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);\n    float tpd = rayPlane(ro, rd, tpdim);\n    vec3 pp = ro + rd * tpd;\n    vec2 p = pp.xy;\n    p.y -= 1.1730;\n\n    // Triangle resize\n    p *= 0.5;\n  // Triangle y offset\n\n  // Triangle inner glow factor\n    float hoff = dot(sin(iTime), p.y);\n    vec3 gcol = HSV2RGB(vec3(0.003, 0.8, hoff*0.01));\n  // Triangle displacement\n    float dt = equilateralTriangle(p);\n\n  // Triangle to scene visibility ratio\n    col = dt < 0.0 ? fillColor : col;\n\n  // Triangle edge glow modification\n    col += (gcol / max(abs(dt), 0.002));\n    \n    return col;\n}\n\n// Function for rendering the ground\nvec3 groundRender(vec3 col, vec3 ro, vec3 rd, vec2 p) {\n    const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));\n    const vec4 gpdim = vec4(gpn, 0.0);\n    float gpd = rayPlane(ro, rd, gpdim);\n\n    if(gpd < 0.0) {\n        return col;\n    }\n\n  // Tiles reflection modifier\n    vec3 gp = ro + rd * gpd;\n    float gpfre = 1.15 + dot(rd, gpn);\n    gpfre *= gpfre;\n    gpfre *= gpfre;\n\n    vec3 grr = reflect(rd, gpn);\n\n    vec2 ggp = gp.xz;\n    ggp.y += iTime * 0.5;\n    float dfy = dFdy(ggp.y);\n    float gcf = sin(ggp.x) * sin(ggp.y);\n    vec2 ggn;\n\n  // Calculate the modulus\n    vec2 c = floor(ggp);\n    ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);\n    ggn = c;\n\n    float ggd = min(abs(ggp.x), abs(ggp.y));\n\n  // Tiles lines color modifier\n    vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005 * smoothstep(1.0, 4.0, iTime) + exp(-18. * timeSinceSnare()) * 0.01));\n\n    vec3 rcol = outerSkyRender(grr, p);\n    rcol = triRender(rcol, gp, grr);\n\n  // Tiles calculations\n    col = gcol / max(ggd, 0.0 + 0.25 * dfy) * exp(-0.25 * gpd);\n\n  // Ground horizon reflection color filter\n    rcol += HSV2RGB(vec3(0.0, 0.0, 0.0));\n  // Ground reflection factor\n    col += rcol * gpfre / 2.0;\n\n    return col;\n}\n// Function for rendering the triangle\nvec3 triRender2(vec3 col, vec3 ro, vec3 rd) {\n  // Triangle fill color\n    vec3 fillColor = vec3(0.005, 0.0, 0.0);\n\n  // Triangle calculations\n    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);\n    float tpd = rayPlane(ro, rd, tpdim);\n    vec3 pp = ro + rd * tpd;\n    vec2 p = pp.xy;\n    p.y -= 2.05;\n    p.x -= 5.0;\n\n    // Apply rotation to the triangle around its center\n    float rotationAngle = iTime/8.0; // You can modify this based on your time needs\n    mat2 rotationMatrix = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle));\n    p = rotationMatrix * p; // Rotate\n\n    // Triangle resize\n    p *= 0.65;\n  // Triangle y offset\n    float angle = iTime; // You can adjust the speed by multiplying iTime with a constant\n    float radius = 1.0;  // Adjust the radius as needed\n  // Triangle inner glow factor\n    float x = cos(angle) * radius;\n    float y = sin(angle) * radius;\n\n    float hoff = dot(x, p.x) + dot(y, p.y);\n    vec3 gcol = HSV2RGB(vec3(0.01, 0.7, hoff*0.01));\n  // Triangle displacement\n    float dt = equilateralTriangle(p);\n\n  // Triangle to scene visibility ratio\n    col = dt < 0.0 ? fillColor : col;\n\n  // Triangle edge glow modification\n    col += (gcol / max(abs(dt), 0.002));\n    return col;\n}\n\n// Function for rendering the ground\nvec3 groundRender2(vec3 col, vec3 ro, vec3 rd, vec2 p) {\n   const vec3 gpn = normalize(vec3(0.0, 2.0, 0.01));\n    const vec4 gpdim = vec4(gpn, 0.0);\n    float gpd = rayPlane(ro, rd, gpdim);\n\n    if(gpd < 0.0) {\n        return col;\n    }\n\n  // Tiles reflection modifier\n    vec3 gp = ro + rd * gpd;\n    float gpfre = 1.15 + dot(rd, gpn);\n    gpfre *= gpfre;\n\n    vec3 grr = reflect(rd, gpn);\n    vec2 ggp = gp.xz;\n    ggp.y += iTime * 0.5;\n\n    float dfy = dFdy(ggp.y);\n    float gcf = sin(ggp.x+1.1) * sin(ggp.y);\n    vec2 ggn;\n\n  // Calculate the modulus\n    vec2 c = floor(ggp);\n    ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);\n    ggn = c;\n\n    float ggd = min(abs(ggp.x), abs(ggp.y));\n\n  // Tiles lines color modifier\n    vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005 * smoothstep(1.0, 4.0, iTime) + exp(-18. * timeSinceSnare()) * 0.01));\n\n    vec3 rcol = outerSkyRender2(gp, grr);\n    rcol = mountainRender(rcol, gp, grr, true);;\n\n    rcol = triRender2(rcol, gp, grr);\n\n  // Tiles calculations\n    col = gcol / max(ggd, 0.0 + 0.25 * dfy) * exp(-0.25 * gpd);\n\n  // Ground horizon reflection color filter\n    rcol += HSV2RGB(vec3(0.0, 0.0, 0.0));\n  // Ground reflection factor\n    col += rcol * gpfre / 2.0;\n\n    return col;\n}\nvec3 sceneOne(vec2 uv) {\n    float dist = 1.0 * smoothstep(4.0, 0.0, iTime);\n    // \"Acceleration effect\": distort picture on riser\n    float riserTime = (scoreTime() - 40. * beatdur) / (7. * beatdur);\n    riserTime = clamp(riserTime, 0., 1.);\n    dist += riserTime * (1. - 0.167 / (1. - riserTime));\n    uv = lensDistortion(uv, dist);\n\n    const float fov = 2.0;\n    // Camera location\n    vec3 ro = 1.0 * vec3(0.0, 0.5, -22.0 + (iTime * 0.3) + smoothstep(1.0, 4.0, iTime) * 10.0);\n     // Camera look at\n    vec3 la = vec3(0.0, 1.5, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n  // camera coordinate system\n    vec3 ww = normalize(la - ro);\n    vec3 uu = normalize(cross(up, ww));\n    vec3 vv = cross(ww, uu);\n  // ray direction\n    vec3 rd = normalize(-uv.x * uu + uv.y * vv + fov * ww);\n      // Rendering process\n    vec3 col = outerSkyRender(rd, uv);\n    col = groundRender(col, ro, rd, uv);\n    col = triRender(col, ro, rd);\n\n\n    return col * smoothstep(1.0, 4.0, iTime);\n\n}\nvec3 sceneTwo(vec2 uv) {\n\n    const float fov = 2.0;\n    // Camera location\n    vec3 ro = 1.0 * vec3(2.0, 0.5, -15.0 + smoothstep(1.0, 4.0, iTime) * 10.0);\n     // Camera look at\n    vec3 la = vec3(0.0, 1.5, 100.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n  // camera coordinate system\n    vec3 ww = normalize(la - ro);\n    vec3 uu = normalize(cross(up, ww));\n    vec3 vv = cross(ww, uu);\n  // ray direction\n    vec3 rd = normalize(-uv.x * uu + uv.y * vv + fov * ww);\n      // Rendering process\n    vec3 col = outerSkyRender2(ro, rd);\n         col = mountainRender(col, ro, rd, false);\n\n    col = groundRender2(col, ro, rd, uv);\n    col = triRender2(col, ro, rd);\n\n    return col * smoothstep(1.0, 4.0, iTime);\n\n}\n// Main image rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n  // Convert and adjust pixel coordinates\n    float dist = 1.0 * smoothstep(4.0, 0.0, iTime);\n\n    uv = lensDistortion(uv, dist);\n\n    vec3 col = sceneOne(uv);\n    if(scoreTime() > 47. * beatdur) {\n        // Fade from white to black on clap\n        float tClap = scoreTime() - 47. * beatdur;\n        col = col = draw_text(uv, vec2(2.0, 0.4)) * exp(-8. * tClap) * smoothstep(1., 0., tClap);\n    }\n    if(scoreTime() > 48. * beatdur) {\n        col = sceneTwo(uv);\n    }\n\n    // Time varying pixel color\n  // Set the final pixel color\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Notations :\n// t = absolute time in seconds\n// tb = time in beats\n// te = time in seconds since start of envelope\n\n#define TAU (2.*3.1415926)\n\n// ESin --- Exponentially-decaying sine wave\n//     f: frequency\n//     d: decay rate\n#define ESin(f,d) sin(TAU*(f)*t)*exp(-d*t)\n\n#define midiratio(x) exp2((x)/12.)\n#define midicps(x) (440.*midiratio((x)-69.))\n\nconst float bpm = 100.;\nconst float bps = bpm/60.; // beats per second\nconst float beatdur = 1./bps; // beat duration\n\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*vec2(noise(t*df),noise(-1000.-t*df));\n}\n\nfloat sweep(float t, float dur)\n{\n    // Exponential sweep from 20kHz to 20Hz in \"dur\" seconds\n    // Running freq: 20000*exp(-t/dt)\n    // freq=20 at t=dur  ==>  20 = 20000*exp(-dur/dt)\n    //                   ==>  exp(-dur/dt) = 1/1000\n    //                   ==>  -dur/dt = log(1/1000)\n    //                   ==>  dt = dur/log(1000)\n    float dt = dur/log(1e3);\n    float intfreq = 20000.*exp(-t/dt)*dt;\n    float phase = TAU*fract(intfreq);\n    float sig = sin(phase);\n    float env = step(0., t) * smoothstep(dur, 0.7*dur, t);\n    return sig*env*0.1;\n}\n\n\nfloat triBipolar(float x)\n{\n    // Triangle wave going from -1 to +1, starting at zero, 4-periodic.\n    return 1. - abs(2.-mod(x+1.,4.));\n}\n\n\nfloat triUnipolar(float x)\n{\n    // Triangle wave going from 0 to +1, starting at zero, 2-periodic.\n    return abs(1.-mod(x+1.,2.));\n}\n\nfloat fold(float x, float a, float b)\n{\n    // Force x to lie between a and b, \"bounce back\" when going too far.\n    return triUnipolar((x-a)/(b-a)) * (b-a) + a;\n}\n\n\nfloat curve(float x, float a, float b, float curvature)\n{\n    // When x is on the a-side, outputs 0\n    // When x is on the b-side, outputs 1\n    // When x is between a and b, interpolates.\n    // curvature = 0 -> linear interpolation\n    // Negative curvature gives lower values, positive gives higher values.\n    x = (x-a)/(b-a);\n    x = clamp(x, 0., 1.);\n    return pow(x, exp(-curvature));\n}\n\nfloat percEnv(float t, float atk, float rel, float cur)\n{\n    return curve(t, 0., atk, cur) * curve(t, atk+rel, atk, cur);\n}\n\nfloat rampIntegral(float x)\n{\n    // Integral of clamp(x,0.,1.).\n    // Used to calculate phase with portamento\n    return (x<=0.) ? 0. : (x < 1.) ? x*x*0.5 : x-0.5;\n}\n\nfloat phasePortamento(float t, float f1, float f2, float t1, float t2)\n{\n    // Integral of frequency of a note with portamento\n    // Transition lasts from t1 to t2, with initial frequency f1 and final frequency f2.\n    // freq(t) = f1 for t < t1\n    // ... = f2 for t > t2\n    // ... = linear interpolation in between\n    \n    \n    // Change of variable : x = (t-t1)/(t2-t1).\n    // dt = (t2-t1)*dx\n    // int freq(t) dt = int freq(t(x)) * (t2-t1) dx\n    // ... = int (f1 + saturate(x)*(f2-f1)) * (t2-t1) dx\n    // ... = f1*t + rampIntegral(x)*(t2-t1).\n    \n    float phase = rampIntegral((t-t1)/(t2-t1)) * (f2-f1) * (t2-t1) + f1*t;\n    phase = mod(phase, 1.);\n    return phase;\n}\n\n///////////////////////////////////\n////////////// SOUNDS /////////////\n///////////////////////////////////\n\n\nfloat lpfSaw3(float t, float f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    // https://www.shadertoy.com/view/wsGyWm\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\n\n//////////////////////////////////////\n////////////// INSTRUMENTS ///////////\n//////////////////////////////////////\n\nvec2 bassStab(float t, float te, float f)\n{\n    // \"Analog bass\" sound based on a filtered sawtooth wave\n    float fc = 100. + 18000.*exp(-53.*te);\n    float env = smoothstep(0.,0.001,te) * exp(-6.*te);\n    vec2 sig = vec2(0);\n    sig += vec2(1.) * lpfSaw3(t, f, fc, 1.);\n    sig += vec2(-1,1) * 0.2 * lpfSaw3(t - 0.05, f+1., fc, 1.); // Widen in stereo\n    return sig * env * 0.08;\n}\n\nfloat kick(float t, float te, float atk)\n{\n    float f0 = midicps(34.), df = 300., spd = 40.;\n    // Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    // Integrate to obtain\n    float phase = TAU*f0*te + TAU*df/spd * (1.-exp(-te*spd));\n    float env = exp(-8.*te) + 2.5*exp(-100.*te);\n    env *= smoothstep(-1e-6,0.,te);\n    env *= (1. + 0.3*smoothstep(0.01,0.0,te)); // Enhance attack\n    float v = sin(phase) * env;\n    float click = noise(20000.*te) * smoothstep(0.,0.001,te) * smoothstep(0.01,0.001,te) * 0.8;\n    click += sweep(te, 0.005) * 2.;\n    v /= 1. + 0.3*abs(v);\n    v *= (1. + 4.*smoothstep(0.05,0.15,te)*smoothstep(0.2,0.1,te)); // Enhance tail\n    v += click; // Don't distort the click\n    return v * smoothstep(-1e-6,atk,te);\n}\n\nfloat snare(float t, float te, float atk)\n{\n    // Snare is \"body\" + \"white noise\" + \"click\"\n    float wnoise = noise(20000.*te) + coloredNoise(te, 6500.,1000.)*0.3;\n    float nenv = (exp(-5.*te) + exp(-30.*te)) * smoothstep(0.2,0.0,te) * 0.5;\n    \n    float spd = 50.;\n    float phase = TAU*180.*te + TAU*80./spd * (1.-exp(-te*spd));\n    float body = sin(phase) * 1.5 * smoothstep(0.,0.005,te) * smoothstep(0.05,0.,te);\n    float v = wnoise*nenv + body;\n    v = 0.5*v;\n    v /= 1. + abs(v);\n    \n    //float click = noise(20000.*t) * exp(-600.*t);\n    float click = sweep(te, 0.005);\n    //v += click * 2.;\n    \n    v *= smoothstep(-1e-6,atk,te);\n    v *= (1. + 0.3* smoothstep(0.01,0.0,te) + 0.2*smoothstep(0.05,0.2,te));\n    \n    return v;\n}\n\n\nvec2 tomDrum(float te, float f0, float df)\n{\n    float spd = 5.;\n    // Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    // Integrate to obtain\n    float phase = f0*te + df/spd * (1.-exp(-te*spd));\n    \n    float env = smoothstep(0.,0.0005,te) * curve(te, 0.35, 0.0, -1.3);\n    float noiseEnv = smoothstep(0.,0.0005,te) * curve(te, 0.8, 0.0, -2.) * (1. + 5.*curve(te, 0.022,0.0,0.));\n    vec2 sig = vec2(0);\n    \n    sig += triBipolar(4.*phase) * env * 0.15;\n    vec2 noise = (coloredNoise2(te, 1000., 20000.) + coloredNoise2(te, 4500., 6000.));\n    \n    sig += (noise.xx + noise.yy)*0.7 * noiseEnv * 0.03;\n    sig /= 1. + abs(sig);\n    sig += noise.yx * smoothstep(0.,0.05,te) * curve(te, 2.0, 0.0, -2.5) * 0.02; // Fake echo\n    \n    return sig;\n}\n\nfloat hihat(float t, float te)\n{\n    float sig = coloredNoise(te, 7500., 4500.) + coloredNoise(te, 2000., 1800.) * 0.1;\n    //float env = smoothstep(0.0,0.0002,te) * (smoothstep(0.05,0.0,te) + 0.5*smoothstep(0.01,0.,te));\n    float env = smoothstep(0.0,0.0002,te) * (curve(te, 0.2,0.0,-2.) + 0.5*smoothstep(0.01,0.,te));\n    return sig * env;\n}\n\nvec2 clap(float t)\n{\n    // A \"clap\" sound effect\n    vec2 sig = vec2(0);\n    sig += (0.8*coloredNoise2(t, 1000., 800.) + 0.5*coloredNoise2(t, 3300.,3100.) + 0.4*coloredNoise2(t,8240.,8000.));\n    \n    sig *= smoothstep(0.,0.01,t) * (curve(t,1.0,0.03, -2.3) + 0.2*curve(t,5.0,0.1,-1.));\n    // Fast envelope \"stutter\" is at the root of the \"clap\" sound\n    sig *= mix(0.7, 0.5+0.5*sin(TAU*80.*t), smoothstep(0.06,0.03,t));\n    sig /= 1.+abs(sig); // Distort\n    \n    return sig;\n}\n\nvec2 sawLead(float t, float te, float f)\n{\n    vec2 sig = vec2(0);\n    te = max(te,0.);\n    float env = exp(-5.*te) * smoothstep(0.,0.01,te);\n    float fc0 = 2.*f;\n    float fc = fc0 + (10000.-fc0)*exp(-8.*te);\n    sig += lpfSaw3(t, f, fc, 1.);\n    sig += vec2(-1,1) * lpfSaw3(t-0.05, f+1.618, fc, 2.);\n    return sig * env * 0.1;\n}\n\nvec2 analogBrass(float t, float te, vec4 f)\n{\n    vec2 sig = vec2(0);\n    float fc = 800. + 8000. * curve(te, 0.,0.3,-1.) * curve(te,2.,0.3,-2.); // Quick swell\n    float env = smoothstep(0.,0.15,te); // Fade in only\n    \n    float amp = 1.;\n    for(float i=0.; i<3.; i++){\n        float dt = 0.06 * 0.05 * noise(t+5.62*i);\n        sig += vec2(1.0,0.0) * lpfSaw3(t+dt, f.z, fc, 1.5) * amp;\n        sig += vec2(0.8,0.6) * lpfSaw3(t+dt, f.x, fc, 1.5) * amp;\n        sig += vec2(0.6,0.8) * lpfSaw3(t+dt, f.y, fc, 1.5) * amp;\n        sig += vec2(0.0,1.0) * lpfSaw3(t+dt, f.w, fc, 1.5) * amp;\n        amp *= 0.7;\n    }\n    \n    vec2 warm = vec2(0);\n    warm += vec2(1.0,0.0) * sin(TAU*f.z*t + sin(TAU*f.z*t));\n    warm += vec2(0.8,0.6) * sin(TAU*f.x*t + sin(TAU*f.x*t));\n    warm += vec2(0.6,0.8) * sin(TAU*f.y*t + sin(TAU*f.y*t));\n    warm += vec2(0.0,1.0) * sin(TAU*f.w*t + sin(TAU*f.w*t));\n    \n    return sig * 0.05 + warm * 0.03;\n}\n\nvec2 fmLead(float te, float f1, float f2, float t1, float t2, float dur)\n{\n    // Lead synth sound\n    \n    // f1, f2, t1, t2 : portamento from f1 to f2 between time t1 and t2\n    \n    float phase = phasePortamento(te, f1, f2, t1, t2);\n    vec2 phase2 = phase + te*vec2(-1,1);\n    \n    // vibrato\n    float vibHz = 5.5;\n    float vibAmp = smoothstep(0.5,1.2,te);\n    float vibrato = sin(TAU*vibHz*te) * vibAmp;\n    phase += 0.06*0.2*f1 * vibrato/(TAU*vibHz);\n    \n    float env = smoothstep(0.,0.01,te) * (1.3 - 0.5*smoothstep(0.,0.1,te) + 0.1*vibrato) * smoothstep(dur,dur-0.1,te);\n    \n    float iom = 5500./max(f1,f2);\n    vec2 sig = vec2(0);\n    sig += 3.*sin(TAU*phase + sin(TAU*phase2));\n    sig += sin(TAU*phase*7. + (3.+vibrato)*sin(2.*TAU*phase2));\n    sig += sin(TAU*(phase2+2.*te) + iom*sin(TAU*phase2));\n    sig += sin(TAU*5000. + (5.+ vibrato)*sin(TAU*phase2.yx));\n    \n    return sig * env * 0.02;\n}\n\n\nvec2 shepardRiser(float t, float dt, float bandwidth)\n{\n    vec2 sig = vec2(0);\n    \n    for(float nn=30.; nn<100.; nn+=8.)\n    {\n        float midinote = nn + 15.*fract(t/dt);\n        float fc = midicps(midinote);\n        float df = bandwidth*fc;\n        sig += coloredNoise2(mod(t,dt), fc, df) * 0.01;\n    }\n    \n    return sig;\n}\n\nvec2 noiseRiseFall(float t, float dt)\n{\n    //float phase = smoothstep(0., dt, t) * dt;\n    float x = t/dt;\n    float phase = dt * x*x*x*(3.-2.25*x);\n    vec2 sig = coloredNoise2(phase, 7000., 10000.) * 0.1;\n    sig *= smoothstep(0., 0.01, t) * smoothstep(dt, dt-0.01, t);\n    return sig;\n}\n\nvec2 machineButtonClick(float t)\n{\n    float reson = sin(TAU*805.*t + sin(TAU*302.*t) + sin(TAU*419.*t)) + 0.5*sin(TAU*100.*t);\n    float noise = coloredNoise(t, 4393., 6000.) + 0.2*coloredNoise(t, 7000., 10000.);\n    \n    float sig = 0.;\n    float env = percEnv(t, 0.001, 0.03, -1.) * 0.01 + percEnv(t-0.021, 0.001, 0.03, -1.) * 0.015\n    + percEnv(t-0.045, 0.001, 0.04, -1.)*0.1 + percEnv(t-0.056, 0.001, 0.1, -1.)*0.15 + percEnv(t-0.09, 0.001, 0.3,-1.8) * 0.1;\n    \n    sig += (reson*0.1+noise) * env;\n    \n    return vec2(sig);\n}\n\nvec2 machineButtonClickVerb(float t)\n{\n    return machineButtonClick(t) + vec2(0.5,0)*machineButtonClick(t-0.0062) + vec2(0,0.3)*machineButtonClick(t-0.01);\n}\n\nvec2 crashCymbal(float t, float atk)\n{\n    float reson = sin(TAU*429.*t + 5.*sin(TAU*1120.*t) + 5.*sin(TAU*1812.*t));\n    vec2 sig = coloredNoise2(t, 7150., 10000.) + 0.1*reson*smoothstep(0.,0.05,t);\n    float env = curve(t, 15.0, 0.0,-3.) * curve(t, 0.0, 0.08, 1.);\n    env *= (1. + smoothstep(0.02,0.0,t) * 2.);\n    env *= (1. - smoothstep(0.0,0.05,t)*smoothstep(0.5,0.0,t) * 0.5);\n    env *= smoothstep(0., atk, t);\n    return sig * env * 0.2;\n}\n\nvec2 crashCymbalVerb(float t)\n{\n    vec2 sig = crashCymbal(t, 0.);\n    sig += crashCymbal(t-0.75*beatdur, 0.05).yx * 0.5;\n    sig += crashCymbal(t-1.50*beatdur, 0.10).xy * 0.25;\n    return sig;\n}\n\n\n\n///////////////////////////////////\n////////// PATTERNS ///////////////\n///////////////////////////////////\n\nvec2 drums(float t, float atk)\n{\n    // atk: zero, or greater for smoother signal attack.\n    vec2 v = vec2(0);\n    \n    float te = mod(t, beatdur * 2.);\n    v += kick(t, te, atk) * 0.1;\n    \n    te = mod(t-beatdur, 2.*beatdur);\n    v += snare(t, te, atk) * 0.25;\n    \n    te = mod(t, beatdur * 0.5);\n    float vel = 1. + mod(t,beatdur);\n    vec2 panHH = 1. + 0.5 * vec2(-1,1) * cos(TAU*t/(4.*beatdur));\n    v += hihat(t, te) * 0.03 * vel * panHH;\n    \n    return v * smoothstep(-1e-6,atk,t);\n}\n\nvec2 clapPattern(float t)\n{\n    vec2 v = vec2(0);\n    float te = mod(t-7.*beatdur, 8.*beatdur);\n    v += clap(te) * 0.25;\n    \n    return v * smoothstep(-1e-6,0.,t);\n}\n\nvec2 tomFill(float t)\n{\n    if(t < 0.5*beatdur || t > 3.*beatdur) return vec2(0);\n    \n    t = t - 0.5*beatdur;\n    float te = mod(t, 0.75*beatdur);\n    float num = floor(t / (0.75*beatdur));\n    float f0i = 0.;\n    float dfi = (200. - 20.*num)*2.;\n    \n    vec2 sig = vec2(0);\n    sig += tomDrum(te, f0i, dfi);\n    \n    return sig;\n}\n\nvec2 pentatonicArp(float t)\n{\n    if(t < 0.) return vec2(0);\n    float notedur = beatdur / 8.;\n    float te = mod(t, notedur);\n    float nthNote = floor(t / notedur);\n    vec2 sig = vec2(0);\n    for(float ni = 0.; ni < 8.; ni++) // Also play the tail of the previous notes\n    {\n        float nn = nthNote-ni;\n        // fold back after 16 notes\n        nn = fold(nn, 0., 16.);\n        float degree = mod(nn, 5.); // degree in pentatonic scale\n        float octave = floor(nn/5.);\n        float note = floor(12.*degree/5.+0.6); // midi note number in pentatonic scale\n        float midiNoteNum = 69. + 12.*octave + note;\n        float f = midicps(midiNoteNum);\n\n        float tei = te+notedur*ni;\n        vec2 sigi = sawLead(t, tei, f);\n        sigi *= smoothstep(notedur*8., notedur*7., tei); // fade out note to avoid clicks\n        sig += sigi;\n    }\n    return sig;\n}\n\nvec2 pentatonicArpVerb(float t)\n{\n    vec2 pan = (1. + 0.7*vec2(-1,1)*sin(0.7*TAU*t));\n    return pan * pentatonicArp(t) + vec2(0.7,0.3)*pentatonicArp(t-3./8.*beatdur-0.02)\n     - vec2(0.2,0.5)*pentatonicArp(t-4./8.*beatdur-0.05);\n}\n\nvec2 bassLine(float t)\n{\n    float notedur = 0.5*beatdur;\n    float te = mod(t, notedur);\n    float nthNote = floor(t/notedur);\n    nthNote = mod(nthNote + 1., 32.); // Start all chords one half note in advance\n    \n    float midiNoteNum = \n        (nthNote < 8.) ? 45. : // A\n        (nthNote < 16.) ? 43. : // G major\n        (nthNote < 28.) ? 48. : // C major\n        50.; // D\n    float freq = midicps(midiNoteNum);\n    \n    float pumping = smoothstep(0.,beatdur*0.5, mod(t,beatdur));\n    vec2 sig = vec2(0);\n    sig += bassStab(t, te, freq) * mix(1.,pumping,0.5) * 0.7;\n    sig += bassStab(t, te, freq/2.) * mix(1.,pumping,0.6) * 0.7;\n    \n    return sig;\n}\n\nvec2 brassPad(float t)\n{\n    float nthNote = floor(t/beatdur);\n    nthNote = mod(nthNote, 16.);\n    vec4 midiNoteNum =\n        (nthNote < 4.) ? vec4(60,62,64,69) : // A minor (+D)\n        (nthNote < 8.) ? vec4(59,62,67,69) : // G\n        (nthNote < 14.) ? vec4(60,62,64,67) : // C (+D)\n        vec4(60,62,65,69); // Dm7\n        \n    vec2 env_startend = \n        (nthNote < 4.) ? vec2(0,4) : \n        (nthNote < 8.) ? vec2(4,8) :\n        (nthNote < 14.) ? vec2(8,14) :\n        vec2(14,16);\n        \n    float te = mod(t, 16.*beatdur) - env_startend.x * beatdur;\n    float noteDur = (env_startend.y - env_startend.x) * beatdur;\n    float fadeout = smoothstep(noteDur, noteDur-0.2, te);\n    \n    vec4 freq = midicps(midiNoteNum);\n    \n    vec2 sig = analogBrass(t, te, freq);\n    sig *= fadeout;\n    \n    return sig;\n}\n\nvec2 brassPadVerb(float t)\n{\n    return brassPad(t) + 0.5*brassPad(t-0.1).yx + 0.2*brassPad(t-1.);\n}\n\nvec2 fmLeadPhrase(float t)\n{\n    if(t<0.) return vec2(0);\n    \n    t = mod(t, 32.*beatdur);\n    if(t < 28.*beatdur) t = mod(t, 16.*beatdur); // variation on second time\n    \n    float tb = t / beatdur;\n    \n    // Each note may contain one portamento\n    // Note data is (tb0, dur, midiNN1, midiNN2, beats until porta, porta duration in beats).\n    mat3x2 noteData = \n        (tb < 2.5) ? mat3x2(0.0, 2.5, 74, 76, 0.5, 0.1) : // D-E\n        (tb < 3.5) ? mat3x2(2.5, 1, 74, 72, 0.5, 0.2) :// D-C\n        (tb < 6.5) ? mat3x2(3.5, 3, 79, 79, 10, 10) : // G\n        (tb < 8.5) ? mat3x2(7.5, 1, 81, 83, 0.0, 0.05) : // B\n        (tb < 9.5) ? mat3x2(8.5, 1, 84, 83, 0.5, 0.2) : // C-B\n        (tb < 11.) ? mat3x2(9.5, 1.5, 76,76,10,10): // E\n        (tb < 11.5) ? mat3x2(11., 0.5, 77,79,0.0,0.1): // G\n        (tb < 12.5) ? mat3x2(11.5, 1., 77,77,10,10): // F\n        (tb < 13.5) ? mat3x2(12.5, 1., 76,76,10,10): // E\n        (tb < 15.) ? mat3x2(13.5, 1.5, 76,74,0.0,0.05): // E-D\n        (tb < 16.) ? mat3x2(15., 1., 72,72,10,10) : // C\n        // identical repeat until...\n        (tb < 29.5) ? mat3x2(27.5,2., 77,77,10,10) : // F (continued)\n        mat3x2(29.5, 1.7, 76,76,10,10) // E\n        ;\n    \n    \n    float t0 = noteData[0][0]*beatdur;\n    float te = t - t0;\n    float dur = noteData[0][1]*beatdur;\n    float f1 = midicps(noteData[1][0]);\n    float f2 = midicps(noteData[1][1]);\n    float t1 = noteData[2][0] * beatdur;\n    float t2 = t1 + noteData[2][1] * beatdur;\n    vec2 sig = fmLead(te, f1, f2, t1, t2, dur);\n    \n    return sig;\n}\n\nvec2 fmLeadPhraseVerb(float t)\n{\n    return fmLeadPhrase(t) + vec2(0.2,0.7) * fmLeadPhrase(t-beatdur+0.01) + vec2(0.5,0.1) * fmLeadPhrase(t-2.*beatdur-0.02);\n}\n\n\n/////////////////////////////////////\n//////////// SONG STRUCTURE /////////\n/////////////////////////////////////\n\nvec2 introSequence(float t)\n{\n    // arps intro\n    // +drums\n    // +brass\n    // +riser, tom fill\n    \n    float tb = t / beatdur;\n    \n    \n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n    float arpPump = 0.7*smoothstep(7.9,8.0,tb);\n    sig += pentatonicArpVerb(t) * 0.09 * mix(1.,pumping,arpPump);\n    \n    t -= 8.*beatdur;\n    vec2 drumSig = drums(t, 0.);\n    sig /= 1. + 3.*abs(drumSig); // Distort the signal according to the drums\n    sig += drumSig;\n    \n    \n    pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.3, te);\n    t -= 8.*beatdur;\n    sig += brassPadVerb(t) * 0.4 * mix(1.,pumping,0.9)  * curve(t, 0., 24., 0.5);\n    \n    t -= 24.*beatdur;\n    \n    sig += noiseRiseFall(t, 7.*beatdur) * 0.2;\n    // Play the first clap louder\n    pumping = smoothstep(0.05,0.,te) + smoothstep(0.05,0.3, te);\n    sig += clapPattern(t) * smoothstep(3.*beatdur,4.*beatdur,t) * (1. + 0.3*smoothstep(15.*beatdur, 8.*beatdur, t))\n     * mix(1., pumping, 0.3);\n    \n    t -= 4.*beatdur;\n    vec2 fill = tomFill(t);\n    sig /= 1.+2.*abs(fill); // Distort signal according to toms\n    sig += fill;\n    \n    return sig;\n}\n\n\nvec2 chorusPattern(float t)\n{\n    // Should be overlayed with intro sequence (t > 48.*beatdur)\n    \n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n    \n    sig += crashCymbalVerb(mod(t,32.*beatdur)) * 0.5 * mix(1., pumping, 0.5);\n    sig += fmLeadPhraseVerb(t) * mix(1.,pumping, 0.8) * 0.7;\n    sig += bassLine(t);\n    \n    return sig;\n}\n\nvec2 bootUp(float t)\n{\n    // Sequence of glitchy sounds\n    // like a tape loading up.\n    // Runs in 4 seconds\n    \n    vec2 sig = vec2(0);\n    \n    sig += machineButtonClickVerb(t-0.5);\n    \n    t -= 1.;\n    \n    float phase = rampIntegral(t / 3.) * 3.;\n    \n    vec2 sig1 = vec2(0);\n    sig1 += 0.1 * pentatonicArpVerb(phase);\n    sig1 += 0.02 * noise(5000.*phase);\n    sig1 *= smoothstep(0.,0.1,t) * smoothstep(3.0,2.999,t);\n    \n    sig += machineButtonClick(1.05*(t-2.9));\n    \n    return sig + sig1 * 0.5;\n}\n\n\nvec2 fullSong(float t)\n{\n    vec2 sig = vec2(0);\n    \n    if(0. < t)\n        sig += introSequence(t);\n    if (12.*4.*beatdur < t)\n    {\n        t -= 12.*4.*beatdur;\n        sig += chorusPattern(t);\n    }\n    \n    return sig;\n}\n\nvec2 mainSound( int samp, float t )\n{\n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n\n    \n    \n    sig += bootUp(t);\n    \n    t -= 4.;\n    \n    sig += fullSong(t);\n    \n    //sig /= 1. + 0.5 * abs(sig);\n    \n    \n    return sig;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}