{
    "Shader": {
        "info": {
            "date": "1581813898",
            "description": "Plot any expression using a macro!  (Function definition not required).\nFocus is on accuracy, not speed.  For lineweight lw (pixels), function is evaluated 2+floor(lw) times.\nAntialiasing still a bit dodgy.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t3XWf",
            "likes": 15,
            "name": "Expression Plotter",
            "published": 3,
            "tags": [
                "plot",
                "util",
                "macro"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 498
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 v, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n\n    vec3 col = vec3(0.);\n\n    mat2 domain = transpose(mat2(-2.,2.,-2.,2.));\n    \n    mat2 window;\n    \n    window = transpose(mat2(.01,.48,.51,.48));\n\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(1), 1, 0, 0., sin(x*2.) );\n    for (float o = .4; o < 3.; o+=.4) {\n        float lw = 0.006*o;\n        float k = 2./(1.+.5*o);\n        PLOT_CONTINUOUS(col,uv,window,domain,vec3(1), 0, 0, lw, sin(k*x)+o );\n        PLOT_CONTINUOUS(col,uv,window,domain,vec3(0), 0, 0, lw, sin(k*x)-o );\n    }\n    \n    window = transpose(mat2(.51,.48,.51,.48));\n\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(0,1,.2), 0, 1, .02, 1.5*(x<0.?cos(exp(-x)*6.):.5*sign(cos(x*20.))) );\n    \n    mat2 window_ll = transpose(mat2(.01,.49,.01,.48));\n    mat2 window_lr = transpose(mat2(.50,.49,.01,.48));\n    mat2 domain_ll = transpose(mat2(-2.,0.,-2.,2.));\n    mat2 domain_lr = transpose(mat2( 0.,2.,-2.,2.));\n    \n    PLOT_CONTINUOUS(col,uv,window_lr,domain_lr, vec3(1), 1, 0, 0., 2. );\n\n    if (abs(uv.x-.5)>.01)\n    for (float o = 0.; o < 1.; o+=.1) {\n        float lw = 0.03;\n        float k = 8.*exp(-o*.3);\n        float h = 1.+3.*o;\n        vec3 c = pow(.5+.5*cos(h+vec3(0,1,2)*2.094),vec3(2.));\n        int blend = (uv.x<.25?1:0);\n        if (abs(uv.x-.25)>.01)\n        PLOT_CONTINUOUS(col,uv,window_ll,domain_ll, blend==1?c*.3:c, 0, blend, lw, cos(k*(x-2.5)-iTime) );\n        PLOT_CONTINUOUS(col,uv,window_lr,domain_lr,               c, 0, 2,     lw, cos(k*(x-2.5)-iTime) );\n    }\n    \n    v = vec4(pow(col,vec3(1./2.2)),0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}