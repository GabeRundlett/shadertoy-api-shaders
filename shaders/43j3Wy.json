{
    "Shader": {
        "info": {
            "date": "1708966659",
            "description": "Some of these are not technically tunnels, but anyway.",
            "flags": 96,
            "hasliked": 0,
            "id": "43j3Wy",
            "likes": 25,
            "name": "Line Connection Tunnels",
            "published": 3,
            "tags": [
                "tunnel",
                "oldschool",
                "line",
                "lines",
                "ghosting"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "/* Line Connection Tunnels by misol101 */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    TunnelData tData = getTunnelData(iTime);\n\n    float blue = 1.;\n    if (tData.colType == 0) {\n        vec4 hist = texelFetch( iChannel1, ivec2(fragCoord), 0 );\n        float val = (hist.x + hist.y + hist.z + hist.w) * (0.54/3.);\n\n        vec2 center = 0.5 * iResolution.xy;\n        vec2 uv = (fragCoord - center) / iResolution.y;\n        blue = abs(uv.y) < 0.43 ? 0.15 : 0.;\n        float white = blue>0. && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? 1. : 0.;\n\n        fragColor = vec4(white);\n        vec3 bc = step(1., tData.colMul) * blue;\n        fragColor += vec4(bc, 0.);\n        fragColor += val * vec4(tData.colMul, 1.);\n    } else {\n        fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 ) * vec4(tData.colMul, 1.);\n    }\n    \n#ifdef STARS\n    float h = fract(sin(fragCoord.y)*99.)+.1, x = mod((iTime+99.) * h * .3, 1.);\n    float star = step(abs(x * iResolution.x - fragCoord.x), 1.) * h;\n    fragColor += star * step(0.1, blue);\n#endif\n\n    float time = mod(iTime, TIME_PER_TUNNEL), cAdd = 0.;\n    if (time < HALF_FADE) cAdd = 1.-(time/HALF_FADE);\n    else if (time > TIME_PER_TUNNEL - HALF_FADE) cAdd = 1.-(TIME_PER_TUNNEL - time) / HALF_FADE;\n    fragColor += cAdd * 1.1;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 36174,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ultrasyd/amiga-tribute-enigma-elysium"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// line function from https://www.shadertoy.com/view/McsXz8 by ChunderFPV\nfloat L(vec2 p, vec3 A, vec3 B, float width, float glow) {\n    vec2 a = A.xy, \n         b = B.xy - a;\n         p -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return width-length(p - b*h)/glow; // + .01*mix(A.z, B.z, h);\n}\n\n// Based on rasterizer (https://www.shadertoy.com/view/MdS3Rz) by HLorenzi\nconst\tmat4 transform1 =\n\t\tmat4(1, 0, 0, 0,\n      \t\t 0, 1, 0, 0,\n      \t\t 0, 0, 1, 0,\n\t\t\t 0, 0, -2.5, 1);\n\nvoid tunnel(inout vec4 c, vec2 p, TunnelData tData, float rz) {\n    float rx=0., ry=0., dist=2.0;\n    vec4 xyg = vec4(vec2(0.,0.), vec2(0.));\n\n\tfloat cx = cos(rx); float sx = sin(rx);\n\tfloat cy = cos(ry); float sy = sin(ry);\n\tfloat cz = cos(rz); float sz = sin(rz);\n    \t\n\tmat4 transform2 =\n\t\tmat4(cz*cy, -sz*cy, sy, 0,\n\t\t\t sz*cx + cz*sy*sx, cz*cx - sz*sy*sx, -cy*sx, 0,\n\t\t\t sz*sx - cz*sy*cx,cz*sx + sz*sy*cx, cy*cx, 0,\n\t\t\t 0, 0, 0, 1);\n\t\n\tfloat n = dist, f = 30.0, t = 1.0;\n\tfloat r = 1.0 * iResolution.x / iResolution.y;\n\tmat4 projection =\n\t\tmat4(n/r, 0, 0, 0,\n      \t\t 0, n/t, 0, 0,\n      \t\t 0, 0, -(f+n)/(f-n), -1,\n\t\t\t 0, 0, -(2.0*f*n)/(f-n), 0);\n\t\n    mat4 finalTransform = projection * transform1 * transform2;\n    \n    for (int j = 0; j < tData.nofSegments; j++) {\n        vec4 lastPt = vec4(0.), firstPt = vec4(0.);\n        \n        float pz = mod(float(j) * tData.segDist + iTime*tData.speed, float(tData.nofSegments) * tData.segDist);\n        pz = float(tData.nofSegments) * tData.segDist - pz + dist;\n        pz = max(NEAR_CUT, pz);\n        float pz2 = pz + tData.segDist;\n        \n        float ppx = sin(pz*tData.xMove.x + iTime*tData.speed*tData.dirSpeed.x) * (pz-dist)*tData.xMove.y;\n        float ppy = cos(pz*tData.yMove.x + iTime*tData.speed*tData.dirSpeed.y) * (pz-dist)*tData.yMove.y;\n\n#ifdef CONNECT_PARENT\n        float ppx2 = sin(pz2*tData.xMove.x + iTime*tData.speed*tData.dirSpeed.x) * (pz2-dist)*tData.xMove.y;\n        float ppy2 = cos(pz2*tData.yMove.x + iTime*tData.speed*tData.dirSpeed.y) * (pz2-dist)*tData.yMove.y;\n#endif\n\n        float rm = 15. / float(tData.nofSegments), rm2 = 0.9 / tData.segDist;\n        float width=max(0.3,1.8 - pz*0.1*rm*rm2), glow=max(0.001,0.0225 - pz*0.0014*rm*rm2);\n    \n        for (int i = 0; i < tData.nofPoints; i++) {\n            float th = (PI*2. / float(tData.nofPoints)) * float(i)*tData.pointAdvance - PI/float(tData.nofPoints);\n            vec4 pt = finalTransform * vec4(sin(th) + ppx,cos(th) + ppy, pz, 1) + xyg;\n            if (i == 0) firstPt = pt;\n            c = max(c, vec4(L(p, pt.xyz / pt.w, lastPt.xyz / lastPt.w, width, glow)));\n#ifdef CONNECT_PARENT\n            vec4 pt2 = finalTransform * vec4(sin(th) + ppx2,cos(th) + ppy2,pz2,1) + xyg;\n            c = max(c, vec4(L(p, pt.xyz / pt.w, pt2.xyz / pt2.w, width, glow)));\n#endif\n            lastPt = pt;\n        }\n        c = max(c, vec4(L(p, firstPt.xyz / firstPt.w, lastPt.xyz / lastPt.w, width, glow)));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2. - vec2(1.);\n    vec4 c = vec4(0);\n\n    TunnelData tData = getTunnelData(iTime);\n    float rz;\n    switch(tData.rotType) {\n        case 0: default: rz = iTime*tData.rotSpeed; break;\n        case 1: rz=sin(iTime)*tData.rotSpeed; break;\n        case 2: rz=iTime*tData.rotSpeed - sin(iTime*tData.rotSpeed); break;\n    }\n\n\ttunnel(c, uv, tData, rz);\n    fragColor = c;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 O, vec2 F) {\n    O = texelFetch(iChannel0, ivec2(F), 0);\n    O[iFrame % 4] = texelFetch(iChannel1, ivec2(F) ,0).x;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define NOF_TUNNELS 8\n#define TIME_PER_TUNNEL 6.\n#define FADE_TIME 1.\nconst float HALF_FADE = FADE_TIME * 0.5;\n\n#define PI 3.14159265359\n#define NEAR_CUT 2.5\n#define CONNECT_PARENT\n//#define STARS\n\nstruct TunnelData {\n    int nofPoints;\n    int nofSegments;\n    float segDist;\n    float speed;\n    int rotType;\n    float rotSpeed;\n    int colType;\n    float pointAdvance;\n    vec2 dirSpeed;\n    vec2 xMove;\n    vec2 yMove;\n    vec3 colMul;\n};\n\nTunnelData getTunnelData(float time) {\n    TunnelData tData;\n    int index = int(mod(time, TIME_PER_TUNNEL * float(NOF_TUNNELS)) / float(TIME_PER_TUNNEL)); \n    vec2 defDirSpd = vec2(1.0, 1.5);\n    vec2 defXMv = vec2(0.27, 0.15);\n    vec2 defYMv = vec2(0.4, 0.15);\n    vec3 defColMul = vec3(0.95, 0.95, 1.2);\n\n    switch(index) {\n        //default: tData = TunnelData(1, 60, 0.8, 1.0, 2, 1.0, 0, 1., defDirSpd, vec2(0.27, 0.35),vec2(0.17, 0.3), vec3(1.0, 0.65, 0.8)); break;\n        //default: tData = TunnelData(11, 7, 2.1, 1.0, 0, 1.0, 0, 2., defDirSpd, defXMv,vec2(0.37, 0.25), vec3(1.0, 0.65, 0.8)); break;\n        //default: tData = TunnelData(7, 17, 0.9, 1.0, 2, 1.0, 0, 0.2, defDirSpd, defXMv,vec2(0.37, 0.25), vec3(1.0, 0.65, 0.8)); break;\n        default: tData = TunnelData(4, 20, 0.7, 1.0, 1, -1.7, 1, 1., vec2(4.0, 1.5), defXMv,vec2(0.37, 0.65), vec3(1.5, 0.65, 0.8)); break;\n        \n        case 0: tData = TunnelData(6, 14, 0.9, 2.0, 0, 2.0, 0, 1., defDirSpd, defXMv, defYMv, defColMul); break;\n        case 1: tData = TunnelData(5, 16, 0.8, 2.0, 2, 1.0, 1, 0.4, defDirSpd, defXMv, defYMv, defColMul); break;\n        case 2: tData = TunnelData(9, 11, 1.1, 1.6, 0, 1.0, 0, 2., defDirSpd, defXMv,vec2(0.37, 0.25), vec3(1.0, 0.8, 0.15)); break;\n        case 3: tData = TunnelData(4, 15, 0.9, -2.0, 1, 1.5, 0, 1., defDirSpd, defXMv, defYMv, vec3(1., 0.95, 0.95)); break;\n        case 4: tData = TunnelData(5, 15, 0.9, 2.0, 0, 2.0, 0, 2.0, defDirSpd, defXMv, defYMv, defColMul); break;\n        case 5: tData = TunnelData(3, 28, 0.5, 2.0, 2, -0.8, 1, 1., defDirSpd, vec2(0.17, 0.4), defYMv, defColMul); break;\n        case 6: tData = TunnelData(7, 13, 0.8, -1.55, 0, 1.0, 0, 2., defDirSpd, defXMv, defYMv, vec3(0.95, 1.0, 0.95)); break;\n        case 7: tData = TunnelData(2, 40, 0.6, 2.0, 1, 2.0, 0, 1.0, defDirSpd, defXMv, defYMv, vec3(0.95, 1., 1.0)); break;\n    }\n    return tData;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}