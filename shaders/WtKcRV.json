{
    "Shader": {
        "info": {
            "date": "1611347392",
            "description": "A normal estimate is used to create a Phong lighting model. A normal map is generated from perlin noise and used to modify the normal. Still a Work in Progress!",
            "flags": 0,
            "hasliked": 0,
            "id": "WtKcRV",
            "likes": 0,
            "name": "Iridescent Cube Spheres",
            "published": 3,
            "tags": [
                "phong",
                "sdf",
                "iridescent"
            ],
            "usePreview": 0,
            "username": "pprovins",
            "viewed": 293
        },
        "renderpass": [
            {
                "code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct BoundingBox {\n    vec3 center;\n    vec3 bounds;\n    float edge;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nfloat distToBoundingBox(Ray ray, BoundingBox bb) {\n    vec3 p = abs(ray.origin - bb.center) - bb.bounds;\n    vec3 q = abs(p + bb.edge) - bb.edge;\n    return min(min(\n             length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n             length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n             length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)\n    );\n}\n\nfloat distToSphere(Ray ray, Sphere s) {\n    return length(ray.origin - s.center) - s.radius;\n}\n\nfloat sdfSmoothIntersection( float d1, float d2, float k ) {\n  float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat distToBoundingBoxScene(Ray r) {\n    BoundingBox bb = BoundingBox(vec3(1.0), vec3(0.3), 0.1);\n    Sphere s = Sphere(vec3(1.0), 0.4);\n    Ray repeatRay = r;\n    repeatRay.origin = mod(r.origin, 2.0);\n    float d1 = distToBoundingBox(repeatRay, bb);\n    float d2 = distToSphere(repeatRay, s);\n    float dist = sdfSmoothIntersection(d1, d2, 0.2);\n    return dist;\n}\n\n\nvec3 sdfNormalEstimate(Ray r) {\n    float epsilon = 0.01;\n    vec3 p = r.origin;\n  \n    vec3 estimate = vec3(\n                             distToBoundingBoxScene(Ray(vec3(p.x + epsilon, p.y, p.z), r.direction)) - distToBoundingBoxScene(Ray(vec3(p.x - epsilon, p.y, p.z), r.direction)),\n                             distToBoundingBoxScene(Ray(vec3(p.x, p.y + epsilon, p.z), r.direction)) - distToBoundingBoxScene(Ray(vec3(p.x, p.y - epsilon, p.z), r.direction)),\n                             distToBoundingBoxScene(Ray(vec3(p.x, p.y, p.z  + epsilon), r.direction)) - distToBoundingBoxScene(Ray(vec3(p.x, p.y, p.z - epsilon), r.direction))\n                           );\n    return normalize(estimate);\n}\n\nvec2 hash2(vec2 p) {\n  return fract(vec2(5978.23857, 2915.98275)*sin(vec2(\n                                                         p.x*832.2388 + p.y*234.9852,\n                                                         p.x*921.7381 + p.y*498.2348\n                                                         )))*2.-1.;\n}\n\nfloat getPerlinValue(vec2 uv, float scale, float offset){\n    uv *= scale;\n    vec2 f = fract(uv);\n    vec2 m = f * f * (3.-f-f);\n    vec2 p = uv - f;\n  \n    float n = mix(\n                   mix(dot(hash2(p + offset + vec2(0,0)), f - vec2(0,0)),\n                      dot(hash2(p + offset + vec2(1,0)), f - vec2(1,0)), m.x),\n                  mix(dot(hash2(p + offset + vec2(0,1)), f - vec2(0,1)),\n                      dot(hash2(p + offset + vec2(1,1)), f - vec2(1,1)), m.x),\n                  m.y);\n  \n    return float(0.5 * n + 0.5);\n}\n\nvec3 getPerlinNormal(vec2 uv, float scale, float offsetLayer) {\n    float n1 = getPerlinValue(uv, scale, 0.0);\n    float n2 = getPerlinValue(uv, scale, offsetLayer);\n    vec3 p1 = vec3(n1);\n    p1.r = 0.5;\n    vec3 p2 = vec3(n2);\n    p2.g = 0.5;\n    vec3 normalValue = p1 + p2;\n    normalValue.b *= 1.2;\n    normalValue /= (normalValue.r + normalValue.g + normalValue.b);\n    normalValue /= max(max(normalValue.r, normalValue.g), normalValue.b);\n    normalValue = normalValue * 2.0 - 1.0;\n    return normalValue;\n}\n\nvec3 getJetSpectra(vec2 uv) {\n  float x = clamp((uv.x + 1.0) / 2.0, 0.0, 1.0);\n  vec3 c;\n  \n  if (x < 0.25)\n    c = vec3(0.0, 4.0 * x, 1.0);\n  else if (x < 0.35)\n    c = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n  else if (x < 0.65)\n    c = vec3(4.0 * (x - 0.35), 1.0, 0.0);\n  else if (x < 0.95)\n    c = vec3(1.0, 1.0 + 4.0 * (0.65 - x), 0.0);\n  else\n    c = vec3(0.4, 0.4, 0.4);\n  return clamp(c, vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= -1.0;\n    vec3 camPos = vec3(1000.0 + (sin(iTime) / 2.5) + 1.0, 1000.0 + (cos(iTime) / 2.5) + 1.0, iTime / 2.0); //time);\n    Ray ray = Ray(camPos, normalize(vec3(uv, 1.0)));\n    vec3 col = vec3(0.0);\n    for (float i=0.0; i<100.0; i++) {\n      float dist = distToBoundingBoxScene(ray);\n      if (dist < 0.001) {\n        vec3 surfacePosition = ray.origin;\n        vec3 ambient = vec3(0.2, 0.2, 0.2);\n        vec3 norm = normalize(sdfNormalEstimate(ray));\n        vec3 lightDirection = normalize(camPos - surfacePosition);\n        float diffuse = clamp(dot(norm, lightDirection), 0.0, 1.0);      \n        vec3 cameraDirection = normalize(camPos - surfacePosition);\n      \n        float specular = 0.0;\n        if (diffuse > 0.0) {\n            specular = pow(clamp(dot(cameraDirection, reflect(-lightDirection, norm)), 0.0, 1.0), 2000.0);\n            specular = pow(dot(cameraDirection, reflect(-lightDirection, norm)), 2000.0);\n        }\n        float distanceToLight = length(camPos - surfacePosition);\n        float attenuation = 1.0 / (0.9 + 0.2 * pow(distanceToLight, 2.0));\n      \n        vec3 colXZ = getPerlinNormal(mod(ray.origin.xz * 2.0 - 1.0, 1.0), 100.0, 123.45);\n        vec3 colYZ = getPerlinNormal(mod(ray.origin.yz * 2.0 - 1.0, 1.0), 100.0, 123.45);\n        vec3 colXY = getPerlinNormal(mod(ray.origin.xy * 2.0 - 1.0, 1.0), 100.0, 123.45);\n        vec3 powNorm = abs(norm);\n        powNorm *= pow(powNorm, vec3(2.0));\n        powNorm /= powNorm.x + powNorm.y + powNorm.z;\n        vec3 normalMap = colYZ * powNorm.x + colXZ * powNorm.y + colXY * powNorm.z;\n        vec3 bumpNormal = norm + normalMap;\n      \n        float NdotL = dot(vec3(dot(cameraDirection, reflect(-lightDirection, bumpNormal))), bumpNormal);\n        vec3 ramp = getJetSpectra(vec2(mod(NdotL, 3.0)));\n        col = (ambient + ramp * 0.2) + attenuation * (diffuse + specular) * (ambient + 0.4);\n        break;\n      }\n      ray.origin += ray.direction * dist;\n    }\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}