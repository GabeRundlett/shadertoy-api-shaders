{
    "Shader": {
        "info": {
            "date": "1569951442",
            "description": "Based on TekF https://www.shadertoy.com/view/ldX3DX and me https://www.shadertoy.com/view/wdK3zm",
            "flags": 0,
            "hasliked": 0,
            "id": "WdyGWR",
            "likes": 17,
            "name": "Windy Flag of China",
            "published": 3,
            "tags": [
                "sss",
                "raymarch",
                "flag",
                "wind"
            ],
            "usePreview": 0,
            "username": "yuchengzhong",
            "viewed": 1235
        },
        "renderpass": [
            {
                "code": "// Yuchengzhong 2019\n// Hazel Quantock 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define d_hash3f(x)  vec3(((((((((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U)>>8U)^(((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U).yzx)*1103515245U)>>8U)^((((((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U)>>8U)^(((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U).yzx)*1103515245U).yzx)*1103515245U)/ float(0xffffffffU) + 1e-30\n#define JITTER 0.018\n\nconst float tau = 6.28318530717958647692;\nvec2 view_Resolution;\nvec2 view_FragCoord;\nint view_Index;\nvec4 view_selectionRelativeMouse;\n\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom ,in vec2 jitter)\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = view_FragCoord.xy - view_Resolution.xy*.5 +jitter;\n\tray.z = view_Resolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = p + f;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn rg;\n}\n\nfloat DistanceField( vec3 pos );\n\nvec3 Normal( vec3 pos )\n{\n    vec3 jitter = d_hash3f(abs(pos));\n\tconst vec2 delta = vec2(0,0.05);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\treturn normalize(grad+JITTER*(jitter-0.5));\n}\n\n\n// ----------------------\n\nfloat RippleHeight( vec2 pos )\n{\n\tvec2 p = pos+vec2(-1,.2)*iTime*2.0;\n\t\n\tp += vec2(1,0)*Noise(p).y; // more natural looking ripples\n\tfloat f = Noise(p).x-.5;\n\tp *= 2.0;\n\tp += vec2(0,-.5)*iTime;\n\tf += (Noise(p).x-.5)*.2;\n\tp *= 2.0;\n\tp += vec2(-3,0)*iTime;\n\tf += (Noise(p).x-.5)*.05;\n\t\n\tf = f*(1.0-exp2(-abs(pos.x)));\n\treturn f*1.2;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn (RippleHeight(pos.xy)-pos.z)*.999;\n}\n\n// map a uv space onto a distorted surface\nvec2 UVMapping( vec2 target )\n{\n\tvec2 uv = vec2(0);\n\t\n\tconst int n = 4;\n\tconst float fudge = 1.0; \n\tvec2 d = target/float(n);\n\tvec2 l;\n\tl.x = RippleHeight( vec2(0,target.y) );\n\tl.y = RippleHeight( vec2(target.x,0) );\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tvec2 s;\n\t\ts.x = RippleHeight( vec2(d.x*float(i),target.y) );\n\t\ts.y = RippleHeight( vec2(target.x,d.y*float(i)) );\n\t\tuv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);\n\t\tl = s;\n\t}\n\t\n\treturn (uv+vec2(0,1))/vec2(3.0,2.0);\n}\nvec3 Star(vec2 uv,vec2 pos,float angle,float scale) \n{\n    uv -=pos;\n    uv *=mat2(sin(radians(angle) + vec4(1,0,2,1)*1.5707));\n    uv /=scale;\n    float a = mod(atan(uv.x,-uv.y),2.*0.6283185)-0.6283185;\n    vec2 preuv = length(uv) * vec2(cos(a),sin(a))*1.23606794;\n    preuv.y = abs(preuv.y);\n    preuv.x -= 0.5;\n    float value = -(0.3467647*preuv.x+preuv.y)*25.534033;//0.2467647,15.534033;\n    return vec3(clamp(value,0.,1.));\n}\nvec3 Pattern(vec2 uv )\n{\n    uv = vec2(30.0*uv.x,20.0-uv.y*20.0);\n    \n    vec3 colorGold = vec3(255.0,222.0,0.0)/255.0;\n    vec3 colorRed = vec3(222.0,41.0,16.0)/255.0;\n\tvec3 colorSTAR = Star(uv,vec2(5,5),180.0,6.0);\n    colorSTAR = max(Star(uv,vec2(10,2),58.0,2.0),colorSTAR);\n    colorSTAR = max(Star(uv,vec2(12,4),91.0,2.0),colorSTAR);\n    colorSTAR = max(Star(uv,vec2(12,7),180.0,2.0),colorSTAR);\n    colorSTAR = max(Star(uv,vec2(10,9),58.0,2.0),colorSTAR);\n    float mask = float(colorSTAR.x>0.0);\n    // Output to screen\n    vec3 outcolor = mix(colorRed,colorGold,mask);\n    return outcolor;\n}\n\n\n// xyz = normal, w = transmission from far side\nvec4 Weave( vec2 uv )\n{\n\tvec2 a = uv*vec2(3.0,2.0)*view_Resolution.y*0.85;\n\tfloat h = (sin(a.x)+sin(a.y))*.25+.5;\n\t\n\th = h*.05; // transparency within the flag\n\t\n\t// edges\n\th = max(h,smoothstep(.495,.5,abs(uv.x-.5)));\n\th = max(h,smoothstep(.495,.5,abs(uv.y-.5)));\n\t\n\treturn vec4(0,0,0,h);\n}\n#define SS 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tview_Resolution = iResolution.xy;\n\tview_FragCoord = fragCoord.xy;\n\tview_Index = 1;\n\tview_selectionRelativeMouse = iMouse/view_Resolution.xyxy;\n    fragColor = vec4(0.0);\nfor(int x=0;x<SS;x++)\n{\n    vec3 seed = vec3(view_FragCoord,5*x);\n    vec3 jitter = d_hash3f(seed)-0.5;//vec2(x,y)/float(SS);\n    jitter*=0.5;\n\tvec3 pos;\n    vec3 ray;\n\n\tCamPolar( pos, ray, vec3(1.4,0,0), vec2(0.0,(sin(0.5*iTime))*3.1415926*0.10), 2.0, 0.5,jitter.xy );//if you like to move +-2.0*(view_selectionRelativeMouse.yx-0.5)\n    \n\t\t\n\tfloat t = 0.0;\n\tfloat h = 1.0;\n\tfor ( int i=0; i < 10; i++ )\n\t{\n\t\tif ( h < .01 )\n        {\n\t\t\tbreak;\n        }\n        float h = DistanceField( pos+t*ray );\n\t\tt += h;\n\t}\t\t\n\tpos += t*ray;\n\n    vec3 colb = texture( iChannel1, ray ).xyz;\n    \n\tvec2 uv = UVMapping( pos.xy );\t\t\n\tvec3 col = Pattern( uv );\t\t\n\tvec4 weave = Weave(uv);\t\t\n\tvec3 normal = Normal( pos );\n\t\t\n\tfloat nl = dot(normal,normalize(vec3(-1,1,-2)));\n\tfloat l = max( nl, .0 );\n    vec3 r = reflect(ray,normal);\n    \n    col *= 0.6*vec3(l)+pow(max(dot(-ray,normal),0.0),5.0)*0.4*max(dot(r,normal),0.0)*textureLod( iChannel1, r ,6.0).xyz/*Reflect*/+1.2*textureLod( iChannel1, normal,6.0).xyz/*radiance*/+0.1*textureLod( iChannel1, ray,3.0).xyz;//sss\n\n\tcol = mix( col, colb, weave.a );\t\t\t\t\n\tfragColor += clamp(vec4(pow(col,vec3(1.0)),1.0), 0.0, 10.0) / float(SS);// bug on some browser that += causing INF\n    \n}\n    //fragColor /= float(SS);\n    //\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}