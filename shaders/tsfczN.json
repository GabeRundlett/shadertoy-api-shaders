{
    "Shader": {
        "info": {
            "date": "1584269161",
            "description": "I imagined when the mission failed in the video game",
            "flags": 0,
            "hasliked": 0,
            "id": "tsfczN",
            "likes": 14,
            "name": "MISSION FAILED",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 686
        },
        "renderpass": [
            {
                "code": "float PI = 3.1415926535;\n\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\nvec2 pmod(vec2 p,float n){\n  float np = acos(-1.)*2.0/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec4 ground(vec3 p){\n\tfloat d = p.y+0.7*fbm(p.xz)+16.0*noise(p.xz*0.08-vec2(0.0,0.1))-0.15;\n\treturn vec4(0.,0.,0.,d);\n}\n// from:https://qiita.com/aa_debdeb/items/bffe5b7a33f5bf65d25b\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x - a.z * b.w + a.w * b.z,\n        a.x * b.z + a.y * b.w + a.z * b.x - a.w * b.y,\n        a.x * b.w - a.y * b.z + a.z * b.y + a.w * b.x\n    );\n}\n\n#define ITERATIONS 8\nvec2 Julia(vec4 p, vec4 c) {\n    vec4 z = p;\n    vec4 dz = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 pz, pdz;\n    float r = 0.0, dr = 1.0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        pz = z;\n        z = qmul(pz, pz) + c;\n        pdz = dz;\n        dz = 2.0 * qmul(pz, pdz);\n        r = length(z);\n        dr = length(dz);\n        if (r > 4.0) break;\n    }\n    return vec2(0.5 * log(r) * r / dr,r);\n}\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 m = max(s-q,0.0);\n\treturn length(abs(max(q-s,0.0)))-min(min(m.z,m.y),m.x);\n}\n\nvec4 tower(vec3 p){\n  float s = 0.11;\n  p -= vec3(-50.7,-6.,-3.);\n  p.xy *= rot(1.57);\n  float ci = 0.0;\n  float d = cube(p,vec3(15.,7.,7.));\n\n    vec2 dj =Julia(vec4(p*s,0.0),vec4(-0.9,0.2,0.2,0.0))/s;\n    d = dj.x;\n    ci = dj.y;\n\n  vec3 mat = vec3(clamp(log(ci*0.5),0.0,1.0));\n  mat = vec3(1.0);\n  float ks = 1.2;\n   p = mod(p,ks)-0.5*ks;\n   float cd = cube(p,vec3(0.4));\n\n   d = max(d,-cd);\n  return vec4(mat,d);\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec4 airplay(vec3 p){\n  p.x +=8.;\n  p.z -= 2.2;\n  p.y += 0.7;\n  p.xz *= rot(0.9);\n  float s = 1.3;\n  p *= s;\n  vec3 pp = p;\n  p.y += 0.35;\n  float d1 = cube(p+vec3(0.0,1.,0.0),vec3(3.7,1.6,2.9));\n  for(int i = 0;i<4;i++){\n    p = abs(p)-vec3(0.6,-0.13,0.4);\n    p.xz *= rot(1.5);\n    p.xy *= rot(1.4);\n  }\n    float d = cube(p,vec3(0.13,0.9,1.9));\n    d = max(d,-d1);\n    p = pp;\n    float dk1 = cube(p+vec3(0.0,1.4,0.0),vec3(3.7,1.6,2.9));\n    p.y -= 0.5;\n    p.x = abs(p.x)-0.4;\n    p.xy = pmod(p.xy,6.);\n      for(int i = 0;i<4;i++){\n        p = abs(p)-0.4*vec3(0.2,0.,0.2);\n        p.xz *= rot(0.1);\n        p.xy *= rot(1.1);\n      }\n      float d2 = cube(p,vec3(0.6,0.4,1.9));\n      d2 = max(d2,-dk1);\n      d = min(d,d2);\n      p = pp;\n      p.xz = abs(p.xz)-0.9;\n      p.yz *= rot(1.);\n      p.xz *= rot(-0.4);\n      float d3 = cube(p,vec3(0.05,0.05,1.5));\n      d = min(d,d3);\n      p = pp;\n      p.x = abs(p.x)-0.8;\n      p.z -= 1.3;\n      p.y -= 0.9;\n      p.xy *= rot(0.48);\n      p.xz *= rot(0.3);\n      p.yz  *= rot(0.2);\n      float d4 = cube(p,vec3(0.04,0.18,0.7));\n      d = max(d,-d4);\n      vec3 mat  = vec3(1.0);\n\n      mat = mix(0.3*vec3(0.5,0.9,0.9),mat,step(0.01,d4));\n      p = pp;\n      p.z += 2.;\n      p.y -= 1.2;\n        float d6 =  cube(p+vec3(0.,0.,1.),vec3(0.2,2.,1.));\n      p.yz *= rot(1.57*0.5);\n      float d5 = cube(p,vec3(0.02,0.9,0.9));\n\n      d = min(d,max(max(d5,-d6),-dk1));\n\n    return vec4(mat,d/s);\n}\n\nvec4 map(vec3 p){\n\tvec4 g = ground(p);\n\tvec4 ap = airplay(p);\n  vec4 tw = tower(p);\n\treturn min(min(g,tw),ap);\n}\n\nvec4 volume(vec3 p){\n    float time = iTime;\n    p -= vec3(-43.7,3.2,-9.5);\n    p.yz *= rot(0.5);\n    p.xy *= rot(0.2);\n    p.xz *= rot(2.3);\n    float sx = 7.9;\n    float sc = 2.8*pow((1.0-(p.x+sx)/(2.0*sx)),2.0);\n    p.y += sin(time+p.x);\n    float d1 = cube(p,vec3(sx,1.*sc,1.*sc))-2.0*fbm(p.xy*1.2-time*vec2(-2.,1.));\n  return vec4(-0.6*vec3(1.0),d1);\n}\n\nvec4 volumeFm(vec3 p){\n    float time = iTime;\n    p -= vec3(-43.7,3.2,-9.5);\n    p.yz *= rot(0.5);\n    p.xy *= rot(0.2);\n    p.xz *= rot(2.3);\n    float sx = 4.9;\n    float sc = 1.4*(1.0-(p.x+sx)/(2.0*sx));\n    p.y += sin(time+p.x);\n    float d1 = cube(p,vec3(sx,1.*sc,1.*sc))-2.0*fbm(p.xy*1.1-time*vec2(-2.,1.));\n  return vec4(clamp((1.0-sc*0.9),0.0,1.0)*vec3(1.0,0.2,0.0),d1);\n}\n\nvec3 getNormal(vec3 p)\n{\n vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += 0.0001;\n        n[i] = map(s.xyz).w;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat softray(vec3 ro, vec3 rd , float hn)\n{\n\tfloat t = 0.01;\n\tfloat jt = 0.0;\n\tfloat res = 1.;\n\tfor (int i = 0; i < 20; ++i) {\n\t\tjt = map(ro+rd*t).w;\n\t\tres = min(res,jt*hn/t);\n\t\tt = t+ clamp(0.02,10.,jt);\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nfloat ao(vec3 p,vec3 n,float len,float power){\n\tfloat oss =0.0;\n\tfor(int i =0;i<3;i++){\n\t\tfloat d = map(p+n*len/3.0*float(i+1)).w;\n\t\toss += (len-d)*power;\n\t\tpower *=0.5;\n\t}\n\treturn clamp(1.-oss,0.0,1.0);\n}\n\n\nvec3 LD = normalize(vec3(1.,1.,1.));\n\nvec3 groundColor(vec3 p,vec3 n,vec3 col,vec4 sla){\n\tfloat hl = max(dot(n, LD),0.0);\n\thl = hl * 0.5 + 0.5;\n\thl = hl * hl;\n  vec3 gcol = vec3(1.0);\n  gcol = mix(vec3(103./255.,66./255.,41./255.),gcol,smoothstep(0.8,0.9,n.y));\n  float sh = clamp((sla.x+0.1),0.0,1.0);\n  return vec3(hl)*gcol*sh*sla.y;\n}\n\nvec3 towercolor(vec3 p,vec3 n,vec3 col,vec4 sla){\n  \tfloat hl = max(dot(n, LD),0.0);\n  \thl = hl * 0.5 + 0.5;\n  \thl = hl * hl;\n    float sh = clamp((sla.x+0.1),0.0,1.0);\n  \treturn vec3(hl)*col*sh*sla.y;\n  }\n\n  float cube2D(vec2 p,vec2 s){\n  \tvec2 q = abs(p);\n  \tvec2 m = max(s-q,0.0);\n  \treturn length(abs(max(q-s,0.0)))-min(m.x,m.y);\n  }\n\n  vec3 airplaycolor(vec3 p,vec3 n,vec3 col,vec3 rd,vec4 sla){\n    float time = iTime;\n    p.x +=8.;\n    p.z -= 2.2;\n    p.y += 0.7;\n    p.xz *= rot(0.9);\n    for(int i = 0; i<4;i++){\n      p = abs(p)-0.5;\n      p.xy *= rot(1.2);\n      p.yz *= rot(1.0);\n    }\n    float ds = abs(cube2D(p.xz,vec2(0.5,0.2)));\n    vec3 em = vec3(0.0);\n    if(ds<0.02&&col.r>0.9){\n     col = vec3(0.5,0.5,0.5);\n     em = 1.0*vec3(0.9,0.1,0.1)*pow(abs(sin(time)),2.0);\n    }\n  \tfloat NdotL = max(dot(n, LD),0.0);\n    vec3 R = normalize( - LD + 2.0 *n * NdotL );\n \t\tfloat spec = pow(max(0., dot(R, -rd)), 10.0);\n\n    float sh = clamp((sla.x+0.1),0.0,1.0);\n    return (NdotL*col+spec)*sh*sla.y+em;\n  }\n\n  //https://www.shadertoy.com/view/lsKSWR\nfloat vig(vec2 uv)\n{\n   float time = iTime;\n   uv *=  1.0 - uv.yx;\n   float vig = uv.x*uv.y * (12.0+7.*noise(vec2(time*10.)));\n   vig = pow(vig, 0.45);\n   return vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float time = iTime;\n\tvec2 uv = fragCoord/iResolution.xy;\n  vec2 uv2 = uv;\n\tuv = (uv-0.5)*2.;\n\tuv.y *= iResolution.y/iResolution.x;\n\tvec2 p = uv;\n  float rkt = 3.7+0.1*mod(time*0.2,24.0*0.2);\n\n\tvec3 rk = vec3(-50.7+30.*sin(rkt),8.3,-3.+30.*cos(rkt));\n  vec3 mov = (mod(time,24.0)-8.0)*0.5*vec3(0.4,0.0,0.4);\n  vec3 ro = mix(vec3(1.8,1.3,0.)+mov,rk,step(12.,mod(time,24.)));\n\tvec3 ta = vec3(1.0,1.2,1.3);\n  ta += mov*step(mod(time,24.),12.);\n  ta += vec3(-50.7,-1.,-3.);\n\tvec3 fo = normalize(ta-ro);\n\tvec3 le = cross(fo,vec3(0.,1.,0.));\n\tvec3 up = cross(le,fo);\n\tfloat fov= 2.2;\n\tvec3 rd = normalize(vec3(fo*fov+up*p.y+le*uv.x));\n\tfloat t = 0.002;\n  float vd;\n  float vdF;\n\tfloat d = 0.0;\n\tvec4 red;\n\n  vec4 revd;\n  vec4 revdF;\n  vec3 accol = vec3(0.0);\n\tvec3 col = vec3(0.0);\n  float BSC = 0.4;\n  float ACOL = 0.4;\n  float bac = BSC;\n\tfor(int i = 0;i<79;i++){\n\t\tvec4 red = map(ro+rd*t);\n\t\td = 1.4*red.w;\n    revd = volume(ro+rd*t);\n    vd = max(revd.w,bac);\n    revdF = volumeFm(ro+rd*t);\n    vdF = max(revdF.w,bac);\n    float jst = step(0.2,d);\n    accol += ACOL*revd.xyz*exp(-vd)*jst;\n    accol += ACOL*revdF.xyz*exp(-vd);\n    d = min(min(d,vd),vdF);\n    t +=0.7*d;\n\t}\n\n  vec3 spos = ro+rd*t;\n\tvec3 normal = getNormal(spos);\n  vec3 ref = reflect(rd,normal);\n  float sh = softray(spos,LD,3.3);\n  float ao = ao(spos,normal,0.25,1.);\n  vec4 sla = vec4(sh,ao,0.0,0.0);\n\tif(ground(spos).w<0.01){\n\t\tcol = groundColor(spos,normal,red.xyz,sla);\n\t}else if(tower(spos).w<0.01){\n    col = towercolor(spos,normal,tower(spos).xyz,sla);\n  }\n  else if(airplay(spos).w<0.01){\n    col = airplaycolor(spos,normal,airplay(spos).xyz,rd,sla);\n  }\n\n\n\n  vec3 fogcol = vec3(0.5,0.5,0.5);\n  float far = 350.;\n  float near =0.0;\n  float fogk = clamp((far-t-300.*fbm(time+spos.xz*0.1+0.01*spos.y))/(far-near),0.0,1.0);\n  col = mix(fogcol,col,fogk);\n  col += 0.1*accol;\n  col *= vig(uv2);\n\tfragColor = vec4(col,0.2);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}