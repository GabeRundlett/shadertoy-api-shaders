{
    "Shader": {
        "info": {
            "date": "1553118188",
            "description": "Coloring tiles based on a moiré pattern.",
            "flags": 32,
            "hasliked": 0,
            "id": "Wd2XzD",
            "likes": 56,
            "name": "Moiré Tiles",
            "published": 3,
            "tags": [
                "2d",
                "bloom"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1567
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\n#define SAMPLES 30\n#define BLOOM_RADIUS 80.0\n\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted( in vec3 color ) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n// Dave_Hoskins hash\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33( in vec3 p3 ){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 bloom = vec3(0);\n    float totfac = 0.0;\n    \n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    float offset = rnd.x*2.0*PI;\n    \n    // bloom\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float theta = 2.0*PI*PHI*float(i) + offset;\n        float radius = sqrt(float(i)) / sqrt(float(SAMPLES));\n        radius *= BLOOM_RADIUS;\n        vec2 offset = vec2(cos(theta), sin(theta))*radius;\n        vec2 delta = vec2( 1.0+exp(-abs(offset.y)*0.1) , 0.5);\n        offset *= delta;\n        vec4 here = textureGrad(iChannel0,(fragCoord+offset)/iResolution.xy, \n                                vec2(.02, 0), vec2(0, 0.02));\n        float fact = smoothstep(BLOOM_RADIUS, 0.0, radius);\n        bloom += here.rgb*0.05*fact;\n        totfac += fact;\n    }\n    \n    bloom /= totfac;\n    \n    // chromatic aberration\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = uv*2.0-1.0;\n    mo *= 0.01;\n    fragColor.r = textureLod(iChannel0, uv-mo*0.1, 0.0).r;\n    fragColor.g = textureLod(iChannel0, uv-mo*0.6, 0.0).g;\n    fragColor.b = textureLod(iChannel0, uv-mo*1.0, 0.0).b;\n    \n    // add bloom\n    fragColor.rgb += bloom;\n    // vignette\n    vec2 vi = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb *= (1.0-sqrt(dot(vi,vi)*0.45));\n    // tonemapping\n    fragColor.rgb = ACESFitted(fragColor.rgb);\n    // gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    // dithering\n    fragColor.rgb += (rnd-0.5)*0.1;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - iResolution.xy*0.5;\n    uv /= iResolution.y;\n    \n    // screen deformation\n    uv += uv*dot(uv,uv)*0.1;\n    \n    // get tile and center\n    uv *= 16.0;\n    vec2 center = floor(uv) + 0.5;\n    uv = uv - center;\n    \n    // get max distance to border to clamp\n    vec2 abuv = abs(uv);\n    float border = smoothstep(0.5, 0.1, max(abuv.x, abuv.y));\n    // colorize according to center and tile\n    vec3 col = sin(length(center*1.0*cos(abs(center)*49.0+iTime*0.05))*vec3(1, 2, 3)+iTime*2.0)*0.5+0.5;\n    col = pow(col, vec3(10));\n    col *= border;\n    \n    // draw a circle\n    float d = length(uv);\n    float s = smoothstep(1.1, 0.1, d);\n    \n    // composite to final color\n    fragColor.rgb = pow(s, 12.0)*col*100.0;\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}