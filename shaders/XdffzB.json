{
    "Shader": {
        "info": {
            "date": "1496678595",
            "description": "Blue is first derivative of red.\n\ncanvas to display derivative arithmetic, utilizing the [chain rule] within dual number arithmetic.\n\nis possibly buggy and incomplete.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdffzB",
            "likes": 2,
            "name": "023 gradient differentiation",
            "published": 3,
            "tags": [
                "gradient",
                "derivative",
                "differential",
                "automaticdifferentiation",
                "derivativearithmetic"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 607
        },
        "renderpass": [
            {
                "code": "//parent:           https://www.shadertoy.com/view/XlV3Dy\n//disabled brother: https://www.shadertoy.com/view/MdjcD3 (failed attempt with arrays)\n\n//this aims to unify \n//https://www.shadertoy.com/results?query=derivative+arithmetic\n//and\n//https://www.shadertoy.com/results?query=contour\n//but the tool set is likely not quite done:\n//\n//I am Stil learning the core of implementing automatic differentiation.\n//and gradients in 2 or 3 dimensions, and that is tricky practice.\n//\n//so THIAS might also be simpler to learn \n//... by constraining self to a 2d plane.\n\n//This extends its family to include lower dimensioal pairs.\n//The 0th derivative is .x of a dual number.\n//All other parameters are first derivatives, \n//...to be used within the [chain rule]\n//\n//This may be confusing.\n//But once you see trough it, a lot more symmetry becomes clear.\n\n//one way is to reduce the number of dimesions \n//to make it a bit simpler, and also more general (n dimensional)\n\n\n//Below library defines \"dual\" number arithmetic\n//where .x is the result of the arithmetic function of .x\n//... and  .y (.yz, .yzw) are the first derivative of .x\n//All functions with multiple parameters utilize the chain rule:\n//https://www.youtube.com/watch?v=YG15m2VwSjA\n//except for the mind() and maxd() functions, (duh!)\n//All functions with only 1 parameter do NOT use the chain rule (duh!)\n//... and they have parameter-chain-ruled variuant (with conflicting namespaces)\n\n//This has a lot of permutated versions, \n//...with less verbose input parameters, \n//...allowing for vector operation shorthands\n//...and allowing to use the same \"dual\" arithmetic \n//...with 2 or 3 dimensions, just like opengl vector arithmetic.\n#define v1 float\n#define v2 vec2\n#define v3 vec3\n#define v4 vec4\n//return a or b, depending on which .x is larger, or smaller.\n#define min1 {return mix(b,a,step(a.x,b.x));}\n#define min3 {return mind(b,a);}\nv2 mind(v2 a,v2 b)min1\nv3 mind(v3 a,v3 b)min1\nv4 mind(v4 a,v4 b)min1//equal permutation, no verbose dimension shorthands.\nv2 mind(v1 a,v2 b){return mind(v2(a,0),b);}\nv3 mind(v2 a,v3 b){return mind(v3(a,0),b);}\nv3 mind(v1 a,v3 b){return mind(v2(a,0),b);}\nv4 mind(v3 a,v4 b){return mind(v4(a,0),b);}\nv4 mind(v2 a,v4 b){return mind(v3(a,0),b);}\nv4 mind(v1 a,v4 b){return mind(v2(a,0),b);}//unequal permutation Adimensions lessThan Bdimensions\nv2 mind(v2 a,v1 b)min3\nv3 mind(v3 a,v2 b)min3\nv3 mind(v3 a,v1 b)min3\nv4 mind(v4 a,v3 b)min3\nv4 mind(v4 a,v2 b)min3\nv4 mind(v4 a,v1 b)min3//unequal permutation Adimensions greaterThan Bdimensions\nv1 mind(v1 a,v1 b){return min(a,b);}\nv1 mind(v2 a){return mind(a.x,a.y);}\n//negation identity:\n#define maxd(a,b) -mind(-a,-b)\nfloat rec(float a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n//single parameter operations are MUCH simpler here:\n//#define siq safeinv(q),q);}\n#define pow2d(a) vec2(a*a,2.*a)\n//above special case should tell you what is going on here.\n#define sqrtd(a) vec2(sqrt(a),.5*rec(sqrt(a)))\n#define sind(a) vec2(sin(a), cos(a))\n#define cosd(a) vec2(cos(a),-sin(a))\n#define absd(a) vec2(abs(a),sign(a))\n#define expd(a) vec2(exp(a),a) \n#define logd(a) vec2(log(a),a)\n//        pow (x,y) exp (     log (x)*y )\n//#define powd(x,y) expd(muld(logd(x),x))\n//\n//but single parameter functions extra symmetry \n//...causes a namespace conflict here:\n//above is simple dual with derivative as secondary parameters,\n//needed for gradient calculation, \n//... the above 5 functions are NOT for automatic differentiation!\n//below is chain rule of above\n//appliying chain rule to multiple dimensions at once:\n#define pow22(a,b) pow2d(a)*vec2(1,b)\n#define sqrt2(a,b) sqrtd(a)*vec2(1,b)\n#define  sin2(a,b)  sind(a)*vec2(1,b)\n#define  cos2(a,b)  cosd(a)*vec2(1,b)\n#define  abs2(a,b)  absd(a)*vec2(1,b)\n#define  exp2(a,b)  expd(a)*vec2(1,b)\n#define  log2d(a,b)  logd(a)*vec2(1,b)\n#define pow23(a,b) pow2d(a)*vec3(1,b,b)\n#define sqrt3(a,b) sqrtd(a)*vec3(1,b,b)\n#define  sin3(a,b)  sind(a)*vec3(1,b,b)\n#define  cos3(a,b)  cosd(a)*vec2(1,b,b)\n#define  abs3(a,b)  absd(a)*vec2(1,b,b)\n#define  exp3(a,b)  expd(a)*vec2(1,b,b)\n#define  log3(a,b)  logd(a)*vec2(1,b,b)\n#define pow24(a,b) pow2d(a)*vec4(1,b,b,b)\n#define sqrt4(a,b) sqrtd(a)*vec4(1,b,b,b)\n#define  sin4(a,b)  sind(a)*vec4(1,b,b,b)\n#define  cos4(a,b)  cosd(a)*vec4(1,b,b,b)\n#define  abs4(a,b)  absd(a)*vec4(1,b,b,b)\n#define  exp4(a,b)  expd(a)*vec4(1,b,b,b)\n#define  log4(a,b)  logd(a)*vec4(1,b,b,b)\n//if(only the return type is different)\n//... I can not share namespaces anyways! (silly parser)\n\n//all below functions are dual-parameter functions, \n//...where the chain rule is already included.\n//(because a second parameter breaks a lot of symmetry!)\n\nv2 modd(v2 a,v2 b){return vec2(mod(a.x,b.x),mod(a.y,1.));}\n#define mab mod(a.x,b.x)\n#define may mod(a.yzw,1.));}\nv4 modd(v4 a,v1 b){return vec4(mod(a.x,b),may\nv3 modd(v3 a,v1 b){return vec3(mod(a.x,b),mod(a.yz,1.));}\nv2 modd(v2 a,v1 b){return vec2(mod(a.x,b),mod(a,1.));}\nv4 modd(v4 a,v2 b){return vec4(mab,may\nv4 modd(v4 a,v3 b){return vec4(mab,may\nv3 modd(v3 a,v2 b){return vec3(mab,mod(a.yz,1.));}\nv4 modd(v2 a,v4 b){return vec4(mab,0,0,0);}\nv4 modd(v3 a,v4 b){return vec4(mab,0,0,0);}\nv4 modd(v1 a,v4 b){return vec4(mod(a,b.x),0,0,0);}\nv3 modd(v1 a,v3 b){return vec3(mod(a,b.x),0,0  );}\nv2 modd(v1 a,v2 b){return vec2(mod(a,b.x),0    );}\n                               //substraction is a differential, making this simple\nv4 subd(v4 a,v4 b){return a-b;}\nv3 subd(v3 a,v3 b){return a-b;}\nv2 subd(v2 a,v2 b){return a-b;}\nv4 subd(v4 a,v1 b){return vec4(a.x-b  ,a.yzw);}\nv4 subd(v4 a,v2 b){return vec4(a.x-b.x,a.yzw);}\nv4 subd(v4 a,v3 b){return vec4(a.x-b.x,a.yzw);}\nv3 subd(v3 a,v1 b){return vec3(a.x-b  ,a.yz);}\nv3 subd(v3 a,v2 b){return vec3(a.x-b.x,a.yz);}\nv2 subd(v2 a,v1 b){return vec2(a.x-b  ,a.y);}\nv4 subd(v1 a,v4 b){return vec4(a  -b.x,-b.yzw);}\nv4 subd(v2 a,v4 b){return vec4(a.x-b.x,-b.yzw);}\nv4 subd(v3 a,v4 b){return vec4(a.x-b.x,-b.yzw);}\nv3 subd(v1 a,v3 b){return vec3(a  -b.x,-b.yz);}\nv3 subd(v2 a,v3 b){return vec3(a.x-b.x,-b.yz);}\nv2 subd(v1 a,v2 b){return vec2(a  -b.x,-b.y);}\n//addition is negated substraction.\n#define addd(a,b) subd(a,-b)\n//multiplication is product rule (within chain rule)\n#define atb b){return a*b;}\nv4 muld(v4 a,v1 atb\nv4 muld(v1 a,v4 atb\nv3 muld(v3 a,v1 atb\nv3 muld(v1 a,v3 atb\nv2 muld(v2 a,v1 atb\nv2 muld(v1 a,v2 atb\nv4 muld(v4 a,v4 b){return vec4(a.x*b.x,a.yzw*b.x+a.x*b.yzw);}\nv3 muld(v3 a,v3 b){return vec3(a.x*b.x,a.yz *b.x+a.x*b.yz );}\nv2 muld(v2 a,v2 b){return vec2(a.x*b.x,a.y  *b.x+a.x*b.y  );}\nv3 muld(v2 a,v3 b){return vec3(a.x*b.x,a.yy *b.x+a.x*b.yz );}\nv3 muld(v3 a,v2 b){return vec3(a.x*b.x,a.yz *b.x+a.x*b.yy );}\nv4 muld(v4 a,v3 b){return vec4(a.x*b.x,a.yzw*b.x+a.x*b.yzz);}//nonsense?\nv4 muld(v4 a,v2 b){return vec4(a.x*b.x,a.yzw*b.x+a.x*b.yyy);}\nv4 muld(v3 a,v4 b){return vec4(a.x*b.x,a.yzz*b.x+a.x*b.yzw);}//nonsense?\nv4 muld(v2 a,v4 b){return vec4(a.x*b.x,a.yyy*b.x+a.x*b.yzw);}\n        //non-baseâ‚¬N exponential identity utilizes baseE:\n//...which is still not efficient.\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define powd(x,y) expd(muld(logd(x),x))\n//reciprocal derivatices are most confusing.\nv4 divd(v4 a,v1 b){return a/b;}\nv3 divd(v3 a,v1 b){return a/b;}\nv2 divd(v2 a,v1 b){return a/b;}\n#define bxx /(b.x*b.x));}\nv4 divd(v1 a,v4 b){return vec4(a  /b.x,(-a  *b.yzw)bxx\nv4 divd(v2 a,v4 b){return vec4(a.x/b.x,(-a.x*b.yzw)bxx\nv4 divd(v3 a,v4 b){return vec4(a.x/b.x,(-a.x*b.yzw)bxx\nv4 divd(v4 a,v4 b){return vec4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)bxx\nv4 divd(v4 a,v3 b){return vec4(a.x/b.x,(a.yzw*b.x-a.x*b.yzz)bxx//nonsense?\nv4 divd(v4 a,v2 b){return vec4(a.x/b.x,(a.yzw*b.x-a.x*b.yyy)bxx//nonsense?\n\n                               //and it gets trickier with functions that take 3 parameters:\nvec4 lengthd(v4 x,v4 y){float q=length(vec2(x.x,y.x));\n return vec4(q,(x.yzw*x.x+y.yzw*y.x)*rec(q));}\nvec3 lengthd(v3 x,v3 y){float q=length(vec2(x.x,y.x));\n return vec3((x.yz*x.x+y.yz*y.x)*rec(q),q);}\nvec2 lengthd(v2 x,v2 y){float q=length(vec2(x.x,y.x));\n return vec2(q,(x.y*x.x+y.y*y.x)*rec(q));}\nvec4 lengthd(v4 x,v4 y,v4 z){float q=length(vec3(x.x,y.x,z.x));\n return vec4(q,(x.yzw*x.x+y.yzw*y.x+z.yzw*z.x)*rec(q));}\n//the utility of a length() function is clear.\nstruct DAVec2{vec3 x;vec3 y;};\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nDAVec2 da_domain(vec2 p){return DAVec2(\n vec3(p.x,1.,0.),\n vec3(p.y,0.,1.));}\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(p.x,1.,0.,0.),\n vec4(p.y,0.,1.,0.),\n vec4(p.z,0.,0.,1.));}\n//return \"dFd.xyz()\", which is like \n//dFdx(),dFdy(),but its 3d\"dual\" muber version\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/dFdx.xhtml\n//where .x is the 0th derivative.\n//where .ywz are first derivatives along 3 carthesian main axes.\nvec4 da_dot(DAVec3 a, DAVec3 b){ \n vec4 t0=muld(a.x,b.x),t1=muld(a.y,b.y),t2=muld(a.z,b.z); \n return addd(addd(t0,t1),t2);}\n\n                               \n//\n//\n//\n//\n//This distance field function is just a dumb test:\n//It needs to exist for the grad() gradient function.\n//It should utilize automatic differentiation.\n//...but it does not do that for now.\nvec2 f(vec2 p){//return cos(p.x)-p.y;\n DAVec2 d=da_domain(p);\n //vec3 l=lengthd(d.x,d.y);return l.xy;\n return expd(p.x);\n return logd(p.x);\n return sind(p.x);    \n //p.x*=2.;return length(p);//a distance field\n}\n\n//return gradient for position [p], by 4*Sampling the 2d_distance_field f();\nvec2 grad(in vec2 p){\n vec2 h=vec2(.01,.0);\n return vec2(f(p+h.xy).x-f(p-h.xy).x,f(p+h.yx).x-f(p-h.yx).x)/(2.*h.x);}\n//grad() is ALMOST the 2d equivalent to getting a 3d normal vector of a 3d distance Field.\n//return smoothstep()_contour for point x of distanceField f() \nfloat color( in vec2 x ){vec2  g=grad(x);float v=f(x).x,d=abs(v)/length(g);\n //return fract(d*9.);\n return smoothstep(.19,.20,d);}\n//yeah, this si WAY too limited to be useful to me.\n//only works fror short distances\n\n//gradient == the vec2() of the first derivative at p in 2 directions...\n//you then return 0thderivativeAtP/length(gradientAtP)\n\n//oh yeah, for 2d analysis, i basically make 3 images.\n//vec3(field,field.derivative.x,dield.derivative.y)\n//and the fun part is that the derivatives calculate automatically.\n\n//this daDemo2() is more of a playground\n#define thick .05\nvec3 daDemo2(vec2 p){\n vec2 u=f(p)-p.y;\n \n //   vec2 g=vec2(0);\n float g=mind(mind(abs(fract(p))),abs(fract(length(p)+thick)-thick));//green\n float blur=40./max(iResolution.y,1.);\n //u=fract(u);\n u=abs(u);\n return smoothstep(blur,-blur,vec3(u.x,g,u.y));\n}\n\nvec3 daDemo(vec2 p){\n vec2 f=abs(fract(p));//green carthesian grid\n float h=abs(fract(length(p)+thick)-thick);//green polar circles\n float g=min(min(f.x,f.y),h);\n vec2 d=sind(p.x);\n //float div=sqrt(1.+p.y*p.y);\n float r=abs(sin(p.x)-p.y)/(sqrt(1.+d.y*d.y))-thick;    \n p.x+=acos(0.);\n d=sind(p.x).xy;\n float b=abs(sin(p.x)-p.y)/(sqrt(1.+d.y*d.y))-thick;\n //this does not work for scaled p, is far from being uder friendly\n\n float blur=20./max(iResolution.y,1.);\n return smoothstep(blur,-blur,vec3(r,g,b));}\n\n\n#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U)*9.;\n vec2 m=frame(iMouse.xy)*9.;\n vec3 d=daDemo(u);//cos(u.x)-u.y;\n //d=fract(d);\n //d=smoothstep(.1,-.1,d-.9);\n //d*=.5;\n// d=fract(d*.8);//seesaw first derivative, contrast illusion.\n //u=fract(u);\n O=vec4(d,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}