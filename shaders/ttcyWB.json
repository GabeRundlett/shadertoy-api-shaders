{
    "Shader": {
        "info": {
            "date": "1609805526",
            "description": "Learing geometry, the blending formula comes firom https://www.jcohen.name/papers/Ferreira_Levelsets_2007.pdf, but it looks not so right.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttcyWB",
            "likes": 0,
            "name": "SDF_Learning",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "Alienity",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "float sdfCircle(vec2 coord, vec2 center, float radius)\n{\n\tvec2 offset = coord - center;\n\treturn sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;\n}\n\nfloat sdfTorus(vec2 coord, vec2 center, float radius1, float radius2)\n{\n    vec2 offset = coord - center;\n    return abs(sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius1) - radius2;\n}\n\nfloat sdfEclipse(vec2 coord, vec2 center, float a, float b)\n{\n    float a2 = a * a;\n    float b2 = b * b;\n    return (b2 * (coord.x - center.x) * (coord.x - center.x) +\n        a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2) / (a2 * b2);\n}\n\nfloat sdfBox(vec2 coord,  vec2 center, float width, float height)\n{\n    vec2 d = abs(coord - center) - vec2(width, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdfRoundBox(vec2 coord,  vec2 center, float width, float height, float r)\n{\n    vec2 d = abs(coord - center) - vec2(width, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n//*****************************Hard Blend******************************\nfloat sdfUnion(const float a,const float b) {\n    return min(a, b);\n}\n\nfloat sdfDifference(const float a, const float b) {\n    return max(a, -b);\n}\n\nfloat sdfIntersection(const float a, const float b) {\n    return max(a, b);\n}\n//*********************************************************************\n\n//******************************Soft Blend*****************************\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n//*********************************************************************\n\n\n//*********************************************************************\n// https://www.jcohen.name/papers/Ferreira_Levelsets_2007.pdf\nfloat sdfBlending(float A, float B, const float alpha, float beta, float gamma) {\n    // A is the SDF the first geometry, B is the SDF of the second geometry and \n    // alpha is the filtering distance.\n    float m = clamp(abs(alpha-A),0.0f,alpha)/alpha*clamp(abs(alpha-B),0.0f,alpha)/alpha;\n    // the blended levelset. beta is the blending curve exponetial and gamma is the \n    // size of the extrusion in the blending area.\n    float C = min(A, B) + pow(m, beta) * gamma;\n    return C;\n}\n//*********************************************************************\n\n\nvec4 render(float d, vec3 color, float stroke) \n{\n\tfloat anti = fwidth(d) * 1.0;\n\tvec4 colorLayer = vec4(color, 1.0 - smoothstep(-anti, anti, d));\n\tif (stroke < 0.000001) {\n\t\treturn colorLayer;\n\t}\n\n\tvec4 strokeLayer = vec4(vec3(0.05, 0.05, 0.05), 1.0 - smoothstep(-anti, anti, d - stroke));\n\treturn vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = 0.5f * iResolution.x;\n    float y = sin(iTime * 1.0f)*60.0f + 0.5f * iResolution.y;\n    vec2 circleCenter = vec2(x, y);\n\n    float r = sdfCircle(fragCoord.xy, circleCenter, 25.0f);\n    float r_1 = sdfCircle(fragCoord.xy, circleCenter, 10.0f);\n    r = sdfDifference(r, r_1);\n    \n    float r2 = sdfBox(fragCoord.xy, iResolution.xy*0.5f, 40.0f, 30.0f);\n    float r2_1 = sdfBox(fragCoord.xy, iResolution.xy*0.5f, 20.0f, 10.0f);\n    r2 = sdfDifference(r2, r2_1);\n    \n    //float r4 = sdfBlending(r, r2, 5.0f, 1.0f, 2.0f);\n    float r4 = opSmoothUnion(r, r2, 7.0f);\n    vec4 col = render(5.0f, vec3(0.5f, 0.05f, 0.0f), r4);\n    \n    // Output to screen\n    fragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}