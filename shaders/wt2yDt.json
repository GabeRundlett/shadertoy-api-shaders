{
    "Shader": {
        "info": {
            "date": "1595773147",
            "description": "Nicer waves, and much better framerate.",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2yDt",
            "likes": 1,
            "name": "Waves v.5",
            "published": 3,
            "tags": [
                "learning"
            ],
            "usePreview": 0,
            "username": "pli",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define EYE_COLOR vec3(0., 0.0, 0.0)\n\n#define BOAT_INITIAL_X 0.1\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nfloat heightAt(float xd, float z) {\n    return -0.1 + 0.01 * cos(13.*xd + 2.*z);\n}\n\nfloat boatHeight(vec3 pos, float delta) {\n    return -0.1 - 0.01 * cos(6. * pos.x + delta * 2. * 3.14159) + 0.1;\n}\n\nfloat sphereSize(float x, float z) {\n    return 0.1 + 0.02 * cos(4.*x - z);\n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\tfloat initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\tvec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .5;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1.,5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.205, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n\n    col = colorVariation * (0.75 + dot(normal, light));\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.3);\n\tcol = mix(col, vec3(1.), (shineVariation -  0.5 * colorVariation) * spec);\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}