{
    "Shader": {
        "info": {
            "date": "1472167225",
            "description": "Just playing around with radial blur, volume rendering, and noise.",
            "flags": 32,
            "hasliked": 0,
            "id": "4ltGDS",
            "likes": 31,
            "name": "Sunfall",
            "published": 3,
            "tags": [
                "volume",
                "sun",
                "radialblur",
                "godray"
            ],
            "usePreview": 1,
            "username": "vgs",
            "viewed": 1832
        },
        "renderpass": [
            {
                "code": "// Created by Vinicius Graciano Santos - vgs/2016\n// https://www.shadertoy.com/view/4ltGDS\n// Making of: http://viniciusgraciano.com/blog/making-of-sunfall/\n\n// The second pass renders the sun and its godrays.\n\n#define STEPS 100\n\n// Hash by Dave Hoskins ( https://www.shadertoy.com/view/4djSRW )\nvec2 hash(vec2 p) {\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 st = fragCoord.xy / iResolution.xy;    \n    vec2 center = vec2(0.27, 0.66);\n    \n    // Radial blur \n    vec3 tot = vec3(0.0); float w = 1.0;\n    vec2 dir = (center - st) / float(STEPS), uv = st;\n    for (int i = 0; i < STEPS; ++i) {\n        vec4 s = texture(iChannel0, uv);\n        tot += s.a * w; w *= 0.995;\n        \n        // hashing reduces banding,\n        // but introduces noise!\n        uv += dir*(0.9 + 0.15*hash(uv + iTime));\n    }\n    tot /= float(STEPS);\n    \n    // Result from first pass\n    vec3 col = texture(iChannel0, st).rgb;\n\t\n    // Composite the sun\n    col = mix(col, tot * vec3(1.0, 0.792, 0.455), 0.7);\n    \n    // Post processing\n    col = clamp(1.5*col, 0.0, 1.0);\n    col *= 0.5 + 0.5*pow(10.*st.x*st.y*(1.0-st.x)*(1.0-st.y), 0.3);    \n    col = smoothstep(0.0, 0.6, col+0.05);\n    col = pow(col, vec3(1.0/2.2));\n            \n    fragColor = vec4(col, 1.0);\n        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Vinicius Graciano Santos - vgs/2016\n// https://www.shadertoy.com/view/4ltGDS\n// Making of: http://viniciusgraciano.com/blog/making-of-sunfall/\n\n// The first pass renders the background, the terrain, and the dust volumetric effect.\n\n#define RAYMARCH_STEPS 80\n#define FAR_PLANE 150.0\n\n// Perlin Noise using quintic interpolation\nfloat noise(vec2 uv) {    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec4 i = vec4(iuv, iuv + 1.0);\n    vec4 f = vec4(fuv, fuv - 1.0);        \n    \n    i = (i + 0.5) / iChannelResolution[0].xyxy;\n        \n    vec2 grad_a = 2.0 * texture(iChannel0, i.xy, -100.0).rg - 1.0;\n    vec2 grad_b = 2.0 * texture(iChannel0, i.zy, -100.0).rg - 1.0;\n    vec2 grad_c = 2.0 * texture(iChannel0, i.xw, -100.0).rg - 1.0;\n    vec2 grad_d = 2.0 * texture(iChannel0, i.zw, -100.0).rg - 1.0;\n    \n    float a = dot(f.xy, grad_a);\n    float b = dot(f.zy, grad_b);\n    float c = dot(f.xw, grad_c);\n    float d = dot(f.zw, grad_d);\n        \n    fuv = fuv*fuv*fuv*(fuv*(fuv*6.0 - 15.0) + 10.0);    \n    return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n}\n\n// Low quality, turbulent FBM\nfloat fbm(vec2 uv) {\n    float h = 0.0, a = 1.0;    \n    for (int i = 0; i < 4; ++i) {\n        h += 1.0-abs(a * noise(uv));\n        a *= 0.45; uv *= 2.02;\n    }\n        \n    return h;\n}\n\n// High quality, turbulent FBM\nfloat fbmH(vec2 uv) {\n    float h = 0.0, a = 1.0;\n    \n    for (int i = 0; i < 9; ++i) {\n        h += 1.0-abs(a * noise(uv));\n        a *= 0.45; uv *= 2.02;\n    }\n        \n    return h;\n}\n\n// Auxiliary functions for raymarching\nfloat terrain(vec2 p) {\n    float h = fbm(0.025 * p);\n    return 10.0*h;\n}\nfloat terrainH(vec2 p) {\n    float h = fbmH(0.025 * p);        \n    return 10.0*h;\n}\nfloat map(vec3 p) {    \n    return 0.8*(p.y - terrain(p.xz));\n}\nfloat mapH(vec3 p) {\n    return p.y - terrainH(p.xz);\n}\n\n// Filter the normal at a distance to avoid aliasing\nvec3 normal(vec3 p, float t) {       \n    vec2 q = vec2(0.0, t * t / iResolution.y + 0.01);\n    return normalize(vec3(mapH(p + q.yxx) - mapH(p - q.yxx),\n                          mapH(p + q.xyx) - mapH(p - q.xyx),\n                          mapH(p + q.xxy) - mapH(p - q.xxy)));\n}\n\n// Just a basic raymarcher, not much to see here...\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0, pix = 2.0 / iResolution.y;    \n        \n    for (int i = 0; i < RAYMARCH_STEPS; ++i) {        \n        float d = map(ro + t * rd);\n        if (d < pix * t || t > FAR_PLANE)\n            break;        \n        t += d;\n    }\n        \n    return t;\n}\n\n// Global variables\nvec3 g_sundir = normalize(vec3(-0.75, 0.0, -1.0));\nvec3 g_suncol = 1.65*vec3(1.0, 0.792, 0.455);\nvec3 g_sand_diff = vec3(0.76, 0.7, 0.5);\nvec3 g_sky_blue = vec3(0.218, 0.325, 0.455);\n\n// Background Color\nvec3 bg(vec3 rd) {     \n    vec3 col = mix(vec3(0.547, 0.455, 0.218), \n                   g_sky_blue, \n                   smoothstep(-0.5, 1.0, rd.y));\n    return 1.65*col;            \n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {    \n    const float pi = 3.141592;\n    \n    vec3 p = ro + t * rd;\n    vec3 n = normal(p, t);    \n    \n    // Diffuse        \n    vec3 diff_brdf = g_sand_diff / pi;\n    \n    // Specular\n    float m = 20.0;\n    vec3 h = normalize(g_sundir - rd);\n    vec3 spec_brdf = vec3((m + 8.0)*pow(max(dot(n, h), 0.0), m)/(8.0*pi));    \n    float schlick = 0.045 + 0.955*pow(1.0 - dot(h, -rd), 5.0);\n    \n    // Rendering Equation\n    vec3 brdf = mix(diff_brdf, spec_brdf, schlick);    \n    vec3 col = brdf * g_suncol * max(dot(n, g_sundir), 0.0);\n\t        \n    // Fill light hack\n    col += 0.75*g_sky_blue*diff_brdf*max(dot(n, -rd), 0.0);\n    \n    // Ambient Hack\n    m = smoothstep(0.0, 1.0, n.y);\n    col = mix(col, g_sand_diff * vec3(0.382, 0.39, 0.336)*m, 0.2);\n    \n    float fog = exp(-0.015*t);\n    return mix(bg(rd), 7.0*col, fog);\n}\n\n// LookAt transform for positioning the camera\nmat3 lookAt(vec3 position, vec3 target) {\n    vec3 f = normalize(position - target);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    return mat3(r, cross(f, r), f);\n}\n\n// I decided to add a volumetric effect and was lazy to code 3D Perlin Noise,\n// so I got the 3D Value Noise by iq ( https://www.shadertoy.com/view/4sfGzS )\nfloat hash(float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Another FBM function, but uses IQ's 3D Value Noise\nfloat fbm(vec3 p) {\n\tfloat k = 0.0;\n\tp *= 1.25;\t\n\tk += 1.000*noise(p); p*=2.0;\n\tk += 0.500*noise(p); p*=2.0;\n\tk += 0.250*noise(p);\n\treturn k/1.75;\n}\n\n// Volume-march backwards after the main raymarcher has finished\nvec3 volmarch(vec3 ro, vec3 rd, float t, vec3 col) {    \n    float pix = 2.0 / iResolution.y;\n   \n    for (int i = 0; i < 10; ++i) {\n        vec3 p = ro + t * rd - vec3(-.5, .5, .1)*iTime;\n    \tfloat EPS = pix * t;\n        \n        float f1 = 0.25*fbm(p);\n        float f2 = 0.25*fbm(p + EPS*g_sundir);\n        \n        // Directional derivatives FTW!\n        //( https://iquilezles.org/articles/derivative )\n        vec3 shade = g_suncol * g_sand_diff * max(f2 - f1, 0.0)/EPS;\n        \n        col = mix(col, shade, f1*smoothstep(0.1, -0.2, rd.y));\n        \n        // hashing to reduce banding\n        t *= 0.9*(0.9 + 0.1*hash(t));\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    // Trace rays\n    vec2 pos = vec2(0.0, -iTime-100.0);\n    vec3 ro = vec3(pos.x, terrain(pos) + 2.0, pos.y);\n    mat3 m = lookAt(ro, ro - vec3(0.0, 0.25, 1.0));\n    vec3 rd = normalize(m*vec3(uv, -1.0));    \n    \n    // Main raymarcher and shading routines\n    fragColor = vec4(bg(rd), 0.0);\n    if (rd.y > 0.2)        \n        return;    \n    \n    float t = raymarch(ro, rd), pass = float(t < FAR_PLANE);\n    fragColor.rgb = mix(fragColor.rgb, shade(ro, rd, t), pass);\n    \n    // Occlusion mask for improving the radial blur in the next render\n    fragColor.a = pow(max(dot(rd, g_sundir), 0.0), 100.0)*(1.0-pass);\n    \n    // Volumetric effect (dust)\n    if (rd.y > 0.1)\n        return;\n    fragColor.rgb = volmarch(ro, rd, t, fragColor.rgb);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}