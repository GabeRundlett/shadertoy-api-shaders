{
    "Shader": {
        "info": {
            "date": "1706798805",
            "description": "it's a pattern, you dolt!",
            "flags": 0,
            "hasliked": 0,
            "id": "4fBXWK",
            "likes": 3,
            "name": "eindacor_perlinstooth",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 140
        },
        "renderpass": [
            {
                "code": "#define AA .002f\n#define PI 3.141592653f\n#define TWOPI 6.28318530718f\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rotatePointAroundOtherPoint(vec2 center, vec2 p, float angleInRadians) {\n    mat2x2 rotationMatrix = mat2x2(\n    \tcos(angleInRadians), -sin(angleInRadians),\n        sin(angleInRadians), cos(angleInRadians)\n    );\n    \n    return (rotationMatrix * (p - center)) + center;\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getStepHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = holdTime + transitionTime;\n    float relativeTime = fract(time / period);\n    return mix(lower, upper, smoothstep(holdTime / 2., period - holdTime / 2., mod(time, period)));\n}\n\nfloat getStripe(float val, float size) {\n    return mod(val, size * 2.) < size ? 1. : 0.;\n}\n\nfloat getDivisor(float time, float interval, float steps, float holdRatio) {\n    int stepIndex = int(floor(time / interval));\n    int nextStepIndex = stepIndex + 1;\n    \n    float firstVal = hash(vec2(float(stepIndex)));\n    float secondVal = hash(vec2(float(nextStepIndex)));\n    \n    return mix(pow(2., floor(firstVal * 4.)), pow(2., floor(secondVal * 4.)), \n        getStepHoldTransitionValue(0., 1., interval * holdRatio, interval * (1. - holdRatio), time));\n    \n    float thisDivisor = float(stepIndex);\n    float nextDivisor = float(stepIndex + 1);\n}\n\nfloat getValInColorSpace(float val) {\n    float minVal = .0;\n    float maxVal = 1.;\n    float increment = (maxVal - minVal) / 4.;\n    \n    return minVal + increment * floor(val * 4.);\n}\n\nfloat getColorVal(float time, float interval, float steps, float noise, float holdRatio) {\n    int stepIndex = int(noise * 58. + floor(time / interval));\n    int nextStepIndex = stepIndex + 1;\n\n    float firstVal = hash(vec2(float(stepIndex)));\n    float secondVal = hash(vec2(float(nextStepIndex)));\n    \n    return mix(getValInColorSpace(firstVal), getValInColorSpace(secondVal), \n        getStepHoldTransitionValue(0., 1., interval * holdRatio, interval * (1. - holdRatio), time));\n}\n\nvec2 getRandomVector(float seed) {\n    vec2 outVec;\n    if (seed < .25) {\n        outVec = vec2(1., 1.);\n    } else if (seed < .5) {\n        outVec = vec2(-1., 1.);\n    } else if (seed < .75) {\n        outVec = vec2(1., -1.);\n    } else {\n        outVec = vec2(-1., -1.);\n    }\n    \n    return outVec;\n}\n\nfloat biLerp(float f0, float f1, float f2, float f3, float lerpX, float lerpY) {\n    float upper = mix(f1, f2, lerpX);\n    float lower = mix(f0, f3, lerpX);\n    \n    return mix(lower, upper, lerpY);\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getModifiedDot(vec2 uv, vec2 p, float gridDimension, float pHash) {\n    float rotation = sin(iTime * .15 + pHash) * 2. * PI;\n    if (pHash < .5) {\n        rotation *= -1.;\n    }\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    return dot((uv - p) / gridDimension, getRandomVector(pHash) * rotationMatrix);\n}\n\n\nfloat getPerlinValue(vec2 uv, float gridDimension, bool hideLines) {\n    float xCoord = floor(uv.x / gridDimension) * gridDimension;\n    float yCoord = floor(uv.y / gridDimension) * gridDimension;\n    \n    float xIndex = floor(uv.x / gridDimension);\n    float yIndex = floor(uv.y / gridDimension);\n    \n    float p0Hash = hash(vec2(xIndex, yIndex));\n    float p1Hash = hash(vec2(xIndex, yIndex + 1.));\n    float p2Hash = hash(vec2(xIndex + 1., yIndex + 1.));\n    float p3Hash = hash(vec2(xIndex + 1., yIndex));\n    \n    vec2 p0 = vec2(xCoord, yCoord);\n    vec2 p1 = vec2(xCoord, yCoord + gridDimension);\n    vec2 p2 = vec2(xCoord + gridDimension, yCoord + gridDimension);\n    vec2 p3 = vec2(xCoord + gridDimension, yCoord);\n    \n    float rotation = sin(iTime * .15) * 2. * PI;\n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n    \n    float dot0 = getModifiedDot(uv, p0, gridDimension, p0Hash);\n    float dot1 = getModifiedDot(uv, p1, gridDimension, p1Hash);\n    float dot2 = getModifiedDot(uv, p2, gridDimension, p2Hash);\n    float dot3 = getModifiedDot(uv, p3, gridDimension, p3Hash);\n    \n    float xInterp = smoothstep(p0.x, p2.x, uv.x);\n    float yInterp = smoothstep(p0.y, p2.y, uv.y);\n    \n    float val = biLerp(dot0, dot1, dot2, dot3, xInterp, yInterp);\n\n    float xLerp = mod(uv.x / 2., gridDimension);\n    float revealMargin = gridDimension * .95;\n\n    if (hideLines || xLerp < revealMargin) {\n        return abs(val);\n    } else {\n        float marginLerp = (xLerp - revealMargin) / (1. - revealMargin);\n        float distFromCenterMargin = abs(.5 - marginLerp);\n        float marginSmooth = smoothstep(0.499, .5, distFromCenterMargin);\n        return mix(clamp(val, 0., 1.), abs(val), marginSmooth);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float gridSize = .2;\n    \n    int gridRow = int(floor(uv.y/gridSize));\n    int gridCol = int(floor(uv.x/gridSize));\n    \n    float interval = 10.;\n    float steps = 10.;\n    \n    float currentStep = floor(iTime / interval);\n    float nextStep = currentStep + 1.;\n    \n    float hashVal = hash(vec2(currentStep));\n    \n    float holdRatio = .5;\n    \n    bool houndsTooth = false;\n    \n    vec4 color0, color1, color2, color3;\n    \n    vec3 background = vec3(0.2, 0., 0.);\n    vec3 perlinColor0_0 = vec3(1., 0.75, .25);\n    vec3 perlinColor0_1 = vec3(1.);\n    vec3 perlinColor0_2 = vec3(2.5);\n\n    vec3 perlinColor1_0 = vec3(.25, 0.75, 0.5);\n    vec3 perlinColor1_1 = vec3(0.);\n    vec3 perlinColor1_2 = vec3(0.5, .75, .25);\n    \n    float perlinVal1 = pow(getPerlinValue(uv, gridSize, false), .15);\n    float perlinVal2 = log(getPerlinValue(uv, gridSize, false)) / 4.;\n    float perlinVal3 = pow(getPerlinValue(uv, gridSize * 5., true), 2.);\n    \n    vec3 perlinMap1 = mix(mix(mix(background, perlinColor0_0, perlinVal1), perlinColor0_1, perlinVal2), perlinColor0_2, perlinVal3 * .7);\n    vec3 perlinMap2 = mix(mix(mix(background, perlinColor1_0, perlinVal1), perlinColor1_1, perlinVal2), perlinColor1_2, perlinVal3 * .7);\n    \n    if (houndsTooth) {\n        color0 = vec4(.2);\n        color1 = vec4(.8);\n        color2 = vec4(.2);\n        color3 = vec4(.8);\n    }\n    else {\n        color0 = vec4(getColorVal(iTime, interval, steps, hash(vec2(0.4)), holdRatio));\n        color1 = vec4(getColorVal(iTime, interval, steps, hash(vec2(- 0.4)), holdRatio));\n        color2 = vec4(getColorVal(iTime, interval, steps, hash(vec2(-0.1)), holdRatio));\n        color3 = vec4(getColorVal(iTime, interval, steps, hash(vec2(0.7)), holdRatio));\n    }\n    \n    float firstVal = getStripe(uv.x, gridSize);\n    float secondVal = getStripe(uv.y, gridSize);\n    \n    float divisor = houndsTooth ? 4. : getDivisor(iTime, interval, steps, holdRatio);\n    \n    float gridDiagonal = sqrt(2. * gridSize * gridSize);\n    float thirdVal = getStripe(rotatePointAroundOtherPoint(vec2(0.), uv, TWOPI / 8.).x, gridDiagonal / divisor);\n    \n    vec4 map1 = mix(color0, color1, firstVal);\n    vec4 map2 = mix(color2, color3, secondVal);\n    \n    vec4 mixColor = mix(map1, map2, thirdVal);\n    \n    vec3 mixedPerlin = mix(perlinMap1, perlinMap2, mixColor.x);\n    \n    fragColor = vec4(mixedPerlin.r, mixedPerlin.g, mixedPerlin.b, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}