{
    "Shader": {
        "info": {
            "date": "1473114543",
            "description": "Compilation of different approahes to checkerboard patterns (and simple 2d transforms for it)\n\nsimple easily forgoten pattern.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Mty3z1",
            "likes": 13,
            "name": "tiling checkerboard compilation",
            "published": 3,
            "tags": [
                "checkerboard"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1200
        },
        "renderpass": [
            {
                "code": "//uncomment for monochrome, to see if [s] is in range: [0 .. 1]:\n//#define monochrome\n\n/*\nConclusion: there are 4 non-branching checkerboad-functions, connonly useon shadertoy.com:\ntop    left ; checkerBool (), uses float(a>c==b>c), is possibly the best         , fastest\nbottom left ; checkerFloor(), uses   mod(floor() ), is second most commonly used , fast\ntop    right; checkerSign (), uses  sign(mod()   ), is        most commonly used , slower\nbottom right; checkerSin  (), uses  sign(sin()   ), and sign() is pretty optional, trigonoical\n\nall can be inverted by adding 1sub.\nall compare beter in monochrome. are color corrected by a=a*2.-1.;\n\ncheckerFloor() is the most used, most obvious, and leatst flexible.\n\ncheckerBool() is possibly the fastest and most flexible.\ncheckerSign() is slower, 1mult more than checkerFloor()\ncheckerSign() and checkerBool() allow for other checker-scaling-ratios by modifying the -.5 constant(s).\n\ncheckerSin() approximates a checkrboard with a factor of 2 sines, which may perform faster on mobile hardware.\n*/\n\n//mod(x,1) == fract(x)\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2 );return float(b.x==b.y);}\nfloat checkerBool (hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2() might be faster than checkerBool() //xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5                     )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n//how to transform this to a non-boolean solution with smooth borders?\n//multiply with a smoothstep?\n                   \n//bool patterns are fun for 3d texturing btw.\n                   \n//by https://www.shadertoy.com/view/4tV3Rh\n//by https://www.shadertoy.com/view/4ssGWX\n//slightly slower. +1 good feature:\nfloat checkerSign(vec2 v){\n //v=sign(mod(v,2.)-.5                    );//unmodified scaling ratio.\n   v=sign(mod(v,2.)-.5+cos(iTime)*.4);\n   return    v.x*v.y;}//non-invert\n //return 1.-v.x*v.y;}//    invert\n\n//mult sub sign  mod, are functions of above:\n//     add floor mod, are functions of below:\n\n//by https://www.shadertoy.com/view/4lyGRh\n//by https://www.shadertoy.com/view/Xss3Dr\n//by https://www.shadertoy.com/view/XdXXWn\n//by https://www.shadertoy.com/view/ldBXz3\n//faster more famous checkerboard:\nfloat checkerFloor(vec2 v){\n   v=   floor(v); //non-invert\n //v=.5-floor(v); //    invert\n return mod(v.x+v.y,2.);}\n\n//by https://www.shadertoy.com/view/XldGD7\n//using sines to approximate a checkerboard pattern\nfloat checkerSin(vec2 v){return sign(cos(v.x)*sin(v.y));}\n//if (you know these values anyways) this is only 2mult\n//performs worst on runtime but has its advantage in being smaller code\n//and perform fastest \n//IF you already precalculated the same trigonometry for other purposes.\n\n//other (branching) checkerboard solutions that do other things worhwhile:\n//in-tile-rotation https://www.shadertoy.com/view/MdK3Wd\n//blur 2 gradients https://www.shadertoy.com/view/Mtd3WB\n//antiaaliasing    https://www.shadertoy.com/view/MdSXzy\n//movement         https://www.shadertoy.com/view/Msl3RX\n//spirals          https://www.shadertoy.com/view/MsfXRj\n//warp             https://www.shadertoy.com/view/MlsXRj\n//spheremap        https://www.shadertoy.com/view/MsXXW4\n//cos tiny         https://www.shadertoy.com/view/lltXRn\n\n//return 2d rotation matrix;\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\nvec4 checkers(vec4 r,vec2 f\n){float t=iTime*.2;\n vec2 v=f;\n v*=rot2(t);//2d rotation //rotation before translation, otherwise it skews! here fragmentts are kinda inverse like that!\n v+=rot2(t*9.)[0]*32.;//position.xy //f.x+=cos(t*9.)*32.;//position.x //f.y+=sin(t*9.)*32.;//position.y\n v*=cos(t)*.5+.51;//scale.xy\n v*=.1;//scale.xy\n float s=0.;\n if(f.y>iResolution.y*.5){\n  if(f.x>iResolution.x*.5)s=checkerFloor(v)*2.-1.; \n  else                    s=(checkerBoolT(v*.5))*2.-1.;\n }else{\n  if(f.x>iResolution.x*.5)s=checkerSin(v*3.);  \n  else                    s=checkerSign(v);\n }\n#ifdef monochrome     \n s=s/4.+.5;//shift range[-1.,1.] to range[.25,.75]\n r.xyz=vec3(s);}//monochrome\n#else\n //1 vector for orange-teal contrast\n s+=.5;//color range correction.\n #define COLOR vec3(1.,.75,.5)\n r.xyz=mix(COLOR,COLOR.zyx,s);\n#endif\n return r;}\n\n\nvoid mainImage(out vec4 r,in vec2 f){\n r=checkers(r,f);\n;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}