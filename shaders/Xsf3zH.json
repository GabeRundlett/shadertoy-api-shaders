{
    "Shader": {
        "info": {
            "date": "1492688840",
            "description": "A julia quaternion hack. Originally a C/OpenGL program ( https://www.youtube.com/watch?v=yZt--S1eS6A ), ported to WebGL ( http://nuclear.mutantstargoat.com/webgl/ ), and now in an act of rampant unbridled procrastination, ported to shadertoy.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xsf3zH",
            "likes": 5,
            "name": "Julia quaternion fractal",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "juliaquaternion"
            ],
            "usePreview": 0,
            "username": "nuclear",
            "viewed": 704
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nhighp float;\n#endif\n\nfloat aspect;\nconst float vfov = 1.02;\nvec4 seed = vec4(0.4, 0.0, 0.0, -0.8);\nconst float err_thres = 0.0075;\nconst int iter = 10;\nconst float reflectivity = 0.4;\nconst vec3 diffuse_color = vec3(0.38, 0.35, 0.32);\nconst int show_floor = 1;\n\n//uniform mat4 mvmat, normmat;\nmat3 rotmat;\n\n#define quat(s, x, y, z)\tvec4(x, y, z, s)\n#define quat_identity()\t\tvec4(0.0, 0.0, 0.0, 1.0)\n\n#define vec2quat(v)\t\t(v).wxyz\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Julia {\n\tbool inside;\n\tvec4 q;\n\tvec4 qprime;\n};\n\nstruct Material {\n\tvec3 kd, ks;\n\tfloat kr;\n\tfloat spow;\n};\n\nstruct ISect {\n\tbool hit;\n\tfloat t;\n\tvec3 pos;\n\tvec3 normal;\n\tMaterial mat;\n};\n\nISect find_intersection(Ray ray);\nvec3 shade(Ray ray, ISect isect);\nfloat amboc(ISect isect);\nvec3 sky(Ray ray);\nJulia julia(vec4 q, vec4 c);\nfloat julia_dist(vec4 z);\nvec3 julia_grad(vec4 z);\nvec4 quat_mul(vec4 q1, vec4 q2);\nvec4 quat_sq(vec4 q);\nfloat quat_length_sq(vec4 q);\nISect ray_julia(Ray ray);\nISect ray_sphere(Ray ray, float rad);\nISect ray_floor(Ray ray);\nRay get_primary_ray(in vec2 tc);\n\nvec3 steps_color(int steps);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = iTime * 0.075;\n    float phi = 0.25;\n    float sintheta = sin(theta);\n    float costheta = cos(theta);\n    float sinphi = sin(phi);\n    float cosphi = cos(phi);\n    \n    mat3 rotx = mat3(\n        costheta, 0, -sintheta,\n        0, 1, 0,\n        sintheta, 0, costheta);\n    mat3 roty = mat3(\n        1, 0, 0,\n        0, cosphi, sinphi,\n        0, -sinphi, cosphi);\n    rotmat = rotx * roty;\n    \n    seed[0] = cos(iTime * 0.333);\n    seed[3] = sin(iTime * 0.333) * 1.25 - 0.25;\n    \n    \n    vec2 tc = fragCoord.xy / iResolution.xy;\n    aspect = iResolution.x / iResolution.y;\n\tRay ray = get_primary_ray(tc);\n\n\tfloat energy = 1.0;\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tfor(int i=0; i<2; i++) {\n\t\tISect res = find_intersection(ray);\n\n\t\tif(res.hit) {\n\t\t\tcolor += shade(ray, res) * energy;\n\t\t\tenergy *= res.mat.kr;\n\n\t\t\tif(energy < 0.001) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tray.origin = res.pos;\n\t\t\tray.dir = reflect(ray.dir, res.normal);\n\t\t} else {\n\t\t\tcolor += sky(ray) * energy;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}\n\n\nISect find_intersection(Ray ray)\n{\n\tISect res;\n\tres.hit = false;\n\t\n\tISect bhit = ray_sphere(ray, 2.0);\n\tif(bhit.hit) {\n\t\tray.origin = bhit.pos;\n\t\tres = ray_julia(ray);\n\t}\n\n\tif(!res.hit && show_floor == 1) {\n\t\tres = ray_floor(ray);\n\t}\n\treturn res;\n}\n\nvec3 shade(Ray ray, ISect isect)\n{\n\tvec3 ldir = normalize(vec3(10.0, 10.0, -10.0) - isect.pos);\n\tvec3 vdir = -ray.dir;\n\tvec3 hdir = normalize(ldir + vdir);\n\n\tfloat ndotl = dot(ldir, isect.normal);\n\tfloat ndoth = dot(hdir, isect.normal);\n\n\tvec3 dcol = isect.mat.kd;// * abs(ndotl);\n\tvec3 scol = isect.mat.ks * pow(abs(ndoth), isect.mat.spow);\n\n\treturn vec3(0.05, 0.05, 0.05) + dcol + scol;\n}\n\n#define AO_STEP\t\t0.04\n#define AO_MAGIC\t8.0\nfloat amboc(ISect isect)\n{\n\tfloat sum = 0.0;\n\n\tfor(float fi=0.0; fi<5.0; fi+=1.0) {\n\t\tfloat sample_dist = fi * AO_STEP;\n\t\tvec3 pt = isect.pos + isect.normal * sample_dist;\n\t\tfloat jdist = julia_dist(quat(pt.x, pt.y, pt.z, 0.0));\n\n\t\tsum += 1.0 / pow(2.0, fi) * (sample_dist - jdist);\n\t}\n\t\n\tfloat res = 1.0 - AO_MAGIC * sum;\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 sky(Ray ray)\n{\n\tvec3 col1 = vec3(0.75, 0.78, 0.8);\n\tvec3 col2 = vec3(0.56, 0.7, 1.0);\n\n\tfloat t = max(ray.dir.y, -0.5);\n\treturn mix(col1, col2, t);\n}\n\nJulia julia(vec4 q, vec4 c)\n{\n\tJulia res;\n\tres.inside = true;\n\n\tres.q = q;\n\tres.qprime = quat_identity();\n\n\t//for(int i=0; i<iter; i++) {\n\tfor(int i=0; i<10; i++) {\n\t\tres.qprime = 2.0 * quat_mul(res.q, res.qprime);\n\t\tres.q = quat_sq(res.q) + c;\n\n\t\tif(dot(res.q, res.q) > 8.0) {\n\t\t\tres.inside = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nfloat julia_dist(vec4 z)\n{\n\tJulia jres = julia(z, seed);\n\n\tfloat lenq = length(jres.q);\n\tfloat lenqprime = length(jres.qprime);\n\n\treturn 0.5 * lenq * log(lenq) / lenqprime;\n}\n\n#define OFFS 1e-4\nvec3 julia_grad(vec4 z)\n{\n\tvec3 grad;\n\tgrad.x = julia_dist(z + quat(OFFS, 0.0, 0.0, 0.0)) - julia_dist(z - quat(OFFS, 0.0, 0.0, 0.0));\n\tgrad.y = julia_dist(z + quat(0.0, OFFS, 0.0, 0.0)) - julia_dist(z - quat(0.0, OFFS, 0.0, 0.0));\n\tgrad.z = julia_dist(z + quat(0.0, 0.0, OFFS, 0.0)) - julia_dist(z - quat(0.0, 0.0, OFFS, 0.0));\n\treturn grad;\n}\n\nvec4 quat_mul(vec4 q1, vec4 q2)\n{\n\tvec4 res;\n\tres.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n\tres.xyz = q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz);\n\treturn res;\n}\n\nvec4 quat_sq(vec4 q)\n{\n\tvec4 res;\n\tres.w = q.w * q.w - dot(q.xyz, q.xyz);\n\tres.xyz = 2.0 * q.w * q.xyz;\n\treturn res;\n}\n\n#define MIN_STEP\t0.001\nISect ray_julia(Ray inray)\n{\n\tfloat dist_acc = 0.0;\n\tRay ray = inray;\n\tISect res;\n\n\tfloat fi = 0.0;\n\tfor(int i=0; i<1000; i++) {\n\t\tvec4 q = quat(ray.origin.x, ray.origin.y, ray.origin.z, 0.0);\n\t\t\n\t\tfloat dist = max(julia_dist(q), MIN_STEP);\n\n\t\tray.origin += ray.dir * dist;\n\t\tdist_acc += dist;\n\n\t\tif(dist < err_thres) {\n\t\t\tres.hit = true;\n\t\t\tres.t = dist_acc;\n\t\t\tres.pos = ray.origin;\n\t\t\tres.normal = normalize(julia_grad(quat(res.pos.x, res.pos.y, res.pos.z, 0.0)));\n\t\t\tres.mat.kr = reflectivity;\n\t\t\tres.mat.kd = diffuse_color * amboc(res);\n\t\t\tres.mat.ks = vec3(0.4, 0.4, 0.4);\n\t\t\tres.mat.spow = 50.0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(dot(ray.origin, ray.origin) > 100.0) {\n\t\t\tres.hit = false;\n\t\t\tbreak;\n\t\t}\n\t\tfi += 0.1;\n\t}\n\n\treturn res;\n}\n\nISect ray_sphere(Ray ray, float rad)\n{\n\tISect res;\n\tres.hit = false;\n\n\tfloat a = dot(ray.dir, ray.dir);\n\tfloat b = 2.0 * dot(ray.dir, ray.origin);\n\tfloat c = dot(ray.origin, ray.origin) - rad * rad;\n\n\tfloat d = b * b - 4.0 * a * c;\n\tif(d < 0.0) return res;\n\n\tfloat sqrt_d = sqrt(d);\n\tfloat t1 = (-b + sqrt_d) / (2.0 * a);\n\tfloat t2 = (-b - sqrt_d) / (2.0 * a);\n\n\tif((t1 >= 0.0 || t2 >= 0.0)) {\n\t\tif(t1 < 0.0) t1 = t2;\n\t\tif(t2 < 0.0) t2 = t1;\n\t\t\n\t\tres.hit = true;\n\t\tres.t = min(t1, t2);\n\t\tres.pos = ray.origin + ray.dir * res.t;\n\t\t//res.mat.kd = vec3(1.0, 0.3, 0.2);\n\t\t//res.normal = res.pos / rad;\n\t}\n\n\treturn res;\n}\n\n#define FLOOR_HEIGHT\t(-2.0)\n\nISect ray_floor(Ray ray)\n{\n\tISect res;\n\tres.hit = false;\n\n\tif(ray.origin.y < FLOOR_HEIGHT || ray.dir.y >= 0.0) {\n\t\treturn res;\n\t}\n\n\tres.normal = vec3(0.0, 1.0, 0.0);\n\tfloat ndotdir = dot(res.normal, ray.dir);\n\n\tfloat t = (FLOOR_HEIGHT - ray.origin.y) / ndotdir;\n\tres.pos = ray.origin + ray.dir * t;\n\n\tif(abs(res.pos.x) > 8.0 || abs(res.pos.z) > 8.0) {\n\t\tres.hit = false;\n\t} else {\n\t\tres.hit = true;\n\t\n\t\tfloat chess = mod(floor(res.pos.x * 0.75) + floor(res.pos.z * 0.75), 2.0);\n\t\tres.mat.kd = mix(vec3(0.498, 0.165, 0.149), vec3(0.776, 0.851, 0.847), chess);\n\t\tres.mat.ks = vec3(0.0, 0.0, 0.0);\n\t\tres.mat.spow = 1.0;\n\t\tres.mat.kr = 0.0;\n\t}\n\treturn res;\n}\n\nRay get_primary_ray(in vec2 tc)\n{\n\tRay ray;\n\t//ray.origin = (mvmat * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n    ray.origin = rotmat * vec3(0.0, 0.0, -3.0);\n\n\tfloat ysz = 2.0;\n\tfloat xsz = aspect * ysz;\n\n\tfloat px = tc.x * xsz - xsz / 2.0;\n\tfloat py = tc.y * ysz - 1.0;\n\tfloat pz = 1.0 / tan(0.5 * vfov);\n\n\t//vec4 dir = normmat * vec4(px, py, pz, 1.0);\n    vec3 dir = rotmat * vec3(px, py, pz);\n\tray.dir = normalize(dir.xyz);\n\n\treturn ray;\n}\n\nvec3 steps_color(int steps)\n{\n\tif(steps <= 1) {\n\t\treturn vec3(0.0, 0.5, 0.0);\n\t} else if(steps == 2) {\n\t\treturn vec3(0.0, 1.0, 0.0);\n\t} else if(steps == 3) {\n\t\treturn vec3(0.0, 0.0, 0.5);\n\t} else if(steps == 4) {\n\t\treturn vec3(0.0, 0.0, 1.0);\n\t} else if(steps == 5) {\n\t\treturn vec3(0.0, 0.5, 0.5);\n\t} else if(steps == 6) {\n\t\treturn vec3(0.0, 1.0, 1.0);\n\t} else if(steps == 7) {\n\t\treturn vec3(0.5, 0.0, 0.5);\n\t} else if(steps == 8) {\n\t\treturn vec3(1.0, 0.0, 1.0);\n\t} else if(steps == 9) {\n\t\treturn vec3(0.5, 0.0, 0.0);\n\t}\n\treturn vec3(0.5 + float(steps - 9) / 10.0, 0.0, 0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}