{
    "Shader": {
        "info": {
            "date": "1552556268",
            "description": "Mapping the unit square into the unit disk, shown as a mesh here. I found [url=https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf]this paper[/url] and simplified their maths into v = maxcomp(abs(v))*normalize(v). Colors show amount of displacement.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dsSWs",
            "likes": 108,
            "name": "Rounding the Square",
            "published": 3,
            "tags": [
                "2d",
                "circle",
                "map",
                "square"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 5286
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Converting the unit square into the unit circle, from\n// https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf \n// but I realized it could be much simplified.\n//\n// v = maxcomp(abs(v))*normalize(v)\n//\n// Also I developped an improvement over it to make it more\n// uniform.\n\n\n#define IMPROVED 1           // make 0 for faster approach\n\n//-----------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\n\n// Take a point in the unit square [-1,1]^2 and map it\n// into a point in the unit disk\nvec2 square2circle( in vec2 v )\n{\n    #if IMPROVED==0\n    return maxcomp(abs(v))*normalize(v);\n    #else\n    return maxcomp(abs(v))*normalize(v*(2.0+abs(v)));\n    #endif\n}\n\nvec2 circle2square( vec2 v )\n{\n    #if IMPROVED==0\n    return v*length(v)/maxcomp(abs(v));\n    #else\n    return vec2(0.0);\n    #endif\n}\n\n\n//-----------------------------------------------\n\nfloat sdLineSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn dot2(pa-ba*h);\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    return dot2(p-a);\n}\n\n//-----------------------------------------------\n\nvec2 vertex( int i, int j, int num, float anim)\n{\n    // unit square\n    vec2 s = -1.0+2.0*vec2(i,j)/float(num);\n    \n    // unit circle\n    vec2 c = square2circle(s);\n        \n    // blend\n    return mix(c,s,anim);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // plane coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float w = 2.0/iResolution.y;\n    \n    // scale\n\tp *= 1.15;\n\tw *= 1.15;\n \n    // anim\n    float anim = smoothstep(-0.6,0.6,cos(iTime*2.0+0.0));\n    float show = smoothstep(-0.1,0.1,sin(iTime*1.0+3.4));\n    \n    // mesh: body\n    vec2 di = vec2(10.0);\n    const int num = 11;         // Make \"num\" odd. If even is desired, the \n\tfor( int j=0; j<num; j++ )  // normalize() in square2circle() should be\n\tfor( int i=0; i<num; i++ )  // protected against divisions by zero.\n    {\n        vec2 a = vertex(i+0,j+0,num,anim);\n        vec2 b = vertex(i+1,j+0,num,anim);\n        vec2 c = vertex(i+0,j+1,num,anim);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,a,c)),\n                               sdPointSq(p,a)));\n    }\n    // mesh: top and right edges\n\tfor( int j=0; j<num; j++ )\n    {\n        vec2 a = vertex(num,j+0,num,anim);\n        vec2 b = vertex(num,j+1,num,anim);\n        vec2 c = vertex(j+0,num,num,anim);\n        vec2 d = vertex(j+1,num,num,anim);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,c,d)),\n                           min(sdPointSq(p,a),\n                               sdPointSq(p,c))));\n    }\n    // mesh: top-right corner\n    di.y = min( di.y, sdPointSq(p,vertex(num,num,num,anim)));\n    di = sqrt(di);\n\n    \n    // background\n    vec3 col = vec3(1.0);\n    \n    // colorize displacement\n    vec2 q = square2circle(p);\n    vec2 p1 = mix(q,p,    anim);\n    vec2 p2 = mix(q,p,1.0-anim);\n    col = mix( col, 0.6 + 0.5*cos(length(p-p1)*15.0 + 2.5+vec3(0,2,4) ),\n               show*smoothstep(0.999,0.99,length(p2)) );\n    // draw mesh    \n    col *= 0.9+0.1*smoothstep(0.0,0.05,di.x);\n    col *= smoothstep(0.0,0.008,di.x);\n    col *= smoothstep(0.03,0.03+w,di.y );\n    \n    // vignette\n    col *= 1.0 - 0.15*length(p);\n\n    // output\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}