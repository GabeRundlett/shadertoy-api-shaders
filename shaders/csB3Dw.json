{
    "Shader": {
        "info": {
            "date": "1667657228",
            "description": "My participation to the inercia shader royale =D",
            "flags": 96,
            "hasliked": 0,
            "id": "csB3Dw",
            "likes": 14,
            "name": "Inercia 2022 - Shader royal",
            "published": 3,
            "tags": [
                "specular",
                "glossy",
                "demoparty",
                "dnb",
                "inercia",
                "royale"
            ],
            "usePreview": 1,
            "username": "z0rg",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\nfloat rand()\n{\n  return hash11(_seed++);\n}\n#define sat(a) clamp(a, 0., 1.)\n#define FFT(a) (texture(iChannel3, vec2(a, 0.)).x*4.)\nvec3 getCam(vec2 uv, vec3 rd)\n{\n  vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+(r*uv.x+u*uv.y)*1.);\n}\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\nmat2 r2d(float a)\n{\n  float c=cos(a),s=sin(a);\n  return mat2(c,-s,s,c);\n}\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(100000., -1.);\n  \n  vec3 op = p;\n  vec3 rep = vec3(15.);\n  //p = mod(p+rep*.5,rep)-rep*.5;\n  acc = _min(acc, vec2(length(p)-1., 0.));\n  for (int i = 0; i < 8; i++)\n  {\n    vec3 p2 = p;\n    \n    p2 = abs(p2)-vec3(1.2,0.,0.);\n    p2.xy *= r2d(-iTime*.5+float(i));\n    p2+= (float(i)-8.)*1.5;\n    p2 = abs(p2);\n    p2.xy *= r2d(iTime+float(i));\n    p2.yz *= r2d(iTime*.8+float(i));\n    float sz = mix(.2,1., float(i)/8.);\n    float cube = _cube(p2, vec3(sz, sz, 2.));\n    //cube = mix(cube, length(p2)-sz, sin(float(i)+fGlobalTime));\n    acc = _min(acc, vec2(cube, 0.));\n  }\n  \n  float box = -_cube(op, vec3(19.));\n  acc = _min(acc, vec2(box, 2.));\n  \n  acc = _min(acc, vec2(-p.y+1., 1.));\n  \n\n  return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01, 0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accCol = vec3(0.);\n    vec3 p = ro;\n  for (int i = 0; i < steps && distance(p, ro) < 50.;++i)\n  {\n    vec2 res = map(p);\n      if (res.x < 0.01)\n        return vec3(res.x, distance(p, ro), res.y);\n      p+=rd*res.x*.5;\n      vec3 rgb = vec3(.2,.4,.8);\n      rgb = mix(rgb, rgb.zxy, sin(length(p)-iTime));\n      if (res.y < 1.)\n        accCol += rgb*(1.-sat(res.x/.5))*.2*sat(sin(p.y*20.))*.85;\n    }\n    return vec3(-1.);\n}\nvec3 getmat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n  vec3 col = vec3(0.);//n*.5+.5;\n  if (res.z == 1.)\n    col = vec3(0.);\n  if (res.z == 0.)\n    col = vec3(.0);\n  \n  if (res.z == 0.)\n  {\n    col += vec3(1.,0.4,0.2)*sat(sin(p.z*10.)*sin(p.y*10.)*100.);\n  }\n  if (p.y < -8.)\n  {\n    float beat = 1./8.;\n    float flicker = mod(iTime, beat)/beat;\n    float flick = mix(1.,flicker, sat(sin(iTime*.5)));\n    col = vec3(1.)*sat((sin(p.z*2.)-.5)*100.)*3.*flick;\n  }\n  return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  float stpt = 1.;\n  float stptime = floor(iTime/stpt)*stpt;\n  uv *= r2d(sin(hash11(stptime)));\n    float t = iTime;\n  float d = 18.;\n  float zbeat = 1./2.;\n  float zz = mod(iTime, zbeat)/zbeat;\n  vec2 off = (vec2(rand(), rand())-.5)*.1;\n  vec3 ro = vec3(sin(t*.3)*d+off.x,-3.+off.y,-5.+zz);\n  vec3 ta = vec3(0.);\n  vec3 rd = normalize(ta-ro);\n  rd = getCam(uv, rd);\n  \n  vec3 res = trace(ro, rd, 64);\n  float depth = 100.;\n  if (res.y > 0.)\n  {\n    depth = res.y;\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p, res.x);\n    col = vec3(.2,.4,.9);\n    col = getmat(p,n,rd,res);\n    \n    vec3 refl = reflect(rd, n);\n    float spec = texture(iChannel2, p.xz).x;\n    refl = normalize(refl+(vec3(rand(), rand(), rand())-.5)*.1*spec);\n    vec3 resrefl = trace(p+n*0.01,refl, 32);\n    if (resrefl.y > 0.)\n    {\n      vec3 prefl = p+refl*resrefl.y;\n      vec3 nrefl = getNorm(prefl, resrefl.x);\n      col += getmat(prefl, nrefl, refl, resrefl);\n    }\n  }\n  col += accCol;\n  col = mix(col, vec3(.2,.4,.8)*.5, 1.-exp(-depth*0.02));  \n  \n  \n  vec2 rep = vec2(.5);\n  uv = mod(uv+rep*.5, rep)-rep*.5;\n    float shape = length(uv)-.02*FFT(uv.x*.1);\n  col += vec3(.89,.2,.3)*(1.-sat(shape*400.));\n\n  \n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 ouv = fragCoord.xy/iResolution.xy;\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  _seed = iTime+texture(iChannel1, uv*10.).x;\n  if (sin(iTime*.5) < 0.)\n  {\n  uv *= r2d(iTime*.5);\n    uv = abs(uv);\n  }\n    vec3 col = rdr(uv);\n  col += rdr(uv+col.xy*.1+(vec2(rand(), rand())-.5)*.05)*.5;\n  col = mix(col, texture(iChannel0, ouv).xyz,.15);\n  //col = mix(col, col.yxz, sat(length(uv)));\n  col = sat(col);\n  col = pow(col, vec3(1.));\n\tfragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 30085,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/marius-smaidris/styles-of-beyond-subculture-upbeats-remix?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}