{
    "Shader": {
        "info": {
            "date": "1562949816",
            "description": "star made out of 5 tetrahedra. the edges build a regular dodecahedron.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tsXD4",
            "likes": 41,
            "name": "soldered star",
            "published": 3,
            "tags": [
                "star",
                "tetrahedron",
                "dodecahedron",
                "soldered"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1335
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// soldered star\n\n// play around with the defines below.\n// ...didnt want to enable shadow by default because 60 fps are really nice on this one\n\n//#define ZOPF\n//#define SHADOW\n#define DIFFUSE\n#define BG_COLOR vec3(1.)\n#define AMBIENT .5\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=textureLod(iChannel0,pos.xy,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.xz,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.zy,0.)*2.-1.;\n    return r;\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nfloat lineDist( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat lineDistInf( vec3 p, vec3 a, vec3 b )\n{\n    return length( p-a - dot(p-a,b-a)*(b-a)/dot(b-a,b-a) );\n}\n\nvec2 distTetraM( vec3 p )\n{\n    vec3 v=.577*vec3(1,-1,1);\n    float d=10000.;\n    vec3 pa=abs(p);\n    if(pa.x>pa.y && pa.x>pa.z) p=p.yzx;\n    if(pa.y>pa.x && pa.y>pa.z) p=p.zxy;\n    if(p.z<0.) p=p.yxz*vec3(-1,1,-1);\n    //d=min(d,lineDist(p,v.yxx,v.xyx));\n    //d=min(d,lineDistInf(p,v.yxx,v.xyx)-.04);\n    vec3 bz=normalize(v.xyx-v.yxx);\n    vec3 bx=vec3(bz.y,-bz.x,0);\n    vec3 by=cross(bz,bx);\n    vec3 pr=vec3(dot(p,bx),dot(p,by),dot(p,bz));\n    float r0=.045;\n    #ifdef ZOPF\n    float ang = dot(p,bz)*PI2*2.;\n    float r=r0*(1.-pr.z*pr.z);\n    for(int i=0;i<3;i++)\n    {\n        vec2 cs=vec2(.5,1.)*cos(ang*vec2(2,1)+vec2(0,-PI2*.16666));\n        d=min(d,lineDistInf(p+r*cs.y*bx+r*cs.x*by,v.yxx,v.xyx)-r0*4./7.);\n        ang+=PI2*.66666;\n    }\n\n    #else\n    \n    vec2 cs=cos(vec2(0,-PI2*.25)+atan(pr.y,pr.x)+dot(p,bz)*PI2*2.);\n    float r=r0*(1.-1.*pr.z*pr.z);\n    d=min(d,lineDistInf(p-r*cs.x*bx-r*cs.y*by,v.yxx,v.xyx)-r0*4./9.);\n    d=min(d,lineDistInf(p+r*cs.x*bx+r*cs.y*by,v.yxx,v.xyx)-r0*4./9.);\n    d=min(d,lineDistInf(p+r*cs.y*bx-r*cs.x*by,v.yxx,v.xyx)-r0*4./9.);\n    d=min(d,lineDistInf(p-r*cs.y*bx+r*cs.x*by,v.yxx,v.xyx)-r0*4./9.);\n    \n    #endif\n\n    float dc=lineDistInf(p,v.yxx,v.xyx)-r0*(1.05+.2*smoothstep(.71,.717,abs(pr.z)));\n    float d2=mix(d,dc,smoothstep(.69,.712,abs(pr.z)));\n    float m=(abs(d2-d)*abs(d2-dc))/.001;\n    //m=abs(d2-d)/.001;\n    //m=abs(d2-dc)*abs(d2-d)/.00001;\n    //if(d2!=d && d2!=dc) m=1.;\n    \n    if(     d2==d)  m=0.;\n    else if(d2==dc) m=2.;\n    else            m=1.;\n    d=d2;\n    \n    return vec2(d,m);\n}\n\n\n\nvec2 distM( vec3 p )\n{\n    /*p+=.00008*getRand(p*.7).xyz*4.;\n    p+=.00003*getRand(p*1.5).xyz*4.;\n    p+=.00020*getRand(p*.25).xyz*4.;*/\n    float d=10000.;\n    vec4 q;\n\n    float a5  = sqrt((5.-sqrt(5.))/2.);\n    float a10 = 2./(1.+sqrt(5.));\n    float sinPI2_10=a5/2.;\n    float sinPI2_20=a10/2.;\n    float ad = 4./sqrt(3.)/(1.+sqrt(5.));\n    float at = 4./sqrt(6.);\n    //float r5 = ad/2./sin(PI2/10.);\n    //float r5 = ad/2./(a5*.5);\n    float r5 = 4./sqrt(3.)/(1.+sqrt(5.)) / sqrt((5.-sqrt(5.))/2.);\n    //float s = sqrt(6.)/(1.+sqrt(5.))/2.*r5;\n    //float s = 2./( (3.+sqrt(5.))*sqrt(5.-sqrt(5.)) );\n    float s = sqrt(5.-sqrt(5.)) / ( 5.+sqrt(5.) );\n    //float ang = PI2/8.-asin(s);\n    //float c2 =  1./sqrt(2.)*(sqrt(1.-s*s)+s);\n    /*float c2 =  1./sqrt(2.)*(\n        sqrt( 1.- (5.-sqrt(5.)) / ( 5.+sqrt(5.) )/ ( 5.+sqrt(5.) ) )\n        +sqrt(5.-sqrt(5.)) / ( 5.+sqrt(5.) )\n        );*/\n    float s5=sqrt(5.);\n    //float c = ( sqrt( 25.+11.*s5 ) + sqrt(5.-s5) ) / (5.+s5)/sqrt(2.) ;\n    float c = ( sqrt(5.*s5+11.) + sqrt(s5-1.) ) / (s5+1.)/sqrt(2.*s5) ;\n    //float ang = acos(c);\n    float ang = PI2/8.-asin(r5*sin(PI2/20.)/at*2.);\n    //ang = PI2/8.-ang;\n    \n    \n    //q=vec4(0,0,sinAng,cosAng);\n    //p=transformVecByQuat(p,q);\n    \n    // 7,4 is quite a lucky shot... exact is below\n    //q=axAng2Quat(vec3(7,4,0),PI2/5.);\n    // 8,5 is even better\n    //q=axAng2Quat(vec3(8,5,0),PI2/5.);\n    //q=axAng2Quat(vec3(cos(ang),sin(ang),0.),PI2/5.);\n    q=axAng2Quat(vec3(c,sqrt(1.-c*c),0.),PI2/5.);\n    \n    //make the small pentagonal crown show in z direction\n    vec4 q0=vec4(normalize(cross(q.xyz,vec3(0,0,1))),1.)/sqrt(2.);\n    p=transformVecByQuat(p,q0);\n    \n    float m=0.;\n    \n    for(int i=0;i<5;i++)\n    {\n        vec2 dm=distTetraM(p);\n        float dold=d;\n        d=min( d, dm.x );\n        if(d<dold) m=dm.y;\n        p=transformVecByQuat(p,q);\n    }\n    \n    //d-=.05;\n    return vec2(d,m);\n}\n\nfloat dist(vec3 pos) { return distM(pos).x; }\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.1) \n    \treturn vec4(0,0,0,1);\n    \n    float m=0.;\n    float eps=0.003;\n    float bg=1.0;\n    float d=10000., dp=0.;\n    float dmin=d;\n    for(int cnt=0;cnt<40;cnt++)\n    {\n        dp=cnt==0?0.:d;\n        vec2 dm = distM(pos);\n        d=dm.x;\n        if(d<dp) dmin=min(d,dmin);\n        pos+=d*dir;\n        if(d<eps) { m=dm.y; break; }\n    }\n    bg = smoothstep(.0,.2,d);\n    return vec4(m,dmin,0,bg); // .w=1 => background\n}\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    #ifndef SHADEROO\n    return texture(iChannel1,dir.xzy,.75);\n    #else\n    dir=normalize(dir);\n    float azim = atan(dir.y,dir.x);\n    float thr  = .5*.5*(.7*sin(2.*azim*5.)+.3*sin(2.*azim*7.));\n    float thr2 = .5*.125*(.7*sin(2.*azim*13.)+.3*sin(2.*azim*27.));\n    float thr3 = .5*.05*(.7*sin(2.*azim*32.)+.3*sin(2.*azim*47.));\n    float br  = smoothstep(thr-.2, thr+.2, dir.z+.25);\n    float br2 = smoothstep(thr2-.2,thr2+.2,dir.z+.15);\n    float br3 = smoothstep(thr3-.2,thr3+.2,dir.z);\n    vec4 r1 = .5*(texture(iChannel0,dir.xy*.01)-texture(iChannel0,dir.xy*.017+.33));\n    vec3 skyCol=vec3(.9,1,1.1)+.5*(r1.xxx*.5+r1.xyz*.5);\n    //skyCol*=2.5;\n    vec4 r2 = .5*(texture(iChannel0,dir.xy*.1)-texture(iChannel0,dir.xy*.07-.33));\n    vec3 floorCol = vec3(.9,1.1,1.)*.8+.5*(r2.xxx*.7+r2.xyz*.3);\n    vec3 col=mix(floorCol.zyx,skyCol,br3);\n    col=mix(floorCol.yzx*.7,col,br2);\n    col=mix(floorCol.xyz*.7*.7,col,br);\n    vec3 r=texture(iChannel0,vec2(azim/PI2*.125,.5)).xyz;\n    col*= 1.-clamp(((r.xxx*.7+r.xzz*.3)*2.-1.)*clamp(1.-abs(dir.z*1.6),0.,1.),0.,1.);\n    return vec4(pow(col,vec3(1.6))*.8*vec3(1.1,1,.9)/**clamp(1.+dir.x*.3,.9,1.2)*/,1);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-4.,0);\n    #ifdef SHADEROO\n    pos.y*=1.-iMouseData.z/5000.;\n    #endif\n    if(iMouse.x<1.) pos.y*=(1.-.5*(.5-.5*cos(iTime*.1)));\n    // pixel view direction\n    vec3 dir = normalize(2.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    #ifdef DOF\n    vec2 poff=(texture(iChannel0,(fragCoord+vec2(iFrame*13,iFrame*7))/Res0).xy-.5)*.02;\n    pos.xz+=poff;\n    dir.xz-=poff*dir.y/(-pos.y-zoomFunc(iTime));\n    #endif\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=iTime; th=.27*iTime; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    vec3 pos0 = pos;\n    \n   \tvec4 mr=march(pos,dir);\n    vec3 n = getGrad(pos,.001);\n    float bg=mr.w;\n    float m=mr.x;\n\n    vec3 ldir=normalize(pos0-pos-vec3(.5,.5,.5));\n    \n    float diff = 1.;\n    #ifdef DIFFUSE\n    diff = 1.2*clamp(dot(n,ldir),0.,1.);\n    #endif\n\n    float sh=1.;\n    #ifdef SHADOW\n    vec3 pos2=pos-dir*.01;\n    vec4 mr2=march(pos2,ldir);\n    sh*=1.-max(1.-mr2.w,exp(-mr2.y*mr2.y/.02/.02));\n    //sh*=clamp(dot(n,ldir),0.,1.);\n    //sh=.4+.6*sh;\n    //sh=.7*sh+.3;\n    #endif\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    ao=clamp(ao,0.,1.);\n    // adjust contrast of ao\n    //ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = (pos-pos0)-2.0*dot((pos-pos0),n.xyz)*n.xyz;\n    R = ((R*rz)*rx);\n    \n    vec3      c = vec3(.55,.3,.2);   // copper\n    if(m>.5 ) c = vec3(.4);          // tin\n    if(m>1.5) c = vec3(.5,.4,.25);   // brass\n    \n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*vec3(1,.4,.7)*.05;\n    //  reflection of cubemap (slightly tilt reflection map to floor - rotX(-.8))\n    float sp=1.;\n    sp-=.20*getRand(pos*2.).x*4.;\n    sp-=.10*getRand(pos*4.).x*4.;\n    sp-=.05*getRand(pos*8.).x*4.;\n    c += sp*myenv(pos,rotX(-.8)*R,1.).xxx*.8;\n    \n    // apply ambient occlusion, diffuse, shadow\n    c*=(1.-AMBIENT)*min(min(ao,diff),sh)+AMBIENT;\n\n    //vec3 bgCol = mix(vec3(1.05,1.05,.95),vec3(.9,.95,1.),1.-length(sc));\n    vec3 bgCol=BG_COLOR;\n    //bgCol=myenv(vec3(0),dir,1.).xyz;\n    \n    // apply background\n    float aspect=iResolution.y/iResolution.x;\n    float r = length(vec2(sc.y*aspect,sc.x));\n    c=mix(c,bgCol,bg);\n    \n    // add some depth fog\n\tc=mix(c,bgCol,clamp(dot(dir,pos)*.4,0.,1.));\n\t\n    // vignetting\n    vec2 sc2=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.1-1.*dot(sc2,sc2);\n    //vign-=dot(exp(-sin(fragCoord/iResolution.xy*3.14)*vec2(20,10)),vec2(1,1));\n    vign*=1.-.3*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n    vign*=1.-.3*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n\n\tfragColor = vec4(c*vign,1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// some quaternion functions, frustum\n\n#define PI2 (3.141592653*2.)\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1) * sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 slerpQuat(vec4 q1, vec4 q2, float t)\n{\n    vec4 q3;\n    float dot = dot(q1, q2);\n\n    /*\tdot = cos(theta)\n     if (dot < 0), q1 and q2 are more than 90 degrees apart,\n     so we can invert one to reduce spinning\t*/\n    if (dot < 0.0)\n    {\n        dot = -dot;\n        q3 = -q2;\n    } else q3 = q2;\n\n    if (dot < 0.95)\n    {\n        float angle = acos(dot);\n        return (q1*sin(angle*(1.0-t)) + q3*sin(angle*t))/sin(angle);\n    } else // if the angle is small, use linear interpolation\n        return mix(q1,q3,t);\n}\n\nvec4 mirrorQuat(vec4 q, vec3 n)\n{\n    //rotate projector around axis which lying in mirror plane and is normal to projector x axis\n    //mirroring has to be done afterwards in x\n    // should be as simple as that: (rotating camera-x into mirror normal is exactly half the angle)\n    vec3 bx=transformVecByQuat(vec3(1,0,0),q);\n    vec3 axe=cross(bx,n);\n    vec4 qr=vec4(-axe,-sign(dot(n,bx))*sqrt(1.-dot(axe,axe)));\n    return multQuat(qr,q);\n}\n\n// glFustum reimplemented\nmat4 myFrustum(float l, float r, float b, float t, float n, float f)\n{\n    return mat4(\n        2.*n/(r-l),0,0,0,\n        0,2.*n/(t-b),0,0,\n        (r+l)/(r-l),(t+b)/(t-b),(n+f)/(n-f),-1,\n        0,0,2.*f*n/(n-f),0\n        );\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}