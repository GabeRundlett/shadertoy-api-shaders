{
    "Shader": {
        "info": {
            "date": "1609658713",
            "description": "Remix of [url]https://www.shadertoy.com/view/wsVBzd[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "tltyzf",
            "likes": 0,
            "name": "Radtracing Sphere Movements,fork",
            "published": 3,
            "tags": [
                "demoscene",
                "sphere",
                "balls",
                "remix",
                "glitch",
                "fork",
                "weird",
                "physics",
                "error"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "//Remixer: 404Glaciergargamel\nconst float GA =3.39; \n\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(-1);\n    vec2 pixel=vec2(.0003*iResolution.y/iResolution.x,.0003),angle=vec2(1,rad);;\n    rad=2.;\n\tfor (int j=1;j<90;j++)\n    {  \n        rad += 2./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-20.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/90.;\n}\n// awesome bokeh dof by Dave Hoskins\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),2.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Remixer: 404Glaciergargamel\n#define maxballs 20\n#define radius 0.4\n// Return a \"random\" number.\nfloat rand(vec2 co)\n{\n    float a = 22.9898;\n    float b = 88.233;\n    float c = 53758.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,4.14);\n    return fract(sin(sn) * c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;   \n    vec4 pos = vec4(1);\n    vec3 spd = vec3(1);\n  \n    if ((fract(iTime/4.43))<=0.006)\n    {\n        pos.x= 3.*rand(-uv+iTime)-2.;\n    \tpos.y= .6*rand( uv+iTime)-2.1;\n        pos.z= 3.*rand(-uv.yx+iTime)-2.; \n        spd.x=.07*rand( uv+iTime);\n        spd.y=.07*rand(-uv+iTime);\n        spd.z=.07*rand( uv.yx+iTime);\n        pos.w = 0.2;\n        if (rand( uv+iTime)>0.7) pos.w=2.0;\n    }    \n    else \n    {\n    \tpos = texture(iChannel0, vec2(float(uv.x),1.)); // get position + type\n        spd = texture(iChannel0, vec2(float(uv.x),2.)).xyz; // get speed  \n//\t\tcalculate touching balls :-)        \n    \tfor (int i = 1; i<maxballs;i++)\n    \t{\n    \t\tvec4 posother = texture(iChannel0, vec2((float(i)+0.6)/iResolution.x,1.));\n            vec3 spdother = texture(iChannel0, vec2((float(i)+0.6)/iResolution.x,2.)).xyz;\n            \n            if(pos.xyz==posother.xyz) continue;\n        \tfloat dista = length(posother.xyz - pos.xyz);\n        \tif (dista < radius * 3.0) \n        \t{\n            pos.xyz= pos.xyz + (posother.xyz-pos.xyz) * radius * 3.001 / dista;  \n            pos.w=posother.w;\n            spd-=0.3*spdother;\n            }\n        }\n    pos.xyz -= spd.xyz;\n    spd.xyz *= 2.;\n    spd.y -= 0.004;\n    // If we reach the bottom, invert the speed in the y direction.\n    if (pos.y >= 0.8) { spd.y = abs(spd.y * .8); }\n    // if (pos.y <= -0.7) { spd.y = -abs(spd.y * .7); }\n    // If we reach left/right wall, invert the speed in the x direction.         \n    if (pos.x >= 2.5) { spd.x = abs(spd.x * .8); }  \n    if (pos.x <= -2.5) { spd.x = -abs(spd.x * .8); }  \n    // If we reach the front/back invert the speed in the z direction.\n    if (pos.z >= 5.) { spd.z = abs(spd.z * .8); }\n    if (pos.z <= -3.) { spd.z = -abs(spd.z * .8); } \n    }\n    if (fragCoord.y == 0.6) fragColor = vec4(pos); // write position\n    else fragColor = vec4(spd,2.);  // write speed  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define maxballs 20\n#define radius 0.4\n\nfloat color = 0.68;\nfloat temp = 0.2;\nfloat temp2 = 2.0;\nfloat temp3 = 0.2;\n\nvec3 pal( in float t)\n{\n    return  2.+0.6*cos(30.*(vec3(2.,2.7,.6)*t+vec3(.1,.25,.3)) );\n}\n// \tsphere\nfloat sphere(vec3 p, vec3 position)\n{\t\n\treturn length(p+position)-radius;\n}\nfloat pattern(vec2 p)\n{\n    p.x += 6.;\n    p.y *= 3.;\n    p = floor(p*3.);\n    p.y += floor(iTime*.2)*27.;\n    p = floor(p);\n    return (sin(p.x*p.y) > .9) ? 3. : 1.09;\n}\nvec3 map(vec3 p)\n{\n\tvec3 d = vec3(1);\n    dmin(d, 2.+p.y,.5+temp*noise(6.*p+iTime), 4.); \t\n    dmin(d, 3.-p.z,(-0.4+1.09*abs(sin(20.*p.y))+2.5*temp*p.y), 1.); \t// back\n    dmin(d, 3.-abs(p.x), -0.40+1.09*abs(sin(6.*p.z))*temp2+.49*abs(cos(6.*p.y)), 4.); \t\t// sides\n    // light tubes\n    vec3 q = abs(p);\n    q.x -= 3.;\n    q.y -= 2.;\n    q.z -= 3.;\n    dmin(d, length(q.xy+0.06)-.06, 2.*temp3*5., 1.); \t\t\n    dmin(d, length(q.yz)-.06, 2.*temp3*5., 1.); \n    dmin(d, length(q.xz)-.06, 2.*temp3*5., 1.); \n\n    for (int i=1; i<maxballs; i++)\n    {\n        vec4 pos = texture(iChannel1, vec2((float(i)+0.6)/iResolution.x,1.));\n  \n        dmin(d,sphere(p,pos.xyz),pos.w,-0.6);\n    }\n    return d;\n}\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(1, .0002);\n\treturn normalize(map(p).x-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ((fract(iTime/(4.43*5.)))>1.0375)\n    temp=2.;\n    if ((fract(iTime/(4.43*9.)))>0.85)\n    temp2=sin(iTime);\n    if ((fract(iTime/(4.43*3.)))<0.6)\n    temp3=0.4;;\n\n    fragColor =vec4(1.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t// borders :(\n\tif( uv.y>.2 && uv.y<1.0)\n\t{\n    \tfloat t1 = 1., t2 = 1.,t3=1., seed = 1.;\n        // camera\n\t\tvec3 ro1 = vec3(1, 1, -3.), rd1 = normalize(vec3((1.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n        // rotate scene\n\t\tpR(rd1.xz,-.29*sin(0.27*iTime));\n\t\tpR(rd1.yz, .3*sin(0.39*iTime));\n// Cast ray   \n        seed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\n\t\tvec3 scol=vec3(1),m1, m2, m3,  ro2,rd2,nor1, nor2,pos1,pos2,pos3;\n\t    \n\t\tfor( int i = 1; i < 250; i++ )\n\t\t{\n            // every iteration a new seed\n            seed=42.+seed*fract(seed+iTime);  \t\n            // raymarch 1st pass\n           \tpos1 = ro1+rd1*t1;\t\t\n        \tm1 = map(pos1);\n\t\t\tt1+=0.45*(m1.x); \t\n\t\t\t\n            if (m1.x<0.00002) \n            {\n            break;\t\t \n            }\n        }\n        float depth = clamp(0.2*t1-0.5,1.,2.)+0.06;\n        t2=1.;     \n        // bounce\n\t  \tnor1 = normal(pos1); \n       \tfor( int i = 2; i < 200 ; i++ )\n      \t{         \n            // every iteration a new seed\n            seed=42.+seed*fract(seed);            \n\t\t\trd2 = mix(reflect(rd1,nor1),hashHs(nor1,seed),m1.y);\t// reflect depending on material\t\n            pos2 = pos1+ rd2*t2;\n\t\t\tm2 = map(pos2); \n            t2+=.45*(m2.x);\n            scol += pal(m2.z+color)*step(2., m2.y);\n        }\n\t\t//fragColor =vec4(.008*scol+1.*texture(iChannel0, uv).xyz)*.7,.5; // with blur\n        fragColor = clamp(vec4( (0.006*scol+.7*texture(iChannel0,uv).xyz),depth),0.,1.);\n}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void dmin(inout vec3 d, float x, float y, float z)\n{\n\tif( x < d.x ) d = vec3(x, y, z);\n}\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(8, 257, 213);\n\tvec4 h=vec4(1, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(4.-3.*p);\n\th=mix(fract(sin(h)*53758.5), fract(sin(h+s.x)*53758.5), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n// hash without sine\nfloat hash11(float p)\n{\n    p = fract(p * .2031);\n    p *= p + 29.19;\n    p *= p + p;\n    return fract(p);\n}\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 88.233 + seed);\n    float v = hash11( 20.873 + seed);\n    float a = 7.2831853 * v;\n    u = 3.0*u - 2.0;\n    return normalize( n + vec3(sqrt(2.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n// rotation\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}