{
    "Shader": {
        "info": {
            "date": "1455308920",
            "description": "One of those side view physics car/motorcycle/bike games.\nRight or Up Arrow=accelerate, Left or Down Arrow=Break/reverse. Space to restart at last checkpoint on game over.\nCollect red orbs to gain fuel.  Lose if you run out of fuel or land upside down.",
            "flags": 48,
            "hasliked": 0,
            "id": "Msy3WD",
            "likes": 65,
            "name": "2d Verlet Physics Stunt Car Game",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "physics"
            ],
            "usePreview": 1,
            "username": "demofox",
            "viewed": 4508
        },
        "renderpass": [
            {
                "code": "/*\nCredits:\n\nChanel Wolfe - Art Direction\nPaul Im - Technical Advisor (Thanks for convincing me to try Verlet!)\nAlan Wolfe - Everything Else\n\nEiffie - Gave a code change to fix a bug with the score display on some machines.\nNrx - Found an uninitialized variable being used, causing graphical glitches on some machines.\n\nSome great resources on game physics:\n\nhttp://gafferongames.com/game-physics/\nhttp://lonesock.net/article/verlet.html\nhttp://www.gamedev.net/page/resources/_/technical/math-and-physics/a-verlet-based-approach-for-2d-game-physics-r2714\n*/\n\n#define AA_AMOUNT 7.0 / iResolution.x\n\n#define SCORE_SIZE 25.0  // in pixels\n\n#define DEBUG_WHEELSTOUCHING 0  // wheels tinted green when they are touching the ground\n#define DEBUG_FUELCOLLIDE 0 // Shows the fuel orb colliding area around the car\n\nconst float c_grassDistance = 0.25; // how far apart on the x axis\nconst float c_grassMaxDepth = 1.0;  // how far below ground level it can go\n\nconst float c_treeDistance = 3.0; // how far apart on the x axis\nconst float c_treeMaxDepth = 0.5; // how far below ground level it can go\n\nconst float c_cloudDistance = 2.0; // how far apart on the x axis\nconst float c_cloudMaxDepth = 2.0; // vertical offset. +/- this amount max\n\n//============================================================\n// SHARED CODE BEGIN\n//============================================================\n\n#define PI 3.14159265359\n#define PIOVERTWO (PI * 0.5)\n#define TWOPI (PI * 2.0)\n\nconst float c_wheelRadius = 0.04;\nconst float c_wheelDistance = 0.125;\n\nconst float c_fuelCanDistance = 20.0;\nconst float c_fuelCanRadius = 0.075;\n\n// variables\nconst vec2 txState = vec2(0.0,0.0);\n// x = timer to handle fixed rate gameplay\n// y = queued input.  0.0 = left, 1.0 = right, 0.5 = none\n// zw = camera center\n#define VAR_FRAME_PERCENT state.x\n#define VAR_QUEUED_INPUT state.y\n#define VAR_CAMERA_CENTER state.zw\nconst vec2 txState2 = vec2(1.0,0.0);\n// x = camera scale\n// y = back wheel is on the ground (1.0 or 0.0)\n// z = front wheel is on the ground (1.0 or 0.0)\n// w = game is over (1.0) or not (0.0)\n#define VAR_CAMERA_SCALE state2.x\n#define VAR_BACKWHEEL_ONGROUND state2.y\n#define VAR_FRONTWHEEL_ONGROUND state2.z\n#define VAR_GAMEOVER state2.w\nconst vec2 txState3 = vec2(2.0,0.0);\n// x = used to slowdown simulation only right when you hit game over state\n// y = last collected fuel orb distance\n// z = spedometer\n// w = fuel remaining\n#define VAR_SIMSLOWDOWN state3.x\n#define VAR_LASTFUELORB state3.y\n#define VAR_SPEDOMETER state3.z\n#define VAR_FUELREMAINING state3.w\n// these are used by check points.  We always restore to the older check point so\n// the player doesn't get stuck in a shitty check point.\nconst vec2 txFrontWheelCP1 = vec2(3.0,0.0);\nconst vec2 txFrontWheelCP2 = vec2(4.0,0.0);\nconst vec2 txBackWheelCP1 = vec2(5.0,0.0);\nconst vec2 txBackWheelCP2 = vec2(6.0,0.0);\nconst vec2 txState4 = vec2(7.0,0.0);\n// x = fuel at CP1\n// y = fuel at CP2\n// z = last CP hit\n// w = unused\n#define VAR_FUELREMAININGCP1 state4.x\n#define VAR_FUELREMAININGCP2 state4.y\n#define VAR_LASTCPHIT state4.w\n\n// simulated points\n// format: xy = location this frame. zw = location last frame\nconst vec2 txBackWheel = vec2(8.0, 0.0);\nconst vec2 txFrontWheel = vec2(9.0, 0.0);\n\nconst vec2 txVariableArea = vec2(10.0, 1.0);\n\nfloat GroundHeightAtX (float x, float scale)\n{\n    \n    //return 0.0;\n    \n    /*\n    float frequency = 2.0 * frequencyScale;\n    float amplitude = 0.1 * scale;\n    return sin(x*frequency) * amplitude +\n           sin(x*frequency*2.0) * amplitude / 2.0\n           + sin(x*frequency*3.0) * amplitude / 3.0\n           + sin(x*1.0) * amplitude * 5.0;\n    */\n    \n    #define ADDWAVE(frequency, start, easein, amplitude, scalarFrequency) ret += sin(x * frequency) * clamp((x-start)/easein, 0.0, 1.0) * amplitude * (sin(x*scalarFrequency) * 0.5 + 0.5);\n    \n    x *= scale;\n    \n    // add several sine waves together to make the terrain\n    // frequency and amplitudes increase over distance    \n    float ret = 0.0;\n    \n    // have a low frequency, low amplitude sine wave\n    ADDWAVE(0.634, 0.0, 0.0, 0.55, 0.1);\n    \n    // a slightly higher frequency adds in amplitude over time\n    ADDWAVE(1.0, 0.0, 50.0, 0.5, 0.37);\n    \n    // at 75 units in, start adding in a higher frequency, lower amplitude wave\n    ADDWAVE(3.17, 75.0, 50.0, 0.1, 0.054); \n    \n    // at 150 units, add in higher frequency waves\n    ADDWAVE(9.17, 150.0, 50.0, 0.05, 0.005);\n    \n    // at 225 units, add another low frequency, medium amplitude sine wave\n    ADDWAVE(0.3, 225.0, 10.0, 0.9, 0.01);    \n    \n    // add an explicit envelope to the starting area\n    ret *= smoothstep(x / 2.0, 0.0, 1.0);\n    \n    return ret * scale;  \n}\n\nfloat GroundFunction (vec2 p, float scale)\n{\n    return GroundHeightAtX(p.x, scale) - p.y;\n}\n\nvec2 AsyncPointPos (in vec4 point, in float frameFraction)\n{\n    return mix(point.zw, point.xy, frameFraction);\n}\n\nvec2 AsyncBikePos (in vec4 backWheel, in vec4 frontWheel, in float frameFraction)\n{\n    return (AsyncPointPos(backWheel, frameFraction)+AsyncPointPos(frontWheel, frameFraction)) * 0.5;\n}\n\nvec2 GroundFunctionGradiant (in vec2 coords, float scale)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( GroundFunction(coords+h.xy, scale) - GroundFunction(coords-h.xy, scale),\n                 GroundFunction(coords+h.yx, scale) - GroundFunction(coords-h.yx, scale) ) / (2.0*h.x);\n}\n\nfloat EstimatedDistanceFromPointToGround (in vec2 point, float scale)\n{\n    float v = GroundFunction(point, scale);\n    vec2  g = GroundFunctionGradiant(point, scale);\n    return v/length(g);\n}\n\nfloat EstimatedDistanceFromPointToGround (in vec2 point, float scale, float frequencyScale, out vec2 gradient)\n{\n    float v = GroundFunction(point, scale);\n    gradient = GroundFunctionGradiant(point, scale);\n    return v/length(gradient);\n}\n\n//============================================================\n// SHARED CODE END\n//============================================================\n\n\n//============================================================\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//============================================================\n// Signed Distance Functions taken/adapted/inspired by from:\n// https://iquilezles.org/articles/distfunctions\n\nfloat UDCircle( in vec2 coords, in vec2 circle, float radius)\n{    \n    return max(length(coords - circle.xy) - radius, 0.0);\n}\n\n//============================================================\nfloat UDFatLineSegment (in vec2 coords, in vec2 A, in vec2 B, in float height)\n{    \n    // calculate x and y axis of box\n    vec2 xAxis = normalize(B-A);\n    vec2 yAxis = vec2(xAxis.y, -xAxis.x);\n    float width = length(B-A);\n    \n\t// make coords relative to A\n    coords -= A;\n    \n    vec2 relCoords;\n    relCoords.x = dot(coords, xAxis);\n    relCoords.y = dot(coords, yAxis);\n    \n    // calculate closest point\n    vec2 closestPoint;\n    closestPoint.x = clamp(relCoords.x, 0.0, width);\n    closestPoint.y = clamp(relCoords.y, -height * 0.5, height * 0.5);\n    \n    return length(relCoords - closestPoint);\n}\n\n//============================================================\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//============================================================\nfloat RandomFloat (vec2 seed) // returns 0..1\n{\n    return rand(vec2(seed.x*0.645, 0.453+seed.y*0.329));\n}\n\n//============================================================\n//number rendering from https://www.shadertoy.com/view/XdjSWz\nbool number(int x, int y, int n)\n{\n    return ((y==1 && x>1 && x<5 && n!=1 && n!=4) ||\n            (y==5 && x>1 && x<5 && n!=0 && n!=1 && n!=7) ||\n            (y==9 && x>1 && x<5 && n!=1 && n!=4 && n!=7) ||\n            (x==1 && y>1 && y<5 && n!=1 && n!=2 && n!=3) ||\n            (x==5 && y>1 && y<5 && n!=5 && n!=6) ||\n            (x==1 && y>5 && y<9 && (n==0 || n==2 || n==6 || n==8)) ||\n            (x==5 && y>5 && y<9 && n!=2) );\n}\n\n//============================================================\nvoid DrawGrass (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale)\n{\n    // draws periodic grass tufts\n    vec2 grassOrigin;\n    grassOrigin.x = floor(uv.x / c_grassDistance) * c_grassDistance + c_grassDistance * 0.5;\n    grassOrigin.y = GroundHeightAtX(grassOrigin.x, scale);    \n    \n    float forceTop = RandomFloat(grassOrigin + vec2(0.342, 0.856)) > 0.25 ? 1.0 : 0.0;\n    grassOrigin.y -= forceTop * (RandomFloat(grassOrigin + vec2(0.756, 0.564)) * c_grassMaxDepth);\n    \n    vec2 grassYAxis = -GroundFunctionGradiant(grassOrigin, scale);\n    vec2 grassXAxis = vec2(grassYAxis.y, -grassYAxis.x);\n    \n    vec2 uvRelative = uv - grassOrigin;\n    vec2 uvLocal;\n    uvLocal.x = dot(uvRelative, grassXAxis);\n    uvLocal.y = dot(uvRelative, grassYAxis);\n    uvLocal /= scale;\n    \n    float snowLine = sin(uv.x*2.35) * 0.1 + sin(uv.x*3.14) * 0.01;\n    float grassStoneMix = smoothstep(snowLine-0.3, snowLine+0.3, uv.y);        \n    vec3 grassColor = mix(vec3(0.3,0.4,0.1),vec3(0.7,0.8,0.5),grassStoneMix * 0.5);\n    \n    // draw a few random tufts\n    for (int i = 0; i < 5; ++i)\n    {\n    \tvec2 endPoint;\n        endPoint.x = (RandomFloat(grassOrigin + vec2(0.254, 0.873) * float(i)) * 2.0 - 1.0) * 0.1;\n        endPoint.y = RandomFloat(grassOrigin + vec2(0.254, 0.873) * float(i)) * 0.03 + 0.02;\n        \n        vec2 startingOffset;\n        startingOffset.x = endPoint.x  * 0.6;\n        startingOffset.y = 0.0;\n        \n    \tfloat tuftDistance = UDFatLineSegment(uvLocal, startingOffset, endPoint, 0.01);\n    \ttuftDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, tuftDistance);\n\t\tpixelColor = mix(pixelColor, grassColor * tint, tuftDistance);\n    }\n}\n\n//============================================================\nvoid DrawTrees (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale)\n{\n    // draw periodic trees\n    vec2 treeOrigin;\n    treeOrigin.x = floor(uv.x / c_treeDistance) * c_treeDistance + c_treeDistance * 0.5;\n    treeOrigin.y = GroundHeightAtX(treeOrigin.x, scale);    \n    \n    float forceTop = 1.0;//RandomFloat(treeOrigin + vec2(0.342, 0.856)) > 0.75 ? 1.0 : 0.0;\n    treeOrigin.y -= forceTop * (RandomFloat(treeOrigin + vec2(0.756, 0.564)) * c_treeMaxDepth);\n    \n    vec2 treeYAxis = -GroundFunctionGradiant(treeOrigin, scale);\n    vec2 treeXAxis = vec2(treeYAxis.y, -treeYAxis.x);\n    \n    vec2 uvRelative = uv - treeOrigin;\n    vec2 uvLocal;\n    uvLocal.x = dot(uvRelative, treeXAxis);\n    uvLocal.y = dot(uvRelative, treeYAxis);\n    uvLocal /= scale;\n    \n    // draw a brown trunk\n   \tfloat dist = UDFatLineSegment(uvLocal, vec2(0.0, 0.0), vec2(0.0,0.15), 0.035);\n   \tdist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);\n\tpixelColor = mix(pixelColor, vec3(0.6, 0.3, 0.1) * tint, dist);\n    \n    // draw some green circles\n    dist = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n       \tvec3 circle;\n        circle.x = 0.05 * (RandomFloat(treeOrigin + vec2(0.453, 0.923) * float(i)) * 2.0 - 1.0);\n        circle.y = 0.08 + 0.2 * RandomFloat(treeOrigin + vec2(0.543, 0.132) * float(i));\n        circle.z = 0.05 + 0.02 * RandomFloat(treeOrigin + vec2(0.132, 0.645) * float(i));\n    \tdist = min(dist, UDCircle(uvLocal, circle.xy, circle.z));  \n    }    \n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT * 3.0, dist);\n    pixelColor = mix(pixelColor, vec3(0.0,0.4,0.0) * tint, dist);       \n}\n\n//============================================================\nvoid DrawHills (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale)\n{\n    float snowLine = sin(uv.x*2.35) * 0.1 + sin(uv.x*3.14) * 0.01;\n    float grassStoneMix = smoothstep(snowLine-0.3, snowLine+0.3, uv.y);    \n    \n    float dist = EstimatedDistanceFromPointToGround(uv, scale) * -1.0;\n    float green = clamp(dist * -3.0, 0.0, 1.0);\n    green = smoothstep(0.0, 1.0, green) * 0.25;\n    vec3 grassPixel = mix(pixelColor, vec3(0.35, (0.85 - green), 0.15) * tint, 1.0 - smoothstep(0.0, AA_AMOUNT, dist)); \n    \n    vec3 stonePixel = mix(pixelColor, vec3((0.85 - green), (0.85 - green), (0.85 - green)) * tint, 1.0 - smoothstep(0.0, AA_AMOUNT, dist)); \n    \n    pixelColor = mix(grassPixel,stonePixel,grassStoneMix);  \n    \n    DrawGrass(uv, pixelColor, tint, scale);\n    DrawTrees(uv, pixelColor, tint, scale);\n}\n\n//============================================================\nvoid DrawClouds (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale, in float alpha)\n{\n    // draw clusters of tinted white circles?\n    vec2 cloudOrigin = vec2(0.0);\n    cloudOrigin.x = floor(uv.x / c_cloudDistance) * c_cloudDistance + c_cloudDistance * 0.5;\n    cloudOrigin.y = (RandomFloat(cloudOrigin + vec2(0.453, 0.748) * 2.0 - 1.0) * c_cloudMaxDepth);\n    \n    vec2 uvRelative = uv - cloudOrigin;\n    uvRelative /= scale;    \n    \n    float dist = 1.0;\n    for (int i = 0; i < 10; ++i)\n    {\n       \tvec3 circle;\n        circle.x = 0.5 * (RandomFloat(cloudOrigin + vec2(0.453, 0.923) * float(i)) * 2.0 - 1.0);\n        circle.y = 0.08 + 0.2 * RandomFloat(cloudOrigin + vec2(0.543, 0.132) * float(i));\n        circle.z = 0.1 + 0.1 * RandomFloat(cloudOrigin + vec2(0.132, 0.645) * float(i));\n    \tdist = min(dist, UDCircle(uvRelative, circle.xy, circle.z));  \n    }    \n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*40.0, dist);\n    pixelColor = mix(pixelColor, tint, dist * alpha);       \n}\n\n//============================================================\nvoid DrawWheel (in vec2 uv, in vec2 wheelPos, inout vec3 pixelColor, bool touchingGround)\n{\n    vec3 wheelColor = vec3(0.0);\n    \n    #if DEBUG_WHEELSTOUCHING\n    if (touchingGround)\n    \twheelColor = vec3(0.5,1.0,0.5);    \n    #endif\n        \n\tfloat zoomCircleDist = UDCircle(uv, wheelPos, c_wheelRadius);\n    zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);\n    pixelColor = mix(pixelColor, wheelColor, zoomCircleDist);    \n    \n\tzoomCircleDist = UDCircle(uv, wheelPos, c_wheelRadius*0.5);\n    zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);\n    pixelColor = mix(pixelColor, vec3(0.75), zoomCircleDist);      \n}\n\n//============================================================\nvoid DrawCar (in vec2 uv, inout vec3 pixelColor, vec4 backWheel, vec4 frontWheel, vec4 state, vec4 state2)\n{\n    // Draw the bike.  Note that we interpolate between last and\n    // current simulation state, which makes the simulation look\n    // smoother than it actually is!\n   \n    vec2 backWheelPos = AsyncPointPos(backWheel, VAR_FRAME_PERCENT);\n    vec2 frontWheelPos = AsyncPointPos(frontWheel, VAR_FRAME_PERCENT);    \n    \n    // draw the wheels.\n    DrawWheel(uv, backWheelPos, pixelColor, VAR_BACKWHEEL_ONGROUND == 1.0);\n    DrawWheel(uv, frontWheelPos, pixelColor, VAR_FRONTWHEEL_ONGROUND == 1.0);       \n    \n    // draw the frame\n    vec2 carOrigin = backWheelPos;\n    vec2 xAxis = normalize(frontWheelPos - backWheelPos);\n    vec2 yAxis = vec2(-xAxis.y, xAxis.x);\n        \n    vec2 uvRelative = uv - carOrigin;\n    vec2 uvLocal;\n    uvLocal.x = dot(uvRelative, xAxis);\n    uvLocal.y = dot(uvRelative, yAxis);\n    \n#if 1\n    float carDistance = UDFatLineSegment(uvLocal, vec2(-c_wheelDistance*0.5, 0.04), vec2(c_wheelDistance*1.6, 0.03), 0.035);\n    carDistance = min(carDistance, UDFatLineSegment(uvLocal, vec2(-0.06,0.04), vec2(0.04,0.09), 0.01));\n    carDistance = min(carDistance, UDFatLineSegment(uvLocal, vec2(0.04,0.09), vec2(0.08,0.09), 0.01));\n    carDistance = min(carDistance, UDFatLineSegment(uvLocal, vec2(0.08,0.09), vec2(0.12,0.04), 0.01));\n    carDistance -= 0.0025;    \n\tcarDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, carDistance);\n    pixelColor = mix(pixelColor, vec3(0.1, 0.0, 0.0), carDistance);\n\n#else\n    float carDistance = UDFatLineSegment(uvLocal, vec2(-c_wheelDistance*0.5, 0.04), vec2(c_wheelDistance*2.0, 0.04), 0.05);\n    carDistance = min (carDistance, UDFatLineSegment(uvLocal, vec2(-c_wheelDistance*0.5, 0.09), vec2(c_wheelDistance, 0.09), 0.05));\n    carDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, carDistance);\n    pixelColor = mix(pixelColor, vec3(0.3,0.3,0.3), carDistance); \n#endif\n    \n}\n\n//============================================================\nvoid DrawGround (in vec2 uv, in vec2 cameraOffset, inout vec3 pixelColor, vec4 backWheel, vec4 frontWheel, vec4 state, vec4 state2, vec4 state3)\n{\n    // draw background layers\n    DrawHills (uv + vec2(1000.0, -0.3) + cameraOffset *-0.9 , pixelColor, vec3(0.25), 0.7 );\n    DrawClouds(uv + vec2(1000.0, -0.3) + iTime * vec2(0.05,0.0) + cameraOffset *-0.85, pixelColor, vec3(0.3) , 0.75, 0.75);\n    DrawHills (uv + vec2(300.0 , -0.1) + cameraOffset  *-0.8 , pixelColor, vec3(0.5) , 0.8 );\n    DrawClouds(uv + vec2(300.0 , -0.1) + iTime * vec2(0.15,0.0) + cameraOffset  *-0.7 , pixelColor, vec3(0.6) , 0.75, 0.75);\n    \n    // draw the car before the ridable layer so that trees and grass appear in front\n    DrawCar(uv, pixelColor, backWheel, frontWheel, state, state2);\n\n    // draw the ridable layer\n \tDrawHills(uv, pixelColor, vec3(1.0), 1.0);\n    \n    // draw the periodic fuel orbs\n    if (uv.x > VAR_LASTFUELORB)\n    {\n    \tfloat uvFuelX = mod(uv.x, c_fuelCanDistance) - c_fuelCanDistance * 0.5;\n    \tfloat uvFuelY = GroundHeightAtX(floor(uv.x / c_fuelCanDistance) * c_fuelCanDistance + c_fuelCanDistance * 0.5, 1.0);\n    \tuvFuelY += c_fuelCanRadius*1.1;\n\t\tfloat fuelDist = UDCircle(uv, vec2(uvFuelX+uv.x, uvFuelY), c_fuelCanRadius*0.5);          \n\t\tfuelDist = 1.0 - smoothstep(0.0, AA_AMOUNT*10.0, fuelDist);\n    \tpixelColor = mix(pixelColor, vec3(1.0, 0.0, 0.0), fuelDist);\n    }\n    \n    // draw some small foreground clouds\n    DrawClouds(uv + vec2(700.0 , -1.25) + iTime * vec2(0.25,0.0) + cameraOffset * 0.5 , pixelColor, vec3(1.0) , 1.0, 0.5);\n}\n\n//============================================================\nvoid DrawSky (in vec2 uv, in vec2 cameraOffset, inout vec3 pixelColor)\n{\n    float alpha = clamp(0.0,1.0,uv.y + cameraOffset.y * -0.9);\n    alpha = smoothstep(0.0, 1.0, alpha);\n    pixelColor = mix(vec3(0.25,0.6,1.0), vec3(0.25,0.1,0.3), alpha);\n}\n\n//============================================================\nvoid DrawDigit (vec2 fragCoord, int digitValue, int digitIndex, inout vec3 pixelColor)\n{\n    if (digitValue < 0)\n        digitValue = 0;\n    \n    int indexX = int(fragCoord.x / SCORE_SIZE);\n    int indexY = int((iResolution.y - fragCoord.y) / SCORE_SIZE);\n    \n    if (indexY > 0 || indexX != digitIndex)\n        return;\n    \n    vec2 percent = fract(vec2(fragCoord.x,iResolution.y-fragCoord.y) / SCORE_SIZE);\n    \n    int x = int(percent.x * SCORE_SIZE / 2.0);\n    int y = int(percent.y * SCORE_SIZE / 2.0);\n    \n    if (number(x,y,digitValue))\n        pixelColor = vec3(1.0);    \n}\n\n//============================================================\nvoid DrawScore (vec2 fragCoord, float score, inout vec3 pixelColor)\n{\n    // keep score between 0000 and 9999\n    score = clamp(score, 0.0, 9999.0);\n    \n    // digits numbered from right to left\n    int digit0 = int(mod(score, 10.0));\n    int digit1 = int(mod(score / 10.0, 10.0));\n    int digit2 = int(mod(score / 100.0, 10.0));\n    int digit3 = int(mod(score / 1000.0, 10.0));\n    \n    // digit index is from left to right though\n    DrawDigit(fragCoord, digit0, 3, pixelColor);\n    DrawDigit(fragCoord, digit1, 2, pixelColor);\n    DrawDigit(fragCoord, digit2, 1, pixelColor);\n    DrawDigit(fragCoord, digit3, 0, pixelColor);\n}\n\n//============================================================\nvoid DrawSpeedometer (vec2 fragCoord, float speedPercent, inout vec3 pixelColor)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    \n    const float size = 0.15;\n    vec2 center = vec2(0.5 * aspectRatio - (size+AA_AMOUNT), -0.5 + (size+AA_AMOUNT));\n    \n    // early out if outside spedometer\n    if (UDCircle(uv, center, size) > AA_AMOUNT)\n        return;\n    \n    // yellow outer ring\n\tfloat zoomCircleDist = UDCircle(uv, center, size);  \n\tzoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);\n    pixelColor = mix(pixelColor, vec3(0.8,0.6,0.0), zoomCircleDist);  \n    \n    // grey interior\n\tzoomCircleDist = UDCircle(uv, center, size - AA_AMOUNT);          \n\tzoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);\n    pixelColor = mix(pixelColor, vec3(0.1), zoomCircleDist);\n    \n    // Tick marks\n    vec2 relativePoint = uv - center;\n    float relativePointAngle = atan(relativePoint.y, relativePoint.x);\n    relativePointAngle += PI * 0.25;\n    relativePointAngle = mod(relativePointAngle, TWOPI);\n    if (relativePointAngle < PI * 1.5)\n    {\n    \tvec2 fakePoint = vec2(length(relativePoint) / size, relativePointAngle);\n    \tfakePoint.y = mod(fakePoint.y, 0.4) - 0.2;\n        float tickDistance = UDFatLineSegment(fakePoint, vec2(0.85, 0.0), vec2(0.95, 0.0), 0.05);\n        tickDistance = 1.0 - smoothstep(0.0, AA_AMOUNT*5.0, tickDistance);\n        pixelColor = mix(pixelColor, vec3(1.0,1.0,0.0), tickDistance);\n    }\n    \n    // speed bar\n    float targetAngle = (1.0 - clamp(speedPercent, 0.0, 1.0)) * PI * 1.5 - PI * 0.25;\n    vec2 targetPoint = center + size * 0.9 * vec2(cos(targetAngle), sin(targetAngle));\n        \n    float boxDistance = UDFatLineSegment(uv, center, targetPoint , 0.003);\n    boxDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, boxDistance);\n    pixelColor = mix(pixelColor, vec3(1.0,0.0,0.0), boxDistance);\n    \n    // red ring in the middle, attached to the bar\n\tzoomCircleDist = UDCircle(uv, center, AA_AMOUNT);          \n\tzoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);\n    pixelColor = mix(pixelColor, vec3(1.0,0.0,0.0), zoomCircleDist);        \n}\n\n//============================================================\nvoid DrawFuelBar(vec2 fragCoord, float fuelPercent, inout vec3 pixelColor)\n{\n    fuelPercent = min(fuelPercent, 1.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;    \n    \n    const float c_width = 0.2;\n    const float c_height = 0.05;\n    \n    vec2 boxPosLeft = vec2(-0.5 * aspectRatio + 0.01, 0.5 - (c_height + SCORE_SIZE / iResolution.y));\n    vec2 boxPosRight = vec2(-0.5 * aspectRatio + 0.01 + c_width, 0.5 - (c_height + SCORE_SIZE / iResolution.y));\n    \n    // black outer box\n    float boxDistance = UDFatLineSegment(uv, boxPosLeft, boxPosRight, c_height);\n    boxDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, boxDistance);\n    pixelColor = mix(pixelColor, vec3(0.0,0.0,0.0), boxDistance);\n    \n    // red fuel amount\n    if (fuelPercent > 0.0)\n    {\n        boxPosRight.x = boxPosLeft.x + (boxPosRight.x - boxPosLeft.x) * fuelPercent;\n        boxDistance = UDFatLineSegment(uv, boxPosLeft, boxPosRight, c_height);\n        boxDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, boxDistance);\n        pixelColor = mix(pixelColor, vec3(1.0,0.0,0.0), boxDistance);   \n    }\n}\n    \n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //----- Load State -----    \n    vec4 state    \t  = loadValue(txState);   \n    vec4 state2   \t  = loadValue(txState2); \n    vec4 state3   \t  = loadValue(txState3); \n    vec4 backWheel    = loadValue(txBackWheel);   \n    vec4 frontWheel   = loadValue(txFrontWheel);\n    \n    // calculate coordinates based on camera settings\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5);\n    uv.x *= aspectRatio;\n    uv *= VAR_CAMERA_SCALE;\n    uv += VAR_CAMERA_CENTER;\n    \n    // draw the sky\n    vec3 pixelColor = vec3(0.0);\n    DrawSky(uv, VAR_CAMERA_CENTER, pixelColor);\n    \n    // draw the ground\n    DrawGround(uv, VAR_CAMERA_CENTER, pixelColor, backWheel, frontWheel, state, state2, state3);\n    \n    // Draw UI\n    DrawScore(fragCoord, VAR_CAMERA_CENTER.x, pixelColor);\n    DrawSpeedometer(fragCoord, VAR_SPEDOMETER, pixelColor);\n    DrawFuelBar(fragCoord, VAR_FUELREMAINING, pixelColor);\n    \n    // if game over, mix it towards red a bit\n    if (VAR_GAMEOVER == 1.0)\n    {\n        vec3 greyPixel = vec3(dot(pixelColor, vec3(0.3, 0.59, 0.11)));\n        pixelColor = mix(vec3(1.0,0.0,0.0), greyPixel, VAR_SIMSLOWDOWN * 0.75 + 0.25);    \n    }\n    \n    #if DEBUG_FUELCOLLIDE\n    vec2 bikePos = AsyncBikePos(backWheel, frontWheel, VAR_FRAME_PERCENT);\n    if (length(bikePos - uv) < c_fuelCanRadius * 2.0)\n        pixelColor = mix(pixelColor, vec3(1.0, 1.0, 0.0), 0.25);\n    #endif\n    \n    // output the final color\n\tfragColor = vec4(pixelColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// game speed in ticks per second\nconst float c_tickRate = 16.0;\n\n// what factor to slow the game down by when it's game over\nconst float c_tickRateGameOver = 0.0;\n\n// how long the game over state slows down the simulation for\nconst float c_gameOverSlowdownDuration = 3.0;\n\n// how many simulation steps to do per tick.  More = more costly, but better simulations.\nconst int c_numSimulationSteps = 1;\n\n// simulation constants\nconst vec2 c_gravityAcceleration = vec2(0.0, -5.0);  // -9.8 is real life values, but 1 unit != 1 meter in our sim.\nconst float c_rotationMultiplier = 0.1; // how much rotation done\nconst float c_throttleAcceleration = 4.0;\nconst float c_fuelBurnRate = 10.0;\nconst float c_checkPointDistance = 5.0; // in world units, distance between checkpoints.\n\n// derived values\nconst float c_tickDeltaTime = 1.0 / c_tickRate;\nconst float c_tickDeltaTimeSq = c_tickDeltaTime*c_tickDeltaTime;\n\n// keys\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n//============================================================\n// SHARED CODE BEGIN\n//============================================================\n\n#define PI 3.14159265359\n#define PIOVERTWO (PI * 0.5)\n#define TWOPI (PI * 2.0)\n\nconst float c_wheelRadius = 0.04;\nconst float c_wheelDistance = 0.125;\n\nconst float c_fuelCanDistance = 20.0;\nconst float c_fuelCanRadius = 0.075;\n\n// variables\nconst vec2 txState = vec2(0.0,0.0);\n// x = timer to handle fixed rate gameplay\n// y = queued input.  0.0 = left, 1.0 = right, 0.5 = none\n// zw = camera center\n#define VAR_FRAME_PERCENT state.x\n#define VAR_QUEUED_INPUT state.y\n#define VAR_CAMERA_CENTER state.zw\nconst vec2 txState2 = vec2(1.0,0.0);\n// x = camera scale\n// y = back wheel is on the ground (1.0 or 0.0)\n// z = front wheel is on the ground (1.0 or 0.0)\n// w = game is over (1.0) or not (0.0)\n#define VAR_CAMERA_SCALE state2.x\n#define VAR_BACKWHEEL_ONGROUND state2.y\n#define VAR_FRONTWHEEL_ONGROUND state2.z\n#define VAR_GAMEOVER state2.w\nconst vec2 txState3 = vec2(2.0,0.0);\n// x = used to slowdown simulation only right when you hit game over state\n// y = last collected fuel orb distance\n// z = spedometer\n// w = fuel remaining\n#define VAR_SIMSLOWDOWN state3.x\n#define VAR_LASTFUELORB state3.y\n#define VAR_SPEDOMETER state3.z\n#define VAR_FUELREMAINING state3.w\n// these are used by check points.  We always restore to the older check point so\n// the player doesn't get stuck in a shitty check point.\nconst vec2 txFrontWheelCP1 = vec2(3.0,0.0);\nconst vec2 txFrontWheelCP2 = vec2(4.0,0.0);\nconst vec2 txBackWheelCP1 = vec2(5.0,0.0);\nconst vec2 txBackWheelCP2 = vec2(6.0,0.0);\nconst vec2 txState4 = vec2(7.0,0.0);\n// x = fuel at CP1\n// y = fuel at CP2\n// z = last CP hit\n// w = unused\n#define VAR_FUELREMAININGCP1 state4.x\n#define VAR_FUELREMAININGCP2 state4.y\n#define VAR_LASTCPHIT state4.w\n\n// simulated points\n// format: xy = location this frame. zw = location last frame\nconst vec2 txBackWheel = vec2(8.0, 0.0);\nconst vec2 txFrontWheel = vec2(9.0, 0.0);\n\nconst vec2 txVariableArea = vec2(10.0, 1.0);\n\nfloat GroundHeightAtX (float x, float scale)\n{\n    \n    //return 0.0;\n    \n    /*\n    float frequency = 2.0 * frequencyScale;\n    float amplitude = 0.1 * scale;\n    return sin(x*frequency) * amplitude +\n           sin(x*frequency*2.0) * amplitude / 2.0\n           + sin(x*frequency*3.0) * amplitude / 3.0\n           + sin(x*1.0) * amplitude * 5.0;\n    */\n    \n    #define ADDWAVE(frequency, start, easein, amplitude, scalarFrequency) ret += sin(x * frequency) * clamp((x-start)/easein, 0.0, 1.0) * amplitude * (sin(x*scalarFrequency) * 0.5 + 0.5);\n    \n    x *= scale;\n    \n    // add several sine waves together to make the terrain\n    // frequency and amplitudes increase over distance    \n    float ret = 0.0;\n    \n    // have a low frequency, low amplitude sine wave\n    ADDWAVE(0.634, 0.0, 0.0, 0.55, 0.1);\n    \n    // a slightly higher frequency adds in amplitude over time\n    ADDWAVE(1.0, 0.0, 50.0, 0.5, 0.37);\n    \n    // at 75 units in, start adding in a higher frequency, lower amplitude wave\n    ADDWAVE(3.17, 75.0, 50.0, 0.1, 0.054); \n    \n    // at 150 units, add in higher frequency waves\n    ADDWAVE(9.17, 150.0, 50.0, 0.05, 0.005);\n    \n    // at 225 units, add another low frequency, medium amplitude sine wave\n    ADDWAVE(0.3, 225.0, 10.0, 0.9, 0.01);    \n    \n    // add an explicit envelope to the starting area\n    ret *= smoothstep(x / 2.0, 0.0, 1.0);\n    \n    return ret * scale;  \n}\n\nfloat GroundFunction (vec2 p, float scale)\n{\n    return GroundHeightAtX(p.x, scale) - p.y;\n}\n\nvec2 AsyncPointPos (in vec4 point, in float frameFraction)\n{\n    return mix(point.zw, point.xy, frameFraction);\n}\n\nvec2 AsyncBikePos (in vec4 backWheel, in vec4 frontWheel, in float frameFraction)\n{\n    return (AsyncPointPos(backWheel, frameFraction)+AsyncPointPos(frontWheel, frameFraction)) * 0.5;\n}\n\nvec2 GroundFunctionGradiant (in vec2 coords, float scale)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( GroundFunction(coords+h.xy, scale) - GroundFunction(coords-h.xy, scale),\n                 GroundFunction(coords+h.yx, scale) - GroundFunction(coords-h.yx, scale) ) / (2.0*h.x);\n}\n\nfloat EstimatedDistanceFromPointToGround (in vec2 point, float scale)\n{\n    float v = GroundFunction(point, scale);\n    vec2  g = GroundFunctionGradiant(point, scale);\n    return v/length(g);\n}\n\nfloat EstimatedDistanceFromPointToGround (in vec2 point, float scale, float frequencyScale, out vec2 gradient)\n{\n    float v = GroundFunction(point, scale);\n    gradient = GroundFunctionGradiant(point, scale);\n    return v/length(gradient);\n}\n\n//============================================================\n// SHARED CODE END\n//============================================================\n\n\n\n//============================================================\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//============================================================\nvec2 RotatePoint (vec2 point, float theta)\n{\n    return vec2(point.x * cos(theta) - point.y * sin(theta), point.y * cos(theta) + point.x * sin(theta));\n}\n\n//============================================================\nvec2 RotatePointAroundPoint (vec2 point, vec2 origin, float theta)\n{\n    return RotatePoint(point-origin, theta) + origin;\n}\n\n//============================================================\nvoid VerletIntegrate (inout vec4 point, in vec2 acceleration)\n{\n\tvec2 currentPos = point.xy;\n    vec2 lastPos = point.zw;\n\n    vec2 newPos = currentPos + currentPos - lastPos + acceleration * c_tickDeltaTimeSq;\n    \n    point.xy = newPos;\n    point.zw = currentPos;\n}\n\n//============================================================\nvoid ResolveGroundCollision (inout vec2 point, inout bool pointTouchingGround)\n{\n    vec2 gradient;\n    float dist = EstimatedDistanceFromPointToGround (point, 1.0, 1.0, gradient) * -1.0;\n    if (dist < c_wheelRadius)\n    {\n        float distanceAdjust = c_wheelRadius - dist;\n        point -= normalize(gradient) * distanceAdjust;\n        pointTouchingGround = true;\n    }\n}\n\n//============================================================\nvoid ResolveDistanceConstraint (inout vec2 pointA, inout vec2 pointB, float distance)\n{\n    // calculate how much we need to adjust the distance between the points\n    // and cut it in half since we adjust each point half of the way\n    float halfDistanceAdjust = (distance - length(pointB-pointA)) * 0.5;\n    \n    // calculate the vector we need to adjust along\n    vec2 adjustVector = normalize(pointB-pointA);\n    \n    // adjust each point half of the adjust distance, along the adjust vector\n    pointA -= adjustVector * halfDistanceAdjust;\n    pointB += adjustVector * halfDistanceAdjust;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > txVariableArea.x || fragCoord.y > txVariableArea.y)\n        discard;\n    \n    //----- Load State -----    \n    vec4 state         = loadValue(txState);\n    vec4 state2        = loadValue(txState2);\n    vec4 state3        = loadValue(txState3);\n    vec4 state4        = loadValue(txState4);\n    vec4 backWheel     = loadValue(txBackWheel);   \n    vec4 frontWheel    = loadValue(txFrontWheel);  \n    vec4 frontWheelCP1 = loadValue(txFrontWheelCP1);\n    vec4 frontWheelCP2 = loadValue(txFrontWheelCP2);\n    vec4 backWheelCP1  = loadValue(txBackWheelCP1);\n    vec4 backWheelCP2  = loadValue(txBackWheelCP2);\n    \n    //----- Initialize -----\n    // init on frame 0 or if we are in the game over state and the space bar is pressed\n    if (iFrame == 0)\n    {\n        state = vec4(0.0);\n        state2 = vec4(0.0);\n        state3 = vec4(0.0);\n        state4 = vec4(0.0);\n        backWheel = vec4(0.0);\n        frontWheel = vec4(0.0);\n        backWheelCP1 = vec4(0.0);\n        frontWheelCP1 = vec4(0.0);    \n        backWheelCP2 = vec4(0.0);\n        frontWheelCP2 = vec4(0.0);        \n        \n        VAR_FRAME_PERCENT = 0.0;\n        VAR_QUEUED_INPUT = 0.5;\n        VAR_CAMERA_CENTER = vec2(0.0);\n        \n        VAR_CAMERA_SCALE = 2.0;\n        VAR_BACKWHEEL_ONGROUND = 0.0;\n        VAR_FRONTWHEEL_ONGROUND = 0.0;\n        VAR_GAMEOVER = 0.0;\n            \n        VAR_SIMSLOWDOWN = 1.0;\n        VAR_SPEDOMETER = 0.0;\n        VAR_LASTFUELORB = 0.0;\n        VAR_FUELREMAINING = 1.0;\n        \n        backWheel = vec4(-c_wheelDistance*0.5, c_wheelRadius, -c_wheelDistance*0.5, c_wheelRadius);\n        frontWheel = vec4( c_wheelDistance*0.5, c_wheelRadius, c_wheelDistance*0.5, c_wheelRadius);   \n\n        // initialize checkpoint data to the starting line state\n        backWheelCP1 = backWheel;\n        backWheelCP2 = backWheel;\n        \n        frontWheelCP1 = frontWheel;\n        frontWheelCP2 = frontWheel;\n        \n        VAR_FUELREMAININGCP1 = VAR_FUELREMAINING;\n        VAR_FUELREMAININGCP2 = VAR_FUELREMAINING;\n        VAR_LASTCPHIT  = 0.0;\n    }\n    \n\t// if it's game over and the user presses space bar, restore from the oldest checkpoint\n    if (VAR_GAMEOVER == 1.0 && texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1)\n    {\n        frontWheel = frontWheelCP2;\n        backWheel = backWheelCP2;\n        \n        // make sure you have at least half a tank of gas at a checkpoint. \n        // Your welcome (;\n        VAR_FUELREMAINING = max(VAR_FUELREMAININGCP2, 0.5);\n        \n\t\tVAR_GAMEOVER = 0.0;\n        \n        VAR_BACKWHEEL_ONGROUND = 0.0;\n        VAR_FRONTWHEEL_ONGROUND = 0.0;\n        \n        VAR_LASTFUELORB = 0.0;\n        \n        // make sure that we reset CP1 to CP2, so that when we hit CP1 again\n        // it doesn't fill in CP1, making it so restarting restarts us at CP1\n        // which might be an unsafe checkpoint.  This shows itself as the problem\n        // where sometimes some people reset to a checkpoint and they are flipped over\n        // with no possible way to survive\n        VAR_LASTCPHIT = floor(backWheel.x / c_checkPointDistance) * c_checkPointDistance;\n        VAR_FUELREMAININGCP1 = VAR_FUELREMAININGCP2;\n        frontWheelCP1 = frontWheelCP2;\n        backWheelCP1 = backWheelCP2;        \n    }\n    \n    // make  camera be centered on the bike\n\tVAR_CAMERA_CENTER = AsyncBikePos(backWheel, frontWheel, VAR_FRAME_PERCENT);    \n    \n    //----- Input -----\n    // input seems backwards in code, but makes sense when playing.\n    // Left = accelerate\n    // Right = break;\n    if (texture(iChannel1, vec2(KEY_RIGHT,0.25)).x > 0.1 || texture(iChannel1, vec2(KEY_UP,0.25)).x > 0.1)\n    {\n        VAR_QUEUED_INPUT = 1.0;\n    }\n    else if (texture(iChannel1, vec2(KEY_LEFT,0.25)).x > 0.1 || texture(iChannel1, vec2(KEY_DOWN,0.25)).x > 0.1)\n    {\n        VAR_QUEUED_INPUT = 0.0;\n    }\n    \n    //----- Simulate -----\n    if (VAR_GAMEOVER == 1.0)\n    {\n        VAR_SIMSLOWDOWN += iTimeDelta / c_gameOverSlowdownDuration;\n        VAR_SIMSLOWDOWN = min(VAR_SIMSLOWDOWN, 1.0);\n    }\n    else\n    {\n        VAR_SIMSLOWDOWN = 1.0;\n    }\n    \n    // slow down the simulation if it's game over\n    VAR_FRAME_PERCENT += iTimeDelta * mix(c_tickRateGameOver, c_tickRate, pow(VAR_SIMSLOWDOWN, 2.0));\n    if (VAR_FRAME_PERCENT > 1.0)\n    {\n        // reset our tick timer\n        VAR_FRAME_PERCENT = fract(VAR_FRAME_PERCENT);\n        \n        vec2 frontWheelRelativeToBackWheel = frontWheel.xy - backWheel.xy;\n        \n        // if both wheels are on the ground, and the front wheel is behind the back wheel,\n        // that means we are upside down and it's game over.\n        if (VAR_GAMEOVER != 1.0 && VAR_BACKWHEEL_ONGROUND == 1.0 && VAR_FRONTWHEEL_ONGROUND == 1.0 && dot(frontWheelRelativeToBackWheel, vec2(-1.0,0.0)) > 0.0)\n        {\n            VAR_GAMEOVER = 1.0;\n            VAR_SIMSLOWDOWN = 0.0;\n        }\n        \n        // if we are in the game over state, stop accepting input\n        if (VAR_GAMEOVER == 1.0)\n            VAR_QUEUED_INPUT = 0.5;\n        \n        // burn fuel.  Game over when out of fuel!\n        if (VAR_QUEUED_INPUT != 0.5)\n        {\n            VAR_FUELREMAINING -= 1.0 / (c_tickRate * c_fuelBurnRate);\n            \n            if (VAR_FUELREMAINING < 0.0)\n            {\n                VAR_GAMEOVER = 1.0;\n                VAR_SIMSLOWDOWN = 0.0;\n                VAR_FUELREMAINING = 0.0;\n                VAR_QUEUED_INPUT = 0.5;\n            }\n        }        \n        \n        // if not game over, and we've passed a new checkpoint, store the info\n        if (VAR_GAMEOVER == 0.0 && (backWheel.x - VAR_LASTCPHIT) > c_checkPointDistance)\n        {\n            VAR_LASTCPHIT = floor(backWheel.x / c_checkPointDistance) * c_checkPointDistance;            \n            VAR_FUELREMAININGCP2 = VAR_FUELREMAININGCP1;\n            VAR_FUELREMAININGCP1 = VAR_FUELREMAINING;\n            frontWheelCP2 = frontWheelCP1;\n            frontWheelCP1 = frontWheel;\n            backWheelCP2 = backWheelCP1;\n            backWheelCP1 = backWheel;\n        }\n        \n        // calculate our acceleration - only accelerate if the back wheel is on the ground\n        vec2 acceleration = c_gravityAcceleration +\n               ((VAR_BACKWHEEL_ONGROUND == 1.0)\n                  ? vec2(VAR_QUEUED_INPUT * 2.0 - 1.0, 0.0) * c_throttleAcceleration\n                  : vec2(0.0));\n        \n        // calculate spin amount\n        float spin = (VAR_QUEUED_INPUT * 2.0 - 1.0) * c_rotationMultiplier;\n        \n        // clear queued input\n        VAR_QUEUED_INPUT = 0.5;\n        \n        // move the simulated points\n        VerletIntegrate(backWheel, acceleration);\n        VerletIntegrate(frontWheel, acceleration);\n        \n        // apply spin as rotation of the front wheel around the back wheel\n        frontWheel.xy = RotatePointAroundPoint(frontWheel.xy, backWheel.xy, spin);\n        \n        // resolve physical constraints\n        bool backWheelOnGround = false;\n        bool frontWheelOnGround = false;\n        for (int i = 0; i < c_numSimulationSteps; ++i)\n        {\n        \tResolveGroundCollision(backWheel.xy, backWheelOnGround);\n        \tResolveGroundCollision(frontWheel.xy, frontWheelOnGround);\n            \n            ResolveDistanceConstraint(backWheel.xy, frontWheel.xy, c_wheelDistance);\n        }\n        \n        // remember whether our wheels are on the ground or not\n        VAR_BACKWHEEL_ONGROUND = backWheelOnGround ? 1.0 : 0.0;\n        VAR_FRONTWHEEL_ONGROUND = frontWheelOnGround ? 1.0 : 0.0;\n        \n        // cheat code teleportation\n        if (backWheel.x < -50.0)\n        {\n        \tbackWheel = vec4(3000.0 + -c_wheelDistance*0.5, 0.5, 3000.0 + -c_wheelDistance*0.5, 0.5);\n        \tfrontWheel = vec4(3000.0 + c_wheelDistance*0.5, 0.5, 3000.0 + c_wheelDistance*0.5, 0.5);   \n        \tVAR_CAMERA_CENTER = AsyncBikePos(backWheel, frontWheel, VAR_FRAME_PERCENT);\n            VAR_FUELREMAINING = 9999.0;\n        }\n    }\n    \n    // if the bike is close to a fuel orb, replenish fuel\n    // Do it ouside of the tick since we interpolate position so could otherwise miss it\n    // We could also do a swept shape test but this is quicker\n    vec2 asyncBikePos = AsyncBikePos(backWheel, frontWheel, VAR_FRAME_PERCENT);\n    vec2 uvFuel;\n    uvFuel.x = mod(asyncBikePos.x, c_fuelCanDistance) - c_fuelCanDistance * 0.5;\n    uvFuel.y = GroundHeightAtX(floor(asyncBikePos.x / c_fuelCanDistance) * c_fuelCanDistance + c_fuelCanDistance * 0.5, 1.0);\n    uvFuel.y += c_fuelCanRadius*1.1;\n    if ( VAR_LASTFUELORB < asyncBikePos.x && length(asyncBikePos - vec2(uvFuel.x+asyncBikePos.x, uvFuel.y)) < c_fuelCanRadius * 2.0)\n    {\n        VAR_FUELREMAINING = max(VAR_FUELREMAINING, 1.0);\n        VAR_LASTFUELORB = floor(asyncBikePos.x / c_fuelCanDistance) * c_fuelCanDistance + c_fuelCanDistance * 0.5 + c_fuelCanRadius*2.0;\n    }    \n    \n    //----- Update Spedometer -----\n    float spedTarget = 1.2 * (length(backWheel.xy - backWheel.zw) + length(frontWheel.xy - frontWheel.zw)) * 0.5;\n\tVAR_SPEDOMETER += (spedTarget - VAR_SPEDOMETER) * 3.0 * iTimeDelta;\n    \n    //----- Update Camera -----\n    // The camera is always centered on the bike\n    VAR_CAMERA_CENTER = asyncBikePos;\n    // The camera zooms out as you go faster\n    float distAboveGround = asyncBikePos.y - GroundHeightAtX(asyncBikePos.x, 1.0);\n    float targetZoom = 0.0;//clamp(distAboveGround * 4.0, 2.0, 6.0);\n    targetZoom = max(targetZoom, VAR_SPEDOMETER * 4.0 + 2.0);\n    \n    VAR_CAMERA_SCALE = mix(VAR_CAMERA_SCALE, targetZoom, iTimeDelta * mix(c_tickRateGameOver, c_tickRate, pow(VAR_SIMSLOWDOWN, 2.0)) / 25.0); \n    VAR_CAMERA_SCALE = clamp(VAR_CAMERA_SCALE, 2.0, 6.0);\n    \n    \n    //----- Save State -----\n    fragColor = vec4(0.0);\n    storeValue(txState, state, fragColor, fragCoord);\n    storeValue(txState2, state2, fragColor, fragCoord);\n    storeValue(txState3, state3, fragColor, fragCoord);\n    storeValue(txState4, state4, fragColor, fragCoord);\n    storeValue(txBackWheel , backWheel , fragColor, fragCoord);\n    storeValue(txFrontWheel, frontWheel, fragColor, fragCoord);\n    storeValue(txBackWheelCP1, backWheelCP1, fragColor, fragCoord);\n    storeValue(txBackWheelCP2, backWheelCP2, fragColor, fragCoord);\n    storeValue(txFrontWheelCP1, frontWheelCP1, fragColor, fragCoord);\n    storeValue(txFrontWheelCP2, frontWheelCP2, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}