{
    "Shader": {
        "info": {
            "date": "1634412788",
            "description": "animated mask",
            "flags": 32,
            "hasliked": 0,
            "id": "NsdSDf",
            "likes": 3,
            "name": "portalx",
            "published": 3,
            "tags": [
                "mask",
                "transform"
            ],
            "usePreview": 0,
            "username": "Sergeindamix",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}\n\n\n\nfloat sdfPlanet(vec3 p,float r){\n    return length(p)-r;\n}\n\nfloat map(vec3 p){\n    mat2 rot=Rot(iTime*.08);\n    \n    vec3 bp=p;\n    bp.xz*=rot;\n    \n    float d=sdfPlanet(bp,.4);\n    d+=texture(iChannel2,bp.xy*3.).r*.015;\n    return d;\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    d=map(p);//length(p)-10.5;\n    /*vec2 uv = vec2(atan(p.x, p.z)/6.2832, p.y/3.)+.5;\n    float disp = texture(iChannel0, uv).r;\n    \n    disp *= smoothstep(1.4, 1., abs(p.y));\n    d -= disp*.3;*/\n    \n    return d=map(p);\n}\n\nvec3 Transform(vec3 p) {\n     /*p.xy *= Rot(iTime*.4);\n     p.xz *= Rot(iTime*.2);*/\n     p.xz*=Rot(T*.2);\n     p.xy*=Rot(T*.1);\n     p.yz*=Rot(T*.15);\n     \n     return p;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = Transform(ro + rd*dO);    \t\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat stars(vec2 uv,float time){\n    vec2 fuv=fract(uv*20.);\n    vec2 fluv=floor(uv*40.);\n    float res;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 offs=vec2(x,y);\n            float r=rand(fluv+offs);\n            float l=length(fuv-offs-r);\n            float d=(.02*r*r/l);\n            d=smoothstep(.01,1.,d);\n            res+=d*((1.-sin(r*r*time*2.)));\n            res-=max(uv.y-uv.x-.5,0.);\n        }\n    }\n    return clamp(res,.01,1.);\n}\n\nvec3 lights(vec3 n, vec2 fragCoord, vec2 uv, vec3 col)\n{\n    mat2 rot=Rot(iTime*.08);\n    // Lighting\n    n.xz*=inverse(rot);\n    \n    vec3 light=vec3(.5);\n    vec3 sun_lig=normalize(vec3(-.5,.45,-.3));\n    float sun_dif=clamp(dot(n,sun_lig),0.,1.);\n    light+=sun_dif*vec3(.6,.6,.6);\n    \n    vec3 sky_lig=normalize(vec3(0.,.5*n.y+.5,0.));\n    float sky_dif=clamp(dot(n,sky_lig),0.,1.);\n    light+=sky_dif*vec3(.3,.05,.01);\n    \n    vec3 planet_lig=normalize(vec3(-.05,.03,.4));\n    float planet_dif=smoothstep(.9,1.,clamp(dot(n,planet_lig),0.,1.))*4.;\n    light+=planet_dif*vec3(.2,1.,1.);//+n*-0.1;\n    \n    col*=light;\n    vec2 pv=fragCoord/iResolution.xy;\n    vec3 curve=texture(iChannel1,pv).rgb;\n    col+=curve;\n    \n    uv-=vec2(-.58,.35);\n    vec2 bfuv=abs(uv*mat2(2.5,0,1.4,1.7))*mat2(2,sin(iTime)*.2-2.,sin(iTime)*.4-.5,1.5);\n    float bright_flare=.1/max(bfuv.x,bfuv.y)*smoothstep(-.7,1.,uv.x);\n    \n    col+=bright_flare*1.*vec3(.8,.9,.6);\n    return col;\n    }\n    \n    // The constant Pi.\nfloat pi = 3.14159;\n\n// Sphere radius, relative.\nfloat radius_rel = 0.45;\n\n// Sphere centre, relative.\nvec2 centre_rel = vec2(0.5, 0.5);\n\n// Sphere rotation speed, rpm.\nfloat rot_vel = 5.0;\n\nvec4 circle(out vec4 color, in vec2 coord)\n{\n    // Sphere radius, px.\n    float radius = radius_rel * min(iResolution.x, iResolution.y);\n    \n    // Sphere centre, px.\n    vec2 centre = centre_rel * iResolution.xy;\n    \n    // Screen coordinates relative to sphere centre.\n    vec2 coord_rel = coord - centre;\n    \n    // Relative screen coordinates normalised to [-1, 1].\n    vec2 coord_rel_norm = coord_rel / radius;\n    \n    // Relative and normalised screen coordinates squared.\n    vec2 coord_rel_norm_sq = coord_rel_norm * coord_rel_norm;\n\t\n    // Output black if screen coordinates outside sphere.\n    if (coord_rel_norm_sq.x + coord_rel_norm_sq.y > 1.0)\n    {    \n\t\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    \treturn color;\n    }\n    \n    // Ratio between parallel radius and sphere radius.\n    float radius_ratio = cos(asin(coord_rel_norm.y));\n\t\n    // Texture coordinates for these screen coordinates.\n    vec2 coord_tex = 0.5 + vec2(\n        asin(coord_rel_norm.x / radius_ratio),\n        asin(coord_rel_norm.y)) / pi;\n\t\n    // Rotate sphere according to elapsed time.\n    //coord_tex.x -= rot_vel * iTime / 30.0;\n    \n\t// Output color at these texture coordinates.\n    color = texture(iChannel0, coord_tex);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 0, -50.+fract(mix(10.,10.1, T))*100.);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    //ro= Transform(ro);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    uv = fragCoord/iResolution.xy;//\n    vec3 col = texture(iChannel2, uv).xyz;//vec3(0);\n    {\n    uv = fragCoord/iResolution.xy;\n    vec3 col1 = texture(iChannel0, uv).xyz;\n    vec3 col2 = texture(iChannel1, uv).xyz;\n    }\n    float d = RayMarch(ro, rd);\n    vec3 p = Transform(ro + rd * d);\n    vec3 n = GetNormal(p);\n    if(d<MAX_DIST) {\n        \n        \n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n\n        //6 faces texturing\n        vec3 colXZ = circle(  fragColor,  fragCoord ).rgb;//texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colYZ = circle(  fragColor,  fragCoord ).rgb;//texture(iChannel0, p.yz*.5+.5).rgb;\n        vec3 colXY = circle(  fragColor,  fragCoord ).rgb;//texture(iChannel0, p.xy*.5+.5).rgb;\n        \n        n = abs(n);\n        \n        \n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n        \n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    }else{\n        uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n        col+=stars(uv,iTime)*1.;\n    }\n    \n    col = lights(n, fragCoord, uv, col);\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float det=.001,t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n    {\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p=abs(5.-mod(p*.2,10.))-5.;\n    float ot=1000.;\n    for (int i=0; i<7; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\n        \n    }\n    ot=exp(-10.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit=0.;\n    vec3 p2=p-adv;\n    p2.xz*=rot(t*.2);\n    p2.xy*=rot(t*.1);\n    p2.yz*=rot(t*.15);\n    float b=box(p2,vec3(1.));\n    p.xy-=path(p.z).xy;\n    float s=sign(p.y);\n    p.y=-abs(p.y)-3.;\n    p.z=mod(p.z,20.)-10.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p)-1.;\n        p.xz*=rot(radians(s*-45.));\n        p.yz*=rot(radians(90.));\n    }\n    float f=-box(p,vec3(5.,5.,10.));\n    float d=min(f,b);\n    if (d==b) boxp=p2, boxhit=1.;\n    return d*.7;\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p,n,g=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<80; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.-hash(gl_FragCoord.xy+t)*.3);\n        if (d<det && boxhit<.5) break;\n        td+=max(det,abs(d));\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\n        //boxp*=.5;\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\n        vec3 colf=vec3(f*f,f,f*f*f);\n        vec3 colb=vec3(b+.1,b*b+.05,0.);\n        g+=colf/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\n        g+=colb/(10.+d*d*20.)*boxhit*.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    t=iTime*7.;\n    vec3 from=path(t);\n    adv=path(t+6.+sin(t*.1)*3.);\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\n  Video Transitions by Mark Craig (Copyright © 2021)\n\n    I originally wrote this as a \"filter\" to create transition frames\n  for videos (C program which outputted PPM files).  But eventually,\n  I figured it could be relatively easily ported to GLSL - this is the\n  result.\n\n*/\n\nint n = 50;            // number of \"frames\" in transition\nfloat sa = .05;        // smooth amount - size of smooth edges\nbool roto = true;      // if true, rotate transitions that can optionally rotate\nfloat rota = 360.0;    // amount of rotation from start to end of transition\nint rn = 1, rd = 0;    // select based on whether to start with full\n//int rn = 0, rd = -1; //   frame of source1 (only for some transitions)\n\n#define SPEEDADJ .75\n//#define NEEDMOD 1\n\n#define imod(a,b) (int((float(a)-(float(b)*floor(float(a)/float(b))))))\n\n#define iGlobalTime (iTime / SPEEDADJ)\n\n#define num_transitions 33\n\n// macros for selecting/mixing the textures\n\n#define MEM2 col = alt ? col1 : col2;\n#define MEM1 col = alt ? col2 : col1;\n#define MEM12 col = alt ? v1 * col2 + v2 * col1 : v1 * col1 + v2 * col2;\n#define MEM1S { col = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\n// Solve some incompatibilities\n\n#define atan2 atan\n#define fmod mod\n#define texture2D texture\n\n// Useful values\n\n#define _TWOPI 6.283185307\n#define M_PI 3.141592654\n\nfloat intersect(vec2, vec2, vec2, vec2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy, uv2;\nbool alt = false;\nint type, i, i2, j;\nvec3 col, col3;\nfloat v1, v2;\nfloat ye, yfe, dx, dy, cx, cy, rad, slope, theta, xc1, yc1, b, rad0, rad2;\nfloat xc2, yc2, b2, cx2, cy2, r1, vy1, vy2, dx2, dy2, ro, ri, ang, a, a1;\nfloat r, r2, l, l2, theta2, theta3, tang, ang1, ang2, angt, angs, c1, s1;\nfloat xc0, yc0;\nvec2 p1, p2, po, pd;\n\nfloat aspect = iResolution.y / iResolution.x;\nvec3 col1 = texture2D(iChannel0, uv).xyz;\nvec3 col2 = texture2D(iChannel1, uv).xyz;\n#ifdef NEEDMOD\ni = imod(int(iGlobalTime * 20.0) , n);\ntype = imod((int(iGlobalTime * 20.0) / n) , num_transitions);\nif (imod(type , 2)== 1) { alt = true; } else { alt = false; }\n#else\ni = int(iGlobalTime * 20.0) % n;\ntype = (int(iGlobalTime * 20.0) / n) % num_transitions;\nif (type % 2 == 1) { alt = true; } else { alt = false; }\n#endif\n\nswitch (type)\n\t\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tcol1 = texture2D(iChannel2, uv).xyz;\n                    col2 = texture2D(iChannel3, uv).xyz;\n\t\t\t\t\tbreak;\n                default:\n\t\t\t\t\tcol1 = texture2D(iChannel0, uv).xyz;\n                    col2 = texture2D(iChannel1, uv).xyz;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//type = 32;\n\n// some of these equations are long, so I'll forego extra spaces\n\n// was a switch, but some GPUs won't do switch\n\n\t\tif (type==0) // fade in/out\n\t\t\t{\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tMEM12\n\t\t\t}\n\t\telse if (type==1) // window down with soft edge\n\t\t\t{\n\t\t\tye=1.0-float(i)/float(n-1);\n\t\t\tyfe=ye+sa;\n\t\t\tif (uv.y<=ye) MEM1\n\t\t\telse if (uv.y>yfe) MEM2\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv2=float(uv.y-ye)/sa; if (v2>1.0) { v2=1.0; } v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==2) // increasing box\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==3) // increasing diamond\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM1\n\t\t\telse if (dy>slope*dx+cy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==4) // increasing circle\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tif (sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy))>rad) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==5) // increasing and decreasing diamonds\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM2\n\t\t\telse if (dy>slope*dx+cy) MEM2\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\t}\n\t\telse if (type==6) // four corner vanish\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>cx-dx)&&(uv.x<cx+dx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.y<cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.y>cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.x<cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.x>cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==7) // increasing circle with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+10.0*sa;\n\t\t\trad2=rad+sa;\n\t\t\tr1=sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy));\n\t\t\tif (r1>rad2) MEM1\n\t\t\telse if (r1>rad) { v1=(r1-rad)/(rad2-rad); v2=1.0-v1; MEM12 }\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==8) // increasing diamond with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+7.0*sa;\n\t\t\trad2=rad+.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx2) MEM1\n\t\t\telse if (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+b2;\n\t\t\t\tv1=(dy-vy1)/(vy2-vy1); v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==9) // increasing & decreasing diamonds w/ soft edge\n\t\t\t{\n\t\t\tfloat xc1s,yc1s,xc2s,yc2s,rads,rad2s,bs,b2s,cxs,cys,cx2s,cy2s;\n\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\t//rads=rad+7.0*sa;\n\t\t\trads=rad+.7*sa;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\t//rad2s=rad2-7.0*sa;\n\t\t\trad2s=rad2-.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\txc1s=rads*cos(theta); yc1s=rads*sin(theta);\n\t\t\txc2s=rad2s*cos(theta); yc2s=rad2s*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tbs=yc1s-slope*xc1s;\n\t\t\tb2s=yc2s-slope*xc2s;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tcys=bs; cxs=(-bs/slope);\n\t\t\tcy2s=b2s; cx2s=(-b2s/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cxs) MEM2\n\t\t\telse if (dy>slope*dx+cys) MEM2\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+bs;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy2s)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b2;\n\t\t\t\tvy2=slope*dx+b2s;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==10) // increasing box with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=(cx*float(i+rn)/float(n+rd));\n\t\t\tdy=(cy*float(i+rn)/float(n+rd));\n\t\t\tdx2=(cx*float(i+rn)/float(n+rd)+sa);\n\t\t\tdy2=(cy*float(i+rn)/float(n+rd)+sa);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse if ((uv.x>=cx-dx2)&&(uv.x<=cx+dx2)&&(uv.y>=cy-dy2)&&(uv.y<=cy+dy2))\n\t\t\t\t{\n\t\t\t\tif ((abs(uv.x-cx)>dx)&&(abs(uv.y-cy)>dy))\n\t\t\t\t\t{\n\t\t\t\t\tif (abs(uv.y-cy)-dy>abs(uv.x-cx)-dx) v1=float(abs(uv.y-cy)-dy)/(sa);\n\t\t\t\t\telse v1=float(abs(uv.x-cx)-dx)/(sa);\n\t\t\t\t\t}\n\t\t\t\telse if (abs(uv.x-cx)>dx) { v1=float(abs(uv.x-cx)-dx)/(sa); }\n\t\t\t\telse if (abs(uv.y-cy)>dy) { v1=float(abs(uv.y-cy)-dy)/(sa); }\n\t\t\t\tv2=1.0-v1; MEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==11) // rotating vanishing (gets smaller) square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = vec3(0,0,0); }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==12) // rotating vanishing (gets smaller) square with fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\tif (rad<=0.0) { rad=0.00001; }\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==13) // increasing flower with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { r=theta2/ang*(ro-ri)+ri; }\n#else\n\t\t\tif (i2%2==0) { r=theta2/ang*(ro-ri)+ri; }\n#endif\n\t\t\telse { r=(1.0-theta2/ang)*(ro-ri)+ri; }\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==14) // increasing star with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tpo.x=po.y=0.0;\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#else\n\t\t\tif (i2%2==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#endif\n\t\t\telse { p1.x=ro; p1.y=0.0; p2.x=ri*cos(ang); p2.y=ri*sin(ang); }\n\t\t\tpd.x=cos(theta2); pd.y=sin(theta2);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==15) // dissolve\n\t\t\t{\n\t\t\t// easier to use this common shadertoy random number gen rather than the one I used in original\n\t\t\tint v=int(fract(sin(dot(uv, vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n\t\telse if (type==16) // split horizontal\n\t\t\t{\n\t\t\tcy=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.y<cy-ye) MEM1\n\t\t\telse if (uv.y>=cy+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==17) // split vertical\n\t\t\t{\n\t\t\tcx=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.x<cx-ye) MEM1\n\t\t\telse if (uv.x>=cx+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==18) // slide\n\t\t\t{\n\t\t\tye=float(i+rn)/float(n+rd);\n\t\t\tuv2.x=uv.x;\n\t\t\tuv2.y=uv.y+ye;\n\t\t\tif (uv.y>=1.0-ye) MEM2\n\t\t\telse MEM1S\n\t\t\t}\n\t\telse if (type==19) // window right with soft edge\n\t\t\t{\n\t\t\tye=float(i)/float(n-1);\n\t\t\tyfe=ye+(10.0*sa);\n\t\t\tif (uv.x<=ye) MEM2\n\t\t\telse if (uv.x>yfe) MEM1\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv1=(uv.x-ye)/(10.0*sa); if (v1>1.0) { v1=1.0; } v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==20) // inset down right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==21) // inset down left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==22) // inset up right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (uv.y>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==23) // inset up left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if ((uv.y)>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==24) // pixelate\n\t\t\t{\n\t\t\t// this is simpler (not as good) as my original non-glsl code\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tif (i<n/2) { j=int(float(i)/(float(n)/2.0)*50.0); }\n\t\t\telse { j=int(float(n-i-1)/(float(n)/2.0)*50.0); }\n\t\t\tif (j<1) { j=1; }\n\t\t\tuv2.x=float(int(uv.x*iResolution.x/float(j))*j)/iResolution.x;\n\t\t\tuv2.y=float(int(uv.y*iResolution.y/float(j))*j)/iResolution.y;\n\t\t\tcol = v1 * (alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz) + v2 * (alt ? texture2D(iChannel0, uv2).xyz : texture2D(iChannel1, uv2).xyz);\n\t\t\t}\n\t\telse if (type==25) // fan in\n\t\t\t{\n\t\t\ttheta2=M_PI*float(i+rn)/float(n+rd);\n\t\t\tdy=1.0/4.0; dx=1.0/2.0; dy2=1.0*3.0/4.0;\n\t\t\txc1=M_PI/180.0*sa; cy=.5;\n\t\t\ttheta=atan2(abs(dx-uv.x),dy-uv.y);\n\t\t\ttheta3=atan2(abs(dx-uv.x),uv.y-dy2);\n\t\t\tif ((theta<theta2)||(theta3<theta2)) MEM2\n\t\t\telse if (abs(theta2-M_PI)<=.00001) MEM2\n\t\t\telse if ((theta<theta2+xc1)&&(uv.y<=cy)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse if (theta3<theta2+xc1) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==26) // fan out\n\t\t\t{\n\t\t\ttheta2=_TWOPI*float(i+rn)/float(n+rd);\n\t\t\tdx=1.0/4.0; dy=.5; dx2=1.0*3.0/4.0; cx=.5;\n\t\t\txc1=M_PI/180.0*sa;\n\t\t\ttheta=M_PI+atan2(1.0-uv.y-dy,dx-uv.x);\n\t\t\ttheta3=M_PI+atan2(1.0-uv.y-dy,uv.x-dx2);\n\t\t\tif (theta2<=M_PI)\n\t\t\t\t{\n\t\t\t\tif ((theta<theta2)&&(theta3<theta2)) MEM2\n\t\t\t\telse if ((theta<theta2+xc1)&&(uv.x<=cx)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse if ((theta3<theta2+xc1)&&(uv.x>=cx)) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse MEM1\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ((theta>theta2+xc1)&&(uv.x<=cx)) MEM1\n\t\t\t\telse if ((theta3>theta2+xc1)&&(uv.x>=cx)) MEM1\n\t\t\t\telse if (!((theta>theta2)&&(theta3>theta2))) MEM2\n\t\t\t\telse if (uv.x<=cx) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==27) // fan up\n\t\t\t{\n\t\t\ttheta2=M_PI/2.0*float(i+rn)/float(n+rd);\n\t\t\tdy=0.0; dx=1.0/2.0; xc1=M_PI/180.0*sa;\n\t\t\ttheta=atan2(abs(dx-uv.x),1.0-uv.y);\n\t\t\tif (theta<theta2) MEM2\n\t\t\telse if (theta<theta2+xc1) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 33: // roll\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w; cy=h;\n\t\t\ttheta=M_PI/2.0*((float)(i+rn)/(float)(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=.5)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=.5)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=(xc1*c1-yc1*s1);\n\t\t\t\t\tyc2=(xc1*s1+yc1*c1);\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==28) // bars\n\t\t\t{\n\t\t\tint v=int(fract(sin(dot(vec2(uv.y,0), vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n/*\n\t\t// I'm not even gonna try to convert this one\n\t\tcase 34: // slide up center\n\t\t\tmem1ts=(short *)calloc(sizeof(short),size);\n\t\t\tcx=w/2; cy=0;\n\t\t\trad=((float)(n-(i+1))/(float)(n+rd));\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tmem1ts[a]=mem1ts[a+1]=mem1ts[a+2]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (yc0=0;yc0<h;yc0+=1.0)\n\t\t\t\t{\n\t\t\t\tfor (xc0=0;xc0<w;xc0+=1.0)\n\t\t\t\t\t{\n\t\t\t\t\txc1=xc0-(float)(cx); yc1=yc0-(float)(cy);\n\t\t\t\t\txc2=rad*xc1;\n\t\t\t\t\tyc2=rad*yc1;\n\t\t\t\t\tdx=(int)(xc2)+cx; dy=(int)(yc2)+cy;\n\t\t\t\t\ta2=(dy*w+dx)*3;\n\t\t\t\t\ta=((int)(yc0)*w+(int)(xc0))*3;\n\t\t\t\t\tif ((dx>=0)&&(dx<w)&&(dy>=0)&&(dy<h)) MEM1TS\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfor (y=0;y<h;y++)\n\t\t\t\t{\n\t\t\t\tfor (x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\ta=(y*w+x)*3;\n\t\t\t\t\tif (mem1ts[a]>=0) MEM1TS1\n\t\t\t\t\telse MEM2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfree(mem1ts);\n\t\t\tbreak;\n*/\n\t\telse if (type==29) // diagonal down right\n\t\t\t{\n\t\t\trad=sqrt(2.0+2.0)*(1.0-(float(i+rn)/float(n+rd)));\n\t\t\tslope=-1.0/1.0;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1-sa;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(uv.y);\n\t\t\tdx=abs(1.0-uv.x);\n\t\t\t//if (dx>cx-sa) MEM2\n\t\t\tif (dy>slope*dx+cy+sa) MEM2\n\t\t\telse if (dy>slope*dx+cy) { v2=(dy-(slope*dx+cy))/(sa); v1=1.0-v2; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==30) // diagonal cross out\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope); vy1=sa;\n\t\t\tdy=(uv.y-.5);\n\t\t\tdx=(uv.x-.5);\n\t\t\tif (!(((dy>slope*dx+cy)||(dy<slope*dx-cy))&&((dy>(-slope)*dx+cy)||(dy<(-slope)*dx-cy)))) MEM2\n\t\t\telse if ((sa!=0.0)&&(!(((dy>slope*dx+cy+vy1)||(dy<slope*dx-cy-vy1))&&\n\t\t\t\t((dy>(-slope)*dx+cy+vy1)||(dy<(-slope)*dx-cy-vy1)))))\n\t\t\t\t{\n\t\t\t\tif ((dx>=0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx>=0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==31) // increasing gear with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tro=sqrt(cx*cx+cy*cy)/.9*float(i+rn)/float(n+rd);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tri=ro*.9;\n\t\t\tpo.x=po.y=0.0;\n\t\t\tangt=5.0;\n\t\t\tangs=2.5;\n\t\t\ttang=(angt+angs)*2.0;\n\t\t\tang=tang*M_PI/180.0;\n\t\t\tyc1=uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1);\n\t\t\ttheta2=fmod(theta+M_PI+vy1,ang);\n\t\t\tif (theta2<=angt*M_PI/180.0) { r1=r2=ri; ang2=angt; ang1=theta2; }\n\t\t\telse if (theta2<=(angt+angs)*M_PI/180.0) { r1=ri; r2=ro; ang2=angs; ang1=theta2-angt*M_PI/180.0; }\n\t\t\telse if (theta2<=(angt+angs+angt)*M_PI/180.0) { r1=r2=ro; ang2=angt; ang1=theta2-(angt+angs)*M_PI/180.0; }\n\t\t\telse { r1=ro; r2=ri; ang2=angs; ang1=theta2-(angt+angs+angt)*M_PI/180.0; }\n\t\t\tang2*=(M_PI/180.0);\n\t\t\tp1.x=r1; p1.y=0.0; p2.x=r2*cos(ang2); p2.y=r2*sin(ang2);\n\t\t\tpd.x=cos(ang1); pd.y=sin(ang1);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==32) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\txc0=uv.x; yc0=uv.y;\n\t\t\txc1=xc0-cx; yc1=yc0-cy;\n\t\t\txc2=rad*(xc1*c1-yc1*s1);\n\t\t\tyc2=rad*(xc1*s1+yc1*c1);\n\t\t\tuv2.x=xc2*aspect+cx; uv2.y=yc2+cy;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=1.0)&&(uv2.y>=0.0)&&(uv2.y<=1.0)) { col3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\t//col=col3;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\nfragColor = vec4(col, 1.0);\n}\n\nfloat intersect(vec2 origin, vec2 direction, vec2 point1, vec2 point2)\n{\nvec2 v1, v2, v3;\nfloat dot, t1, t2;\n\nv1.x = origin.x - point1.x;\nv1.y = origin.y - point1.y;\nv2.x = point2.x - point1.x;\nv2.y = point2.y - point1.y;\nv3.x = -direction.y;\nv3.y = direction.x;\ndot = v2.x * v3.x + v2.y * v3.y;\nif (abs(dot) < 0.000001) return(-1000.0);\nt1 = (v2.x * v1.y - v2.y * v1.x) / dot;\nt2 = (v1.x * v3.x + v1.y * v3.y) / dot;\nif ((t1 >= 0.0) && (t2 >= 0.0) && (t2 <= 1.0)) return(t1);\nreturn(-1000.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// The Universe Within - by Martijn Steinrucken aka BigWings 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// After listening to an interview with Michael Pollan on the Joe Rogan\n// podcast I got interested in mystic experiences that people seem to\n// have when using certain psycoactive substances. \n//\n// For best results, watch fullscreen, with music, in a dark room.\n// \n// I had an unused 'blockchain effect' lying around and used it as\n// a base for this effect. Uncomment the SIMPLE define to see where\n// this came from.\n// \n// Use the mouse to get some 3d parallax.\n\n// Music - Terrence McKenna Mashup - Jason Burruss Remixes\n// https://soundcloud.com/jason-burruss-remixes/terrence-mckenna-mashup\n//\n// YouTube video of this effect:\n// https://youtu.be/GAhu4ngQa48\n//\n// YouTube Tutorial for this effect:\n// https://youtu.be/3CycKKJiwis\n\n#define t iTime\n#define re iResolution.xy\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define colorRange 24.0\nvec4 fragColor;\n\nfloat Band(float t, float start, float end, float blur) {\n\n\t\t\t\tfloat step1 = smoothstep(start - blur, start + blur, t);\n\t\t\t\tfloat step2 = smoothstep(end + blur, end - blur, t);\n\n\t\t\t\treturn step1 * step2;//overlap edges\n\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n\t\t\t\tfloat band1 = Band(uv.x, left, right, blur);\n\t\t\t\tfloat band2 = Band(uv.y, bottom, top, blur);\n\n\t\t\t\treturn band1 * band2;//overlap horizontal and vertical bands\n\n}\nvoid getTriangle(vec2 uv, vec2 t0, vec2 t1, vec2 t2 ) {\n\t\t\t\t//Colors\n\t\t\t\tvec3 fgColor = vec3(0.741, 0.635, 0.471);\n\t\t\t\tvec3 bgColor = vec3(0.192, 0.329, 0.439);\n\n\t\t\t\t//Triangle barycentric coordinates defined on screen space\n\t\t\t\t/*vec2 t0 = vec2(0.5, 0.375);//base izq\n\t\t\t\tvec2 t1 = vec2(0.75, 0.25);//base der\n\t\t\t\tvec2 t2 = vec2(0.75, 0.50);//punta*/\n\t\t\t\tvec2 tCentroid = (t0 + t1 + t2) / 3.0;\n\t\t\t\t//Compute UV coordinates\n\t\t\t\t\n\n\t\t\t\tvec2 v0 = t2 - t0;\n\t\t\t\tvec2 v1 = t1 - t0;\n\t\t\t\tvec2 v2 = uv - t0;\n\n\t\t\t\t//Compute barycentric coordinates \n\t\t\t\tfloat dot00 = dot(v0, v0);\n\t\t\t\tfloat dot01 = dot(v0, v1);\n\t\t\t\tfloat dot02 = dot(v0, v2);\n\t\t\t\tfloat dot11 = dot(v1, v1);\n\t\t\t\tfloat dot12 = dot(v1, v2);\n\n\t\t\t\tfloat invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\t\t\t\tfloat baryX = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\t\t\t\tfloat baryY = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n\t\t\t\tif ((baryX >= 0.0) && (baryY >= 0.0) && (baryX + baryY <= 1.0)) {\n\t\t\t\t\tfragColor = vec4(fgColor, 1.0);\n\t\t\t\t}\n\t\t\t\t//else discard;\n\t\t\t\t/*{\n\t\t\t\t\tfragColor = vec4(bgColor, 1.0);\n\t\t\t\t}*/\n\t\t\t\t\n}\n\nfloat triangle( in vec2 uv, in vec2 n ) {\n    vec2 uuv = vec2(abs(uv.x), uv.y);\n    return max(-uv.y, dot(n, uuv));\n}\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat CircleShape(vec2 pos, float radius){    \n    \n    return step(radius, length(pos));\n}\n\nfloat polygon(vec2 pos, float rad, float sides){\n    pos = pos * 2. - 1.;\n    float angle = atan(pos.x, pos.y);\n    float slice = PI * 2.0/ sides;\n    \n    return step(rad, cos(floor(0.5 + angle/ slice) * slice - angle) * length(pos));\n\n}\n\n// Created by beautypi - beautypi/2012\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat length2( vec2 p )\n{\n    vec2 q = p*p*p*p;\n    return pow( q.x + q.y, 1.0/4.0 );\n}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An example showing the use of iChannelData[] in order to synchronize an aimation\n\n#define BPM 140.0\n#define STROBEPREVENTION\n#define PI_2 6.28\nfloat rand (vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noisex(vec2 n)\n{\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat getPoly (vec2 uv, float gonSide, float gonAngle, float thickness, float percent)\n{\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gonSlice = 6.28319 / gonSide;\n    float gonSize = percent;\n    float gonWidth = thickness;\n  \t\n    vec2 deltaUV = vec2(0.5) - uv;\n    float deltaAngle = atan(deltaUV.x,deltaUV.y) + (gonAngle / PI);\n    float dist = cos(floor(.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(deltaUV.xy) * 2.0;\n    return min(smoothstep(gonSize - gonWidth - 0.001, gonSize - gonWidth, dist), smoothstep(gonSize + gonWidth, gonSize + gonWidth - 0.001, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    //p*=rot(t);\n\n    float r = length( p );\n    float a = atan( p.y, p.x );\n\n    float dd = 0.2*sin(4.0*iTime);\n    float ss = 1.0 + clamp(1.0-r,0.0,1.0)*dd;\n\n    r *= ss;\n\n    vec3 col = vec3( 0.0, 0.3, 0.4 );\n\n    float f = fbm( 5.0*p );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n\n    col = mix( col, vec3(0.9,0.6,0.2), 1.0-smoothstep(0.2,0.6,r) );\n\n    a += 0.05*fbm( 20.0*p );\n\n    f = smoothstep( 0.3, 1.0, fbm( vec2(20.0*a,6.0*r) ) );\n    col = mix( col, vec3(1.0,1.0,1.0), f );\n\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*a,10.0*r) ) );\n    col *= 1.0-0.5*f;\n\n    col *= 1.0-0.25*smoothstep( 0.6,0.8,r );\n\n    f = 1.0-smoothstep( 0.0, 0.6, length2( mat2(0.6,0.8,-0.8,0.6)*(p-vec2(0.3,0.5) )*vec2(1.0,2.0)) );\n\n    col += vec3(1.0,0.9,0.9)*f*0.985;\n\n    col *= vec3(0.8+0.2*cos(r*a));\n\n    f = 1.0-smoothstep( 0.2, 0.25, r );\n    col = mix( col, vec3(0.0), f );\n\n    f = smoothstep( 0.79, 0.82, r );\n    col = mix( col, vec3(1.0), f );\n\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    /////////////\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    col *= mix(col, baseCol*m, 0.10);\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    //pulse star\n\n    vec3 star;\n    float l,z=t;\n    for(int i=0;i<3;i++) {\n        vec2 uv,p=fragCoord.xy/r;\n        p-=.5;\n        //p.x*=r.x/r.y;\n        uv=p;\n\t\tz+=.07;\n        l=length(p);\n        uv+=p*abs(sin(l*7.-z*1.35));\n        uv *= smoothstep(0.0005, 0.0006, l);\n        //uv+= vec2(0.0,0.4);\n        star[i]=0.05/length(uv);\n        \n        }\n        \n    //tube    \n    float x=uv.x;\n    float y=uv.y;\n    //y=x;//vertical\n    float d= smoothstep(.1,.2,length(y));\n    x=y;//horiz\n    float d2= fract(smoothstep(.1,.2,length(x+y)));//wide + or *\n    d2+= mix(d2,fract(smoothstep(.1,.2,length(x+y))),1.0);//wide + or *\n    \n    //cones\n    //move position\n    p = vec2(.0, .0);\n\t\t\t\t\n    x += .0;//move horizontal\n    y += .0;//move vertical\n\n    m = -(x - .5)*(x + .5);//distortion parabola\n    y = uv.y - m;//distortion x\n    //circle mask\n    float mask = smoothstep(.03,.003,length(uv) - .4);//esfera Circle(uv, p, .5, .01);\n    //mask += max(mask,  p.y-0.35);//cortar altura del circulo\n    col += vec3(1.3, 0.75, 0.5)*mask;\n    mask += smoothstep(.02,.01,length(uv) - .2);\n    //cut another circle or add with symbol + or overlap multipling *\n    //mask -= Circle(uv, p - vec2(.0, .0), .49, .01);\n    mask += length(uv) + .1;//esferaCircle(uv, vec2(.0, .0), .3, .01);\n    //col += vec3(0., 0., 1.)*mask;\n    //cut another circle or add with symbol + or overlap multipling *\n    mask -= CircleShape(uv,  .1);\n    mask += length(uv) - .1;//esferaCircle(uv, vec2(.0, .0), .1, .01);\n    //col += vec3(0.7, 0.8, 1.0)*mask;\n    mask -= CircleShape(uv,  .1);\n    p = uv - vec2(.0, .125);\n    //getTriangle(p, vec2(0.5, 0.375), vec2(0.75, 0.25), vec2(0.75, 0.50));\n    mask -= Rect(uv, .5, .9, -.08, .09, .001);\n    //getTriangle(p, vec2(0.5, 0.375), vec2(0.25, 0.25), vec2(0.25, 0.5));\n    mask -= Rect(uv, -.9, -.5, -.08, .09, .001);\n    mask += smoothstep(.001,.001,triangle( abs(st*rot)-vec2(.0,0.22), vec2(.008,.006) ));\n\t\t\t\n\n    //set color of circle and background\n    if(d<.3) c = 0.0; else c= 1.0;\n\n    //colorize circle\n    //col /= vec3(1., 1., 1.)*mask;\n    \n    \n    //polygon\n    uv*=6.0;\n    float polygon = polygon(rot* -uv+vec2(.5,.5), .6,3.0) * polygon(rot* uv+vec2(.5,.5), .6,3.0);\n    \n    col += polygon*star;\n    \n    //bpm\n    uv*=.2;\n    t = fract(iTime*(BPM/60.));\n    float h = fract( 0.25 + 0.5*iChannelTime[0]*BPM/60.0 );\n\tf = 1.0-smoothstep( 0.0, 1.0, h );\n\tf *= smoothstep( 4.5, 4.51, iChannelTime[0] );\n\tr = length(uv-0.0) + 0.2*cos(25.0*h)*exp(-4.0*h);\n\tf = pow(f,0.5)*(1.0-smoothstep( 0.5, 0.55, r) );\n\tfloat rn = r/0.55;\n\tcol = mix( col, vec3(0.4+1.5*rn,0.1+rn*rn,0.50)*rn, f );\n\t\n\n\tcol = mix( col, vec3(1.0), smoothstep(  0.0,  3.0, iChannelTime[0] )*exp( -1.00*max(0.0,iChannelTime[0]- 2.5)) );\n\tcol = mix( col, vec3(1.0), smoothstep( 16.0, 18.0, iChannelTime[0] )*exp( -0.75*max(0.0,iChannelTime[0]-19.0)) );\n\t\n    ////drums\n    float beattime = 1.0-fract(iTime/60.*BPM)/(BPM/60.0);\n    float claptime = 1.0-fract((iTime-0.5)/120.*BPM)/(BPM/120.0);\n    float hatintime = 1.0-fract((iTime-0.25)/60.*BPM)/(BPM/120.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv /= fract(uv);\n    float kick = smoothstep(0.333,0.33,uv.x);\n    float hat = smoothstep(0.66,0.662,uv.x);\n    float clap = 1.0-max(kick,hat);\n    \n    col += vec3(kick*beattime,\n                    hat*hatintime,\n                    clap*claptime);\n    #ifdef STROBEPREVENTION\n    // desaturate to possibly reduce strobing?\n    //col = ( col * 0.3 ) + 0.7;\n    #endif\n    \n    ////bpmstuff\n    vec2 pixelSz = vec2(1.0) / iResolution.xy;\n    \n\tuv = fragCoord / iResolution.xy;\n    vec4 final = texture(iChannel0, uv);\n    \n    const float stepsize = 0.1;\n    const float stepmult = stepsize * 0.5;\n    float samplescale = pixelSz.x * 64.0;\n    \n    for (float i=0.0; i<= 1.0; i+= stepsize)\n    {\n        float bias = i - 0.5;\n        float samplerand = rand(uv) - 0.5;\n        vec2 sampleuv = vec2(bias * samplescale + samplerand * samplescale, 0.0);\n        \n        final += texture(iChannel0, uv + sampleuv) * stepmult * (1.0 - abs(samplerand));\n        final += texture(iChannel0, uv - sampleuv) * stepmult * (1.0 - abs(samplerand));\n    }\n    \n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    final.a = 1.0;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvOrig = fragCoord / iResolution.xy;\n    vec2 ctDelta = uvOrig - vec2(0.5);\n    float ctLen = length(ctDelta);\n    vec2 ctDir = normalize(ctDelta);\n    \n    // Aspect ratio corrected uv\n    uv = uvOrig;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv += 0.5;\n    \n    // Beat?\n    //const float BPM = 120.0;\n    const float BPS = 60.0 / BPM;\n    const float BPS2 = BPS * 2.0;\n    float beatDelta = mod(iTime, BPS) / BPS;\n    float beatDelta2 = mod(iTime, BPS2) / BPS2;\n    float beatIncr = 3.0 + mod(floor(iTime / BPS), 4.0);\n    float beatIncr2 = 3.0 + mod(floor(iTime / BPS2), 4.0);\n    \n    float beatTime = iTime / BPS;\n    float powerBeat = pow(1.0 - beatDelta, 1.4);\n    \n    // Flashy background\n    float bgr = mod(beatIncr, 6.0) / 6.0;\n    vec3 flash = vec3(sin(iTime * 2.0 + 60.0) * 0.5 + 0.5, cos(iTime * 4.0 + 0.5) * 0.5 + 0.5, abs(sin(iTime))) * 0.4 * pow(1.0 - beatDelta, 3.0);\n    final.xyz = flash * (uv.y + sin(uv.x * 10.0) * 0.05);\n    // Rad BG\n    float radRand = rand(vec2(floor(uv.x * 8.0) / 8.0, beatIncr));\n    vec2 raduv = vec2(uv.x, min(uv.y + radRand * 0.5, 1.0));\n    \n    float radIntensity = pow(min(powerBeat + radRand * 0.3, 1.0), 2.0) * 0.52 + abs(sin(beatTime * 10.0 + radRand * 42.0)) * 0.1;\n    float radDelta = 1.0 - abs(radIntensity - raduv.y) * 2.0;\n    float radPercent = max(round(sin(raduv.y * 128.0) * pow(radDelta, 2.0)) * pow(max(radDelta, 0.0), 6.0), smoothstep(radIntensity, radIntensity - 0.001, raduv.y));\n    // radPercent *= pow(radDelta, 3.0);\n    \n    vec3 radColour = mix(vec3(0.0), vec3(0.9, 0.55, 0.15) * (1.0 + radRand * 0.1), radPercent);\n    final.xyz += radColour * (1.0 + noise(uv * 5.0 + iTime) * 0.4 + noise(uv * 100.0 + iTime) * 0.9);\n    \n    // BG with stars?\n    float ctAngle = atan(ctDir.y, ctDir.x) / PI_2 + 0.5;\n    float starSamp = smoothstep(0.98, 1.0, noise(vec2(ctAngle * 2.0, ctLen * 0.05 - beatTime * 0.05) * 100.0));\n    final.xyz += starSamp;\n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    // rotato potato\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gon1Side = beatIncr; // sides\n    float gon1Angle = beatDelta * 4.0 - 2.0;\n    float gon2Angle = beatDelta2 * 4.0 - 2.0;\n    float gon1Width = 0.01 + pow(beatDelta, 3.0) * 0.1;\n    \n    float t1 = (beatDelta + abs(sin(beatDelta * 5.0)) * 0.2) / 1.2;\n    float gon1Size = pow(1.0 - pow(1.0 - t1, 1.0), 3.0) * 2.0;\n    float gon2Size = pow(1.0 - pow(1.0 - beatDelta2, 0.5), 2.5) * 2.0;\n    \n    float gon1 = getPoly(uv, gon1Side, gon1Angle, gon1Width, gon1Size);\n    float gon2 = getPoly(uv, gon1Side + 1.0, gon2Angle, 0.01, gon2Size);\n    \n    final.xyz = mix(final.xyz, vec3(1.0), gon1);\n    final.xyz += vec3(fract(0.5 - bgr), bgr, 0.5) * 0.25 * gon2; //mix(final.xyz, vec3(fract(0.5 - bgr), bgr, 0.5), gon2 * 0.2);\n    for (float i=0.1; i<=1.0; i+=0.1)\n    {\n        float disp = 1.0 - pow(1.0 - i, 3.0);\n        \n        float gon3Size = pow(1.0 - pow(1.0 - t1 - 0.1 * disp, 1.0), 3.0) * 2.0;\n        float gon3 = getPoly(uv, gon1Side, gon1Angle, gon1Width * 0.3 * i, gon3Size - 0.2);\n    \tfinal.xyz += vec3(sin(iTime * 2.0 + 60.0), tan(iTime * 4.0 + 0.5), abs(sin(iTime))) * gon3 * disp;\n        // final.xyz = mix(final.xyz, vec3(sin(iTime * 2.0 + 60.0), tan(iTime * 4.0 + 0.5), abs(sin(iTime))), gon3);\n    }\n    \n    // Output to screen\n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    final.a = 1.0;\n    \n    \n    col += final.xyz;\n    \n    fragColor = vec4(col-polygon,final.a);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Fork of \"The Cave\" by BoyC. https://shadertoy.com/view/MsX3RH\n// 2018-12-30 22:01:35\n\n// constants for the camera tunnel\nconst vec2 cama=vec2(-2.6943,3.0483);\nconst vec2 camb=vec2(0.2516,0.1749);\nconst vec2 camc=vec2(-3.7902,2.4478);\nconst vec2 camd=vec2(0.0865,-0.1664);\n\nconst vec2 lighta=vec2(1.4301,4.0985);\nconst vec2 lightb=vec2(-0.1276,0.2347);\nconst vec2 lightc=vec2(-2.2655,1.5066);\nconst vec2 lightd=vec2(-0.1284,0.0731);\n\n// calculates the position of a single tunnel\nvec2 Position(float z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn sin(z*a)*b+cos(z*c)*d;\n}\n\n// calculates 3D positon of a tunnel for a given time\nvec3 Position3D(float time, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn vec3(Position(time,a,b,c,d),time);\n}\n\n// 2d distance field for a slice of a single tunnel\nfloat Distance(vec3 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, float r)\n{\n\tvec2 pos=Position(p.z,a,b,c,d);\t\n\tfloat radius=max(5.0,r+sin(p.z*e.x)*e.y)/10000.0;\n\treturn radius/dot(p.xy-pos,p.xy-pos);\n}\n\n// 2d distance field for a slice of the tunnel network\nfloat Dist2D(vec3 pos)\n{\n\tfloat d=0.0;\n\t\n\td+=Distance(pos,cama,camb,camc,camd,vec2(2.1913,15.4634),70.0000);\n\td+=Distance(pos,lighta,lightb,lightc,lightd,vec2(0.3814,12.7206),17.0590);\n\td+=Distance(pos,vec2(2.7377,-1.2462),vec2(-0.1914,-0.2339),vec2(-1.3698,-0.6855),vec2(0.1049,-0.1347),vec2(-1.1157,13.6200),27.3718);\n\td+=Distance(pos,vec2(-2.3815,0.2382),vec2(-0.1528,-0.1475),vec2(0.9996,-2.1459),vec2(-0.0566,-0.0854),vec2(0.3287,12.1713),21.8130);\n\td+=Distance(pos,vec2(-2.7424,4.8901),vec2(-0.1257,0.2561),vec2(-0.4138,2.6706),vec2(-0.1355,0.1648),vec2(2.8162,14.8847),32.2235);\n\td+=Distance(pos,vec2(-2.2158,4.5260),vec2(0.2834,0.2319),vec2(4.2578,-2.5997),vec2(-0.0391,-0.2070),vec2(2.2086,13.0546),30.9920);\n\td+=Distance(pos,vec2(0.9824,4.4131),vec2(0.2281,-0.2955),vec2(-0.6033,0.4780),vec2(-0.1544,0.1360),vec2(3.2020,12.2138),29.1169);\n\td+=Distance(pos,vec2(1.2733,-2.4752),vec2(-0.2821,-0.1180),vec2(3.4862,-0.7046),vec2(0.0224,0.2024),vec2(-2.2714,9.7317),6.3008);\n\td+=Distance(pos,vec2(2.6860,2.3608),vec2(-0.1486,0.2376),vec2(2.0568,1.5440),vec2(0.0367,0.1594),vec2(-2.0396,10.2225),25.5348);\n\td+=Distance(pos,vec2(0.5009,0.9612),vec2(0.1818,-0.1669),vec2(0.0698,-2.0880),vec2(0.1424,0.1063),vec2(1.7980,11.2733),35.7880);\n\t\n\treturn d;\n}\n\nvec3 nmap(vec2 t, sampler2D tx, float str)\n{\n\tfloat d=1.0/1024.0;\n\n\tfloat xy=texture(tx,t).x;\n\tfloat x2=texture(tx,t+vec2(d,0)).x;\n\tfloat y2=texture(tx,t+vec2(0,d)).x;\n\t\n\tfloat s=(1.0-str)*1.2;\n\ts*=s;\n\ts*=s;\n\t\n\treturn normalize(vec3(x2-xy,y2-xy,s/8.0));///2.0+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime/3.0+291.0;//+43.63/3.0;\n\n\t//calculate camera by looking ahead in the tunnel\n\t\n\tvec2 p1=Position(time+0.05,cama,camb,camc,camd); //position ahead\n\tvec3 Pos=Position3D(time,cama,camb,camc,camd); //current position\n\tvec3 oPos=Pos;\n\t\n\tvec3 CamDir=normalize(vec3(p1.x-Pos.x,-p1.y+Pos.y,0.1));\n\tvec3 CamRight=normalize(cross(CamDir,vec3(0,1,0)));\n\tvec3 CamUp=normalize(cross(CamRight,CamDir));\t\n\tmat3 cam=mat3(CamRight,CamUp,CamDir);\n\n\t//ray calculation\t\n\tvec2 uv=2.0*fragCoord.xy/iResolution.xy-1.0;\n\tfloat aspect=iResolution.x/iResolution.y;\n\t\n\tvec3 Dir=normalize(vec3(uv*vec2(aspect,1.0),1.0))*cam;\n\t\n\t//raymarching\n\tfloat fade=0.0;\n\t\n\tconst float numit=75.0; //raymarch precision\n\tconst float threshold=1.20; //defines the thickness of tunnels\n\tconst float scale=1.5; //tunnel z depth\n\t\n\tvec3 Posm1=Pos;\n\t\n\t//calculate first hit\n\tfor (float x=0.0; x<numit; x++)\n\t{\n\t\tif (Dist2D(Pos)<threshold)\n\t\t{\n\t\t\tfade=1.0-x/numit;\n\t\t\tbreak;\n\t\t}\n\t\tPosm1=Pos;\n\t\tPos+=Dir/numit*scale;//*(1.0+x/numit);\n\t}\n\n\t//track back to get better resolution\n\tfor (int x=0; x<6; x++)\n\t{\n\t\tvec3 p2=(Posm1+Pos)/2.0;\n\t\tif (Dist2D(p2)<threshold) \n\t\t\tPos=p2;\n\t\telse\n\t\t\tPosm1=p2;\n\t}\t\n\n\t//lighting\t\n\tvec3 n=normalize(vec3(Dist2D(Pos+vec3(0.01,0,0))-Dist2D(Pos+vec3(-0.01,0,0)),\n\t\t\t\t\t\t  Dist2D(Pos+vec3(0,0.01,0))-Dist2D(Pos+vec3(0,-0.01,0)),\n\t\t\t\t\t\t  Dist2D(Pos+vec3(0,0,0.01))-Dist2D(Pos+vec3(0,0,-0.01))));\n\t\n\t//triplanar blend vector\n\tvec3 tpn=normalize(max(vec3(0.0),(abs(n.xyz)-vec3(0.2))*7.0))*0.5;\n\t\n\t//position of the light - uncomment the second line to get a more interesting path\n\tvec3 lp=Position3D(time+0.5,cama,camb,camc,camd); //current light position\n\t//lp=Position3D(time+0.3,lighta,lightb,lightc,lightd);\n\t\n\tvec3 ld=lp-Pos;\t//light direction\n\tfloat lv=1.0;\n\t\n\tconst float ShadowIT=15.0; //shadow precision\n\t\n\t//shadow calc\n\tfor (float x=1.0; x<ShadowIT; x++)\n\t\tif (Dist2D(Pos+ld*(x/ShadowIT))<threshold) \n\t\t{\n\t\t\tlv=0.0;\n\t\t\tbreak;\n\t\t}\n\n\tvec3 tuv=Pos*vec3(3.0,3.0,1.5);\t//texture coordinates\n\t\n\t//normal mapping\n\tfloat nms=0.19;\n\tvec3 nmx=nmap(tuv.yz,iChannel0,nms)+nmap(-tuv.yz,iChannel0,nms);\n\tvec3 nmy=nmap(tuv.xz,iChannel1,nms)+nmap(-tuv.xz,iChannel1,nms);\n\tvec3 nmz=nmap(tuv.xy,iChannel2,nms)+nmap(-tuv.xy,iChannel2,nms);\n\t\n\tvec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);\n\t\n\tfloat dd;\n\t//normalmapped version:\n\tdd=max(0.0,dot(nn,normalize(ld*mat3(vec3(1,0,0),vec3(0,0,1),n))));\n\t//standard version:\n\t//dd=max(0.0,dot(n,normalize(ld)));\n\t\n\tvec4 diff=vec4(dd*1.2*lv)+vec4(0.2);\n\n\t//wisp\n\tfloat w=pow(dot(normalize(Pos-oPos),normalize(lp-oPos)),5000.0);\n\tif (length(Pos-oPos)<length(lp-oPos)) w=0.0;\t\n\n\t//texturing\n\t//double sampling to fix seams on texture edges\n    \n    float ctx=max(sin(Pos.x*200.),cos(Pos.y*200.));\n     ctx=min( ctx,sin(Pos.z*200.));\n    ctx=ctx*2.2;\n    \n    //tex stripes\n   float zStripes=min(atan(sin(Pos.z*5.)*55.),sin(Pos.z*111.));\n   zStripes*=10.;\n    \n    //tex dots\n    float ctxDots=sin(Pos.x*130.)*sin(Pos.y*130.)*sin(Pos.z*130.);\n    \tctxDots=ctxDots*ctxDots*ctxDots*10.;\n    \n   //mux   \n   ctx =max(ctx, zStripes*(sin(1.6+iMouse.x/100.)));\n\n    if (iMouse.xy==vec2(0)) //startup\n    {\n       ctx =mix(ctx,ctxDots,sin(iTime/2.));\n    }\n    else\n       ctx =mix(ctx,ctxDots,iMouse.y/iResolution.y);  \n    \n    \n    vec4 tx=vec4(\n        ctx*sin(Pos.x*10.) ,//+atan(sin(Pos.x*55.)*55.),\n        ctx*sin(Pos.y*10.)  ,\n       ctx*sin(Pos.z*10.) //+atan(sin(Pos.y*55.)*55.)\n        , 1.);\n\tvec4 col=tx*tpn.x;\n\t\n\tfragColor = col*min(1.0,fade*10.0)+w; //*diff\n  \n     \n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}