{
    "Shader": {
        "info": {
            "date": "1608471446",
            "description": "An animation of the parameter a in the generalized Newton's method.\n\n - https://darkeclipz.blogspot.com/2020/12/newton-fractals.html",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcyRH",
            "likes": 4,
            "name": "Generalized Newton's Method",
            "published": 3,
            "tags": [
                "fractal",
                "newton"
            ],
            "usePreview": 0,
            "username": "darkeclipz",
            "viewed": 834
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define C fragCoord\n#define T iTime\n#define M iMouse\n\nfloat pixelSize = 0.;\nfloat pi = 3.14159;\nfloat e = 2.718281828459;\n\nvec3 magma(float t) {\n\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    t *= 2.;\n    if(t >= 1.)\n    {\n        t = 2. - t;\n    }\n    \n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 c0 = vec3(0,2,5)/255.;\nvec3 c1 = vec3(8,45,58)/255.;\nvec3 c2 = vec3(38,116,145)/255.;\nvec3 c3 = vec3(167,184,181)/260.;\nvec3 c4 = vec3(38,116,145)/255.;\n\nvec3 cmap(float t) {\n    vec3 col = vec3(0);\n    col = mix( c0,  c1, smoothstep(0. , .2, t));\n    col = mix( col, c2, smoothstep(.2, .4 , t));\n    col = mix( col, c3, smoothstep(.4 , .6, t));\n    col = mix( col, c4, smoothstep(.6,  .8, t));\n    col = mix( col, c0, smoothstep(.8, 1.,  t));\n    return col;\n}\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); \n                               return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 map(vec2 z, vec2 c, float n) {\n    float b = 4., i=0.;\n    float ii = n;\n    \n    // x = x - f(x)/f'(x)\n \n    \n    //c = (2.*iMouse.xy-R) / R.y;\n    //z = vec2(1,0);\n    \n    vec2 z_prev = z;\n    for(i=0.; i < n; i++) {\n        \n        \n        z_prev = z;\n        \n        float p = 3.;\n        float t = iTime / 40.;\n        vec2 a = vec2(cos(13.*t), sin(15.*t));\n        float r = 2.*(cos(iTime)*.5 + .5) + .3;\n        \n        // z = z - cdiv(cpow(z, 2.0) + vec2(1.0, 0), cmul(z, vec2(2.0,0)));\n        // z = z - cdiv(sin(z) - vec2(1.0,0), cos(z));\n        \n        z = z - cmul(a, cdiv(cpow(z, 3.0) - vec2(1,0), cmul(vec2(3.,0), cpow(z, 2.0))));\n        \n        \n        // z = z - r * cdiv(cpow(z, p) - vec2(1.0, 0), cmul(cpow(z, p-1.0), vec2(p, 0))) + c;\n        // z = z - cdiv(cpow(z - vec2(1.0, 0), 3.0) , cmul(cpow(z, 2.0), vec2(3.,0))) + c;\n        \n        // z = z - cdiv(cpow(sin(z), 2.0) - vec2(1.0,0), cmul(cmul(sin(z), cos(z)), vec2(2.0,0)));\n        // z = z - cdiv(sin(z) - vec2(1.0, 0), cos(z));\n        // z = z - cdiv(cpow(z, 3.) - vec2(1.0, 0), cmul(cpow(z,2.), vec2(3.0,0))) + c;\n        // z = z - cmul(a, cdiv(cpow(z, p) - vec2(-1,0), cmul(vec2(p,0), cpow(z, p-1.))));\n        \n        if( abs(length(z-z_prev)) < 0.0001){\n            ii = min(ii, i);\n        }\n        \n        if(dot(z,z) > 8.) {\n            //ii = min(i, ii);\n            //break;\n        }\n   \n\t}   \n    return vec3(z, ii / n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*C-R)/R.y;\n    uv *= 1.2;\n    float t = iTime / 4.;\n    // uv *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    pixelSize = 1./R.y;\n    vec3 m = map(uv, uv, 60.);\n    vec2 z = m.xy;\n    \n    //z = uv;\n    \n    // Calculate polar coordinates\n    float r = sqrt(dot(z, z));\n    float theta = atan(z.y, z.x+0.000000001);\n     \n    // Normalize theta\n    float thetaNorm = (pi + theta) / (2.*pi);\n    \n    // Color the angle based on rainbow colors, and show the distance\n    float absW = log2(length(m.z));\n    float a = 0.0;\n    vec3 col = hsb2rgb(vec3(thetaNorm, 1., 1.) +.1) * (1.0 - a + a*absW);\n    \n    //col = hsb2rgb(vec3(fract(length(z)),1.,1.));\n    //col = magma(fract(length(z)));\n    //col = magma(m.z);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}