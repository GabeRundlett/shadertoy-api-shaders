{
    "Shader": {
        "info": {
            "date": "1668380373",
            "description": "Have you ever felt that time is elapsing faster and faster? Also, here's an excessively detailed post on how this thing works and on motion blur in general:\n\nhttps://www.osar.fr/notes/motionblur/",
            "flags": 0,
            "hasliked": 0,
            "id": "cdXSRn",
            "likes": 66,
            "name": "Torusphere Accelerator (+ blog)",
            "published": 3,
            "tags": [
                "blur",
                "motionblur",
                "motion",
                "analytic",
                "tone",
                "shepard",
                "acceleration"
            ],
            "usePreview": 0,
            "username": "dracusa",
            "viewed": 1116
        },
        "renderpass": [
            {
                "code": "/*\nInfinite speed motion blur using volume ray casting.\n\nBlog post to go with it: https://www.osar.fr/notes/motionblur\n*/\n\n#define PI 3.14159265359\n\n// basic material, light and camera settings\n#define DIFFUSE .9\n#define SPEC .9\n#define REFLECT .05\nconst vec3 lightDir = normalize(vec3(-5, -6, -1));\n#define CAM_D 2.4\n#define CAM_H .75\n\n// marching iterations\n#define ITER 40\n#define SHADOW_ITER 20\n// marching step, which depends on the size of the bounding sphere\nfloat stepSz;\n// torus shape ratio = minor radius / major radius\n#define TOR_RATIO .38\n// speed for: time remapping; ball transition into orbit; object rotation\n#define TIMESCALE .015\n#define RAD_SPEED 100.\nconst float RT_RAD_SPEED = sqrt(RAD_SPEED);\nconst float MAX_SPEED = floor(30./(TIMESCALE*PI*2.)+.5)*PI*2.;\n// remapped time for large scale events\nfloat T;\n// cycle duration in remapped time\n// it depends on the torus ratio because the radiuses zoom into each other\nconst float C = log((1. + TOR_RATIO) / TOR_RATIO);\nconst float D = C * .5;\n// ball and torus speed, rotation and transformation matrix\nfloat balSpeed, balRot, torSpeed, torRot;\nmat2 balMat, torMat;\n// ball and torus size and cycle progression\nfloat balSz, torSz, balCycle, torCycle;\n// ball and torus motion blur amplification\nfloat balAmp, torAmp;\n// torus minor and major radius, with squared version\nvec2 tor, tor2;\n// constants for torus angle and ball normals\nfloat torCst, balCst;\n// density and normity x-fades, ball orbit radius, cosmetic adjustments\nfloat densXf, normXf, balOrbit, torNormSz, strobe;\n\n// by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nfloat hash14(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy+33.33);\n\treturn fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n// by iq: https://iquilezles.org/articles/filterableprocedurals/\nfloat filteredGrid(vec2 p, float scale, vec2 dpdx, vec2 dpdy) {\n\tfloat iscale = 1./scale;\n\tfloat N = 60.0*scale;\n\tp *= iscale;\n\tvec2 w = max(abs(dpdx), abs(dpdy))*iscale;\n\tvec2 a = p + 0.5*w;\n\tvec2 b = p - 0.5*w;\n\tvec2 i = (floor(a)+min(fract(a)*N,1.0)-\n\t\tfloor(b)-min(fract(b)*N,1.0))/(N*w);\n\treturn (1.0-i.x*.6)*(1.0-i.y*.6);\n}\n\n// by iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = max(k-abs(a-b), 0.0)/k;\n\treturn min(a, b) - h*h*k*(1.0/4.0);\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\n// 2-point sphere intersection\nvec2 sphIntersect2(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.0) return vec2(-1.0, -1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h);\n}\n\n// antiderivative of the cosine shutter function which is:\n// (1-cos((x-t1) 2 PI / (t2-t1)))/(t2-t1) if t1<x<t2\n// 0 otherwise\nfloat iCosShutter(float x, float t1, float t2) {\n\tif (x < t1) return 0.;\n\tif (x > t2) return 1.;\n\tfloat d = 1./(t2 - t1);\n\tx -= t1;\n\treturn x*d - sin(2.*PI*x*d)/(2.*PI);\n}\n\n// motion blurred density = integral of { object presence * window function }\nfloat cosMotionBlur(float obj1, float obj2) {\n\t// Shutter time interval. Should include the frameStart, but it's\n\t// moved to the pixel coordinates for easier wrap management.\n\tfloat shut1 = -1./60.;\n\tfloat shut2 = 1./60.;\n\t// integral of the shutter function from obj1 to obj2\n\treturn iCosShutter(obj2, shut1, shut2) - iCosShutter(obj1, shut1, shut2);\n}\n\n// Take a slice at depth y. In polar coordinates, at radius r,\n// find the polar angle of the ball surface.\n// Returns 0 if r is entirely outside the ball.\n// Returns -1 if r is entirely inside the ball.\nfloat ballPolarSurface(float r, float y) {\n\tfloat rad = balSz*balSz - y*y;\n\tif (rad <= 0.) return 0.;\n\trad = sqrt(rad);\n\tif (r <= rad-balOrbit) return -1.;\n\tfloat div = (balOrbit*balOrbit+r*r-rad*rad)/(2.*r*balOrbit);\n\tif (abs(div) > 1.) return 0.;\n\treturn acos(div);\n}\n\n// motion-blurred ball density\nfloat ballDensity(vec3 p, float speed) {\n    p.xz *= balMat;\n\tp.z = abs(p.z);\n\tvec2 pol = vec2(length(p.xz), atan(p.z, p.x));\n\tfloat bA = ballPolarSurface(pol.x, p.y);\n\tif (bA == -1.) return 1.;\n\t// Time interval for the object presence at this pixel.\n\tfloat obj1 = (pol.y-bA)/speed;\n\tfloat obj2 = (pol.y+bA)/speed;\n\treturn cosMotionBlur(obj1, obj2);\n}\n\n// ball \"normity\", pseudo distance field to calculate normals\nfloat ballNormity(vec3 p) {\n    p.xz *= balMat;\n\tp.z = abs(p.z);\n\tvec2 pol = vec2(length(p.xz), atan(p.z, p.x));\n\tpol.y = max(0., pol.y-balCst);\n\tp.x = pol.x*cos(pol.y);\n\tp.z = pol.x*sin(pol.y);\n\treturn length(p-vec3(balOrbit, 0., 0.))-balSz;\n}\n\n// Take a slice at depth z. In polar coordinates, at radius r,\n// find the polar angle of the torus surface.\n// Returns 0 if r is entirely outside the torus.\n// Returns -1 if r is entirely inside the torus.\nfloat spiricPolarSurface(float r, float z) {\n\tfloat r2 = r*r;\n\tfloat z2 = z*z;\n\tfloat sum = torCst-2.*tor2.x*z2-2.*tor2.x*r2-2.*tor2.y*z2+2.*tor2.y*r2+z2*z2+2.*z2*r2+r2*r2;\n\tif (sum < 0.) return -1.;\n\tfloat sq = sqrt(sum)/(2.*tor.y*r);\n\tif (abs(sq) > 1.) return 0.;\n\treturn acos(sq);\n}\n\n// motion-blurred density of a half torus (a macaroni)\nfloat halfTorusDensity(vec2 pol, float z, float speed) {\n\tfloat da = spiricPolarSurface(pol.x, z);\n\tif (da == 0.) return 0.;\n\tif (da == -1.) return 1.;\n\t// Time interval for the object presence at this pixel.\n\tfloat obj1 = (pol.y-da)/speed;\n\tfloat obj2 = (pol.y+da)/speed;\n\treturn cosMotionBlur(obj1, obj2);\n}\n\n// motion-blurred torus density\nfloat torusDensity(vec3 p3d, float speed) {\n    p3d.xy *= torMat;\n\tvec2 pol = vec2(length(p3d.xy), atan(p3d.y, p3d.x));\n\tpol.y = mod(pol.y, PI*2.)-PI;\n\tfloat da = halfTorusDensity(pol, p3d.z, speed);\n\tpol.y = mod(pol.y + PI*2., PI*2.)-PI;\n\tfloat da2 = halfTorusDensity(pol, p3d.z, speed);\n\tif (da == 0. && da2 == 0.) return 0.;\n\tif (da == -1. || da2 == -1.) return 1.;\n\treturn min(1., da+da2);\n}\n\n// torus \"normity\", pseudo distance field to calculate normals\nfloat torusNormity(vec3 p, float speed) {\n    p.xy *= torMat;\n\tfloat shell = abs(length(p)-tor.y)-tor.x*.3;\n\tvec2 q = vec2(length(p.xz)-tor.y,p.y);\n\tfloat torus = length(q)-tor.x;\n\treturn -smin(speed*.002-torus, .1-shell, 0.1);\n}\n\n// combined density and normity\nfloat density(vec3 p) {\n\tfloat ball = ballDensity(p, balSpeed)*balAmp;\n\tfloat torus = torusDensity(p, torSpeed)*torAmp;\n    return mix(ball, torus, densXf);\n}\nfloat normity(vec3 p) {\n    return mix(\n\t\tballNormity(p),\n    \ttorusNormity(p*torNormSz, torSpeed*.5),\n\t\tnormXf);\n}\nvec3 getNormal(vec3 p) {\n\tfloat d = normity(p);\n\tvec2 e = vec2(.001, 0);\n\tvec3 n = d - vec3(\n\t\tnormity(p-e.xyy),\n\t\tnormity(p-e.yxy),\n\t\tnormity(p-e.yyx));\n\treturn normalize(n);\n}\n\n// Because we're raycasting translucent stuff, this is called up to 28x per px\n// so let's keep it short\nvec3 material(vec3 normal, vec3 rayDir) {\n\tfloat diff = max(dot(normal, -lightDir), .05);\n\tvec3 reflectDir = -lightDir - 2.*normal * dot(-lightDir, normal);\n\tfloat spec = max(dot(rayDir, reflectDir), 0.);\n\treturn vec3(.8,.9,1.) * (diff * DIFFUSE + spec * REFLECT);\n}\n\n// render torusphere by volume raycasting\nvec4 march(vec3 ro, vec3 rd, float marchPos, float marchBack) {\n\tfloat totMul = strobe*stepSz/0.05;\n\tvec4 col = vec4(0.);\n\tmarchPos -= stepSz * hash14(vec4(rd*4000., iTime*100.));\n\tint nMats = 0;\n\tfor(int i=0; i<ITER; i++) {\n\t\tvec3 pos = ro + rd * marchPos;\n\t\tfloat d = clamp(density(pos)*totMul, 0., 1.);\n\t\tif(d > .002) {\n\t\t\td = d*d*.5;\n\t\t\tfloat a2 = (1.-col.a)*d;\n\t\t\tvec3 n = getNormal(pos);\n\t\t\tcol += vec4(material(n, rd)*a2, a2);\n\t\t\tif (col.a > 0.95) break;\n\t\t\tif (nMats++ > 28) break;\n\t\t}\n\t\tmarchPos += stepSz;\n\t\tif (marchPos > marchBack) break;\n\t}\n\tif (col.a > 0.) col.rgb /= col.a;\n\treturn col;\n}\n\n// render ground shadow by volume raycasting without material\nfloat shadowMarch(vec3 ro, vec3 rd, float marchPos, float marchBack) {\n\tfloat ret = 0.;\n\tfloat shadowStep = stepSz*2.;\n\tfloat totMul = .47*strobe*shadowStep/0.05;\n\tmarchPos -= shadowStep * hash14(vec4(ro*4000., iTime*100.));\n\tfor(int i=0; i<SHADOW_ITER; i++) {\n\t\tvec3 pos = ro + rd * marchPos;\n\t\tfloat d = clamp(density(pos)*totMul, 0., 1.);\n\t\tif(d > .002) {\n\t\t\td = d*d*.9;\n\t\t\tret += (1.-ret)*d;\n\t\t\tif (ret > 0.95) break;\n\t\t}\n\t\tmarchPos += shadowStep;\n\t\tif (marchPos > marchBack) break;\n\t}\n\treturn min(1., ret);\n}\n\n// very inefficiently speed up the boring parts\nfloat retime(float t) {\n\tt *= TIMESCALE;\n\tfloat s = .5+1.7*t*PI*2./D;\n\ts = sin(s+sin(s+sin(s+sin(s)*0.3)*0.5)*0.75);\n\treturn s*.06+t*1.7;\n}\n\n// ball<->torus crossfade used separately by density and normity\nfloat getXf(float x) {\n\tx = (abs(mod(x-(D/4.), C)-D)/D-.5)*2.+.5;\n\t// return smoothstep(0, 1, x)\n\tx = 2.*clamp(x, 0., 1.)-1.;\n\treturn .5+x/(x*x+1.);\n}\n\n// The entire scene is necessarily zooming out. The ground texture deals with\n// that by crossfading different scales.\nconst float GRID_CYCLE = log(64.);\nvec3 grid(vec2 pt, vec2 dx, vec2 dy, float phase, float t) {\n\tfloat freq = exp(-mod(t+GRID_CYCLE*phase, GRID_CYCLE))*7.;\n\tfloat amp = cos(PI*2.*phase+t*PI*2./GRID_CYCLE)*-.5+.5;\n\tfloat g = filteredGrid(pt, freq, dx, dy)*amp;\n\treturn vec3(g,g,g);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// set all the globals...\n\tT = retime(iTime+25.); // consider a modulo here\n\tbalCycle = mod(T, C);\n\ttorCycle = mod(T+D, C);\n\n\t// size of the bounding sphere for marching and step size\n\tfloat boundSz = exp(-min(torCycle, 5.*(C-mod(T-D, C))));\n\tstepSz = boundSz/20.;\n\n\t// the ball/torus appear constant size and the camera appears to zoom out\n\t// in the code the camera distance is fixed and the objects are shrinking\n\tbalSz = exp(-balCycle-D);\n\ttorSz = exp(-torCycle);\n\n\t// the rotation is (theoretically) the integral of the speed, we need both\n\tbalSpeed = .04*MAX_SPEED*(cos(T*PI*2./C)+1.);\n\ttorSpeed = .04*MAX_SPEED*(cos((T+D)*PI*2./C)+1.);\n\tbalRot = MAX_SPEED*(sin(T*PI*2./C)/(PI*2./C)+T)/C;\n\ttorRot = MAX_SPEED*(sin((T+D)*PI*2./C)/(PI*2./C)+T)/C;\n\tif (balCycle<D) {\n\t\tbalRot = MAX_SPEED*(floor(T/C+.5)*C+D)/C;\n\t\tbalSpeed = 0.;\n\t}\n\tif (torCycle<D) {\n\t\ttorRot = MAX_SPEED*(floor((T+D)/C+.5)*C)/C;\n\t\ttorSpeed = 0.;\n\t}\n\tbalMat = rot2d(balRot);\n\ttorMat = rot2d(torRot);\n\n\t// torus minor and major radius and their squares\n\ttor = vec2(torSz/(1.+1./TOR_RATIO), torSz/(1.+TOR_RATIO));\n\ttor2 = tor*tor;\n\n\t// precalculate constants for the spiric angle and ball normals\n\ttorCst = tor2.x*tor2.x + tor2.y*tor2.y - 2.*tor2.x*tor2.y;\n\tbalCst = 2.*balSpeed*smoothstep(30., 40., balSpeed);\n\tfloat bx = balCst*.037;\n\tbalCst = (balCst+bx*bx*bx)*.004;\n\n\t// ball's orbital radius\n\tbalOrbit = clamp(balCycle-D, 0., 2.*RT_RAD_SPEED/RAD_SPEED)-RT_RAD_SPEED/RAD_SPEED;\n\tbalOrbit = .5+RT_RAD_SPEED*balOrbit/(balOrbit*balOrbit*RAD_SPEED+1.);\n\tbalOrbit *= tor.y;\n\n\t// ball<->torus crossfade: the normity precedes the density slightly\n\t// this smoothens the max speed -> zero speed illusion\n\tdensXf = getXf(T);\n\tnormXf = getXf(T+0.06);\n\n\t// motion blur amplification is what makes this work\n\tbalAmp = 1.+balSpeed*balSpeed*.00013;\n\ttorAmp = 1.5+torSpeed*torSpeed*.00015;\n\ttorNormSz = max(1., 8.*(torCycle-.76));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// the strobe effect simulates overlap between fast spin and slow spin\n\tstrobe = 1.-.1*(sin(iTime*83.+PI*smoothstep(.4, .6, uv.x))+1.)*(sin(2.2+T*PI*2./D)+1.)*.5;\n\n\t// camera\n\tfloat side = cos(CAM_H)*CAM_D;\n\tfloat camT = iTime*0.05+PI*.75;\n\tvec3 ro = vec3(sin(camT)*side, sin(CAM_H)*CAM_D, cos(camT)*side); // camera position (ray origin)\n\tvec3 ta = vec3(0., 0., 0.); // camera target\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 2.*ww);\n\n\t// this starting color taints the entire scene (unintentional but why not)\n\tvec3 col = vec3(0.33, 0.18, 0.1);\n\n\t// the ground plane\n\tif (rd.y < 0.) {\n\t\tvec3 groundPt = ro + rd*(-(ro.y+.8) / rd.y);\n\t\tvec2 g2d = groundPt.xz;\n\t\tvec2 dx = dFdx(g2d);\n\t\tvec2 dy = dFdy(g2d);\n\t\t// the ground texture zooms out by crossfading different scales\n\t\tcol += grid(g2d, dx, dy, 0., T)/3.;\n\t\tcol += grid(g2d, dx, dy, 1./3., T)/3.;\n\t\tcol += grid(g2d, dx, dy, 2./3., T)/3.;\n\t\tfloat sqDist = dot(g2d, g2d);\n\t\tcol *= 2./(sqDist*.5*1.5+1.)-1.2/(sqDist*1.5*1.5+1.);\n\t\t// are we in the shadow of the bounding sphere?\n\t\tvec2 sphInter = sphIntersect2(groundPt, -lightDir, vec4(0.,0.,0.,boundSz));\n\t\tif (sphInter != vec2(-1., -1.)) {\n\t\t\t// march the torusphere to draw the shadow\n\t\t\tfloat shad = shadowMarch(groundPt, -lightDir, sphInter.x, sphInter.y);\n\t\t\tcol *= 1.-shad*.7;\n\t\t}\n\t}\n\n\t// the sky (only visible in interactive version)\n\tfloat up = dot(rd, vec3(0.,1.,0.));\n\tcol = mix(col, vec3(0.33, 0.18, 0.1)*.7, 1.-smoothstep(0., .02, abs(up)+.003));\n\tcol = mix(col, vec3(0.,0.,.1), smoothstep(0., .5, up));\n\n\t// finally render the torusphere\n\tvec2 sphInter = sphIntersect2(ro, rd, vec4(0.,0.,0.,boundSz));\n\tif (sphInter != vec2(-1., -1.)) {\n\t\tvec4 ts = march(ro, rd, sphInter.x, sphInter.y);\n\t\tcol = mix(col, ts.rgb, ts.a);\n\t}\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}