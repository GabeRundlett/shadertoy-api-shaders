{
    "Shader": {
        "info": {
            "date": "1474357871",
            "description": "I was accidentally challenged by @CacheFlowe to make a Sierpinski Gasket in a fragment shader. It was fun to make, as usual!\nI would love something like this as a screensaver!",
            "flags": 0,
            "hasliked": 0,
            "id": "XtyGD1",
            "likes": 8,
            "name": "Sierpinski Floater",
            "published": 3,
            "tags": [
                "2d",
                "triangle",
                "sierpinski",
                "gasket",
                "sieve"
            ],
            "usePreview": 0,
            "username": "Zanzlanz",
            "viewed": 667
        },
        "renderpass": [
            {
                "code": "// By Zanzlanz\n// Creative commons with attribution, please - Sorry for ugly code btw :)\n\nfloat exp2Iterations = 4.0; // Gets changed in realtime. Iterations the fragment will calculate.\nbool tri(float x, float y) {\n    return (x+y < 1.0);\n}\n// I just needed a bitwise &. Ah well, here's a function that does it:\nfloat and(vec2 n) {\n\tif(n.x<0.0 || n.y<0.0 || n.x>=exp2Iterations || n.y>=exp2Iterations) return -1.0;\n\tfloat bitVal = 1.0;\n\tfloat result = 0.0;\n\tfor(int i=0; i<32; i++) {\n\t\tif (mod(n.x, 2.0) == 1.0 && mod(n.y, 2.0) == 1.0) result+=bitVal;\n\t\tn = floor(n / 2.0);\n\t\tbitVal *= 2.0;\n\t\tif(!(n.x > 0.0 || n.y > 0.0)) break;\n\t}\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    exp2Iterations = exp2( floor(sin(iTime+uv.y*2.0+uv.x*1.0+1.5+sin(uv.y*15.0)*.05)*4.0+4.5) );\n     \n    float scale = (sin(iTime*.4+3.0)*.4+.9)*exp2Iterations; // Pulsating\n    \n    // Movement around screen\n    uv.y -= .3*sin(iTime*.43) + .5;\n    uv.x -= .3*sin(iTime*.33) + .5+(iResolution.x-iResolution.y)/iResolution.y*.5;\n    \n    // Use polar coordinates to do funky rotation stuff\n\tfloat d = length(uv);\n\tfloat r = atan(uv.y, uv.x);\n\tr += .6+(1.0-d*.5)*sin(iTime*.3)*3.0;\n    uv = vec2(d*cos(r), d*sin(r));\n    \n    uv*=scale; // Scale it properlyish\n    \n    // Center on centroid so rotation looks good\n    uv.x+=exp2Iterations*.5;\n    uv.y+=exp2Iterations*.5/sqrt(3.0);\n    \n    uv.y/=sqrt(3.0)/2.0; // ...then make it equilateral!\n    uv.x-=uv.y*.5;       // Convert graph to isosceles first...\n    \n    // If x&y==0 and point lies under triangle, we're on the triangle! Woot!\n    if(and(floor(uv)) == 0.0 && tri(mod(uv.x, 1.0), mod(uv.y, 1.0)))\n\t\t fragColor = vec4(fragCoord/iResolution.xy, 1.0, 1.0);\n    else fragColor = vec4(fragCoord.xy/iResolution.xy*.1, 0.1, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}