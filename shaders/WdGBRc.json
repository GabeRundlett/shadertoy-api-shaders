{
    "Shader": {
        "info": {
            "date": "1607685686",
            "description": "Roll a dice on a surface in random directions: Here is the values it prints.\n( In fact I print the visible face of the dice. bottom face = 7 - this ).\nClick for no fading.\nTuto code for compact direction vectors ( as int 0..5) and rot matrices ( = ivec3).",
            "flags": 32,
            "hasliked": 0,
            "id": "WdGBRc",
            "likes": 14,
            "name": "rolling dice on surface",
            "published": 3,
            "tags": [
                "2d",
                "simulation",
                "tuto",
                "dices"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 447
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 O, vec2 U )\n{\n // U = (U-R/2.)/24. + R/2.;                                    // zoom on current area\n    U = (U-R/2.)/24. + mix( T(1).xy, T(0).xy, float(iFrame%N)/float(N) ); // interp dice location\n    bool p =  floor(U)==T(1).xy;                                // true on current dice location\n    float v = T(U).x;                                           // local printed value\n    O-=O;\n    \n    if ( v != 0. ) {\n        float t = iMouse.z>0. ? 1.                              // click to ignore fading\n                              : exp( - .2*( iTime - T(U).w ) ); // fading with age\n        if (t<.05) return;                                      // optim: discard darkests\n        \n        O =  t*( .6 + .6 * cos( 6.3*v/6.  + vec4(0,23,21,0) )); // display color\n\n        U = fract(U)*4.-.5;                                     // --- display dots\n        vec2 I = floor(U) - 1.;\n        if (max(abs(I.x),abs(I.y)) < 2. ) {                     // I = 3x3 dot grid\n            U = fract(U)*2.-1.;                                 // U = coords in cells\n            int i = int(v), l = int( 1.+I.y*I.x );\n            if ( I.x==0. ? I.y==0. && i%2 == 1                  // dice value to grid pattern\n                         : l==2 && i > 1 || l==0 && i > 3 || l==1 && i > 5 )\n            O -= smoothstep(1.5/3., 0., length(U)-.45);         // draw one dot\n        }\n        else  if (p) O++;                                       // frame dice location\n\n\n     // U = fract(U)*vec2(2,3);                                 // --- display (packed) dots\n     // vec2 I = floor(U); U = ( fract(U)*2.-1. ) / vec2(2,3);\n     // if ( v > I.x + 2.*I.y ) O -= smoothstep(1.5/16., 0., length(U)-.2);    \n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n#define R    iResolution.xy\n#define N    20                                 // slow down factor. 0 = fastest. ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define hash(p)  fract(sin( (p) * 12.9898 ) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    U-=.5;\n    if ( iFrame < 1 ) {                                    // initialization\n        if (U==vec2(0)) O = vec4( floor(R/2.), 0,1 );      // dice location P and frame I,J\n        return;                                            // directions: X,Y,Z,-X,-Y,-Z â†’ 0..5  K = I^J\n    }\n    \n    O = T(U);                                              // restore previous state\n    if ( iFrame % N > 0 ) return;                          // keep slow\n    \n    if (U==vec2(0)) {                                      // --- dice management\n// translate dir id to vec3 and back; apply compact rotation matrix\n#define decode(i)   ivec3( i==0?1:i==3?-1:0, i==1?1:i==4?-1:0, i==2?1:i==5?-1:0 )\n#define encode(V)   ( ( V.x!=0 ? 0 : V.y!=0 ? 1 : 2 ) +3 * int( V.x+V.y+V.z < 0 ) )\n#define apply(M,V)  ( ivec3( V[abs(M).x-1] , V[abs(M).y-1] , V[abs(M).z-1] ) * sign(M) )\n        int r = int(4.*hash(iTime));                       // random roll in direction X,-X,Y,-Y;\n        ivec3 M = r == 0 ? ivec3( 3,2,-1)                  // compact rotation matrices\n                : r == 1 ? ivec3(-3,2, 1)\n                : r == 2 ? ivec3(1, 3,-2)\n                :          ivec3(1,-3, 2);\n        O = vec4( O.x+ ( r==0 ? 1. : r==1 ? -1. : 0.),     // update position\n                  O.y+ ( r==2 ? 1. : r==3 ? -1. : 0.), \n                  encode( apply(M, decode(int(O.z)) ) ),   // update frame I,J (apply rotation)\n                  encode( apply(M, decode(int(O.w)) ) ) );   \n        return;\n    }\n    if (U==vec2(1)) { O = T(0); return; }                  // keep prev dice state\n    \n    if ( U == T(0).xy ) {                                  // --- print dice top face to new location \n        ivec2 F = ivec2( T(0).zw );\n        int f = F.x==2 ? 1 : F.x==5 ? 6                    // which face is up ?\n              : F.y==2 ? 2 : F.y==5 ? 5\n              : (F.y-F.x+6)%6 < 3 ? 4 : 3;\n        O = vec4(f, F+1, iTime);                           // x: face value. yz: for debug w: birthday\n    }\n}\n\n\n\n\n\n/*  // === old (uncomplete) approach with tables. ========================================\n        // roll the dice/  / array: how frame rotates for each roll direction X,-X,Y,-Y\n        int dir[] = int[]( 5,1,0,2,4,3,   2,1,3,5,4,0,   0,5,1,3,2,4,   0,2,4,3,5,1 );  \n        int r = int(4.*hash(iTime)),                       // random roll in direction X,-X,Y,-Y;\n            b = int(O.y>O.x);   // <><><> it's more more complicated :-( <><><>\n        O = vec4( O.x+ ( r==0 ? 1. : r==1 ? -1. : 0.),     // update position\n                  O.y+ ( r==2 ? 1. : r==3 ? -1. : 0.), \n                  dir[int(O.z)+6*(r^b)],                   // update local frame\n                  dir[int(O.w)+6*(r^b)] );\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}