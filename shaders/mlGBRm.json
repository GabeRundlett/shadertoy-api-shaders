{
    "Shader": {
        "info": {
            "date": "1701984534",
            "description": "based on https://www.shadertoy.com/view/clGBzm",
            "flags": 0,
            "hasliked": 0,
            "id": "mlGBRm",
            "likes": 15,
            "name": "Orthogonal Spheres Flower (iter)",
            "published": 3,
            "tags": [
                "raymarching",
                "math",
                "sdf",
                "sphere",
                "tracing",
                "iterative"
            ],
            "usePreview": 0,
            "username": "Real_NC",
            "viewed": 198
        },
        "renderpass": [
            {
                "code": "#define LAYERS\n\n#define EPS 0.001\n\n// the basis here is that the two spheres always intersect at a ring. We can use the ring to create a correct sdf exterior\nfloat sdDoubleSphere(vec3 p, vec4 s1, vec4 s2) \n{\n    float d1 = abs(distance(p, s1.xyz) - s1.w);\n    //float d2 = max(d1, s2.w - distance(p, s2.xyz)); // this gives us the correct shape but without the rounded edge.\n    float d2 = distance(p, s2.xyz) - s2.w;\n    \n    float ringX = 0.5*(s1.w*s1.w - s2.w*s2.w)/distance(s1.xyz, s2.xyz) - 0.5*distance(s1.xyz, s2.xyz);\n    vec3 ringPos = s2.xyz + normalize(s2.xyz - s1.xyz)*ringX;\n    float ringRad = sqrt(s1.w*s1.w - dot(s1.xyz - ringPos, s1.xyz - ringPos));\n    \n    vec3 tnorm = normalize(s2.rgb - s1.rgb);\n    vec3 p2 = p + tnorm*dot(ringPos.xyz - p, tnorm);\n    p2 = normalize(p2 - ringPos)*(ringRad) + ringPos;\n    \n    vec3 closests1 = normalize(p - s1.xyz) * s1.w;\n    \n    //return max(d1,d2); // shape debugger\n    if (dot(p2 - s2.xyz, p - p2) < 0.0 ) return d1;\n    return distance(p, p2);\n}\n\nfloat sdFlower(vec3 p)\n{\n    p.x = abs(p.x);\n    float d = length(p);\n    float r = 1.0;\n    for(r; r <= 20.0; r *= 2.0)\n    {\n        \n        d = min(d, sdDoubleSphere(p, vec4(r,0,0,r), vec4(0,4,0,4)));\n    }\n    \n    return d;\n    \n}\n\nfloat map(vec3 p)\n{\n    return sdFlower(p + vec3(0,4,0)) - 0.1;\n}\n\nvec3 normal(vec3 p) // tetrahedral SDF normal\n{\n    vec2 q = vec2(EPS,0);\n    return normalize(vec3(\n    map(p + q.xyy) - map(p - q.xyy),\n    map(p + q.yxy) - map(p - q.yxy),\n    map(p + q.yyx) - map(p - q.yyx)\n    ));\n}\n\nfloat checker(vec3 p)\n{\n    //p.xz = vec2(atan(p.x,p.z)*1.27323954474, length(p.xz)); // magic number is 8/tau\n    p = fract(p) - 0.5;\n    return 0.6 + 0.4 * sign(p.x*p.y*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-14);\n    vec3 rd = normalize(vec3(uv,1.7));\n    \n    float yaw = iTime;\n    if(iMouse.z > 0.) yaw = iMouse.x/iResolution.x*6.28 - 3.14;\n    float pitch = iMouse.y/iResolution.y*3.14 - 1.57;\n    mat2 rot = mat2(cos(yaw), sin(yaw),\n                    sin(yaw), -cos(yaw));\n    \n    mat2 rotp = mat2(cos(pitch), -sin(pitch),\n                     sin(pitch), cos(pitch));\n    \n    rd.zy = -(-rd.zy*rotp);\n    ro.zy *= rotp;\n    \n    rd.xz = -(-rd.xz*rot);\n    ro.xz *= rot;\n    \n    float d = 9.; // do not increase this past 10, otherwise it brokie\n    for(int i = 0; i <= 200; i++)\n    {\n        if (map(ro + rd*d) < EPS) break;\n        d += map(ro + rd*d);\n        if (d >= 18.1) \n        {\n            d = -1.0;\n            break;\n        }\n    }\n    vec3 ri = ro + rd*d;\n    fragColor = vec4(0);\n    \n    fragColor.rgb = vec3(checker(ri*1.));\n    \n    vec3 norm = normal(ri);\n    vec3 light = normalize(vec3(1,1,-1));\n    fragColor *= 0.5 + 0.5 * dot(norm, light);\n    fragColor *= 0.6;\n    fragColor += pow(max(dot(reflect(rd, norm), light), 0.), 28.0); // add specular\n    \n    if(d <= 0.) fragColor *= 0.;\n    \n    vec3 ps = ro - rd*dot(rd, ro);\n    float ds = -dot(rd,ro) - sqrt(16.0 - dot(ps,ps));\n    ri = ro + rd*ds;\n    \n    float sphereMesh;\n    if(dot(ps, ps) <= 16.0)\n    {\n        float d2 = -dot(rd + rd, ro) - ds; // backface distance\n        vec3 ri2 = ro + rd*d2;\n        if(d <= 0.|| d2 < d)\n        {\n            vec3 ri2 = ro + rd*(-dot(rd + rd, ro) - ds);\n            sphereMesh = smoothstep(0.15,0.1,length(ri2.xz)*abs(fract(atan(ri2.x, ri2.z)*4.77464829276)-0.5));\n            sphereMesh = mix(sphereMesh,1.0, smoothstep(0.15, 0.1, 3.14*abs(fract(acos(ri2.y/4.0)*4.77464829276)-0.5)));\n            fragColor = mix(fragColor, vec4(0.6,0.2,0.1,1), sphereMesh*0.4);\n        }\n    \n        sphereMesh = smoothstep(0.15,0.1,length(ri.xz)*abs(fract(atan(ri.x, ri.z)*4.77464829276)-0.5));\n        sphereMesh = mix(sphereMesh,1.0, smoothstep(0.15, 0.1, 3.14*abs(fract(acos(ri.y/4.0)*4.77464829276)-0.5)));\n        \n        if(ds < d || d <= 0.) fragColor = mix(fragColor, vec4(0.8,0,0,1), sphereMesh*0.4);\n    }\n    \n    fragColor = pow(fragColor, vec4(1./2.2));\n    /*\n    uv *= 12.0;\n    uv.y += 4.0;\n    float dist = map(vec3(uv, 0)) - 0.1;\n    fragColor = vec4(0.8+0.2*sin(dist*30.))*vec4(1,0.5,0,1);\n    if(dist <= 0.0) fragColor = 0.7 - 0.7*fragColor;\n    fragColor = mix(fragColor, vec4(0.5,0.5,1,1), .01/(dist*dist + .01));\n    */\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}