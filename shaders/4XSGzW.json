{
    "Shader": {
        "info": {
            "date": "1708225197",
            "description": "Explicit expression approximating the airmass using line integral in a gaussian scalar field, and evaluating it without running into an intermediate overflow.",
            "flags": 0,
            "hasliked": 0,
            "id": "4XSGzW",
            "likes": 6,
            "name": "Gaussian airmass",
            "published": 3,
            "tags": [
                "atmosphere",
                "erf",
                "chapman",
                "airmass"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Computation of approximate airmass, used to showcase an\n// overflow-wary evaluation of line integrals in a gaussian field.\n\n// Computation of airmass ( https://en.wikipedia.org/wiki/Air_mass_(astronomy) )\n// in a spherical atmosphere tends to involve Chapman\n// function ( https://en.wikipedia.org/wiki/Chapman_function ), under\n// the assumption that the density follows barometric\n// formula ( https://en.wikipedia.org/wiki/Barometric_formula ).\n// NOTE: while the Chapman function deals with a semi-infinite\n// ray, you can add/subtract two rays to obtain either an infinite\n// line, or a finite segment.\n// As this function is somewhat involved, there is an interest\n// in an approximation.\n//\n// One simple approximation is to use a gaussian field instead\n// of a linear exponent. NOTE: this is well-known, see e.g.\n// Fitzmaurice, J. A. (1964). Simplification of the Chapman Function for Atmospheric Attenuation. Applied Optics, 3(5), 640. doi:10.1364/ao.3.000640\n// where similar expression is given (without elaboration).\n// Specifically, we approximate the density\n//     k*exp(-h/H)=k*exp(-(r-R)/H)\n// where h is the height above the baseline R (e.g. sea level),\n// and H is the scale height ( https://en.wikipedia.org/wiki/Scale_height ),\n// via\n//     k*exp(-(r^2-R^2)/(2*R*H))=k*exp(-h/H-h^2/(2*H*R))\n// For planets with dense atmosphere (for Earth R/H≈700),\n// this is reasonably accurate (Fitzmaurice reports accuracy\n// 2% for R/H=50, and 0.1% for R/H=800). Note that for\n// h>sqrt(R*H) (where the discrepancy becomes large) the\n// density already is very low (and so is the absolute error).\n// The h<-sqrt(R*H) case may need more care, if we were\n// to sample there at all (which we usually don't, if\n// h=0 is the sea level).\n// With this, the airmass approximation becomes a familiar\n// integral of a gaussian field along a ray ro+t*rd:\n//     ∫ k*exp(-(A*t^2+B*t+C)) dt\n// with A,B,C depending on ro, rd, R, and H, which is\n//     (k*sqrt(pi/A)/2)*exp(B^2/(4*A)-C)*erf(sqrt(A)*t+B/(2*sqrt(A))))\n// One more hurdle is that evaluating it this way may run into\n// an intermediate overflow in otherwise moderately\n// sized exp(HUGE)*(erf(x+SMALL)-erf(x)). We deal with this\n// by using scaled complementary error function erfcx(x)=exp(x^2)*(1-erf(x)),\n// in corresponding cases (in the case where we don't (see code),\n// the overflow would likely be genuine: the result itself\n// overflows, not just the intermediate computation).\n//\n// NOTE: this shader just shows airmass, which is only\n// one part of atmospheric scattering computations. On its own\n// this is not a sky model. Still, you can use this explicit\n// expression to replace numerical integration in some places,\n// e.g. the inner loop in glsl-atmosphere:\n//     https://github.com/wwwtyro/glsl-atmosphere/blob/master/index.glsl\n// though with only 8 samples in said loop, the performance gain is\n// unimpressive.\n//\n// NOTE: there are, of course, much more accurate expressions for\n// the Chapman function, see e.g.:\n//     http://www.thetenthplanet.de/archives/4519\n//     https://zero-radiance.github.io/post/analytic-media/\n//     https://earth-planets-space.springeropen.com/articles/10.1186/s40623-021-01435-y\n//     https://egusphere.copernicus.org/preprints/2024/egusphere-2023-3112/egusphere-2023-3112.pdf\n\nconst float pi=3.14159265358979;\n\n#if 1\n// From https://www.shadertoy.com/view/ml3yWj\n// Eabs ~ 2.8e-8\n// Erel ~ 2.8e-8\nfloat erf(float x)\n{\n    x=clamp(x,-4.0,+4.0);\n    float x2=x*x;\n    return tanh(x*(1.12837919+x2*(0.275732946+x2*(0.0408672727+x2*0.00200393011)))/(1.0+x2*(0.153282651+x2*(0.0224402472+x2*0.000285807058))));\n}\n\n// Erel=2.89760318e-08\nfloat erfcx(float x)\n{\n    float q=1.0+sqrt(pi)*abs(x);\n    float t=abs(x)>1e9?1.0:abs(x)/(1.0+abs(x));\n    float p=(1.0+t*(-1.83923738+t*(0.716286914+t*(0.798943258+t*(-0.777020726+t*0.196551435)))))/(1.0+t*(-2.48331366+t*(2.67169669+t*(-1.47041333+t*(0.417875249+t*-0.0403214433)))));\n    float y=p/q;\n    return x<0.0?2.0*exp(x*x)-y:y;\n}\n#else\n// The REALLY crude approximations of erf and erfcx.\n// Please use something better (see e.g.\n// https://www.shadertoy.com/view/ml3yWj), if\n// you care about accuracy.\n\n// From https://www.shadertoy.com/view/tt2cWc\n// Eabs<0.0037.\nfloat erf(float x)\n{\n    x=clamp(x,-3.0,+3.0);\n    return (1.13072*x)/(1.0+(x*x)*(0.357055+(x*x)*-0.01014));\n}\n\nfloat erfcx(float x)\n{\n       const float a=0.4956; // Eabs<0.00150, Erel<0.01100\n    // const float a=0.5000; // Eabs<0.00167, Erel<0.01032\n    // const float a=0.5343; // Eabs<0.00311, Erel<0.00608\n    float y=(1.0+a*abs(x))/(1.0+abs(x)*((2.0/sqrt(pi)+a)+sqrt(pi)*a*abs(x)));\n    return x>=0.0?y:2.0*exp(x*x)-y;\n}\n#endif\n\n#if 0\n// Old version. Needs both erf and erfcx on (-inf;+inf).\n\n// Compute exp(x)*(1-erf(y)).\nfloat gauss_ray(float x,float y)\n{\n    return y<0.0?exp(x)*(1.0+erf(-y)):exp(x-y*y)*erfcx(y);\n}\n\n// Compute exp(x)*(erf(z)-erf(y)).\nfloat gauss_segment(float x,float y,float z)\n{\n    return y*z<0.0?\n        exp(x)*(erf(z)-erf(y)):\n        sign(y+z)*(exp(x-y*y)*erfcx(abs(y))-exp(x-z*z)*erfcx(abs(z)));\n}\n#else\n// New version. Needs only erfcx on [0;+inf).\n// Hopefully branchless.\n\n// Compute exp(x)*(erf(z)-erf(y)).\nfloat gauss_segment(float x,float y,float z)\n{\n    // NOTE: copysign() works as well, but sign() DOES NOT.\n    // Hopefully branchless.\n    float sy=(y>=0.0?+1.0:-1.0);\n    float sz=(z>=0.0?+1.0:-1.0);\n    // NOTE: first term can be simply (sz-sy)*exp(x)\n    // as long as exp(x) does not overflow, but fails\n    // if it does. Hopefully branchless.\n    return (sy==sz?0.0:(sz-sy)*exp(x))+\n        sy*exp(x-y*y)*erfcx(abs(y))-sz*exp(x-z*z)*erfcx(abs(z));\n}\n\n// Compute exp(x)*(1-erf(y)).\nfloat gauss_ray(float x,float y)\n{\n    return y>=0.0?+exp(x-y*y)*erfcx(abs(y)):\n        2.0*exp(x)-exp(x-y*y)*erfcx(abs(y));\n}\n#endif\n\n// Solve equation x^2+2*p*x+q=0.\nvec2 quadratic_solve(float p,float q)\n{\n    float d=p*p-q;\n    return d<0.0?vec2(+1e17,-1e17):-p+sqrt(d)*vec2(-1,+1);\n}\n\n// Or use actual infinity, if available.\nconst float INF=1e17;\n\n// Compute integral of density(ro+t*rd)*dt on [lo;hi],\n// where density(r)=k*exp(-(r^2-R^2)/(2*R*H)).\nfloat optical_depth(float k,float R,float H,vec3 ro,vec3 rd,float lo,float hi)\n{\n    // For r=ro+t*rd, density=k*exp(-(A*t^2+B*t+C)).\n    float A=0.5/(R*H);\n    float B=dot(ro,rd)/(R*H);\n    float C=0.5*(dot(ro,ro)-R*R)/(R*H);\n    float W=0.25*B*B/A-C;\n    // NOTE: hi==INF test is optional, gauss_segment()\n    // should be able to handle both cases.\n    return 0.5*k*sqrt(pi/A)*(hi==INF?\n        gauss_ray(W,sqrt(A)*lo+0.5*B/sqrt(A)):\n        gauss_segment(W,sqrt(A)*lo+0.5*B/sqrt(A),sqrt(A)*hi+0.5*B/sqrt(A)));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float R=6.4;     // Planet radius in arbitrary units.\n    float H=R/700.0; // Scale height (≈atmosphere depth).\n    float k=1e2/R;   // Density.\n    vec3 col=vec3(1e-3);\n    vec3 l=normalize(vec3(1)); // Direction to lightsource.\n    float h=R/4096.0;\n    float z=mix(0.0,4.0*R,smoothstep(-1.0,+1.0,sin(iTime)));\n    vec3 ro=vec3(0,R+h,z);          // Ray origin.\n    vec3 rd=normalize(vec3(xy,-1)); // Ray direction.\n    float lo=0.0,hi=INF;            // Ray bounds.\n    vec2 s=quadratic_solve(dot(ro,rd),dot(ro,ro)-R*R);\n    if(s.x<s.y&&s.x>0.0) // Real roots exist and both positive.\n    {\n        hi=s.x;\n        vec3 r=ro+s.x*rd;\n        vec3 n=normalize(r);\n        col=vec3(0.4,0.7,0.2)*(0.0625+0.5*max(dot(n,l),0.0));\n    }\n    col=mix(vec3(1.0),col,exp(-optical_depth(k,R,H,ro,rd,lo,hi)));\n    col=1.0-exp(-1.0*col); // Tonemap.\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}