{
    "Shader": {
        "info": {
            "date": "1580216545",
            "description": "https://cineshader.com/view/3tG3Rm",
            "flags": 0,
            "hasliked": 0,
            "id": "3tG3Rm",
            "likes": 5,
            "name": "Dimensional clock",
            "published": 3,
            "tags": [
                "volume",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "nodo",
            "viewed": 17250
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\n#define Time floor(iTime)*30.0\n\nconst float pi = acos(-1.);\nconst float pi2 = pi*2.;\nfloat pmodid;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 4378.553);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n\nfloat rand(vec2 co){\n    float a = 52.9498;\n    float b = 48.213;\n    float c = 438.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nvec3 hsv(float h, float s, float v) {\n\tvec3 a = fract(h+vec3(0.,2.,1.)/3.)*6.-3.;\n\ta = clamp(abs(a)-1.,0.,1.)-1.;\n\ta = a*s +1.;\n\treturn a*v;\n}\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    pmodid = floor(a / n);\n    a = pmodid * n;\n    return p * rot(-a);\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d2 : d1;\n}\n\nvec2 map(vec3 p){\n        \n    vec3 bp = p;    \n    vec3 pp = p;\n \n    float period = 5.0;\n    float v = floor(iTime/period)*period+smoothstep(0.2, 0.8,mod(iTime,period));\n    p.xz *= rot(pi*v);\n    \n    float period2 = 8.0;\n    v = floor(iTime/period2)*period2+smoothstep(0.2, 0.8,mod(iTime,period2));\n    p.yz *= rot(pi*v*2.0);\n    \n    \n    float f = fbm(bp * 0.2+iTime+0.001);\n    \n\n    bp.xy = pmod(bp.xy,40.0);\n  \n\n    bp.y -= 30.0;\n    vec2 bd = vec2(0.1 - length(bp) * 0.1+f*0.6,1.0);\n\n\n    for(int i = 0; i < 2;i++){\n        bp.y -= 6.0;\n\n        bp.xy *= rot(pi/20.0*float(i));\n    \tbd = opI(bd,vec2(0.1 - length(bp) * 0.1+f*0.6,1.0));\n    }\n    \n    \n    vec3 lp = p;\n    lp.xy *= rot(-Time/60.0);  \n    float f2 = fbm(lp * 0.1+iTime);\n    \n    \n    lp.y -= 10.;\n    vec2 longhand = vec2(0.1 - length(lp*vec3(1.5,0.3,1.0)) * 0.1 +f2,3.0);\n    \n    \n    vec3 sp = p;  \n    sp.xy *= rot(-Time/720.0);   \n    sp.y -= 6.;\n    vec2 shorthand = vec2(0.1 - length(sp*vec3(1.5,0.5,1.0)) * 0.1 +f2,3.0);\n    \n    \n    \n    p.xy = pmod(p.xy,12.0);\n    p.y -= 23.0;\n    vec2 dial = vec2(0.1 - length(p) * 0.1 + f*0.5,2.0);\n    \n    pmod(pp.xy,40.0);\n    \n    //return opI(opI(shorthand,longhand),bd);\n    return opI(opI(dial,opI(shorthand,longhand)),bd);\n}\n\n\n//https://www.shadertoy.com/view/WslGWl\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 ro = vec3(0.0,0.0,-45.0);\n    float screenZ = 1.0;\n    vec3 rd = normalize(vec3(uv,screenZ));\n\n    \n    // For raymarching const values.\n    const int sampleCount = 34;\n    const int sampleLightCount = 2;\n    const float eps = 0.01;\n    \n    // Raymarching step settings.\n    float zMax = 65.0;\n    float zstep = zMax / float(sampleCount);\n    \n    float zMaxl = 20.0;\n    float zstepl = zMaxl / float(sampleLightCount);\n    \n    // Easy access to the ray origin\n    vec3 p = ro;\n    \n    // Transmittance\n    float T = 1.0;\n    \n    // Substantially transparency parameter.\n    float absorption = 60.0;\n    \n    // Light Direction\n    vec3 sun_direction = normalize(vec3(1.0, 0.0, 0.0));\n    \n    vec4 col = vec4(0.0);\n    \n    vec2 mat;\n    \n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n\n        \n        mat = map(p);\n        float density = mat.x;\n        \n        if (density > 0.0)\n        {\n\n            float tmp = density / float(sampleCount);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            float Tl = 1.0;\n\n            vec3 lp = p;\n            \n            for (int j = 0; j < sampleLightCount; j++)\n            {\n                float densityLight = map(lp).x;\n                \n                if (densityLight > 0.0)\n                {\n                    float tmpl = densityLight / float(sampleCount);\n                    Tl *= 1.0 - (tmpl * absorption);\n                }\n                \n                if (Tl <= 0.01)\n                {\n                    break;\n                }\n                \n                lp += sun_direction * zstepl;\n            }\n            \n            float opaity = 50.0;\n            float k = opaity * tmp * T;            \n            \n            vec4 cloudColor = vec4(vec3(0.01,0.11,0.5),1.0);\n            \n            if(mat.y == 1.0){\n                cloudColor.rgb = hsv(pmodid/40.0,1.,1.5);           \n            }else if(mat.y == 3.0){\n                cloudColor.rgb = vec3(.0,.8,.9); \n                         \n            }else{\n                pmod(p.xy,12.0);\n                cloudColor.rgb = hsv(pmodid/12.0,1.0,1.8);                   \n            }\n            \n            vec4 col1 = cloudColor * k;\n                       \n            float opacityl = 30.0;\n            float kl = opacityl * tmp * T * Tl;\n            vec4 lightColor = vec4(.0, 0., .1, 1.0);\n            vec4 col2 = lightColor * kl;\n            \n            col += col1 + col2*3.0;\n        }\n        \n        p += rd * zstep;\n    }\n    \n    col.a *= 0.5;\n    \n    if(col.a == 0.0){\n        col.rgb = vec3(0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}