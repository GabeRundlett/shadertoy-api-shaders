{
    "Shader": {
        "info": {
            "date": "1719928954",
            "description": "Function to find the closest point to a 3D rectangle + code to prove it works.\nThe proof is performed by ray marching while using the provided function to compute the distance to the rectangle.\n\nSee \"get_closest_point_on_rectangle()\" in the Common tab.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3KXW1",
            "likes": 1,
            "name": "Closest point to 3D rectangle",
            "published": 3,
            "tags": [
                "3d",
                "square",
                "rectangle",
                "point",
                "to",
                "quad",
                "closest"
            ],
            "usePreview": 0,
            "username": "Tara",
            "viewed": 58
        },
        "renderpass": [
            {
                "code": "#define ROTATE_QUADS\n\nconst vec3 n_light_direction = normalize(vec3(0.0, 1.0, 0.0));\n\nconst mat4 identity_mat4 = mat4(vec4(1,0,0,0),\n                                vec4(0,1,0,0),\n                                vec4(0,0,1,0),\n                                vec4(0,0,0,1));\n\nconst quad quads[] = quad[]\n(\n    quad(vec3(0.0, 1.2, 0.4), vec3(0, 0, 1.0),  vec3(0, 0.5, 0),  vec3(1.0)),\n    quad(vec3(0.5, 1.0, 0.5), vec3(0, 0, 0.1),  vec3(0, 0.5, 0),  vec3(1.0, 0.5, 0.1)),\n    quad(vec3(-0.5, 1.0, 0.5), vec3(0, 0, 0.1),  vec3(0, 0.5, 0), vec3(0.2, 0.5, 1.1)),\n    quad(vec3(0.5, 1.0, -0.5), vec3(0, 0, 0.1),  vec3(0, 0.5, 0), vec3(0.2, 0.5, 1.1))\n);\n\n/*\n// Trace primary ray, to figure out material attributes.\nbool trace_ray(ray _ray_ws, out shading_surface out_surface)\n{\n    vec3 inv_ray_direction_ws = 1.0 / _ray_ws.direction;\n    \n    out_surface = null_shading_surface;\n    \n    mat4 rotation_matrix = rotationAxisAngle(normalize(vec3(1.0, 0.0, 0.0)), iTime * 0.5);\n    rotation_matrix = rotationAxisAngle(normalize(vec3(0.0, 0.0, 1.0)), iTime * 0.5); // TODO\n#ifndef ROTATE_QUADS\n    rotation_matrix = identity_mat4;\n#endif\n\n    plane ground_plane = to_plane(vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float t_plane = ray_intersects_plane_branchless(_ray_ws, ground_plane);\n    if((t_plane >= 0.0)&&(t_plane < out_surface.t))\n    {\n        out_surface.t = t_plane;\n        \n        vec3 position_ws = get_point_along_ray(_ray_ws, t_plane);\n        out_surface.emissive = vec3(0.0);\n        out_surface.n_normal_ws = ground_plane.xyz;\n        \n        vec2 uv = position_ws.xz;\n        out_surface.albedo = texture(iChannel2, uv).rgb;\n        out_surface.albedo = sRGB_to_linear(out_surface.albedo);\n        out_surface.albedo *= vec3(0.75, 1.0, 1.0);\n        \n        float roughness = texture(iChannel2, position_ws.xz).r;\n\n        roughness *= roughness;\n        roughness = min(0.1 + roughness, 1.0);\n        roughness *= roughness;\n        \n        out_surface.roughness = roughness;\n        out_surface.anisotropy = 0.0;\n        out_surface.metallic = 0.0;\n        \n        out_surface.n_tangent   = vec3(1.0, 0.0, 0.0);\n        out_surface.n_bitangent = vec3(0.0, 0.0, 1.0);\n    }\n    \n    out_surface.position_ws = get_point_along_ray(_ray_ws, out_surface.t);\n   \n    \n    return(out_surface.t < FLT_MAX);\n}\n*/\n\nvec3 sample_environment_map(vec3 direction)\n{\n    vec3 sky_color = texture(iChannel0, direction).rgb;\n    sky_color = sRGB_to_linear(sky_color);\n    sky_color *= sky_color;\n    sky_color *= 4.0;\n    return(sky_color);\n}\n\nmat4 get_quad_rotation_matrix(void)\n{\n#ifdef ROTATE_QUADS\n    return(rotationAxisAngle(vec3(1.0, 0.0, 0.0), iTime * 0.5) *\n           rotationAxisAngle(vec3(0.0, 0.0, 1.0), iTime * 0.5));\n#else\n    return(identity_mat4);\n#endif\n}\n\nbool intersect_scene(vec3 ray_origin_ws, vec3 n_ray_direction_ws, ray _mouse_ray_ws,\n                     out shading_surface out_surface)\n{ \n    mat4 rotation_matrix = get_quad_rotation_matrix();\n    \n    ray view_ray_ws = ray(ray_origin_ws, n_ray_direction_ws);\n    \n    const int ray_marching_steps = 256;\n    const float quad_thickness = 0.01;\n    \n    out_surface = null_shading_surface;\n    \n    float ray_t = 0.0;\n    for(int s=0; s<ray_marching_steps; ++s)\n    {\n        float min_distance_to_quad = 99999.9;\n        \n        vec3 p_ws = get_point_along_ray(view_ray_ws, ray_t);\n            \n        for(int i=0; i<quads.length(); ++i)\n        {\n            quad quad_ws = transform_quad(quads[i], rotation_matrix);\n            \n            vec3 p_on_quad_ws = get_closest_point_on_quad_v3(p_ws, quad_ws);\n            \n            float distance_to_quad = distance(p_ws, p_on_quad_ws);\n            min_distance_to_quad = min(min_distance_to_quad, distance_to_quad);\n            \n            if(distance_to_quad < quad_thickness)\n            {\n                vec2 uv = get_quad_uv(p_on_quad_ws, quad_ws);\n                out_surface.albedo = texture(iChannel2, uv).rgb * quad_ws.color;\n                out_surface.n_normal_ws = normalize(p_ws - p_on_quad_ws);\n                out_surface.position_ws = p_ws;\n                \n                s = ray_marching_steps;\n                break;\n            }\n        }\n\n        ray_t += min_distance_to_quad * 0.5;\n    }\n    \n    plane ground_plane = to_plane(vec3(0.0), vec3(0.0, 1.0, 0.0));\n\n    float t_plane = ray_intersects_plane_branchless(view_ray_ws, ground_plane);\n    if(t_plane >= 0.0 && t_plane < ray_t)\n    {\n        out_surface.position_ws = get_point_along_ray(view_ray_ws, t_plane);\n        out_surface.albedo = texture(iChannel1, out_surface.position_ws.xz).rgb;\n        // Desaturate the texture:\n        out_surface.albedo = (out_surface.albedo.rrr + out_surface.albedo) * 0.5;\n        out_surface.albedo *= 0.6;\n        out_surface.n_normal_ws = ground_plane.xyz;\n    }\n    \n    return(t_plane > 0.0 || ray_t < 999.9);\n\n    /*\n    for(int s=0; s<ray_marching_steps; ++s)\n    {\n        for(int i=0; i<quads.length(); ++i)\n        {\n            quad quad_ws = transform_quad(quads[i], rotation_matrix);\n\n            vec3 p_ws = get_point_along_ray(view_ray_ws, ray_t);\n            vec3 p_on_quad_ws = get_closest_point_on_quad(p_ws, quad_ws);\n\n            if(squared_distance(p_ws, p_on_quad_ws) < sqr(quad_thickness))\n            {\n                vec2 uv = get_quad_uv(p_on_quad_ws, quad_ws);\n\n                out_surface.albedo = texture(iChannel2, uv).rgb;\n                out_surface.n_normal_ws = get_quad_normal(quad_ws);\n                out_surface.position_ws = p_ws;\n                //return(out_surface);\n                s = ray_marching_steps;\n                break;\n            }\n\n            ray_t += max_view_distance / float(ray_marching_steps);\n        }\n    }\n    */\n    \n    //vec3 n_reflection = normalize(reflect(n_ray_direction_ws, ground_plane.xyz));\n    //ray reflection_ray_ws = ray(ray_origin_ws, n_reflection);\n    \n    /*\n    if(trace_primary_ray(_mouse_ray_ws, mouse_ray_surface))\n    {\n        vec3 n_mouse_reflection = normalize(reflect(_mouse_ray_ws.direction, mouse_ray_surface.n_normal_ws));\n\n        // Anisotropic version:\n        ray mouse_reflection_ray_ws = ray(mouse_ray_surface.position_ws, n_mouse_reflection);\n\n        // Offset the position, to avoid self-intersection artifacts:\n        mouse_reflection_ray_ws.origin += mouse_ray_surface.n_normal_ws * 0.0001;\n\n        //if(.(mouse_reflection_ray_ws, mouse_ray_surface))\n        {\n            //vec3 p = mouse_ray_surface.position_ws;\n            vec3 p = calculate_closest_point_in_quad(mouse_reflection_ray_ws, quad_ws);\n\n            if(distance(primary_surface.position_ws, p) < 0.025)\n            {\n                return(vec3(1.0, 1.0, 0.0));\n            }\n        }\n       \n        if(distance(primary_surface.position_ws, mouse_ray_surface.position_ws) < 0.025)\n        {\n            //return(vec3(1.0, 1.0, 0.0));\n        }\n      \n    }\n    */\n\n    /*\n    surface mouse_ray_surface;\n    if(trace_primary_ray(_mouse_ray_ws, mouse_ray_surface))\n    {\n        //shading_result_separate result = shade_pbr(primary_surface, light);\n        //add_shading_result(total_shading_result_separate, result); \n\n        if(distance(primary_surface.position_ws, mouse_ray_surface.position_ws) < 0.025)\n        {\n            out_color = vec3(1.0, 0.0, 0.0);\n        }\n    }\n    */\n}\n\nvec3 get_primary_ray_direction_vs(vec2 uv)\n{\n    vec2 p = 2.0 * uv - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(p.xy, 2.0));\n    return(rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera origin:\n    float an = (iTime + 45.0) * 0.4;\n    vec3 view_origin = -vec3(cos(an), 0.0, sin(an)) * 2.0;\n    \n    // Move up and down:\n    view_origin.y += sin(an * 0.5) * 0.9 + 1.0;\n     \n    // Camera target:\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Camera-to-world transformation\n    mat3 ca = get_camera_matrix(view_origin, ta, 0.0);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // View ray direction\n    vec3 n_view_direction = ca * get_primary_ray_direction_vs(uv);\n\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    vec3 n_mouse_ray_direction_ws = ca * get_primary_ray_direction_vs(mouse_uv);\n    ray mouse_ray_ws = ray(view_origin, n_mouse_ray_direction_ws);\n    \n    shading_surface surface;\n    if(intersect_scene(view_origin, n_view_direction, mouse_ray_ws, surface))\n    {\n        vec3 indirect_diffuse = textureLod(iChannel0, surface.n_normal_ws, 9.0).rgb;\n        indirect_diffuse *= indirect_diffuse;\n        indirect_diffuse *= 4.0;\n        vec3 direct_diffuse = vec3(lambert(surface.n_normal_ws, n_light_direction));\n        vec3 diffuse = indirect_diffuse + direct_diffuse * 4.0;\n        vec3 linear_albedo = sRGB_to_linear(surface.albedo);\n        fragColor.rgb = linear_albedo * diffuse;\n    }\n    else\n    {\n        fragColor.rgb = sample_environment_map(n_view_direction);\n    }\n\n    fragColor.rgb = reinhard(fragColor.rgb);\n    fragColor.rgb = linear_to_sRGB(fragColor.rgb);\n    fragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sqr(float _x)\n{\n    return(_x * _x);\n}\n\nfloat squared_length(vec3 _v)\n{\n    return(dot(_v, _v));\n}\n\nfloat squared_distance(vec3 _a, vec3 _b)\n{\n    return(squared_length(_a - _b));\n}\n\nvec3 sRGB_to_linear(vec3 color)\n{\n\treturn(pow(color, vec3(2.2)));  \n}\n\nvec3 linear_to_sRGB(vec3 color)\n{\n\treturn(pow(color, vec3(1.0 / 2.2)));\n}\n\nfloat lambert(vec3 n, vec3 l)\n{\n\treturn(max(dot(n, l), 0.0));\n}\n\nfloat half_lambert(vec3 n, vec3 l)\n{\n\treturn(max(dot(n, l) * 0.5 + 0.5, 0.0));\n}\n\nvec3 reinhard(vec3 x)\n{\n\treturn(x / (1.0 + x));\n}\n\n/////////////////////////////////////////////////////////\n// PLANE\n//\n// XYZ = normal\n// W   = signed distance\n#define plane vec4\n\nplane to_plane(vec3 _origin, vec3 _normal)\n{\n\treturn(plane(_normal, dot(_origin, _normal)));\n}\n/////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////\n// RAY\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 get_point_along_ray(ray _ray, float _distance)\n{\n\treturn(_ray.origin + _ray.direction * _distance);\n}\n\n// Returns a negative value if no intersection was found.\n// To check if an intersection was found, use \"t >= 0.0\".\nfloat ray_intersects_plane_branchless(ray _r, plane _p)\n{\n    //float ray_direction_dot_plane_normal = dot(_r.direction, _p.normal);\n    //float t = (_p.signed_distance - dot(_r.origin, _p.normal)) / ray_direction_dot_plane_normal;\n    float t = (_p.w - dot(_r.origin, _p.xyz)) / dot(_r.direction, _p.xyz);\n    return(t);\n}\n/////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////\n// QUAD\nstruct quad\n{\n    vec3 origin;\n    vec3 axis_x;\n    vec3 axis_y;\n    vec3 color;\n};\n\nquad transform_quad(quad _quad, mat4 _rotation_matrix)\n{\n    quad out_quad = _quad;\n    out_quad.origin += out_quad.axis_y * 0.5;\n    out_quad.axis_x = (vec4(out_quad.axis_x, 0.0) * _rotation_matrix).xyz;\n    out_quad.axis_y = (vec4(out_quad.axis_y, 0.0) * _rotation_matrix).xyz;\n    //out_quad.n_normal = get_quad_normal(quad_ws);\n\n    // Offset, so it rotates around its center:\n    out_quad.origin -= out_quad.axis_x * 0.5;\n    out_quad.origin -= out_quad.axis_y * 0.5;\n        \n    return(out_quad);\n}\n\n// \"_point: The point to find the closest point on the rectangle to.\n//\n// \"_rectangle_corner\": The rectangle origin that \"_rectangle_right\" \n//                      and \"_rectangle_up\" are relative to.\n//                      This is also a corner of the rectangle.\n//\n// \"_rectangle_right\": A vector going from (for example) the rectangle's\n//                     bottom left corner to the bottom right corner.\n//\n// \"_rectangle_up\": A vector going from (for example) the rectangle's\n//                  bottom left corner to the top left corner.\nvec3 get_closest_point_on_rectangle(vec3 _point,\n                                    vec3 _rectangle_corner,\n                                    vec3 _rectangle_right,\n                                    vec3 _rectangle_up)\n{\n    vec3 rectangle_to_point = _point - _rectangle_corner;\n    \n    vec2 uv;\n    uv.x = dot(_rectangle_right, rectangle_to_point);\n    uv.y = dot(_rectangle_up,    rectangle_to_point);\n    uv.x /= squared_length(_rectangle_right);\n    uv.y /= squared_length(_rectangle_up);\n    \n    // Clamp within the quad:\n    uv = clamp(uv, vec2(0.0), vec2(1.0));\n    \n    return(_rectangle_corner +\n           _rectangle_right * uv.x +\n           _rectangle_up * uv.y);\n}\n\nvec3 get_closest_point_on_quad_v3(vec3 position_ws, quad _quad)\n{\n    return(get_closest_point_on_rectangle(position_ws, _quad.origin, _quad.axis_x, _quad.axis_y));\n}\n\n// Different way to call the function:\nvec3 ClosestPointOnRectToPoint(vec3 position_ws, vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n    quad q;\n    q.origin = p0;\n    q.axis_x = p1 - p0;\n    q.axis_y = p2 - p0;\n    \n    vec3 p_on_quad = get_closest_point_on_rectangle(position_ws, q.origin, q.axis_x, q.axis_y);\n    return(p_on_quad);\n}\n\nvec2 get_quad_uv(vec3 position_ws, quad _quad)\n{\n    vec3 quad_to_position_ws = position_ws - _quad.origin;\n    \n    vec2 out_uv;\n    out_uv.x = dot(_quad.axis_x, quad_to_position_ws);\n    out_uv.y = dot(_quad.axis_y, quad_to_position_ws);\n    out_uv.x /= squared_length(_quad.axis_x);\n    out_uv.y /= squared_length(_quad.axis_y);\n    \n    return(out_uv);\n}\n\n//vec3 get_quad_normal(quad _quad)\n//{\n//    return(normalize(cross(_quad.axis_x, _quad.axis_y)));\n//}\n/////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////\n// SHADING_SURFACE\nstruct shading_surface\n{\n\t// Expected to be in linear sRGB color space\n\tvec3 albedo;\n\t\n\tvec3 n_normal_ws;\n    \n    vec3 position_ws;\n};\n\nconst shading_surface null_shading_surface = shading_surface\n(\n\tvec3(1.0),\t\t\t // vec3 albedo\n\tvec3(0.0, 0.0, 1.0), // vec3 n_normal_ws\n\tvec3(0.0, 0.0, 0.0)  // vec3 position_ws\n);\n/////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////\n// Source: https://www.shadertoy.com/view/Xds3zN\n//\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// The license is here only not because I want to (can one\n// license pieces of math?), but because people get upset\n// if I don't add one...\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    https://iquilezles.org/articles/distfunctions\nmat4 rotationAxisAngle(vec3 v, float angle)\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return(mat4(v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t    0.0,                0.0,                0.0,                1.0));\n}\n\nmat3 get_camera_matrix(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n/////////////////////////////////////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}