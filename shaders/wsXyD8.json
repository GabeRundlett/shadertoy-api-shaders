{
    "Shader": {
        "info": {
            "date": "1584694477",
            "description": "If you live in France or if you speak french, send us your shaders and win a high-end NVidia Quadro GPU! \nThe rendering contest is organized by the jFIG2020 conference that will be held in november 2020:\nhttps://jfig2020.sciencesconf.org/",
            "flags": 0,
            "hasliked": 0,
            "id": "wsXyD8",
            "likes": 7,
            "name": "jFIG2020 contest announcement",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raytracing",
                "tutorial",
                "rendering",
                "challenge",
                "contest",
                "jfig2020"
            ],
            "usePreview": 1,
            "username": "haqreu",
            "viewed": 1685
        },
        "renderpass": [
            {
                "code": "#define BUNW 6\n#define BUNH 6\n#define BUND 4\n#define BUNVOXSIZE 0.1\nuint[] bunny_bitfield = uint[]( 0xc30d0418u, 0x37dff3e0u, 0x7df71e0cu, 0x004183c3u, 0x00000400u );\nbool bunny(in int cubeID) {\n    if (cubeID<0 || cubeID>=BUNW*BUNH*BUND) return false;\n    return 0u != (bunny_bitfield[cubeID/32] & (1u << (cubeID&31)));\n}\n\n#define JFIGW 32u\n#define JFIGH 18u\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    uint id = x + (JFIGH-1u-y)*JFIGW;\n    if (id>=JFIGW*JFIGH) return false;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\nstruct Ray {\n\tvec3 origin;\n    vec3 dir;\n};\n\nstruct Box {\n    vec3 center;\n    vec3 halfsize;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nLight[] lights = Light[]( Light(vec3(-15,10,10), vec3(1,1,1)) );\n    \nbool box_ray_intersect(in Box box, in Ray ray, out vec3 point, out vec3 normal) {\n\tfor (int d=0; d<3; d++) {\n    \tif (abs(ray.dir[d])<1e-5) continue; \n\t\tfloat side = (ray.dir[d] > 0. ? -1.0 : 1.0);\n        float dist = (box.center[d] + side*box.halfsize[d] - ray.origin[d]) / ray.dir[d];\n\t\tif (dist < 0.) continue;\n        point = ray.origin + ray.dir*dist;\n        int i1 = (d+1)%3;\n        int i2 = (d+2)%3;\n        if (point[i1]>box.center[i1]-box.halfsize[i1] && point[i1]<box.center[i1]+box.halfsize[i1] &&\n        \tpoint[i2]>box.center[i2]-box.halfsize[i2] && point[i2]<box.center[i2]+box.halfsize[i2]) {\n            normal = vec3(0);\n            normal[d] = side;\n            return true;\n        }\n\t}\n    return false;\n}\n\nvec3 hs2rgb(vec2 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 colorFromIndex(float index) {\n    return hs2rgb(vec2(fract((index * 12.0)), index));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// anti-unroll trick to help the compiler\n#define Z min(0,iFrame)\n\nbool bunny_ray_intersect(in Ray ray, out vec3 point, out vec3 normal, out vec3 color) {\n    float bunny_dist = 1e10;\n    vec3 p = vec3(0), n = vec3(0);\n    for (int i=Z; i<BUNW; i++) {\n    \tfor (int j=Z; j<BUNH; j++) {\n    \t\tfor (int k=Z; k<BUND; k++) {\n                int cellID = i+j*BUNW+k*BUNW*BUNH;\n\t\t\t\tif (!bunny(cellID)) continue;\n                Box box = Box(vec3(i-BUNW/2,j-BUNH/2,-k+BUND/2)*BUNVOXSIZE+vec3(.5,.5,-.5)*BUNVOXSIZE, vec3(1.,1.,1.)*BUNVOXSIZE*.45);\n                if (box_ray_intersect(box, ray, p, n) && length(p-ray.origin) < bunny_dist) {\n                    bunny_dist = length(p-ray.origin);\n                    point = p;\n                    normal = n;\n                    color = colorFromIndex(float(int(hash(uint(cellID)))%144)/144.);\n                }\n    \t\t}\n    \t}\n    }\n\treturn bunny_dist < 1e3;\n}\n\nvec3 cast_ray(in Ray ray) {\n    vec3 p = vec3(0), n = vec3(0), c = vec3(0);\n    if (!bunny_ray_intersect(ray, p, n, c))\n        return texture(iChannel0, ray.dir).xyz;\n    \n   \tvec3 diffuse_light = vec3(0.);\n    for (int i=0; i<lights.length(); i++) {\n       \tvec3 light_dir = normalize(lights[i].position - p);\n        vec3 shadow_orig = dot(light_dir, n) < 0. ? p - n*1e-3 : p + n*1e-3;\n\t    vec3 shadp, shadn, shadc;\n        if (bunny_ray_intersect(Ray(shadow_orig, light_dir), shadp, shadn, shadc)) {\n            continue;\n        }\n       \tdiffuse_light  += lights[i].color * max(0., dot(light_dir, n));\n    }\n   \n    return c*(vec3(.7,.7,.7) + diffuse_light);\n}\n\nvec3 rotateCamera(in vec3 orig, in vec3 dir, in vec3 target) {\n    vec3 zAxis = normalize(orig - target);\n    vec3 xAxis = normalize(cross(vec3(0., 1., 0.), zAxis));\n\tvec3 yAxis = normalize(cross(zAxis, xAxis));\n   \tmat4 transform = mat4(vec4(xAxis, 0.), vec4(yAxis, 0.), vec4(zAxis, 0.), vec4(orig, 1.));\n    return (transform * vec4(dir, 0.)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    const float fov = 3.1416 / 4.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y*tan(fov/2.); \n\n    vec3 orig = vec3(-sin(iTime/4.), 0., cos(iTime/4.));\n    vec3 dir = normalize(vec3(uv, -1));\n\tdir = rotateCamera(orig, dir, vec3(0.));\n    \n    vec3 col = cast_ray(Ray(orig, dir));\n    float m = max(col.x, max(col.y, col.z));\n    if (m>1.) col = col / m;\n    \n    vec2 coord = fragCoord/iResolution.xy*vec2(JFIGW, JFIGH);\n    if (jfig(uint(coord.x), uint(coord.y)))\n        col += vec3(.5);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}