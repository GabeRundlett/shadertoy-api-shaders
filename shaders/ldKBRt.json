{
    "Shader": {
        "info": {
            "date": "1530050396",
            "description": "Placed 3rd in the 2018 Nova wild compo (as an animated gif, check out [url]https://giphy.com/gifs/7J4WFr2AAN0vGVXTgZ[/url] if it's running slowly)",
            "flags": 0,
            "hasliked": 0,
            "id": "ldKBRt",
            "likes": 100,
            "name": "Eternal Commute",
            "published": 3,
            "tags": [
                "escher",
                "knot",
                "train",
                "trefoil",
                "underground",
                "nova",
                "london",
                "graffiti",
                "tfl"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 2351
        },
        "renderpass": [
            {
                "code": "\nfloat time;\n\n// --------------------------------------------------------\n// Utilities\n// hg_sdf https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// Don't round corners when distance is reduced\nfloat fBoxy(vec2 p, vec2 s) {\n    return vmax(abs(p) - s);\n}\n\nfloat smin(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b) {\n    return smin(a, b, .0);\n}\n\nfloat smax(float a, float b) {\n    return smax(a, b, 0.);\n}\n\n\n// --------------------------------------------------------\n// Bezier\n// IQ https://www.shadertoy.com/view/ldj3Wh\n// Modified to return the closest point instead of\n// the distance\n// --------------------------------------------------------\n\nvec4 bezierPoint(vec3 A, vec3 B, vec3 C, vec3 pos)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec4 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec3 qos = A + (c + b*t)*t;\n        res = vec4(qos, t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec3 qos = A + (c + b * t.x) * t.x;\n        float dis = dot(qos - pos, qos);\n        res = vec4(qos, t.x);\n\n        qos = A + (c + b * t.y) * t.y;\n        float dis2 = dot(qos - pos, qos);\n        if( dis2 < dis ) {\n            res = vec4(qos, t.y);\n            dis = dis2;\n        }\n\n        qos = A + (c + b * t.z) * t.z;\n        dis2 = dot(qos - pos,qos);\n        if (dis2 < dis) {\n            res = vec4(qos, t.z);\n        }\n    }\n    \n    return res;\n}\n\n\n// --------------------------------------------------------\n// Trefoil\n//\n// This is a lot of code to create a simple trefoil knot,\n// however the usual method (helix in polar-coordinate space)\n// produces a tube with a lot of distortion in the centre.\n//\n// Instead, I'm constructing it from bezier curves, which have\n// been calculated with a ThreeJS/CanonJS app that finds a\n// 'tight' knot as described in this paper (1), see \n// https://github.com/tdhooper/trefoil-bezier\n//\n// I've reduced the number of individual curves that need to\n// be evaluated, from 15 to 9, by repeating space around\n// the knot's centre and plane. You can see these visualised\n// in the app.\n//\n// (1) Ropelength of tight polygonal knots\n//     Justyna Baranska, Piotr Pieranski, Eric J. Rawdon\n//     https://arxiv.org/abs/physics/0409108\n// --------------------------------------------------------\n\nfloat switchBezier(vec3 p, vec4 a, vec4 b) {\n    return length(p - a.xyz) - length(p - b.xyz);\n}\n\nstruct Curve {\n    vec3 position;\n    vec3 tangent;\n    vec3 normal;\n    vec3 binormal;\n    float t;\n};\n\nstruct CurvePart {\n    vec4 bez;\n    vec3 tangent;\n    vec3 normal;\n    float offset;\n};\n\n// 14\nvec3 a0 = vec3(-0.5669088543444947, -0.23671635305770958, 0.3195550470325173);\nvec3 b0 = vec3(-0.21879767215820162, -0.40033356387104035, 0.281874024845266);\nvec3 c0 = vec3(0, -0.40033356387104035, 0);\nvec3 aTan0 = vec3(0.9022064407419169, -0.38757768574492396, -0.1892275767334432);\nvec3 cTan0 = vec3(0.613494495153403, 0.0002619034153996805, -0.7896989526541569);\nvec3 aNor0 = vec3(-0.3077045475610546, -0.8858362163188649, 0.34729254133673104);\nvec3 cNor0 = vec3(0.00016067630912024614, -0.9999999657032999, -0.0002068248599310844);\n// 0\nvec3 a1 = vec3(0, -0.40033356387104035, 0);\nvec3 b1 = vec3(0.21879767215820162, -0.40033356387104035, -0.281874024845266);\nvec3 c1 = vec3(0.5669088543444947, -0.23671635305770958, -0.3195550470325173);\nvec3 aTan1 = vec3(0.613494495153403, 0.0002619034153996805, -0.7896989526541569);\nvec3 cTan1 = vec3(0.902206440741908, 0.38757768574494417, -0.18922757673344437);\nvec3 aNor1 = vec3(0.00016067630912024614, -0.9999999657032999, -0.0002068248599310844);\nvec3 cNor1 = vec3(0.307704565929649, -0.8858362318233614, -0.3472924855147808);\n// 1\nvec3 a2 = vec3(0.5669088543444947, -0.23671635305770958, -0.3195550470325173);\nvec3 b2 = vec3(0.9150200365307877, -0.0730991422443788, -0.3572360692197686);\nvec3 c2 = vec3(0.9444049957885698, 0.24455937521789314, -0.1786180346098843);\nvec3 aTan2 = vec3(0.902206440741908, 0.38757768574494417, -0.18922757673344437);\nvec3 cTan2 = vec3(0.14311311393143017, 0.8728591195545045, 0.4665143020652047);\nvec3 aNor2 = vec3(0.307704565929649, -0.8858362318233614, -0.3472924855147808);\nvec3 cNor2 = vec3(0.9651563914319037, -0.018749617671540965, -0.2610011339349261);\n// 5\nvec3 a3 = vec3(-0.34669903629988125, 0.20016678193552043, 0);\nvec3 b3 = vec3(-0.4560978723789819, 0.010682439557619071, -0.281874024845266);\nvec3 c3 = vec3(-0.48845680241143064, -0.3725992929638091, -0.3195550470325173);\nvec3 aTan3 = vec3(-0.3067472913765029, -0.531301816894778, -0.7896989797368913);\nvec3 cTan3 = vec3(-0.11545113752095092, -0.9751225133799538, -0.1892276902165235);\nvec3 aNor3 = vec3(-0.8660198797752173, 0.500009567669747, -0.000008534097960699594);\nvec3 cNor3 = vec3(-0.9210193666153568, 0.17643446721607253, -0.3472667635948305);\n// 6\nvec3 a4 = vec3(-0.48845680241143064, -0.3725992929638091, -0.3195550470325173);\nvec3 b4 = vec3(-0.5208157324438795, -0.7558810254852374, -0.3572360692197686);\nvec3 c4 = vec3(-0.2604078662219397, -0.940158405422784, -0.1786180346098843);\nvec3 aTan4 = vec3(-0.11545113752095092, -0.9751225133799538, -0.1892276902165235);\nvec3 cTan4 = vec3(0.6843619980972525, -0.5603684330860392, 0.4665146029451097);\nvec3 aNor4 = vec3(-0.9210193666153568, 0.17643446721607253, -0.3472667635948305);\nvec3 cNor4 = vec3(-0.49883011384191744, -0.8264741169516885, -0.26097710921340667);\n// 7\nvec3 a5 = vec3(-0.2604078662219397, -0.940158405422784, -0.1786180346098843);\nvec3 b5 = vec3(1.377036685388269e-16, -1.1244357853603304, 0);\nvec3 c5 = vec3(0.26040786622193884, -0.9401584054227843, 0.1786180346098843);\nvec3 aTan5 = vec3(0.6843619980972525, -0.5603684330860392, 0.4665146029451097);\nvec3 cTan5 = vec3(0.684361998097279, 0.5603684330859919, 0.4665146029451278);\nvec3 aNor5 = vec3(-0.49883011384191744, -0.8264741169516885, -0.26097710921340667);\nvec3 cNor5 = vec3(0.4988300815201652, -0.8264741202403052, 0.2609771605784677);\n// 8\nvec3 a6 = vec3(0.26040786622193884, -0.9401584054227843, 0.1786180346098843);\nvec3 b6 = vec3(0.5208157324438776, -0.7558810254852383, 0.3572360692197686);\nvec3 c6 = vec3(0.4884568024114297, -0.37259929296381017, 0.3195550470325173);\nvec3 aTan6 = vec3(0.684361998097279, 0.5603684330859919, 0.4665146029451278);\nvec3 cTan6 = vec3(-0.1154511375209849, 0.9751225133799435, -0.18922769021655528);\nvec3 aNor6 = vec3(0.4988300815201652, -0.8264741202403052, 0.2609771605784677);\nvec3 cNor6 = vec3(0.9210193440053495, 0.17643447537181506, 0.34726681941733095);\n// 9\nvec3 a7 = vec3(0.4884568024114297, -0.37259929296381006, 0.3195550470325173);\nvec3 b7 = vec3(0.4560978723789819, 0.010682439557618061, 0.281874024845266);\nvec3 c7 = vec3(0.34669903629988125, 0.2001667819355199, 0);\nvec3 aTan7 = vec3(-0.1154511375209849, 0.9751225133799435, -0.18922769021655528);\nvec3 cTan7 = vec3(-0.30674729137653417, 0.5313018168947605, -0.7896989797368906);\nvec3 aNor7 = vec3(0.9210193440053495, 0.17643447537181506, 0.34726681941733095);\nvec3 cNor7 = vec3(0.8660198557765797, 0.5000096092349068, 0.000008571384490341227);\n// 10\nvec3 a8 = vec3(0.34669903629988125, 0.2001667819355199, 0);\nvec3 b8 = vec3(0.23730020022078058, 0.38965112431342175, -0.281874024845266);\nvec3 c8 = vec3(-0.07845205193306419, 0.6093156460215194, -0.3195550470325173);\nvec3 aTan8 = vec3(-0.30674729137653417, 0.5313018168947605, -0.7896989797368906);\nvec3 cTan8 = vec3(-0.7867551988977671, 0.5875449230132569, -0.1892279589507877);\nvec3 aNor8 = vec3(0.8660198557765797, 0.5000096092349068, 0.000008571384490341227);\nvec3 cNor8 = vec3(0.6133085148535106, 0.709419711040007, -0.34724103904362313);\n\nfloat sepa;\nfloat sepR = 0.465;\n\n// Curve closest to the center\nCurvePart bezierInner(vec3 p) {\n    vec4 bez, bezPart;\n    vec3 a, b, c,\n        aTan, cTan, aNor, cNor,\n        tan, nor;\n    float offset;\n\n    a = a0;\n    b = b0;\n    c = c0;\n    aTan = aTan0;\n    cTan = cTan0;\n    aNor = aNor0;\n    cNor = cNor0;\n    bezPart = bezierPoint(a, b, c, p);\n    bez = bezPart;\n    tan = mix(aTan, cTan, bez.w);\n    nor = mix(aNor, cNor, bez.w);\n    offset = 0.;\n\n    a = a1;\n    b = b1;\n    c = c1;\n    aTan = aTan1;\n    cTan = cTan1;\n    aNor = aNor1;\n    cNor = cNor1;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 1.;\n    }\n\n    a = a2;\n    b = b2;\n    c = c2;\n    aTan = aTan2;\n    cTan = cTan2;\n    aNor = aNor2;\n    cNor = cNor2;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 2.;\n    }\n\n    sepa = length(p - bez.xyz) - sepR;\n\n    return CurvePart(\n        bez,\n        tan,\n        nor,\n        offset\n    );\n}\n\n// Curve that loops around the outside\nCurvePart bezierOuter(vec3 p) {\n    vec4 bez, bezPart;\n    vec3 a, b, c,\n        aTan, cTan, aNor, cNor,\n        tan, nor;\n    float offset;\n\n    a = a3;\n    b = b3;\n    c = c3;\n    aTan = aTan3;\n    cTan = cTan3;\n    aNor = aNor3;\n    cNor = cNor3;\n    bezPart = bezierPoint(a, b, c, p);\n    bez = bezPart;\n    tan = mix(aTan, cTan, bez.w);\n    nor = mix(aNor, cNor, bez.w);\n    offset = 0.;\n\n    a = a4;\n    b = b4;\n    c = c4;\n    aTan = aTan4;\n    cTan = cTan4;\n    aNor = aNor4;\n    cNor = cNor4;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 1.;\n    }\n\n    float sepd = length(p - bez.xyz) - sepR;\n\n\n    a = a5;\n    b = b5;\n    c = c5;\n    aTan = aTan5;\n    cTan = cTan5;\n    aNor = aNor5;\n    cNor = cNor5;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 2.;\n    }\n\n    a = a6;\n    b = b6;\n    c = c6;\n    aTan = aTan6;\n    cTan = cTan6;\n    aNor = aNor6;\n    cNor = cNor6;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 3.;\n    }\n\n    float sepc = 1e12;\n\n    a = a7;\n    b = b7;\n    c = c7;\n    aTan = aTan7;\n    cTan = cTan7;\n    aNor = aNor7;\n    cNor = cNor7;\n    bezPart = bezierPoint(a, b, c, p);\n\n    sepc = min(sepc, length(p - bezPart.xyz) - sepR);\n\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 4.;\n    }\n\n    a = a8;\n    b = b8;\n    c = c8;\n    aTan = aTan8;\n    cTan = cTan8;\n    aNor = aNor8;\n    cNor = cNor8;\n    bezPart = bezierPoint(a, b, c, p);\n\n    sepc = min(sepc, length(p - bezPart.xyz) - sepR);\n\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 5.;\n    }\n\n    float sepb = length(p - bez.xyz) - sepR;\n    sepa = max(sepa, sepb);\n    sepc = max(sepc, sepd);\n    sepa = min(sepa, sepc);\n\n    return CurvePart(\n        bez,\n        tan,\n        nor,\n        offset + 6.\n    );\n}\n\nCurve TrefoilCurve(vec3 p) {\n\n    vec4 bez, bezPart;\n    \n    float side = 0.;\n    float tFlip = 1.;\n\n    float cell = 0.;\n\n    float repetitions = 3.;\n    float angle = TAU / repetitions;\n\n\n    if (p.z > 0.) {\n        p.z *= -1.;\n        p.y *= -1.;\n        pR(p.xy, angle / -2.);\n        side = 1.;\n        tFlip = -1.;\n    }\n    pR(p.xy, angle / -2.);\n    cell = pModPolar(p.xy, repetitions);\n    pR(p.xy, angle / 2.);\n\n    float outer = 0.;\n\n    CurvePart curve = bezierInner(p);\n    CurvePart outerCurve = bezierOuter(p);\n\n    if (switchBezier(p, curve.bez, outerCurve.bez) > 0.) {\n        outer = 1.;\n        curve = outerCurve;\n    }\n\n    float an = cell * angle;\n\n    mat3 m = mat3(\n        cos(an), -sin(an), 0,\n        sin(an), cos(an), 0,\n        0, 0, 1\n    );\n\n    mat3 m2 = mat3(\n        cos(angle / -2.), -sin(angle / -2.), 0,\n        sin(angle / -2.), cos(angle / -2.), 0,\n        0,0,-1\n    );\n    mat3 m3 = mat3(1,0,0,0,-1,0,0,0,1);\n\n    if (side > 0.) {\n        m = m * m2 * m3;\n    }\n\n    float parts = 24.;\n\n    float sectionCurveOffset;\n\n    vec3 tangent = curve.tangent;\n    vec3 normal = curve.normal;\n    vec3 binormal = cross(tangent, normal);\n\n    normal *= -1.;\n\n    if (side > 0.) {\n        binormal *= -1.;\n    }\n\n    tangent = normalize(tangent);\n    binormal = normalize(binormal);\n    normal = normalize(normal);\n\n    float flip = -1. + side * 2.;\n    cell = mod(cell * flip, 3.);\n    float offset = cell * 5. + side * 7.;\n    float t = (offset - (curve.bez.w + curve.offset) * flip);\n    t = mod(t / 15., 1.);\n\n    vec3 position = curve.bez.xyz;\n\n    return Curve(\n        position * m,\n        curve.tangent * m,\n        normal * m,\n        binormal * m,\n        t\n    );\n}\n\nvoid pModTrefoil(inout vec3 p, float len) {\n    Curve curve = TrefoilCurve(p);\n    float x = dot(p - curve.position, curve.normal);\n    float y = dot(p - curve.position, curve.binormal);\n    float z = curve.t;\n    p = vec3(x, y, z);\n    p.z -= 0.0666;\n    p.z *= len;\n}\n\n\n// --------------------------------------------------------\n// Materials, well, actually just colours\n// --------------------------------------------------------\n\nvec3 TRAIN_MAT = vec3(.9,.5,.5);\nvec3 CHANNEL_MAT = vec3(.15);\nvec3 SLEEPER_MAT = vec3(.2);\nvec3 RAIL_MAT = vec3(.25);\nvec3 PLATFORM_MAT = vec3(.5);\nvec3 MIND_THE_GAP_MAT = vec3(1.,1.,0.);\n\nvec3 TRAIN_RED = vec3(1,.025,.125);\nvec3 TRAIN_GREY = vec3(.4);\nvec3 TRAIN_ROOF = vec3(.6);\nvec3 TRAIN_WINDOW = vec3(.5,.9,1.);\nvec3 TRAIN_WHITE = vec3(1);\nvec3 TRAIN_BLUE = vec3(0,0,.7);\nvec3 TRAIN_UNDERCARRIDGE = vec3(.1);\n\nvec3 STAIR_BASE_MAT = vec3(.1);\nvec3 STEP_MAT = vec3(.3);\nvec3 STEP_TOP_MAT = vec3(.5);\nvec3 STEP_YELLOW_MAT = vec3(1.,1.,0.);\nvec3 HANDRAIL_MAT = vec3(.7);\n\n\n// --------------------------------------------------------\n// Model\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 material;\n    vec2 uv;\n    float underStep;\n    int id;\n};\n\nModel opU(Model a, Model b) {\n    if (a.dist < b.dist) {\n        return a;\n    }\n    return b;\n}\n\nModel mTrain(vec3 p, float width, float height, float index) {\n    p.z *= -1.;\n\n    float d = 1e12;\n    float len = 1.2;\n\n    vec3 pp = p;\n\n    p /= height * 4.;\n    p.y *= sign(p.x);\n    p.y -= mix(.75, .25, sign(p.x) * .5 + .5);\n    p.z += (index - 1.) * len * 4.;\n    vec2 uv = p.zy;\n\n    p = pp;\n    p.x = abs(p.x);\n    pp = p;\n\n    float isFront = max(0., sign(p.z));\n    float frontWidth = .12;\n    float backWidth = .08;\n    float innerLength = (len * 2.) - backWidth * 2.;\n    float frontDoorOffset = frontWidth - backWidth;\n\n    d = p.x - width;\n\n    // Slanted side\n    p.xy -= vec2(width, height * .45);\n    d = max(d, dot(p.xy, normalize(vec2(1.,-.175))));\n    p = pp;\n\n    // Round top\n    float topRadius = width * 1.1;\n    p.y += height - topRadius;\n    float top = length(p.xy) - topRadius;\n    top = min(top, -p.y);\n    d = smax(d, top, .005);\n    p = pp;\n\n    // Blue bar\n    float blueStripe = step(0., p.y - height + .03);\n    vec3 color = mix(TRAIN_WHITE, TRAIN_BLUE, blueStripe);\n\n    float form = d;\n    float thinOffset = .025;\n    float thin = form + thinOffset;\n    d = thin;\n\n    // Roof setup\n    float roofPane = p.y + height * .8;\n\n    // Carridge setup\n    float carridgeCrop = max(-p.z - innerLength / 2., p.z - innerLength / 2. + frontDoorOffset);\n    d = smax(d, carridgeCrop, .01);\n\n    // Side doors\n    float sideDoorWidth = .17 / 2.;\n    float spacing = innerLength / 3.;\n    p.z -= spacing / 2.;\n    float cell = pMod1(p.z, spacing);\n    float isFrontDoor = max(0., cell);\n    p.z += frontDoorOffset * isFrontDoor;\n    p.z = abs(p.z);\n    p.z -= sideDoorWidth - .001;\n    float sideDoorMask = fBox2(p.yz, vec2(1., sideDoorWidth));\n    float sideDoors = smax(form, sideDoorMask, thinOffset * 1.5);\n    sideDoors = smax(sideDoors, -roofPane, .01);\n    sideDoors = max(sideDoors, carridgeCrop);\n    float sideDoorEdge = sideDoorMask + .01;\n    vec3 sideDoorColor = mix(TRAIN_RED, TRAIN_WHITE, isFrontDoor);\n    sideDoorColor = mix(sideDoorColor, TRAIN_BLUE, blueStripe * isFrontDoor);\n    float windowFrameOffset = .007;\n    p.y += .028;\n    p.z += .025;\n    float sideDoorWindow = fBox2(p.yz, vec2(height * .42, sideDoorWidth * .3)) - .005;\n    sideDoorColor = mix(sideDoorColor, TRAIN_WINDOW, 1. - step(0., sideDoorWindow));\n    p = pp;\n    color = mix(color, sideDoorColor, step(0., d - sideDoors));\n    d = min(d, sideDoors);\n    p = pp;\n\n    // Side windows\n    p.y = abs(p.y);\n    float sideWindow = p.y - .04;\n    sideWindow = smax(sideWindow, -sideDoorMask + windowFrameOffset * 2., .01);\n    pMod1(p.z, spacing);\n    p.z = abs(p.z);\n    sideWindow = smax(sideWindow, -(p.z - windowFrameOffset * 2.), .01);\n    color = mix(color, TRAIN_WINDOW, 1. - step(0., sideWindow));\n    p = pp;\n\n    // Roof\n    float roof = smax(form, roofPane, .01);\n    roof = smax(roof, carridgeCrop, .01);\n    color = mix(color, TRAIN_ROOF, step(0., d - roof));\n    d = min(d, roof);\n\n    // Front\n\n    p.z = abs(p.z);\n    p.z -= len;\n    float frontRadius = width * 3.;\n    float endcap = length(p.xz + vec2(0,frontRadius)) - frontRadius;\n    endcap *= .5;\n    p = pp;\n\n    p.z -= len;\n    float front = smax(form, endcap, .03);\n    front = smax(front, -(p.z + frontWidth), .01);\n    color = mix(color, TRAIN_RED, step(0., d - front));\n    d = min(d, front);\n    p = pp;\n\n    // Back\n    p.z += len;\n    float back = smax(form, endcap, .03);\n    back = smax(back, (p.z - backWidth), .01);\n    vec3 backColor = mix(TRAIN_WHITE, TRAIN_BLUE, blueStripe);\n    color = mix(color, backColor, step(0., d - back));\n    d = min(d, back);\n    p = pp;\n\n    // Front grey\n    p.z = abs(p.z);\n    p.z -= len - .05;\n    float grey = form + .01;\n    grey = max(grey, -p.z);\n    p.y -= height * .48;\n    p.x -= width * .3;\n    if (isFront > 0.) {\n        grey = smax(grey, dot(p.xy, normalize(vec2(.3,1))), .02);\n        grey = max(grey, p.y);\n    }\n    color = mix(color, TRAIN_GREY, step(0., d - grey));\n    p = pp;\n\n    // Front door\n    vec2 doorWH = vec2(width * .22, height * 1.7);\n    vec2 doorXY = vec2(0, height);\n\n    // - Inset\n    p.z = abs(p.z);\n    p.xy -= doorXY;\n    p.z -= len;\n    d = smax(d, -fBox(p, vec3(doorWH, .01)), .01);\n\n    // - Template\n    float door = fBox2(p.xy, doorWH);\n    p = pp;\n\n    // Window\n    float windowBottom = mix(.02, -.01, isFront);\n    float windowOffset = .0125;\n    float window = max(door + windowOffset, p.y - windowBottom);\n    p = pp;\n\n    float window2Offset = .02;\n    float window2 = max(-door + window2Offset, p.y - .02);\n    p.xy -= vec2(doorWH.x + window2Offset, windowBottom + .01);\n    window2 = max(window2, dot(p.xy, normalize(vec2(-.7,1))));\n\n    p = pp;\n    window2 = max(window2, -(p.y + doorWH.y - doorXY.y - windowOffset + .005));\n    window2 = smax(window2, grey + .02, .01);\n    window = min(window, window2);\n    color = mix(color, TRAIN_WINDOW, 1.-step(0., window));\n\n    // Undercarridge\n\n    float baseHeight = .025;\n    p.y -= height;\n    d = smax(d, p.y, 0.);\n\n    p.y -= baseHeight / 2.;\n    float undercarridge = fBox2(p.xy, vec2(width - baseHeight, baseHeight / 2.));\n    p.z = abs(p.z);\n    undercarridge = max(undercarridge, endcap);\n    color = mix(color, TRAIN_UNDERCARRIDGE, step(0., d - undercarridge));\n    d = min(d, undercarridge);\n    p = pp;\n\n    Model train = Model(d, color, uv, .2, 1);\n    return train;\n}\n\nbool pastThreshold = false;\nfloat lastSide = 1.;\n\nModel mTrainSide(vec3 p, float curveLen, float radius) {\n    \n    vec3 pp = p;\n    float d = 1e12;\n    vec3 color = CHANNEL_MAT;\n\n    float trainSize = .175;\n\n    // Impossible Channel\n    // Carves through beyond the other side of a thi turface,\n    // as if it had depth.\n\n    p.x = abs(p.x);\n    d = -p.y - .001;\n\n    float threshold = fBox2(p.xy + vec2(0,.003), vec2(radius, .002));\n    float side = sign(threshold);\n    if (side != lastSide) {\n        pastThreshold = true;\n    }\n    lastSide = side;\n\n    float gap = .01;\n    float channelWidth = trainSize + gap;\n    float channelDepth = .09;\n\n    if (pastThreshold) {\n        float cut = fBox2(p.xy, vec2(channelWidth, channelDepth));\n        d = max(d, -cut);\n    }\n\n    // Platform\n\n    p.x = abs(p.x);\n    p.x -= radius;\n    float platform = fBox2(p.xy, vec2(radius - channelWidth,.005)) - .005;\n    color = mix(color, PLATFORM_MAT, step(0., d - platform));\n    d = min(d, platform);\n    p = pp;\n\n    p.x = abs(p.x);\n    p.x -= mix(radius, channelWidth, .5);\n    pMod1(p.z, curveLen * 2./3. / 10.);\n    float mindTheGap = fBox2(p.xz, vec2(0., .125)) - .015;\n    color = mix(color, MIND_THE_GAP_MAT, 1. - step(0., mindTheGap));\n    p = pp;\n\n\n    // Sleepers\n\n    p.x = abs(p.x);\n    float sleeperSize = curveLen / 80.;\n    float sleeperHeight = .02;\n    pMod1(p.z, sleeperSize);\n    p.y -= channelDepth;\n    float sleepers = fBox(p, vec3(channelWidth * .66, sleeperHeight, sleeperSize / 4.));\n    color = mix(color, SLEEPER_MAT, step(0., d - sleepers));\n    d = min(d, sleepers);\n    p = pp;\n\n\n    // Rails\n\n    p.x = abs(p.x);\n    float railHeight = .01;\n    p.x = abs(p.x);\n    p.x -= channelWidth * .4;\n    p.y -= channelDepth - sleeperHeight - railHeight;\n    float rail = fBox2(p.xy, vec2(railHeight));\n    color = mix(color, RAIL_MAT, step(0., d - rail));\n    d = min(d, rail);\n    p = pp;\n\n\n    Model track = Model(d, color, vec2(0), 0., 2);\n\n    p.z += curveLen * .14;\n    p.z += time * (curveLen * 5. / 6.);\n    float c = floor(p.z / curveLen * 2. + .5);\n    c = mod(c, 2.);\n    if (time > .85) {\n        c += 1.;\n    }\n    pMod1(p.z, curveLen / 2.);\n    float trainHeight = trainSize * .8;\n    p.y += trainHeight;\n    Model train = mTrain(p, trainSize, trainHeight, c);\n    p = pp;\n\n    Model model = opU(track, train);\n\n    if ( ! pastThreshold) {\n        model.dist = max(model.dist, p.y);\n    }\n\n    return model;\n}\n\nModel mStairSide(vec3 p, float curveLen, float radius) {\n    vec3 pp = p;\n    float d = p.y;\n\n    float stairSize = curveLen / 60.;\n    p.z += time * stairSize * 2. * -3.;\n\n    pMod1(p.z, stairSize);\n\n    float stairRadius = stairSize * .9;\n    float handrailWidth = .1;\n    float stairWidth = radius - handrailWidth;\n\n    vec3 color = STAIR_BASE_MAT;\n\n    // Step\n    p.z -= stairSize / 2.;\n    pp = p;\n    pR(p.yz, (30./180.) * PI);\n    float steps = length(p.yz) - stairRadius;\n    steps = smax(steps, p.y, .02);\n    vec3 stepColor = STEP_TOP_MAT;\n\n    float warning = -fBox2(p.xz, vec2(stairWidth - .01, stairRadius - .02));\n    warning = -(abs(p.z) - stairRadius + .025);\n    stepColor = mix(stepColor, STEP_YELLOW_MAT, 1.-step(0., warning));\n\n    p.y += .01;\n    vec3 edgeColor = mix(STAIR_BASE_MAT, STEP_MAT, smoothstep(stairRadius * -.6, 0., p.y));\n    stepColor = mix(stepColor, edgeColor, 1.-step(0., p.y));\n    p = pp;\n\n    // Dummy\n    p.z -= stairSize;\n    steps = min(steps, length(p.yz) - stairRadius);\n\n    // Limit width\n    steps = max(steps, p.x - stairWidth);\n\n    color = mix(color, stepColor, step(0., d - steps));\n    d = min(d, steps);\n    p = pp;\n\n    p.x -= radius;\n    float handrailHeight = .14;\n    float handrail = fBox2(p.xy, vec2(handrailWidth, handrailHeight));\n    vec3 handrailColor = mix(STAIR_BASE_MAT, HANDRAIL_MAT, smoothstep(0., handrailHeight * 2., p.y));\n    handrailColor = mix(handrailColor, HANDRAIL_MAT, step(0., p.x + handrailWidth * .75));\n    color = mix(color, handrailColor, step(0., d - handrail));\n    d = min(d, handrail);\n    p = pp;\n\n    d = max(d, -p.y);\n    return Model(d, color, vec2(0), .2, 3);\n}\n\nbool AO_PASS = false;\n\nModel fModel(vec3 p) {\n\n    float curveLen = 14.;\n    pModTrefoil(p, curveLen);\n    pR(p.xy, -time * PI * 2.);\n\n    float radius = .28;\n    float outer = length(p.xy) - radius;\n    float eps = .02;\n\n    // Overstep can happen when we're past one part of the curve,\n    // but still moving torards another part. Avoid this by stepping\n    // to the inside edge of the curve tube\n    float d = -outer + eps * 2.;\n\n    // Don't model the whole train/track/stairs when we're outside the trefoil\n    if ( ! AO_PASS) {\n        if (outer > eps) {\n            return Model(outer, vec3(.2), vec2(0), 0., 0);\n        }\n    } else {\n        // Disable the shortcut and overstep hack\n        // when calculating ambient occlusion\n        d = 1e12;\n    }\n\n    p.y -= .05;\n    Model model = mTrainSide(p, curveLen, radius);\n    p.x = abs(p.x);\n\n    // Don't model the stars when we're in the 'impossible channel'\n    // that the tracks carve\n    if ( ! pastThreshold) {\n        Model stair = mStairSide(p, curveLen, radius);\n        model = opU(model, stair);\n    }\n\n    // Cut the geometry to remain inside the trefoil tube\n    model.dist = max(model.dist, outer);\n\n    // Apply the overstep hack\n    model.dist = min(model.dist, d);\n\n    return model;\n}\n\nfloat focalLength;\n\nModel map(vec3 p) {\n    pR(p.xy, .39 * PI * 2. + time * PI * 2. * 2./3.);\n\n    float scale = focalLength;\n    p *= scale;\n    Model model = fModel(p);\n    model.dist /= scale;\n    return model;\n}\n\n\n// --------------------------------------------------------\n// NOVA graffiti\n// --------------------------------------------------------\n\nfloat fNova(vec2 p, float weight) {\n\n    float d = 1e12;\n    vec2 p2 = p;\n    vec2 p3 = p;\n    float arrow;\n\n    // N\n    p3 = p;\n    d = min(d, fBoxy(p, vec2(.6, .5)));\n    p.x -= .1;\n    pR45(p);\n    d = max(d, fBoxy(p, vec2(1., .6)));\n    p = p3;\n    p.x += .03;\n    d = max(d, -fBoxy(p - vec2(.2, .5), vec2(weight/2.,.6)));\n    d = max(d, -fBoxy(p + vec2(.2, .5), vec2(weight/2.,.6)));\n    p = p2;\n\n    // O\n    p.x -= .9;\n    p2 = p;\n    float O = fBoxy(p, vec2(.5,.6));\n    pR45(p);\n    O = max(O, vmax(abs(p)) - .55);\n    O = max(O, -d + weight);\n    d = min(d, O);\n    p = p2;\n\n    p += vec2(.25,-.2);\n    p3 = p;\n    p.y *= 1.25;\n    pR45(p);\n    arrow = vmax(p);\n    p = p3;\n    arrow = max(arrow, fBoxy(p, vec2(.1, 1.)));\n    d = max(d, -arrow + weight);\n    d = min(d, arrow);\n    p = p2;\n    d = min(d, fBoxy(p - vec2(-.1,-.4), vec2(.25,.15)));\n    d = max(d, -p.y - .5);\n\n    // V\n    p.x -= .8;\n    p2 = p;\n    p.y += .95;\n    p.x = abs(p.x);\n    pR(p, -.42);\n    float V = p.x;\n    p = p2;\n    V = max(V, abs(p.y) - .6);\n    p.y -= .6;\n    p.x -= .025;\n    V = max(V, -fBoxy(p, vec2(weight/2., .75)));\n    p = p2;\n    p.x -= .075;\n    p.y -= .3;\n    V = max(V, -vmax(p * vec2(1,-1)));\n    d = max(d, -V + weight);\n    d = min(d, V);\n    p = p2;\n\n    // A\n    p.x -= .75;\n    p2 = p;\n    p.y += .1;\n    float A = fBoxy(p, vec2(.45, .4));\n    p = p2;\n    A = max(A, -V + weight);\n    d = min(d, A);\n    p = p2;\n\n    p -= vec2(-.3, .2);\n    arrow = abs(p.y) - .125;\n    p.y -= .05;\n    pR45(p);\n    pR(p, -.3);\n    arrow = max(arrow, -p.x * 1.5);\n    d = max(d, -arrow + weight);\n    d = min(d, arrow);\n    p = p2;\n    p.x -= .3;\n    d = min(d, fBoxy(p, vec2(.15, .3)));\n    p = p2;\n    d = max(d, p.x- .45);\n    pR45(p);\n    d = max(d, p.x - .43);\n\n    p = p2;\n    d = max(d, -fBoxy(p + vec2(-.05,.23), vec2(.1, weight/2.)));\n\n    return d;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 rayOrigin;\n    float rayLength;\n    vec3 rayDirection;\n};\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    AO_PASS = true;\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 drawNova(vec3 col, vec2 uv) {\n    float scale = .3;\n    uv *= -1.;\n    uv /= scale;\n    uv.y -= .5;\n    uv.x /= 1.4;\n    uv.x += 1.2;\n\n    vec2 uv2 = uv;\n    pR(uv2, PI * .25);\n    vec2 warp = sin((uv2 + .25 + time) * 5.) * .1;\n    uv += warp;\n\n    float d = fNova(uv, .133);\n    float dOffset = fNova(uv - vec2(.05,-.1), .133);\n\n    d *= scale;\n    dOffset *= scale;\n\n    col = mix(col, vec3(.3), smoothstep(.005, .0, d - .02));\n    col = mix(col, vec3(.0), smoothstep(.005, .0, dOffset + .01));\n\n    // Outline\n    d = max(d - .04, -d + .01);\n    col = mix(col, TRAIN_WHITE, smoothstep(.005, .0, d));\n\n    return col;\n}\n\nvec3 render(Hit hit, vec3 col) {\n    if ( ! hit.isBackground) {\n        float ao = calcAO(hit.pos, hit.normal);\n        col = hit.model.material;\n\n        if (hit.model.id == 1) {\n            col = drawNova(col, hit.model.uv);\n        }\n\n        vec3 diffuse = mix(vec3(.5,.5,.6) * 1., vec3(1), ao);\n        col *= diffuse;\n    }\n    return col;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 3.;\nconst float INTERSECTION_PRECISION = .0001;\nconst int NUM_OF_TRACE_STEPS = 150;\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nHit raymarch(vec3 rayOrigin, vec3 rayDirection){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float rayLength = 0.;\n    Model model;\n\n    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(rayOrigin + rayDirection * rayLength);\n        currentDist = model.dist;\n        rayLength += currentDist * (1. - model.underStep);\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (rayLength > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = rayOrigin + rayDirection * rayLength;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(\n        model,\n        pos,\n        isBackground,\n        normal,\n        rayOrigin,\n        rayLength,\n        rayDirection\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nfloat backgroundMap(vec2 uv) {\n    float scale = 1.5;\n    float repeat = 3.55;\n\n    uv.y *= -1.;\n    uv /= scale;\n\n    vec2 uv2 = uv;\n    uv.x += time * repeat;\n    vec2 uv3 = uv;\n\n    pMod1(uv.x, repeat);\n    uv.x += 1.2;\n\n    pR(uv3, PI * .5);\n    uv3 -= time * repeat;\n\n    vec2 warp = vec2(0);\n    warp += sin((uv3 / repeat * PI * 1.) * 2.) * .2;\n    warp *= sin(uv2.x * PI * 1.5 + PI / 2.) * .5 + .5;\n    warp += sin(uv2 * PI + PI / 2.) * .1;\n\n    uv += warp;\n\n    float d = fNova(uv, .06) * scale;\n\n    return smoothstep(-0.01, .0, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = iTime;\n    time *= .25;\n    time = mod(time, 1.);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    p.y *= -1.; // Last minute adjustment, put the train on top\n    p.y -= .03;\n\n    vec3 camPos = vec3(-1.,0,.25) * .95;\n    vec3 camTar = vec3(0,-.0025,0);\n    vec3 camUp = vec3(0,0,1);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    focalLength = 18.191446;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    vec3 bg = mix(vec3(1), TRAIN_WINDOW, 1. - backgroundMap(p));\n\n    Hit hit = raymarch(camPos, rayDirection);\n    vec3 color = render(hit, bg);\n\n    color = pow(color, vec3(1.,.9,.8)); // Brighten and tint a little blue\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n\n    fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}