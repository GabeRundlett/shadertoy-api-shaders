{
    "Shader": {
        "info": {
            "date": "1631613280",
            "description": "Trying to master the art of placing items on a noise generated ground - and not float above or crash under. \n// also I guess I'm still tweaking this - lol, hard to put a shader down.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sK3DR",
            "likes": 31,
            "name": "Polygon Landscapes",
            "published": 3,
            "tags": [
                "draftdiamondsancds"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 593
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Polygon Landsacpes\n    9/13/21 @byt3_m3chanic\n    \n    Putting stuff on the ground and making it look half \n    way natural is hard, beginning experiments with it.\n    \n    need better noise functions...\n    \n    Rock shape/object from @gaz https://twitter.com/gaziya5/status/1436924535463309318\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    65.\n#define MIN_DIST    .0005\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat hash21(vec2 p) {\n    // @Dave_Hoskins - Hash without sine\n    // but it's HEAVY compile time / sadly and it looks better..\n    // so using other low cost hash for now..\n    \n\t//vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //p3 += dot(p3, p3.yzx + 33.33);\n    //return fract((p3.x + p3.y) * p3.z);\n    return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); \n}\n\nfloat noise (in vec2 uv) {\n    // @morgan3d https://www.shadertoy.com/view/4dS3Wd\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1., 0.));\n    float c = hash21(i + vec2(0., 1.));\n    float d = hash21(i + vec2(1., 1.));\n    vec2 u = f;// * f * (3.-2.*f);  @Shane's tip for polygonized look..\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b)* u.x * u.y;\n}\n\n//generate terrain using above noise algorithm\nfloat fbm( vec2 p, float freq ) {\t\n\tfloat h = -1.5;\n\tfloat w = 2.50;\n\tfloat m = 0.25;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noise((p * m));\n\t\tw *= 0.5; m *= 2.0;\n\t}\n\treturn h;\n}\n\nfloat gaz( vec3 p, float s) {\n    float e = abs(p.x+p.y)+abs(p.y+p.z)+abs(p.z+p.x)+abs(p.x-p.y)+abs(p.y-p.z)+abs(p.z-p.x)-s;\n    return e/3.5;\n}\n\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat box(vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//http://mercury.sexy/hg_sdf/\nconst float angle = 2.*PI/6.;\nconst float hfang = angle*.5;\nvoid mpolar(inout vec2 p) {\n    float a = atan(p.y, p.x) + hfang;\n    float c = floor(a/angle);\n    a = mod(a,angle) - hfang;\n    p = vec2(cos(a), sin(a))*length(p);\n} \n\n//globals\nvec3 hitPoint,hit;\nvec2 gid,sid;\nfloat mvt = 0.,snh,gnh;\nmat2 turn,wts;\n\nconst float sz = .325;\nconst float hf = sz*.5;\nconst float db = sz *2.;\nconst float detail = 4.;\nconst float pwr = 1.75;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    p.y+=4.;\n    p.x+=mvt;\n    float ter = fbm(p.xz*sz,detail)*pwr;\n    float d2 = p.y - ter;\n    \n    if(d2<res.x) {\n       res = vec2(d2,2.);\n       hit=p;\n       gnh=ter;\n    }\n\n    vec2 id = floor(p.xz*sz) + .5;    \n    vec2 r = p.xz - id/sz;\n    vec3 q = vec3(r.x,p.y,r.y);\n    float hs = hash21(id);\n    float xtr = fbm(id,detail)*pwr;\n    vec3 qq=q-vec3(0,xtr+.2,0);\n\n    mat2 htn = rot(-hs*PI2);\n    qq.yz*= htn;\n    qq.xz*= htn;\n\n    float df = gaz(qq,4.5*hs*hs);\n    if(df<res.x && hs>.5 && xtr>1.75) {\n        res=vec2(df,3.);\n        hit=p;\n        gnh=xtr;\n        gid=id;\n    }\n    \n    float zz = 1.25;\n    vec2 fid = floor(p.xz*zz) + .5;    \n    vec2 fr = p.xz - fid/zz;\n    vec3 fq = vec3(fr.x,p.y,fr.y);\n    \n    hs = hash21(fid);\n    qq=fq-vec3(0,ter+.001,0);\n\n    mpolar(qq.xz);      \n    float adjust = sin(qq.x*12.);\n    float flwr= box(qq,vec3(.3,smoothstep(.01,.35,.035*adjust),.035*adjust));\n    if(flwr<res.x && hs<.1 ) {\n        res=vec2(flwr,4.);\n        hit=qq;\n        gnh=ter;\n        gid=fid;\n    }\n\n    float cells = 8.;\n    vec3 qz = p-vec3(mvt,7.25,0);\n    qz.xz*=turn;\n    // Polar Repetion \n    // @Shane showed me this in one of my first\n    // shaders!\n    float a = atan(qz.z, qz.x);\n    float ia = floor(a/6.2831853*cells);\n    ia = (ia + .5)/cells*6.2831853;\n\n    float ws = -mod(ia,.0);\n    float cy = sin( ws*4. + (T * .25) * PI) * 1.5;\n    qz.y +=cy;\n\n    qz.xz *= rot(ia);\n    qz.x -= 6.5;\n  \n    wts = rot(ws+T);\n    qz.zy*=wts;\n    qz.xz*=wts;\n\n    float dx = zag(qz,.25);\n    if(dx<res.x) {\n        res=vec2(dx,5.);\n        hit=qz;\n        gnh=ws;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tfloat tx = hash21(floor(p.xy));\n    float ty = hash21(floor(p.zx));\n    float tz = hash21(floor(p.yz));\n    return vec3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 glintz( vec3 lcol, vec3 pos, vec3 n, vec3 rd, vec3 lpos, float fresnel) {\n    vec3 mate = vec3(0);\n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    vec3 tcoord;\n    float pw,q,anisotropy;\n \n    //build layers\n    for(int i = 0; i < 2;i++) {\n\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n        \n        vec3 aniso = vec3(vor3D(tcoord.zyx*pw,n).yy, vor3D(tcoord.xyz*vec3(pw,-pw,-pw),n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n \n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n    return  mix(light*vec3(0.3), vec3(.05), fresnel) + glints + lcol * .3;\n}\n\n// compact sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, float ison) { \n    rd.y+=.2;\n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n\n    vec3 Rayleigh = vec3(1), Mie = vec3(1); \n    // rayleigh / mie\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1), betaM = vec3(4e-2); \n    float zAng = max(2e-6, rd.y);\n    // scatter - Klassen's model.\n    vec3 extinction = exp(-(betaR*1. + betaM*1.)/zAng);\t\n    vec3 col = 2.*(1. - extinction);\n    // dist clouds\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 uv = (ro + t*rd).xz;\n\tif(t>0.&&ison>0.) {\n        col = mix(col, vec3(3), smoothstep(1.,.475,  fbm(5.*uv/1e5,5.))*\n                                smoothstep(.15, .85, rd.y*.5 + .5)*.4);  \n    }\n\n    return clamp(ACESFilm(col), 0., 1.);\n} \n\nvec3 sky = vec3(0);\n\nvec3 hue(float a, float b, float c) {\n    return b+c*cos(PI2*a*(vec3(1.25,.5,.25)*vec3(.99,.97,.96))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n\n    float  m = 0.;\n    vec3 p = ro;\n    for (int i = 0; i<128;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32 ? ray.x*.25 : ray.x*.75; \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    sid=gid;\n    snh=gnh;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n      \tvec3 n = normal(p, d);\n        \n        vec3 lpos = vec3(-11.,15,18.);\n        vec3 l = normalize(lpos-p);    \n        float diff = clamp(dot(n,l),0.,1.);\n        float shdw = 1., t = .01;\n\n        for(int i=0; i<24; i++){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) {shdw = 0.; break;}\n            shdw = min(shdw, 14.*h/t);\n            t += h * .8;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        float fresnel = pow(1.0 + dot(n,rd), 2.0);\n        fresnel = mix( 0.0, 0.95, fresnel );\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.5 * pow(max(dot(view, ret), 0.), 24.);\n\n        ref=vec3(.0);\n        vec3 h = vec3(.5);\n        \n        if(m==2.) {\n            vec3 c = mix(vec3(0.647,0.573,0.192),vec3(0.082,0.459,0.145),clamp(.1+snh*.5,0.,1.));\n            h = glintz(c, hitPoint*.05, n, rd, l, fresnel);\n        }\n        if(m==3.) {\n            h = clamp(hue((snh+fresnel)*3.25,.80,.15)*.85,vec3(.1),vec3(1.));\n            ref = h-fresnel;\n        }\n        if(m==4.) {    \n            h = vec3(0.329,0.580,0.020);\n            ref = h-fresnel;\n        }\n        if(m==5.) {    \n            h = vec3(0.286+fresnel,0.576+fresnel,0.953);//hue((snh+fresnel)*3.25,.65,.35);\n            ref = h-fresnel;\n        }\n        C += h * diff+spec;\n        C = mix(vec3(0.392,0.502,0.565),C,  exp(-.000015*d*d*d));\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    \n    C=clamp(C,vec3(.03),vec3(1.));\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    mvt= 280.;//+T*.733;\n    turn = rot(T*.2);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float sf = .5*sin(T*.1);\n    vec3 ro = vec3(0,1.65,13.+sf);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy == vec2(0) ? .0 : .07+(M.y/R.y * .0625 - .03125) * PI;\n    float y = M.xy == vec2(0) ? .0 : -(M.x/R.x * .5 - .25) * PI;\n    float sx = .3*cos(T*.1);\n    mat2 rx = rot(x), ry=rot(y+sx);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n    \n    // sky and vars\n    sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fill=vec3(1.);\n    \n    // ref loop @BigWIngs\n    float d =0.;\n    float a =0.;\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d);\n        C += pass.rgb*fill;\n        fill*=ref;\n        if(i==0.)a=d;\n    }\n\n    C = mix(sky,C, exp(-.000015*a*a*a));\n    C = pow(C, vec3(.4545));\n    C = clamp(C,vec3(.03),vec3(1.));\n    O = vec4(C,1.0);\n}\n// end\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}