{
    "Shader": {
        "info": {
            "date": "1677620503",
            "description": "A cut-down version of the GLSL SDF code for the hand I made in my Terminator 2 shader (https://www.shadertoy.com/view/mdt3D7) - Hopefully someone might find it 'handy'. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "csd3zX",
            "likes": 38,
            "name": "Handy SDF",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "hand",
                "fingers"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "// 'Handy SDF' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/csd3zX\n//\n// Based on my Terminator 2 shader: https://www.shadertoy.com/view/mdt3D7\n//\n// Most component SDFs based on iq's awesome examples.\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 bend(vec3 p) {\n\tfloat c = cos(-.3 * p.x),\n\t      s = sin(-.3 * p.x);\n\tp.xz *= mat2(c, s, -s, c);\n\treturn p;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p) {\n\tvec2 d = abs(vec2(length(p.yz), p.x)) - vec2(.06, .15);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tr *= 1. - p.x / h * .14;\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tri(vec3 p, vec3 a, vec3 c) {\n\tconst vec3 b = vec3(.06, 0, 0);\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot3(ba * sat(dot(ba, pa) / dot3(ba)) - pa), dot3(cb * sat(dot(cb, pb) / dot3(cb)) - pb)), dot3(ac * sat(dot(ac, pc) / dot3(ac)) - pc)) : dot(n, pa) * dot(n, pa) / dot3(n));\n}\n\n// Simple articulated bone.\nfloat bone(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xz *= rot;\n\tfloat d = cap(p, h, r);\n\tp.x -= h;\n\treturn d;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n// SDF of the hand.\nfloat sdf(vec3 p) {\n\tfloat d, l,\n\t      curl = 1. - iMouse.y / R.y;\n\tp.xy *= rot(1.8 - iMouse.x / R.x);\n\tvec3 r,\n\t     q = p + vec3(.25, -.1, .07);\n\tq.xy *= mat2(.49757, .86742, -.86742, .49757);\n\td = bone(q, mat2(.98007, -.19867, .19867, .98007), .42, .04 - .07 * S(.1, .5, q.x));\n\tq.yz *= mat2(.16997, -.98545, .98545, .16997);\n\td = smin(d, bone(q, rot(.3 * curl - .5), .26, -.025), .04);\n\tfloat h = cyl(q);\n\td = smin(d, bone(q, mat2(.995, -.09983, .09983, .995), .22, -.03 - .065 * S(.1, .25, q.x) * S(.05, -.08, q.z)), .02);\n\tp = bend(p);\n\tr = vec3(.37, .47 - S(.1, -.4, p.x) * .15, .12);\n\td = smin(d, box(p, r - .12), .16);\n\tp.x -= r.x;\n\tcurl = S01(curl * (1. + step(p.y, 0.) * .3));\n\td = smin(d, tri(p, vec3(0, r.y - .12, 0), vec3(0, .12 - r.y, 0)), .05);\n\td -= .12;\n\tp.xz *= rot(-.2 - curl * .63);\n\tl = 1. + step(0., p.y) * .1 + step(.25, p.y) * .2;\n\tp.y = -abs(p.y);\n\tp.xz -= .05;\n\tq = p;\n\tq.y += r.y * .5 - .12;\n\tq.xy *= mat2(.9998, -.02, .02, .9998);\n\tmat2 r1 = rot(-.7 * curl),\n\t     r2 = rot(-1.4 * curl);\n\td = smin(d, bone(q, r1, .32 * l, .105), .06);\n\td = smin(d, bone(q, r2, .17 * l, .09), .01);\n\td = smin(d, bone(q, r1, .13 * l, .08), .01);\n\tq = p;\n\tq.y += r.y - .12;\n\tq.z += .07;\n\tq.xy *= mat2(.995, -.09983, .09983, .995);\n\td = smin(d, bone(q, r1, .19 * l, .105), .06);\n\td = smin(d, bone(q, r2, .13 * l, .09), .01);\n\td = smin(d, bone(q, mat2(1, 0, 0, 1), .12 * l, .08), .01);\n\treturn min(h, d) - .01;\n}\n\n\n// Calculate a normal.\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h);\n\t}\n\n\treturn normalize(n);\n}\n\n// Simple ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec2 h = vec2(.1, 1);\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p);\n\n\treturn sat(min2(ao / h));\n}\n\n// Set the color.\nvec3 lights(vec3 p, vec3 rd, vec3 n) {\n\tvec3 l,\n\t     ld = normalize(vec3(0, -10, -6) - p);\n\tfloat _ao = ao(p, n), fre = S(1., .7, 1. + dot(rd, n));\n\tl = sat(vec3(dot(ld, n), dot(-ld.xz, n.xz), n.y));\n\tl.xy = .1 + .9 * l.xy;\n\tl *= .1 + .9 * _ao;\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), 1e2);\n\treturn sum2(l.xy) * vec3(1, 1.11, 1.5) * fre;\n}\n\n// Simple ray marhcing loop.\nvec3 march(vec3 p, vec3 rd) {\n\tfloat d = 0.;\n\tfor (float i = min(iTime, 0.); i < 64.; i++) {\n        // Background.\n\t\tif (d > 64.)\n            return vec3(length(rd.xy) * .2);\n        \n\t\tfloat h = sdf(p);\n\t\tif (abs(h) < 1e-4) break;\n\t\td += h;\n\t\tp += h * rd;\n\t}\n\n\treturn pow(max(vec3(0), lights(p, rd, N(p, d))), vec3(.4545));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = 0.0;\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tfloat st = S(0., 15., t);\n\tvec3 lookAt = vec3(0, 0.3, 0),\n\t     ro = vec3(.5, .001, -2);\n\tfragColor = vec4(march(ro, rayDir(ro, lookAt, uv)), 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}