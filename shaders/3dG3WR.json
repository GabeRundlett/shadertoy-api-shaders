{
    "Shader": {
        "info": {
            "date": "1569953156",
            "description": "like inking but with shader. Today the theme is Ring !",
            "flags": 64,
            "hasliked": 0,
            "id": "3dG3WR",
            "likes": 7,
            "name": "Shadertober 01 Ring",
            "published": 3,
            "tags": [
                "ring",
                "inktober",
                "shadertober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 448
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER #01 Ring\n// Poulet Vert 01/10/2019\n// using code from Leon, iq\n\n#define VOLUME 0.001\n#define PI 3.14159\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat uSDF(float s1, float s2) { return min(s1, s2);}\n\nfloat sSDF( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRing( vec3 p, vec2 t, float s)\n{\n    float c = 0.0;\n    vec3 pr = p + vec3(0.0, -0.15, 0.0);\n    pr.xy *= rot(PI/2.);\n    float c1 = sdCappedCylinder(pr, t.x, t.y);\n    float c2 = sdCappedCylinder(pr, t.x-s, t.y+s);\n    return sSDF(c2,c1);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\n\n\nfloat map(vec3 pos)\n{\n    float t = 0.0;\n    \n    vec3 ringPos = pos + vec3(1.8, -1.15, 0.0);\n    t = sdRing(ringPos, vec2(0.3, .05), .09);\n    \n    vec3 wallPos = pos + vec3(1.8, 0.0, 0.0);\n    float rightWall = sdBox(wallPos, vec3(1.0, 8., 4.0));\n    vec3 subWallPos = pos + vec3(0.0, -3.5, 0.0);\n    rightWall = sSDF(sdBox(subWallPos, vec3(5.0, 2.5, 2.0)), rightWall);\n    \n    wallPos = pos + vec3(-3.0, 0.0, -4.0);\n    float backgroundWall = sdBox(wallPos, vec3(5.0, 8.0, 1.0));\n    \n    t = uSDF(t, rightWall);\n    t = uSDF(t, backgroundWall);\n    \n    return t;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<64 ; i++)\n    {\n        float ray = map(ro + rd * t);\n        \n        if(ray < (0.0001*t))\n        {\n            return t;\n        }\n        \n        t += ray;\n    }\n    \n    return -1.0;\n}\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 GetNormal (vec3 p) \n{ \n    vec2 e = vec2(0.01, 0.0); \n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        )); \n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 screenUV)\n{\n    float t = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(t == -1.0)\n    {\n        col = vec3(rd.y);\n        vec2 rain = screenUV;\n        rain *= rot(PI/16.);\n        rain.x *= 100.;\n        \n        float randRain = fract(sin(floor(rain.x)));\n        col = vec3(step(fract(rain.x), .5)*(fract(rain.y+iTime*randRain)));\n        col = mix(vec3(0.0, 0.1, 0.2), vec3(0.0, 0.44, .94), col.r);\n        col *= .5;\n        \n    }\n    else\n    {\n        vec3 pos = ro + rd * t;\n        vec3 N = GetNormal(pos);\n        vec3 L = vec3(-5.0, 5.0, 0.0);\n        float light = dot(N,  L)*.2;\n    \n        col = vec3(.5);\n        col *= light*.2 + .5;\n        col *= GetShadow(pos, L, 4.);\n        \n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cp = vec3(3.0, 2.0, -4.0);\n    cp.x += sin(iTime*0.05)*0.52;\n    vec3 ct = vec3(1.0, 2.5, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = vec3(length(uv));\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    col = Render(cp, vd, screenUV);\n    \n    // compositing\n    col *= 1.-vec3(step(screenUV.x, .4)); // COMPOSITING CHEAT CODE\n    \n    \n    \n    col.x = .2*screenUV.x; // horizontal red ramp\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 19792,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/tauqeer-ahmad-waheedi/relaxing-rain-and-thunder"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}