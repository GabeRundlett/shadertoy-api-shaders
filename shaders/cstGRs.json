{
    "Shader": {
        "info": {
            "date": "1677698198",
            "description": "Simple test of periodic piecewise C1 cubic akima spline interpolation of points.\nYou can move one of the points with mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "cstGRs",
            "likes": 7,
            "name": "Periodic akima spline",
            "published": 3,
            "tags": [
                "2d",
                "spline",
                "cubic",
                "periodic"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "/*\nSee https://www.shadertoy.com/view/dd33RB for C1 quadratic spline variant\nSee https://www.shadertoy.com/view/Dd33zs for C2 cubic spline variant\nSee https://www.shadertoy.com/view/dd3Gzl for cubic cardinal spline variant\n*/\n\nconst vec3 dot_col = vec3(0);\nconst vec3 curve_col = vec3(0,1,0);\nconst vec3 bg_col = vec3(1);\n\nconst float dot_size = .01;\nconst float line_width = .003;\n\nconst float zoom = 2.;\n\nconst float eps = .00001;\n\n// compute matrix for getting parameters of quadratic polynomial with end points a b\nmat4 solution_matrix(vec2 a, vec2 b){\n\tmat4 matrix = mat4(a.x * a.x * a.x, b.x * b.x * b.x, 3. * a.x * a.x, 3. * b.x * b.x,\n\t                   a.x * a.x, b.x * b.x, 2. * a.x, 2. * b.x,\n\t                   a.x, b.x, 1., 1.,\n\t                   1., 1., 0., 0.);\n\n\treturn inverse(matrix);\n}\n\n// compute parameters of quadratic polynomial with end points a b and slope ma in a, slope mb in b\nvec4 compute_params(vec2 a, vec2 b, float ma, float mb){\n\tmat4 inv = solution_matrix(a, b);\n\n\treturn inv * vec4(a.y, b.y, ma, mb);\n}\n\n// approximate distance to cubic curve between a and b\nfloat cubic_distance_approx(vec2 uv, float a, float b, vec4 params){\n\tfloat val = uv.x * (uv.x * (uv.x * params.x + params.y) + params.z) + params.w;\n\tfloat diff = uv.x * (uv.x * 3. * params.x + 2. * params.y) + params.z;\n\n\tif(uv.x > a && uv.x < b){\n\t\treturn abs(uv.y-val) / length(vec2(diff,1));\n\t}\n\telse{\n\t\treturn 1e38;\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border = 2. / iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n\tuv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse -= .5;\n\tmouse.y *= iResolution.y / iResolution.x;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\t// choose sensible point for preview\n\tif(mouse.x < -.6 || mouse.x > .6){\n\t    mouse = vec2(-.1,.2);\n\t}\n\n\t// clamp mouse to allowed area\n\tmouse.x = clamp(mouse.x, -.37, .37);\n\n\t// points that are interpolated\n\tvec2 points[] = vec2[](vec2(-.8,-.2),vec2(-.6,.1),vec2(-.4,.2),mouse,vec2(.4,.0),vec2(.6,-.2));\n\n\t// repeat curve\n\tuv.x -= points[0].x;\n\tuv.x = mod(uv.x, points[points.length()-1].x - points[0].x);\n\tuv.x += points[0].x;\n\n\tvec3 color = bg_col;\n\n\tfloat curve_dis = 1e38;\n\tfloat point_dis = 1e38;\n\n\t// render splines and dots\n\tfor(int i=0;i<points.length();i++){\n\t\tpoint_dis = min(point_dis, distance(uv,points[i])-dot_size);\n\n\t\tint index0 = (points.length()+i-2)%points.length();\n\t\tint index1 = (points.length()+i-1)%points.length();\n\t\tint index2 = i;\n\t\tint index3 = (i+1)%points.length();\n\t\tint index4 = (i+2)%points.length();\n\t\tint index5 = (i+3)%points.length();\n\n\t\tfloat m0 = (points[index1].y - points[index0].y) / (points[index1].x - points[index0].x);\n\t\tfloat m1 = (points[index2].y - points[index1].y) / (points[index2].x - points[index1].x);\n\t\tfloat m2 = (points[index3].y - points[index2].y) / (points[index3].x - points[index2].x);\n\t\tfloat m3 = (points[index4].y - points[index3].y) / (points[index4].x - points[index3].x);\n\t\tfloat m4 = (points[index5].y - points[index4].y) / (points[index5].x - points[index4].x);\n\n\t\tfloat slope1, slope2;\n\n\t\tfloat denom1 = abs(m3-m2) + abs(m1-m0);\n\t\tif(abs(denom1) > eps){\n\t\t\tslope1 = (abs(m3-m2)*m1 + abs(m1-m0)*m2) / denom1;\n\t\t}\n\t\telse{\n\t\t\tslope1 = (m1 + m0) / 2.;\n\t\t}\n\n\t\tfloat denom2 = abs(m4-m3) + abs(m2-m1);\n\t\tif(abs(denom2) > eps){\n\t\t\tslope2 = (abs(m4-m3)*m2 + abs(m2-m1)*m3) / denom2;\n\t\t}\n\t\telse{\n\t\t\tslope2 = (m2 + m1) / 2.;\n\t\t}\n\n\t\tvec4 params = compute_params(points[index2], points[index3], slope1, slope2);\n\t\tcurve_dis = min(curve_dis, cubic_distance_approx(uv, points[index2].x, points[index3].x, params)-line_width);\n\t}\n\n\tcolor = mix(curve_col, color, smoothstep(-border/2.,border/2.,curve_dis));\n\tcolor = mix(dot_col, color, smoothstep(-border/2.,border/2.,point_dis));\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}