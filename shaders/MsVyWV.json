{
    "Shader": {
        "info": {
            "date": "1523435737",
            "description": "Etienne Jacob [url]https://goo.gl/2d7xvC[/url] displaces randomly a grid.\nBut procedural way from pixel uv is the reverse: gives too different look and can't fold. \nHere: trying to solve U = P + noise(P) for P.\nBut my naive algo still don't solve folds.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsVyWV",
            "likes": 16,
            "name": "inverse shaking grid ",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "displacement",
                "perlin",
                "art",
                "etiennejacob"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1046
        },
        "renderpass": [
            {
                "code": "// tuto by Etienne Jacob https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/\n// -> direct costly displacement U=D(P): https://www.shadertoy.com/view/MdyyWK\n// Usual pixel-procedural displacement P=D(U) is cheap but look bad: https://shadertoy.com/view/MsGyWK\n// Here I try to inverse U=D(P). a bit naively, though ;-)\n// D(P) = P + k(P).perlin(P)\n\n// --- pseudo perlin noise 3D\n\nint MOD = 1;  // type of Perlin noise\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define hash31(p) fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123)\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix( mix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),f.x),\n                       mix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),f.x), f.y), \n                  mix( mix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),f.x),\n                       mix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),f.x), f.y), f.z);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\nfloat fbm3(vec3 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 2; i++, p*=2.,a/=2.) \n        p.xy *= R, p.yz *= R,\n        v += a * noise3(p);\n\n    return v/.75;\n}\n// -------------------------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, V;\n    U = ( U+U - R ) / R.y;\n    O -= O;\n    \n    float t = 2.*iTime;\n    \n#define F(U) .5* max(1.-length(U),0.)   \\\n               * vec2( fbm3(vec3(U, t)), fbm3(vec3(U+5., t)) )\n\n  //for (int i=0; i< 5; i++)U += F(U);\n    for (int i=0; i< 5; i++)  U -= F(U), U += F(U);\n    \n    U = sin(60.*U); U = smoothstep(1.5,0.,abs(U)/fwidth(U));\n    O += U.x+U.y;  // * if you want points\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}