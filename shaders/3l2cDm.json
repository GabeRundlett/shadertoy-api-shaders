{
    "Shader": {
        "info": {
            "date": "1594571504",
            "description": "animating a solid noise with a distance field from a quad",
            "flags": 0,
            "hasliked": 0,
            "id": "3l2cDm",
            "likes": 3,
            "name": "Quad Glow",
            "published": 3,
            "tags": [
                "glow",
                "hover"
            ],
            "usePreview": 0,
            "username": "Paltoquet",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "// Author: Thibault Ober\n// Title: Glow Effect\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.142\n#define tableSize 255.0\n#define numLayers 5.0\n\nfloat rect(vec2 p, vec2 size) {  \n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat getAngle(vec2 pos) {\n    float coef = 1.0; //getCurrentTime();\n    float theta = atan(pos.y, pos.x);\n    theta = theta + coef * 2.0 * PI;\n    return theta;\n}\n\nfloat _smoothstep(float val){\n    return val * val * (3.0 - 2.0 * val); \n}\n\nfloat random (vec2 val) {\n    return fract(sin(dot(val,vec2(12.9898,78.233)))* 43758.513);\n}\n\nfloat noise(vec2 p){\n    float xi = floor(p.x); \n    float yi = floor(p.y); \n\n    float tx = p.x - xi; \n    float ty = p.y - yi; \n\n    float rx0 = mod(xi, tableSize); \n    float rx1 = mod(rx0 + 1.0, tableSize); \n    float ry0 = mod(yi, tableSize) ;\n    float ry1 = mod(ry0 + 1.0, tableSize); \n    \n    float c00 = random(vec2(rx0, ry0)); \n    float c10 = random(vec2(rx1, ry0)); \n    float c01 = random(vec2(rx0, ry1)); \n    float c11 = random(vec2(rx1, ry1));\n    \n    float sx = _smoothstep(tx);\n    float sy = _smoothstep(ty);\n    \n    float nx0 = mix(c00, c10, sx);\n    float nx1 = mix(c01, c11, sx);\n    \n    float result = mix(nx0, nx1, sy);\n    return result;\n}\n\nfloat fbm(vec2 pos){\n    float accelerator = 80.384;\n    float dt = iTime * accelerator;\n    \n    pos.x += dt;\n    pos.y += dt;\n    \n    float brownianNoise = 0.0; \n\tfloat rateOfChange = 2.0; \n    float baseFrequency = 0.03;\n    float noiseMax = 1.000;\n    float relight = 1.5 + sin(u_time) / 2.0;\n    for (float i = 0.0; i < numLayers; ++i) \n    {\n        float frequency = baseFrequency * pow(rateOfChange, i);\n        float amplitude = pow(rateOfChange, i);\n        brownianNoise += noise(pos * frequency) / amplitude; \n        noiseMax += 1.0 / amplitude;\n    } \n    \n    brownianNoise = brownianNoise / noiseMax;\n    brownianNoise *= relight;\n    brownianNoise = clamp(0.0, 1.0, brownianNoise);\n    \n    return brownianNoise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float width = 0.8;\n    vec2 screenPos = fragCoord;\n    vec2 st = screenPos/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    \n    float noise = fbm(screenPos);\n    float border = rect(st, vec2(width));\n    float glowRadius = 0.160;\n    float val = 0.0;\n    vec3 color = vec3(0.0);\n    if(border < glowRadius) {\n        vec4 firstColor = vec4(0.975,0.580,0.004,1.000);\n    \tvec4 secondColor = vec4(0.957,0.980,0.858,1.000);\t\n        float range = 1.0 - glowRadius;\n        float easing = 1.0 - border;\n        float coef = 1.0 / glowRadius;\n        float dist = (easing - range) * coef;\n        val = dist * noise;\n        \n        color = mix(firstColor.xyz, secondColor.xyz, val);\n        color = mix(vec3(0.0), color, dist);\n    } \n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}