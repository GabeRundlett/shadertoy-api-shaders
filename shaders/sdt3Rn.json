{
    "Shader": {
        "info": {
            "date": "1629211367",
            "description": "a simple laser effect",
            "flags": 0,
            "hasliked": 0,
            "id": "sdt3Rn",
            "likes": 2,
            "name": "A Simple Laser effect",
            "published": 3,
            "tags": [
                "3d",
                "laser"
            ],
            "usePreview": 0,
            "username": "wangxiaochen",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 32\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Light_pos vec3(5.,5.,9.)\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.1,0.5,0.9) );\n}\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\nfloat smin(float a,float b,float h){\n    float c=clamp((b-a)/h*0.5+0.5,0.,1.);\n    //return c;\n    return mix(b,a,c)-h*c*(1.0-c);\n}\n\nmat2 rot(float a){\n   float c=sin(a);\n   float s=cos(a);\n    return mat2(c,s,-s,c);\n    \n}\nfloat GetDist(vec3 p){\n   return 1.9*(max(0.,fbm(p*.3)-.35+.05*abs(sin(iTime))));\n}\nfloat rayMarch(vec3 ro,vec3 rd){\n    float d0=0.;\n    float T=1.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*d0;\n        float ds=GetDist(p)/32.;\n        T*=(1.-ds);\n        d0+=50.*ds*T;\n        if(T<.001)break;\n        //if(d0>MAX_DIST||ds<SURF_DIST)break;\n    }\n    return d0;\n}\nvec3 getNormal(vec3 p){\n    float l= GetDist(p);\n    vec2 cau=vec2(.01,0.);\n    vec3 n=normalize(vec3(l-GetDist(p-cau.xyy),\n                          l- GetDist(p-cau.yxy),\n                          l- GetDist(p-cau.yyx)\n                           ));\n    return n;\n    \n}\nfloat  getLight(vec3 p){\n    vec3 ld=Light_pos;\n    vec3 li=normalize(ld-p);\n    vec3 sn=getNormal(p);\n    float sh=rayMarch(p+sn*SURF_DIST*2.,li);\n    float dif=clamp(dot(sn,li),0.,1.) ;\n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 r0=vec3(0.,0.,5.);\n    vec3 rd=vec3(uv.x,uv.y-.2,1.);\n    vec3 col = vec3(1.);\n    col.xyz=vec3(1.)*rayMarch(r0,rd)*.09;\n    float d= rayMarch(r0,rd);\n    vec3 p=r0+rd*d;\n    vec3 n=getNormal(p);\n    float difu=getLight(p);\n     float ndotv=max(0.,dot(normalize(rd),n));\n    vec3 halfh=normalize(normalize(-rd)+normalize(Light_pos-p));\n    float ndothalfh=max(0.,dot(halfh,n));\n     col =mix(vec3(difu),spectrum(.4+ndothalfh),0.9);\n    col+=vec3(pow(ndothalfh,25.));\n    fragColor = vec4(col*difu,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}