{
    "Shader": {
        "info": {
            "date": "1644325229",
            "description": "Experimenting with instrument synthesis.",
            "flags": 8,
            "hasliked": 0,
            "id": "fdjyWt",
            "likes": 5,
            "name": "Music - Techno",
            "published": 3,
            "tags": [
                "music"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float bpm = 126.;\nfloat T;\nfloat seed;\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float t) {\n    float p = ((seed+=1.) + mod(t, 21.44352345) * 1500. + 50.0);\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat nf(float t, float freq) { return hash11(floor(t*freq)/freq); }\nfloat mixc(float a, float b, float r) { return mix(a, b, clamp(0., 1., r)); }\n\n//float note2freq(float note) { return 440. * exp2(-10./12.) * exp2(note/12.); }\nfloat note2freq(float note) { return 440. * exp2(-2./12.) * exp2(note/12.); }    // transposed to the current key\n\nfloat sinhz(float x) { return sin(6.2831*x); }\nfloat saw(float x) { return abs((fract(x-0.25)-0.5)*2.)*2.-1.; }\nfloat sawt(float x) { return fract(x-0.5)*2.-1.; }\n\nfloat kick(float t) { return t*40.*sin(0.8/(t+0.0001))*exp(-t*30.)*0.9; }\nfloat hh(float t) {\n    return hash11(mod(t,1./4500.))*t*200.*clamp(1.-t*100.,0.,1.);\n}\nfloat snare(float t) { return hash11(t)*sawt(t*40.)*smoothstep(0.08,0.,t); }\nfloat snare2(float t) { return hash11(t)*smoothstep(0.18,0.,t)*0.4; }\n\nfloat padsynth(float t, float note) {\n    float freq = note2freq(note);\n    float h1 = saw(freq*t) + saw(freq*t*2.)/2. + saw(freq*t*3.)/6. + saw(freq*t*4.)/5. + sawt(freq*t*8.)/10.;\n    float h2 = sinhz(freq*t) + sinhz(freq*t*2.)/2.;\n    return mixc(h1, h2, 1.-exp(-t*2.));\n}\n\nfloat basssynth(float t, float note, float soft) {\n    float freq = note2freq(note-24.);\n    float p = freq*t;   //    p = p/smoothstep(0.,0.1,p);\n    float h1 = sawt(p), h2 = sinhz(p);\n    return (mixc(h1, h2, t*15. + soft)+h2/3.)*exp(-t*12.);\n}\nfloat basssynth(float t, float note) { return basssynth(t, note, 0.); }\n\nfloat m(float repeat, float offset) { return mod(T - 60./bpm*4. * offset, 60./bpm*4. * repeat); }\nfloat m(float repeat) { return m(repeat, 0.); }\n#define T(a,b)   (float(a)/float(b))\n#define T1(a)    (1./float(a))\n#define M(a,b)   m(float(a)/float(b))\n#define M1(a)    m(1./float(a))\n#define MM(a,b,c,d)  m(float(a)/float(b), float(c)/float(d))\n\nfloat s(float offset, float len) { return step(60./bpm*4. * offset, T) * (1. - step(60./bpm*4. * (offset+len), T)); }\nfloat s(float offset) { return step(60./bpm*4. * offset, T); }\n\n#define DETUNE(FUNC, TIME, NOTE)  (FUNC(TIME, NOTE) + FUNC(TIME, NOTE+0.2) + FUNC(TIME, NOTE-0.1))/3.\n#define SYNTH(TIME, NOTE)               DETUNE(padsynth, TIME, NOTE)\n#define CHORD(TIME, N, N2, N3)         (SYNTH(TIME, float(N)) + SYNTH(TIME, float(N+N2)) + SYNTH(TIME, float(N+N3)))*0.6\n\nfloat drumpat() {\n    return 0.\n        + kick(M1(4))\n        + hh(M1(16))*0.2\n        + snare(m(T1(2), T1(4)))\n    ;\n}\n\nfloat pat1(float time) {\n    T = time;\n    T = m(8.);\n    return 0.\n        + drumpat()\n        + CHORD(m(1.),         0, 4, 7)*exp(-2.0*m(1.))\n        + CHORD(m(2., T(3,4)), 0, 4, 9)*exp(-3.5*m(2., T(3,4)))\n        + basssynth(M1(4), -12.)\n        + basssynth(m(T1(4), T1(8)), 0.)\n        + basssynth(m(1., -T1(16)), 0., 0.6)\n        + snare(m(4., -T(4,8)))\n        + snare(m(4., -T(3,8)))\n        + snare(m(4., -T(2,8))) + snare2(m(4., -T(2,8)))\n        + snare(m(4., -T(1,8)))\n        + snare(m(4., -T(1,16)))\n        ;\n}\n\nfloat pat2(float time) {\n    T = time;\n    T = m(8.);\n    return 0.\n        + drumpat()\n        + snare2(m(T1(2), T(1,4)))\n        + SYNTH(m(4.), 4.-12.) * exp(-0.5*m(1.))/2.\n        + SYNTH(m(4., 1.), -1.)* exp(-0.3*m(4., 1.))/2.  * s(1.)\n        + SYNTH(m(4., 2.), 2.) * exp(-0.2*m(4., 2.))/2. * s(2.)\n        + SYNTH(m(4., 3.), 4.) * exp(-0.1*m(4., 3.))/2.  * s(3.)\n        + basssynth(M1(4), -12. + 4.)\n        + basssynth(m(T1(1), T(3,16)), 0. + 4.)\n        + basssynth(m(T1(1), T(6,16)), 0. + 4.)\n        + basssynth(m(T1(1), T(8,16)), 0. + 4., 0.6)/2.\n        + basssynth(m(2., -T1(8)), 12. + 2., 0.9)\n        + basssynth(m(2., -T1(16)), 0. + 2., 0.6)\n        + snare(m(4., -T(4,8)))\n        + snare(m(4., -T(3,8)))\n        + snare(m(4., -T(7,16)))\n        + snare(m(4., -T(2,8)))\n        + snare(m(4., -T(1,8)))\n        + snare(m(4., -T(1,16)))\n        ;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    T = time;\n    seed = 10.;\n\n    float p1 = m(12.);\n    float p2 = m(12., 8.);\n    return vec2(\n        p1 < p2 ? pat1(p1) : pat2(p2)\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}