{
    "Shader": {
        "info": {
            "date": "1681877653",
            "description": "A zellij tile pattern.",
            "flags": 8,
            "hasliked": 0,
            "id": "Dld3zn",
            "likes": 4,
            "name": "Zellij pattern 5 (music)",
            "published": 3,
            "tags": [
                "fractal",
                "mosaic",
                "zellige"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a+fract(a/2.+.5))\n        //fract(a+fract(a*2.+.5)/2.)\n        //fract(a+fract(a*4.)/4.)\n        //abs(fract(a)-abs(.5-fract(a)))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    //a *= sign(mod(floor(a/2.),2.)-.5);\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(1.-sign(a.x)/2.,0.5+sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)+.5;\n    uv.x = mod(uv.x,.5)+2.75;\n    for(int k = 0; k < 9; k++){\n        //k += int(uv.y<uv.x);\n        //uv.x += float(int(uv.x*4.)>>2);\n        //if((k)%3 == 0) t2 *= 0.;\n\n        uv =\n            abs(.5+uv+t2)/1.5\n            //abs(.5+uv+t2)/1.5*(1.+mod(floor(uv.y),2.)/2.)\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5).yx\n            //-triangle_wave(uv+sign(.5-t2.x)+.5*sign(.5-uv.x)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        {uv=uv*sign(uv.y-uv.x);}\n        \n        //remove this line to make it gray\n        //if(uv.x<.5)\n        col.x =\n            max(sign(uv.x-t2.y),col.x)\n            //max(sign(uv.x-t2.y),1.-col.x)\n            //min(sign(uv.x-t2.y),col.x)\n            //max(distance(uv,t2+sin(iTime)),col.x)\n        ;\n        //if(t2.y>t2.x)\n        //if(uv.x>0.)\n        col =\n            abs(col.yzx/2.-float(b))\n            //vec3(col.zx,abs(uv.x*sign(t2.x-t2.y)-uv.y))\n        ;\n        //if(t2.x<t2.y) col=col.yzx;\n        //if(uv.x<uv.y) uv.x += .5;\n        //if(t2.x>t2.y) uv.x -= .5;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat fmod2(float a, float b){\n    return b*mod(floor(a),b);\n}\n\nfloat fmod1(float x, float y){\n    //x += floor((x*y)/8.);\n    //x += floor(hash11(floor(mod(floor(x/4.),y)))*8.);\n    /*\n    for(int i = 0; i < 3; i++){\n        x += mod(floor(x/2.),2.);\n        y += mod(floor(x/2.),2.);\n    }\n    */\n    //x += fmod2(x*4.,8.);\n    return\n        floor(mod(floor(x),y))\n        //mod(floor(floor(floor(x*2.)*y)/8.),y)\n        //floor(mod(floor(x*8.+floor(x/y)),y)/2.)*floor(mod(floor(x*8.),y/2.))\n        //mod(mod(floor(x/4.+2.),y*2.),8.)\n        //mod(mod(4.+floor(x),4.+floor(x/y)+y),y)\n        //floor(mod(floor(x),y)-mod(floor(x/2.),y))\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(fmod1(fmod1(a,b)+2.,fmod1(a/8.,b+4.)+2.),b)\n        //fmod1(a+fmod1(a/2.,b),b)\n    ;\n}\n//#define fmod(x,y) floor(mod(floor(x),y))\n//#define fmod(x,y) floor(mod(floor(x+floor(pow((1.5),y))),y))\n//#define fmod(x,y) floor(mod(floor(x),floor(y/2.)+2.))\n//#define fmod(x,y) floor(mod(floor(x+pow(2.,floor(y/2.))),y))\n//#define fmod(x,y) floor(mod(floor(x*2./y),y))\n//#define fmod(x,y) floor(mod(floor(x)*floor(x/8./y),y))\n//#define fmod(x,y) floor(sqrt(mod(floor(x),y*y)))\n\n//#define fmod(a,b) mod(floor(a*2./b)*floor(a),b)\n//#define fmod(x,y) floor(mod(floor(-x*2.)/y,y))\n#define floor1(x) fmod((x*pow(2.,fmod(x/8.,3.))),2.)\n#define fmod1(x,y) mod(floor1(-x/2.),y)\n\nfloat fract1(float a){\n    return\n        fract(a)\n        //fract(a*(1.+fmod(a*1.5,1.5)))\n        //fract(a+fract(a*2.)/2.)\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  \n  /*\n  for(int i = 0; i < 3;i++){\n      time += fmod(time*4.,2.);\n      //time += fmod(time*pow(2.,fmod(time*2.,4.)-1.),2.);\n  }\n  */\n  \n  \n  float\n  s2 = 8.,\n  t=\n      time*(2.-fmod(time+floor1(time/2.),2.))/4.\n      //time*(2.-fmod(time+floor1(time/8.)+floor1(time/2.),2.))/4.\n  ,\n  m1 =\n      fmod1(t*s2,s2)\n  ;\n  /*\n  for(int i = 0; i < 3; i++){\n      t += mod(floor(t*4.),2.)/2.;\n  }\n  */\n  //t = s2*pow(2.,fmod(t*2.+m1,2.))*t/(1.+fmod(m1+floor(t/2.),2.));\n  float m3 =\n      fmod(-t/(m1+.5),s2)\n      //floor(fmod(-t/(m1+.5),s2*2.)/2.)\n  ;\n\n  float a=\n      64.*((1.-sqrt(fract(t)/1.125)))*.2\n      //pow(2.,2.-log(fract(t)/2.))/2.\n      //64.*((1.-sqrt(fract(t-.5)/1.125)))*.2\n      //64.*pow((1.-(fract(t))),2.)\n  ,\n  nb =\n      //time*pow(2.,fmod(-t*8.+m3+1.,m3+1.)/5.+7.)\n      time*pow(2.,(m3)/5.+7.)\n  ;\n\n  return \n      //abs(.5-vec2(fract1(nb*.998),fract1(nb)))*a\n      abs(a/8.-abs(.5-vec2(fract1(nb*.998),fract1(nb)))*a/4.)\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}