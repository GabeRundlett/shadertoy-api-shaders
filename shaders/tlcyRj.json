{
    "Shader": {
        "info": {
            "date": "1609459255",
            "description": "2021 = 43*47 is a semiprime, in fact the product of two consecutive primes. If the semiprimes are drawn as a spiral, 2021 is an isolated point (see [url]https://oeis.org/A113688[/url])\n\nPress mouse button if you get bored waiting for the spiral to draw.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlcyRj",
            "likes": 4,
            "name": "2021 & the semiprime spiral",
            "published": 3,
            "tags": [
                "spiral",
                "2021",
                "semiprime"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 2021, Matthew Arcus, mla, 2021\n//\n// The square semiprime spiral: arrange the integers in a square spiral\n// and colour in the semiprimes. An isolated semiprime is one where none\n// of its 8 neighbours are semiprimes. 2021 (flashing in red) is an\n// isolated semiprime.\n//\n// Grid code from: https://www.shadertoy.com/view/3tc3zj by saidwho12\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint N = 4; // Pixels per square side\n\n// Get ring start number, from current ring width\nint K(int w) { return w > 1 ? 4+(w-2)*4 : 1; }\n\n// Get width of ring index\nint W(int i) { return i*2+1; }\n\nbool semiprime(int n) {\n  if (n < 2) return false;\n  int target = 2;\n  int count = 0;\n  for (int i = 2; i*i <= n; i++) {\n    while (n % i == 0) {\n      count++;\n      if (count > target) return false;\n      n /= i;\n      if (n == 1) return count == target;\n    }\n  }\n  // n is prime\n  return count == target-1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    \n    if (iMouse.z > 0.0) N = 1+int(16.0*iMouse.y/iResolution.y);\n    // Let's hope division by power of 2 is exact.\n    fragCoord = floor(fragCoord/float(N));\n   \tint x = int(fragCoord.x);\n   \tint y = int(fragCoord.y);\n    int i = max(abs(x), abs(y)); // Ring index\n    int w0 = W(i-1); // Ring below width\n    int w1 = W(i); // Ring current width\n    int h = w1/2;\n    int A = w0*w0;\n    \n    int v = sign(y) == -1 && y == -h && x > -h ? 3 : (sign(x) == 1 && x == h ? 0 : (sign(y) == 1 && y == h ? 1 : 2));  \n\n    int j;\n    \n    switch (v)\n    {\n        case 0:\n        j = y + h+2;\n        break;\n        \n        case 1:\n        j = -x + (h+1);\n        break;\n        \n        case 2:\n        j = -y + (h);\n        break;\n        \n        case 3:\n        j = x + (h-1);\n        break;\n    }\n    // Original is off by 2!\n    int n = A + v*w1 + j * int(i != 0) - 2;\n    \n    //float S = float(W(int(N)) * W(int(N)));\n    //float al = (float(n)) / S;\n    vec3 col = vec3(0);\n    if (n < iFrame || iMouse.z > 0.0) {\n      col = semiprime(n)?vec3(1):vec3(0);\n      if (iMouse.z > 0.0 && iMouse.x > 0.5*iResolution.x) col = 1.0-col;\n      if (n == 2021 && fract(iTime) < 0.5) col = vec3(1,0,0);\n    }\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}