{
    "Shader": {
        "info": {
            "date": "1482877206",
            "description": "Kleinian group limit set.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlVXzh",
            "likes": 39,
            "name": "Kleinian group limit set",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "JosLeys",
            "viewed": 2755
        },
        "renderpass": [
            {
                "code": "//By Jos Leys ( with the help of Knighty)\n\nvec3  background1Color=vec3(1.0,1.0,1.0);\nvec3  background2Color=vec3(1.0,1.0,0.5);\nvec2  ambientColor=vec2(0.5,0.3);\nvec3  color2=vec3(0.2,0.6,0.0);\nfloat specularExponent=4.;\nfloat specularity=0.8;\nvec3 from=vec3(0.0,0.975,-5.0);\n\n\n\nfloat box_size_x=1.;\nfloat box_size_z=1.;\nvec3 light=vec3(50,10,-50);\nfloat slice_start=-1.;\nfloat slice_end=1.;\nfloat fudge_factor=0.5;\n\n//sphere inversion\nbool SI=false;\nvec3 InvCenter=vec3(1,.96,0.);\nfloat rad=0.8;\n\nvec2 wrap(vec2 x, vec2 a, vec2 s){\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec3 z, inout float DF, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\tDF *= iR;//max(1.,iR);\n}\n\nfloat  JosKleinian(vec3 z)\n{\n    float KleinR = 1.94+0.05*abs(sin(-iTime*0.5));//1.95859103011179;\n   float KleinI = 0.03*cos(-iTime*0.5);//0.0112785606117658;\n\tvec3 lz=z+vec3(1.), llz=z+vec3(-1.);\n    float d=0.; float d2=0.;\n    \n    if(SI) {\n             z=z-InvCenter;\n\t\td=length(z);\n\t\td2=d*d;\n\t\tz=(rad*rad/d2)*z+InvCenter;\n            }\n\n\tfloat DE=1e10;\n\tfloat DF = 1.0;\n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1. ;     \n\tfor (int i = 0; i < 20 ; i++) \n\t{\n\t\tz.x=z.x+b/a*z.y;\n\t\tz.xz = wrap(z.xz, vec2(2. * box_size_x, 2. * box_size_z), vec2(- box_size_x, - box_size_z));\n\t\tz.x=z.x-b/a*z.y;\n               \n\t\t//If above the separation line, rotate by 180° about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec3(-b, a, 0.) - z;}\n        \n\t\t//Apply transformation a\n\t\tTransA(z, DF, a, b);\n\t\t\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-5) {break;}\n\t\t\n\t\t//Store prévious iterates\n\t\tllz=lz; lz=z;\n\t}\n\t\n\t\n\tfloat y =  min(z.y, a-z.y) ;\n\tDE=min(DE,min(y,0.3)/max(DF,2.));\n      if (SI) {DE=DE*d2/(rad+d*DE);}\n\treturn DE;\n}\n\n\n\nfloat trace(vec3 ro, vec3 rd, float start,inout bool hit) {\n    float dist=100.0;\n    float t =start;\n    for (int i = 0;  i < 200  ;i++) {\n        if (t>(-ro.z+slice_end)/rd.z) {hit=false; break;}\n        dist = JosKleinian(ro+t*rd);\n        if (dist<1./pow(10.,3.5)) {break;}\n        t += fudge_factor*dist;\n    }\n    return t;\n}\n\nvec3 blinnPhong(vec3 color, vec3 p, vec3 n)\n{\n\t// Ambient colour based on background gradient\n      float HALFPI=3.14159/2.;\n\tvec3 ambColor = clamp(mix(background2Color, background1Color, (sin(n.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0);\n\tambColor = mix(vec3(ambientColor.x), ambColor, ambientColor.y);\n\tvec3  halfLV = normalize(light - p);\n\tfloat diffuse = max(dot(n, halfLV), 0.0);\n\tfloat specular = pow(diffuse, specularExponent);\n\t\n\treturn ambColor * color + color * diffuse + specular * specularity;\n}\n\n\nvec3 generateNormal(float afst,vec3 rd, vec3 from)\n{\n\tfloat eps =0.001; bool hit=true;\n   \tvec3 ray=  from+rd*afst;\n\t\n\tfloat start=afst-.1;\n\t\n    vec3 ray1=from+vec3(eps,0,0)+ rd*trace(from+vec3(eps,0,0), rd,start,hit );\n\tvec3 ray2=from+vec3(0,eps,0)+ rd*trace(from+vec3(0,eps,0), rd,start,hit );\n\tvec3 ray3=from+vec3(-eps,0,0)+ rd*trace(from+vec3(-eps,0,0), rd,start,hit );\n\t\n\tvec3 n1=normalize(-cross(ray1-ray,ray2-ray));\n\tvec3 n2=normalize(-cross(ray2-ray,ray3-ray));\n\t\n\tvec3 n=(n1+n2)/2.;\n\treturn n;\n}\n\nvec3  detcol( vec3  ray_direction)   \n{\n\tbool hit=true;\n    float start=(-from.z+slice_start)/ray_direction.z;\n\tfloat afst= trace(from, ray_direction,start,hit);\n\tvec3 ray=from+afst* ray_direction;\n      \n\nif ( !hit) {return background1Color;\t }  \n\nelse {\t\n    vec4  color;\n\tvec3 normal = generateNormal(afst,ray_direction,from);\n\tcolor.rgb = blinnPhong(clamp(color2, 0.0, 1.0), ray, normal);\n\t\n\t// Shadows\n\t\tvec3 light_direction=normalize(ray-light);\n\t\tfloat startlight=(-light.z+slice_start)/light_direction.z;\n\t\tfloat afstlight= trace(light,light_direction,startlight,hit);\n\t\tif (abs(afstlight-length(light-ray))>0.001) {color.rgb *=0.8;}\n\t\n\t\n\treturn color.xyz;}\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (3.0)*uv-vec2(1.5,.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n   \n    vec3 rd = normalize(vec3(uv,0.)-from);\n\n    float start=(-from.z-1.)/rd.z;\n\n    \n    vec3 c =detcol(rd);\n\tfragColor = vec4(c, 1.0);\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}