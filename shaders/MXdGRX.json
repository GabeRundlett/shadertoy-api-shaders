{
    "Shader": {
        "info": {
            "date": "1716838586",
            "description": "CC0: Atari Windows Terminal Shader\nThe Atari rainbow logo as I remember it",
            "flags": 0,
            "hasliked": 0,
            "id": "MXdGRX",
            "likes": 19,
            "name": "Atari Windows Terminal Shader",
            "published": 3,
            "tags": [
                "windowsterminal"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 260
        },
        "renderpass": [
            {
                "code": "// CC0: Atari Windows Terminal Shader\n//  The Atari rainbow logo as I remember it\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float \n    outer = .0125*0.5\n  , inner = .0125*0.5\n  , full  = inner+outer\n  , pi    = acos(-1.)\n  , tau   = 2.*pi\n  ;\n\nconst vec3 \n    lightCol0 = HSV2RGB(vec3(0.58, 0.8, 2.))\n  , lightCol1 = HSV2RGB(vec3(0.68, 0.5, 2.))\n  , sunCol    = HSV2RGB(vec3(0.08, 0.8, 5E-2))\n  , lightPos0 = vec3(1.1, 1.-0.5, 1.5) \n  , lightPos1 = vec3(-1.5, 0, 1.5)\n  ; \n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// IQ's polynomial min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// IQ's segment\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n  float ik = 1.0/k;\n  float p = ik*(pos.y - 0.5*ik)/3.0;\n  float q = 0.25*ik*ik*pos.x;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat atari(vec2 p) {\n  p.x = abs(p.x);\n  float db = box(p, vec2(0.36, 0.32));\n\n  float dp0 = -parabola(p-vec2(0.4, -0.235), 4.0);\n  float dy0 = p.x-0.115;\n  float d0 = mix(dp0, dy0, smoothstep(-0.25, 0.125, p.y)); // Very hacky\n\n  float dp1 = -parabola(p-vec2(0.4, -0.32), 3.0);\n  float dy1 = p.x-0.07;\n  float d1 = mix(dp1, dy1, smoothstep(-0.39, 0.085, p.y)); // Very hacky\n\n  float d2 = p.x-0.035;\n  const float sm = 0.025;\n  float d = 1E6;\n  d = min(d, max(d0, -d1));;\n  d = pmin(d, d2, sm);\n  d = pmax(d, db, sm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {\n  const float z = 2.;\n  return atari(p/z)*z;\n}\n\nfloat hf(vec2 p) {  \n  float d0 = df(p);\n  float x = clamp(full+(d0-outer), 0., full);\n  float h = sqrt((full*full-x*x))/full;\n\n  return -0.5*full*h;\n}\n\nvec3 nf(vec2 p) {\n  vec2 e = vec2(sqrt(8.)/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nfloat mountain(float p) {\n  p*= 5.;\n  p += -1.+5E-3*TIME;\n  float h = 0.;\n  float a = 1.;\n  for (int i = 0; i < 3; ++i) {\n    h += a*sin(p);\n    a *= .5;\n    p = 1.99*p+1.;\n  }\n  \n  return 0.05*h+0.05;\n}\n\nvec3 layer0(vec3 col, vec2 p, float aa, float tm) {\n  vec3 \n      ro    = vec3(0,0,tm)\n    , rd    = normalize(vec3(p,2))\n    , ard   = abs(rd)\n    , srd   = sign(rd)\n    ;\n \n  for (float i = 1.; i < 10.; ++i) {\n    float tw = -(ro.x-6.*sqrt(i))/ard.x;\n    if (tw>1E3) continue;\n\n    vec3 wp = ro+rd*tw;\n    \n    vec2 \n        wp2 = (ro+rd*tw).yz*2E-2\n      , wn2 = round(wp2)\n      , wc2 = wp2 - wn2\n      ;\n\n    if (hash(wn2+i+.5*srd.x) < .5)\n      wc2 = vec2(wc2.y, -wc2.x);\n\n    float \n        fo  = smoothstep(-sqrt(.5), 1., sin(.1*wp.z+tm+i+srd.x))\n      , wd  = abs(min(length(wc2+.5)-.5, length(wc2-.5)-.5))-25E-3\n      ;\n\n\n    col += \n       (1.+sin(vec3(-4,3,1)/2.+5E-2*tw+tm))\n      *exp(-3E-3*tw*tw)\n      *fo\n      *25E-4/max(abs(wd), 3E-3*fo);\n  }\n\n\n  return col;\n}\n\nvec3 layer1(vec3 col, vec2 p, float aa) {\n  float d = df(p);\n  vec3  n = nf(p);\n\n  vec3 lcol = vec3(0.);\n  vec3 p3 = vec3(p, 0.);\n\n  vec3 ro = vec3(0.,0.,10.);\n  vec3 rd = normalize(p3-ro);\n  vec3 r = reflect(rd, n);\n  vec3 ld0 = normalize(lightPos0-p3);\n  vec3 ld1 = normalize(lightPos1-p3);\n\n  float spe0 = pow(max(dot(r, ld0), 0.0), 70.);\n  float spe1 = pow(max(dot(r, ld1), 0.0), 40.);\n\n  float m = mountain(p.x);\n  float cy = p.y+m;\n  vec2 sp = p-vec2(0.0,0.5);\n  vec3 topCol = hsv2rgb(vec3(0.58+cy*0.15, 0.95, 1.));\n  topCol *= smoothstep(0.7, 0.25, cy);\n  topCol += sunCol/max(dot(sp, sp), 1E-2);\n  vec3 botCol = hsv2rgb(vec3(0.98-cy*0.2, 0.85, 1.));\n  botCol *= tanh(-10.*min(0., cy+0.01)+0.05);\n\n  lcol = mix(topCol, botCol, smoothstep(aa, -aa, cy));\n\n  lcol *= 0.67+0.33*sin(p.y*RESOLUTION.y*tau/max(round(RESOLUTION.y/144.), 6.));\n  lcol *= 2.;\n  lcol += spe0*lightCol0;\n  lcol += spe1*lightCol1;\n  lcol -= 0.0125*length(p);\n\n  col *= 1.-0.9*exp(-10.*max(d+0.0125*sqrt(2.), 0.));\n  col = mix(col, lcol, smoothstep(aa, -aa, d-outer));\n  col = mix(col, vec3(0.), smoothstep(aa, -aa, abs(d-outer)-2E-3));\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float\n      aa = sqrt(2.)/RESOLUTION.y\n    ;\n \n  vec3 \n      col = vec3(0.)\n    ;\n    \n  col = layer0(col, p, aa, 0.5*TIME);\n  col = layer1(col, p, aa);\n\n  col *= smoothstep(sqrt(2.), sqrt(.5), length(pp));\n  col = sqrt(aces_approx((col)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}