{
    "Shader": {
        "info": {
            "date": "1628074475",
            "description": "Happy Chinese Valentine!",
            "flags": 0,
            "hasliked": 0,
            "id": "slSXzV",
            "likes": 6,
            "name": "Happy Chinese Valentine!",
            "published": 3,
            "tags": [
                "basedonotherscreation"
            ],
            "usePreview": 0,
            "username": "letian",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\n// -- Uniforms -----------------------------------------------------------------\n\n#ifndef SHADERTOY\nuniform vec3 iResolution;\nuniform vec3 iMouse;\nuniform float iTime;\nuniform sampler2D iChannel0;\n#endif\n\n// -- Constants ----------------------------------------------------------------\n\n// Camera constants\n\nconst float kFOV = 0.785398;                           // Camera field of view \n\n// RayMarching constants\n\nconst int kMaxSteps = 100;                              // Max number of raymarching steps\nconst float kMaxDistance = 55.0;                       // Max raymarching distance\nconst float kBias = 0.01;                              // Bias offset for normal estimation\nconst float kNoHit = -1.0;                             // No intersection distance.\n\n// Scene constants.\nconst vec3 kSkyColor = vec3(0.5, 0.12, 0.5);          // Night sky color.\nconst vec3 kSkyHorzColor = vec3(0.4, 0.2, 0.87);       // Night sky horizon color.\n\nconst vec3 kMoonDir = vec3(-0.18443, 0.3688, -0.9221); // Moon direction.\nconst vec3 kMoonColor = vec3(1.0, 1.0, 0.8);           // Moon color.\nconst vec3 kMoonSkyByColor = vec3(0.9, 0.6, 1);      // Moon glow color.\nconst float kMoonCosRange = 0.999;                     // Moon cosine range.\n\n// Material constants.\nconst float kMaterialNone = 0.0;\nconst float kMaterialHeart = 1.0;\nconst float kMaterialWater = 2.0;\n\n// Other constants\n\nconst vec3 kOnes = vec3(1.0, -1.0, 0.0);               // Helper vector with ones.\nconst float kPI = 3.14159265359;                       // PI\n\n// -- Global values ------------------------------------------------------------\n\nfloat gAnimTime;\n\nvec3  gHeartPos;\nfloat gHeartMorph;\nfloat gHeartColoring;\n\nfloat gWaveTime;\n\nfloat gMsgFadeInTime;\nfloat gFadeTime;\n\n\n// -- Structures ---------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayHit\n{\n    float time;\n    float material;\n};\n\nstruct DistanceSample\n{\n    float dist;\n    float stepRatio;\n    float material;\n};\n\n    \n// --- Math funcs --------------------------------------------------------------\n\n// Build quaternion from axis angle\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n    float theta = 0.5 * angle;\n    float sine = sin(theta);\n    return vec4(sin(theta) * axis, cos(theta));\n}\n\n// Builds the conjugate quaternion\nvec4 QuatConjugate(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n// Rotates a vector around the quaternion\nvec3 QuatTransformVec(vec3 v, vec4 q)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// -- Noise funcs --------------------------------------------------------------\n\n// Hash noise function from I. Quilez\nfloat Hash(float p)\n{\n    float h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash noise function from I. Quilez\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// Modified Hash noise function for 3D hashing.\nfloat Hash(vec3 p)\n{\n    float h = dot(p, vec3(127.1, 311.7, 511.9));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// 2D Perlin Noise\nfloat PerlinNoise(vec2 p)\n{    \n    vec2 i = floor(p);\n    vec2 f = fract(p);  \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zz), Hash(i + kOnes.xz), u.x);\n    float f01 = mix(Hash(i + kOnes.zx), Hash(i + kOnes.xx), u.x);\n    float f1 = mix(f00, f01, u.y);\n    \n    return 2.0 * f1 - 1.0;\n}\n\n// 3D Perlin Noise\nfloat PerlinNoise(vec3 p)\n{    \n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zzz), Hash(i + kOnes.xzz), u.x);\n    float f01 = mix(Hash(i + kOnes.zxz), Hash(i + kOnes.xxz), u.x);\n    float f02 = mix(Hash(i + kOnes.zzx), Hash(i + kOnes.xzx), u.x);\n    float f03 = mix(Hash(i + kOnes.zxx), Hash(i + kOnes.xxx), u.x);\n    \n    float f10 = mix(f00, f01, u.y);\n    float f11 = mix(f02, f03, u.y);\n    \n    float f2 = mix(f10, f11, u.z);\n    \n    return 2.0 * f2 - 1.0;\n}\n\n// Fractional Brownian Motion from I. Quilez\n// https://iquilezles.org/articles/warp\n// In the end, it's a sum of Perlin Noise functions with increasing frequencies\n// and decreasing amplitudes. To enhance the noise, a rotation matrix is applied\n// at each step.\n\nconst mat2 FBM_M2 = mat2(0.84147, 0.54030, 0.54030, -0.84147);\nconst mat3 FBM_M3 = mat3(0.00, 0.90, 0.60, -0.90, 0.36, -0.48, -0.60, -0.48, 0.34 );\n\nfloat FBM(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M2 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M2 * p * 2.03;\n    f += 0.1250*PerlinNoise(p); p = FBM_M2 * p * 2.01;\n    //f += 0.0625*PerlinNoise(p);\n    //return f/(0.9375);\n    return f/(0.8750);\n}\n\nfloat FBM(vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M3 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M3 * p * 2.33;\n    f += 0.1250*PerlinNoise(p); p = FBM_M3 * p * 2.01;\n    f += 0.0625*PerlinNoise(p); \n    return f/(0.9175);\n}\n\n// -- Camera funcs -------------------------------------------------------------\n\nRay ViewportToRay(vec2 uv, vec3 offs, vec4 rot)\n{\n    Ray ray;\n    ray.direction = QuatTransformVec(normalize(vec3(uv * tan(kFOV * 0.5), -1.0)), rot);\n    ray.origin = offs;\n    \n    return ray;\n}\n\nRay ReflectRay(Ray ray, float d, vec3 n)\n{\n    ray.origin += ray.direction * d;\n    ray.direction = reflect(ray.direction, n);\n    return ray;\n}\n\nDistanceSample NewDistanceSample(float d, float s, float m)\n{\n    DistanceSample h;\n    h.dist = d;\n    h.stepRatio = s;\n    h.material = m;\n    return h;\n}\n\nRayHit NewRayHit(float t, float m)\n{\n    RayHit h;\n    h.time = t;\n    h.material = m;\n    return h;\n}\n\n// -- Water funcs --------------------------------------------------------------\n\n// Computes the height of a wave at the specified point\nfloat WaveDirectional(vec2 p, float wavelength, float speed, vec2 direction, float amplitude)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float theta = dot(direction, p);\n\n    return amplitude * pow(sin(theta * freq + gAnimTime * phase), 3.0);\n}\n\nfloat WavePunctual(vec2 p, float wavelength, float speed, vec2 perturb, float amplitude, float waveTime)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float dist = -length(p - perturb);\n    amplitude /= 1.0 + (0.3 * -dist) + (0.15 * waveTime * waveTime);\n\n    return amplitude * pow(sin(max(0.0, dist * freq + waveTime * phase)), 3.0);\n}\n\n// -- SDF funcs ----------------------------------------------------------------\n\n// Signed Distance Field of a point to a heart located at the origin. It works by computing\n// the SDF of a sphere whose space has been distorted by a polar function\nDistanceSample SDFHeart(vec3 p)\n{\n    // Apply noise to position when it's a drop.\n    if (gHeartMorph < 1.0)\n        p += 0.16 * FBM(p + vec3(0, gAnimTime * 2.5, 0)) * (1.0 - gHeartMorph);\n    \n    // Apply domain distortion for heart.\n    float a0 = atan(p.x, p.y);\n    float a1 = atan(p.x, p.z);\n    float b0 = abs(a0 / kPI);\n    float b1 = abs(a1);\n    float l = length(p.xy);\n    \n    // Constants computed with Octave:\n    // x = [   0; 0.35;  0.53;   1; ];\n    // y = [ 0.6;  1.0;  0.9; 1.2; ];\n    // K = polyfit(x, y, 3);\n    const vec4 K = vec4(6.34975, -9.8705, 4.39112, 0.4);\n    vec4 B = vec4(b0 * b0 * b0, b0 * b0, b0, 1.0);\n    \n    float d0 = dot(K, B);\n    d0 = mix(1.0, d0, smoothstep(0.0, 0.7, l));\n    float d1 = 1.0 - 0.5*abs(cos(a1));\n    \n    p.xy /= mix(1.0, d0, gHeartMorph);\n    p.z  /= mix(1.0, d1, gHeartMorph);\n    \n    // Increase size whenever the mouse is close.\n\tfloat mouseOverSize = 1.0+0.7*smoothstep(0.2, 0.0, length((iMouse.xy / iResolution.xy) - 0.5));\n\t\n    // Compute sphere's SDF\n    return NewDistanceSample(length(p) - 0.8 - 0.5 * gHeartMorph * mouseOverSize, 0.5, kMaterialHeart);\n}\n\n// Signed Distance Field of a point to the water plane located at the origin.\n// It's simply the distance to a plane distorted by the wave field.\nDistanceSample SDFWater(vec3 p)\n{\n    const float overallSpeed = 0.7;\n    float height = 0.0;\n    height -= FBM(vec3(p.xz * 0.5, 0.75 * gAnimTime)) * 0.05;\n    height += WavePunctual(p.xz, 12.0, 1.5, vec2(0.0, -12.0), 2.0, gWaveTime);\n    \n    return NewDistanceSample(p.y - 1.5 * height, 1.0, kMaterialWater);\n}\n\n// -- SDF CGS funcs ------------------------------------------------------------\n\nDistanceSample OpUnion(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist < d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSubstract(DistanceSample d1, DistanceSample d2)\n{\n    d2.dist = -d2.dist;\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpIntersect(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSmoothMin(DistanceSample d1, DistanceSample d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2.dist - d1.dist)/k, 0.0, 1.0);\n    \n    DistanceSample d;\n    d.dist = mix(d2.dist, d1.dist, h) - k * h * (1.0-h);\n    d.stepRatio = min(d2.stepRatio, d1.stepRatio);\n    d.material = mix(d2.material, d1.material, h);\n    \n    return d;\n}\n\n// -- Transform funcs ----------------------------------------------------------\n\nvec3 Tx(vec3 p, vec3 tx)\n{\n    return (p - tx);\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q)\n{\n    p -= tx;\n    return QuatTransformVec(p, QuatConjugate(q));\n}\n\n// --- Scene funcs -------------------------------------------------------------\n\nDistanceSample Scene(vec3 position)\n{\n    // Evaluate scene distances.\n    DistanceSample d0 = SDFHeart(Tx(position, gHeartPos, QuatFromAxisAngle(vec3(0.,1.,0.), gAnimTime*1.7)));\n    DistanceSample d1 = SDFWater(Tx(position, vec3(0,-2,0)));\n    return OpSmoothMin(d0, d1, 0.8);\n}\n\nvec3 SceneNormal(vec3 position)\n{\n    vec2 offset = vec2(kBias, 0.0);\n    float d = Scene(position).dist;\n    \n    return normalize(vec3\n    (\n        Scene(position + offset.xyy).dist - d,\n        Scene(position + offset.yxy).dist - d,\n        Scene(position + offset.yyx).dist - d\n    ));\n}\n\nvec3 SkyColor(vec3 n)\n{\n    // Compute the sky color from hemisphere. \n    float h = 1.0 - pow(abs(n.y), 0.4);\n    vec3 color = mix(kSkyColor, kSkyHorzColor, h);\n    \n    // Add stars.\n    float s = pow(max(0.0, PerlinNoise(n * 4e2)), 18.0);\n    color.rgb += vec3(s, s, s);\n    \n    // Add moon and moon light.\n    float dotNM = dot(n, kMoonDir);\n    color = mix(color, kMoonColor, smoothstep(0.0, 0.0001, dotNM - kMoonCosRange));\n    color += kMoonSkyByColor * pow(max(0.0, dotNM), 100.0);\n    \n    return color;\n}\n\nRayHit Raymarch(Ray ray)\n{\n    float t = 0.0;\n    DistanceSample d;\n    \n    for (int i = 0; (i < kMaxSteps); i++)\n    {\n        d = Scene(ray.origin + ray.direction * t);\n        t += d.dist * d.stepRatio;\n        \n        if ((d.dist < 0.0) || (t >= kMaxDistance))\n            break;\n    }\n    \n    if (t < kMaxDistance)\n        return NewRayHit(t, d.material);\n    \n    return NewRayHit(kNoHit, kMaterialNone);\n}\n\nfloat SparkCircle(vec2 uv, vec2 center, float rad)\n{\n    float d = length(uv - center);\n    return smoothstep(rad, 0.0, d);\n}\n\nfloat SparkRect(vec2 uv, vec2 center, vec2 size, float ang)\n{\n    vec2 cs = vec2(cos(ang), sin(ang));\n    uv -= center;\n    uv = vec2(dot(uv, cs), dot(uv.yx * vec2(-1.0, 1.0), cs));\n    \n    vec2 x = smoothstep(size*0.5, vec2(0.0, 0.0), abs(uv));\n    return pow(x.x * x.y, 3.0);\n}\n\nfloat Spark(vec2 uv, vec2 center, float ang)\n{\n    float f = 0.0;\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang);\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(60.0));\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(120.0));\n    f += SparkCircle(uv, center, 0.01);\n    return f;\n} \n\nvec3 Colorize(Ray ray, RayHit hit)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);   \n    color.rgb = SkyColor(ray.direction);\n    \n    // If there was an intersection, compute normal and the hit surface color.\n    if (hit.material != kMaterialNone)\n    {\n        vec3 p = ray.direction * hit.time + ray.origin;\n        vec3 n = SceneNormal(p);\n        \n        color.rgb = mix(vec3(0.0, 0.0, 0.0), SkyColor(reflect(ray.direction, n)), 1.0 - pow(length(n.xz), 16.0));\n        \n        if (hit.material == kMaterialHeart)\n        {\n            color.rgb += gHeartColoring * vec3(0.4, 0, 0);\n        }\n        \n        //color.rgb = SceneNormal(p);//0.3 + 0.7*pow(max(0., Normal(p).z), 30.0);\n    }\n    \n    return color;\n}\n                        \n// --- Main --------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Setup globals.\n\tgAnimTime      = mod(1.5 * iTime, 20.0);\n\tgHeartPos      = vec3(0.0, -3.5 + 5.0 * smoothstep(1.0, 3.0, gAnimTime), -12.0);\n\tgHeartMorph    = smoothstep(2.5, 4.0, gAnimTime);\n\tgHeartColoring = smoothstep(4.0, 6.0, gAnimTime);\n\tgWaveTime      = max(0.0, gAnimTime - 0.8);\n\tgMsgFadeInTime = smoothstep(7.0, 9.0, gAnimTime);\n\tgFadeTime      = smoothstep(0.0, 1.0, gAnimTime) * smoothstep(20.0, 19.0, gAnimTime);\n\n    // Get uvs in [-1 1] range and correct them with the aspect ratio.\n    vec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Generate first ray and raymarch along scene.\n    Ray ray = ViewportToRay(uv, kOnes.zzz, QuatFromAxisAngle(vec3(1.0, 0.0, 0.0), radians(6.0)));\n    RayHit hit = Raymarch(ray);    \n\n    // Initialize background color.\n    vec3 color = Colorize(ray, hit);\n    \n    // Show sparks around the heart\n    for(int i = 0; i < 8; i++)\n    {\n        float t = max(0.0, (gAnimTime + (float(i)) * 0.2) - 6.0);\n        float s = floor(t / 0.4);\n        float sTime = fract(t / 0.4);\n        vec2 sPos = vec2(Hash(s * 61.0), Hash(s * 17.0));\n        sPos = 2.0 * sPos - 1.0;\n        sPos *= 0.15;\n        color.rgb += sin(sTime * kPI) * Spark(uv, sPos, 0.0) * vec3(1.0, 0.4, 0.4);\n    }\n    \n    // Show the valentine's message\n    /*\n    if (gMsgFadeInTime > 0.0)\n    {\n        vec2 texAspect = vec2(1.0, -4.0);\n        vec2 texUv = uv * texAspect;\n        texUv = clamp(texUv * 0.5 + 0.5, 0.0, 1.0);\n        \n        vec2 texMsg = texture(iChannel0, texUv).rg;\n        color.rgb += gMsgFadeInTime * (texMsg.y * vec3(0.4, 0.0, 0.0) + texMsg.xxx);        \n    }\n    */\n    \n    // Apply vignetting effect.\n    color.rgb -= color.rgb*0.2*dot(uv, uv);\n\n    fragColor = vec4(gFadeTime * color, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n    vec4 fragColor;\n    mainImage(fragColor, gl_FragCoord);\n    gl_FragColor = fragColor;\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}