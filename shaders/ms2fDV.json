{
    "Shader": {
        "info": {
            "date": "1690188725",
            "description": "CHECK COMMON FOR CONTROLS\n\norder of filters:\n\nBuffer A:\n- chromatic aberration\n- RGB grain\n- vignette\n- rounded corners\n\nBuffer B:\n- 7x4 pixelation\n- hex offset\n- 7x4 sub-pixel RGB mask\n\nImage:\n- bloom\n- barrel-distortion",
            "flags": 32,
            "hasliked": 0,
            "id": "ms2fDV",
            "likes": 29,
            "name": "REALISTIC SUB-PIXEL OLD CRT :::.",
            "published": 3,
            "tags": [
                "crt",
                "aberration",
                "old",
                "vignette",
                "grain"
            ],
            "usePreview": 0,
            "username": "ENDESGA",
            "viewed": 1538
        },
        "renderpass": [
            {
                "code": "// CC0 :::.\n// Credit (@ENDESGA) and\n// link to this Shadertoy appreciated\n\n// CHECK COMMON FOR CONTROLS\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n    vec2 uv = (( F.xy / iResolution.xy ) * 2.) - 1.;\n    float r = length( uv );\n    uv /= ( 2. * distortion_amount * r * r );\n    uv = ( ( uv * ( 1. - sqrt( 1. - 4. * distortion_amount * r * r ) ) ) + 1. ) / 2.;\n    float v = min( min( uv.x, 1. - uv.x ), min( uv.y, 1. - uv.y ) ),\n        AA = 0.5 * length( vec2( dFdx( v ), dFdy( v ) ) );\n    vec4 t = mix( vec4( 0. ), texture( iChannel0, uv ), smoothstep( -AA, AA, v ) );\n    // bloom\n    float weight[ 7 ] = float[]( 0.25, 0.5, 1.0, 2.0, 1.0, 0.5, 0.25 );\n    C = vec4(0.);\n    for( int x = -3; x <= 3; ++x )\n        for( int y = -3; y <= 3; ++y )\n            C += weight[ x + 3 ] *\n                weight[ y + 3 ] *\n                texture( iChannel0, uv + vec2( x, y ) * (1.0 / iResolution.xy) );\n    C = mix(texture( iChannel0, uv ), C / 7., bloom_amount * mask_amount)\n        // barrel-distortion mask\n        * smoothstep( -AA, AA, v );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash( vec3 p )\n{\n\tp = fract( p * 0.1031 );\n\tp += dot( p, p.yzx + 19.19 );\n\treturn fract( ( p.x + p.y ) * p.z );\n}\n\nfloat noise( vec3 x )\n{\n\tvec3 p = floor( x ), f = fract( x ), m = f * f * ( 3.0 - 2.0 * f );\n\tvec3 i = p + vec3( 1.0, 0.0, 0.0 );\n\tvec4 hash = vec4( hash( p ), hash( i ), hash( p + vec3( 0.0, 1.0, 0.0 ) ), hash( i + vec3( 0.0, 1.0, 0.0 ) ) );\n\treturn mix( mix( hash.x, hash.y, m.x ), mix( hash.z, hash.w, m.x ), m.y );\n}\n\nfloat grain( vec3 x )\n{\n\treturn 0.5 + ( 4.0 * noise( x ) - noise( x + 1. ) + noise( x - 1. ) ) / 4.0;\n}\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n\tvec2 uv = F / iResolution.xy,\n        aber_dis = ( uv - vec2( 0.5 ) ) * aberration_amount * length( uv - 0.5 ) * .5;\n\tvec3 aber = vec3(\n            texture( iChannel0, uv ).r,\n            texture( iChannel0, uv - aber_dis ).g,\n            texture( iChannel0, uv - 2.0 * aber_dis ).b\n        );\n\tfloat frame = floor( float( iFrame ) );\n\tvec3 rgb_grain = vec3(\n            grain( vec3( F, frame ) ),\n            grain( vec3( F, frame + 9.0 ) ),\n            grain( vec3( F, frame - 9.0 ) )\n        );\n    float radius = rounded_amount * ((iResolution.x + iResolution.y)*.5) * .5;\n\t//\n    C = vec4(vec3(\n        // aberration + RGB grain\n        mix( aber, mix( aber * rgb_grain, aber + ( rgb_grain - 1.0 ), 0.5 ), noise_amount )\n        // vignette\n        * mix( 1.0, 1.0 - clamp( smoothstep( 0.25, 1.0, length( (uv - vec2( 0.5 )) * vec2( 1.0, iResolution.y / iResolution.x * 2.0 ) ) ), 0.0, 1.0 ), vignette_amount )\n        )\n        // rounded corners\n        * step(length(max(abs(F - iResolution.xy / 2.)-(iResolution.xy / 2.)+radius,0.0))-radius, 0.)\n        ,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define X vec3( 0.0 )\n#define R vec3( 1.0, 0.0, 0.0 )\n#define G vec3( 0.0, 1.0, 0.0 )\n#define B vec3( 0.0, 0.0, 1.0 )\n#define M vec3[ 28 ]( X, X, X, X, X, X, X, X, R, R, G, G, B, B, X, R, R, G, G, B, B, X, R, R, G, G, B, B )\n\nvoid mainImage( out vec4 C, in vec2 F )\n{\n    vec2 uv = floor((F / iResolution.xy) * (iResolution.xy / vec2(7., 4.)));\n    float hex_offset = mod(uv.x, 2.0) * 2.;\n    uv.y += floor(mod(F.y, 4.) / 2.) * hex_offset * .5;\n\n    // 7x4 pixelation\n    C = vec4(0.0);\n    for(float y = 0.0; y < 4.; y++) {\n        for(float x = 0.0; x < 7.; x++) {\n            C += texture(iChannel0, ((uv * vec2(7., 4.)) + vec2(x, y)) / iResolution.xy);\n        }\n    }\n    C = mix(texture(iChannel0,F / iResolution.xy), C/28.,pixelate_amount);\n    \n    C.rgb *= mix(vec3(1.),\n        // 7x4 sub-pixel RGB mask\n        M[int(int(mod(F.y + hex_offset, 4.0)) * 7 + int(mod(F.x, 7.0)))],\n        mask_amount);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define aberration_amount 0.07\n#define noise_amount 0.7\n#define vignette_amount 0.7\n#define rounded_amount 0.07\n\n#define pixelate_amount .7\n#define mask_amount .7\n\n#define bloom_amount .7\n#define distortion_amount 0.07",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}