{
    "Shader": {
        "info": {
            "date": "1725350075",
            "description": "Mostly a test for the animation framework. It's essentially a skeletal animation system, which makes sin-based animations (like this!) a lot easier to implement.",
            "flags": 0,
            "hasliked": 0,
            "id": "lc2Bzc",
            "likes": 7,
            "name": "Running Cubeman",
            "published": 3,
            "tags": [
                "animation"
            ],
            "usePreview": 0,
            "username": "triggthediscovery",
            "viewed": 124
        },
        "renderpass": [
            {
                "code": "// Animated Running Cubeman.\n//\n// This is a little complicated, but in essance it's\n// a cube renderer with the ability compose rotations\n// and translations to give the equivalent of skeletal\n// animation. Each cube can have a parent, and a\n// parent's transforms will apply to it's children.\n// This requires all cubes be in order (parents before\n// children) so the hierarchy can be calculated in a\n// single pass. \n//\n// As for the animation itself, it's very simple.\n// Mostly wanted to get the idea out there instead\n// of tinkering too much with the model/animation.\n//\n// A major limitation is that all cubes start from the\n// object's origin. This means most proper limbs need\n// to comprise two objects so the pivot points are at\n// the ends.\n//\n// provided under CC0.\n\nstruct NormAndCol {\n    vec3 col;\n    vec3 norm;\n    float dist;\n};\n\nstruct Cube {\n    vec3 local_pos;\n    mat3 local_rot;\n    vec3 size;\n    vec3 col;\n    int parent;\n    vec3 world_pos;\n    mat3 world_rot;\n    mat3 world_irot;\n};\n\nNormAndCol n_a_c(vec3 col, vec3 norm, float dist) {\n    NormAndCol ret;\n    \n    ret.col = col;\n    ret.norm = norm;\n    ret.dist = dist;\n    \n    return ret;\n}\n\nCube m_c(vec3 pos, vec3 size, vec3 col, mat3 rot) {\n    Cube ret;\n    \n    ret.local_pos = pos;\n    ret.local_rot = rot;\n    ret.size = size;\n    ret.col = col;\n    ret.parent = -1;\n    \n    return ret;\n}\n\nCube m_c(vec3 pos, vec3 size, vec3 col, mat3 rot, int parent) {\n    Cube ret;\n    \n    ret = m_c(pos, size, col, rot);\n\n    ret.parent = parent;\n    \n    return ret;\n}\n\nCube cubes[20];\nint cube_num = 19;\n\nconst float max_dist = 1000.0;\nvec3 light_dir;\nfloat cube_size = 0.5;\nconst float ambient_light = 0.4;\n\nconst float floor_level = -2.0;\nconst float checkerboard = 4.0;\nconst float checkerboard2 = checkerboard/2.0;\n\n// Calculates a ray intersection with an infinite\n// checkerboard which scrolls with time.\nNormAndCol floor_check(vec3 in_vec, vec3 in_pos) {\n    if (in_pos.y < (floor_level+0.0011) || in_vec.y > -0.03) {\n        return n_a_c(vec3(0), vec3(0), max_dist+1.0);\n    }\n    \n    float dist = (in_pos.y - floor_level) / -in_vec.y;\n\n    vec3 int_point = in_pos + (in_vec*dist);\n    \n    int_point.z += iTime*6.07;\n    \n    bool x_int = mod(int_point.x, checkerboard) < checkerboard2;\n    bool z_int = mod(int_point.z, checkerboard) < checkerboard2;\n    \n    float fog = (clamp(pow(dist/30.0, 0.2)-0.65, 0.0, 0.5));\n\n    if (x_int ^^ z_int) {\n        return n_a_c(vec3(fog), vec3(0,-1,0), dist);\n    } else {\n        return n_a_c(vec3((1.0-fog)), vec3(0,-1,0), dist);\n    }\n}\n\n// Calculates transform hierarchies.\nvoid update_cubes() {\n    for (int c_n=0; c_n<cube_num; c_n++) {\n        int par = cubes[c_n].parent;\n\n        if (par == -1) {\n            cubes[c_n].world_pos = cubes[c_n].local_pos;\n            cubes[c_n].world_rot = cubes[c_n].local_rot;\n        } else {\n            cubes[c_n].world_pos = cubes[par].world_pos + (cubes[c_n].local_pos * cubes[par].world_rot);\n            cubes[c_n].world_rot = cubes[c_n].local_rot * cubes[par].world_rot;\n        }\n\n        cubes[c_n].world_irot = inverse(cubes[c_n].world_rot);\n    }\n}\n\n// Cube intersection with rotation.\nNormAndCol check_cube(vec3 in_vec, vec3 in_pos, Cube cube) {\n    in_pos -= cube.world_pos;\n    in_vec = in_vec * cube.world_irot;\n    in_pos = in_pos * cube.world_irot;\n\n    vec3 origin_dist = in_pos / -in_vec;\n    vec3 box_dist = cube.size / abs(in_vec);\n\n    vec3 box_dist_min = origin_dist - box_dist;\n    vec3 box_dist_max = origin_dist + box_dist;\n\n    if (box_dist_min.x < box_dist_max.y && box_dist_min.x < box_dist_max.z && \n        box_dist_min.y < box_dist_max.x && box_dist_min.y < box_dist_max.z && \n        box_dist_min.z < box_dist_max.x && box_dist_min.z < box_dist_max.y) {\n        vec3 norm = vec3(0);\n        float best = 0.0;\n        \n        if (box_dist_min.x > box_dist_min.y && box_dist_min.x > box_dist_min.z) {\n            norm = vec3(1,0,0);\n            best = box_dist_min.x;\n        \n            if (in_vec.x < 0.0) norm = -norm;\n        } else if (box_dist_min.y > box_dist_min.z) {\n            norm = vec3(0,1,0);\n            best = box_dist_min.y;\n        \n            if (in_vec.y < 0.0) norm = -norm;\n        } else {\n            norm = vec3(0,0,1);\n            best = box_dist_min.z;\n        \n            if (in_vec.z < 0.0) norm = -norm;\n        }\n        \n        norm = norm * cube.world_rot;\n        \n        return n_a_c(cube.col, norm, clamp(best, 0.0, max_dist));\n    }\n    \n    return n_a_c(vec3(1), vec3(0), max_dist+1.0);\n}\n\n// Rotate around axis.\nmat3 rotations(vec3 axis, float amt) {\n    mat3 ret;\n    float ct = cos(amt);\n    float st = sin(amt);\n    float ict = 1.0-cos(amt);\n    \n    ret[0] = vec3(axis.x*axis.x,axis.x*axis.y,axis.x*axis.z);\n    ret[1] = vec3(axis.y*axis.x,axis.y*axis.y,axis.y*axis.z);\n    ret[2] = vec3(axis.z*axis.x,axis.z*axis.y,axis.z*axis.z);\n    \n    ret *= ict;\n    \n    ret[0] += vec3(        ct, -axis.z*st,  axis.y*st);\n    ret[1] += vec3( axis.z*st,         ct, -axis.x*st);\n    ret[2] += vec3(-axis.y*st,  axis.x*st,         ct);\n    \n    return ret;\n}\n\nmat3 indentity() {\n    mat3 ret;\n    \n    ret[0] = vec3(1,0,0);\n    ret[1] = vec3(0,1,0);\n    ret[2] = vec3(0,0,1);\n    \n    return ret;\n}\n\n// Complete raycast, to aid shadow calculations.\nNormAndCol raycast(vec3 in_vec, vec3 in_pos) {\n    NormAndCol best = n_a_c(vec3(1), vec3(0), max_dist+1.0);\n    \n    for (int i=0; i<cube_num; i++) {\n        NormAndCol mdia = check_cube(in_vec, in_pos, cubes[i]);\n\n        if (mdia.dist < best.dist && mdia.dist > 0.0001) {\n            best = mdia;\n        }\n    }\n    \n    NormAndCol mfloor = floor_check(in_vec, in_pos);\n    \n    if (mfloor.dist < best.dist) {\n        best = mfloor;\n    }\n    \n    return best;\n}\n\nconst float gm_p = 1.5;\nconst float ch_p = 0.2;\n\nfloat gamma(float inp) {\n    return inp < ch_p ? inp * pow(ch_p, gm_p-1.0) : pow(inp, gm_p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tim = iTime*5.0+1.0;\n\n    float torso_tilt = sin((tim*2.0)+3.0)/15.0+0.1;\n    float head_tilt = sin(((tim+0.2)*2.0)+3.0)/15.0+0.1;\n    \n    float u_leg = (sin(tim)/1.2)+3.1416;\n    float l_leg = u_leg/2.0 + cos(tim)/3.0;\n    \n    float arm_swing = (sin((tim+0.8))/4.0)+3.1416;\n    float arm_twist = (sin((tim+0.8))/4.0);\n    \n    float body_bob = sin((tim*2.0)+0.5)/8.0;\n    \n    // Quick explanation, the general pattern here is m_c (make_cube), which\n    // initializes the cube, then manually setting the local_rot. This is\n    // just a prefereance thing, and you can pass the rotation matrix into\n    // m_c, but this seemed cleaner when I was writing it.\n    // \n    // The numebr at the end (excluding cubes[0]) is which cube is a parent\n    // to that cube. So 1 is parented to 0, 2 is parented to 1, and so on.\n    \n    // torso\n    cubes[0] = m_c(vec3(0.0, 0.5, 0.0), vec3(0.38,0.6,0.25), vec3(1.0, 0.5, 0.5),  mat3(0));\n    cubes[0].local_pos += vec3(0, body_bob, 0);\n    cubes[0].local_rot = rotations(vec3(1,0,0), torso_tilt);\n    \n    // right arm\n    cubes[1] = m_c(vec3(0.55,0.4, 0.0), vec3(0.2, 0.2, 0.2), vec3(1.0, 0.5, 0.5), mat3(0), 0);\n    cubes[1].local_rot = rotations(vec3(1,0,0), arm_swing+0.3);\n    cubes[2] = m_c(vec3(0,0.4,0),       vec3(0.13,0.4,0.13), vec3(1.0, 0.9, 0.7), mat3(0), 1);\n    cubes[2].local_rot = rotations(vec3(0,1,0), -arm_twist);\n    cubes[3] = m_c(vec3(0,0.4,0),       vec3(0.13,0.13,0.13),vec3(1.0, 0.9, 0.7), mat3(0), 2);\n    cubes[3].local_rot = rotations(vec3(1,0,0), arm_swing+2.0);\n    cubes[4] = m_c(vec3(0,0.4,0),       vec3(0.12,0.4,0.12), vec3(1.0, 0.9, 0.7), mat3(0), 3);\n    cubes[4].local_rot = indentity();\n    \n    // left arm\n    cubes[5] = m_c(vec3(-0.55,0.4,0.0), vec3(0.2, 0.2, 0.2), vec3(1.0, 0.5, 0.5), mat3(0), 0);\n    cubes[5].local_rot = rotations(vec3(1,0,0), -arm_swing+0.3);\n    cubes[6] = m_c(vec3(0,0.4,0),       vec3(0.15,0.4,0.15), vec3(1.0, 0.9, 0.7), mat3(0), 5);\n    cubes[6].local_rot = rotations(vec3(0,1,0), -arm_twist);\n    cubes[7] = m_c(vec3(0,0.4,0),       vec3(0.13,0.13,0.13),vec3(1.0, 0.9, 0.7), mat3(0), 6);\n    cubes[7].local_rot = rotations(vec3(1,0,0), -arm_swing+2.0);\n    cubes[8] = m_c(vec3(0,0.4,0),       vec3(0.12,0.4,0.12), vec3(1.0, 0.9, 0.7), mat3(0), 7);\n    cubes[8].local_rot = indentity();\n    \n    // right leg\n    cubes[ 9] = m_c(vec3(0.2,-0.5, 0.0), vec3(0.18,0.18,0.18),vec3(0.5, 0.5, 1.0), mat3(0), 0);\n    cubes[ 9].local_rot = rotations(vec3(1,0,0), -u_leg-0.2);\n    cubes[10] = m_c(vec3(0,0.5,0),       vec3(0.18,0.5,0.18), vec3(0.5, 0.5, 1.0), mat3(0), 9);\n    cubes[10].local_rot = indentity();\n    cubes[11] = m_c(vec3(0,0.5,0),       vec3(0.15,0.15,0.15),vec3(0.5, 0.5, 1.0), mat3(0), 10);\n    cubes[11].local_rot = rotations(vec3(1,0,0), l_leg-1.0);\n    cubes[12] = m_c(vec3(0,0.5,0),       vec3(0.15,0.5,0.15), vec3(0.5, 0.5, 1.0), mat3(0), 11);\n    cubes[12].local_rot = indentity();\n    \n    // left leg\n    cubes[13] = m_c(vec3(-0.2,-0.5, 0.0),vec3(0.18,0.18,0.18),vec3(0.5, 0.5, 1.0), mat3(0), 0);\n    cubes[13].local_rot = rotations(vec3(1,0,0), u_leg-0.2);\n    cubes[14] = m_c(vec3(0,0.5,0),       vec3(0.18,0.5,0.18), vec3(0.5, 0.5, 1.0), mat3(0), 13);\n    cubes[14].local_rot = indentity();\n    cubes[15] = m_c(vec3(0,0.5,0),       vec3(0.15,0.15,0.15),vec3(0.5, 0.5, 1.0), mat3(0), 14);\n    cubes[15].local_rot = rotations(vec3(1,0,0), -l_leg+2.0);\n    cubes[16] = m_c(vec3(0,0.5,0),       vec3(0.15,0.5,0.15), vec3(0.5, 0.5, 1.0), mat3(0), 15);\n    cubes[16].local_rot = indentity();\n    \n    // head\n    cubes[17] = m_c(vec3(0, 1.0, 0),     vec3(0.25,0.3,0.25), vec3(1.0, 0.9, 0.7), mat3(0), 0);\n    cubes[17].local_rot = rotations(vec3(1,0,0), -head_tilt);\n    \n    // neck\n    cubes[18] = m_c(vec3(0, 0.5, 0),     vec3(0.15,0.5,0.15), vec3(1.0, 0.9, 0.7), mat3(0), 0);\n    cubes[18].local_rot = indentity();\n    \n    // Propagate parent changes to children to accelerate raycasting.\n    update_cubes();\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord-(iResolution.xy/2.0);\n\n    uv /= iResolution.y;\n\n    float dist = 7.0;\n    float c_ang = (iTime+4.5)/2.0;\n\n    vec3 in_vec_p = vec3(sin(c_ang)*dist, 2.0, -(cos(c_ang)*dist));\n    vec3 in_vec_d = normalize(-in_vec_p);\n    light_dir = normalize(vec3(0.3,0.6,0.3));\n    \n    float fov = 1.0;\n\n    mat3 lookat;\n    lookat[2] = in_vec_d;\n    lookat[0] = cross(vec3(0,1,0), lookat[2]);\n    lookat[1] = cross(lookat[2], lookat[0]);\n    lookat = transpose(lookat);\n    \n    in_vec_d = normalize(vec3(uv.xy*fov, 1.0)) * lookat;\n\n    vec3 col = mix(vec3(0.7,0.8,1), vec3(0.5,0.6,1), uv.y);\n    \n    NormAndCol best = raycast(in_vec_d, in_vec_p);\n    \n    if (best.dist < max_dist) {\n        vec3 hit_point = in_vec_p + (in_vec_d * best.dist);\n    \n        NormAndCol sun = raycast(light_dir, hit_point);\n\n        float light = dot(best.norm, -light_dir);\n        float light2 = clamp(light, ambient_light, 1.0);\n            \n        col = best.col * light2;\n        \n        // Shadow calculation, I dont like that light <= 0\n        // is in here, but it was the easiest way to make \n        // sure backfaces are in shadow. The cube intersection\n        // algorithm struggles when that happens for some\n        // reason.\n        if (sun.dist < 100.0 || light <= 0.0) {\n            col *= 0.7;\n        }\n    }\n    \n    col.x = gamma(col.x);\n    col.y = gamma(col.y);\n    col.z = gamma(col.z);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}