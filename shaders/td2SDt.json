{
    "Shader": {
        "info": {
            "date": "1555515709",
            "description": "Raymarched menger sponge + displaced sphere\nRenderer based on IQ's sphere template: https://www.shadertoy.com/view/ldfSWs",
            "flags": 32,
            "hasliked": 0,
            "id": "td2SDt",
            "likes": 3,
            "name": "Bulging Fractal",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "sdf"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 773
        },
        "renderpass": [
            {
                "code": "#define BLUR .1\n\nvec3 nearPixel(vec2 fragCoord, vec2 pos)\n{\n\treturn texture(iChannel0, (fragCoord+pos)/iResolution.xy).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get color + AA\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    // Uncomment for motion blur\n    //col = mix(col, nearPixel(fragCoord, vec2(0., 1.)), BLUR);\n    //col = mix(col, nearPixel(fragCoord, vec2(1., 0.)), BLUR);\n    //col = mix(col, nearPixel(fragCoord, vec2(0., -1.)), BLUR);\n    //col = mix(col, nearPixel(fragCoord, vec2(-1., 0.)), BLUR);\n    //col = mix(col, nearPixel(fragCoord, vec2(-1., 1.)), BLUR);\n    //col = mix(col, nearPixel(fragCoord, vec2(1., -1.)), BLUR);\n    \n    // Greyscale (remove for color)\n   \t//col = vec3(col.r + col.g + col.b)/3.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//------------------------------------------------------------------------\n// Structs & Values\n//------------------------------------------------------------------------\n\n#define NOEMIT 0.0\n#define EMIT 1.0\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n    float emission;\n};\n\n\n//------------------------------------------------------------------------\n// Noise Credit: https://www.shadertoy.com/user/iq\n//------------------------------------------------------------------------\n\nvec3 hash( vec3 p ) \n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// returns 3D value noise\nfloat snoise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float ctime = time/2.0;\n    float zoom = 3.0;\n    float an = sin(ctime)/5. + mouseX;\n\tcamPos = vec3(0.+zoom*sin(an)*1.,2.5,zoom*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Coloring \n//\n// Color transformations and color sets\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0., 0., 0.);\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvec3 contrastAdjust( vec3 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n    return color;\n}\n\nvec3 comColors( vec4 d1, vec4 d2 )\n{\n    vec3 ret = ((d1.w<d2.w) ? d1.rgb : d2.rgb);\n\treturn ret;\n}\n\n\n//------------------------------------------------------------------------\n// Shaping \n//\n// Shapes the coordinates, proceeding models\n//------------------------------------------------------------------------\n\nvec3 opRotate( vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 transform = mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n    \n    return (inverse(transform) * vec4(p, 1.0)).xyz;\n}\n\nfloat opUnion ( vec4 d1, vec4 d2)\n{\n    return ((d1.w<d2.w) ? d1.w : d2.w);\n}\n\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\n\nfloat getEmissionCurve()\n{\n    return sin(iTime*12.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{   \n    // shaping\n    float sphere = length(p)-s;\n    return sphere;\n}\n\nfloat sDist(vec3 p, float freq, float time)\n{\n    return 0.1*sin(freq*p.x + time*5.)*sin(freq*p.y + time)*sin(freq*p.z + time)*sin(freq*time + time*.5);\n}\n\nvec4 sdDistortedSphere( vec3 p, float s )\n{\n    // sdf\n    vec4 sdf;\n    float sphere = sdSphere(p,s);\n    float time = iTime * .5;\n    \n    // distortion\n    sdf.w = sDist(p, 12.0, time);\n    sdf.w = sphere + sdf.w;\n    sdf.w *= .5;\n    \n    // color\n    sdf.rgb = vec3(1., .65, 0.)*(.7+getEmissionCurve());\n    \n    return sdf;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec4 doFractal(vec3 p)\n{\n   vec3 c = vec3(2.0, 2.0, 2.0);\n    \n   // base\n   vec4 sdf;\n   sdf.w = sdBox(p,vec3(.7));\n   sdf.rgb = vec3(0.0, .75, 1.0)*.2;\n    \n   float noise = snoise(p + iTime)+.1;\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 ip = p;\n       \n      // rotation\n      ip = opRotate(ip, vec3(1.0), float(m)*5.);\n       \n      vec3 a = mod( ip*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>sdf.w )\n      {\n      \tsdf.w = max(sdf.w,c);\n      \tvec3 icolor = hueShift(sdf.rgb, -float(m)/2.);\n        sdf.rgb = mix(icolor, vec3(1.0, .65, 0.0), clamp(noise*float(m), 0., 1.));\n      }\n   }\n\n   return sdf;\n}\n\n// x = ray\n// yzw = color\nvec4 doModel( vec3 p , float fromEmission)\n{   \n    // offset\n    float offsetTime = (iTime)/7.;\n    p.x += sDist(vec3(offsetTime), 10.0, offsetTime)*3.;\n    p.y += sDist(vec3(offsetTime + 10.), 10.0, offsetTime+5.)*3.;\n    p.z += sDist(vec3(offsetTime + 4.), 10.0, offsetTime+12.)*3.;\n    \n    // transformations\n    p = opRotate(p, vec3(cos(iTime/2.), sin(iTime/2.), sin(iTime/2.)), iTime/2.); // rotation\n    \n    // distortion\n    p.x += snoise(p*1.5 + iTime/2.)/4.4; // noise dist\n    p.y += snoise(p*1.5 + (iTime+5.)/2.)/4.4; // noise dist\n    p.z += snoise(p*1.5 + (iTime+12.)/2.)/4.4; // noise dist\n    \n    // sdf\n    vec4 sdf;\n    vec4 fractal = doFractal(p);\n    vec4 sphere = sdDistortedSphere(p,(1.-fromEmission)*.55 + getEmissionCurve()/10.);\n    \n    // unions\n    sdf.w = opUnion(fractal, sphere);\n    sdf.w *= .7; // lipschitz modifier\n    \n    // coloring\n    sdf.rgb = comColors(fractal, sphere);\n    \n    return sdf;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return doModel(pos, NOEMIT).rgb;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float fromEmission)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n        vec4 sdf = doModel( ro + rd*t , fromEmission);\n\t\tfloat h = sdf.w;\n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal, Light light)\n{\n    vec3 lin = vec3(0.0);\n    \n    vec3 lightDirection = (light.position-pos);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(lightDirection);\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig, .1, .1, light.emission);\n    lin += dif*vec3(9.00,5.00,5.00);\n\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin*.5;\n    vec3 col2 = light.color * lin * .5 * vec3(light.intensity);\n    \n    col = max(col,col2);\n\n    \n    // fog    \n    //----------------------------\n\tcol *= exp(-0.06*dis*dis);//\n\n    return clamp(col, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------\n// Geometry\n//------------------------------------------------------------------------\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 5.0;           // max trace distance\n\tconst float precis = 0.002;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        \n\t    h = doModel( ro+rd*t , NOEMIT).w;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps , NOEMIT).w + \n\t\t\t\t\t  v2*doModel( pos + v2*eps , NOEMIT).w + \n\t\t\t\t\t  v3*doModel( pos + v3*eps , NOEMIT).w + \n\t\t\t\t\t  v4*doModel( pos + v4*eps , NOEMIT).w );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t, NOEMIT).w;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),roll) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n//------------------------------------------------------------------------\n// Main Image\n//------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float time = iTime*2.0;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, time, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,4.0 + sin(time)) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n        \n        // center light\n        Light cLight;\n        cLight.position = ro + vec3(0., 2., 0.);\n        cLight.color = vec3(0., 0., 0.);\n        cLight.intensity = 1.0;\n        cLight.emission = NOEMIT;\n        col = doLighting( pos, nor, rd, t, mal , cLight); \n        \n        // inner light\n        Light iLight;\n        iLight.position = vec3(0.0,0.0,0.0);\n        iLight.color = vec3(1.0, .65, 0.0);\n        iLight.intensity = getEmissionCurve() + 1.5;\n        iLight.emission = EMIT;\n        col = max( col, doLighting( pos, nor, rd, t, mal , iLight));\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.85) );\n    col = contrastAdjust(col, 1.5);\n    \n    // motion blur\n    vec3 prev = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n\tcol = mix(prev, col, .6);\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}