{
    "Shader": {
        "info": {
            "date": "1590693513",
            "description": "Who's gonna win?",
            "flags": 40,
            "hasliked": 0,
            "id": "3s2BzV",
            "likes": 73,
            "name": "Path Racers",
            "published": 3,
            "tags": [
                "tunnel",
                "light",
                "shadows",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "friol",
            "viewed": 2765
        },
        "renderpass": [
            {
                "code": "\n//\n// friol 2o2o\n// choose your noise function wisely\n// dof/bokeh blur readapted from halcy\n// 29.05.2020: cleaned up a bit and darkened the walls&reflective sphere\n//\n\nvec3 dof(sampler2D tex, vec2 uv) \n{\n    vec3 col = vec3(0.0);\n    float asum = 0.0;\n    float coc = texture(tex,uv).a;\n    for(float t=0.0;t<2.0*3.141592;t+=3.141592/16.0) \n    {\n    \tfloat r = cos(3.14 / 6.0) / cos(mod(t, 2.0 * 3.14 / 6.0) - 3.14 / 6.0);\n        \n        vec2 offset = vec2(sin(t), cos(t)) * r * t * vec2(1.0) / iResolution.xy * coc;\n        vec4 samp = texture(tex, uv + offset * 1.0);\n        \n        offset = vec2(sin(t), cos(t)) * r * t * vec2(1.0) / iResolution.xy * samp.a;\n        samp = texture(tex,uv+offset);\n        \n        col += samp.rgb * samp.a * t;\n        asum+=samp.a*t;\n    }\n    col = col / asum;\n    return(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(dof(iChannel0, uv), 0.0);\n    if (iTime<8.0) fragColor=mix(fragColor,vec4(0.0),(8.0-iTime)/8.0);\n\t//fragColor = vec4(texture(iChannel0, uv));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float globalTempo=130.0; // global, song tempo dancing\n\n\nvec2 oldRand(inout vec2 seed,float time) \n{\n    seed+=vec2(-0.001,0.001);\n    return vec2(fract(cos(dot(seed.xy ,vec2(123.4+sin(time),234.5))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 133421.631));\n}\n\nvec2 rand2n(vec2 co,float time){\n    return vec2(\n        fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453),\n        fract(cos(dot(co.xy ,vec2(32.9898,78.233))) * 13758.5453)\n    );\n}\n\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(425.215, 714.388)))*45758.5453);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nconst int samplesPerPixel=32; // in 2025, you'll be able to raise this to 256\nconst int maxRayReflections=3;\n\n#define INFINITY 999999.0\n\nstruct rtIntersection \n{\n    float dist;\n\tvec3 position;\n    vec3 normal;\n    int material;\n};\n    \nbool intersectSphere( float radius, vec3 center, vec3 ro,vec3 rd, out rtIntersection hit ) \n{\n\tvec3 oc = center - ro;\n    float l = dot(rd, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(radius, 2.0);\n    if (det < 0.0) return false;\n\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return false;\n\n    vec3 pos = ro + len * rd;\n    hit = rtIntersection(len, pos, (pos - center) / radius,-1);\n    return true;\n}\n\n\nbool intersectPlane( vec3 normal,vec3 ro,vec3 rd, out rtIntersection hit ) \n{\n\tfloat len = -dot(ro, normal) / dot(rd, normal);\n    if (len < 0.0) return false;\n    hit = rtIntersection(len, ro + len * rd, normal, -1);\n    return true;\n}\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n    \nbool intersect_aabb(vec3 ro,vec3 rd, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / rd;\n\tvec3 t_1 = (aabb.min_ - ro) * div;\n\tvec3 t_2 = (aabb.max_ - ro) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3 ray_at(vec3 ro,vec3 rd, float t)\n{\n\treturn ro + t * rd;\n}\n\nfloat intersect_box(vec3 ro,vec3 rd, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ro,rd, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ro,rd,t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nrtIntersection rayTraceScene(vec3 ro,vec3 rd)\n{\n    float maxt=10000.0;\n    rtIntersection noResult=rtIntersection(-1.0,vec3(0.0),vec3(0.0),0);\n\n    rtIntersection resultSphere;\n    if (intersectSphere(.3,vec3(0.0,.3,4.5+5.0*sin(iTime/2.0)),ro,rd,resultSphere))\n    {\n        maxt=resultSphere.dist;\n        resultSphere.material=0;\n    }\n\n    rtIntersection resultSphere2;\n    if (intersectSphere(0.23,vec3(.8*sin(iTime),.2,-1.*cos(iTime)),ro,rd,resultSphere2))\n    {\n        maxt=min(maxt,resultSphere2.dist);\n        resultSphere2.material=3;\n    }\n\n    rtIntersection resultSphere3;\n    if (intersectSphere(.2,vec3(cos(iTime),.2,-0.25),ro,rd,resultSphere3))\n    {\n       \tmaxt=min(maxt,resultSphere3.dist);\n        resultSphere3.material=1;\n    }\n    \n    rtIntersection resultPlane;\n    if (intersectPlane(vec3(0.0,1.0,0.0),ro,rd,resultPlane))\n    {\n        maxt=min(maxt,resultPlane.dist);\n        resultPlane.material=2;\n    }\n\n    rtIntersection resultPlane2; // Up\n    if (intersectPlane(vec3(0.0,-1.0,0.0),ro-vec3(0.0,2.0,0.0),rd,resultPlane2))\n    {\n        maxt=min(maxt,resultPlane2.dist);\n        resultPlane2.material=2;\n    }\n\n    rtIntersection resultPlane3;\n    if (intersectPlane(vec3(1.0,0.0,0.0),ro-vec3(-1.2,0.0,0.0),rd,resultPlane3))\n    {\n        maxt=min(maxt,resultPlane3.dist);\n        resultPlane3.material=2;\n    }\n\n    rtIntersection resultPlane4;\n    if (intersectPlane(vec3(-1.0,0.0,0.0),ro-vec3(1.2,0.0,0.0),rd,resultPlane4))\n    {\n        maxt=min(maxt,resultPlane4.dist);\n        resultPlane4.material=2;\n    }\n\n    const int numBoxes=4;\n    rtIntersection resultBoxes[numBoxes];\n    float boxDist[numBoxes];\n    if (iTime>=(60.0/globalTempo)*32.)\n    {\n        for (int b=0;b<numBoxes;b++)\n        {\n            float x=0.2;//float(b)*0.1;\n            float y=1.9;//mod(float(b)*234.0,4.0);\n            vec3 dimensions=vec3(1.5,.1,2.2);\n\n            if (b==2)\n            {\n                x=.5;\n                dimensions=vec3(0.2,2.1,2.2);\n            }\n\n            if (b==0)\n            {\n                x=-0.1;\n                dimensions=vec3(0.2,2.1,2.2);\n            }\n\n            vec3 resNormal;\n            boxDist[b]=intersect_box(ro-vec3(-.7+x*4.0,y,-64.0+mod(32.0*iTime+float(b)*32.0,128.0)),rd,resNormal,\n                                     dimensions);\n            if (boxDist[b]!=INFINITY)\n            {\n                maxt=min(maxt,boxDist[b]);\n                resultBoxes[b].material=b+4;\n                resultBoxes[b].dist=boxDist[b];\n                resultBoxes[b].normal=resNormal;\n            }\n        }\n    }\n    \n    if (maxt==resultSphere.dist) return resultSphere;\n    if (maxt==resultSphere2.dist) return resultSphere2;\n    if (maxt==resultSphere3.dist) return resultSphere3;\n    if (maxt==resultPlane.dist) return resultPlane;\n    if (maxt==resultPlane2.dist) return resultPlane2;\n    if (maxt==resultPlane3.dist) return resultPlane3;\n    if (maxt==resultPlane4.dist) return resultPlane4;\n    \n    if (iTime>=(60.0/globalTempo)*32.)\n    {\n        for (int b=0;b<numBoxes;b++)\n        {\n            if (maxt==boxDist[b]) return resultBoxes[b];\n        }\n    }\n        \n    return noResult;\n}\n\n\n//\n//\n//\n\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineDistribution(vec3 dir)\n{\n\t//dir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n(dir.xy,iTime);\n\tr.x=r.x*2.*3.141592;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    float fogAmount = 1.0 - exp(-dist * 0.035);\n    return mix(c, fxcol, fogAmount);\n}\n\nvec3 pathTrace(vec3 ro, vec3 rd, in vec2 fragCoord,in vec2 uv,out float firstDistance)\n{\n    vec3 fogColor=vec3(0.008,0.08,0.08);\n    //vec3 lightPos=vec3(1.2,4.0,-2.0);\n\n    vec3 rayOrigin=ro;\n    vec3 rayDir=rd;\n    \n    vec3 accumulatedCol=vec3(0.0);\n    vec3 firstRayHit=vec3(-1.0);\n    \n    for (int ref=0;ref<maxRayReflections;ref++)\n    {\n        rtIntersection rayHit=rayTraceScene(rayOrigin,rayDir);\n        if (rayHit.dist==-1.0)\n        {\n        \tif (ref==0) accumulatedCol=vec3(fogColor);\n            return accumulatedCol;\n        }\n        \n        int mat=rayHit.material;\n        vec3 pHit=rayOrigin+rayDir*rayHit.dist;\n        if (ref==0) firstDistance=rayHit.dist;\n        vec3 N=rayHit.normal;\n        //float dotprod=max(dot(lightPos,N),0.0);\n\n        if (mat==0)\n        {\n            accumulatedCol+=vec3(0.71,0.2,.1712)*9.52;\n        }\n        else if (mat==1)\n        {\n            accumulatedCol+=vec3(0.31,0.52,.962)*2.52;\n        }\n        else if (mat==2) // walls\n        {\n            vec3 pHit2=vec3(pHit.x,pHit.y,pHit.z-iTime*8.0);\n            vec2 tuv = pHit2.yz + vec2(N.x, 0);\n            if (abs(N.y)>0.2) tuv = pHit2.xz + vec2(0, N.y);\n\n            vec3 sampleCol;\n            tuv*=4.;\n\n            if (abs(N.y)>0.2) tuv*=.8;\n            vec2 id = floor(tuv);\n            tuv -= id + .5;\n\n            vec3 pointcol=vec3(hash21(id));\n            sampleCol = pointcol;\n\n            float k=1.0;\n            // sync with snare entry\n            if ((iTime>=(60.0/globalTempo)*64.) && (mod(hash21(id+floor(iTime/(60.0/globalTempo))),8.0)>0.96)) k=128.0;\n            if (ref==0) \n            {\n                accumulatedCol=sampleCol*vec3(.11,.14,.28)*k;\n            }\n            else\n            {\n                if (k==1.0) accumulatedCol*=sampleCol;\n                else accumulatedCol+=sampleCol;\n            }\n            if (ref==0) accumulatedCol=fog(accumulatedCol,distance(rayOrigin,firstRayHit),fogColor);\n            \n            if (mod(hash21(id - .2),8.0)<0.06) mat=3;\n        }\n        else if (mat==3)\n        {\n            accumulatedCol += 0.1;\n        }\n        else if ((mat==4)||(mat==5)||(mat==6)||(mat==7))\n        {\n            if (mat==4) accumulatedCol+=vec3(0.31,0.52,.962)*12.52;\n            if (mat==5) accumulatedCol+=vec3(0.61,0.2,.1712)*2.52;\n            if (mat==6) accumulatedCol+=vec3(0.71,0.12,.1712)*12.52;\n            if (mat==7) accumulatedCol+=vec3(0.271,0.52,.712)*12.52;\n            //accumulatedCol+=vec3(0.92)*3.0;\n        }\n\n        // bounce ray\n        rayOrigin=pHit+N*.004;\n        if (mat==3) { vec3 randRay=normalize(getCosineDistribution(reflect(rayDir,N))); rayDir=mix(normalize(reflect(rayDir,N)),randRay,0.1); }\n        else rayDir=normalize(getCosineDistribution(reflect(rayDir,N)));\n    }    \n\n    /*rtIntersection rayHit=rayTraceScene(rayOrigin,rayDir);\n    if (rayHit.dist==-1.0)\n    {\n        return accumulatedCol;\n    }\n\n    int mat=rayHit.material;\n    vec3 pHit=rayOrigin+rayDir*rayHit.dist;\n    //if (ref==0) firstDistance=rayHit.dist;\n    vec3 N=rayHit.normal;\n    float dotprod=max(dot(lightPos,N),0.0);\n    if (mat==0)\n    {\n        accumulatedCol+=vec3(0.71,0.2,.1712)*dotprod;\n    }\n    else if (mat==2) // walls\n    {\n        accumulatedCol+=vec3(0.11,0.12,.12)*dotprod;\n    }*/\n    \n    //accumulatedCol=fog(accumulatedCol,distance(rayOrigin,firstRayHit),fogColor);\n    return accumulatedCol;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0*(screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float camadderx=0.0; float camaddery=0.0;\n    if (iMouse.z>0.0)\n    {\n    \tvec2 mousepos=(iMouse.xy-0.5*iResolution.xy)/iResolution.x;\n        camadderx=(mousepos.x)*1.5;\n        camaddery=(-mousepos.y)*2.0;\n    }    \n    \n    camPos=vec3(camadderx+0.5*sin(iTime)*cos(iTime),camaddery+0.8+.2*sin(iTime),-2.);\n    //camPos=vec3(0.0,0.8,-2.);\n    camTarget=vec3(0.0,0.32,0.0);\n    \n    vec3 finalCol=vec3(0.0);\n\n    float fd=0.0;\n    float totalfd=0.0;\n    for (int s=0;s<samplesPerPixel;s++)\n    {\n        vec2 seed = uv.xy * (float(100-s) - 1.0);\n    \tvec3 rayDir = getCameraRayDir(uv-(oldRand(seed,iTime)/256.0), camPos, camTarget); \n    \tfinalCol+=pathTrace(camPos, rayDir,fragCoord,uv,fd);\n        totalfd+=fd;\n    }\n    finalCol/=float(samplesPerPixel);\n    totalfd/=float(samplesPerPixel);\n    \n    finalCol=pow(finalCol,vec3(0.45));\n    \n    float coc=totalfd*0.02;\n    if ((totalfd>2.0)&&(totalfd<=2.5)) coc=totalfd*0.05;\n    if (totalfd>2.5) coc= 0.7 * abs(1.0 - length(camPos - camTarget) / totalfd);\n    \n    // if you like motion blur\n    //fragColor = vec4(mix(texture(iChannel0, fragCoord / iResolution.xy).rgb,finalCol, 0.5),coc);\n    fragColor = vec4(finalCol,coc);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\n// bytebeat\n//\n\n#define PI 3.141592\n#define TAU PI*2.0\n\n\nfloat notes[12];\n\n\n//\n//\n//\n\nfloat modfix(float phase) {\n    return mod(phase, TAU);\n}\n\nfloat sinf(float t, float freq) {\n\treturn sin(modfix(TAU * t * freq));\n}\n\nfloat kick(float t) \n{\n    return clamp(1.25 * sinf(t, 120. * exp(-t * 5.0)) * exp(-t * 5.), -1.0, 1.0) * smoothstep(0.001, 0.003, t);\n}\n\n//\n// saw\n//\n\nfloat sawpitch(float p) {\n\treturn pow(1.059460646483, p) * 440.0;\n}\n\nfloat saw(float phase) \n{\n    float s = 0.0;\n    for (int k=1; k < 17; k++) {\n        s += (sin(TAU*float(k)*phase) / float(k));\n    }\n    return -(1.0/PI)*s;\n}\n\nvec2 sawSynth(float t,vec3 notes)\n{\n    // good triads: 0,2,7 0,3,7 0,3,2\n    float s = 0.0;\n    float semitones[3];\n    semitones[0] = notes.x;\n    semitones[1] = notes.y;\n    semitones[2] = notes.z;\n    \n    for (int i=0;i<3;i++) \n    {\n        float f = sawpitch(semitones[i]);\n        \n        for (int u=0;u<3;u++) {\n            float fu = float(u);\n            float new_f = f + fu*sin(fu);\n    \t\ts += saw(t * new_f)*0.11111111111111;\n        }\n    }\n    \n    return vec2(\n        s*clamp((1.0+cos(t))/2.0,0.25,0.75),\n        s*clamp((1.0+sin(t))/2.0,0.25,0.75)\n    );\n}\n\n// synthie\n\nfloat pulse( float morph, float pulse, float phase )\n{\n\tfloat a, b;\n    if( pulse < 0.5 )\n        a = morph * pulse * 0.5;\n    else\n        a = morph * ( 1.0 - pulse ) / 2.0;\n    if( phase < pulse )\n    {\n        if( phase < a )\n        {\n            b = phase / a - 1.0;\n            return 1.0 - b * b;\n        }\n        if( phase < pulse - a )\n            return 1.0;\n        b = ( phase - pulse + a ) / a;\n        return 1.0 - b * b;\n    }\n    if( phase < pulse + a )\n    {\n        b = ( phase - pulse ) / a - 1.0;\n        return b * b - 1.0;\n    }\n    if( phase <= 1.0 - a )\n        return -1.0;\n    b = ( phase - 1.0 + a ) / a;\n    return b * b - 1.0;\n}\n\nvec2 synthie(float time,float note1,float note2)\n{\n\tfloat y=time*globalTempo/240.0;\n    float a=16.0;\n    float s=1.0;\n    float b=16.0;\n    float bi=floor(b*y);\n    float w=b*y-bi;\n    float sqe=pow(min(1.0,min(s-s*w,a*w)),2.0)*(3.0-mod(bi,3.0));\n    float x=time*note1;\n    float x2=time*note2;\n    \n    float wave=\n        pulse(0.75, 0.75, fract(x))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*0.1, 0.5+0.45*sin(y*16.0), fract(x))+\n        pulse(0.75, 0.75, fract(x2))+pulse(0.9+sin(y*2.0/16.0)*0.1-sqe*0.1, 0.5+0.45*sin(y*16.0), fract(x2));\n        \n    \n    return ((1.0+0.5*sin(time))/2.0)*vec2(\n        (wave*sqe*0.07)*clamp((1.0+sin(time))/2.,0.25,0.75),\n        (wave*sqe*0.07)*clamp((1.0+cos(time))/2.,0.25,0.75)\n    );\n}\n\n// snare\n\nvec2 sine(float time, float freq) {\n    return vec2(sin(time * freq * 3.1415 * 2.));\n}\n\nvec2 noise(float a, float b) {\n    return vec2(2. * (0.5 - fract(sin(dot(vec2(a, b) ,vec2(12.9898,78.213))) * 42758.5453)));\n}\n\nvec2 exp_noise(float time, float b, float q) {\n    return vec2(noise(time, b) * exp(-time * q));\n}\n\nvec2 exp_sine(float time, float freq, float q) {\n    return vec2(sine(time, freq)) * exp(-time * q);\n}\n\nvec2 snare(float time) {\n    return exp_noise(time, 1., 20.) * 0.3 + exp_sine(time, 200. * exp(-time), 50.) * 0.7;\n}\n\nvec2 tom(float time) {\n    return exp_sine(time, 60. * exp(-time), 25.);\n}\n\nvec2 finalSnare(float time,float panning)\n{\n    return 0.9 * vec2(\n        (tom(fract(time)) + snare(fract(time))).x*panning,\n        (tom(fract(time)) + snare(fract(time))).y*(1.0-panning)\n        );\n}\n\n// hi-hat\n\nvec2 hihat(float time,float panning)\n{\n    float tb = mod(time,(60.0/globalTempo)*0.25);\n    float hihat=(fract(cos(time * 32234.523) * 134.) * exp(mod(tb, 1. / 2.0) / 2.0 * -120.)*(fract(tb) + .2));\n    return vec2(hihat*panning,hihat*(1.0-panning))*.55;\n}\n\n#define hihatsss(starttime,endtime,panning) if ((time>=starttime)&&(time<endtime)) finalSound+=hihat(time,panning);\n\n// bazzz\n\nfloat adsr(float t, vec4 env, float s)\n{\n    float a = t/env.x;\n    float d = max(s, 1.0-(t-env.x)*(1.0-s)/env.y);\n    float r = (1.0 - max(0.0,t-(env.x+env.y+env.z))/env.w);\n    return max(0.,min(a, r*d));\n}\n\nfloat sineBazz(float phase, float time, float note) \n{\n    return sin (TAU*note*4.0*phase)*exp(-3.*phase);\n}\n\nvoid initNotes()\n{\n\tnotes[0]=16.055;\n    notes[1]=17.01;\n    notes[2]=18.02;\n    notes[3]=19.09;\n    notes[4]=20.225;\n    notes[5]=21.43;\n    notes[6]=22.705;\n    notes[7]=24.055;\n    notes[8]=25.485;\n    notes[9]=27.00;\n    notes[10]=28.605;\n    notes[11]=30.305;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 finalSound=vec2(0.0);\n    \n    initNotes();\n\n    if (time>=(60.0/globalTempo)*32.)\n    {\n        if ((time>=(60.0/globalTempo)*31.5)&&(time<(60.0/globalTempo)*120.0))\n        {\n            finalSound += kick(mod(time,60.0/globalTempo))*0.5;\n        }\n\n        const int numSteps=16;\n        int notearr[16];\n        notearr[0]=0;notearr[1]=3;notearr[2]=0;notearr[3]=6;\n        notearr[4]=0;notearr[5]=0;notearr[6]=0;notearr[7]=0;\n        notearr[8]=0;notearr[9]=3;notearr[10]=0;notearr[11]=5;\n        notearr[12]=6;notearr[13]=1;notearr[14]=0;notearr[15]=5;\n\n        float note=notes[notearr[int(mod((floor(time/(60.0/globalTempo))),16.0))]];\n        float b = sineBazz(mod (time, (60.0/globalTempo)*0.25), time,note);\n\n        b = adsr(b, vec4(1.1, .1, 1.9, 1.0), 1.0)*(.9+.5*abs(sin(time)));\n        b *= b*b;\n        finalSound+=b*0.15;\n\n        hihatsss((60.0/globalTempo)*32.,(60.0/globalTempo)*36.0,0.30);\n        hihatsss((60.0/globalTempo)*40.,(60.0/globalTempo)*44.0,0.30);\n        hihatsss((60.0/globalTempo)*48.,(60.0/globalTempo)*52.0,0.30);\n        hihatsss((60.0/globalTempo)*56.,(60.0/globalTempo)*60.0,0.30);\n        hihatsss((60.0/globalTempo)*64.0,(60.0/globalTempo)*96.0,0.30);\n        \n\t\tif (time>(60.0/globalTempo)*96.0) finalSound+=sawSynth(mod(time-(60.0/globalTempo)*96.0,32.0*(60.0/globalTempo)),vec3(12.+7.8))*0.02;\n    }\n\n    if (\n        (time>=(60.0/globalTempo)*32.) &&\n        (time<(60.0/globalTempo)*96.0)\n       )\n    {\n        finalSound+=finalSnare(fract(mod((time+0.45),2.0*60.0/globalTempo)),0.65)*0.6;\n        if (time>=(60.0/globalTempo)*64.) finalSound+=finalSnare(fract(mod((time+.55),4.*60.0/globalTempo)),0.35)*0.6;\n    }\n\n    // open all\n    if (time>=(60.0/globalTempo)*126.)\n    {\n        finalSound += kick(mod(time,60.0/globalTempo))*0.5;\n        hihatsss((60.0/globalTempo)*120.0,(60.0/globalTempo)*256.0,0.30);\n        finalSound+=finalSnare(fract(mod((time+0.45),2.0*60.0/globalTempo)),0.65)*0.6;\n\t\tfinalSound+=finalSnare(fract(mod((time+.55),4.*60.0/globalTempo)),0.35)*0.6;\n    }\n    \n    time=mod(time,(60.0/globalTempo)*32.0);\n    if (time<(60.0/globalTempo)*16.0) finalSound+=synthie(time,notes[0]*16.0,notes[3]*18.0)*0.4;\n    else finalSound+=synthie(time,notes[3]*12.0,notes[8]*12.0)*0.4;\n\n    \n    return finalSound*1.2;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}