{
    "Shader": {
        "info": {
            "date": "1571874693",
            "description": "Anaglyph Decoration. Framed for https://fanzine.cookie.paris/",
            "flags": 0,
            "hasliked": 0,
            "id": "td3SDH",
            "likes": 9,
            "name": "Anaglyph Decoration",
            "published": 3,
            "tags": [
                "anaglyph",
                "cookiezine",
                "cookieparty"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 501
        },
        "renderpass": [
            {
                "code": "// Anaglyph Decoration\n// Framed for https://fanzine.cookie.paris/\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.10.24\n// Using code from Inigo Quilez\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\n\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * .75 + right * anchor.x + up * anchor.y);\n}\n\nfloat map (vec3 pos) {\n    vec3 p = pos;\n    float scene = 10.0;\n    float r = 1.0;\n    const float count = 9.0;\n    for (float index = count; index > 0.0; --index) {\n        pos.xz = abs(pos.xz)-1.4*r;\n        pos.yx *= rot(3.9/r + iTime * 0.3);\n        pos.yz *= rot(0.5/r + iTime * 0.2);\n        pos.xz *= rot(0.2/r + iTime * 0.1);\n        scene = min(scene, abs(max(pos.x, max(pos.y, pos.z))));\n        r /= 1.8;\n    }\n    scene = max(abs(p.z)-1., scene);\n    scene = max(-length(p.xy)-p.z*.5, scene);\n    return scene;\n}\n\nvec4 raymarch (vec3 eye, vec3 ray) {\n    float dither = random(ray.xy+fract(iTime));\n    vec4 result = vec4(eye, 0);\n    float total = 0.1 * dither;\n    float maxt = 20.0;\n    const float count = 30.;\n    for (float index = count; index > 0.0; --index) {\n        result.xyz = eye + ray * total;\n        float dist = map(result.xyz);\n        if (dist < 0.001 + total * .001 || total > maxt) {\n            result.w = index / count;\n            break;\n        }\n        dist *= 0.7 + 0.1 * dither;\n        total += dist;\n    }\n    result.w *= step(total, maxt);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(.2,.1,-2.);\n    vec3 at = vec3(0);\n    vec3 ray = look(eye, at, uv);\n    vec3 eyeoffset = 0.02*normalize(cross(normalize(at-eye), vec3(0,1,0)));\n    vec4 resultLeft = raymarch(eye-eyeoffset, ray);\n    vec4 resultRight = raymarch(eye+eyeoffset, ray);\n    fragColor = vec4(resultLeft.w,vec2(resultRight.w),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}