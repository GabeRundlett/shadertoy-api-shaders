{
    "Shader": {
        "info": {
            "date": "1715010665",
            "description": "Voronoi landscape...",
            "flags": 0,
            "hasliked": 0,
            "id": "lcVSR1",
            "likes": 12,
            "name": "Voronoi Hills",
            "published": 3,
            "tags": [
                "raymarching",
                "voronoi",
                "landscape"
            ],
            "usePreview": 0,
            "username": "Alie",
            "viewed": 208
        },
        "renderpass": [
            {
                "code": "#define r2d(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\nvec3 hash3(vec3 p) {\n\tp=fract(p*vec3(443.897,441.423,437.195));\n\tp+=dot(p,p.yxz+19.19);\n\treturn fract((p.xxy+p.yxx)*p.zyx);\n}\n\nvec2 hash2(vec2 p) {\n\tp=fract(p*vec2(443.897,441.423));\n\tp+=dot(p,p.yx+19.19);\n\treturn fract((p.xy+p.yx)*p.xy);\n}\n\nfloat lineDist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Returns 3 random values + distance from centre\nvec4 voronoiCentre2(vec2 p) {\n    vec2 a = floor(p),\n    d = ceil(p),\n    b = vec2(d.x, a.y),\n    c = vec2(a.x, d.y);\n    const float scale = 1./sqrt(2.);\n    \n    float ad = distance(p, a + hash2(a) * scale - scale * .5),\n    bd = distance(p, b + hash2(b) * scale - scale * .5),\n    cd = distance(p, c + hash2(c) * scale - scale * .5),\n    dd = distance(p, d + hash2(d) * scale - scale * .5);\n    \n    float m = min(ad, min(bd, min(cd, dd)));\n    a = m==ad ? a : (m==bd ? b : (m==cd ? c : d));\n    \n    vec3 k = hash3(a.xyy);\n    return vec4(k, m);\n}\n\n// Returns 3 random values + distance from edge\nvec3 voronoiEdge2(vec2 p) {\n    p /= 8.;\n    vec2 ip = floor(p),\n    fp = fract(p),\n    selectedCell, selectedPos;\n\n    // first pass: regular voronoi\n    float minD = 8.0;\n    vec2 k;\n    for(int j=-1; j<=1; j++) {\n        for(int i=-1; i<=1; i++) {\n            vec2 cell = vec2(float(i), float(j));\n            vec2 rand = hash2(ip + cell);\n            vec2 pos = cell + rand - fp;\n            float d = dot(pos, pos);\n\n            if(d < minD) {\n                minD = d;\n                selectedPos = pos;\n                selectedCell = cell;\n                k = rand;\n            }\n        }\n    }\n\n    // second pass: distance to borders\n    minD = 8.0;\n    for(int j=-1; j<=1; j++) {\n        for(int i=-1; i<=1; i++) {\n            vec2 pos = selectedCell + vec2(i, j);\n            vec2 rand = hash2(ip + pos);\n            vec2 newPos = pos + rand - fp;\n\n            if( dot(selectedPos - newPos, selectedPos - newPos) > 0.0001) {\n                minD = min(\n                    minD, \n                    dot((selectedPos + newPos) * .5, normalize(newPos - selectedPos))\n                );\n            }\n        }\n    }\n    return vec3(k, minD);\n}\n\nvec3 df(vec3 p) {\n    vec3 d = vec3(0);\n    float s = 1.;\n    for (int i=0; i<3; i++) {\n        r2d(p.xz, 1.);\n        vec3 e = voronoiEdge2(p.xz * s);\n        p.y -= e.z * 4. / s;\n        d.z = p.y * .5;\n        d.xy += e.xy;\n        s++;\n    }\n    d.xy /= 3.;\n    return d;\n}\n\nvec3 norm(vec3 p, float d) {\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(\n        d - df(p-e.xyy).z,\n        d - df(p-e.yxy).z,\n        d - df(p-e.yyx).z\n    ));\n}\n\nvec3 rm(vec3 p, vec3 dir) {\n    vec3 d;\n    for (int i=0; i<40; i++) {\n        d = df(p);\n        if (d.z < 0.001) {\n            break;\n        }\n        p += d.z * dir;\n    }\n    vec3 n = norm(p, d.z);\n    return d.yyy * max(0., dot(n, normalize(vec3(1.,1,-1))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.yy;\n    \n    vec3 p = vec3(0,5.+sin(iTime / 5.) * 2.,iTime*3.),\n    d = normalize(vec3(uv, 1.));\n    r2d(d.yz, 1.);\n    \n    vec3 col = rm(p, d);\n    //vec3 k = vec3(1) - step(0.98, max(fract(uv.x), fract(uv.y)));\n    \n   \n    //vec4 v2 = voronoiCentre2(uv);\n    //vec4 v2 = voronoiEdge2(uv);\n    fragColor = vec4(col, 1.);  \n    //fragColor = vec4(v2.rgb+smoothstep(.8, .95, fract(v2.w * 8. - iTime)),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}