{
    "Shader": {
        "info": {
            "date": "1502468290",
            "description": "An aeons-old city is found within the frozen heart of Antarctica.\n\nInspired by the novella 'At the Mountains of Madness' by H.P. Lovecraft.\n\nMouse rotates camera.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldjBzt",
            "likes": 80,
            "name": "At The Mountains",
            "published": 3,
            "tags": [
                "fractal",
                "terrain",
                "tower",
                "mountains",
                "city"
            ],
            "usePreview": 1,
            "username": "ssell",
            "viewed": 6563
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://www.shadertoy.com/view/ldjBzt\n *\n * An aeons-old city is found within the frozen heart of Antarctica.\n * Inspired by the novella 'At the Mountains of Madness' by H.P. Lovecraft.\n *\n *     Buffer A: Scene rendering.\n *     Image: Scene sampling and antialiasing.\n *\n * ------------------------------------------------------------------------\n * - References / Sources\n * ------------------------------------------------------------------------\n *\n * As with all of my shaders, part of this work is something old, part is\n * something new, and part is something borrowed. Oh, there is also some blue.\n *\n * [Terrain]\n *\n *     'Value Noise Derivatives' - iq\n *     https://iquilezles.org/articles/morenoise\n *\n *         This was my first go with this method of heightmap generation,\n *         so naturally iq's article on it was tremendously helpful.\n *\n * [Lighting]\n *\n *     'Outdoors Lighting' - iq\n *      https://iquilezles.org/articles/outdoorslighting\n *\n *         Second time using this lighting setup, and it works very well \n *         for large, outdoor scenes.\n *\n * [Volumetric Fog]\n *\n *     'Frozen Wasteland' - Dave_Hoskins\n *     https://www.shadertoy.com/view/Xls3D2\n *\n *     'Xyptonjtroz' - Nimitz\n *     https://www.shadertoy.com/view/4ts3z2\n *\n *         Though my final fog result is fairly different from theirs, they were\n *         still valuable resources. The Noise3D function is taken from Dave_Hoskins.\n *\n * [Pathing]\n *\n *     'Fourier vs Spline Interpolation' - revers\n *     https://www.shadertoy.com/view/MlGSz3\n *\n *         Used revers' Catmull-Rom implementation in the camera path interpolation.\n * \n * [SDFs]\n *\n *     'Modeling with Distance Functions' - iq\n *     https://iquilezles.org/articles/distfunctions\n *\n *     'Smooth Minimum' - iq\n *     https://iquilezles.org/articles/smin\n *\n *         Naturally.\n *\n * [Anti-Aliasing]\n *\n *     'Anti-Aliasing Compare' - JasonD\n *     https://www.shadertoy.com/view/4dGXW1\n *\n *         Implemented '3Dfx rotated grid' in SampleAA().\n *\n * ------------------------------------------------------------------------\n * - Known Issues / To-Do\n * ------------------------------------------------------------------------\n *\n *     - Terrain 'warp' bubbles.\n *     - Fullscreen performance.\n *     - General refactoring.\n *     - City aliasing.\n *     - The sky is pretty plain.\n *     - A better title...\n */\n\nvec4 SampleAA(sampler2D sampler, in vec2 uv)\n{\n    vec2 s = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 o = vec2(0.11218413712, 0.33528304367) * s;\n    \n    return (texture(sampler, uv + vec2(-o.x,  o.y)) +\n            texture(sampler, uv + vec2( o.y,  o.x)) +\n            texture(sampler, uv + vec2( o.x, -o.y)) +\n            texture(sampler, uv + vec2(-o.y, -o.x))) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec3 color = SampleAA(iChannel0, uv).rgb;\n    color *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.1); // Vignette\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://www.shadertoy.com/view/ldjBzt\n */\n\n#define TerrainNearClip    0.1\n#define TerrainFarClip     25000.0\n#define TerrainMaxSteps    100\n#define TerrainMaxHeight   800.0\n#define TerrainTexScale    0.0005\n#define TerrainPersistence 0.5\n\n#define CityNearClip       0.1\n#define CityFarClip        150.0\n#define CityMaxSteps       200\n\n#define NumPathPoints      20\n#define PathClamp(x)       clamp(x, 0, NumPathPoints - 1)\n\nconst float TexDim      = 1.0 / 256.0;\nconst mat2  m2          = mat2(0.8, 0.6, -0.6, 0.8);\n\nconst vec3 SunDir       = normalize(vec3(0.5, 1.5, 1.25));\nconst vec3 SunColor     = vec3(1.0, 1.0, 0.7);\n\nconst vec3 SkyDir       = normalize(vec3(0.0, 1.0, 0.0));\nconst vec3 SkyColor     = vec3(0.0, 0.0, 1.0);\n\nconst vec3 AmbDir       = normalize(SunDir * vec3(-1.0, 0.0, -1.0));\nconst vec3 AmbColor     = vec3(1.0, 1.0, 1.0);\n\nconst vec3 StartPos     = vec3(1100.0, 0.0, 1000.0);\nconst vec3 EndPos       = vec3(1100.0, 0.0, 26100.0);\nconst vec3 CityPos      = vec3(1400.0, 200.0, 13500.0);\n\nconst float TimeStep    = 6.5;\nconst float SceneLength = TimeStep * float(NumPathPoints);\n\nconst vec2 Path[NumPathPoints] = vec2[]( vec2(1100.0, 1000.0), vec2(1100.0, 3000.0), vec2(1200.0, 4800.0), vec2(1100.0, 6500.0), vec2(1250.0, 8000.0), vec2(1400.0, 9500.0), vec2(1400.0, 11000.0), vec2(1000.0, 13000.0), vec2(1000.0, 14000.0), vec2(1800.0, 14000.0), vec2(1800.0, 13000.0), vec2(600.0, 12500.0), vec2(600.0, 14500.0), vec2(1400.0, 16000.0), vec2(1400.0, 17500.0), vec2(1250.0, 19300.0), vec2(1100.0, 20500.0), vec2(1200.0, 22300.0), vec2(1100.0, 24100.0), vec2(1100.0, 27100.0));\n\n\n//------------------------------------------------------------------------------------------\n// Ray \n//------------------------------------------------------------------------------------------\n    \nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \n//------------------------------------------------------------------------------------------\n// Camera Structures and Functions\n//------------------------------------------------------------------------------------------\n\nstruct Camera\n{\n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    vec3 origin;\n};\n\nRay Camera_GetRay(in Camera camera, vec2 uv)\n{\n    Ray ray;\n    \n    uv    = (uv * 2.0) - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    ray.origin    = camera.origin;\n    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.0));\n\n    return ray;\n}\n\nCamera Camera_LookAt(vec3 origin, vec3 lookAt)\n{\n\tCamera camera;\n    \n    camera.origin  = origin;\n    camera.forward = normalize(lookAt - camera.origin);\n    camera.right   = normalize(cross(camera.forward, vec3(0.0, 1.0, 0.0)));\n    camera.up      = normalize(cross(camera.right, camera.forward));\n    \n    return camera;\n}\n\n// Catmull-Rom Matrix\nconst mat4 CRM = mat4(-0.7, 2.0 - 0.7, 0.7 - 2.0, 0.7, 2.0 * 0.7, 0.7 - 3.0, 3.0 - 2.0 * 0.7, -0.7, -0.7, 0.0, 0.7, 0.0, 0.0, 1.0, 0.0, 0.0);\n\nvec2 InterpCRM(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) \n{\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n\n// Interpolates the camera along the pre-defined path. Updates only .xz position.\nvec3 CameraPos(float time)\n{\n    float tmod = mod(iTime, SceneLength);  // Repeat the path every 'SceneLength' seconds\n    \n    int i = int(tmod / TimeStep);          // Determine the current path step.\n                                           // We are on 'b' and heading to 'c'.\n    int a = PathClamp(i - 1);              \n    int b = PathClamp(i + 0);\n    int c = PathClamp(i + 1);\n    int d = PathClamp(i + 2);\n    \n    vec2 pxz = InterpCRM(Path[a], Path[b], Path[c], Path[d], mod(tmod, TimeStep) / TimeStep);\n    \n    return vec3(pxz.x, 0.0, pxz.y);\n}\n\n//------------------------------------------------------------------------\n// Terrain Generation\n//------------------------------------------------------------------------\n\nfloat DistanceRatioCamera(vec2 p)\n{\n    // Returns ratio [0, 1] depending on distance to camera start/end position.\n    // 0.0 = At camera start/end position.\n    // 1.0 = 4000.0 or more units from camera start/end position.\n    \n\tfloat ds = length(p - StartPos.xz);\n    float de = length(p - EndPos.xz);\n    \n    float d = min(ds, de);\n    \n    return smoothstep(0.0, 1.0, clamp(d / 4000.0, 0.325, 1.0));\n}\n\nfloat DistanceRatioCity(vec2 p)\n{\n    // Returns ratio [0, 1] depending on distance to city position.\n    // 0.0 = At city center.\n    // 1.0 = 7500.0 or more units away from city center.\n    \n\tfloat d = distance(p, CityPos.xz);\n    float r = clamp(d / 7500.0, 0.0, 1.0);\n    \n    return smoothstep(0.0, 1.0, pow(r, 3.1));\n}\n\n// Returns the terrain noise heightmap value (.x) and it's derivate (.yz) for normals\nvec3 TerrainNoiseRaw(vec2 p)\n{\n    vec2 pfract = fract(p);\n    vec2 pfloor = floor(p);\n    \n    // Quintic interpolation factor (6x^5-15x^4+10x^3) and it's derivative (30x^4-60x^3+30x^2)\n    vec2 lfactor = pfract * pfract * pfract * (pfract * (pfract * 6.0 - 15.0) + 10.0);\n    vec2 lderiv  = 30.0 * pfract * pfract * (pfract * (pfract - 2.0) + 1.0);\n    \n    /** \n     * Noise LUT sample points (p = pfloor):\n     *\n     *      ┌───┬───┐\n     *      │ c │ d │\n     *      ├───┼───┤\n     *      │ a │ b │\n     *      p───┴───┘\n\t */\n    \n    // Use textureLod instead of texture so that Angle (Windows Firefox) doesn't choke.\n    float a = textureLod(iChannel0, (pfloor + vec2(0.5, 0.5)) * TexDim, 0.0).r;\n    float b = textureLod(iChannel0, (pfloor + vec2(1.5, 0.5)) * TexDim, 0.0).r;\n    float c = textureLod(iChannel0, (pfloor + vec2(0.5, 1.5)) * TexDim, 0.0).r;\n    float d = textureLod(iChannel0, (pfloor + vec2(1.5, 1.5)) * TexDim, 0.0).r;\n    \n    /**\n     * For the value (.r) we perform a bilinear interpolation with a \n     * quintic factor (biquintic?) over the four sampled points.\n     *\n     * .r could be written as:\n     * \n     *    mix(mix(a, b, lfactor.x), mix(c, d, lfactor.x), lfactor.y)\n     *\n     * The mixes are factored out so that the individual components\n     * (k0, k1, k2, k4) can be used in finding the derivative (for the normal).\n     */\n    \n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n    \n\treturn vec3(\n        k0 + (k1 * lfactor.x) + (k2 * lfactor.y) + (k4 * lfactor.x * lfactor.y),  // Heightmap value\n        lderiv * vec2(k1 + k4 * lfactor.y, k2 + k4 * lfactor.x));                 // Value derivative\n}\n\nvec3 TerrainNoise(in vec2 p, int octaves)\n{\n    // Samples the terrain heightmap.\n    // There are certain parts of the terrain that could be better (which\n    // I wont point out so hopefully you don't notice it too), but I just\n    // really like the first mountain at the start of the scene.\n    \n    float sratio = DistanceRatioCamera(p);   // Ratio [0, 1] to the camera start position.\n    float cratio = DistanceRatioCity(p);     // Ratio [0, 1] to the city position.\n    \n    float amplitude = 1.0;\n    float value     = 0.0;                   // Cumulative noise value\n    \n\tvec2  deriv     = vec2(0.0);             // Cumulative noise derivative\n\tvec2  samplePos = (p * TerrainTexScale);\n    \n    for(int i = 0; i < octaves; ++i)\n    {\n        // For each iteration we accumulate the noise value, derivative, and\n        // scale/adjust the sample position.\n        \n        vec3 noise = TerrainNoiseRaw(samplePos);\n        \n        // 'noise.x * amplitude': Reduce the contribution of each successive iteration\n        // '* (sratio + 0.1)': Flatten out the terrain at camera start/end\n        // '/ (...)': Sharpen the mountain slopes\n        \n        deriv += noise.yz;\n        value += (noise.x * amplitude * (sratio + 0.1)) / (0.9 + dot(deriv, deriv));\n        \n        amplitude *= TerrainPersistence;\n        samplePos  = m2 * samplePos * 1.9;\n    }\n    \n    // Here we compose the height range for the terrain.\n    // sratio and cratio are used to form the 'craters' or terrain openings\n    // that the camera starts at (sratio) and the city resides in (cratio).\n    // Without this, the entire terrain would be mountains and unusable.\n    // The '+ p.y * 0.01' just accentuates the peaks.\n    \n    float height = mix(100.0, TerrainMaxHeight + p.y * 0.01, min(sratio, cratio));\n    \n\treturn vec3(height * value, deriv);\n}\n\n// Three levels of terrain quality:\n//     High Quality:   Used for normals.\n//     Medium Quality: Used for terrain geometry.\n//     Low Quality:    Used for camera altitude.\n\nvec3 TerrainNoiseHQ(vec2 p) { return TerrainNoise(p, 15); }\nvec3 TerrainNoiseMQ(vec2 p) { return TerrainNoise(p, 9); }\nvec3 TerrainNoiseLQ(vec2 p) { return TerrainNoise(p, 3); }\n\nvec3 TerrainNormal(vec3 pos, float depth)\n{\n    /** \n     * Adjust the gradient epsilon based on geometry depth in scene.\n     * This provides smoother results than fixed epsilon step sizes\n     * when the scene is large. Example:\n     *\n     *     At depth N, adjacent texels may be 1 world unit apart.\n     *     So having an epsilon in the range of 1 would produce \n     *     accurate and smooth normals.\n     *\n     *     But at depth N*M, adjacent texels may be 100 world units apart.\n     *     So having an epsilon at range of 1 would produce potentially\n     *     discontinous normals that appear noisy and inaccurate.\n     */\n    \n    vec2 eps = vec2(0.002 * depth, 0.0 );\n    \n    return normalize(vec3(TerrainNoiseHQ(pos.xz - eps.xy).x - TerrainNoiseHQ(pos.xz + eps.xy).x,\n                          2.0 * eps.x,\n                          TerrainNoiseHQ(pos.xz - eps.yx).x - TerrainNoiseHQ(pos.xz + eps.yx).x));\n}\n\nvec2 MarchTerrain(Ray ray)\n{\n    vec3 pos = vec3(0.0);\n    \n    float depth = TerrainNearClip;\n    float sdf   = 0.0;\n    \n    for(int steps = 0; steps < TerrainMaxSteps; ++steps)\n    {\n        pos = ray.origin + (ray.direction * depth);\n        sdf = pos.y - TerrainNoiseMQ(pos.xz).x;\n        \n        if(sdf < (0.002 * depth) || (depth > TerrainFarClip))\n        {\n            break;\n        }\n        \n        depth += sdf * 0.5;\n    }\n    \n    return vec2(depth, 0.0);\n}\n\n//------------------------------------------------------------------------\n// City Generation\n//------------------------------------------------------------------------\n\nvec3 RotX(in vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return vec3(p.x, (c * p.y) - (s * p.z), (s * p.y) + (c * p.z));\n}\n\nvec3 Repeat(vec3 p, vec3 c)\n{\n\treturn mod(p, c) - (0.5 * c);    \n}\nfloat Box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat HexPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0 - h);\n}\n\nvec2 Tower(vec3 pos)\n{\n    // Constructs the tower, which is the focal point of the scene.\n    // Originally, the entire city was going to be made out of\n    // 3D voronoi noise or similar, and there was not going to be\n    // any central tower (there is no such tower in the AtMoM story).\n    \n    // But that didn't really pan out, so I started hand-making\n    // a few building designs with the intent of repeating them at \n    // various sizes. Again, I wasn't happy with the result.\n    \n    // Then I stumbled across this design, and felt immediately\n    // it should be the central landmark of the city and everything\n    // should radiate out from it. \n    \n    // It is alien enough to definitely not be of human origination.\n    // But at the same time, if colored white, the sides start to \n    // resemble a spine or similar structure.\n    \n    // There is also the benefit that it looks fairly unassuming from\n    // far away, particularly when shadowed.\n    \n    // The base shape of it is a box, but the width decreases slightly\n    // from the bottom to the top (w variable). The change is subtle\n    // but keeps it from being perfectly straight lines.\n    \n    float id   = 0.0;                                               // Used for later texturing\n    float w    = mix(11.45, 10.0, clamp(pos.y / 50.0, 0.0, 1.0));   // Box width\n    float smod = mix(0.65, 0.625, clamp(pos.y / 50.0, 0.0, 1.0));   // 's' modifier\n    float box  = Box(pos, vec3(w, 130.0, w));                       // Base shape\n    float s    = 5.0;                                               // Used in positioning and sphere size\n    \n    for(int i = 0; i < 7; ++i)\n    {\n        // For each iteration we cut away at the tower box with spheres.\n        // Simple and cheap, just have to get the placement/size right.\n        \n        vec3 p  = Repeat(pos, vec3(3.55, 1.5, 3.55) * s);\n        \n    \tfloat c = length(p) - s;\n        float t = max(box, -c);\n        \n        s *= smod;\n        \n        if(t > box)\n        {\n            // Save the iteration (id) that this surface was cut for later shading.\n            id = float(i);\n            box = t;\n        }\n    }\n    \n    // smin with a sphere at the bottom of the tower where it connects\n    // to the base. This gives the core a way to end plus adds on another\n    // slight alien component.\n    \n    float ts = length(pos - vec3(0.0, -12.0, 0.0)) - 10.0;\n    box = smin(box, ts, 10.0);\n    \n    return vec2(box, id);\n}\n\nvec2 Base(vec3 pos)\n{\n    // Constructs the base of the tower.\n    // It is made of two stacked hexes (the bottom slightly wider\n    // than the top) that are cut away to reveal floors, walls, etc.\n    \n    float id = 0.0;\n    float s = 2.025;\n    \n    // Rotate the hexes onto their sides.\n    vec3 rpos = RotX(pos, 3.14 * 0.5);\n    \n    // The top base hex and then the bottom, wider hex sminned onto it.\n    float r = HexPrism(rpos, vec2(30.0, 45.0));\n    r = smin(r, HexPrism(rpos + vec3(0.0, 0.0, 20.0), vec2(36.5, 52.5)), 10.0);\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        // Each iteration we cut away at the base using boxes.\n        // Earlier versions of this produced a base that resembled\n        // the sides of a gothic cathedral. It was actually quite \n        // nice but the city obscures that portion of the base now.\n        \n        vec3 p = pos - vec3(0.0, 10.0, 0.0);\n        p = Repeat(pos, vec3(3.0, 2.10, 3.0) * s);\n        \n    \tfloat b = Box(p, vec3(s));\n        float t = max(r, -b);\n        \n        s *= 0.65;\n        \n        if(t > r)\n        {\n            // Save the iteration (id) that this surface was cut for later shading.\n            id = float(i);\n            r = t;\n        }\n    }\n    \n    return vec2(r, id);\n}\n\nvec2 SCity(vec3 pos)\n{\n    // The city is composed of expanding hexes that are carved away. \n    // The goal was to make something that felt massive but has been\n    // beaten away by countless years of harsh weather.\n    \n    // Each successive hex also gets slightly shorter. This helps to\n    // make the city feel larger and also breaks up the horizon to \n    // reduce depth-related artifacts.\n    \n\tvec3 rpos = RotX(pos, 3.14 * 0.5);    // Rotate the hex prisms on their sides\n    \n    float r = CityFarClip;\n    float id = 0.0;\n    \n    float csize = 40.0;                   // Cut-out hex size\n    float hsize = 80.0;                   // Primary hex size\n    \n    for(int i = 0; i < 4; ++i)            // Construct the city base structure.\n    {                                   \n        // We have a primary hex (h) and it's cutout (c).\n        // This prevents outer hexes from overlapping inner ones, and also\n        // provides separation which may have been roads at one point in time.\n        \n        float c = HexPrism(rpos, vec2(csize, 60.0));\n        float h = HexPrism(rpos, vec2(hsize, 10.0 * mix(3.0, 1.0, float(i) / 3.0)));\n        \n        r = min(r, max(h, -c));\n        \n        csize = hsize * 1.1;\n        hsize = csize * 2.0;\n    }\n    \n    float s0 = 2.025;\n    float s1 = 17.25;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        // Here we cut away at the hex bases.\n        // This is sligtly modified from the Base algorithm.\n        \n        // There are two kinds of cuts being done: box and sphere.\n        \n        // The boxes create the appearance of floors, balconies, etc.\n        // The spheres add a slight alien feel and also an increased sense of disrepair.\n        \n        vec3 p0 = Repeat(pos, vec3(3.0, 2.0, 3.0) * s0);\n    \tvec3 p1 = Repeat(pos, vec3(3.0, 2.0, 3.0) * s1); \n        \n    \tfloat b0 = Box(p0, vec3(s0));\n        float b1 = length(p1) - s1;\n        \n        float t = max(r, -min(b0, b1));\n        \n        s0 *= 0.625;\n        s1 *= 0.415;\n        \n        if(t > r)\n        {\n            // Save the iteration (id) that this surface was cut for later shading.\n            id = float(i);\n            r = t;\n        }\n    }\n    \n    return vec2(r, id);\n}\n\nvec2 CitySDF(vec3 pos)\n{\n    // Todo: Factor out all of these 'if' statements...\n    \n    pos -= CityPos;\n    pos *= 0.165;      // Make the city larger to fill up the crater\n    \n    vec2 tower = Tower(pos - vec3(0.0, 50.0, 0.0));  // Main tower\n    vec2 base  = Base(pos);                          // Base of the tower\n    vec2 city  = SCity(pos);                         // Surrounding city\n    \n    if(tower.x < base.x && tower.x < city.x)\n    {\n        return tower;\n    }\n    \n    if(base.x < tower.x && base.x < city.x)\n    {\n        return base;\n    }\n    \n    // Snow build up at the bottom of the city\n    float snow = smin(pos.y + 10.0, city.x, 2.0);\n    \n    if(snow < city.x)\n    {\n        return vec2(snow, -1.0);\n    }\n    \n    return city;\n}\n\nvec2 MarchCity(in Ray ray)\n{\n\tfloat depth = CityNearClip;\n    vec2  sdf = vec2(0.0);\n    \n    vec3 pos = vec3(0.0);\n    \n    for(int i = 0; i < CityMaxSteps; ++i)\n    {\n   \t\tpos = ray.origin + (ray.direction * depth);\n        sdf = CitySDF(pos);\n        \n        if(sdf.x < CityNearClip)\n        {\n            return vec2(depth, sdf.y);\n        }\n        \n        depth += sdf.x * 6.0;\n    }\n    \n    return vec2(depth, -1.0);\n}\n\nfloat CalcShadow(vec3 pos, vec3 lDir)\n{\n    float tshadow = 1.0;    // Terrain shadow\n    float cshadow = 1.0;    // City Shadow\n    \n    float deptht = 40.0;    // Terrain start depth\n    float depthc = 10.0;    // City start depth\n    \n    float cratio = DistanceRatioCity(pos.xz);\n    \n    // If not within the flat bowl of the city\n    if(cratio >= 0.20)\n    {\n        // Terrain Shadow\n        for(int i = 0; i < 16; ++i)\n        {\n            vec3 pt = pos + (deptht * lDir);\n            float sdft = pt.y - TerrainNoiseMQ(pt.xz).x;\n\n            tshadow = min(tshadow, 8.0 * sdft / deptht);\n            deptht += sdft;\n\n            if((sdft < 0.01) || (pt.y > TerrainMaxHeight * 10.0))\n            {\n                break;\n            }\n        }\n    }\n    \n    // If not in dark terrain shadow and near the city\n    if((tshadow > 0.1) && (cratio < 0.35))\n    {\n        // City Shadow\n    \tfor(int i = 0; i < 16; ++i)\n        {\n            vec3 pc = pos + (depthc * lDir);\n            float sdfc = CitySDF(pc).x;\n            \n            cshadow = min(cshadow, 8.0 * sdfc / depthc);\n            depthc += sdfc;\n            \n            if((sdfc < 0.01) || (sdfc > 20.0))\n            {\n                break;\n            }\n        }\n    }\n    \n    return clamp(min(tshadow, cshadow), 0.1, 1.0);\n}\n\nvec3 CityNormal(vec3 pos, float t)\n{\n\tvec2 eps = vec2(0.001 * t, 0.0);\n    return normalize(\n        vec3(CitySDF(pos + eps.xyy).x - CitySDF(pos - eps.xyy).x,\n             CitySDF(pos + eps.yxy).x - CitySDF(pos - eps.yxy).x,\n             CitySDF(pos + eps.yyx).x - CitySDF(pos - eps.yyx).x));\n}\n\n//------------------------------------------------------------------------\n// Render Terrain\n//------------------------------------------------------------------------\n\nvec3 Sky(vec3 rd)\n{\n    float sun = pow(abs(dot(rd, SunDir)), 15.0);\n    vec3 sky = mix(vec3(0.29804, 0.61569, 0.92157), vec3(0.20980, 0.41764, 0.79215), clamp(abs(rd.y) * 2.0, 0.0, 1.0));\n    \n    return mix(sky, vec3(1.0), sun);\n}\n\nvec3 Lighting(vec3 albedo, vec3 pos, vec3 norm, vec3 rd)\n{\n    float shadow = 1.0;\n    float direct =  clamp(dot(norm, SunDir), 0.0, 1.0);\n    \n    if(direct > 0.01)\n    {\n        shadow = CalcShadow(pos, SunDir);\n    }\n    \n    vec3 sunLight  = SunColor * direct * 1.5 * shadow;\n    vec3 skyLight  = SkyColor * clamp(0.5 + (0.5 * norm.y), 0.0, 1.0) * 0.1;\n    vec3 ambLight  = AmbColor * clamp(dot(norm, AmbDir), 0.0, 1.0) * 0.1;\n  \tvec3 diffLight = (sunLight + skyLight + ambLight) * albedo;\n    \n    vec3 reflVec   = reflect(-SunDir, norm);\n    vec3 specLight = pow(max(0.0, dot(rd, -reflVec)), 16.0) * vec3(0.35) * shadow;\n    \n    return (diffLight + specLight);\n}\n\nvec3 CalcExpFog(vec3 color, vec3 pos, Ray ray)\n{\n    // We decrease fog intensity as we get closer to the city center\n    // so that it is clearer to see. This also allows the opening\n    // to be foggier/harsher weather conditions.\n    \n    float dist      = distance(ray.origin, pos);\n    float fogAmount = 1.0 - exp(-dist * mix(0.0005, 0.00005, DistanceRatioCamera(ray.origin.xz)));\n    vec3  fogColor  = Sky(ray.direction);  // Fog is the same color as the sky/sun\n    \n    return mix(color, fogColor, fogAmount);\n}\n\nvec3 TerrainTexture(vec3 pos, vec3 norm)\n{\n\tvec3 cliff = vec3(0.1);\n    vec3 snow = vec3(0.9);\n    \n    float slope = smoothstep(0.5, 0.9, norm.y) * smoothstep(0.0, 0.1, norm.x + 1.0);\n    \n    return mix(cliff, snow, smoothstep(0.1, 0.8, slope));\n}\n\nvec3 ShadeTerrain(vec3 pos, vec3 norm, Ray ray)\n{\n    vec3 albedo = TerrainTexture(pos, norm);\n    vec3 color  = Lighting(albedo, pos, norm, ray.direction);\n    \n    return CalcExpFog(color, pos, ray);\n}\n\nvec4 RenderTerrain(Ray ray)\n{\n    vec2 march = MarchTerrain(ray);\n    vec4 color = vec4(Sky(ray.direction), march.x);\n    \n    if(march.x < TerrainFarClip)\n    {\n        vec3 pos  = ray.origin + (ray.direction * march.x);\n        vec3 norm = TerrainNormal(pos, march.x);\n        \n        color.rgb = ShadeTerrain(pos, norm, ray);\n    }\n    \n    return color;\n}\n\n\n//------------------------------------------------------------------------\n// Render City\n//------------------------------------------------------------------------\n\nconst vec3 CityColors[7] = vec3[](vec3(0.05), vec3(0.2), vec3(0.05), vec3(0.3), vec3(0.1), vec3(0.4), vec3(0.1));\n\nvec3 ShadeCity(float id, vec3 pos, vec3 norm, Ray ray)\n{\n    vec3 albedo = (id < 0.0 ? vec3(1.0) : CityColors[int(id)]);\n    vec3 color  = Lighting(albedo, pos, norm, ray.direction);\n    \n    if(id > 3.0)\n    {\n        // Fake emissive on the tower core.\n    \tfloat timeRatio = sin(pos.y + iTime * 3.0);\n        float distRatio = length(pos.xz - CityPos.xz) / (40.0 + timeRatio * 25.0);  \n        \n        vec3 core = mix(vec3(0.0, 1.7, 1.0), vec3(0.0, 1.2, 1.7), timeRatio);\n        \n        color = mix(color, core, clamp(1.0 - distRatio, 0.0, 1.0));\n    }\n    \n    return CalcExpFog(color, pos, ray);\n}\n\nvec4 RenderCity(Ray ray)\n{\n    vec2 march = MarchCity(ray);\n    vec4 color = vec4(vec3(0.1), march.x);\n    \n    if(march.x < TerrainFarClip)\n    {\n        vec3 pos = ray.origin + (ray.direction * march.x);\n        vec3 norm = CityNormal(pos, march.x);\n        \n        color.rgb = ShadeCity(march.y, pos, norm, ray);\n    }\n    \n    return color;\n}\n\n//------------------------------------------------------------------------\n// Volumetric Fog\n//------------------------------------------------------------------------\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\nfloat Noise3D(in vec3 p) { float z  = 1.4; float rz = 0.0; vec3  bp = p; for(float i = 0.0; i <= 2.0; i++) { vec3 dg = tri3(bp); p += (dg); bp *= 2.0; z  *= 1.5; p  *= 1.3; rz += (tri(p.z+tri(p.x+tri(p.y))))/z; bp += 0.14; } return rz; }\n\nfloat VolumeFogNoise(vec3 p)\n{\n    float time = iTime;\n    \n    p.x -= time * 220.0;\n    p.z -= time * 40.0;\n    p.y -= time * 25.5;\n    \n    return Noise3D(p * 0.002);\n}\n\nvec3 VolumeFog(vec3 sceneColor, float sceneDepth, in Ray ray)\n{\n    // Some cheap volumetric fog to mimic wind blowing across the surface.\n    // The fog hangs very low to the ground as a full blown storm/squall is not desired.\n    // It is most noticeable at the start of the scene even though it is present\n    // the entire time. If the fog is too strong then it is overly apparent on\n    // the city and does not look good. Right now it is barely perceptible on the\n    // city but that is ok. The goal was to add an extra layer of harshness\n    // to the opening and a bit of depth to the city.\n    \n    float depth = 1.0;\n    vec3 hit = ray.origin + (ray.direction * (sceneDepth * TerrainFarClip - 50.0));\n    \n    // Notice the march does not begin at the ray origin like it does in\n    // similar effects in other shaders. Those shaders want a fog/wind/etc. that\n    // affects the whole scene, whereas this fog is just slightly above the ground.\n    \n    for(int i = 0; i < 2; ++i)\n    {\n        vec3 pos = hit + (ray.direction * depth);\n        float fogNoise = VolumeFogNoise(pos);\n        \n        fogNoise   = mix(fogNoise, 0.0, clamp(pos.y / 1000.0, 0.0, 1.0));\n        sceneColor = mix(sceneColor, sceneColor * vec3(0.05), fogNoise * fogNoise * 0.5);\n        \n        depth += min(depth * 1.5, 1.0);\n    }\n    \n    return sceneColor;\n}\n\n//------------------------------------------------------------------------\n// Render\n//------------------------------------------------------------------------\n\nvec3 Render(in Ray ray)\n{\n    vec4 terrain = RenderTerrain(ray);\n    vec4 city    = vec4(vec3(0.0), TerrainFarClip * 2.0);\n    \n    // If we are in range of seeing the city then render it\n    if(distance(ray.origin, CityPos) < 10000.0)\n    {\n        city = RenderCity(ray);\n    }\n    \n    float sceneDepth = clamp(min(terrain.w, city.w) / TerrainFarClip, 0.0, 1.0);\n    vec3  sceneColor = mix(terrain.rgb, city.rgb, step(city.w, terrain.w));\n    \n    return VolumeFog(sceneColor, sceneDepth, ray);\n}\n\n//------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------\n\nmat2 Rotate(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nRay GetCameraRay(vec2 uv)\n{\n    // Boils down to: if the mouse has not been used/or has been reset\n    // to (0,0), then the camera looks at the top of the tower. Otherwise,\n    // the camera direction is based on mouse position.\n    \n    vec2 halfRes = iResolution.xy * 0.5;\n    vec2 mouse = iMouse.xy;\n    \n    vec3 ro = CameraPos(iTime);\n    ro.y = TerrainNoiseLQ(ro.xz).x + mix(10.0, 340.0, DistanceRatioCamera(ro.xz));\n    vec3 rt = ro + (vec3(0.0, 0.0, 1.0) * 1000.0);\n    \n    if(ivec2(mouse) == ivec2(0))\n    {\n        mouse = halfRes;\n        rt = vec3(CityPos.x, CityPos.y + 600.0, CityPos.z);\n    }\n    \n    Camera camera = Camera_LookAt(ro, rt);\n    Ray ray = Camera_GetRay(camera, uv);\n    \n    vec2 d = (halfRes - mouse) * vec2(0.01, 0.005);\n    \n    ray.direction.yz *= Rotate(-d.y);\n\tray.direction.xz *= Rotate(d.x);\n    \n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    Ray ray = GetCameraRay(uv);\n    \n    vec3 color = Render(ray);\n    color = pow(color, vec3(1.0 / 2.2));    // Gamma correction\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}