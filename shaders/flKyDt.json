{
    "Shader": {
        "info": {
            "date": "1662451822",
            "description": "Another endless library",
            "flags": 0,
            "hasliked": 0,
            "id": "flKyDt",
            "likes": 26,
            "name": "Ultimate Library 2",
            "published": 3,
            "tags": [
                "motion",
                "library",
                "replication",
                "book"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 344
        },
        "renderpass": [
            {
                "code": "// \"Ultimate Library 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  (Based on \"Library Lost and Found\", but with hexagonal floor plan and\n  motion along stairs).\n  Alternating movement paths; mouseable - click in upper/lower right corners\n  for pano and monochrome views.\n\n  No. 10 in \"Library\" series\n    \"Babel's Library\"           (4slcW2)\n    \"Bibliotheque\"              (lsXcWs)\n    \"Ultimate Library\"          (4s2czR)\n    \"Books and Stairs\"          (4djczw)\n    \"Mount Book\"                (XsjcRc)\n    \"Literary Tunnel\"           (ldSyDG)\n    \"Books and Stairs 2\"        (MtsfRl)\n    \"Library Lost and Found\"    (tdlBzH)\n    \"Reading Room\"              (fs3fzn)\n*/\n\n#define AA       0    // (= 0/1) optional antialiasing\n#define DO_FADE  0    // (= 0/1) optional fading\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexVertDist (vec2 p);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nvec3 qHit, ltPos, ltAx, cId;\nvec2 gSize, cMid, stAngCs;\nfloat dstFar, tCur, tDir, vuHt;\nint idObj, stLib;\nbool isPano, colImg, doClimb;\nconst int idFlr = 1, idCol = 2, idRail = 3, idStr = 4, idShlf = 5, idBk = 6, idLt = 7,\n   idSeatC = 8, idSeatM = 9;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr, qs;\n  float dMin, d, r, a, s;\n  dMin = dstFar;\n  p = vec3 (p.xz - cMid, p.y - gSize.y * (cId.y + 0.5)).xzy;\n  r = length (p.xz);\n  qs = p;\n  qs.xz = Rot2D (qs.xz, pi / 6.);\n  a = (r > 0.) ? atan (qs.z, - qs.x) / (2. * pi) : 0.;\n  qs.xz = Rot2D (qs.xz, 2. * pi * (floor (6. * a + 0.5) / 6.));\n  q = p;\n  q.y = 0.5 * gSize.y - 0.3 - abs (p.y);\n  d = max (q.y, 9.8 - r);\n  DMINQ (idFlr);\n  if (stLib >= 3) {\n    q.y = p.y;\n    q.xz = qs.xz;\n    s = length (vec2 (q.x, abs (q.z)) - vec2 (-18.5, 5.));\n    d = min (s - 0.4, max (s - 0.6, 9.5 - abs (q.y)));\n    DMINQ (idCol);\n  }\n  if (stLib >= 4) {\n    qr = p;\n    qr.xz = Rot2Cs (qr.xz, - stAngCs);\n    q = qr;\n    q.xy = Rot2D (q.xy - 0.5 * gSize.y * vec2 (1., -1.), 0.25 * pi);\n    d = 0.5 * max (q.y - abs (0.5 - abs (0.5 - fract (q.x / sqrt (2.)))) * sqrt (2.),\n       max (abs (q.z) - 2.2, -0.2 - q.y));\n    q.xy = qr.xy;\n    DMINQ (idStr);\n    q = qr;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    q.z = abs (q.z);\n    q.yz -= vec2 (-0.3, 1.2);\n    d = PrRoundCylDf (q.yzx, 0.1, 0.02, 12.);\n    DMINQ (idLt);\n  }\n  if (stLib >= 5) {\n    q = qr;\n    d = max (length (vec2 (r - 10.2, abs (q.y + 6.) - 1.3)) - 0.13, 2. - abs (q.z));\n    d = min (d, PrRoundCylDf (vec3 (abs (q.xz) - vec2 (10., 2.), q.y + 7.), 0.2, 0.05, 2.8));\n    d = min (d, PrRoundBox2Df (vec2 (r - 9.8, q.y - 0.5 * gSize.y * sign (q.y) - 0.05),\n       vec2 (0.05, 0.3), 0.05));\n    q.xz = Rot2D (q.xz, 2. * pi / 32.);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a + 0.5) / 16.));\n    d = min (d, PrCylDf ((q - vec3 (-10.2, -7.2, 0.)).xzy, 0.13, 2.5));\n    q = qr;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (q.y - 3.8, abs (q.z) - 2.)) - 0.17, abs (qr.x) - 10.));\n    q = qr;\n    q.x += 20.;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (q.y - 3.8, abs (q.z) - 2.)) - 0.17, abs (qr.x) - 10.));\n    DMINQ (idRail);\n  }\n  if (stLib >= 6) {\n    q = p;\n    q.y -= -6.7;\n    s = 2.5 - abs (qs.z);\n    d = max (SmoothMax (PrRoundBox2Df (vec2 (r - 16.8, q.y), vec2 (1.15, 2.95), 0.05), s, 0.05),\n       - max (max (abs (r - 16.) - 1.5, abs (abs (q.y) - 1.4) - 1.25), 0.4 + s));\n    DMINQ (idShlf);\n    d = SmoothMax (PrRoundBox2Df (vec2 (r - 19.3, q.y + 1.8), vec2 (0.7, 1.2), 0.1),\n       6.5 - abs (qs.z), 0.2);\n    DMINQ (idSeatC);\n    d = SmoothMax (PrRoundBox2Df (vec2 (gSize.x * HexVertDist (q.xz / gSize.x) - 3., q.y + 1.8),\n       vec2 (1., 1.2), 0.1), 0.2 - gSize.x * HexEdgeDist (q.xz / gSize.x), 0.2);\n    DMINQ (idSeatM);\n  }\n  if (stLib == 7 && q.y > 0. || stLib >= 8) {\n    d = max (max (abs (r - 16.8) - 0.7, abs (q.y) - 2.8), 0.2 + s);\n    DMINQ (idBk);\n  }\n  if (stLib >= 2) {\n    q = p;\n    q.y -= 9.4;\n    d = length (vec2 (r - 11., q.y)) - 0.3;\n    q.xz = qs.xz;\n    q.x -= -17.;\n    d = min (d, PrRoundCylDf (q.xzy, 1., 0.02, 0.2));\n    DMINQ (idLt);\n  }\n  return dMin;\n}\n\nvoid SetCConf ()\n{\n  float a;\n  cMid = HexToPix (cId.xz * gSize.x);\n  a = (2. * pi / 6.) * floor (6. * Hashfv2 (cId.xz + vec2 (27.1, 37.1)));\n  if (doClimb && cId.x == cId.z) a = - pi / 3. - pi * mod (floor (cId.x / 3.), 2.);\n  stAngCs = sin (a + pi / 6. + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec4 vri, hv;\n  vec3 vf, p, cIdP;\n  vec2 edN[3], pM, s;\n  float dHit, d, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = vec4 (gSize.x / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2])),\n     1. / rd.y);\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / gSize.x;\n  pM = HexToPix (PixToHex (ro.xz / gSize.x));\n  cIdP = vec3 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cId = vec3 (PixToHex (p.xz / gSize.x), floor (p.y / gSize.y)).xzy;\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    hv = vec4 ((vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))),\n       gSize.y * (cId.y + step (0., rd.y))) * vri;\n    s = vec2 (Minv3 (hv.xyz), dHit + abs (hv.w - p.y * vri.w));\n    d = ObjDf (p);\n    if (dHit + d < Minv2 (s)) {\n      dHit += d;\n    } else if (s.x < s.y) {\n      dHit = s.x + eps;\n      pM += sqrt3 * ((s.x == hv.x) ? edN[0] : ((s.x == hv.y) ? edN[1] : edN[2]));\n    } else {\n      dHit = s.y + eps;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP;\n  float ao, d;\n  int idObjT;\n  idObjT = idObj;\n  cIdP = vec3 (-999.);\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.1 + float (j) / 8.;\n    p = ro + d * rd;\n    cId = vec3 (PixToHex (p.xz / gSize.x), floor (p.y / gSize.y)).xzy;\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  idObj = idObjT;\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec2 r, dr;\n  float tt, h, dh, cxm, cxmm;\n  h = vuHt;\n  if (! doClimb) {\n    tt = mod (t, 4.);\n    if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n    else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n    else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n    else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n    r.y += 3. * floor (t / 4.);\n    r *= gSize.x;\n    r.x += 0.01;\n  } else {\n    r = vec2 (0.01, gSize.x * t - 3. * gSize.x);\n    r = Rot2D (r, - pi / 3.);\n    cId.xz = PixToHex (r / gSize.x);\n    cxm = mod (floor (cId.x / 3.), 2.);\n    cxmm = mod (cId.x, 6.);\n    if (cId.x == cId.z) {\n      dr = r - HexToPix (cId.xz * gSize.x);\n      dh = gSize.y * 0.5 * (1. + clamp ((length (dr) * sign (Rot2D (dr, pi / 3.).y) + 5.) / 10.,\n         -1., 1.));\n      h += (cxm == 0.) ? dh : gSize.y - dh;\n      cxmm = abs (cxmm - 2.5);\n      h += gSize.y * (step (cxmm, 2.) + step (cxmm, 1.));\n    } else {\n      cxmm = abs (cxmm - 3.);\n      h += gSize.y * (step (cxmm, 2.5) + step (cxmm, 1.5) + step (cxmm, 0.5));\n    }\n  }\n  return vec3 (r, h).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, ltVec, ltDir, roo, vn;\n  vec2 vf;\n  float dstObj, ltDist, ltCeil, ao, atten, r, s, a, y, shLab[2];\n  bgCol = vec3 (0.05);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFlr || idObj == idShlf || idObj == idBk) {\n      qHit.xz = Rot2D (qHit.xz, pi / 6.);\n      r = length (qHit.xz);\n      a = (r > 0.) ? atan (qHit.z, - qHit.x) / (2. * pi) + 0.5 : 0.;\n    }\n    ltCeil = 0.;\n    if (idObj == idFlr) {\n      vf = vec2 (32., 0.2);\n      if (vn.y > 0.01) {\n        col4 = vec4 (0.6, 0.4, 0.2, 0.1) * (1. - 0.3 * Fbm2 (ro.xz));\n        if (stLib >= 4) col4.rgb *= 0.7 + 0.3 * SmoothBump (0.02, 0.98, 0.01, fract (1.1 * r));\n      } else if (vn.y < -0.01) {\n        col4 = vec4 (vec3 (1.), 0.);\n        if (stLib >= 3) ltCeil = (1. - smoothstep (1., 4., length (Rot2D (qHit.xz,\n           2. * pi * floor (6. * a + 0.5) / 6.) - vec2 (17., 0.)))) +\n           (1. - smoothstep (0., 4., r - 11.));\n        else col4 = vec4 (vec3 (0.4), 0.1);\n      } else col4 = vec4 (0.6, 0.4, 0.2, 0.1);\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.05);\n      if (abs (vn.y) < 0.1) col4 *= 0.85 + 0.15 * smoothstep (0.08, 0.1, fract (2. * qHit.y));\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.2);\n      vf = vec2 (32., 0.2);\n    } else if (idObj == idStr) {\n      if (abs (qHit.z) > 2.) {\n        col4 = vec4 (0.5, 0.55, 0.5, 0.);\n        vf = vec2 (32., 0.2);\n      } else if (vn.y > -0.01) {\n        col4 = vec4 (0.5, 0.3, 0.1, 0.05) * (1. - 0.2 * Fbm2 (2. * ro.xz));\n        vf = vec2 (32., 0.2);\n      } else {\n        col4 = vec4 (0.45, 0.45, 0.5, 0.);\n        vf = vec2 (32., 0.2);\n        ltCeil = 1. - smoothstep (0., 0.8, PrRoundBox2Df (vec2 (qHit.x, abs (qHit.z) - 1.2),\n           vec2 (12. / sqrt(2.), 0.05), 0.05));\n      }\n    } else if (idObj == idShlf) {\n      col4 = vec4 (vec3 (0.7, 0.5, 0.2) * (0.5 + 0.5 * Fbm2 ((r > 17.99) ?\n         vec2 (256. * a, 0.5 * qHit.y) :\n         ((abs (vn.y) < 0.01) ? vec2 (4. * r, 0.5 * qHit.y) : vec2 (32. * a, 4. * r)))), 0.1);\n      vf = vec2 (32., 0.1);\n      a = fract (12. * a + 0.5) - 0.5;\n      if (stLib >= 7 && r > 17.99 && abs (a) < 0.2) {\n        shLab[0] = dot (mod (vec2 (55., 45.) + cId.xz, 100.), vec2 (100., 1.));\n        shLab[1] = mod (54. + cId.y, 100.);\n        if (abs (qHit.y - 2.2) < 0.4) {\n          if (ShowInt (vec2 (- 10. * a - 0.5, (qHit.y - 2.)), vec2 (2., 0.5), 4., shLab[0]) != 0.) \n             col4 = vec4 (0., 0.6, 0.8, -1.);\n        } else if (abs (qHit.y - 1.4) < 0.4) {\n          if (ShowInt (vec2 (- 10. * a - 0.2, (qHit.y - 1.2)), vec2 (1.5, 0.5), 2., shLab[1]) != 0.)\n             col4 = vec4 (0., 0.8, 0.6, -1.);\n        }\n      }\n    } else if (idObj == idBk) {\n      a *= 300.;\n      s = Hashfv2 (vec2 (floor (a), 1. + floor (qHit.y / 2.8)));\n      y = fract (qHit.y / 2.8) / (0.9 - 0.3 * s);\n      if (y < 1.) {\n        a = fract (a);\n        col4 = vec4 (HsvToRgb (vec3 (fract (Hashfv3 (cId) + 0.3 * s), 0.7,\n           0.7 * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, a)))), 0.1);\n        col4.rgb *= 1. + smoothstep (0.35, 0.45, abs (y - 0.5)) * ((y > 0.5) ? 0.3 : -0.8);\n        col4.rgb = mix (mix (col4.rgb, vec3 (0.7, 0.7, 0.3), SmoothBump (0.2, 0.25, 0.01, y)),\n           vec3 (0.8, 0.8, 0.2), step (abs (y - 0.5), 0.15) *\n           step (abs (a - 0.5), 0.25) * step (0.5, Noisefv2 (cId.xz * vec2 (19., 31.) +\n           floor (vec2 (16. * a, 16. * qHit.y)))));\n        vn.xz = Rot2D (vn.xz, 0.5 * pi * (a - 0.5));\n      } else {\n        col4 = vec4 (0.1, 0.04, 0., -1.);\n      }\n    } else if (idObj == idSeatC) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.05);\n      vf = vec2 (32., 1.5);\n    } else if (idObj == idSeatM) {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.05);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idLt) {\n      col4 = (stLib >= 3) ? vec4 (1., 1., 0.8, -1.) : vec4 (vec3 (0.8), 0.1);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    atten = 1. / (1. + pow (0.005 * ltDist, 1.5));\n    if (stLib <= 3 && ! isPano) atten *= 0.05 + 0.95 * smoothstep (0.7, 0.9, dot (ltAx, - ltVec));\n    ao = 1.;\n    if (stLib >= 2 && idObj != idBk) ao = ObjAO (ro, vn);\n    if (stLib == 1) vf = vec2 (256., 2.);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = ao * (col4.rgb * (0.1 + 0.4 * max (vn.y, 0.) + 0.5 * max (dot (vn, ltVec), 0.)) +\n         col4.a * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.));\n      if (idObj == idBk) col += 0.3 * col4.rgb * (0.6 - 0.4 * dot (normalize (vn.xz),\n         normalize (qHit.xz)));\n      if (ltCeil > 0.) col += 0.15 * ltCeil * vec3 (1., 1., 0.8);\n      col *= atten;\n    } else col = atten * col4.rgb * (0.6 + 0.4 * max (- dot (rd, vn), 0.));\n    col = clamp (mix (bgCol, col, exp (32. * min (0., 0.7 - dstObj / dstFar))), 0., 1.);\n  } else col = bgCol;\n  col = clamp (col, 0., 1.);\n  if (stLib <= 2) col = vec3 (0.95, 0.95, 1.) * Maxv3 (col);\n  if (stLib == 1) col *= (tDir < 0.) ? vec3 (1., 0.2, 0.2) : vec3 (0.2, 1., 0.2);\n  if (! colImg) col = vec3 (0.95, 0.95, 1.) * pow (Maxv3 (col), 0.9);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, colT, colF[2], p1, p2, vd;\n  vec2 canvas, uv, uvv, um;\n  float az, el, asp, zmFac, sr, tc, t, mb, spd, regBdy, nState;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  gSize = vec2 (30., 20.);\n  regBdy = (length (uv * vec2 (1. / asp, 1.)) - 1.5 * SmoothBump (0.5, 0.995, 0.005,\n     fract ((1./106.) * tCur))) * canvas.y;\n  doClimb = (regBdy > 0.);\n  if (! doClimb) {\n    spd = 0.35;\n    vuHt = 10.;\n    p1 = TrackPath (spd * tCur + 0.3);\n    p2 = TrackPath (spd * tCur - 0.3);\n    ro = 0.5 * (p1 + p2);\n    vd = p1 - p2;\n    az = atan (vd.x, vd.z);\n    el = -0.02 * pi;\n  } else {\n    spd = 0.35;\n    vuHt = 8.5;\n    ro = TrackPath (spd * tCur);\n    az = pi / 3.;\n    el = -0.02 * pi;\n  }\n  colImg = true;\n  isPano = false;\n  mb = Minv2 (vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5);\n  if (mPtr.z > 0. && mb > 0.) {\n    if (mPtr.y > 0.) isPano = ! isPano;\n    else colImg = ! colImg;\n  }\n  if (mPtr.z > 0. && colImg && ! isPano && mb < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = isPano ? 0.3 : 3.;\n  ltPos = vuMat * vec3 (0.3, 2., -1.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 12. * gSize.x;\n  nState = 15.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (isPano ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)), uvv.y).xzy : \n       vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n#if DO_FADE\n    tc = 0.6 * tCur;\n    for (int k = VAR_ZERO; k < 2; k ++) {\n      t = mod ((tc + float (k)) / nState, 2.);\n      tDir = (2. * floor (t) - 1.) * (1. - abs (t - 1.));\n      stLib = int (nState) - int (nState * abs (tDir));\n      if (k == 0 || stLib < 9) colF[k] = ShowScene (ro, rd);\n      else colF[1] = colF[0];\n    }\n    colT = mix (colF[0], colF[1], smoothstep (0.2, 0.8, fract (tc)));\n    colT *= 1. - step (5. * abs (mod ((tc + 0.5) / nState, 2.) - 1.),\n       min (1.5, length (uv * vec2 (1. / asp, 1.))));\n#else\n    stLib = int (nState);\n    colT = ShowScene (ro, rd);\n#endif\n    col += (1. / naa) * colT;\n  }\n  if (colImg && ! isPano && doClimb && stLib >= 7) {\n    um = uv - vec2 (0., -0.96) * vec2 (asp, 1.);\n    if (Maxv2 (abs (um) - vec2 (0.1, 0.05)) < 0.) col = mix (mix (col, vec3 (0., 0., 1.), 0.2),\n       vec3 (0.8, 0., 0.), ShowInt (um - vec2 (0.06, -0.02), vec2 (0.1, 0.06) * vec2 (asp, 1.), 3.,\n       mod (54. + floor (ro.y / gSize.y), 100.)));\n  }\n  if (mPtr.z > 0. && min (uv.x - asp, abs (uv.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  \n  if (regBdy < -1. && abs (regBdy) < 3.) col = vec3 (0.5, 0.5, 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexVertDist (vec2 p)\n{\n  p = abs (p);\n  return min (length (vec2 (p.x - (sqrt3/2.), p.y - 0.5)), length (vec2 (p.x, p.y - 1.)));\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}