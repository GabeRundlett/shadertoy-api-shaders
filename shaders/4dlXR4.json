{
    "Shader": {
        "info": {
            "date": "1397553285",
            "description": "Domain repetition. A (simple) clover shape is repeated over space. Clearly NOT the way to do it (super slow). I run out of instructions (and speed), so I couldn't add variation or detail or lighting really. But the basic technique is there.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlXR4",
            "likes": 89,
            "name": "Clover Tree",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 7846
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Domain repetition. A (simple) clover shape is repeated over space.\n\n// Clearly NOT the way to do it (super slow). I run out of instructions (and speed), so\n// I couldn't add variation or detail or lighting really. But the basic technique is there.\n\nfloat hash1( vec3 p )\n{\n    return fract(sin(dot(p,vec3(1.0,57.0,113.0)))*43758.5453);\n}\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\nvec3 hash3( vec3 p )\n{\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n\t\t\t\t           dot(p,vec3(57.0,113.0,1.0)),\n\t\t\t\t           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\n// simple clover shape\nfloat shape( in vec3 p, in float s )\n{\n\tfloat a = atan( p.x, p.y );\n\tfloat r = length( p.xy );\n\t\n\tfloat ra = 0.2 + 0.3*sqrt(0.5+0.5*sin( 3.0*a ));\n\tra *= s;\n    return min( max(length(p.xy)-0.04*(0.5+0.5*p.z),-p.z), max( length(p.xy)-ra, abs(p.z-0.2*r)-0.06*s*clamp(1.0-1.5*r,0.0,1.0) ) );\n}\n\n// df\nvec4 map( vec3 p )\n{\n\tp.x += 0.1*sin( 3.0*p.y );\n\t\n\tfloat rr = length(p.xz);\n\tfloat ma = 0.0;\n\tvec2 uv = vec2(0.0);\n\t\n\tfloat d1 = rr - 1.5;\n    if( d1<1.8 )\n\t{\n\t\t\n\t\tfloat siz = 6.0;\n\t\tvec3 x = p*siz + 0.5;\n\t\tvec3 xi = floor( x );\n\t\tvec3 xf = fract( x );\n\n\t\tvec2 d3 = vec2( 1000.0, 0.0 );\n\t\tfor( int k=-1; k<=1; k++ )\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec3 b = vec3( float(i), float(j), float(k) );\n\t\t\tvec3 c = xi + b;\n\t\t\t\n\t\t\tfloat ic = dot(c.xz,c.xz)/(siz*siz);\n\t\t\t\n\t\t\tfloat re = 1.5;\n\t\t\t\n\t\t\tif( ic>(1.0*1.0) && ic < (re*re) )\n\t\t\t{\n            vec3 r = b - xf + 0.5 + 0.4*(-1.0+2.0*hash3( c ));\n\t\t\t//vec3 r = c + 0.5 - x;\n\n\t\t\tvec3 ww = normalize( vec3(c.x,0.0,c.z) );\n\t\t\tww.y += 1.0; ww = normalize(ww);\n            ww += 0.25 * (-1.0+2.0*hash3( c+123.123 ));\n\t\t\t\t\n\t\t\tvec3 uu = normalize( cross( ww, vec3(0.0,1.0,0.0) ) );\n\t\t\tvec3 vv = normalize( cross( uu, ww ) );\n\t\t\tr = mat3(  uu.x, vv.x, ww.x,\n\t\t\t\t\t   uu.y, vv.y, ww.y,\n\t\t\t\t\t   uu.z, vv.z, ww.z )*r;\n            float s = 0.75 + 0.5*hash1( c+167.7 );\t\t\t\t\n\t\t\tfloat d = shape(r,s)/siz;\n            if( d < d3.x )\n            {\n                d3 = vec2( d, 1.0 );\n\t\t\t\tma = hash1( c.yzx+712.1 );\n\t\t\t\tuv = r.xy;\n            }\n\t\t\t}\n        }\n\t\td1 = mix( rr-1.5, d3.x, d3.y );\n\t}\n\t\n\td1 = min( d1, rr - 1.0 );\n\n    return vec4(d1, ma, uv );\n\t\n}\n\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\t\n    float t = 0.0;\n    float m = -1.0;\n\tvec2  u = vec2(0.0);\n    for( int i=0; i<70; i++ )\n    {\n\t    vec4 res = map( ro+rd*t );\n        if( abs(res.x)<0.001||t>maxd ) break;\n\t    m = res.y;\n\t\tu = res.zw;\n        t += res.x;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec4( t, m, u );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 eps = vec2(0.001,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\t\n    // camera\n\tfloat an = 20.0 + 0.15*iTime - 7.0*m.x;\n    vec3  ro = 3.1*normalize(vec3(sin(an),0.5-0.4*m.y, cos(an)));\n    vec3  ta = vec3( 0.0, 0.8, 0.0 );\n\tfloat rl = 0.5*sin(0.35*an);\n    vec3  ww = normalize( ta - ro );\n    vec3  uu = normalize( cross(ww,vec3(sin(rl),cos(rl),0.0) ) );\n    vec3  vv = normalize( cross(uu,ww));\n    vec3  rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// render\n    vec3 col = texture( iChannel2, rd ).xyz; col = col*col;\n\t\n\t// raymarch\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.y>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // material\n\t\tvec3 mate = vec3(0.3,0.5,0.1);\n\t\tmate = mix( mate, vec3(0.5,0.25,0.1), smoothstep( 0.9,0.91, tmat.y) );\n\t    mate += 0.1*sin( tmat.y*10.0  + vec3(0.0,2.0,2.0));\n\t\tmate *= 0.8+0.4*tmat.y;\n\t    vec2 uv = tmat.zw;\n\t\tfloat r = length(uv);\n\t\tfloat a = atan(uv.y,uv.x);\n\t\tmate += vec3(0.2,0.15,0.1)*smoothstep(0.8,1.0,-cos(3.0*a))*(1.0-1.5*r);\n\t\tmate *= 0.2+r;\n\t\t\n\t\t// lighting\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tamb *= 0.1 + 0.9*pow( clamp( (length(pos.xz)-1.0)/(1.5-1.0), 0.0, 1.0 ), 2.0 );\n\t\tvec3 snor = normalize( nor + normalize( vec3(pos.x,0.0,pos.y) ) );\n\t\tvec3 lin = 1.0*texture( iChannel1, snor ).xyz*amb;\n\t\tcol = mate*lin;\n\t\tfloat kd = pow(clamp(1.0+dot(rd,nor),0.0,1.0),3.0);\n\t\tcol += 0.2*kd*pow( texture( iChannel2, ref ).xyz, vec3(2.2) )*amb;\n\t}\n\n\t// gamma\n\tcol = pow( col, vec3(0.45) );\n\t\n\t// vigneting\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n    fragColor = vec4( col,1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}