{
    "Shader": {
        "info": {
            "date": "1475781061",
            "description": "A remix of one of my older shaders, includes a nice post proc pipeline, pretty cool, huh?",
            "flags": 32,
            "hasliked": 0,
            "id": "MtG3R3",
            "likes": 21,
            "name": "Nebular Clouds w/ Post",
            "published": 3,
            "tags": [
                "raymarching",
                "color",
                "volumetric",
                "stars",
                "correction"
            ],
            "usePreview": 0,
            "username": "mu6k",
            "viewed": 1757
        },
        "renderpass": [
            {
                "code": "// a remix of one of my older shaders, includes a nice post proc pipeline, pretty cool, huh?\n\n// parameter\nconst float blurAmount          = 0.20; // 1.0 - full blur, 0.0 sharp\nconst int aberrationSampleCount = 6; // number of samples\nconst float aberrationStrength  = 0.01; // length in screen percentage\nconst vec3 colorStrength = vec3(+1.85,+1.50,+1.50); // adjust highs\nconst vec3 colorGamma =    vec3(+1.05,+1.05,+1.05); // adjust mids\nconst vec3 colorOffset =   vec3(-0.08,-0.09,-0.10); // adjust lows\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return max(vec3(.0), min(vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colorSum = vec3(0);\n    vec3 weightSum = vec3(0);\n    \n    float invASC = 1.0/float(aberrationSampleCount);\n    for (int i=0; i<aberrationSampleCount; i++){\n        float x = float(i)*invASC*2.0-1.0;\n\t\tvec3 w = vec3(max(.0,-x),1.0 - abs(x),max(.0,x));\n        vec2 direction = (fragCoord/iResolution.xy-.5);\n        vec3 original = texture(iChannel0, aberrationStrength*direction*x+ fragCoord/iResolution.xy).xyz;\n        vec3 blurry = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n        vec3 color = mix(original, blurry, blurAmount);\n        colorSum += color*w;\n        weightSum += w;\n    }\n    \n    vec3 color = colorSum/weightSum;\n    const vec3 invColorGamma = vec3(1.0/colorGamma);\n    color = max(vec3(.0),pow(color,invColorGamma)*colorStrength + colorOffset);\n    color = ACESFilm(color);\n    //color = (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//2D texture based 4 component 1D, 2D, 3D noise\nvec4 noise(float p){return texture(iChannel0,vec2(p*float(1.0/256.0),.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p*vec2(1.0/256.0));}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy*vec2(1.0/256.0) + noise(sprev).yz*21.421),texture(iChannel0,p.xy*vec2(1.0/256.0) + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nconst float toffs = -152.0;\nfloat t;\n\n//density function\nfloat density(vec3 p)\n{\n\tvec4 d = noise(p*.25)*noise(p.xz*.044)*noise(p.xy*.067)*noise(p.yz*.21);\n\tfloat fd = dot(d,vec4(1.4));\n\tfd = fd*fd*fd*fd*fd;\n\t\n\treturn max(.0,fd);\n}\n\n//background with stars\nvec3 background(vec3 d, vec3 p)\n{\n\tvec4 n = noise(d*0.45*iResolution.y+p*.05);\n\tfloat sun = max((dot(d,normalize(vec3(1.0)))-.98)*512.0,0.0);;\n\tfloat den = abs(d.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n\treturn vec3(pow(n.x+n.y*.1+den,22.0))*.3+ mix(vec3(.1,.15,.2)*.25,vec3(1.2,.9,.5),sun);\n}\n\n//smooth version of the background - used for ambient lighting\nvec3 background2(vec3 d)\n{\n\tfloat sun = dot(d,normalize(vec3(1.0)));\n\treturn mix(vec3(.1,.15,.2),vec3(1.2,.9,.5),sun)*.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime + toffs;\n    \n     vec2 uv = fragCoord.xy / iResolution.yy -vec2(.9,.5);\n\tvec2 m = iMouse.xy*8.0/ iResolution.yy;\n\t//rotation matrix for the camera\n\tmat3 rotmat = rotate_y((t-toffs)*.07+m.x+0.2)*rotate_x((t-toffs)*.031+m.y+0.2);\n\t//p is ray position\n\tvec3 p = vec3(.0,.0,-30.0); p*=rotmat;\n\tp += vec3(sin(t),cos(t),sin(t*.25)*29.0+t*7.0-22.0-4.0/((t-toffs)*.01+0.01));\n\t//d is ray direction\n\tvec3 d = normalize(vec3(uv*(sin(t*.17)*.2+0.8),1.0-length(uv)*.2));\n\td*=rotmat;\n\tp+=d*noise(fragCoord.xy).x*.9;\n\t\n\t//some accumulators\n\tfloat a = .0;\n\tfloat ai = .0;\n\tvec3 color = vec3(.0);\n\t\n\t//raycast 60 steps\n\tfor (int i=0; i<60; i++)\n\t{\n\t\t//move forward\n\t\tp+=d*.9;\n\t\t//space distort\n\t\tvec3 n = noise(p.xz*.25+vec2(t*.1)).xyz*12.0*noise(p.zy*.1+vec2(t*.1)).xyz;\n\n\t\tfloat de = density(p+n);\n\t\ta += de; // a is alpha, as the ray traverses the density function the\n\t\t//pixel is more and more opaque\n\t\ta = min(1.0,a); //a > 1.0 makes no sence and produces bugs\n\t\tvec4 c2 = noise(p.yz*.03).xyzw;\n\t\tvec3 c = c2.xyz*1.7;\n\t\t\n\t\t//lame illumiation\n\t\tfloat occ = min((de-density(p+vec3(0.7+n))),1.0);\n\t\tocc = min(occ,(de-density(p+vec3(3.7)+n)));\n\t\tocc = min(occ,(de-density(p+vec3(5.7)+n)));\n\t\t\n\t\tcolor += max(.0,occ)*(1.0-a)*c;\n\t\tif (a>1.0) break; //traversing beyond this point makes\n\t\t//no sense because it's not visible anymore, so break\n\t}\n\n\t//post processing + blending\n\t\n\tcolor += background2(d)*.15;\n    //color += background(d,p);\n\tcolor = mix(background(d,p),color,a);\n\t\n\tcolor +=noise(uv).xyz*.08;\n\t\n\tfragColor = vec4(color,1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// parameter\nconst float _smooth = 0.5;\nconst int sampleCount = 32;\nconst vec2 samplingVector = vec2(00.1, +0.25);\n\nfloat weight(float x) {\n\treturn pow(2.71828, -(x*x)*(_smooth*_smooth)*64.0);\n}\n\n// separablu blur pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float invSampleCount = 1.0/float(sampleCount);\n    vec3 colorSum = vec3(0);\n    float weightSum = .0;\n    for (int i=0; i<sampleCount; i++)\n\t\n    {\n        float x = (float(i)*invSampleCount-.5)*2.0;\n        float w = weight(x);\n        weightSum += w;\n        colorSum += w * texture(iChannel0, x*samplingVector + fragCoord/iResolution.xy).xyz;\n    }\n\tfragColor = vec4(colorSum/weightSum,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n// parameter\nconst float _smooth = 0.5;\nconst int sampleCount = 64;\nconst vec2 samplingVector = vec2(+0.6, 0.1);\n\nfloat weight(float x) {\n\treturn pow(2.71828, -(x*x)*(_smooth*_smooth)*64.0);\n}\n\n// separablu blur pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float invSampleCount = 1.0/float(sampleCount);\n    vec3 colorSum = vec3(0);\n    float weightSum = .0;\n    for (int i=0; i<sampleCount; i++)\n\t\n    {\n        float x = (float(i)*invSampleCount-.5)*2.0;\n        float w = weight(x);\n        weightSum += w;\n        colorSum += w * texture(iChannel0, x*samplingVector + fragCoord/iResolution.xy).xyz;\n    }\n\tfragColor = vec4(colorSum/weightSum,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}