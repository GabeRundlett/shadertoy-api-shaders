{
    "Shader": {
        "info": {
            "date": "1709178742",
            "description": "After picking apart many shaders from @Shane - my version of a cheesy path demo shader. ",
            "flags": 32,
            "hasliked": 0,
            "id": "XXfSz4",
            "likes": 16,
            "name": "Cavern River",
            "published": 3,
            "tags": [
                "raymarching",
                "water",
                "reflections",
                "path",
                "cavern"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Cavern River\n    02/29/2024  @byt3_m3chanic\n\n    Going though old shaders, one of my first was a learning experience \n    picking apart one of @Shane's tunnel demos (listed below). I love these\n    type of never ending paths shaders. Reminds me of the early demos I saw\n    at high school in the PC labs. \n    \n    Doing some cheap effects for water / just trying to keep perf up. Try\n    swapping textures in iChannel0 for other types of noise\n    \n    Oh yeah you can move the light with the mouse.\n    \n    Checkout some of @Shane's path/tunnel shaders!\n    https://www.shadertoy.com/view/MscSDB\n    https://www.shadertoy.com/view/MlXSWX\n    https://www.shadertoy.com/view/XlXXWj\n    \n*/\n#define R   iResolution\n#define PI  3.14159265359\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((R.x / 4.) * intensity, opacity), 0., 1.)), 1.);\n}\n\nvec2 opacity = vec2(.01);\n\nvoid mainImage( out vec4 fragColor, in vec2 F ) {  \n\tvec2 uv = F.xy/R.xy;\n    uv=(uv*1.025)-vec2(.0125,.0125);\n\n    vec4 baseColor = texture(iChannel0, uv);\n\n    baseColor *= vignette(uv, R.xy, 1.);\n\n    if (uv.x < 0. || uv.y < 0. || uv.x > 1. || uv.y > 1.){\n        baseColor = vec4(vec3(0),0);\n    }\n   \n    fragColor = baseColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Cavern River\n    02/29/2024  @byt3_m3chanic\n\n    Going though old shaders, one of my first was a learning experience \n    picking apart one of @Shane's tunnel demos (listed below). I love these\n    type of never ending paths shaders. Reminds me of the early demos I saw\n    at high school in the PC labs. \n    \n    Doing some cheap effects for water / just trying to keep perf up. Try\n    swapping textures in iChannel0 for other types of noise\n    \n    Oh yeah you can move the light with the mouse.\n    \n    Checkout some of @Shane's path/tunnel shaders!\n    https://www.shadertoy.com/view/MscSDB\n    https://www.shadertoy.com/view/MlXSWX\n    https://www.shadertoy.com/view/XlXXWj\n*/\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-3\n\n#define PI          3.1415926\n#define PI2         6.2831853\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define S           smoothstep\n\nmat2 r2(float a){ \n    return mat2(cos(a),sin(a),-sin(a),cos(a)); \n}\n\nfloat hash21( vec2 p ) { \n    return fract(sin(dot(p,vec2(43.23,34.21))) *6732.4); \n}\n    \nivec2 txtCoord(int offset) {\n    return ivec2(offset%32,offset/32);\n}\n\nfloat smin( in float a, in float b, float k) {\n    float h = max(k -abs(a-b), .5);\n    return min(a,b) - h*h/(k*4.);\n}\n// Triangle function by Nimitz\nvec3 tri(in vec3 x) {\n    return abs(x-floor(x)-.5);\n}\n// Surface/Path function @Shane https://www.shadertoy.com/view/MlXSWX \nfloat surf(in vec3 p) {\n    float a = texelFetch(iChannel0, txtCoord(3 * 127 + 1), 0).x;\n    float b = texelFetch(iChannel0, txtCoord(3 * 127 + 2), 0).x;\n    float c = texelFetch(iChannel0, txtCoord(3 * 127 + 3), 0).x;\n    float d = texelFetch(iChannel0, txtCoord(3 * 127 + 5), 0).x;\n\n    float dsp = sin(3. * p.x) * sin(4. * p.y) * sin(5. * p.z) * d;\n    float n = dot(tri(p*1.15), vec3(a,b,c)) + dsp;\n    p.xz = vec2(p.x + p.z, p.z - p.y) * .73;   \n\n    float e = texelFetch(iChannel0, txtCoord(3 * 127 + 6), 0).x*2.;\n    float f = texelFetch(iChannel0, txtCoord(3 * 127 + 7), 0).x;\n    float g = texelFetch(iChannel0, txtCoord(3 * 127 + 8), 0).x;\n    \n    n = dot(tri(p*e + tri(p*f).yzx), vec3(g)) + n;\n    return abs(n);\n}\n\nvec2 path(in float z){ \n    vec2 wv1 =vec2(1.3*cos(z * .35), 1.4*sin(z * .45));\n    vec2 wv2 =vec2(.6*sin(z * .59), .7*cos(z * .61));\n    return wv1 + wv2;\n}\n\nvec2 path2(in float z){ \n    vec2 wv1 =vec2(1.2*cos(z * .35), 1.2*sin(z * .15));\n    vec2 wv2 =vec2(2.3*sin(z * .59), 1.4*cos(z * .21));\n    return wv1 + wv2;\n}\nvec3 hit,hp;\n\nvec2 map (in vec3 p) {\n\n    \n    vec2 tun = p.xy - path(p.z);\n    vec2 tun2 = p.xy - path2(p.z);\n    \n    float ff = .3+.05*sin(p.z*2.1+T+tun2.x*.2+T*.1);\n    float fx = .35+.25*sin(p.z*.6);\n    float d =  1.- smin(length(tun)-.5,length(tun2),.25) + ((.5+fx)-surf(p));\n    hp = p;\n    vec2 res = vec2(d*.4,2.);\n\n    float g = tun2.y+ff;\n    if(g<res.x)res=vec2(g,3.);\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p) {\n    float d=0.,m=0.;\n    for(int i=0;i<164;i++){\n        vec2 t = map(p);\n        d += i<24?t.x*.3:t.x;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(t.x<d*MIN_DIST||d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 normal(in vec3 p) {\n    float d = map(p).x;\n    vec2 e = vec2(.01,.0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\n// https://www.shadertoy.com/view/XlXXWj\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x +\n         texture(tex, p.zx)*n.y +\n         texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Texture bump mapping @Shane https://www.shadertoy.com/view/MlXSWX \nfloat gscale(vec3 p) { \n    return p.x*.299 + p.y*0.587 + p.z*0.114; \n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float factor) {\n    const float e = .001;\n    float ref = gscale(tex3D(tex, p, n));                 \n    vec3 grad = vec3( \n        gscale(tex3D(tex, vec3(p.x-e, p.y, p.z), n))-ref,\n        gscale(tex3D(tex, vec3(p.x, p.y-e, p.z), n))-ref,\n        gscale(tex3D(tex, vec3(p.x, p.y, p.z-e), n))-ref\n    )/e;\n             \n    grad -= n*dot(n, grad);            \n    return normalize( n + grad*factor );  \n}\n\nfloat tm;\nvec4 FC = vec4(0.024,0.043,0.055,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float b, inout float d) {\n\n    vec3 color = vec3(1.);\n    vec3 p = ro;\n    vec2 ray = marcher(ro, rd, p);\n    hit=hp;\n    d = ray.x;\n    if(ray.x<MAX_DIST) {\n        vec3 n = normal(p);\n        vec3 tint = vec3(0,.1,.4);\n        if(ray.y==2.) {\n        \n            tint = tex3D( iChannel1, hit*.25, n);\n            vec3 ofs = mix(vec3(.66,.22,.17),vec3(.84,.48,.14),tint.x);\n            tint*=ofs;\n            n=doBumpMap(iChannel2, hit*3., n, .3);\n            ref=vec3(.001);\n         }\n        if(ray.y==3.) {\n            vec3 hp = hit*.3;\n            tint = vec3(0,vec2(.25,.425)*tex3D( iChannel3, T*.05+hp, n).xy);\n            n = doBumpMap(iChannel2, hp-T*.05, n, .02);\n            hp.z+=T*.07;\n            n = doBumpMap(iChannel2, hp, n, .02);\n            ref=vec3(.8);\n        }\n         \n        float y = M.xy==vec2(0) ? .0 : (M.y/R.y * 4.-2.)*PI; \n        float x = M.xy==vec2(0) ? .0 : (M.x/R.x * 1.-.5)*PI; \n        \n        vec3 lpos = vec3(x, .2, 2.75+tm+y);\n        lpos.xy += path2(lpos.z);\n        \n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.0,.9);\n\n        color = tint*diff;\n    \n        ro = p+n*.001;\n        rd = reflect(rd,abs(n));\n    }else{\n        color = FC.rgb;\n    } \n    return vec4(color,1.);\n}\n\nvec3 camera( in vec3 ro, in vec3 lp, in vec2 uv ) {\n    vec3 cf = normalize(lp-ro),\n         cp = vec3(0,1,0),\n         cr = normalize(cross(cp, cf)),\n         cu = normalize(cross(cf, cr)),\n         c = ro + cf * .35,\n         i = c + uv.x * cr + uv.y * cu;\n    return i-ro; \n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (F.xy - R.xy*.5)/max(R.x,R.y);\n\n    tm = T * .115;\n    \n    float ff = .15+.075*sin(T*1.1);\n\n    vec3 lp = vec3(0,.15-ff,tm);\n    vec3 ro = lp + vec3(0,0,-.3);\n    lp.x+= -.03+ff*.3;\n\n    lp.xy += path2(lp.z);\n    ro.xy += path2(ro.z);\n\n    vec3 rd = camera(ro, lp, uv);\n\n    vec3 C = vec3(0), ref = vec3(0), fil = vec3(1);\n    \n    float d = 0., a = 0.;\n    \n    for(float i=0.; i<2.; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref,i, d);\n        C += pass.rgb*fil;\n        fil *= ref;\n        if(i==0.) a = d;\n    }\n\n    C = mix(FC.rgb,C,  exp(-.0005*a*a*a));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}