{
    "Shader": {
        "info": {
            "date": "1488193938",
            "description": "A simple sample demonstrates how to raycast a box, not using raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "lslcDH",
            "likes": 1,
            "name": "Raycast to a box sample",
            "published": 3,
            "tags": [
                "math",
                "raycast",
                "box",
                "plane",
                "sample"
            ],
            "usePreview": 0,
            "username": "0xAA55",
            "viewed": 782
        },
        "renderpass": [
            {
                "code": "\nfloat PI = 3.1415926535897932384626;\nvec3 eyepos = vec3(0.0, 0.0, -5.0);\nvec2 yawpitch = vec2(0, 0);\n\nstruct box_t\n{\n    vec3 p, d;\n    mat3 r;\n};\n\nmat3 RotXAxis(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cang,-sang),\n        vec3(0.0, sang, cang)\n    );\n}\n\nmat3 RotYAxis(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, 0.0, sang),\n        vec3(  0.0, 1.0, 0.0),\n        vec3(-sang, 0.0, cang)\n    );\n}\n\nmat3 RotZAxis(float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3( cang, sang, 0.0),\n        vec3(-sang, cang, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat3 RotAxis(vec3 v, float ang)\n{\n    float sang = sin(ang);\n    float cang = cos(ang);\n    return mat3\n    (\n        vec3\n        (\n            (1.0 - cang) * v.x * v.x + cang,\n            (1.0 - cang) * v.x * v.y - sang * v.z,\n            (1.0 - cang) * v.x * v.z + sang * v.y\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.y * v.x + sang * v.z,\n            (1.0 - cang) * v.y * v.y + cang,\n            (1.0 - cang) * v.y * v.z - sang * v.x\n        ),\n        vec3\n        (\n            (1.0 - cang) * v.z * v.x - sang * v.y,\n            (1.0 - cang) * v.z * v.y + sang * v.x,\n            (1.0 - cang) * v.z * v.z + cang\n        )\n    );\n}\n    \nmat3 EulerRotation(vec3 ypr)\n{\n    return RotZAxis(ypr.z) * RotXAxis(ypr.y) * RotYAxis(ypr.x);\n}\n\nbool Box_Raycast(box_t box, vec3 start, vec3 n_ray, out vec3 castpoint, out vec3 normal, out vec2 uv, out float castdist, inout bool isfrominside)\n{\n    mat4 box_mat = mat4\n    (\n        vec4(box.r[0], 0.),\n        vec4(box.r[1], 0.),\n        vec4(box.r[2], 0.),\n        vec4(box.p, 1.)\n    );\n    bool inside = false;\n    \n    mat4 box_mat_inv = inverse(box_mat);\n    \n    vec3 start_local = (box_mat_inv * vec4(start, 1.)).xyz;\n    vec3 ray_local = (box_mat_inv * vec4(n_ray, 0.)).xyz;\n    \n    vec3 sv = step(abs(start_local), box.d);\n    if(sv.x > .5 && sv.y > .5 && sv.z > .5) inside = true;\n    if(inside && !isfrominside) return false;\n    if(inside || isfrominside) start_local = -start_local;\n    \n    vec3 rat = 1.0 / ray_local;\n    vec3 trp = rat * start_local;\n    vec3 dim = box.d * abs(rat);\n    \n    vec3 t1 = -trp - dim;\n    vec3 t2 = -trp + dim;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    \n\tif( tN > tF || (!isfrominside && tF < 0.0) ) return false;\n    \n    vec3 nor = -sign(ray_local)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    castpoint = start + n_ray * tN;\n    castdist = abs(tN);\n    normal = (box_mat * vec4(nor,0.)).xyz;\n    isfrominside = inside;\n    \n    vec3 cp_local = (box_mat_inv * vec4(castpoint, 1.)).xyz;\n    \n    uv = (nor.x * cp_local.yz + nor.y * cp_local.zx + nor.z * cp_local.xy) *.5 + .5;\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    vec2 mouse_rotation = ((iMouse.xy / iResolution.y) * 2. -1.) * PI;\n    \n    mat3 RotMat = RotXAxis(-mouse_rotation.y)\n        * RotYAxis(mouse_rotation.x)\n        * EulerRotation(vec3(iTime * .2, iTime * .1, iTime * .3));\n    \n    vec3 ray = normalize(vec3(xy, 1));\n    \n    vec4 color = vec4(.2, .5, 1., 1.);\n    \n    vec3 castpnt, castnormal;\n    vec2 castuv;\n    float castdist;\n    bool isfrominside;\n\n    box_t bx = box_t(vec3(0, 0, 0), vec3(1, 1, 1), RotMat);\n    \n    isfrominside = false;\n    // if(xy.x > 0.) isfrominside = true;\n    if(Box_Raycast(bx, eyepos, ray, castpnt, castnormal, castuv, castdist, isfrominside))\n\t{\n        // color = vec4(castdist);\n        color = vec4(castnormal * .5 + .5, 1.);\n        // color = texture(iChannel0, castuv);\n\t}\n    \n\tfragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}