{
    "Shader": {
        "info": {
            "date": "1489664628",
            "description": "A Simple scene of physically-incorrect ray-traced Spheres.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdscDS",
            "likes": 4,
            "name": "Ray-traced Spheres",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "sphere"
            ],
            "usePreview": 0,
            "username": "Yetman",
            "viewed": 635
        },
        "renderpass": [
            {
                "code": "#define PI  3.14159265\n#define PI2 6.28318531\n\n#define SIZE 25\n#define DELTA PI2/float(SIZE/2)\n#define BACKCOLOR_LOWER vec4(0.1,0.3,0.45,1)\n#define BACKCOLOR_UPPER vec4(0,0.025,0.05,1)\n#define DONT_DRAW_MAIN_SPHERE 0\n#define AA\n//#define BLINN\n#define ACES_TM\n//#define EXPOSURE_TM\n//#define REINHARD_TM\n//#define GAMMA_CORRECTION\n\n\nconst float ball_speed = 0.25;\nconst float light_speed = 0.25;\nconst vec3 mainCenter = vec3(0,0,20);\nconst float rotationRadius = 12.0;\nconst float mainRadius = 10.0;\nconst float subRadius = 1.0;\n\nconst vec3 albedo0 = vec3(0.7,0.6,0.1);\nconst vec3 ambient0 = vec3(0.1,0.1,0.05);\nconst vec3 albedo1 = vec3(0.6,0.05,0.1);\nconst vec3 ambient1 = vec3(0.1,0,0.05);\nconst vec3 albedo2 = vec3(0.05,0.6,0.1);\nconst vec3 ambient2 = vec3(0,0.1,0.05);\n\nstruct sphere\n{\n    vec3 center;\n    float radius;\n    vec3 albedo;\n    vec3 ambient;\n};\n\nstruct directional_light\n{\n    vec3 direction;\n};\n\nstruct ray\n{\n    vec3 start;\n    vec3 direction;\n};\n\nstruct ray_hit\n{\n    int idx;\n    float dist;\n};\n\nsphere spheres[SIZE];\ndirectional_light light;\n\nray_hit raySphereIntersect(in ray r, in sphere s)\n{\n    vec3 L = s.center - r.start;\n    float proj = dot(r.direction, L);\n    float dis2 = dot(L,L) - proj*proj;\n\tfloat r2 = s.radius * s.radius;\n    if(dis2 > r2) return ray_hit(-1,proj);\n    float db = sqrt(r2 - dis2);\n    float x = proj - db;\n\tif(x < 0.0) return ray_hit(-1,x);\n\treturn ray_hit(0, x);\n}\n\nray_hit sceneIntersect(in ray r, in int begin, in int end, in int except)\n{\n    ray_hit res = ray_hit(-1,1e12);\n    for(int i = begin; i < end; i++){\n        if(i != except){\n        \tray_hit ires = raySphereIntersect(r, spheres[i]);\n            if(ires.idx >= 0 && ires.dist < res.dist) res = ray_hit(i, ires.dist);\n        }\n    }\n    return res;\n}\n\nvec3 rotfn(float val, float val2)\n{\n    float cosval = cos(val);\n    return normalize(vec3(cos(val2)*cosval,sin(val2)*cosval,sin(val)));\n}\n\nvec4 simplephong(in ray r, in ray_hit h)\n{\n    vec3 point = r.start + h.dist * r.direction;\n    ray_hit lightRes = sceneIntersect(ray(point, -light.direction), DONT_DRAW_MAIN_SPHERE, SIZE, h.idx);\n    vec3 normal = (point - spheres[h.idx].center)/spheres[h.idx].radius;\n    float fresnel = 0.2*pow(1.0+dot(r.direction,normal), 4.0);\n    if(lightRes.idx < 0)\n    {\n        float diffuse = max(dot(-light.direction, normal), 0.0);\n        #ifdef BLINN \n        float specular = pow(max(0.0, -dot(normal, normalize(light.direction + r.direction))), 140.0);\n        #else\n        float specular = pow(max(0.0, -dot(r.direction, reflect(light.direction, normal))), 70.0);\n        #endif\n        return vec4((diffuse+fresnel)*spheres[h.idx].albedo + spheres[h.idx].ambient + specular*vec3(1),1);\n    }\n    else\n        return vec4(fresnel*spheres[h.idx].albedo + spheres[h.idx].ambient,1);\n}\n\nvec4 reflectivephong(in ray r, in ray_hit h)\n{\n    vec3 point = r.start + h.dist * r.direction;\n    ray_hit lightRes = sceneIntersect(ray(point, -light.direction), DONT_DRAW_MAIN_SPHERE, SIZE, h.idx);\n    vec3 normal = normalize(point - spheres[h.idx].center);\n    float fresnel = 0.2*pow(1.0+dot(r.direction,normal), 4.0);\n    vec4 reflected = vec4(0,0,0,1);\n    vec3 refDir = reflect(r.direction, normal);\n    ray_hit refRes = sceneIntersect(ray(point, refDir), DONT_DRAW_MAIN_SPHERE, SIZE, h.idx);\n    if(refRes.idx >= 0){\n        reflected = simplephong(ray(point, refDir), refRes);\n    } else {\n        reflected = mix(BACKCOLOR_LOWER,BACKCOLOR_UPPER,(refDir.y+1.0)/2.0);\n    }\n    if(lightRes.idx < 0)\n    {\n        float diffuse = max(dot(-light.direction, normal), 0.0);\n        #ifdef BLINN \n        float specular = pow(max(0.0, -dot(normal, normalize(light.direction + r.direction))), 140.0);\n        #else\n        float specular = pow(max(0.0, -dot(r.direction, reflect(light.direction, normal))), 70.0);\n        #endif\n        return vec4((diffuse+fresnel)*spheres[h.idx].albedo + spheres[h.idx].ambient + 0.9*reflected.rgb + specular*vec3(1,1,1),1);\n    }\n    else\n        return vec4(fresnel*spheres[h.idx].albedo + spheres[h.idx].ambient + 0.9*reflected.rgb,1);\n}\n\nvec3 coord2dir(vec2 coord)\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = coord / iResolution.xy;\n    uv = (2.0*uv - 1.0)*vec2(aspectRatio,1);\n    return normalize(vec3(uv, 1.0));\n}\n\n#ifdef ACES_TM\n//ACES Filmic Tonemapping Approximation \n//From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 start = vec3(0,0,0);\n    \n    float stime = iTime*ball_speed;\n    float lstime = iTime*light_speed;\n    \n    light.direction = normalize(vec3(cos(lstime),cos(lstime),sin(lstime)));\n    \n    spheres[0] = sphere(mainCenter, mainRadius, albedo0, ambient0);\n    for(int i = 1; i < SIZE/2+1; i++){\n        spheres[i] = sphere(mainCenter - rotationRadius*rotfn(stime+DELTA*float(i), stime+PI/4.0),\n                            subRadius, albedo1, ambient1);\n    }\n    for(int i = SIZE/2+1; i < SIZE; i++){\n        spheres[i] = sphere(mainCenter - rotationRadius*rotfn(stime+DELTA*float(i)+ DELTA/2.0, stime-PI/4.0),\n                            subRadius, albedo2, ambient2);\n    }\n    \n    fragColor = vec4(0);\n    float depth = 0.0;\n    #ifdef AA\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++) {\n            vec3 direction = coord2dir(fragCoord+vec2(i,j)/2.0);\n            #else\n            vec3 direction = coord2dir(fragCoord);\n            #endif\n            ray_hit res = sceneIntersect(ray(start, direction), DONT_DRAW_MAIN_SPHERE, SIZE, -1);\n            if(res.idx < 0) {\n                fragColor += mix(BACKCOLOR_LOWER,BACKCOLOR_UPPER,(direction.y+1.0)/2.0);\n                depth += 1000.0;\n            }\n            else {\n                fragColor += reflectivephong(ray(start, direction), res);\n                depth += res.dist;\n            }\n            #ifdef AA\n        }\n    }\n    fragColor /= 9.0;\n    depth /= 9.0;\n    #endif\n    #ifdef ACES_TM\n    //ACES Filmic ToneMapping\n    fragColor = vec4(ACESFilm(fragColor.rgb), 1.0);\n    #elif defined(EXPOSURE_TM)\n    //Exposure ToneMapping\n    const float exposure = 1.0;\n    fragColor = vec4(vec3(1.0) - exp(-fragColor.rgb * exposure), 1.0);\n    #elif defined(REINHARD_TM)\n    //Reinhard Tonemapping\n    fragColor /= vec4((fragColor + vec4(1.0)).rgb, 1.0);\n    #endif\n    #ifdef GAMMA_CORRECTION\n    // Gamma correction \n    const float gamma = 2.2;\n    fragColor = pow(fragColor, vec4(1.0 / gamma));\n    #endif\n    fragColor.a = (mainCenter.z - depth)/mainRadius;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}