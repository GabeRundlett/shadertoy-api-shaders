{
    "Shader": {
        "info": {
            "date": "1559650664",
            "description": "Raytraced metaballs",
            "flags": 0,
            "hasliked": 0,
            "id": "3lj3DD",
            "likes": 0,
            "name": "Metashapes",
            "published": 3,
            "tags": [
                "ray",
                "meta"
            ],
            "usePreview": 0,
            "username": "elementbound",
            "viewed": 502
        },
        "renderpass": [
            {
                "code": "#define DEG2RAD 0.01745329251994329576923690768489\n#define PI 3.1415926535897932384626433832795\n#define SQRT3 0.57735026918962576450914878050195\n\nconst int ITERATION_COUNT = 64;\nconst int RAY_DEPTH = 1;\nconst float RAY_OFFSET = 0.05f;\nconst float NABLA = 0.05f;\nconst float MIN_STEP = 0.0125f;\n\nstruct sphere_t {\n    vec3 pos; \n    float r;\n};\n    \nstruct camera_t {\n\tvec3 from; \n\tvec3 to;\n\tvec3 up;\n};\n    \nsphere_t spheres[3];\nsphere_t cubes[3];\ncamera_t camera;\n\n// Based on: \n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\nmat4 lookAt(vec3 from, vec3 to, vec3 up) {\n    up = normalize(up);\n    \n    vec3 forward = to - from;\n    forward = normalize(forward);\n    \n    vec3 side = normalize(cross(forward, up));\n    up = cross(side, forward); \n    up = normalize(up);\n    \n    return mat4(vec4(side, 0.0), vec4(up, 0.0), vec4(forward, 0.0), vec4(0.,0.,0.,1.));\n}\n\nvec3 yawroll(float yaw, float roll) {\n    float d = cos(roll);\n    return vec3(cos(yaw)*d, sin(roll), sin(yaw)*d);\n}\n\nmat4 getView(in camera_t camera) {\n    return lookAt(camera.from, camera.to, camera.up);\n}\n\nvoid setupCamera(float time) {\n    float yaw = iTime / 15.0;\n    float roll = (1.0 + sin(mod(iTime / 30.0, 1.0) * 2.0 * PI)) / 2.0;\n    roll = mix(-30.0f, 60.0f, roll) * DEG2RAD;\n    \n    camera.from = yawroll(yaw, roll) * 4.0;\n    camera.to = vec3(0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n}\n\nvoid setupScene(float time) {\n    float f = mod(time / 32.0,1.0);\n    \n    spheres[0].pos = yawroll(120.0f +  360.0f * f * DEG2RAD,   0.0f * DEG2RAD); spheres[0].r = 0.8;\n    spheres[1].pos = yawroll(240.0f +  720.0f * f * DEG2RAD,  45.0f * DEG2RAD); spheres[1].r = 1.0;\n    spheres[2].pos = yawroll(360.0f + 1080.0f * f * DEG2RAD, -30.0f * DEG2RAD); spheres[2].r = 1.2;\n    \n    cubes[0].pos = 2.0f * yawroll(120.0f * DEG2RAD, 0.0f) - vec3(0,4,0); cubes[0].r = 1.5;\n    cubes[1].pos = 2.0f * yawroll(240.0f * DEG2RAD, 0.0f) - vec3(0,4,0); cubes[1].r = 1.5;\n    cubes[2].pos = 2.0f * yawroll(  0.0f * DEG2RAD, 0.0f) - vec3(0,4,0); cubes[2].r = 1.5;\n    \n    setupCamera(time);\n}\n\nfloat evaluateSphere(vec3 at, sphere_t sphere) {\n    return distance(at, sphere.pos) - sphere.r;\n}\n\nfloat evaluateCube(vec3 at, sphere_t cube) {\n    vec3 d = at - cube.pos;\n    vec3 da = abs(d);\n    float m = max(da.x, da.y);\n    m = max(m, da.z);\n    \n    return m - cube.r;\n}\n\nfloat evaluateScene(vec3 at) {\n    float result = evaluateSphere(at, spheres[0]);\n    \n    for(int i = 1; i < spheres.length(); i++) {\n        result = min(result, evaluateSphere(at, spheres[i]));\n    }\n    \n    for(int i = 0; i < cubes.length(); i++) {\n        result = min(result, evaluateCube(at, cubes[i]));\n    }\n                     \n    return result;\n}\n\nvec3 evaluateNormal(vec3 at, float r) {\n    const vec3[8] OFFSETS = vec3[8](\n        vec3(        SQRT3,        SQRT3,        SQRT3),\n        vec3(        SQRT3,-1.0f * SQRT3,-1.0f * SQRT3),\n        vec3(-1.0f * SQRT3,        SQRT3,-1.0f * SQRT3),\n        vec3(-1.0f * SQRT3,-1.0f * SQRT3,        SQRT3),\n        \n        vec3(        SQRT3,        SQRT3,-1.0f * SQRT3),\n        vec3(        SQRT3,-1.0f * SQRT3,        SQRT3),\n        vec3(-1.0f * SQRT3,        SQRT3,        SQRT3),\n        vec3(-1.0f * SQRT3,-1.0f * SQRT3,-1.0f * SQRT3)\n    );\n    \n    vec3 result = vec3(0);\n    \n    for(int i = 0; i < OFFSETS.length(); i++) {\n        vec3 offset = OFFSETS[i];\n        \n        result += offset * evaluateScene(at + offset * r);\n    }\n    \n    return normalize(result);\n}\n\nvoid evaluateRay(inout vec3 at, vec3 ray, out float value) {\n    for(int i = 0; i < ITERATION_COUNT; i++) {\n        value = evaluateScene(at);\n        \n        if (value < 0.0f) {\n        \t// We found a hit!\n            at += ray * value;\n            break;\n        } else {\n        \tat += ray * max(MIN_STEP, value);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scene\n    setupScene(iTime);\n\n    // Camera\n    const float fov = 60.0f * DEG2RAD;\n    const float znear = 1.0 / tan(fov / 2.0f);\n    \n    mat4 view = getView(camera);\n    \n    // Ray\n    vec3 ray = normalize(vec3(uv, znear));\n    ray = (view * vec4(ray, 1.0)).xyz;\n    \n    // Raytrace\n    vec3 at = camera.from;\n    float value;\n    vec3 normal;\n    \n    vec4 color = texture(iChannel0, ray);\n    \n    for(int i = 0; i < RAY_DEPTH; i++) {\n    \tevaluateRay(at, ray, value);\n        \n        if(value <= 1.0f) {\n            normal = evaluateNormal(at, NABLA);\n            ray = reflect(ray, normal);\n            color = texture(iChannel0, ray);\n            \n            at += RAY_OFFSET * ray;\n        } else {\n            break;\n        }\n    }\n    \n    // Output to screen\n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}