{
    "Shader": {
        "info": {
            "date": "1594505469",
            "description": "Interpolate between boundary data in 2D.\nGeneralized interpolation using walk on spheres to solve the laplacian equation with a monte carlo method.\nBuffer A has the logic.\nFor a blog post coming shortly!",
            "flags": 48,
            "hasliked": 0,
            "id": "wtSyWm",
            "likes": 12,
            "name": "Demofox WoS Interpolation 2D",
            "published": 3,
            "tags": [
                "montecarlo",
                "interpolation",
                "laplace",
                "wos"
            ],
            "usePreview": 1,
            "username": "demofox",
            "viewed": 1268
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the interpolated color\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rgb;\n    \n    // convert from linear to sRGB and output the color\n    fragColor = vec4(LinearToSRGB(color), 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// rainbow colors from\n// https://www.shadertoy.com/view/lsfBWs\n// level is [0,5], assumed to be a whole number\nvec3 rainbow(float level)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\nvec3 smoothRainbow (float x)\n{\n    float level1 = floor(x*6.0);\n    float level2 = min(6.0, floor(x*6.0) + 1.0);\n    \n    vec3 a = rainbow(level1);\n    vec3 b = rainbow(level2);\n    \n    return mix(a, b, fract(x*6.0));\n}\n\n// sdLine() from\n// https://iquilezles.org/articles/distfunctions\nvoid LineTest(in vec2 p, vec2 a, vec2 b, vec3 cu,vec3 cv, inout vec4 dis_col)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    if( d<dis_col.x )\n    {\n        float s = pa.x*ba.y-pa.y*ba.x;\n        dis_col = vec4(d,(s<0.0)?cu:cv);\n    }\n}\n\nvoid CircleTest(in vec2 p, in vec3 centerRadius, in vec3 color, inout vec4 distanceAndColor)\n{\n    p -= centerRadius.xy;\n    float dist = length(p) - centerRadius.z;\n    if (dist < distanceAndColor.x)\n    {\n        distanceAndColor.x = dist;\n        distanceAndColor.yzw = color;\n    }\n}\n\nvec4 DistanceToBoundaryAndColor(vec2 p)\n{\n    vec4 ret = vec4(10000.0, 0.0, 0.0, 0.0);\n    \n    #if SCENE == 1 || SCENE == 2\n    {\n        float dist = -(length(p) - 0.4);\n        if (dist > -0.01)\n        {\n        \tfloat angle = atan(p.y, p.x);\n            if (angle < 0.0)\n                angle += c_pi * 2.0;\n            \n            #if SCENE == 2\n                float percent = angle / (2.0 * c_pi);\n            \tfloat shade = sin(angle * 10.0);\n            \tvec3 color = smoothRainbow(percent) * shade;\n            #else\n            \tfloat shade = sin(angle * 10.0);\n            \tvec3 color = vec3(shade, shade, shade);           \n            #endif\n        \tret.x = dist;\n        \tret.yzw = color;\n        }\n        else\n        {\n            ret = vec4(0.0, 0.8, 0.8, 0.8);\n        }\n        \n    }\n    #elif SCENE == 3\n    {\n    \tLineTest(p, vec2(0.0, -0.2), vec2(0.3, 0.2), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ret);\n    \tLineTest(p, vec2(0.3, 0.2), vec2(-0.3, 0.2), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ret);\n    \tLineTest(p, vec2(-0.3, 0.2), vec2(0.0, -0.2), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ret);\n    }\n    #elif SCENE == 4\n    {\n    \tLineTest(p, vec2(0.3, -0.2), vec2(0.3, 0.2), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ret);\n    \tLineTest(p, vec2(0.3, 0.2), vec2(-0.3, 0.2), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ret);\n    \tLineTest(p, vec2(-0.3, 0.2), vec2(-0.3, -0.2), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ret);\n    }    \n    #elif SCENE == 5\n    {\n        CircleTest(p, vec3(0.0, -0.2, 0.03), vec3(1.0, 0.0, 0.0), ret);\n        CircleTest(p, vec3(0.3, 0.2, 0.03), vec3(0.0, 1.0, 0.0), ret);\n        CircleTest(p, vec3(-0.3, 0.2, 0.03), vec3(0.0, 0.0, 1.0), ret);\n\n        LineTest(p, vec2(-0.7, 0.4), vec2(-0.7, -0.4), vec3(0.0, 0.0, 0.0), vec3(0.8, 0.8, 0.8), ret); \n        LineTest(p, vec2( 0.7, 0.4), vec2( 0.7, -0.4), vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), ret); \n    }\n    #endif\n    \n    return ret;\n}\n\nvec2 R2(int index)\n{\n    // Generalized golden ratio to 2d.\n    // Solution to x^3 = x + 1\n    // AKA plastic constant.\n    // from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    float g = 1.32471795724474602596f;\n    float a1 = 1.0f / g;\n    float a2 = 1.0f / (g * g);\n\n    return vec2(fract(float(index) * a1), fract(float(index) * a2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    vec3 thisFrameColor = vec3(0.0f, 0.0f, 0.0f);\n    for (int walkIndex = 0; walkIndex < c_numWalksPerFrame; ++walkIndex)\n    {\n        // this is our starting point\n        vec2 p = (fragCoord.xy / iResolution.xy); \n        if (BN != 0)\n            p.x = fract(p.x*2.0);\n        p -= 0.5;\n        p.x *= iResolution.x / iResolution.y;  // aspect ratio\n        \n        // first random number\n        vec2 offset = R2(iFrame) * vec2(1024.0, 1024.0);\n        float rnd = texelFetch(iChannel2, ivec2(fragCoord.xy + offset) % ivec2(1024, 1024),0).r;\n        rnd = fract(rnd + float(walkIndex) * c_goldenRatioConjugate);\n        if (BN == 0 || fragCoord.x < iResolution.x * 0.5)\n        {\n            rnd = RandomFloat01(rngState);              \n        }\n\n        // Walk on spheres algorithm\n        vec4 distanceAndColor;\n        for (int i = 0; i < c_numStepsMax; ++i)\n        {        \n            // Get distance to closest boundary.\n            // If it's close enough, we are done. Use the color of the boundary we are next to.\n            distanceAndColor = DistanceToBoundaryAndColor(p);\n            if (distanceAndColor.x < c_epsilon)\n                break;\n\n\n            // Otherwise, walk the distance to the nearest boundary, in a random direction.\n            float angle = rnd * 2.0 * c_pi;\n            vec2 direction = vec2(cos(angle), sin(angle));\n            p += direction * distanceAndColor.x;\n            \n            // next random number\n            rnd = RandomFloat01(rngState);\n        }\n        thisFrameColor += distanceAndColor.yzw / float(c_numWalksPerFrame);\n    }\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);  \n\n    // incremental average this new color with the old.\n    vec4 lastFrameColor = texelFetch(iChannel0, ivec2(fragCoord.xy),0);\n    float blend = (iFrame < 2 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    #if BN\n    vec3 newColor = thisFrameColor;\n    #else\n    vec3 newColor = mix(lastFrameColor.rgb, thisFrameColor, blend);\n    #endif\n    fragColor = vec4(newColor, blend);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// how close the random walk needs to get before it's considered a hit.\n// This is in a percentage of the screen\nconst float c_epsilon = 0.001;\n\n// how many steps to take on the random walk at maximum\nconst int c_numStepsMax = 32;\n\n// how many walks done per pixel, per frame.\n// useful for getting around being limited to 60fps\nconst int c_numWalksPerFrame = 64;\n\n// SCENE values:\n// 1 - a black and white circle\n// 2 - a rainbow circle\n// 3 - a triangle with sides RGB inside and out\n// 4 - same as 3, but made into a U shape instead of a triangle\n// 5 - 3 circles R,G,B with black borders on the sides\n#define SCENE 5\n\n#define BN 0\n#define BN_SEED_SHARE 1\n\nconst float c_goldenRatioConjugate = 0.618033988749895;\n\n// ==================================================================\n\nconst float KEY_SPACE = 32.5/256.0;\n\nconst float c_pi = 3.14159265359;\n\n// for converting from linear to sRGB\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(\n        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        lessThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308))\n    );\n}\n\n// RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}