{
    "Shader": {
        "info": {
            "date": "1635602979",
            "description": "Creating an antialiased, glass and metal, animated two-tiled hexagonal Truchet scene in realtime.",
            "flags": 32,
            "hasliked": 0,
            "id": "NdVXWy",
            "likes": 65,
            "name": "Glass And Metal Tubing",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "glass",
                "truchet",
                "metal",
                "reprojection"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1060
        },
        "renderpass": [
            {
                "code": "/*\n\n\tGlass And Metal Tubing\n\t----------------------\n    \n    See Buffer A.    \n\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // The other buffer has a maximum Y-resolution of 540 set, which \n    // means any pixels outside that are mot rendered. On a 1980x1080\n    // fullscreen resolution, this means roughly a quarter of the pixels\n    // are rendered, which is a huge saving. Of course, this also means\n    // that the scene needs to be upscaled, which will make things less\n    // crisp, but you can't have everything. :)\n    //\n    // By the way, this tip came from Shadertoy user, spalmer, who has\n    // a heap of interesting work for anyone interested:\n    // https://www.shadertoy.com/user/spalmer\n    //\n    const float maxRes = 540.;\n    vec2 uv = fragCoord/iResolution.xy;\n    // If the resolution exceeds the maximum, upscale.\n    if(iResolution.y>maxRes) uv = (fragCoord/iResolution.xy - .5)*maxRes/iResolution.y + .5;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = sqrt(col);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n\tGlass And Metal Tubing\n\t----------------------\n\n    Creating an antialiased, glass and metal, animated two-tiled \n    hexagonal Truchet scene in realtime. I put this together some \n    time ago, but took a while to put in the finishing touches. It \n    runs at full speed in the large canvas window on my laptop, but \n    it's pretty GPU intensive, so apologies in advance for anyone \n    who experiences slowdown.\n    \n    There are more than a few challenges associated with creating\n    glassy materials in a shader. For anything but the simplest of\n    scenes, execution speed is definitely one of them, as you require \n    multiple bounces -- For this particular example, any fewer than 5 \n    won't look right. On top of that, the finished product tends to \n    look more sparkly and aliased than usual due to contrasty edges. \n    There's an easy solution, and that is to use multisampling on \n    each frame.\n    \n    Unfortunately, that's not viable. Rendering slightly offset pixel\n    samples to a buffer then combining can help mitigate the aliasing\n    to a degree, but with a moving camera, you're then left with \n    temporal camera ghosting. That too can be mitigated with IQ's \n    awesome temporal camera reprojection code -- Speaking of helpful \n    material, going to fullscreen won't utterly slay performance\n    thanks to spalmer's maximum resolution and upscaling idea.\n    \n    Once you've solved those problems, you're still left with ghosting\n    due to objects that move relative to the camera, and unfortunately,\n    there's not a lot that can be done about it... so I'm declaring any\n    motion blur effects a feature. :D Seriously though, if someone\n    knows a way around that, I'd love to hear it.\n    \n    I guess the last thing I should mention is that the distance\n    field is an animated two-tiled hexagon Truchet, which wasn't as\n    difficult to produce as I thought it'd be. However, it wasn't \n    particularly easy either. Anyway, hopefully the code will make\n    it easier for the next person who wants to try it. :) By the way,\n    I have one that includes a crossover tubing tile that I'll\n    post later.    \n    \n\n    \n    Useful examples:\n\n\t// An old favorite. Simple and pretty.\n    Spout - P_Malin\n\thttps://www.shadertoy.com/view/lsXGzH\n\n    // If you're trying to implement a basic multipass refraction and reflection \n    // example, I'd recommend this one. There are subtle differences, but I'm\n    // using similar logic. I adopted some of the naming conventions as well.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n    \n    // 3D temporal reprojection: IQ puts up a lot of difficult to find code with\n    // very little fanfare. This is one example.\n    Some boxes - iq\n    https://www.shadertoy.com/view/Xd2fzR\n    \n    // A fullscreen upscaling example, amongst other things.\n    Lights, Camera, Action! - spalmer \n    https://www.shadertoy.com/view/sdKXD3\n \n*/\n\n// Make use of IQ's well written temporal reprojection code. Unfortunately, \n// if you have a slow machine, all you'll see is blur, so you'll need\n// to turn it off.\n#define REPROJECTION\n\n// Use the simpler (and faster) square Truchet tiles. In fact, I prefer\n// this, since it's faster and looks more antialiased. However, I figured \n// people would appreciate the alternative two tiled animated hexagon \n// Truchet, which is by far the more unique of the two.\n//#define SQUARE_TRUCHET\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 5\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(23.527, 57.683)))*43758.5453); }\n\n/*\n// Based on the UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input. Also, \n// in theory, you could tweak the figures by hand to get a really scrambled output... \n// When I'm feeling less lazy, I might do that.\n//\n// By the way, GPU's are fickle things, so if this isn't working on your\n// system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    p -= floor(p/128.)*128. + vec2(64.340627, 72.465623);\n    return fract(dot(p.xyx*p.xyy, vec3(20.390625, 60.703123, 2.4281207)));\n    \n    // My own experimental hash. Seems to work for the right range, but \n    // I don't trust it yet.\n    //p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    //return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    \n    // Another, based on the \"17*17 = 289\" thing.\n    //float x = dot(p, vec2(97, 37));\n    //x *= 288./289.;                \n    //x = (x - floor(x))*289.;                         \n    //x = (x*34. + 113.)*x/289.;                       \n    //return x - floor(x);    \n \n}\n*/\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n\n#ifdef SQUARE_TRUCHET\n\n// The scene. All of it is pretty standard. There's a wall, extruded\n// hollowed out Truchet tubing and some metallic elements. To be honest, \n// this was a little rushed, but the field doesn't have a lot going on, \n// so tightening it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;\n     \n    // Truchet object and animated metallic balls: This is just a\n    // standard 2D animated Truchet with an extruded factor. If you're\n    // not sure how it works, myself and others have plenty of \n    // animated Truchet examples on Shadertoy to refer to.\n    //\n    // Grid construction: Cell ID and local cell coordinates.\n    const vec2 GSCALE = vec2(1./3.);\n    const vec2 sc = 1./GSCALE, hsc = .5/sc;    \n    vec2 iq = floor(p.xy*sc) + .5;    \n    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;\n    \n    // Flip random cells. This effectively rotates random cells,\n    // but in a cheaper way.\n    float rnd = hash21(iq + .37);\n    if(rnd<.5) q.y = -q.y;\n      \n    // Circles on opposite square vertices.\n    vec2 d2 = vec2(length(q - hsc), length(q + hsc));\n    // Using the above to obtain the closest arc.\n    float crv = abs(min(d2.x, d2.y) - hsc.x);\n    \n    // Flipping the direction on alternate squares so that the animation\n    // flows in the right directions -- It's a standard move that I've\n    // explained in other examples.  \n    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;\n    // Using repeat polar coordinates to create the moving metallic balls.\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot2(iTime*dir); // Animation occurs here.\n    float a = atan(pp.y, pp.x); // Polar angle.\n    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.\n    // Polar coordinate.\n    vec2 qr = rot2(a*6.2831853)*pp; \n    qr.x -= hsc.x;\n     \n    // Ridges, for testing purposes.\n    //crv += clamp(cos(a*16. + dir*iTime)*2., 0., 1.)*.003;\n    \n    // A rounded square Truchet tube. Look up the torus formula, if you're\n    // not sure about this. However, essentially, you place the rounded curve\n    // bit in one vector position and the Z depth in the other, etc. Trust me,\n    // it's not hard. :)\n    float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .05;\n    //float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .02), vec2(.05, .05), .035);\n    \n    \n \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along. This operation needs to be\n    // performed prior to hollowing out the tubes. See below.\n    q = abs(abs(q) - .5/sc);\n    float mtl = min(q.x, q.y) - .01;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Adding in the railing.\n    float rail = tr + .035 + .01;\n    \n\n    // 3D ball position.\n    vec3 bq = vec3(qr,  p.z + .05/2. + .02);\n    //float ball = max(length(bq.zx) - .02, abs(bq.y) - .03);\n    float ball = length(bq) - .02; // Ball.\n    //ball = abs(ball + .005) - .005; // Hollow out.\n    \n    float mtl2 = ball;//max(ball, -(rail - .0025));\n    mtl = min(mtl, rail);\n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway.\n    tr = max(tr, -(tr + .01 + .01));\n\n    // Debug: Take out the glass tubing.\n    //tr += 1e5;\n    \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, mtl2);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), min(mtl, mtl2));\n \n}\n\n#else\n\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    //vec4 h = p.xyxy - vec4(hC.xy + .5, hC.zw)*s.xyxy;\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n\n// The hexagon field.\nfloat map(vec3 q){\n\n    // Debug usage to compare rigid moving objects with\n    // objects that flow with the Truchet tubing.\n    #define RIGID_OBJECTS\n\n    // Scaling factor.\n    const float sc = 2.;\n    \n    // Moving object time; A bit redundant here, but helpful when \n    // you want to change the speed without having to refactor everywhere.\n    float tm = iTime;\n  \n\n    // Back wall\n    float wall = -q.z + .1; // Thick wall: (abs(p.z - .2) - .2) + .1;\n\n\n    // Local hexagonal cell coordinate and cell ID.\n    vec4 h = getGrid(q.xy*sc);\n    \n    // Using the idetifying coordinate - stored in \"h.zw,\" to produce a unique random number\n    // for the hexagonal grid cell.\n    float rnd = hash21(h.zw + vec2(.11, .31));\n    //rnd = fract(rnd + floor(iTime/3.)/10.); // Periodically changing the random number.\n    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); // Another random number.\n   \n    \n    // It's possible to control the randomness to form some kind of repeat pattern.\n    //rnd = mod(h.z + h.w, 2.)/2.;\n    \n    \n    // Storing the local hexagon cell coordinates in \"p\". This serves no other\n    // purpose than to not have to write \"h.xy\" everywhere. :)\n    vec2 p = h.xy;\n    \n\n    // Using the local coordinates to render three arcs, and the cell ID\n    // to randomly rotate the local coordinates by factors of PI/3.\n    rnd = floor(rnd*144.);\n    \n    // Random rotation and flow direction..\n    float dir = mod(rnd, 2.)*2. - 1.;\n    float ang = rnd*3.14159/3.;\n\n    p = rot2(ang)*p; // Random rotate.\n    \n    \n    // Arc radii and thickness variables.\n    const float rSm = s.y/6.; // .5/1.732 -> 1.732/2./3.\n    const float th = .1; // Arc thickness.\n\n    // The three segment (arc) distances.\n    vec3 d;\n    \n   \n    // Metal.\n    float mtl = 1e5;\n \n    #ifndef RIGID_OBJECTS\n    // Angle for non rigid objects.\n    float a3;\n    #endif\n    \n    // The Truchet distance.\n    float tr = 1e5;\n    \n    // A scaling constant.\n    const float aSc = 1.;\n    \n    // Is the piece and arc or not. This is an orientation hack that I'll\n    // fix later.\n    float isArc = 1.;\n    \n    // Z-based value and a redundant height value that gets used in\n    // another example.\n    vec3 qZ3, hgt = vec3(0);\n    \n    // Rotation and minimum coordinate.\n    vec2 qR, minP;\n    \n    if(rnd2<.5){\n    \n        // Relative local coordinate centers of the two arc and line.\n        vec2 p0 = p - vec2(0, -s.y/3.);\n        vec2 p1 = p - vec2(0, s.y/3.);\n        vec2 p2 = p;\n        // Distances.\n        d.x = length(p0) - rSm;\n        d.y = length(p1) - rSm;\n        d.z = abs(p2.y);\n        \n        d = abs(d)/sc; // Turning the circles into arc segments and scaling.\n\n        // Move the Z-position out to the correct position for all three tubes. \n        // There's a redundant relative height value there for crossover tubes.\n        qZ3 = q.z + .045 + hgt;\n\n        // A rounded or square Truchet tube. Look up the torus formula, if you're\n        // not sure about this. However, essentially, you place the rounded curve\n        // bit in one vector position and the Z depth in the other, etc. Trust me,\n        // it's not hard. :)\n\n        // Technically, I could get away with using the minimum 2D arc length and \n        // calculate just one of these, but I'll be extending to include crossover\n        // arcs, so I'll leave it in this form.\n        d.x = length(vec2(d.x, qZ3.x)) - .05;\n        d.y = length(vec2(d.y, qZ3.y)) - .05;\n        d.z = length(vec2(d.z, qZ3.z)) - .05;\n    /*    \n        d.x = sBoxS(vec2(d.x, qZ3.x), vec2(.05, .05), .025);\n        d.y = sBoxS(vec2(d.y, qZ3.y), vec2(.05, .05), .025);\n        d.z = sBoxS(vec2(d.z, qZ3.z), vec2(.05, .05), .025);\n    */    \n\n        \n        \n        // Arc segment angle calculation.\n        if(min(d.x, d.y)<d.z){\n            \n            // Minimum \n            minP = p1;\n            \n            // Reverse the direction of the first arc.\n            if(d.x<d.y) {\n               minP = p0; \n               dir *= -1.;\n            }\n            \n            #ifdef RIGID_OBJECTS\n            minP *= rot2(dir*tm); // Animation occurs here.\n            float a = atan(minP.y, minP.x); // Polar angle.\n            a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.\n            // Polar coordinate.\n            qR = rot2(a*6.2831853)*minP; \n            qR.x -= rSm; \n            #else\n            a3 = atan(minP.x, minP.y);\n            a3 = (a3*(6./6.2831)*aSc - tm*dir);\n            #endif\n            \n        }\n        else {\n            \n            // I guessed a time dialation figure of 3.14159 based on the relative \n            // length of a full circle tube (broken into thirds) and a straight\n            // tube (broken into thirds). Pure fluke, but I'll take it. :)\n            // Circle tube: length = diameter*PI;\n            // Straight tube:  length = diameter;\n            // Basically, the objects in the tube will travel just a few percentage\n            // points slower than those in the arcs in order to meet up perfectly, \n            // but you'll never notice.\n            minP = p2;\n            #ifdef RIGID_OBJECTS\n            qR = p2;\n            qR.x = mod(qR.x - dir*tm/3.14159, 1./3.) - 1./6.;\n            isArc = 0.; // Not an arc piece.\n            #else\n            a3 = minP.x;\n            a3 = (a3*(3.)*aSc - tm*dir - aSc*.5);\n            #endif\n            \n        }\n\n    }\n    else {\n    \n        vec2 p0 = p - vec2(-.5, -.5/s.y);\n        vec2 p1 = p - vec2(.5, -.5/s.y);\n        vec2 p2 = p - vec2(0, s.y/3.);\n        d.x = length(p0) - rSm;\n        d.y = length(p1) - rSm;\n        d.z = length(p2) - rSm;\n        \n        d = abs(d)/sc; // Turning the circles into arc segments and scaling.\n\n        // Move the Z-position out to the correct position for all three tubes.\n        qZ3 = q.z + .045 + hgt;\n\n        // A rounded or square Truchet tube.\n        d.x = length(vec2(d.x, qZ3.x)) - .05;\n        d.y = length(vec2(d.y, qZ3.y)) - .05;\n        d.z = length(vec2(d.z, qZ3.z)) - .05;\n    /*    \n        d.x = sBoxS(vec2(d.x, qZ3.x), vec2(.05, .05), .025);\n        d.y = sBoxS(vec2(d.y, qZ3.y), vec2(.05, .05), .025);\n        d.z = sBoxS(vec2(d.z, qZ3.z), vec2(.05, .05), .025);\n    */    \n        \n        // Since the moving objects reside within the tubes, the minimum 3D arc \n        // distance should provide the minimum coordinate upon which to calculate \n        // the angle of the object flowing through it... It will work with this \n        // example, but sometimes, you'll have to calculate all three.\n        minP = d.x<d.y && d.x<d.z? p0 : d.y<d.z? p1 : p2;\n        \n        ///// \n        #ifdef RIGID_OBJECTS\n        \n        minP *= rot2(dir*tm); // Animation occurs here.\n        float a = atan(minP.y, minP.x); // Polar angle.\n        a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.\n        // Polar coordinate.\n        qR = rot2(a*6.2831853)*minP; \n        qR.x -= rSm; \n        \n        #else\n      \n        // Calculating, scaling and moving the angles.\n        a3 = atan(minP.x, minP.y);\n        a3 = (a3*(6./6.2831)*aSc - tm*dir);\n        \n        #endif\n        ///// \n    \n    }\n    \n    // The Truchet tube distance is the minimum of all. I could save a couple\n    // of \"min\" calls and set this above, but this will do.\n    tr = min(min(d.x, d.y), d.z);\n \n\n    ///// \n    #ifdef RIGID_OBJECTS\n    \n    // 3D ball position. \"qR\" is based on \"p,\" which has been scalle\n    // by the factor \"sc,\" so needs to be scaled back. \"q.z\" has not been\n    // scaled... Yeah, it can be confusing. :)\n    vec3 bq = vec3(qR/2.,  qZ3.x); // All heights are equal, in this example.\n    //if(isArc==0.) bq = bq.yxz;\n    //float obj =  max(length(bq.zx) - .02, abs(bq.y) - .04); // Cylinder.\n    float obj = length(bq) - .02; // Ball.\n    // obj = min(tr + .035 + .01, ball); // Adding in the railing.\n    \n    #else\n   \n    a3 = abs(fract(a3) - .5) - .25;\n    a3 /= (6.*aSc/sc);\n    float obj = max(tr + .0325, a3);\n    \n    #endif\n    ///// \n    \n    \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along.\n    //\n    // Joins.\n    vec2 rp = p;\n    rp *= rot2(-3.14159/6.); // Animation occurs here.\n    float a = atan(rp.y, rp.x); // Polar angle.\n    a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.\n    // Polar coordinate.\n    rp = rot2(a*6.2831853)*rp; \n    rp.x -= .5; // Moving the element along the radial line to the edge.\n\n    // Construct the joiner rings.\n    rp = abs(rp);\n    mtl = rp.x - .02;//max(rp.x, rp.y) - .025;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Tracks.\n    mtl = min(mtl, tr + .045);\n    \n\n    \n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway. I've \n    // made the walls kind of thick. Obviously, the thickness can effect\n    // the way light bounces around, and ultimately the look.\n    tr = max(tr, -(tr + .02)); \n    \n    \n   \n    // Debug: Take out the glass tubing, brackets, tracks, etc, to see the inner\n    // objects unobstructed.\n    //tr += 1e5;\n    //mtl += 1e5;\n    \n   \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, obj);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), min(mtl, obj));\n\n\n\n}\n#endif\n \nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n    float tmin = 0.;\n    float tmax = FAR;\n    \n    // IQ's bounding plane addition, to help give some extra performance.\n    //\n    // If ray starts above bounding plane, skip all the empty space.\n    // If ray starts below bounding plane, never march beyond it.\n    const float boundZ = -.11;\n    float h = (boundZ - ro.z)/rd.z;\n    if(h>0.){\n    \n        if( ro.z<boundZ ) tmin = max(tmin, h);\n        else tmax = min(h, FAR);\n    }\n \n    float t = tmin;\n    for(int i = 0; i<72; i++){\n    \n        float d = map(ro + rd*t)*distanceFactor;\n        if( abs(d)<DELTA ) return t;\n        if( t>tmax) break; \n        t += d*.9; \n    }\n\n    return FAR;\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        //if (d<0. || t>end) break; \n        // Bounding plane optimization, specific to this example. Thanks to IQ. \n        if (d<0. || t>end || (ro.z + rd.z*t)<-0.11) break;\n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n/* \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// Random hash setup.\nvec2 seed = vec2(.13, .27);\n\nvec2 hash22() {\n    \n    seed += vec2(.723, 643);\n    seed = fract(seed);\n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    #ifdef REPROJECTION\n    // Initial hit point and distance.\n    vec3 resPos = vec3(0);\n    float resT = 1e8;\n    #endif\n    \n    \n    // Setting a maximum resolution, then upscaling. I picked up this tip when\n    // looking at one of spalmer's examples, here:\n    // https://www.shadertoy.com/view/sdKXD3\n    const float maxRes = 540.;\n    float iRes = min(iResolution.y, maxRes);\n    ivec2 iR = ivec2(fragCoord);\n    if(iR.y > 0 || iR.x>3){\n        fragColor = vec4(0, 0, 0, 1);\n        vec2 uv2 = abs(fragCoord - iResolution.xy*.5) - iRes/2.*vec2(iResolution.x/iResolution.y, 1.);\n        if(any(greaterThan(uv2, vec2(0)))) return;  // if(uv2.x>0. || uv2.y>0.) return;\n       \n    }\n    \n    \n    // Screen coordinates.\n    seed += fract(iTime)*113.87;\n\t//vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy*.5 + (hash22() - .5)/4.)/iRes;\n    \n    \n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/48.*s.y, iTime/64.*s.x, -1); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.04, -.03, .25); \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1, 0); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    mat3 mCam = mat3(rgt, up, fwd);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the Truchet tubing. Normally, you'd have\n    // diferent ones for different objects, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object: With more objects, you'd use a looping\n        // mechanism, but I'd imagine this hideous expression is a little faster.\n        float svObjID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z && vObjID.x<vObjID.w)? 0. : \n                        vObjID.y<vObjID.z && vObjID.y<vObjID.w? 1. : vObjID.z<vObjID.w? 2. :  3.;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n         \n         \n            #ifdef REPROJECTION\n            if(j==0){\n                // Only save the initial hit point and \n                // distance. Ignore other bounces.\n                resPos = sp;\n                resT = t;\n            }\n            #endif\n            \n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel1, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            float sh = 1.;\n            #if 0\n            // Shadows on each bounce.\n            sh = softShadow(sp, lp, sn, 12.);\n            gSh = min(sh + .5, 1.); // Adding brightness to the shadow.\n            #else\n            // Shadows on just two bounces.\n            if(j < 2){ \n                sh = softShadow(sp, lp, sn, 12.);\n                gSh = min(gSh, min(sh + .53, 1.)); \n            }\n            #endif\n            \n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            //float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            // Fresnel.\n            float Schlick = pow(1. - clamp(dot(rd, normalize(rd + ld)), 0., 1.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n             \n           if(svObjID == 0.){ // Back wall.\n               \n               // Texturing. \n               vec3 tx = tex3D(iChannel1, sp, sn);\n               tx = smoothstep(-.05, .5, tx);\n      \n               // Stripes.\n               vec2 q = rot2(-3.14159/3.)*sp.xy;\n               float str = abs(fract(q.x*12.) - .5)*2. - .4;\n               str = min(str, abs(str - .15) - .05);\n               oCol = mix(vec3(.5), vec3(.05), 1. - smoothstep(0., .05, str));\n               \n               oCol *= min(tx*2., 1.);\n\n               // The wall has no reflection of refraction, so setting the\n               // reflective or transmission power to zero will cause the\n               // loop to terminate early, which saves a lot of work.\n               objRef = 0.;\n\n               spe *= freS;\n\n               // Reflection only override. This ensures that no refraction\n               // will occur... It's hacky, but it works. :)\n               refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass Truchet tubes.\n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dark, in order to look transparent.\n                vec3 tx = tex3D(iChannel1, sp, sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*.125;//*vec3(1, 2, 3); // Color.\n                objRef = 1.; \n                \n                // Faking more of a glass look.\n                oCol *= tx;\n                objRef = 1.2; \n                \n            }\n            else { // Metallic stuff.            \n            \n                // Technically, I should be moving the texture\n                // hit point of the metallic moving objects in\n                // relation to their movement, but I wanted to\n                // save the calculations. Hopefully, the sliding\n                // texture movement isn't too perceptable.\n                \n                // Joins, tracks and animated metal objects.\n                vec3 tx = tex3D(iChannel1, sp, sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*vec3(.5);//*vec3(3, 1.6, .8);\n                \n                \n                objRef = .25; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*4.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n                \n                /*\n                // The moving metal objects.\n                if(svObjID==3.){\n                   oCol *= vec3(3, 1.5, .8); // Gold option.\n                   //objRef = 1.;\n                }\n                */\n                \n            }\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .2 + vec3(1, .4, .2)*spe*32.);\n            \n            // Shading.\n            colL *= gSh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n        \n    }\n    \n    \n    \n    // This is IQ's temporal reprojection code: It's well written and\n    // it makes sense. I wrote some 2D reprojection code and was not\n    // looking forward to writing the 3D version, and then this \n    // suddenly appeared on Shadertoy. If you're interested in rigid \n    // realtime path traced scenes with slowly moving cameras, this is \n    // much appreciated. :)\n    //\n    #ifdef REPROJECTION\n    //-----------------------------------------------\n\t// Reproject to previous frame and pull history.\n    //-----------------------------------------------\n    \n    float kFocLen = 1./FOV;\n    vec3 pos = resPos;\n    ivec2 q = ivec2(fragCoord);\n    col = clamp(col, 0., 1.);\n\n    // fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4(texelFetch(iChannel0, ivec2(0, 0), 0),\n                           texelFetch(iChannel0, ivec2(1, 0), 0),\n                           texelFetch(iChannel0, ivec2(2, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos*oldCam;\n    // Convert to NDC space (project).\n    vec2 npos = (kFocLen*2.)*cpos.xy/cpos.z*iRes/iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5*npos*vec2(iResolution.y/iResolution.x, 1);\n\t// Convert to raster space.\n    vec2 rpos = spos*iResolution.xy;\n\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = textureLod( iChannel0, spos, 0.);\n    // If we consider the data contains the history for this point.\n    if(iFrame>0 && resT<FAR && (rpos.y>1.5 ||rpos.x>3.5)){\n    \n        // Blend with history (it's an IIR low pas filter really).\n        col = mix( ocolt.xyz, col, 1./4.);\n    }\n    \n    // Color and depth.\n    fragColor = vec4(col, resT);\n    \n    // Output.\n\tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) fragColor = vec4(mCam[0], -dot(mCam[0], ro));\n        else if(q.x == 1) fragColor = vec4( mCam[1], -dot(mCam[1], ro));\n        else fragColor = vec4( mCam[2], -dot(mCam[2], ro));\n    } \n    #else\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    //fragColor = vec4(max(col, 0.), 1);\n    #endif\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}