{
    "Shader": {
        "info": {
            "date": "1606309169",
            "description": "Loosely recreating one of Regolo Bizzi's mathematical sketches via simple procedural methods. No 3D was harmed during the making of this. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "3dtBWX",
            "likes": 105,
            "name": "Cube Circle Sketch",
            "published": 3,
            "tags": [
                "cube",
                "circle",
                "sketch",
                "pencil",
                "isometric",
                "paper",
                "art",
                "quad"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1838
        },
        "renderpass": [
            {
                "code": "/*\n\t\n\tCube Circle Sketch\n\t------------------\n\n\tI see a lot of really classy geometric styled pencil drawings on \n    the internet by various mathematical artists -- The effort that \n    goes into some of them is really impressive. Reproducing them in \n    code form is kind of cheating, but it's a little hard to resist. :)\n\n\tThis particular arrangement is pretty common and something I've \n    seen many times in various forms, but most tend to be based off of \n    the works of mathematical artist Regolo Bizzi -- His Escheresque\n    geometric designs are everywhere, but if you've never chanced upon \n    one of them, I've provided a link below. A lot of love and effort \n    would have gone into the original sketch, but the effort that went\n    into the code version was far less impressive: Render 12 hexagons \n    on the border of a circle, orient them a bit (by PI/6), then shade \n    the faces. \n    \n    There's some extra code to give it that tech drawing feel, fake \n    lighting and a mediocre sketch algorithm included, but that's it.\n\n\tAnyway, I was more interested in producing a halfway passable look\n\tin order to render more interesting patterns. Suggestions for \n\tsimple improvements are always welcome. :)\n\n\n\n    // Links.\n\n    // You can find some of Regolo Bizzi's work at the following:\n    http://impossible-world.blogspot.com/2014/10/new-images-by-regolo-bizzi.html\n    https://www.behance.net/regolo\n\n*/\n\n\n// Cube subdivision lines. Interesting, but a bit much, I think. :)\n//#define SUBDIV_LINES \n\n// Greyscale sketch -- Sans color.\n//#define GREYSCALE\n\n// Blinking lights: It was an attempt to animate the sketch in a believable\n// way... This isn't it. :D\n//#define BLINKING_LIGHTS\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    \n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Rotation speed -- Rotation seemed like a good idea at the time, but\n    // I decided against it. :)\n    float rT = 0.;//sin(-iTime/6.*3.)/12.;\n\n    // Scaling and rotation.\n    vec2 p = rot2(rT)*uv*gSc;\n    \n    // Distance field holders for the cubes, lines and the previous\n    // cube (used for CSG related to overlap).\n    float d = 1e5, ln = 1e5, prevD = 1e5; \n    \n    // Edge width. \n    const float ew = .0025;\n    \n   \n    // The cubes are rendered along the sides of a dodecahedron. These are just some standard\n    // measurements to help place the cubes in the correct positions.\n    //\n    const float cR = .3; // Larger circle radius.\n    const float cAp = cR*cos(6.2831/24.); // Apothem.\n    const float sL = cR*acos(6.2831/24.)/2.; // Side length, which will relate to the hexagon scale.\n    \n    \n        // The offset vertex information.\n    // Hexagon vertices with scaling to enable rendering back in normal space. \n    vec2 hSc = sL*vec2(.5, .8660254);\n    vec2[6] svV = vec2[6](vID[0]*hSc, vID[1]*hSc, vID[2]*hSc, vID[3]*hSc, vID[4]*hSc, vID[5]*hSc);\n\n   \n    // Coordinate perturbation. There's small rigid one to enhance the hand-drawn look, and\n    // a larger animated one to wave the paper around a bit.\n    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));\n    vec2 offs2 = vec2(fbm(p*1. + iTime/4.), fbm(p*1. + .5 + iTime/4.));\n    const float oFct = .007;\n    const float oFct2 = .05;\n    p -= (offs - .5)*oFct;\n    p -= (offs2 - .5)*oFct2;\n    \n \n    \n    \n    float lnL = -cR - sL*.75; // Line length.\n    float a0 = 6.2831/24.; // Initial reference angle.\n    float dA = 6.2831/12.; // One twelth revolution.\n    float inR =  cR - sL/2.*.8660254; // Inner radius. \n    \n    \n    // Some distance field holders.\n    float gHex = 1e5, gD = 1e5, qLn = 1e5, dSh = 1e5;\n    // Z buffer, for shadows.\n    float zBuf = 0.;\n    \n    \n    \n    // Fake lighting.\n    vec3 lp = vec3(-.75, 3, -1.5);\n    vec3 ld = normalize(lp - vec3(uv, 0)); \n    ld.xy = rot2(rT)*ld.xy;\n    \n    \n    // Initialize the background.\n    vec3 col = vec3(.95, .975, 1);\n    \n    \n    vec2 q; \n    \n    // Apply some graph lines.\n    float dim = 9.; // For the lines to match up: dim = 9./(cR*3.);\n    q = p;//uv*gSc - (offs - .5)*oFct  - (offs2 - .5)*oFct2;//uv*gSc - (offs - .5)*oFct;//p;//\n    q = abs(mod(q, 1./dim) - .5/dim);\n    float ln3 = abs(max(q.x, q.y) - .5/dim);\n    col = mix(col, vec3(.35, .65, 1), (1. - smoothstep(0., sf*2., ln3))*.8);\n    dim *= 2.;\n    q = p;//uv*gSc - (offs - .5)*oFct  - (offs2 - .5)*oFct2;//uv*gSc - (offs - .5)*oFct;//p;//\n    q = abs(mod(q, 1./dim) - .5/dim);\n    ln3 = max(abs(max(q.x, q.y) - .5/dim), -ln3);\n    col = mix(col, vec3(.35, .65, 1), (1. - smoothstep(0., sf*2., ln3))*.65);\n    \n    // Applying light and a bit of noise to the background.\n    col *= clamp(dot(normalize(vec3(p, -1.5)), ld), 0., 1.)*.2 + .8;\n    col *= fbm(p*8.)*.1 + .9;\n    \n    \n    // Produce and render the 12 cubes. This is pretty standard stuff -- Position\n    // the cubes and render three rhomboids for the cube faces.\n    \n    // Cube face normals.\n    vec3[3] n = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, -1));\n       \n\n    // Iterate through all 12 cubes -- Some will note that you could apply polar\n    // coordinates and cut this right down to two iterations, which would definitely\n    // be faster. However, the example isn't too taxing on the system, and the\n    // brute force method simplifies the code a bit... Having said that, I might\n    // cave in an update this later. :)\n    //\n    for(int i = 0; i<12; i++){\n        \n        q = p;\n        \n        // Grey lines point to point lines.\n        vec2 a, b, nA;\n        a =  rot2(a0 + dA*float(i))*vec2(0, inR);\n        b =  rot2(a0 + dA*float(i + 3))*vec2(0, inR);\n        nA = normalize(b - a)*sL*1.6;\n        ln = min(ln, lBox(q, a - nA, b + nA, 0.));\n        \n        \n        // Hexagons.\n        vec2 hCtr = rot2(6.2831/12.*float(11 - i))*vec2(0, cR); // Hexagon center.\n        q -= hCtr; // Move to the border.\n        q = rot2(-6.2831/12.*float(11 - i))*q; // Rotate in situ.\n        //q = rot2(iTime/3.)*q; // Rotate individual hexagons.\n        float dH = sdHexagon(q, sL/2.); // Hexagon distance field.\n        d = dH;\n        \n        // Hexagon or cube shadows.\n        vec2 qSh = p + ld.xy*.03;\n        qSh -= hCtr;\n        qSh = rot2(-6.2831/12.*float(11 - i))*qSh;\n        dSh = sdHexagon(qSh, sL/2.);\n        \n        // All hexagons.\n        gHex = min(gHex, d);\n        \n        // Grey hexagon circle outlines.\n        ln = min(ln, abs(length(q) - sL/2./.8660254));\n        \n        // Cutting out the previous hexagon to avoid overlap. A Z-buffer would\n        // also work, and might be cleaner, but it's done now. :)\n        d = max(d, -(prevD - ew/3.));\n        \n        prevD = d; \n        \n        // Shadow and shadow buffer -- Needs fixing, but it'll do for now.\n        col = mix(col, mix(vec3(0), col, zBuf), (1. - smoothstep(0., sf*5., dSh - ew/2.))*.35);\n        zBuf = mix(zBuf, 1., (1. - smoothstep(0., sf*5., dSh - ew/2.))); \n  \n        // Combination of all objects... It was used to rotate things in combination with\n        // the sketch algorithm, but I decided against it.\n        gD = min(gD, min(min(ln, d), dSh));\n        \n        // Rendering the hexagon base -- Not entirely necessary, but it enhance the edges.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., d - ew/2.))*.35); // Fake AO.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, d - ew/2.))*.8);\n        //col = mix(col, vec3(1), (1. - smoothstep(0., sf, d + ew - ew/2.)));\n          \n          \n             \n        // Iterate through the three cube faces.\n        for(int j = 0; j<6; j+=2){\n        \n            // Constructing the edge midpoints and normals at those\n            // points for both the string and corresponding shadows.\n            vec2[4] v = vec2[4](svV[(j + 1)%6].yx, svV[(j + 2)%6].yx, svV[(j + 3)%6].yx, vec2(0));\n\n            // Quad center and local quad ID.\n            vec2 qCtr = (v[0] + v[1] + v[2] + v[3])/4.;\n            vec2 qID = hCtr + qCtr;\n            \n            // Face quad.\n            float quad = max(sdPoly4(q, v), d);\n            \n            // Accumulated quad field.\n            gD = min(gD, quad);\n            \n            // Spectrum or rainbow colors.\n            vec3 rnbCol = .6 + .4*cos(6.2831*float(i)/12. + vec3(0, 1, 2)*1.5 + 3.14159/6.);\n            \n            #ifdef BLINKING_LIGHTS\n            float rndI = hash21(hCtr); rndI = cos(rndI*6.2831 + iTime/1.25 + .5);\n            rndI = smoothstep(.9, .95, sin(rndI*6.2831 + iTime*3.)*.5 + .5);\n            \n            vec3 rCol = vec3(.55) + float(i%3)/12.;//vec3(hash21(hCtr + .6)*.35 + .5);\n            rCol = mix(rCol, dot(rCol, vec3(.299, .587, .114))*vec3(4, 1, .5), rndI);\n            rCol = mix(rCol, rCol.xzy, sin(hash21(hCtr + .44)*6.2831 + iTime)*.35 + .35);\n            \n            // Alternative.\n            //vec3 rCol = rnbCol;\n            //rCol = mix(rCol, rnbCol*1.5, rndI);\n            #else\n            vec3 rCol = rnbCol;\n            #endif\n            \n  \n            // Face normal.\n            vec3 sn = n[j/2];\n            // Rotate the face normals about the XY axis -- Since this isn't 3D, we\n            // need to fake it.\n            sn.xy = rot2(6.2831/12.*float(11 - i))*sn.xy;\n             \n            // Using the quad distance field for a bit of shading. In this case, it\n            // gives the cubes a subtle faux ambient occulsion feel.\n            float sh = clamp(.35 - quad/.03, 0., 1.)*.3 + .7;\n            // Standard diffuse lighting.\n            float dif = max(dot(ld, sn), 0.);\n            // Lit face color.\n            rCol = rCol*(dif + .5)*sh;\n            \n            // Render the face quad.\n            col = mix(col, rCol*.5, (1. - smoothstep(0., sf, quad)));\n            col = mix(col, vec3(rCol), (1. - smoothstep(0., sf, quad + ew)));\n            \n            #ifdef SUBDIV_LINES\n            // Quad lines -- Not used.\n            \n            qLn = lBox(q, mix(v[0], v[1], .5), mix(v[2], v[3], .5), .0);\n            qLn = min(qLn, lBox(q, mix(v[1], v[2], .5), mix(v[3], v[0], .5), .0));\n            /*         \n            qLn = lBox(q, mix(v[0], v[1], .333), mix(v[2], v[3], .666), .0);\n            qLn = min(qLn, lBox(q, mix(v[1], v[2], .333), mix(v[3], v[0], .666), .0));\n            qLn = min(qLn, lBox(q, mix(v[0], v[1], .666), mix(v[2], v[3], .333), .0));\n            qLn = min(qLn, lBox(q, mix(v[1], v[2], .666), mix(v[3], v[0], .333), .0));\n            */\n            qLn = max(qLn, (prevD - ew/3.));\n            \n            vec3 svCol = col;\n            col = mix(col, col*1.35, (1. - smoothstep(0., sf*3., qLn - .003)));\n            col = mix(col, svCol*.65, (1. - smoothstep(0., sf*2., qLn - .001)));\n            #endif\n        }\n        \n         \n    }\n    \n\n    // Faking the ruled guide lines. We'll make them more pronounced outside the colored\n    // cubes and faint over the top.\n    float lAlpha = mix(.25, .125, 1. - smoothstep(0., sf*2., gHex));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., ln - .001*fbm(p*32. + .5)))*lAlpha);\n    // IQ's suggestion to let a trace amount of the graph paper pattern show through.\n    // The graph paper was a later addition, so I'd forgotten to include it.\n    col = mix(col, vec3(.35, .65, 1)/4., (1. - smoothstep(0., sf*2., max(gHex, ln3)))*.25);\n    \n    \n \n    // Subtle pencil overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    q = p*8.;//mix(p*10., uv*gSc*10. - (offs - .5)*oFct  - (offs2 - .5)*oFct2, smoothstep(0., sf, gD));\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    #ifdef GREYSCALE\n    // Just the pencil sketch. The last factor ranges from zero to one and \n    // determines the sketchiness of the rendering... Pun intended. :D\n    col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .6);\n    #else\n    col = mix(col, 1. - exp(-(col*2.)*(colP + .25)), .85); \n    #endif\n    //col = mix(col, colP, .5);\n    //col = mix(min(col, colP), max(col, colP), .5); \n   \n  \n     // Cheap paper grain... Also barely worth the effort. :)\n    vec2 pp = q;//floor(q*1024.);\n    vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));\n    vec3 pg = .8 + (rn3.xyz*.35 + rn3.xxx*.65)*.4;\n    col *= min(pg, 1.); \n    \n    \n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.)/vec2(.5, 1), vec2(-.5, 2./6.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1), \n                      vec2(.5, 2./6.)/vec2(.5, 1), vec2(.5, -2./6.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));\n//vec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1), \n                      //vec2(.5, 0)/vec2(.5, 1), \n                      //vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n// IQ's box formula -- Modified slightly.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n  \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This renders a horizontal or vertical box-line from point \"a\" to point \"b,\" with a line \n// width of \"w.\" It's different to the the usual line formula because it doesn't render the \n// rounded caps on the end -- Sometimes, you don't want those. It utilizes IQ's box formula \n// and was put together in a hurry, so I'd imagine there are more efficient ways to do the \n// same, but it gets the job done. I put together a more generalized angular line formula as \n// well.\nfloat lBoxHV(vec2 p, vec2 a, vec2 b, float w){\n    \n   vec2 l = abs(b - a); // Box-line length.\n   p -= vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)); // Positioning the box center.\n   \n   // Applying the above to IQ's box distance formula.\n   vec2 d = abs(p) - (l + w)/2.; \n   return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.) ;\n}\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n// Determines which side of a line a pixel is on. Zero is the threshold.\nfloat line(vec2 p, vec2 a, vec2 b){\n     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));\n}\n\n/*\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n*/\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Compare it to the underlying grey scale value.\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    const float contrast = 1.;\n    ns = (.5 + (gr - (max(max(ns, ns2), ns3)))*contrast); // Same, but with contrast.\n    //ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), ns3))); // Different contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0., 1.));\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}