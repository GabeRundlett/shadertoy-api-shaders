{
    "Shader": {
        "info": {
            "date": "1710439948",
            "description": "Rendering grids on plane and sphere after complex transformations.",
            "flags": 0,
            "hasliked": 0,
            "id": "l3fXRB",
            "likes": 6,
            "name": "3D Complex Maps",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "Friend",
            "viewed": 197
        },
        "renderpass": [
            {
                "code": "#define res_           iResolution\n#define time_          iTime\n#define pi_            3.14159265\n#define tau_           2.*pi_\n\n#define dom(f,s)       (2. * f.xy - res_.xy) / res_.y * s\n#define ry(a)          mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define rz(a)          mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.)\n    \n#define march_steps_   228\n#define hit_perc_      .00001\n#define max_range_     5000.\n\n\nvec2  de(vec3 p);\nvec3  normal(vec3 p);\nvec3  triplanar(sampler2D tex, vec3 p, vec3 n);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\nfloat calcSoftshadow( in vec3 ro, in vec3 rd);\nvec3  doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal);\nfloat fog_exp2(float dist, float dens);\n\nfloat customAtan2(float y, float x) {\n    float t0 = atan(abs(y), abs(x));      // angle in [0, pi/2]\n    float t1 = (x < 0.0) ? pi_ - t0 : t0; // correct for [pi/2, pi] and [-pi/2, 0]\n    float t2 = (y < 0.0) ? -t1 : t1;      // correct for [-pi, -pi/2] and [-pi/2, 0]\n\n    return t2;\n}\n\nvec3 shsv(float h, float s, float v) {\n    vec3 p = clamp(abs(fract(vec3(h) + vec3(3.0, 2.0, 1.0) / 3.0) * 6.0 - vec3(3.0)) - vec3(1.0), 0.0, 1.0);\n    p = p * p * (3.0 - 2.0 * p); // Apply smoothstep function\n    return v * mix(vec3(1.0), p, s);\n}\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p  = dom(f, 1.); vec2 np = f / res_.xy;\n    \n    // Camera\n    // ----------------\n    float r = 20.;\n    float fq = .5;\n    float phi = fq * time_; \n    float theta = mix(\n        0.1 * pi_,\n        0.9 * pi_,\n        sin(0.5 * fq * time_)\n    ); \n\n    vec3 ro = vec3(\n        r * sin(theta) * cos(phi),\n        r * cos(theta),\n        r * sin(theta) * sin(phi)\n    );\n    vec3 target = vec3(0., 0., 0.);\n    mat3 lam = look_at(ro, target, 0.);    \n\tvec3 rd = normalize(lam * vec3(p.xy, 1.));\n    \n    // Raymarch\n    // ----------------\n    vec3 pos, nor = vec3(0.);\n    float d, step_ , id= 0.;  \n    int i = 0;\n    for(i = 0; i < march_steps_; i++) {\n    \tpos = ro + step_ * rd;\n        \n        vec2 info = de(pos);\n        d   = info.x; id  = info.y;\n        step_ += .5*d;\n        \n    \tif(d < hit_perc_ || d > max_range_) break;    \n    }\n    pos = ro + step_ * rd;\n \tnor = normal(pos);\n    \n    // Shading\n    // ----------------\n    vec3 c = vec3(.0);\n    if(d < hit_perc_) {\n        // Plane material\n        if(id == 0.) {            \n            vec2 z = pos.xz;\n            z *= .2;\n            z = zexp(1.2, z);\n            z = zsin(zinv(z));\n            float dg  = grid(z);\n            dg = smoothstep(.5, 1.5, dg);\n            \n            float ma  = length(z);\n            float an  = customAtan2(z.y, z.x);       // Use the smooth atan2 function\n            float hue = (an + pi_) / (2.0 * pi_);    // Normalize angle to [0, 1] for hue\n            float val = 1. - exp(-ma);               // Exponential decay for brightness\n            vec3  gc  = shsv(hue, val, val*val);       // s is always 1 in your hsv2rgb function\n            vec3  plane_mal = gc * dg;\n            \n            c = doLighting(pos, nor, rd, d, plane_mal);\n        }\n        else if (id == 1.0) {\n            float u = atan(pos.z, pos.x) / (2.0 * pi_) + 0.5;\n            float v = 0.5 - acos(pos.y / length(pos)) / pi_;\n            vec2 uv = 15.*vec2(u, v);\n            \n            vec2 z = uv;\n            //z = 2.*zexp(1.25, z);\n            //z = 20.*sin(t*.1) * zsqrt(z);\n            //z = 15.*zlog(z) + 15.*zlog(zconj(z));\n            //z = .1*zsin(z);\n            //z = 2.*ztan(2.*z);\n            z = 2.*zinv(.2*z);\n            \n            z *= .5;\n            z = 3.*zdiv(zsin(zinv(z)), zcos(z));\n            float dg  = grid(z);\n            dg = smoothstep(.5, 1.5, dg);\n            \n            float ma  = length(z);\n            float an  = customAtan2(z.y, z.x);       // Use the smooth atan2 function\n            float hue = (an + pi_) / (2.0 * pi_);    // Normalize angle to [0, 1] for hue\n            float val = 1. - exp(-ma);               // Exponential decay for brightness\n            vec3  gc  = shsv(hue, val, val*val);     // s is always 1 in your hsv2rgb function\n            vec3  plane_mal = gc * dg;\n            \n            c = doLighting(pos, nor, rd, d, plane_mal);\n        }\n    }\n\t\n\n\t// Postprocessing\n    //----------------\n    // fog\n    c = mix(c, vec3(0.0001), fog_exp2(float(i), .03));\n    // gamma\n\tc = pow( clamp(c, 0.0, 1.0), vec3(0.3545) );\n    // final\n    o = vec4(c, 1.);\n}\n\nvec2 de(vec3 p) {\n    vec2 z = p.xz;\n    z = zpow(z, 2.);\n    \n    float d_pl = p.y+20.;\n    \n    float d_sp = length(p) - 10.;\n    float d_cy = length(p.xz) - 1.; // Distance to a cylinder along the Y-axis, with a radius of 2 units\n    float d_cz = length(p.xy) - 3.;\n    float d_sp_h = max(-d_cy, d_sp); // Subtract the cylinder from the sphere\n    d_sp_h = max(-d_cz, d_sp_h);\n    \n    float id = d_pl > d_sp ? 1. : 0.;\n    \n    return vec2(min(d_sp_h, d_pl), id);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(hit_perc_, .0);\n    return normalize(vec3(\n        de(p+e.xyy).x-de(p-e.xyy).x,\n        de(p+e.yxy).x-de(p-e.yxy).x,\n        de(p+e.yyx).x-de(p-e.yyx).x\n    ));\n}\n\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.0005;                 \n\tfloat h = 1.0;\n    for(int i=0; i<40; i++) {         \n        h = de(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   \n\t\tt += clamp( h, 0.02, 2.0 );   \n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0, .7, 0.9));\n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0; \n    if(dif>0.01) \n        sha=calcSoftshadow(pos+0.01*nor, lig);\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    return col;\n}\n\nfloat fog_exp2(float dist, float dens) {\n  const float log2v = -0.442695;\n  float d = dens * dist;\n  \n  return 1. - clamp(exp2(d*d*log2v), 0., 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define res_        iResolution\n#define time_       iTime\n#define pi_         3.14159265\n#define tau_        2.*pi_\n#define t           iTime \n\n#define crot(a)     mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ccrot(a)    mat2(cos(a),sin(a),-sin(a),cos(a))\n#define dom(f,s)    (2. * f.xy - res_.xy) / res_.y * s\n\n\nfloat grid(vec2 p) {\n\treturn min(\n        (abs(fract(p-.49)-.5) / fwidth(p)).x,\n        (abs(fract(p-.49)-.5) / fwidth(p)).y \n    );\n}\n\nvec2 zexp(float c, vec2 z) {\n    float ln_c = log(c); // Natural log of the base c\n    float a = exp(z.x * ln_c);\n    return vec2(a * cos(z.y * ln_c), a * sin(z.y * ln_c));\n}\n\nvec2 zadd(vec2 z, float c) {\n    return vec2(z.x + c, z.y);\n}\n\nvec2 zmul(vec2 z0, vec2 z1)  {\n    return vec2(\n        z0.x * z1.x - z0.y * z1.y,\n        z0.x * z1.y + z0.y * z1.x\n    );\n}\n\nvec2 zdiv(vec2 z0, vec2 z1)  {\n    float d = dot(z1, z1);\n    return vec2(dot(z0, z1), z0.y * z1.x - z0.x * z1.y) / d; \n}\n\nvec2 zpow(vec2 z, float c) {\n    float r = length(z);\n    float a = atan(z.y, z.x);\n    return pow(r, c) * vec2(cos(a * c), sin(a * c)); \n}\n\nvec2 zsqrt(vec2 z) {\n    float m = length(z);\n    return sqrt(.5 * vec2(m + z.x, m - z.x)) * vec2(1., sign(z.y));\n}\n\nvec2 zconj(vec2 z) { \n    return vec2(z.x, -z.y); \n}\n\nvec2 zsin(vec2 z) {\n    vec2 d = vec2(exp(z.y), exp(-z.y));\n\treturn vec2(sin(z.x) * (d.x+d.y)*.5, cos(z.x) * (d.x-d.y)*.5);\n}\n\nvec2 zcos(vec2 z) {\n    vec2 d = vec2(exp(z.y), exp(-z.y));\n \treturn vec2(cos(z.x) * (d.x+d.y)*.5, -sin(z.x) * (d.x-d.y)*.5);\n}\n\nvec2 ztan(vec2 z) {\n\tvec2 d = vec2(exp(z.y), exp(-z.y));\n \tfloat e = cos(z.x), s = (d.x-d.y)*.5;\n \treturn vec2(sin(z.x) * e, s * (d.x+d.y)*.5) / (e*e+s*s);\n}\n\nvec2 zlog(vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 zinv(vec2 z) {\n    return vec2(z.x, -z.y) / dot(z, z);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}