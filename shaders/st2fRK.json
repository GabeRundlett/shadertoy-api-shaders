{
    "Shader": {
        "info": {
            "date": "1652537756",
            "description": "Complex functions can be visualized using domain coloring.",
            "flags": 0,
            "hasliked": 0,
            "id": "st2fRK",
            "likes": 1,
            "name": "Custom Domain Coloring",
            "published": 3,
            "tags": [
                "function",
                "complex",
                "domaincoloring"
            ],
            "usePreview": 0,
            "username": "Fraktoler",
            "viewed": 259
        },
        "renderpass": [
            {
                "code": "#define ITERS 1\nfloat zoom = 5.;\nvec2 center = vec2(0.);\n\nvec3 HSLtoRGB(in vec3 c) { //From @tpfto's comment\n    vec3 rgb = clamp(abs(mod(c.x / 60. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n    float v = c.z + c.y * min(c.z, 1. - c.z);\n    float s = v == 0. ? 0. : 2. * (1. - c.z / v);;\n\treturn v * mix(vec3(1.), rgb, s);\n}\n\nvec2 pixelToComplex(in float zoom, in vec2 center, in vec2 pixel) {\n    return (2. * pixel - iResolution.xy) / iResolution.x * zoom + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 c = pixelToComplex(zoom, center, fragCoord);\n    vec2 z = c;\n    int iter = 0;\n    while (iter < ITERS) {\n\n        z = power(z, iTime); //Function\n\n        iter++;\n    }\n    float h, l;\n    if (isnan(arg(z))) {\n        h = 0.;\n    } else {\n        h = arg(z);\n        if (h < 0.) {\n            h += pi + pi;\n        }\n        h *= 180. / pi;\n    }\n    l = length(z);\n    l = isnan(l) ? 1. : 1. - 1. / (sqrt(l) + 1.);\n    //l = 0.5;\n    vec3 col = HSLtoRGB(vec3(h, 1., l));\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n normalizesqr(z) = normalize(z^2)\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n powerfv(x, z) = x^z (Complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n gamma(z) (Gamma function)\n productlog(k, z) (Lambert W function (kth branch))\n digamma(z) (Digamma function)\n trigamma(z) (Trigamma function)\n*/\n#define one vec2(1., 0.)\n#define two vec2(2., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n//const float[] B = float[](1., .5, 1./6., 0., -1./30., 0., 1./42., 0., -1./30., 0., 5./66., 0., -691./2730., 0., 7./6.);\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 normalizesqr(in vec2 z) {\n    return one - conj(z.yx) * (z.y + z.y) / dot(z, z);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 powerfv(in float x, in vec2 z) {\n    float lnr = log(x);\n    return exp(z.x * lnr) * cis(z.y * lnr);\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 2.0), z + i) - one));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 2.0), z - i) + one));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(two, powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(two, powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 gamma(in vec2 z) {\n    //https://www.shadertoy.com/view/WtlGDN\n    const float[6] p = float[] (2.506628275635, 225.525584619175, -268.295973841305, 80.9030806934622, -5.007578639705, 0.0114684895435);\n    vec2 zz = z.x > 1. ? z : one - z;\n    vec2 m = vec2(p[0], 0.);\n    for (int k = 1; k < p.length(); k++) {\n        m = m + p[k] * recip(zz + vec2(k, 0.));\n    }\n    vec2 zh = zz + vec2(5.65, 0.0);\n    vec2 w = powexp(ln(m) + mul(zz + vec2(.5, 0.), ln(zh)) - ln(zz) - zh);\n    return z.x > 1. ? w : pi * recip(mul(w, sine(pi * z)));\n}\n\nvec2 productlog(in int k, in vec2 z) {\n    vec2 m, w, mw, w2;\n    if (k == 0) {\n        //https://www.shadertoy.com/view/3lsGD4\n        m = sqrtp(2. * e * z + vec2(2., 0.));\n        w = 2. * ln(one + .8842 * m);\n        w = div(w - ln(one + .9294 * ln(one + .5106 * m)) - vec2(1.213, 0.), one + recip(w + vec2(4.69483568, 0.)));\n    } else {\n        w = ln(z) + float(2 * k) * pi * i;\n        w -= ln(w);\n    }\n    for (int k = 0; k < 8; k++) {\n        m = powexp(w);\n        mw = mul(m, w);\n        w2 = w + two;\n        w = div(mul(mw, sqr(w)) + mul(sqr(w2) - two, z), mul(mw + z, w2) + (m + m));\n    }\n    return w;\n}\n\nvec2 digamma(in vec2 z) {\n    vec2 zz = z.x < .5 ? one - z : z, a = vec2(0.), w = zz;\n    while (w.x < 8.) {\n        a += recip(w);\n        w += one;\n    }\n    vec2 zinv = recip(w);\n    w = ln(w) - 0.5 * zinv;\n    zinv = sqr(zinv);\n    w -= zinv / 12. - sqr(zinv) / 120. + cube(zinv) / 252. + a;\n    return (z.x < .5 ? pi * cot(pi * zz) + w : w);\n}\n\nvec2 trigamma(in vec2 z) {\n    vec2 zz = z.x < .5 ? one - z : z, a = vec2(0.), w = zz;\n    while (w.x < 8.) {\n        a += recip(sqr(w));\n        w += one;\n    }\n    w = recip(w) + 0.5 * recip(sqr(w)) + recip(cube(w)) / 6. - recip(power5(w)) / 30. + recip(power7(w)) / 42. + a;\n    return z.x < .5 ? sqr(pi * recip(sine(pi * zz))) - w : w;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}