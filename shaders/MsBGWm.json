{
    "Shader": {
        "info": {
            "date": "1389223076",
            "description": "Recreation of Matthew DiVito's animated gif design_takes_time: http://cargocollective.com/matthewdivito",
            "flags": 0,
            "hasliked": 0,
            "id": "MsBGWm",
            "likes": 74,
            "name": "Spinner 3",
            "published": 3,
            "tags": [
                "conetracing"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 4450
        },
        "renderpass": [
            {
                "code": "// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n//#define BLOB // alternate shape\n\n\nconst float tau = 6.28318530717958647692;\n// anti aliased / blurred distance field tracer\n\n// trace a cone vs the distance field\n// approximate pixel coverage with a direction and proportion\n// this will cope correctly with grazing the edge of a surface, which my focal blur trick didn't\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec3 viewSpaceRay;\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\tviewSpaceRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n#ifdef BLOB\n\tfloat a = atan(pos.x,pos.z)+iTime*.5;\n\tpos.xz = length(pos.xz)*vec2(sin(a),cos(a));\n\treturn .5*(length(pos)-2.0+(Noise(pos).x+Noise(pos*2.0+iTime*vec3(0,1.0,0)).x/2.0)*1.0);\n#else\n\t// rotational symmettry\n\tconst float slice = tau/12.0;\n\tfloat a = abs(fract(atan(pos.x,pos.z)/slice+iTime*2.5)-.5)*slice;\n\tpos.xz = length(pos.xz)*vec2(sin(a),cos(a));\n\t\n\t// symettry in y\n\tpos.y = abs(pos.y);\n\t\n\treturn dot(pos,normalize(vec3(1,1,1))) - 1.0;\n#endif\n}\n\n\nvec3 Normal( vec3 pos, float rad )\n{\n\tvec2 delta = vec2(0,rad);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\treturn normalize(grad);\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\t// combine some vague coloured shapes\n\tvec3 col = vec3(0);\n\t\n\tcol += vec3(.8,.1,.13)*smoothstep(.2,1.0,dot(ray,normalize(vec3(1,1,3))));\n\tcol += vec3(.1,.1,.05)*Noise(ray*2.0+vec3(0,1,5)*iTime).x;\n\tcol += 3.0*vec3(1,1.7,3)*smoothstep(.8,1.0,dot(ray,normalize(vec3(3,3,-2))));\n\tcol += 2.0*vec3(2,1,3)*smoothstep(.9,1.0,dot(ray,normalize(vec3(3,8,-2))));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat zoom = 1.5;\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, .04*vec3(Noise(vec3(3.0*iTime,0,0)).xy,0), vec2(.22,0)+vec2(.7,tau)*iMouse.yx/iResolution.yx, 6.0, zoom, fragCoord );\n\n\t// radius of cone to trace, at 1m distance;\n\tfloat coneRad = .7071/(iResolution.y*zoom);\n\t\n\tfloat coverage = -1.0;\n\tvec3 coverDir = vec3(0); // this could be a single angle, or a 2D vector, since it's perp to the ray\n\t\n\tfloat aperture = .05;\n\tfloat focus = 5.0;\n\t\n\tvec3 col = vec3(0);\n\tfloat t = .0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tfloat rad = t*coneRad + aperture*abs(t-focus);\n\n\t\tvec3 p = pos + t*ray;\n\t\tfloat h = DistanceField( p );\n\t\t\n\t\tif ( h < rad )\n\t\t{\n\t\t\t// shading\n\t\t\tvec3 normal = Normal(p, rad);\n\t\t\t\n\t\t\tvec3 albedo = vec3(.2);\n\t\t\t\n\t\t\t// lighting\n\t\t\tvec3 ambient = vec3(.1)*smoothstep(.7,2.0,length(p.xz)+abs(p.y));\n\t\t\tvec3 directional = 3.0*vec3(1,.1,.13)*max(dot(normal,normalize(vec3(-2,-2,-1))),.0);\n\t\t\tdirectional *= smoothstep(.5,1.5,dot(p,normalize(vec3(1,1,-1))));\n\n\t\t\tfloat fresnel = pow( 1.0-abs(dot( normal, ray )), 5.0 );\n\t\t\tfresnel = mix( .03, 1.0, fresnel );\n\t\t\t\n\t\t\tvec3 reflection = Sky( reflect(ray,normal) );\n\t\t\t\n\t\t\tvec3 sampleCol = mix( albedo*(ambient+directional), reflection, vec3(fresnel) );\n\t\t\t\n\t\t\t// compute new coverage\n\t\t\tfloat newCoverage = -h/rad;\n\t\t\tvec3 newCoverDir = normalize(normal-dot(normal,ray)*ray);\n\n\t\t\t// allow for coverage at different angles\n\t\t\t// very dubious mathematics!\n\t\t\t// basically, coverage adds to old coverage if the angles mean they don't overlap\n\t\t\tnewCoverage += (1.0+coverage)*(.5-.5*dot(newCoverDir,coverDir));\n\t\t\tnewCoverage = min(newCoverage,1.0);\n\n\t\t\t// S-curve, to imitate coverage of circle\n\t\t\tnewCoverage = sin(newCoverage*tau/4.0);//smoothstep(-1.0,1.0,newCoverage)*2.0-1.0;\n\n\t\t\tif ( newCoverage > coverage )\n\t\t\t{\n\t\t\t\t\n\t\t\t\t// combine colour\n\t\t\t\tcol += sampleCol*(newCoverage-coverage)*.5;\n\t\t\t\t\n\t\t\t\tcoverDir = normalize(mix(newCoverDir,coverDir,(coverage+1.0)/(newCoverage+1.0)));\n\t\t\t\tcoverage = newCoverage;\n\t\t\t}\n\t\t}\n\t\t\n\t\tt += max( h, rad*.5 ); // use smaller values if there are echoey artefacts\n\t\t\n\t\tif ( h < -rad || coverage > 1.0 )\n\t\t\tbreak;\n\t}\n\t\n\tcol += (1.0-coverage)*.5*Sky(ray);\n\n\t// grain\n\tvec3 grainPos = vec3(fragCoord.xy*.8,iTime*30.0);\n\tgrainPos.xy = grainPos.xy*cos(.75)+grainPos.yx*vec2(-1,1)*sin(.75);\n\tgrainPos.yz = grainPos.yz*cos(.5)+grainPos.zy*vec2(-1,1)*sin(.5);\n\tvec2 filmNoise = Noise(grainPos*.5);\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*pow(filmNoise.y,1.0) );\n\n\t// dust\n\tvec2 uv = fragCoord.xy/iResolution.y;\n\tfloat T = floor( iTime * 60.0 );\n\tvec2 scratchSpace = mix( Noise(vec3(uv*8.0,T)).xy, uv.yx+T, .8 )*1.0;\n\tfloat scratches = texture( iChannel1, scratchSpace ).r;\n\t\n\tcol *= vec3(1.0)-.5*vec3(.3,.5,.7)*pow(1.0-smoothstep( .0, .1, scratches ),2.0);\n\t\n\tfragColor.rgb = ToGamma(col);\n\tfragColor.w = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}