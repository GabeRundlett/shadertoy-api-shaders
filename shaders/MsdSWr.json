{
    "Shader": {
        "info": {
            "date": "1458851562",
            "description": "CONTROL: Teclas de direccion (como simulador de vuelo)\nBARRA IZQUIERDA: Proximidad limite anillo asteroides (prohibido salir del anillo)\nBARRA DERECHA: Integridad estructural (la nave no debe ser destruida)\nCONTADOR: Distancia recorrida hacia planeta\n\n\n",
            "flags": 48,
            "hasliked": 0,
            "id": "MsdSWr",
            "likes": 4,
            "name": "Asteroid game",
            "published": 3,
            "tags": [
                "game",
                "asteroid"
            ],
            "usePreview": 0,
            "username": "pacolmos",
            "viewed": 892
        },
        "renderpass": [
            {
                "code": "// ****************************************************************************\n// Juego basado en Planet Shadertoy de Reinder Nijhoff\n// https://www.shadertoy.com/view/4tjGRh\n//\n// Para pintar el texto se han utilizado funciones de Wordtoy de Pol Jeremias\n// https://www.shadertoy.com/view/Xst3zX\n//\n// Para el control con el teclado hemos aprendido mucho de Drifter de eiffie\n// https://www.shadertoy.com/view/lsK3Dt\n// ****************************************************************************\n\n// -----------------------------\n// FunciÃ³n de lectura del Buffer\n// -----------------------------\n#define load(a) texture(iChannel0,(vec2(a - 0.5,0.5))/iResolution.xy)\n\n\n// -------------------------------------\n// Variables pasadas a travÃ©s del Buffer\n// -------------------------------------\nconst float COLISION = 1.;\nconst float POSICION = 2.;\nconst float DIRECCION = 3.;\nconst float UP = 4.;\nconst float TA = 5.;\nconst float GAME_OVER = 6.;\nconst float DANIO = 7.;\n\n// ----------------------\n// Constantes matemÃ¡ticas\n// ----------------------\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI / 180.0);\nconst float MAX = 10000.0;\n\n// --------------------------------------------\n// Propiedades del planeta (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------------\nconst float EARTH_RADIUS = 1000.;\nconst float EARTH_ATMOSPHERE = 5.;\nconst float EARTH_CLOUDS = 1.;\n\n// ---------------------------------------------------------------------\n// Propiedades del anillo de asteroides del planeta (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// ---------------------------------------------------------------------\nconst float RING_INNER_RADIUS = 1500.;\nconst float RING_OUTER_RADIUS = 2300.;\nconst float RING_HEIGHT = 2.;\n\n// --------------------------------------------------------------\n// Propiedades de calidad de imagen muy baja (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------------------------------\nconst int   ASTEROID_NUM_STEPS = 7;\nconst int\tASTEROID_NUM_BOOL_SUB = 4;\nconst int   RING_VOXEL_STEPS = 16;\nconst float ASTEROID_MAX_DISTANCE = .67; \nconst int   FBM_STEPS = 3;\nconst int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\nconst int   ATMOSPHERE_NUM_IN_SCATTER = 4;\n\n// ----------------------------------------\n// Propiedades del Sol (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// ----------------------------------------\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\n\n// -------------------------------------\n// Caracteres de texto (by Pol Jeremias)\n// https://www.shadertoy.com/view/Xst3zX\n// -------------------------------------\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_e = 2018607.0;\nfloat ch_g = 706922.0;\nfloat ch_m = 1571693.0;\nfloat ch_o = 711530.0;\nfloat ch_r = 1760621.0;\nfloat ch_v = 1497938.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\n\n// --------------------------------------------------------\n// Propiedades de los caracteres de texto (by Pol Jeremias)\n// https://www.shadertoy.com/view/Xst3zX\n// --------------------------------------------------------\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n// --------------------------------------------------------------\n// Tiempo para el movimiento y rotaciÃ³n de los asteroides(by TDM)\n// https://www.shadertoy.com/view/ldSSzV\n// --------------------------------------------------------------\nfloat time;\n\n\n// --------------------------------------\n// Noise functions (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------\n\nfloat hash( const in float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash( const in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31( const in float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\nvec3 hash33( const in vec3 p) {\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\n}\n\nfloat noise( const in  float p ) {    \n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\n}\n\nfloat noise( const in  vec2 p ) {    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise( const in  vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat tri( const in vec2 p ) {\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n   \n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( in vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); \n    \n    return f/0.9375;\n}\n\nfloat fbm( const in vec3 p, const in float a, const in float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < FBM_STEPS; i++) {\n        float n = pow(noise(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n// ---------------------------------------------\n// Funciones de iluminaciÃ³n (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// ---------------------------------------------\n\nfloat diffuse( const in vec3 n, const in vec3 l) { \n    return clamp(dot(n,l),0.,1.);\n}\n\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\n}\n\n// -----------------------------------------\n// Funciones matemÃ¡ticas(by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// -----------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n// ---------------------------------\n// Funciones de IntersecciÃ³n (by iq)\n// ---------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return -MAX;\n\treturn -b + sqrt( d );\n}\n\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\n\td = sqrt( d );\n\treturn vec2( -b - d, -b + d );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n// --------------------------------------\n// Asteroide (by TDM)\n// https://www.shadertoy.com/view/ldSSzV\n// --------------------------------------\n\nconst float ASTEROID_TRESHOLD \t= 0.001;\nconst float ASTEROID_EPSILON \t= 1e-6;\nconst float ASTEROID_DISPLACEMENT = 0.1;\nconst float ASTEROID_RADIUS = 0.13;\n\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\nconst vec3  RING_COLOR_2 = vec3(0.51,0.41,0.32) * 0.2;\n\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \n    float d = sphere(p,ASTEROID_RADIUS);    \n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\n        float ii = float(i)+id.x;\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \n    }\n    return d;\n}\n\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( xyangle, ro.xy );\n    \n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( yzangle, ro.yz );\n}\n\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( -yzangle, ro.yz );\n\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( -xyangle, ro.xy );  \n}\n\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\n    asteroidTransForm( p, id );\n    \n    vec3 n;\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\n    n = normalize(n-asteroidMapDetailed(p, id));\n    \n    asteroidUnTransForm( n, id );\n    return n;\n}\n\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\n    asteroidTransForm( ori, id );\n    asteroidTransForm( dir, id );\n    \n    vec2 td = vec2(0.0);\n    for(int i = 0; i < ASTEROID_NUM_STEPS; i++) {\n        vec3 p = ori + dir * td.x;\n        td.y = asteroidMap(p, id);\n        if(td.y < ASTEROID_TRESHOLD) break;\n        td.x += (td.y-ASTEROID_TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \n}\n\n// --------------------------------------------------\n// Anillo de asteroides de cerca (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------------------\n\nconst float RING_DETAIL_DISTANCE = 40.;\nconst float RING_VOXEL_STEP_SIZE = .03;\n\nvec3 ringShadowColor( const in vec3 ro ) {\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\n        return vec3(0.);\n    }\n    return vec3(1.);\n}\n\nbool ringMap( const in vec3 ro ) {\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\n}\n\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \n// find startpoint \n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\n   \n    if( d1 < 0. && d2 < 0. ) return vec4( 0. );\n    \n    float d = min( max(d1,0.), max(d2,0.) );\n    \n    if( d > ASTEROID_MAX_DISTANCE ) return vec4( 0. );\n    \n    vec3 ros = ro + rd*d;\n    \n    // avoid precision problems..\n    vec2 mroxy = mod(ros.xy, vec2(10.));\n    vec2 roxy = ros.xy - mroxy;\n    ros.xy -= roxy;\n    ros /= RING_VOXEL_STEP_SIZE;\n    ros.xy -= vec2(.013,.112)*time*.5;\n    \n\tvec3 pos = floor(ros);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\t\n    float alpha = 0., dint;\n\tvec3 offset = vec3(0.), id, asteroidro;\n    vec2 asteroid;\n    \n\tfor( int i=0; i<RING_VOXEL_STEPS; i++ ) {\n\t\tif( ringMap(pos) ) {\n            id = hash33(pos);\n            offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\n            dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\n            \n            if( dint > 0. ) {\n                asteroidro = ros+rd*dint-(pos+offset);\n    \t        asteroid = asteroidSpheretracing( asteroidro, rd, id );\n\t\t\t\t\n                if( asteroid.y < .1 ) {\n\t                alpha = 1.;\n        \t    \tbreak;\t    \n                }\n            }\n\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n    if( alpha > 0. ) {       \n        vec3 intersection = ros + rd*(asteroid.x+dint);\n        vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\n\n        vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\n\n        intersection *= RING_VOXEL_STEP_SIZE;\n        intersection.xy += roxy;\n        col *= ringShadowColor( intersection );\n         \n\t    return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\n    }\n    \n\treturn vec4(0.);\n}\n\n// --------------------------------------------------\n// Anillo de asteroides de lejos (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------------------\n\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. ) {\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n        }\n    }\n    return 0.;\n}\n\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. && d < maxd ) {\n        maxd = d;\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\n            \n            col *= ringShadowColor( intersection );\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\n\t\t\tcol *= SUN_COLOR;\n            return vec4( col, dens );\n        }\n    }\n    return vec4(0.);\n}\n\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    vec4 far = renderRingFar( ro, rd, maxd );\n    float l = length( ro.xy );\n\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\n     \t\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\n        far.xyz *= detail;    \n    }\n    \n\t// are asteroids neaded ?\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\n        \n        vec4 near = renderRingNear( ro, rd );\n        far = mix( far, near, near.w );\n        maxd=0.;\n    }\n            \n    return far;\n}\n\n// --------------------------------------\n// Estrellas (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------\n\nvec4 renderStars( const in vec3 rd ) {\n\tvec3 rds = rd;\n\tvec3 col = vec3(0);\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\n    \n    vec2 xy = vec2(rds.y * v, rds.x * v);\n    float s = noise(rds*134.);\n    \n    s += noise(rds*470.);\n    s = pow(s,19.0) * 0.00001;\n    if (s > 0.5) {\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \n        col += backStars;\n    }\n\treturn   vec4( col, 1 ); \n} \n\n// --------------------------------------\n// Atmospheric Scattering (by GLtracy)\n// https://www.shadertoy.com/view/lslXDr\n// --------------------------------------\n\nconst float ATMOSPHERE_K_R = 0.166;\nconst float ATMOSPHERE_K_M = 0.0025;\nconst float ATMOSPHERE_E = 12.3;\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\nconst float ATMOSPHERE_G_M = -0.85;\n\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\n\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\n\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\n\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n    \n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\nfloat atmosphericPhaseReyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat atmosphericDensity( vec3 p ){\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\n}\n\nfloat atmosphericOptic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n    float sumdensity = 0.;\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\n\t\tfloat dens = atmosphericDensity( v );\n  \n\t    float m = MAX;\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\n \t\tsumdensity += dens;\n        \n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\n}\n\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\n\t    float m = MAX;\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\n}\n\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \n    // inside or outside atmosphere?\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\n        \n    if(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\n\n    if ( e.x > e.y ) {\n        d = MAX;\n        return vec4(0.);\n    }\n    d = e.y = min( e.y, f.x );\n\n    return atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\n}\n\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n    e.x = 0.;\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\n}\n\n// --------------------------------------\n// Seascape (by TDM)\n// https://www.shadertoy.com/view/Ms2SD1\n// --------------------------------------\n\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\n    \n    color += upc*SEA_WATER_COLOR * (att * 0.18);\n    color += sunc * vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// --------------------------------------\n// Nubes (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------\n\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\n\tvec3 intersection = ro+rd*d;\n    vec3 cint = intersection*0.009;\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\n\n    cint.xy = rotate( rot, cint.xy );\n\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\n\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\n\n    shadow = clamp(1.-clouds, 0., 1.);\n\n    clouds = clamp(clouds, 0., 1.);\n    clouds *= clouds;\n    clouds *= smoothstep(0.,0.4,d);\n\n    vec3 clbasecolor = vec3(1.);\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\n    clcol += .3*clbasecolor*sunColor;\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \n    \n    return vec4( clcol, clouds );\n}\n\n// --------------------------------------\n// Planeta (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------\n\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\n\n    vec3 intersection = ro + rd*d;\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\n    vec4 res;\n\n    float mixDetailColor = 0.;\n        \n\tif( d < 0. || d > maxd) {\n      \treturn vec4(0.);\n\t}\n    if( d > 0. ) {\n\t    maxd = d;\n    }\n    float att = 0.;\n    \n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\n    \n    float dm = MAX, e = 0.;\n    vec3 col, detailCol, nDetail;\n    \n    // normal and intersection \n    e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\n    \n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \n                 \n    // color  \n    if( mixDetailColor < 1. ) {\n        if( e < .45 ) {\n            // sea\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \n        } else {\n            // planet (land) far\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\n\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\n            vec3 landColor2 = RING_COLOR_1 * land2;\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\n\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\n        }\n    }\n    \n    if( mixDetailColor > 0. ) {\n        col = mix( col, detailCol, mixDetailColor );\n    }\n        \n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\n    if( d > 0. ) { \n        float shadow;\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\n        col *= shadow; \n        col = mix( col, clouds.rgb, clouds.w );\n    }\n    \n    float m = MAX;\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\n\n \treturn vec4( col, 1. ); \n}\n\n// --------------------------------------\n// Lens flare (by musk)\n// https://www.shadertoy.com/view/4sX3Rs\n// --------------------------------------\n\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\n\tc = c*.5 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\n// -------------------------------------------------------\n// Extracts bit b from the given number. (by Pol Jeremias)\n// https://www.shadertoy.com/view/Xst3zX\n// -------------------------------------------------------\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n// -------------------------------------------------------------------------\n// Returns the pixel at uv in the given bit-packed sprite. (by Pol Jeremias)\n// https://www.shadertoy.com/view/Xst3zX\n// -------------------------------------------------------------------------\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n}\n\n// --------------------------------------\n// Prints a character. (by Pol Jeremias)\n// https://www.shadertoy.com/view/Xst3zX\n// --------------------------------------\nfloat char(float ch, vec2 uv, inout vec2 cursor)\n{\n    float c = sprite(ch, CHAR_SIZE, 0.5 * (uv - cursor));\n    cursor += vec2(CHAR_SPACING.x, 0.0);\n    return c;\n}\n\n// ------------------------------------------\n// VisualizaciÃ³n de la informaciÃ³n del juego\n// ------------------------------------------\n\nvec3 pintarIntegridadEstructural(vec3 fragColor, vec2 coordenada)\n{\n    vec3 color = fragColor;\n    float x = coordenada.x * iResolution.y/iResolution.x;\n    \n    if (x > 0.9 && x < 0.93)\n    {\n\t    vec4 danio = load(DANIO);\n        float integridad = 0.5 - danio.x;\n        if ((coordenada.y >= -0.5 && coordenada.y < integridad)\n           || abs(coordenada.y) >= 0.5 && abs(coordenada.y) <= 0.51)\n        {\n            color.r = 0.5 - coordenada.y;\n            color.g = coordenada.y + 0.5;\n            color.b = 0.0;\n        }\n    }\n    \n    return color;\n}\n\nvec3 pintarDistanciaSalidaAnillo(vec3 fragColor, vec2 coordenada)\n{\n    vec3 color = fragColor;\n    float x = coordenada.x * iResolution.y/iResolution.x;\n    \n    if (x < -0.9 && x > -0.93)\n    {\n\t    vec4 posicion = load(POSICION);\n        float y = posicion.z * 0.5 / RING_HEIGHT;\n        if ((coordenada.y >= 0.0 && coordenada.y <= y) \n            || (coordenada.y <= 0.0 && coordenada.y >= y)\n            || abs(coordenada.y) >= 0.5 && abs(coordenada.y) <= 0.51)\n        {\n            color.r = 2.0 * abs(coordenada.y);\n            color.g = 1.0 - abs(coordenada.y) * 2.0;\n            color.b = 0.0;\n        }\n    }\n    \n    return color;\n}\n\nfloat obtenerDigito(inout float distancia)\n{\n    float valorDigito = floor(fract(distancia) * 10.0);\n    distancia *= 0.1;\n    \n    if (valorDigito == 1.0)\n    {\n        return ch_1;\n    }\n    else if (valorDigito == 2.0)\n    {\n        return ch_2;\n    }\n    else if (valorDigito == 3.0)\n    {\n        return ch_3;\n    }\n    else if (valorDigito == 4.0)\n    {\n        return ch_4;\n    }\n    else if (valorDigito == 5.0)\n    {\n        return ch_5;\n    }\n    else if (valorDigito == 6.0)\n    {\n        return ch_6;\n    }\n    else if (valorDigito == 7.0)\n    {\n        return ch_7;\n    }\n    else if (valorDigito == 8.0)\n    {\n        return ch_8;\n    }\n    else if (valorDigito == 9.0)\n    {\n        return ch_9;\n    }\n    else\n    {\n        return ch_0;\n    }\n}\n\nvec3 pintarPuntuacion(vec3 fragColor, vec2 coordenada)\n{\n    float tamanio = 1.0;\n    vec2 cursor = tamanio * vec2(0.0 + STRWIDTH(1.0), iResolution.y - STRHEIGHT(1.5));\n    vec2 fragCoord = floor(coordenada * tamanio);\n    \n    vec4 posicion = load(POSICION);\n    float distancia = 23008.4 - (distance(vec3(0.0, 0.0, 0.0), vec3(posicion)) * 10.0);\n    float digito6 = obtenerDigito(distancia);\n    float digito5 = obtenerDigito(distancia);\n    float digito4 = obtenerDigito(distancia);\n    float digito3 = obtenerDigito(distancia);\n    float digito2 = obtenerDigito(distancia);\n    float digito1 = obtenerDigito(distancia);\n\n    float color = (char(digito1, fragCoord, cursor) + char(digito2, fragCoord, cursor) +\n           char(digito3, fragCoord, cursor) + char(digito4, fragCoord, cursor) +\n           char(digito5, fragCoord, cursor) + char(digito6, fragCoord, cursor));\n    \n    if (color > 0.0)\n    {\n        return vec3(color);\n    }\n    else\n    {\n        return vec3(fragColor);\n    }\n}\n\nvec3 pintarGameOver(vec3 fragColor, vec2 coordenada)\n{\n    float tamanio = 0.25;\n    vec2 cursor = tamanio * vec2(0.0 + STRWIDTH(21.0), iResolution.y - STRHEIGHT(16.0));\n    vec2 fragCoord = floor(coordenada * tamanio);\n    \n    float color = (char(ch_g, fragCoord, cursor) + char(ch_a, fragCoord, cursor) +\n           char(ch_m, fragCoord, cursor) + char(ch_e, fragCoord, cursor) +\n           char(ch_sp, fragCoord, cursor) + char(ch_o, fragCoord, cursor) +\n           char(ch_v, fragCoord, cursor) + char(ch_e, fragCoord, cursor) +\n           char(ch_r, fragCoord, cursor));\n    \n    if (color > 0.0)\n    {\n        return vec3(color);\n    }\n    else\n    {\n        return vec3(fragColor);\n    }\n}\n\n\nvec3 pintarCentro(vec3 fragColor, vec2 coordenada)\n{\n    vec3 color = fragColor;\n    vec2 centro = vec2(0.0,0.0);\n    \n    if (distance(coordenada, centro) < 0.01)\n    {\n        color = vec3(1.0, 1.0, 0.0);\n    }\n    \n    return color;\n}\n\n//---------------------\n// Juego Asteroid game\n//---------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float proporcion = iResolution.x/iResolution.y;\n    \n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= proporcion;\n    \n    // Se sitÃºa y orienta la nave (cÃ¡mara)\n    vec3 ro = vec3(load(POSICION));\n    vec3 ta = vec3(load(TA));\n    vec3 up = vec3(load(UP));\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n\n    // Se pintan las estrellas\n    float maxd = MAX;  \n    vec3 col = renderStars( rd ).xyz;\n\n    // Se pinta el planeta\n    vec4 planet = renderPlanet( ro, rd, up, maxd );       \n    if( planet.w > 0. ) col.xyz = planet.xyz;\n\n    // Se pinta el efecto atmosfÃ©rico del planeta\n    float atmosphered = maxd;\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n    // Se pinta el anillo de asteroides\n    time = mod( iTime, 50. );\n    vec4 ring = renderRing( ro, rd, maxd );\n    col = col * (1.-ring.w ) + ring.xyz;\n\n    // Se realiza el post-procesado de la imagen (lens flare)\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col *= vec3(1.,0.99,0.95);   \n    col = clamp(1.06*col-0.03, 0., 1.);      \n\n    vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\n    float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\n    col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\n\n    // Se visualizan las colisiones\n    vec4 colision = load(COLISION);\n    \n    if (colision.x > 0.0)\n    {\n        col += vec3(0.9, 0.0, 0.0);\n    }\n    \n    // Se visualiza la informaciÃ³n del juego\n    if (iTime > 13.0)\n    {\n\t    col = pintarIntegridadEstructural(col, p);\n        col = pintarDistanciaSalidaAnillo(col, p);\n        col = pintarPuntuacion(col, fragCoord);\n        \n        vec4 gameOver = load(GAME_OVER);\n        if (gameOver.x > 0.5)\n        {\n            col = pintarGameOver(col, fragCoord);\n        }\n        \n        col = pintarCentro(col, p);\n    }\n    \n    fragColor = vec4( col ,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------\n// Clave de las teclas de direcciÃ³n\n// ---------------------------------\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n\n// --------------------------------------\n// Variables pasadas a travÃ©s del Buffer\n// --------------------------------------\nconst float COLISION = 1.;\nconst float POSICION = 2.;\nconst float DIRECCION = 3.;\nconst float UP = 4.;\nconst float TA = 5.;\nconst float GAME_OVER = 6.;\nconst float DANIO = 7.;\n\n// -----------------------\n// Velocidades de la nave\n// -----------------------\nconst float PASO_AVANCE = 0.0015;\nconst float PASO_GIRO = 0.01;\n\n// ------------------------------------------------------------------\n// Propiedades del planeta (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// (Deben estar coordinadas con las definidas en el shader de imagen)\n// ------------------------------------------------------------------\nconst float EARTH_RADIUS = 1000.;\n\n// ---------------------------------------------------------------------\n// Propiedades del anillo de asteroides del planeta (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// (Deben estar coordinadas con las definidas en el shader de imagen)\n// ---------------------------------------------------------------------\nconst float RING_INNER_RADIUS = 1500.;\nconst float RING_OUTER_RADIUS = 2300.;\nconst float RING_HEIGHT = 2.;\n\n// ------------------------------------------------------------------\n// Propiedades de calidad de imagen muy baja (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// (Deben estar coordinadas con las definidas en el shader de imagen)\n// ------------------------------------------------------------------\nconst int   ASTEROID_NUM_STEPS = 7;\nconst int\tASTEROID_NUM_BOOL_SUB = 4;\nconst int   RING_VOXEL_STEPS = 16;\nconst float ASTEROID_MAX_DISTANCE = .67; \n\n// ------------------------------------------------------------\n// Tiempo para la rotaciÃ³n de los asteroides(by TDM)\n// https://www.shadertoy.com/view/ldSSzV\n// (Esta variable es clave para la detecciÃ³n de las colisiones)\n// ------------------------------------------------------------\nfloat time;\n\n\n// -------------------------------------------------\n// FunciÃ³n para el cÃ¡lculo de la matriz de rotaciÃ³n\n// -------------------------------------------------\nvec3 rotate3D(vec3 v, float angle, vec3 er)\n{\n    mat3 ex = mat3(0.0, er.z, -er.y, -er.z, 0.0, er.x, er.y, -er.x, 0.0);\n    mat3 exe = mat3(er.x*er.x, er.x*er.y, er.x*er.z, er.x*er.y, er.y*er.y, er.y*er.z, er.x*er.z, er.y*er.z, er.z*er.z); \n\tmat3 vr = cos(angle) * mat3(1.0) + sin(angle) * ex + (1.0 - cos(angle)) * exe;\n    return v * vr;\n}\n\n// --------------------------------------\n// Noise functions (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------\n\nfloat hash( const in float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31( const in float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\nvec3 hash33( const in vec3 p) {\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\n}\n\nfloat noise( const in  float p ) {    \n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\n}\n\nfloat noise( const in  vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// -----------------------------------------\n// Funciones matemÃ¡ticas(by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// -----------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\n\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n// ---------------------------------\n// Funciones de IntersecciÃ³n (by iq)\n// ---------------------------------\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n// --------------------------------------\n// Asteroide (by TDM)\n// https://www.shadertoy.com/view/ldSSzV\n// --------------------------------------\n\nconst float ASTEROID_TRESHOLD \t= 0.001;\nconst float ASTEROID_DISPLACEMENT = 0.1;\nconst float ASTEROID_RADIUS = 0.13;\n\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \n    float d = sphere(p,ASTEROID_RADIUS);    \n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\n        float ii = float(i)+id.x;\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \n    }\n    return d;\n}\n\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( xyangle, ro.xy );\n    \n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( yzangle, ro.yz );\n}\n\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( -yzangle, ro.yz );\n\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( -xyangle, ro.xy );  \n}\n\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\n    asteroidTransForm( ori, id );\n    asteroidTransForm( dir, id );\n    \n    vec2 td = vec2(0.0);\n    for(int i = 0; i < ASTEROID_NUM_STEPS; i++) {\n        vec3 p = ori + dir * td.x;\n        td.y = asteroidMap(p, id);\n        if(td.y < ASTEROID_TRESHOLD) break;\n        td.x += (td.y-ASTEROID_TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\n\n// --------------------------------------------------\n// Anillo de asteroides de cerca (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n// --------------------------------------------------\n\nconst float RING_DETAIL_DISTANCE = 40.;\nconst float RING_VOXEL_STEP_SIZE = .03;\n\nbool ringMap( const in vec3 ro ) {\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\n}\n\n\n// ------------------------\n// DetecciÃ³n de colisiones\n// ------------------------\nbool colision(const in vec3 ro, const in vec3 rd)\n{ \n    float l = length( ro.xy );\n    if (l >= RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \n        || l <= RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE)\n        return false;\n    \n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\n   \n    if( d1 < 0. && d2 < 0. ) return false;\n    \n    float d = min( max(d1,0.), max(d2,0.) );\n    \n    if( d > ASTEROID_MAX_DISTANCE ) return false;\n    \n    vec3 ros = ro + rd*d;\n    \n    // avoid precision problems..\n    vec2 mroxy = mod(ros.xy, vec2(10.));\n    vec2 roxy = ros.xy - mroxy;\n    ros.xy -= roxy;\n    ros /= RING_VOXEL_STEP_SIZE;\n    ros.xy -= vec2(.013,.112)*time*.5;\n    \n\tvec3 pos = floor(ros);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\n    float alpha = 0., dint;\n\tvec3 offset = vec3(0.), id, asteroidro;\n    vec2 asteroid;\n    \n\tfor( int i=0; i<RING_VOXEL_STEPS; i++ ) {\n\t\tif( ringMap(pos) ) {\n            id = hash33(pos);\n            offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\n            dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\n \n            if( dint > 0. ) {\n                asteroidro = ros+rd*dint-(pos+offset);\n    \t        asteroid = asteroidSpheretracing( asteroidro, rd, id );\n\n                if( asteroid.y < .1 ) {\n\t                alpha = 1.;\n        \t    \tbreak;\t    \n                }\n            }\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n    if( alpha > 0. )\n    {       \n        vec3 intersection = ros + rd*(asteroid.x+dint);\n        intersection *= RING_VOXEL_STEP_SIZE;\n        intersection.xy += roxy;\n        \n        if (distance(intersection, ro) < 0.09)\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n//-------------------------------------------\n// Control de la cÃ¡mara (by Reinder Nijhoff)\n// https://www.shadertoy.com/view/4tjGRh\n//-------------------------------------------\n\nvec3 pro, pta, pup;\nfloat dro, dta, dup;\n\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\n    if( t >= prevt && t <= prevt+duration ) {\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\n    }\n    prev = dest;\n    prevt += duration;\n}\n\n// ------------------------------------------------\n// Funciones para el acceso a variables del buffer\n// ------------------------------------------------\nbool esDato(float x, float idDato)\n{\n    return x > (idDato -1.0) && x < idDato;\n}\n\nvec2 coordDato(float idDato)\n{\n    return vec2(idDato - 0.5, 0.5)/iResolution.xy;\n}\n\n// -------------------------------------------------------------------\n// Control de la cÃ¡mara (introducciÃ³n inicial + movimiento de la nave)\n// -------------------------------------------------------------------\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up, bool avanzar)\n{\n    dro = dta = dup = 0.;\n\n    if (t <= 12.)\n    {\n        // IntroducciÃ³n inicial\n        pro = ro = vec3(-2000. ,10000. ,1500. );\n        pta = ta = vec3(    0. ,    0. ,   0. );\n        pup = up = vec3(    0. ,    0.4,   1. ); \n   \n        camint( ro, t, 12., vec3(1500. , 1744.8 , 1.2 ), pro, dro );\n        camint( ta, t, 12., vec3(    0. , 0. , 0. ), pta, dta );\n        camint( up, t, 12., vec3(    0. ,  0.,    1. ), pup, dup );\n\n        up = normalize( up );\n\t}\n    else\n    {\n        // Movimiento de la nave\n        ro = vec3(texture(iChannel0,coordDato(POSICION)));\n        \n        if (avanzar)\n        {\n        \tvec3 direccion = vec3(texture(iChannel0,coordDato(DIRECCION)));\n\t        ro += (PASO_AVANCE * direccion);\n        }\n     }\n}\n\n// --------------------------------\n// DetecciÃ³n de pulsaciÃ³n de tecla\n// --------------------------------\nbool KeyDown(in int key)\n{\n\treturn (texture(iChannel1, vec2((float(key) + 0.5) / 256.0, 0.25)).x > 0.0);\n}\n\n// --------------------------------\n// Control del juego Asteroid Game\n// --------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Para agilizar el juego, se descarta el procesamiento de la parte\n    // del buffer que no es utilizado\n    if (fragCoord.y > 1.0) discard;\n    if (fragCoord.x > 7.0) discard;\n\n    // Por defecto, se toma el mismo valor que en el frame anterior\n\tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n\n    // Si se ha acabado el juego, no es necesario hacer nada\n    if (texture(iChannel0,coordDato(GAME_OVER)).x > 0.5) return;\n\n    // DetecciÃ³n de ColisiÃ³n\n    if (esDato(fragCoord.x, COLISION))\n    {\n        // Por defecto no hay colisiÃ³n (fragColor.x = 0.0)\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n\n        // Se recuperan los parÃ¡metros de la cÃ¡mara\n        vec3 ro = vec3(texture(iChannel0,coordDato(POSICION)));\n        vec3 ta = vec3(texture(iChannel0,coordDato(TA)));\n        vec3 up = vec3(texture(iChannel0,coordDato(UP)));\n\n        // Se calculan los vectores intermedios utilizados para el cÃ¡lculo del vector rd\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,up) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // Se ajusta la variable time que es clave para la localizaciÃ³n de los asteroides\n        time = mod( iTime, 50. );\n\n        // Se prepara una zona de detecciÃ³n situada en el centro de la pantalla\n        const int numDivX = 3; // NÂº de divisiones horizontales\n        const int numDivY = 3; // NÂº de divisones verticales\n        float reduccionZona = 0.5; // ReducciÃ³n de la zona de detecciÃ³n\n        float divX = 2.0 * reduccionZona / float(numDivX); // Ancho de cada divisiÃ³n\n        float divY = 2.0 * reduccionZona / float(numDivY); // Alto de cada divisiÃ³n\n        float offsetX = divX * 0.5 - 1.0 * reduccionZona; // Desplazamiento horizontal de cada punto de detecciÃ³n\n        float offsetY = divY * 0.5 - 1.0 * reduccionZona; // Desplazamiento vertical de cada punto de detecciÃ³n\n\n        // Se define el punto de detecciÃ³n\n        vec2 p = vec2(0.0, 0.0);\n        \n        // Se recorre cada punto de detecciÃ³n de la zona para comprobar si hay colisiÃ³n\n        for (int x = 0; x < numDivX; x++)\n        {\n            p.x = float(x) * divX + offsetX;\n            for (int y = 0; y < numDivY; y++)\n            {\n                p.y = float(y) * divY + offsetY;\n                vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n\n                if (colision( ro, rd ))\n                {\n                    fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n                    break;\n                }\n            }\n        }\n    }\n    // PosiciÃ³n de la nave\n    else if (esDato(fragCoord.x, POSICION))\n    {\n        vec3 ro, ta, up;\n        cameraPath( iTime, ro, ta, up, true );\n        fragColor = vec4(ro, 1.0);\n    }\n    // DirecciÃ³n de la nave\n    else if (esDato(fragCoord.x, DIRECCION))\n    {\n        // InicializaciÃ³n de la direcciÃ³n\n        if (iTime < 12.)\n        {\n            fragColor = vec4(-1., -1., 0., 1.0);\n        }\n        // Control de la direcciÃ³n con el teclado\n        else\n        {\n            // Vector que apunta hacia arriba respecto a la nave (ajusta el giro de la cÃ¡mara)\n            vec3 arriba = vec3(texture(iChannel0,coordDato(UP)));\n            \n            // CÃ¡lculo de giro en funciÃ³n de la tecla de direcciÃ³n pulsada\n            vec3 direccion = vec3(fragColor);\n            if (KeyDown(KEY_LEFT))\n            {\n                fragColor = vec4(rotate3D(direccion, PASO_GIRO, arriba), 1.0);\n            }\n            else if (KeyDown(KEY_RIGHT))\n            {\n                fragColor = vec4(rotate3D(direccion, -PASO_GIRO, arriba), 1.0);\n            }\n            if (KeyDown(KEY_UP))\n            {\n                vec3 derecha = cross(direccion, arriba);\n                fragColor = vec4(rotate3D(direccion, PASO_GIRO, derecha), 1.0);\n            }\n            if (KeyDown(KEY_DOWN))\n            {\n                vec3 derecha = cross(direccion, arriba);\n                fragColor = vec4(rotate3D(direccion, -PASO_GIRO, derecha), 1.0);\n            }\n        }\n    }\n    // Vector que apunta hacia arriba respecto a la nave (constante a lo largo del juego)\n    else if (esDato(fragCoord.x, UP))\n    {\n        // Se inicializa durante la introducciÃ³n inicial\n        if (iTime < 12.)\n        {\n            vec3 ro, ta, up;\n\n            cameraPath( iTime, ro, ta, up, false );\n            fragColor = vec4(up, 1.0);\n        }\n    }\n    // Vector que va desde la nave hacia un punto en el espacio hacia donde se dirige\n    else if (esDato(fragCoord.x, TA))\n    {\n        // Se inicializa durante la introducciÃ³n inicial\n        if (iTime < 12.)\n        {\n            vec3 ro, ta, up;\n\n            cameraPath( iTime, ro, ta, up, false );\n            fragColor = vec4(up, 1.0);\n        }\n        else\n        {\n            // Se recuperan los vectores necesarios para el cÃ¡lculo del vector ta\n            vec3 arriba = vec3(texture(iChannel0,coordDato(UP)));\n            vec3 posicion = vec3(texture(iChannel0,coordDato(POSICION)));\n            vec3 direccion = vec3(texture(iChannel0,coordDato(DIRECCION)));\n            \n            // CÃ¡lculo de giro en funciÃ³n de la tecla de direcciÃ³n pulsada\n            if (KeyDown(KEY_LEFT))\n            {\n                direccion = rotate3D(direccion, PASO_GIRO, arriba) * 10000.;\n                fragColor = vec4(direccion + posicion, 1.0);\n            }\n            else if (KeyDown(KEY_RIGHT))\n            {\n                direccion = rotate3D(direccion, -PASO_GIRO, arriba) * 10000.;\n                fragColor = vec4(direccion + posicion, 1.0);\n            }\n            if (KeyDown(KEY_UP))\n            {\n                vec3 derecha = cross(direccion, arriba);\n                direccion = rotate3D(direccion, PASO_GIRO, derecha) * 10000.;\n                fragColor = vec4(direccion + posicion, 1.0);\n            }\n            if (KeyDown(KEY_DOWN))\n            {\n                vec3 derecha = cross(direccion, arriba);\n                direccion = rotate3D(direccion, -PASO_GIRO, derecha) * 10000.;\n                fragColor = vec4(direccion + posicion, 1.0);\n            }\n        }\n    }\n    // CÃ¡lculo del daÃ±o sufrido por la nave\n    else if (esDato(fragCoord.x, DANIO))\n    {\n        vec3 colision = vec3(texture(iChannel0,coordDato(COLISION)));\n\n        if (iTime > 15.0 && colision.x > 0.0)\n        {\n            fragColor.x += 0.002;\n        }\n    }\n    // DetecciÃ³n del fin de la partida (por salida del campo de asteroides o por daÃ±o total)\n    else if (esDato(fragCoord.x, GAME_OVER))\n    {\n        vec3 posicion = vec3(texture(iChannel0,coordDato(POSICION)));\n        vec3 danio = vec3(texture(iChannel0,coordDato(DANIO)));\n\n        if (iTime > 12.0 \n            && (abs(posicion.z) > RING_HEIGHT || danio.x > 1.0))\n        {\n            fragColor = vec4(1.0);\n        }\n    }\n    else\n    {\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}