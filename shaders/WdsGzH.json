{
    "Shader": {
        "info": {
            "date": "1544977122",
            "description": "A light show for the festive season: generate random 3D projective transformations and use to transform a glowing cube.",
            "flags": 16,
            "hasliked": 0,
            "id": "WdsGzH",
            "likes": 9,
            "name": "Projective Light Show",
            "published": 3,
            "tags": [
                "lightshow",
                "projective",
                "svd",
                "singularvalue",
                "randomrotation"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1024
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// (c) Matthew Arcus 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A festive light show: generate random 4D linear transformations, from\n// a random scaling sandwiched between two random rotations (each generated\n// from two random quaternions). This is essentially a singular value\n// decomposition for the resulting matrix (we have the decomposition by\n// construction rather than having to compute it, for that see\n// https://www.shadertoy.com/view/XlsGRl by paniq).\n//\n// The random transformation is then used to projectively transform a cube in\n// 3D projective space using separate interpolation on the two rotations and\n// the diagonal scaling matrix.\n//\n// Mouse changes camera position.\n// 'c': toggle camera rotation\n// 'r': toggle rotation in transformation\n// 's': toggle scaling in transformation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float scale = 1.0;\nconst float A = 0.5; // Light amplitude\nconst float K = 0.4; // Concentration\nconst float R = 0.2; // Radius\nconst float PI = 3.14159265359;\n\nbool dorotation = true;\nbool doscaling = true;\nbool docamerarotation = true;\n\nbool alert = false;\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n// Quaternion left and right multiplication as matrices\n// The two forms commute (this is just associativity).\nmat4 qmat_left(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t, z,-y,-x, \n              -z, t, x,-y,\n               y,-x, t,-z,\n               x, y, z, t );\n}\n\nmat4 qmat_right(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y,-x, \n               z, t,-x,-y,\n              -y, x, t,-z,\n               x, y, z, t );\n}\n\nvec2 closest(vec4 p,vec4 q,vec4 r,vec4 s) {\n  // Find k and j such that p+kq and r+js are the closest points.\n  // Use Cramer's rule to solve linear system\n  //(p+kq-r-js).q = 0 -> p.q+kq.q-r.q-js.q = 0 => kq.q - js.q = -p.q+r.q\n  //(p+kq-r-js).s = 0 -> p.s+kq.s-r.s-js.s = 0 => kq.s - js.s = -p.s+r.s\n  vec2 c0 = vec2(dot(q,q),dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-dot(s,s));\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  float d0 = determinant(mat2(a,c1)); // replace c0 with a\n  float d1 = determinant(mat2(c0,a)); // replace c1 with a\n  return vec2(d0,d1)/determinant(mat2(c0,c1));\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\n// Numerical Recipes 32-bit Linear Congruential Generator\nuint seed = 1U;\nuint lcg() {\n  seed *= 1664525U;\n  seed += 1013904223U;\n  return seed;\n}\n\n// Wang Hash, used to seed LCG\nuint ihash(uint a) {\n  a = (a ^ 61U) ^ (a >> 16);\n  a *= 9U;\n  a = a ^ (a >> 4);\n  a = a * 0x27d4eb2dU;\n  a = a ^ (a >> 15);\n  return a;\n}\n\n// Uniform random float in [0,1)\nfloat random() {\n  return float(lcg())/pow(2.0,32.0);\n}\n\n// Construct a uniformly distributed point on a sphere.\nvec3 randomspherepoint() {\n  float theta = 2.0*PI*random(); // Random azimuth\n  float z = 2.0*random()-1.0;    // z in [-1,1]\n  float r = sqrt(1.0-z*z);       // Sphere radius at z\n  return vec3(r*cos(theta),r*sin(theta),z);\n}\n\nfloat randomscalefactor(float t) {\n  //float s = -2.0*log(random());\n  //float s = 0.5/(random()-0.5);\n  //float s = inversesqrt(random());\n  float s = 1.0/random();\n  t = 2.0*min(t,1.0-t);\n  float res = mix(1.0,s,smoothstep(0.0,1.0,t));\n  return res;\n}\n\nmat4 randomscaling(float t) {\n  return mat4(randomscalefactor(t),0,0,0,\n              0,randomscalefactor(t),0,0,\n              0,0,randomscalefactor(t),0,\n              0,0,0,randomscalefactor(t));\n}\n\nvec4 randomquaternion(float t) {\n  vec3 axis = randomspherepoint();\n  float theta = PI*(random()-0.5);\n  t = min(t,1.0-t);\n  theta *= smoothstep(0.0,0.5,t);\n  return vec4(sin(theta)*axis,cos(theta));\n}\n\n// General a random R4 rotation, from two\n// random quaternions.\nmat4 randomrotation(float t) {\n  mat4 left = qmat_left(randomquaternion(t));\n  mat4 right = qmat_right(randomquaternion(t));\n  //assert(eq(left*right,right*left));\n  return left*right;\n}\n\nmat4 setmatrix(float t) {\n  t /= 10.0;\n  uint epoch = uint(floor(t));\n  seed = ihash(epoch);\n  t = fract(t);\n  if (true) {\n    // 4 seconds each out and back, with a 1 second pause between.\n    t *= 1.25;\n    if (t > 0.5) t = max(t-0.125,0.5);\n    if (t > 1.0) t = max(t-0.125,1.0);\n  }\n  mat4 m = mat4(1);\n  if (dorotation) m *= randomrotation(t);\n  if (doscaling) m *= randomscaling(t);\n  if (dorotation && doscaling) m *= randomrotation(t);\n  return m;\n}\n\n// A cube, centre of side and side direction.\nvec4 lines[] = vec4[]\n  (vec4(1,1,0,1),vec4(0,0,1,0),\n   vec4(1,-1,0,1),vec4(0,0,1,0),\n   vec4(-1,-1,0,1),vec4(0,0,1,0),\n   vec4(-1,1,0,1),vec4(0,0,1,0),\n\n   vec4(1,0,1,1),vec4(0,1,0,0),\n   vec4(1,0,-1,1),vec4(0,1,0,0),\n   vec4(-1,0,-1,1),vec4(0,1,0,0),\n   vec4(-1,0,1,1),vec4(0,1,0,0),\n   \n   vec4(0,1,1,1),vec4(1,0,0,0),\n   vec4(0,1,-1,1),vec4(1,0,0,0),\n   vec4(0,-1,-1,1),vec4(1,0,0,0),\n   vec4(0,-1,1,1),vec4(1,0,0,0));   \n\nvoid getline(int i, mat4 m, out vec4 r, out vec4 s) {\n  vec4 r0 = m*lines[2*i];\n  vec4 s0 = m*lines[2*i+1];\n  r  = r0/r0.w;\n  // Normalization not needed for the vector algebra, but\n  // we need to measure along the line consistently.\n  s = normalize(r0*s0.w-r0.w*s0);\n}\n\nvec4 transform(in vec4 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (docamerarotation) {\n    p.yz = rotate(p.yz, 0.123*iTime);\n    p.zx = rotate(p.zx, 0.2*iTime);\n  }\n  return p;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  docamerarotation = !keypress(CHAR_C);\n  dorotation = !keypress(CHAR_R);\n  doscaling = !keypress(CHAR_S);\n\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  float camera = 3.0;\n  vec4 p = vec4(0,0,camera,1);\n  vec4 q = vec4(xy,-1,0);\n  p = transform(p);\n  q = normalize(transform(q));\n  vec3 color = vec3(0); // Accumulate color here\n  mat4 m = setmatrix(iTime);\n  for (int i = 0; i < 12; i++) {\n    vec4 r,s;\n    getline(i,m,r,s);\n    vec2 k = closest(p,q,r,s);\n    vec4 p1 = p+k.x*q;\n    vec4 r1 = r+k.y*s;\n    float d = distance(p1/p1.w,r1/r1.w);\n    float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n    vec3 basecolor = hsv2rgb(vec3(h,1.0,1.0));\n    color += A*float(k.x > 0.0)*(1.0-pow(smoothstep(0.0,R,d),K))*basecolor;\n  }\n  outColor = vec4(sqrt(color),1.0);\n  if (alert) outColor = vec4(1,0,0,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}