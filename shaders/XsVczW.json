{
    "Shader": {
        "info": {
            "date": "1521227189",
            "description": "Use mouse to change parameters, click lower left corner to autoplay.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "XsVczW",
            "likes": 3,
            "name": "Halley's method convergence",
            "published": 3,
            "tags": [
                "iterative",
                "root",
                "halley"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 497
        },
        "renderpass": [
            {
                "code": "/*\nVisualize convergence of Halley's method on the real axis.\nTop row is reference color, lower rows are consecutive halley iterations.\nVertical lines are roots of the derivatives and outer root bounds.\nConvergence basin's of Halley's method seem to be exactly determined by the roots\nof the derivatives.\nNewton's method and also all higher Householder Method's don't share this property.\nComment out in line 562 and following to try other methods.\n*/\n\nconst float eps = .000005;\nconst float pi = 3.1416;\nconst float zoom = 3.5;\nconst float it_num = 30.;\n\nvec3 x_to_col(float x){\n\treturn .5+.5*vec3(sin(x),sin(x+2./3.*pi),sin(x+4./3.*pi));\n}\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tfloat min1=min(roots[0],roots[1]);\n\tfloat min2=min(roots[2],roots[3]);\n\n\tfloat max1=max(roots[0],roots[1]);\n\tfloat max2=max(roots[2],roots[3]);\n\n\tfloat maxmin=max(min1,min2);\n\tfloat minmax=min(max1,max2);\n\n\ttmp[0]=min(min1,min2);\n\ttmp[1]=min(maxmin,minmax);\n\ttmp[2]=max(minmax,maxmin);\n\ttmp[3]=max(max1,max2);\n\n\troots=tmp;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0]=min(roots[0],min(roots[1],roots[2]));\n\ttmp[1]=max(roots[0],min(roots[1],roots[2]));\n\ttmp[2]=max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots2(inout vec2 roots){\n\tvec2 tmp;\n\n\ttmp[0]=min(roots[0],roots[1]);\n\ttmp[1]=max(roots[0],roots[1]);\n\n\troots=tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\nfloat eval_poly4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly3(vec3 coeffs, float x){\n\n\tfloat f = ((x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly2(vec2 coeffs, float x){\n\n\tfloat f = (x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly1(float coeff, float x){\n\n\tfloat f = x + coeff;\n\n\treturn f;\n}\n\nfloat sixth_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\tfloat f4 = 120. * x + 24. * a4;\n\tfloat f5 = 120.;\n\n\treturn x - 6.*(120.*f*f1*f1*f1*f1*f1 - 240.*f*f*f1*f1*f1*f2 + 90.*f*f*f*f1*f2*f2 - 10.*f*f*f*f*f1*f4 + f*f*f*f*f*f5 + 20.*(3.*f*f*f*f1*f1 - f*f*f*f*f2)*f3)/(720.*f1*f1*f1*f1*f1*f1 - 1800.*f*f1*f1*f1*f1*f2 + 1080.*f*f*f1*f1*f2*f2 - 90.*f*f*f*f2*f2*f2 + 20.*f*f*f*f*f3*f3 + 12.*f*f*f*f*f1*f5 + 120.*(4.*f*f*f1*f1*f1 - 3.*f*f*f*f1*f2)*f3 - 30.*(3.*f*f*f*f1*f1 - f*f*f*f*f2)*f4);\n}\n\nfloat fifth_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\tfloat f4 = 120. * x + 24. * a4;\n\tfloat f5 = 120.;\n\n\treturn x - 5.*(24.*f*f1*f1*f1*f1 - 36.*f*f*f1*f1*f2 + 6.*f*f*f*f2*f2 + 8.*f*f*f*f1*f3 - f*f*f*f*f4)/(120.*f1*f1*f1*f1*f1 - 240.*f*f1*f1*f1*f2 + 90.*f*f*f1*f2*f2 - 10.*f*f*f*f1*f4 + f*f*f*f*f5 + 20.*(3.*f*f*f1*f1 - f*f*f*f2)*f3);\n}\n\nfloat fourth_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\tfloat f4 = 120. * x + 24. * a4;\n\n\treturn x-4.*(6.*f*f1*f1*f1 - 6.*f*f*f1*f2 + f*f*f*f3)/(24.*f1*f1*f1*f1 - 36.*f*f1*f1*f2 + 6.*f*f*f2*f2 + 8.*f*f*f1*f3 - f*f*f*f4);\n}\n\nfloat third_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\n\treturn x-3.*(2.*f*f1*f1 - f*f*f2)/(6.*f1*f1*f1 - 6.*f*f1*f2 + f*f*f3);\n}\n\nfloat laguerre_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\tfloat G=f1/f;\n\tfloat H=G*G-f2/f;\n\tfloat a=5./(G+sign(G)*sqrt(abs(4.*(5.*H-G*G))));\n\n\treturn x - a;\n}\n\nfloat second_irrational_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\n\tfloat b=(3.*f1*f2-f*f3)/(3.*f2);\n\n\treturn x - 2.*f/(b+sign(b)*sqrt(abs(b*b-4.*((3.*f2*f2-2.*f1*f3)/(f2*6.))*f)));\n}\n\nfloat third_irrational_householder_iteration5(float coeffs[5], float x){\n\n\tfloat f = ((((x + coeffs[4]) * x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = (((5. * x + 4. * coeffs[4]) * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = ((20. * x + 12. * coeffs[4]) * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\tfloat f3 = (60. * x + 24. * coeffs[4]) * x + 6. * coeffs[3];\n\tfloat f4 = 120. * x + 24. * coeffs[4];\n\n\tfloat q1=(f*f4-2.*f2*f3)/(6.*f2*f2-4.*f1*f3);\n\tfloat q2=(3.*f2*f3-4.*f3*f3)/(24.*f1*f3+36.*f2*f2);\n\n\tfloat a=f2/2.+f1*q1+f*q2;\n\tfloat b=f1+f*q1;\n\tfloat c=f;\n\n\treturn x - 2.*f/(b+sign(b)*sqrt(abs(b*b-4.*a*c)));\n}\n\nfloat irrational_halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x-(2.*f)/(f1+sign(f1)*sqrt(abs(f1*f1-2.*f*f2)));\n}\n\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat newton_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\n\treturn x-f/f1;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n    \n\treturn 3;\n}\n\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n\n\t\t//s[old_num] = tmp[0];\n\t\t//s[old_num+1] = tmp[1];\n\n\t\tif(old_num == 0){\n            s[0] = tmp[0];\n            s[1] = tmp[1];\n        }\n        else{//old_num == 2\n            s[2] = tmp[0];\n            s[3] = tmp[1];\n        }\n\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n    float border = 2./iResolution.y;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat a0 = -6. / 89.;\n\tfloat a1 = 158. / 267.;\n\tfloat a2 = 34. / 89.;\n\tfloat a3 = -464. / 267.;\n\tfloat a4 = -65. / 267.;\n\n\tfloat t0 = mod(iTime,6.*pi);\n\n\ta0 += sin(t0)*.3;\n\ta1 += sin(t0*2./3.)*.7;\n    \n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        a0=mouse.y;\n        a1=mouse.x;\n    }\n\n\tvec4 c1 = vec4(a1,2.*a2,3.*a3,4.*a4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tfloat val = eval_poly5(a0,a1,a2,a3,a4,uv.x);\n\tfloat drv = eval_poly4(c1,uv.x)*5.;\n\n\t//float val = eval_poly4(c1,uv.x);\n\t//float drv = eval_poly3(c2,uv.x)*4.;\n\n\t//float val = eval_poly3(c2,uv.x);\n\t//float drv = eval_poly2(c3,uv.x)*3.;\n\n\t//float val = eval_poly2(c3,uv.x);\n\t//float drv = eval_poly1(c4,uv.x)*2.;\n\n\tfloat d0 = abs(val-uv.y)/length(vec2(drv,1.));\n\n\td0 = min(d0,abs(uv.y));\n\n\tint num_intervals = 0;\n\n\tvec4 roots_drv=vec4(1e38);\n\n\tfloat ub = upper_bound_lagrange5(a0,a1,a2,a3,a4);\n\tfloat lb = lower_bound_lagrange5(a0,a1,a2,a3,a4);\n\n\td0 = min(d0,abs(uv.x - ub));\n\td0 = min(d0,abs(uv.x - lb));\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfor(int i=0;i<4;i++){\n\t\tif(i < num_roots_drv){\n\t\t\td0 = min(d0,abs(uv.x - roots_drv[i]));\n\t\t}\n\t}\n\tif(num_roots_drv != 4){\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots_snd_drv){\n\t\t\t\td0 = min(d0,abs(uv.x - roots_snd_drv[i]));\n\t\t\t}\n\t\t}\n\t\tif(num_roots_snd_drv != 3){\n\t\t\tvec2 roots_trd_drv = vec2(1e38);\n\t\t\tint num_roots_trd_drv = solve_quadric(c3,roots_trd_drv);\n\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(i < num_roots_trd_drv){\n\t\t\t\t\td0 = min(d0,abs(uv.x - roots_trd_drv[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat x = uv.x;\n\n\tfloat j = floor((1.-(uv.y/zoom+.5))*it_num);\n\n\tfor(float i=0.;i<it_num;i+=1.){\n\t\tif(i<j){\n\t\t\t//x = newton_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\tx = halley_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = irrational_halley_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = laguerre_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = second_irrational_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = third_irrational_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = third_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = fourth_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = fifth_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = sixth_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t}\n\t}\n\n\tvec3 col = x_to_col(x);\n\n\tfragColor = vec4(mix(vec3(0),col,smoothstep(0., border, d0)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}