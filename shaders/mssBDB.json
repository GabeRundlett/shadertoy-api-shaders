{
    "Shader": {
        "info": {
            "date": "1689152317",
            "description": "Owen the shadowless sheep (he's an Aries)\n\nhorrifying unoptimised shader don't even bother looking at the source code",
            "flags": 0,
            "hasliked": 0,
            "id": "mssBDB",
            "likes": 15,
            "name": "Owen",
            "published": 3,
            "tags": [
                "raymarching",
                "displacement",
                "sheep",
                "owen"
            ],
            "usePreview": 0,
            "username": "martysh12",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define ITERS_MAX 200\n#define DIST_MIN 1e-3\n#define DIST_MAX 20.\n#define NORM_EPSILON 0.01\n\nstruct ray {\n  vec3 p;\n  bool hit;\n  float len;\n  int iters;\n\n  // material\n  vec3 c;\n  float shin;\n\n  float diffr;\n  float specr;\n};\n\nstruct sdfparams {\n  vec3 c;\n  float shin;\n\n  float diffr;\n  float specr;\n};\n\nstruct sdf {\n  float d;\n  sdfparams p;\n};\n\nstruct plight {\n  vec3 p;\n  vec3 c;\n};\n\nvec3 erot(vec3 p, vec3 ax, float r) {\n  return mix(dot(ax, p) * ax, p, cos(r)) + cross(ax, p) * sin(r);\n}\n\nsdf sdf_smooth_union(sdf a, sdf b, float k) {\n  float h = clamp(0.5 + (b.d - a.d) / k * 0.5, 0.0, 1.0);\n\n  return sdf(\n    mix(b.d, a.d, h) - k * h * (1. - h),\n    sdfparams(\n      mix(b.p.c, a.p.c, h),\n      mix(b.p.shin, a.p.shin, h),\n      mix(b.p.diffr, a.p.diffr, h),\n      mix(b.p.specr, a.p.specr, h)\n    )\n  );\n}\n\nsdf sdf_union(sdf a, sdf b) {\n  sdf chosen;\n  if (a.d < b.d) {\n    chosen = a;\n  } else {\n    chosen = b;\n  }\n  return chosen;\n}\n\nsdf sdf_wave_displace(vec3 p, float a, float b, sdf s) {\n  s.d += sin(p.x * a) * sin(p.y * a) * sin(p.z * a) * b;\n  return s;\n}\n\nsdf sdf_sphere(vec3 p, float r, sdfparams m) {\n  return sdf(\n    length(p) - r,\n    m\n  );\n}\n\nsdf sdf_cylinder(vec3 p, float r, float h, sdfparams m) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n\n  return sdf(\n    min(max(d.x, d.y), 0.) + length(max(d, 0.0)),\n    m\n  );\n}\n\nsdf sdf_plane(vec3 p, sdfparams m) {\n  return sdf(\n    p.y,\n    m\n  );\n}\n\nsdf wool(vec3 p, float wig, sdfparams wool_mat) {\n  vec3 np = p;\n  np /= vec3(1., 1., 1.2);\n  np = erot(np, vec3(0., 0., 1.), wig * 0.05);\n\n  sdf s = sdf_sphere(\n    np, 2.,\n    wool_mat\n  );\n\n  s.d *= 1.2;\n\n  s = sdf_wave_displace(np, 6., 0.05, s);\n\n  return s;\n}\n\nsdf eye(vec3 p, float blink, float eye_rad, float iris_rad, sdfparams head_mat) {\n  sdfparams eye_white = sdfparams(\n    vec3(1.),\n    100.,\n    1.,\n    1.\n  );\n\n  sdfparams eye_black = sdfparams(\n    vec3(0.05),\n    10.,\n    1.,\n    0.05\n  );\n\n  bool do_iris = length(p - vec3(0., 0., -eye_rad)) < iris_rad;\n\n  sdfparams mat;\n\n  if (blink == 1.0) {\n    mat = head_mat;\n  } else {\n    if (do_iris) {\n      mat = eye_black;\n    } else {\n      mat = eye_white;\n    }\n  }\n\n  sdf l = sdf_sphere(\n    p, eye_rad,\n    mat\n  );\n\n  return l;\n}\n\nsdf eyes(vec3 p, sdfparams head_mat) {\n  float blink = ceil(max(sin(iTime * 1.5) * 150. - 149., 0.));\n  float glance = floor(sin(iTime) * 0.55 + 0.5);\n\n  vec3 offs = vec3(0.21, 0., 0.);\n\n  vec3 lp = p;\n  lp /= vec3(1., 1.05, 1.);\n  lp += offs;\n  lp = erot(lp, vec3(0., 1., 0.), glance * 0.5);\n\n  vec3 rp = p;\n  rp /= vec3(1., 0.95, 1.);\n  rp -= offs;\n  rp = erot(rp, vec3(0., 1., 0.), glance * 0.5);\n\n  sdf leye = eye(lp, blink, 0.25, 0.06, head_mat);\n  leye.d *= 1.05;\n  sdf reye = eye(rp, blink, 0.2, 0.045, head_mat);\n  reye.d *= 0.95;\n\n  return sdf_union(leye, reye);\n}\n\nsdf ear(vec3 p, float wiggle, float m, sdfparams mat) {\n  vec3 np = p;\n  np = erot(np, vec3(0., 1., 0.), 0.25 * m);\n  np = erot(np, vec3(1., 0., 0.), wiggle);\n  np -= vec3(0., -0.75, 0.);\n  np = erot(np, vec3(0., 0., 1.), 3.14 / 3. * m);\n  np /= vec3(1., 1., .5);\n\n  sdf c = sdf_cylinder(\n    np,\n    0.5, 0.0,\n    mat\n  );\n  c.d *= 0.5;\n  c.d -= 0.025;\n\n  return c;\n}\n\nsdf ears(vec3 p, sdfparams mat) {\n  float ltime = iTime + 8.;\n  float rtime = iTime - 10.;\n  float lwiggle = max(fract(-ltime / 4.) * 3. - 2., 0.) * sin(ltime / 4. * 6.28 * 8.);\n  float rwiggle = max(fract(-rtime / 5.) * 4. - 3., 0.) * sin(rtime / 5. * 6.28 * 8.);\n\n  vec3 offs = vec3(1., 0., 0.);\n\n  sdf lear = ear(p - offs, lwiggle * 0.5, 1., mat);\n  sdf rear = ear(p + offs, rwiggle * 0.5, -1., mat); // haha\n\n  return sdf_union(lear, rear);\n}\n\nsdf head_base(vec3 p, sdfparams mat) {\n  sdf s = sdf_sphere(\n    p - vec3(0., -0.1, 0.),\n    1.,\n    mat\n  );\n\n  sdf c = sdf_cylinder(\n    p - vec3(0., 0.6, 0.4),\n    0.3, 0.5,\n    mat\n  );\n\n  c.d -= 0.5;\n\n  return sdf_smooth_union(s, c, 0.25);\n}\n\nsdf head(vec3 p, float wool_wiggle, sdfparams head_mat) {\n  vec3 np = p;\n  np = erot(np, vec3(0., 0., 1.), wool_wiggle * 0.015);\n\n  sdf head = head_base(np, head_mat);\n  sdf eyes = eyes(np - vec3(0., 0.9, -0.35), head_mat);\n  sdf ears = ears(np - vec3(0., 1.4, 0.5), head_mat);\n\n  return sdf_union(\n    sdf_smooth_union(head, ears, 0.1),\n    eyes\n  );\n}\n\nsdf leg(vec3 p, sdfparams wool_mat, sdfparams skin_mat) {\n  p -= vec3(0., 1.25, 0.);\n\n  sdf leg = sdf_cylinder(\n    p,\n    0.125, 1.25,\n    skin_mat\n  );\n\n  sdf thing = sdf_cylinder(\n    p - vec3(0., 1.25, 0.),\n    0.2, 0.4,\n    wool_mat\n  );\n\n  vec3 fp = p;\n  fp /= vec3(1., 1., 1.1);\n  fp -= vec3(0., -1.1, -0.1);\n\n  sdf foot = sdf_cylinder(\n    fp,\n    0.2, 0.05,\n    skin_mat\n  );\n\n  foot.d /= 1.1;\n  foot.d -= 0.05;\n\n  return sdf_union(sdf_smooth_union(leg, foot, 0.25), thing);\n}\n\nsdf legs(vec3 p, sdfparams wool_mat, sdfparams skin_mat) {\n  vec3 np = vec3(abs(p.x), p.yz);\n  np -= vec3(1., 0., 0.);\n\n  sdf front = leg(np, wool_mat, skin_mat);\n  sdf back = leg(np - vec3(0., 0., 2.5), wool_mat, skin_mat);\n\n  return sdf_union(front, back);\n}\n\nsdf owen(vec3 p) {\n  sdfparams skin_mat = sdfparams(\n    vec3(0.1),\n    20.,\n    1.,\n    0.03\n  );\n\n  sdfparams wool_mat = sdfparams(\n    vec3(0.95),\n    10.,\n    1.,\n    0.1\n  );\n\n  vec3 np = p;\n  np -= vec3(0., 4.2, 0.);\n\n  float wool_wiggle = max(sin(iTime * 1.5), 0.) * sin(iTime * 12.);\n\n  vec3 head_p = np;\n  head_p -= vec3(0., sin(iTime / 3.) * 0.4 - 0.25, -2.);\n  head_p = erot(head_p, vec3(0., 0., 1.), sin(iTime / 1.5) * 0.1);\n  head_p += vec3(0., 0.25, 0.);\n\n  sdf h = head(head_p, wool_wiggle, skin_mat);\n\n  sdf w = wool(\n    np - vec3(0., sin(iTime / 2. + 1.) * 0.1, 1.),\n    wool_wiggle,\n    wool_mat\n  );\n\n  sdf l = legs(\n    p - vec3(0., 0., -0.25),\n    wool_mat,\n    skin_mat\n  );\n\n  return sdf_union(h, sdf_smooth_union(w, l, 0.5));\n}\n\nsdf scene(vec3 p) {\n  sdfparams ground_mat = sdfparams(\n    vec3(0.1, 0.8, 0.1),\n    10.,\n    1.,\n    0.1\n  );\n\n  sdf o = owen(p - vec3(0., 0., -1.));\n  sdf g = sdf_cylinder(\n    p,\n    5., 0.,\n    ground_mat\n  );\n\n  return sdf_union(o, g);\n}\n\nray raymarch(vec3 ro, vec3 rd) {\n  ray r = ray(\n    ro,\n    false,\n    0.,\n    0,\n    vec3(0.),\n    0.,\n    0.,\n    0.\n  );\n\n  for (int i = 0; i < ITERS_MAX; i++) {\n    sdf s = scene(r.p);\n    r.p += rd * s.d;\n    r.len += s.d;\n    r.iters = i;\n    r.c = s.p.c;\n    r.shin = s.p.shin;\n    r.diffr = s.p.diffr;\n    r.specr = s.p.specr;\n\n    if (s.d < DIST_MIN) {\n      r.hit = true;\n      break;\n    }\n    if (r.len > DIST_MAX) {\n      break;\n    }\n  }\n\n  return r;\n}\n\nvec3 norm(ray r) {\n  sdf s = scene(r.p);\n  vec2 eps = vec2(NORM_EPSILON, 0.);\n\n  return normalize(s.d - vec3(\n    scene(r.p - eps.xyy).d,\n    scene(r.p - eps.yxy).d,\n    scene(r.p - eps.yyx).d\n  ));\n}\n\nvec3 _diffuse(ray r, plight l, vec3 lv, vec3 n) {\n  return max(dot(lv, n), 0.) * r.c * l.c;\n}\n\nvec3 _specular(ray r, plight l, vec3 lv, vec3 n, vec3 rd) {\n  vec3 ref = reflect(lv, n);\n  return pow(max(dot(ref, rd), 0.), r.shin) * l.c;\n}\n\nvec3 singular_light(ray r, plight l, vec3 rd) {\n  vec3 n = norm(r);\n  vec3 lv = normalize(l.p - r.p);\n\n  return r.diffr * _diffuse(r, l, lv, n) + r.specr * _specular(r, l, lv, n, rd);\n}\n\nvec3 light(ray r, vec3 rd, vec3 amb) {\n  plight l1 = plight(\n    vec3(1., 1., -1.) * 8.,\n    vec3(1., 0.7, 0.5)\n  );\n\n  plight l2 = plight(\n    vec3(-1., -1., -1.) * 16.,\n    vec3(0.9, 0.9, 1.) * 0.25\n  );\n\n  plight l3 = plight(\n    vec3(0., 0., 1.) * 32.,\n    vec3(1., 1., 1.) * 0.75\n  );\n\n  vec3 c = amb;\n  c += singular_light(r, l1, rd);\n  c += singular_light(r, l2, rd);\n  c += singular_light(r, l3, rd);\n\n  return c;\n}\n\nvec3 cam(vec3 p) {\n  p = erot(p, vec3(1., 0., 0.), 0.2 + sin(iTime / 3.) * 0.1);\n  p = erot(p, vec3(0., 1., 0.), sin(iTime / 2.) * 0.25);\n  //p = erot(p, vec3(1., 0., 0.), sin(time * 2.));\n  //p = erot(p, vec3(0., 1., 0.), time);\n\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n  vec3 ro = vec3(0., 3., -12.);\n  vec3 rd = normalize(vec3(uv, 1.));\n\n  ro = cam(ro);\n  rd = cam(rd);\n\n  ray r = raymarch(ro, rd);\n\n  vec3 fg = light(r, rd, vec3(.01, 0.025, 0.025));\n  vec3 bg = vec3(0.5, 0.8, 0.8);\n\n  vec3 col = r.hit ? fg : bg;\n\n  fragColor = vec4(sqrt(col), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}