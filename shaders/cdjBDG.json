{
    "Shader": {
        "info": {
            "date": "1690084188",
            "description": "2023 SWS3005 Group 06.\nThe romance of light, shadow, and gems in NUS.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdjBDG",
            "likes": 1,
            "name": "NUS Disco Room",
            "published": 3,
            "tags": [
                "raytracing",
                "sws3005"
            ],
            "usePreview": 1,
            "username": "snowcharm",
            "viewed": 185
        },
        "renderpass": [
            {
                "code": "//============================================================================\n// GROUP NUMBER: 06\n//\n// STUDENT NAME: CAI YUQIN\n// NUS User ID.: t0930312\n//\n// STUDENT NAME: QIU YILUN\n// NUS User ID.: t0930195\n//\n// STUDENT NAME: YANG XUAN\n// NUS User ID.: t0929996\n//\n// COMMENTS TO GRADER:\n// Due to time constraints, the coding style of our program may not be optimal. \n// However, we have ensured the consistency of variable naming and added comments \n// where appropriate to maximize the readability of the code. \n// I believe our code is easy to understand.\n//\n//============================================================================\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\nconst float SIN_30 = 0.5;\nconst float COS_30 = 0.86602540378;\nconst float BLOCK_NUM = 4.0;\nconst float BLOCK_LENGTH = 0.45;\nconst vec3 BACKGROUND_COLOR = vec3(1.0, 1.0, 0.3);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 23;\nconst int NUM_PLANES = 6;\nconst int NUM_CYLINDERS = 4;\nconst int NUM_SPHERES = 8;\nconst int NUM_TRIANGLES = 12;\nconst int NUM_BOXS = 9;\n\n// Time for the prelude\nconst float PRELUDE_TIME = 11.0;\n\nstruct Ray_t {\n    vec3 o; // Ray origin\n    vec3 d; // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center; // Sphere center\n    float radius; // Sphere radius\n    int materialID;\n};\n\nstruct Cylinder_t {\n    vec3 center; // Cylinder center\n    float radius; // Cylinder radius\n    float height; // Cylinder height\n    int materialID;\n};\n\nstruct Triangle_t {\n    vec3 v0, v1, v2; // Three triangle vertexes\n    int materialID;\n};\n\nstruct Box_t {\n    vec3 radius; // Box raidus\n    int materialID;\n    mat4 M; // transform matrix\n};\n\nstruct Light_t {\n    vec3 position; // Point light 3D position.\n    vec3 I_a; // For Ambient.\n    vec3 I_source; // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCylinder_t Cylinder[NUM_CYLINDERS];\nTriangle_t Diamond[NUM_TRIANGLES];\nBox_t Box[NUM_BOXS];\nBox_t Platform;\nSphere_t Ball;\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// Generate transform matrix for the box\nmat4 GenerateTransformMatrix(vec3 tranlate, float theta) {\n    return mat4(vec4(cos(theta / 180.0 * PI), 0, sin(theta / 180.0 * PI), 0), vec4(0, 1, 0, 0), vec4(-sin(theta / 180.0 * PI), 0, cos(theta / 180.0 * PI), 0), vec4(0, 0, 0, 1)) * mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, 0), vec4(tranlate, 1));\n}\n\n// Set the parameters of the material\nvoid setMaterial(in vec3 k_d, in vec3 k_a, in vec3 k_r, in vec3 k_rg, in float n, inout Material_t material_out) {\n    material_out.k_d = k_d;\n    material_out.k_a = k_a;\n    material_out.k_r = k_r;\n    material_out.k_rg = k_rg;\n    material_out.n = n;\n}\n\n// Set the parameters of the box\nvoid setBox(in vec3 radius, in int materialID, in mat4 matrix, inout Box_t box_out) {\n    box_out.radius = radius;\n    box_out.materialID = materialID;\n    box_out.M = matrix;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene() {\n    // Six planes form a closed space for the scene\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 5.0;\n    Plane[1].materialID = 3;\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 5.0;\n    Plane[2].materialID = 4;\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 1.0;\n    Plane[3].D = -5.0;\n    Plane[3].materialID = 5;\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = -5.0;\n    Plane[4].materialID = 2;\n    Plane[5].A = 0.0;\n    Plane[5].B = 1.0;\n    Plane[5].C = 0.0;\n    Plane[5].D = -9.0;\n    Plane[5].materialID = 3;\n\n    // Set the paramters of 4 cylinders\n    Cylinder[0].center = vec3(4.0, -0.5, 4.0);\n    Cylinder[0].radius = 0.3;\n    Cylinder[0].height = 10.0;\n    Cylinder[0].materialID = 3;\n    Cylinder[1].center = vec3(-4.0, -0.5, 4.0);\n    Cylinder[1].radius = 0.3;\n    Cylinder[1].height = 10.0;\n    Cylinder[1].materialID = 3;\n    Cylinder[2].center = vec3(4.0, -0.5, -4.0);\n    Cylinder[2].radius = 0.3;\n    Cylinder[2].height = 10.0;\n    Cylinder[2].materialID = 3;\n    Cylinder[3].center = vec3(-4.0, -0.5, -4.0);\n    Cylinder[3].radius = 0.3;\n    Cylinder[3].height = 10.0;\n    Cylinder[3].materialID = 3;\n\n    // Set the paramters of the platform\n    mat4 tranform_matrix = GenerateTransformMatrix(vec3(0.0, 0.0, 0.0), 0.0);\n    Platform.radius = vec3(0.8, 0.8, 0.8);\n    Platform.materialID = 4;\n    Platform.M = tranform_matrix;\n\n    // Set the paramters of the central ball\n    Ball.center = vec3(0.0, 3.25 + abs(0.5 * sin(iTime)), 0.0);\n    Ball.radius = 0.4;\n    Ball.materialID = 1;\n\n    // Set the paramters of 9 boxes in the wall\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -2.5, 2.0), 90.0);\n    float height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 6, tranform_matrix, Box[0]);\n    //center\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -2.5, 0.0), 90.0);\n    height = (texture(iChannel0, vec2(0.01, 0.25)).x - 0.8) * 8.0;\n    setBox(vec3(0.5, 0.51, height), 7, tranform_matrix, Box[1]);\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -2.5, -2.0), 90.0);\n    height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 8, tranform_matrix, Box[2]);\n    //corner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -4.5, 2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 9, tranform_matrix, Box[3]);\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -4.5, 0.0), 90.0);\n    height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 10, tranform_matrix, Box[4]);\n    //corner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -4.5, -2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 11, tranform_matrix, Box[5]);\n    //corner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -0.5, 2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 12, tranform_matrix, Box[6]);\n    //mid\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -0.5, 0.0), 90.0);\n    height = texture(iChannel0, vec2(0.07, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 13, tranform_matrix, Box[7]);\n    //coner\n    tranform_matrix = GenerateTransformMatrix(vec3(5.0, -0.5, -2.0), 90.0);\n    height = texture(iChannel0, vec2(0.30, 0.25)).x * 2.0;\n    setBox(vec3(0.5, 0.51, height), 14, tranform_matrix, Box[8]);\n\n    // Set the paramters of the diamond\n    Diamond[0].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[0].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[0].v2 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[1].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[1].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[1].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[2].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[2].v1 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[2].v2 = vec3(-0.6, 2.8, 0.0);\n    Diamond[3].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[3].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[3].v2 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[4].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[4].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[4].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[5].v0 = vec3(0.0, 1.0, 0.0);\n    Diamond[5].v1 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[5].v2 = vec3(-0.6, 2.8, 0.0);\n    Diamond[6].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[6].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[6].v2 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[7].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[7].v1 = vec3(0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[7].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[8].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[8].v1 = vec3(-0.6 * SIN_30, 2.8, 0.6 * COS_30);\n    Diamond[8].v2 = vec3(-0.6, 2.8, 0.0);\n    Diamond[9].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[9].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[9].v2 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[10].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[10].v1 = vec3(0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[10].v2 = vec3(0.6, 2.8, 0.0);\n    Diamond[11].v0 = vec3(0.0, 2.8, 0.0);\n    Diamond[11].v1 = vec3(-0.6 * SIN_30, 2.8, -0.6 * COS_30);\n    Diamond[11].v2 = vec3(-0.6, 2.8, 0.0);\n    for(int i = 0; i < NUM_TRIANGLES; i++) {\n        Diamond[i].materialID = 1;\n    }\n\n    // Set the paramters of 8 spheres\n    Sphere[0].center = vec3(0.7 + abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.0);\n    Sphere[1].center = vec3(-0.7 - abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.0);\n    Sphere[2].center = vec3(0.0, 3.5 - 2.2 * abs(cos(iTime)), 0.7 + abs(cos(iTime)));\n    Sphere[3].center = vec3(0.0, 3.5 - 2.2 * abs(cos(iTime)), -0.7 - abs(cos(iTime)));\n    Sphere[4].center = vec3(0.7 + abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.7 + abs(cos(iTime)));\n    Sphere[5].center = vec3(-0.7 - abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), 0.7 + abs(cos(iTime)));\n    Sphere[6].center = vec3(0.7 + abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), -0.7 - abs(cos(iTime)));\n    Sphere[7].center = vec3(-0.7 - abs(cos(iTime)), 3.5 - 2.2 * abs(cos(iTime)), -0.7 - abs(cos(iTime)));\n    for(int i = 0; i < NUM_SPHERES; i++) {\n        Sphere[i].radius = 0.2;\n        Sphere[i].materialID = i + 15;\n    }\n\n    // Set the paramters of different materials (some are not used)\n    setMaterial(vec3(0.5), vec3(0.1), vec3(1.0), vec3(0.5), 64.0, Material[1]);\n    setMaterial(vec3(0.0, 0.2, 0.2), vec3(0.0, 0.08, 0.08), vec3(0.0, 0.6, 0.6), vec3(0.0, 0.12, 0.12), 64.0, Material[2]);\n    setMaterial(vec3(0.5), vec3(0.1), vec3(1.0), vec3(0.1), 64.0, Material[3]);\n    setMaterial(vec3(0.0, 0.0, 0.0), vec3(0.25164, 0.60648, 0.22648), vec3(0.90, 0.91, 0.99), vec3(0.3), 1.0, Material[4]);\n    setMaterial(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, Material[5]);\n    setMaterial(vec3(0.0, 0.0, 1.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[6]);\n    setMaterial(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[7]);\n    setMaterial(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[8]);\n    setMaterial(vec3(1.0, 0.0, 1.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[9]);\n    setMaterial(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[10]);\n    setMaterial(vec3(0.2, 0.6, 0.8), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[11]);\n    setMaterial(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[12]);\n    setMaterial(vec3(0.8, 0.4, 0.5), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[13]);\n    setMaterial(vec3(0.3, 0.6, 0.2), vec3(0.0, 0.04, 0.04), vec3(0.0, 0.4, 0.4), vec3(0.0, 0.2, 0.2), 64.0, Material[14]);\n    setMaterial(vec3(1.5, 0.5, 0.5), vec3(0.3, 0.1, 0.1), vec3(3.0, 1.0, 1.0), vec3(1.5, 0.5, 0.5), 64.0, Material[15]);\n    setMaterial(vec3(0.614240, 0.041360, 0.041360), vec3(0.174500, 0.011750, 0.011750), vec3(0.727811, 0.626959, 0.626959), vec3(0.55, 0.55, 0.55), 128.0, Material[16]);\n    setMaterial(vec3(0.3712, 0.008640, 0.3712), vec3(0.053750, 0.001250, 0.053750), vec3(0.614240, 0.041360, 0.041360), vec3(0.55, 0.55, 0.55), 128.0, Material[17]);\n    setMaterial(vec3(0.45, 0.568627, 0.113725), vec3(0.329412, 0.223529, 0.027451), vec3(0.992157, 0.941176, 0.807843), vec3(0.4, 0.4, 0.4), 27.0, Material[18]);\n    setMaterial(vec3(0.8, 0.45, 0.1), vec3(0.24725, 0.1995, 0.0745), vec3(0.7, 0.4, 0.1), vec3(0.55, 0.55, 0.55), 51.2, Material[19]);\n    setMaterial(vec3(0.021500, 0.045500, 0.098000), vec3(0.002, 0.00425, 0.009), vec3(0.089, 0.183, 0.316), vec3(0.2, 0.2, 0.2), 256.0, Material[20]);\n    setMaterial(vec3(0.021500, 0.174500, 0.021500), vec3(0.002, 0.017, 0.002), vec3(0.075680, 0.614240, 0.075680), vec3(0.2, 0.2, 0.2), 256.0, Material[21]);\n    setMaterial(vec3(0.001440, 0.662400, 0.630240), vec3(0.00025, 0.114, 0.108), vec3(0.001440, 0.662400, 0.630240), vec3(0.55, 0.55, 0.55), 128.0, Material[22]);\n\n    // Light 0.\n    Light[0].position = vec3(0.0, 8.0, 0.0);\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(1.0, 1.0, 1.0);\n\n    // Light 1.\n    Light[1].position = vec3(-4.0, 8.0, 0.0);\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(1.0, 1.0, 1.0);\n}\n\n//Signed Distance Function of segment shape\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\n//Signed Distance Function of horsehoe shape\nfloat sdHorseshoe(in vec2 p, in vec2 c, in float r, in vec2 w) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x) * p;\n    p = vec2((p.y > 0.0 || p.x > 0.0) ? p.x : l * sign(-c.x), (p.x > 0.0) ? p.y : l);\n    p = vec2(p.x, abs(p.y - r)) - w;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n//Signed Distance Function of Letter 'N'\nfloat N_sdf(in vec2 p) {\n    vec2 offset = vec2(-2.0, 0.0);\n    float d = udSegment(p - offset, vec2(-0.6, 1.0), vec2(-0.6, 3.0)) - 0.1;\n    float d1 = udSegment(p - offset, vec2(-0.6, 3.0), vec2(0.6, 1.0)) - 0.1;\n    float d2 = udSegment(p - offset, vec2(0.6, 1.0), vec2(0.6, 3.0)) - 0.1;\n    return min(d2, min(d, d1));\n}\n\n//Signed Distance Function of Letter 'U'\nfloat U_sdf(in vec2 p) {\n    float d = udSegment(p, vec2(-0.6, 1.6), vec2(-0.6, 3.0)) - 0.1;\n    float d1 = sdHorseshoe(p - vec2(0.0, 1.6), vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.1, 0.1));\n    float d2 = udSegment(p, vec2(0.6, 1.6), vec2(0.6, 3.0)) - 0.1;\n    return min(d2, min(d, d1));\n}\n\n////Signed Distance Function of Letter 'S'\nfloat S_sdf(in vec2 p) {\n    vec2 offset = vec2(2.0, 0.0);\n    float d1 = udSegment(p - offset, vec2(-0.6, 1.0), vec2(0.2, 1.0)) - 0.1;\n    float d2 = udSegment(p - offset, vec2(-0.2, 3.0), vec2(0.6, 3.0)) - 0.1;\n    float d3 = udSegment(p - offset, vec2(-0.2, 2.0), vec2(0.2, 2.0)) - 0.1;\n    float d4 = sdHorseshoe(p.yx - offset.yx - vec2(2.5, -0.2), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1));\n    float d5 = sdHorseshoe(-p.yx + offset.yx - vec2(-1.5, -0.2), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1));\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between NUS and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectNUS(in vec2 p) {\n    return N_sdf(p) < 0.0 || U_sdf(p) < 0.0 || S_sdf(p) < 0.0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(\n    in Plane_t pln,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(N);\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(\n    in Sphere_t sph,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    vec3 oc = ray.o - sph.center;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discr = b * b - c;\n    if(discr >= 0.0) {\n        float sqrtd = sqrt(discr);\n        t = -b - sqrtd;\n        hitPos = ray.o + t * ray.d;\n        vec3 normal = normalize(hitPos - sph.center);\n        hitNormal = normal;\n        return (t >= tmin && t <= tmax);\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 oc = ray.o - sph.center;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discr = b * b - c;\n    if(discr >= 0.0) {\n        float sqrtd = sqrt(discr);\n        float t = -b - sqrtd;\n        return (t >= tmin && t <= tmax);\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a cylinder and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec2 rayOriInSphere = ray.o.xz - cyl.center.xz;\n    float a = dot(ray.d.xz, ray.d.xz);\n    float b = 2.0 * dot(ray.d.xz, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0)\n        return false;\n    float t1 = (-1.0 * b + sqrt(d)) / (2.0 * a);\n    float t2 = (-1.0 * b - sqrt(d)) / (2.0 * a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1 >= tmin && t1 <= tmax) {\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2 >= tmin && t2 <= tmax) {\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false)\n        return false;\n    t = finalT;\n    hitPos = ray.o + finalT * ray.d;\n    hitNormal = hitPos - cyl.center;\n    if(hitNormal.y - cyl.center.y < 0.0 || hitNormal.y - cyl.center.y > cyl.height)\n        return false;\n    hitNormal.y = 0.0;\n    hitNormal = hitNormal / cyl.radius;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a cylinder and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder(in Cylinder_t cyl, in Ray_t ray, in float tmin, in float tmax) {\n    vec2 rayOriInSphere = ray.o.xy - cyl.center.xy;\n    float a = dot(ray.d.xy, ray.d.xy);\n    float b = 2.0 * dot(ray.d.xy, rayOriInSphere);\n    float c = dot(rayOriInSphere, rayOriInSphere) - cyl.radius * cyl.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0)\n        return false;\n    float t1 = (-1.0 * b + sqrt(d)) / (2.0 * a);\n    float t2 = (-1.0 * b - sqrt(d)) / (2.0 * a);\n    float finalT;\n    bool isSatisfy = false;\n    if(t1 >= tmin && t1 <= tmax) {\n        isSatisfy = true;\n        finalT = t1;\n    }\n    if(t2 >= tmin && t2 <= tmax) {\n        isSatisfy = true;\n        finalT = t2;\n    }\n    if(isSatisfy == false)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 sco = (box.M * vec4(ray.o, 1.0)).xyz;\n    vec3 scd = normalize((transpose(inverse(box.M)) * vec4(ray.d, 1.0)).xyz);\n    vec3 m = 1.0 / scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.radius;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.y, t1.z), t1.x);\n    float tF = min(min(t2.y, t2.z), t2.x);\n    if(tN > tF || tF < 0.0)\n        return false;\n    if(tN < tmin || tN > tmax)\n        return false;\n    t = tN;\n    hitPos = (inverse(box.M) * vec4((sco + t * scd), 1.0)).xyz;\n    hitNormal = (transpose(inverse(box.M)) * vec4((-sign(ray.d) * step(t1.zxy, t1.xyz) * step(t1.yzx, t1.xyz)), 1.0)).xyz;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 sco = (box.M * vec4(ray.o, 1.0)).xyz;\n    vec3 scd = normalize((transpose(inverse(box.M)) * vec4(ray.d, 1.0)).xyz);\n    vec3 m = 1.0 / scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * box.radius;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.y, t1.z), t1.x);\n    float tF = min(min(t2.y, t2.z), t2.x);\n    if(tN > tF || tF < 0.0)\n        return false;\n    if(tN < tmin || tN > tmax)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle(in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 e1 = tri.v1 - tri.v0;\n    vec3 e2 = tri.v2 - tri.v0;\n    vec3 s = ray.o - tri.v0;\n    vec3 s1 = cross(ray.d, e2);\n    vec3 s2 = cross(s, e1);\n    float s1e1 = dot(s1, e1);\n    float s2e2 = dot(s2, e2);\n    float s1s = dot(s1, s);\n    float s2d = dot(s2, ray.d);\n    float s1e1_inv = 1.0 / s1e1;\n    float t0 = s2e2 * s1e1_inv;\n    float t1 = s1s * s1e1_inv;\n    float t2 = s2d * s1e1_inv;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    if(t1 < 0.0 || t2 < 0.0 || t1 + t2 > 1.0)\n        return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = -abs(normalize(cross(e1, e2)));\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle(in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 e1 = tri.v1 - tri.v0;\n    vec3 e2 = tri.v2 - tri.v0;\n    vec3 s = ray.o - tri.v0;\n    vec3 s1 = cross(ray.d, e2);\n    vec3 s2 = cross(s, e1);\n    float s1e1 = dot(s1, e1);\n    float s2e2 = dot(s2, e2);\n    float s1s = dot(s1, s);\n    float s2d = dot(s2, ray.d);\n    float s1e1_inv = 1.0 / s1e1;\n    float t0 = s2e2 * s1e1_inv;\n    float t1 = s1s * s1e1_inv;\n    float t2 = s2d * s1e1_inv;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    if(t1 < 0.0 || t2 < 0.0 || t1 + t2 > 1.0)\n        return false;\n    return true;\n}\n\n// Compute the color of decorated squares\nvec3 squaresColours(vec2 p) {\n    p += vec2(iTime * 0.2);\n    vec3 orange = vec3(1.0, 0.4, 0.1) * 2.0;\n    vec3 purple = vec3(1.0, 0.2, 0.5) * 0.8;\n    float l = pow(0.5 + 0.5 * cos(p.x * 7.0 + cos(p.y) * 8.0) * sin(p.y * 2.0), 4.0) * 2.0;\n    vec3 c = pow(l * (mix(orange, purple, 0.5 + 0.5 * cos(p.x * 40.0 + sin(p.y * 10.0) * 3.0)) +\n        mix(orange, purple, 0.5 + 0.5 * cos(p.x * 20.0 + sin(p.y * 3.0) * 3.0))), vec3(1.2)) * 0.7;\n    c += vec3(1.0, 0.8, 0.4) * pow(0.5 + 0.5 * cos(p.x * 20.0) * sin(p.y * 12.0), 20.0) * 2.0;\n    c += vec3(0.1, 0.5 + 0.5 * cos(p * 20.0)) * vec3(0.05, 0.1, 0.4).bgr * 0.7;\n    return c;\n}\n\n// Compute the color for a better visual effect\nvec3 calculateColor(vec2 p, float border) {\n    float sm = 0.02;\n    vec2 res = vec2(3.5);\n    vec2 ip = floor(p * res) / res;\n    vec2 fp = fract(p * res);\n    float m = 1.0 - max(smoothstep(border - sm, border, abs(fp.x - 0.5)), smoothstep(border - sm, border, abs(fp.y - 0.5)));\n    m += 1.0 - smoothstep(0.0, 0.56, distance(fp, vec2(0.5)));\n    return m * squaresColours(ip);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    in bool inShadow,\n    in Material_t mat,\n    in Light_t light\n) {\n    if(inShadow) {\n        return light.I_a * mat.k_a;\n    } else {\n        vec3 R = reflect(-L, N);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n        return light.I_a * mat.k_a +\n            light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n// This method will also be based on the plane in which the ray hit,\n// So that the shader can present different visual effects in the different planes (walls)\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    in bool inShadow,\n    in Light_t light,\n    vec3 nearest_hitPos,\n    int hitWhichPlane\n) {\n    Material_t mat = Material[1];\n    vec2 p;\n    if(hitWhichPlane == 0 || hitWhichPlane == 5)\n        p = nearest_hitPos.xz;\n    else if(hitWhichPlane == 1 || hitWhichPlane == 3)\n        p = nearest_hitPos.xy;\n    else if(hitWhichPlane == 2 || hitWhichPlane == 4)\n        p = nearest_hitPos.yz;\n    else if(hitWhichPlane < 0) {\n        p.y = nearest_hitPos.y;\n        p.x = length(nearest_hitPos.xz);\n    }\n    p = p / BLOCK_NUM;\n    mat.k_d = calculateColor(p, BLOCK_LENGTH);\n    mat.k_a = 0.4 * mat.k_d;\n    mat.k_r = 3.0 * mat.k_d;\n    if(inShadow) {\n        return light.I_a * mat.k_a;\n    } else {\n        vec3 R = reflect(-L, N);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n        return light.I_a * mat.k_a +\n            light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(\n    in Ray_t ray,\n    out bool hasHit,\n    out vec3 hitPos,\n    out vec3 hitNormal,\n    out vec3 k_rg\n) {\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX; // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;            // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;         // Normal vector at the nearest hit point.\n    int nearest_hitMatID;           // MaterialID of the object at the nearest hit point.\n\n    // Temporary arguments\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n    int hitWhichPlane;\n    // Intersect with the plane\n    for(int i = 0; i < NUM_PLANES; i++) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n            hitWhichPlane = i;\n        }\n    }\n    // Intersect with the cylinder\n    for(int i = 0; i < NUM_CYLINDERS; i++) {\n        temp_hasHit = IntersectCylinder(Cylinder[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Cylinder[i].materialID;\n        }\n    }\n    if(iTime >= PRELUDE_TIME) { // A judgement of time for a better performance in the prelude\n        // Intersect with the sphere\n        for(int i = 0; i < NUM_SPHERES; i++) {\n            temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_hasHit && temp_t < nearest_t) {\n                hasHitSomething = true;\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n        //Intersect with the box\n        for(int i = 0; i < NUM_BOXS; i++) {\n            temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_hasHit && temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n                hasHitSomething = true;\n            }\n        }\n        // Intersect with the triangle\n        for(int i = 0; i < NUM_TRIANGLES; i++) {\n            temp_hasHit = IntersectTriangle(Diamond[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n            if(temp_hasHit && temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Diamond[i].materialID;\n                hasHitSomething = true;\n            }\n        }\n        // Intersect with the platform\n        temp_hasHit = IntersectBox(Platform, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Platform.materialID;\n            hasHitSomething = true;\n        }\n        // Intersect with the central ball\n        temp_hasHit = IntersectSphere(Ball, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Ball.materialID;\n            hasHitSomething = true;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if(!hasHitSomething)\n        return BACKGROUND_COLOR;\n\n    /* Drawing NUS in the plane*/\n    vec2 p = nearest_hitPos.xy;\n    if(hitWhichPlane == 3) { // Judge an intersection in a special plane (for drawing)\n        if(iTime < 3.0) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 2.0 + iTime * (2.0 / 3.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 4.0 - iTime * (1.4 / 3.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n\n        } else if(iTime < 6.0 && iTime >= 3.0) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(3.5, 4.0), vec2(3.5 - (iTime - 3.0) * (2.0 / 3.0), 6.0 - iTime * (2.0 / 3.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 2.6)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p - vec2(-0.1, 2.5), vec2(cos(1.6 * (iTime - 3.0) / 3.0), sin(1.6 * (iTime - 3.0) / 3.0)), 0.6, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 6.0 && iTime < 10.0) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(3.5, 4.0), vec2(1.5, 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(1.5, 2.0), vec2(1.5, 2.0 + (iTime - 6.0) / 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 2.6)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p - vec2(-0.1, 2.5), vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-0.7, 2.6), vec2(-0.7, 2.6 + (iTime - 6.0) * (1.4 / 4.0))) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 10.0 && iTime < PRELUDE_TIME) {\n            if((udSegment(p, vec2(3.5, 2.0), vec2(3.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(3.5, 4.0), vec2(1.5, 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(1.5, 2.0), vec2(1.5, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(0.5, 4.0), vec2(0.5, 2.6)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p - vec2(-0.1, 2.5), vec2(cos(1.6), sin(1.6)), 0.6, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-0.7, 2.6), vec2(-0.7, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else {\n            Material[5].k_d = Material[1].k_d;\n            Material[5].k_a = Material[1].k_a;\n            Material[5].k_r = Material[1].k_r;\n            Material[5].k_rg = Material[1].k_rg;\n            Material[5].n = Material[1].n;\n        }\n    }\n    if(hitWhichPlane == 3) {\n        if(iTime < 2.0) {\n            if((udSegment(p, vec2(-3.1 + iTime * (0.9 / 2.0), 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 2.0 && iTime < 4.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6 * (iTime - 2.0) / 2.0), sin(1.6) * (iTime - 2.0) / 2.0), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 4.0 && iTime < 6.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.2, 3.0), vec2(-2.2 - (iTime - 4.0) * (0.9 / 2.0), 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 6.0 && iTime < 8.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.1, 3.0), vec2(-3.1, 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p.yx - vec2(2.5, -3.1), vec2(cos(1.6 * (iTime - 6.0) / 2.0), sin(1.6) * (iTime - 6.0) / 2.0), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 8.0 && iTime < 10.0) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.2, 3.0), vec2(-3.1, 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p.yx - vec2(2.5, -3.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-3.1, 2.0), vec2(-3.1 + (iTime - 8.0) * (1.2 / 2.0), 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else if(iTime >= 10.0 && iTime < PRELUDE_TIME) {\n            if((udSegment(p, vec2(-2.2, 4.0), vec2(-3.1, 4.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(-p.yx + vec2(3.5, -2.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-2.2, 3.0), vec2(-3.1, 3.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if(sdHorseshoe(p.yx - vec2(2.5, -3.1), vec2(cos(1.6), sin(1.6)), 0.5, vec2(0.1, 0.1)) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            } else if((udSegment(p, vec2(-3.1, 2.0), vec2(-3.1 + (10.0 - 8.0) * (1.2 / 2.0), 2.0)) - 0.1) < 0.0) {\n                nearest_hitNormal = vec3(0.0, 0.0, -1.0);\n                Material[5].k_d = vec3(0.6, 0.4, 0.5);\n                Material[5].k_a = 0.0 * Material[2].k_d;\n                Material[5].k_r = 0.0 * Material[2].k_d;\n                Material[5].k_rg = 0.0 * Material[2].k_r;\n                Material[5].n = 128.0;\n            }\n        } else {\n            Material[5].k_d = Material[1].k_d;\n            Material[5].k_a = Material[1].k_a;\n            Material[5].k_r = Material[1].k_r;\n            Material[5].k_rg = Material[1].k_rg;\n            Material[5].n = Material[1].n;\n        }\n    }\n    if(hitWhichPlane == 4) {\n        if(IntersectNUS(nearest_hitPos.zy)) {\n            nearest_hitNormal = vec3(-1.0, 0.0, 0.0);\n            Material[2].k_d = vec3(0.9, 0.8, 0.0);\n            Material[2].k_a = 0.0 * Material[2].k_d;\n            Material[2].k_r = 0.0 * Material[2].k_d;\n            Material[2].k_rg = 0.0 * Material[2].k_r;\n            Material[2].n = 128.0;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n    vec3 I_local = vec3(0.0); // Result color will be accumulated here.\n    Ray_t shadowRay;\n    shadowRay.o = nearest_hitPos;\n    for(int i = 0; i < NUM_LIGHTS; i++) {\n        bool inShadow = false, tempInShadow;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        float LineSegmentMin = DEFAULT_TMIN;\n        float LineSegmentMax = length(Light[i].position - nearest_hitPos);\n        if(iTime >= PRELUDE_TIME) {\n            for(int j = 0; j < NUM_SPHERES; j++) {\n                if(inShadow)\n                    break;\n                tempInShadow = IntersectSphere(Sphere[j], shadowRay, LineSegmentMin, LineSegmentMax);\n                if(tempInShadow)\n                    inShadow = true;\n            }\n            for(int j = 0; j < NUM_BOXS; j++) {\n                if(inShadow)\n                    break;\n                tempInShadow = IntersectBox(Box[j], shadowRay, LineSegmentMin, LineSegmentMax);\n                if(tempInShadow)\n                    inShadow = true;\n            }\n            for(int j = 0; j < NUM_TRIANGLES; j++) {\n                if(inShadow)\n                    break;\n                tempInShadow = IntersectTriangle(Diamond[j], shadowRay, LineSegmentMin, LineSegmentMax);\n                if(tempInShadow)\n                    inShadow = true;\n            }\n            tempInShadow = IntersectBox(Platform, shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n            tempInShadow = IntersectSphere(Ball, shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n        }\n        for(int j = 0; j < NUM_PLANES; j++) {\n            if(inShadow)\n                break;\n            tempInShadow = IntersectPlane(Plane[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n        }\n        for(int j = 0; j < NUM_CYLINDERS; j++) {\n            if(inShadow)\n                break;\n            tempInShadow = IntersectCylinder(Cylinder[j], shadowRay, LineSegmentMin, LineSegmentMax);\n            if(tempInShadow)\n                inShadow = true;\n        }\n        vec3 L = normalize(Light[i].position - nearest_hitPos);\n        vec3 N = normalize(nearest_hitNormal);\n        vec3 V = normalize(-ray.d);\n        if(nearest_hitMatID == 3) {\n            I_local += PhongLighting(L, N, V, inShadow, Light[i], nearest_hitPos, hitWhichPlane);\n        } else {\n            I_local += PhongLighting(L, N, V, inShadow, Material[nearest_hitMatID], Light[i]);\n        }\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    return I_local;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera (animation)\n    vec3 cam_pos, cam_lookat, cam_up_vec;\n    if(iTime < PRELUDE_TIME) {\n        cam_pos = vec3(0, 3.1, -1.5);\n        cam_lookat = vec3(0.0, 3.1, 5.0);\n        cam_up_vec = vec3(0.0, 1.0, 0.0);\n    } else {\n        float time = iTime - PRELUDE_TIME;\n        if(mod((time / 20.0), 2.0) >= 1.0 && time > 20.0) {\n            cam_pos = vec3(3.5 * cos(time * 0.3), 5.0, 3.5 * sin(time * 0.3));\n            cam_lookat = vec3(0.0, 2.0 + cos(time), 0.0);\n            cam_up_vec = vec3(0.0, 1.0, 0.0);\n        } else {\n            cam_pos = vec3(0, 5.0, 0);\n            cam_lookat = vec3(5.0 * sin(time * 0.3), 2.0, 5.0 * cos(time * 0.3));\n            cam_up_vec = vec3(0.0, 1.0, 0.0);\n        }\n    }\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis + pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 I_result = vec3(0.0);\n    vec3 compounded_k_rg = vec3(1.0);\n    Ray_t nextRay = pRay;\n    for(int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        vec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n        I_result += compounded_k_rg * I_local;\n        if(!hasHit)\n            break;\n        compounded_k_rg *= k_rg;\n        nextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n    }\n    fragColor = vec4(I_result, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}