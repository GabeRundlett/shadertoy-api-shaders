{
    "Shader": {
        "info": {
            "date": "1567869303",
            "description": "you can drag left/right to control roughness\nopen using CineShader: https://cineshader.com/view/3sc3z4",
            "flags": 0,
            "hasliked": 0,
            "id": "3sc3z4",
            "likes": 96,
            "name": "GLSL ray tracing test",
            "published": 3,
            "tags": [
                "raytracing",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "colin299",
            "viewed": 277523
        },
        "renderpass": [
            {
                "code": "//drag the window LR to control roughness\n\n//--graphics setting (lower = better fps)---------------------------------------------------------------------\n#define AVERAGECOUNT 16\n#define MAX_BOUNCE 32\n\n//--scene data---------------------------------------------------------------------\n#define SPHERECOUNT 6\n//xyz = pos, w = radius\nconst vec4 AllSpheres[SPHERECOUNT]=vec4[SPHERECOUNT](\n    vec4(0.0,0.0,0.0,2.0),//sphere A\n    vec4(0.0,0.0,-1.0,2.0),//sphere B\n    vec4(0.0,-1002.0,0.0,1000.0),//ground\n    vec4(0.0,0.0,+1002,1000.0),//back wall\n    vec4(-1004.0,0.0,0.0,1000.0),//left wall    \n    vec4(+1004.0,0.0,0.0,1000.0)//right wall\n);\n//-----------------------------------------------------------------------\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n//-----------------------------------------------------------------------\nstruct HitData\n{\n    float rayLength;\n    vec3 normal;\n};\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)\n{\n    HitData hitData;\n    hitData.rayLength = 9999.0; //default value if can't hit anything\n\n    for(int i = 0; i < SPHERECOUNT; i++)\n    {\n        vec3 sphereCenter = AllSpheres[i].xyz;\n        float sphereRadius = AllSpheres[i].w;\n        //----hardcode sphere pos animations-------------------------------------\n        if(i == 0)\n        {\n            float t = fract(iTime * 0.7);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 0.7;\n            \n            sphereCenter.x += sin(iTime) * 2.0;\n            sphereCenter.z += cos(iTime) * 2.0;\n        }\n             \n        if(i == 1)\n        {\n            float t = fract(iTime*0.47);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 1.7;\n            \n            sphereCenter.x += sin(iTime+3.14) * 2.0;\n            sphereCenter.z += cos(iTime+3.14) * 2.0;\n        }             \n        //---------------------------------------\n                \n        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);\n        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)\n        {\n            //if a shorter(better) hit ray found, update\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n    \t\thitData.normal = normalize(hitPos - sphereCenter);\n        }\n    }\n    \n    //all test finished, return shortest(best) hit data\n    return hitData;\n}\n//--random functions-------------------------------------------------------------------\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)\n{\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n//---------------------------------------------------------------------\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex)\n{\n    //init\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n    \n    //only for CineShader, to show depth\n    float firstHitRayLength = -1.0;\n    \n    //can't write recursive function in GLSL, so write it in a for loop\n    //will loop until hitting any light source / bounces too many times\n    for(int i = 0; i < MAX_BOUNCE; i++)\n    {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001,rayDir);//+0.0001 to prevent ray already hit at start pos\n        \n        //only for CineShader, to show depth\n        firstHitRayLength = firstHitRayLength < 0.0 ? h.rayLength : firstHitRayLength;\n               \n        //if ray can't hit anything, rayLength will remain default value 9999.0\n        //which enters this if()\n        //** 99999 is too large for mobile, use 9900 as threshold now **\n        if(h.rayLength >= 9900.0)\n        {\n            vec3 skyColor = vec3(0.7,0.85,1.0);//hit nothing = hit sky color\n            finalColor = skyColor * absorbMul;\n            break;\n        }   \n               \n\t\tabsorbMul *= 0.8; //every bounce absorb some light(more bounces = darker)\n        \n        //update rayStartPos for next bounce\n\t\trayStartPos = rayStartPos + rayDir * h.rayLength; \n        //update rayDir for next bounce\n        float rougness = 0.05 + iMouse.x / iResolution.x; //hardcode \"drag the window LR to control roughness\"\n\t\trayDir = normalize(reflect(rayDir,h.normal) + randomInsideUnitSphere(rayDir,rayStartPos,AAIndex) * rougness);       \n    }\n    \n    return vec4(finalColor,firstHitRayLength);//alpha nly for CineShader, to show depth\n}\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; //aspect fix\n\n    vec3 cameraPos = vec3(sin(iTime * 0.47) * 4.0,sin(iTime * 0.7)*8.0+6.0,-25.0);//camera pos animation\n    vec3 cameraFocusPoint = vec3(0,0.0 + sin(iTime),0);//camera look target point animation\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n    \n    //TEMPCODE: fov & all ray init dir, it is wrong!!!!\n    //----------------------------------------------------\n    float fovTempMul = 0.2 + sin(iTime * 0.4) * 0.05;//fov animation\n    vec3 rayDir = normalize(cameraDir + vec3(uv,0) * fovTempMul);\n    //----------------------------------------------------\n\n    vec4 finalColor = vec4(0);\n    for(int i = 1; i <= AVERAGECOUNT; i++)\n    {\n        finalColor+= calculateFinalColor(cameraPos,rayDir, float(i));\n    }\n    finalColor = finalColor/float(AVERAGECOUNT);//brute force AA & denoise\n    finalColor.rgb = pow(finalColor.rgb,vec3(1.0/2.2));//gamma correction\n    \n    //only for CineShader, to show depth\n    float z = finalColor.w; //z is linear world space distance from camera to surface\n    float cineShaderZ; //expect 0~1\n    cineShaderZ = pow(clamp(1.0 - max(0.0,z-21.0) * (1.0/6.0),0.0,1.0),2.0);\n    \n    //result\n    fragColor = vec4(finalColor.rgb,cineShaderZ);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}