{
    "Shader": {
        "info": {
            "date": "1539894423",
            "description": "mouse input!\n\nnice small canvas to show intersection of ray2lineSegment\ncathing div0 nicely\npretty sure there is a way to catch cases where eay misses line\n, with less sqrt() and segment() than InterWall() contains",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdBWM",
            "likes": 1,
            "name": "inter-wall   help please",
            "published": 3,
            "tags": [
                "transparency",
                "ray",
                "grid",
                "intersection",
                "checkerboard",
                "transparent",
                "compositing",
                "linesegment"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 586
        },
        "renderpass": [
            {
                "code": "//all code is in common tab\n\nvoid mainImage( out vec4 o, in vec2 u\n){o=imageEntry(u,iMouseZwFix(iMouse,true),iResolution.xy,iTime)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n//https://www.shadertoy.com/view/MtdBWM\n\n\n#define tiny .0001\n\n#define vec1 float\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n//#define ss(a,u)smoothstep(a,-a,u)//bad namespace for this,more trouble than its worth\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\nfloat ma(vec2 a){return max(a.x,a.y);}\n\n//2d zoom\n#define ViewZoom 3.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(r.x,r.y)/ViewZoom)\n#define fra(u)(u-.5*r.xy)*ViewZoom/r.y//usually first function of mainImage(),not typecast.\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}//v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}//v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}//v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n\n\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nvec2 gLLxX0(vec2 A,vec2 B,vec2 C,vec2 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;//if (dotperp==0.)return A\n ;//dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n\n                          \n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\n\nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}//checkerboard\nvec4 checker(vec2 u){return vec4(checkerBool(u)*.5+.25);}//scaling wrapper\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(vec2 rs,vec2 r2,vec2 ls,vec2 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;vec2 ll=le-ls\n ;float c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n                          \nvec2 InterWall(vec2 rs,vec2 r2,vec2 ls,vec2 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;vec2 j=(ls+le)*.5//midpoint\n ;vec2 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n                          \nvec4 imageEntry(vec2 u,vec4 m,vec2 r,float t\n){vec4 c=vec4(0)\n ;u=fra(u)\n ;m.xy=fra(m.xy);m.zw=fra(m.zw)//mouse\n ;//c.x=length(u-m.xy) \n ;c.y=segment(u,m.xy,m.zw)//draw green segment\n ;c.z=.6-1./Aa-(ma(abs(fract(u)-.5)))-.01//grid\n ;vec4 l=vec4(vec2(0,.61),vec2(1.61,.3))//define start+end of red segment\n ;c.x=segment(u,l.xy,l.zw)//draw line segment\n ;c.w=length(InterWall(m.xy,m.zw,l.xy,l.zw)-u)\n ;c.z=min(c.z,length((l.xy+l.zw)*.5-u))//midpoint between lineegment-endpoints\n ;c=smoothstep(1./Aa,-1./Aa,c-.1)\n ;c*=.5//transparency\n ;c=pdOver(pdOver(vec4(1,1,0,1)*c.w,vec4(1,0,0,1)*c.x)\n          ,pdOver(vec4(0,1,0,1)*c.y,vec4(0,0,1,1)*c.z))//porterDuff compositing (bilinear)\n ;c=pdOver(c,checker(u))\n ;return c;}\n                          \n                          \n//all code is in common tab\n/*\nvoid mainImage( out vec4 o, in vec2 u\n){o=imageEntry(u,iMouse.xyzw,iResolution.xy,iTime)\n ;}*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}