{
    "Shader": {
        "info": {
            "date": "1521761129",
            "description": "Thinking more about how to improve sampling of SDF textures by using gradient information. \nUse mouse to toggle between lines and stipples. Looks better in fullscreen.",
            "flags": 16,
            "hasliked": 0,
            "id": "MdycWh",
            "likes": 25,
            "name": "sketchy font distance",
            "published": 3,
            "tags": [
                "sdf",
                "visualization",
                "font",
                "sketchy"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 1407
        },
        "renderpass": [
            {
                "code": "/* \"sketchy font distance\" by mattz\n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n \n   Thinking more about how to leverage gradient information to get\n   cleaner font outlines. This is not a solution, just a potential\n   step along the way. \n\n   Basically, at each font texel, I'm drawing up to 9 isosurfaces\n   corresponding its own linear approximation of the zero isocontour, \n   as well as it's neighbors' approximations.\n\n   Every time there should be a sharp corner in the font, we do\n   see multiple linear approximations intersecting there -- along\n   with some outliers. I feel like by applying some robust\n   estimation, it should be possible to reconstruct the original\n   isocontour, and hence recompute better distances.\n\n   Let's see where this goes, I guess?\n\n   See https://www.shadertoy.com/view/llcXRl for documentation about\n   the font texture.\n\n */\n\n\nconst float TEX_RES = 1024.;\nconst float TEX_CHAR_COUNT = 16.;\n\nconst float TEXELS_PER_UNIT = TEX_RES/TEX_CHAR_COUNT;\nconst float UNITS_PER_TEXEL = TEX_CHAR_COUNT/TEX_RES;\n\nconst float TEX_BIAS = 127./255.;\n\n// get font texel coords from screen coords\nvec2 font_from_screen(vec2 tpos, float font_size, vec2 char_pos) {\n    return tpos*TEXELS_PER_UNIT/font_size + (char_pos+0.5)*TEXELS_PER_UNIT;\n}\n\n// get screen coords from texel coords\nvec2 screen_from_font(vec2 font_uv, float font_size, vec2 char_pos) {\n    return font_uv*UNITS_PER_TEXEL*font_size - (char_pos+0.5)*font_size;\n}\n\n// get gradient and distance from font texture\nvec3 fetch_grad_dist(ivec2 uv, float font_size) {\n    \n    vec3 grad_dist = (texelFetch(iChannel0, uv, 0).yzw - TEX_BIAS) * font_size;\n    \n    grad_dist.y = -grad_dist.y;\n    \n    grad_dist.xy = normalize(grad_dist.xy + 1e-5);\n    \n    return grad_dist;\n    \n}\n\n// main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // size of character block on screen\n    float font_size = 1.4*iResolution.y;\n    \n    // which character to render now\n    int cidx = int(mod(iTime + 64., 256.));\n    if (cidx == 64) { cidx = 29; } else if (cidx == 29) { cidx = 64; }\n    \n    for (int i=32; i<127; ++i) {\n        if (texelFetch(iChannel1, ivec2(i,0), 0).x != 0.) {\n            cidx = i;\n        }\n    }\n    \n    // position within font texture\n    vec2 char_pos = vec2(ivec2(cidx%16, 15-cidx/16));\n    \n    // point relative to screen center \n    vec2 p = (fragCoord - 0.5*iResolution.xy);\n    \n    // get uv (actually texel coords) in font texture\n    vec2 uv = font_from_screen(p, font_size, char_pos);\n    \n    // uv coordinates for center of this texel \n    vec2 uvc = floor(uv) + 0.5;\n    \n    // displacement between current pixel and \n    // pixel coordinates corresp. to center of texel\n    vec2 pcp = screen_from_font(uvc, font_size, char_pos) - p;\n    \n    // distance to letter from center of texel cooresponding to this pixel\n    float ctr_dist = texelFetch(iChannel0, ivec2(uvc), 0).w - TEX_BIAS;\n   \n    // adapt iq's color pallete from https://www.shadertoy.com/view/4sS3zz\n    vec3 color = vec3(1.) - sign(ctr_dist)*vec3(0.1,0.4,0.7);\n    color *= 1. - exp(-14.*abs(ctr_dist));\n\n    // dim pixel outlines in texture using iq's vignette code\n    vec2 q = clamp(uv - floor(uv), 0.05, 0.95);\n    color *= pow( 24.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.05 );\n    \n    // for each texel in a 3x3 neighborhood centered on this one\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            \n            // offset to neighbor texel\n            ivec2 delta = ivec2(i,j)-1;\n\n            // fetch gradient & distance at neighbor\n            vec3 grad_dist = fetch_grad_dist(ivec2(uvc)+delta, font_size);\n            \n            // displacement in screen coordinates between this pixel\n            // and neighbor texel center location\n            vec2 pdelta = pcp + vec2(delta) * UNITS_PER_TEXEL * font_size;\n            \n            // distance to zero isosurface based on neighbor estimate\n            float local_dist_estimate;\n            \n            if (max(iMouse.z, iMouse.w) < 10.) {\n                local_dist_estimate = abs(dot(grad_dist.xy, pdelta) - grad_dist.z);\n            } else {\n                local_dist_estimate = length(pdelta - grad_dist.xy*grad_dist.z) - 1.;\n            }\n            \n            // add in white outline\n            color = mix(color, vec3(1), smoothstep(1., 0., local_dist_estimate));\n    \n        }\n    }\n    \n    // push to screen\n    fragColor = vec4(color, 1);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}