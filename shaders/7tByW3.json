{
    "Shader": {
        "info": {
            "date": "1650398096",
            "description": "Practice, based on IQ's recent video about their terrain with trees. Tried to keep my code really organized and well-commented (locally I have it as a series of files, using VSCode's \"shadertoy\" plugin). Lots of half-implemented stuff in here.",
            "flags": 0,
            "hasliked": 0,
            "id": "7tByW3",
            "likes": 3,
            "name": "Landscape Attempt #8394872983",
            "published": 3,
            "tags": [
                "raymarch",
                "landscape"
            ],
            "usePreview": 1,
            "username": "cra_manning_w",
            "viewed": 187
        },
        "renderpass": [
            {
                "code": "\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n//Animate a property over time; useful for visualizing different settings.\n#define TIME_LERP(a, b, speed) mix(a, b, 0.5 + (0.5 * sin(iTime * speed)))\n\n\n////////////////////////\n//    Vector Math     //\n////////////////////////\n\n//Note: using Y-up,  Z-forward, X-right (left-handed).\n\nstruct Basis\n{\n    vec3 forward, right, up;\n};\n\n//Makes a vector-basis, given a Z direction and the world \"up\" axis.\nBasis makeBasis(vec3 forward)\n{\n    vec3 right = cross(vec3(0, 1, 0), forward);\n    vec3 up = cross(forward, right);\n    return Basis(forward, right, up);\n}\n\n\n///////////////////////\n//    Randomness     //\n///////////////////////\n\n// A modified version of this: https://www.shadertoy.com/view/4djSRW\n\n//Hash 1D from 1D-3D data\nfloat hashTo1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hashTo1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hashTo1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Hash 2D from 1D-3D data\nvec2 hashTo2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Hash 3D from 1D-3D data\nvec3 hashTo3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hashTo3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hashTo3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//Hash 4D from 1D-4D data\nvec4 hashTo4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nvec4 hashTo4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nvec4 hashTo4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hashTo4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n////////////////////////////\n//   Terrain Parameters   //\n////////////////////////////\n\n//Attempt to make the scale of the terrain similar to real terrains,\n//    so that we can treat units like meters.\n#define TERR_SCALE 1.0/2000.0\n#define TERR_HEIGHT 1800.0\n\n//An exponent that reduces the grassiness of the surface.\n#define TERR_GRASS_THRESHOLD 13.0\n\n#define TERR_NOISE_SEED 1.7253789\n\n//This originally started as an attempt at making a cliff, like in IQ's video.\n//What I ended up making was a pair of plateaus at two different heights.\n//The second value must be larger than the first.\n#define TERR_PLATEAU_A (590.0 / TERR_HEIGHT) /* The magic number is in meters */\n#define TERR_PLATEAU_B (725.0 / TERR_HEIGHT)\n\n//The change from one noise octave to the next. Sometimes called \"persistence\".\n#define OCTAVE_SCALING 2.0\n\n\n//////////////////////////////////////////\n//   Terrain Noise Octave definitions   //\n//////////////////////////////////////////\n\n//The terrain uses octave noise.\nstruct NoiseOctave\n{\n    //Scales and rotates the input position before plugging it into the noise function.\n    //Scaling is a core part of octave noise.\n    //Rotation helps eliminate axis-aligned bias.\n    mat2 transform;\n\n    //The importance of this octave. Should change inversely with the octave's scale.\n    float weight;\n};\n\n#define OCTAVE_SCALE(i) (pow(OCTAVE_SCALING, float(i)))\n#define OCTAVE_WEIGHT(i) (pow(1.0/OCTAVE_SCALING, float(i)))\n\n//Each octave needs to be scaled, and should also be rotated.\n//2D rotation matrices can be made easily with pythagorean triples;\n//    here we use (5, 12, 13).\n#define OCTAVE_MAT (                                 \\\n    /* Rotation matrix: */                           \\\n    mat2(12.0/13.0, 5.0/13.0,                        \\\n         -5.0/13.0, 12.0/13.0) *                     \\\n    /* Scale matrix: */                              \\\n    mat2(OCTAVE_SCALING, 0.0, 0.0, OCTAVE_SCALING)   \\\n)\n#define OCTAVE_MAT2 (OCTAVE_MAT * OCTAVE_MAT)\n#define OCTAVE_MAT4 (OCTAVE_MAT2 * OCTAVE_MAT2)\n#define OCTAVE_MAT8 (OCTAVE_MAT4 * OCTAVE_MAT4)\n\n\n#define N_OCTAVES 14\nconst NoiseOctave OCTAVES[N_OCTAVES] = NoiseOctave[N_OCTAVES](\n    NoiseOctave(mat2(1.0, 0.0, 0.0, 1.0), OCTAVE_WEIGHT(0)),\n    NoiseOctave(OCTAVE_MAT,\n                OCTAVE_WEIGHT(1)),\n    NoiseOctave(OCTAVE_MAT2,\n                OCTAVE_WEIGHT(2)),\n    NoiseOctave(OCTAVE_MAT2 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(3)),\n    NoiseOctave(OCTAVE_MAT4,\n                OCTAVE_WEIGHT(4)),\n    NoiseOctave(OCTAVE_MAT4 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(5)),\n    NoiseOctave(OCTAVE_MAT4 * OCTAVE_MAT2,\n                OCTAVE_WEIGHT(6)),\n    NoiseOctave(OCTAVE_MAT4 * OCTAVE_MAT2 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(7)),\n    NoiseOctave(OCTAVE_MAT8,\n                OCTAVE_WEIGHT(8)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(9)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT2,\n                OCTAVE_WEIGHT(10)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT2 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(11)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT4,\n                OCTAVE_WEIGHT(12)),\n    NoiseOctave(OCTAVE_MAT8 * OCTAVE_MAT4 * OCTAVE_MAT,\n                OCTAVE_WEIGHT(13))\n);\n\n//Gets the noise value (no derivative) at a point on the terrain's surface,\n//    for the given noise octave.\nfloat terrainNoiseOctaveValue(NoiseOctave octave, vec2 pos)\n{\n    //Simple value noise!\n\n    //First, transform the position for this octave.\n    pos *= TERR_SCALE;\n    pos = octave.transform * pos;\n\n    //Get the four corners of the grid cell surrounding this position.\n    vec2 gridPos = pos,\n         gridMin = floor(gridPos),\n         gridMax = gridMin + 1.0;\n\n    //Assign a randomized value to each corner.\n    vec4 gridMinMax = vec4(gridMin, gridMax);\n    float v00 = hashTo1(vec3(gridMinMax.xy, TERR_NOISE_SEED)),\n          v10 = hashTo1(vec3(gridMinMax.zy, TERR_NOISE_SEED)),\n          v01 = hashTo1(vec3(gridMinMax.xw, TERR_NOISE_SEED)),\n          v11 = hashTo1(vec3(gridMinMax.zw, TERR_NOISE_SEED));\n\n    //Interpolate.\n    //Normally this would look like:\n    /*\n        vec2 t = gridPos - gridMin;\n        t = smoothstep(0.0, 1.0, t);\n        return mix(mix(v00, v10, t.x),\n                   mix(v01, v11, t.x),\n                   t.y);\n    */\n    //To attempt to figure out analytical derivatives, here is that same expression\n    //    written out as plain, differentiable math operations.\n    //It seems to be wrong though.\n    /*\n        mix(a, b, t) = a + ((b-a) * t)\n        t(p) = (-3*p*p*p) + (2*p*p)\n        noise(p)   = (v00 + ((v10 - v00) * t.x)) +\n                     ( ((v01 + ((v11 - v01) * t.x)) - (v00 + ((v10 - v00) * t.x))) * t.y )\n                   = v00 + (t.x * v10) + (t.x * -v00) +\n                     (t.y * (v01 + (t.x * v11) + (t.x * -v01))) +\n                     (t.y * -(v00 + (t.x * v10) + (t.x * -v00)))\n                   = v00 +\n                     t.x * (v10 - v00) +\n                     t.y * (v01 - v00) +\n                     (t.x * t.y) + (v11 + v10 - v01 - v00)\n                   = v00 +\n                     ((-3 * p.x^3) + (2 * p.x^2)) * (v10 - v00) +\n                     ((-3 * p.y^3) + (2 * p.y^3)) * (v01 - v00) +\n                     ((-3 * p.x^3) + (2 * p.x^2)) * ((-3 * p.y^3) + (2 * p.y^2)) * (v11 + v10 - v01 - v00)\n                   = v00 +\n                     (p.x^3 * (v10 - v00) * -3) +\n                     (p.x^2 * (v10 - v00) * 2) +\n                     (p.y^3 * (v01 - v00) * -3) +\n                     (p.y^2 * (v01 - v00) * 2) +\n                     ((v11 + v10 - v01 - v00) *\n                      ((9 * p.x^3 * p.y^3) + (4 * p.x^2 * p.y^2) +\n                       (-6 * p.x^3 * p.y^2) + (-6 * p.x^2 * p.y^3)))\n                   = v00 +\n                     (p.x^3 * (v10 - v00) * -3) +\n                     (p.x^2 * (v10 - v00) * 2) +\n                     (p.y^3 * (v01 - v00) * -3) +\n                     (p.y^2 * (v01 - v00) * 2) +\n                     (p.x^3 * p.y^3 * (v11 + v10 - v01 - v00) * 9) +\n                     (p.x^2 * p.y^2 * (v11 + v10 - v01 - v00) * 4) +\n                     (p.x^3 * p.y^2 * (v11 + v10 - v01 - v00) * -6) +\n                     (p.x^2 * p.y^3 * (v11 + v10 - v01 - v00) * -6)\n          => noise'dx = (p.x^2 * (v10 - v00) * (-3 * 3)) +\n                        (p.x * (v10 - v00) * (2 * 2)) +\n                        (p.x^2 * p.y^3 * (v11 + v10 - v01 - v00) * (9 * 3)) +\n                        (p.x * p.y^2 * (v11 + v10 - v01 - v00) * (4 * 2)) +\n                        (p.x^2 * p.y^2 * (v11 + v10 - v01 - v00) * (3 * -6)) +\n                        (p.x * p.y^3 * (v11 + v10 - v01 - v00) * (2 * -6))\n          => noise'dy = (p.y^2 * (v01 - v00) * (-3 * 3)) +\n                        (p.y * (v01 - v00) * (2 * 2)) +\n                        (p.y^2 * p.x^3 * (v11 + v10 - v01 - v00) * (3 * 9)) +\n                        (p.y * p.x^2 * (v11 + v10 - v01 - v00) * (2 * 4)) +\n                        (p.y * p.x^3 * (v11 + v10 - v01 - v00) * (2 * -6)) +\n                        (p.y^2 * p.x^2 * (v11 + v10 - v01 - v00) * (3 * -6))\n    */\n    if (true)\n    {\n        vec2 t = gridPos - gridMin;\n        t = smoothstep(0.0, 1.0, t);\n        return mix(mix(v00, v10, t.x),\n                   mix(v01, v11, t.x),\n                   t.y);\n    }\n    else\n    {\n        vec2 p = gridPos - gridMin;\n        vec2 p2 = p * p,\n             p3 = p2 * p;\n        return v00 +\n               (p3.x * (v10 - v00) * -3.0) +\n               (p2.x * (v10 - v00) * 2.0) +\n               (p3.y * (v01 - v00) * -3.0) +\n               (p2.y * (v01 - v00) * 2.0) +\n               (p3.x * p3.y * (v11 + v10 - v01 - v00) * 9.0) +\n               (p2.x * p2.y * (v11 + v10 - v01 - v00) * 4.0) +\n               (p3.x * p2.y * (v11 + v10 - v01 - v00) * -6.0) +\n               (p2.x * p3.y * (v11 + v10 - v01 - v00) * -6.0);\n    }\n}\n\n//Alternative noise function that uses polynomial noise, based on IQ's video.\n//I don't know how to calculate the analytical derivative for this.\nfloat terrainNoiseOctaveValue_POLY(NoiseOctave octave, vec2 pos)\n{\n    //Split the world into a grid.\n    //Each grid cell has a different polynomial function,\n    //    whose parameters are based on the 4 corners.\n    //This setup makes the corners/edges of the cells line up with their neighbors,\n    //    and also provides a nice analytic derivative.\n\n    //First, transform the position for this octave.\n    pos *= TERR_SCALE;\n    pos = octave.transform * pos;\n\n    //Compute the parameters of the four corners.\n    vec2 gridPos = pos,\n         gridMin = floor(gridPos),\n         gridMax = gridMin + 1.0;\n    vec4 gridMinMax = vec4(gridMin, gridMax);\n    float paramMinXMinY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.xy, TERR_NOISE_SEED))),\n          paramMaxXMinY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.zy, TERR_NOISE_SEED))),\n          paramMinXMaxY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.xw, TERR_NOISE_SEED))),\n          paramMaxXMaxY = -1.0 + (2.0 * hashTo1(vec3(gridMinMax.zw, TERR_NOISE_SEED)));\n\n    //Compute the polynomial.\n    vec2 t = gridPos - gridMin;\n    t = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t));\n    return paramMinXMinY +\n           (t.x * (paramMaxXMinY - paramMinXMinY)) +\n           (t.y * (paramMinXMaxY - paramMinXMinY)) +\n           (t.x * t.y * (paramMinXMinY + paramMaxXMaxY - paramMinXMaxY - paramMaxXMinY));\n}\n\n////////////////////////////////\n//   Terrain Data Functions   //\n////////////////////////////////\n\n//Calculates the terrain height at a given horiziontal position.\nfloat terrainHeight(vec2 horzPos)\n{\n    //Compute the octave noise.\n    float value = 0.0,\n          maxValue = 0.0;\n    for (int i = 0; i < N_OCTAVES; ++i)\n    {\n        NoiseOctave octave = OCTAVES[i];\n        value += (octave.weight * terrainNoiseOctaveValue(octave, horzPos));\n        maxValue += octave.weight;\n    }\n    value /= maxValue;\n\n    //Create the two plateaus by using smoothstep() on the height values between them.\n    //This pushes the height values towards either end.\n    if (value >= TERR_PLATEAU_A && value <= TERR_PLATEAU_B)\n    {\n        float cliffT = smoothstep(TERR_PLATEAU_A, TERR_PLATEAU_B, value);\n        value = mix(TERR_PLATEAU_A, TERR_PLATEAU_B, cliffT);\n    }\n\n    //TODO: How did IQ make those cliffs exactly?\n\n    return TERR_HEIGHT * value;\n}\n\n//Estimates how close a point is to the terrain.\n//If the value is <= 0, you can interpret that as a collision.\n//As the distance gets larger, the quality of the estimation gets worse.\nfloat terrainDist(vec3 pos)\n{\n    //Check the distance from this point to the terrain's heightmap directly below it.\n    //This distance estimation works well when close to the terrain.\n    //When far from the terrain, the point may be closer to a hill or sheer cliff\n    //    than to the spot directly below it,\n    //    but at that point the estimate isn't useful anyway.\n\n    //Don't forget to use signed distance,\n    //    a.k.a. the output should be negative when below the terrain.\n\n    return pos.y - terrainHeight(pos.xz);\n}\n\nvec3 terrainNormal(vec2 horzPos)\n{\n    /*\n        Here's the implementation for analytic derivatives:\n            float derivX = ...;\n            float derivZ = ...;\n            return normalize(-vec3(derivX, -1, derivZ));\n    */\n\n    //Use finite differences, which works OK when you can't figure out an analytic derivative.\n    //TODO: Why does setting the epsilon to be smaller seem to create a much worse result?\n    #define TERR_NORMAL_EPSILON 0.1\n    vec2 offset2 = vec2(TERR_NORMAL_EPSILON, 0.0);\n\n    return normalize(vec3(\n        terrainHeight(horzPos - offset2.xy) -\n           terrainHeight(horzPos + offset2.xy),\n        2.0 * TERR_NORMAL_EPSILON,\n        terrainHeight(horzPos - offset2.yx) -\n           terrainHeight(horzPos + offset2.yx)\n    ));\n}\nvec3 terrainNormal(vec3 pos) { return terrainNormal(pos.xz); }\n\n//Determines how grassy or rocky a part of the terrain's surface is.\nfloat terrainGrassiness(vec3 pos, vec3 normal)\n{\n    float grassiness = normal.y;\n    grassiness = pow(grassiness, TERR_GRASS_THRESHOLD);\n    grassiness = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, grassiness));\n    return grassiness;\n}\n\n\n////////////////////\n//   Raymarching  //\n////////////////////\n\n//Codes for what surface was hit.\n#define HIT_SKY 0\n#define HIT_TERRAIN 1\n#define HIT_TREES 2\n\nstruct RayQuality\n{\n    //How far the ray moves each step, when close to its source.\n    float initialInterval;\n    //How much coarser the ray gets as it moves away from its source.\n    float intervalIncrement;\n\n    //TODO: Define the target range of the ray, compute the required number of march iterations, then cap it at the below value.\n\n    //How many iterations of the raymarcher to run.\n    int nIterations;\n\n    //TODO: Quality flag for \"shadow mode\", a.k.a. ignore trees, terrain normals, and some octaves.\n};\n\nstruct RayHit\n{\n    int code; //See the HIT_[X] tokens defined above.\n    vec3 pos; //Not defined if hitting sky.\n    float dist; //Not well-defined if hitting sky.\n\n    //Estimates the closest the ray got to the terrain during its travel.\n    float minTerrainDist;\n\n    //Data that's only given if the terrain was hit:\n    vec3 terrainNormal;\n    float terrainGrassiness;\n\n    //Channels of debug data for visualization.\n    vec4 debug;\n};\n\nRayHit marchRay(vec3 rayPos, vec3 rayDir, RayQuality quality)\n{\n    float totalDist = 0.0;\n\n    //If the ray starts above the terrain, jump to the 'ceiling' of the heightmap.\n    if (rayPos.y > TERR_HEIGHT)\n    {\n        if (rayDir.y >= 0.0)\n        {\n            return RayHit(HIT_SKY, rayPos, 0.0,\n                          rayPos.y - terrainHeight(rayPos.xz),\n                          vec3(0.0), 0.0, vec4(0.0));\n        }\n        else\n        {\n            float intersectT = (TERR_HEIGHT - rayPos.y) / rayDir.y;\n            rayPos += rayDir * intersectT;\n            totalDist += intersectT;\n        }\n    }\n\n    float stepDist = quality.initialInterval;\n    float minTerrainDist = 9999999.0;\n    float previousStepTerrainDist = 9999999.0;\n    for (int i = 0; i < quality.nIterations; ++i)\n    {\n        //Check for collisions at the current position.\n\n        //If the ray is above the terrain and heading further upwards,\n        //    don't bother with collision-testing anymore.\n        if ((rayDir.y > 0.0) && (rayPos.y > TERR_HEIGHT))\n        {\n            return RayHit(HIT_SKY, rayPos, totalDist, minTerrainDist,\n                          vec3(0, 0, 0), 0.0, vec4(0));\n        }\n\n        //Estimate distance to the terrain with the point's elevation.\n        //This estimation is less accurate when the point is far away from the terrain,\n        //    but in that case the value isn't important anyway.\n        float terrHeight = terrainHeight(rayPos.xz);\n        float terrainDist = rayPos.y - terrHeight;\n        if (terrainDist <= 0.0)\n        {\n            //The ray is most likely underneath the terrain now.\n            //Approximate the point of collision by finding the intersection\n            //    between the last ray step and a line running along the terrain's surface.\n            float backwardsStepScale = 1.0 - (-previousStepTerrainDist / (terrainDist - previousStepTerrainDist));\n            float backwardsStep = backwardsStepScale * (stepDist - quality.intervalIncrement);\n            rayPos -= backwardsStep * rayDir;\n            totalDist -= backwardsStep;\n\n            minTerrainDist = 0.0;\n            vec3 normal = terrainNormal(rayPos);\n            float grassiness = terrainGrassiness(rayPos, normal);\n            return RayHit(HIT_TERRAIN, rayPos, totalDist, minTerrainDist,\n                          normal, grassiness,\n                          //Debug data:\n                          vec4(backwardsStep, terrainDist, 0.0, 0.0));\n        }\n        minTerrainDist = min(terrainDist, minTerrainDist);\n\n        //March the ray forward.\n        rayPos += rayDir * stepDist;\n        totalDist += stepDist;\n        stepDist += quality.intervalIncrement;\n        previousStepTerrainDist = terrainDist;\n    }\n\n    //Nothing concrete was hit, so we \"hit\" sky.\n    return RayHit(HIT_SKY, rayPos, totalDist, minTerrainDist, vec3(0, 0, 0), 0.0,\n                  //Debug data:\n                  vec4(0));\n}\n\n\n/////////////\n//   Sun   //\n/////////////\n\nstruct SunState\n{\n    vec3 brightness;\n    vec3 towardsSun;\n};\n\nSunState sunCurrentState()\n{\n    //TODO: Animated day/night thing\n    return SunState(vec3(1.0, 0.95, 0.9), normalize(vec3(1, 0.5, 1)));\n}\n\n\n///////////////\n//  Shadows  //\n///////////////\n\n#define SHADOW_RAY_QUALITY RayQuality(2.5, 0.3, 100)\n#define SHADOW_START_AHEAD 5.3\n\n//Gets a 0-1 value indicating how much light reaches the given position.\nfloat castShadow(vec3 surfacePos, SunState sun)\n{\n    RayHit hit = marchRay(surfacePos + (sun.towardsSun * SHADOW_START_AHEAD),\n                          sun.towardsSun,\n                          SHADOW_RAY_QUALITY);\n\n    //TODO: Use the 'minTerrainDist' term for soft shadows.\n    return (hit.code == HIT_SKY) ? 1.0 : 0.0;\n}\n\n\n//////////////////\n//   Lighting   //\n//////////////////\n\n#define LIGHT_AMBIENT vec3(0.85, 0.76, 0.5)\n\n#define FOG_ATTEN (-0.0006 * vec3(1, 2, 4.0))\n#define FOG_BRIGHTNESS 0.775\n//TODO: Add height-based fog\n\n#define TERR_COLOR_ROCK vec3(0.43, 0.33, 0.31)\n#define TERR_COLOR_GRASS vec3(0.18, 0.39, 0.19)\nvec3 lightTerrain(RayHit hit, SunState sun)\n{\n    vec3 albedo = mix(TERR_COLOR_ROCK, TERR_COLOR_GRASS, hit.terrainGrassiness);\n    float diffuse = max(0.0, dot(hit.terrainNormal, sun.towardsSun));\n\n    //TODO: Specular\n\n    vec3 fogDensity = vec3(1.0 - exp(hit.dist * FOG_ATTEN));\n\n    float shadow = diffuse * castShadow(hit.pos, sun); //TODO: Fix the mixture of diffuse, shadow, and ambient.\n    vec3 shadowColor = min(vec3(shadow), LIGHT_AMBIENT);\n\n    vec3 surfaceColor = albedo * sun.brightness * shadowColor;\n    return mix(surfaceColor, vec3(FOG_BRIGHTNESS), fogDensity);\n}\n\n#define SKY_COLOR_HORIZON vec3(0.435, 0.65, 1.0)\n#define SKY_COLOR_ZENITH vec3(0.05, 0.25, 0.775)\nvec3 lightSky(vec3 camPos, vec3 camRayDir, SunState state)\n{\n    float zenithT = smoothstep(0.0, 1.0, max(0.0, camRayDir.y));\n    vec3 baseColor = mix(SKY_COLOR_HORIZON, SKY_COLOR_ZENITH, zenithT);\n\n    //TODO: Clouds.\n\n    return baseColor;\n}\n\n\n////////////////////////////////////\n//    Camera Definitions/math     //\n////////////////////////////////////\n\n#define CAM_FOV_SCALE 1.0\n\nstruct CamState\n{\n    vec3 pos, forward;\n    float fovScale;\n};\n\n//Gets the direction of a ray starting at the camera\n//    and passing through the given point on the screen.\nvec3 camRay(CamState state, vec2 uv)\n{\n    Basis basis = makeBasis(state.forward);\n    vec3 offset = ((1.0/state.fovScale) * basis.forward)\n                     + (mix(-basis.right, basis.right, uv.x))\n                     + (mix(-basis.up, basis.up, uv.y));\n    return normalize(offset);\n}\n\n\n//////////////////////////////////\n//    Camera Animation Math     //\n//////////////////////////////////\n\nstruct CamKeyframe\n{\n    vec2 horzPos;\n    float heightOffset;\n\n    //Heading/yaw is given as 0-1.\n    //Pitch is given as a value which is put into the view direction before normalization.\n    float headingT, pitchForce;\n\n    float fovScale;\n};\nCamKeyframe interpolateCamOrientation(CamKeyframe a, CamKeyframe b, float t)\n{\n    //TODO: Use different interpolation curves for each kind of data. E.x:\n    //    * Pitch should spend most of its time around 0\n    //    * Heading should check for wraparound angle being smaller\n\n    return CamKeyframe(\n        mix(a.horzPos, b.horzPos, t),\n        mix(a.heightOffset, b.heightOffset, t),\n        mix(a.headingT, b.headingT, t),\n        mix(a.pitchForce, b.pitchForce, t),\n        mix(a.fovScale, b.fovScale, t)\n    );\n}\n//Converts camera keyframe data into a state.\nCamState computeCamState(CamKeyframe keyframe)\n{\n    vec3 pos = vec3(keyframe.horzPos.x,\n                    terrainHeight(keyframe.horzPos) + keyframe.heightOffset,\n                    keyframe.horzPos.y);\n\n    float headingRad = keyframe.headingT * (2.0 * 3.14159265);\n    vec3 forward = normalize(vec3(cos(headingRad),\n                                  keyframe.pitchForce,\n                                  sin(headingRad)));\n\n    return CamState(pos, forward, keyframe.fovScale);\n}\n\n\n//////////////////////////////////\n//    Camera Animation Keys     //\n//////////////////////////////////\n\nconst CamKeyframe CAM_KEYFRAMES[] = CamKeyframe[](\n    CamKeyframe(vec2(42.55 * -80.0), 35.5,\n                0.255, -0.05,\n                1.0)\n);\n\nCamState camCurrentState(float time)\n{\n    CamKeyframe key = CAM_KEYFRAMES[0];\n    //key.headingT += iTime * 0.1;\n    return computeCamState(key);\n}\n\n\n\n/////////////////////////\n//   Post-processing   //\n/////////////////////////\n\nvec3 postProcess(vec3 computedColor, vec3 camRayDir)\n{\n    //TODO: Try smoothstep to increase vibrance/contrast.\n    //TODO: Add a glow near the sun direction, to simulate a lens.\n\n    return computedColor;\n}\n\n\n////////////////////\n//    Samples     //\n////////////////////\n\n//High-quality, for show:\n//#define MAIN_RAY_QUALITY RayQuality(0.2, 0.002, 900)\n//Low-quality, for testing:\n#define MAIN_RAY_QUALITY RayQuality(0.4, 0.008, 450)\n\n//Affects the number of samples used for anti-aliasing.\n//Larger values improve quality but kill performance.\n//A value of 1 means \"no AA\", and a value of 0 effectively disables rendering.\n#define AA_SAMPLES 1\n\n//Computes a single pixel sample.\n//Antialiasing can use multiple such samples.\nvec3 sampleColor(CamState camera, SunState sun, vec2 uv)\n{\n    vec3 rayDir = camRay(camera, uv);\n    RayHit hit = marchRay(camera.pos, rayDir, MAIN_RAY_QUALITY);\n    if (hit.code == HIT_TERRAIN)\n        return lightTerrain(hit, sun);\n    else if (hit.code == HIT_SKY)\n        return lightSky(camera.pos, rayDir, sun);\n    else if (hit.code == HIT_TREES)\n        return vec3(1, 0, 0);\n    else\n        return vec3(1, 0, 1); //Unknown surface! Return 'error' color.\n}\n\n//Computes the color for a pixel, including anti-aliasing.\n//Takes aspect-ratio-corrected UV data (a.k.a. at least one axis has a different range than 0-1).\nvec3 pixelColor(CamState camera, SunState sun,\n                vec2 uvScreenMin, vec2 uvScreenMax,\n                vec2 uvAspected, vec2 screenResolution)\n{\n    //SSAA: Render multiple times per-pixel, with subpixel offsets,\n    //    and average them together.\n    vec3 sampleSum = vec3(0.0);\n\n    //This pixel covers some amount of UV space.\n    vec2 uvCoverage = (uvScreenMax - uvScreenMin) / screenResolution; //Note that we'd expect uvCoverage.x == uvCoverage.y\n    vec2 uvCoverageMin = uvAspected - (uvCoverage / 2.0),\n         uvCoverageMax = uvCoverageMin + uvCoverage;\n\n    //Take regular samples across this UV pixel.\n    for (int x = 0; x < AA_SAMPLES; ++x)\n    {\n        float tX = (float(x) + 0.5) / float(AA_SAMPLES);\n        for (int y = 0; y < AA_SAMPLES; ++y)\n        {\n            float tY = (float(y) + 0.5) / float(AA_SAMPLES);\n\n            vec2 uvSample = mix(uvCoverageMin, uvCoverageMax, vec2(tX, tY));\n            sampleSum += sampleColor(camera, sun, uvSample);\n        }\n    }\n    vec3 rawColor = sampleSum / float(AA_SAMPLES * AA_SAMPLES);\n\n    return postProcess(rawColor, camRay(camera, uvAspected));\n}\n\n\n\n//////////////\n//   main   //\n//////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get screen UV coordinates.\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //Correct for aspect ratio by stretching UV's horizontally.\n    float aspect = iResolution.x / iResolution.y;\n    float uvExtraWidth = aspect - 1.0,\n          uvHorzPadding = uvExtraWidth / 2.0;\n    vec2 uvMin = vec2(-uvHorzPadding, 0.0),\n         uvMax = vec2(1.0 + uvHorzPadding, 1.0);\n    vec2 uvAspected = mix(uvMin, uvMax, uv);\n\n    //Get camera data.\n    CamState camera = camCurrentState(iTime);\n    vec3 rayDir = camRay(camera, uvAspected);\n\n    //Debug outputs:\n    {\n        //DEBUG: Output screen data.\n        if (false)\n        {\n            fragColor = vec4(uvAspected, 0.0, 1.0);\n            return;\n        }\n\n        //DEBUG: Output terrain-related data.\n        if (false)\n        {\n            vec3 testPos = camera.pos + vec3(uvAspected*30.0, 0.0).xzy;\n            float testDist = terrainDist(testPos) / TERR_HEIGHT;\n\n            fragColor = vec4(testDist, testDist, testDist, 1.0);\n            return;\n        }\n\n        //DEBUG: Output camera/ray data.\n        if (false)\n        {\n            Basis basis = makeBasis(camera.forward);\n            fragColor = vec4(basis.up, 1.0);\n            return;\n        }\n\n        //DEBUG: Raymarching collision data.\n        if (false)\n        {\n            RayHit hit = marchRay(camera.pos, rayDir, MAIN_RAY_QUALITY);\n            if (hit.code == HIT_TERRAIN)\n            {\n                //Color based on hit distance.\n                float strength = hit.dist / 550.0;\n                strength = max(0.35, strength);\n                fragColor = vec4(strength * 0.2, strength, 0.0, 1.0);\n\n                //Color based on estimated distance to the terrain.\n                fragColor = vec4(vec3(hit.minTerrainDist / 5.0), 1.0);\n\n                //Color based on debug visualization data.\n                fragColor = vec4(hit.debug.xy * vec2(1.0, -1.0),\n                                 0.0, 1.0);\n\n                //Color based on surface normal.\n                fragColor = vec4(abs(hit.terrainNormal), 1.0);\n\n                //Color based on finite-differences math.\n                vec2 posXMin = vec2(hit.pos.x - TERR_NORMAL_EPSILON, hit.pos.z),\n                     posXMax = vec2(hit.pos.x + TERR_NORMAL_EPSILON, hit.pos.z),\n                     posZMin = vec2(hit.pos.x, hit.pos.z - TERR_NORMAL_EPSILON),\n                     posZMax = vec2(hit.pos.x, hit.pos.z + TERR_NORMAL_EPSILON);\n                float heightXMin = terrainHeight(posXMin),\n                      heightXMax = terrainHeight(posXMax),\n                      heightZMin = terrainHeight(posZMin),\n                      heightZMax = terrainHeight(posZMax);\n                float heightY = 2.0 * TERR_NORMAL_EPSILON;\n                vec2 change2D = vec2(heightXMin - heightXMax,\n                                     heightZMin - heightZMax);\n                vec3 dir = vec3(change2D.x, heightY, change2D.y);\n                vec3 norm = normalize(dir);\n                vec2 heightsXLinearized = pow(-vec2(heightXMin, heightXMax) / TERR_HEIGHT,\n                                              vec2(4.0));\n                vec2 change2DLinearized = pow(abs(change2D), vec2(0.2));\n                fragColor.rgb = vec3(sign(norm.xz), fract(hit.pos.x));\n\n                //Color based on height.\n                fragColor.rgb = vec3(terrainHeight(hit.pos.xz) / TERR_HEIGHT);\n            }\n            else if (hit.code == HIT_SKY)\n            {\n                float strength = hit.minTerrainDist / 100.0;\n                fragColor = vec4(0.0, 0.0, strength, 1.0);\n            }\n            else\n            {\n                //Uh-oh, what are we looking at??\n                fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n            }\n\n            return;\n        }\n    }\n\n    //The actual logic used for coloring the scene:\n    if (true)\n    {\n        fragColor.rgb = pixelColor(camera, sunCurrentState(),\n                                   uvMin, uvMax, uvAspected,\n                                   iResolution.xy);\n        fragColor.a = 1.0;\n        return;\n    }\n\n    //DEBUG: Fallback, return noise to indicate \"you forgot to return anything\".\n    fragColor = vec4(hashTo3(uv * 3999.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}