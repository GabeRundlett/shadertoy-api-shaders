{
    "Shader": {
        "info": {
            "date": "1674264061",
            "description": "75k Engraulia ringens, the Peruvian anchoveta, form into a swarm in an attempt to dissuade predators.\n\nFeaturing \"ocean under\" by rockhard https://shadertoy.com/view/7dyXWc\n\n*mouse to attract the swarm*\n*shift to disable ssao*\n*space to disable fxaa*",
            "flags": 48,
            "hasliked": 0,
            "id": "mtSGDt",
            "likes": 73,
            "name": "Swarming Anchoveta",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "particles",
                "ocean",
                "dynamics",
                "fish",
                "ssao",
                "swarm"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 1039
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  75k Engraulia ringens, the Peruvian anchoveta, form into a swarm in an attempt to\n//  dissuade predators. Water surface borrowed from rockhard's\n//\n//      ocean under               https://shadertoy.com/view/7dyXWc\n//\n//  FXAA from reinder's\n//\n//      Post process - FXAA       https://shadertoy.com/view/ls3GWS\n//\n//  SSAO originally from iq's\n//\n//      SSAO (basic)              https://www.shadertoy.com/view/Ms23Wm\n//\n//  I saw these fish swarms, and I thought it looked like a good use for SSAO.\n//\n//      https://www.researchgate.net/profile/Michael-Thrun/publication/338880262/figure/fig1/AS:1033391478669313@1623391136755/A-fish-swarm-in-the-form-of-a-ball-Uber-Pix-2015-an-example-of-emergence-in-swarms.ppm\n//\n//  Since I already had particles rendering with SSAO, I modified the particle sim to\n//  to move like this swarm, and then modified the particle rendering to draw ellipoids\n//  instead of spheres, with an environment map. For the environment map and background\n//  I borrowed the water surface from the excellent \"water under\" by rockhard (if (s)he\n//  sees this I hope (s)he's OK with my pilfering...if not please let me know).\n//\n//  The physics simply treats the particles as spheres. But, the screen-space voronoi \n//  neighbor search does take the ellipsoid shape into account (otherwise the heads and\n//  tails of the fish get lost).\n//\n//  As usual I'm not really that happy with the anti-aliasing. The FXAA avoids the worst\n//  artifacts at least. Suggestions are welsome!\n//\n//  Click mouse to attract the swarm. Space to disable SSAO, shift to disable FXAA.\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D performs lighting and SSAO\n//  Image performs FXAA post-process\n//\n// ---------------------------------------------------------------------------------------\n\n// From reinder's  Post process - FXAA\n//    https://www.shadertoy.com/view/ls3GWS\n// he got it from:\n//    http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 AArender( vec2 uv2 )\n{    \n    uv2 /= iResolution.xy;\n    vec2 rcpFrame = 1. / iResolution.xy;\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n    vec3 rgbNW = textureLod(iChannel0, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(iChannel0, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(iChannel0, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(iChannel0, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(iChannel0, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(iChannel0, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(iChannel0, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(iChannel0, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (keyDown(KEY_SPACE))\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor.xyz = AArender(fragCoord);\n        \n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .025;\nconst vec3 FISH_SIZE = vec3(4, .4, .8)*PARTICLE_SIZE;\nconst float FAR_CLIP = 1e6;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    ivec4 nbs[4];\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.vel = particleData5.xyz;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 75000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, 0., 0);\n    cameraPos\t = vec3(0, -1, 3.5);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float resolution;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.resolution = -iResolution.x * iResolution.y;\n}\n\n#define fxInitState(state) fxGetStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    \n    fxState state;\n    state.resolution = data0.x;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, 0, 0, 0);\n}\n\n// G BUFFER\n\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n, pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n = fragColor.xyz;\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/intersectors/\n// ellipsoid centered at the origin with radii ra\nfloat eliIntersect( in vec3 ro, in vec3 rd, in vec3 ra )\n{\n    vec3 ocn = ro/ra;\n    vec3 rdn = rd/ra;\n    float a = dot( rdn, rdn );\n    float b = dot( ocn, rdn );\n    float c = dot( ocn, ocn );\n    float h = b*b - a*(c-1.0);\n    if( h<0.0 ) return -1.; //no intersection\n    h = sqrt(h);\n    return (h - b) / a;\n}\n\nvec3 eliNormal( in vec3 pos, in vec3 ra )\n{\n    return normalize( pos/(ra*ra) );\n}\n\nfloat fishIntersect(fxParticle p, vec3 ro, vec3 rd, out vec3 normal)\n{\n    vec3 front = normalize(p.vel);\n    vec3 left = -normalize(cross(vec3(0, 1, 0), front));\n    vec3 up = -normalize(cross(left, front));\n    mat3 m = mat3(front, left, up);\n    mat3 mi = inverse(m);\n    \n    vec3 ero = mi * (ro - p.pos);\n    vec3 erd = mi * rd;\n    \n    float t = eliIntersect(ero, erd, FISH_SIZE);\n    vec3 hitPos = ero + erd * t;\n    normal = m * eliNormal(hitPos, FISH_SIZE);\n\n    return t;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nvoid particleStep(inout fxParticle p, fxState state, int id)\n{\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init\n        for (int i = 0; i < 100; ++i) // kinda dumb, but just keep trying until it's in a sphere (relax it's just init)\n        {\n            vec3 h = hash3( uvec3(id, iFrame, i) );\n\n            p.pos = h * 2. - 1.;\n            p.vel = vec3(0);\n            \n            if (length(p.pos) < 1.)\n            {\n                p.pos *= 1.2; // expand a bit\n                p.vel.xz = p.pos.zx * vec2(1, -1) * .01; // initial swarm rotation\n                return;\n            }\n        }\n        \n        return;\n    }\n\n    // particle update\n    p.vel.xz += p.vel.zx * vec2(1, -1) * sin(iTime * 15. + float(id)) * .04; // swim\n    p.vel.xz += p.pos.zx * vec2(1, -1) / sqrt(length(p.pos.xz)) * .0001; // swarm rotation\n    p.vel.xz -= p.pos.xz * .00015; // attract to swarm center\n    p.vel.y -= p.pos.y * .0001; // attract to swarm center\n    \n    vec3 attractPos;\n    float attractStrength;\n    if (iMouse.z > 0.)\n    {\n        // mouse interact\n        attractPos = (iMouse.xy - .5 * iResolution.xy).xyy * vec3(1, 1, 0) / iResolution.y;\n        attractStrength = .0005;\n    }\n    else\n    {\n        // drag the swarm around a bit more gently if no mouse, to keep it changing\n        attractPos = sin(iTime * vec3(.2, 0, .2));\n        attractStrength = .0001;\n    }\n    p.vel += (attractPos - p.pos) / length(attractPos - p.pos) * attractStrength;\n    \n    // collide with neighbors (only as sphere)\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            int nid = p.nbs[i][j];\n            if (nid < 0) break;\n            fxParticle nb = fxGetParticle(nid);\n            vec3 delta = nb.pos - p.pos;\n\n            if (length(delta) > 1e-6 && length(delta) < PARTICLE_SIZE * 2.)\n            {\n                vec3 dir = normalize(p.pos - nb.pos);\n\n                // position correction\n                p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .25);\n\n                // clip velocity\n                vec3 relVel = p.vel - nb.vel;\n                p.vel -= dot(relVel, dir) * dir;\n            }\n        }\n    }\n\n    p.vel *= .99; // damping\n    const float MAX_SPEED = .2; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n\n    p.pos += p.vel; // integrate\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // consider neighbors' neighbors\n                for (int x = 0; x < 4; ++x)\n                {\n                    ivec4 nbsNbs = ivec4(fxGetParticleData(nid, x));\n                    for (int y = 0; y < 2; ++y)\n                    {\n                        int nbNid = nbsNbs[y];\n                        if (nbNid < 0) break;\n                        sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                    }\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 3;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, state, id);\n    fragColor = fxSaveParticle(p, dataType);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec3 ro, vec3 rd)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    fxParticle p = fxGetParticle(id);\n    vec3 hitPos;\n    float t = fishIntersect(p, ro, rd, hitPos);\n\n    if (t == -1.) return FAR_CLIP;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, cameraPos, rayDir);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            for (int i = 0; i < 3; ++i)\n            {\n                ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j * 4 + i)));\n                ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n                int nid = nbs[h.y % 4];\n\n                if (nid >= 0)\n                {\n                    float dis2 = distance2Particle(nid, cameraPos, rayDir);\n                    insertion_sort( new, dis, nid, dis2 );\n                }\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 16u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 4; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, cameraPos, rayDir);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, cameraPos, rayDir));\n        }\n    }\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// draw one fish\nbool renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    vec3 normal;\n    float t = fishIntersect(p, ro, rd, normal);\n    if (t > 0. && t < pix.t)\n    {\n        pix.n = normal;\n        pix.t = t;\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        if (!renderParticle(id, data, cameraPos, rayDir, pix)) break;\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Lighting and shading first pass\n// ---------------------------------------------------------------------------------------\n\n// water surface borrowed from \"ocean under\" by rockhard\n//     https://shadertoy.com/view/7dyXWc\nfloat wavedx(vec2 position, vec2 direction, float time, float freq){\n    float x = dot(direction, position) * freq + time;\n    return exp(sin(x) - 1.0);\n}\n\nfloat getwaves(vec2 position){\n    float iter = 0.0,phase = 6.0,speed = 2.0;\n    float weight = 1.0,w = 0.0,ws = 0.0;   \n    for(int i=0;i<5;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        float res = wavedx(position,p,speed*iTime,phase);        \n        w += res * weight; ws += weight;\n        iter += 12.0; weight *=0.75; phase *= 1.18; speed *= 1.08;\n    }\n    return w / ws;\n}\nfloat sea_octave(vec2 uv,float choppy){\nreturn getwaves(uv*choppy)+getwaves(uv); }\n\nconst vec3 WATER_COLOR = vec3(0.0,0.39,0.62);\nvec3 water(vec3 cameraPos, vec3 rayDir)\n{\n    vec3 sun = vec3(-0.6, 0.5,-0.3); \n    float i = max(0.0, 1.4/(length(sun-rayDir)+1.0));\n    vec3 col = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8));\n    col = mix(col, WATER_COLOR,(1.0-rayDir.y)*0.9);   \n\n    if (rayDir.y > 0.0){//water suf\n        float d = (cameraPos.y-3.0)/rayDir.y;\t\n        vec2 wat = (rayDir * d).xz-cameraPos.xz;\n        d += sin(wat.x + iTime);\n        wat = (rayDir * d).xz-cameraPos.xz;     \n        wat = wat * 0.1 + 0.2* texture(iChannel0,wat*0.01).xz;      \n        col += sea_octave(wat,0.5) * max(2.0/-d, 0.0);\n    }\n    \n    return col*col*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel0, fragCoord/iResolution.xy));\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    if (pix.t >= FAR_CLIP)\n    {\n        fragColor.xyz = water(cameraPos, rayDir);\n    }\n    else\n    {\n        // ssao model inspired by SSAO (basic) by iq: https://www.shadertoy.com/view/Ms23Wm\n        // sample neighbor pixels\n        float ao = 0.0;\n        const float SAMPLES = 20.; // increase for higher quality if your GPU can handle it\n        for( float i=0.; i<SAMPLES; i++ )\n        {\n            vec3 h = hash3(uvec3(fragCoord, 0));\n\n            // get a random 2D offset vector\n            vec2 off = texture(iChannel1, (fragCoord.xy + 23.71*float(i)) / iChannelResolution[1].xy).xz - .5\n                + vec2(0, 1.); // shift search in the direction of normal\n            off += sign(off) * .0; // don't waste samples looking at nearby pixels\n\n            // sample the zbuffer at a neightbor pixel\t\t\n            fxGBufferPixel nbPix = fxUnpackGBuffer(texture(iChannel0, fragCoord.xy / iResolution.xy + off * .03));\n            \n            // accumulate occlusion if difference is less than 0.02 units\t\t\n            ao += clamp((pix.t-nbPix.t)/.02, 0., 1.);\n        }\n        \n        // average down the occlusion\t\n        ao = clamp(1. - ao/SAMPLES, 0., 1.);\n        \n        // lighting\n        vec3 hitPos = cameraPos + rayDir * pix.t;\n        float hf = (smoothstep(-.7, -.1, hitPos.y) * .9 + .1); // darken lowest area (cheat!) because ao doesn't reach far enough\n        if (keyDown(KEY_SHIFT)) { ao = 1.; hf = 1.; }\n        fragColor.xyz = ao * water(hitPos, pix.n) * .95 * hf + WATER_COLOR * .05;\n    }\n\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}