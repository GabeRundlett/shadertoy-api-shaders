{
    "Shader": {
        "info": {
            "date": "1723142426",
            "description": "originals  https://glslsandbox.com/e#75222.0",
            "flags": 0,
            "hasliked": 0,
            "id": "McByWd",
            "likes": 0,
            "name": "triange twist",
            "published": 3,
            "tags": [
                "triangle",
                "twist"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 77
        },
        "renderpass": [
            {
                "code": "\n\nvec2 offset = vec2(0.5, 0.5);\nfloat speed = 0.2;\n#define time iTime\n#define resolution iResolution.xy\n#define twopi 6.283185307179586  // 2*pi\n\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\n\nfloat tw()\n{\n\treturn sin(time) * 0.5 +0.5;\n}\n\nvec3 hue2rgb(float hue)\n{\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-0.75,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)));\n}\n\n\n#define PI 3.14159265359\n#define TWO_PI PI*2\n\n//DECLARO UNA FUNCION. ESTA FUNCION ME SIRVE PARA GENERAR POLIGONOS.\n//Funcion sacada de : https://thebookofshaders.com/07/\n//aunque la transformación a función fue hecha por jp.\n\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a)\n{\n    // Remap the space to -1. to 1.\n    vec2 st = p - uv ;\n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = PI*2.0/float(N);\n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,s+dif,d);\n    return e;\n}// end poly\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n\n//HAGO FUNCIONES PARA ESCALAR UVS EN UNA SOLA LINEA !!\nvec2 scale(vec2 uv,vec2 _sc)\n{\n    float fix = resolution.x/resolution.y; \n    uv-=vec2(0.5*fix,0.5);\n    uv = scale(_sc)*uv;\n    uv+=vec2(0.5*fix,0.5);\n    return uv;\n}\n//HAGO FUNCIONES PARA ROTAR UVS EN UNA SOLA LINEA !!\nvec2 rotate2d(vec2 uv,float _rot)\n{\n    float fix = resolution.x/resolution.y; \n    uv-=vec2(0.5*fix,0.5);\n    uv = rotate2d(_rot)*uv;\n    uv+=vec2(0.5*fix,0.5);\n    return uv;\n}\nconst float pi = 3.141592;\n\n//BPM\nconst float bpm = 128.;\n\nmat2 rot(float r)\n{\n  float s = sin(r);\n  float c = cos(r);\n  return mat2(c,s,-s,c);\n}\n\nvec2 myTwist(vec3 p,float power)\n{\n  float s = sin(power*p.z);\n  float c = cos(power*p.z);\n  mat2 n = mat2(c,s,-s,c);\n  return p.xy*n;\n}\n\nvec2 pmod(vec2 p,float r)\n{\n  float a = atan(p.x,p.y) + pi/r;\n  float n = pi *2. / r;\n  a = floor(a/n) * n;\n  return p*rot(-a);\n}\n\nfloat cube(vec3 p, vec3 s)\n{\n  vec3 q = abs(p) - s;\n  return max(max(q.x,q.y),q.z);\n}\n\nfloat map(vec3 p)\n{\n  float tbpm = time * bpm / 60.;\n\n  vec3 q = p;\n\n  if(mod(floor(tbpm),4.) <= 1.)\n  {\n     q.xy = myTwist(q,0.002*(time));\n  }\n  if(mod(floor(tbpm),4.) >= 2.)\n  {\n    q.xy = myTwist(q,0.0020*(time));\n  }\n\n  float obj = 0.;\n  float add = 1.;\n  for(int i = 0; i <20; i++)\n  {\n    \n   \n    q.z = mod(q.z,4.)-2.;\n    float d = cube(q,vec3(1.));\n    float d2 = cube(q,vec3(.5,.5,2.));\n    float d3 = cube(q,vec3(2.,.5,.5));\n    float d4 = cube(q,vec3(.5,2.,.5));\n    obj = max(max(max(d,-d2),-d3),-d4);\n    obj = min(obj,1e5);\n    add += .1;\n  }\n\n  return obj;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  float t = time * 2.0 * speed;\n\tvec2 p = (gl_FragCoord.xy/resolution.xy - offset)*resolution.xy;\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tp = vec2(0.056, t - log2(length(p.xy))) + atan(p.y, p.x) / twopi; \n   vec2 p4 = (gl_FragCoord.xy * 2. - resolution.xy) / min(resolution.x,resolution.y);\n    float fix = resolution.x/resolution.y;\n    uv.x*=fix;\n\n  float tbpm = time * bpm / 60.;\n  float seq = floor(tbpm);\n\n  //camera\n  vec3 cPos = vec3(0.,0.,10.);\ncPos.z+=iTime;\n  vec3 cDir = vec3(0.,0.,-1);\n  vec3 cUp = vec3(0.,1.,0.);\n  vec3 cSide = cross(cDir , cUp);\n  float targetDepth = 1.;\n\n  //ray\n  vec3 ray = normalize(p4.x * cSide + p4.y * cUp + cDir * targetDepth);\n\n  //color\n  float mainEmissive = 0.;\n  vec3 color = vec3(0.);\n\n  //raymarching\n  float dist = 0.;\n  float rLen = 0.;\n  vec3 rPos = cPos;\n\n  for(int i = 0; i< 128; i ++)\n  {\n    dist = map(rPos);\n    rLen += dist;\n    rPos = cPos + rLen * ray;\n    mainEmissive += exp(dist*-0.2);\n    if(dist < 0.001)\n    {\n      break;\n    }\n  }\n\n  float emissiveValue = mainEmissive * 0.11;\n\n  color = vec3(0.3,0.7,0.7);\n    vec2 p2 = vec2(0.5*fix,0.5) - uv;\n    float r = length(p);\n    float a = atan(p.x,p.y);\n    \n    const int cantidad = 10;//Defino la cantidad de iteraciones que tendra mi for\n    vec3 fin = vec3(0.0);//Defino un vec3 en el que ire sumando los circulos.\n    \n    vec2 uv2 = uv;\n\t\n    for( int i =0; i< cantidad; i++)\n    {\n        \n        float index = float(i)*PI*2.0/float(cantidad); \n        \n        \n        //ACA EL SCALE SE ESTA APLICANDO EN CADA BUCLE, ENTONCES EN CADA BUCLE A UV2 LE HACE UN SCALE \n        //*1.3, lo que equivale a hacerlo mas pequeño.\n        uv2 -= vec2(0.5*fix,0.5);\n        uv2 = scale(vec2(1.7))*uv2; \n        uv2 += vec2(0.5*fix,0.5);\n\n        //Esta tecnica es para que en una \n        //pasada del bucle sume figura y en la otra pasada del bucle reste.\n        //Entonces visualmente queda asi :\n        if(mod(float(i),2.0) == 0.0)\n\t{\n           // fin+= poly(uv2,vec2(0.5*fix,0.5),0.35,0.05,3,0);\n           //Aca hago que cambie el angulo en relación al indice y que gire para un lado\n            fin += poly(uv2,vec2(0.5*fix,0.5),0.35,0.05,3,index+time); \n        }\n\telse\n\t{\n            //fin-= poly(uv2,vec2(0.5*fix,0.5),0.4,0.05,3,0); \n            //Aca hago que cambie el angulo \n            //en relación al indice y que gire para el otro lado.\n            fin-= poly(uv2,vec2(0.5*fix,0.5),0.35,0.05,3,index-time); \n        }\n    }// end  for( int i =0; i< cantidad; i++)\n\tfloat r3 = fract(p.y+t);\n\n\tfragColor = vec4(hue2rgb(r3)*fin,1.0 - r); \n     fragColor*= vec4(color*emissiveValue,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}