{
    "Shader": {
        "info": {
            "date": "1489066550",
            "description": "It's just an experiment.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdfcRX",
            "likes": 11,
            "name": "inspiration of star wars ui",
            "published": 3,
            "tags": [
                "transparent",
                "starwars"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 1113
        },
        "renderpass": [
            {
                "code": "\n/**\nThis code is based on \"https://www.shadertoy.com/view/Md3SDB\". \nFrom my side, I just replaced geometory model to startwars ship model which I used iq's distance function. \n*/\n\nstruct tweenObj {\n    vec3 pos;\n};\n\nconst bool GlowEnabled = true;\nconst float WallDistance = 0.01;\nconst float GlowDistance = 0.00574;\n\nconst bool Jitter = true;\nconst float MarchDumping = 0.658;\nconst float Far = 64.0;\nconst int MaxSteps = 128;\n\n#define PI 3.141592\n#define RADIANS(x) ((x) * (PI / 180.0))\n\nvec4 QuatRotate (float x,float y,float z,float deg){\t\n    float rad = deg * (PI / 180.0) / 2.0;\n    float s = sin(rad);\n    return vec4(\n        cos(rad), //w\n        x * s, //x\n        y * s, //y\n        z * s //z\n    );\n}\n\nmat4 QuatRotateConvertToMatrix(vec4 q){\n    float s = sqrt(q.w * q.w + q.x * q.x + q.y * q.y\n                   + q.z * q.z);\n    s = 2.0 / (s * s);\n    float vx = q.x * s;\n    float vy = q.y * s;\n    float vz = q.z * s;\n    float wx = vx * q.w;\n    float wy = vy * q.w;\n    float wz = vz * q.w;\n    float sx = q.x * vx;\n    float sy = q.y * vy;\n    float sz = q.z * vz;\n    float cx = q.y * vz;\n    float cy = q.z * vx;\n    float cz = q.x * vy;\n\n    return mat4(\n        1.0 - sy - sz,\n        cz + wz,\n        cy - wy,\n        0.0,\n        cz - wz,\n        1.0 - sx - sz,\n        cx + wx,\n        0.0,\n        cy + wy,\n        cx - wx,\n        1.0 - sx - sy,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        1.0\n    );\n}\n\nfloat line( vec2 a, vec2 b, vec2 p ) {\n    vec2 aTob = b - a;\n    vec2 aTop = p - a;\n\n    float t = dot( aTop, aTob ) / dot( aTob, aTob);\n\n    t = clamp( t, 0.0, 1.0);\n\n    float d = length( p - (a + aTob * t) );\n    d = 0.001 / d;\n\n    d = pow(d, 10.0);\n    return clamp( d, 0.0, 0.6 );\n}\n\n// Hash by iq\nfloat hash(float h) {\n    return fract(sin(h) * 43758.5453123);\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { \n    return dot(v,v);\n}\n\n// bottom radius, top radius, height\nfloat sdCappedCone (vec3 p, vec3 s) {\n    vec2 q = vec2(length(p.xy),p.z);\n\n    vec2 ba = vec2(s.x - s.y, -2.0*s.z);\n    vec2 pa = vec2(q.x - s.y, q.y - s.z);\n\n    vec2 d = pa - ba * clamp(dot(pa,ba) / dot(ba,ba),0.0,1.0);\n    vec2 h0 = vec2(max(q.x - s.x,0.0),q.y + s.z);\n    vec2 h1 = vec2(max(q.x - s.y,0.0),q.y - s.z);\n\n    return sqrt(min(dot2(d),min(dot2(h0),dot2(h1))))\n        * sign(max(dot(pa,vec2(-ba.y, ba.x)), abs(q.y) - s.z));\n}\n\nfloat combine(float d1, float d2 ) {\n    if ( d1 < d2 ) return d1;\n    return d2;\n}\n\nfloat cubicOut(float t) {\n\tfloat f = t - 1.0;\n  \treturn f * f * f + 1.0;\n    /*\n    return t < 0.5\n        ? 4.0 * t * t * t\n        : -0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n    */\n}\n\nfloat tween(float t, float dur, float delay, float val, float now){\n    return cubicOut(clamp(t-delay,0.0,dur)/dur)*(val-now);\n}\n\nfloat map(vec3 p) {\n    tweenObj tobj;\n    tweenObj tobj2;\n    tobj.pos = vec3(0);\n    tobj2.pos = vec3(0);\n    float t = mod(iTime,4.0);\n\n    float val = tween(t,1.0,1.0,0.05,tobj.pos.x);\n    tobj.pos.x = val;\n    val += tween(t,1.0,3.2,0.0,tobj.pos.x);\n    tobj.pos.x = val;\n\n    float val2 = tween(t,1.0,1.2,0.03,tobj2.pos.x);\n    tobj2.pos.x = val2;\n    val2 += tween(t,1.0,3.0,0.0,tobj2.pos.x);\n    tobj2.pos.x = val2;\n\n    float v1 = sdHexPrism(p+vec3(0.0,0.0,0.15+tobj.pos.x), vec2(0.18,0.006) );\n    float v2 = sdHexPrism(p+vec3(0.0,0.0,0.14+tobj.pos.x), vec2(0.05,0.005) );\n    float v3 = sdHexPrism(p+vec3(0.0,0.0,-0.15-tobj.pos.x), vec2(0.18,0.006) );\n    float v4 = sdHexPrism(p+vec3(0.0,0.0,-0.14-tobj.pos.x), vec2(0.05,0.005) );\n    float v5 = sdCapsule(p, vec3(0), vec3(0), 0.08);\n\n    mat4 m = QuatRotateConvertToMatrix(QuatRotate(1.0,0.0,0.0,-180.0));\n    vec4 pos1 = (vec4(p,1.0)+vec4(0.0,0.0,0.10+tobj2.pos.x,0.05));\n    float v6 = sdCappedCone(pos1.xyz, vec3(0.015,0.04,0.045) );\n\n    vec4 pos2 = (vec4(p,1.0)+vec4(0.0,0.0,-0.10-tobj2.pos.x,0.05))*m;\n    float v7 = sdCappedCone(pos2.xyz, vec3(0.015,0.04,0.045) );\n\n    float res1 = combine(v1,v2);\n    float res2 = combine(v3,v4);\n    float res3 = combine(v5,v6);\n    float res4 = combine(v7,res1);\n    float res5 = combine(res2,res3);\n    float res6 = combine(res4,res5);\n    return res6;\n}\n\nfloat shapeProgress(float t) {\n    t = mod(t, 15.0);\n\n    float prog = 0.0;\n    prog += smoothstep(2.0, 3.0, t);\n    prog += smoothstep(5.0, 6.0, t);\n    prog += smoothstep(8.0, 9.0, t);\n    prog += smoothstep(11.0, 12.0, t);\n    prog += smoothstep(14.0, 15.0, t);\n\n    return prog;\n}\n\nvec3 render(vec3 ro, vec3 rd, mat4 m) {\n    float tmin = 0.0;\n    float tmax = Far;\n\n    float precis = 0.002;\n    float t = tmin;\n\n    vec3 accu = vec3(0.0);\n    float steps = 0.0;\n    float glowFactor = 0.0;\n\n    for (int i = 0; i < MaxSteps; i++) {\n        steps = float(i);\n        vec4 p = vec4(ro + rd * t,1.0)*m;\n        float d = map(p.xyz);\n        float absd = abs(d);\n\n        if (Jitter) {\n            absd *= 0.8 + hash(absd) * 0.2;\n        }\n\n        if (t > tmax) {\n            break;\n        }\n\n        glowFactor += pow(1.0 - smoothstep(0.0, GlowDistance, d), 14.0)\n            * step(0.0, d);\n        //float f = absd * (1.0 - smoothstep(0.0, WallDistance, absd));\n        //accu += vec3(f);\n\n        t += max(0.0001, absd * MarchDumping);\n    }\n    glowFactor /= steps;\n\n    if (GlowEnabled) {\n        accu += 0.7 * pow(glowFactor, 1.2) * vec3(0.0, 1.0, 1.0);\n    }\n    return accu;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.0 * p - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 3.5));\n    vec4 rotVec = QuatRotate(0.0,1.0,0.0,(time*20.0));//(time*10.0)\n    mat4 m = QuatRotateConvertToMatrix(rotVec);\n    vec3 col = render(ro, rd, m);\n    col = pow(col, vec3(1.2));\n\n    // left side UI\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*-0.2,1.0)-0.5;\n\n    vec3 colorUI = vec3(line(vec2(-0.499,1.0),vec2(-0.499,0.0),p));\n    colorUI += vec3(line(vec2(-0.37,1.0),vec2(-0.37,0.0),p));\n    colorUI += vec3(line(vec2(-0.499,1.0),vec2(-0.37,1.0),p));\n    colorUI += vec3(line(vec2(-0.499,0.0),vec2(-0.37,0.0),p));\n\n    colorUI += vec3(line(vec2(-0.434,0.9),vec2(-0.434,0.1),p));\n    colorUI += vec3(line(vec2(-0.48,0.5),vec2(-0.38,0.5),p));\n\n    colorUI += vec3(line(vec2(-0.499,0),vec2(-0.499,-1.0),p));\n    colorUI += vec3(line(vec2(-0.37,0),vec2(-0.37,-1.0),p));\n    colorUI += vec3(line(vec2(-0.499,0),vec2(-0.37,0),p));\n    colorUI += vec3(line(vec2(-0.499,-1.0),vec2(-0.37,-1.0),p));\n    colorUI += vec3(line(vec2(-0.434,-0.1),vec2(-0.434,-0.9),p));\n    colorUI += vec3(line(vec2(-0.48,-0.5),vec2(-0.38,-0.5),p));\n\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*-0.4,1.0)-0.5;\n\n    colorUI += vec3(line(vec2(-0.24,1.0),vec2(-0.24,0.0),p));\n    colorUI += vec3(line(vec2(-0.37,1.0),vec2(-0.24,1.0),p));\n    colorUI += vec3(line(vec2(-0.37,0.0),vec2(-0.24,0.0),p));\n\n    colorUI += vec3(line(vec2(-0.305,0.9),vec2(-0.305,0.1),p));\n    colorUI += vec3(line(vec2(-0.36,0.5),vec2(-0.25,0.5),p));\n\n    colorUI += vec3(line(vec2(-0.24,0),vec2(-0.24,-1.0),p));\n    colorUI += vec3(line(vec2(-0.37,0),vec2(-0.24,0),p));\n    colorUI += vec3(line(vec2(-0.37,-1.0),vec2(-0.24,-1.0),p));\n\n    colorUI += vec3(line(vec2(-0.305,-0.1),vec2(-0.305,-0.9),p));\n    colorUI += vec3(line(vec2(-0.36,-0.5),vec2(-0.25,-0.5),p));\n\n    // right side UI\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*0.5,1.0)-0.5;\n    colorUI += vec3(line(vec2(0.24,0.5),vec2(0.24,0.0),p));\n    colorUI += vec3(line(vec2(0.24,-0.2),vec2(0.24,-0.5),p));\n\n    p = fragCoord.xy / iResolution.xy;\n    p -= .5;\n    p.y += mod(p.y+time*0.2,0.8)-0.4;\n    colorUI += vec3(line(vec2(0.26,0.0),vec2(0.275,0.0),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*5.0));\n    colorUI += vec3(line(vec2(0.26,0.0),vec2(0.275,0.06),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*5.0));\n\n    colorUI += vec3(line(vec2(0.28,0.0),vec2(0.295,0.06),p))*vec3(sin(time*0.1*5.0));\n    colorUI += vec3(line(vec2(0.30,0.0),vec2(0.315,0.06),p))*vec3(sin(time*0.1*5.0));\n\n    colorUI += vec3(line(vec2(0.32,0.06),vec2(0.335,0.0),p))*vec3(sin(time*0.2*5.0));\n    colorUI += vec3(line(vec2(0.32,0.0),vec2(0.335,0.0),p))*vec3(sin(time*0.2*5.0));\n\n    colorUI += vec3(line(vec2(0.34,0.06),vec2(0.355,0.0),p))*vec3(sin(time*0.3*5.0));\n\n    colorUI += vec3(line(vec2(0.36,0.06),vec2(0.375,0.0),p))*vec3(sin(time*0.4*5.0));\n    colorUI += vec3(line(vec2(0.36,0.06),vec2(0.375,0.06),p))*vec3(sin(time*0.4*5.0));\n\n    colorUI += vec3(line(vec2(0.38,0.03),vec2(0.395,0.03),p))*vec3(sin(time*0.5*5.0));\n    colorUI += vec3(line(vec2(0.40,0.03),vec2(0.415,0.03),p))*vec3(sin(time*0.5*5.0));\n\n    colorUI += vec3(line(vec2(0.42,0.0),vec2(0.435,0.06),p))*vec3(sin(time*0.6*5.0));\n    colorUI += vec3(line(vec2(0.44,0.0),vec2(0.455,0.06),p))*vec3(sin(time*0.6*5.0));\n\n    colorUI += vec3(line(vec2(0.46,0.0),vec2(0.475,0.0),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*0.7*5.0));\n    colorUI += vec3(line(vec2(0.46,0.0),vec2(0.475,0.06),p))*vec3(1.0,0.0,0.0)*vec3(sin(time*0.7*5.0));\n\n    //\n    colorUI += vec3(line(vec2(0.26,0.2),vec2(0.275,0.26),p));\n    colorUI += vec3(line(vec2(0.28,0.2),vec2(0.295,0.26),p));\n\n    colorUI += vec3(line(vec2(0.30,0.2),vec2(0.315,0.2),p))*vec3(1.0,0.0,0.0);\n    colorUI += vec3(line(vec2(0.30,0.2),vec2(0.315,0.26),p))*vec3(1.0,0.0,0.0);\n\n    colorUI += vec3(line(vec2(0.32,0.2),vec2(0.335,0.2),p));\n    colorUI += vec3(line(vec2(0.32,0.26),vec2(0.335,0.2),p));\n\n    colorUI += vec3(line(vec2(0.34,0.2),vec2(0.355,0.26),p));\n\n    colorUI += vec3(line(vec2(0.36,0.26),vec2(0.375,0.26),p));\n    colorUI += vec3(line(vec2(0.36,0.26),vec2(0.375,0.2),p));\n\n    colorUI += vec3(line(vec2(0.38,0.2),vec2(0.395,0.26),p));\n    colorUI += vec3(line(vec2(0.40,0.2),vec2(0.415,0.26),p));\n\n    colorUI += vec3(line(vec2(0.42,0.26),vec2(0.435,0.2),p));\n    colorUI += vec3(line(vec2(0.44,0.26),vec2(0.455,0.2),p));\n\n    colorUI += vec3(line(vec2(0.46,0.26),vec2(0.475,0.2),p));\n    colorUI += vec3(line(vec2(0.46,0.2),vec2(0.475,0.2),p));\n\n    //\n    colorUI += vec3(line(vec2(0.26,0.46),vec2(0.275,0.4),p))*vec3(sin(time*0.1*5.0));\n    colorUI += vec3(line(vec2(0.26,0.4),vec2(0.275,0.4),p))*vec3(sin(time*0.1*5.0));\n\n    colorUI += vec3(line(vec2(0.28,0.4),vec2(0.295,0.46),p))*vec3(sin(time*0.5*5.0));\n    colorUI += vec3(line(vec2(0.30,0.4),vec2(0.315,0.46),p))*vec3(sin(time*0.5*5.0));\n\n    colorUI += vec3(line(vec2(0.32,0.46),vec2(0.335,0.4),p))*vec3(sin(time*0.2*5.0));\n\n    colorUI += vec3(line(vec2(0.34,0.46),vec2(0.355,0.4),p))*vec3(sin(time*0.2*5.0));\n\n    colorUI += vec3(line(vec2(0.36,0.4),vec2(0.375,0.46),p))*vec3(sin(time*0.3*5.0));\n    colorUI += vec3(line(vec2(0.36,0.46),vec2(0.375,0.46),p))*vec3(sin(time*0.3*5.0));\n\tcolorUI*=vec3(0.5,0.9,1.0);\n    fragColor = vec4(colorUI+col*vec3(3.0), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}