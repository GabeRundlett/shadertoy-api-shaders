{
    "Shader": {
        "info": {
            "date": "1469461936",
            "description": "A slightly more sophisticated version of my \"Abstract Tunnel\" example. A lot of it has been faked to keep the rendering speed up on slower machines.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xld3W4",
            "likes": 53,
            "name": "Abstract Island Cavern",
            "published": 3,
            "tags": [
                "tunnel",
                "raymarch",
                "water",
                "cavern"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2523
        },
        "renderpass": [
            {
                "code": "/*\n\n\tAbstract Island Cavern\n\t----------------------\n\n\tI made an \"Abstract Tunnel\" example a while back. The main motivation was to provide a very\n\tbasic tunnel template for anyone interested. I used the term \"abstract\" to describe the naive \n\trendering style - used to simulate the oldschool flat shaded polygon examples - that is  \n\tmildly reminiscent of abstract art.\n\n\tAnyway, this is a slightly more sophisticated version, but is built on the same premise. Like \n\tthe previous version, it's a tunnel system surfaced with a very basic triangle noise layer. \n\tRather than a single tunnel, this uses a more complex tunnel system created with some \n\tsinusoidal-based gyroid code, but it's simple enough. Other than that, there's some simple \n\twater, which is just a glorified, perturbed floor with some fake reflection and refraction.\n\n\tFor anyone interested in creating a simple tunnel system with minimal effort, the gyroid \n\ttunnel setup is worth looking at. As for cheap, jagged, noise-like surfacing, Nimitz's \n\ttriangle noise is impossible to improve on... but I'm still trying anyway. :)\n\n\tThe word \"abstract\" is a bit of a cop out in this case. I didn't have the cycles to perform \n\tall the required physics, like multiple reflection\\refraction passes, etc, so decided to fake \n\tit then call it \"abstract.\" It's kind of like using the terms \"alien\" and \"alternate reality\"\n\twhen the physics doesn't make any sense. So, with that in mind, this is an abstract rendering\n\tof a sea cavern setting on an alien planet in an alternate reality. :)\n\n\tAll things considered, the rendering speed is pretty reasonable, but I'd like to refine it \n\tsome more to accommodate slower machines than the one I'm currently on.\n\n\tBased on:\n\tAbstract Corridor - Shane\n\thttps://www.shadertoy.com/view/MlXSWX\n\t\n\t// Abstract rendering with triangle noise.\n\tSomewhere in 1993 - nimitz\n\thttps://www.shadertoy.com/view/Md2XDD\n\n\tMuch fancier example:\n\n\t// One of my favorites. In an idea world with fast computers, this is how I'd do it. :)\n\tLa calanque - XT95\n\thttps://www.shadertoy.com/view/Mst3Wr\n\n\n\n*/\n\n#define FAR 50. // Far plane, or maximum distance.\n\nfloat objID = 0.; // Object ID - Cavern: 0.; Water: 1..\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n \n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    //p = cos(p*3.14159 + iTime)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    \n    // Try this one for a regular, beveled Voronoi looking pattern. It's faster to\n    // hone in on too, which is a bonus.\n    p = fract(p)-.5;  \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //p = abs(p - (p.x+p.y+p.z)/3.);\n    //return dot(p, vec3(.5));\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n\n    \n}\n\n\n// The 3D tiling process. I've explained it in the link below, if you're interested in the process.\n//\n// Cellular Tiled Tunnel\n// https://www.shadertoy.com/view/MscSDB\nfloat cellTile(in vec3 p){\n    \n    \n    // Draw four overlapping objects at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw);//, v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    //d.x =  min(v.z, v.w) - min(v.x, v.y); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    d.x =  min(v.x, v.y); // First order.\n        \n    return d.x*2.66; // Normalize... roughly.\n    \n}\n\n/*\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){ return abs(fract(x)-.5); } // Triangle function.\n// PF - phase variance. Varies between zero and 1. Zero is redundant, as it returns the triangle function.\nvec3 trap(in vec3 x, float pf){ return (tri(x - pf*.125) + tri(x + pf*.125))*.5; } // Trapezoid function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n\n    \n\t//return dot(tri(p*.5 + tri(p*.25).yzx), vec3(0.666));\n    \n    p /= 2.75;//6.283;\n    //return dot(tri(p + tri(p.zxy)), vec3(0.666));\n    \n    // Trapezoidal function - created from two out of phase triangle functions. The second factor acts\n    // like a smoothing factor of sorts. One gives a longer topped trapezoid, and lesser values \n    // produce shorter tops -- effectively make it more pointy. A redundant value of zero produces\n    // a triangle function.\n    return dot(trap(p + trap(p.zxy, .666), .666), vec3(0.666));\n    \n    //return dot(tri(p*.5 + tri(p.yzx*0.25)), vec3(4.5/9.)) + dot(tri(p.yzx + tri(p*.5)), vec3(1.5/9.));\n \n    //p *= 6.283;\n    //return dot(sin(p*.5 + sin(p.yzx*0.25))*.66 + sin(p.yzx + sin(p*.5))*.34, vec3(.166)) + .5;\n \n\n}\n\n// Perturbing the sea floor. Just a very basic sinusoidal combination.\nfloat surfFunc2(in vec3 p){\n    \n\treturn dot(sin(p + sin(p.yzx*2. + iTime*2.)), vec3(.1666)) + .5; \n\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.2 + a*1., t);\n    \n}\n\n\n// The cavern scene. The tunnel system is created with a sinusoidal lattice structure,\n// and a triangle function variation provides the jagged surfacing. The sea is nothing\n// more than a plane perturbed with a sinusoidal function. Everything is wrapped around\n// a winding path.\n// \n// By the way, I could use all sorts of trickery to slim this down and speed things up\n// but it's more readable this way.\n//\nfloat map(vec3 p){\n       \n\t\n    float sea = p.y + 3.5; // Sea level. Just a plane.\n    float sf = surfFunc(p); // Tunnel surface function.\n    // Sinusoial tunnel system. It doesn't need to be produced here, but it looks more\n    // random if it is.\n    float cav = abs(dot(cos(p*3.14159/6.), sin(p.yzx*3.14159/6.)) + 1.5);\n    \n    p.xy -= camPath(p.z).xy; // Offsetting the main tunnel by the camera path.\n  \n    float tun = 2. - length(p.xy); // Main tunnel.\n    \n    // Smoothly combining the main tunnel with the sinusoidal tunnel system.\n    tun = smax(tun, 1.-cav, 1.) + .35 + (.5-sf);\n    \n    // Perturbing the sea floor to create a watery effect... Lame watery effect. :)\n    sf = surfFunc2(p);\n    sea += (.5-sf)*.5;\n    \n    objID = step(sea, tun); // Determining the sea or cavern object ID.\n    \n    return min(sea, tun); // Combining the sea with the cavern (tunnel system).\n \n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.5, occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.015, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.0025, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.85;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(abs(h), 0.01, 0.25);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (h<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n// Surface bump function. Cheap, but with decent visual impact. Used for the water surface.\nfloat bumpSurf3D( in vec3 p){\n    \n    return cellTile(p*.5)*.7 + cellTile(p)*.3;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tpl(iChannel1, rd/3., sn).zyx;\n    //tx = smoothstep(0.2, 1., tx*2.); \n    //float c = dot(tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 6.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 4.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, .25, 0);\n    vec2 a = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    //loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2(-camPath(lk.z).x/16. )*r.xy;\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t;\n        \n        float ed; // Edge variable.\n        vec3 n = nr(p, ed);\n        \n        vec3 svn = n;\n        \n        // Texture bump the normal.\n\n        // Bump mapping.\n        float sz = .5;\n        if(sObjID>.5) { // Sea.\n            sz = .25;\n            n = dbF(p, n, .25); // Function bump.\n            n = db(iChannel1, p*sz, n, .005/(1. + t/FAR)); // Texture bump.\n        } \n        else { // Cavern. \n            n = db(iChannel0, p*sz, n, .02/(1. + t/FAR)); // Texture bump only.\n        }\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        float at = 1./(1. + d*.25 + d*d*.05); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 16.); // Specular term.\n        float fr = pow(clamp(1.0 + dot(r, n), 0.0, 1.0), 2.); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping.\n        vec3 tx;\n        if(sObjID<.5) {\n            tx = tpl(iChannel0, p*sz, n)*1.35; // Rock texturing.\n            tx *= mix(vec3(1), vec3(1.35, 1, .65), abs(n)); // Fake angular coloring.\n        }\n        else {\n            tx = tpl(iChannel1, p*sz, n)*vec3(2, 2.4, 2.8); // Sea water texturing.\n        }\n\n        \n\n        // Extra shading. Not really necessary, but I like it for extra depth.\n        float sf;\n        \n        if(sObjID<.5){ // Rock surface shading.\n        \tsf = surfFunc(p); \n        }\n        else { // Sea surface shading.\n            vec3 txp = p;\n        \ttxp.xy -= camPath(txp.z).xy;\n            sf = surfFunc2(txp)*.8 + .2;\n            sf *= bumpSurf3D(p)*.8 + .2;\n        }\n        \n        tx *= sf; // Applying the surface shading to the texture value.\n        \n\n\t\t// Very simple scene coloring. Diffuse, ambience and specular.\n        col = tx*(di + vec3(.75, .75, 1)) + vec3(.5, .7, 1)*sp;\n        col += (tx*.5 + .125)*vec3(.5, .7, 1)*fr; // A touch of Fresnel.\n        \n        // Edges.\n        col *= 1. - ed*.75; // Darker edges.\n\n        // Fake environment mapping.\n        vec3 ref, refr;\n        vec3 em; \n        \n        if(sObjID>.5){ // Water.\n            // Fake reflection and refraction to give a bit of a watery look, albeit\n            // in a nonbelievable abstract fashion.\n            //col *= .5;\n            ref = reflect(r, svn*.5 + n*.5);\n            em = eMap(ref, n);\n            ref = tpl(iChannel0, ref, n)*em*4.;\n            refr = refract(r, svn*.5 + n*.5, 1./1.33);\n        \tem = eMap(refr, n); \n        \trefr = tpl(iChannel0, refr, n)*em*2.;\n            //col += (refr + ref)*4.;\n            col += mix(refr, ref, fr*fr)*8.;\n        }\n        else {\n            ref = reflect(r, svn*.75 + n*.25);\n            em = eMap(ref, n);\n            col += col*em*3.; // Cavern walls.\n        }\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    // If we've hit the far plane, calulate \"l\" only.\n    if(t>=FAR) l = normalize(l - o - r*FAR);\n \t\n    // Produce some colored fog.\n    vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), l.y*.5 + .5);\n    col = mix(clamp(col, 0., 1.), bg.yzx, smoothstep(0., FAR-2., t));\n     \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}