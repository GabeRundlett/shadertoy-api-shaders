{
    "Shader": {
        "info": {
            "date": "1668385552",
            "description": "OBSOLETE, SEE: https://www.shadertoy.com/view/DdfSRr\nUsed multiple declarations to avoid the recursion limit.\n\n10 seconds to compile with 3 recursion steps.\nTakes 300+ seconds to compile with more than 4+ recursion depth levels, but runs FAST.",
            "flags": 0,
            "hasliked": 0,
            "id": "ms23Dd",
            "likes": 3,
            "name": "Pixel Dist (OBSOLETE)",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field",
                "signed"
            ],
            "usePreview": 1,
            "username": "Hatchling",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "// WARNING: Compilation times are slow with more than 3 levels of recursion.\n//          Currently with 3 levels it takes 10 seconds.\n//          4 levels of recursion takes 300+ seconds to compile!!\n//          But after compilation it is very fast!\n//          Increase recursion level at your own risk!\n\n// TODO: Perhaps if I make the recursive function smaller\n//       by moving most of the logic into other functions that it calls,\n//       it'll be easier for the compiler to parse.\n\n// Controls =================================\n// Mouse + Click: Change the distance checked position.\n\n// Colors ===================================\n// Black Cell:       Cell fully empty.\n// Blue Cell:        Cell partially occupied (contains an edge).\n// Light Blue Cell:  Cell fully occupied.\n// Red-Tinted Cells: Cells checked for occupancy.\n// Orange Circle:    Distance of found cell.\n// Whtie Circle:     Final distance.\n\n\nconst int mipCount = 11;\nconst int maxMip = mipCount - 1;\n\nbool containsEdge(bool mySign, ivec2 coord, int mipLevel)\n{\n    float occupancy = cubeFetch(iChannel0, coord, mipLevel).r;\n\n    if(mySign)\n    {\n        return occupancy < 1.;\n    }\n    else\n    {\n        return occupancy > 0.;\n    }\n}\n\nbool isOccupied(vec2 uv)\n{\n    float occupancy = cubeLod(iChannel0, uv, 0.0).r;\n    return occupancy > 0.;\n}\n\n\nvoid GetSubsampleCoords(bool xNeg, bool yNeg, bool absXGtAbsY, out ivec4 c01, out ivec4 c23)\n{\n    int r = 0x1B; // 00 10 01 11;\n    \n    if(xNeg)\n    {\n        const int xor = 0xAA; // 10 10 10 10\n        r = r ^ xor;\n    }\n    \n    if(yNeg)\n    {\n        const int xor = 0x55; // 01 01 01 01\n        r = r ^ xor;\n    }\n    \n    if(!absXGtAbsY)\n    {\n        const int xor = 0x3C; // 00 11 11 00\n        r = r ^ xor;\n    }\n    \n    const ivec4 c01_m = ivec4\n    (\n        0x80, // 10 00 00 00\n        0x40, // 01 00 00 00\n        0x20, // 00 10 00 00\n        0x10  // 00 01 00 00\n    );\n    \n    const ivec4 c01_s = ivec4\n    (\n        7,\n        6,\n        5, \n        4 \n    );\n    \n    const ivec4 c23_m = ivec4\n    (\n        0x08, // 00 00 10 00\n        0x04, // 00 00 01 00\n        0x02, // 00 00 00 10\n        0x01  // 00 00 00 01\n    );\n    \n    const ivec4 c23_s = ivec4\n    (\n        3, \n        2, \n        1,\n        0\n    );\n    \n    c01 = (ivec4(r) & c01_m) >> c01_s;\n    c23 = (ivec4(r) & c23_m) >> c23_s;\n}\n\n// Returns the minimum distance from\n// a given coordinate to a square whose minimum\n// is coord, and whose maximum is coord+(1,1).\nfloat getMinDistSqr(vec2 point, ivec2 coord)\n{\n    vec2 squareCenter = vec2(coord) + vec2(0.5);\n    vec2 centerToPoint = point - squareCenter;\n    vec2 minOffset = clamp(centerToPoint, vec2(-0.5), vec2(0.5));\n    return lengthSqr(centerToPoint - minOffset);\n}\n\nconst vec4 DebugBoundsCheckColor    = vec4(0.0, 0.0, 1.0, 0.25);\nconst vec4 DebugEdgeCheckColor      = vec4(1.0, 0.0, 0.0, 0.25);\nconst vec4 DebugStackIncrementColor = vec4(0.0, 1.0, 1.0, 0.25);\nconst vec4 DebugStackLimitColor     = vec4(0.0, 1.0, 0.0, 0.5);\nconst vec4 DebugSubDistCloserColor  = vec4(1.0, 0.5, 0.0, 1.0);\nconst vec4 DebugSubDistFurtherColor = vec4(0.5, 1.0, 0.0, 1.0);\n\nconst int ErrorStackUnderflow = 0;\nconst int ErrorStackOverflow = 1;\nconst int ErrorInvalidState = 2;\n\nvoid drawCharacter(vec4 fontColor, in ivec2 fontElement, in vec2 fragCoord, inout vec4 fragColor)\n{\n    if(fontElement.x >= 16 || fontElement.y >= 16 || fontElement.x < 0 || fontElement.y < 0)\n        fontElement = ivec2(0);\n    \n    vec4 text = sampleFontElementColor(iChannel2, fragCoord, fontElement, fontColor);\n    \n    blend(text, fragColor);\n}\n\nvoid drawError(in int errorID, in int data, in vec2 fragCoord, inout vec4 fragColor)\n{\n    const vec4 ErrorStackUnderflowColor = vec4(1.0, 0.2, 0.0, 1.0);\n    const vec4 ErrorStackOverflowColor = vec4(1.0, 0.2, 0.2, 1.0);\n    const vec4 ErrorInvalidStateColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    ivec2 fontElement;\n    vec4 fontColor;\n    \n    switch(errorID)\n    {\n        case ErrorStackUnderflow:\n            fontElement = ivec2(1 + data, 9);\n            fontColor = ErrorStackUnderflowColor;\n            break;\n        case ErrorStackOverflow:\n            fontElement = ivec2(1 + data, 11);\n            fontColor = ErrorStackOverflowColor;\n            break;\n        case ErrorInvalidState:\n            fontElement = ivec2(1 + data, 11);\n            fontColor = ErrorInvalidStateColor;\n            break;\n    }\n    \n    if(fontElement.x >= 16 || fontElement.y >= 16 || fontElement.x < 0 || fontElement.y < 0)\n        fontElement = ivec2(0);\n    \n    vec4 text = sampleFontElementColor(iChannel2, fragCoord, fontElement, fontColor);\n    \n    blend(text, fragColor);\n}\n\n// Define the function in a way that recursion is easy to type.\n// Too bad multi-line macros are not supported.\n#define SSH(name) float name\n#define SSA00 (\n#define SSA01     float      distSqrToSignChange,\n#define SSA02     ivec2      samplingCoord, \n#define SSA03     int        mip, \n#define SSA04     vec2       testCoord,\n#define SSA05     in bool    testOccupied,\n#define SSA06     vec2       fragTestCoord,\n#define SSA07     vec2       originalFragCoord,\n#define SSA08     inout vec4 fragColor\n#define SSA09 )\n#define SSA10 {\n#define SSA11     mip -= 1;\n#define SSA12     distSqrToSignChange *= 4.0;\n#define SSA13     samplingCoord *= 2;\n#define SSA14     testCoord *= 2.0;\n#define SSA15     fragTestCoord *= 2.0;\n    \n                  // Get the subsample coordinates sorted by distance to the sample.\n#define SSA16     ivec2 subsampleCoords[4];\n#define SSA17     {\n#define SSA18         vec2 testToSample = vec2(samplingCoord + ivec2(1)) - testCoord;\n#define SSA19         bool xNeg = testToSample.x < 0.;\n#define SSA20         bool yNeg = testToSample.y < 0.;\n#define SSA21        bool absXGtAbsY = abs(testToSample.x) > abs(testToSample.y);\n#define SSA22        ivec4 c01, c23;\n#define SSA23        GetSubsampleCoords(xNeg, yNeg, absXGtAbsY, c01, c23);\n#define SSA24        subsampleCoords[0] = c01.xy;\n#define SSA25        subsampleCoords[1] = c01.zw;\n#define SSA26        subsampleCoords[2] = c23.xy;\n#define SSA27        subsampleCoords[3] = c23.zw;\n#define SSA28    }\n    \n                 // Go through subsamples from closest to furthest.\n#define SSA29    for(int iSub = 0; iSub < 4; iSub++)\n#define SSA30    {\n#define SSA31        ivec2 subsamplingCoord = samplingCoord + subsampleCoords[iSub];\n#define SSA32        float subsampleDistSqr = getMinDistSqr(testCoord, subsamplingCoord);\n        \n#define SSA33        if(!(subsampleDistSqr < distSqrToSignChange))\n#define SSA34            continue;\n    \n#define SSA35        if(floorToInt(fragTestCoord) == subsamplingCoord)\n#define SSA36            fragColor += vec4(0.1,0,0,0);\n\n#define SSA37        if(!containsEdge(testOccupied, subsamplingCoord, mip))\n#define SSA38            continue;\n            \n#define SSA39        float temp =\n\n                     // Non recursive\n#define SSB00        subsampleDistSqr;\n\n                     // Recursive   \n#define SSR(name)    name                     \n#define SSC00        (\n#define SSC01            distSqrToSignChange, \n#define SSC02            subsamplingCoord,\n#define SSC03            mip,\n#define SSC04            testCoord,\n#define SSC05            testOccupied,\n#define SSC06            fragTestCoord,\n#define SSC07            originalFragCoord,\n#define SSC08            fragColor\n#define SSC09        );\n\n#define SSD00        distSqrToSignChange = min(distSqrToSignChange, temp);\n\n#define SSD01         drawCircle\n#define SSD02         (\n#define SSD03             testCoord,\n#define SSD04             fragTestCoord,\n#define SSD05             sqrt(temp),\n#define SSD06             0.01,\n#define SSD07             vec4(1.0, 0.5, 0.1, 1.0),\n#define SSD08             fragColor\n#define SSD09         );\n#define SSD10     }\n    \n#define SSD11     return distSqrToSignChange * 0.25;\n#define SSD12 }\n\n// Combine all of the lines into one macro.\n#define SSA_0 SSA00 SSA01 SSA02 SSA03 SSA04 SSA05 SSA06 SSA07 SSA08 SSA09\n#define SSA_1 SSA10 SSA11 SSA12 SSA13 SSA14 SSA15 SSA16 SSA17 SSA18 SSA19\n#define SSA_2 SSA20 SSA21 SSA22 SSA23 SSA24 SSA25 SSA26 SSA27 SSA28 SSA29\n#define SSA_3 SSA30 SSA31 SSA32 SSA33 SSA34 SSA35 SSA36 SSA37 SSA38 SSA39\n\n#define SSC_0 SSC00 SSC01 SSC02 SSC03 SSC04 SSC05 SSC06 SSC07 SSC08 SSC09\n\n#define SSD_0 SSD00 SSD01 SSD02 SSD03 SSD04 SSD05 SSD06 SSD07 SSD08 SSD09\n#define SSD_1 SSD10 SSD11 SSD12\n\n#define SS_HEADER(n)        SSH(n)\n#define SS_START            SSA_0 SSA_1 SSA_2 SSA_3\n#define SS_TERMINATING      SSB00\n#define SS_RECURSIONCALL(n) SSR(n)\n#define SS_RECURSIVE        SSC_0\n#define SS_END              SSD_0 SSD_1\n\n#define SS_DECLARE_TERMINATING(name) SS_HEADER(name) SS_START SS_TERMINATING SS_END\n\n#define SS_DECLARE_RECURSIVE(name, calls) SS_HEADER(name) SS_START SS_RECURSIONCALL(calls) SS_RECURSIVE SS_END\n\n#define RECURSION_DEPTH 3\nSS_DECLARE_TERMINATING(SubSample3)\nSS_DECLARE_RECURSIVE(SubSample2, SubSample3)\nSS_DECLARE_RECURSIVE(SubSample, SubSample2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    ivec2 maxMipSize = textureSize(iChannel0, maxMip); \n    \n    vec2 centerUV = vec2(0.5);\n    vec2 centerTestCoord = centerUV * vec2(maxMipSize);\n    ivec2 centerTestIntCoord = floorToInt(centerTestCoord);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(maxMipSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    bool mouseIsOccupied = isOccupied(mouseUV); \n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(maxMipSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    \n    if(fragTestIntCoord == centerTestIntCoord)\n    {\n        for(int i = maxMip-RECURSION_DEPTH; i <= maxMip; i++)\n        {\n            ivec2 mipSize = textureSize(iChannel0, i);\n            bool fragIsOccupied = containsEdge(false, ivec2(fragUV * vec2(mipSize)), i);   \n            bool fragIsOccupied2 = containsEdge(true, ivec2(fragUV * vec2(mipSize)), i);   \n\n            fragColor += fragIsOccupied ? vec4(0.1, 0.2, 0.5, 1) : vec4(0);\n            fragColor += !fragIsOccupied2 ? vec4(0.1, 0.2, 0.5, 1) : vec4(0);\n\n            \n            // Remove this to show all mip levels explored.\n            // (You'll have to change the colors a bit though.)\n            break;\n        }\n            \n        // Compress the range to 0-1\n        //fragColor /= vec4(1.0, 0.5, 0.25, 0.001) + fragColor;\n    }\n    \n    float distSqrToSignChange = 100000.0;\n\n    if(containsEdge(mouseIsOccupied, centerTestIntCoord, maxMip))\n    {\n        distSqrToSignChange = SubSample\n        (\n            distSqrToSignChange,\n            centerTestIntCoord, \n            maxMip, \n            mouseTestCoord,\n            mouseIsOccupied,\n            fragTestCoord,\n            fragCoord,\n            fragColor\n        );   \n    }\n         \n    drawCircle\n    (\n        mouseTestCoord,\n        fragTestCoord,\n        sqrt(distSqrToSignChange),\n        0.01,\n        vec4(1, 1, 1, 1.0),\n        fragColor\n    );\n    \n    // Compress the range to 0-1\n    fragColor /= vec4(0.25) + fragColor;\n    fragColor = smoothstep(vec4(0), vec4(1), fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\n\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nconst int DataCompleteFrame = 4;\n\n// Sampling Order -------------------------------\n// Frame 0: Imprecise version calculated.\n// Frane 2: Precise version calculated.\n//     Depends on:\n//         - Sampling Order, Frame 0\n//         - Sampling Distance, Frame 1\n// Frame 3: Ready.\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\nconst int SamplingOrderFrameImprecise = 0;\nconst int SamplingOrderFramePrecise = 2;\n\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n\nvec4 DebugSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec3 d = GetSamplingOrderCoord(n, data);\n    \n    \n    vec4 color = vec4\n    (\n        vec3(d.xyz) / vec3(vec2(10), 5), \n        1\n    );\n    \n    color.xyz /= (1.0 + abs(color.xyz));\n    color.xy += 0.5;\n    return color;\n}\n\n// Cached Sampling Distances -------------------------------\n// Frame 1: Calculate minimum distance between Pixel[0] and Pixel[N].\n//     Depends on:\n//         - Sampling Order, Frame 0\n// Frame 3: Recalculate distances with new precise ordering.\n//     Depends on:\n//         - Sampling Order, Frame 2\nconst int SamplingDistanceRow = 1;\nconst int SamplingDistanceFrameImprecise = 1;\nconst int SamplingDistanceFramePrecise = 3;\nfloat GetSamplingDistance(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingDistanceRow);\n    \n    return texelFetch(data, coord, 0).x;\n}\n\nvec4 DebugSamplingDistance(int n, sampler2D data)\n{\n    float d = GetSamplingDistance(n, data);\n    \n    d *= 0.01;\n    d = d / (1.0 + d);\n    \n    vec4 color = vec4(1);\n    color.rgb = hsv2rgb(vec3(d, 1.0, 1.0));\n    return color;\n}\n\n\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow: fragColor = DebugSamplingOrderCoord(iCoord.x, dataChannel); return;\n        case SamplingDistanceRow: fragColor = DebugSamplingDistance(iCoord.x, dataChannel); return;\n    }\n    \n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This is a really stupid work-around to enforcing power-of-two buffers... but whatever.\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy; \n    \n    uv += vec2(0.1);\n    \n    fragColor = texture(iChannel0, uv).r > 0.7 ? vec4(1) : vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}