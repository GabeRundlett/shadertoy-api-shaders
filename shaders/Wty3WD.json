{
    "Shader": {
        "info": {
            "date": "1578912890",
            "description": "old shebang\n",
            "flags": 40,
            "hasliked": 0,
            "id": "Wty3WD",
            "likes": 20,
            "name": "[music] Ghidra",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "bytebeat",
                "dnb"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 1056
        },
        "renderpass": [
            {
                "code": "\n// REWIND SHADER TO MAKE SOUND WORK.\n\n// Some old stuff I never released\n// THE VISUALS ARE VERY BASED ON https://www.shadertoy.com/view/4t2cR1\n// WAS LEARNING MAKING TUNNELS\n\n// Anyways, the main part is the sound.\n// The drop bass uses a bunch of bytebeats, also the hihats.\n// Bytebeat base code is from someone on shadertoy, but I don't recall who.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 f = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    col += f;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define start_offset (0.)\n\n// - time divisions - //\n#define tmp    129.\n#define msr    ((tmp/100.)*8.)\n#define dmsr   (msr*2.)\n#define hmsr   (msr/2.)\n#define qmsr   (hmsr/2.)\n#define bar    (tmp/100.)\n#define hbar   (bar/2.)\n#define beat   (bar/4.)\n#define hbeat   (beat/2.)\n#define qbeat  (beat/4.)\n#define sbeat  (qbeat/4.)\n\n#define pi acos(-1.)\n#define tau acos(-1.)*2.\n\n// - sequencer functions - //\n#define M(N) (floor(t/msr)== N) \n#define Q(synth, env, seq) hit = t-seq<0.?0.:t-seq ; s += synth*env;\n\n// - utils - //\nfloat sidechain(float t){\n    float hit  = mod(t, bar/1.);\n    float hit2 = clamp(mod(t + bar/3. ,bar), 0., 1.);\n    float env1 = exp(-hit*20.); \n    float env2 = exp(-hit2*20.);\n\treturn env1 + env2;\n}\n\n\nfloat rnd(float i){\n\treturn fract(sin(i)*1235.41252156);\n}\n\nfloat nois(float t){\n    float n = 0.;\n    n = fract(rnd(t)*rnd(t*2.41));\n    vec2 p = vec2(fract(rnd(t*14.11)),fract(rnd(t*124.1)*rnd(t*3.15)));\n    vec2 q = vec2(fract(rnd(t*14.124)*rnd(t*41.15)), n*0.15);\n    n = fract(dot(p,q));\n    \n\treturn n;\n}   \nfloat freq(float n, float o){\n\treturn pow(27.5, ((o*12.) + n)/12.);\n}\nfloat n(vec2 i){\n //   i *= 2.;\n //return fract(dot(vec2(i.x*1.6525, i.y*1.512), i)*24124.124124);\n return fract(sin(dot(vec2(i.x*1.6525, i.y*1.512), i)*2124.124124));\n //return fract(sin(dot(vec2(i.x*1.6525, i.y*1.512), i)*2124.124124)*214124.12412);\n}\nfloat hash(float i){\n\treturn fract(sin(114.121*i)*11252.11242512);\n}\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\nfloat random(float st){\n\treturn fract(sin(st*21451.24124)*st*1.2314);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n// ----- sound stuff ----- //\nfloat env(float attack, float hold, float release, float t){\n    float res=0.;\n    float releaseRange = 4.;\n    if (release > releaseRange) release = releaseRange;\n    if (t < attack){\n    \t//res=mix(exp(t - 2.) - exp(-2.), 1.,t/attack);\n        res=mix(0., 1.,t/attack);\n        //res = 0.;\n    } else if (t < attack + hold) {\n    \tres=1.;\n    } else{\n    \tres = exp((-t+attack + hold)*mix(4.,0.,release/releaseRange));\n        // \n    }\n    \n\treturn res;\n}\n\n\nfloat note(float note, float octave){\n\treturn 27.5*pow(2., ((octave*12.) + note )/12.);\n}\n\nmat2 rot(float deg){return mat2(cos(deg), sin(-deg), sin(deg), cos(deg));}\n\nvec3 getRd (vec3 ro,vec3 lookAt ,vec2 uv){\n    vec3 look = normalize(lookAt - ro);\n\tvec3 r = normalize(cross(vec3(0,1,0), look));\n    vec3 u = normalize(cross(look, r));\n    return look + r*uv.x + u*uv.y;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define max_steps   250\n#define min_dist \t0.001\n#define max_dist \t400.\n\n#define T           iTime\n#define my          (590.*iMouse.y/iResolution.y + T*20.)\n#define mx          (20.*iMouse.x/iResolution.x)\n\n#define shaking\n//#define pi \t\t\t(acos(-1.))\n\n// -- globals -- //\nint scene = 2;\nint id = 0; // 1 is ground, 2 is struct\nint idS= 0;     // ids for structs. 0 is black, 1 is white, 2 is whatever\nfloat DGROUND = 0.;\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat r31(vec3 p) {\n\tfloat h = dot(p,vec3(127.1,811.7, 542.1));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n//    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    //return j;\n    float h = mix(i, j, fd.z); \n        \n    float res = h;\n    \n\treturn res;\n}\n\nfloat fbm(vec3 uv){\n    \n    uv*= 0.05;\n    \n\tfloat res = 0.;\n    \n    \n//    uv = abs(uv);\n    \n    res += valueNoise(uv*2.)*7.;\n    res += valueNoise(uv*8.)*0.4;\t\n    res += valueNoise(uv*21.)*0.4;\t\n    \n    \n\treturn res;\n}\n\nfloat sdBox(vec3 p,vec3 s){\n    p = abs(p);\n\treturn max(p.y - s.y,max(p.x - s.x, p.z - s.z) );\n\n}\nvec2 offsTunn(vec3 p){\n    vec2 off = vec2(0);\n    \n    p.z *= 0.01;\n    off.x += cos(p.z);\n    off.y += sin(p.z);\n    \n    off *= 100.;\n    \n\treturn off;\n}\nfloat sdGround(vec3 p){\n\tfloat d = 100.;\n    vec3 q = p;\n    q.xy += offsTunn(q);\n    float dGround = -(length(q.xy) -29.);\n    d = min(d, dGround);\n    d = min(d, d - fbm(q)*1.9);\n    d = min(d, d - fbm(q*2.5)*1.9);\n    DGROUND += d;\n    return d/3.;\n}\nfloat curve(float t, float d) {\n  float g=t/d;\n  float it=fract(g);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), it);\n}\n\nfloat tick(float t, float d) {\n  float g=t/d;\n  float it=fract(g);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  return floor(g) + it;\n}\n\n\nfloat sdGeometry(vec3 p){\n\tfloat d = 100.;\n    \n    // ----- Geom ----- // \n    // -- base box\n    vec3 pB = vec3(0,-1.,0);\n    vec3 sB = vec3(0.4, 0.05 ,1.0);\n\tfloat dBox = sdBox(p - pB, sB);\n    // -- base2 box\n    vec3 pBU = pB + vec3(0,sB.y,0);\n    vec3 sBU = sB*0.9;\n\tfloat dBoxU = sdBox(p - pBU, sBU);\n    // -- pipes\n    vec3 sP = vec3(0.07,0.5,0.07);\n    vec3 pP = vec3(sB.x*0.75,-0.5,sB.z*0.8);\n    float dPipes = sdBox(p - pP, sP);\n    dPipes = min(dPipes, sdBox(p - vec3(-pP.x,pP.y,pP.z), sP));\n    dPipes = min(dPipes, sdBox(p - vec3(-pP.x,pP.y,-pP.z), sP));\n    dPipes = min(dPipes, sdBox(p - vec3(pP.x,pP.y,-pP.z), sP));\n    // -- top box\n    vec3 sBT = vec3(sB.x*0.3, sB.y, sB.z);\n    vec3 pBT = pB + vec3(sB.x - sBT.x,sP.y*2.,0);\n\tfloat dBoxT = sdBox(p - pBT, sBT);\n\tdBoxT = min(sdBox(p - vec3(-pBT.x, pBT.y, pBT.z), sBT), dBoxT);\n    // -- mid box\n    vec3 sBM = vec3(sB.x/2.,sB.y,sB.z);\n    vec3 pBM = vec3(0.,-1.+sP.y,0);\n    float dBoxM = sdBox(p - pBM, sBM);\n    // -- mid box2\n    vec3 sBM2 = vec3(1.);\n    vec3 pB2M = vec3(0.,-1.+sP.y,0);\n    float dBoxM2 = sdBox(p - pBM, sBM);\n    \n    \n    \n    // ------ end ----- //\n    d = min(d, dBox);\n    d = min(d, dBoxU);\n\td = min(d, dBoxT);\n\td = min(d, dBoxM);\n\td = min(d, dPipes);\n    // -- material ids -- //\n    dBox<=d ? idS=1 : dBoxU<=d ? idS=2 : dPipes<=d ? idS=3 : dBoxT<=d? idS=1 :\n    dBoxM<=d ? idS=4: idS=0;\n    \n\n\t    \n    return d;\n}\n\nfloat sdStructScene1(vec3 p){\n\tfloat d = 100.;\n    vec3 pOrig = p;\n    float sep =  35.;\n    float id = floor(p.z/sep);\n    \n    float dist=50.0;\n    p = (fract(p/dist+.5)-.5)*dist;\n    \t\n    for (float i = 0.; i < 4.; i++ ){\n    \n        p.x -= 2.4;\n        p.y -= 0.1;\n        p.xz *= rot(0.31);\n        p.yz *= rot(0.51);\n        p.z -= 2.9;\n        \n    \tp.x = abs(p.x);\n    \tp.z = abs(p.z);\n    \tp.y = abs(p.y);\n    }\n    \n    \n    \n    \n    d = min(d, sdGeometry(p));\n    \n    return d;\n}\n\nfloat sdStructScene2(vec3 p){\n\tfloat d = 100.;\n    p.xy += offsTunn(p);\n    float sep =  35.;\n    float id = floor(p.z/sep);\n    p.z = mod(p.z, sep) -sep/2.;\n    \n    float reps = 5.;\n\tpModPolar(p.xy, reps);    \n    vec3 polarP = vec3(reps - 1., 0., 0.);\n    \n    for (float i = 0.; i < 3.; i++){\n    \tp.y -= 0.5;\n    \tp.x -= 1.5 - curve(T + id, 1.5)*1.9;\n    \tp=abs(p);\n\t\tp.z -= 0.9 + fract(id*2144.124)*0.5;\n        \n    \tp.yz *= rot(4.5 + sin(T*0.2  + id)*0.5);\n    \tp.xz *= rot(0.4);\n    }\n    \n    p -= polarP;\n    d = min(d, sdGeometry(p));\n    \n    return d;\n}\nfloat map(vec3 p){\n\tfloat d = 100.;\n    float dStruct;\n    float dTunnGround;\n    if (scene == 1){\n    \tdStruct = sdStructScene1(p);\n        dTunnGround = 10000.;\n    }\n    else if (scene == 2){\n    \tdStruct = sdStructScene2(p);\n        dTunnGround = sdGround(p);\n    }\n    d = min(dStruct, d);\n    d = min(d, dTunnGround);\n   \tdStruct <= d ? id = 1 : dTunnGround <= d ? id = 2 : id = 0;\n    return d;\n}\n\nvec3 normal (vec3 p){\n\tvec2 e = vec2(0.001, 0);\n\treturn normalize(map(p) - vec3(\n    \tmap(p - e.xyy),\n    \tmap(p - e.yxy),\n    \tmap(p - e.yyx)\n    ));\n\n}\n\nvec3 shake(vec3 p){\n\tp.y += fract(sin(p.z*1.1))*0.01;\n\tp.x += fract(sin(p.z*2.1))*0.01;\n    return p;\n}\n#define spectra(t) (0.9  + sin(t + 1.5 + 2.*vec3(0.1,0.4,0.6) )*0.4   )\n#define spectra2(t, beat) (-0.5 + beat  + sin(t + 4.9 + 1.*vec3(0.9,0.4,0.6) )*0.6   )\nvec4 render(vec2 uv){\n\tvec3 col = vec3(0);\n\n    vec3 ro;\n    vec3 lookAt;\n    float trig;\n    if (scene == 1){\n        float z = 30.;\n        ro = vec3(0. , 0,-1. );\n        ro.x += sin(mx)*z; ro.z += cos(mx)*z;\n        lookAt = vec3(0. ,0,0.);\n        trig = 1.;\n    } else if (scene == 2){\n        ro = vec3(0. , 0,-11. + my);\n        #ifdef shaking\n    \tro = shake(ro);\n        #endif\n        ro.xy -= offsTunn(ro);\n        lookAt = vec3(0. ,0,-8. + my);\n        lookAt.xy -= offsTunn(ro + vec3(0,0,3));\n        trig = exp(-mod(T, 0.5));\n    }\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 glow = vec3(0);\n    vec3 glow2= vec3(0);\n    float t = 0.; vec3 p = ro;\n    for (int i = 0; i<max_steps; i++){\n    \tfloat h = map(p);\n    \n        if (h < min_dist || t > max_dist) break;\n        glow += spectra(t*0.05)*0.02;\n        glow2+= spectra2(t*0.05, trig)*0.02;\n        t += h;\n        p += h * rd;\n    }\n    if (scene == 1){\n        glow2.g *= 0.9;\n        col =  glow2*20.; \n        col *= 0.1;\n        \n        col -= t*0.0009;\n        //col *= shade(p, ro, rd);\n    }\n    else if (scene == 2){\n        if (id == 2){\n            //col -= DGROUND*0.01;\n            col = glow ;\n            float restraint = clamp(exp(-length(glow)*1.95 + 2.34),0., 1.);\n            //col *= restraint;\n            //col.b *= restraint;\n            //col.b = col.b*0.4 + col.b*restraint*0.6;\n\n            col.g = pow(col.g, 2.);\n            //col.g -= DGROUND*0.001;\n        } else {\n            glow2.g *= 0.9;\n            col =  glow2*20.; \n            col *= 0.1;\n            //col *= shade(p, ro, rd);\n        }\n    \n    }\n    \n    \n    //col += t*0.02;\n    \n    \n    return vec4(col, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 f = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    vec3 z = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    float d = texelFetch(iChannel1, ivec2(fragCoord), 0).w;\n    \n    \n    float blurAmt = 0. + clamp(exp(-d*5.),0.,1.);\n    \n    \n    \n    \n    col += f*(1. - blurAmt);\n    //col += z*blurAmt*8.5;\n\n    col.g /= d*1.3;\n    col.b/= d*1.3;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvec2 sAmbG(float t, float freq){\n\tvec2 s = vec2(0);\n    t = mod(t, hmsr);\n    float iters = 3. + clamp( exp(-t/2.)*5., 0., 30.);\n    for (float i = 1.;i < iters; i++){\n    \ts += sin(t*tau*freq*i)/i;\n    }\n    \n    vec2 n = noise(t);\n    vec2 sOrig = s;\n    float tMod = sin(t*8.)*(1. + exp(t/2.- 1.)*0.3);\n    float tMod2 = cos(t*2.)*0.5;\n    s = sOrig*sin(freq*4.*t*tau + n.x*0.4  + tMod          );\n    s += sOrig*sin(freq*2.*t*tau + n.y*0.4 + tMod2        );\n    s += sOrig*(fract(freq*8.*t*tau + n.y*0.4 -tMod + tMod2  ));\n\n    s /= 4.;\n    \n    return s;\n}\nvec2 gPadSaw(float t){\n\tvec2 s = vec2(0);\n\tfloat hit;\n    \n    if(M(0.) || M(1.)  ){\n        t = mod(t, msr*2.);\n        if (t<hmsr){\n        \ts += sAmbG(t, note(1.,2.));\n    \t\ts += sAmbG(t, note(6.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n        } else if (t<msr){\n        \ts += sAmbG(t, note(3.,2.));\n    \t\ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.));\n        } else if (t<msr+hmsr){\n        \ts += sAmbG(t, note(4.,2.));\n    \t\ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n        }\n\t\telse if (t<msr*2.){\n        \ts += sAmbG(t, note(3.,2.));\n    \t\ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(9.,2.));\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.));\n        }    \t\n        \n    } else if (M(2.) || M(3.)){\n        t = mod(t, msr*2.);\n        if (t<hmsr){\n        \ts += sAmbG(t, note(5.,2.));\n    \t\ts += sAmbG(t, note(10.,2.));\n    \t\ts += sAmbG(t, note(13.,2.));\n        } else if (t<msr){\n        \ts += sAmbG(t, note(7.,2.));\n    \t\ts += sAmbG(t, note(11.,2.));\n    \t\ts += sAmbG(t, note(13.,2.));\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.));\n        } else if (t<msr+hmsr){\n        \ts += sAmbG(t, note(8.,2.));\n    \t\ts += sAmbG(t, note(11.,2.));\n    \t\ts += sAmbG(t, note(13.,2.));\n        }\n\t\telse if (t<msr*2.){\n            float expMod = exp(-mod(t - msr -hmsr/2., msr)*0.2)*0.5;\n            float revExpMod = exp(mod(msr+hmsr, msr)*0.05 - 1.)*0.5;\n            float pitchDown =  1. + revExpMod*sin(t*(30. + revExpMod*400.))*0.04 - expMod;\n        \ts += sAmbG(t, note(7.,2.)*pitchDown);\n    \t\ts += sAmbG(t, note(11.,2.)*pitchDown);\n    \t\ts += sAmbG(t, note(13.,2.)*pitchDown);\n            if (t>msr -hmsr/2.) s += sAmbG(t, note(10.,2.)*pitchDown);\n        }    \t\n    \n    }\n    return s;\n}\nvec2 gIntroAmb(float t){\n    vec2 s = vec2(0);\n    \n    float iters = 30.;\n    if (M(0.) || M(1.)){\n        for (float i = 0.; i<iters; i++){\n            float f = 1900.+ hash(i)*(170. + sin(t)*300. );\n            f*= 0.33;\n            float tex = texture(iChannel0, vec2(i/1000.)).x;\n            s += (sin(t*f)*noise(vec2(f*i*0.1,f*i*0.11))*tex)/iters;\n        }\n    } else if(M(2.) || M(3.)){\n        for (float i = 0.; i<iters; i++){\n            float m1 = exp(t*0.25 - 4.)*13.;\n            float m2 = sin(t*(1. + m1*0.006));\n            float f = 1900.+ hash(i)*(170. + m1 + m2  );\n            f*= 0.33;\n            \n            if (t>(msr*3.75)){\n                float h = t - msr*3.75;\n                f *= 1. + (1./(h+1.)+ 1.)*4.; \n            }\n            float tex = texture(iChannel0, vec2(i/1000.)).x;\n            s += (sin(t*f)*noise(vec2(f*i*0.1,f*i*0.11))*tex)/iters;\n        }\n    } \n    s *= 4.;\n    return s;\n\n}\n\nvec2 gSub(float t){\n\tvec2 s = vec2(0);\n    \n    \n    if (M(0.)){\n    \n    }\n    else if (M(4.) || M(5.)){\n        if (t < bar)\n        \ts += sin(freq(2.05 + clamp(exp(-mod(t,bar))*4., 0., 8.), 1.)*tau*t);\n        else\n            s += sin(note(10.1,0.)*tau*t);\n        \n    } if ( M(6.) || M(7.) || M(8.) || M(9.)){\n       \ts += sin(note(10.1,0.)*tau*t);\n    }\n    float satAmt = 0.4;\n    \n    \n    // sidechain\n    float hit  = mod(t, bar/1.);\n    float hit2 = clamp(mod(t + bar/3. ,bar), 0., 1.);\n    float env1 = exp(-hit*10.); \n    float env2 = exp(-hit2*10.);\n    s *= clamp( 1. - env1*5. - env2 *5.,0., 1.) ;\n    \n    \n    return s;\n}\nvec2 gKick(float t){\n    vec2 s = vec2(0);\n\tfloat hit  = mod(t, bar/1.);\n    float hit2 = clamp(mod(t + bar/3. ,bar), 0., 1.);\n    \n    if (M(0.) || M(1.) ){\n    \n    } else if(M(2.) || M(3.)){\n        if (t > msr*3.5 && t < msr*3.75){\n        \thit  = mod(t, beat*2.);\n        \ts += sin(tau*(30. + exp(-hit*40.)*10.));\n        }\n        \n    \t else if (t > msr*3.75){\n        \thit  = mod(t, qbeat);\n        \ts += sin(tau*(30. + exp(-hit*40.)*10.));\n        } else {\n            s += sin(tau*(30. + exp(-hit*40.)*10.));\n            s += sin(tau*(30. + exp(-hit2*40.)*10.));\n            s *= 0.4;\n        }\n    }\n    else if (M(4.) || M(5.) || M(6.) || M(7.)|| M(8.) || M(9.)){\n    \tfloat rel = 12.;\n        s += sin(tau*15.*exp(-hit*rel*2./3.))*exp(-hit*rel*2.);\n        s += sin(tau*10.*exp(-hit*66.))*exp(-hit*rel*6.)/2.;\n        s += sin(tau*15.*exp(-hit2*rel*2./3.))*exp(-hit2*rel*2.); \n        s += sin(tau*10.*exp(-hit2*66.))*exp(-hit2*rel*6.)/2.;    \n    }\n\n\n    \n    s  = s + (s / (0.2 + abs(s)));\n    s *= 0.4;\n    s = clamp(s, -1., 1.);\n    s *= 2.;\n    return s;\n}\nvec2 gSnare(float t){\n\tvec2 s = vec2(0);\n    \n    float hit = mod(t + hbar/2.,hbar);\n    \n    if (M(2.) || M(3.)){\n        if (t > msr*3.5){\n        \tfloat tMod = t - msr*3.5;\n            s += sin(tau*( (9.5 + - exp(tMod)*10.)*clamp(exp(-hit*(95. )),0.15,0.5)));\n            //s += sin(tau*( (9.5 + - exp(tMod)*10.)*clamp(exp(-hit*(95. )),0.15,0.5)));\n            s = s/(1.4 - abs(s));\n            \n        } else{\n            s += sin(tau*( 9.5*clamp(exp(-hit*95.),0.15,0.6)));\n            s = s/(1.6 - abs(s));\n        }\n        \n    }\n    else if (M(4.) ||M(5.)  || M(6.) || M(7.) || M(8.) || M(9.)  || M(10.) || M(11.) ){\n    \n    \ts += sin(tau*freq(12.+ 1.2*exp(-hit*26.) ,0.))*exp(-hit*18.);    \t\n            \n        float satAmt = 0.5;\n        s = s*(1.-satAmt) +  (s / (0.99 -abs(s)))*satAmt;\n        //s *= 0.7;\n        s = (s + nois(t + rnd(t))*s*3.)/2.; \n    \n    }\n\n    \n\n    s *= 0.9;\n    s = clamp(s, -1., 1.);\n    \n    return s;\n    \n}\nvec2 gHats(float time){\n    \n\tfloat s;\n    int t = int(time*iSampleRate/7.);\n    t = int(time*iSampleRate);\n    float currentMeasure = floor(time/(msr));\n    if (currentMeasure<4.){\n        if (currentMeasure < 1.)\n        \ttime = mod(time, beat*2.);\n         else \n            time = mod(time, beat);\n        \n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 3.;\n    }\n    if (currentMeasure==4.){\n        time = mod(time, beat);\n    \tt = t % ((t >>3) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 3.;\n    }\n    else if (currentMeasure==5.){\n        time = mod(time, beat);\n    \tt = t % ((t >>2) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 9.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 4.;\n    } else if (currentMeasure==6. || currentMeasure==7. || currentMeasure==8.|| currentMeasure==9.  ){\n        time = mod(time, beat);\n    \tt = t % ((t >>2) % t*2);\n        s =float(t & 0xff - 128)/ 128.;\n        s *= pow(exp(-mod(time,qbeat*20.)), 9.);\n        s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n        s *= 4.;\n    \n    }\n    \n    \n    //s = clamp(s, -1., 1.);\n    \n    \n    return vec2(float(s));\n}\nvec2 gHats2(float time){\n    if (time < msr*2.) return vec2(0);\n    \n    if (mod(time, hmsr) < 0.25){\n    \ttime = mod(time, qbeat*8.) - hbeat;\n    } else {\n    \ttime = mod(time, qbeat*4.) - hbeat;\n    }\n\t\n\tfloat s;\n    int t = int(time*iSampleRate);\n    \n    t = t % ((t >>2) % t*2);\n    s =float(t & 0xff - 128)/ 128.;\n    s *= pow(exp(-mod(time,qbeat*20.)), 30.);\n    s = (s + (s*nois(time * mod(time, 0.001)*100.))*9.*exp(-time));\n    s *= 3.;\n\treturn vec2(s);\n}\n\nvec2 gBass(float time){\n\tfloat s;\n    int t = int(time*iSampleRate/7.);\n    \n    //time +=hmsr + bar;\n    if (floor(time/msr)==0. || floor(time/msr)==1. || floor(time/msr)==2. || floor(time/msr)==3. ){\n    \treturn vec2(0.);\n    } \n    \n    else if (floor(time/msr)==4.){\n        time = mod(time, msr);\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>6)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>1)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>2)*(t<<4);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*4.)\n           \tt = t&(t>>1)*(t<<1);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*4.)\n           \t//t = t&((t>>2)*(t<<5))*(t>>int(exp(-mod(time,bar)*2.)*2. + 4.));    \n            t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n        else\n            t = 0;\n    } else if (floor(time/msr)==5.){\n        time = mod(time, msr);\n        //time += hmsr + beat*3.; \n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>4)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>6)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>8)*(t<<2);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*4.)\n           \tt = t&(t>>1)*(t<<1);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*4.){\n            t = int(time*iSampleRate/7.);\n            int tMod = (t*int(sin(time*hmsr) + 1.));\n           \t//t = t<<((t<<29*t)&(t*4));\n            t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*2. + 6.));    \n    \t}\n            //t = t&((t>>3)*(t<<2))*(t>>int(exp(-mod(time,bar)*3.)*1. + 2.));    \n        else\n            t = 0;\n    } else if (floor(time/msr)==6.){\n        time = mod(time, msr);\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>2)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>2)*(t<<3);    \n        else if(time < bar)\n           \tt = t&(t>>2)*(t<<4);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*3.)\n           \tt = t&(t>>2)*(t<<1);    \n        else if(time < bar*4.)\n           \tt = t&(t>>1)*(t<<1);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*2.75)\n           \t//t = t&((t>>2)*(t<<5))*(t>>int(exp(-mod(time,bar)*2.)*2. + 4.));    \n            t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n        else \n            t = t&((t>>6)*(t<<2))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n    } else if (floor(time/msr)==7.){\n        time = mod(time, msr);\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat)\t\n    \t\tt = t&(t>>9)*(t<<1);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>5)*(t<<1);    \n        else if(time < bar)\n           \tt = t&(t>>2)*(t<<4);    \n        else if(time < bar*2.)\n           \tt = t&(t>>1)*(t<<1);    \n        else if(time < bar*3.)\n           \tt = t&(t>>2)*(t<<3);    \n        else if(time < bar*4.){\n            t = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%190)%(t<<16);\n        }\n       //    \tt = t&(t>>1)*(t<<2);\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < hmsr + bar*2.75){\n            t = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%520)%(t<<16);\n        }\n           \t//t = t&((t>>2)*(t<<5))*(t>>int(exp(-mod(time,bar)*2.)*2. + 4.));    \n        //    t = t&((t>>6)*(t<<3))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.));    \n        else \n            t = t&((t>>6)*(t<<2))*(t>>int(exp(-mod(time,bar)*2.)*1. + 6.)); \n    } else if (floor(time/msr)==8.){\n    \ttime = mod(time, msr);\n        //time += hmsr + bar*0.75;\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat*2.)\t\n    \t\tt = t&(t>>4)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>4)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>5)*(t<<4);    \n        else if(time < hmsr){\n           \tt = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%120)%(t<<16);\n        }\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < msr*2.){\n\t\t\tt = t%(1*(t<<1)&(t<<2)*10);\n            //t = (t%900)>>(t>>20);\n        }\n    } else if (floor(time/msr)==9.){\n    \ttime = mod(time, msr);\n        //time += hmsr + bar*0.75;\n        t = int(time*iSampleRate/7.);\n    \tif(time < beat*2.)\t\n    \t\tt = t&(t>>4)*(t<<3);\n    \telse if(time < beat*2.)\n    \t\tt = t&(t>>4)*(t<<4);    \n        else if(time < bar)\n           \tt = t&(t>>5)*(t<<4);    \n        else if(time < hmsr){\n           \tt = 1*t%(2*(t<<2)&(t<<2)*10);\n            t = (t%120)%(t<<16);\n        }\n        // halfmsr\n        else if(time < hmsr + beat*3.)\n           \tt = t&(t>>5)*(t<<1);    \n        else if(time < hmsr + bar)\n           \tt = t&(t>>6)*(t<<3);    \n        else if(time < msr*2.){\n\t\t\tt = t%(1*(t<<1)&(t<<2)*10);\n            //t = (t%900)>>(t>>20);\n        }\n    }\n    \n    s = float(t & 0xff - 128)/128.;\n    s = s*2.- 1.;\n    // FX\n    \n    //sc\n    s *= 1.-(sidechain(time)*2.);\n    s *= 1.-(clamp(exp(-mod(time + hbar/2.,hbar)*6.), 0., 5.))*0.2;\n    //fm\n    s =s + s*sin(tau*time*10200.)*0.3;\n    \n    \n    \n    s = s/(0.1 - abs(s));\n    \n    s = clamp(s, -1., 1.);\n\n\treturn vec2(s);\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s = vec2(0);\n    \n    //t*=2.;\n    //t += start_offset;\n    \n    float volHats = 0.6;\n        \n    if (M(5.) || M(6.) || M(7.) || M(8.) ){\n    \tvolHats = 0.94;\n    }\n    \n    \n    \n    s += gKick(t)*0.5;\n    s += gSnare(t)*1.;\n    s += gHats(t)*volHats;\n    s += gHats2(t)*0.2;\n    s += gBass(t)*0.115;\n    s += gSub(t)*0.4;\n    s += gPadSaw(t)*0.2;\n\ts += gIntroAmb(t)*0.5;\n\n    if (t < msr*4.){ s*= 0.45;};\n    if (M(3.)){\n    \tif (t > msr*3.95)\n        {\n        \ts *= exp(-(t - msr*3.95)*0.5);\n        }\n    }\n    \n    s *= 0.6;\n    s = clamp(s, -1., 1.);\n    return s;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}