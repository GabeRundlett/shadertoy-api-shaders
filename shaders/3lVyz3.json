{
    "Shader": {
        "info": {
            "date": "1611451888",
            "description": "Some space folding tests.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lVyz3",
            "likes": 6,
            "name": "Testing space folding",
            "published": 3,
            "tags": [
                "testing",
                "space",
                "folding"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "/*Visualizing how different space folding techniques work.\nUse grid, gradient and marker to help see whats happening.\n\nGrid = 0.1 units every grid cell\nGradient red = x position value, green = y position value\nMarker pointy end = negative y position\n*/\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat triwave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //2d position coordinate\n    vec2 pos = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float fold = mod(floor(iTime/10.),4.);//loop through different folds over time\n    //fold = 1.;//or set a specific fold\n    if (iTime < 2.) fold = -1.;//show no fold at start as reference\n    \n    \n    //mirror fold\n    if (fold == 0.) {\n        pos = abs(pos)-triwave(iTime*.1);\n    }\n    \n    //plane fold\n    if (fold == 1.) {\n        vec2 pnorm = vec2(sin(iTime),cos(iTime));\n        pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n    }\n    \n    //box fold\n    if (fold == 2.) {\n        float ext = triwave(iTime*.13)*.5;\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n    \n    //polar/circular fold\n    if (fold == 3.) {\n        float sz = .1+2.*pow(triwave(iTime*.0876),4.),\n            ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n        pos = vec2(sin(ang),cos(ang))*length(pos)-vec2(0.,.5);\n    }\n\n\n    //visualize position as grid, gradient(red = x, green = y) and line(pointy end = negative y)\n    vec2 gpos = abs(mod(abs(pos),.1)-.05);//1 grid cell = 0.1 units\n    float grid = min(gpos.x,gpos.y);\n    \n    fragColor = vec4(pos.x*.5+.5,pos.y*.5+.5,0,1)*//gradient\n            clamp(max(0.,grid-.002)*iResolution.y*.2,0.,1.)+//grid\n            max(0.,1.-length(max(abs(pos)-vec2(pos.y>0.?.02:.02-abs(pos.y)*.1,.2),0.))*iResolution.y*.2);//line\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}