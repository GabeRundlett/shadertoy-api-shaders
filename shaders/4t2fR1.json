{
    "Shader": {
        "info": {
            "date": "1514592675",
            "description": "Some Ray Marching with 2 light",
            "flags": 0,
            "hasliked": 0,
            "id": "4t2fR1",
            "likes": 2,
            "name": "Ray Marching Phong Template",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "alijaya",
            "viewed": 748
        },
        "renderpass": [
            {
                "code": "#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n\tvec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\n// change this\nfloat sdScene( vec3 p ) {\n    float sphere = sdSphere( p, 220. );\n    float box = sdBox(p, 200., 50., 200.);\n    float cylinder = sdCylinder(p, 150., 250.);\n    return sdSubstract(sdIntersect(box, sphere), cylinder);\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n    \tsdScene(p+xe) - sdScene(p-xe),\n        sdScene(p+ye) - sdScene(p-ye),\n        sdScene(p+ze) - sdScene(p-ze)\n    ));\n}\n\n// ray marching algorithm\nfloat getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d );\n        \n        if (dist < EPSILON) { // inside a scene\n            return depth;\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return MAX_DISTANCE;\n        }\n    }\n    \n    return MAX_DISTANCE;\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n    \n    // create 8 points of cube\n    vec3 points[8];\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            for (int k=0; k<2; k++) {\n                points[i*4+j*2+k] = vec3(float(i) * 2. - 1., float(j) * 2. - 1., float(k) * 2. - 1.);\n            }\n        }\n    }\n    \n    // render\n    float dist = getSDF(ray);\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n    vec3 diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(500. * sin(iTime), 500. * cos(iTime), 400.);\n    light1.color = vec3(1., 0.5, 0.3);\n    \n    Light light2;\n    light2.pos = vec3(1000. * cos(iTime), 400., 1000. * sin(iTime));\n    light2.color = vec3(1., 0.8, 0.5);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}