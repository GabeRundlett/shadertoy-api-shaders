{
    "Shader": {
        "info": {
            "date": "1705499744",
            "description": "blood vessel\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4cfXRf",
            "likes": 5,
            "name": "blood Vessel",
            "published": 3,
            "tags": [
                "bloodvessel"
            ],
            "usePreview": 0,
            "username": "kenshin",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 150\n#define MIN_DIST  .0001\n#define MAX_DIST  100.\n#define F         6\n\nmat2 rot2d(float radian)\n{\n    float c = cos(radian);\n    float s = sin(radian);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdPlane(vec3 p, float h)\n{\n    return p.y - h;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias)\n{\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy)) - bias) / scale - thickness;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 sdScene(vec3 p)\n{\n    float plane = sdPlane(p, -1.3);\n    vec3 p0 = p;\n    p0.xz *= rot2d(iTime * .143);\n    p0.yz *= rot2d(iTime * .289);\n    float sphere = sdSphere(p0, .99);\n    float scale = 16.123765;\n    float increase = 20.;\n    float g1 = sdGyroid(p0, scale, .03, 1.);\n    \n    for(int i = 0; i < F; i++)\n    {\n        scale += increase;\n        float g = sdGyroid(p0, scale, .03, .3);\n        g1 -= g * .15;\n    }\n    g1 += sdGyroid(p0, 100., .03, .3) * .1;\n    sphere = max(sphere, g1 * .50);\n    if(sphere < plane)\n    {\n        return vec2(sphere, 1.);\n    }\n    else\n    {\n        return vec2(plane, 0.);\n    }\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec3(sdScene(p).x);\n    vec2 delta = vec2(0.0001, .0);\n    n -= vec3(\n        sdScene(p - delta.xyy).x,\n        sdScene(p - delta.yxy).x,\n        sdScene(p - delta.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 rayMarching(vec3 ro, vec3 rd)\n{\n    float t = .0;\n    vec2 dist;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + t * rd;\n        dist = sdScene(p);\n        t += dist.x;\n        if(dist.x < MIN_DIST || t > MAX_DIST) break;\n    }\n    return vec2(t, dist.y);\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 ro, vec3 light, vec3 col, float shinness)\n{\n    \n    vec3 camDir = normalize(ro - p);\n    vec3 lightDir = normalize(light - p);\n    vec3 h = normalize(camDir + lightDir);\n    float diff = max(dot(lightDir, n), .0);\n    float specular = pow(max(dot(h, n), .0), shinness);\n    return diff * col + specular * vec3(1.) + vec3(.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    //mouse.y = mouse.y * .5 + .5;\n    \n    vec3 ro = vec3(0, 0, -1.7);\n    vec3 rd = vec3(uv, 1.);\n    \n    //rotate Camera\n    ro.xz *= rot2d(mouse.x);\n    rd.xz *= rot2d(mouse.x);\n    ro.yz *= rot2d(mouse.y);\n    ro.yz *= rot2d(mouse.y);\n    \n    vec2 d = rayMarching(ro, rd);\n    vec3 col = vec3(.0);\n    vec3 lightPos = vec3(-.5, 5.1, -.5);\n    if(d.x < MAX_DIST)\n    {\n        vec3 p = ro + rd * d.x;\n        vec3 n = getNormal(p);\n        if(d.y == 1.)\n        {\n            vec3 n = getNormal(p);\n            //n = n * .5 + .5;\n            //col = n;\n            float g = sdGyroid(p, 12.123765, .03, .3);\n            d *= smoothstep(-0.9, .1, g);\n            col = shade(p, n, ro, lightPos, vec3(0.741,0.039,0.039), 1024.);\n            col *= d.x * 1.5;\n            //col = pow(col, vec3(2.2));\n        }\n        else\n        {\n            col = shade(p, n, ro, lightPos, vec3(0.769,0.769,0.769), 32.);;\n            //shadow ray\n            vec3 ld = normalize(lightPos - p);\n            vec3 lo = p + ld * 0.001;\n            vec2 dd = rayMarching(lo, ld);\n            if(dd.x < MAX_DIST)\n            {\n                col *= .5;\n            }\n            \n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}