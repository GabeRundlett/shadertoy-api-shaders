{
    "Shader": {
        "info": {
            "date": "1718211761",
            "description": "The code I wrote is old, so it is very messy and difficult to read..\nChange params in common \n\nATTENTION: you need to move the camera with wasd and use C to switch render modes",
            "flags": 48,
            "hasliked": 0,
            "id": "43G3WV",
            "likes": 7,
            "name": "My simple slow pt renderer",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 1,
            "username": "MinimilisticBits",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "/*\nWASD to move\nMouse to pan camera\nC to switch rendering modes\n*/\n\n//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n//////////////////////////////////\nvec3 mul3(in mat3 m, in vec3 v) {\n  return vec3(dot(v, m[0]), dot(v, m[1]), dot(v, m[2]));\n}\n\nvec3 mul3(in vec3 v, in mat3 m) { return mul3(m, v); }\n\nvec3 srgb2oklab(vec3 c) {\n\n  mat3 m1 =\n      mat3(0.4122214708, 0.5363325363, 0.0514459929, 0.2119034982, 0.6806995451,\n           0.1073969566, 0.0883024619, 0.2817188376, 0.6299787005);\n\n  vec3 lms = mul3(m1, c);\n\n  lms = pow(lms, vec3(1. / 3.));\n\n  mat3 m2 = mat3(+0.2104542553, +0.7936177850, -0.0040720468, +1.9779984951,\n                 -2.4285922050, +0.4505937099, +0.0259040371, +0.7827717662,\n                 -0.8086757660);\n\n  return mul3(m2, lms);\n}\n\nvec3 oklab2srgb(vec3 c) {\n  mat3 m1 = mat3(1.0000000000, +0.3963377774, +0.2158037573, 1.0000000000,\n                 -0.1055613458, -0.0638541728, 1.0000000000, -0.0894841775,\n                 -1.2914855480);\n\n  vec3 lms = mul3(m1, c);\n\n  lms = lms * lms * lms;\n\n  mat3 m2 = mat3(+4.0767416621, -3.3077115913, +0.2309699292, -1.2684380046,\n                 +2.6097574011, -0.3413193965, -0.0041960863, -0.7034186147,\n                 +1.7076147010);\n  return mul3(m2, lms);\n}\n\nvec3 lab2lch(in vec3 c) {\n  return vec3(c.x, sqrt((c.y * c.y) + (c.z * c.z)), atan(c.z, c.y));\n}\n\nvec3 lch2lab(in vec3 c) { return vec3(c.x, c.y * cos(c.z), c.y * sin(c.z)); }\n\nvec3 srgb_to_oklch(in vec3 c) { return lab2lch(srgb2oklab(c)); }\nvec3 oklch_to_srgb(in vec3 c) { return oklab2srgb(lch2lab(c)); }\n\nvec3 tonemap(vec3 sRGB)\n{\n    // NOTE: Tune these params based on your use case.\n    // Desmos graph: https://www.desmos.com/calculator/cvt2brlyl3\n    const float EXPOSUREX = 1.0;\n    const float CONTRAST = 1.79;\n    const float RANGE = 1.5;\n    \n    const mat3 sRGB_to_LMS = transpose(mat3(\n        0.31399022, 0.63951294, 0.04649755,\n        0.15537241, 0.75789446, 0.08670142,\n        0.01775239, 0.10944209, 0.87256922));\n\n    const mat3 LMS_to_sRGB = transpose(mat3(\n        5.47221206, -4.6419601 ,  0.16963708,\n       -1.1252419 ,  2.29317094, -0.1678952 ,\n        0.02980165, -0.19318073,  1.16364789));\n        \n    const vec3 sRGB_to_Y = vec3(0.2126729, 0.7151522, 0.0721750);\n    \n    // Apply tonescale in LMS\n    \n    vec3 LMS = sRGB_to_LMS * sRGB;\n    \n    LMS = pow(EXPOSUREX * LMS, vec3(CONTRAST / RANGE));\n    LMS = LMS / (LMS + 1.0);\n    LMS = pow(LMS, vec3(RANGE));\n    \n    sRGB = LMS_to_sRGB * LMS;\n    \n    // Apply gamut mapping in sRGB\n    \n    float Y = dot(sRGB_to_Y, sRGB);\n    if (Y > 1.0)\n        return vec3(1.0);\n        \n    float minimum = min(sRGB.r, min(sRGB.g, sRGB.b));\n    if (minimum < 0.0)\n        sRGB = mix(sRGB, vec3(Y), -minimum / (Y - minimum));\n    \n    float maximum = max(sRGB.r, max(sRGB.g, sRGB.b));\n    if (maximum > 1.0)\n        sRGB = mix(sRGB, vec3(Y), (1.0 - maximum) / (Y - maximum));\n    \n    return sRGB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz;\n    if(texture(iChannel1, vec2(0.99)).x > 0.5){\n        col/=(c.w+1.);\n    }\n   // col = vec3(1.)-exp(-1.2*col);\n    //NOT MY CODE//////////////////\n   // vec3 a = vec3(0.3,0.7,0.7)-0.4;\n   // col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n   // vec3 aa = vec3(1.0,1.1,1.7);\n   // col = sqrt(col/aa);\n   // col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n   col *= 6.;\n\n    col = tonemap(col);\n    col = pow(col, vec3(1./1.8));\n   \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float focaldist = 5.3;\nfloat radius = 0.01;\nint tiles = 3;\nint samples = 130;\nfloat scaleUV = 1.1;\nvec3 lig = normalize(vec3(0.6,0.9,0.9));\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define KEY_A 65.0\n#define KEY_W 87.0\n#define KEY_S 83.0\n#define KEY_D 68.0\n\n#define KEY_C 67.0\n\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc = c * pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n//NOT MY CODE////////////////////\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).xyz;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //vec3 d = texture(iChannel1, vec2(40.,0.)/iResolution.xy).xyz;\n    //vec3 p = vec3(0.);\n    //vec3 d;\n    //d = normalize(vec3(uv.x, 1., uv.y));\n    vec3 d = vec3(0.,-1.,0.);\n    vec3 side = vec3(1.,0.,0.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, -mouse.y*130.);\n    d.xy = rot(d.xy, mouse.x*180.);\n    side.xy = rot(side.xy, mouse.x*180.);\n    //vec3 prevcol = col;\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n    if(fragCoord.x < 0.05*iResolution.x && prev_state.x < 0.5){\n    \n        if(iFrame < 5){\n            col = vec3(0., 0., 10.);\n        }\n    \n        if(isPressed(KEY_W)){\n            col-=d*0.1;\n        }\n        if(isPressed(KEY_S)){\n            col+=d*0.1;\n        }\n        if(isPressed(KEY_A)){\n            col-=side*0.1;\n        }\n        if(isPressed(KEY_D)){\n            col+=side*0.1;\n        }\n    }\n    \n    if(fragCoord.x > iResolution.x*0.5 && fragCoord.x < iResolution.x*0.6 && prev_state.x < 0.5){\n        col = vec3(-mouse.y*90., mouse.x*180., 0.);\n    }\n    \n    if(fragCoord.x > 0.95*iResolution.x){\n        if(isPressed(KEY_C)){\n            col = (col.x > 0.5)?vec3(0.):vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    float l = length(a);\n    if(l < 0.0001){\n        return vec2(0.);\n    }\n    a/=l;\n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n    return vec2(cos(ang),sin(ang))*l;\n}\nfloat escape = 0.;\nfloat escape2 = 0.;\n\nfloat box(vec3 p, vec3 s){\n\n    vec3 a = abs(p)-s;\n\n    return max(max(a.x,a.y),a.z);\n}\n\n//NOT MY CODE///////////////\n//https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\nuint wang_hash(inout uint seed)\n{\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n//https://jbaker.graphics/writings/DEC.html\nfloat jb2(vec3 p){\n  p.xz=fract(p.xz)-.5;\n  escape2 = 0.;\n  float k=1.;\n  float s=0.;\n  for(int i=0;i++<12;){\n    s=2./clamp(dot(p,p),.1,1.),\n    p=abs(p)*s-vec3(.4,5,.5),\n    k*=s;\n    escape2 += exp(-0.2*dot(p,p));\n    }\n    \n\n  return length(p)/k-.001;\n}\n\n \t\nfloat de332(vec3 p0){\n//p0 = floor(p0*30.)/30.;\n\tvec4 p = vec4(p0, 1.);\n\tp.xyz=abs(p.xyz);\n\tif(p.x < p.z)p.xz = p.zx;\n\tif(p.z < p.y)p.zy = p.yz;\n\t//if(p.y < p.x)p.yx = p.xy;\n\tfor(int i = 0; i < 8; i++){\n\t\tp.xyz = abs(p.xyz);\n\t\tuint seed = uint(p.x+p.y+p.z);\n\t\tp*=(2.3/clamp(dot(p.xyz,p.xyz),0.,1.));\n\t\tp.xyz-=vec3(1.6,.9,2.2);\n\t}\n\tfloat m = 1.0;\n\tp.xyz-=clamp(p.xyz,-m,m);\n    return length(p.xyz)/p.w;\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fractal_de217(vec3 p){\np=abs(p);\n  float d, a;\n  d=a=1.;\n  escape = 0.;\n  for(int j=0;j++<19;){\n    p.xz=abs(p.xz)*rotate2D(3.14159/4.),\n    d=min(d,max(length(p.zx)-.3,p.y-.4)/a),\n    p.yx*=rotate2D(.9),\n    p.y-=3.,\n    p*=1.2,\n    a*=1.2;\nescape += exp(-0.2*dot(p,p));\n    }\n\n  return d;\n}\n\n///////////////////////////\n\n\nvec3 Rotate(vec3 z,float AngPFXY,float AngPFYZ,float AngPFXZ) {\n        float sPFXY = sin(radians(AngPFXY)); float cPFXY = cos(radians(AngPFXY));\n        float sPFYZ = sin(radians(AngPFYZ)); float cPFYZ = cos(radians(AngPFYZ));\n        float sPFXZ = sin(radians(AngPFXZ)); float cPFXZ = cos(radians(AngPFXZ));\n\n        float zx = z.x; float zy = z.y; float zz = z.z; float t;\n\n        // rotate BACK\n        t = zx; // XY\n        zx = cPFXY * t - sPFXY * zy; zy = sPFXY * t + cPFXY * zy;\n        t = zx; // XZ\n        zx = cPFXZ * t + sPFXZ * zz; zz = -sPFXZ * t + cPFXZ * zz;\n        t = zy; // YZ\n        zy = cPFYZ * t - sPFYZ * zz; zz = sPFYZ * t + cPFYZ * zz;\n        return vec3(zx,zy,zz);\n}\n\nfloat espv = 0.;\nfloat desfff( vec3 p ) {\n    float Scale = 1.34f;\n    float FoldY = 1.025709f;\n    float FoldX = 1.025709f;\n    float FoldZ = 0.035271f;\n    float JuliaX = -1.763517f;\n    float JuliaY = 0.392486f;\n    float JuliaZ = -1.734913f;\n    float AngX = -51.080209f;\n    float AngY = 0.0f;\n    float AngZ = -29.096322f;\n    float Offset = -3.036726f;\n    int EnableOffset = 1;\n    int Iterations = 80;\n    float Precision = 1.0f;\n    // output _sdf c = _SDFDEF)\n\n    vec4 OrbitTrap = vec4(1,1,1,1);\n    float u2 = 1.;\n    float v2 = 1.;\n    if(EnableOffset!=0)p = Offset+abs(vec3(p.x,p.y,p.z));\n\n    vec3 p0 = vec3(JuliaX,JuliaY,JuliaZ);\n    float l = 0.0;\n    int i=0;\n    espv = 0.;\n    for (i=0; i<Iterations; i++) {\n        p = Rotate(p,AngX,AngY,AngZ);\n        p.x=abs(p.x+FoldX)-FoldX;\n        p.y=abs(p.y+FoldY)-FoldY;\n        p.z=abs(p.z+FoldZ)-FoldZ;\n        p=p*Scale+p0;\n        l=length(p);\n        float rr = dot(p,p);\n        espv += exp(-0.2*dot(p,p));\n    }\n    return Precision*(l)*pow(Scale, -float(i));\n}\n\nvec3 Rotat2e(vec3 z,float AngPFXY,float AngPFYZ,float AngPFXZ) {\n        float sPFXY = sin(radians(AngPFXY)); float cPFXY = cos(radians(AngPFXY));\n        float sPFYZ = sin(radians(AngPFYZ)); float cPFYZ = cos(radians(AngPFYZ));\n        float sPFXZ = sin(radians(AngPFXZ)); float cPFXZ = cos(radians(AngPFXZ));\n\n        float zx = z.x; float zy = z.y; float zz = z.z; float t;\n\n        // rotate BACK\n        t = zx; // XY\n        zx = cPFXY * t - sPFXY * zy; zy = sPFXY * t + cPFXY * zy;\n        t = zx; // XZ\n        zx = cPFXZ * t + sPFXZ * zz; zz = -sPFXZ * t + cPFXZ * zz;\n        t = zy; // YZ\n        zy = cPFYZ * t - sPFYZ * zz; zz = sPFYZ * t + cPFYZ * zz;\n        return vec3(zx,zy,zz);\n}\n\nfloat deBB( vec3 p ) {\n    float Scale = 1.34f;\n    float FoldY = 1.025709f;\n    float FoldX = 1.025709f;\n    float FoldZ = 0.035271f;\n    float JuliaX = -1.763517f;\n    float JuliaY = 0.392486f;\n    float JuliaZ = -1.734913f;\n    float AngX = -80.00209f;\n    float AngY = 0.0f;\n    float AngZ = -28.096322f;\n    float Offset = -3.036726f;\n    int EnableOffset = 1;\n    int Iterations = 80;\n    float Precision = 1.0f;\n    // output _sdf c = _SDFDEF)\n\n    vec4 OrbitTrap = vec4(1,1,1,1);\n    float u2 = 1.;\n    float v2 = 1.;\n    if(EnableOffset != 0)p = Offset+abs(vec3(p.x,p.y,p.z));\n\n    vec3 p0 = vec3(JuliaX,JuliaY,JuliaZ);\n    float l = 0.0;\n    int i=0;\n        espv = 0.;\n\n    for (i=0; i<Iterations; i++) {\n        p = Rotat2e(p,AngX,AngY,AngZ);\n        p.x=abs(p.x+FoldX)-FoldX;\n        p.y=abs(p.y+FoldY)-FoldY;\n        p.z=abs(p.z+FoldZ)-FoldZ;\n        p=p*Scale+p0;\n        l=length(p);\n        espv += exp(-0.2*dot(p,p));\n\n        float rr = dot(p,p) + 1.5f;\n        // OrbitTrap.r = max( OrbitTrap.r, rr );\n    }\n    // hitColor = vec3( OrbitTrap.r, abs( 10.0f * p.xy ) );\n    return Precision*(l)*pow(Scale, -float(i));\n}\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5 + 0.5*cos(2.*3.14159*t*a + b);\n}\n\nmat2 zx(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\nbool iswat = false;\nfloat deWATER(vec3 p) {\n  float e, i = 0., j, f, a, w;\n  // p.yz *= zx( .7 );\n  f = .128;\n  i < 45. ? p : p -= .001;\n  float t = 0.;\n  e = p.y + 5.;\n  for (a = j = .9; j++ < 30.; a *= .8) {\n    vec2 m = vec2(1.) * zx(j);\n     float x = dot( p.xz, m ) * f + t + t; // time varying behavior\n    //float x = dot(p.xz, m) * f + 0.;\n    w = exp(sin(x) - 1.);\n    p.xz -= m * w * cos(x) * a;\n    e -= w * a;\n    f *= 1.2;\n  }\n  return e;\n}\nfloat random3d(vec3 p) {\n  return fract(sin(p.x * 214. + p.y * 241. + p.z * 123.) * 100. +\n               cos(p.x * 42. + p.y * 41.2 + p.z * 32.) * 10.);\n}\nfloat pps = 0.;\nvec3 orbitSSSS = vec3(0.);\n\nfloat deFractal4(vec3 p0){\n    vec4 p = vec4(p0, 1.);\n    p=abs(p);\n      orbitSSSS = vec3(0.);\n\n    if(p.x < p.z)p.xz = p.zx;\n    if(p.z < p.y)p.zy = p.yz;\n    if(p.y < p.x)p.yx = p.xy;\n    pps = 0.;\n    for(int i = 0; i < 10; i++){\n      if(p.x < p.z)p.xz = p.zx;\n      if(p.z < p.y)p.zy = p.yz;\n      if(p.y < p.x)p.yx = p.xy;\n      p.xyz = abs(p.xyz);\n      p*=(1.8/clamp(dot(p.xyz,p.xyz),-1.0,1.));\n      p.xyz-=vec3(0.3,1.9,0.4);\n      pps += exp(-0.2*dot(p.xyz,p.xyz));\n      orbitSSSS = max(orbitSSSS, p.xzy * 2. * vec3(0.2, 0.9, 0.9));\n\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\n    return length(p.xyz)/p.w;\n  }\n  \n    #define rotzzz(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n  float denew ( vec3 p ) {\n  pps = 0.;\n        orbitSSSS = vec3(0.);\n\n    p=abs(p)-3.;\n    if(p.x < p.z)p.xz=p.zx;\n    if(p.y < p.z)p.yz=p.zy;\n    if(p.x < p.y)p.xy=p.yx;\n    float s=2.; vec3 off=p*.5;\n    for(int i=0;i<10;i++){\n      p=1.-abs(p-1.);\n      float k=-1.1*max(1.5/dot(p,p),1.5);\n      s*=abs(k); p*=k; p+=off;\n      p.zx*=rotzzz(-1.2);\n      pps += exp(-0.2*dot(p,p));\n            orbitSSSS = max(orbitSSSS, p.xzy * 2. * vec3(0.2, 0.9, 0.2));\n\n    }\n    float a=2.5;\n    p-=clamp(p,-a,a);\n    return length(p)/s;\n  }\n  bool iswat2 = false;\n  \nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob, inout bool ref){\n    c = vec3(0.3,0.7,0.8);\n    a2 = 0.1;\n    iswat2 = false;\n    prob = 0.9;\n    l = 0.;\n    ref = false;\n    vec3 pm = p;\n    p.z += 28.;\n  //  float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n  //  float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n   // float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n   // float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n   // float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\nvec3 pos = vec3(-1.1,15.3,1.4)-p;\npos.yz = rot(pos.yz, 90.);\n               float aa = 0.;    //float aaa = DE45((vec3(78.0,0.2,-0.0)-p)/10.)*10.;\n  uint seed = uint(pos.x+pos.y+pos.z);\n  //aa = max(max(box(pos, vec3(1.7)), -(box(mod(pos, 1.)-0.5,vec3(.3,.3,.3)))), \n  //-(fractal_de217((pos/0.3))*0.3));\n  aa = deBB((pos-p)/4.)*4.;\n//  vec3 pos2 = vec3(22.1,15.3,1.4)-p;\n//    pos2.yz = rot(pos2.yz, 90.);\n///  aa = min(aa, deBB((pos2-p)/2.)*2.);\n  \n    //float b2 = box(vec3(0., 60., 3.)-p, vec3(125.7,2.,125.));\n   // float bb2 = box(vec3(-8., -20., 16.)-p, vec3(20.7,20.,5.));\n\n    //float aa3 = fractal_de89((vec3(0.0,-19.2,2.0)-p)/10.)*10.;\n\n    //float final = min(min(min(min(min(min(b2, a),b),c1),c2),c3),\n   // max(aa, box(vec3(0.,2.,0.)-p, vec3(9.))));\n    float wat = deWATER(pm.xzy/0.1)*0.1;\n    vec3 ppp = vec3(10., -0., 20.)-p;\n   float aax = denew((ppp)/3.)*3.;\n    //float aax = max(, box(vec3(0., 0., 10.)-p, vec3(40., 40., 10.)));\n    float letssee = box(mod(vec3(0.)-p-2., 4.) - 2., vec3(0.1, 0.1, 20.));\n    letssee = max(letssee, box(vec3(0.)-p, vec3(10., 10., 100.)));\n    float final = min(aa, min(wat, min(aax, aax)));\n   \n    //float plane = p.z - (9.+((sin(p.x + cos(p.y))+cos(p.y+sin(p.x)))*0.03+\n\n    //(sin(p.x*5.+cos(p.y)) + cos(p.z*5.+sin(p.x*2.)))*0.005  ) );\n   \n    //if(final == b2)l = 3.2;c=vec3(0.9, 0.7, 0.2);\n    //if(final == a)l=0.2;\n   // if(final == c1)c = vec3(0.2);\n   // if(final == c2)c = vec3(0.2);\n   // if(final == a)c = vec3(0.2);\n   // if(final == b)c = vec3(0.2);\n   // if(final == c3)c = vec3(0.2);\n\n\n    vec3 color = vec3(0.2,0.9,0.9);\n    if(final == aa){a2 = 0.1;prob=0.;c=pal(espv, vec3(0.9), vec3(0.9,0.2,0.9));\n    l = 0.;\n    ref = true;\n    //c = vec3(0.9);\n    }\n    if(final == wat){\n        l = 0.;\n        ref = false;\n        a2 = 0.025;\n        prob = 1.;\n        c = vec3(0.2);\n        iswat2 = true;\n    }\n  \n    if(final == aax){\n        c = pal(pps*0.1, vec3(0.9), vec3(0.2, 0.6, 0.9));\n        c = mix(c, vec3(0.7), vec3(0.8));\n        a2 = 0.025;\n        prob = 0.64;\n        vec3 cx = clamp(orbitSSSS, 0., 1.);\n\n        if(cx.y < 0.29 && cx.x < 0.75){\n          //  l = 4.;\n           // c = vec3(0.2, 0.5, 0.9);\n        }\n       // c = cx;\n        ref = false;\n    }\n\n    if(final == letssee){\n        c = vec3(0.9, 0.4, 0.4);\n        l = 4.;\n        ref = false;\n    }\n\n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float t = pow(r2, 2./(1.+a));\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.01;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k, inout bool ref){\n    for(int i = 0; i < 180; i++){\n        dd = dis(p,l,c,a,prob, ref);\n        if(dd<0.001)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    bool ref;\n    \n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.002, p.yz),l,c,a,prob,ref) - dis(vec3(p.x-0.002, p.yz),l,c,a,prob,ref),\n            dis(vec3(p.x, p.y+0.002, p.z),l,c,a,prob,ref) - dis(vec3(p.x, p.y-0.002, p.z),l,c,a,prob,ref),\n            dis(vec3(p.x, p.y,p.z+0.002),l,c,a,prob,ref) - dis(vec3(p.x, p.y,p.z-0.002),l,c,a,prob,ref)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    \n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n   \n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\n\nvec3 F(float costheta, float y, vec3 A, vec3 B, vec3 C, vec3 D, vec3 E){\nreturn (1.+A*exp(B/costheta))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\nvec3 skyp2x(vec3 d, vec3 lig){//my code to begin with\nvec3 zenith = vec3(0.,0.,1.);\nfloat costheta = max(dot(d,zenith),0.);\nfloat costhetas = max(dot(lig,zenith),0.);\nfloat cosy = max(dot(lig,d),0.);\nfloat y = acos(cosy);\n\nfloat T = 3.;\nfloat X = (4./9. - T/120.)*(3.14159-2.*acos(costhetas));\nfloat Yz = (4.0453*T - 4.9710)*tan(X)-0.2155*T+2.4192;\n\nvec3 AYxy = vec3(0.1787*T-1.4630, -0.0193*T-0.2592,-0.0167*T-0.2608);\nvec3 BYxy = vec3(-0.3554*T+0.4275,-0.0665*T+0.0008,-0.0950*T+0.0092);\nvec3 CYxy = vec3(-0.0227*T+5.3251,-0.0004*T+0.2125,-0.0079*T+0.2102);\nvec3 DYxy = vec3(0.1206*T-2.5771,-0.0641*T-0.8989,-0.0441*T-1.6537);\nvec3 EYxy = vec3(-0.0670*T+0.3703,-0.0033*T+0.0452,-0.0109*T+0.0529);\n\nfloat ts = acos(costhetas);\nfloat ts2 = ts*ts;\nfloat ts3 = ts*ts*ts;\nvec3 xz0 = vec3(0.00166*ts3 -0.00375*ts2 + 0.00209*ts,\n-0.02903*ts3 + 0.06377*ts2 - 0.03202*ts + 0.00394,\n0.11693*ts3 - 0.21196*ts2 + 0.06052*ts + 0.25886\n);\n\nvec3 yz0 = vec3(0.00275*ts3 -0.00610*ts2 + 0.00317*ts,\n-0.04214*ts3 + 0.08970*ts2 - 0.04153*ts + 0.00516,\n0.15346*ts3 - 0.26756*ts2 + 0.06670*ts + 0.26688\n);\n\nfloat xz = xz0.x*T*T + xz0.y*T + xz0.z;\nfloat yz = yz0.x*T*T + yz0.y*T + yz0.z;\n\nvec3 Yxyz = vec3(Yz,xz,yz);\n//test\n//vec3 test1 = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Ftop = F(costheta, y, AYxy, BYxy, CYxy, DYxy, EYxy);\nvec3 Fbottom = F(1., ts, AYxy, BYxy, CYxy, DYxy, EYxy);\n\nvec3 finalYxy = Yxyz*(Ftop/Fbottom);\n\nvec3 XYZ = vec3(\n(finalYxy.y*finalYxy.x)/finalYxy.z,\nfinalYxy.x,\n((1.-finalYxy.y - finalYxy.z)*finalYxy.x)/finalYxy.z\n);\n\nvec3 rgb = vec3(\n3.2404542*XYZ.x -1.5371385*XYZ.y -0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\n\n//return test1*0.1;\nreturn rgb*0.034 + exp(-y*20.)*vec3(0.9,0.6,0.2);\n}\n\n\n//NOT MY CODE///////////\n bool intersect22(vec3 p,  vec3 C, float size, vec3 d, inout vec2 t){\n \n \t\n\tvec3 o_minus_c = p - C.xyz;\n\n    float p2 = dot(d, o_minus_c);\n    float q = dot(o_minus_c, o_minus_c) - (size * size);\n    \n    float discriminant = (p2 * p2) - q;\n    \n\n    float dRoot = sqrt(discriminant);\n    t.x = -p2 - dRoot;\n    t.y = -p2 + dRoot;\n\n    return true;\n \n }\n vec3 Be(vec3 b0,float h, float H){\nreturn b0*exp(-h/H);\n}\nfloat ph(float h, float H){\nreturn exp(-(abs(h)/H));\n}\nvec3 Brr(vec3 wave){\nfloat n = 1.029;\nfloat N = 10.;\nreturn 8.*pow(3.14159,3.)*(pow(n*n-1.0, 2.)/(3.*N*wave*wave*wave*wave));\n}\nfloat PM(float cost, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+cost*cost);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.);\nreturn a*(b/c);\n}\n\nfloat RayleighPhase(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\n\nvec3 skyp2( vec3 d, vec3 lig) {\n  vec3 p = vec3(0., 0., 6400.);\n  vec3 wavelengths = vec3(700., 530., 420.);\n  lig.z = clamp(lig.z, 0., 1.);\n\n  vec2 t = vec2(0.);\n  float reyleighH = 4000.;\n  float MieH = 1200.;\n\n  vec3 accumulateLight = vec3(0.);\n  vec3 accumulateLightMie = vec3(0.);\n  if (intersect22(p, vec3(0., 0., 0.), 6420.0, d, t)) {\n    // col = vec3(t.x);\n    vec3 m = p;\n\n    vec3 cam = p;\n    vec3 fin = p + d * t.y;\n    vec3 div = vec3(fin - cam) / 20.;\n    float mm = length(cam - fin);\n\n    vec3 accum = vec3(0.);\n    vec3 accum11 = vec3(0.);\n    vec3 accum1111 = vec3(0.);\n\n    ///////////////////////////////////\n    float PMMM = PM(max(dot(d, lig), 0.), 0.76);\n    float PRRR = RayleighPhase(max(dot(d, lig), 0.0));\n    vec3 coefficients = vec3(33.1, 13.5, 5.8);\n    float Bs = 110.;\n    vec3 Be0 = Be(coefficients, 0.0, 2000.);\n    vec3 BRrgb = Brr(wavelengths * 0.00109);\n    vec3 BMrgb = vec3(0.01);\n    ///////////////////////////////////\n\n    float prevM = 0.0;\n    float prevR = 0.0;\n\n    for (int i = 0; i < 20; i++) {\n      accum += ph(max(cam.z - 1660., 0.), reyleighH) * length(div);\n      accum1111 += ph(max(cam.z - 1460., 0.), MieH) * length(div);\n\n      vec3 accum2 = vec3(0.);\n      vec3 accum222 = vec3(0.);\n      float accum3 = 0.;\n      if (intersect22(cam, vec3(0., 0., 0.), 6420.0, lig, t)) {\n        vec3 cam2 = cam;\n        vec3 fin2 = cam2 + lig * t.y;\n        vec3 div2 = vec3(fin2 - cam2) / 20.;\n        for (int k = 0; k < 20; k++) {\n          accum222 += ph(max(cam2.z - 3160., 0.), reyleighH) * length(div2);\n          accum2 += max(length(cam2) - 6260., 0.) * length(div2);\n          \n          cam2 += div2;\n        }\n\n      \n        vec3 t1 = BRrgb * accum222 + BMrgb * accum2;\n        vec3 t2 = BRrgb * accum + BMrgb * accum1111;\n\n        accumulateLight +=\n            (exp(-pow(t1 * 0.0054, vec3(1.))) * exp(-t2 * 0.028)) *\n            length(div * 1.) * .0005 * (PRRR * BRrgb * 230. + PMMM * 50.) *\n            mix(vec3(0.9, 0.4, 0.2), vec3(0.9),\n                clamp(dot(lig, vec3(0., 0., 1.)) * 4., 0., 1.));\n\n        \n      }\n\n      if (cam.z < 6360.) {\n        break;\n      }\n      cam += div;\n    }\n\n  }\n\n  return max(accumulateLight * 6.4 *\n                 pow(clamp(dot(lig, vec3(0., 0., 1.)), 0., 1.), 2.),\n             0.);\n\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 sampleSun(vec3 n, inout uint r, float theta){\n        float diff = 1.-cos(theta);\n        float z = cos(theta) + rndf(r)*diff;\n        float angle = rndf(r)*3.14159*2.;\n        float radius = sqrt(1. - z*z);\n        float x = cos(angle) * radius;\n        float y = sin(angle) * radius;\n        \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 53;\n    float ll = 0.;\n    float k = 0.;\n    bool ref = false;\n    for(int i = 0; i < bounces; i++){\n       // p += d*(rndf(r)*2.-1.)*0.1;\n        if(trac(p,d,dd,l,c,a,probability,r,k,ref)){\n            vec3 n = norm(p-d*0.002,dd);\n            p+=n*0.0024;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\nrough = rough*rough;\n            d = angledircos(n,r);\n        if(i == 0)ll=length(p-prevp);\n            float number = rndf(r);\n           \n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*l*c;\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n           \n           ////////////////////////////\n           float theta = 0.1;\n           vec3 lightdir = sampleSun(lig, r, theta);\n           /////////////////////////////\n\n\n            ldir = normalize(lightdir);\n\n\n            vec3 brdf = c/3.14159 ;\n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n   \n   \n               \n        \n            if(number < probability){\n                brdf = specular;\n                hemipdf = beckmann_pdf2(reflect(wi,n),d,rough);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = specular2;\n                hemipdf2 = beckmann_pdf2(reflect(ldir,n),wi,rough);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            }\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n          //  abs(dot(L, -R));\n            \n            \n            vec3 L = vec3(0.9,0.4,0.2)*200.;\n            \n           vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            //vec3 lightdir = anglephong(100000., lig, r);\n            //theta - 0, pi/2\n            float height = cos(theta);\n            float ar = 2.*3.14159*(1.0-height);\n            bool ref2 = false;\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2,ref2) && dot(ldir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                float brpdf = max(dot(ldir, n),0.)/3.14159;\n                brpdf = max(brpdf, 0.00000001);\n                if(number < probability){\n                    brpdf = hemipdf2;\n                }\n                float pdf = 1./ar;\n                float weight = powerh(1., pdf, 1., brpdf);\n                col += tt*brdf2*L*weight*dot(ldir,n)/pdf;\n                //break;\n            }\n            \n           //MIS\n           float an = acos(dot(d,lig));\n           if((an) <= theta){\n               curr = p;\n               if(!trac(curr, d,dd,l2,c,a2,prob2,r,k2,ref2)){\n                   float heightbrdf = cos(an);\n                   float arbrdf = 2.*3.14159*(1.-heightbrdf);\n                   float pdf = 1./arbrdf;\n                   float weight = powerh(1.,hemipdf,1.,pdf);\n                   col += tt*brdf*weight*L*max(dot(d,n),0.)/hemipdf;\n                   break;\n               }\n           }\n            \n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                   \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                   \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/      \n            \n            if(ref){\n            if(i==0){\n                        tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n\n            }\n            float sch = 0.65 + (1.0-0.65)*pow(1.0-max(dot(n, wi),0.),5.);\n                if(rndf(r) < 0.96){\n                float prob2 = 0.;\n                float dds = dis(p,l,c,a,prob2,ref);\n                if(dds > 0.01){\n                p-=n*0.04;\n                //d = refract(wi, n, 0.65);\n                }\n                for(int k = 0; k < 340; k++){\n                    float dds = dis(p,l,c,a,prob2,ref);\n                    if(dds>0.01){\n                    break;\n                    }\n                    if(rndf(r) < 0.4){\n                         vec3 anv = angledircos(d,r);\n                         d = normalize(anv+anglephong(1000., d, r));\n                    }\n                    p+=d*.01;\n                }\n                vec3 n2 = norm(p,dd);\n                p+=n2*0.02;\n                \n                //d = refract(wi, -n2, 0.65);\n                 d = angledircos(n2,r);\n                    vec3 L = vec3(0.9,0.4,0.2)*200.;\n            tt *= (c)*abs(dot(d, n2));\n           vec3 curr = p;\n            float l2;\n             a2,prob2;\n            float k2;\n            //vec3 lightdir = anglephong(100000., lig, r);\n            //theta - 0, pi/2\n            float height = cos(theta);\n            float ar = 2.*3.14159*(1.0-height);\n            bool ref2 = false;\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2,ref2) && dot(ldir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                float brpdf = max(dot(ldir, n),0.)/3.14159;\n                brpdf = max(brpdf, 0.00000001);\n                if(number < probability){\n                    brpdf = hemipdf2;\n                }\n                float pdf = 1./ar;\n                float weight = powerh(1., pdf, 1., brpdf);\n                col += tt*brdf2*L*weight*dot(ldir,n)/pdf;\n                //break;\n            }\n            \n          \n                 \n                }else{\n                //d = reflect(wi, n);\n                 tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n                }\n                \n            }else{\n            \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            }\n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           if(i == 0  ){\n                const int samples = 7;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                vec3 accum = vec3(0.);\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                float ts = 1.;\n                vec3 lightdir = anglephong(1000., lig, r);\n                vec3 volCol = vec3(0.);\n                vec3 volAbs = vec3(1.);\n                vec3 stepAbs = vec3(1.) * exp(-0.05 * length(p-prevp));\n                vec3 stepCol = (vec3(1.) - stepAbs);\n\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*max(rndf(r), 0.8);\n                    vec3 ppp = curr;\n                    bool ref2 = false;\n                    float shadow = (!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2, ref2))?1.:0.;\n                    //if(){\n                        accum += stepAbs*volAbs*shadow*stepCol*2.25*vec3(0.9,0.7,0.4);\n                        //ts *= exp(-length(curr - prevp)*0.5);\n                        // accum += stepCol * volAbs*vec3(0.8,0.7,0.4);\n\n                        // volAbs *= exp(-length(finPos - cam)*.025);\n\n                   // }else{\n                        accum += min(shadow,0.1)*2.9*stepCol*vec3(0.2, 0.6, 0.9);\n                   // }\n                   volAbs *= 1.-exp(-length(curr - prevp) * .41);\n\n                }\n                col = max(col,0.) + max(accum*5.5*volAbs, 0.);\n            }\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\nif(i==0)ll=length(p-prevp);\n          if(i == 0 ){\n                const int samples = 7;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                vec3 accum = vec3(0.);\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                float ts = 1.;\n                vec3 lightdir = anglephong(1000., lig, r);\n                vec3 volCol = vec3(0.);\n                vec3 volAbs = vec3(1.);\n                vec3 stepAbs = vec3(1.) * exp(-0.05 * length(p-prevp));\n                vec3 stepCol = (vec3(1.) - stepAbs);\n\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*max(rndf(r), 0.8);\n                    vec3 ppp = curr;\n                    bool ref2 = false;\n                    float shadow = (!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2, ref2))?1.:0.;\n                    //if(){\n                        accum += shadow*0.1*vec3(0.9,0.7,0.4);\n                        //ts *= exp(-length(curr - prevp)*0.5);\n                        // accum += stepCol * volAbs*vec3(0.8,0.7,0.4);\n\n                        // volAbs *= exp(-length(finPos - cam)*.025);\n\n                   // }else{\n                        accum +=min(shadow,0.1)*2.9*vec3(0.2, 0.6, 0.9);\n                   // }\n                   volAbs *= exp(-length(curr - prevp) * .01);\n\n                }\n                col = max(col,0.) + max(accum,0.);\n            }\n            if(i==0){\n                col += tt*skyp2(d, lig)*0.9;\n            }else{\n                col += tt*skyp2(d, lig)*0.9;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    //col += 1./(1.+exp(-2.*(clamp(ll,0.,20.)*0.1-2.)))*vec3(0.2,0.2,0.2);\n    return col;\n}\n\n\nvec3 get_color(vec3 p, vec3 d, vec2 frag){\n    vec3 prevp = p;\n    vec3 p2 = p;\n    vec3 d2 = d;\n    vec3 prevp2 = p2;\n    bool hit_obj = false;\n    vec3 ligc = vec3(0.9,0.8,0.4);\n    vec3 col = vec3(0.);\n    float k = 0.;\n    vec3 glow = vec3(0.);\n    float l = 0.;\n    vec3 c = vec3(0.);\n    float a = 0.;\n    float prob = 0.;\n    bool ref = false;\n    for(int i = 0; i < 80; i++){\n    //dis(p,l,c,a,prob);\n        float dist2 = abs(dis(p2,l,c,a,prob,ref))+0.001;\n        p2 += d2*dist2;\n        if(l > 0.01){\n            c = vec3(0.9, 0.1, 0.1)*100.;\n        }\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*c;\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }\n    col = glow*12.;\n   return col;\n}\n\n//NOT MY CODE//////////////////////\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NOT MY CODE//////////////////////////////\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n\n    \n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(prev_state.x > 0.5){\n        if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n        if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n    }\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n   // uv *= 0.5;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n      \n     uv *= scaleUV;\n      \n      \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n    d.xy = rot(d.xy, -uv.x*22.);\n    d.yz = rot(d.yz, uv.y*22.);\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = texture(iChannel1, vec2(0.)).xyz;\n    \n    vec3 rotations = texture(iChannel1, vec2(0.55)).xyz;\n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    float rota = 0.;\n    float rotb = 0.;\n    rota = rotations.x;\n    rotb = rotations.y;\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    vec3 col = vec3(0.);\n    \n    vec3 camdirection = vec3(0.,1.,0.);\n        camdirection.yz = rot(camdirection.yz, rota);\n        camdirection.xy = rot(camdirection.xy, rotb);\n        vec3 sidex = vec3(1.,0.,0.);\n        vec3 sidey = vec3(0.,0.,1.);\n       // sidex.yz = rot2(sidex.yz,rota);\n        //sidex.xz = rot(sidex.xz, -20.);\n       // sidex.yz = rot(sidex.yz,rota);\n        sidex.xy = rot(sidex.xy,rotb);\n    //    sidex.yz = rot(sidex.yz,rota);\n\n        //sidey.xz = rot(sidey.xz,-20.);\n        sidey.yz = rot(sidey.yz,rota);\n        sidey.xy = rot(sidey.xy,rotb);\n    \n        float ang = rndf(r)*2.0*3.14159;\n        float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n        float scale = sqrt(rndf(r))*radius;\n       //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n       //vec2 aa = normalize(vec2(0.,1.));\n        vec2 offset = vec2(cos(ang), sin(ang))*scale;\n        //if(offset.x > offset.y)offset.xy=offset.yx;\n        //offset.x+=-1.;\n    \n       //offset*=radius;\n       //NOT MY CODE////////////////////////\n        vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n        /////////////////////////////////////\n       // vec3 dd = vec3(uv.x,1.,uv.y);\n       // dd.yz = rot(dd.yz, rota);\n       // dd.xy = rot(dd.xy, rotb);\n       //vec3 focuspoint = p+(dd*focaldist);\n        //p.xz += offset;\n\n        p = p + sidex*offset.x;\n        p = p + sidey*offset.y;\n\n        d = normalize(focuspoint - p);\n    \n    if(prev_state.x > 0.5){\n        \n        \n\n        \n        //p += d*sin(float(iFrame)*0.5)*0.1;\n    \n        col = renderpixel(p,d, r, fragCoord);\n        col = clamp(col, 0., 100.);\n       // col = tonemap_uchimura2(col);\n        //col = pow(col, vec3(1.6))*1.8;\n       // col = pow(col, vec3(1./2.2));\n\n        if(jk != 0){\n            col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        }\n    }else{\n        col = get_color(p,d,fragCoord.xy);\n    }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}