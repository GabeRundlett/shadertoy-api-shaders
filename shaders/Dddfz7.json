{
    "Shader": {
        "info": {
            "date": "1697028691",
            "description": "My study on cube coordinate systems associated with hexagonal lattices, described in https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html\n\nMost of these functions actually work with ivec2 in disguise.",
            "flags": 32,
            "hasliked": 0,
            "id": "Dddfz7",
            "likes": 8,
            "name": "Hex grid on cube coordinates",
            "published": 3,
            "tags": [
                "cube",
                "hexgrid",
                "adorable"
            ],
            "usePreview": 0,
            "username": "Suslik",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "//Controls: push the left mouse button, drag it around\n\n//Inspired by https://www.shadertoy.com/view/dtySDy\n\n//Amazing resource explaining cube coordinates of hexagon grids:\n//https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#justin-pombrio\nmat2 skewed_to_grid = mat2(1.0f, 0.0f, 0.5f, sqrt(3.0f) / 2.0f);\n\nvec2 GridToSkewed(vec2 grid_pos)\n{\n    return inverse(skewed_to_grid) * grid_pos;\n}\n\nvec2 SkewedToGrid(vec2 skewed_pos)\n{\n    return skewed_to_grid * skewed_pos;\n}\n\nvec3 SkewedToCube(vec2 skewed_pos)\n{\n    return vec3(skewed_pos.xy, -skewed_pos.x - skewed_pos.y);\n}\n\n//Brachless version that achieves the same thing a bunch of if's do in the article above:\nvec3 CubeToHex(vec3 cube_pos)\n{\n    vec3 i = round(cube_pos);\n    vec3 d = abs(i - cube_pos);\n    return mix(i, -i.yzx - i.zxy, step(d.yzx, d.xyz) * step(d.zxy, d.xyz));\n}\n\n\n//An alternative formulation involves 3x floor + 3x round:\n//https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 CubeToTri(vec3 cube_pos)\n{\n    return floor(cube_pos.xyz - cube_pos.zxy);\n}\n\nvec3 TriToHex(vec3 tri_index)\n{\n    return round((tri_index.xyz - tri_index.yzx) / 3.0f);\n}\n\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\nfloat HexOuterDist(vec3 cube_delta)\n{\n    return max3(abs(cube_delta.xyz - cube_delta.yzx));\n}\n\nfloat HexInnerDist(vec3 cube_delta)\n{\n    return length(cube_delta) / (sqrt(2.0f) / sqrt(3.0f)); //(sqrt(2.0f) / 2.0f) for inscribed normalization\n}\n\nvec2 Rotate2(vec2 vec, float ang)\n{\n    mat2 m = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    return m * vec;\n}\n\nfloat SmoothFract(float val)\n{\n    float f = fract(val);\n    return f * clamp((1.0f - f) * 10.0f, 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //inputs\n    bool mouse_was_pressed = texelFetch(iChannel0, ivec2(0), 0).r > 0.5f;\n    float mouse_pressed_time = texelFetch(iChannel0, ivec2(0), 0).g;\n    vec2 grid_pos = fragCoord.xy/iResolution.x * 15.0f;\n    float straight_fade = mouse_was_pressed ? mouse_pressed_time : clamp(0.5f - cos(iTime * 0.5f) * 4.0f, 0.0f, 1.0f);\n    vec2 skewed_pos = mix(GridToSkewed(grid_pos), grid_pos, straight_fade);\n    float width = 0.05f;\n    vec2 grid = step(width, fract(skewed_pos.xy + vec2(width * 0.5f)));\n    \n    vec2 wiggle_pos = vec2(-sin(0.3f * iTime), -sin(0.42f * iTime)) * 0.4f + vec2(0.5f);\n    vec2 quad_index2f = step(mouse_was_pressed ? iMouse.xy : (iResolution.xy * wiggle_pos), fragCoord.xy);\n    int quad_index = int(quad_index2f.y * 2.0f + quad_index2f.x);\n    \n    //hex stuff\n    vec3 cube_pos = SkewedToCube(skewed_pos);\n    vec3 tri_index = CubeToTri(cube_pos); //this is an ivec2\n    vec3 hex_index = TriToHex(tri_index); //this is an ivec2\n    //vec3 hex_index2 = CubeToHex(cube_pos); //same result, calculated in a different way\n    //note that distances are calcualted based in cube coordinates, so they're independent of whether the grid is skewed or not\n    float outer_dist = HexOuterDist(hex_index.xyz - cube_pos.xyz); //0..1\n    float inner_dist = HexInnerDist(hex_index.xyz - cube_pos.xyz); //0..1\n    vec2 hex_skewed_pos = hex_index.xy;\n    vec2 hex_grid_pos = mix(SkewedToGrid(hex_skewed_pos), hex_skewed_pos, straight_fade);\n\n\n    if(quad_index == 3)\n    {\n        fragColor = vec4(fract((hex_index + vec3(-0.5f)) / 6.0f).xyz * (1.0f - inner_dist) * SmoothFract(outer_dist * 4.0f) * 1.5f, 1.0f);    \n    }\n    if(quad_index == 0)\n    {\n        fragColor = vec4(fract((tri_index + vec3(-0.5f)) / 6.0f).xyz * grid.x * grid.y, 1.0f);    \n        //fragColor = vec4(vec3(fract(tri_index / 6.0f)[int(iTime / 3.0f) % 3]) * grid.x * grid.y, 1.0f);    \n    }\n    if(quad_index == 1)\n    {\n        fragColor = vec4(vec3(fract((hex_index + vec3(-0.5f)) / 6.0f).xyz) * inner_dist * grid.x * grid.y, 1.0f);\n        //fragColor = vec4(vec3(fract(hex_index / 6.0f)[int(iTime / 3.0f) % 3]) * inner_dist * grid.x * grid.y, 1.0f);\n    }    \n    if(quad_index == 2)\n    {\n        fragColor = vec4(fract(Rotate2(grid_pos - hex_grid_pos, iTime)) * grid.x * grid.y * (1.0f - pow(outer_dist, 5.0f)), 0.0f, 1.0f);\n    }\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0f / 2.2f));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel_coord = ivec2(fragCoord.xy);\n    fragColor = texelFetch(iChannel0, pixel_coord, 0);\n    if(pixel_coord == ivec2(0, 0))\n    {\n        fragColor.r = max(fragColor.r, iMouse.z);\n        fragColor.g = clamp(fragColor.g + (iMouse.z > 0.5f ? iTimeDelta : -iTimeDelta) * 4.0f, 0.0f, 1.0f);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}