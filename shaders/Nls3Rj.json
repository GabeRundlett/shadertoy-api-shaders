{
    "Shader": {
        "info": {
            "date": "1622432838",
            "description": "Testing out raymarching and signed distance functions combined with basic blinn phong lighting. \n\"Manual\" bounce light added for better looks. Added soft shadows",
            "flags": 0,
            "hasliked": 0,
            "id": "Nls3Rj",
            "likes": 3,
            "name": "Simple raymarching shader",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "blinnphonglighting"
            ],
            "usePreview": 0,
            "username": "Danimtz",
            "viewed": 315
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.01\n#define AA 2\n\n#define SPHERE1 1.0\n#define PLANE 0.0\nfloat sdSphere(vec3 p, float r)//Signed distance function of sphere\n{\n    return length(p) - r;\n}\n\nvec2 compSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 map(vec3 p) //Scene geometry information\n{\n    vec3 sph_o = vec3(cos(0.2*iTime), 2.0, 10.0+3.0*sin(0.2*iTime));\n    vec2 cur_sdf = vec2(1e10, 0.0);\n\n    cur_sdf = compSDF(cur_sdf, vec2(p.y, PLANE)); //plane\n    cur_sdf = compSDF(cur_sdf, vec2(sdSphere(p-sph_o, 2.0), SPHERE1)); //sphere\n    cur_sdf = compSDF(cur_sdf, vec2(sdSphere(p-sph_o+vec3(3.2,0.5,-0.5), 0.7), SPHERE1)); //sphere\n    \n    return cur_sdf;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.001;\n    vec2 res;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd; //Go along ray\n        res = map(p); //Calc distance to surface, res.x\n        if(res.x < SURF_DIST || dO>MAX_DIST) break;\n        dO += res.x ;\n    }\n    if (dO > MAX_DIST) dO = -1.0;\n    return vec2(dO, res.y);\n}\n\nfloat calcSoftShdw(vec3 ro, vec3 rd, float k)\n{\n    //more info: https://iquilezles.org/articles/rmshadows\n    //Circle circle intersection: https://mathworld.wolfram.com/Circle-CircleIntersection.html\n\n    float res = 1.0; //1.0 if hard shadow\n    float prev_d = 1e10; //previous closest distance to surface\n    for(float t = 0.0; t<MAX_DIST;)\n    {\n        float d = map(ro + t*rd).x;\n        if(d < SURF_DIST){ return 0.0; }\n        float y = d*d/(2.0*prev_d); //y: distance from curr pos to ray midpoint \n        float d_ys = sqrt(d*d-y*y);//d_ms: distance from y to closest surface\n        float sh =  clamp(k*d_ys/max(0.0, t-y),0.0,1.0);\n        \n        res = min(res, sh*sh*(3.0-2.0*sh));//apply smoothstep (3-2x)*x^2\n        prev_d = d;\n        t += d;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    float d = map(p).x; //get distance to surface\n    vec2 e = vec2(0.01, 0);//error bias for difference\n    vec3 n = normalize(vec3( //find normal using small difference\n            d-map(p-e.xyy).x,    \n            d-map(p-e.yxy).x,  \n            d-map(p-e.yyx).x\n    ));\n    return n;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //Raymarch pixel\n    vec2 res = rayMarch(ro, rd); //distance to point p\n    float d = res.x;\n    //sky colour\n    vec3 col = vec3(0.4, 0.6, 0.8) - 0.7*rd.y;\n    if (d > 0.0){\n\n        vec3 p = ro + d*rd;\n        //colour and lights\n        vec3 mat = vec3(0.0);\n        if(res.y<1.0){ mat = vec3(0.017, 0.02, 0.03);}\n        else if(res.y<2.0){ mat = vec3(0.18);}\n\n        \n\n        vec3 lpos = vec3(1.5, 1.5, -1.0);\n        float speed = 1.0;\n        //lpos.xz += vec2(sin(iTime*speed), cos(iTime*speed))*2.;\n\n        //light & normal vectors\n        vec3 l = normalize(lpos-0.0);\n        vec3 n = calcNormal(p);\n\n        //diffuse light\n        float dif = clamp(dot(n,l), 0.0, 1.0);\n        float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounce_dif = clamp(0.2+0.2*dot(n,vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        float shdw = calcSoftShdw(p+n*SURF_DIST, l, 16.0); //step(rayMarch((p+n*SURF_DIST), l).x, 0.0);//hard shadows\n        \n        //specular light\n        vec3 h = normalize(l + normalize((ro-p)));\n        float spec = pow(max(0.0, dot(n,h)), 128.0);\n        \n\n        vec3 light_in = vec3(0.0);\n        light_in += vec3(7.0, 5.8, 3.6)*dif*shdw;\n        light_in += vec3(0.5, 0.8, 0.6)*sky_dif;\n        light_in += vec3(0.6, 0.3, 0.1)*bounce_dif;\n\n        col = mat*light_in;\n\n        col += mat*spec*shdw;\n    }\n    return (col);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera/Ray origin\n    vec3 ro = vec3(0.0, 2.7, -1.2);\n\n\n    vec3 avrg_col = vec3(0.0);\n#if AA>1 //Supersampling AA\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        //Pixel coordinates\n        vec2 of = vec2(float(i),float(j)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord+of)- .5*iResolution.xy)/iResolution.y;\n#else\n        \n        vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n#endif\n        \n        //Ray direction\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n        \n        //Render scene\n        vec3 col = render(ro,rd);\n        \n        \n\n        avrg_col += col;\n\n#if AA>1      \n    }\n    avrg_col /= float(AA*AA);//Apply AA\n#endif\n    //gamma\n    avrg_col = pow(avrg_col, vec3(0.4545));\n\n    fragColor = vec4(avrg_col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}