{
    "Shader": {
        "info": {
            "date": "1703289024",
            "description": "A port of the symvox SVDAG octree dda algorithm\nhttps://github.com/RvanderLaan/SVDAG-Compression\nIt's supposed to look very wrong. There's no SVDAG data yet.\nI don't believe the shader works correctly...\n",
            "flags": 48,
            "hasliked": 0,
            "id": "McXGRX",
            "likes": 3,
            "name": "SymVox  SVDAG Octree DDA",
            "published": 3,
            "tags": [
                "voxel",
                "dda",
                "trace",
                "octree",
                "dag",
                "svdag",
                "directedacyclicgraph",
                "symvox"
            ],
            "usePreview": 1,
            "username": "GabeRundlett",
            "viewed": 232
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 image_size = vec4(iResolution.xy, vec2(1.0) / iResolution.xy);\n    // invert Y because OpenGL is silly\n    vec2 pixel_pos = vec2(fragCoord.x, image_size.y - 1.0 - fragCoord.y);\n\n    Player player = load_player(iChannel0);\n    Camera cam = player_get_camera(player, image_size);\n\n    vec2 uv = get_uv(pixel_pos, image_size);\n    ViewRayContext vrc = vrc_from_uv(cam, uv);\n\n    vec3 ray_pos = ray_origin_ws(vrc);\n    vec3 ray_dir = ray_dir_ws(vrc);\n\n    Ray ray = Ray(ray_pos, ray_dir);\n\n    vec3 pos = vec3(0);\n    vec3 nrm = vec3(0);\n    vec4 res = trace_ray(ray, vec2(1e-10, 1e30), 1.0, nrm);\n\n    vec3 col = vec3(0);\n    switch (int(res.x)) {\n    case -1: col = vec3(0.0);           // inside bbox, no intersection\n    case -3: col = vec3(1.0, 0.0, 0.0); // too many iterations\n    case -4: col = vec3(0.5, 0.7, 1.0); // never hit bbox\n    case -2: break;   // left the bounds\n    default:\n        pos = ray_pos + ray_dir * res.x;\n        col = pos;\n        break;\n    }\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CAMERA CONTROLLER\n\nconst float MOUSE_SENSITIVITY = 0.01;                  // radians per pixel\nconst float WALK_SPEED = 1.0;                          // units (meters) per second\nconst float SPRINT_SPEED = 4.0;                        // units (meters) per second\nconst float VERTICAL_FOV = 75.0;                       // degrees\nconst float VERTICAL_FOV_ZOOM = 20.0;                  // degrees\nconst float VERTICAL_FOV_ZOOM_ANIMATION_SPEED = 500.0; // degrees per second\n\nconst int KEY_MOVE_FORWARD = 87;  // W\nconst int KEY_MOVE_BACKWARD = 83; // S\nconst int KEY_MOVE_LEFT = 65;     // A\nconst int KEY_MOVE_RIGHT = 68;    // D\nconst int KEY_MOVE_UP = 32;       // SPACE\nconst int KEY_MOVE_DOWN = 17;     // CTRL\nconst int KEY_MOVE_SPRINT = 16;   // SHIFT\nconst int KEY_ZOOM = 70;          // F\n\nconst float PI = 3.14159265;\n\nstruct Rotor3d {\n    float scalar;\n    float xy;\n    float yz;\n    float zx;\n};\nstruct RigidTransform {\n    vec3 translation;\n    Rotor3d orientation;\n};\n\nRotor3d from_to_rotor(vec3 from_dir, vec3 to_dir) {\n    from_dir = normalize(from_dir);\n    to_dir = normalize(to_dir);\n    // Calculations below assume the input directions are normalised\n    vec3 halfway = normalize(from_dir + to_dir);\n    vec3 wedge = vec3(\n        (halfway.x * from_dir.y) - (halfway.y * from_dir.x),\n        (halfway.y * from_dir.z) - (halfway.z * from_dir.y),\n        (halfway.z * from_dir.x) - (halfway.x * from_dir.z));\n    Rotor3d result;\n    result.scalar = dot(from_dir, halfway);\n    result.xy = wedge.x;\n    result.yz = wedge.y;\n    result.zx = wedge.z;\n    return result;\n}\nRotor3d reverse(Rotor3d r) {\n    Rotor3d result;\n    result.scalar = r.scalar,\n    result.xy = -r.xy;\n    result.yz = -r.yz;\n    result.zx = -r.zx;\n    return result;\n}\nvec3 transform(Rotor3d r, vec3 v) {\n    // Assume r is formed by the multiplication of two unit vectors.\n    // Then S = Rv, result = SR^{-1} where R^{-1} is just R with the bivector coefficients negated\n    float S_x = r.scalar * v.x + r.xy * v.y - r.zx * v.z;\n    float S_y = r.scalar * v.y - r.xy * v.x + r.yz * v.z;\n    float S_z = r.scalar * v.z - r.yz * v.y + r.zx * v.x;\n    float S_xyz = r.xy * v.z + r.yz * v.x + r.zx * v.y;\n\n    vec3 result;\n    result.x = S_x * r.scalar + S_y * r.xy + S_xyz * r.yz - S_z * r.zx;\n    result.y = S_y * r.scalar - S_x * r.xy + S_z * r.yz + S_xyz * r.zx;\n    result.z = S_z * r.scalar + S_xyz * r.xy - S_y * r.yz + S_x * r.zx;\n    return result;\n}\n\nstruct Player {\n    vec3 pos;\n    vec4 rot;\n\n    float near;\n    float fov;\n    vec2 mouse_state;\n};\n\nstruct Camera {\n    mat4 view_to_clip;\n    mat4 clip_to_view;\n    mat4 world_to_view;\n    mat4 view_to_world;\n};\n\nstruct ViewRayContext {\n    vec4 ray_dir_cs;\n    vec4 ray_dir_vs_h;\n    vec4 ray_dir_ws_h;\n    vec4 ray_origin_cs;\n    vec4 ray_origin_vs_h;\n    vec4 ray_origin_ws_h;\n};\n\nvoid player_init(inout Player self) {\n    self.pos = vec3(3.0, 3.0, 2.5);\n    self.rot = vec4(-2.4, 1.0, 0.0, 0.0);\n    self.near = 0.01;\n    self.fov = VERTICAL_FOV;\n    self.mouse_state = vec2(-1.0);\n}\n\nvoid player_update(inout Player self, float dt, vec4 mouse_pos, sampler2D keyboard_image) {\n    vec2 mouse_delta = vec2(0.0);\n    if (self.mouse_state.x > 0.0) {\n        mouse_delta = mouse_pos.xy - self.mouse_state;\n    }\n    if (mouse_pos.z > 0.0) {\n        self.mouse_state = mouse_pos.xy;\n    } else {\n        self.mouse_state = vec2(-1.0);\n    }\n\n    self.rot.x += mouse_delta.x * MOUSE_SENSITIVITY;\n    self.rot.y += mouse_delta.y * MOUSE_SENSITIVITY;\n\n    self.rot.y = clamp(self.rot.y, 0.0, PI);\n\n    vec3 forward = vec3(sin(self.rot.x), cos(self.rot.x), 0.0);\n    vec3 right = vec3(forward.yx * vec2(1.0, -1.0), 0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n\n#define LOAD_KEY(KEY) texelFetch(keyboard_image, ivec2(KEY, 0), 0).x > 0.0\n\n    float speed = WALK_SPEED;\n    if (LOAD_KEY(KEY_MOVE_SPRINT)) {\n        speed = SPRINT_SPEED;\n    }\n\n    if (LOAD_KEY(KEY_MOVE_FORWARD)) {\n        self.pos += forward * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_BACKWARD)) {\n        self.pos -= forward * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_LEFT)) {\n        self.pos -= right * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_RIGHT)) {\n        self.pos += right * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_UP)) {\n        self.pos += up * speed * dt;\n    }\n    if (LOAD_KEY(KEY_MOVE_DOWN)) {\n        self.pos -= up * speed * dt;\n    }\n\n    if (LOAD_KEY(KEY_ZOOM)) {\n        self.fov = clamp(self.fov - dt * VERTICAL_FOV_ZOOM_ANIMATION_SPEED, VERTICAL_FOV_ZOOM, VERTICAL_FOV);\n    } else {\n        self.fov = clamp(self.fov + dt * VERTICAL_FOV_ZOOM_ANIMATION_SPEED, VERTICAL_FOV_ZOOM, VERTICAL_FOV);\n    }\n\n#undef LOAD_KEY\n}\n\nmat4 rotation_matrix(float yaw, float pitch, float roll) {\n    float sin_rot_x = sin(pitch), cos_rot_x = cos(pitch);\n    float sin_rot_y = sin(roll), cos_rot_y = cos(roll);\n    float sin_rot_z = sin(yaw), cos_rot_z = cos(yaw);\n    return mat4(\n               cos_rot_z, -sin_rot_z, 0, 0,\n               sin_rot_z, cos_rot_z, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1) *\n           mat4(\n               1, 0, 0, 0,\n               0, cos_rot_x, sin_rot_x, 0,\n               0, -sin_rot_x, cos_rot_x, 0,\n               0, 0, 0, 1) *\n           mat4(\n               cos_rot_y, -sin_rot_y, 0, 0,\n               sin_rot_y, cos_rot_y, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1);\n}\nmat4 inv_rotation_matrix(float yaw, float pitch, float roll) {\n    float sin_rot_x = sin(-pitch), cos_rot_x = cos(-pitch);\n    float sin_rot_y = sin(-roll), cos_rot_y = cos(-roll);\n    float sin_rot_z = sin(-yaw), cos_rot_z = cos(-yaw);\n    return mat4(\n               cos_rot_y, -sin_rot_y, 0, 0,\n               sin_rot_y, cos_rot_y, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1) *\n           mat4(\n               1, 0, 0, 0,\n               0, cos_rot_x, sin_rot_x, 0,\n               0, -sin_rot_x, cos_rot_x, 0,\n               0, 0, 0, 1) *\n           mat4(\n               cos_rot_z, -sin_rot_z, 0, 0,\n               sin_rot_z, cos_rot_z, 0, 0,\n               0, 0, 1, 0,\n               0, 0, 0, 1);\n}\nmat4 translation_matrix(vec3 pos) {\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        pos, 1);\n}\n\nCamera player_get_camera(Player self, vec4 tex_size) {\n    Camera result;\n\n    float aspect = tex_size.x * tex_size.w;\n    float tan_half_fov = tan(self.fov * PI / 180.0 * 0.5);\n\n    result.view_to_clip = mat4(0.0);\n    result.view_to_clip[0][0] = +1.0 / tan_half_fov / aspect;\n    result.view_to_clip[1][1] = +1.0 / tan_half_fov;\n    result.view_to_clip[2][2] = +0.0;\n    result.view_to_clip[2][3] = -1.0;\n    result.view_to_clip[3][2] = self.near;\n\n    result.clip_to_view = mat4(0.0);\n    result.clip_to_view[0][0] = tan_half_fov * aspect;\n    result.clip_to_view[1][1] = tan_half_fov;\n    result.clip_to_view[2][2] = +0.0;\n    result.clip_to_view[2][3] = +1.0 / self.near;\n    result.clip_to_view[3][2] = -1.0;\n\n    result.view_to_world = translation_matrix(self.pos) * rotation_matrix(self.rot.x, self.rot.y, self.rot.z);\n    result.world_to_view = inv_rotation_matrix(self.rot.x, self.rot.y, self.rot.z) * translation_matrix(-self.pos);\n\n    return result;\n}\n\nvec2 get_uv(vec2 pix, vec4 tex_size) { return (floor(pix) + 0.5) * tex_size.zw; }\nvec2 cs_to_uv(vec2 cs) { return cs * vec2(0.5, -0.5) + vec2(0.5, 0.5); }\nvec2 uv_to_cs(vec2 uv) { return (uv - 0.5) * vec2(2.0, -2.0); }\n\nViewRayContext vrc_from_uv(Camera cam, vec2 uv) {\n    ViewRayContext res;\n\n    res.ray_dir_cs = vec4(uv_to_cs(uv), 0.0, 1.0);\n    res.ray_dir_vs_h = cam.clip_to_view * res.ray_dir_cs;\n    res.ray_dir_ws_h = cam.view_to_world * res.ray_dir_vs_h;\n    res.ray_origin_cs = vec4(uv_to_cs(uv), 1.0, 1.0);\n    res.ray_origin_vs_h = cam.clip_to_view * res.ray_origin_cs;\n    res.ray_origin_ws_h = cam.view_to_world * res.ray_origin_vs_h;\n\n    return res;\n}\n\nvec3 ray_dir_vs(in ViewRayContext vrc) { return normalize(vrc.ray_dir_vs_h.xyz); }\nvec3 ray_dir_ws(in ViewRayContext vrc) { return normalize(vrc.ray_dir_ws_h.xyz); }\nvec3 ray_origin_vs(in ViewRayContext vrc) { return vrc.ray_origin_vs_h.xyz / vrc.ray_origin_vs_h.w; }\nvec3 ray_origin_ws(in ViewRayContext vrc) { return vrc.ray_origin_ws_h.xyz / vrc.ray_origin_ws_h.w; }\n\n// ShaderToy-specific code\n\nPlayer load_player(sampler2D player_image) {\n    Player result;\n    result.pos = texelFetch(player_image, ivec2(0, 0), 0).xyz;\n    result.rot = texelFetch(player_image, ivec2(1, 0), 0);\n    vec4 nf = texelFetch(player_image, ivec2(2, 0), 0);\n    result.mouse_state = texelFetch(player_image, ivec2(3, 0), 0).xy;\n    result.near = nf.x;\n    result.fov = nf.y;\n    return result;\n}\n\nvoid save_player(Player self, out vec4 fragColor, vec2 fragCoord) {\n    ivec2 pixel_i = ivec2(fragCoord);\n    if (pixel_i.y == 0 && pixel_i.x <= 4) {\n        switch (pixel_i.x) {\n        case 0:\n            fragColor = vec4(self.pos, 0.0);\n            break;\n        case 1:\n            fragColor = self.rot;\n            break;\n        case 2:\n            fragColor = vec4(self.near, self.fov, 0.0, 0.0);\n            break;\n        case 3:\n            fragColor = vec4(self.mouse_state, 0.0, 0.0);\n            break;\n        }\n    }\n}\n\n//=============================================================\n//  This file is part of the SymVox (Symmetry Voxelization) software\n//  Copyright (C) 2016 by CRS4 Visual Computing Group, Pula, Italy\n//\n//  For more information, visit the CRS4 Visual Computing Group\n//  web pages at http://vic.crs4.it\n//\n//  This file may be used under the terms of the GNU General Public\n//  License as published by the Free Software Foundation and appearing\n//  in the file LICENSE included in the packaging of this file.\n//\n//  CRS4 reserves all rights not expressly granted herein.\n//\n//  This file is provided AS IS with NO WARRANTY OF ANY KIND,\n//  INCLUDING THE WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS\n//  FOR A PARTICULAR PURPOSE.\n//=============================================================\n\n// Defined from outside:\n// SVDAG || USSVDAG || SSVDAG\n// SSVDAG_TEX3D\n// VIEWER_MODE || DEPTH_MODE || SHADOW_MODE || AO_MODE\n// N_HS_SAMPLES\n\nconst vec3 sceneBBoxMin = vec3(0);\nconst vec3 sceneBBoxMax = vec3(2);\n\nconst vec3 sceneCenter = (sceneBBoxMax + sceneBBoxMin) * 0.5;\n// half the width of the root-node. Aka half the max extent\nconst float rootHalfSide = max(max(sceneBBoxMax.x - sceneBBoxMin.x, sceneBBoxMax.y - sceneBBoxMin.y), sceneBBoxMax.z - sceneBBoxMin.z) / 2.0;\nconst uint drawLevel = 12u;\nconst uint maxIters = 300u;\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct traversal_status {\n    float t_current;\n    int node_index;\n    uint hdr;\n    ivec3 mirror_mask;\n    uvec2 leaf_data;\n\n    ivec3 idx;\n    ivec3 local_idx;\n    uint child_linear_index;\n    vec3 t_next_crossing;\n    vec3 inv_ray_d;\n    ivec3 delta_idx;\n    int current_node_size;\n\n    float cell_size;\n    uint level;\n};\n\n//////////////////////////// STACK STUFF ////////////////////\n\n#define INNER_LEVELS 12\n#define MAX_STACK_DEPTH (INNER_LEVELS + 1)\n\nivec3 stack[MAX_STACK_DEPTH];\nuint stack_size = 0u;\n\nvoid stack_push(in int node, in uint hdr, in ivec3 mirror_mask, in uint level) {\n    int mask = mirror_mask.x | (mirror_mask.y << 1) | (mirror_mask.z << 2) | int(level << 3);\n    stack[stack_size] = ivec3(node, hdr, mask);\n    ++stack_size;\n}\n\nvoid stack_pop_in(out int node, out uint hdr, out ivec3 mirror_mask, out uint level) {\n    --stack_size;\n    ivec3 node_mask = stack[stack_size];\n    node = node_mask.x;\n    hdr = uint(node_mask.y);\n    int mask = node_mask.z;\n    mirror_mask = ivec3(mask & 1, (mask >> 1) & 1, (mask >> 2) & 1);\n    level = uint(mask >> 3u) & 255u;\n}\n\nbool stack_is_empty() {\n    return stack_size == 0u;\n}\n\nuint voxel_to_linear_idx(in ivec3 mirror_mask, in ivec3 idx, in int sz) {\n    idx = (ivec3(1) - 2 * mirror_mask) * idx + mirror_mask * (sz - 1);\n    return uint(idx.z + sz * (idx.y + sz * idx.x));\n}\n\n#define SVDAG 1\n#define USSVDAG 0\n\nint bit_count(int x) {\n    int c;\n    c = (x & 0x55555555) + ((x >> 1) & 0x55555555);\n    c = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n    c = (c & 0x0F0F0F0F) + ((c >> 4) & 0x0F0F0F0F);\n    c = (c & 0x00FF00FF) + ((c >> 8) & 0x00FF00FF);\n    c = (c & 0x0000FFFF) + ((c >> 16) & 0x0000FFFF);\n    return c;\n}\n\nuvec4 fetch_buffer(int index) {\n    // Given that you have SVDAG voxel data, here's where you'd supply it\n    return uvec4(16 + 4 + 2);\n}\n\n#if SVDAG // ----------------------------------------------------------------------\n\n#define LEAF_SIZE 2\n\nuint myFetch(in int idx) {\n    // On AMD GPUs this causes some problems for files > 32 MM. Took some time to find this out\n    // The idx is signed, so cast it to unsigned\n    // uvec4 tmp = fetch_buffer(idx/4);\n    uvec4 tmp = fetch_buffer(int(uint(idx) / 4u));\n\n    int selected = idx % 4;\n    uint result;\n    if (selected == 0)\n        result = tmp.x;\n    else if (selected == 1)\n        result = tmp.y;\n    else if (selected == 2)\n        result = tmp.z;\n    else if (selected == 3)\n        result = tmp.w;\n    return result;\n}\n\nbool fetch_voxel_bit(in traversal_status ts) {\n    return (ts.hdr & (1u << ts.child_linear_index)) != 0u;\n}\n\nvoid fetch_data(inout traversal_status ts) {\n    ts.hdr = myFetch(ts.node_index);\n}\n\nvoid fetch_child_index_in(inout traversal_status ts) {\n    int childPtrPos = bit_count((int(ts.hdr) & 0xFF) >> ts.child_linear_index);\n    ts.node_index = int(myFetch(ts.node_index + childPtrPos));\n}\n\n#elif USSVDAG // ------------------------------------------------------------------\n\n#define LEAF_SIZE 2\n\nuint myFetch(in int idx) {\n    uvec4 tmp = fetch_buffer(int(uint(idx) / 4u));\n    int selected = idx % 4;\n    uint result;\n    if (selected == 0)\n        result = tmp.x;\n    else if (selected == 1)\n        result = tmp.y;\n    else if (selected == 2)\n        result = tmp.z;\n    else if (selected == 3)\n        result = tmp.w;\n    return result;\n}\n\nbool fetch_voxel_bit(in traversal_status ts) {\n    return (ts.hdr & (1u << ts.child_linear_index)) != 0u;\n}\n\nvoid fetch_data(inout traversal_status ts) {\n    ts.hdr = myFetch(ts.node_index);\n}\n\nvoid fetch_child_index_in(inout traversal_status ts) {\n    int childPtrPos = bit_count((int(ts.hdr) & 0xFF) >> ts.child_linear_index);\n    ts.node_index = int(myFetch(ts.node_index + childPtrPos));\n    ivec3 m = ivec3(0, 0, 0); // FIXME optimize\n    if ((ts.hdr & (1u << (ts.child_linear_index + 8u))) != 0u)\n        m.x = 1;\n    if ((ts.hdr & (1u << (ts.child_linear_index + 16u))) != 0u)\n        m.y = 1;\n    if ((ts.hdr & (1u << (ts.child_linear_index + 24u))) != 0u)\n        m.z = 1;\n    ts.mirror_mask ^= m;\n}\n\n#endif\n\n///////////////////////////// DDA PRIMITIVES\n\nbool in_bounds(in ivec3 local_idx, in int sz) {\n    bvec3 cond0 = lessThan(local_idx, ivec3(sz));\n    bvec3 cond1 = lessThanEqual(ivec3(0, 0, 0), local_idx);\n    return cond0.x && cond0.y && cond0.z && cond1.x && cond1.y && cond1.z;\n}\n\nvec2 intersectAABB(in Ray r, in vec3 aabbMin, in vec3 aabbMax) {\n    vec3 t1 = (aabbMin - r.o) / r.d;\n    vec3 t2 = (aabbMax - r.o) / r.d;\n    vec3 tMin = min(t1, t2);\n    vec3 tMax = max(t1, t2);\n\n    vec2 t = vec2(max(max(tMin.x, 0.0), max(tMin.y, tMin.z)), min(tMax.x, min(tMax.y, tMax.z)));\n    return t;\n}\n\nbool resolution_ok(float t, float cell_size, float projection_factor) {\n    return (cell_size * projection_factor) < t;\n}\n\n// ==========================================================================\n\nvoid dda_init(in Ray r, inout traversal_status ts) {\n    // Init dda FIXME USE OCTREE POINT LOCATION\n    float voxel_eps = 1.0f / (256. * 1024.);\n    vec3 p_a = r.o + (ts.t_current + voxel_eps) * r.d; // find current pos\n    ts.idx = ivec3(p_a / ts.cell_size);                // current global grid voxel\n\n    // During initialization do not step back for dir < 0, because it would move of more than once cell\n    ivec3 delta_idx_conservative = max(ivec3(0), ts.delta_idx);\n    ivec3 idx_next = ts.idx + delta_idx_conservative;\n    vec3 p_next_a = vec3(idx_next) * ts.cell_size; // this should be the plane\n\n    ts.t_next_crossing = (p_next_a - r.o) * ts.inv_ray_d;\n    ts.local_idx = ts.idx % 2;\n}\n\n// https://stackoverflow.com/questions/24599502/is-there-a-built-in-function-in-glsl-for-and-or-is-there-some-optimized-method-f\nbvec3 bvec3_and(bvec3 one, bvec3 two) {\n    return bvec3(uvec3(one) & uvec3(two));\n}\n\n// Returns the direction of the step\nivec3 dda_next(inout traversal_status ts) {\n    bvec3 b1 = lessThan(ts.t_next_crossing.xyz, ts.t_next_crossing.yzx);\n    bvec3 b2 = lessThanEqual(ts.t_next_crossing.xyz, ts.t_next_crossing.zxy);\n    bvec3 mask = bvec3_and(b1, b2);\n    vec3 mask_v3 = vec3(mask);\n\n    // All components of mask are false except the one components to the shortest t_next_crossing\n    //  which is the direction in which the step have to be done\n    ivec3 delta = ivec3(mask) * ts.delta_idx;\n    ts.idx += delta;\n    ts.local_idx += delta;\n\n    ts.t_current = dot(mask_v3, ts.t_next_crossing);\n    ts.t_next_crossing += mask_v3 * ts.cell_size * abs(ts.inv_ray_d);\n    return delta;\n}\n\nivec3 dda_next_delta_index(in traversal_status ts) {\n    bvec3 b1 = lessThan(ts.t_next_crossing.xyz, ts.t_next_crossing.yzx);\n    bvec3 b2 = lessThanEqual(ts.t_next_crossing.xyz, ts.t_next_crossing.zxy);\n    bvec3 mask = bvec3_and(b1, b2);\n    return ivec3(mask) * ts.delta_idx;\n}\n\nvoid up_in(in Ray r, inout traversal_status ts) {\n    uint delta_level = ts.level;\n    stack_pop_in(ts.node_index, ts.hdr, ts.mirror_mask, ts.level);\n    delta_level -= ts.level;\n\n    ts.idx >>= delta_level; // always delta_level >= 1\n    ts.cell_size *= float(1 << delta_level);\n    ts.current_node_size = ts.level < uint(INNER_LEVELS) ? 2 : LEAF_SIZE;\n    ts.local_idx = ts.idx & 1;\n\n    ivec3 delta_idx_conservative = max(ivec3(0), ts.delta_idx);\n    ivec3 idx_next = ts.idx + delta_idx_conservative;\n    vec3 p_next_a = vec3(idx_next) * ts.cell_size; // this should be the plane\n    ts.t_next_crossing = (p_next_a - r.o) * ts.inv_ray_d;\n}\n\nvoid go_down_one_level(in Ray r, inout traversal_status ts) {\n    ++ts.level;\n    ts.cell_size *= 0.5;\n\n    // Init ts idx, t_next_crossing, local_idx using octree point location\n    vec3 p_a = r.o + ts.t_current * r.d;\n    vec3 p_center = vec3(ts.idx * 2 + 1) * ts.cell_size;\n    bvec3 child_pos = lessThan(p_center, p_a);\n    ivec3 delta = ivec3(child_pos);\n    ts.idx = ts.idx * 2 + delta;\n\n    ivec3 delta_idx_conservative = max(ivec3(0), ts.delta_idx);\n    ivec3 idx_next = ts.idx + delta_idx_conservative;\n    vec3 p_next_a = vec3(idx_next) * ts.cell_size; // this should be the plane\n\n    ts.t_next_crossing = (p_next_a - r.o) * ts.inv_ray_d;\n    ts.local_idx = ts.idx & (ts.current_node_size - 1);\n}\n\nvoid down_in(in Ray r, inout traversal_status ts) {\n    // Check/push next\n    ivec3 local_idx = ts.local_idx;\n    ivec3 delta = dda_next_delta_index(ts);\n\n    if (in_bounds(local_idx + delta, 2)) {\n        stack_push(ts.node_index, ts.hdr, ts.mirror_mask, ts.level);\n    }\n\n    // Go down to next level: Fetch child index (store in node_idx)\n    // and update accumulated_mirror_mask\n    fetch_child_index_in(ts);\n\n    go_down_one_level(r, ts);\n\n    if (ts.level == uint(INNER_LEVELS)) {\n        // GO TO LEAVES\n        ts.current_node_size = LEAF_SIZE;\n        int voxel_count = LEAF_SIZE / 2;\n        while (voxel_count > 1) {\n            go_down_one_level(r, ts);\n            voxel_count >>= 1;\n        }\n    }\n}\n\nbool transform_ray(inout Ray r, inout vec2 t_min_max) {\n    float epsilon = 1E-4f;\n    vec3 sign_rd = sign(r.d);\n\n    // Move ray to LOCAL box\n    float scale = 1.0 / (2.0 * rootHalfSide);\n    vec3 octree_min = sceneCenter - vec3(rootHalfSide);\n    vec3 octree_max = sceneCenter + vec3(rootHalfSide);\n    r.o = r.o - octree_min;\n    r.o *= scale;\n    t_min_max *= scale;\n\n    // avoid div by zero\n    if (r.d.x * sign_rd.x < epsilon)\n        r.d.x = sign_rd.x * epsilon;\n    if (r.d.y * sign_rd.y < epsilon)\n        r.d.y = sign_rd.y * epsilon;\n    if (r.d.z * sign_rd.z < epsilon)\n        r.d.z = sign_rd.z * epsilon;\n\n    vec3 clip_box_min = (sceneBBoxMin - octree_min) * scale;\n    vec3 clip_box_max = (sceneBBoxMax - octree_min) * scale;\n\n    vec2 t_intersection = intersectAABB(r, clip_box_min, clip_box_max);\n\n    t_min_max.x = max(t_intersection.x, t_min_max.x + 1e-10);\n    t_min_max.y = min(t_intersection.y, t_min_max.y);\n\n    return t_intersection.x < t_intersection.y;\n}\n\nvoid init(inout Ray r, inout traversal_status ts) {\n    ts.inv_ray_d = vec3(1.0 / r.d);\n    ts.delta_idx = ivec3(sign(r.d));\n\n    // Level status\n    ts.mirror_mask = ivec3(0, 0, 0);\n    ts.level = 0u;\n    ts.cell_size = 0.5;\n\n    // Step status\n    dda_init(r, ts);\n    ts.current_node_size = 2;\n\n    ts.node_index = 0;\n    fetch_data(ts);\n    ts.child_linear_index = voxel_to_linear_idx(ts.mirror_mask, ts.local_idx, ts.current_node_size);\n}\n\n// TRACE RAY\n// returns vec3\n//\tX: intersection t\n//\t\t >= 0 := intersection!\n//\t\t-1   := inside scene bbox, but no intersection\n//\t\t-2   := -2 out of t bounds\n//\t\t-3   := too many iterations used (> maxIters)\n//\t\t-4   := out of scene bbox\n//\tY: level of the intersection (-1 => no intersection)\n//\tZ: num Iterations used.\n//  W: node index (-1 => no intersection)\n\nvec4 trace_ray(in Ray r, in vec2 t_min_max, in float projection_factor, out vec3 norm) {\n\n    if (!transform_ray(r, t_min_max))\n        return vec4(-4.0, 0, 0, -1); // out of scene Bbox\n\n    float scale = 2.0 * rootHalfSide;\n    traversal_status ts;\n    ts.t_current = t_min_max.x;\n    init(r, ts);\n\n    ivec3 stepDir = ivec3(0);\n\n    int iteration_count = 0;\n    uint max_level = min(uint(INNER_LEVELS), drawLevel - 1u);\n    do {\n        bool full_voxel = fetch_voxel_bit(ts);\n\n        if (!full_voxel) {\n            stepDir = dda_next(ts);\n            if (!in_bounds(ts.local_idx, ts.current_node_size)) {\n                if (stack_is_empty()) {\n                    return vec4(-1., 0, float(iteration_count), -1); // inside scene BBox, but no intersection\n                }\n                up_in(r, ts);\n            }\n        } else {\n            bool hit = (ts.level >= max_level || resolution_ok(ts.t_current, ts.cell_size, projection_factor));\n            if (hit) {\n                norm = -vec3(stepDir);\n                return vec4(ts.t_current * scale, ts.level, float(iteration_count), ts.node_index); // intersection\n            } else {\n                down_in(r, ts);\n                fetch_data(ts);\n            }\n        }\n\n        ts.child_linear_index = voxel_to_linear_idx(ts.mirror_mask, ts.local_idx, ts.current_node_size);\n        ++iteration_count;\n    } while ((ts.t_current < t_min_max.y) && (uint(iteration_count) < maxIters));\n\n    if (uint(iteration_count) >= maxIters)\n        return vec4(-3., 0, float(iteration_count), -1); // too much itarations\n    return vec4(-2., 0, float(iteration_count), -1);     // intersection out of t bounds\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Player player = load_player(iChannel0);\n\n    if (iFrame == 0) {\n        player_init(player);\n    } else {\n        player_update(player, iTimeDelta, iMouse, iChannel1);\n    }\n\n    // This buffer isn't wasted for another use, it just stores the player state in a few pixels.\n    // So basically, it's only necessary that you call `save_player` last in this function to ensure\n    // the player state is saved in the necessary pixels.\n\n    save_player(player, fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}