{
    "Shader": {
        "info": {
            "date": "1587313616",
            "description": "Sky Scattering based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky",
            "flags": 0,
            "hasliked": 0,
            "id": "WdByDV",
            "likes": 6,
            "name": "Sky Scattering (SS12)",
            "published": 3,
            "tags": [
                "shadersundays"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 1616
        },
        "renderpass": [
            {
                "code": "/*\n\tShader Sundays! (12/52) \n\t\"Sky Scattering\"\n\t\n\t!LEFT CLICK FOR FISHEYE LENS!\n\t\n\tHello There! I'm about 4 weeks late with this shader but I'm going to go ahead and \n\tblame the global pandemic for being late on this one. This time a rather simple shader\n\tin size, but not in scope. I still don't understand fully the background for volumetric\n\trendering but I'm happy with this as a first experiment. I've based most of the code\n\ton the teachings of scratchapixel but consulted many papers / articles / shaders in\n\tthe process.\n\t\n\tHere are the best ones I found: \n\thttps://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n\thttps://www.shadertoy.com/view/XtBXDz#\n\thttp://www.pbr-book.org/3ed-2018/Volume_Scattering.html\n\thttp://www-ljk.imag.fr/Publications/Basilic/com.lmc.publi.PUBLI_Article@11e7cdda2f7_f64b69/article.pdf\n\thttps://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\n\thttp://publications.lib.chalmers.se/records/fulltext/203057/203057.pdf\n\t\n\tNow, let's see how quickly can I make up for these missed four weeks....\n*/\n\n//const variables\nconst float S_Luminance = 20.0;\nconst float R_earth     = 6360e3;\nconst float R_atmo      = 6420e3;\nconst float H_Air       = 7994.0; \nconst float H_Aerosols  = 1200.0; \nconst vec3 betaRayleigh = vec3(3.8e-6f, 13.5e-6f, 33.1e-6f); \nconst vec3 betaMie = vec3(21.0e-6);\nconst int numSamples_View = 16;\nconst int numSamples_Sun  = 8;\n\n//uniforms\nfloat time = 0.0;\nvec3 sunDir = vec3(0.0);\n\nfloat\nrayleighPhaseFunction(float mu)\n{\n    return \n           3.0 * (1.0 + mu*mu)\n    / //----------------------\n            (16.0 * M_PI);\n}\n\nfloat\nhenyeyGreensteinPhaseFunc(float mu)\n{\n    const float g = 0.76;\n    return\n                        (1. - g*g)\n    / //---------------------------------------------\n        ((4. * M_PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\nbool\nRayIntersectSphere(vec3 ro, vec3 rd, vec3 sOrigin, float r, inout float t0, inout float t1)\n{\n    ro -= sOrigin;\n    float A = dot(rd, rd);\n    float B = 2.0 * dot(ro, rd);\n    float C = dot(ro, ro) - r*r;\n    float discriminant = B*B - 4.0*A*C;\n\n    //Ray never hits sphere\n    if(discriminant < 0.0) return false;\n\n    t0 = (-B - sqrt(discriminant)) / 2.0*A ;\n    t1 = (-B + sqrt(discriminant)) / 2.0*A ;\n\n    return true;\n}\n\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //Ray setup -> view ray\n    float t0_View, t1_View;\n    vec3 densityAir_View, densityAerosols_View;\n    vec3 totalRayleigh, totalMie;\n\n    //Atmosphere intersection -> view ray\n    bool hit = RayIntersectSphere(ro, rd, vec3(0.0), R_atmo , t0_View, t1_View);\n    if(!hit) return totalRayleigh; //Empty value\n\n    //Phase functions\n    float mu = dot(rd, sunDir);\n    float phaseRayleigh = rayleighPhaseFunction(mu);\n    float phaseMie = henyeyGreensteinPhaseFunc(mu);\n\n    //Ray marching -> view ray\n    float stepSize_View = t1_View / float(numSamples_View);\n    float t_View = 0.0; \n    for(int i = 0; i < numSamples_View; ++i)\n    {\n        //Ray pos and height\n        vec3 pos_View = ro + rd*(t_View + stepSize_View * 0.5);\n        float height_View = length(pos_View) - R_earth;\n\n        //Density at current location\n        float airDensityAtPos_View = exp(- height_View / H_Air ) * stepSize_View;\n        float aerosolDensityAtPos_View = exp(-height_View / H_Aerosols) * stepSize_View;\n        densityAir_View += airDensityAtPos_View;\n        densityAerosols_View += aerosolDensityAtPos_View;\n\n        //Ray setup -> Sun ray\n        vec3 densityAir_Sun, densityAerosols_Sun;\n        float t0_Sun, t1_Sun;\n\n        //Atmosphere intersection -> Sun ray\n        RayIntersectSphere(pos_View, sunDir, vec3(0.0), R_atmo , t0_Sun, t1_Sun);\n\n        //Raymarching from point in view ray -> sunDir\n        float t_Sun = 0.0; \n        float stepSize_Sun = t1_Sun / float(numSamples_Sun);\n        bool hitGround = false;\n        for(int i =0; i < numSamples_Sun; ++i)\n        {\n            //Ray pos and height\n            vec3 pos_Sun = pos_View + sunDir * (t_Sun + stepSize_Sun * 0.5);\n            float height_Sun = length(pos_Sun) - R_earth;\n            \n            //Early out if you're in earth shadow\n            if(height_Sun < 0.)\n            {\n                 hitGround = true;\n                 break;\n            }\n\t\t\t\n            //Density at current location\n            densityAir_Sun      += exp(-height_Sun / H_Air)      * stepSize_Sun;\n            densityAerosols_Sun += exp(-height_Sun / H_Aerosols) * stepSize_Sun;\n\n            t_Sun += stepSize_Sun;\n        }\n\n        //Earth shadow\n        if(!hitGround) \n        {\n            //Multiplication of exponentials == sum of exponents\n            vec3 tau = betaRayleigh * (densityAir_View);\n            tau += betaMie * 1.1 * (densityAerosols_Sun + densityAerosols_View); \n            vec3 transmittance = exp(-tau);\n\n            //Total scattering from both view and sun ray direction up to this point\n            totalRayleigh += airDensityAtPos_View * transmittance;\n            totalMie      += aerosolDensityAtPos_View * transmittance;\n        }\n\t\t\n        t_View += stepSize_View;\n    }\n\n    return S_Luminance * (totalRayleigh * phaseRayleigh * betaRayleigh +\n                          totalMie * phaseMie * betaMie );\n}\n\nvoid \nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Init common vars\n    time = iTime / 15.0;\n    const bool fishEye = true;\n    const bool mouseControl = false;\n\n    sunDir = normalize(vec3(cos(time), abs(sin(time)) - 0.2, 0.0));\n    if(mouseControl)\n        sunDir = normalize(vec3(iMouse.xy,0.0));\n    \n    vec3 col = vec3(0.0);\n\n    //Common Camera setup\n    vec3 rayOrigin = vec3(0, R_earth + 1.0 , 0.0);\n    vec2 uv = 2.0 *  (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    vec3 rayDirection_WS;\n    if(fishEye && iMouse.z < 0.1)\n    {\n\t\t//Pinhole camera\n        vec3 target = rayOrigin + vec3(1.0, 0.0, 0.0);\n        const float nearPlane = 1.0;\n        rayDirection_WS = SetCamera(rayOrigin, target, 0.0) * normalize(vec3(uv, nearPlane));\n    }\n    else\n    {\n                //Fisheye camera\n        const float hemisphereRadius = 1.0;\n        float length2 = dot(uv, uv);\n        if(length2 > hemisphereRadius) return;\n        float phi = atan(uv.y, uv.x); \n        float theta = acos(sqrt((hemisphereRadius - length2)));\n        rayDirection_WS = vec3(sin(theta) * cos(phi),\n                           cos(theta),\n                           -sin(theta) * sin(phi));\n        \n    }\n\n    col = Render(rayOrigin, rayDirection_WS);\n\n    GAMMA(col);\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define INV_GAMMA  0.454545\n#define M_PI acos(-1.0)\n#define M_TAU M_PI*2.0\n\n//Comment this out if running this file on shadertoy\n#define SHADERTOY \n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Shaping functions-----------------------------\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat \nsdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat\nsdGroundPlane(vec3 p)\n{\n    return p.y;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------SDF Joining functions-----------------------------\n#define UOP(dist, ID) res = uop(res, vec2(dist, ID))\nvec2\nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Rotation functions--------------------------------\nvec2 \nrotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Noise functions-----------------------------------\nfloat\nhash(float seed)\n{\n    uvec2 p = floatBitsToUint(vec2(seed+=.1,seed+=.1));\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    uint n = h32^(h32 >> 16);\n    return float(n)/float(0xffffffffU);\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Camera functions------------------------------\n\n/*\n    Camera to World transform\n*/\nmat3\nSetCamera(vec3 ro, vec3 ta, float roll)\n{\n    /*\n        IÃ±igos way:\n        vec3 cw = normalize(ta-ro);  \n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    */\n#if 0\n    //My version\n    vec3 f, temp, r, u;\n    f = normalize(ta - ro); \n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(temp, f));\n    u = (cross(f, r)); //\n\n    return mat3(r, u, f);\n#else\n    //Inigos version with other names\n    vec3 k = normalize(ta-ro);\n\tvec3 j_temp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 i = normalize( cross(k,j_temp) ); //This results in -i\n\tvec3 j =          ( cross(i,k) ); //This results in +j!\n    \n    /*\n        I don't use his because his camera results in a left-handed coordinate sytem.\n    */\n    return mat3( i, j, k ); // -i, +j, +k?\n#endif\n\n}\n\n//------------------------------------------------------------------------------------\n//----------------------------------Path Trace functions------------------------------\nvec3\nCosineWeightedRay(vec3 N, float seed)\n{\n    float u = hash(seed + 70.93);\n    float v = hash(seed + 21.43);\n\n    float a = M_TAU*v;\n    u = 2.0*u - 1.0;\n\n    return(normalize(N + vec3(sqrt(1.0 - u*u)*vec2(cos(a), sin(a)), u)));\n}\n\n//--------------------------------------------------------------------------------------\n//----------------------------------Post processing functions----------------------------\n#define GAMMA(col) col = pow(col, vec3(INV_GAMMA))\n\n\n//---------------------------------------------------------------------------------------- \n//----------------------------------Basic functions---------------------------------------\n#ifdef SHADERTOY\n#define saturate(col) clamp(col, 0.0, 1.0)\n#endif\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}