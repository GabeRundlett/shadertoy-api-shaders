{
    "Shader": {
        "info": {
            "date": "1565304523",
            "description": "Relevant blog post [url=http://www.4rknova.com/blog/2019/08/08/generative-art]here[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3lSXRw",
            "likes": 16,
            "name": "Generative Art, Geometric Doodle",
            "published": 3,
            "tags": [
                "doodle",
                "geometry",
                "pattern",
                "polar"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 1725
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI  3.14159265359\n\n#define ITERATIONS (75)     // Number of iterations\n#define AMPLITUDE  (0.30)\t// Polar radius multiplier\n#define PERIOD     (5.00)   // Polar angle multiplier (i.e. repetitions)\n#define PERIOD_MUL (3.00)   // Angular offset modifier\n#define SCALE      (1.50)   // Zoom factor\n#define RING_MIN   (0.97)   // Ring shape lower boundary\n#define RING_MAX   (1.00)   // Ring shape upper boundary\n#define FADE       (6.50)   // Fading factor\n#define BRIGHTNESS (0.25)   // Brightness modifier\n#define CONTRAST   (0.85)   // Contrast modifier\n\nfloat ring(float r) { return step(r, RING_MAX) - step(r, RING_MIN); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the aspect corrected normalized 2D coords\n\tvec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Calculate the polar coordinates and scale\n    float r     = SCALE  * length(p);\n    float theta = PERIOD * atan(p.y, p.x);\n        \n    // This is the grayscale value (gradient) of the pixel\n    float f = 0.0;\n    \n    // In each iteration calculate the distance from the shape\n    // and accumulate the value to the pixel's gradient\n    for (int i = 1; i < ITERATIONS; ++i) {\n        float k = float(i)/float(ITERATIONS);\n        \n        // For each iteration, offset the angle (i.e. rotate the shape)\n        // Scale the radius for each iternation and offset the value by\n        // a sine wave of the polar angle.\n    \tfloat w = r/k + AMPLITUDE * sin(theta + PI * PERIOD_MUL / k);\n        \n        // Calculate the distance from the shape and fade the\n        // value based on a constant value, the polar radius and\n        // the iteration number. Accumulate value for current pixel.\n        f += ring(w) * BRIGHTNESS * pow(k,FADE) * r;\n    }\n    \n    fragColor = vec4(vec3(pow(f,CONTRAST)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}