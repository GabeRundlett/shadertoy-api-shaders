{
    "Shader": {
        "info": {
            "date": "1645204130",
            "description": "I was playing with @macbooktall's IFS and this pair of lungs appeared.\n\nRendered animation here https://twitter.com/tdhooper/status/1494669344021913601",
            "flags": 32,
            "hasliked": 0,
            "id": "sdXBzs",
            "likes": 30,
            "name": "Fractal breathing",
            "published": 3,
            "tags": [
                "sss",
                "ifs"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 1025
        },
        "renderpass": [
            {
                "code": "vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define ANIMATE\n#define SSS\n#define DOF\n\nfloat guiRotPhaseX = .591;\nfloat guiRotPhaseY = .366;\nfloat guiRotPhaseZ = .5005000000000001;\nfloat guiAnimPhaseX = -.42;\nfloat guiAnimPhaseY = .33;\nfloat guiAnimPhaseZ = .0;\nfloat guiOffsetX = .66;\nfloat guiOffsetY = .37;\nfloat guiOffsetZ = .18;\nfloat spaceAnimFreq = .06;\nfloat startScale = 1.5;\nvec3 animAmp = vec3(-.02,.02,-.06) * 3.;\n \n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq https://www.shadertoy.com/view/tl23Rm\nvec2 rndunit2(vec2 seed ) {\n    vec2 h = seed * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat time;\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n    bool sss;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    vec3 albedo;\n    int id;\n};\n\nMaterial shadeModel(Model model, inout vec3 nor) {\n    vec3 skin = pow(vec3(0.890,0.769,0.710), vec3(2.2));\n    float flush = smoothstep(-1.75, -.0, model.albedo.x);\n    skin += mix(vec3(-.6,.0,.15) * .5, vec3(.4,-.03,-.05), flush);\n    skin *= vec3(1.1,.8,.7);\n    skin = clamp(skin, vec3(0,0,0), vec3(1,1,1));\n    bool sss = false;\n    #ifdef SSS\n    sss = true;\n    #endif\n    return Material(skin, .15, .3, sss);\n}\n\n\n// IFS from Connor Bell (macbooktall)\nModel map(vec3 p) {\n\n    p.y += .12;\n    pR(p.yz, .75);\n\n    float s = .3;\n    p /= s;\n\n    vec3 pp = p;\n\n    float scale = startScale;\n\n    const int iterations = 20;\n\n    float l = 0.;\n    float len = length(p) * spaceAnimFreq*2.;\n\n    float phase = time * PI * 2. + len * -5.0;\n\n    vec3 rotPhase = vec3(guiRotPhaseX, guiRotPhaseY, guiRotPhaseZ) * PI * 2.;\n    vec3 animPhase = vec3(guiAnimPhaseX, guiAnimPhaseY, guiAnimPhaseZ) * PI * 2.;\n    vec3 offset = vec3(guiOffsetX, guiOffsetY, guiOffsetZ);\n\n    vec3 anim = len + rotPhase + sin(phase + animPhase) * animAmp;\n \n    float orbitTrap = 1e20;\n    for (int i=0; i<iterations; i++) {\n        p.xz = abs(p.zx);\n        p = p * scale - offset;\n        pR(p.xz, anim.x);\n        pR(p.yz, anim.y);\n        pR(p.xy, anim.z);\n        orbitTrap = min(orbitTrap, length(p)-scale);\n    }\n\n    float d = length(p) * pow(scale, -float(iterations));\n\n    p = pp;\n    d = smax(d, -(length(p * vec3(1,1,.75)) - .4), .1);\n\n    d *= s;\n\n\n    return Model(d, p, vec3(orbitTrap), 1);\n\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).d - map(p-h.xyy).d,\n                           map(p+h.yxy).d - map(p-h.yxy).d,\n                           map(p+h.yyx).d - map(p-h.yyx).d ) );\n}\n\n\nvec3 sunPos = normalize(vec3(-.5,.5,-.25)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\nvec3 sunColor = vec3(8.10,6.00,4.20) * 4.5;\n\n\nvec3 env(vec3 dir, bool includeSun) {\n    vec3 col = mix(vec3(.5,.7,1) * .0, vec3(.5,.7,1) * 1., smoothstep(-.2, .2, dir.y));\n    return col * .6;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 400; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep;\n\n        if (model.d < .0002) break;\n\n        if (rayLength > maxDist) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3 dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// Walk on spheres subsurface scattering\n// inspired by blackle https://www.shadertoy.com/view/wsfBDB\nHit walkOnSpheres(vec3 origin, vec3 normal, float startdepth, inout vec2 seed) {\n    Model model;\n    \n    vec2 lastSeed = seed;\n    seed = hash22(seed);\n    normal = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n    \n    model = map(origin - normal * startdepth);\n    origin -= normal * abs(model.d);\n    \n    for (int v = 0; v < 250; v++) {\n        model = map(origin);\n\n        if (abs(model.d) < .00002) break;\n        \n        vec2 lastSeed = seed;\n        seed = hash22(seed);\n        vec3 dir = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n        \n        origin += dir * abs(model.d);\n    }\n    return Hit(model, origin);\n}\n\nvec3 sampleDirect(Hit hit, vec3 nor, vec3 throughput, inout vec2 seed) {\n    vec3 col = vec3(0);\n    vec3 lightDir = (sunPos - hit.pos);\n    vec3 lightSampleDir = getConeSample(lightDir, .0005, seed);\n    seed = hash22(seed);\n    float diffuse = dot(nor, lightSampleDir);\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n    if (diffuse > 0.) {\n        Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += throughput * sunColor/10. * diffuse;\n        }\n    }\n    return col;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n// noby https://www.shadertoy.com/view/lllBDM\nfloat ggx(vec3 nor, vec3 rayDir, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(-rayDir + l);\n    float dnl = clamp(dot(nor,l), 0.0, 1.0);\n    float dnv = clamp(dot(nor,rayDir), 0.0, 1.0);\n    float dnh = clamp(dot(nor,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nvec3 sphereLight(vec3 lightPos, float radius, vec3 pos, vec3 rayDir, vec3 nor) {\n    vec3 L = (lightPos - pos);\n    vec3 ref = reflect(rayDir, nor);\n    vec3 centerToRay = dot(L, ref) * ref - L;\n    vec3 closestPoint = L + centerToRay * clamp(radius / length(centerToRay), 0., 1.);\n    return closestPoint;\n}\n\nvec3 sampleDirectSpec(Hit hit, vec3 rayDir, vec3 nor, float rough, inout vec2 seed) {\n    vec3 lpos = sphereLight(sunPos, 5., hit.pos, rayDir, nor);\n    \n    vec3 lightDir = normalize(lpos - hit.pos);\n    vec3 h = normalize(rayDir + lightDir);\n    float specular = pow(clamp(dot(h, nor), 0., 1.), 64.0);\n\n    vec3 col = vec3(0);\n\n    float fresnel = pow(max(0., 1. + dot(nor, rayDir)), 5.);\n    specular = ggx(nor, rayDir, lightDir, rough, fresnel);\n\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightDir, nor)));\n    if (specular > 0.) {\n        Hit sh = march(shadowOrigin, lightDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += sunColor * specular * .1;\n        }\n    }\n    return col;\n}\n\nconst float sqrt3 = 1.7320508075688772;\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    \n    p *= .85;\n\n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(0,0,.4) * focalLength * 1.;\n    vec3 camTar = vec3(0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    //vec3 origin = eye;\n    //vec3 rayDir = normalize(vec3(p.x * fov, p.y * fov, -1.) * mat3(vView));\n\n\n    #ifdef DOF\n    float fpd = .36 * focalLength;\n    vec3 fp = origin + rayDir * fpd;\n    origin = origin + camMat * vec3(rndunit2(seed), 0.) * .02;\n    rayDir = normalize(fp - origin);\n    #endif\n\n    Hit hit;\n    vec3 nor, ref;\n    Material material;\n    vec3 throughput = vec3(1);\n    vec3 bgCol = skyColor;\n    bool doSpecular = true;\n\n    const int MAX_BOUNCE = 3;\n    \n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n   \n        hit = march(origin, rayDir, 10., .5);\n   \n        if (hit.model.id == 0)\n        {\n            if (bounce > 0 && ! doSpecular)\n                col += env(rayDir, doSpecular) * throughput;\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        seed = hash22(seed);\n        doSpecular = hash12(seed) < material.specular;\n        \n        bool doSSS = material.sss && bounce < 1 && ! doSpecular;\n        if (doSSS) {\n            seed = hash22(seed);\n            doSSS = hash12(seed) < .8;\n        }\n        \n        if ( ! doSpecular) {\n            // update the colorMultiplier\n            throughput *= material.albedo;\n        }\n\n        if (doSSS) {\n            origin = hit.pos;\n            \n            seed = hash22(seed);\n            hit = walkOnSpheres(origin, nor, .05, seed);\n            nor = calcNormal(hit.pos);\n\n            float extinctionDist = distance(origin, hit.pos) * 10.;\n            vec3 extinctionCol = material.albedo;\n            extinctionCol = mix(mix(extinctionCol, vec3(0,0,1), .5), vec3(1,0,0), clamp(extinctionDist - 1., 0., 1.));\n            vec3 extinction = (1. - extinctionCol);\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            extinction = clamp(extinction, vec3(0), vec3(1));\n            throughput *= extinction;\n        }\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular)\n        {\n            seed = hash22(seed);\n            col += sampleDirect(hit, nor, throughput, seed);\n            rayDir = diffuseRayDir;\n        }\n        else\n        {\n            if (bounce == 0) { // fix fireflies from diffuse-bounce specular\n                seed = hash22(seed);\n                col += sampleDirectSpec(hit, rayDir, nor, material.roughness, seed) * throughput;\n            }\n            \n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = 0.5;\n\n    #ifdef ANIMATE\n        time = fract(iTime / 4.);\n        \n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        \n        vec4 col = vec4(0.);\n        const int c = 4;\n        for (int i = 0; i < c; i++) {\n            col += draw(fragCoord, iFrame * c + i);\n        }\n        col /= float(c);\n        \n        col = mix(col, lastCol, .2);\n    #else\n        vec4 col = draw(fragCoord, iFrame);\n        if (iFrame > 0 && iMouse.z <= 0.) {\n            vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n            col += lastCol;\n        }\n    #endif\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}