{
    "Shader": {
        "info": {
            "date": "1524311338",
            "description": "Conelight shader from \"the explorer\"\nThis time with shadows",
            "flags": 0,
            "hasliked": 0,
            "id": "MstBR4",
            "likes": 16,
            "name": "Conelight shadow",
            "published": 3,
            "tags": [
                "shadow",
                "volumetric",
                "conelight"
            ],
            "usePreview": 0,
            "username": "Virgill",
            "viewed": 1017
        },
        "renderpass": [
            {
                "code": "\n\nvec3 lightpos,schein;\nvec3 lightdir = vec3(0,0,1);\nfloat scatter;\n\n\n// noise\nfloat rnd(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\n// box sdf\nfloat sdBox(vec3 p,vec3 b)\n{\n  vec3 d = abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n// 3D noise function (shane)\nfloat noise(vec3 p)\n{\n\tvec3 ip = floor(p);\n    p -= ip; \n    vec3 s = vec3(7,157,113);\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p = p*p*(3.-2.*p); \n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n// capped cone sdf\nfloat sdCone( vec3 p, vec2 c,float le )\n{\n    float f1 = dot(c,vec2(max(length(p.xy),le),p.z*1.1));\n    float f2 = dot(c,vec2(length(p.xy),p.z));\n\n    return max(-f1,f2);\n}\n\n\n// rotation\nvoid pR(inout vec2 p,float a) \n{\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////\n\n\n// main scene\nfloat mapScene(in vec3 p) \n{\n\n    pR(p.zy,iTime*0.35);\n    pR(p.zx,0.18*iTime);\n \tfloat d = sdBox(p,vec3(0.4))-0.03;\n    float d2 = sdBox(p,vec3(0.3,0.3,1.0));\n    float d3 = sdBox(p,vec3(1.0,0.3,0.3));\n    float d4 = sdBox(p,vec3(0.3,1.0,0.3));\n    d= max(d,-d2);\n    d= max(d,-d3);\n    return max(d,-d4)+0.02*noise(20.*p);\n}\n\n// cast ray Shadow\nfloat castRayShadow(in vec3 ro, in vec3 rd) \n{\n    float precis = 0.0001;\n    float h = precis * 2.0;\n    float t = 0.;\n    for(int i = 0; i < 200; i++) \n    {\n    \tif(abs(h) < precis || t > 3.) continue;\n        h = mapScene(ro+rd*t);\n        t += .06*h;\n    }\n    return t;\n}\n\n\n// conelight scene\nfloat map(in vec3 p, int vol) \n{\n\n// main scene in mapScene\n   float d= mapScene(p);\n    \n// cone light\n    if (vol==1)\n    {\n    \tschein=(p-lightpos);\n  \tpR(schein.zx,sin(iTime*-0.3));\n    pR(schein.yz,sin(iTime*1.3));\n        float so = sdCone(schein,normalize(vec2(1,.7)),10.);\n        // get length of light cone\n   \t\tfloat le=0.;\n        if (so<-0.0) le=castRayShadow(normalize(p),normalize(-p+lightpos)); \n    \t// light cone\n        float s = sdCone(schein,normalize(vec2(1,.7)),le)/length(schein*schein)+0.1*noise(10.*p-0.3*iTime)-0.1*noise(p*23.);//+0.1*rnd(p.xy);\n\t\tscatter += max(-s,0.)*.6;\n    }\n    \n\t// flashlight\n    float f = length(p-lightpos)-0.2; \n    return min(f,d);\n}\n\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt, in float co,in int vol) {\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float t = co;\n    for(int i = 0; i < 100; i++) \n    {\n    \tif(abs(h) < precis || t > maxt) continue;\n        h = map(ro+rd*t,vol);\n        t += 0.5*h;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float eps = 0.1, d = map(pos,0);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0),0)-d,map(pos+vec3(0,eps,0),0)-d,map(pos+vec3(0,0,eps),0)-d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0,0,-1.);\n    vec3 rd = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y));\n\n    lightpos = vec3(0.2*cos(0.2*iTime),0.0 + 0.0 * sin(iTime*2.0),.3); \n    pR(lightdir.yz,sin(iTime*-1.3));\n    pR(lightdir.zx,sin(iTime*0.3));\n\n// render\n    vec3 col = vec3(0);\n   \tfloat t= castRay(ro, rd, 15.0,0.-rnd(uv+0.01*iTime)*1.,1);    \n\tfloat depth = clamp(t/5.-1.3,0.,1.);\n\tif (t>15.) t=1000000.;\n//  calculations needed for diffuse + specular light   \n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    float ncol=0.;\n\n\n    // treat light as conelight\n    vec3 L = normalize(lightpos - pos);\t\t\t\t// vector to light position (from surcface)\n    vec3 V = normalize(ro - pos);\t\t\t\t\t// vector to viewer (from surface)\n    vec3 H = normalize(L+V);\t\t\t\t\t\t// half vector of viewer and light vector\n    float NdotL = dot(nor,L);\n    float NdotH = dot(nor,H);\n    float conedot = dot(lightdir, normalize(L));\n    float conecos = 0.7071;\n    float cold = NdotL; \t\t\t\t\t\t\t// diffuse\n    float cols = pow(clamp(NdotH, 0.0, 1.0), 60.0);\t// specular  \n    float cone =  1.;\n    if (NdotL > 0.0 && conedot > conecos)  \t\t\t// 45 degrees, corresponding to cone param (1,1)\n    {        \n         cone =  pow((conedot-conecos)/(1.-conecos),4.);// pow for cone light distribution\n         ncol = (cold + cols) * cone;\t\t\t\t// combine  \n    }    \n  \n\n\n\tcol+=0.3*scatter*vec3(.6,.8,1.);\n    col+= 5.7*vec3(1./16., 1./4., 2./1.)* exp(6.*(-1.+ncol)); \n\n    col = clamp(col,0.,1.);\n \n\tfragColor = vec4(col,depth*.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}