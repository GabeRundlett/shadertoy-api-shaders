{
    "Shader": {
        "info": {
            "date": "1525117233",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3BD4",
            "likes": 7,
            "name": "polar Brick & Tiles & BskWeave",
            "published": 3,
            "tags": [
                "2d",
                "pattern",
                "brick",
                "weaving"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 547
        },
        "renderpass": [
            {
                "code": "// polar variant of https://www.shadertoy.com/view/XdtBzn\n\n#define MM 0\nfloat CELL = 15.,                  // grid size vertically -> cell size\n      HOLLOW = 1.,                 // empty center area ' #bricks )\n      RATIO = 3.,                  // brick length / brick width\n      OFFSET = 0.,                 // offset per circle (cell%). 0=tile, .5=brick\n      ROT0 = 0.,                   // brick fix rotation ( degrees )\n      ROT1 = 0.,                   // brick random rotation amplitude (degrees)\n      ROUND = 1./4.,               // radius of round corners\n      polyN  = 5.,                 // nb sides for polygon and star shape\n      starR  = .5,                 // star interior radius ( % exterior )\n      ROTshape0 = 0.,              // shape fix rotation ( degrees )\n      ROTshape1 = 180.;            // shape random rotation amplitude (degrees)\n\nvec2  CYCLE = vec2(5,10),          // pattern repeat scale ( in #brick )\n      BEVEL = vec2(1)/4.,          // bevel width ( cell %  )\n      GAP  = vec2(.5)/8.,          // inter brick gap ( cell % )\n      SUPERCELL = 0.*vec2(3),         // super tiles ( nb of tiles H, V ) \n      SUPERGAP  = vec2(.2),        // gap around supertile ( cell % )\n      shapeN = vec2(1),            // tiling of shapes in the brick area\n      shapeGap = vec2(0)/8.;       // gap between shapes ( cell % )\n      \nbool  RANDofs = true;              // random tile offset per circle\nint   BRICK = 0,                  // -1: basketweave 0:tiling 1: bricks\n      RAND = 0,                    // 0: white bricks. 1: random B&W. 2: random col\n      TEXT = 2,                    // 0: plein 1: one texture 2: two textures\n      GRAD = 0;                    // gradient through bricks\nvec2  grad = vec2(1,0);            // grad direction & strength\nfloat grad_randA = 2.,             // spread in amplitude ( amp * [1/A,A] )\n      grad_randD = 360.;           // spread in direction ( degrees )\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x )              // integer param\n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) +1e-30; // <- eps to fix a windows/angle bug\n}\nvec3 hash3f(vec3 x) {              // float[0,1] param\n    return hash3(uvec3( x * float(0xffffffffU) ) );\n}\n\n#define rot(a) mat2(sin(radians(a) + vec4(1,0,2,1)*1.5707))\n\n// --- custom bevel profile        // in: [0,1] out: continuous if p(0)=0, p(1)=1\nfloat profile(float d) {\n    return d;\n}\n\n// --- custom shapes: local centered coordinates, box size, shape id (=hash)\n// rectangular brick\nvec4 shapeTile(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n    vec2 A = Box/2. - abs(U),                   // coords from borders \n         B  = A * 2. / BEVEL;                   // coords in bevel\n        float m = min(B.x,B.y);                 // in bevel if [0,1]\n    if (A.x<ROUND && A.y<ROUND)                 // round edges\n        m = (ROUND-length(ROUND-A)) *2./dot(BEVEL,normalize(ROUND-A));\n    \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// disc brick\nvec4 shapeDisc(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n    float A = Box.y/2. - length(U),             // distance from borders \n          B = A * 2. / BEVEL.y,                 // distance in bevel\n          m = B;                                // in bevel if [0,1]\n    \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// poly brick\nvec4 shapePoly(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n     float a = atan(U.x,U.y) + radians(ROTshape0 + ROTshape1*(-1.+2.*hash3f(vec3(id,.4,0)).x)), \n           l = length(U),\n           b = 3.14159/polyN,\n           A = Box.y/2. - l * cos(mod(a,2.*b)-b) / cos(b),\n           B = A * 2. / BEVEL.y,                // distance in bevel\n           m = B;                               // in bevel if [0,1]\n          \n    \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// star brick\nvec4 shapeStar(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n     float a = atan(U.x,-U.y) + radians(ROTshape0 + ROTshape1*(-1.+2.*hash3f(vec3(id,.4,0)).x)),\n           l = length(U),\n           b = 3.14159/polyN,\n          tb = tan(b),\n           s = .5*(starR * tb)/(sqrt(1.+tb*tb)-starR);\n    a = mod(a,2.*b)-b;\n    U = l * vec2(cos(a),sin(a)) / cos(b);\n    U.y = abs(U.y);\n    U.x -= .5*Box.y;\n    float A = -(s*U.x+U.y)/sqrt(1.+s*s),\n          B = A * 2. / BEVEL.y,                 // distance in bevel\n          m = B;                                // in bevel if [0,1]\n         \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// --- higher level custom shape: using serval other shapes.\n// here: draw a tiling of shapes\nvec4 shaper(vec2 U, vec2 Box, float vert, float id) {\n  //return shapePoly(U,Box,id);                // for tests\n  //return shapeStar(U,Box,id);                // for tests\n  //return shapeTile(U,Box,id);                // for tests\n    vec4 O = vec4(0);\n    vec2 N = shapeN-1.,\n       ofs = Box/shapeN;\n    Box = Box/shapeN - shapeGap;\n    //Box = vec2(min(Box.x,Box.y)); //  <- comment for adjustable shapes\n    for (float n=1., j = -N.y/2.; j <=N.y/2.; j++)\n        for (float i = -N.x/2.; i <=N.x/2.; i++, n++)\n            O += shapeTile(U+vec2(i,j)*ofs,Box, vert, hash3f(vec3(id,.9/n++,0)).x);\n    return O;\n}\n\n// --- main tile/brick shader\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = ( U+U- R ) / R.y;\n    bool gap = false;\n    O -= O;\n    demo( floor(U.x-iTime-.2*sin(4.*U.y-3.*iTime)) ); // demo mode\n\n    // polar management\n    float l = length(U)*CELL, a = atan(U.y,U.x), k;\n    if (BRICK==-1) l /= RATIO*=2.;              // basketweave: align larger blocks\n    U = vec2( a*(floor(l)+.5), l );             // polar bands\n    if (U.y<HOLLOW) gap = true;                 // empty center\n    k = 6.28*(floor(l)+.5)/RATIO;\n    U.x *= (floor(k)+(BRICK==-1?.5:0.)) / k;    // integer #cells\n    if (RANDofs) U.x += hash3(uvec3(l,1,12)).x * RATIO;\n    U.x += OFFSET*floor(l);\n    CYCLE = vec2(floor(k),1e5);                 // a circle = a CYCLE\n    if (BRICK==-1) U *= RATIO, RATIO/=2.;       // basketweave\n    \n    vec2 W = vec2(RATIO,1);                     // normalize in cells units\n    float vert = 0.;\n    if (BRICK==-1) SUPERCELL *= RATIO;          // basketweave\n        \n    else U /= W;\n    \n    if (BRICK==1) \n        U.x += .5* mod(floor(U.y),2.);\n    else if (SUPERCELL!=vec2(0)) {\n        vec2 iU = floor(U / SUPERCELL) * SUPERCELL, // pos in supercell\n             fU = mod(U,SUPERCELL);\n        fU = (fU-SUPERGAP) / (SUPERCELL-2.*SUPERGAP);\n        if ( fU !=  clamp(fU,0.,1.) ) gap = true;\n        fU = clamp(fU,0.,1.);\n        U =  iU + fU * SUPERCELL;               // renormalize inside superbrick\n    }\n    if (BRICK==-1) {\n        vec2 iU = floor(U/ RATIO);\n        if ( mod(iU.x+iU.y,2.) > 0. ) vert = 1.;\n        if (vert==1.) U = U.yx;\n        U /= W;\n    }\n    ivec2 H = ivec2( CYCLE==vec2(0) ? U : mod(U,CYCLE) ); // vec2 tile id\n    vec2 S = W* (fract(U) - 1./2.);             // centered coords in a brick\n  //if (S != clamp(S,-W/2.+GAP,W/2.-GAP)) gap = true; // <- enforce gap after rotation\n\n    float id = hash3(uvec3(H,2)).r,\n         dir = ROT0 + ROT1 * (-1.+2.*hash3(uvec3(H,1)).x); // brick rotation\n    S *= rot(dir);\n\n    if (!gap) O = shaper(S, W-2.*GAP, float(vert), id);\n    if (O.a==0.) id = -1.;                     // id of mortar\n\n#if MM    \n // O-=O;\n    O.r = id;                                  // tile id\n // O.g = O.g;                                 // image(height)\n    O.b = dir + 90.*vert;                      // direction (degrees)\n#endif  \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// autodemo touches most parameters but brick size, ratio and grad direction\n\n#define demo(t) {                                    \\\n    vec3 h1 = hash3(uvec3(t*vec3( 1  , 7.2,-3.1))),  \\\n         h2 = hash3(uvec3(t*vec3( 7.2,-3.1, 9.7  ))),\\\n         h3 = hash3(uvec3(t*vec3(-3.1,-9.9, 7.2))),  \\\n         h4 = hash3(uvec3(t*vec3(11.1, 1.3,-7.5))),  \\\n         h5 = hash3(uvec3(t*vec3(-9.3, 5.1,-2.5)));  \\\n   RATIO = ceil(4.*h4.z);                            \\\n   BEVEL = vec2(h1.xy)/8.;                           \\\n    GAP  = vec2(h2.xy)/4.;                           \\\n   ROUND = h1.z/2.;                                  \\\n   BRICK = int(h2.z*2.)-1;                           \\\n   if (BRICK!=1) SUPERCELL = ceil(4.*h2.xy), SUPERGAP = vec2(h2.z)/2.; \\\n   RAND = int(h3.x*3.);                              \\\n   TEXT = int(h3.y*3.);                              \\\n   GRAD = int(h3.z*2.);                              \\\n   ROT0 = h4.x*h4.x*10.;                             \\\n   ROT1 = h4.y*h4.y*10.;                             \\\n   shapeN = 1.+0.*floor(h5.xy*vec2(8,3));            \\\n   polyN  = 3.+floor(h5.z*5.);                       \\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}