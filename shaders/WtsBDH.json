{
    "Shader": {
        "info": {
            "date": "1596614589",
            "description": "How to C2 continuous bicubic interpolation:\n- compute C1 continuous partial derivatives by using a specific convolution kernel (Buffer C)\n- construct a bicubic patch in each 2x2 neighborhood from the values+derivatives stored at the grid vertices (Image)\n",
            "flags": 32,
            "hasliked": 0,
            "id": "WtsBDH",
            "likes": 28,
            "name": "Bicubic C2 cont. Interpolation",
            "published": 3,
            "tags": [
                "filter",
                "filtering",
                "bicubic",
                "cubic",
                "interpolation",
                "kernel",
                "reconstruction",
                "c2"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 1603
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nHow to C2 continuous bicubic interpolation:\n- compute C1 continuous partial derivatives by using a specific convolution kernel (Buffer C)\n- construct a bicubic patch in each 2x2 neighborhood from the values+derivatives stored at the grid vertices (Image)\n- bonus: analytically compute normals during the reconstruction\n\nbottom:\n\tleft:  bicubically sampled grey scale texture\n\tright: artifact free shading based on analytically computed C1 continuous normals  \ntop:\n\tleft:  abs(laplacian); useful for debugging the C2 continuity\n\tright: normals\n\n\nRelated:\n\n- https://www.shadertoy.com/view/wlsBz2 | \"C2-interpolating cubic Kernel\"   (plot + background info on the kernel used to compute the derivatives)\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"            (derivation of the bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/wtByDt | \"Single Sample Bicubic Sampling\"  (approximating the reconstruction with a single sample in 2d)\n- https://www.shadertoy.com/view/tdtyzj | \"Single Sample Tricubic Sampling\" (approximating the reconstruction with a single sample in 3d)\n\n*/\n\n// use this to scale the shown region\n#if 1\n\t#define SCALE 0.125*0.5\n#else\n\t#define SCALE 0.75\n#endif\n\n\n// CUBIC AND BICUBIC RECONSTRUCTION KERNELS ============================================================================================\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives (only used to debug C2 continuity here)\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\n\n// IMAGE ==========================================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n   #if 0\n    //if(uv0.x < 256.0 && uv0.y < 256.0)\n    {\n    \tvec4 col = texelFetch(iChannel0, ivec2(uv0)/1, 0);\n        col.xyz = col.xyz * 2.0 + 0.2;\n    \tfragColor = vec4((clamp01(col.rgb)), 0.0);\n        return;\n    }\n   #endif\n \n    vec3 col;\n    \n    vec2 uv = uv0;\n    \n   #if 1\n    if(uv0.x >= iResolution.x*0.5)\n    uv.x -= iResolution.x*0.5;\n   #endif\n    \n    col = vec3(texture(iChannel0, uv0/iResolution.xy*0.125).r);\n    \n    float s = SCALE;\n    \n    uv += 2.0/SCALE;\n    uv += iMouse.xy;// - iResolution.xy*0.5;\n    \n    vec4 d2;\n    vec4 h = SampleBicubic3(iChannel0, uv * s, d2);\n    \n    float nscale = 4.0;// must be 1 for normals to properly align with height map\n    vec3 N = normalize(vec3(-h.xy * nscale, 1.0));\n    \n    vec3 V = vec3(0.0, 0.0, 1.0);\n    vec3 L = AngToVec(vec2(Pi*0.75, Pi*0.3)).xzy;\n    //vec3 L = AngToVec(vec2(Pi*0.75 + sin(iTime)*(Pi*0.3), Pi*0.3)).xzy;\n    vec3 H = normalize(L + V);\n\n    float ct = clamp01(dot(N, L));\n    \n    if(uv0.x < iResolution.x*0.5)\n    {\n        if(uv0.y < iResolution.y*0.75)\n        {\n    \t\tcol = vec3(h.w);// == col = vec3(SampleBicubic(iChannel0, uv0 * s));\n        }\n        else\n        {\n            col = vec3(abs(d2.x + d2.y));\n            //col = vec3(abs(d2.x + d2.y + d2.z + d2.w));\n            //col = vec3(abs(d2.z + d2.w));\n        }\n    }\n    else\n    {\n        if(uv0.y < iResolution.y*0.75)\n        {\n        \tfloat r = (1.0-Pow2(1.0-h.w));\n        \tcol = vec3(ct*h.w*h.w + 0.25*ct*r*(1.0/(1.0 + r*20.0 * (1.0-clamp01(dot(H, N))))));\n\n        \tcol = GammaEncode(clamp01(col));\n        }\n        else\n        {\n         \tcol = clamp01(N * 0.5 + 0.5);\n        }\n    }\n    \n    \n    fragColor = vec4(col, 0.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define FILTERING_MODE 0\n/*\n\t0: interpolating cubic kernel (produces C2 continuous signal without altering the sample values)\n\t1: generalized cubic BSpline (produces C2 continuous signal with smaller kernel but alters the sample values)\n\t2: quadratic BSpline (produces C1 continuous signal)\n\t3: central difference (reconstructed signal will not be C2 continuous; overall bad quality)\n*/\n\n#define FETCH(uv) (texelFetch(iChannel3, uv + ivec2(40, 64), 0).b)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n    \n#if FILTERING_MODE == 0\n    // ======================================================= INTERPOLATING CUBIC KERNEL =======================================================\n    \n    // truncated kernel radii for 1st and 2nd derivatives respectively\n    int r1 = 5;\n    int r2 = 2;\n    // setting r2 to 0 results in suprisingly little shading artifacts (which might mean that in 3d we can throw out all higher order derivatives..)\n    \n    \n    col.w = FETCH(uv);\n    \n   #if 1\n    // precomputed kernel\n    float kern[12];\n    kern[0] = 0.0         ; kern[1] = -0.803848    ; kern[ 2] = 0.21539       ; kern[ 3] = -0.0577137    ; \n    kern[4] = 0.0154643   ; kern[5] = -0.00414365  ; kern[ 6] = 0.00111029    ; kern[ 7] = -0.000297501  ; \n    kern[8] = 0.0000797152; kern[9] = -0.0000213596; kern[10] = 0.00000572329 ; kern[11] = -0.00000153355;\n   #else\n    // compute kernel at compile time\n    float kern[12];\n    {\n    \tkern[0] = 0.0;\n        \n        float sn = -1.0;\n    \tfor(uint i = 1u; i < 12u; ++i, sn = -sn)\n        \tkern[i] = sn * 3.0 * exp2(-float(i) * log2(2.0 + sqrt(3.0)));\n    }\n   #endif    \n    \n    // d/dx\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, 0));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.x += f * k;\n    }\n    \n    // d/dy\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(0, i));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.y += f * k;\n    }\n    \n    \n    // d^2/dxy\n    for(int j = -r2; j <= r2; ++j)\n    for(int i = -r2; i <= r2; ++i)\n    {\n        if(i == 0 || j == 0) continue;\n        \n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.z += f * (kx * ky);\n    }\n\n#elif FILTERING_MODE == 1\n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[3];\n    float kernD1[3];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 1\n   \n    sw = 0.25;// similar to 1/3 but less ringing\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 0\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n#elif FILTERING_MODE == 2\n    // ======================================================= QUADRATIC BSPLINE =======================================================\n    \n    float kernD0[2];\n    float kernD1[2];\n    \n    kernD0[0] = 0.5; kernD0[1] =  0.25;\n    kernD1[0] = 0.0; kernD1[1] = -0.5 ;\n    \n    int r = 1;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n#else    \n    // ======================================================= CENTRAL DIFFERENCE =======================================================\n    \n    col.w = FETCH(uv);\n    \n    float kern[2];\n    \n    kern[0] =  0.0;\n    kern[1] = -0.5;\n    \n    for(int j = -1; j <= 1; ++j)\n    for(int i = -1; i <= 1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.xyz += f * vec3(kx * (j == 0 ? 1.0 : 0.0), \n                            ky * (i == 0 ? 1.0 : 0.0), \n                            kx * ky);\n    }\n    \n#endif    \n\n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nfloat cubic(float x) {return x*x*(3.-2.*x);}\nvec2  cubic(vec2  x) {return x*x*(3.-2.*x);}\nvec3  cubic(vec3  x) {return x*x*(3.-2.*x);}\nvec4  cubic(vec4  x) {return x*x*(3.-2.*x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}