{
    "Shader": {
        "info": {
            "date": "1564592149",
            "description": "Old test too, I publish it to be more productive on other shaders :)",
            "flags": 32,
            "hasliked": 0,
            "id": "MsccWj",
            "likes": 34,
            "name": "Another sponza atrium",
            "published": 3,
            "tags": [
                "unfinished",
                "sponza"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 912
        },
        "renderpass": [
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bufa = texture(iChannel0, uv);\n    \n    //Lens fresnel\n    vec2 offset = (uv*2.-1.)/iResolution.xy;\n    vec3 col = vec3(0.);\n    col.r = texture(iChannel0, uv+offset).r;\n    col.g = bufa.g;\n    col.b = texture(iChannel0, uv-offset).b;\n    \n    //Vignetting\n    col = clamp(col,0.,1.) * (.5 + .5*pow( uv.x*uv.y*(1.-uv.x)*(1.-uv.y)*50., .5));\n    \n    fragColor = vec4(col*min(iTime*.25,1.), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//More details here http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\n\nconst float PI = 3.14159265359;\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nfloat box( in vec3 p, in vec3 data );\nfloat map( in vec3 p );\n\nmat3 lookat( in vec3 fw, in vec3 up );\nmat3 rotate( in vec3 v, in float angle);\n\nfloat hash(float p);\nvec3 randomSphereDir(vec2 rnd);\nvec3 randomHemisphereDir(vec3 dir, float i);\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff );\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n);\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k );\nfloat getGrey(vec3 p);\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor);\nvec3 getMaterial( in vec3 p, inout vec3 n);\n\n\n \n//Sponza in sdf  \nfloat arch( vec3 p ) { \n    if(p.y<40.1)\n        p.y += 3.3;\n    //arch\n    vec3 a = vec3( fract(p.x/45.5-.5)-.5, -p.y+40., fract(p.z/32.9-.5)-.5 );\n    \n    float d = -sqrt( a.y*a.y + min(a.x*a.x,a.z*a.z)*2000.)+19.5;\n    if (abs(p.x)<28.)\n       d -= 1.;\n    d = max(d, a.y);\n    d = max(d, -a.y-24.);\n    return d*.8;\n}\nfloat column1( vec3 p ) {\n    \n    // column\n    vec3 pp = p;\n    pp.z = mod(p.z, 32.9)-32.9/2.;\n    pp.x = mod(p.x-44., 44.0)-44.0/2.;\n    \n    float d = length(pp.xz) - 4.;\n    d = min(d, box(pp-vec3(0.,40.,0.), vec3(6.,2.,6.)));\n    \n    d = max(d, abs(p.x)-50.);\n    d = max(d, p.y-40.);\n    \n    d = min(d, arch(p));\n    return d;\n}\nfloat column2( vec3 p ) {\n    \n    float yy = pow(p.y-13., .5)*1.2;\n    // column\n    vec3 pp = p;\n    pp.z = mod(p.z-32.9/2., 65.8)-65.8/2.;\n    pp.x = mod(p.x-44., 44.0)-44.0/2.;\n    \n    float d = length(pp.xz) - 3. + sin(p.y*p.y*.004+3.8)*.3;\n    \n    pp.z = mod(p.z+32.9/2., 65.8)-65.8/2.;\n    d = min(d, max(abs(pp.x), abs(pp.z)) - 3.);\n    \n    pp.z = mod(p.z, 32.9)-32.9/2.;\n    float y = pow(p.y-40., .5)*1.;\n    d = min(d, box(pp-vec3(0.,40.,0.), vec3(6.,3.,6.))*.8);\n    d = min(d, box(pp-vec3(0.,12.,0.), vec3(4.5,3.,4.5))*.8);\n\n    \n    \n    d = max(d, abs(p.x)-50.);\n    d = max(d, p.y-40.);\n    \n    d = min(d, arch(p));\n    return d;\n}\n\nfloat stings( in vec3 p ) {\n    vec3 pp = p;\n    pp.z = mod(p.z, 32.9)-32.9/2.;\n    vec3 ppp = pp;\n    pp = rotate(vec3(0.,0.,1.), .4*-sign(p.x)) * pp; \n    \n    float d = length(pp.zy-vec2(0.,120.))-1.4;\n    d = max(d, -abs(ppp.x)+16.5);\n    d = min(d, length(pp.zy-vec2(0.,120.))-.3);\n    d = max(d, abs(p.x)-30.);\n    d = max(d, -abs(p.x)+3.);\n    d = max(d, abs(p.z)-60.);\n    \n    return d;\n}\nfloat map( in vec3 p )\n{\n    //base\n    const vec3 dim = vec3(66.2, 77.75, 142.0);\n    const vec3 dim2 = vec3(dim.x-49., 80., dim.z-32.);\n\tfloat d = -box(p-vec3(0.,dim.y, 0.), dim );\n    d = min(d, column1(p));\n    d = min(d, column2(p-vec3(0.,60.,0.)));\n    \n    d = min(d, box(p-vec3(0., 67., 0.),vec3(dim2.x+10.,5.,dim2.z+10.)));\n    d = min(d, box(p-vec3(0., 72., 0.),vec3(dim2.x+10.4,.5,dim2.z+10.4)));\n    \n    \n    \n    d = min(d, -p.y+120.);\n    d = max(d, -box(p-vec3(0.,186.,0.), dim2+vec3(-1.,100.,0.)));\n    \n\td = max(d, p.y-dim2.y-100.);\n    \n    // windows on the top\n    vec3 pp = p;\n    pp.z = mod(p.z-32.9/2., 65.8)-65.8/2.;\n    d = max(d, -box(pp-vec3(0.,140.,0.), vec3(dim.x,5.,5.) ) );\n    pp.z = mod(p.z+32.9/2., 65.8)-65.8/2.;\n    d = max(d, -length(pp.zy-vec2(0.,160.))+4. );\n    \n    d = min(d, stings(p));\n    \n\treturn d;\n}\n\n\n//Shading\nvec3 getMaterial( in vec3 p, inout vec3 n) {\n    vec3 albedo;\n    \n    if (arch(p) == map(p) && abs(p.x) > 28. && p.y < 64.) {\n        if (p.y < 40.1) {\n        \talbedo = vec3( getGrey(tex3D(iChannel1, p*.05,n).xyz*.5) );\n        \tn = doBumpMap(iChannel1, p*.05, n, .02);\n        }\n        else {\n        \talbedo = vec3(1.,.8,.6) * getGrey(tex3D(iChannel0, p*.05,n).xyz);\n        \tn = doBumpMap(iChannel0, p*.05, n, .02);\n        }\n    } else if (arch(p-vec3(0., 60., 0.)) == map(p-vec3(0., 60., 0.)) && abs(p.x) > 28.) {\n        if (p.y < 100.1) {\n        \talbedo = vec3( getGrey(tex3D(iChannel1, p*.05,n).xyz*.5) );\n        \tn = doBumpMap(iChannel1, p*.05, n, .02);\n    \t}\n    \telse {\n        \talbedo = vec3(1.,.8,.6) * getGrey(tex3D(iChannel0, p*.05,n).xyz);\n        \tn = doBumpMap(iChannel0, p*.05, n, .02);\n        }\n    } else if (stings(p) == map(p)){\n        \talbedo = vec3( getGrey(tex3D(iChannel0, p*.05,n).xyz*.5) );\n        \tn = doBumpMap(iChannel0, p*.05, n, .02);\n    } else {\n        albedo = tex3D(iChannel1, p*.07, n).xyz;\n        n = doBumpMap(iChannel1, p*.07, n, .02);\n    }\n    return albedo;\n}\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd )\n{\t\t\n    // sky \n    vec3 fog = vec3(.7,.9,1.);\n    float d = length(p-ro);\n    if (d > 350. )\n        return fog;\n        \n        \n    vec3 ld = normalize( vec3(.2, 1., -.35) );\n\t\n    // search the good material\n    vec3 albedo = getMaterial(p,n);\n\n    \n    float ao = ambientOcclusion(p,n, 1., 1.5) * ambientOcclusion(p,n, 40., 2.5);\n    float shad = softshadow(p,ld, .1, 200., 30.);\n    \n    \n    \n    \n    vec3 diff = vec3(1.,.5,.3) * max(dot(n,ld), 0.) * shad;\n    vec3 bounce = vec3(1.,.85,.6) * max(dot(n,vec3(0.,-1.,0.)), 0.) * ao;\n    vec3 amb = vec3(.19,.2,.31) * ao;\n    \n    vec3 col = albedo * (amb + diff*2. + bounce*.1);\n\n    \n    col = mix(col, fog, min( 1., pow(d*.00025,2.)) );\n    \n    return col;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tfloat t = (iTime)*.3;\n\tvec3 ro = vec3( cos(t)*50.,80., -102. );\n\tvec3 rd = normalize( vec3(v.x, v.y, 2.) );\n\t//rd = lookat( -ro , vec3(0., 1., 0.) ) * rd;\n\t\n\t//classic raymarching by distance field\n\tvec3 p = raymarch(ro, rd, vec2(.1, 400.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, ro, rd);\n\t\n\t//Gamma correction\n    col = pow(col, vec3(1./2.2));\n\n        \n\tfragColor = vec4( col, max(0., 2.-length(p-ro)/30.) );\n}\n\n\n\n\n\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 nfplane )\n{\n\tvec3 p = ro+rd*nfplane.x;\n\tfloat t = 0.;\n\tfor(int i=0; i<128; i++)\n\t{\n        float d = map(p);\n        t += d;\n        p += rd*d;\n\t\tif( d < 0.001 || t > nfplane.y )\n            break;\n            \n\t}\n\t\n\treturn p;\n}\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\nfloat box( in vec3 p, in vec3 data )\n{\n    return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z);\n}\n\n\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n//Random number [0:1] without sine\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n) {\n    n = abs(n);\n    return texture(tex, p.yz).rgb * n.x +\n           texture(tex, p.xz).rgb * n.y +\n           texture(tex, p.xy).rgb * n.z;\n}\n\n// iq magic\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n// Shane magic\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor) {\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}