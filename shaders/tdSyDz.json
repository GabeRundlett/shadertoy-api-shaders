{
    "Shader": {
        "info": {
            "date": "1586422129",
            "description": "The dual of [url]https://www.shadertoy.com/view/Ws2cRh[/url] - generate conics from intersections of corresponding lines of two pencils.\n\nMouse changes correspondence and so changes the conic.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdSyDz",
            "likes": 6,
            "name": "Conics from Projective Pencils",
            "published": 3,
            "tags": [
                "pencil",
                "conic",
                "projective",
                "loopless"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 515
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Conics as Intersections of Pencils of Lines\n// Matthew Arcus, mla, 2020\n//\n// Companion piece to https://www.shadertoy.com/view/Ws2cRh: here we\n// have a correspondence between to two pencils of lines (a pencil of\n// lines is just the set of all lines through a given point), where\n// the points of intersection of corresponding lines outline the\n// conic (corresponding lines have the same colour).\n//\n// Mouse changes the parameters of the correspondence, generating\n// different conics.\n//\n// A projective mapping of parameter t, 0 <= t < PI to the lines\n// in a pencil (as the angle with some axis) is:\n//\n// g(t) = atan(A*tan(t+B)+C)\n//\n// and since tan(t+B) =  we see that:\n//\n// g(t) = atan(A*(tan(t)+tan(B))/(1-tan(t)*tan(B))+C)\n//      = atan(f(tan(t))) where f(x) = A*(x+tan(B))/(1-x*tan(B)) + C\n// \n// (so f(x) is a 1d real Mobius tranformation: f(x) = (ax+b)/(cx+d),\n// but we have parametrized it with (A,B,C) rather than (a,b,c,d) -\n// think of stereographic projection from a circle to a line).\n//\n// Given two pencils, we can establish a correspondence with two\n// mappings g1, g2 as above, and then line g1(t) in pencil 1\n// corresponds with line g2(t) in pencil 2. Here, g1(t) is the\n// identity map, with A=1,B=C=0, and g2(t) has A = 1 and derives B and\n// C from mouse position. Only N regularly spaced lines from [0..PI]\n// are displayed.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\nfloat point(vec3 p, vec3 q) {\n  if (abs(p.z) <= 1e-4) return 1e8;\n  p /= p.z; q /= q.z; // Normalize\n  return distance(p.xy,q.xy);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat N = 50.0;\n\n// Find parameter t of the nearest displayed line from the pencil.\n// t is actually in range [0,1)\nfloat nearestline(vec2 p, vec2 centre, vec3 mobius, out float index) {\n  float A = mobius.x, B = mobius.y, C = mobius.z;\n  p -= centre;\n  float t = p.y/p.x;\n  // Look out for infinities here\n  if (p.x == 0.0) sign(p.y)*1e4;\n  //t = atan(A*tan(t+B)+C);\n  t = A*(t+B)/(1.0-t*B)+C;\n  t = atan(t);\n  // Add time offset and round to nearest line\n  t = t/PI+0.05*iTime;\n  t *= N;\n  t = mod(round(t),N);\n  index = t;\n  t /= N;\n  return t;\n}\n\n// Make line coordinates for the line with parameter t in the given pencil.\nvec3 makelinecoords(float t, vec2 centre, vec3 mobius) {\n  float A = mobius.x, B = mobius.y, C = mobius.z;\n  t -= 0.05*iTime;\n  t = (tan(t*PI)-C)/A;\n  // Infinities!\n  if (abs(t) > 1e4) t = sign(t)*1e4;\n  t = (t-B)/(1.0+t*B);\n  return join(vec3(centre,1),vec3(centre+vec2(1,t),1));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float scale = 3.0;\n  float A = 1.0, B = 1.4, C = -0.5;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    B = tan(0.5*PI*m.y); // B represents angular offset\n    C = m.x; // C is linear offset\n  }\n  p *= scale;\n  vec2 centre1 = vec2(1,0);\n  vec2 centre2 = vec2(-1,0);\n  vec3 mobius1 = vec3(1,0,0);\n  vec3 mobius2 = vec3(A,B,C);\n  float index1,index2;\n  float t1 = nearestline(p,centre1,mobius1,index1);\n  vec3 l1 = makelinecoords(t1,centre1,mobius1);\n  vec3 l12 = makelinecoords(t1,centre2,mobius2);\n  vec3 p1 = join(l1,l12);\n\n  float t2 = nearestline(p,centre2,mobius2,index2);\n  vec3 l2 = makelinecoords(t2,centre2,mobius2);\n  vec3 l21 = makelinecoords(t2,centre1,mobius1);\n  vec3 p2 = join(l2,l21);\n  \n  float lwidth0 = 0.0;\n  float pwidth0 = 0.02;\n  float lwidth1 = 0.015;\n  lwidth1 = max(lwidth1,1.5*fwidth(p.x));\n  float pwidth1 = max(0.05,fwidth(p.x));\n  pwidth1 = max(pwidth1,fwidth(p.x));\n  vec3 col = vec3(0);\n  vec3 pcolor = vec3(0.8);\n  float d;\n  d = line(vec3(p,1),l2);\n  col = mix(hsv2rgb(vec3(index2/N,1,1)),col,smoothstep(lwidth0,lwidth1,d));\n  d = line(vec3(p,1),l1);\n  col = mix(hsv2rgb(vec3(index1/N,1,1)),col,smoothstep(lwidth0,lwidth1,d));\n  d = point(vec3(p,1),p1);\n  col = mix(pcolor,col,smoothstep(pwidth0,pwidth1,d));\n  d = point(vec3(p,1),p2);\n  col = mix(pcolor,col,smoothstep(pwidth0,pwidth1,d));\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}