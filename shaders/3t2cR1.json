{
    "Shader": {
        "info": {
            "date": "1593723953",
            "description": "a messier version of https://www.shadertoy.com/view/wtfyzf",
            "flags": 0,
            "hasliked": 0,
            "id": "3t2cR1",
            "likes": 13,
            "name": "attempted vegetation",
            "published": 3,
            "tags": [
                "terrain",
                "fbm"
            ],
            "usePreview": 0,
            "username": "yonatan",
            "viewed": 578
        },
        "renderpass": [
            {
                "code": "// feel free to reuse\n\nmat2 rot2d(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));} // Angle => 2D rotation matrix\n\nfloat terrain_height(vec2 position) { // https://iquilezles.org/articles/fbm\n  float height=0., amplitude, n, am;\n  vec2 pp = position*.1;\n  float z = length(sin(pp)*cos(pp));\n  am = z*z*z*z*z*.6+.6;\n  amplitude=1.4*z*z;\n  for(int i = 0; i < 20; i++) { // Sum up 20 layers\n    n = sin(position.x) * cos(position.y); n = n * n * n; // Simple base pattern, no noise\n    if(i>9) n*=clamp(1., 1./(height*height*9.), 4.0); // This does the \"trees\"\n    height += n * amplitude; // Accumulate value at current amplitude\n    position *= rot2d(float(i*i)); // Rotate (phase-shift?) by a hash of the current iteration\n    position *= 1.41;\n    amplitude = am * amplitude;\n  }\n  return abs(height) - .02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime * .2 + iMouse.x / iResolution.x * 28.;\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x,iResolution.y);\n  vec3 p, water_tint = vec3(1), ray_origin = vec3(-cos(time*.5)*7.,1.,time+4.), // Camera position\n    ray_direction = normalize(vec3(uv.x, uv.y - .7 + cos(time) * .5, 1.9));\n  ray_direction.xy *= rot2d(sin(time*.5)*.5); // Camera orientation and field of view\n  float distance = 0., ray_length = 0.;\n  for(int i = 0; i < 75; i++) { // Raymarching loop\n    p = ray_origin + ray_direction * ray_length; // Get current ray position\n    if(distance<.1 && p.y<0.) { // If we're close to the surface check p.y for a water hit\n      ray_origin.y = -ray_origin.y; ray_direction.y = -ray_direction.y; // Reflect ray\n      water_tint = vec3(.7,.8,.9)/(ray_direction.y);\n    } else { // Not underwater - march\n      distance = p.y-terrain_height(p.xz); // Real distance is hard to calculate so use p's\n      // height above the terrain, and since that's obviously\n      ray_length += distance * .6; // wrong - only march .6 of the way and hope for the best.\n    }\n    if(ray_length > 20.) break; // We are far away (in the sky)\n  }\n  vec2 h = vec2(.0001, 0); // From https://iquilezles.org/articles/normalsSDF\n  vec3 surface_normal = normalize(vec3(terrain_height(p.xz-h.xy) - terrain_height(p.xz+h.xy),\n                                       2.*h.x, terrain_height(p.xz-h.yx) - terrain_height(p.xz+h.yx)));\n  vec3 terrain_color = mix(vec3(.4,.6,.1),vec3(.7,.65,.15),abs(p.y)*8.)*.5\n    * (surface_normal.z * .5 + .5); // Terrain, backlit\n  vec3 sky_color = mix(vec3(1.1,1.,.8),vec3(.6,.7,.8),abs(ray_direction.y)); // Sunny horizon\n  vec3 color = mix(terrain_color, sky_color, min(1.,ray_length/20.)); // Mountains-sky fade\n  color *= water_tint; // Water color\n  fragColor = vec4(pow(color, vec3(.4545)), 1); // Gamma correction\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}