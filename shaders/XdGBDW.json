{
    "Shader": {
        "info": {
            "date": "1529074829",
            "description": "Raymarching an extruded jigsaw pattern.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdGBDW",
            "likes": 80,
            "name": "Jigsaw",
            "published": 3,
            "tags": [
                "raymarching",
                "pattern",
                "jigsaw",
                "extrusion"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2235
        },
        "renderpass": [
            {
                "code": "/*\n\n\tJigsaw\n\t------\n \n\tI saw a few jigsaw images on the net and thought to myself that I'd set aside a few minutes\n\tto code one up. I wasn't aware of it until a few hours later, but it turns out that jigsaw\n\tpatterns aren't as straight forward as you'd think... or I'm not particulary good at coding \n\tjigsaw patterns. Either way, an embarrassing amount of time later, and here it is. :D\n\n\tCreating a 2D square jigsaw pattern requires a bit of finesse. Putting a wavy pattern together\n    is more frustrating, but it can be done -- Constructing dissimilar interlocked asymmetrical \n    objects requires some thought. However, I started to realize that I might be in for more work \n    than I anticipated when I attempted to raymarch the pattern at a decent frame rate. :)\n\n\tI really try not to complicate things, but sometimes, it can't be avoided. Anyone familiar\n\twith rendering objects of varying heights across a repeat grid will know that rendering them \n    adjacent to one another isn't generally possible due to cell overlap artifacts. The only way \n\taround it is to render every second grid cell across two dimensions (ensuring no object overlap), \n\tthen render three other grid combinations to fill in the spaces -- The return value being the \n\tminimum distance of the four individual grid objects. Essentially, this means everything needs \n\tto be rendered four times over, so even a mildy complicated object -- like a jigsaw piece -- \n\twon't be feasible in real time... unless you can find a way to store calculations in a buffer.\n\n\tSo, that's what I've done here. Luckily, the jigsaw pieces are extruded, so the 2D distance \n\tfield calculations can be precalculated and stored in a 2D texture, then read back. Even better, \n\tall four calculations can be stored in each of the texture channels, which means just one call \n\tin the distance field function. After that, there's still some extruded object construction\n    and minimums to determine, but it involves significantly less calculation. In fact, my laptop\n\tcan run this in fullscreen quite easily.\n\t\n\tI decided to jitter the shadows, ever so slightly. It definitely improves banding issues on \n\tlong shadow casts, but adds a slight amount of unecessary jitter to shadows that are in close\n\tproximity to the object. Overall, however, I felt it improved things significantly.\n\n\tIn regard to the lighting and coloring, the scene is supposed to have a cardboard kind of \n\tconsistency... Not sure if it does entirely, but it turned out roughly the way I wanted.\n\n\n    Interlocking Asymmetrical Examples:\n\n\t// Awesome example: This involves repetition of a single object and is achieved in realtime \n\t// by reading the precalculated contour points from an array. Ultra also has a smooth\n\t// version of this.\n\tShaded Horses - Ultraviolet\n\thttps://www.shadertoy.com/view/lsXfDf\n\n\t// As above, it involves a single object, but is calculated on the fly.\n\tescherized tiling 2 (WIP) - FabriceNeyret2\n\thttps://www.shadertoy.com/view/lsdBR7\n\n*/\n\n\n#define FAR 10.\n\n// Gives a sheeny appearance. Intereting, but I prefer the flat look.\n//#define FAKE_ENVIROMENT_REFLECTIONS\n\n// Debug color overide. If you look in the \"Common\" tab, there's also a \"FLAT_PATTERN\" \n// define that will level the height out, effectively putting the pieces on a flat plane.\n//#define GREY\n\n// There's a slight perspective tilt on the camera, but this has a bit more -- to keep Dr2\n// happy and give it less of a scrolling texture look. :)\n//#define CAMERA_TWO\n\n\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001); //max(abs(n) - .2, 0.001); // etc.\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n*/\n\n \n// Global 2D surface value. It's poor programming practice putting it here. I'll \n// tidy this up later.\n//float surf2D;\n\n\n// Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n    \n    // Sampling the 2D jigsaw pattern value from the texture, then passing it\n    // into a relatively cheap 3D extrusion function to give the final distance\n    // value.\n    vec4 jigDist = texture(iChannel0, p.xy/4. + .5);\n    vec2 jig = jigsaw(p - vec3(moveXY(iTime), 0), jigDist);\n    \n    //surf2D = jig.y; // Just the 2D value. Used for some cheap edging.\n \n    return jig.x*.866; // 3D extruded distance field value.\n    \n    \n}\n\n\n// Standard raymarching function.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    \n    for(int i = 0; i<80; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += d;\n    }\n\n    return min(t, FAR);\n    \n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001;  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    dist += hash31(ro + rd)*.007;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist); //  map(ro + rd*dist + hash31(ro + rd)*dist*.03);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n// An AO routine, tweaked to suit this particular example, and based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 5., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.; \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Standard 2x2 hash algorithm.\nvec2 hash22G(vec2 p, float repScale) {\n\n    p = mod(p, repScale);\n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n\n}\n\n// Gradient noise: Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f, float repScale){\n  \n   f *= repScale;\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22G(p + e.xx, repScale), f - e.xx), dot(hash22G(p + e.yx, repScale), f - e.yx), w.x),\n                  mix(dot(hash22G(p + e.xy, repScale), f - e.xy), dot(hash22G(p + e.yy, repScale), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p, float repScale){\n    \n    return gradN2D(p, repScale)*.57 + gradN2D(p, repScale*2.)*.28 + gradN2D(p, repScale*4.)*.15;\n    \n}\n\n*/\n\n\n// With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n//\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine.\n// Creative Commons Attribution-ShareAlike 4.0 International Public License.\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n /*   \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n*/\n}\n\n\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash33G(vec3 p){ \n   \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = rot2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    float n = sin(dot(p, vec3(27, 57, 111)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n); \n    //return sin(p*6.2831853 + iTime); \n}\n*/\n\n\n// Gradient noise, or Perlin noise. Break space into cubes, attach random 3D vectors to each of the eight \n// verticies, then smoothly interpolate between them. It's that simple. With the exception of some simple\n// changes and some commentary addition, this is basically IQ's implementation.\n// \nfloat gradN3D(in vec3 p){\n   \n    // Utilility bector.\n    const vec2 e = vec2(0, 1);\n    \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec3 ip = floor(p); \n    \n    p -= ip; // Fractional position within the cube.\n\n    // Smoothing - for smooth interpolation. Comment it out to see the\n    //vec3 w = p*p*p*(p*(p*6. - 15.) + 10.); // Quintic smoothing. Slower, but derivaties are smooth too.\n    vec3 w = p*p*(3. - 2.*p); // Cubic smoothing. \n    //vec3 w = p*p*p; w = (7. + (w - 7.) * p) * w;\t// Super smooth, but less practical.\n    //vec3 w = .5 - .5*cos(p*3.14159); // Cosinusoidal smoothing.\n    //vec3 w = p; // No smoothing. Gives a blocky appearance. Can look cool under the right conditions.\n    \n    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space.\n    float c = mix(mix(mix(dot(hash33G(ip + e.xxx), p - e.xxx), dot(hash33G(ip + e.yxx), p - e.yxx), w.x),\n                      mix(dot(hash33G(ip + e.xyx), p - e.xyx), dot(hash33G(ip + e.yyx), p - e.yyx), w.x), w.y),\n                  mix(mix(dot(hash33G(ip + e.xxy), p - e.xxy), dot(hash33G(ip + e.yxy), p - e.yxy), w.x),\n                      mix(dot(hash33G(ip + e.xyy), p - e.xyy), dot(hash33G(ip + e.yyy), p - e.yyy), w.x), w.y), w.z);\n    \n    // Taking the final result, and putting it into the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n\n}\n\n// Gradient noise fBm.\nfloat fBm3D(in vec3 p){\n    \n    return gradN3D(p)*.57 + gradN3D(p*2.)*.28 + gradN3D(p*4.)*.15;\n}\n\n#ifdef FAKE_ENVIROMENT_REFLECTIONS\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = fBm3D(rd);\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25 + .25); \n    \n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, min(iResolution.y, 800.)*.5));\n    // Slight lens warping.\n    rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z - dot(rd.xy, rd.xy)*.03)));\n    \n    //vec3 ro = vec3(0. + iTime/4., 0. + iTime/8., -1.5);\n    // The camera movement is provided via texture scrolling. We're doing it\n    // this way, because it'd be very difficult to wrap this particular \n    // pattern. Not impossible, but compilicated. Therefore, texture area\n    // has to span beyond the canvas borders for the effect to work.\n    vec3 ro = vec3(0, 0, -1.);\n    // Light -- set up somewhere near the camera.\n    vec3 lp = ro + vec3(-.25, .75, 0);\n    \n    \n    // Tilting the camera ever so slightly.\n    #ifdef CAMERA_TWO\n    rd.yz *= rot2(-.2);\n    rd.xy *= rot2(.1);\n    #else\n    rd.yz *= rot2(-.03);\n    rd.xy *= rot2(.03);\n    #endif\n    \n    \n    // Standard raymarching segment. Because of the straight forward setup, very few \n    // iterations are needed.\n    float t = trace(ro, rd);\n    \n    // Saving the unique cell ID and the 2D surface value.\n    vec2 svCellID = cellID;\n    //float svSurf2D = surf2D;\n    \n    // Initiate the scene color.\n    vec3 col = vec3(0);\n    \n    // Trivial surface hit. I think all rays would hit this particular surface.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t;\n        vec3 sn = normal(sp);\n        vec3 l = lp - sp;\n        float lDist = length(l);\n        l /= max(lDist, .0001);\n\n        //lDist /= 3.;\n        float atten = 1./(1. + lDist*.05);\n\n        // Ambient occlusion and shadows.\n        float ao = calcAO(sp, sn);\n        float sh = softShadow(sp + sn*.002, lp, 4., t); // Set to \"1.,\" if you can do without them.\n        sh = min(sh + ao*.2, 1.);\n\n\n        float dif = max(dot(l, sn), 0.); // Diffuse term.\n        dif *= dif; // Ramping up the diffuse.\n        float spe = pow(max( dot( reflect(-l, sn), -rd ), 0.0 ), 32.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        // Schlick appoximation. It tones down the specular term.\n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + l)), 0.), 5.0);\n        float fre2 = mix(.1, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n\n        // Texture value. Note that it's moving along XY to match the scrolling \"Buf A\" texture.\n        vec3 tSp = sp;\n        tSp.xy -= moveXY(iTime);\n        \n        // Shadertoy texture, but I went textureless for this one.\n        //vec3 objCol = mix(tex3D(iChannel1, sp/1., sn), tex3D(iChannel1, sp*2., sn), .34);\n        //vec3 objCol = tex3D(iChannel1, tSp/2., sn);//*texture(iChannel0, fract(sp.xy)).xyz;\n        //objCol = smoothstep(-.3, .3, objCol);\n\n        // COLORING THE JIGSAW PIECES.\n        //\n        vec3 objCol = vec3(1);\n        // Some random colors based on the unique jigsaw piece ID. Used for coloring.\n        vec3 rnd = vec3(hash(svCellID + 72.5), hash(svCellID + 37.1), hash(svCellID + 93.7));\n        //vec3 rnd = hash33G(svCellID.xyx + vec3(72, 37, 93))*.5 + .5;\n  \n        // Random base colors. Orange tones, I think.\n        vec3 cellCol = vec3(rnd.x*.2 + .8, rnd.z*.5 + .5, rnd.z*.3 + .3);\n        \n        // Mixing in some fire tones... I'll usually try this out if things aren't working. :)\n        float c = dot(cellCol, vec3(.299, .587, .114));\n        cellCol = cellCol*.5  + pow(min(vec3(1.5, 1, 1)*c, 1.), vec3(1, 3, 16));\n        \n        // Too much orange, so make some of them green for an autumn feel.\n        if(rnd.y<=.5) cellCol = min(cellCol*2., 1.).yxz;\n\n        // Color a portion of the pieces with the autumn palette, but leave some gray. It seemed\n        // like a fun thing to do at the time. :)\n        if(fract(rnd.x*289.97 + .73)>.15) objCol *= cellCol;\n        \n        objCol = mix(objCol, objCol.xzy, .15); // Tone the color down. \n        \n        #ifdef GREY\n        objCol = vec3(.9, 1.05, 1.2);\n        #endif\n        \n        // Blue\n        //objCol = objCol.zyx;\n        // Pink.\n        //objCol = objCol.xzy;\n        // Grey tones.\n        //objCol = vec3(1)*dot(cellCol, vec3(.299, .587, .114));\n \n\n        // Matches the pylon routine in the \"jigsaw\" construction routine called\n        // in the raymarching function.\n        //\n        float cellHeight = getCellHeight(svCellID); // Cell (jigsaw piece) height.\n        \n        // Put edges near the top of the block.\n        objCol *= smoothstep(0., .003, abs(sp.z - cellHeight + .5 - .006) - .00075)*.8 + .2; // Dark edges.\n     \n        // Put a 2D pattern on the top of the block above the dark edge.\n        if((abs(sp.z - cellHeight) - .5 + .006)>0.){\n             //objCol *= smoothstep(0., .0075, max(-svSurf2D, 0.) - .01)*.8 + .2; // Dark edges.\n             //objCol *= (1. - smoothstep(0., .01, -svH2 - .01))*.35 + 1.; // Light edges.\n            \n            // Wavy gradient contour pattern. You could put anything you want here, or nothing\n            // at all if you're super boring. :)\n            objCol *= clamp(-sin(fBm3D(vec3(tSp.xy, 0))*6.2831*96.)*5. + 2.9, 0., 1.)*.2 + .8;\n            \n        }\n        \n        // I originally put the pattern down the sides, but went with the 2D pattern above.\n        //objCol *= clamp(-sin(fBm3D(tSp)*6.2831*96.)*4. + 2.9, 0., 1.)*.2 + .8;\n        \n        // Some gradient fBm sprinkles to break things up and give a slight papery feel.\n        objCol *= fBm3D(tSp*80.)*.4 + .8;\n\n\n        // Very basic lighting. Diffuse, ambient and specular.\n        col = objCol*(dif + .25 + vec3(1, .7, .4)*spe*fre2);\n\n\t\t#ifdef FAKE_ENVIROMENT_REFLECTIONS\n        // Add the fake environmapping. Not as good as a reflective pass, but it gives that\n        // impresssion for just a fraction of the cost.\n        vec3 em = eMap(reflect(rd, sn), sn); // Fake environment mapping.\n        col += col*em*2.;\n        #endif\n\n        // Apply the light attenuation, ambient occlusion and shadows.\n        col *= atten*ao*sh;\n         \n    }\n    \n    // Subtle vignette.\n    vec2 uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\n    // Colored variation.\n    //col = mix(col.zyx/2., col, \n              //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Used for debug purposes, but it does give you a better look at the \n// pattern outline.\n//#define FLAT_PATTERN\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Translational movement.\nvec2 moveXY(float t){\n    return vec2(1./4., -1./12.)*t;\n}\n\n/*\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp(.5 + .5*(b-a)/s, 0., 1.);\n    return mix(b, a, h) - h*(1. - h)*s;\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// vec2 to float hash.\nfloat hash(vec2 p){\n    return fract(sin(dot(p, vec2(41.71, 112.97)))*43758.5453);\n}\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n// Unique jigsaw piece cell ID.\nvec2 cellID;\n\n/*\n// Random stepped height field.\nfloat getCellHeight(vec2 id){\n    \n    float cellHeight = hash(id);\n    cellHeight = floor(cellHeight*7.999)/7.;\n    return cellHeight*.075;\n    \n}\n*/\n\n// Sinusoidal stepped height field.\nfloat getCellHeight(vec2 p){\n    \n    #ifdef FLAT_PATTERN\n    // Handy for debug purposes.\n    return .0375;\n    #else\n    // Any kind of cheap flowing height field will do. \n    float cellHeight = (dot(sin(p*2.2 - cos(p.yx*1.4)), vec2(.25)) + .5);\n    cellHeight = floor(cellHeight*7.999)/7.;\n    return cellHeight*.075;\n    #endif\n}\n\n\n// It can be annoying trying to follow someone's esoteric code logic, but trust me, the\n// idea behind it is pretty simple... even if it took me way too long to realize how simple\n// it was. :) Anyway, construct a four sided shape with curved sides (using circles), identify \n// all four neighbors, then add a little circle to the edge of one, and take away a circle \n// from its neighbor.\n//\n// By the way, the nice straight square version is \"much\" simpler, but doesn't quite have that \n// jigsaw feel. I wish it did, because I could have saved a lot of small headaches. :)\n//\nfloat jigsawPiece(vec2 p, vec2 ip){\n    \n    // Random ID threshold.\n    const float rnd = .5;\n    \n    // The four border IDs: As an example, take the northern, or upper, border.\n    // The currect cell ID is \"ip.\" The upper cell wil have ID \"ip + vec2(0, 1).\"\n    // The unique \"border\" ID will be the average of the two, which will be\n    // \"(ip + ip + vec2(0, 1))/2.\" which is \"ip + vec2(0, .5).\" This means the \n    // current cell's upper border ID will always match the lower border ID of the\n    // cell above.\n    //\n    // The idea is to use the unique cell border ID to generate the random number.\n    // If it is above a certain threshold add, or take, a circle, then -- and this\n    // is the bit that confused me -- do the opposite with the opposite border. In\n    // pseudo code:\n    //\n    // if (hash(IDNorth)>thresshold) addCircle();\n    // if (hash(IDSouth)<=thresshold) takeCircle();\n    //\n    // It still confuses me if I think about it too much, but it works. In fact, you\n    // could use this process to fit any random shapes together.\n    \n    \n    // Four random border IDs.\n    vec4 idJoinNSEW = vec4(hash(ip + vec2(0, .5)), hash(ip + vec2(0, -.5)), \n                           hash(ip + vec2(.5, 0)), hash(ip + vec2(-.5, 0)));\n    \n    \n    const float ew = .015; // Jigsaw edge width.\n    const float cw = .14; // Jigsaw connector circle width.\n    // Jigsaw circle offset perpendicularly from the border. If you change this,\n    // find the \"sR\" varialbe below, and make adjustments there too.\n    vec4 sR = vec4(.07); \n\n   \n    // Unfortunately, the \"sign\" function returns -1, 1 and 0, but we don't want \n    // zero. :) Hence, the line below. Although, there's probably a more efficient \n    // WebGL specific way to do it.\n    //\n    //vec4 sNSEW = sign(vec4(idJoinN, idJoinS, idJoinE, idJoinW) - rnd);\n    vec4 sNSEW = vec4(idJoinNSEW.x>rnd? 1.: -1., idJoinNSEW.y>rnd? 1.: -1., \n                      idJoinNSEW.z>rnd? 1.: -1., idJoinNSEW.w>rnd? 1.: -1.);\n\n    \n    // Used to check alternating tiles in the checkerboard pattern. Tiles are either\n    // vertically convex and horizontally concave, or vice versa. By the way, I proabably\n    // could have gone with quarter rotation (p = p.yx) logic, but I was allowing for\n    // assymetrical varations at the time.\n    //\n    float checkerPat = (mod(ip.x + ip.y, 2.)<.5)? 1. : -1.;\n    // Used to reorient tiles, depending on the checkerboard setup.\n    vec2 e = checkerPat>0.? vec2(1, 0) : vec2(0, 1); \n    \n    // Main tile slab construction.\n    // The large circle is used to add curvature to the square sides to give even \n    // more of a jigsaw pattern feel.\n    vec2 lROffs = vec2(2); // Large circle offset away from the center.\n\n    // Large circle radius. Equal to the distance from the translated central circle\n    // point to the corner of the border in question. This is a northern border\n    // calculation.\n    //float lRConvex = length(vec2(.5, .5) -  vec2(0, -r2.y));\n    //float lRConcave = length(vec2(.5, .5) -  vec2(0, 1. + r2.y));\n    float lR = length(vec2(.5, .5) -  vec2(0, -lROffs.y));\n    \n    // Move the point perpendicularly away from the border, then construct a large\n    // circle equal in radius from the new central point to the corner of the square\n    // side. In this case, due to symmetry, all circles will have the same radius.\n    //\n    // I left the following lines so you could see the logic behind the construction.\n    // Obviously, I went with shorter \"abs\" version.\n    //float c2N = length(p + lROffs.y*e.yx) - lR + ew/2.;\n    //float c2S = length(p - lROffs.y*e.yx) - lR + ew/2.;\n    //float c2E = length(p + (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    //float c2W = length(p - (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    //float d = max(c2N, c2S);\n    //d = smax(d, -min(c2E, c2W), .05);\n\n    // Equivalent to the lines above, just less work for the GPU.\n    float c2NS = length(abs(p) + lROffs.y*e.yx) - lR + ew/2.;\n    float c2EW = length(abs(p) - (1. + lROffs.x)*e.xy) - lR - ew/2.;\n    float d = smax(c2NS, -c2EW, .05);\n    \n    \n    \n    // Damn logic. If you switch the points based on checker pattern convexity, you have\n    // to rotate the unique border IDs with them. So obvious, but this mistake cost me more time \n    // than I care to admit. Oh, and why I'm at it, I put this line below the unique rotation\n    // block, so those went haywire too. :)\n    idJoinNSEW = checkerPat<0.? idJoinNSEW.zwxy : idJoinNSEW; \n    sNSEW = checkerPat<0.? sNSEW.zwxy : sNSEW; \n    sR = checkerPat>0.? sR.zwxy : sR; \n    \n\n    // I wanted to edge out the connector circles \n    if(idJoinNSEW.x<=rnd) sR.x = .1;\n    if(idJoinNSEW.y>rnd) sR.y = .1;\n    if(idJoinNSEW.z>rnd) sR.z = .1;\n    if(idJoinNSEW.w<=rnd) sR.w = .1;    \n\n    \n    // With straight edges, you can simply translate the jigsaw connecter bits along the X and Y borders.\n    // However, with curved edges, they need to follow the curves subtented from the main cirecles pivotal\n    // point - Don't worry, I groaned about it too. :D \n    \n    // Clamped to stop the circles from overlapping the edges.\n    vec4 rAng = clamp((idJoinNSEW - .5), - .35, .35)*3.14159/20.; \n    mat2 rotN = rot2(rAng.x);\n    mat2 rotS = rot2(rAng.y);\n    mat2 rotE = rot2(rAng.z);\n    mat2 rotW = rot2(rAng.w);\n\n\n    const float sf = .05; // Smoothing factor. The effect is subtle, but rounds the pieces a little.\n    \n    // The connector circles run along the out curved edges of the jigsaw pieces. They're rotionally \n    // offset by a unique amount (based on unique border ID).\n    float cN = length(rotN*(p + lROffs.y*e.yx) - (lR - ew - .0 - sNSEW.x*sR.x)*e.yx) - cw;\n    float cS = length(rotS*(p - lROffs.y*e.yx) + (lR - ew - .0 + sNSEW.y*sR.y)*e.yx) - cw;\n    float cE = length(rotE*(p -  (1. + lROffs.x)*e.xy) + (lR - ew - .0 + sNSEW.z*sR.z)*e.xy) - cw;\n    float cW = length(rotW*(p +  (1. + lROffs.x)*e.xy) - (lR - ew - .0 - sNSEW.w*sR.w)*e.xy) - cw;\n\n    \n    // As explained above, test the unique random border number against a threshold\n    // and either smoothly add or take away the connector circles. Make sure to do the exact\n    // opposite with the border directly opposite.\n    d = (idJoinNSEW.x>rnd)? smax(d, -(cN - ew), sf) : smin(d, cN, sf);\n    d = (idJoinNSEW.y<=rnd)? smax(d, -(cS - ew), sf) : smin(d, cS, sf);\n    d = (idJoinNSEW.z>rnd)? smax(d, -(cE - ew), sf) : smin(d, cE, sf);\n    d = (idJoinNSEW.w<=rnd)? smax(d, -(cW - ew), sf) : smin(d, cW, sf);\n    \n\n    // Return the 2D distance field value.\n    return d;\n    \n}\n\n\n\n// \"jigDist\" contains four 2D jigsaw values, so we find the height for each \n// of the pieces and return the minimum 3D and 2D distance. By the way, I \n// left it in 2x2 loop form for informative purposes. I could easily have\n// unrolled it.\n//\nvec2 jigsaw(vec3 p3, vec4 jigDist){\n    \n    const float jSc = 4.; // I had to tweak the scale to get things right.\n    vec2 p = p3.xy*jSc;    \n    const vec2 sc = vec2(2, 2);\n    \n    // The 3D and 2D distance values.\n    float d = 1e5, d2 = 1e5;\n\n    // The height of each object.\n    float cellHeight = 0.;\n    \n    // Iterating through four repeat grids of objects - each spaced out to skip the\n    // object in between. This way the individual grid objects will easily fit in\n    // their cells.\n    // \n    // G1 G2 G1 G2 G1 G2\n    // G3 G4 G3 G4 G3 G4\n    // G1 G2 G1 G2 G1 G2\n    // G3 G4 G3 G4 G3 G4 // Etc.\n    //\n    for(int j = 0; j<=1; j++){\n        for(int i = 0; i<=1; i++){\n        \n\n            vec2 ip = floor((p - vec2(i, j))/sc)*sc;\n     \n            // The main calculation. Normally expensive, but it's been precalculated\n            // so is just being read out.\n            //float c = jigDist[j*2 + i]; \n            //float c = jigsawPiece(mod(p + vec2(i, j), sc) - sc/2., ip + vec2(i, j));\n            \n            // Swizzling to avoid the switch statement generated by \"dynamic vector indexing\".\n            // The following two lines are equivalent to the indexed line above.\n            // Thanks to Cyberjax for this suggestion. It helps the compiler out a bit.\n            float c = jigDist.x;\n            jigDist.xyzw = jigDist.yzwx;\n\n            // Record the minimum object's cell ID.\n            if(c<d2) {\n                cellID = ip + vec2(i, j);\n            }\n            \n            // Minimum 2D field value.\n            d2 = min(d2, c);\n            \n            // The height of the object.\n            cellHeight = getCellHeight(ip + vec2(i, j));\n\n            // Minimum 3D field value.\n            d = min(d, smax(c/jSc, abs(p3.z - cellHeight - .0) - .5, .0115));\n            \n\n\n        }\n    }\n    \n    // Return the 3D and 2D field values.\n    return vec2(d, d2);\n    \n}\n\n// The 2D jigsaw pattern value. Called via \"Buf A\" once per frame. See the function above\n// for an explanation. By the way, if you're only interested in a 2D jigsaw value, this\n// function will suffice.\nvec4 jigsaw4(vec3 p3){\n    \n    const float jSc = 4.;\n    vec2 p = p3.xy*jSc; // I had to tweak the scale to get things right.\n    const vec2 sc = vec2(2, 2);\n    \n    vec4 d4 = vec4(0);\n    \n    for(int j = 0; j<=1; j++){\n        for(int i = 0; i<=1; i++){\n\n            vec2 ip = floor((p - vec2(i, j))/sc)*sc;\n            vec2 q = mod(p + vec2(i, j), sc) - sc/2.;\n\n            float c = jigsawPiece(q, ip + vec2(i, j));\n            \n\n            // Swizzling to avoid the switch statement generated by \"dynamic vector indexing\".\n            // Thanks to Cyberjax for this suggestion. It helps the compiler out a bit.\n            //d4[j*2 + i] = c;\n            d4.x = c;\n            d4.xyzw = d4.yzwx;\n\n        }\n    }\n    \n    // Return the four 2D texture values. We'll use them later -- in the raymarching \n    // equation -- to determine the minimum 3D extruded block field value.\n    return d4;\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // The 2D jigsaw piece function is by far the most expensive, but it's \n    // only called once per frame, then passed to the raymarching function\n    // via the \"Buf A\" texture, which is a huge saving. Without this step,\n    // attempting to raymarch this in realtime would stop a lot of systems \n    // in their tracks.\n    //\n    vec2 p = fragCoord.xy/iResolution.xy;\n    \n    // The camera movement is provided via texture scrolling. We're doing it\n    // this way, because it'd be difficult to wrap this particular pattern. \n    // Not impossible, but compilicated. Therefore, the texture area has to \n    // span beyond the canvas borders to keep it withing the camera's field\n    // of view. Otherwise, the effect wouldn't work.\n    //\n    fragColor = jigsaw4(vec3(p*4. - moveXY(iTime), 0));\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}