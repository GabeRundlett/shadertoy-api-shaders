{
    "Shader": {
        "info": {
            "date": "1585240924",
            "description": "potato",
            "flags": 40,
            "hasliked": 0,
            "id": "wdXczX",
            "likes": 17,
            "name": "Day 98",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 644
        },
        "renderpass": [
            {
                "code": "\n\n// radiual blur in this buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 16.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.1)*0.04;\n    //float chromAb = smoothstep(0.,1.,pow(length(uv - 0.5), 0.3))*1.1;\n    float chromAb = pow(length(uv - 0.5),1.)*1.2;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    fragColor.b *= 0.97 + dot(uvn,uvn)*0.4;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.6);\n    \n    fragColor.t *= 1.  - smoothstep(0.,1.,dot(uvn,uvn))*0.;\n    \n    \n    //fragColor.b *= 1. + uv.x*0.02;\n    //fragColor.g *= 1. + uv.t*0.05;\n    \n    fragColor = max(fragColor, 0.);\n    fragColor = pow(fragColor, vec4(0.4545 ));\n    fragColor *= 1. - dot(uvn,uvn)*1.   ;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat xor(float a, float b){\n\treturn float(int(a)^ int(b));\n}\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n    return max(p.y,p.x);\n}\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    n = max(n, 0.);\n    return n;\n}\nvec3 get( vec2 fragCoord )\n{\n    vec2 p =( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    \n    p *= 1. - dot(p,p)*0.05 ;\n    \n    \n    vec2 b = p;\n    float d = 10e6;\n    \n    p *= 1.;\n    \n    p = vec2(9.*atan(p.x,p.y)/6.14, length(p));\n    \n    p.y = log(p.y)*1. - iTime*1. + valueNoise(vec2(iTime),4.).x*1.;\n    vec2 j = p;\n    \n    float id = floor(p.y);\n    vec4 n = noise(id);\n    p.xy *= rot(0. + sin(p.y)*0.);\n    \n    //vec2 id =\n    b *= 1.5;\n    //p = cos(p*(1. - exp(-length(b)*length(b)*1000.)*0.2));\n    p = cos(p*(1. - exp(-length(b)*length(b)*1000.)*0.));\n    \n    for(float i = 0.; i < 9.         ; i++){\n    \t\tp = abs(p);\n        \n        \tfloat sc = (5. + n.y*6.);\n        \tvec2 q = p;\n        \n        \tfloat x = xor(q.y*sc,q.x*sc);\n        \tp *= 1. - x*(0.06 - sin(n.y*4.)*0.02);\n        \tp -= 0.02 + n.y*0.045;\n        \tp *= rot(0.125*3.14);\n        {\n        if(mod(i, 2.) == 0.)\n    \t\td = min(d, sdBox(p, vec2(0.04 + x*0.005)));\n        else\n    \t\td = max(d, -sdBox(p, vec2(0.02 + x*0.005))); \n        \n        }\n    }\n\n    \n    col += smoothstep(0.001,0.,d);\n    \n    \n    float f = smoothstep(0.,1.,fbm(j*80.).x);\n    \n    f = pow(f, 6.)*2.4;\n    if(col.x < 0.4)\n        col += f*6.5;\n    \n    \n    col -= f;\n    \n    \n    \n    //col += fbm(p).x*10.;\n    //col.r += sin(id)*3.5;\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float aa = 5.;\n    \n    for(float i =0.; i < aa*aa   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    \n    col = max(col, 0.);\n\tcol = pow(col, vec3(0.4545));\n    \n    col = 1. - col;\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define TT (tau*t)\n#define tt (tau*t)\n\n#define init vec2 s = vec2(0)\n#define ret return s\n#define bpm 140.\n\n#define tick (60./bpm)\n\n#define beat tick\n#define bar  beat*4.\n#define hbar  bar/2.\n#define msr  bar*4.\n#define hbeat tick/2.\n#define qbeat tick/4.\n\n#define S vec2 s = vec2(0);\n#define E return s;\n#define T true\n#define F false\n\n\nbool[] pattA = bool[16](T,F,F,T,F,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattL = bool[16](T,T,F,T,T,T,T,F,T,F,F,T,F,T,T,F);\nbool[] pattS = bool[8](F,T,F,T,F,T,F,T);\n\n\nbool[] pattBa = bool[8](T,T,F,T,F,T,F,T);\nbool[] pattB = bool[8](T,T,T,T,T,T,T,T);\nint[] notesB = int[8](0,1,2,3,0,1,2,3);\n\nconst vec4 cmin9 = vec4(0.,3.,7.,14.);\nconst vec4 cmin7 = vec4(0.,3.,7.,10.);\nconst vec4 cmaj9 = vec4(0.,4.,7.,14.);\nconst vec4 cmaj7 = vec4(0.,4.,7.,11.);\nconst vec4 cmaj7f15 = vec4(0.,4.,6.,11.);\nconst vec4 cmin7maj = vec4(0.,3.,7.,11.);\n\nvec4[] chords = vec4[4](\n    cmin7maj,\n    cmin7 + 1.,\n    cmaj9 - 2.,\n    cmaj7f15 - 3.\n);\nfloat note(float note, float octave){ \n\treturn 27.5*exp2(((octave*12. ) + note )/12.);//pow(2., );\n}\n\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float ft = fract(t);\n    float tn = t - ft;\n    ft = smoothstep(0.0, 1.0, ft);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, ft);\n}\n\n#define bitreduction(s,amt) s = sign(s) * floor(abs(s)/amt)*amt\n#define sampleratereduction(t, amt) t = floor(t/amt)*amt\n\n\nvec2 kick (float t, inout float sc){\n\tinit;\n\t\n    sampleratereduction(t, 0.00002);\n    \n    float md = beat/4.;\n    float pl = 16.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    float env = exp(-t*40.7);\n    s += sin((exp(-t*20.1)*240. + 30.)*tt )*env;\n    \n    s = mix(s,sin(s*3.)*1., 0.3);\n    \n    \n    bitreduction(s, 0.001);\n    \n    //s = sign(s)*smoothstep(0.,1.,abs(s));\n    \n    \n    s = clamp(s,-1., 1.);\n    \n    \n    float att = float(pattA[int(idx)]);\n    s *= att;\n    sc = 1. - pow(env, 0.15)*att;\n    sc = smoothstep(0.,1.,sc);\n    ret;\n}\n\nvec2 snare(float t){\n\n    init;\n    \n    \n    sampleratereduction(t, 0.00001);\n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 9500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*26.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (240./1. + exp(-t*26.)*1500.  )*tt;\n    s += sin( f )*env;\n    \n    \n    \n    \n    s += sin( f*1.5 )*env*0.1;\n    bitreduction(s, 0.001);\n    s += sin( f*2. )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    //s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    //s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    //s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    //s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n    \n\t//s = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\n\nvec2 snarea(float t){\n\n    init;\n    \n    float md = beat;\n    float pl = 8.;\n    t = mod(t, md*pl);\n    float idx = floor(t/md);\n    t = mod(t, md);\n    \n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 3500.)*0.45;\n    \n    float amt = 1.;\n    float env = exp(-t*16.);\n    //float f = (400. + exp(-t*50.)*600.)*tt;\n    float f = (440./1.5 + exp(-t*50.)*1400.  )*tt;\n    s += sin( f )*env;\n    //s += sin( f*2.25 )*env*0.1;\n    //s += sin( f*1.5 )*env*0.1;\n    s += amt*sin( f + nn*0.9*smoothstep(0.,1.,t*20.) )*env;\n    s -= amt*sin( f )*env;\n    \n    \n    //s += sign(s)*pow(abs(s), vec2(2.))*0.9;\n    s += amt*sin( f*4. + nn.x*exp(-t*10.))*env*env*0.2;\n    //s *= 1.6;\n    s *= 0.39;\n    //s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.1);\n\ts = sin(s*1.5);\n    \n    s *= float(pattS[int(idx)]);\n    ret;\n}\n\nvec2 lead(float t){\n\tinit;\n\t\n    sampleratereduction(t, 0.001);\n    float to;\n    vec2 nn = lpnoise(t, 600.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.1;\n    \n    \n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,bar);\n    float reps = 16.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float amt = 1.;\n    float env = exp(-t*10.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    s += sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 + nn*0.4)*env;\n    s -= sin( note(n, 4.) *tt +sin(note(n, 8.) *tt)*exp(-t*20.)*0.05 )*env;\n    \n    \n    //s += sin(f + sin(2000.*tt)*exp(-t*20.))*env;\n    \n    \n    \n    \n    bitreduction(s, 0.5);\n    s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\nvec2 bass(float t){\n\tinit;\n\t\n    float to;\n    \n    \t\n    sampleratereduction(t, 0.001);\n    vec2 id;\n    float r = bar;\n    t = mod(t, r*4.);\n    \n    id.x = floor(t/r);\n    \n    t = mod(t,r);\n    float reps = 32. / 2.;\n    id.y = floor(t/(bar/reps));\n    \n    id.y = mod(id.y, 4.);\n    \n    t = mod(t,bar/reps);\n    \n    \n    float env = exp(-t*9.4);\n    \n    \n    \n\tfloat n = chords[int(id.x)][int(id.y)];\n    \n    //n += floor(id.y/4.)*12.;\n    \n    s += sin( note(n, 1.) *tt \n             +sin(note(n, 2.) *tt + \n             \t+sin(note(n, 4.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1. \n             +sin(note(n, 1.) *tt + \n             \t+sin(note(n, 2.) *tt)*exp(-t*1.)*0.1 \n                 \n                 )*exp(-t*9.)*1.5\n            )*env;\n    \n    \n    s *= 1.;\n    \n    \n    bitreduction(s, 0.3);\n    //s *= float(pattL[int(id.y)]);\n    \n    //s += sin( f )*env;\n    //s += amt*sin( f + nn*0.5 )*env;\n    //s -= amt*sin( f )*env;\n    \n    s *= 0.7;\n    ret;\n}\n\n\n\nvec2 chord(float t){\n\tinit;\n    \n    \n    sampleratereduction(t, 0.0005);\n    float r = bar;\n    t = mod(t,r*4.);\n    int id = int(floor(t/r));\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 4500.)*0.45;\n    \n    nn *= 0.1*sin(t);\n    float m = 1.;\n    float width = 2.;\n    for(float i = 0.; i < 9.; i++){\n        float a = (1. + i/4.);\n    \ts.x += sin( note(chords[id].x, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].y, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].z, 4.) *tt*a + nn.x)*m;\n    \ts.x += sin( note(chords[id].w, 4.) *tt*a + nn.x)*m;\n    \ts.y += sin( note(chords[id].x, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].y, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].z, 4.) *tt*a + nn.y + width)*m;\n    \ts.y += sin( note(chords[id].w, 4.) *tt*a + nn.y + width)*m;\n    \tm *= 0.5;\n    }\n    \n    bitreduction(s, 0.5);\n    \n    s *= 0.04;\n    //s /= 2.;\n    //s = sin(s);\n\tret;\n}\n\n\nvec2 hats (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat*0.5);\n    \n    sampleratereduction(t, 0.00005);\n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 1500.)*0.4;\n    \n    float amt = 0.7;\n    float env = exp(-t*15.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    bitreduction(s, 0.5);\n    s *= 0.7;\n    ret;\n}\nvec2 hatsb (float t){\n\tinit;\n\t\n    t = mod(t + 0., hbeat/0.5);\n    \n    vec2 nn = lpnoise(t, 400.);\n    nn += lpnoise(t, 500.)*0.9;\n    nn += lpnoise(t, 2500.)*0.45;\n    nn += lpnoise(t, 5500.)*0.4;\n    \n    float amt = 1.;\n    float env = exp(-t*5.4);\n    float f =  sin((12000. )*tt)*exp(-t*0.4)*0.215 +sin((9000. )*tt)*exp(-t*2.)*0.5 + ( 2000. + exp(-t*60.)*100.)*tt +lpnoise(t, 200500.).x*1.;\n    s += sin( f )*env;\n    s += amt*sin( f + nn )*env;\n    s -= amt*sin( f )*env;\n    \n    float bitreduction = 0.35;\n    s = sign(s) * floor(abs(s)/bitreduction)*bitreduction;\n    \n    s *= 0.7;\n    ret;\n}\n\n\nvec2 mainSound( in int samp, float t )\n{\n    vec2 s= vec2(0);\n    \n    \n    float sc;\n    s += kick(t,sc)*1.;\n    s += snare(t);\n    s += hats(t)*(pow(sc,4.4))*0.2;\n    s += hatsb(t)*(pow(sc,4.4))*0.2;\n    s += chord(t)*(pow(sc,1.8))*0.9;\n    s += lead(t)*(pow(sc,1.))*0.25;\n    \n    if(t > beat*16. &&  (  t < beat*(16. + 8.) || t > beat*(16. + 12.) )  )\n    \ts += bass(t)*(pow(sc,1.))*0.75;\n    //s += lead(t)*0.4;\n    s *= 0.7;\n    \n    s = mix(s,sign(s)*smoothstep(0.1,1.,abs(s)), 0.3 + sin(t)*0.2);\n    s = clamp(s,-1.,1.);\n    \n    //s *= smoothstep(0.,1.,t*0.5);\n    return s;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}