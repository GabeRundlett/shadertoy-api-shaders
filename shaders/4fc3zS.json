{
    "Shader": {
        "info": {
            "date": "1711810386",
            "description": "classic RayMarching to ve a single octahedron and manipulate space and rays to create a beautiful illusion",
            "flags": 0,
            "hasliked": 0,
            "id": "4fc3zS",
            "likes": 2,
            "name": "Octahedron Space Vortex",
            "published": 3,
            "tags": [
                "raymarching",
                "vortex"
            ],
            "usePreview": 0,
            "username": "JonathanShiri",
            "viewed": 129
        },
        "renderpass": [
            {
                "code": "vec3 pallete(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos(6.28318 *(c*t + d));\n}\n\nmat2 rot2D (float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h*h*h*k*(1.0 / 6.0);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n    }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat map(vec3 p) {\n    // Object is advancing towards camera\n    p.z += iTime * .4;\n    \n    // Space repetition\n    p.xy = fract(p.xy) - .5;\n    // different spacing in the Z axis\n    p.z = mod(p.z, .3) - .125;\n    \n    float box = sdOctahedron(p, .15);\n\n    return box;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    int iter = 80;\n    float th = 0.001;\n    \n    vec3 ro = vec3(0, 0, -3); // Rays origin\n    vec3 rd = normalize(vec3(uv, 1)); // Rays direction\n    float t = 0.; // total distance travelled\n    \n    \n    //Vertical camera rotation:\n //   ro.yz *= rot2D(-m.y);\n  //  rd.yz *= rot2D(-m.y);\n    \n    // Horizontal camera rotation:\n//    ro.xz *= rot2D(-m.x);\n  //  rd.xz *= rot2D(-m.x);\n    \n    if (iMouse.z < 0.) m = vec2(cos(iTime*.2), sin(iTime)*.2);\n    \n    //RayMarching\n    int i = 0;\n    for (; i < iter; i++) { \n        vec3 p = ro + rd*t;\n        \n        \n        p.xy *= rot2D(t*.2*m.x); // rotate ray around Z axis\n        \n        p.y += sin(t*(m.y + 1.)*.5)*.35; // wiggle ray\n            \n        float d = map(p);\n\n        t+= d;\n        if (d < th || t > 100.) break;\n    }\n\n    // color is determined by the total distance and the iteration:\n    col = pallete(t *.04 + float(i)*.005);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}