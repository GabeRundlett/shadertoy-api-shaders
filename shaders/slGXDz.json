{
    "Shader": {
        "info": {
            "date": "1640528614",
            "description": "Look, it's a thing!",
            "flags": 0,
            "hasliked": 0,
            "id": "slGXDz",
            "likes": 0,
            "name": "eindacor_fibonado",
            "published": 3,
            "tags": [
                "spiral"
            ],
            "usePreview": 0,
            "username": "Eindacor_DS",
            "viewed": 34
        },
        "renderpass": [
            {
                "code": "\n#define TWOPI 6.28318530718f\n#define THETA 1.618033988749894848\n#define AA 0.001f\n\n#define CYAN vec3(0., 1., 1.)\n#define MAGENTA vec3(1., 0., 1.)\n#define YELLOW vec3(1., 1., 0.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define ORANGE vec3(1., .75, .25)\n#define PINK vec3(1., .25, .75)\n#define WHITE vec3(1.)\n#define BLACK vec3(0.)\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getRadialVal(vec2 p1, vec2 p2) {\n    float offsetAngle = getOffsetAngle(p1, p2);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nvec3 getRandomColor(float seed) {\n    seed = clamp(seed, 0., 1.);\n    float colorCount = 6.;\n    float colorIncrement = 1.f / colorCount;\n    float seedFloor = floor(seed / colorIncrement) * colorIncrement;\n    float lerpVal = smoothstep(seedFloor, seedFloor + colorIncrement, seed);\n\n    if (seed <= colorIncrement * 1.) {\n        return mix(RED, YELLOW, lerpVal);\n    } else if (seed <= colorIncrement * 2.) {\n        return mix(YELLOW, GREEN, lerpVal);\n    } else if (seed <= colorIncrement * 3.) {\n        return mix(GREEN, CYAN, lerpVal);\n    } else if (seed <= colorIncrement * 4.) {\n        return mix(CYAN, BLUE, lerpVal);\n    } else if (seed <= colorIncrement * 5.) {\n        return mix(BLUE, MAGENTA, lerpVal);\n    } else {\n        return mix(MAGENTA, vec3(1.), lerpVal);\n    }\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getCircleTangentPoints(vec2 p, vec2 circleCenter, float circleRadius) {\n    float distFromCircle = distance(p, circleCenter);\n    float angle = asin(circleRadius / distFromCircle);\n    float innerAngle = TWOPI / 4. - angle; // 180 degrees in a circle, one angle is 90, leaves 90 degrees between others\n    \n    vec2 firstPoint = ((p - circleCenter) * (circleRadius / distFromCircle)) * createRotationMatrix(innerAngle) + circleCenter;\n    vec2 secondPoint = ((p - circleCenter) * (circleRadius / distFromCircle)) * createRotationMatrix(-innerAngle) + circleCenter;\n    \n    return vec4(firstPoint.x, firstPoint.y, secondPoint.x, secondPoint.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float bandWidth = .03;\n    \n    vec2 center = vec2(.5 * aspectRatio, .5);\n    \n    uv = (uv - center) * createRotationMatrix(iTime * -.2) + center;\n    \n    float angle = asin((uv.y - center.y)/distance(uv, center));\n    \n    float radialVal = getRadialVal(center, uv);\n    float dist = distance(uv, center) + bandWidth * radialVal; \n\n    float val = mod(dist, bandWidth) / bandWidth;\n    val = 1.;\n    \n    vec2 startingPoint = center + vec2(bandWidth, 0.);\n    \n    int numPoints = 40;\n    \n    vec3 outColor = vec3(.1, .05, .3);\n    //outColor = vec3(1.);\n    \n    float transitionTime = 10.;\n    float holdTime = 0.;\n    \n    float radianIncrement = getHoldTransitionValue(THETA + .2, THETA, holdTime, transitionTime, iTime + holdTime * 2. + transitionTime);\n    vec3 fillColor = vec3(1.);\n    vec3 lineColor = vec3(0.);\n    \n    for (int i=0; i<numPoints; ++i) {\n        int pointIndex = numPoints - 1 - i;\n        \n        float radianOffset = float(pointIndex) * radianIncrement;\n        float fullRevolutions = radianOffset / TWOPI;\n        vec2 point = vec2(fullRevolutions * bandWidth) * createRotationMatrix(radianOffset) + center;\n        float pointRenderVal = distance(point, center) * 1.5;\n        \n        float pointRadius = mix(.025, .055, pointRenderVal);\n        float dist = distance(uv, point);\n        \n        float colorMod = mix(.2, 1., pointRenderVal);\n        \n        fillColor = getRandomColor(float(i)/float(numPoints));\n        \n        vec4 tangentPoints = getCircleTangentPoints(center, point, pointRadius);\n        \n        float lineWidth = pointRadius * .05;\n    \n        if (dist < pointRadius) {\n            outColor = fillColor * colorMod;\n            float pointVal = smoothstep(pointRadius - AA, pointRadius, dist);\n            outColor = mix(outColor, lineColor * colorMod, pointVal);\n        } else {\n            float pointVal = smoothstep(pointRadius + lineWidth, pointRadius + lineWidth + AA, dist);\n            outColor = mix(lineColor * colorMod, outColor, pointVal);\n        }\n        \n        if (distance(center, point) > pointRadius) {\n            outColor = mix(outColor, lineColor, lineSegmentSmoothStep(center, tangentPoints.xy, uv, lineWidth, AA, true));\n            outColor = mix(outColor, lineColor, lineSegmentSmoothStep(center, tangentPoints.zw, uv, lineWidth, AA, true));\n        }       \n    }\n\n    // Output to screen\n    vec3 washColor = vec3(0.8, .9, 1.);\n    fragColor = vec4(outColor * washColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}