{
    "Shader": {
        "info": {
            "date": "1708304499",
            "description": "This got less fun very quickly\nStarting on glass for the however manyth time, please work now. Please\nPublished 2/26/24",
            "flags": 32,
            "hasliked": 0,
            "id": "lXj3Rh",
            "likes": 1,
            "name": "Ray Tracing: Glass PLEASEdfjbzds",
            "published": 3,
            "tags": [
                "raytracing",
                "rays",
                "sphere",
                "balls"
            ],
            "usePreview": 0,
            "username": "UsamagorQ",
            "viewed": 77
        },
        "renderpass": [
            {
                "code": "    vec4 ApplyGammaCorrection(vec4 color) {\n    float gamma = 2.3;\n    return pow(color, vec4(1. / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 Render = texture(iChannel1, uv);\n    Render = ApplyGammaCorrection(Render);\n    fragColor = vec4(Render);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool accumulation = true;\nuint seed;\nint maxBounceCount = 500;\nfloat raysPerPixel = 1.;\n// Random number generator\nfloat random() {\n    seed = seed * 747796405u + 2891336453u;\n    uint result = ((seed >> ((seed >> 28) + 4U)) ^ seed) * 277803737u;\n    result = (result >> 22) ^ result;\n    return float(result) / 4294967295.0;\n}\n\n// Ray structure\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n// Material structure\nstruct Material {\n    vec3 color;\n    vec3 emissionColor;\n    float emissionStrength;\n    float smoothness;\n    float specularProbability;\n    vec3 specularColor;\n    vec2 Dielectric;\n};\nstruct Triangle\n{\nvec3 posA;\nvec3 posB;\nvec3 posC;\n\nvec3 normalA;\nvec3 normalB;\nvec3 normalC;\n};\n\n// Sphere structure\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n\n// Structure to hold hit information\nstruct HitInfo {\n    bool didHit;\n    bool frontFace;\n    float dst;\n    vec3 hitPoint;\n    vec3 normal;\n    Material material;\n};\nstruct meshInfo\n{\nint firstTriangleIndex;\nint numTriangles;\nMaterial material;\n};\nfloat reflectance(float cosine, float ior) {\n        // Use Schlick's approximation for reflectance.\n        float r0 = (1.-ior) / (1.+ior);\n        r0 = r0*r0;\n        return r0 + (1.-r0)*pow((1. - cosine), 5.);\n    }\n\n\nHitInfo RaySphere(Ray ray, vec3 sphereCenter, float sphereRadius) {\n    HitInfo hitInfo;\n    vec3 offsetRayOrigin = ray.origin - sphereCenter;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(offsetRayOrigin, ray.dir);\n    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4. * a * c;\n\n    if (discriminant >= 0.) {\n        float dst = (-b - sqrt(discriminant)) / (2. * a);\n\n        if (dst >= 0.) {\n            hitInfo.didHit = true;\n            hitInfo.dst = dst;\n            hitInfo.hitPoint = ray.origin + ray.dir * dst;\n            hitInfo.normal = normalize(hitInfo.hitPoint - sphereCenter);\n        }\n    }\n    vec3 outwardNormal = normalize(ray.origin + hitInfo.dst*ray.dir - sphereCenter);\n    hitInfo.frontFace = dot(ray.dir, outwardNormal) < 0.;\n    hitInfo.normal = hitInfo.frontFace ? outwardNormal : -outwardNormal; \n    return hitInfo;\n}\nRay scatter(Ray ray, HitInfo hitinfo ) {\n    float ior = hitinfo.material.Dielectric.y;\n    float refract_ratio = hitinfo.frontFace ? (1.0 / ior) : ior;\n\n    vec3 uDir = normalize(ray.dir);\n    float cosTheta = min(dot(-uDir, hitinfo.normal), 1.0);\n    float sinTheta = sqrt(1.0 - (cosTheta * cosTheta));\n\n    bool noRefract = refract_ratio * sinTheta > 1.0;\n    vec3 refractedDir = refract(ray.dir, hitinfo.normal, refract_ratio);\n    vec3 reflectedDir = reflect(ray.dir, hitinfo.normal);\n\n    float reflectProb = reflectance(cosTheta, refract_ratio);\n\n    if (noRefract || random() < reflectProb) {\n        ray.dir = reflectedDir;\n    } else {\n        // Check if the ray is entering or exiting the glass\n        if (hitinfo.frontFace) {\n            // Ray is entering the glass, so refract normally\n            ray.dir = refractedDir;\n        } else {\n            // Ray is exiting the glass, so reverse the refracted direction\n            ray.dir = refractedDir;\n        }\n        // Shift the origin slightly to avoid self-intersection\n        ray.origin += 0.001 * ray.dir;\n    }\n\n    return ray;\n}\n\n\n\n\nHitInfo RayTriangle(Ray ray, Triangle tri)\n{\nvec3 edgeAB = tri.posB - tri.posA;\nvec3 edgeAC = tri.posC - tri.posA;\nvec3 normal = cross(edgeAB, edgeAC);\nvec3 ao = ray.origin - tri.posA;\nvec3 dao = cross(ao, ray.dir);\n\nfloat Tdeterminant = -dot(ray.dir, normal);\nfloat invDet = 1. / Tdeterminant;\n\nfloat dst = dot(ao, normal) * invDet;\nfloat u = dot(edgeAC, dao) * invDet;\nfloat v = -dot(edgeAB, dao) * invDet;\nfloat w = 1. - u - v;\n\nHitInfo hitinfo;\nhitinfo.didHit = Tdeterminant >= 1e-6 && dst >= 0. && u >= 0. && w >= 0.;\nhitinfo.hitPoint = ray.origin + ray.dir * dst;\nhitinfo.normal = normalize(tri.normalA * w + tri.normalB * u + tri.normalC * v);\nhitinfo.dst = dst;\nreturn hitinfo;\n}\n\n\n// Function to check ray-sphere intersections for a scene\nHitInfo Scene(Ray ray) {\n    HitInfo closestHit;\n    closestHit.dst = 1e6;\n\n    HitInfo hitInfo;\n    if(true)\n    {\n    // Call RaySphere for each sphere in the scene\n    hitInfo = RaySphere(ray, vec3(40., 35., 35.), 15.);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(0., 1., 0.), vec3(1.), 2., 0., 0.25, vec3(1.), vec2(0.,0.)); // Green Sphere (Light)\n    }\n\n        hitInfo = RaySphere(ray, vec3(1., 0.3, 0.), 0.5);\n        if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n            closestHit = hitInfo;\n            closestHit.material = Material(vec3(0., 0., 1.), vec3(0.), 0., 0., 0., vec3(0.208,0.220,0.271), vec2(0.,0.));  // Blue Sphere\n        }\n   \n    hitInfo = RaySphere(ray, vec3(-1., -0.75, -2.), 1.);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(1./*0.3, 0.3, 1*/), vec3(0.), 0., 0., 0., vec3(1.), vec2(1.,1.5)); // glass sphere\n    }\n    \n    hitInfo = RaySphere(ray, vec3(-1., -0.75, -2.), 0.35);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(75/255, 255/255 , 100/255), vec3(0.), 0., 0.015, 0.00, vec3(1.), vec2(0.,0.)); //Green Sphere\n    }\n    \n    hitInfo = RaySphere(ray, vec3(1., -0.6, 0.), 0.35);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(0.3, 0.3, 1), vec3(0.), 0., 0., 0., vec3(1.), vec2(0.,0.)); // light blue sphere\n    }\n\n     hitInfo = RaySphere(ray, vec3(1., -17, 0.), 15.);\n    if (hitInfo.didHit && hitInfo.dst < closestHit.dst) {\n        closestHit = hitInfo;\n        closestHit.material = Material(vec3(1.,1. ,0. ), vec3(0.), 0., 0., 0., vec3(1.), vec2(0.,0.)); // big sphere\n    }\n    \n    } \n    //just so I can collapse the entire thing down, makes it easier for organization, especially for the future\n    // No triangles yet, probably never because I don't feel like doing all of the import calculations by hand.\n\n    return closestHit;\n}\nvec3 GetEnvironmentLight()\n{\n\nreturn vec3(90./255.);\n}\nvec3 randomDirection()\n{\nfloat x = random();\nfloat y = random();\nfloat z = random();\nreturn normalize(vec3(x, y, z));\n}\nvec3 randomHemisphereDirection(vec3 normal)\n{\nvec3 dir = randomDirection();\nreturn dir * sign(dot(normal, dir));\n}\nvec3 Trace(Ray ray) {\n    meshInfo AllMeshInfo[1];\n    Material trimat0 = Material(vec3(1.), vec3(0.), 0., 1., 1.,vec3(1.,0.,0.5), vec2(0.,0.));\n    AllMeshInfo[0] = meshInfo(0, 1, trimat0);\n    Triangle triangles[1];\n\n    vec3 incomingLight = vec3(0.);\n    vec3 rayColor = vec3(1.);\n\n    for (int i = 0; i < maxBounceCount; i++) {\n        HitInfo hitinfo = Scene(ray);\n\n        if (hitinfo.didHit) {\n            Material material = hitinfo.material;\n            vec3 emittedLight = material.emissionColor * material.emissionStrength;\n            incomingLight += emittedLight * rayColor;\n\n            if (material.Dielectric.x == 1.0) {\n                // Handle glass material\n                ray = scatter(ray, hitinfo);\n                rayColor *= material.color;\n            } else {\n                // Handle other materials\n                vec3 diffuseDir = normalize(hitinfo.normal + randomDirection());\n                vec3 specularDir = reflect(ray.dir, hitinfo.normal);\n                float isSpecularBounce = material.specularProbability >= random() ? 0.0 : 1.0;\n\n                ray.dir = mix(diffuseDir, specularDir, material.smoothness);\n                rayColor *= mix(material.specularColor, material.color, isSpecularBounce);\n            }\n\n            ray.origin = hitinfo.hitPoint;\n        } else {\n            // No intersection, accumulate environment light\n            incomingLight += GetEnvironmentLight() * rayColor;\n            break;\n        }\n    }\n\n    return incomingLight;\n}\n\n\n// Main function for rendering\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialize ray and seed\n    Ray ray;\n    ray.origin = vec3(0., 1.35, 5.);\n    seed = floatBitsToUint(texture(iChannel0, fragCoord / iResolution.xy).x + iTime);\n\n    // Generate a random offset\n    vec2 of = -0.5 + vec2(random(), random());\n\n    // Calculate the pixel position in normalized device coordinates\n    vec2 p = (2.0 * (fragCoord + of) - iResolution.xy) / iResolution.y;\n\n    // Calculate the direction from the camera to the view point\n    vec3 viewPoint = vec3(p, 1.);\n    ray.dir = normalize(viewPoint - ray.origin);\n    vec3 totalIncomingLight;\n    for (int rayIndex = 0; rayIndex < int(raysPerPixel); rayIndex++)\n    {\n    totalIncomingLight += Trace(ray);\n    }\n    vec3 pixelCol = totalIncomingLight / raysPerPixel;\n    // Set the pixel color based on the material color from the scene\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 old = texture(iChannel1,uv);\n    vec4 new = vec4(pixelCol, 1.);\n    float weight = 1.0/(float(iFrame) + 1.);\n    vec4 accumulatedAverage = old * (1. - weight) + new * weight;\n    if(accumulation)\n    {\n    fragColor = vec4(accumulatedAverage);\n    }\n    else\n    {\n    fragColor = vec4(pixelCol, 1.);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}