{
    "Shader": {
        "info": {
            "date": "1493921827",
            "description": "Spherical Fibonacci mapping is an approximation of uniform distribution over a sphere.\nThis demo shows how to distribute circles over a sphere.\nMouse available for moving around.\nUsed for my experiments as an omnidirectional texture.",
            "flags": 1,
            "hasliked": 0,
            "id": "Ms2yDK",
            "likes": 19,
            "name": "Equirectangular Fibonacci Sphere",
            "published": 3,
            "tags": [
                "sphere",
                "mapping",
                "spherical",
                "fibonacci",
                "equirectangular",
                "projections"
            ],
            "usePreview": 1,
            "username": "starea",
            "viewed": 1857
        },
        "renderpass": [
            {
                "code": "/** \n * Equirectangular Fibonacci Sphere\n * Link to demo: https://www.shadertoy.com/view/Ms2yDK\n * starea @ ShaderToy\n *\n * Most of the code is forked from:\n * [1] nomadiclizard's Dragon Egg. https://www.shadertoy.com/view/MslyRr\n * Thank you nomadiclizard for sharing!\n * I added the equirectangular part and orange circles to mimic the Kusama style (https://hirshhorn.si.edu/kusama/).\n *\n * Reference: \n * [1] Keinert, Benjamin, et al. \"Spherical fibonacci mapping.\" ACM Transactions on Graphics (TOG) 34.6 (2015): 193.\n       http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping.pdf\n * [2] https://www.openprocessing.org/sketch/41142\n * [3] http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere\n *\n * My Related Shaders:\n * [1] Unified Gnomonic & Stereographic Projections. https://www.shadertoy.com/view/ldBczm\n * [2] Cubemap to Gnomonic Projection. https://www.shadertoy.com/view/4sjcz1\n * [3] [WiP] Halftone Sphere. https://www.shadertoy.com/view/4sSyD1\n *\n **/\n\n#define pi 3.14159265359\n#define twoPi 6.28318530718\n#define halfPi 1.57079632679\n#define infinity 100.0\n#define phi 1.61803398875\n#define phiMinusOne 0.61803398875\n#define twoPiOnPhi 3.88322207745\n#define root5 2.2360679775\n#define logPhiPlusOne 0.96242365011\n#define EQUIRECTANGULAR true\n#define KUSAMA_COLOR true\n//#define TIME iTime\n#define TIME 5.0\n\n// egg definition and colouring\nconst float maxn = 50.0;\nconst float growtime = 5.0;\nconst bool convex = true;\nconst float f1 = 856.0, s1 = 3.0, a1 = 0.15;\nconst float f2 = 335.0, s2 = 2.0, a2 = 0.10;\n\n// SIMPLE STUFF THAT WOULD BE COOL IF WEBGL HAD IN A STANDARD LIBRARY :V\n\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec4 rotationQuat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float c = cos(0.5 * angle);\n    float s = sqrt(1.0 - c * c);\n    return vec4(axis.x * s, axis.y * s, axis.z * s, c);\n}\n\nvec3 rotate(vec3 p, vec4 q)\n{\n\treturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    return rotate(p, rotationQuat(axis, angle));\n}\n\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\nmat4 scaleMatrix(float s)\n{\n    return mat4(s,   0.0, 0.0, 0.0,\n                0.0, s,   0.0, 0.0,\n                0.0, 0.0, s,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// k'th fibonacci number\nfloat calcfk(float k)\n{\n\treturn round(pow(phi, k) / root5);\n}\n\n// calculates a basis vector for fibonacci sphere n\nvec2 calcbk(float fk, float n)\n{\n    return vec2(twoPi * fract((fk + 1.0) * phiMinusOne) - twoPiOnPhi,\n                -2.0 * fk / n);\n}\n\n// calc point i of n in spherical coordinates\nvec2 calcpoint(float i, float n)\n{\n    return vec2(twoPi * fract(i * phiMinusOne),\n                1.0 - (2.0 * i + 1.0) / n);\n}\n\n// converts [phi,cos theta] into [x,y,z] for unit sphere\nvec3 s2c(vec2 s)\n{\n    float sinTheta = sqrt(1.0 - s.y * s.y);\n    return vec3(cos(s.x) * sinTheta,\n                sin(s.x) * sinTheta,\n                s.y);\n}\n\n// converts [x,y,z] into [phi, cos theta] for unit sphere\nvec2 c2s(vec3 c)\n{\n    return vec2(atan(c.y, c.x),\n                c.z);\n}\n\n// angle between two points in spherical coords\nfloat angdist(vec2 sp1, vec2 sp2)\n{\n    float sinTheta1 = sqrt(1.0 - sp1.y * sp1.y);\n    float sinTheta2 = sqrt(1.0 - sp2.y * sp2.y);\n    return acos(sp1.y * sp2.y + sinTheta1 * sinTheta2 * cos(sp2.x - sp1.x));\n}\n\n// calculate new point [phi, cos theta] if walking point sp on bearing ib distance d\nvec2 gcircle(vec2 sp, float ib, float d)\n{\n    float cosd = cos(d);\n    float sind = sin(d);\n    float sinTheta1 = -sp.y;\n    float cosTheta1 = sqrt(1.0 - sp.y * sp.y);\n    float sinTheta2 = sinTheta1 * cosd + cosTheta1 * sind * cos(ib);\n    float theta2 = asin(sinTheta2);\n    float phi2 = sp.x + atan(sin(ib) * sind * cosTheta1, cosd - sinTheta1 * sinTheta2);\n    return vec2(mod(phi2, twoPi), cos(theta2 + halfPi));\n}\n\n// 0..1 for seed x\nfloat random(float x)\n{\n    return fract(abs(sin(x * 12.9898) * 43758.5453));\n}\n\n// distance to nearest cell on a fibonacci sphere\nfloat fibspheren(vec3 p, float n, out float minidx, out vec3 sn)\n{\n    // get spherical coords for point p on surface of unit sphere\n    vec2 sp = c2s(p);\n    float avdist = sqrt(4.0 * pi / n);\n    \n    // calc the dominant zone number\n    float k = max(2.0, floor(log(root5 * n * pi * (1.0 - sp.y * sp.y)) / logPhiPlusOne));   \n    \n    // calc basis vectors for this zone\n    // [could all be precalculated and looked up for k,n]\n    vec2 f = vec2(calcfk(k), calcfk(k + 1.0));\n    vec2 bk = calcbk(f[0], n);\n    vec2 bk1 = calcbk(f[1], n);\n    mat2 b = mat2(bk, bk1);\n    mat2 invb = inverse(b);\n    \n    // change of basis for point sp to local grid uv\n    float z0 = 1.0 - 1.0 / n;\n    vec2 c = floor(invb * (sp - vec2(0.0, z0)));\n    \n    // for k<=4 paper suggests using (-1,0,+1)^2 offset factors but we'll\n    // stick with (0,1)^2 and live with the occasional glitches\n    float mindist = pi;\n    vec2 minisp;\n    for (int s = 0; s < 4; s++) {\n        // figure out the point index and generate fib point\n        vec2 o = vec2(s - (s/2) * 2, s / 2);\n        float idx = dot(f, c + o);\n        if (idx > n) continue;        \n        vec2 isp = calcpoint(idx, n);\n        \n        // walk on a random bearing a random distance to make cells move a bit\n        //float b = mod((-0.05 + 0.1 * random(idx + 42.39)) * iTime, twoPi);\n        //float d = dist * random(idx + 28.93) * cos((-0.5 + 1.0 * random(idx + 42.39)) * iTime);\n        //isp = gcircle(isp, b, d);\n        \n        // closest?\n        float dist = angdist(isp, sp);\n        if (dist < mindist) {\n\t\t\tmindist = dist;\n            minidx = idx;\n            minisp = isp;\n        }\n    }\n    \n    // use nearest point to calculate surface normal via rotation around cotangent from p -> ip\n    // ohhhh wow I can make keeled scales real easy if dist varies by direction!\n    vec3 ip = s2c(minisp), cotan;\n    if (convex) {\n        cotan = cross(ip - p, p);\n    } else {\n        cotan = cross(p - ip, p);\n    }\n    sn = rotate(p, cotan, mindist / avdist);\n    return mindist;\n}\n\n// view stuff\nconst float fov = radians(50.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\n// calculates intersection parameters for a ray through a sphere at sp radius r\n// return true if the halfray ro + t1.rd is hitting\nbool spherehit(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    vec3 rosp = ro - sp;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, rosp);\n    float c = dot(rosp, rosp) - (r * r);\n    float b2m4ac = b * b - 4.0 * a * c;\n    if (b2m4ac >= 0.0) {\n        float r = sqrt(b2m4ac);\n        t1 = (-b - r) / (2.0 * a);\n        t2 = (-b + r) / (2.0 * a);\n        return t1 >= 0.0 || t2 >= 0.0;\n    } else {\n        return false;\n    }\n}\n\n\nbool spherehitd(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    return true; \n}\n\n// black -> white via red and yellow for 0,1\nvec4 falsecolourr(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\n// black -> white via green and cyan for 0,1\nvec4 falsecolourg(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord, vec3 ro, vec3 rd)\n{\n    \n    // number of points in fibsphere\n    float n = pow(2.0, log(maxn) / log(2.0) * smoothstep(0.0, 1.0, TIME / growtime)); \n    \n    // fibsphere location and size\n    vec3 sp = vec3(0.0);\n\tif (!EQUIRECTANGULAR) sp = vec3(0.0, 0.0, -2.0);\n    float sr = pow((n / maxn), 0.333) * (1.0 + 0.01 * cos(TIME));\n    \n    // mouse rotates it\n    float r1 = (iMouse.x / iResolution.x - 0.5) * twoPi;\n    float r2 = (iMouse.y / iResolution.y - 0.5) * twoPi;\n    r1 += TIME * 0.25;\n    \n    // transform and inverse matrices\n    mat4 ms = scaleMatrix(1.0 / sr) *\n              translationMatrix(-sp);\n    mat4 mr = rotationMatrix(forward, -r1) *\n              rotationMatrix(right, -r2);\n    mat4 mmr = rotationMatrix(right, r2) *\n        \t   rotationMatrix(forward, r1);\n    \n    \n    // check if an intersection is possible (in world space)\n    float t1, t2;\n    if (spherehit(sp, sr, ro, rd, t1, t2)) {\n        \n        \n        vec4 wp = vec4(ro + t1 * rd, 1.0);\n    \t// calculate hit of fibsphere (back in model space)\n        vec3 mp = vec3(mr * ms * wp), msn;\n        float idx, ir = fibspheren(mp, n, idx, msn);\n        \n        // surface normal back in world coords\n        vec3 sn = vec3(mmr * vec4(msn, 1.0));\n        \n        // colour it all pretty - similar to adding octaves of noise\n        // overlaying lots of waves gives it a cool mesmerising effect\n        float vrange = 0.5 + a1 * cos(f1 * (idx / maxn) + s1 * TIME) +\n            \t\t\ta2 * cos(f2 * (idx / maxn) + s2 * TIME);\n        \n        vec3 c = vec3(0.0, 1.0, 0.0); \n       // if (idx < 0.5) c = vec3(1.0, 0.0, 0.0); \n        if (KUSAMA_COLOR) c = vec3(0.86, 0.78, 0.1);\n        c*=smoothstep(.02, .0 , ir-0.1 + sin(iTime+idx)*.05);\n        //if (ir > 0.1 + sin(iTime + idx) * 0.05) c = vec3(0.0); \n        fragColor = vec4(c, 1.0); \n        \n        \n    \t// define the spherical coordinates, [-1, 1]\n    \t//vec2 s = vec2(acos(sn.z), atan(sn.y, sn.x)) / pi; \n    \t//fragColor = texture(iChannel0, s);\n        \n    } else {\n        fragColor = vec4(1.0); \n        //fragColor = 0.3 + 0.3 * vec4(fragCoord.y / iResolution.y);\n    }\n    \n     \n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // the VR version does it for us\n    render(fragColor, fragCoord, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // figure out where to look\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    \n    if (EQUIRECTANGULAR) {\n   \t\tvec2 sph = fragCoord.xy / iResolution.xy * vec2(twoPi, pi);\n    \trd = vec3(sin(sph.y) * sin(sph.x), cos(sph.y), sin(sph.y) * cos(sph.x)); \n    }\n    render(fragColor, fragCoord, ro, rd);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}