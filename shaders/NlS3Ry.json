{
    "Shader": {
        "info": {
            "date": "1624081884",
            "description": "I really like redstone!",
            "flags": 0,
            "hasliked": 0,
            "id": "NlS3Ry",
            "likes": 21,
            "name": "Redstone",
            "published": 3,
            "tags": [
                "3d",
                "minecraft"
            ],
            "usePreview": 0,
            "username": "been_jamming",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "struct face{\n    vec3 p;\n    vec3 side0;\n    vec3 side1;\n};\n\nstruct ray{\n\tvec3 p;\n\tvec3 vec;\n};\n\nvec4 create_orientation(vec3 axis, float angle){\n\tfloat len;\n\tvec4 outvec;\n\t\n\tlen = length(axis);\n\taxis *= sin(angle)/len;\n\toutvec.yzw = axis;\n\toutvec.x = cos(angle);\n\t\n\treturn outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n\treturn vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n\tvec4 outvec;\n\t\n    outvec.x = dot(a, b.xyzw*vec4(1.0, -1.0, -1.0, -1.0));\n    outvec.y = dot(a, b.yxwz*vec4(1.0, 1.0, 1.0, -1.0));\n    outvec.z = dot(a, b.zwxy*vec4(1.0, -1.0, 1.0, 1.0));\n    outvec.w = dot(a, b.wzyx*vec4(1.0, 1.0, -1.0, 1.0));\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n\tvec4 v;\n\t\n\tv.x = 0.0;\n\tv.yzw = p.xyz;\n\treturn compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nvoid ray_face_intersect(face f, ray r, out float t, out vec2 face_coords, out vec3 intersect_pos){\n    vec3 normal_vec;\n    \n    normal_vec = cross(f.side0, f.side1);\n    t = dot(f.p - r.p, normal_vec)/dot(r.vec, normal_vec);\n    intersect_pos = r.vec*t + r.p;\n    face_coords.x = dot(intersect_pos - f.p, f.side0)/(dot(f.side0, f.side0));\n    face_coords.y = dot(intersect_pos - f.p, f.side1)/(dot(f.side1, f.side1));\n}\n\nfloat hash(const float n){\n    return fract(cos(2.0734*n)*sin(n*1.1234512)*12111.312);\n}\n\n//The number of rectangular faces in the scene\n#define NUM_FACES 51\n\n//For each face, I have defined a corner of the face and two vectors for the sides of the face\nconst face faces[NUM_FACES] = face[NUM_FACES](\n    //The smooth stone block\n    face(vec3(0.0625, 0.0625, -0.0001), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(-0.0001, 0.0625, 0.0625), vec3(0.0, 0.0, 0.875), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(1.0001, 0.0625, 0.0625), vec3(0.0, 0.0, 0.875), vec3(0.0, 0.875, 0.0)),\n    face(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(0.0625, 0.0625, 1.0001), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(0.0625, 1.0001, 0.0625), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.0, 0.875)),\n    face(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)),\n    \n    //The grass ground\n    //This is just a plane that lies a the bottom of the scene\n    face(vec3(50.0, 0.0, 50.0), vec3(-100.0, 0.0, 0.0), vec3(0.0, 0.0, -100.0)),\n    \n    //The wood on the redstone torch\n    face(vec3(0.4375, 0.125, 0.0001), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.4375, 0.125, 0.0001), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.5625, 0.125, 0.0001), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.4375, 0.25, 0.1251), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.5, -0.5)),\n    \n    //The redstone on the redstone torch\n    face(vec3(0.4375, 0.625, -0.4999), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.625, -0.4999), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.5627, 0.625, -0.4999), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.75, -0.3749), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.75, -0.6249), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, 0.125)),\n    \n    //The redstone dust!\n    face(vec3(-1.25, 0.0001, 0.5625), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, -0.125)),\n    face(vec3(-1.25, 0.0001, 0.625), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, -0.0625)),\n    face(vec3(-1.25, 0.0001, 0.375), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, 0.0625)),\n    \n    //The redstone repeater\n    face(vec3(-1, 0, -1), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0, 0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0, -1), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(0, 0, -1), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0.125, -1), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)),\n    \n    //The wood on the repeater\n    face(vec3(-0.875, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.75, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.875, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.125, -0.4375), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    \n    //The redstone on the repeater\n    face(vec3(-0.875, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.75, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.875, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.3125, -0.4375), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.4375, -0.5625), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    face(vec3(-0.625, 0.1256, -0.5625), vec3(0.5, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    //The wood on the repeater\n    face(vec3(-0.25, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.125, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.25, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.125, -0.4375), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    \n    //The redstone on the repeater\n    face(vec3(-0.25, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.125, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.25, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.3125, -0.4375), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.4375, -0.5625), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    //More redstone dust\n    face(vec3(-1.25, 0.0001, 0.75), vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5)),\n    face(vec3(-1.25, 0.0001, -0.25), vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5)),\n    face(vec3(-1.4375, 0.0001, -0.25), vec3(-0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.5)),\n    face(vec3(-1.25, 0.0001, -0.4375), vec3(0.25, 0.0, 0.0), vec3(0.0, 0.0, -0.125))\n);\n\n//Each face gets a default color\nvec3 face_colors[NUM_FACES] = vec3[NUM_FACES](\n    //The smooth stone block\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    \n    //The grass ground\n    vec3(0.2, 0.4, 0.05),\n    \n    //The wood on the redstone torch\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the redstone torch\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //The redstone dust\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //The redstone repeater\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    vec3(0.4, 0.0, 0.0),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //More redstone dust\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0)\n);\n\n//Since I can't store the actual textures in the shader, I instead resort to adding the\n//\"roughness\" that you see in Minecraft's textures to try to make it look like the same\n//textures. I compensate by adding more faces when I need more detail\nconst vec3 material_variation[NUM_FACES] = vec3[NUM_FACES](\n    //The smooth stone block\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    \n    //The grass ground\n    vec3(0.2, 0.2, 0.2),\n    \n    //The wood on the redstone torch should only vary in \"brown-ness\"\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.25, 0.14, 0.0),\n    \n    //The redstone on the redstone torch\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //The redstone dust\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    \n    //The redstone repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    vec3(0.0, 0.0, 0.0),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //More redstone dust\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\n//This stores how many \"mc pixels\" across each face is\n//This will determine the resolution of the material variation\nconst vec2 texture_dims[NUM_FACES] = vec2[NUM_FACES](\n    //The smooth stone block\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    \n    //The grass ground\n    vec2(1600.0, 1600.0),\n    \n    //The wood on the redstone torch\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    \n    //The redstone on the redstone torch\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    //The redstone dust\n    vec2(20.0, 2.0),\n    vec2(20.0, 1.0),\n    vec2(20.0, 1.0),\n    \n    //The redstone repeater\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 16.0),\n    \n    //The wood on the redstone repeater\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    \n    //The redstone on the repeater\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    vec2(1.0, 1.0),\n    \n    //The wood on the redstone repeater\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    \n    //The redstone on the repeater\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    //More redstone dust\n    vec2(8.0, 8.0),\n    vec2(8.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(4.0, 2.0)\n);\n\n//This stores which materials are transparent to light\nconst bool material_transparent[NUM_FACES] = bool[NUM_FACES](\n    //The smooth stone block is not transparent\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    \n    //The grass is not transparent\n    false,\n    \n    //The wood on the redstone is not transparent\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the redstone torch is transparent (so we can put the light source inside)\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone dust\n    true,\n    true,\n    true,\n    \n    //The redstone repeater\n    false,\n    false,\n    false,\n    false,\n    false,\n    \n    //The wood on the redstone repeater\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the repeater\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    true,\n    \n    //The wood on the redstone repeater\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the repeater\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    //More redstone dust\n    true,\n    true,\n    true,\n    true\n);\n\n//The chance that a pixel of the block will be transparent\n//This is pretty much only for redstone dust (I might use this for particle effects later though)\nconst float material_pixel_invisible_chance[NUM_FACES] = float[NUM_FACES](\n    //The smooth stone block is not transparent\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The grass is not transparent\n    0.0,\n    \n    //The wood on the redstone is not transparent\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the redstone torch is transparent (so we can put the light source inside)\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone dust\n    0.5,\n    0.8,\n    0.8,\n    \n    //The redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The wood on the redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    0.0,\n    \n    //The wood on the redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //More redstone dust\n    0.5,\n    0.5,\n    0.6,\n    0.5\n);\n\n//The number of light sources\n#define NUM_LIGHT_SOURCES 4\n\n//This stores the different light source colors\nvec3 light_source_color[NUM_LIGHT_SOURCES] = vec3[NUM_LIGHT_SOURCES](\n    vec3(0.25, 0.03125, 0.03125),\n    vec3(2.0, 4.0, 4.0),\n    vec3(0.1, 0.0125, 0.0125),\n    vec3(0.1, 0.0125, 0.0125)\n);\n\n//This stores each light source position\nvec3 light_source_position[NUM_LIGHT_SOURCES] = vec3[NUM_LIGHT_SOURCES](\n    vec3(0.5, 0.775, -0.5),\n    vec3(-2.0, 4.0, 4.0),\n    vec3(-0.8125, 0.375, -0.5),\n    vec3(-0.1875, 0.375, -0.5)\n);\n\n//This stores whether each light source is active\nbool light_source_active[NUM_LIGHT_SOURCES] = bool[NUM_LIGHT_SOURCES](\n    true, true, true, true\n);\n\nray get_camera_ray(vec2 pixel){\n\tfloat least_side;\n\t\n\tpixel -= vec2(0.5);\n\tleast_side = min(iResolution.x, iResolution.y);\n\treturn ray(vec3(0), vec3(pixel.x*iResolution.x/least_side, pixel.y*iResolution.y/least_side, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 camera_orientation;\n    vec3 camera_position;\n    vec4 look_down;\n    ray camera_ray;\n    face f;\n    int face_num;\n    int texture_id;\n    vec3 intersect_pos;\n    vec2 face_coords;\n    float intersect_time;\n    float best_dist = 25.0;\n    vec3 face_pos;\n    vec3 face_color;\n    vec3 face_normal;\n    int face_intersect;\n    ray shadow_ray;\n    vec3 current_color;\n    vec3 emission;\n    int light_id;\n    float pix_x;\n    float pix_y;\n    vec2 texture_dim;\n        \n    camera_orientation = create_orientation(vec3(0.0, 1.0, 0.0), iTime/5.0 + 0.125);\n    look_down = create_orientation(vec3(1.0, 0.0, 0.0), 0.3);\n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    camera_ray.vec = apply_orientation(camera_ray.vec, look_down);\n    camera_ray.vec = apply_orientation(camera_ray.vec, camera_orientation);\n    camera_ray.p = apply_orientation(vec3(-0.25, 1.75, -2.875), camera_orientation);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for(face_num = 0; face_num < NUM_FACES; face_num++){\n        f = faces[face_num];\n        ray_face_intersect(f, camera_ray, intersect_time, face_coords, intersect_pos);\n        if(intersect_time > 0.0 && length(intersect_pos - camera_ray.p) < best_dist && face_coords.x > 0.0 && face_coords.x < 1.0 && face_coords.y > 0.0 && face_coords.y < 1.0){\n            texture_dim = texture_dims[face_num];\n            pix_x = floor(face_coords.x*texture_dim.x);\n            pix_y = floor(face_coords.y*texture_dim.y);\n            if(material_pixel_invisible_chance[face_num] > hash((pix_x + 4.0 + 2.0*float(face_num))*(pix_y + 1.0 + float(face_num))))\n                continue;\n            best_dist = length(intersect_pos - camera_ray.p);\n            face_pos = intersect_pos;\n            face_color = face_colors[face_num] + material_variation[face_num]*hash(pix_x + 16.0*pix_y);\n            face_intersect = face_num;\n            face_normal = normalize(cross(f.side0, f.side1));\n        }\n    }\n    \n    if(best_dist != 25.0){\n        current_color = vec3(1.0/dot(face_pos - camera_ray.p, face_pos - camera_ray.p))*face_color;\n        light_source_active[0] = mod(iTime, 1.0) < 0.5;\n        light_source_active[2] = mod(iTime - 0.4, 1.0) < 0.5;\n        light_source_active[3] = mod(iTime - 0.4, 1.0) < 0.5;\n        if(mod(iTime, 1.0) < 0.5 && face_intersect >= 15 && face_intersect <= 19)\n            current_color += 2.0*face_color;\n        if(mod(iTime - 0.4, 1.0) < 0.5 && ((face_intersect >= 32 && face_intersect <= 36) || (face_intersect >= 20 && face_intersect <= 22) || face_intersect >= 42))\n            current_color += 2.0*face_color;\n        for(light_id = 0; light_id < NUM_LIGHT_SOURCES; light_id++){\n            if(!light_source_active[light_id])\n                continue;\n            if(light_id == 0 && face_intersect >= 15 && face_intersect <= 19)\n                continue;\n            if(light_id == 2 && face_intersect >= 32 && face_intersect <= 36)\n                continue;\n            if(light_id == 3 && face_intersect >= 42 && face_intersect <= 46)\n                continue;\n            shadow_ray = ray(face_pos, light_source_position[light_id] - face_pos);\n            for(face_num = 0; face_num < NUM_FACES; face_num++){\n                if(material_transparent[face_num] || face_num == face_intersect)\n                    continue;\n                f = faces[face_num];\n                ray_face_intersect(f, shadow_ray, intersect_time, face_coords, intersect_pos);\n                if(intersect_time > 0.0 && intersect_time < 1.0 && face_coords.x > 0.0 && face_coords.x < 1.0 && face_coords.y > 0.0 && face_coords.y < 1.0)\n                    break;\n            }\n            if(face_num == NUM_FACES)\n                current_color += light_source_color[light_id]*vec3(abs(dot(face_normal, shadow_ray.vec))/(length(shadow_ray.vec)*dot(shadow_ray.vec, shadow_ray.vec)))*face_color;\n        }\n        fragColor = vec4(current_color, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}