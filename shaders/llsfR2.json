{
    "Shader": {
        "info": {
            "date": "1512577036",
            "description": "generate a distance field out of geometry. also see [url]https://shaderoo.org[/url]\nnot very useful here, but the version on shaderoo can be used to convert normal gl-geometry to distfields.\nsigned-df only works with smooth normals for now.",
            "flags": 32,
            "hasliked": 0,
            "id": "llsfR2",
            "likes": 46,
            "name": "generate distance field",
            "published": 3,
            "tags": [
                "distancefield",
                "volumetric",
                "geometry"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 1732
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// generate a distance field out of geometry. also see https://shaderoo.org\n// i used my medusa geometry from https://www.shaderoo.org/?shader=ri47GG \n// for demonstration purpose.\n// not very useful here, but the version on shaderoo can be used to convert normal \n// gl-geometry to distfields.\n// if you have smooth normals, you can even make a signed-df\n\n// go into the lower left corner to only show th distance field without the rendering\n\n\nvec3 getDistRes() { return vec3(floor(pow(iResolution.x*iResolution.y,.33)-1.)); }\n\n\nfloat distTiled(vec3 pos)\n{\n    ivec3 res=ivec3(getDistRes());\n    pos=pos*.5+.5;\n    int z1=int(floor(pos.z*float(res.z)));\n    int z2=int(ceil(pos.z*float(res.z)));\n    float fr=fract(pos.z*float(res.z));\n    int xnum=int(iResolution.x)/res.x;\n    vec2 t1=vec2(res.x*(z1%xnum),res.y*(z1/xnum))+pos.xy*float(res.xy);\n    vec2 t2=vec2(res.x*(z2%xnum),res.y*(z2/xnum))+pos.xy*float(res.xy);\n    t1/=iResolution.xy;\n    t2/=iResolution.xy;\n    return mix(texture(iChannel0,t1).x,texture(iChannel0,t2).x,fr);\n}\n\n#define FloorZ -.75\nvec2 mdist(vec3 pos)\n{\n    float m=1.;\n    vec3 tpos=clamp(pos,-.95,.95);\n    float d=(distTiled(tpos)-.02);\n    d+=length(tpos-pos)*.5;\n    float dp=d;\n    d=min(d,pos.z-FloorZ);\n    if (d<dp) m=2.;\n    \n    return vec2(d,m);\n}\n\nfloat dist(vec3 pos)\n{\n    return mdist(pos).x;\n}\n\n#define PI2 6.2832\n#define LNUM 5\n\nvec3 getGrad(vec3 p)\n{\n    float eps=1./64.;\n    vec3 d = vec3(eps,0,0);\n    return vec3(\n        dist(p+d.xyz)-dist(p-d.xyz),\n        dist(p+d.zxy)-dist(p-d.zxy),\n        dist(p+d.yzx)-dist(p-d.yzx)\n        )/eps;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec3 refl(vec3 dir)\n{\n    return mix(vec3(.2,.3,.4),vec3(.7,.85,1)*1.5,clamp(dir.z*3.+.5,0.,1.));\n\t//return texture(iChannel0,dir.yzx).zyx*1.2+.1;\n}\n\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float rval=0.0;\n    float R = 1.01;\n    float d0=length(pos);\n\n    // do some bounding check for better performance\n    bool inside = false;\n    // bounding sphere\n    vec3 pn = pos-dir*dot(pos,dir);\n    float d=length(pn);\n    inside = inside || (d<R);\n    inside=true;\n    if(!inside) return 0.0;\n    \n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n       \tfloat d=dist(pos);\n        if(d<eps) { rval=mdist(pos).y; break; }\n        if(d>d0+R) { rval=0.0; break; }\n        pos+=dir*d*1.;\n    }\n    return rval;\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel1,coord+.003*iTime);\n    c+=texture(iChannel1,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel1,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel1,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n// envoronment just a sky and some floor grid...\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    vec3 colHor=vec3(.3,.4,.5)+.25;\n    vec3 colSky=mix(vec3(1.5,.75,0.)*1.7,vec3(.8,.9,1)*1.2,clamp(7.*dir.z,0.,1.));\n    vec3 skyPos=pos+dir/abs(dir.z)*(20.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.001).x-.5));\n    colSky*=mix(1.,cloudPat,step(0.,dir.z));\n    vec3 colFloor=vec3(.3,.4,.5);\n    vec3 colScale=vec3(1,1,1);\n    vec3 floorPos=pos-dir/dir.z*(pos.z-FloorZ);\n    vec2 s;\n    float scale=1.;\n    s=sin(floorPos.xy*PI2*.5*period);\n    scale*=(1.-.3*exp(-s.x*s.x/.01))*(1.-.3*exp(-s.y*s.y/.01));\n    s=sin(floorPos.xy*PI2*.5/10.*period);\n    scale*=(1.-.5*exp(-s.x*s.x/.001))*(1.-.5*exp(-s.y*s.y/.001));\n    colFloor=mix(colFloor,colScale,1.-scale)*(1.+.4*(getRand(floorPos.xy*.001).x-.5));\n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*6.)-.1,0.,1.));\n    return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c1=texture(iChannel0,fragCoord/iResolution.xy);\n \tvec3 pos = vec3(0,0,2.5*(1.2/*-iMouseData.z/1000.*/));\n \tvec3 dir = normalize(vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x,-1.));\n    vec2 ang=PI2*(iMouse.xy/iResolution.xy*vec2(-1,.3)-vec2(0,.02));\n    if(iMouse.x==0. && iMouse.y==0.) ang = vec2(-2.4-.7+.3*iTime,1.4);\n    vec4 q = vec4(0,0,0,1);\n    q = multQuat(q,axAng2Quat(vec3(0,0,1),ang.x));\n    q = multQuat(q,axAng2Quat(vec3(1,0,0),ang.y));\n    pos=transformVecByQuat(pos,q);\n   \tdir=transformVecByQuat(dir,q);\n   \tvec3 camDir=transformVecByQuat(vec3(0,0,-1),q);\n   \tvec3 camPos=pos;\n    float m = march(pos,dir);\n    vec3 n = normalize(getGrad(pos));\n    \n    vec3 bg=mix(vec3(1),vec3(.3,.3,1),length(fragCoord.xy-.5*iResolution.xy)/iResolution.x);\n    \n    float fres=abs(dot(dir,n));\n    fres=1.-fres;\n    //fres*=fres;\n    fres=.1+.9*fres;\n    vec3 col=vec3(.75,.8,.85); // material color of distfield\n    if(int(m+.1)!=1) col=vec3(1);  // set to 1 if bg or floor\n    if(int(m+.1)==1) col*=1.-fres;\n    if(int(m+.1)==1) col+=.9*fres*myenv(pos,reflect(dir,n),10.).xyz;\n    col=.1+col*.9;\n    \n    bg=myenv(pos,dir,10.).xyz;\n    if(   fragCoord.x<.3*iResolution.x \n       && fragCoord.y<.3*iResolution.y) bg=texture(iChannel0,fragCoord/iResolution.xy/.3).xyz;\n       \n    // calc ao by stepping along normal\n    float ao=1.;\n    ao*=.2+.8*dist(pos+n.xyz*.12)/.12;\n    ao*=.4+.6*dist(pos+n.xyz*.25)/.25;\n    ao*=.6+.4*dist(pos+n.xyz*.5)/.5;\n    \n    //ao=-dist(pos-n.xyz*.02)/.02;\n    //col+=clamp(1.-ao,0.,1.);\n    \n    float vign = (1.1-.2*dot((fragCoord.xy/iResolution.xy)*2.-1.,(fragCoord.xy/iResolution.xy)*2.-1.));    \n    fragColor.xyz=col;\n    fragColor.xyz=mix(bg,col,(m!=1.)?0.:1.);\n    fragColor.xyz*=clamp(ao*.7+.3,0.,1.);\n    fragColor.w=1.;\n    if(iMouse.x<.3*iResolution.x && iMouse.y<.3*iResolution.y && iMouse.x>1.) fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n    //fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 getDistRes() { return vec3(floor(pow(iResolution.x*iResolution.y,.33)-1.)); }\n\n//####################################################################\n//## medusa geometry from https://www.shaderoo.org/?shader=ri47GG   ##\n\n#define G (.5+sqrt(5./4.))\n#ifndef PI2\n#define PI2 (3.141592653*2.)\n#endif\n#define PI 3.141592653\n\n// noise funcs by Morgan McGuireâ€¨https://www.shadertoy.com/view/4dS3Wd\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec4 noise4(vec2 x) {\n    return vec4(\n        noise(x+vec2(0,0)),\n        noise(x+vec2(0,.333)),\n        noise(x+vec2(.333,0)),\n        noise(x+vec2(0,.666))\n    );\n}\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=noise4(pos.xy*256.)*2.-1.;\n    r*=noise4(pos.xz)*2.-1.;\n    r*=noise4(pos.zy)*2.-1.;\n    return r;\n}\n\nvec4 getRand01Sph(vec3 pos)\n{\n    vec2 res = iResolution.xy;\n    vec2 texc=((pos.xy*123.+pos.z)*res+.5)/res;\n    return vec4(noise(texc*256.));\n}\n\nconst vec4 p0 = vec4( 1, G, -G ,0 )/length(vec2(1,G));\n\nvec3 icosaPosRaw[12] = vec3[] (\n    -p0.xwz,  p0.xwy, -p0.xwy,  p0.xwz,\n     p0.wyx, -p0.wzx,  p0.wzx, -p0.wyx,\n     p0.yxw,  p0.zxw, -p0.zxw, -p0.yxw\n);\n\nint posIdx[60] = int[](\n0,  6, 1,\n0, 11, 6,\n1,  4, 0,\n1,  8, 4,\n1, 10, 8,\n2,  5, 3,\n2,  9, 5,\n2, 11, 9,\n3,  7, 2,\n3, 10, 7,\n4,  8, 5,\n4,  9, 0,\n5,  8, 3,\n5,  9, 4,\n6, 10, 1,\n6, 11, 7,\n7, 10, 6,\n7, 11, 2,\n8, 10, 3,\n9, 11, 0\n);\n\n// get icosahedron triangle\nvoid getIcosaTri(int idx, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    float dot1 = -1000.0;\n    float dot2 = -1000.0;\n    float dot3 = -1000.0;\n    int s1, s2, perm;\n\n    int i1 = posIdx[idx*3+0];\n    int i2 = posIdx[idx*3+1];\n    int i3 = posIdx[idx*3+2];\n\n    p1=icosaPosRaw[i1];\n    p2=icosaPosRaw[i2];\n    p3=icosaPosRaw[i3];\n}\n\n\n// subdivide 1 triangle into 4 triangles and give back closest triangle\nvoid getTriSubDiv(int idx, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    vec3 p4 = normalize(p1+p2);\n    vec3 p5 = normalize(p2+p3);\n    vec3 p6 = normalize(p3+p1);\n\n    if     (idx==0) { p1=p1; p2=p4; p3=p6; }\n    else if(idx==1) { p1=p6; p2=p5; p3=p3; }\n    else if(idx==2) { p1=p6; p2=p4; p3=p5; }\n    else if(idx==3) { p1=p4; p2=p2; p3=p5; }\n}\n\n\nint triStripIndex [6] = int [] (0,1,2,1,3,2);\n\n#define mixSq(a,b,f) mix(a,b,cos(f*PI)*.5+.5)\n\n//float homFact(float f) { return cos(f*PI)*.5+.5; }\n//float homFact(float f) { return f<.5?f*f*2.:1.-(f-1.)*(f-1.)*2.; }\nfloat homFact(float f) { f-=.5; return .5+(f-.9/.75*f*f*f)/(1.-.9/3.); }\n\nvoid geomTangentCurve(vec3 pos1, vec3 pos2, vec3 tan1, vec3 tan2, float r1, float r2, \n                      int rSegNum, int tSegNum, int vIdx, out vec3 pos, out vec3 normal)\n{\n    float l = length(pos1-pos2);\n    l*=.4;\n    int i=(vIdx/3/2)%tSegNum;\n    //{  // converted some loops into proper vertex index values\n        float fact, fact2;\n        fact=max(0.,homFact(float(i)/float(tSegNum))); // force >=0 because of sqrt below\n        vec3 p1=mix(pos1+tan1*l*sqrt(fact ),pos2-tan2*l*sqrt(1.-fact ),fact );\n        fact2=max(0.,homFact(float(i+1)/float(tSegNum))); // force >=0 because of sqrt below\n        vec3 p2=mix(pos1+tan1*l*sqrt(fact2),pos2-tan2*l*sqrt(1.-fact2),fact2);\n\n        vec3 ta = mix(tan1,tan2,fact);\n        vec3 tn = mix(tan1,tan2,fact2);\n\n        float dph=PI*2./float(rSegNum);\n        //vec3 b1=normalize(vec3(ta.x,-ta.y,0));\n        vec3 b1=normalize(cross(ta,p1));\n        vec3 b2=normalize(cross(ta,b1));\n        //vec3 b3=normalize(vec3(tn.x,-tn.y,0));\n        vec3 b3=normalize(cross(tn,p2));\n        vec3 b4=normalize(cross(tn,b3));\n        float r_1 = mix(r1,r2,fact);\n        float r_2 = mix(r1,r2,fact2);\n        int j=(vIdx/3/2/tSegNum)%rSegNum;\n        //{\n            float ph  = float(j)*dph;\n            float ph2 = ph+dph;\n            vec3 v1 = p1+r_1*(b1*cos(ph )+b2*sin(ph ));\n            vec3 v2 = p1+r_1*(b1*cos(ph2)+b2*sin(ph2));\n            vec3 v3 = p2+r_2*(b3*cos(ph )+b4*sin(ph ));\n            vec3 v4 = p2+r_2*(b3*cos(ph2)+b4*sin(ph2));\n            vec3 v[4] = vec3[](v1,v2,v3,v4);\n            pos = v[triStripIndex[vIdx%6]];\n            normal = normalize(cross(v[1]-v[0],v[2]-v[0]));\n        //}\n    //}\n}\n\nfloat calcAngle(vec3 v1, vec3 v2)\n{\n    return acos(dot(v1,v2)/length(v1)/length(v2));\n}\n\n// distance to 2 torus segments in a triangle\n// each torus segment spans from the middle of one side to the middle of another side\nvoid geomTruchet(vec3 p1, vec3 p2, vec3 p3, float dz, int rSegNum, int tSegNum, int trNum, \n                 float radius, int idx, out vec3 pos, out vec3 normal )\n{\n    if (radius<0.0) radius=.45*dz;\n    float d = 10000.0;\n    float rnd =getRand01Sph(p1+p2+p3).x;\n    float rnd2=getRand01Sph(p1+p2+p3).y;\n    // random rotation of torus-start-edges\n    if      (rnd>.75) { vec3 d=p1; p1=p2; p2=d; }\n    else if (rnd>.50) { vec3 d=p1; p1=p3; p3=d; }\n    else if (rnd>.25) { vec3 d=p2; p2=p3; p3=d; }\n    \n    vec3 p4 = p1*(1.f-dz);\n    vec3 p5 = p2*(1.f-dz);\n    vec3 p6 = p3*(1.f-dz);\n\n    // FIXME: why is this necessary - very seldom actually!?\n    bool xchg=false;\n    if(dot(cross(p2-p1,p3-p1),p1)>0.0) {\n        vec3 dummy;\n        dummy=p2; p2=p3; p3=dummy;\n        dummy=p5; p5=p6; p6=dummy;\n        xchg=true;\n    }\n\n    float lp1 = length(p1);\n    float lp4 = length(p4);\n    \n    float r,r1,r2,fact,ang,fullAng;\n    vec3 n = normalize(cross(p2-p1,p3-p1));\n\n    // torus segments:\n    // actually i have to fade from one torus into another\n    // because not all triangles are equilateral\n    vec3 m;\n//    std::vector <vec3> p;\n    vec3 v1,v2,v3,v4,v5,v6;\n    int tubeNum=rSegNum*tSegNum*2*3;\n    int i=(idx/(tubeNum))%trNum;\n    {\n        if(i==0) { v1=p1; v2=p2; v3=p3; v4=p4; v5=p5; v6=p6; }\n        if(i==1) { v1=p2; v2=p3; v3=p1; v4=p5; v5=p6; v6=p4; }\n        if(i==2) { v1=p3; v2=p1; v3=p2; v4=p6; v5=p4; v6=p5; }\n        //if(dot(cross(v2-v1,v3-v1),v1)>0.0) { vec3 dummy=v2; v2=v3; v3=dummy; }\n        //if(dot(cross(v5-v4,v6-v4),v4)>0.0) { vec3 dummy=v5; v5=v6; v6=dummy; }\n\n    \tfullAng = calcAngle(v3-v1,v2-v1);\n        //ang = calcAngle(pos2-v1,v2-v1);\n        float dang=fullAng/float(tSegNum);\n        //if (fullAng<.001) break;\n\n        //float r1, r2;\n        //r1=length(v2-v1)*.5f; r1=length(v3-v1)*.5f;\n        vec3 pos1, pos2;\n        pos1 = lp1*normalize(v2+v1); pos2 = lp4*normalize(v6+v4);\n        // FIXME: why is this necessary - very seldom actually!? - see above\n        if(xchg) {\n            pos1 = lp1*normalize(v5+v4); pos2 = lp4*normalize(v3+v1);\n        }\n        if(rnd2>.25)\n        {\n            if(i==0) { pos1 = lp4*normalize(v5+v4); pos2 = lp4*normalize(v6+v4); }\n            if(i==1) { pos1 = lp1*normalize(v2+v1); pos2 = lp1*normalize(v3+v1); }\n        }\n        vec3 tan1 = normalize(cross(v2-v1,v1));\n        vec3 tan2 = normalize(cross(v3-v1,v1));\n        geomTangentCurve(pos1,pos2,tan1,tan2,radius,radius,rSegNum,tSegNum,\n                         idx%tubeNum,pos,normal);\n    }\n}\n\n// final shape\nvoid geom_medusa(int rNum, int tNum, int subdiv, int idx, out vec3 pos, out vec3 normal)\n{\n    vec3 p1,p2,p3;\n\n    int icosaFaceNum = 20;\n    int subDivNum = 4;\n    \n    int trNum = 3; // tubes per truchet segemnt\n    int truchetNum=rNum*tNum*2*3*trNum; // 2 triangles * 3 vertices * trNum tubes\n    \n    //for(int i1=0;i1<icosaFaceNum;i1++)\n    int idiv=truchetNum; for(int i=0;i<subdiv;i++) idiv*=subDivNum;\n    getIcosaTri(idx/idiv, p1, p2, p3);\n    int p_subDivNum_i = 1;\n    for(int i=0;i<subdiv;i++)\n    {\n        idiv/=subDivNum;\n        int isub = (idx/idiv)%subDivNum;\n        getTriSubDiv(isub,p1,p2,p3);\n        p_subDivNum_i*=subDivNum;\n    }\n    geomTruchet(p1,p2,p3,0.12/float(1+subdiv),rNum,tNum,trNum,-1.,idx%truchetNum,pos,normal);\n    pos=(idx>icosaFaceNum*truchetNum*p_subDivNum_i)?vec3(0):pos;\n    normal=(idx>icosaFaceNum*truchetNum*p_subDivNum_i)?vec3(0):normal;\n}\n\n//## end - medusa geom\n//####################################################################\n\n// this geometry will be converted to a distance field\n#define TriNum 0x2000\nvoid geometry( out vec3 pos, int vertIndex )\n{\n    /*pos = vec3(0);\n    float l=float(vertIndex)*.01;\n    pos = .5*(.97+.03*float(vertIndex%2))\n          *sin(vec3(0,1.6,.707)+l*vec3(1,3,2)+iTime);*/\n\n    vec3 normal;\n    \n    //torusGeom( pos, normal, vertIndex%TorusVertNum );\n    \n    geom_medusa(4,16,0,vertIndex,pos,normal); pos*=.7;\n    \n    //pos=pos.yzx;\n}\n\nvec2 triangleCoord( vec3 v2, vec3 v0, vec3 v1 )\n{\n    float dot00=dot(v0,v0);\n    float dot01=dot(v0,v1);\n    float dot02=dot(v0,v2);\n    float dot11=dot(v1,v1);\n    float dot12=dot(v1,v2);\n    float denom = dot00*dot11-dot01*dot01;\n    if(denom<0.00001) return vec2(-1,-1);\n    vec2  rval;\n    rval.x = (dot11 * dot02 - dot01 * dot12) / denom;\n    rval.y = (dot00 * dot12 - dot01 * dot02) / denom;\n    return rval;\n}\n\n// checks if a vertex lies within a certain triangle\nbool inTriangle( vec3 pos, vec3 v1, vec3 v2, vec3 v3 )\n{\n    vec2 tc=triangleCoord( pos-v1, v2-v1, v3-v1 );\n    return ( (tc.x>0.0f) && (tc.y>0.0f) && (tc.x+tc.y<1.0f) );\n}\n\n// returns actual distance to line in .y and on-line-parameter on .x 0->pos=0, 1->pos=v (>1 or <0 means off line)\nvec2 calcLineDist(vec3 pos, vec3 v)\n{\n    vec2 rval;\n    rval.x = dot(pos,v)/dot(v,v);\n    rval.y = length(pos-rval.x*v);\n    return rval;\n}\n\n// calculates the closest-distance-point to triangle v1,v2,v3 (in weights of the edge points)\nvec3 calcDistPoint( vec3 pos, vec3 v1, vec3 v2, vec3 v3 )\n{\n    bool found = false;\n    float dist = 1024.0;\n\n    vec3 m = vec3(1,0,0);\n    vec3 m1 = m.xyz;\n    vec3 m2 = m.zxy;\n    vec3 m3 = m.yzx;\n\n    vec3 distpos;\n#if 1\n    // triangle (normal distance to plane)\n    vec2 tc=triangleCoord( pos-v1, v2-v1, v3-v1 );\n    if ( (tc.x>0.0f) && (tc.y>0.0f) && (tc.x+tc.y<1.0f) ) // check if normal-dist point is within triangle\n    {\n        distpos=tc.x*(m2-m1)+tc.y*(m3-m1)+m1;\n        found = true;\n    }\n    if(found) return distpos;\n\n    // edges (normal distance to line)\n    vec2 linedist;\n    linedist=calcLineDist(pos-v1,v2-v1); if( linedist.x>0.0 && linedist.x<1.0 && linedist.y<dist ) { dist=linedist.y; distpos=mix(m1,m2,linedist.x); found=true; }\n    linedist=calcLineDist(pos-v2,v3-v2); if( linedist.x>0.0 && linedist.x<1.0 && linedist.y<dist ) { dist=linedist.y; distpos=mix(m2,m3,linedist.x); found=true; }\n    linedist=calcLineDist(pos-v3,v1-v3); if( linedist.x>0.0 && linedist.x<1.0 && linedist.y<dist ) { dist=linedist.y; distpos=mix(m3,m1,linedist.x); found=true; }\n    if(found) return distpos;\n#endif\n    // points (distance to edge-point)\n    float actdist;\n    actdist=length(pos-v1); if(actdist<dist) { dist=actdist; distpos=m1; found=true; }\n    actdist=length(pos-v2); if(actdist<dist) { dist=actdist; distpos=m2; found=true; }\n    actdist=length(pos-v3); if(actdist<dist) { dist=actdist; distpos=m3; found=true; }\n    if(found) return distpos;\n\n    return vec3(1,0,0);\n}\n\nfloat calcDist( vec3 pos, vec3 p1, vec3 p2, vec3 p3, vec3 n1, vec3 n2, vec3 n3, out vec3 d, out vec3 n )\n{\n    vec3 m = calcDistPoint(pos,p1,p2,p3);\n    d = m.x*p1 + m.y*p2 + m.z*p3;\n    n = m.x*n1 + m.y*n2 + m.z*n3;\n    return length(pos-d);\n}\n\n// maked it a Signed Distance Field (works only with smooth normals for now)\nuniform float signedField;\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    #define TrisAtOnce 16\n    for(int i=0;i<TrisAtOnce;i++)\n    {\n    int frame=iFrame-((iResolution.x<400.)?1:60);\n    int tri=frame*TrisAtOnce+i;\n    if(tri>=TriNum) return;\n    // the X/Y/Z-size of the 3d distance field (normally 3D-texture but here tiled in 2D)\n    vec3 size = getDistRes();\n    // return big distance if invalid triangle index (or init);\n    if(frame<0) { fragColor=vec4(20,20,20,1); return; }\n    \n    // get the triangle\n    vec3 p1,p2,p3;\n    geometry(p1,int(tri)*3+0);\n    geometry(p2,int(tri)*3+1);\n    geometry(p3,int(tri)*3+2);\n    \n    // dont take 0-triangles into account\n    if(p1==p2 || p1==p3 || p2==p3) { return; }\n    \n    // get the xyz texcoord in the 3d-texture for our actual fragment\n    vec2 fbSize = iResolution.xy;\n    vec2 gridSize = floor(fbSize/floor(size.xy));\n    vec2 gridPos = floor(fragCoord.xy/floor(size.xy));\n    // the texcoord\n    vec3 pos01 = vec3(mod(fragCoord.xy,floor(size.xy)), gridPos.x+gridPos.y*gridSize.x)/floor(size);\n\n    vec3 pos = pos01*2.0-vec3(1.0); // texcoord -> pos\n    vec3 dpos;\n    vec3 dnorm;\n    vec3 n=normalize(cross(p2-p1,p3-p1));\n    // get the distance\n    float d = calcDist(pos, p1,p2,p3, n,n,n, dpos, dnorm);\n    // negative for SDF if pos in -normal direction\n    if(signedField>0.5 && dot(pos-dpos,dnorm)<0.0) d=-d;\n\n    if (isinf(d)) d=2.;\n    if (isnan(d)) d=2.;\n    //if (d==0.)    d=2.;\n    \n    vec3 col = (d<0.0) ? vec3(1,-1,-1) : vec3(1); // red is truely signed, green and blue hold unsigned distfield\n    // mask invalid screen regions (give them some blue-ish bg color)\n    if(gridPos.x>=gridSize.x || pos01.z>1.) { d=2.; col=vec3(0,.15,.3); }\n    \n    // write final fragment distance * col\n    fragColor = (d<fragColor.x)?vec4(d*col,1):fragColor;\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}