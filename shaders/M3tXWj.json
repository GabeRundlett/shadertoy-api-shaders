{
    "Shader": {
        "info": {
            "date": "1719884094",
            "description": "Distort space around the SDFs for more interest.\nSDFs tell marching something is there, but when you get there, it is somewhere else.\nContinued from https://www.shadertoy.com/view/433XD7\nThe little man is different.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3tXWj",
            "likes": 6,
            "name": "Odd SDFs",
            "published": 3,
            "tags": [
                "sdf",
                "experiment"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 167
        },
        "renderpass": [
            {
                "code": "/* Continuing https://www.shadertoy.com/view/433XD7   ...\nSome of these SDFs tell marching something is there, but when you get there, the object is somewhere else.\nGoals: Stranger shapes from SDFs without complicated code.\nTheory: SDFs returning closer non-zero distances can still render okay but marching will be slower.\nSDF can also return an efficient approximate distance when far enough that no real SDF calculation is needed.\nMaybe the combination of the above 3 can result in a performant interesting simple solution.\n*/\n\n//#define SHOW_MARCHING_ISSUES  // run out of steps\n\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\nfloat xTime;\nvoid IniTime() {\n    xTime = min( iTime, float(iFrame) / 10. ); // slow time on slower hardware\n}\n#define iTime xTime\n\n\n#define max3(V) max((V).x,max((V).y,(V).z))\n#define min3(V) min((V).x,min((V).y,(V).z))\n#define add3(V) ((V).x+(V).y+(V).z)\n\n#define MIN3(a,b,c) min(min(a,b),c)\n#define MIN4(a,b,c,d) min(min(a,b),min(c,d))\n#define MIN5(a,b,c,d,e) min(min(a,b),min(c,min(d,e)))\n\n#define MAX3(a,b,c) max(max(a,b),c)\n#define MAX4(A,B,C,D) max(max(A,B),max(C,D))\n#define MAX6(A,B,C,D,E,F) max(max(max(A,B),max(C,D)),max(E,F))\n\n\n#define OSC(L,H,T) ( ( sin(T) + 1. ) / 2. * ( (H) - (L) ) + (L) )\n\n#define MARGIN .1\n\n#define ROTT(V,T) vec2( (V).x*cos(T) + (V).y*sin(T), (V).y*cos(T) - (V).x*sin(T) )\n\n#define ROTATE \\\n    rot *= iTime*1.5; \\\n    /*p.xz = ROTT((p.xz),rot.z);*/ \\\n    p.xy = ROTT((p.xy),rot.x); \\\n    p.yz = ROTT((p.yz),rot.y); \\\n    \n//#define ROTATE   // no rotation\n\n\n// originally iq sdf of orthogonal box at 0 https://www.shadertoy.com/view/Xds3zN\nfloat SkewedBoxSDF(vec3 p,vec3 orig,vec3 box,vec3 rot)\n{\n    p -= orig;\n    ROTATE\n    p.x -= .5*p.y; // mess it up a ittle\n    vec3 d = abs(p) - box; // everything is symmetrical so just 3 sides need examination\n    return min(max3(d),.0) + length(max(d,.0));\n}\n\n// originally https://www.shadertoy.com/view/MtV3Dy but I simplified it\nfloat tetrahedron(vec3 p,float d) {\n    float sd1 = -p.x + p.y + p.z;\n    float sd2 =  p.x - p.y + p.z;\n    float sd3 =  p.x + p.y - p.z;\n    float sd4 = -p.x - p.y - p.z;\n    return (MAX4(sd1,sd2,sd3,sd4) - d)/sqrt(3.);\n}\n\n/*\nfloat TetrahedronSDF(vec3 p,vec3 orig,float d,vec3 rot) {\n    p -= orig;\n    //p.yx *= 1.+p.z/5.;\n    ROTATE\n    return tetrahedron(p,d);\n}\n*/\n\nfloat OctahedronSDF(vec3 p,vec3 orig,float d,vec3 rot) {\n    p -= orig;\n    float q = length(p) - d / 3.;\n    if ( q < 1. ) return q;\n    ROTATE\n    //The octahedron is the intersection of two dual tetrahedra.  \n    float a = tetrahedron(p,d);\n    float b = tetrahedron(-p,d);\n    return max(a,b);\n}\n\n// also originally https://www.shadertoy.com/view/MtV3Dy \n//Golden mean and inverse -  for the icosohedron and dodecadron\n#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\nfloat DodecahedronSDF(vec3 p,float d,vec3 orig,vec3 rot) {\n    p -= orig;\n    float q = length(p) - d;\n    if (q > 2.) return q-1.; // if a bit outside, indicate outside\n \n    if ( q < OSC(d/4.,-.2,iTime) ) // amount of outside\n       return q+d/3.; // sphere size\n\n    ROTATE\n    \n    vec3 v = normalize(vec3(0.0,1.0,PHI));\n    vec3 w = normalize(vec3(0.0,1.0,-PHI));\n    \n    p = abs(p);\n    \n    // v.x=w.x=0;  v.y=w.y=.525731;  w.z=-v.z=.85065074\n    \n    //float d1x = 0.; //p.x*v.x - d*v.x*v.x;\n    float d1y = p.y*v.y - d*v.y*v.y;\n    float d1z = p.z*v.z - d*v.z*v.z;\n    float d1 = d1y + d1z; // dot(p-d*v,v);  \n\n    //float d2x = 0.; //p.x*v.x - d*v.x*v.x;\n    float d2y = p.y*w.y - d*w.y*w.y;\n    float d2z = p.z*w.z - d*w.z*w.z;\n    float d2 =  d2y + d2z; // dot(p-d*w,w);\n    \n    float d3x = p.x*v.z - d*v.z*v.z;\n    //float d3y = 0.; // p.y*v.x - d*v.x*v.x;\n    float d3z = p.z*v.y - d*v.y*v.y;\n    float d3 =  d3x + d3z; // dot(p-d*v.zxy,v.zxy);\n    // Didn't finish checking for simplifications ...\n  /*  \n    float d4x = p.x*v.y - d*v.y*v.y;\n    float d4y = p.y*v.z - d*v.z*v.z;\n    float d4z = p.z*v.z - d*v.x.z*v.x;  */\n    float d4 = dot(p-d*v.yzx,v.yzx);\n    float d5 = dot(p-d*w.zxy,w.zxy);\n    float d6 = dot(p-d*w.yzx,w.yzx);\n    float ds = MAX6(d1,d2,d3,d4,d5,d6);\n    return ds;\n} \n\nfloat SpherexSDF(vec3 p,vec3 orig,float siz) {\n    p.x -= 10. / p.y; // distort\n    return distance(p,orig) - siz;\n}\n\nfloat Octahedron2SDF(vec3 p,vec3 orig,float siz,vec3 dist,vec3 rot) {\n    p -= orig;\n    ROTATE\n    p = abs(p);\n    p *= dist; // distort\n    return sqrt( add3(p) ) - sqrt(siz); // stumbled on this one\n}\n\nfloat SpikeySDF(vec3 p,vec3 orig,float siz,vec3 spikes,vec3 rot) {\n    p -= orig;\n    // enclosing sphere for quick elimination of intersection:\n    float j = length(p) - siz*4.; // sdf for enclosing sphere\n    if (j > .2) return j-.1; // if a bit outside sphere, indicate outside of sphere\n    ROTATE\n    p = abs(p);\n    return sqrt(\n      pow( p.x, spikes.x ) + \n      pow( p.y, spikes.y ) + \n      pow( p.z, spikes.z ) \n    ) - siz/3.;\n}\n\n// this came out interesting\nfloat CubexSDF(vec3 p,vec3 org,float siz,vec3 dist,vec3 rot){\n    p -= org;\n    float lim=.35;\n    float amt=.16;\n    // enclosing box for quick elimination of intersection:\n    float j = max3(abs(p)) - siz/amt; // sdf for enclosing box\n    if (j > .2) return j+.1; // if a bit outside box, indicate outside of box\n    ROTATE\n    p = abs(p);\n    //p *= dist\n    vec3 q = p;\n    q.x *= max(lim,1.-(p.y+p.z)*amt);\n    q.y *= max(lim,1.-(p.x+p.z)*amt);\n    q.z *= max(lim,1.-(p.y+p.x)*amt);\n    return max3(q) - siz;\n}\n\nfloat DogSDF(vec3 p,vec3 orig,vec3 siz,vec3 rot) { // woof\n    p -= orig;\n    ROTATE\n    p *= siz; // mix it up\n    return length(p)-1.;\n}\n\n#define BOX(PTminORIG,SIZ) MAX3( \\\n  abs( (PTminORIG).x ) - (SIZ).x, \\\n  abs( (PTminORIG).y ) - (SIZ).y, \\\n  abs( (PTminORIG).z ) - (SIZ).z )\n\n// try smoothing SDF parts into each other for a new SDF (after giving up on something below)\nfloat ManSDF(vec3 p,vec3 orig,float sz,vec3 rot) {\n    p -= orig;\n    //ROTATE\n#if 1\n    rot *= iTime*1.5;\n    p.xz = ROTT((p.xz),rot.z);\n    vec3 dd = vec3(0);\n    float kk = sz/3.;\n    float res = 0., cnt = 0.;\n    for ( dd.x = -kk; dd.x <= kk; dd.x += kk ) // average 9 nearby SDF values\n    for ( dd.y = -kk; dd.y <= kk; dd.y += kk )\n    for ( dd.z = -kk; dd.z <= kk; dd.z += kk )\n    {\n        float d1=length(p+dd+vec3(0,-sz*6.,0))-sz*1.5; // head\n        float d2=length(p+dd+vec3(0,-sz*3.,0))-sz*2.; // body\n        float d3=BOX( p+dd-vec3(0,sz*4.,0), vec3(sz*4.,sz*.75,sz*.75) ); // arms\n        float d4=BOX( vec3(ROTT(p.xy,-.3),p.z)+dd-vec3(-sz,-sz*1.,0), vec3(sz*.55,sz*3.,sz*.75) );\n        float d5=BOX( vec3(ROTT(p.xy,.3),p.z)+dd-vec3( sz,-sz*1.,0), vec3(sz*.55,sz*3.,sz*.75) );\n        res += MIN5(d1,d2,d3,d4,d5);\n        cnt += 1.;\n    }\n    return res/cnt;\n#else\n    // I tried distorting space around this man\n    // and managed to extrude arms and 1 raised leg or something,\n    // but only at one camera angle and gave up:\n    float d=1e5;\n    d=min(d,length(p+vec3(0,-sz*6.,0))-sz*1.5); // head\n    d=min(d,length(p/ vec3( sz*2.\n       / (abs(p.y-sz*3.)+sz/4.)\n       / (abs(p.y+p.x/sz+sz*2.)+sz/4.)\n       // / (abs(p.y-p.x/3.+sz*2.)+sz/4.)\n       , 8 , 1 ))-sz); // body\n    return d;\n#endif\n    /*\n    //vec3 j=p+vec3(sz*2.,sz*6.,0);\n    //d=min(d,length((j+vec3(-j.y,-j.x/sz,0))/vec3(1,5,1))-sz);\n    //j=p+vec3(-sz*2.,sz*6.,0);\n    //d=min(d,length((j+vec3(j.y,-j.x/sz,0))/vec3(1,5,1))-sz);\n    return d;\n    */\n}\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n    T(SpherexSDF(pt,vec3(-15.+cos(iTime),-4.+sin(iTime)*1.,3.+cos(iTime)),2.));\n    T(DogSDF(pt,vec3(-12,12,40),vec3(.2,.2,.5),vec3(2.2,1.66,2.5)));\n    T(SkewedBoxSDF(pt,vec3(-3,1,2),vec3(1.5,1.2,2),vec3(1.2,2.66,3.5)));\n    T(SpherexSDF(pt,vec3(-10.+cos(iTime),-4.+sin(iTime)*1.,3.+cos(iTime)),2.));\n    T(OctahedronSDF(pt,vec3(17,2,5),3.,vec3(2.2,1.66,1.5)));\n    T(OctahedronSDF(pt,vec3(-17,8,5),4.,vec3(1.2,1.66,1.5)));\n    T(Octahedron2SDF(pt,vec3(6,8,5),1.,vec3(.4,.6,1),vec3(1.2,1.66,1.5)));\n    T(DodecahedronSDF(pt,5.,vec3(8,-2,30),vec3(1.2,.66,.5)));\n    T(DogSDF(pt,vec3(-8,-9,40),vec3(.5,.2,.5),vec3(1.2,2.4,1.5)));\n    T(DogSDF(pt,vec3(23,13,30),vec3(.4,.2,.99),vec3(.6,.7,.5)));\n    T(SpikeySDF(pt,vec3(23,-13,40),5.,vec3(.9,.7,OSC(.3,1.,iTime*3.)),vec3(.6,.7,.5)));\n    T(CubexSDF(pt,vec3(5,-15,35),1.,vec3(.8),vec3(.75)));\n    T(ManSDF(pt,vec3(-11.,-7.,-2.),.6,vec3(0,0,1)));\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = 0; stps < 300; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( obj.x < .001 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nfloat sqrN(float i,int n)\n{\n  while ( n-- > 0 ) i *= i;\n  return i;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    IniTime(); // slow down on slow hardware\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv /= 5.;\n    vec3 cam = vec3( 0, 0, -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n\n    vec4 hit = March( cam, camdir );\n\n    vec3 Light = vec3( 0, 10, -10 );\n    vec3 dir = normalize( Light - hit.xyz );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, dir );\n    difu = .3 + .7*difu;\n    \n    #define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    O = sqrt( color4(hit.w*.4) );\n    O *= difu + sqrN(difu,9);\n    \n    if ( hit.w >= 90. ) O=vec4(.3);\n#ifdef SHOW_MARCHING_ISSUES\n    if ( hit.w == 90. ) O=vec4(1,0,0,1); // usually marching in parallel with a close plane\n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}