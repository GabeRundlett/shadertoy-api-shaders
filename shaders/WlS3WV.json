{
    "Shader": {
        "info": {
            "date": "1561132778",
            "description": "inspired by Bigwing's \"Double Triangle Truchet Doodle\" and Shane's \"Double Simplex Truchet Weave\".\nonly uses a subset of the symmetry they used in their pieces. also flow possible (uncomment SHOW_FLOW)",
            "flags": 0,
            "hasliked": 0,
            "id": "WlS3WV",
            "likes": 39,
            "name": "tri truch tralala",
            "published": 3,
            "tags": [
                "simplex",
                "truchet",
                "pattern",
                "trigonal"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1597
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// pretty much inspired by those 2 pieces:\n// Bigwings - Double Triangle Truchet Doodle (https://www.shadertoy.com/view/Ml2yzD)\n// Shane    - Double Simplex Truchet Weave (https://www.shadertoy.com/view/3lB3Rc)\n\n// using a very similar symmetry as Shane an Bigwings but just one tile in 3 rotations\n// (use COMPLEX_PATTERN for 3 different tiles)\n// then added a 3d wave to it, so that the pieces link to each other and entangle nicely\n// ...actually this one is also flow-able because i use only 1 symmetry - leaving\n// mirrored parts away (also with COMPLEX_PATTERN)\n\n// also try (un)commenting those defines...\n\n//#define COMPLEX_PATTERN\n\n//#define SHOW_FLOW\n\n#define SHOW_FLOOR_GRID\n\n//#define SHOW_GRID\n\n#define ABBERATION\n\n// branch different shapes for COMPLEX_PATTERN - runs a but faster, but compiles much slower \n#define BRANCHING\n\n\n\n#define PI2 6.28318530718\n\nvoid ROT(inout vec2 v, float ang)\n{\n    vec2 cs=cos(ang-vec2(0,PI2/4.));\n    v = vec2(dot(v,cs),dot(v,cs.yx*vec2(-1,1)));\n}\n\n\n// iq's Capsule/Line distance field\nfloat lineDist( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat distCircle(vec3 p, float r)\n{\n    return length(p-normalize(p*vec3(1,1,0))*r);\n}\n\n// circle with some sine offset in z\nfloat distCircleOff(vec3 p, float r, vec3 v0, float s, float f)\n{\n    float ang = atan(p.y,p.x)-atan(v0.y,v0.x);\n    vec3 poffs=-vec3(0,0,r*3.*sin(ang*f)*s);\n    float d=distCircle(p+poffs,r);\n    \n    #ifdef SHOW_FLOW\n    d+=.03*sin(ang*sign(s)*3.*floor(r*4.7)+iTime*3.);\n    #endif\n    \n    return d;\n}\n\n#define R0 0.27\n\n// only used for COMPLEX_PATTERN if BRANCHING is disabled\n// this on compiles much faster than branchig to the 4 truchVar1..4 functions\n// ...but sadly performance gets worse.\nfloat truchVar(vec3 pos, vec3 p1, vec3 p2, vec3 p3, int idx)\n{\n    float d=10000.;\n    vec3 m1i[4] = vec3[]( p1, p1, p1, .5*(p1+p2) );\n    vec3 m2i[4] = vec3[]( p2, p2, p1, .5*(p2+p3) );\n    vec3 m3i[4] = vec3[]( p3, p3, .5*(p2+p3), .5*(p3+p1) );\n    vec3 t1i[4] = vec3[]( p2-p1, p2-p1, p2-p1, p2-p1 );\n    vec3 t2i[4] = vec3[]( p3-p2, p3-p2, p2-p1, p3-p2 );\n    vec3 t3i[4] = vec3[]( p1-p3, p1-p3, p3-p2, p1-p3 );\n    vec3 fsr1[4] = vec3[]( vec3(6.,-1.,2.*R0), vec3(6.,1.,2.*(1.-R0)), vec3(6.,1.,2.*(1.-R0)), vec3(2.,1.,2.*(.5-R0)) );\n    vec3 fsr2[4] = vec3[]( vec3(6.,-1.,2.*R0), vec3(6.,1.,2.*(1.-R0)), vec3(6.,-1.,2.*R0),     vec3(2.,1.,2.*(.5-R0)) );\n    vec3 fsr3[4] = vec3[]( vec3(6.,-1.,2.*R0), vec3(6.,1.,2.*(1.-R0)), vec3(2.,1.,2.*(.5-R0)), vec3(2.,1.,2.*(.5-R0)) );\n    float f,s,r; vec3 m,t;\n    f=fsr1[idx].x; s=fsr1[idx].y; r=fsr1[idx].z; m=m1i[idx]; t=t1i[idx];\n    d=min(d,distCircleOff(pos-m,r,t,s*.015/f*6.,f));\n    f=fsr2[idx].x; s=fsr2[idx].y; r=fsr2[idx].z; m=m2i[idx]; t=t2i[idx];\n    d=min(d,distCircleOff(pos-m,r,t,s*.015/f*6.,f));\n    f=fsr3[idx].x; s=fsr3[idx].y; r=fsr3[idx].z; m=m3i[idx]; t=t3i[idx];\n    d=min(d,distCircleOff(pos-m,r,t,s*.015/f*6.,f));\n    return d;\n}\n\nfloat truchVar1(vec3 pos, vec3 p1, vec3 p2, vec3 p3)\n{\n    float d=10000.;\n    d=min(d,distCircleOff(pos-p1,2.*R0,vec3(p2-p1),-.015,6.));\n    d=min(d,distCircleOff(pos-p2,2.*R0,vec3(p3-p2),-.015,6.));\n    d=min(d,distCircleOff(pos-p3,2.*R0,vec3(p1-p3),-.015,6.));\n    return d;\n}\n\n\nfloat truchVar2(vec3 pos, vec3 p1, vec3 p2, vec3 p3)\n{\n    float d=10000.;\n    d=min(d,distCircleOff(pos-p1,2.*(1.-R0),vec3(p2-p1), .015,6.));\n    d=min(d,distCircleOff(pos-p2,2.*(1.-R0),vec3(p3-p2), .015,6.));\n    d=min(d,distCircleOff(pos-p3,2.*(1.-R0),vec3(p1-p3), .015,6.));\n    return d;\n}\n\n\nfloat truchVar3(vec3 pos, vec3 p1, vec3 p2, vec3 p3)\n{\n    float d=10000.;\n    d=min(d,distCircleOff(pos-p1,2.*(1.-R0),vec3(p2-p1), .015,6.));\n    d=min(d,distCircleOff(pos-p1,2.*(   R0),vec3(p2-p1),-.015,6.));\n    d=min(d,distCircleOff(pos-(p2+p3)*.5,2.*(.5-R0),vec3(p3-p2),.045,2.));\n    return d;\n}\n\nfloat truchVar4(vec3 pos, vec3 p1, vec3 p2, vec3 p3)\n{\n    float d=10000.;\n    d=min(d,distCircleOff(pos-(p1+p2)*.5,2.*(.5-R0),vec3(p2-p1),.045,2.));\n    d=min(d,distCircleOff(pos-(p2+p3)*.5,2.*(.5-R0),vec3(p3-p2),.045,2.));\n    d=min(d,distCircleOff(pos-(p3+p1)*.5,2.*(.5-R0),vec3(p1-p3),.045,2.));\n    return d;\n}\n\nvec4 getRand(vec3 pos)\n{\n    vec2 rres=vec2(textureSize(iChannel0,0));\n    return texelFetch(iChannel0,ivec2(mod(pos.xy,rres)),0);\n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    return uv+.6*sin(uv*res*PI2)/PI2/res;\n}\n\nvec4 getRandS(vec2 pos)\n{\n    vec2 rres = vec2(textureSize(iChannel0,0));\n    return textureLod(iChannel0,uvSmooth(pos.xy/rres,rres),0.);\n}\n\n\nfloat distTri(vec3 pos, vec3 p1, vec3 p2, vec3 p3)\n{\n    float d=10000.;\n\n    vec4 r=getRand(p1);\n    if(r.y<.333) { vec3 v=p1; p1=p2; p2=p3; p3=v; }\n    if(r.y<.666) { vec3 v=p1; p1=p2; p2=p3; p3=v; }\n\n    #ifdef COMPLEX_PATTERN\n      #ifdef BRANCHING\n        float di[4];\n        di[0]=truchVar1(pos,p1,p2,p3);\n        di[1]=truchVar2(pos,p1,p2,p3);\n        di[2]=truchVar3(pos,p1,p2,p3);\n        di[3]=truchVar4(pos,p1,p2,p3);\n        d=di[int(r.x*3.999)];\n      #else\n        d=truchVar(pos,p1,p2,p3,int(r.x*3.999));\n      #endif\n    #else\n      d=truchVar3(pos,p1,p2,p3);\n    #endif\n    \n    #ifdef SHOW_GRID\n    d=min(d,lineDist(pos,p1,p2)+.04);\n    d=min(d,lineDist(pos,p2,p3)+.04);\n    d=min(d,lineDist(pos,p3,p1)+.04);\n    #endif\n\n    return d;\n}\n\nfloat distTruch(vec3 p)\n{\n    vec3 p1 = vec3(0);\n    vec3 p2 = vec3(2,0,0);\n    vec3 p3 = vec3(1,sqrt(3.),0);\n    mat2 m = mat2((p2-p1).xy,(p3-p1).xy);\n    vec2 q = inverse(m)*p.xy;\n    vec2 qi = floor(q);\n    vec2 p0=m*qi;\n    p1.xy+=p0; p2.xy+=p0; p3.xy+=p0;\n    if(q.x-qi.x+q.y-qi.y>1.) { p1=p2+p3-p1; vec3 dummy=p3; p3=p2; p2=dummy; }\n    return distTri(p,p1,p2,p3)-.1;\n}\n\nint m = 0;\n\n#define FloorZ (-.17)\n\nfloat distFloor(vec3 p)\n{\n    float s,gridOffs=0.;\n    #ifdef SHOW_FLOOR_GRID\n    s=sin(dot(p.xy,sin(0.*PI2/6.+vec2(0,PI2*.25)))*PI2*.25/sqrt(3./4.)); gridOffs+=exp(-s*s/.003)*.05;\n    s=sin(dot(p.xy,sin(1.*PI2/6.+vec2(0,PI2*.25)))*PI2*.25/sqrt(3./4.)); gridOffs+=exp(-s*s/.003)*.05;\n    s=sin(dot(p.xy,sin(2.*PI2/6.+vec2(0,PI2*.25)))*PI2*.25/sqrt(3./4.)); gridOffs+=exp(-s*s/.003)*.05;\n    #endif\n    float d=p.z+(getRandS(p.xy*25.).x-getRandS(p.xy*25.+vec2(5.3,13.7)).x)*.002+gridOffs-FloorZ;\n    return d;\n}\n\nfloat dist(vec3 p)\n{\n    float d=10000.;\n    d=min(d,distTruch(p));\n    d=min(d,distFloor(p));\n    return d;\n}\n\nvec3 getDistGrad(vec3 p, float eps)\n{\n    vec3 d=vec3(eps,0,0);\n    float d0=dist(p);\n    return vec3(\n        dist(p+d.xyz)-d0,\n        dist(p+d.zxy)-d0,\n        dist(p+d.yzx)-d0\n        )/eps;\n}\n\nvoid march(inout vec3 pos, vec3 dir)\n{\n    float eps=0.001;\n    float d;\n    for(int i=0;i<50;i++) \n    {\n        d=dist(pos);\n        pos+=d*dir*.8;\n        if (d<eps) break;\n    }\n    d=dist(pos);\n    m=0;\n    if(d==distTruch(pos)) m=1;\n    if(d==distFloor(pos)) m=2;\n}\n\nvec4 getMRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel0,coord+.003*iTime);\n    c+=texture(iChannel0,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel0,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel0,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n//#define FloorZ -.33\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    #ifndef SHADEROO\n    return texture(iChannel1,dir.xzy);\n    #else\n    vec3 colHor=vec3(.5,.55,.6);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*1.,vec3(.8,.9,1)*1.,clamp(7.*dir.z,0.,1.));\n    vec3 skyPos=pos+dir/abs(dir.z)*(20.-pos.z);\n    float cloudPat=(1.+.4*(getMRand(skyPos.xy*.001).x-.5));\n    colSky*=mix(1.,cloudPat,step(0.,dir.z));\n    vec3 colFloor=vec3(.9,.95,1.)*.7;\n    vec3 colScale=vec3(.0,.3,.5);\n    vec3 floorPos=pos-dir/dir.z*(pos.z-FloorZ);\n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*6.)-.1,0.,1.));\n    return vec4(col,1);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camDist=12.;\n    #ifdef SHADEROO\n    camDist*=1.-iMouseData.z/1000.0;\n    #endif\n    float th=-iMouse.y/iResolution.y*1.2;\n    float ph=iMouse.x/iResolution.x*10.;\n    float t=iTime*.2;\n    if (iMouse.x<1.)\n    {\n        th=(.1-.8*(.5-.5*sin(t-.5)))*PI2*.25;\n        ph = t;\n        camDist = 30.-26.*sin(t*.3);\n    }\n    vec3 pos = vec3(0,0,camDist);\n    vec3 dir = vec3((fragCoord-iResolution.xy*.5)/iResolution.x,-1);\n    #ifdef ABBERATION\n    dir.xy+=.5*dir.xy*dot(dir.xy,dir.xy);\n    #endif\n    dir=normalize(dir);\n    ROT(pos.yz,th);\n    ROT(pos.xy,ph);\n    ROT(dir.yz,th);\n    ROT(dir.xy,ph);\n    if (iMouse.x<1.)\n    {\n        pos.x+=2.7*t;\n    }\n    \n    vec3 pos0=pos;\n    vec4 env0=myenv(pos,dir,1.);\n    \n    float eps=.2;\n    float ao=1.;\n    \n    vec3 n = vec3(0,0,1);\n    float br=1.;\n    m=0;\n    pos-=dir/dir.z*(pos.z-.3);\n    march(pos, dir);\n    n=getDistGrad(pos,.01);\n    vec3 pos1=pos;\n    ao*=(dist(pos+n*eps)-dist(pos))/eps;\n    if (m==2) {\n        br=.7;\n        if (dist(pos)>.001) n=vec3(0);\n        dir=reflect(dir,n);\n        br*=(1.-(FloorZ-pos.z)*15.);\n        pos+=dir*.01;\n        m=0;\n        march(pos, dir);\n    }\n    \n    int bg=0; if (dist(pos)>.001) bg=1;\n    \n    n=getDistGrad(pos,.01);\n    if (bg==1) n=vec3(0);\n    if(m!=0) dir=reflect(dir,n);\n\n    if(bg==1) ao=1.;\n    \n    vec3 col=(n*.5+.5);\n    //col=vec3(1);\n    \n    float diff=clamp(n.z,0.,1.)*.3+.7;\n    if(bg==1) diff=1.;\n    \n    vec3 env=myenv(pos,dir,1.).xyz;\n    col=mix(col,env,.9);\n    col=ao*br*diff*col;\n\n    fragColor=vec4(col,1);\n\n    if(true)\n    {\n        vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n        float vign = 1.-.7*dot(scc,scc);\n        vign*=1.-.7*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n        vign*=1.-.7*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n        fragColor.xyz *= vign;\n    }   \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}