{
    "Shader": {
        "info": {
            "date": "1696081500",
            "description": "Using raymarched icosahedral traversal to produce an animated randomly subdivided icosahedral object running in realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "csyyzm",
            "likes": 76,
            "name": "Raymarched Icosahedral Traversal",
            "published": 3,
            "tags": [
                "raymarching",
                "math",
                "icosahedron",
                "icosahedron",
                "spherical",
                "subdivision",
                "polyhedron",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "/*\n\n    Raymarched Icosahedral Traversal\n    --------------------------------\n    \n    For a while, I've wanted to make some kind of random subdivided 3D \n    polyhedral cell slice object, but it's taken a while to figure out how\n    I was going to make that happen on Shadertoy. Chances are that you've \n    never come across a polyhedral cell traversal before, and if I'd never \n    considered making this, I wouldn't have either. :) In fact, I couldn't\n    find any existance of polyhedral traversal online, so I'm not sure it's\n    even a thing.\n    \n    I wanted to find a simpler way, but I eventually and begrudgingly \n    realized that spherical coordinate traversal was the only feasable method \n    available that wouldn't set the GPU on fire. Regular raymarching using \n    neighboring cell methods would be a prohibitively expensive book-keeping \n    nightmare and boolean raytracing methods would probably be worse.\n\n    Interestingly, the subdivided icosahedral traversal didn't turn out to be \n    as difficult as I thought it'd be, but it still wasn't fun, so I doubt \n    it'll catch on as a new technique-du-jour amongst Minecraft coders or \n    whoever. :)\n    \n    The scene design -- if you can call it that -- is pretty random. After \n    completing the spherical object, I got bored and subdivided the background,\n    just to see if it was possible to have two conflicting traversal schemes\n    running concurrently. The background would look better plain, plus the \n    framerate would improve considerably, but after all that work, I was \n    insistent on leaving it in... Anyway, for those who like novel \n    approaches... and early 2000s hot pearlescent pink -- or whatever that \n    color is, you're in luck. And for those with slower machines, my apologies. \n    However, I'll return to this later and try to speed things up.\n \n\n\t\n    Other examples:\n    \n  \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n    \n    // Very cool demonstration. Polyhedrons are more TDHoopers's domain. The\n    // example below relies on folding symmetry to work, so would be less \n    // applicable in an asymmetric setting. Having said that TDHooper would \n    // probably know of some clever ways to improve my hacky polyhedral code. :)\n    Geodesic tiling - tdhooper\n    https://www.shadertoy.com/view/llVXRd\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Random icosahedral subdivision, if desired. Commenting this out \n// will look cleaner and increase the frame rate, but I don't feel\n// it looks as interesting.\n#define ICOS_SUBDIV\n\n// Random back wall subdivision, if desired. Commenting this out \n// will increase the frame rate.\n#define WALL_SUBDIV\n\n// Using the brick background. Commenting this out will display a \n// dark matte wall, and free up some cycles.\n#define BRICKS\n\n// Color scheme -- Golden orange: 0, Pinkish purple: 1, Greenish blue: 2.\n#define COLOR 1\n\n\n// Scene object ID and individual ID storage.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n*/\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // Depending on your machine, this should be faster than\n    // the block below it.\n    return texture(iChannel0, f*vec2(.2483, .3437)).x;\n    /* \n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    */\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    \n    return texture(iChannel0, f.xy*vec2(.2483, .1437) + f.z*vec2(.4865, .5467)).x;\n    // Volume noise texture.\n    //return texture(iChannel0, f*vec3(.2483, .4237, .4865)).x;\n    /* \n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    */ \n}\n\n\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better version of this that I'll have to find.\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n \nvec3 rotObj(in vec3 p){\n\n    vec3 oP = p;\n    \n    float tm = iTime/4.;\n    p.yz *= rot2(tm/2.);\n    p.xz *= rot2(tm);\n   \n    if(iMouse.z>0.){\n        // Mouse movement.\n        vec2 ms = (iMouse.xy/iResolution.xy - .5)*vec2(3.14159);\n        p = oP;\n        p *= rot(vec3(0, ms.y, -ms.x));\n    } \n\n    return p;\n}\n\n \n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n \n \n\n// IQ's box routine with added smoothing factor.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// IQ's box routine with added smoothing factor.\nfloat sBox(in vec3 p, in vec3 b, float r){\n\n  vec3 d = abs(p) - b + r;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// IQ's extrusion formula with added smoothing factor.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\n\n\n/////////\n// Normalizing and scaling. If there's a clever way to do this, feel\n// free to let me know.\nmat3x3 nrmSclMat(mat3x3 m, float rad){\n    \n    return mat3x3(normalize(m[0]), normalize(m[1]), normalize(m[2]))*rad;\n}\n\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI TAU*.5 // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482 // (1. + sqrt(5.))/2.\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Direction vector and sector ID.\n//vec3 dir;\n//int sID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 q, inout mat3x3 gVertID, const float rad){\n       \n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems. The bottom section is \n    // rotated by PI/5 about the equator.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    const float scX = 5.; // Longitudinal scale.\n    vec4 sph = atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.);\n    sph = fract((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX)*TAU;\n    //sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    const vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    const vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Skip the top or bottom strip, depending on whether we're in the\n    // northern or southern hemisphere.\n    ivec3 iR = q.y<0.? ivec3(1, 2, 3) : ivec3(0, 1, 3);\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point. Usually, only one\n    // two strips are normally checked, but three are checked here on account \n    // of faux shadow rendering.\n    for(int k = 0; k<3; k++){ \n\n        int i = iR[k];\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i&1], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n    \n    // X - coordinates for all three vertices.\n    vec3 ax = mod(vec3(0, -PI/5.*baseFlip, PI/5.*baseFlip) + TAU + sph[id], TAU);\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID = mat3x3(vec3(ax.x, ayT, rad), vec3(ax.y, ayB, rad), vec3(ax.z, ayB, rad));\n    \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if ((id&1)==0) gVertID[0].x = 0.;\n\n    /*\n    // Direction and section ID stuff. Not used here.\n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    \n    sID = id;\n    */\n    \n    return q;\n}\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n/*\n/////////\n// Nimitz's simple basis function. I'll take people's word for it that it\n// fails at the negative one Z point, so I've attempted to put in a hacky fix.\nmat3 basis(in vec3 n){\n    \n    float a = min(1./(1. + n.z), 1e6);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n}\n\n\n\n// Sphere intersection: Pretty standard, and adapted from one\n// of IQ's formulae.\nvec2 sphereIntersect(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n    if(b > 0.) return vec2(1e8, 0.);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.) return vec2(1e8, 0.);\n\treturn vec2(-b - sqrt(h), 1.); \n    \n}\n*/\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec3 ro, vec3 rd, vec3 p, vec3 n){\n\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n   //return dn>0.? max(dot(p - ro, n), 0.)/dn : 1e8;   \n\n}\n\n// Plane distance function. Probably from IQ's page.\nfloat plane(vec3 p0, vec4 p) {\n\treturn dot(p.xyz, p0 + p.xyz*p.w);\n}\n\n\nvec3 gDir2; // Cell traversing direction.\nvec3 gRd2; // Global ray variable.\n\nvec3 gRd; // Global ray variable.\nfloat gCD; // Global cell boundary distance.\nvec3 gP;\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n \n// Individual icosahedral cell ID and wall panel cell ID.\n// I'm also storing the moving height values in the final slot.\nvec4 icosCellID;\nvec3 wallCellID;\n\n \n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    \n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n            \n    // Icosahedron vertices and vertex IDs for the current cell.\n    mat3x3 v, vertID;\n\n    // Obtaining the local cell coordinates and spherical coordinates\n    // for the icosahedron cell.\n    const float rad = .5;\n    vec3 lq = getIcosTri(q, vertID, rad);\n    \n    // Converting the cell triangle vertices to world coordinates.\n    v[0] = sphericalToWorld(vertID[0]);\n    v[1] = sphericalToWorld(vertID[1]);\n    v[2] = sphericalToWorld(vertID[2]);\n         \n \n    \n    // Edge mid points.\n    mat3x3 vE = (v + mat3x3(v[1], v[2], v[0]));\n    vE = nrmSclMat(vE, rad);\n    /*\n    // The above is equivalent to the following.\n    vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n    vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n    vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n    */\n    \n\n    /////\n\n    // Triangle subdivision, if desired.\n    #ifdef ICOS_SUBDIV\n    int subDivNum = 2;\n    #else\n    int subDivNum = 1;\n    #endif\n\n    int subs = 0;\n\n    if(length(lq)>.8) subDivNum = 0;\n\n    //float midTri = 0.;\n    //\n    // There'd be faster ways to do this, but this is\n    // relatively cheap, and it works well enough.\n    for(int i = 0; i<subDivNum; i++){\n\n        #ifdef ICOS_SUBDIV\n        if(i>=1){\n            vec3 rC = v[0] + v[1] + v[2];\n            float sRnd = hash31(rC + float(i + 1)/8.);\n            if(sRnd<.65) break;\n        }\n        #endif\n        subs++;\n\n\n        // Create three line boundaries within the triangle to \n        // partition into four triangles. Pretty standard stuff.\n        // By the way, there are other partitionings, but this \n        // is the most common. At some stage, I'll include some\n        // others, like the three triangle version connecting the \n        // center to the vertices.\n        //\n        if(dot(lq, cross(vE[0], vE[1]))>0.){\n            v[0] = vE[0]; v[2] = vE[1];                    \n        }\n        else if(dot(lq, cross(vE[1], vE[2]))>0.){\n            v[0] = vE[2]; v[1] = vE[1];\n        }\n        else if(dot(lq, cross(vE[2], vE[0]))>0.){\n            v[1] = vE[0]; v[2] = vE[2];\n        }\n        else {\n            v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n            //midTri = 1.;\n        }\n\n        // Recalculating the edge mid-vectors for the next iteration.\n        vE = (v + mat3x3(v[1], v[2], v[0]));\n        vE = nrmSclMat(vE, rad); \n    }\n  \n            \n    /////  \n \n\n     // The cell center, which doubles as a cell ID,\n    // due to its uniqueness, which can be used for \n    // randomness, etc.\n    //vec3 tCntr = sSize(v[0] + v[1] + v[2], rad);\n    vec3 cntrID = (v[0] + v[1] + v[2]);\n \n\n     // Icosahedral cell boundary.\n    mat3 mEdge = mat3(cross(v[1], v[0]), cross(v[2], v[1]), cross(v[0], v[2]));\n    // Normals at each of the triangle sides.\n    mat3x3 sNrm = nrmSclMat(mEdge, 1.); \n    //mat3x3 sNrm = mat3x3(normalize(mEdge[0]), normalize(mEdge[1]), normalize(mEdge[2]));\n    \n    // Icosahedral triangle face cell boundary.\n    vec3 ep = (normalize(lq)*mEdge)/\n              vec3(length(v[1] - v[0]), length(v[2] - v[1]), length(v[0] - v[2]));  \n    float triF = min(min(ep.x, ep.y), ep.z);   \n \n    ////////////\n \n    // Random animated radius.\n    float r = hash31(cntrID + .16);\n    r = (smoothstep(.9, .95, sin(6.2831589*r + iTime))*.2 + .95)*rad;\n    // Storing the center ID and radius for later.\n    icosCellID = vec4(cntrID, r);\n    \n    \n    // The main polyhedral object.\n    float object = 1e5;\n\n    // Edge smoothing factor. Hacky, but it works well enough.\n    float eSm = 1./float(subs + 1);\n\n    // Creating the triangle wedge object for this cell by simply\n    // obtaining the maximum of all inner boundary planes.\n    float gap = .005; // Cell gap.\n    float side = plane(lq, vec4(-sNrm[0], gap)); // Normal facing plane.\n    side = smax(side, plane(lq, vec4(-sNrm[1], gap)), .06*eSm);\n    side = smax(side, plane(lq, vec4(-sNrm[2], gap)), .06*eSm);\n    //side = abs(side + .025*eSm) - .025*eSm; // Thin sides.\n\n    // The top of the triangle cell wedge.\n    float top = length(lq) - r; // Round surface.\n    //float top = -plane(lq, vec4(normalize(-cntrID), r));\n    object = abs(top + .02) - .02; // Thin slice, instead of solid.\n    //object = top; // Standard solid chunk.\n\n    // The triangle cell object consists of a top moved out from the center\n    // of the spherical opject with three triangular sides cut out. The\n    // last factor (triF) is the 2D triangle distance, which we're using to\n    // make the object look pointy on top. Removing it will return a flat\n    // surface.\n    object = smax(object, side, .015) - triF*.3;\n\n    // Inner ball.\n    object = min(object, length(lq) - .35);\n\n    // The tubes eminating from the center of the polygon.\n    float tube = distLine(lq, vec3(0), normalize(cntrID)*(r + .06*eSm)) - .04*eSm; \n    // Other failed experiments. :)\n    //float tube = distLine(lq, vec3(0), normalize(cntrID)*8.);\n    //tube = max(tube, top) - .035*eSm;\n    //tube = min(tube, length(lq - normalize(cntrID)*(r + .06*eSm)) - .04*eSm);\n    //float tube = max(top - .05, -line + length(vE[2] - normalize(cntrID)*rad)*.8); \n     \n \n \n    ///////////\n    // Icosahedral traversal section: Setup wasn't fun, but the execution\n    // is incredibly simple. Trace the ray to the outer walls, and note\n    // the minimum distance.\n    // Ray to triangle prism wall distances.\n    vec4 rC = vec4(1e5);\n    rC.x = rayLine(lq, gRd, vec3(0), -sNrm[0]);\n    rC.y = rayLine(lq, gRd, vec3(0), -sNrm[1]);\n    rC.z = rayLine(lq, gRd, vec3(0), -sNrm[2]);\n\n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... or something like that.\n    gCD = max(min(min(rC.x, rC.y), min(rC.z, rC.w)), 0.);\n    \n \n    ///////////\n    \n \n    // Standard rectangle subdivision with offset rows.\n    float wBlock = 1e5;\n    \n    // Not using bricks will return a flat dark background and free up\n    // some cycles.\n    #ifdef BRICKS\n    // Trying to speed things up by not calculating pixels we don't have to.\n    if(p.z>0. && length(p)>1.){ \n  \n        // Scale and row offset.\n        vec2 sc2 = vec2(1.5, 1)*.36;\n        vec2 p2 = p.xy - vec2(0, iTime/8.);\n        vec2 offs = vec2(0);\n        vec2 ii = mod(floor(p2/sc2), 3.)/3.;\n        p2.x -= ii.y*sc2.x;\n        offs.x += ii.y;\n   \n        vec2 svP2 = p2;\n        // Local cell position and ID. \n        vec2 ip2 = floor(p2/sc2) + .5;\n        p2 -= ip2*sc2;\n        subs = 1; // Subdivision number.\n        #ifdef WALL_SUBDIV\n        // One subdivision level.\n        if(hash21(ip2 + .2)<.35){\n            sc2 /= 2.;\n            p2 = svP2;\n            ip2 = floor(p2/sc2) + .5;\n            p2 -= ip2*sc2;\n            subs++;\n        }\n        #endif\n        ip2 = (ip2 + offs)*sc2; // Cell ID.\n     \n     \n        // Outer blocks.\n        float x = ip2.x/1.5/.36;\n        int outer = (x>3. || x<-3.)? 1 : 0;\n\n        // Height based on X-distance... I'm not even sure what the \"crv\" reference\n        // is... It makes the wall look curved on the ends. Fair enough. :D\n        float crvH = .3*max(abs(ip2.x), 0.); \n        float h = hash21(ip2 + .22); // Random height.\n\n        // Moving outer walls, and static in the middle.\n        if(outer == 1) h = smoothstep(.9, .95, sin(6.2831589*h + iTime))*.25 + crvH;\n        else h = crvH; \n\n        // Save the wall ID and height for later.\n        wallCellID = vec3(ip2, h);\n\n        vec3 p3 = vec3(p2, p.z - 2. - .04);\n        //float wBlock = sBox(vec3(p2, -(p.z + h/2.) + 3.), vec3(sc2/2., h/2.), .01);\n        float d2D = sBox(p2, sc2/2., .1*sqrt(min(sc2.x, sc2.y)));\n        //float wBlock = opExtrusion(d2D, p.z - 3., h, .015) + d2D*.2;\n        float sphCrv = length(p2/sc2/2.)*.02;\n        float blockFce = (outer == 1)? min(-d2D, .2)*.15 : 0.;\n        if(outer == 0 && hash21(ip2)<.5) d2D = abs(d2D + .04) - .04;\n        wBlock = opExtrusion(d2D, p3.z + h, .04, .025) - blockFce + sphCrv;\n\n        // The wall tube... I should look for a faster way to do this, but it'll\n        // do for now.\n        float tube2 = distLine(p3, vec3(0), \n                      vec3(0, 0, -1)*(h + .18/float(subs + 1))) - .08/float(subs + 1); \n\n        // Only connecting tubes on the outer bricks. It's not mandatory, but I\n        // wanted the inner brick to look cleaner.\n        if(outer == 1) tube = min(tube, tube2);\n\n\n        // Directional ray collision with the square cell boundaries.\n        vec2 rC2 = (gDir2.xy*sc2 - p2)/gRd2.xy; // For 2D, this will work too.\n\n        // Minimum of all distances, plus not allowing negative distances.\n        gCD = min(gCD, max(min(rC2.x, rC2.y), 0.)); // Adding a touch to advance to the next cell.\n    \n    }\n    #endif\n    \n    // Advancing the traversal distance the next cell.\n    gCD += .0001;\n    \n    \n   \n\n    //////////////////\n    // The background wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    //float wall = -(length(p - sphPos - vec3(0, 0, -(48. - 3.))) - 48.);\n    // Flat plane back wall.\n    float wall = -p.z + 2.5;\n    \n\n    // Overall object ID -- There in one rundundant slot there.\n    vID = vec4(tube, wall, wBlock, object);\n\n    // Shortest distance to a scene object.\n    return min(min(tube, wall), min(wBlock, object));\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Closest and total distance.\n    float d, t = hash31(ro + rd)*.15;// Jittering to alleviate glow artifacts.\n    \n    gRd = rd; // Set the global icosadral ray direction varible.\n    // It needs to match the object rotation. Performing this in the\n    // \"map\" function will rotate it multiple times per loop, so \n    // won't work... I found that out the hard way. :)\n    gRd = rotObj(gRd); \n    \n    // Back wall unit direction ray. Not rotated. \n    // We need the direction itself for the standard cube\n    // traversal trickery.\n    gDir2 = sign(rd)*.5;\n    gRd2 = rd;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += min(d*.8, gCD);\n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable. \n    // machine anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n\n    gRd = rd; // Icosahedral direction ray.\n    gRd = rotObj(gRd);\n    \n    gDir2 = sign(rd)*.5; // Back wall direction ray. Not rotated.\n    gRd2 = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect:  dist += clamp(h, .01, stepDist), \n        // etc.\n        //t += clamp(d, .01, .25); // Normally this.\n        t += clamp(min(d, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.15, .3, -2);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n    \n    vec4 iCellID = icosCellID; // Icosahedron cell ID with radius.\n    vec3 wCellID = wallCellID; // Wall cell ID with height.\n  \n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        // Sharper diffus... iveness... Diffusivity. :)\n        diff = pow(diff, 4.)*2.; \n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t     \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty \n        // subtle, so could almost be aproximated by a constant, but I prefer it. Here, \n        // it's being used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        \n        float refF = 1.; // Reflection factor.\n         \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n         \n        // Texturing position and normal.\n        vec3 txP = sp, txN = sn;\n\n        // Object patterns, coloring, etc.        \n        if(objID==1){ \n        \n           \n            // The background itself. Mostly hidden behind the bricks,\n            // but there nonetheless.\n            txP /= 3.;\n            txP.xy *= rot2(3.14159/4.);\n            txP += .25;\n         \n             // Color and reflection.\n            texCol = vec3(.0175); // Black.\n     \n            // Virtually no specular reflection.\n            refF = .0125;\n\n            \n        }\n        else if(objID==2 || (objID==0 && sp.z>1.)){ \n        \n            // Wall blocks and vertices.\n        \n            // Texture positio.\n            txP.xy -= vec2(0, iTime/8.);\n            txP.z += wCellID.z;\n            txP /= 3.;\n            txP.xy *= rot2(3.14159/4.);\n            \n            // Random color.\n            float iRnd = hash21(wCellID.xy + .06);\n            texCol = .5 + .45*cos(6.2831*iRnd/10. + vec3(0, 1, 2) + .5);\n            \n            // Darkening the bricks in the center and some on the\n            // left and right sides, and reducing the reflection factor.\n            float x = wCellID.x/1.5/.36; // Scale in distance function.\n            \n            // Darkening the back end of all poles... It was a last minute thing.\n            int back = 0;//((sp.z - 2.04) + wCellID.z - .08>0. && objID==0)? 1 : 0;\n            \n            if(((x<3. && x>-3.) || hash21(wCellID.xy + .38)<.5) || back==1){\n            //if(hash21(wCellID.xy + .38)<.8 || tip==1){\n              texCol = mix(texCol/4., vec3(.13)*dot(texCol, vec3(.299, .587, .114)), .9);\n              refF = .25;\n            }\n            \n            // Tubes and vertices on the outer bricks.\n            if(objID==0){\n                texCol = mix(texCol*2., vec3(.5)*dot(texCol, vec3(.299, .587, .114)), .65);\n            }\n           \n            #if COLOR >= 1\n            texCol = mix(texCol.xzy, texCol.yzx, \n                         1. - smoothstep(0., 1., rd.x*.5+rd.y*2. + .9));\n            #endif\n\n            #if COLOR == 2\n            texCol = texCol.yzx;  // Other colors.    \n            #endif\n \n\n        }\n        else { \n        \n            // Icosahedral color.\n        \n            // Texture position and normal.\n            float rad = .5;\n            txP = sp - sphPos;\n            txP += normalize(txP)*(rad - iCellID.w);\n            \n             \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n            \n            // Color and reflection.\n            float iRnd = hash31(iCellID.xyz + .07);\n            texCol = .5 + .45*cos(6.2831*iRnd/10. + vec3(0, 1, 2) + .5);\n             \n               \n            // Coloring the tube and vertices.\n            if(objID==0){\n                texCol = mix(texCol*2., vec3(.5)*dot(texCol, vec3(.299, .587, .114)), .65);\n            }\n            \n            // Darkening the back end of all poles... It was a last minute thing.\n            int back = 0;//(length(sp - sphPos.xyz) - iCellID.w + .02<0. && objID==0)? 1 : 0;\n            \n            \n            // Dark inner sphere.\n            if(length(sp - sphPos.xyz)<.42 || back==1){ \n                texCol = mix(texCol/4., vec3(.13)*dot(texCol, vec3(.299, .587, .114)), .9); \n                refF = .25; // Less reflection.\n            } \n            \n            #if COLOR >= 1\n            texCol = mix(texCol.xzy, texCol.yzx, \n                         1. - smoothstep(0., 1., rd.x*.5 + rd.y*2. + .9));\n            #endif\n            \n            #if COLOR == 2\n            texCol = texCol.yzx; \n            #endif\n\n        }\n        \n        \n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        vec3 rCol = spRef*refTx*1.; //smoothstep(.03, 1., spRef)  \n\n        \n        // Adding the specular reflection here.\n        texCol += rCol*refF;\n \n        // Metal and powder coat enamel.\n        vec3 tx = tex3D(iChannel2, txP + .5, txN);\n        texCol *= tx*2. + .3;\n       \n        \n        \n        // This is probably a good example for a BRDF scheme, but things look\n        // OK as is, so I'll keep things more simple.\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh*2.);\n \n        // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Not need here.\n    //col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n\n\n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1); \n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}