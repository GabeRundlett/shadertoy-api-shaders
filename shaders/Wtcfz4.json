{
    "Shader": {
        "info": {
            "date": "1612298959",
            "description": "A paint mixing simulation using 16 8-bit color channels.",
            "flags": 48,
            "hasliked": 0,
            "id": "Wtcfz4",
            "likes": 57,
            "name": "Multispectral Paint Blending",
            "published": 3,
            "tags": [
                "fluid",
                "blending",
                "poisson",
                "paint",
                "mixing",
                "cfd",
                "multispectral"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 1745
        },
        "renderpass": [
            {
                "code": "/*\n    Created by Cornus Ammonis (2021)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n    \n    This is an approach to paint mixing that solves the \"blue + yellow = green\"\n    problem. In most color spaces, blending between blue and yellow will produce\n    gray instead of green. This is a general problem; without a more robust\n    representation of the color spectrum, we are unable to reliably achieve color\n    blending results that are consistent with real-life expectations. In practical\n    terms, that means that when we only use 3 or 4 color channels and repeatedly\n    blend colors together, we tend to rapidly end up with a muddy gray color.\n    Or worse, repeated blending may not be stable at all, and the result may tend \n    to blow up or settle on some fixed point in the color space no matter what \n    the input colors are. \n    \n    Here, color space is represented by 16 8-bit log-space spectral components,\n    which are packed into a vec4. Blending is achieved using simple linear blends\n    on the 16 log-space components.\n    \n    A fluid simulation (Buffer A, C, D) is used to supply advection offset vectors \n    to the paint blending layer (Buffer B). The fluid simulation makes use of the \n    separable multistep Poisson solver method described here \n    \n        Fast Separable Poisson SVD https://www.shadertoy.com/view/wsVyzD\n        \n    to solve for pressure. The fluid simulation is multiscale and incorporates\n    methods developed here\n    \n        Multiscale MIP Fluid https://www.shadertoy.com/view/tsKXR3\n        \n    along with a few other techniques. I have adapted paniq's Analytical Biquadratic\n    Gradient Interpolation method to take an LOD argument (Common Tab).\n    \n    Developing a colorspace is tricky and requires some choice of tradeoffs.\n    I chose constants here to get a relatively accurate conversion from RGB\n    while maintaining good saturation. It would be preferable to use higher \n    bit-depth values for each of the spectral components.\n    \n    A HI_QUALITY #define in the common tab can be enabled to use higher-order\n    sampling for the fluid simulation. Buffer A and B have a variety of\n    configurable parameters in #defines to change the fluid and blending\n    properties.\n    \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texel = 1.0/iResolution.xy;\n\tvec2 uv = fragCoord.xy * texel;\n    vec3 n = vec3(sample_biquadratic_gradient(iChannel2, iResolution.xy, uv, 0.0),0.04);\n\n    n = normalize(n);\n\n    vec3 light = normalize(vec3(1,4,3));\n    \n    float spec = ggx(reflect(light,n), vec3(0,1,0), light, 0.4, 0.8);\n    \n    float d = texture(iChannel2,uv).x;\n    float occ = 0.0;\n    float occs = 0.0;\n    for (float m = 1.0; m <= 10.0; m +=1.0) {\n        float dm = texture(iChannel2, uv, m).x;\n        float occw = pow(m,1.0);\n        occs += occw;\n        occ += occw*softclamp(-1.0, 1.0, (d - dm),8.0);\n    }\n    occ /= occs;\n\n    occ = pow(softclamp(0.0,1.0,occ,12.0), 0.06);\n\n\tfragColor = occ*(0.1*spec + (1.2+0.5*spec) * vec4(colorFromSpectrum(getPackedSpectrum(iChannel1, fragCoord)),1));\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define HI_QUALITY\n\nivec2 imod(ivec2 x, ivec2 p) {\n\t\treturn x - p * (x/p);\n}\n\n#define MOUSE_RADIUS 0.0002\n\n#define MOUSE_VEC vec4(mousePath(iTime),mousePath(iTime-2.0))\nvec2 mousePath(float T) {\n    return vec2(0.5 + 0.3 * cos(T) / (1.0 + sin(T)*sin(T)), 0.5+0.5*cos(T)*sin(T) / (1.0 + sin(T)*sin(T)));\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x,0.0, 1.0) * 255.0);\n    uvec4 r = uvec4(x) & uvec4(0xFF);\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    vec4 fmag = vec4(r) / 255.0;\n    return fmag;\n}\n\n#define unpack(x) unpackUnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packUnorm4x8(x))\n\n#define unpack16(x) unpackSnorm2x16(floatBitsToUint(x))\n#define pack16(x) uintBitsToFloat(packSnorm2x16(x))\n\n\n#define WAVELENGTHS 16\n\n#define SQRT_TWO_PI 2.50662827463\nfloat gaussian(float x, float mu, float sig) {\n    return (1.0/(SQRT_TWO_PI*sig)) * exp(-0.5 * pow((x-mu)/sig,2.0));\n}\n\n#define SS 1.04\n#define GSS 1.0\n//          |         |\n//0 1 2 3 4 5 6 7 8 9 A B C D E F\nvec3 sampleWeights(float i) {\n\treturn vec3(gaussian(i,2.666,SS),gaussian(i,7.5,GSS*SS),gaussian(i,12.333,SS));\n}\n\n#define LOG_SCALE0 0.90\n#define LOG_SCALE1 0.09\n#define LOG_SCALE2 5.28\n\nvoid upsample(vec3 upsamp, inout float spectrum[WAVELENGTHS]) {\n    vec3 col = vec3(0);\n    vec3 dw = vec3(0);\n    \n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        dw += sw;\n    }\n    \n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n\t\tspectrum[i] = -LOG_SCALE1*log(LOG_SCALE2*LOG_SCALE0*dot(sw/dw,1.0-upsamp));\n    }\n}\n\nvec3 downsample(float spectrum[WAVELENGTHS]) {\n    vec3 col = vec3(0);\n\t\tvec3 dw = vec3(0);\n\t\tfor(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        dw += sw;\n    }\n\n\t/* METHOD 1\n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        col += (sw/dw)*(1.0-exp(-spectrum[i]/LOG_SCALE1))/LOG_SCALE0;\n    }\n    return col;*/\n\n\t// METHOD 2\n\tfor(int i = 0; i < WAVELENGTHS; i++) {\n\t\tvec3 sw = sampleWeights(float(i));\n\t\tcol += -(sw/dw)*spectrum[i];\n\t}\n\treturn (1.0-exp(col/LOG_SCALE1))/LOG_SCALE0;\n}\n\nvoid vec16toArray(inout float spectrum[WAVELENGTHS], vec4 spec0, vec4 spec1, vec4 spec2, vec4 spec3) {\n    spectrum[0] = spec0.x;\n    spectrum[1] = spec0.y;\n    spectrum[2] = spec0.z;\n    spectrum[3] = spec0.w;\n    spectrum[4] = spec1.x;\n    spectrum[5] = spec1.y;\n    spectrum[6] = spec1.z;\n    spectrum[7] = spec1.w;\n    spectrum[8] = spec2.x;\n    spectrum[9] = spec2.y;\n    spectrum[10] = spec2.z;\n    spectrum[11] = spec2.w;\n    spectrum[12] = spec3.x;\n    spectrum[13] = spec3.y;\n    spectrum[14] = spec3.z;\n    spectrum[15] = spec3.w;\n}\n\nvoid unpackSpectrum(vec4 packed_spectrum, inout float spectrum[WAVELENGTHS]) {\n\tvec4 unpack0 = unpack(packed_spectrum.x);\n    vec4 unpack1 = unpack(packed_spectrum.y);\n    vec4 unpack2 = unpack(packed_spectrum.z);\n    vec4 unpack3 = unpack(packed_spectrum.w);\n\n    vec16toArray(spectrum, unpack0, unpack1, unpack2, unpack3);\n}\n\nvec3 colorFromSpectrum(vec4 packed_spectrum) {\n\t\tfloat spectrum[WAVELENGTHS];\n\t\tunpackSpectrum(packed_spectrum, spectrum);\n\t\treturn downsample(spectrum);\n}\n\nvec4 packSpectrum(float spectrum[WAVELENGTHS]) {\n\treturn vec4(\n        pack(vec4(spectrum[0],spectrum[1],spectrum[2],spectrum[3])),\n        pack(vec4(spectrum[4],spectrum[5],spectrum[6],spectrum[7])),\n        pack(vec4(spectrum[8],spectrum[9],spectrum[10],spectrum[11])),\n        pack(vec4(spectrum[12],spectrum[13],spectrum[14],spectrum[15]))\n    );\n}\n\nvec4 getPackedSpectrum(sampler2D channel, vec2 fragCoord) {\n\treturn texelFetch(channel, ivec2(floor(fragCoord)), 0);\n}\n\n// Fast Biquadratic Interpolation by paniq, Public Domain\n// https://www.shadertoy.com/view/wtXXDl\n\n// avoid hardware interpolation\n#define RESMOD(d,r) ivec2(imod((ivec2(r) + ivec2(imod(ivec2(d),ivec2(r)))), ivec2(r)))\n\nvec4 sample_biquadratic_exact(sampler2D channel, vec2 iResolution, vec2 uv) {\n\tivec2 LODres = textureSize(channel, 0);\n    vec2 q = fract(uv * vec2(LODres));\n    ivec2 t = ivec2(floor(uv * vec2(LODres)));\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, RESMOD(t + e.xx, LODres), 0);\n    vec4 s01 = texelFetch(channel, RESMOD(t + e.xy, LODres), 0);\n    vec4 s02 = texelFetch(channel, RESMOD(t + e.xz, LODres), 0);\n    vec4 s12 = texelFetch(channel, RESMOD(t + e.yz, LODres), 0);\n    vec4 s11 = texelFetch(channel, RESMOD(t + e.yy, LODres), 0);\n    vec4 s10 = texelFetch(channel, RESMOD(t + e.yx, LODres), 0);\n    vec4 s20 = texelFetch(channel, RESMOD(t + e.zx, LODres), 0);\n    vec4 s21 = texelFetch(channel, RESMOD(t + e.zy, LODres), 0);\n    vec4 s22 = texelFetch(channel, RESMOD(t + e.zz, LODres), 0);\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);\n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n#define PM(d) fract(d)\n\nvec4 sample_biquadratic_exact_lod(sampler2D channel, vec2 uv, int lod) {\n    ivec2 LODres = textureSize(channel, lod);\n    vec2 FC = uv * vec2(LODres);\n    vec2 q = fract(FC);\n    ivec2 t = ivec2(floor(FC));\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, RESMOD(t + e.xx, LODres), lod);\n    vec4 s01 = texelFetch(channel, RESMOD(t + e.xy, LODres), lod);\n    vec4 s02 = texelFetch(channel, RESMOD(t + e.xz, LODres), lod);\n    vec4 s12 = texelFetch(channel, RESMOD(t + e.yz, LODres), lod);\n    vec4 s11 = texelFetch(channel, RESMOD(t + e.yy, LODres), lod);\n    vec4 s10 = texelFetch(channel, RESMOD(t + e.yx, LODres), lod);\n    vec4 s20 = texelFetch(channel, RESMOD(t + e.zx, LODres), lod);\n    vec4 s21 = texelFetch(channel, RESMOD(t + e.zy, LODres), lod);\n    vec4 s22 = texelFetch(channel, RESMOD(t + e.zz, LODres), lod);\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);\n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n// accurate analytical gradient with 8 taps\nvec2 sample_biquadratic_gradient(sampler2D channel, vec2 res, vec2 uv, float mip) {\n    vec2 q = fract(uv * res);\n\t\tfloat sc = pow(2.0,mip);\n    vec2 c = sc * (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec2 cc = sc * 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx0 = textureLod(channel, fract(vec2(ww1.x, w0.y)), mip).r - textureLod(channel, fract(vec2(ww0.x, w0.y)), mip).r;\n    float nx1 = textureLod(channel, fract(vec2(ww1.x, w1.y)), mip).r - textureLod(channel, fract(vec2(ww0.x, w1.y)), mip).r;\n\n    float ny0 = textureLod(channel, fract(vec2(w0.x, ww1.y)), mip).r - textureLod(channel, fract(vec2(w0.x, ww0.y)), mip).r;\n    float ny1 = textureLod(channel, fract(vec2(w1.x, ww1.y)), mip).r - textureLod(channel, fract(vec2(w1.x, ww0.y)), mip).r;\n\n\treturn vec2(nx0 + nx1, ny0 + ny1) / 2.0;\n}\n\n#define SAMPLE_CHAN x\n\nvec2 sample_biquadratic_gradient_lod(sampler2D channel, vec2 uv, int lod) {\n    ivec2 LODres = textureSize(channel, lod);\n    vec2 FC = uv * (vec2(LODres));\n    vec2 q = fract(FC);\n    ivec2 t = ivec2(floor(FC));\n    ivec3 e = ivec3(-1, 0, 1);\n    float s_sw = texelFetch(channel, RESMOD(t + e.xx, LODres), lod).SAMPLE_CHAN;\n    float s_w  = texelFetch(channel, RESMOD(t + e.xy, LODres), lod).SAMPLE_CHAN;\n    float s_nw = texelFetch(channel, RESMOD(t + e.xz, LODres), lod).SAMPLE_CHAN;\n    float s_n  = texelFetch(channel, RESMOD(t + e.yz, LODres), lod).SAMPLE_CHAN;\n    float s_c  = texelFetch(channel, RESMOD(t + e.yy, LODres), lod).SAMPLE_CHAN;\n    float s_s  = texelFetch(channel, RESMOD(t + e.yx, LODres), lod).SAMPLE_CHAN;\n    float s_se = texelFetch(channel, RESMOD(t + e.zx, LODres), lod).SAMPLE_CHAN;\n    float s_e  = texelFetch(channel, RESMOD(t + e.zy, LODres), lod).SAMPLE_CHAN;\n    float s_ne = texelFetch(channel, RESMOD(t + e.zz, LODres), lod).SAMPLE_CHAN;\n\n    vec2 p = q * (q-1.0) + 0.5;\n    vec2 nq  = 1.0 - q;\n    vec2 nq2 = 1.0 - 2.0*q;\n    vec2 np  = 1.0 - p;\n    vec2 ppq = p+q-0.5;\n    vec2 pmq = p-q+0.5;\n\n    vec2 W_c  = vec2(2.0 * np.y * nq2.x, 2.0 * np.x * nq2.y);\n    vec2 W_n  = vec2(ppq.y * nq2.x, 2.0 * q.y * np.x);\n    vec2 W_s  = vec2(pmq.y * nq2.x, -2.0 * nq.y * np.x);\n    vec2 W_e  = vec2(2.0 * q.x * np.y, ppq.x * nq2.y);\n    vec2 W_w  = vec2(-2.0 * nq.x * np.y, pmq.x * nq2.y);\n    vec2 W_nw = vec2(-nq.x * ppq.y, pmq.x * q.y);\n    vec2 W_se = vec2(q.x * pmq.y, -ppq.x * nq.y);\n    vec2 W_ne = vec2(q.x * ppq.y, ppq.x * q.y);\n    vec2 W_sw = vec2(-nq.x * pmq.y, -pmq.x * nq.y);\n\n    vec2 sum = W_c * s_c + W_n * s_n + W_s * s_s + W_e * s_e + W_w * s_w\n            + W_nw * s_nw + W_se * s_se + W_ne * s_ne + W_sw * s_sw;\n\n    return sum / 2.0;\n}\n\nvec4 biquad(vec2 q, vec4 s00, vec4 s01, vec4 s02, vec4 s10, vec4 s11, vec4 s12, vec4 s20, vec4 s21, vec4 s22) {\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);\n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n// avoid hardware interpolation\nvoid sample_biquadratic_exact_unpack(sampler2D channel, vec2 uv, vec2 iResolution, out float spectrum[WAVELENGTHS]) {\n    vec2 q = fract(uv * iResolution);\n    ivec2 t = ivec2(floor(uv * iResolution));\n    ivec3 e = ivec3(-1, 0, 1);\n\n    vec4 p00 = texelFetch(channel, RESMOD(t + e.xx, iResolution), 0);\n    vec4 p01 = texelFetch(channel, RESMOD(t + e.xy, iResolution), 0);\n    vec4 p02 = texelFetch(channel, RESMOD(t + e.xz, iResolution), 0);\n    vec4 p12 = texelFetch(channel, RESMOD(t + e.yz, iResolution), 0);\n    vec4 p11 = texelFetch(channel, RESMOD(t + e.yy, iResolution), 0);\n    vec4 p10 = texelFetch(channel, RESMOD(t + e.yx, iResolution), 0);\n    vec4 p20 = texelFetch(channel, RESMOD(t + e.zx, iResolution), 0);\n    vec4 p21 = texelFetch(channel, RESMOD(t + e.zy, iResolution), 0);\n    vec4 p22 = texelFetch(channel, RESMOD(t + e.zz, iResolution), 0);\n\n\n    vec4 spec0 = biquad(q,\n                   unpack(p00.x), unpack(p01.x), unpack(p02.x),\n                   unpack(p10.x), unpack(p11.x), unpack(p11.x),\n                   unpack(p20.x), unpack(p21.x), unpack(p21.x));\n\n    vec4 spec1 = biquad(q,\n                   unpack(p00.y), unpack(p01.y), unpack(p02.y),\n                   unpack(p10.y), unpack(p11.y), unpack(p11.y),\n                   unpack(p20.y), unpack(p21.y), unpack(p21.y));\n\n    vec4 spec2 = biquad(q,\n                   unpack(p00.z), unpack(p01.z), unpack(p02.z),\n                   unpack(p10.z), unpack(p11.z), unpack(p11.z),\n                   unpack(p20.z), unpack(p21.z), unpack(p21.z));\n\n    vec4 spec3 = biquad(q,\n                   unpack(p00.w), unpack(p01.w), unpack(p02.w),\n                   unpack(p10.w), unpack(p11.w), unpack(p11.w),\n                   unpack(p20.w), unpack(p21.w), unpack(p21.w));\n\n    vec16toArray(spectrum, spec0, spec1, spec2, spec3);\n\n}\n\nvec4 bilin(vec2 q, vec4 p11, vec4 p12, vec4 p21, vec4 p22) {\n    vec4 x1 = mix(p11, p21, q.x);\n    vec4 x2 = mix(p12, p22, q.x);\n    return mix(x1, x2, q.y);\n}\n\n\nvoid sample_bilinear_unpack(sampler2D channel, vec2 uv, vec2 iResolution, out float spectrum[WAVELENGTHS]) {\n\n    vec2 p = uv * iResolution - 0.5;\n    vec2 q = fract(p);\n    vec2 tx = 1.0 / iResolution;\n    \n    ivec2 t = ivec2(floor(p));\n    \n    ivec3 e = ivec3(-1, 0, 1);\n\n    vec4 p12 = texelFetch(channel, RESMOD(t + e.yz, iResolution), 0);\n    vec4 p11 = texelFetch(channel, RESMOD(t + e.yy, iResolution), 0);\n    vec4 p21 = texelFetch(channel, RESMOD(t + e.zy, iResolution), 0);\n    vec4 p22 = texelFetch(channel, RESMOD(t + e.zz, iResolution), 0);\n\n    vec4 spec0 = bilin(q,\n                   unpack(p11.x), unpack(p12.x),\n                   unpack(p21.x), unpack(p22.x));\n\n    vec4 spec1 = bilin(q,\n                   unpack(p11.y), unpack(p12.y),\n                   unpack(p21.y), unpack(p22.y));\n\n    vec4 spec2 = bilin(q,\n                   unpack(p11.z), unpack(p12.z),\n                   unpack(p21.z), unpack(p22.z));\n\n    vec4 spec3 = bilin(q,\n                   unpack(p11.w), unpack(p12.w),\n                   unpack(p21.w), unpack(p22.w));\n\n    vec16toArray(spectrum, spec0, spec1, spec2, spec3);\n\n}\n\n\n// Only used for rendering, but useful helpers\nfloat softmax(float a, float b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nfloat softmin(float a, float b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nvec4 softmax(vec4 a, vec4 b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nvec4 softmin(vec4 a, vec4 b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nfloat softclamp(float a, float b, float x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(vec4 a, vec4 b, vec4 x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(float a, float b, vec4 x, float k) {\n\treturn (softmin(vec4(b),softmax(vec4(a),x,k),k) + softmax(vec4(a),softmin(vec4(b),x,k),k)) / 2.0;    \n}\n\n\n\n\n// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// a simple modification for this shader to get a vec4\nvec4 rand4( vec2 fragCoord, vec2 iResolution, int iFrame ) {\n    uvec2 p = uvec2(fragCoord);\n    uvec2 r = uvec2(iResolution);\n    uint c = p.x + r.x*p.y + r.x*r.y*uint(iFrame);\n\treturn vec4(hash3(c),hash1(c + 75132895U));\n}\n// End IQ's integer hash\n\n\n\n\n\n\n\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define K_FUNC_VEL 1.0\n#define K_FUNC_OFF 0.0\n#define OFFSET_SCALE_OFF 1.0\n#define OFFSET_SCALE_VEL 1.0\n#define OFFSET_TEMPORAL_SMOOTH 0.0\n#define ADVECT_TIMESTEP 1.0\n#define DIVERGENCE_MIN -0.02\n#define VELOCITY_FEED 1.0\n#define VISCOSITY 0.0015\n#define DAMPING 0.005\n#define MOUSE_AMP 1.0\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n#ifdef HI_QUALITY\n    #define E(d) sample_biquadratic_exact_lod(iChannel0, uv + texel * (d+0.), 0)\n#else\n    #define E(d) textureLod(iChannel0, uv + texel * (d+0.), 0.0)\n#endif\n#define K_F(k) (K_FUNC_VEL*k.xy+K_FUNC_OFF*k.zw)\nvec4 advect(vec2 uv, vec2 v, float ts){\n    vec2 texel = 1.0/iResolution.xy;\n    uv -= v * texel;\n    vec4 k1 = E();\n    vec4 k2 = E(-0.5*K_F(k1)*ts);\n    vec4 k3 = E(-0.5*K_F(k2)*ts);\n    vec4 k4 = E(-K_F(k3)*ts);\n    return 1.0*(k1+2.0*k2+2.0*k3+k4)/6.0;\n}\n#ifdef HI_QUALITY\n    #define C(x,y) sample_biquadratic_exact_lod(iChannel0, t*(U+float(1<<s)*vec2(x,y)), s)\n#else\n    #define C(x,y) textureLod(iChannel0, t*(U+float(1<<s)*vec2(x,y)), float(s))\n#endif\n#define D() sample_biquadratic_gradient_lod(iChannel2, uv, s)\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = O-O;\n    vec2 t = 1./iResolution.xy;\n    vec2 uv = U*t;\n\n    int s = int(max(log2(iResolution.x),log2(iResolution.y)));\n    vec2 mdiff = vec2(0);\n    vec4 sample_prev = textureLod(iChannel0, uv, 0.0);\n    vec2 offset_prev = sample_prev.zw;\n\tconst float L0 = -3.0;\n\tconst float L1 = 0.5;\n\tconst float L2 = 0.25;\n\tvec4 lapl = vec4(0);\n    for (; s >= 0; s--) {\n\t\tvec4 c_n = C(0,1);\n\t\tvec4 c_s = C(0,-1);\n\t\tvec4 c_e = C(1,0);\n\t\tvec4 c_w = C(-1,0);\n\t\tvec4 c_ne = C(1,1);\n\t\tvec4 c_se = C(1,-1);\n\t\tvec4 c_nw = C(-1,1);\n\t\tvec4 c_sw = C(-1,-1);\n\t\tvec4 c = C(0,0);\n\t\tlapl += pow(float(s+1),1.0) * (L0 * c + L1 * (c_n+c_e+c_w+c_s) + L2 * (c_ne+c_se+c_nw+c_sw));\n\t\tO.xy += pow(float(s+1),1.0) * (2.0 * vec2(c_n.x + c_s.x, c_e.y + c_w.y) -4.0 * c.xy + (c_se - c_ne - c_sw + c_nw).yx);\n        mdiff += pow(float(s+1),1.0) * D();\n    }\n    vec2 offset = OFFSET_SCALE_OFF*O.xy + OFFSET_SCALE_VEL*sample_prev.xy;\n    vec2 new_offset = mix(offset,offset_prev,OFFSET_TEMPORAL_SMOOTH);\n    O = vec4(advect(uv,new_offset,ADVECT_TIMESTEP).xy \n            + DIVERGENCE_MIN * mdiff \n            + VELOCITY_FEED * t.xx * new_offset \n            + VISCOSITY * lapl.xy \n            - DAMPING * sample_prev.xy\n            , new_offset\n    );\n\n    // mouse control\n    vec4 mouseUV;\n    if (iMouse.z > 0.0) {\n        mouseUV = iMouse / iResolution.xyxy;\n    } else {\n        mouseUV = MOUSE_VEC;\n    }   \n    vec2 delta = -normz(mouseUV.xy - abs(mouseUV.zw));\n    vec2 md = (mouseUV.xy - uv) * vec2(1.0,t.x/t.y);\n    float amp = clamp(exp(max(-24.0,-dot(md,md)/MOUSE_RADIUS)),0.0,1.0);\n    O += vec4(MOUSE_AMP * delta * amp,0,0);\n\n    // init\n    if(iChannelResolution[1].z < 1.0) {\n    \tO = vec4(1e-4);    \n    } else if(reset()) {\n        O = vec4(1e-4);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define K_FUNC_VEL 0.0\n#define K_FUNC_OFF 1.0\n#define ADVECT_INIT_VEL 0.0\n#define ADVECT_INIT_OFF 0.5\n#define ADVECT_TIMESTEP 0.7\n#define ADVECT_BLEND 1.0\n#define MOUSE_AMP 10.0\n#define SPEC_AMP_MAX 0.5\n#define SPEC_AMP_MIN -1.5\n\n#ifdef HI_QUALITY\n    #define E(d) sample_biquadratic_exact_lod(iChannel0, uv + tx * (d+0.), 0)\n#else\n    #define E(d) textureLod(iChannel0, uv + tx * (d+0.), 0.0)\n#endif\n\n#define K_F(k) (K_FUNC_VEL*k.xy+K_FUNC_OFF*k.zw)\nvec4 advect(vec2 uv, vec2 v, float ts, out float result[WAVELENGTHS]){\n    vec2 tx = 1.0/iResolution.xy;\n    uv -= v * tx;\n    vec4 k1 = E();\n\t\tfloat spectrum_advect0[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv - tx*K_F(k1), iResolution.xy, spectrum_advect0);\n    vec4 k2 = E(-0.5*K_F(k1)*ts);\n\t\tfloat spectrum_advect1[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv -0.5*tx*K_F(k2), iResolution.xy, spectrum_advect1);\n    vec4 k3 = E(-0.5*K_F(k2)*ts);\n\t\tfloat spectrum_advect2[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv -0.5*tx*K_F(k3), iResolution.xy, spectrum_advect2);\n    vec4 k4 = E(-K_F(k3)*ts);\n\t\tfloat spectrum_advect3[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv - tx*K_F(k4), iResolution.xy, spectrum_advect3);\n\n\t\tfor (int i = 0; i < WAVELENGTHS; i++) {\n\t\t\t result[i] = (spectrum_advect0[i]+2.0*spectrum_advect1[i]+2.0*spectrum_advect2[i]+spectrum_advect3[i])/6.0;\n\t\t}\n    return 1.0*(k1+2.0*k2+2.0*k3+k4)/6.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tx = 1.0 / iResolution.xy;\n\n    float spectrum[WAVELENGTHS];\n\n    vec4 A = textureLod(iChannel0, uv, 0.0);\n\n    vec4 packed_spectrum = getPackedSpectrum(iChannel2, fragCoord);\n    unpackSpectrum(packed_spectrum, spectrum);\n\n    float spectrum_advect[WAVELENGTHS];\n\n\tadvect(uv, ADVECT_INIT_OFF*A.zw + ADVECT_INIT_VEL*A.xy, ADVECT_TIMESTEP, spectrum_advect);\n\n    for (int i = 0; i < WAVELENGTHS; i++) {\n    \t spectrum[i] = mix(spectrum[i], spectrum_advect[i], ADVECT_BLEND);\n    }\n\n    // mouse control\n    vec4 mouseUV;\n    vec2 delta;\n    if (iMouse.z > 0.0) {\n        mouseUV = iMouse / iResolution.xyxy;\n        delta = -normz(mouseUV.xy - abs(mouseUV.zw));\n    } else {\n        mouseUV = MOUSE_VEC;\n        delta = -normz(mouseUV.xy - abs(mouseUV.zw));\n    }\n    \n    vec2 md = (mouseUV.xy - uv) * vec2(1.0,tx.x/tx.y);\n    float amp = clamp(MOUSE_AMP*exp(max(-24.0,-0.5*dot(md,md)/MOUSE_RADIUS)),0.0,1.0);\n\n    // generate a paint color spectrum\n    vec4 r0 = rand4(vec2(iTime), iResolution.xy, 0);\n    vec4 r1 = rand4(vec2(iTime), iResolution.xy, 1);\n    vec4 r2 = rand4(vec2(iTime), iResolution.xy, 2);\n    for (int i = 0; i < WAVELENGTHS; i++) {\n        float spec = (\n            r0.x * gaussian(float(i), float(WAVELENGTHS) * r0.y, r0.z * 2.0) +\n            r1.x * gaussian(float(i), float(WAVELENGTHS) * r1.y, r1.z * 2.0) +\n            r2.x * gaussian(float(i), float(WAVELENGTHS) * r2.y, r2.z * 2.0));\n\n        spectrum[i] = max(1.0/255.0,spectrum[i] + mix(SPEC_AMP_MIN,SPEC_AMP_MAX,r0.w) * spec * amp);\n    }\n\n    // init\n    if(iChannelResolution[1].z < 1.0) {  \n        fragColor = vec4(0);\n    } else if((iChannelResolution[1].z == 1.0 && texture(iChannel2,vec2(0.5)) == vec4(0))) {\n        vec3 up = textureLod(iChannel1, uv, 0.0).xyz;\n        upsample(up, spectrum);  \n        fragColor = packSpectrum(spectrum);\n    } else {\n\t\tfragColor = packSpectrum(spectrum);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    \n/*\nU:\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-7.0606907e-001   4.6167731e-001  -1.4625093e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n\nV:\n 6.2750203e-003  5.2398670e-002  3.7276962e-001\n-1.6414278e-003  4.2486224e-002  5.4995743e-001\n-4.3498466e-002 -1.0892533e-001  2.4023362e-001\n-1.3135171e-001 -3.3953004e-001 -7.8265086e-004\n-3.0484343e-001 -5.0984393e-001  1.8311873e-002\n-6.2280256e-001  3.2918550e-001 -2.3270335e-002\n-5.8224388e-076  3.2916004e-064 -1.0109051e-055\n 6.2280256e-001 -3.2918550e-001  2.3270335e-002\n 3.0484343e-001  5.0984393e-001 -1.8311873e-002\n 1.3135171e-001  3.3953004e-001  7.8265088e-004\n 4.3498466e-002  1.0892533e-001 -2.4023362e-001\n 1.6414278e-003 -4.2486224e-002 -5.4995743e-001\n-6.2750203e-003 -5.2398670e-002 -3.7276962e-001\n\ndiag(S):\n\n  5.2045614e-001\n  4.5787111e-002\n  5.3607463e-003\n  1.3379961e-003\n  2.4305267e-005\n  6.5520767e-008\n  2.7241624e-013\n  1.8098574e-013\n  4.2556708e-014\n  3.2104951e-014\n  5.6655005e-016\n  2.1958056e-018\n  1.0637097e-030\n\n*/\n\n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n\n    #define Po(m,n) texelFetch(iChannel0, RESMOD(ivec2(fragCoord) + ivec2(m,n), iResolution.xy), 0)\n    #define Go(m,n) texelFetch(iChannel1, RESMOD(ivec2(fragCoord) + ivec2(m,n), iResolution.xy), 0)\n\n    vec2 P1 = vec2(0);\n    vec2 P2 = vec2(0);\n    vec2 P3 = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n\n        vec2 t = Po(i,0).xy;\n        float g = Go(i,0).x;\n        \n        P1 += vec2(p_x1[index], p_y1[index]) * t;\n        P2 += vec2(p_x2[index], p_y2[index]) * t;\n        P3 += vec2(p_x3[index], p_y3[index]) * t;\n        \n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(iFrame <= 1 || reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(pack16(P1),pack16(P2),pack16(P1), G);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n\n    #define Po(m,n) texelFetch(iChannel0, RESMOD(ivec2(fragCoord) + ivec2(m,n), iResolution.xy), 0)\n\n    vec2 P = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n        \n        vec4 tx = Po(0,i);\n        vec2 t1 = unpack16(tx.x);\n        vec2 t2 = unpack16(tx.y);\n        vec2 t3 = unpack16(tx.z);\n\n        float g = tx.w;\n        \n        P += s_i[0] * vec2(p_x1[index], p_y1[index]).yx * t1;\n        P += s_i[1] * vec2(p_x2[index], p_y2[index]).yx * t2;\n        P += s_i[2] * vec2(p_x3[index], p_y3[index]).yx * t3;\n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(iFrame <= 1 || reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(P.x + P.y + G);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}