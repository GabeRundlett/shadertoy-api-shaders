{
    "Shader": {
        "info": {
            "date": "1496161719",
            "description": "Full demo: https://www.youtube.com/watch?v=-helx-SxnJo",
            "flags": 0,
            "hasliked": 0,
            "id": "MsXBW4",
            "likes": 26,
            "name": "OJ - Ljusf√§rd, scene 2",
            "published": 3,
            "tags": [
                "3d",
                "refraction"
            ],
            "usePreview": 0,
            "username": "rammoskar",
            "viewed": 730
        },
        "renderpass": [
            {
                "code": "#define TIME mod(iTime, 24.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n#define LPOS vec3(0, 2, 0)\nvec4 roomLight(vec3 pos) {\n\tvec3 lightCol = vec3(1,0.8, 0.8);\n\n\tfloat dis = sdSphere(pos - LPOS, 0.1);\n\n\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 30.0/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec4 laser(vec3 p) {\n\tvec3 lightCol = vec3(1,0.05, 0.05);\n\tfloat dx = 2.0;\n\tint partX = int(p.x / dx);\n\tp.x = mod(p.x, dx) - dx * 0.5;\n\tfloat dz = 4.0;\n\tp.z = mod(p.z, dz) - dz * 0.5;\n\tp.y -= -1.3;\n\tfloat music = drum; \n\tfloat dis = sdCappedCylinder(p.xzy, vec2(0.0, 1.0 * (0.2 + 0.8 * music))) - 0.05;\n\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 5.0/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 r = roomLight(pos);\n\tvec4 l = laser(pos);\n\tdis = min(r.w, l.w);\n\treturn r.xyz + l.xyz;\n}\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\n\tvec3 lpos = LPOS;\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 70.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.1*dis*dis);\n\tfloat tmp = 0.0;\n\tcolor =  color * (0.1 + 0.9*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n#define MAT_BOX 1.0\n#define MAT_GEL 2.0\n#define MAT_GROUND 3.0\n\nvec2 gels(vec3 p, inout bool inBox){\n\tfloat ttt = TIME * 1.6;\n\tfloat gelDis = 99999.0;\n\tfloat boxDis = 99999.0;\n\tfloat cycle = 14.0;\n\tfloat mz = 4.0;\n\tp.z += 2.0;\n\tfloat partZ = floor(p.z / mz);\n\tfloat iTimeZ = ttt + partZ * 3.0;\n\tfloat time = mod(iTimeZ, cycle);\n\n\tfloat t1 = max(0.0, time - 0.5);\n\tfloat t2 = time;\n\n\tfloat m = 3.0;\n\n\tp.x +=  smoothstep(cycle - 2.0, cycle, mod(iTimeZ, cycle)) * m;\n\tfloat part = floor((p.x) / m);\n\tp.x = mod(p.x, m) - m * 0.5;\n\n\n\tp.z = mod(p.z, mz) - mz * 0.5;\n\n\tfloat r = 0.3;\n\tfloat rt = iTimeZ;\n\tfloat yr = 1.0;\n\tfloat cx = \tcos(rt + p.y * yr)*r;\n\tfloat cz = \tsin(rt + p.y * yr)*r;\n\tfloat s = 1.0;\n\tfloat outer = 9999.0; \n\tfloat inner = 9999.0; \n\tfloat mt = mod(iTimeZ + 3.0, 60.0);\n\tif (partZ == 0.0) {\n\t\touter = length(p - vec3(0, 0.4 , 0)) - 1.2;\n\t\tinner = sdCappedCylinder(p - vec3(0, 2.5, 0), vec2(0.0, 2.0)) - 0.9;\n\t} else if(partZ == 1.0) {\n\t\touter = sdHexPrism(p.xzy - vec3(0, 0, 0), vec2(1.1, 1.1));\n\t\tinner = sdHexPrism(p.xzy - vec3(0, 0, 2), vec2(0.9, 2.0));\n\t} else if (partZ == -1.0) {\n\t\touter = udRoundBox(p, vec3(s), s * 0.1);\n\t\tinner = udRoundBox(p - vec3(0, 1.0, 0), vec3(s * 0.8, s, s * 0.8), s * 0.1);\n\t}\n\tboxDis = max(-inner, outer);\n\tif (boxDis > 0.01) {\n\t\tinBox = false;\n\n\t\tif (abs(partZ) <= 1.0) {\n\t\t\tt1 -= part * cycle;\n\t\t\tt2 -= part * cycle;\n\t\t\tfloat dis = p.y - min(t1, 9.0) * 0.1 + sin(length(p.xz*20.0) - 2.0*(1.0-smoothstep(10.0,12.0,t2)))*0.03*(1.0-0.8*smoothstep(8.0, 12.0, t2));\n\t\t\tif (inner > 0.01 || length(p.xz-vec2(cx, cz))*2.0 > t1) {\n\t\t\t\t\tdis = 999.0;\n\t\t\t\t}\n\t\t\tfloat dc = sdCappedCylinder(p - vec3(cx, 12.0 - min(t2 * 3.0, 2.0), cz), vec2(0.1, 10.0));\n\t\t\tfloat h = 3.0 - max(0.0, t2 - 8.0);\n\t\t\tif (p.y > h) {\n\t\t\t\tdc = max(dc,p.y - h);\n\t\t\t}\n\t\t\tgelDis = smink(dis, dc, 1.5);\n\t\t}\n\t}\n\treturn gelDis < boxDis || inBox ? vec2(gelDis, MAT_GEL) : vec2(boxDis, MAT_BOX);\n}\n\nvec2 map(vec3 p, inout bool inBox) {\n\tvec3 q = mod(p, 1.0) - 0.5;\n\tq.y = p.y + 2.0;\n\tfloat dis = length(max(abs(q)-vec3(0.3),0.0))- 0.3;\n\n\tq = mod(p.xzy, 1.0) - 0.5;\n\tq.y = p.z - 8.0;\n\tdis = min(dis, length(max(abs(q)-vec3(0.3),0.0))- 0.3 );\n\n\tq = mod(p.xzy, 1.0) - 0.5;\n\tq.y = p.z + 8.0;\n\tdis = min(dis, length(max(abs(q)-vec3( 0.3),0.0))-  0.3 );\n\n\tvec2 res = vec2(dis, MAT_GROUND);\n    res = un(res, gels(p, inBox));\n\treturn res;\n}\n\nvec2 map(vec3 p) {\n\tbool tmp = false;\n\treturn map(p, tmp);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz).x - map(p - ep.xyz).x;\n    normal.y = map(p + ep.yxz).x - map(p - ep.yxz).x;\n    normal.z = map(p + ep.yzx).x - map(p - ep.yzx).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal)\n{\n\tfloat o = clamp(2.0*map(p + normal * 0.5).x, 0.0, 1.0);\n\treturn 0.7 * o + 0.3; //fma(0.7, o, 0.3);\n}\n\n\n#define maxIter 200\n#define maxDis 300.0\nvec3 raymarch(vec3 ro, vec3 rd, vec3 eye) {\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tvec3 col = vec3(0);\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tbool inBox = false;\n\tfor (int i = 0; i < maxIter; i++) {\n\t\tvec3 p = ro + rd * t;\n\t\tvec2 res = map(p, inBox);\n\t\td = res.x;\n\t\tfloat fogAmount = 0.005;\n\t\tfloat lightDis = -1.0;\n\t\tvec3 light = evaluateLight(p, lightDis);\n\t\td = min(min(d, 1.0), max(lightDis, 0.05)); \n\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\tscatteredLight += transmittance * lightIntegrated;\n\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\tt += d;\n\t\tfloat m = res.y;\n\t\tif (d < 0.01) {\n\t\t\tvec3 c = vec3(1);\n\t\t\tvec3 normal = getNormal(p);\n\t\t\tif (m == MAT_BOX) {\n\t\t\t\tc = vec3(0.7, 0.6, 0.4);\n\t\t\t} else if(m == MAT_GEL) {\n\t\t\t\tif (p.z > 2.0) {\n\t\t\t\t\tc = vec3(0.1, 0.8, 0.3);\n\t\t\t\t} else if (p.z < -2.0) {\n\t\t\t\t\tc = vec3(0.9, 0.2, 0.3);\n\t\t\t\t} else {\n\t\t\t\t\tc = vec3(0.3, 0.1, 0.7);\n\t\t\t\t}\n\t\t\t} else if(m == MAT_GROUND) {\n\t\t\t\tvec3 fp = floor(p);\n\t\t\t\tc = vec3(0.5);//texCube(iChannel0, p * 1.0 + floor(p) * 1.3, normal, 1.0).xyz * 0.5 + 0.5;\n\t\t\t\tif (abs(p.z) <= 1.0 || abs(p.z + 4.0) <= 1.0 || abs(p.z - 4.0) <= 1.0) {\n\t\t\t\t\tc = mix(c, vec3(0.2, 0.5, 0.7), 0.5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc *= occlusion(p, normal);\n\t\t\taddLightning(c, normal, eye, p);\n\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\n\t\t\tinBox = true;\n\t\t\tref *= 0.8;//0.8\n\t\t\ti = 0;\n\n\t\t\tif (m != MAT_BOX){\n\t\t\t\treturn col;\n\t\t\t}\n\n\t\t\trd = refract(rd, getNormal(p), 1.0/1.3);\n\t\t\tro = p + rd*0.05;\n\t\t\tt = 0.0;\n\t\t}\n\t\tif (t > maxDis ||  ref < 0.1) {\n\t\t\treturn col;\n\t\t}\n\t}\n\n\treturn col;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n    \n    float t = TIME * 0.25;\n    vec3 eye = vec3(sin(t) * 3.5, 2.5 + 0.5 * sin(t) , cos(t) * 3.5);\n\tvec3 tar = vec3(0, 0 , sin(t) * 1.5);//eye + vec3(0.0, 0.0, 1.0);\n\n\tfloat mt = mod(TIME, 25.0);\n\tfloat tpart = floor(mt / 5.0);\n\tfloat tmp = mod(mt, 5.0)*1.5;\n\tif (tpart == 0.0) {\n\t\teye = vec3(0.0, 2.0 + tmp * 0.3, 0.0);\n\t\ttar = vec3(0.1);\n\t} else if (tpart == 1.0) {\n\t\teye = vec3(0, 3, 1.5 + tmp * 0.2);\n\t\ttar = eye + vec3(1,-0.8,0);\n\t} else if (tpart == 2.0) {\n\t\teye = vec3(4.0, 3.0, -3.0 + tmp * 0.2);\n\t\ttar = eye + vec3(-1,-0.8,0.5);\n\t} else if (tpart == 3.0) {\n\t\teye = vec3(3.5, 2, 6.5 - tmp * 0.2);\n\t\ttar = eye + vec3(0,-0.5,-1);\n\t} else /*if (tpart == 4.0) */{\n\t\tvec3 start = vec3(0, 15, 0);\n\t\ttar = LPOS + vec3(0.01);//vec3(0.1);\n\t\teye = start  + smoothstep(4.0, 6.0, tmp)*(tar - start);\n\t}\n\n\n\tvec3 dir = normalize(tar - eye);\n\tfloat rot = TIME * 0.5;\n\tvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), dir));\n\tvec3 up = cross(dir, right);\n\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n//\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, eye);\n\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}