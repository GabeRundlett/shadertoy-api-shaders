{
    "Shader": {
        "info": {
            "date": "1550747469",
            "description": "A procedural color pattern algo. Small write up on it here: https://link.medium.com/7Pe7frHduU",
            "flags": 0,
            "hasliked": 0,
            "id": "3s23D3",
            "likes": 5,
            "name": "Procedural color palettes",
            "published": 3,
            "tags": [
                "procedural",
                "colorpalettes",
                "colortheorem"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 1369
        },
        "renderpass": [
            {
                "code": "// procedural color idea. The geometry is based on code from The_ArtOfCode.\n\n#define iTime iTime*0.4\n#define _Color1 vec3(abs(cos(iTime+12.) + sin(iTime*0.7 + 71.124)*0.5),abs(cos(iTime) + sin(iTime*0.8 + 41.)*0.5) ,abs(cos(iTime+61.) + sin(iTime*0.8 + 831.32)*0.5))\n#define _Color2 vec3(abs(sin(iTime ) + sin(0.6 * iTime+ 21.)*0.5),abs(sin(iTime *0.9 +215.12) + sin(0.93 * iTime+ 52.231)*0.5),abs(sin(iTime+ 12.512 ) + sin(0.8 * iTime+ 58.15)*0.5))\n#define _Color3 vec3(abs(sin(iTime *0.58 +89.21) + sin(0.76 * iTime+ 7232.)*0.5),abs(sin(iTime *1.1 +0.124) + sin(0.5 * iTime+ 712.)*0.5),abs(sin(iTime+ 1.6) + sin(iTime *0.5 + 12.512) *0.5))\n\nfloat rand(vec2 seed){\n return fract(sin( dot(seed, vec2(21.41,13.2)) * 4.)*10.);   \n}\n\nfloat randOneD(float seed){\n    return fract(sin(seed*21.)*61.);\n}\n\n\nvec3 sampleOnATriangle(float r1, float r2 ){\n  return (1. - sqrt(r1))*_Color1 + (sqrt(r1)*(1. - r2))*_Color2\n\t\t\t\t+ (r2*sqrt(r1)) * _Color3;   \n}\n\n\nfloat Circles(vec2 uv, float tiling, out float seed, out float  edge){\n    \n    float m = 0.;\n    for(int x= -1; x<= 1; x++){\n        \n        for(int y = -1; y<= 1; y++){\n         \t\n            \n  \t\t\t  vec2 fracUV = fract(uv * tiling) + vec2(x,y);\n   \t\t\t  vec2 intUV = floor(uv * tiling) + vec2(x,y);\n   \t\t \n    \t\t  float rd = rand(intUV );\n              \tvec2 center = vec2( 0.5) ;\n                vec2 centerToPixel =  fracUV -center;\n   \t\t\t\t float angle = atan(centerToPixel.y, centerToPixel.x);\n    \t\t  \n    \t\t  float radius = 0.5+  0.4 * abs(sin(iTime * 0.8 )+ sin(iTime*1. + 51.215))\n                  + (abs(sin(angle*3. -iTime )+ sin(angle*4. +iTime))) * abs( sin(iTime) +sin(iTime*0.8 + 21.1256))*0.1;\n            \n          float seedController =  1.-smoothstep(radius, radius+0.0001,distance(fracUV, center ));\n  \t\t\t  m += seedController;\n            \n              edge *= 1.-smoothstep(0.03*1./(iResolution.x/600.), .00,abs(distance(fracUV, center )-radius));\n              seed += mix(0.,dot(intUV, vec2(21.214,6.214)), seedController); \n        }\n        \n    }\n    \n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = vec3(1.,1.,1.);\n    \n    float tiling = 5.;\n    \n    \n    float seed = 0.;\n    float edge = 1.;\n    float m = Circles(uv, tiling, seed, edge);\n\n    col.xyz = mix(sampleOnATriangle(randOneD(m+61. ), randOneD(m)),\n                  sampleOnATriangle(randOneD(m+1.+seed), randOneD(m+125.+seed)), mod(m, 2.));\n    col.xyz = mix(col.xyz, _Color1*0.7,1.-edge);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}