{
    "Shader": {
        "info": {
            "date": "1469341263",
            "description": "Click on the screen or use the arrow keys to move. Try to get above 2000! Every levels you get a chance to shoot a +500 bonus. The game goes on forever and the enemies/projectiles positions are the same for everyone. Music is Capsule in Space by Ceephax.",
            "flags": 112,
            "hasliked": 0,
            "id": "XldGDN",
            "likes": 24,
            "name": "[SH16C] Aliens vs. Humans",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "retro",
                "space",
                "sh16c",
                "schmup"
            ],
            "usePreview": 1,
            "username": "Klems",
            "viewed": 2197
        },
        "renderpass": [
            {
                "code": "\n// display gameplay buffer in the lower left corner\n// #define GAMEPLAY_BUFFER_SCALE 4.0\n\n// size between each transitions\n#define TRANSITION 3000.0\n// scroll speed of the player, in pixels per frames\n#define SCROLL_SPEED 0.65\n// duration between each transitions\n#define TRANSITION_PERIOD (TRANSITION/SCROLL_SPEED)\n\n#define PI 3.14159265359\n\nconst vec3 ENNEMY_COLOR = vec3(0.6, 0.2, 0.7);\nconst vec3 FRIEND_COLOR = vec3(0.4, 1.0, 0.3);\nconst vec3 BACKGROUND_COLOR = vec3(0.7, 0.8, 1.0);\n\n// size of pixel on screen, resolution dependant\nfloat pixelSize;\n// time since the beginning\nfloat gameplayGlobalTime;\n\nfloat doDithering( in float value, in float noise, in float frac ) {\n    value += (noise * 1.8 - 0.9) / frac;\n    value = floor(value*frac) / (frac - 1.0);\n    value = clamp(value, 0.0, 1.0);\n    return value;\n}\n\nint imod( in int a, in int n ) {\n\treturn a - (n * int(a/n));\n}\n\n// iq's 3D noise\nfloat noise( in vec3 x ) {\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel3, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat hash1( in float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*438.5453);\n}\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat triangle( in vec2 uv, in vec2 n ) {\n    vec2 uuv = vec2(abs(uv.x), uv.y);\n    return max(-uv.y, dot(n, uuv));\n}\n\nfloat diamond( in vec2 uv, in float top, in float bottom ) {\n    if (uv.y > 0.0) uv.y /= top;\n    if (uv.y < 0.0) uv.y /= bottom;\n    vec2 a = abs(uv);\n    return a.x + a.y;\n}\n\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Thanks P_Malin, see https://www.shadertoy.com/view/4sf3RN\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat InRect(const in vec2 vUV, const in vec4 vRect) {\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\nfloat SampleDigit(const in float fDigit, const in vec2 vUV) {\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\tif(fDigit < 0.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y1, x2, y4);\n\t} else if(fDigit < 1.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y5); \n        vRect1 = vec4(x0, y0, x0, y0);\n\t} else if(fDigit < 2.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y3, x2, y4); \n        vRect2 = vec4(x1, y1, x3, y2);\n\t} else if(fDigit < 3.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y3, x2, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 4.5) {\n\t\tvRect0 = vec4(x0, y1, x2, y5); \n        vRect1 = vec4(x1, y2, x2, y5); \n        vRect2 = vec4(x2, y0, x3, y3);\n\t} else if(fDigit < 5.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x3, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 6.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x3, y4); \n        vRect2 = vec4(x1, y1, x2, y2);\n\t} else if(fDigit < 7.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x0, y0, x2, y4);\n\t} else if(fDigit < 8.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y1, x2, y2); \n        vRect2 = vec4(x1, y3, x2, y4);\n\t} else if(fDigit < 9.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); \n        vRect1 = vec4(x1, y3, x2, y4); \n        vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 10.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t} else if(fDigit < 11.5) {\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\treturn mod(fResult, 2.0);\n}\n\n// STORAGE\n\nconst vec2 ADR_PLAYER = vec2(0, 0);\nconst vec2 ADR_GAME = vec2(8, 0);\nconst vec2 ADR_SCORE = vec2(16, 0);\nconst vec2 ADR_PLAYER_PROJ_FIRST = vec2(24, 0);\nconst vec2 ADR_PLAYER_PROJ_LAST = vec2(31, 0);\nconst vec2 ADR_ALIEN_SHIP_FIRST = vec2(0, 8);\nconst vec2 ADR_ALIEN_SHIP_LAST = vec2(31, 8);\nconst vec2 ADR_ALIEN_SHIP_PROJ_FIRST = vec2(0, 16);\nconst vec2 ADR_ALIEN_SHIP_PROJ_LAST = vec2(31, 23);\n\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n// RENDERING\n\nfloat explosion( in float seed, in vec2 uv, in float frac, in float radius ) {\n    float len = length(uv);\n    vec2 decal = vec2(hash1(seed*0.41355),\n                      hash1(seed*9.00412))*2.0-1.0;\n    decal *= radius*0.15;\n    float len2 = length(uv+decal);\n    float expl = frac * radius;\n    float explosion = smoothstep(expl*0.75, expl+1.0, len);\n    explosion *= 1.0 - smoothstep(expl+3.0, expl+4.0, len2);\n    explosion *= frac;\n    explosion *= 1.0 - smoothstep(0.6, 1.0, frac);\n    return explosion;\n}\n\n// small ship, cannon fodder\nvec4 getShipFighterColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    frac = smoothstep(0.0, 0.2, frac);\n    uv.y *= -1.0;\n    uv.y += 2.0;\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    \n    float tri = triangle(uv, normalize(vec2(3, 1))) - 5.0;\n    float wings = triangle(uv + vec2(0, -4.5), normalize(vec2(1, 3))) - 1.5;\n    wings = min(wings, box(uv, vec2(13, 2)));\n    float cockpit = diamond(uv+vec2(0, 2), 3.0, 0.6) - 4.0;\n    float mm = min(tri, wings);\n    \n    vec4 colorBase = vec4(ENNEMY_COLOR, 1.0);\n    \n    if (tri > 0.0) colorBase.rgb *= 0.5;\n    else colorBase.rgb *= 1.0 + dither*(-tri*0.5);\n    if (cockpit < 0.0) {\n        if (cockpit < -1.5) colorBase.rgb = ENNEMY_COLOR * 4.0;\n        else colorBase.rgb = vec3(0);\n    }\n    if (mm > 0.0) {\n        if (mm > 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    if (colorBase.a < 0.5) {\n        float trail = 1.0;\n        if (abs(uv.x) > 3.0) trail = 0.0;\n        if (uv.y > 0.0) trail = 0.0;\n        trail *= 1.0 - smoothstep(0.0, 20.0, -uv.y);\n        colorBase = vec4(ENNEMY_COLOR*3.0, trail);\n    }\n    \n    colorBase.a *= 1.0 - frac;\n    \n    float explo = explosion(float(index)+shipValue.z, uv, frac, 12.0);\n    colorBase += vec4(ENNEMY_COLOR, 1)*explo;\n    \n    return colorBase;\n}\n\n// small ship but tankier than a fighter\nvec4 getShipKnightColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    frac = smoothstep(0.0, 0.2, frac);\n    uv.y *= -1.0;\n    uv.y += 6.0;\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    \n    float tank = triangle(uv, normalize(vec2(6, 1)));\n    tank = max(tank, uv.y-8.0) - 9.0;\n    float cockpit = diamond(uv+vec2(0.0, -17.0), 0.7, 3.0) - 4.5;\n    \n    vec2 uuv = uv;\n    uuv.x = abs(uuv.x);\n    float guns = box(uuv-vec2(9, 12), vec2(2, 8)) - 0.0;\n    \n    vec4 colorBase = vec4(ENNEMY_COLOR, 1.0);\n    \n    if (tank > 0.0) {\n        colorBase.rgb *= 0.5;\n        colorBase.rgb *= 1.0 - dither*(-guns*0.5);\n    } else {\n        colorBase.rgb = mix(ENNEMY_COLOR, vec3(0.3), 0.7);\n        colorBase.rgb *= 1.0 + dither*-tank*0.1;\n        colorBase.rgb -= max(0.0, -cockpit+2.5)*dither*0.1;\n        float xx = abs(uv.x);\n        if (xx > 7.5) colorBase.rgb = ENNEMY_COLOR;\n    }\n    if (cockpit < 0.0) {\n        float alea = sin(gameplayGlobalTime*8.0 + float(index)*5.0832)*0.5+0.5;\n        if (cockpit < -1.5) colorBase.rgb = ENNEMY_COLOR * (1.0 + alea*3.0);\n        else colorBase.rgb = vec3(0);\n    }\n    \n    float mm = min(tank, guns);\n    mm = min(mm, cockpit);\n    if (mm > 0.0) {\n        if (mm > 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n\n    colorBase.a *= 1.0 - frac;\n    \n    float explo = explosion(float(index)+shipValue.z, uv, frac, 20.0);\n    colorBase += vec4(ENNEMY_COLOR, 1)*explo;\n    \n    return colorBase;\n}\n\n// small, fast, low health, dangerous\nvec4 getShipNinjaColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    frac = smoothstep(0.0, 0.2, frac);\n    uv.y *= -1.0;\n    uv.y += 2.0;\n    uv *= 1.2;\n    \n    vec2 uuv = vec2(abs(uv.x), uv.y);\n    uuv *= rot(-0.5);\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    \n    float tri = triangle(uv+vec2(0, -4), normalize(vec2(5, 2))) - 5.0;\n    float wings = length(uv+vec2(0, -18)) - 18.0;\n    wings = max(-wings, length(uv+vec2(0, -8)) - 15.0);\n    float cockpit = diamond(uv, 3.0, 3.0) - 4.0;\n    \n    float blades = triangle(uuv+vec2(0, 0), normalize(vec2(7, 2))) - 4.0;\n    \n    vec4 colorBase = vec4(ENNEMY_COLOR, 1.0);\n    \n    if (wings < 0.0) {\n        if (wings > -0.5) colorBase.rgb = vec3(0);\n        else {\n            colorBase.rgb = mix(colorBase.rgb, vec3(0.6), 0.5);\n            colorBase.rgb *= 1.0 + dither*-wings*0.2;\n        }\n    } else {\n        colorBase.rgb *= 0.5;\n        colorBase.rgb *= 1.0 + dither*(-tri*0.5);\n        if (cockpit < 0.0) {\n        \tif (cockpit < -1.5) colorBase.rgb = ENNEMY_COLOR * 4.0;\n        \telse colorBase.rgb = vec3(0);\n    \t}\n    }\n    \n    float mm = min(wings, tri);\n    mm = min(blades, mm);\n    \n    if (mm > 0.0) {\n        if (mm > 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    colorBase.a *= 1.0 - frac;\n    \n    float explo = explosion(float(index)+shipValue.z, uv, frac, 16.0);\n    colorBase += vec4(ENNEMY_COLOR, 1)*explo;\n    \n    return colorBase;\n}\n\n// fire horizontally\nvec4 getShipPillarColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    frac = smoothstep(0.0, 0.2, frac);\n    vec2 uuv = uv;\n    uv = abs(uv);\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    \n    float tank = triangle(uv + vec2(0, -7), normalize(vec2(2, 1))) - 4.5;\n    float middle = box(uv, vec2(4, 5));\n    \n    vec4 colorBase = vec4(ENNEMY_COLOR, 1.0);\n    \n    if (tank < 0.0) {\n        colorBase.rgb = mix(ENNEMY_COLOR, vec3(0.1), 0.7);\n        colorBase.rgb *= 1.0 + dither*-tank*0.3;\n        colorBase.rgb *= 1.0 - dither*-middle*0.2;\n        float xx = abs(uv.x);\n        if (xx > 7.5) colorBase.rgb = ENNEMY_COLOR;\n    } else if (middle < 0.0) {\n        float alea = sin(gameplayGlobalTime*7.0 + float(index)*5.0832)*0.5+0.5;\n        float bar = fract(gameplayGlobalTime*1.0 + float(index)*5.0832);\n        bar = cos(bar*PI)*5.0;\n        colorBase.rgb = ENNEMY_COLOR*(2.0+3.0*alea);\n        colorBase.rgb *= 1.0 + dither*-middle*0.5;\n        if (abs(uuv.x-bar) < 1.0) colorBase.rgb = vec3(0);\n    }\n    \n    float mm = min(tank, middle);\n    if (mm > 0.0) {\n        if (mm > 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    colorBase.a *= 1.0 - frac;\n    \n    float explo = explosion(float(index)+shipValue.z, uv, frac, 20.0);\n    colorBase += vec4(ENNEMY_COLOR, 1)*explo;\n        \n    return colorBase;\n}\n\n// big ship, moderate HP, lots of bullets\nvec4 getShipFregateColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    frac = smoothstep(0.0, 0.3, frac);\n    uv.y *= -1.0;\n    uv.y += 10.0;\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    \n    float tri = triangle(uv, normalize(vec2(4, 1))) - 14.0;\n    tri = max(tri, uv.y-40.0);\n    \n    float wings = triangle(uv + vec2(0, -6), normalize(vec2(1, 3))) - 5.0;\n    wings = min(wings, box(uv + vec2(0.0, 4.0), vec2(35.0, 4.0)));\n    wings = min(wings, triangle(uv + vec2(0, -32), normalize(vec2(1, 3))) - 3.0);\n    wings = min(wings, box(uv + vec2(0, -25), vec2(23.0, 3.0)));\n    float control = box(uv + vec2(0, 9), vec2(31.0, 5.0));\n    float cockpit = diamond(uv+vec2(0.0, 2.0), 2.5, 0.9) - 8.0;\n    \n    vec2 uuv = uv;\n    uuv.x = abs(uuv.x);\n    float guns = box(uuv-vec2(17, 28), vec2(2, 8)) - 0.0;\n    \n    vec4 colorBase = vec4(ENNEMY_COLOR, 1.0);\n    \n    if (tri > 0.0) {\n        colorBase.rgb *= 0.5;\n        if (abs(control) < 1.0) colorBase.rgb *= 0.4;\n        else if (control < 0.0) colorBase.rgb *= 1.5;\n        else if (guns < 0.0 && wings > 0.0) colorBase.rgb *= 0.4;\n    } else {\n        colorBase.rgb = mix(colorBase.rgb, vec3(0.6), 0.5);\n        colorBase -= smoothstep(-6.0, 0.0, tri)*0.5*dither;\n    }\n    \n    if (cockpit < 0.0) {\n        if (cockpit < -1.5) {\n            colorBase.rgb = ENNEMY_COLOR * 2.0;\n            colorBase.rgb += (1.0-smoothstep(-8.0, 0.0, cockpit)) * dither;\n        } else colorBase.rgb = vec3(0);\n    }\n\t\n    float mm = min(tri, wings);\n    mm = min(guns, mm);\n    \n    if (mm > 0.0) {\n        if (mm > 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    if (colorBase.a < 0.5) {\n        float trail = 1.0;\n        if (abs(uv.x) > 10.0) trail = 0.0;\n        if (uv.y > 0.0) trail = 0.0;\n        trail *= 1.0 - smoothstep(10.0, 22.0, -uv.y);\n        colorBase = vec4(ENNEMY_COLOR*3.0, trail);\n    }\n    \n    colorBase.a *= 1.0 - frac;\n    \n    float explo = explosion(float(index)+shipValue.z, uv, frac, 48.0);\n    colorBase += vec4(ENNEMY_COLOR, 1)*explo;\n    \n    return colorBase;\n}\n\n// huge ship, lots of HP, maze attack\nvec4 getShipMotherColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    float len = length(uv);\n    float theta = atan(uv.y, uv.x)*0.5 + 0.5*PI;\n    \n    float radius = len - 40.0;\n    float x = len / 40.0;\n    vec3 norm = normalize(vec3(uv, sqrt(1.0-x*x)*40.0));\n    \n    float rot = gameplayGlobalTime*0.25;\n    float blades = smoothstep(0.6, 0.65, abs(fract((theta+rot)/PI*5.0)*2.0-1.0));\n    blades = max(radius-6.0, blades);\n    \n    float grebble = cos((theta+rot)*100.0)*0.5+0.5;\n    float grebble2 = cos(theta*50.0)*0.5+0.5;\n    \n    vec4 colorBase = vec4(ENNEMY_COLOR, 1.0);\n    \n    if (radius < -23.0) {\n    \t\n        float alea = sin(gameplayGlobalTime*1.0);\n        colorBase += doDithering(1.0-smoothstep(0.0, 20.0, len), dither, 4.0)*(1.7+alea);\n    } else if (radius < -15.0) {\n        colorBase *= 0.4;\n        colorBase -= doDithering(grebble2, dither, 4.0)*0.2;\n        float spin = abs(radius+19.0);\n        float spinAngle = max(0.0, shipValue.w) / 130.0 * PI;\n        if (spin < 4.0) {\n            if (spin < 2.0) {\n                if (spinAngle >= theta) {\n                    colorBase.rgb = ENNEMY_COLOR*2.0;\n                }\n            } else {\n                colorBase.rgb = vec3(0);\n            }\n        }\n    } else if (radius < 0.0) {\n        colorBase.rgb = mix(colorBase.rgb, vec3(0.4), 0.4);\n        float d = max(0.0, dot(norm, normalize(vec3(10, 8, 13))));\n        colorBase += doDithering(d, dither, 4.0)*0.4;\n    } else {\n        colorBase *= 0.4;\n        colorBase -= doDithering(grebble, dither, 4.0)*0.2;\n    }\n    \n    float mm = min(blades, radius);\n    \n    if (mm > 0.0) {\n        if (mm >= 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    if (colorBase.a < 0.5) {\n        colorBase.rgb = ENNEMY_COLOR;\n    }\n    \n    colorBase.a *= 1.0 - frac;\n    \n    // add 4 explosions\n    for (int i = 0 ; i < 4 ; i++) {\n        vec2 decal = vec2(hash1(float(i)*0.41355+shipValue.z),\n                          hash1(float(i)*9.00412+shipValue.z*8.223))*2.0-1.0;\n        decal *= 30.0;\n        float rad = hash1(float(i)*431.412+shipValue.z*752.35)*50.0;\n        float start = float(i)*0.2;\n        float explofrac = smoothstep(start, start+0.3, frac);\n        float explo = explosion(float(i)+shipValue.z, uv+decal, explofrac, 20.0 + rad);\n    \tcolorBase += vec4(ENNEMY_COLOR, 1)*explo;\n    }\n    \n    return colorBase;\n}\n\n// bonus ship (not a ship, duh)\nvec4 getShipBonusColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    frac = smoothstep(0.0, 0.2, frac);\n    vec2 uuuv = abs(uv);\n    uv *= rot(gameplayGlobalTime*1.75);\n    vec2 uuv = uv;\n    uv = abs(uv);\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    \n    float tank = box(uv, vec2(2, 8)) - 2.5;\n    tank = max(tank, 5.0-uv.y);\n    float middle = box(uv, vec2(3, 5));\n    \n    vec4 colorBase = vec4(FRIEND_COLOR, 1.0);\n    \n    if (tank > middle) {\n        float dd = dot(uuv, vec2(1, 1)) + gameplayGlobalTime*15.0;\n        dd = fract(dd*0.2);\n        colorBase.rgb *= step(0.5, dd);\n    } else {\n        colorBase.rgb = mix(colorBase.rgb, vec3(0.6), 0.8);\n        colorBase.rgb *= 1.0 + dither*-tank*0.5;\n    }\n    \n    float mm = min(tank, middle);\n    if (mm > 0.0) {\n        if (mm > 1.5) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    if (colorBase.a < 0.5) {\n        float explo = explosion(float(index)+shipValue.z, uv,\n                                fract(gameplayGlobalTime*0.5), 14.0);\n    \tcolorBase = vec4(FRIEND_COLOR, explo*0.5);\n    }\n    \n    colorBase.a *= 1.0 - frac;\n    \n    uuuv.x *= 0.5;\n    float radius = min(abs(uuuv.x), abs(uuuv.y));\n    float explo = explosion(float(index)+shipValue.z, uuuv, frac, 48.0-radius);\n    colorBase += vec4(FRIEND_COLOR, 1)*explo;\n    \n    return colorBase;\n}\n    \n// texture for the player ship\nvec4 getPlayerShipColor( in vec2 uv, in float frac, in float seed ) {\n    \n    float dither = texture( iChannel2, uv / 8.0 ).r;\n    float len = length(uv);\n    float theta = atan(uv.y, uv.x)*0.5 + 0.5*PI;\n    \n    float radius = len - 5.5;\n    float x = len / 5.5;\n    vec3 norm = normalize(vec3(uv, sqrt(1.0-x*x)*5.5));\n    \n    vec2 uuv = uv;\n    uuv.x = abs(uuv.x);\n    float guns = box(uuv-vec2(6, 2), vec2(0, 5)) - 0.0;\n    float reguns = box(uuv-vec2(6, -3), vec2(0.5, 1.0)) - 1.0;\n    guns = min(guns, reguns);\n    \n    float cockpit = dot(norm, normalize(vec3(0, 10, 7)));\n    cockpit = smoothstep(0.4, 0.5, cockpit);\n    \n    vec4 colorBase = vec4(mix(FRIEND_COLOR.rgb, vec3(0.8), 0.9), 1.0);\n    \n    colorBase.rgb = mix(colorBase.rgb, FRIEND_COLOR*0.05, cockpit);\n    \n    if (radius < 0.0) {\n        float d = max(0.0, dot(norm, normalize(vec3(10, 8, 13))));\n        colorBase += doDithering(d, dither, 4.0)*0.4;\n    } else if (guns < 0.5) {\n        colorBase.rgb = FRIEND_COLOR;\n        if (reguns < 0.5) colorBase.rgb = mix(colorBase.rgb, vec3(0.3), 0.8);\n        if (radius < 1.0) colorBase.rgb = vec3(0);\n        if (uv.y > 5.5 && uv.y < 6.5) colorBase.rgb = vec3(0);\n    }\n        \n    float mm = min(radius, guns);\n    if (mm > 0.0) {\n        if (mm > 1.0) colorBase.a = 0.0;\n        else colorBase = vec4(0, 0, 0, 1);\n    } else colorBase.a = 1.0;\n    \n    colorBase.a *= 1.0 - frac;\n    \n    colorBase.rgb = mix(colorBase.rgb, vec3(1), frac);\n    \n    // add explosions\n    for (int i = 0 ; i < 8 ; i++) {\n        vec2 decal = vec2(hash1(float(i)*0.41355+seed),\n                          hash1(float(i)*9.00412+seed*9.3153))*2.0-1.0;\n        decal *= 10.0;\n        float rad = hash1(float(i)*431.412+seed*124.312)*20.0;\n        float start = float(i)*0.1;\n        float explofrac = smoothstep(start, start+0.1, frac);\n        float explo = explosion(float(i)*seed, uv+decal, explofrac, 16.0 + rad);\n    \tcolorBase += vec4(FRIEND_COLOR, 1)*explo;\n    }\n    \n    return colorBase;\n}\n\n// bbox for the ennemies\nvec2 getShipBBox( in int index ) {\n    if (index < 28) return vec2(50);\n    if (index < 30) return vec2(150);\n    if (index < 31) return vec2(200);\n    return vec2(200, 100);\n}\n\n// sprite sheet for the ennemies\nvec4 getShipColor( in int index, in vec2 uv, in float frac, in vec4 shipValue ) {\n    if (index < 8) return getShipFighterColor(index, uv, frac, shipValue);\n    if (index < 16) return getShipKnightColor(index, uv, frac, shipValue);\n    if (index < 24) return getShipNinjaColor(index, uv, frac, shipValue);\n    if (index < 28) return getShipPillarColor(index, uv, frac, shipValue);\n    if (index < 30) return getShipFregateColor(index, uv, frac, shipValue);\n    if (index < 31) return getShipMotherColor(index, uv, frac, shipValue);\n    return getShipBonusColor(index, uv, frac, shipValue);\n}\n\n// round to nearest pixel\nvec2 roundToWorld( in vec2 pixel ) {\n    pixel = floor(pixel / pixelSize);\n    pixel *= pixelSize;\n    pixel += pixelSize * 0.5;\n   \treturn pixel;\n}\n\n// planets palette\nvec3 pal( in float t ) {\n    const vec3 a = vec3(0.4,0.7,0.8);\n    const vec3 b = vec3(0.3,0.3,0.3);\n    const vec3 c = vec3(1.0,1.3,2.2);\n    const vec3 d = vec3(0.5,0.20,0.25);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// planets background\nvec4 getPlanets( in vec2 uv ) {\n    uv *= rot(5.58231);\n    const vec2 grid = vec2(900.0);\n    \n    vec2 planet = floor(uv / grid) + 0.5;\n    planet *= grid;\n    // randomize the planet\n    vec3 seed = hash3( planet );\n    float radius = 50.0 + seed.z * 150.0;\n    planet += (seed.xy * 2.0 - 1.0) * (grid * 0.5 - radius - 100.0);\n    vec2 delta = (uv - planet) / radius;\n    float x = length(delta);\n    \n    vec3 randColor = pal(seed.z);\n    vec4 baseColor = vec4(randColor, 1.0-smoothstep(0.95, 1.0, x));\n    \n    if (x < 1.0) {\n        vec3 norm = normalize(vec3(delta, sqrt(1.0-x*x)));\n        vec3 nnorm = norm;\n\n        // rotate the normal randomly\n        vec3 seed2 = hash3( planet + 12.0032 );\n        norm.yz *= rot((seed2.y*2.0-1.0)*PI*0.5);\n        norm.xy *= rot(seed2.x*2.0*PI+gameplayGlobalTime*0.1);\n\n        // convert to spherical coordinates\n        vec2 sphere = vec2(atan(norm.y/norm.x), acos(norm.z));\n\n        float n = noise((norm + seed)*3.0)*0.7;\n        n += noise((norm + seed*12.43)*5.0)*0.4;\n        n += noise((norm + seed*242.47)*12.0)*0.2;\n        n = clamp(n, 0.0, 1.0);\n        baseColor.rgb = mix(baseColor.rgb, randColor-0.3, n);\n\n        // add spiralling clouds\n        float clouds = sin(sphere.y*10.0+sphere.x*2.0-gameplayGlobalTime)*0.5+0.5;\n        clouds *= smoothstep(0.0, 0.2, sphere.y);\n        clouds *= 1.0-smoothstep(PI-0.2, PI, sphere.y);\n        clouds *= noise((norm + seed*15.43)*4.0);\n        clouds *= noise((norm + seed*154.2)*2.0);\n        baseColor.rgb = mix(baseColor.rgb, vec3(1.0), clouds);\n        \n        // add light\n        float light = max(0.0, dot(nnorm, normalize(vec3(-1, 3, 6))));\n        baseColor.rgb *= light;\n    }\n\n    // add the atmosphere\n    float atmos = smoothstep(radius-50.0, radius, x*radius);\n    atmos *= 1.0 - smoothstep(radius, radius+40.0, x*radius);\n    baseColor = mix(baseColor, vec4(randColor*0.75, 1.0), atmos*0.9);\n    \n    return baseColor;\n}\n\n// sci-fi background\nvec4 getGrebble( in vec2 uv, in float alpha, in float baseDither ) {\n    float totalAlpha = 0.0;\n    float top = 0.0;\n    float ao = 1.0;\n    float detail = 0.0;\n    \n    for (int i = 0 ; i < 3 ; i++) {\n        // size of the frame\n        vec2 scale = vec2(150.0+float(i)*60.0, 80.0+float(i)*30.0);\n        if (imod(i, 3) == 0) scale.xy = scale.yx;\n        \n        // random offset\n        vec2 uuv = uv;\n        uuv += vec2(hash1(float(i)*12.442),\n                    hash1(float(i)*72.247))*scale;\n        // animate the offset\n        float ani = imod(i, 2) == 0 ? -1.0:+1.0;\n        uuv.x += gameplayGlobalTime*sign(ani)/scale.x*600.0;\n        // snap to the grid\n        uuv = floor(uuv+0.5);\n        \n        // get the center of the box\n        vec2 center = floor(uuv/scale)+0.5;\n        center *= scale;\n        \n        // 1 seed per box, get the dimensions of the box\n        float seed = dot(center, vec2(0.4125, 0.90512));\n        vec2 boxDim = vec2(hash1(seed),\n                           hash1(seed*52.552))*0.2+0.3;\n        boxDim *= scale;\n        float height = hash1(seed+float(i)*0.5125);\n        height *= height;\n        \n        // dither value\n        float dither = texture(iChannel3, uuv/256.0, -100.0).g;\n        float tt = 0.5 + (dither*2.0-1.0)*0.5*(1.0-height);\n        \n        // offset the box itself\n        vec2 decal = vec2(hash1(seed*12.441),\n                          hash1(seed*312.77))*2.0-1.0;\n        decal *= (scale*0.5)-boxDim;\n        center += decal*0.9;\n        center = floor(center+0.5);\n        \n        // distance to the box\n        vec2 inBox = uuv-center;\n        float dist = box(inBox, boxDim);\n        // rivets center\n        vec2 rivets = center + sign(inBox)*(boxDim-8.0);\n        float distRivets = length(uuv-rivets)-3.0;\n            \n    \tfloat noiseFactor = 1.0 - abs(2.0*(alpha-0.5));\n        float noiseTot = noise(vec3(inBox*0.5, 6.0))*0.2;\n        noiseTot += noise(vec3(inBox*0.2, 7.0))*0.2;\n        noiseTot += noise(vec3(inBox*0.05, 8.0))*0.6;\n        float thisAlpha = alpha + noiseFactor*noiseTot;\n        \n        // draw on top\n        if (dist < 0.0 && thisAlpha > tt && height > top) {\n            totalAlpha = 1.0;\n            top = height;\n            ao = smoothstep(1.0, 3.0, -dist);\n            ao *= smoothstep(0.2,0.5, distRivets);\n            detail = texture(iChannel2, inBox / scale / 3.0).r;\n            detail += texture(iChannel3, inBox / 17.4457, -100.0).r*2.0;\n        }\n    }\n    \n    top = sqrt(top);\n    float value = 0.1 + top*0.3 + detail*0.05;\n    value -= (1.0-ao)*0.15;\n    \n    return vec4(BACKGROUND_COLOR*value, totalAlpha);\n}\n\n// transition indicator\nvec4 getTransitionPanel( in vec2 uv, in float index ) {\n    float dither = texture(iChannel2, uv/8.0).r;\n    \n    // get some light\n    const vec2 lightSize = vec2(100.0, 100.0);\n    float lightIndex = floor(uv.y / lightSize.y);\n    float ss = sign(uv.x);\n    ss = ss == 0.0 ? 1.0: ss;\n    vec2 uvLight = vec2(ss, lightIndex + 0.5);\n    uvLight.y = clamp(uvLight.y, -2.5, 3.5);\n    uvLight *= lightSize;\n    float lightValue = fract(lightIndex*0.1-gameplayGlobalTime*0.25);\n    lightValue *= lightValue; lightValue *= lightValue;\n    lightValue *= lightValue; lightValue *= lightValue;\n    float distToLight = length(uv-uvLight);\n    \n    vec4 baseColor = vec4(BACKGROUND_COLOR, 0.0);\n    \n    // set light pole\n    if (distToLight < 6.0) {\n        baseColor.a = 1.0;\n        if (distToLight > 5.0) baseColor.rgb = vec3(0.0);\n        else {\n            baseColor.rgb *= 0.2;\n            float lens = 1.0-smoothstep(0.0, 6.0, distToLight);\n            lens = doDithering(lens, dither, 4.0);\n            baseColor.rgb += BACKGROUND_COLOR*lens*0.45*(lightValue*0.5+0.5);\n        }\n    }\n    \n    // box center\n    const vec2 boxCenter = vec2(0.0, 350.0);\n    const vec2 boxDim = vec2(60.0, 40.0);\n    vec2 uvBox = uv-boxCenter;\n    \n    float boxDist = box(uvBox, boxDim)-5.0;\n    if (boxDist < 0.0) {\n        baseColor.a = 1.0;\n        if (boxDist > -1.5) baseColor.rgb = vec3(0.0);\n        else {\n            float noise = texture(iChannel3, uvBox/256.0, -100.0).r;\n            vec3 color = mix(BACKGROUND_COLOR, vec3(0.2), 0.6);\n            baseColor.rgb = color+noise*0.1;\n            baseColor -= smoothstep(-5.0, 0.0, boxDist)*0.3;\n            float inBoxDist = box(uvBox, boxDim-5.0)-5.0;\n            if (inBoxDist < 0.0) {\n                if (inBoxDist > -2.5) baseColor.rgb = vec3(0.0);\n                else {\n                    float d = dot(uvBox, vec2(3, 1)*0.1);\n                    d = sin(d)*0.5+0.5;\n                    d = smoothstep(0.7, 1.0, d);\n                    float dd = dot(uvBox, vec2(-5, 3)*0.3);\n                    dd = sin(dd)*0.5+0.5;\n                    vec3 grey = mix(baseColor.rgb, vec3(0.4), 0.7);\n                    baseColor.rgb = mix(grey, vec3(0.3), d);\n                    baseColor.rgb -= dd*noise*0.5;\n                    baseColor -= smoothstep(-15.0, 0.0, inBoxDist)*0.2;\n                    index = min(index, 99.0);\n                    float a = mod(index, 10.0);\n                    float b = floor(index / 10.0);\n                    float digit = 0.0;\n                    digit = max(digit, SampleDigit(a, uvBox*0.02 + vec2(-0.15, 0.5)));\n                    digit = max(digit, SampleDigit(b, uvBox*0.02 + vec2(0.9, 0.5)));\n                    baseColor.rgb += digit*BACKGROUND_COLOR*1.1;\n                }\n            }\n        }\n    }\n    \n    // light glow\n    float lightRadius = (1.0-smoothstep(0.0, 45.0, distToLight))*lightValue;\n    lightRadius *= 0.5;\n    \n    baseColor = mix(baseColor, vec4(BACKGROUND_COLOR*2.0, 1.0), lightRadius);\n    \n    return baseColor;\n}\n\n// background color\nvec3 getBackground( in vec2 uv ) {\n    float dither = texture(iChannel2, uv / 8.0).r;\n    vec2 center = vec2(0, (gameplayGlobalTime*60.0)*SCROLL_SPEED + 175.0);\n    center = floor(center+0.5);\n    \n    vec3 baseColor = BACKGROUND_COLOR*0.1;\n    \n    // stars 1\n    float stars1 = 0.0;\n    vec2 uvStars1 = (uv * 5.0 + center) * 0.04;\n    uvStars1 *= rot(2.1258);\n    stars1 += noise(vec3(uvStars1, 0.0))*0.38;\n    uvStars1 *= rot(2.338);\n    stars1 += noise(vec3(uvStars1, 1.0))*0.38;\n    uvStars1 *= rot(1.1412);\n    stars1 += noise(vec3(uvStars1, 2.0))*0.38;\n    //stars1 = pow(abs(stars1), 120.0);\n    stars1 = smoothstep(0.96, 1.0, stars1);\n    baseColor = mix(baseColor, BACKGROUND_COLOR*1.5, stars1*0.75);\n    \n    // stars 2\n    float stars2 = 0.0;\n    vec2 uvStars2 = (uv * 2.5 + center) * 0.06;\n    uvStars2 *= rot(2.1258);\n    stars2 += noise(vec3(uvStars2, 3.0))*0.38;\n    uvStars2 *= rot(2.338);\n    stars2 += noise(vec3(uvStars2, 4.0))*0.38;\n    uvStars2 *= rot(1.1412);\n    stars2 += noise(vec3(uvStars2, 5.0))*0.38;\n    //stars2 = pow(abs(stars2), 120.0);\n    stars2 = smoothstep(0.98, 1.0, stars2);\n    baseColor = mix(baseColor, BACKGROUND_COLOR*2.0, stars2*0.75);\n    \n    // add planets\n    //vec4 getPlanets( in vec2 uv ) {\n    vec2 uvPlanets = (uv * 2.0 + center);\n    uvPlanets = floor(uvPlanets/2.0+0.5);\n    vec4 planets = getPlanets(uvPlanets*2.0);\n    float planetsDither = texture(iChannel2, uvPlanets/8.0).r;\n    planets.a = doDithering(planets.a, planetsDither, 8.0);\n    planets.r = doDithering(planets.r, planetsDither, 8.0);\n    planets.g = doDithering(planets.g, planetsDither, 8.0);\n    planets.b = doDithering(planets.b, planetsDither, 8.0);\n    baseColor = mix(baseColor, planets.rgb, planets.a);\n    \n    // add more shit under the scifi stuff\n    vec2 uvRuins = uv * 1.5 + center;\n    float ruinsFact = fract(uvRuins.y/TRANSITION);\n    uvRuins /= 1.5;\n    uvRuins.x -= gameplayGlobalTime*8.0;\n    uvRuins = floor(uvRuins+0.5);\n    float alphaRuins = smoothstep(0.2, 0.4, ruinsFact);\n    alphaRuins *= 1.0 - smoothstep(0.5, 0.7, ruinsFact);\n    alphaRuins *= noise(vec3(uvRuins*0.01, 6.0));\n    alphaRuins *= noise(vec3(uvRuins*0.05, 7.0));\n    vec2 ruinsDistV = abs(mod(uvRuins, 40.0)*2.0 - 20.0);\n    float ruinsDist = 40.0 - min(ruinsDistV.x, ruinsDistV.y);\n    vec3 ruinsColor = BACKGROUND_COLOR*0.2;\n    if (ruinsDist < 30.0) ruinsColor = vec3(0);\n    if (ruinsDist < 27.5) alphaRuins = 0.0;\n    float noise = texture(iChannel3, uvRuins / 256.0, -100.0).r;\n    alphaRuins = step(0.25, alphaRuins+noise*0.2);\n    baseColor = mix(baseColor, ruinsColor, alphaRuins);\n    \n    // set grebbles\n    float greb = fract((uv.y + center.y)/TRANSITION);\n    float alpha = smoothstep(0.3, 0.4, greb);\n    alpha *= 1.0 - smoothstep(0.5, 0.6, greb);\n    if (alpha > 0.0) {\n        vec2 uvGreb = (uv + center);\n        vec4 grebble = getGrebble(uvGreb, alpha, dither*0.998+0.001);\n        baseColor = mix(baseColor, grebble.rgb, grebble.a);\n    }\n    \n    // add the transition panel\n    vec2 thingUV = uv * 0.7 + center;\n    thingUV.y += TRANSITION*0.75; // offset into the grebble part\n    vec2 thingPos = vec2(0.0, floor(thingUV.y/TRANSITION+0.5));\n    float index = thingPos.y;\n    thingPos *= TRANSITION;\n    \n    thingUV /= 0.7;\n    thingPos /= 0.7;\n    thingUV = floor(thingUV+0.5);\n    thingPos = floor(thingPos+0.5);\n    \n    vec4 thing = getTransitionPanel((thingUV-thingPos), index);\n    thing.a = doDithering(thing.a, dither, 16.0);\n    baseColor = mix(baseColor, thing.rgb, thing.a);\n    \n    \n    return baseColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // the size of a pixel depends on the resolution\n    pixelSize = floor(iResolution.y / 350.0); // 1 pixel in windowed\n    pixelSize = max(pixelSize, 1.0);\n    // the size of the playing field is a multiple of pixelsize\n    vec2 play = vec2(pixelSize * 160.0);\n    \n    // get game stats\n    vec4 game = loadValue(ADR_GAME);\n    vec4 scoreState = loadValue(ADR_SCORE);\n    float gameOver = game.x;\n    float gameTimestamp = game.y;\n    float gameOverTimestamp = game.z;\n    float score = scoreState.x;\n    float highscore = scoreState.y;\n    \n    gameplayGlobalTime = float(iFrame) - gameTimestamp;\n    gameplayGlobalTime /= 60.0; // 60 FPS (hopefully)\n\n    // round uv to pixelSize for big pixels\n    vec2 uv = fragCoord.xy - iResolution.xy * 0.5;\n    vec2 uvFine = uv;\n    uv = roundToWorld(uv);\n    \n    bool outside = (uv.x>play.x)||(uv.x<-play.x)||(uv.y>play.y)||(uv.y<-play.y);\n    \n    // do the background color\n    if (!outside) {\n    \tfragColor.rgb = getBackground(uv/pixelSize);\n    }\n        \n    // display collision mesh with pixel perfect accuracy\n    vec2 colUV = (uvFine / play) * 0.5 + 0.5;\n    colUV *= 128.0 / iResolution.xy;\n    vec4 particles = texture( iChannel1, colUV );\n    if (particles.r < 0.0) {\n        fragColor.rgb = ENNEMY_COLOR;\n        fragColor.rgb += (1.0-smoothstep(-0.03, 0.0, particles.r))*1.5;\n    }\n    if (particles.g < 0.0) {\n        fragColor.rgb = FRIEND_COLOR;\n        fragColor.rgb += (1.0-smoothstep(-0.03, 0.0, particles.g))*2.0;\n    }\n    \n    // dithered for added retroness\n    float dither = texture( iChannel2, uv / pixelSize / 8.0 ).r;\n    \n    // for each ennemies\n    if (!outside) { // don't draw outside the playing zone\n        for (int i = 0 ; i < 32 ; i++) {\n            vec2 adr = ADR_ALIEN_SHIP_FIRST + vec2(i, 0.0);\n            vec4 other = loadValue(adr);\n            vec2 shipPos = roundToWorld(other.xy*play);\n            vec2 displayPos = (uv-shipPos)/pixelSize;\n            vec4 color = vec4(0);\n\n            float delta = float(iFrame) - other.z;\n            float white = 1.0;\n            float frac = 0.0;\n\n            float inBB = box(displayPos, getShipBBox(i));\n\n            if (other.w < 0.5) {\n                frac = smoothstep(0.0, 150.0, delta);\n            } else {\n                white = 1.0-smoothstep(0.0, 10.0, delta);\n            }\n\n            if (frac < 1.0 && inBB < 0.0) {\n                color = getShipColor( i, displayPos, frac, other );\n            }\n\n            color.a = doDithering(color.a, dither, 4.0);\n\n            color.rgb = mix(color.rgb, vec3(1), white);\n            fragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n        }\n    }\n    \n    // player\n    vec2 playerPos = roundToWorld(loadValue(ADR_PLAYER).xy*play);\n    vec4 playerColor = vec4(0);\n    if (gameOver > 0.5) {\n        float delta = float(iFrame) - gameOverTimestamp;\n        float frac = smoothstep(0.0, 150.0, delta);\n        playerColor = getPlayerShipColor( (uv-playerPos)/pixelSize, frac, gameTimestamp );\n    } else {\n        playerColor = getPlayerShipColor( (uv-playerPos)/pixelSize, 0.0, 0.0 );\n    }\n    playerColor.a = doDithering(playerColor.a, dither, 4.0);\n    fragColor.rgb = mix(fragColor.rgb, playerColor.rgb, playerColor.a);\n    \n    // add a border around the game zone\n    if (outside) {\n        \n    \tfloat distToPlay = box(uv, play)/pixelSize;\n        \n        if (distToPlay < 2.0) {\n            fragColor.rgb = vec3(0);\n        } else if (distToPlay < 5.0) {\n            fragColor.rgb = BACKGROUND_COLOR*1.2;\n        } else if (distToPlay < 7.0) {\n            fragColor.rgb = vec3(0);\n        } else {\n            \n            vec3 noise = texture(iChannel3, uv/128.0, -100.0).rgb;\n            float dither = texture(iChannel2, uv/8.0).r;\n            \n            float d = dot(uv/pixelSize, vec2(-0.831, 0.313));\n            float dd = dot(uv/pixelSize, vec2(10.4412, 10.9803));\n            \n            d = sin(d*0.1)*0.5+0.5;\n            d = smoothstep(0.2, 0.5, d);\n            dd = sin(dd*0.05)*0.5+0.5;\n            dd = smoothstep(0.0, 1.0, dd);\n            \n            vec3 baseColor = BACKGROUND_COLOR*0.2+d*0.05;\n            baseColor -= dd*0.4*noise.r;\n            baseColor += noise.g*0.1;\n            float shadow = 1.0-smoothstep(0.0, 30.0, distToPlay);\n            vec2 vign = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            shadow += dot(vign, vign)*0.7;\n\n            // now display the score in the top left corner\n            vec2 uvScore = uv + iResolution.xy*0.5;\n            uvScore.x -= iResolution.x * 0.5;\n            uvScore.x += (iResolution.x*0.5+play.x)*0.5;\n            uvScore.y -= iResolution.y;\n            uvScore /= pixelSize;\n            uvScore -= vec2(0, -50);\n            const vec2 scoreBox = vec2(42, 20);\n            float distScore = box(uvScore, scoreBox);\n            \n            // add a shadow around the score box\n            shadow += 1.0-smoothstep(6.0, 20.0, distScore);\n            shadow = doDithering(shadow, dither, 4.0);\n            baseColor -= shadow*0.2;\n            fragColor.rgb = baseColor;\n            \n            if (distScore < 7.0) {\n                if (distScore > 6.0) {\n                    fragColor.rgb = vec3(0);\n                } else if (distScore > 3.0) {\n                    fragColor.rgb = BACKGROUND_COLOR*1.2;\n                } else if (distScore > 1.0) {\n                    fragColor.rgb = vec3(0);\n                } else {\n                    fragColor.rgb = vec3(0);\n\n                    // display game stats\n                    float scoreAcc = min(999999.0, score);\n                    float colorAcc = 0.0;\n\n                    // score\n                    vec2 startScore = uvScore*0.09;\n                    startScore += vec2(-2.5, -0.5);\n                    for (int i = 0 ; i < 6 ; i++) {\n                        float digit = mod(scoreAcc, 10.0);\n                        scoreAcc -= digit;\n                        scoreAcc *= 0.1;\n                        colorAcc = max(colorAcc, SampleDigit(digit, startScore));\n                        startScore.x += 1.0;\n                        if (imod(i-2, 3) == 0) startScore.x += 0.7;\n                    }\n\n                    // highscore\n                    scoreAcc = min(999999.0, highscore);\n                    vec2 startHigh = uvScore*0.09;\n                    startHigh += vec2(-2.5, +1.4);\n                    for (int i = 0 ; i < 6 ; i++) {\n                        float digit = mod(scoreAcc, 10.0);\n                        scoreAcc -= digit;\n                        scoreAcc *= 0.1;\n                        colorAcc = max(colorAcc, SampleDigit(digit, startHigh));\n                        startHigh.x += 1.0;\n                        if (imod(i-2, 3) == 0) startHigh.x += 0.7;\n                    }\n\n                    fragColor.rgb += colorAcc;\n                }\n            }\n        }\n    }\n    \n    #ifdef GAMEPLAY_BUFFER_SCALE\n    vec2 buv = fragCoord.xy / iResolution.xy / GAMEPLAY_BUFFER_SCALE;\n    vec2 bmax = ADR_ALIEN_SHIP_PROJ_LAST / iResolution.xy;\n    if (buv.x <= bmax.x && buv.y <= bmax.y) {\n        vec4 val = texture(iChannel0, buv);\n        fragColor.rgb = clamp(val.rgb, vec3(0), vec3(1));\n    }\n    #endif\n    \n\tfragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// #define GODMODE\n// #define THUMBNAIL\n// #define HELL // uncomment if you want the real bullet hell experience ;)\n// #define BOT  // uncomment so the game can play itself, code by Imp5\n\n// size between each transitions\n#define TRANSITION 3000.0\n// scroll speed of the player, in pixels per frames\n#define SCROLL_SPEED 0.65\n// duration between each transitions\n#define TRANSITION_PERIOD (TRANSITION/SCROLL_SPEED)\n\n#define PI 3.14159265359\n\nint imod(in int a, in int n) {\n\treturn a - (n * int(a/n));\n}\n\n// STORAGE (use multiple of 8 for efficient SIMD usage)\n\nconst vec2 ADR_PLAYER = vec2(0, 0);\nconst vec2 ADR_GAME = vec2(8, 0);\nconst vec2 ADR_SCORE = vec2(16, 0);\nconst vec2 ADR_PLAYER_PROJ_FIRST = vec2(24, 0);\nconst vec2 ADR_PLAYER_PROJ_LAST = vec2(31, 0);\nconst vec2 ADR_ALIEN_SHIP_FIRST = vec2(0, 8);\nconst vec2 ADR_ALIEN_SHIP_LAST = vec2(31, 8);\nconst vec2 ADR_ALIEN_SHIP_PROJ_FIRST = vec2(0, 16);\nconst vec2 ADR_ALIEN_SHIP_PROJ_LAST = vec2(31, 23);\n\nconst vec2 ADR_MAX = ADR_ALIEN_SHIP_PROJ_LAST;\n\nfloat isInside( vec2 p, vec2 c ) {\n    vec2 d = abs(p-0.5-c) - 0.5001;\n    return -max(d.x,d.y);\n}\nfloat isInside( vec2 p, vec2 c, vec2 cc ) {\n    vec2 delt = (cc-c)*0.5;\n    vec2 d = abs(p-0.5-(c+delt)) - delt - 0.5001;\n    return -max(d.x,d.y);\n}\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n// INPUT\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nfloat keyDown( in float key ) {\n    return texture( iChannel2, vec2(key, 0.25) ).r;\n}\n\n// GAME LOGIC\n\n// date of the game over\nint gameoverFrame = 0;\n\n// frame since the beginning\n// used to determine ennemies spawn/behavior\nint gameplayFrame = 0;\n\n// collision mesh sample in the game world\nvec4 getCollisionMesh( in vec2 uv ) {\n    if (uv.x < -1.0 || uv.x >= 1.0) return vec4(999.9);\n    if (uv.y < -1.0 || uv.y >= 1.0) return vec4(999.9);\n    uv = uv * 0.5 + 0.5;\n    uv *= 128.0 / iResolution.xy;\n    return texture( iChannel1, uv );\n}\n\n// radius function for the ennemy\nfloat getRadius( in int index ) {\n    if (index < 8) return 0.06;\n    if (index < 16) return 0.07;\n    if (index < 24) return 0.05;\n    if (index < 28) return 0.05;\n    if (index < 30) return 0.14;\n    if (index < 31) return 0.26;\n    return 0.04;\n}\n\n// score for each ennemy type\nfloat getScore( in int index ) {\n    if (index < 8) return 1.0;\n    if (index < 16) return 5.0;\n    if (index < 24) return 10.0;\n    if (index < 28) return 5.0;\n    if (index < 30) return 50.0;\n    if (index < 31) return 150.0;\n    return 500.0;\n}\n\n// create a new ennemy ship\nvoid BirthEnnemy( in int index, inout vec4 value ) {\n    // FIGHTER\n    if (index < 8) {\n        int i = imod(index+gameplayFrame, 8);\n        int j = imod(index*3+gameplayFrame*7, 16);\n        value.x = (float(i - 4) + 0.5) / 4.0 * 0.95;\n        value.y = 1.75 - (float(j) / 16.0)*0.65;\n        value.w = 1.0;\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n        int i = imod(index, 8);\n        int j = imod(index*9+gameplayFrame*12, 16);\n        value.x = (float(i - 4) + 0.5) / 4.0 * 0.95;\n        value.y = 1.75 - (float(j) / 16.0)*0.65;\n        value.w = 9.0;\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        value.xy = vec2(0.0, 1.2);\n        value.w = 2.0;\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        int i = imod(index, 4);\n        int j = imod(index*2+gameplayFrame*7, 8);\n        value.x = (float(i - 2) + 0.5) / 2.0 * 1.2;\n        value.y = 1.75 - (float(j) / 8.0)*0.65;\n        value.w = 9.0;\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        int i = imod(index, 2);\n        int j = imod(index+gameplayFrame*19, 16);\n        value.x = (float(i - 1) + 0.5) * 1.2;\n        value.y = 2.0 - (float(j) / 16.0)*0.75;\n        value.w = 30.0;\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        value.xy = vec2(0.0, 1.3);\n        value.w = 130.0;\n    }\n    \n    // BONUS\n    else {\n        value.xy = vec2(-1.1, 0.5);\n        value.w = 3.0;\n    }\n}\n\n// create a new ennemy projectile\nvoid BirthEnnemyProj( in int index, inout vec4 value, in vec4 shipValue ) {\n    // FIGHTER\n    if (index < 8) {\n\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        vec2 playerPos = loadValue(ADR_PLAYER).xy;\n        vec2 delt = playerPos - shipValue.xy;\n        float theta = atan(delt.y, delt.x);\n        value.w = theta;\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        value.w = 0.0;\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        value.w = 0.03;\n        value.y -= 0.1;\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        // mothership projectiles are always in the center\n        // so xy is used as polar coordinates\n        value.x = 0.2;\n       \tint i = imod(gameplayFrame, 32);\n        value.y = float(i) / 16.0 * PI * 5.0;\n    }\n}\n\n// move ennemy ship\nvoid ThinkEnnemy( in int index, inout vec4 value ) {\n    // FIGHTER\n    if (index < 8) {\n        // go straight down\n        value.y -= 0.007;\n        if (value.y < -1.1) {\n            value.w = 0.0;\n        }\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n        // move slowly toward the center of the screen\n        value.y -= max(0.0, log(value.y+1.0 - 0.25)*0.005);\n        value.y -= 0.0015;\n        if (value.y < -1.1) {\n            value.w = 0.0;\n        }\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        // find a position somewhere\n        vec2 pos = vec2(0.0, 0.3);\n        float param = float(index)*1.0+float(gameplayFrame)*0.03;\n        pos.x += sin(param*0.3312)*2.0;\n        pos.y += sin(param*0.5368)*1.5;\n        vec2 delt = pos-value.xy;\n        delt *= max(0.0, log(length(delt)+1.0));\n        value.xy += delt*0.005;\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        // go straight down\n        value.y -= 0.002;\n        if (value.y < -1.1) {\n            value.w = 0.0;\n        }\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        // check the state of the other fregate\n        float otherIndex = 28.0;\n        if (index == 28) otherIndex += 1.0;\n        vec4 otherFregate = loadValue(vec2(otherIndex, ADR_ALIEN_SHIP_FIRST.y));\n\t\t\n        // when the other fregate is dead go to the center of the screen\n        vec2 wishPos = vec2(0.0, 0.7);\n        float ecart = 0.6;\n        if (otherFregate.w > 0.5) {\n            ecart = 0.4;\n            // otherwise go to its own side\n            if (index == 28) wishPos.x = -0.5;\n            else wishPos.x = 0.5;\n        }\n        \n        // move the position around\n        float v = float(index-28);\n        wishPos.x += sin(float(gameplayFrame)*0.02 + v*PI)*ecart;\n        \n        // then go toward it\n        vec2 delt = wishPos-value.xy;\n        delt *= max(0.0, sqrt(length(delt)+1.0));\n        value.xy += delt*0.005;\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        // move slowly toward the center of the screen\n        value.y -= max(0.0, log(value.y+1.5)*0.003);\n        value.y = max(0.0, value.y);\n    }\n    \n    // BONUS\n    else {\n        // move to the right\n        value.x += 0.006;\n        value.y += sin(float(gameplayFrame)*0.05)*0.01;\n        if (value.x > 1.1) {\n            value.w = 0.0;\n        }\n    }\n}\n\n// move ennemy projectile\nvoid ThinkEnnemyProj( in int index, inout vec4 value ) {\n    // FIGHTER\n    if (index < 8) {\n        value.y -= 0.015;\n        if (value.y < -1.1) {\n            value.z = 0.0;\n        }\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n        value.y -= 0.008;\n        if (value.y < -1.1) {\n            value.z = 0.0;\n        }\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        vec2 vec = vec2(cos(value.w), sin(value.w));\n        value.xy += vec * 0.01;\n        if (value.x < -1.1 || value.x > +1.1 || \n            value.y < -1.1 || value.y > +1.1) {\n            value.z = 0.0;\n        }\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        value.w += 0.003;\n        value.y -= 0.002;\n        if (value.w > 2.5 || value.y < -1.1) {\n            value.z = 0.0;\n        }\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        value.w += 0.003;\n        value.y -= 0.009;\n        if (value.y < -1.1) {\n            value.z = 0.0;\n        }\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        value.x += 0.002;\n        value.y -= 0.004;\n        if (value.x > 1.5) {\n            value.z = 0.0;\n        }\n    }\n}\n\n// should the ennemy spawn at this frame ? basically difficulty setting\nbool ShouldSpawnEnnemy( in int index ) {\n    \n    // this is the duration between each transitions\n    int period = int(TRANSITION_PERIOD+0.5);\n    // this is the offset from the start the the point of transition\n    int offset = int(780.0/SCROLL_SPEED+0.5);\n    // position in the transition\n    int inTransition = imod(gameplayFrame, period);\n    // has the player just entered a transition?\n    bool enteringTransition = inTransition == offset;\n    // which transition we are in\n    int periodIndex = gameplayFrame / period;\n    \n    // get a random value per transitions\n    vec2 inDither = vec2(float(periodIndex), float(periodIndex/64)) + 0.5;\n    inDither /= 64.0;\n    float noise = texture(iChannel3, inDither, -100.0).r;\n    \n    // do a boss fight starting with 2, then 4, etc\n    bool doBossFight = imod(periodIndex, 2) == 1 && periodIndex > 0;\n    // type of boss is random\n    bool doMothership = noise < 0.4;\n    \n    // difficulty moves with transition index, cap at level 20\n    int baseIndex = imod(index, 8);\n    int diff = 20-periodIndex;\n    #ifdef HELL\n    diff = diff - 15;\n    #endif\n    if (diff < 0) diff = 0;\n    \n    // during a boss fight ? is used to inhibe spawn rates\n    bool duringBossFight = doBossFight && inTransition > offset-300 &&\n        inTransition < offset+1000+diff*20;\n    \n    #ifdef HELL\n    duringBossFight = false;\n    #endif\n    \n    // FIGHTER\n    if (index < 8) {\n        if (duringBossFight) return false;\n        if (imod(gameplayFrame+baseIndex*1483, 353+diff*97) == 0) return true;\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n        if (duringBossFight) return false;\n        if (imod(gameplayFrame+baseIndex*1979, 1019+diff*131) == 0) return true;\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        if (duringBossFight) return false;\n        if (imod(gameplayFrame+baseIndex*1871, 797+diff*139) == 0) return true;\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        if (duringBossFight) return false;\n        if (imod(gameplayFrame+baseIndex*1259, 1201+diff*103) == 0) return true;\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        if (enteringTransition && doBossFight && !doMothership) return true;\n        if (duringBossFight) return false;\n        if (diff > 16) return false;\n        if (imod(gameplayFrame+baseIndex*4783, 2857+diff*449) == 0) return true;\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        if (enteringTransition && doBossFight && doMothership) return true;\n        if (duringBossFight) return false;\n        if (diff > 3) return false;\n        if (imod(gameplayFrame, 4937+diff*977) == 0) return true;\n    }\n    \n    // BONUS\n    else {\n        // 1 bonus per transitions, with a random offset\n        return inTransition == int(noise*float(period)+0.5);\n    }\n    \n    return false;\n}\n\n// should the projectile spawn at this frame ?\nbool ShouldSpawnEnnemyProj( in int index, in vec4 shipValue ) {\n    // FIGHTER\n    if (index < 8) {\n        return imod(gameplayFrame+index*37, 130) == 0;\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n        if (shipValue.y > 0.7) return false;\n        return imod(gameplayFrame+index*30, 60) == 0;\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        if (shipValue.x < -1.1 || shipValue.x > +1.1 || \n            shipValue.y < -1.1 || shipValue.y > +1.1) {\n            return false;\n        }\n        return imod(gameplayFrame+index*31, 130) == 0;\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        return imod(gameplayFrame+index*27, 200) == 0;\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        if (shipValue.y > 0.8) return false;\n        return imod(gameplayFrame+index*20, 40) == 0;\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        if (dot(shipValue.xy, shipValue.xy) > 0.0 ) return false;\n        return imod(gameplayFrame, 127) == 0;\n    }\n    \n    // BONUS\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // outside the limits of the gameplay buffer, discard the fragment\n    if ( !(isInside(fragCoord, vec2(0), ADR_MAX) > 0.0) ) {\n        discard;\n        return;\n    }\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 floorFragCoord = vec2(iFragCoord);\n    \n    // load game state\n    vec4 game = loadValue(ADR_GAME);\n    vec4 score = loadValue(ADR_SCORE);\n    float gameOver = game.x;\n    float gameTimestamp = game.y;\n    float gameOverTimestamp = game.z;\n    float highscore = max(2000.0, score.y);\n    float bonus = score.z;\n    bool doBonus = float(iFrame)-bonus < 300.0;\n    \n    gameplayFrame = iFrame - int(gameTimestamp);\n    gameoverFrame = iFrame - int(gameOverTimestamp);\n    \n    // this means theres isn't enough place to play the game properly\n    // the game area is 320 pixels large\n    bool thumb = iResolution.x < 280.0 || iResolution.y < 280.0;\n    #ifdef THUMBNAIL\n    thumb = true;\n    #endif\n    \n    // initialize the first frame\n    bool initialize = gameOver > 0.5 && (gameoverFrame > 300);\n    if ( iFrame == 0 || initialize ) {\n        fragColor = vec4(0.0);\n        \n        // initialize player\n        if ( isInside(fragCoord, ADR_PLAYER) > 0.0 ) {\n            fragColor = vec4(0.0, thumb?0.0:-0.6, 0.0, 0.0);\n    \t}\n        \n        // initialize game\n        if ( isInside(fragCoord, ADR_GAME) > 0.0 ) {\n            fragColor = vec4(0.0, float(iFrame), 0.0, 0.0);\n        }\n        \n        // initialize score\n        if ( isInside(fragCoord, ADR_SCORE) > 0.0 ) {\n            fragColor = vec4(0.0, highscore, -999.9, 0.0);\n        }\n        \n        // initialize ennemies\n        if ( isInside(fragCoord, ADR_ALIEN_SHIP_FIRST, ADR_ALIEN_SHIP_LAST) > 0.0 ) {\n            fragColor = vec4(999.9, 999.9, -999.0, 0.0);\n        }\n        \n        return;\n    }\n    \n    // run the player loop\n    if ( isInside(fragCoord, ADR_PLAYER) > 0.0 ) {\n        vec4 value = loadValue(ADR_PLAYER);\n        vec2 pos = value.xy;\n        vec2 ppos = pos;\n        \n        bool left = keyDown(KEY_LEFT) > 0.5;\n        bool up = keyDown(KEY_UP) > 0.5;\n        bool right = keyDown(KEY_RIGHT) > 0.5;\n        bool down = keyDown(KEY_DOWN) > 0.5;\n        \n        vec2 delta = vec2(0);\n        float speed = 0.015;\n        \n        #ifndef BOT\n        if (iMouse.z > 0.5) {\n            // same computation than in the image buffer\n            vec2 uv = iMouse.xy - iResolution.xy * 0.5;\n            float pixelSize = floor(iResolution.y / 350.0);\n            pixelSize = max(pixelSize, 1.0);\n            vec2 play = vec2(pixelSize * 160.0);\n            vec2 pointer = uv / play;\n            delta = pointer-pos;\n            float len = length(delta);\n            if (len > speed) {\n                delta /= len;\n                delta *= speed;\n            }\n        } else {\n            // otherwise, use the keyboard\n            delta = vec2(\n                keyDown(KEY_RIGHT)-keyDown(KEY_LEFT),\n                keyDown(KEY_UP)-keyDown(KEY_DOWN));\n        \tif (dot(delta, delta) > 1.44) delta /= 1.41421;\n            delta *= speed;\n        }\n        #endif\n        \n        // code by Imp5\n        #ifdef BOT \n        {\n            vec2 playerPos = ppos;\n            vec2 limit = vec2(0.09, 0.15);\n            vec2 v00 = min(getCollisionMesh(playerPos).rb, limit);\n            vec2 v10 = min(getCollisionMesh(playerPos + vec2(0.01, 0.0)).rb, limit);\n            vec2 v01 = min(getCollisionMesh(playerPos + vec2(0.0, 0.01)).rb, limit);\n\n            vec2 wishPos = vec2(0.0, -0.5);\n            wishPos.x = getCollisionMesh(vec2(playerPos.x + 0.01, 0.8)).b <\n                getCollisionMesh(vec2(playerPos.x, 0.8)).b ?\n                playerPos.x + 0.1 : playerPos.x - 0.1;\n\n            vec2 gradient = vec2(v10.x - v00.x, v01.x - v00.x)\n                + vec2(v10.y - v00.y, v01.y - v00.y)\n                + ((wishPos - playerPos) * 0.001);\n            gradient.x *= 5.0;                    \n            delta = normalize(gradient);\n            delta *= speed;            \n        }\n        #endif\n        \n        delta *= 1.0 - gameOver;\n        pos += delta;\n        pos = clamp(pos, -0.99, +0.99);\n        if ( thumb ) pos = vec2(0.0);\n        \n        value.xy = pos;\n        fragColor = value;\n    }\n    \n    \n    // game logic loop (game over)\n    if ( isInside(fragCoord, ADR_GAME) > 0.0 ) {\n        vec4 value = loadValue(ADR_GAME);\n        \n        float gameOver = value.x;\n        float gameOverTimestamp = value.z;\n        \n        // while the game is running, check collision model for gameover state\n        if (gameOver < 0.5 && !thumb) {\n            vec2 playerPos = loadValue(ADR_PLAYER).xy;\n            vec2 something = getCollisionMesh(loadValue(ADR_PLAYER).xy).rb;\n            #ifndef GODMODE\n            if ( something.x < 0.0 || something.y < 0.0 ) {\n                gameOver = 1.0;\n                gameOverTimestamp = float(iFrame);\n            }\n            #endif\n        }\n        \n        value.x = gameOver;\n        value.z = gameOverTimestamp;\n        fragColor = value;\n    }\n    \n    // compute score\n    if ( isInside(fragCoord, ADR_SCORE) > 0.0 ) {\n        vec4 value = loadValue(ADR_SCORE);\n        \n        float score = value.x;\n        float highscore = value.y;\n        float bonusFrame = value.z;\n        \n        // for each kind of ennemies\n        for (int i = 0 ; i < 32 ; i++) {\n            vec2 adr = ADR_ALIEN_SHIP_FIRST + vec2(float(i), 0.0);\n            vec4 other = loadValue(adr);\n            if (other.w < -0.5) {\n                score += getScore(i);\n                if (i == 31) {\n                    bonusFrame = float(iFrame);\n                }\n            }\n        }\n        \n        // set the highscore\n        highscore = max(score, highscore);\n        \n        if (thumb) {\n            score = 999999.0;\n            highscore = 999999.0;\n        }\n        \n        value.x = score;\n        value.y = highscore;\n        value.z = bonusFrame;\n        fragColor = value;\n    }\n    \n    \n    // for each player owned projectiles\n    if ( isInside(fragCoord, ADR_PLAYER_PROJ_FIRST, ADR_PLAYER_PROJ_LAST) > 0.0 ) {\n        vec4 value = loadValue(floorFragCoord);\n        vec2 pos = value.xy;\n        float alive = value.z;\n        float type = value.w;\n        \n        if ( alive > 0.5 ) {\n            // when alive, move the projectile to the top\n            pos.y += 0.04;\n            // remove the thing when it goes offscreen\n            if (pos.y > 1.1) {\n                alive = 0.0;\n                pos = vec2(0);\n            }\n        } else {\n            // we might be trying to shoot?\n            if (imod(gameplayFrame, 12) == 0 && gameOver < 0.5) {\n                // are we the first dead projectile?\n                bool firstDead = true;\n                for (int i = 0 ; i < 8 ; i++) {\n                    const int offset = int(ADR_PLAYER_PROJ_FIRST.x+0.5);\n                    if (i+offset < iFragCoord.x && firstDead) {\n                        vec2 adr = ADR_PLAYER_PROJ_FIRST + vec2(float(i), 0.0);\n                        vec4 other = loadValue(adr);\n                        if (other.z < 0.5) {\n                            firstDead = false;\n                        }\n                    }\n                    \n                }\n                // then if this is the case, put it back in the world\n                if (firstDead) {\n                    alive = 1.0;\n                    pos = loadValue(ADR_PLAYER).xy;\n                    \n                    if (imod(gameplayFrame/12, 2) > 0) {\n                        pos.x += 0.02;\n                    } else {\n                        pos.x -= 0.02;\n                    }\n                    \n                    if (doBonus) {\n                        type = 1.0;\n                    } else {\n                        type = 0.0;\n                    }\n                }\n            }\n        }\n        \n        if ( thumb ) alive = 0.0;\n        value.xy = pos;\n        value.z = alive;\n        value.w = type;\n        fragColor = value;\n    }\n    \n    // for each ennemies\n\tif ( isInside(fragCoord, ADR_ALIEN_SHIP_FIRST, ADR_ALIEN_SHIP_LAST) > 0.0 ) {\n        int index = iFragCoord.x;\n        vec4 value = loadValue(floorFragCoord);\n        \n        if ( value.w > 0.5 ) {\n            \n            // move the ennemy\n            ThinkEnnemy(index, value);\n            \n            // remove health when touching a collision mesh\n            bool score = false;\n            float lastHitDelta = float(iFrame) - value.z;\n            if (lastHitDelta > 8.0 && getCollisionMesh(value.xy).g < getRadius(index)) {\n                value.z = float(iFrame);\n                value.w = value.w - 1.0;\n                score = value.w < 0.5;\n            }\n            \n            // remove the projectile when the health is 0\n            if (value.w < 0.5) {\n                if (score) {\n                    // ennemy was killed, store timestamp\n                    value.z = float(iFrame); // also used to animate death\n                    // set health to -1 to award score\n                    value.w = -1.0;\n                } else {\n                    // ennemy suicided, drop it\n                   \tvalue.xy = vec2(999.9);\n                    value.z = 0.0;\n                    value.w = 0.0;\n                }\n            }\n\n        } else {\n            \n            float timeSinceDeath = float(iFrame) - value.z;\n            \n            // the ennemy is dead, should we spawn?\n            // don't spawn too son after death, this will ruin death animations\n            if (timeSinceDeath > 200.0 && ShouldSpawnEnnemy(iFragCoord.x)) {\n                BirthEnnemy(iFragCoord.x, value);\n            } else {\n                // the health might be at -1, which means the player killed it\n            \tvalue.w = 0.0;\n            }\n            \n        }\n        \n        if ( thumb ) value.w = 0.0;\n        fragColor = value;\n    }\n    \n    \n    // for each ennemies projectiles\n    if ( isInside(fragCoord, ADR_ALIEN_SHIP_PROJ_FIRST, ADR_ALIEN_SHIP_PROJ_LAST) > 0.0 ) {\n        vec4 value = loadValue(floorFragCoord);\n        \n        if ( value.z > 0.5 ) {\n            // move the projectile\n            ThinkEnnemyProj(iFragCoord.x, value);\n        } else {\n            // look at the friend ship\n            vec2 shipAdr = vec2(floorFragCoord.x, ADR_ALIEN_SHIP_FIRST.y);\n            vec4 shipValue = loadValue(shipAdr);\n            int delta = int(float(iFrame) - shipValue.z + 0.5);\n            \n            // is the ship trying to shoot?\n            if (shipValue.w > 0.5 && ShouldSpawnEnnemyProj(iFragCoord.x, shipValue)) {\n                // are we the first dead projectile?\n                bool firstDead = true;\n                for (int i = 0 ; i < 8 ; i++) {\n                    const int offset = int(ADR_ALIEN_SHIP_PROJ_FIRST.y+0.5);\n                    if (i+offset < iFragCoord.y && firstDead) {\n                        vec2 adr = vec2(floorFragCoord.x, \n                                        ADR_ALIEN_SHIP_PROJ_FIRST.y + float(i));\n                        vec4 other = loadValue(adr);\n                        if (other.z < 0.5) {\n                            firstDead = false;\n                        }\n                    }\n                    \n                }\n                \n                // then if this is the case, put it back in the world\n                if (firstDead) {\n                    value.z = 1.0;\n                    value.xy = shipValue.xy;\n                    BirthEnnemyProj(iFragCoord.x, value, shipValue);\n                }\n            }\n        }\n\n        if ( thumb ) value.z = 0.0;\n        fragColor = value;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define PI 3.14159265359\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat capsule( vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// STORAGE (use multiple of 8 for efficient SIMD usage)\n\nconst vec2 ADR_PLAYER = vec2(0, 0);\nconst vec2 ADR_GAME = vec2(8, 0);\nconst vec2 ADR_SCORE = vec2(16, 0);\nconst vec2 ADR_PLAYER_PROJ_FIRST = vec2(24, 0);\nconst vec2 ADR_PLAYER_PROJ_LAST = vec2(31, 0);\nconst vec2 ADR_ALIEN_SHIP_FIRST = vec2(0, 8);\nconst vec2 ADR_ALIEN_SHIP_LAST = vec2(31, 8);\nconst vec2 ADR_ALIEN_SHIP_PROJ_FIRST = vec2(0, 16);\nconst vec2 ADR_ALIEN_SHIP_PROJ_LAST = vec2(31, 23);\n\nvec4 loadValue( in vec2 re ) {\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n// RASTERIZE COLLISION MESH INTO A SMALL 128 BUFFER\n// collision mesh is a regular distance field, negative value is inside a projectile\n// distance fields works nicely with linear interpolation, see\n// http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n\n// radius function for the ennemy\nfloat getRadius( in int index ) {\n    if (index < 8) return 0.06;\n    if (index < 16) return 0.07;\n    if (index < 24) return 0.05;\n    if (index < 28) return 0.05;\n    if (index < 30) return 0.14;\n    if (index < 31) return 0.26;\n    return 0.04;\n}\n\n// distance function for a given projectile\nfloat getDistance( in int index, in vec2 coord, in vec4 value ) {\n    \n    vec2 uv = coord - value.xy;\n    \n    // FIGHTER\n    if (index < 8) {\n        return length(uv) - 0.06;\n    }\n    \n    // KNIGHT\n    else if (index < 16) {\n        vec2 center = vec2(sign(uv.x), 0.0);\n        if (center.x == 0.0) center.x = 1.0;\n        center.x *= 0.05;\n        return length(uv-center)-0.03;\n    }\n    \n    // NINJA\n    else if (index < 24) {\n        return length(uv) - 0.06;\n    }\n    \n    // PILLAR\n    else if (index < 28) {\n        vec2 center = vec2(sign(uv.x), 0.0);\n        if (center.x == 0.0) center.x = 1.0;\n        center.x *= value.w;\n        vec2 secondCenter = center;\n        if (secondCenter.x > 0.0) {\n            secondCenter.x = max(0.0, secondCenter.x - 0.3);\n        } else {\n            secondCenter.x = min(0.0, secondCenter.x + 0.3);\n        }\n        return capsule(uv, center, secondCenter)-0.03;\n    }\n    \n    // FREGATE\n    else if (index < 30) {\n        float radius = value.w;\n        uv.x += radius*0.5;\n        float x = floor((uv.x)/radius)+0.5;\n        x = clamp(x, -0.5, 1.5);\n        x *= radius;\n        vec2 center = vec2(x, 0.0);\n        return length(uv-center)-0.06;\n    }\n    \n    // MOTHERSHIP\n    else if (index < 31) {\n        float len = length(coord)-value.x;\n        float dist = abs(len)-0.04;\n        const vec2 inBox = vec2(0.5, 0.06);\n        for (int i = 0 ; i < 5 ; i++) {\n            vec2 uuv = coord*rot(value.y+(PI*2.0 / 5.0) * float(i));\n            uuv.x += value.x;\n            float inner = box(uuv, inBox);\n            dist = max(dist, -inner);\n        }\n        return dist;\n    }\n    \n    return 999.9;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord.xy / 128.0;\n    // outside the limits of the collision mesh, discard the fragment\n    if (uv.x > 1.0 || uv.y > 1.0) {\n        discard;\n        return;\n    }\n    \n    uv = uv * 2.0 - 1.0;\n    \n    // for each projectiles\n    float minProj = 999.9;\n    for (int i = 0 ; i < 8 ; i++) {\n        vec2 adr = ADR_PLAYER_PROJ_FIRST + vec2(float(i), 0.0);\n        vec4 other = loadValue(adr);\n        if (other.z > 0.5) {\n            float len = 0.0;\n            if (other.w > 0.5) len = abs(uv.y-other.y);\n            else len = length(uv-other.xy);\n            minProj = min(minProj, len-0.03);\n        }\n    }\n    \n    // for each ennemies\n    float minEnnemy = 999.9;\n    float minProjEnn = 999.9;\n    // skip the last one (bonus don't hurt player)\n    for (int i = 0 ; i < 31 ; i++) {\n        vec2 adr = ADR_ALIEN_SHIP_FIRST + vec2(float(i), 0.0);\n        vec4 other = loadValue(adr);\n        if (other.w > 0.5) {\n            minEnnemy = min(minEnnemy, length(uv-other.xy)-getRadius(i));\n        }\n        \n        // for each ennemies projectiles\n        for (int j = 0 ; j < 8 ; j++) {\n            vec2 aadr = adr + vec2(0, 8+j);\n            vec4 projO = loadValue(aadr);\n            if (projO.z > 0.5) {\n                minProjEnn = min(minProjEnn, getDistance(i, uv, projO));\n            }\n        }\n    }\n    \n    fragColor.r = minProjEnn; \t// r = ENNEMIES PROJECTILES\n    fragColor.g = minProj; \t\t// g = PLAYER PROJECTILES\n    fragColor.b = minEnnemy; \t// b = ENNEMIES\n    fragColor.a = 999.9;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 4322,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ceephax/capsule"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}