{
    "Shader": {
        "info": {
            "date": "1722976683",
            "description": "packing 3x5 digit font in as little data and code as possible",
            "flags": 0,
            "hasliked": 0,
            "id": "MfByDK",
            "likes": 17,
            "name": "Nano DecimalFont",
            "published": 3,
            "tags": [
                "numbers",
                "font",
                "2tweets",
                "digits",
                "timer",
                "codegolf",
                "glyph"
            ],
            "usePreview": 0,
            "username": "spalmer",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "// ooo ·o· ooo ooo o·o ooo ooo ooo ooo ooo\n// o·o ·o· ··o ··o o·o o·· o·· ··o o·o o·o\n// o·o ·o· ooo ooo ooo ooo ooo ··o ooo ooo\n// o·o ·o· o·· ··o ··o ··o o·o ··o o·o ··o\n// ooo ·o· ooo ooo ··o ooo ooo ··o ooo ooo\n\n// recently someone (think Fabrice started it?) did one with all 10 digits' columns packed into one uint\n\n// see also\n// http://shadertoy.com/view/McByR1 // 267 ch total draws timer w 8 digits rather efficiently\n// http://shadertoy.com/view/lfScRh\n// http://shadertoy.com/view/MlXXzH\n\n// the entire font (without decimal point, minus) is 10*3*5 = 150 bits; 5 dwords is 160 bits.\n// so unless I can find some compression that fits in 4 dwords or fewer... that wins on pure data bits.\n\n// it got me thinking about the problem to the point I needed to experiment,\n// and wound up in an epic golf match.\n\n// what a battle!\n\n// well they knocked 41 ch off what I started with.\n\n// it's off vs. site timer by a rounding error on last digit, would take +4 ch to fix.\n// needs a decimal point!\n\n/**/\n// -ice took it below 200 by removing g\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8;\n    o = vec4(\n            q.x < 33 && 5/q--.y > 0\n            ?   1067438039 + int[](0,-436832130,12286,-303756994,6295552)[q.y]\n                >>\n                int(iTime / pow(10., float(5 - q/4)) ) % 10 *3 + (q %= 4).x&1\n              -q.x/3\n            : 0\n        );\n}\n/* * /\n// spalmer trying different constants and clip twist on fabrice' idea and SnoopethDuck's constants; seems chose a median value which works out to fewer total ch despite the few minus signs\n// this way also works out to 199 ch; same but found an equivalently short table.\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8;\n    o = vec4(\n            q.x < 33 && 5/q--.y > 0\n            ?   //630605909 + int[](436832130,0,436844416,133075136,443127682)[q.y] // huh, adds 3 ch.  still winds up with many 9 digit numbers\n                1067450325 - int[](12286,436844416,0,303769280,-6283266)[q.y] // same\n                //763681045 + int[](303756994,-133075136,303769280,0,310052546)[q.y] // huh, adds 4 ch.  SnoopethDuckDuck probably tried all of them.\n                //1073733591 - int[](6295552, 443127682, 6283266, 310052546, 0)[q.y] // huh, adds 1 ch.  :(\n                >>\n                int(iTime / pow(10., float(5 - q/4))) % 10 *3 + (q &= 3).x&1  \n              -q.x/3\n            : 0\n        );\n}\n// everything I tried so far on the clipping just broke it\n/** /\n// spalmer trying inverting the constants, hopefully it will reduce digits enough\n// to make up for the inverted logic (~) and removal of clever\n// variable modifications inside expressions that may possibly be non-portable.\n// Also I broke fabrice' clipping when inverting, and had to redo it.  :octopus:\n// Can't think of a way to reduce table further by using an offset.\n// Inverting truly helps, since most of the glyphs have big solid bars across several rows\n// and inverting turns those strings of on bits into off bits, trimming many leading zeroes.\n// but at 210 ch, it's not winning.\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1;\n    o = vec4(\n            uint(q.x) < 31u && uint(q.y) < 5u && (q.x&3) != 3\n            ?\n                ~\n                int[] ( 6303784, 443135914, 6291498, 310060778, 8232 )\n                //1073741823 ^ int[] ( 1067438039, 630605909, 1067450325, 763681045, 1073733591 ) \n                [q.y]\n                \n                >>\n                int(iTime / pow(10., float(5 - q/4)) ) % 10 * 3 + (q.x&3)\n               \n              &1\n            : 0\n        );\n}\n\n/* * /\n// spalmer different constant but fixes clipping on linux for me; 213 ch\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1;\n    o = vec4(\n            q.x < 32 && q.x >= 0 && q.y < 5 && q.y >= 0\n            ?   1067450325 - int[](12286,436844416,0,303769280,-6283266)[q.y]\n                >>\n                int(iTime / pow(10., float(5 - q/4))) % 10 *3 + (q &= 3).x&1  \n              -q.x/3\n            : 0\n        );\n}\n\n/** /\n// Xor, 213 ch\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1,\n          g = q / 4;\n          \n    o = vec4(\n            g.x < 8 && uint(q.y) < 5u\n            ? 1067438039 \n            + int[](0,-436832130,12286,-303756994,6295552)[q.y]\n              >> 3 * (int(iTime / pow(10., float(5 - g)))%10) + (q.x -= g.x * 4)\n              &1-q.x/3\n            : 0\n        );\n}\n\n/** /\n// Xor, 216 ch\nvoid mainImage(out vec4 o, vec2 v)\n{\n    int x = int(v) / 8 - 1,\n    y = int(v.y) / 8+4,\n    g = x / 4; \n    x -= g * 4;\n    o = vec4(\n            g < 8 && y/5==1  //&& x<3 \n            ?  (\n                  int[] ( 1067438039, 630605909, 1067450325, 763681045, 1073733591 ) [y-5] \n                  >> 3 * (int(iTime / pow(10., float(5 - g)))%10) + x\n               ) &1 - x / 3\n            : 0\n        );\n}\n\n/** /\n// SnoopethDuckDuck (220 ch)\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1,\n          g = q / 4;\n          \n    o = vec4(\n            g.x < 8 && uint(q.y) < 5u && uint(q -= g * 4) < 3u\n            ? 1067438039 \n            + int[](0,-436832130,12286,-303756994,6295552)[q.y]\n              >> 3 * int(mod(iTime / pow(10., float(5 - g)), 10.)) + q.x\n              &1\n            : 0\n        );\n}\n/* * /\n// spalmer retry (currently 220 ch by removing g, but it added many complications)\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1;\n        // the offset by 1 is particularly problematic since it requires more clipping\n    o = vec4(\n            q.x < 31 && q.y < 5 && q.y >= 0 && (q.x&3)<3\n            ?  (\n                  1067450325 - int[](12286,436844416,0,303769280,-6283266)[q.y] \n                  >> (3 * (int(mod(iTime / pow(10., float(5 - q.x / 4)), 10.))) + q.x%4)\n               ) &1\n            : 0\n        );\n}\n\n/** /\n\n// SnoopethDuckDuck (226 ch)\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1,\n          g = q / 4; \n    q.x -= g.x * 4;\n    o = vec4(\n            g.x < 8 && uint(q) < 3u && uint(q.y) < 5u\n            ? 1067438039 \n            + int[](0,-436832130,12286,-303756994,6295552)[q.y]\n              >> 3 * int(mod(iTime / pow(10., float(5 - g)), 10.)) + q.x\n              &1\n            : 0\n        );\n}\n/** /\n\n/* * /\n\n/*\nCC0 1.0 Universal (CC0 1.0)\nhttp://creativecommons.org/publicdomain/zero/1.0\nTo the extent possible under law, the author has waived all copyright and related or neighboring rights to this work.\n*/\n\n/* * /\n    // idea, to eliminate the need for the (q.x&3) < 3 part used elsewhere:\n    // but it requires storing an extra column per glyph, and ensure that column code 0\n    // corresponds to 'blank'; luckily multiply by 32 does the shifts I need.\n    // in fact I can probably encode the entire 4x6 cell box and just leave the padding empty.\n    // that may make things simpler in other ways... hrmm.\n\n// spalmer try try again, back to drawing board, trying 4x6 cells with an empty row,column\n// 224 ch   :octopus:   converting hex to dec helped about half as much as expected\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8;\n    //float n = 12345.675; //98765.435; //iTime; //\n    //int d = int(mod(n / pow(10., float(5 - q.x / 4)), 10.));\n    o = vec4(\n            q.x < 32 && q.y < 6\n            && \n            ((\n                  int[](\n                      480599, 139810, 476951, 476999, 350020, 464711, 464727, 476228, 481111, 481095\n                      //0x75557, 0x22222, 0x74717, 0x74747, 0x55744, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747\n                  ) [int(mod(iTime / pow(10., float(5 - q.x / 4)), 10.))] * 32\n                  >> q.y * 4 + q.x % 4\n               )&1) != 0\n        );\n    //o *= .8 + .2 * float((q.x^q.y)&1);\n}\n\n/** /\n//  originalish 8 digit timer by spalmer in 239 ch.\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1;\n    int g = q.x / 4; \n    q.x -= g * 4;\n    o = vec4(\n            g < 8 && uint(q.x) < 3u && uint(q.y) < 5u\n            ?  (\n                  int[] ( 1067438039, 630605909, 1067450325, 763681045, 1073733591 ) [q.y] \n                  >> (3 * (int(mod(iTime / pow(10., float(5 - g)), 10.))) + q.x)\n               ) &1  //   (-1ch thanks SnoopethDuckDuck for reminding me about & space issue)\n            : 0\n        );\n}\n\n\n// I'm having a lazy Tuesday, all right?  :D\n\n\n// but I still have a few ideas muwahaha\n// * keep everything float with exp2? how to mask?  subtract and == needs  temp var\n// * keep everything uvec2? could help, but would add so many u suffixes it wouldn't be a win\n// * fab clipping could be cheaper (and even cheaper than Xor clamp since here we know fragcoord can't go negative)\n//     I tried it and just managed to break it\n// * try a loop instead of mod (or % 4) and int(pow(10., float())) madness\n// * use a different + constant for the array; what about 630605909 (the smallest value) so we don't wind up with any negatives?\n// * TODO find a way to pack data in fewer than 5 uints using different LUT scheme; could use ivec4 instead of int[], saving nothing but a comma or so\n// * it may be more effective to encode the \"off\" bits as 1, since there are fewer of them, generally\n// FIXME we seem to have golfed away the left and/or bottom bounds in some cases,\n// may be problematic when trying to use algo for general purpose numbers translated anywhere in window.\n// I blame myself for picking - 1 offset initially!\n\n\n/* * /\n\n// 247 ch\n// columns table idea again but let's turn it sideways and invert the bits, now it's a mask:\n\n// 00000 00010 00011 01000 01010 01110 01111 11011 11111\n\n// still not competitive, but it's an idea.\n// I don't think these will work out well until I can find a way to pack them\n// in less data, and extract them with less effort.  Proof of concept, needs much golfing.\n\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1;\n    o = vec4(\n        ~( // simply inverting for now; TODO switch it all\n            int []( 0, 2, 3, 8, 10, 14, 15, 27, 31 )\n                 // 00000 00010 00011 01000 01010 01110 01111 11011 11111\n           [\n            (\n                int[]( 80, 2056, 323, 68, 114, \n                       833, 832, 102, 64, 65 )\n                //int[]( (0*16+5)*16+0, (8*16+0)*16+8, (1*16+4)*16+3, (0*16+4)*16+4, (0*16+7)*16+2, \n                //       (3*16+4)*16+1, (3*16+4)*16+0, (0*16+6)*16+6, (0*16+4)*16+0, (0*16+4)*16+1 ) // 'horner hexadec'\n                [int(iTime / pow(10., float(5 - q/4))) % 10]\n                >>\n                (q.x&3)*4\n            ) &15\n            ]\n            >> q.y\n        )\n        &1\n        &int(uint(q.x) < 31u && uint(q.y) < 5u && (q.x&3)<3)\n        );\n}\n\n/* * /\n// more fun,\n// just trying the palette columns table idea\n\n// deleting duplicate columns:  still needs 9 columns total, ugh\n\n// ·o·oooooo\n// ···o··o·o\n// ··oo·oooo\n// ·······oo\n// ····ooooo\n\n// I sorted before I realized I had the encodings flipped\n\n// still, let's roll with it for now:\n// it's now 249 ch.  Perhaps more can be done.\nvoid mainImage(out vec4 o, vec2 v)\n{\n    ivec2 q = ivec2(v) / 8 - 1;\n    o = vec4(\n        (\n            int []( 0, 16, 4, 28, 17, 21, 29, 23, 31 )\n            [\n            (\n                int[]( 2120, 128, 1623, 2133, 2083, \n                       1878, 1880, 2065, 2136, 2134 )\n                //int[]( (8*16+4)*16+8, (0*16+8)*16+0, (6*16+5)*16+7, (8*16+5)*16+5, (8*16+2)*16+3, \n                //       (7*16+5)*16+6, (7*16+5)*16+8, (8*16+1)*16+1, (8*16+5)*16+8, (8*16+5)*16+6 ) // may as well use hexadecimal!\n                [int(iTime / pow(10., float(5 - q/4))) % 10]\n                >>\n                (q.x&3)*4\n            ) &15\n            ]\n            >> q.y\n        )\n        &1\n        &int(uint(q.x) < 31u && uint(q.y) < 5u)\n        );\n}\n\n// this is 25 bits each, 50 total, could split up with 30 bits and have some left over for other glyphs..\n// now must pack 3 4-bit indices for each glyph somehow, that's 10*3*4 = 120 bits just for this table, once it's built:           \n// so, split up this way, I'm facing a total table size of 170 bits, that's more than 160, will require 6 uints at least.\n\n// if hypothetically we had a way to only use 8 column patterns,\n// it'd be 10*3*3 = 90, plus 50, = 140 total, that'd at least fit in 5 still.\n// it may not matter if the # of dwords goes up, so long as the code logic cleans up to compensate,\n// or the data takes fewer ch.\n\n// could still lead somewhere.\n\n// one thing to note is that, aside from 4 and 7, all are symmetrical somehow\n\n/* * /\n\n// just for fun, here's a variation using a loop instead of pow:  (258 ch)\nvoid mainImage(out vec4 o, vec2 v)\n{\n    uvec2 q = uvec2(v) / 8u - 1u;\n    uint b = 0u, \n        n = uint(iTime*1e2);\n    q.x -= 28u;\n    for (int d = 9; --d > 0; n /= 10u) {\n        b |= q.x < 3u ? uint(1067450325 - int[](12286,436844416,0,303769280,-6283266)[q.y] \n                  >> (n%10u*3u + q.x)) : 0u;\n        q.x += 4u;\n    }\n    o = vec4(b&uint(q.x < 35u && q.y < 5u));\n}\n\n/* * /\n\n// spalmer experimenting with clip techniques (currently 97-126 ch just for 8 3x5 cells)\nvoid mainImage(out vec4 o, vec2 v)\n{\n    // all floating point is not working out so well: (128 ch so far)\n//    v = floor(v) / 8. - 1.;\n//    o = vec4(all(lessThan(vec4(0), vec4(\n//        31. - v.x,\n//        5. - v.y,\n//        v.y + .001,\n//        3. - mod(v.x, 4.)\n//        )))); \n    // all float meh (101 ch so far)\n//    o = vec4(\n//         abs(v.x - 128. - 8.) < 128. \n//      && abs(v.y - 28.) < 20.\n//      && mod(v.x, 32.) >= 8.\n//  );\n    // sad because they don't even need temporaries\n    \n    // all integer doing ok (97 ch so far)\n    ivec2 q = ivec2(v) / 8 - 1;\n    //o = vec4(\n    //        q.x < 31 && q.y < 5 && q.y >= 0 && (q.x&3) < 3\n    //    );\n    // using abs could save 2 ch but really adds up to 104 ch\n    o = vec4(\n            abs(q.x - 15) < 16 && abs(q.y - 2) < 3 && (q.x&3) < 3\n        );\n}\n\n// original unoptimized:\n\n/*\nint D(ivec2 q, int n)\n{\n    return (\n        int[] (\n        1067438039,\n         630605909,\n        1067450325,\n         763681045,\n        1073733591\n        )\n    [q.y] >> (\n        3 * n + q.x\n        )\n    ) & 1;\n}\n*/\n          //  0.9876543210\n          //  007777757727,\n          //  005541154425,\n          //  007747777725,\n          //  004545444125,\n          //  027747747727 \n        // obviously one can convert the constants from octal to decimal to save at least one ch each,\n        // so when ch count is a priority... and when is it not?\n        // also saved 4 ch by flipping table vertically\n    //if (n == 10) if (q.x != 1) return 0.;// else q.x--; // I got the period to work!  what a kludge though.\n    // decimal point should theoretically fit, but seems the unsigned \n    // integer right shift is being treated as a signed shift, improperly,\n    // generating a 1 where there should be no bits at all..\n    // this way (using left shift) might work.. bizarrely this fails also.\n    // I suspect my machine really only has 31 bits precision for integers.\n    //return float((r10[q.y] & (1u << (3 * n + q.x))) != 0u);\n                    //int(mod(iTime + 10., 11.))));\n/*                    \nvoid mainImage(out vec4 o, vec2 v)\n{\n    v = floor(v / 8.) - 1.;\n    ivec2 q = ivec2(v);\n    int g = q.x / 4; q.x -= g * 4;\n    o = //.5 * \n        vec4(\n            g < 8 && all(lessThan(uvec2(q), uvec2(3,5)))\n            ? \n                //2* \n            //    D(q,\n            //        int(mod(iTime / pow(10., float(6-g)), 10.)))\n            //        : 0 //: 1\n            //        \n            //\n                  (\n                  int[] (\n                    1067438039,\n                     630605909,\n                    1067450325,\n                     763681045,\n                    1073733591\n                    )\n                [q.y] >> (\n                    3 * (\n                        int(mod((iTime + .005) / pow(10., float(6-g)), 10.))\n                    ) + q.x\n                    )\n                ) & 1\n            : 0\n        );\n}\n\n*/\n\n/*\none thing to note is that for the typical 3x5 font, the columns won't ever be anything but these patterns:\n----- *---- ----* *---* *-*-- --*-* *-*-* *-*** ***-* ***** \nand maybe for alternate 4, ---*- and ****-\nthat's 10 or 12 patterns, so 4 bits LUT index can represent any column, saving 1 bit\nhex nibbles! we need 3 per glyph, 8 could fit per dword, so 2 glyphs/dword.\n\nwe can go further!\nshould also try to take advantage of symmetry; many ch are mirror images or rotations of one another,\nor have parts that are shared.\n\nreflection symmetry bitcodes could be stored compactly and might vastly reduce needed data\nhopefully without adding too much code complexity.\n\nbut then the columns won't ever be anything but:\n--- --* -*- *-- *-* ***   and maybe -** and **- for a curvy 2 and 5 or tails on 6 and 9\nso that fits in 3 bits, but then the bits themselves only take 3 bits.  So no savings to be had by tabling that way.\n\nthe LUT idea has merit, but is fairly complicated.\n*/\n\n// N.B. the 10*3*5 packing fits nicely in 5 dwords total, wasting only 2 bits per uint\n// which could conceivably represent a period, except I actually implemented that,\n// and hit trouble due to my machine apparently only having 31 bits precision or misimplementing\n// unsigned right shift as signed somehow, wouldn't work without more ugly kludges.  :octopus:\n\n\n// doesn't help\n//precision highp int;\n//precision highp float;\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}