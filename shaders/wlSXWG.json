{
    "Shader": {
        "info": {
            "date": "1566914200",
            "description": "Cookie Curves. Encoded in a Discrete Fourier Transform",
            "flags": 32,
            "hasliked": 0,
            "id": "wlSXWG",
            "likes": 14,
            "name": "Cookie Curves",
            "published": 3,
            "tags": [
                "text",
                "dft",
                "cookie"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 551
        },
        "renderpass": [
            {
                "code": "// Cookie Curves\n// Ray marching a SDF texture from a painting buffer\n// Curve is encoded with Discrete Fourier Transform\n// Original idea used in 4k pc demo at Evoke 2019\n// https://www.pouet.net/prod.php?which=82618\n\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.08.27\n\n// Using code from\n// Inigo Quilez\n// Morgan McGuire\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Discrete Fourier Transform of a curve describing the word cookie\nvec2 cookie(float t) {\n\treturn vec2(0.08+cos(t-1.58)*0.23+cos(t*2.-1.24)*0.14+cos(t*3.-1.12)*0.09+cos(t*4.-0.76)*0.06+cos(t*5.-0.59)*0.05+cos(t*6.+0.56)*0.03+cos(t*7.-2.73)*0.03+cos(t*8.-1.26)*0.02+cos(t*9.-1.44)*0.02+cos(t*10.-2.09)*0.03+cos(t*11.-2.18)*0.01+cos(t*12.-1.91)*0.02,cos(3.14)*0.05+cos(t+0.35)*0.06+cos(t*2.+0.54)*0.09+cos(t*3.+0.44)*0.03+cos(t*4.+1.02)*0.07+cos(t*6.+0.39)*0.03+cos(t*7.-1.48)*0.02+cos(t*8.-3.06)*0.02+cos(t*9.-0.39)*0.07+cos(t*10.-0.39)*0.03+cos(t*11.-0.03)*0.04+cos(t*12.-2.08)*0.02);\n}\n\n// Originaly made for a 4k pc demo at Evoke 2019\nvec2 evoke(float t) {\n\treturn vec2(-0.0911+cos(t-1.46)*0.3+cos(t*2.0-1.04)*0.13+cos(t*3.-1.3)*0.07+cos(t*4.-1.53)*0.07+cos(t*5.-1.22)*0.04+cos(t*6.-1.02)*0.03+cos(t*7.-2.84)*0.02+cos(t*8.-1.34)*0.03+cos(t*9.-1.76)*0.03+cos(t*10.-1.53)*0.03+cos(t*11.-2.48)*0.03,-0.08+cos(t+0.12)*0.07+cos(t*2.+1.02)*0.08+cos(t*3.+0.66)*0.06+cos(t*4.+0.12)*0.02+cos(t*5.+0.8)*0.05+cos(t*6.-0.15)*0.03+cos(t*7.+1.1)*0.02+cos(t*8.+0.56)*0.02+cos(t*9.+0.17)*0.06+cos(t*10.-0.71)*0.01+cos(t*11.+0.47)*0.01);\n}\n\n// draw curve sdf in buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float anim = float(iFrame)/rate;\n    float e = 1./rate;\n    vec2 next = cookie(-TAU*(anim+e));\n    vec2 prev = cookie(-TAU*anim);\n    float thin = .01+.005*sin(anim*TAU*12.);\n    \n    vec4 frame = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float sdf = sdCapsule(uv, next, prev, thin);\n    \n    // draw\n    fragColor = vec4(min(frame.x, sdf));\n    \n    // erase\n    if (mod(anim, 2.) > 1.9) fragColor = vec4((frame.x + sdf * .01));\n\n    // reset\n    if (iFrame == 0 || mod(anim, 2.) > 2.-.05)\n        fragColor = vec4(1,0,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Raymarching tab\n\n#define repeat(p,r) (mod(p,r)-r/2.)\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\n\nvec2 getUV (vec2 pos, float scale) {   \n    vec2 uv = pos/scale;\n    uv.x /= iResolution.x/iResolution.y;\n    return uv*.5+.5;\n}\n\nfloat map (vec3 pos) {\n    vec3 p0 = pos;\n    float scene = 1.;\n    \n    // distorted tube\n    float scale = 1.;\n    float radius = 1.+.5*sin(pos.y+iTime);\n    float cell = 1.25;\n    float y = pos.y + iTime * .5;\n    float iy = floor(y/cell);\n    pos.xz *= rot(pos.y * .5);\n    float l = length(pos.xz);\n    float a = atan(pos.z,pos.x);\n    float ar = (a+PI)/TAU;\n    ar += iTime * .1 - iy * .2;\n    pos.zx = vec2(l-radius,repeat(ar * 2., 1.) * 2.);\n    pos.y = repeat(y, cell);\n    scene = texture(iChannel0, getUV(pos.xy, scale)).x + abs(pos.z);\n    \n    // twisted ribbon in center\n    pos = p0;\n    pos.x += sin(pos.y+iTime) * .2;\n    pos.zx *= rot(pos.y + iTime);\n    pos.y = repeat(pos.y, 2.);\n    scene = min(scene, texture(iChannel0, getUV(pos.yx, .9)).x + abs(pos.z));\n    \n    return scene;\n}\n\nvec3 getNormal (vec3 pos) {\n  vec2 e = vec2(.001,0);\n  return normalize(vec3(map(pos)-vec3(map(pos-e.xyy),map(pos-e.yxy),map(pos-e.yyx))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float dither = random(uv+fract(iTime));\n    vec3 eye = vec3(0,.1,1.5);\n    eye.z += .2 * sin(iTime*.5);\n    eye.y += .2 * sin(iTime*.3);\n    float fov = 1.0 + .2 * sin(iTime);\n    vec3 ray = look(eye, vec3(0), uv, fov);\n    ray.xy *= rot(iTime * -.2);\n    vec3 pos = eye;\n    float total = 0.0;\n    float maxt = 20.0;\n    float shade = 0.0;\n    const int count = 50;\n    for (int index = count; index > 0; --index) {\n        float dist = map(pos);\n        if (total > maxt) {\n            shade = 0.;\n            break;\n        }\n        if (dist < 0.001) {\n            shade = float(index)/float(count);\n            break;\n        }\n        dist *= 0.7+0.1*dither;\n        total += dist;\n        pos += ray * dist;\n    }\n    float y = uv.y * .5 + .5;\n    vec3 background = mix(vec3(1, 0.682, 0.219), vec3(0.996, 0.901, 0.764), y);\n    vec3 color = mix(1.-background, vec3(1.), shade);\n    \n    fragColor = vec4(color,1);\n    //fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nconst float PI = 3.1415;\nconst float TAU = 3.1415*2.0;\nconst float rate = 500.0;\n\n// iq distance function\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}