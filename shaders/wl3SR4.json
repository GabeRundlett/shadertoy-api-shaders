{
    "Shader": {
        "info": {
            "date": "1580474334",
            "description": "Verlet softbody simulation with permanent deformation based on impact strength.",
            "flags": 48,
            "hasliked": 0,
            "id": "wl3SR4",
            "likes": 12,
            "name": "Crash and crumble",
            "published": 3,
            "tags": [
                "collision",
                "simulation",
                "deformation",
                "physics",
                "verlet",
                "softbody"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////\n//\n// Crash and crumble\n// by Timo Kinnunen 2020\n//\n// I attempted to model a collision with physically-based\n// impact damage that changes the shape of the box object\n// permanently, a short of half-way between softbody and rigid-body \n// simulation.\n//\n// The simulation keeps an extra set of vertices to record\n// the shape of the object model, in addition to vertex positions at \n// the current and previous timesteps.\n//\n// On penetrating inside the rigid ground plane, instead of the full\n// force being deflected at the vertex to bounce the object outside\n// again, a portion of the force is used to nudge the corresponding\n// model vertex instead. This allows the movement to continue while\n// slowing down, leading to further penetrations and crumbling.\n//\n// The difference between the current model vertex position and\n// the original analytical position of the vertex is used to offset\n// the vertex position in subsequent simulation timesteps.\n//\n// The orientation of the box is not tracked. Instead the rotation\n// angle is estimated from the average position of the current vertex\n// and its 3 \"diagonal\" neighbours that correspond to\n// 90/180/270 degree rotations.\n//\n//\n// Fork of \"Jello!\" by qwertsol. https://shadertoy.com/view/ldKBWd\n// 2020-01-31 11:47:47\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0), 1);\n    vec2 uv = fragCoord;\n    \n    fragColor = vec4(vec3(0.9 - distance(iResolution.xy / 2.0, uv) / iResolution.y / 10.0), 1.0);\n    fragColor.rgb += hash(uvec3(fragCoord, 29.0)) / 50.0;\n    \n    fragCoord.x -= iResolution.x / 2.0;\n\tuv = fragCoord;\n    \n    float scale = iResolution.y / 500.0;\n    \n    vec4 color = texelFetch(iChannel0, ivec2(0, 1), 0);\n    \n    int j, c = 0;\n  \tfor (int i=0, j=N*4-1; i<N*4; j=i, i+=1) \n    {\n        vec2 a = (getBody(i, iChannel0).xy+vec2(0,10)) * scale;\n        vec2 b = (getBody(j, iChannel0).xy+vec2(0,10)) * scale;\n        \n    \tif (((a.y > uv.y) != (b.y > uv.y)) &&\n     \t\t(uv.x < (b.x-a.x) * (uv.y-a.y) / (b.y-a.y) + a.x))\n      \t c++;\n  \t}\n    \n    bool isIn = (c % 2 == 1);\n\n    float totalDist = 0.0;\n    float closeDist = 9e10;\n    vec4 colors = vec4(0);\n    for (int i=0; i<4*N; i++) {\n        vec2 p1 = getBody(i, iChannel0).xy+vec2(0,10);\n        float sD = distance(fragCoord, p1.xy * scale);\n        if(sD<closeDist){\n        color = texelFetch(iChannel0, ivec2(i, 1), 0);\n            closeDist=sD;\n        }\n        const float gain =50./800.0*2.0;\n        colors = mix(texelFetch(iChannel0, ivec2(i, 1), 0),colors,fract(gain*sD*sD/(totalDist+gain*sD*sD)));\n        totalDist = mix(sqrt(sD),totalDist,fract(gain*sD*sD/(totalDist+gain*sD*sD)));\n    }\n    if (isIn)\n        fragColor = colors;\n\n    \n    vec2 p0 = getBody(0, iChannel0).xy+vec2(0,10);\n    for (int i=1; i<4*N+1; i++)\n    {\n        vec2 p1 = getBody(i, iChannel0).xy+vec2(0,10);\n        drawLine(fragCoord, p0.xy * scale, p1.xy * scale, 1.0, colors, fragColor);\n        p0 = p1;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2 g = vec2(0, -9.8) * 100.0;\nconst float td = 1.0 / 60.0; \nconst float m = 0.1;\nconst float k = 5.0;\nconst float b = 0.02;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 random =  hash(uvec3(iFrame>>9, 13, 29));\n    if ((iFrame&0x1FF) == 0 || texelFetch(iChannel1, ivec2(32, 0), 0).r > 0.0) \n    {\n        vec2 start = vec2(0, 900);\n        \n        int i = int(fragCoord.x);\n        if (i < 4*N && fragCoord.y < 3.0) \n        {\n            vec2 coords = initBodyCoords(i);\n            vec2 pos = rotate(coords * R - vec2(float(N/2)) * R, random.x * 100.0) + start;\n        \n            if (fragCoord.y > 2.0) {\n                fragColor = vec4(coords, 0, 0);\n            } else if (fragCoord.y > 1.0) {\n                if (iFrame > 0)\n                    fragColor = vec4(hue(random.y).rgb * .7, 1.0);\n                else\n                    fragColor = vec4(1, 0, 0, 1);\n            } else {\n                fragColor = vec4(pos, pos);\n                float rand = random.y*2.0-1.0;\n                fragColor.xz += sign(rand)*((0.5+0.5*abs(rand))*250.0+vec2(0,0.05/td));\n            }\n        }\n    }\n    else\n    {\n        vec2 params = (iMouse.x<10.0||iMouse.y<10.0) ? random.xy : clamp((iMouse.xy-30.0)/(iResolution.xy-50.0),0.,1.);\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        int i = int(fragCoord.x);  \n        if (i<4*N && fragCoord.y < 3.0)\n        {\n            vec4 p0 = getBody(i, iChannel0);\n            vec2 pc0 = getBodyCoords(i, iChannel0);\n            vec2 f = vec2(0);\n\n            const int S = int(float(4*N) / 2.8);\n            for (int j=-S; j<=S; j++)\n            {\n                if (j == 0)\n                    continue;\n                \n                vec4 p1 = getBody(i+j, iChannel0);\n                vec2 pc1 = getBodyCoords(i+j, iChannel0);\n                float len = distance(pc0, pc1);\n                float deformed = clamp(1./5.*(distance(initBodyCoords(i+j),pc1)+distance(initBodyCoords(i),pc0)),0.,1.);\n                f += hookesLaw(p1-initBodyCoords(i+j).xyxy+pc1.xyxy, p0-initBodyCoords(i).xyxy+pc0.xyxy, len * R,\n                               k+1.*k*deformed, b+2.*b*deformed, td);\n            }\n            \n            if (p0.y < 1.0)\n            {\n                vec2 v = (p0.xy - p0.zw) / td;\n                vec2 n = g*m + f; \n                if (n.y < 0.0)\n                \tf += -v.x * m * vec2(1, 0) * .02 * (-n.y);\n            }\n\n            vec2 newPos = p0.xy + (p0.xy - p0.zw) * .9999 + (g + f/m) * td * td;\n            vec2 oldPos = p0.xy;\n            vec2 displacement = vec2(0);\n            if (newPos.y < 0.0) {\n                if(abs(-p0.y * .3-newPos.y) > 2.5) {\n                    displacement=vec2(0,-p0.y * .3-newPos.y);\n                    vec2 cmc = 0.25*(pc0+getBodyCoords(i+N, iChannel0)+getBodyCoords(i+2+N, iChannel0)+getBodyCoords(i+3*N, iChannel0));\n                    vec2 mc = 0.25*(oldPos+getBody(i+N, iChannel0).xy+getBody(i+2+N, iChannel0).xy+getBody(i+3*N, iChannel0).xy);\n                    float srcAngle = atan(mc.y-p0.y,mc.x-p0.x);\n                    float dstAngle = atan(cmc.y-pc0.y,cmc.x-pc0.x);\n                    float srcLen = distance(mc,p0.xy);\n                    float dstLen = distance(cmc,pc0);\n                    float c = cos(dstAngle-srcAngle),s=sin(dstAngle-srcAngle);\n                    mat2 rot=mat2(c,s,-s,c);\n                    displacement = rot*displacement;\n                    //displacement*=srcLen/dstLen;\n                    displacement*=0.125;\n                }\n                newPos.y = -p0.y * .3;\n            }\n            if(fragCoord.y > 2.0) {\n                fragColor.xy += (300./450.*8.0-4.0)*displacement;\n            } else if(fragCoord.y > 1.0) {\n                float oldDmg = 0.5+0.5*smoothstep(5.,0.5,distance(initBodyCoords(i),pc0));\n                float newDmg = 0.5+0.5*smoothstep(5.,0.5,\n                                                  distance(initBodyCoords(i),pc0+\n                                                           (iMouse.y/iResolution.y*8.0-4.0)*displacement));\n                \n                fragColor.rgb *= clamp(newDmg/oldDmg,0.5,1.0);\n            } else {\n                fragColor.xy = newPos + ((450.-params.x*250.)/800.0*8.0-4.0)*displacement;\n                fragColor.zw = oldPos + ((params.y*150.+150.)/450.0*8.0-4.0)*displacement;\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define normalize(x) normalize(x+1e-6) \n\nconst int N = 20;\nconst float R = 10.0;\n\nconst uint hk = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*hk;\n    x = ((x>>8U)^x.yzx)*hk;\n    x = ((x>>8U)^x.yzx)*hk;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec4 hue( float x )\n{\n    return .6 + .6 * cos(6.3 * x  + vec4(0,23,21,0));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat segmentDistance( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nvoid drawLine( vec2 coords, vec2 p0, vec2 p1, float thickness, vec4 color, inout vec4 outputColor )\n{\n    float sD = segmentDistance(coords, p0, p1);\n\tfloat a = 1.0 - clamp(sD - thickness / 2.0 + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawCircle( vec2 coords, vec2 center, float radius, vec4 color, inout vec4 outputColor )\n{\n    float sD = distance(coords, center);\n\tfloat a = 1.0 - clamp(sD - radius + .5, 0.0, 1.0);\n    \n    outputColor = mix(outputColor, color, a * color.a);\n}\n\nvoid drawSpring( vec2 coords, vec2 p0, vec2 p1, \n                 float thickness, int loops, vec4 color, inout vec4 outputColor )\n{\n    vec2 d = p1 - p0;\n    if (length(d) < 0.001)\n        return;\n    \n    vec2 dir = normalize(d);\n    vec2 per = vec2(dir.y, -dir.x);\n    \n    vec2 st = d / float(loops * 2);\n    vec2 last = p0 + per * thickness / 2.0 + st / 2.0;\n    vec2 sw = -thickness * per;\n    float th = 1.0;\n    \n    drawLine(coords, p0, last, th, color, outputColor);\n    \n    for (int i=0; i<loops*2-1; i++)\n    {\n        vec2 next = last + st + sw;\n        sw = -sw;\n        drawLine(coords, last, next, th, color, outputColor);\n        last = next;\n    }\n    \n    drawLine(coords, last, p1, th, color, outputColor);\n}\n\nvec2 hookesLaw( vec4 anchor, vec4 body, float len, float stiffness, float damping, float dt ) \n{\n    vec2 dx = anchor.xy - body.xy;\n    float x = len - length(dx);\n            \n    vec2 d = normalize(dx);\n    vec2 v0 = (anchor.xy - anchor.zw) / dt;\n    vec2 v1 = (body.xy - body.zw) / dt;\n    vec2 dv = v0 - v1;\n    float v = dot(dv, d);\n    \n    vec2 f = (-stiffness*x) * d;\n    f += damping * v * d;\n    return f;\n}\n\nvec2 getBodyCoords(int i, sampler2D iChannel0)\n{\n    i = (i % (4*N) + 4*N) % (4*N);\n    \n    return texelFetch(iChannel0, ivec2(i, 2), 0).xy;\n}\nvec2 initBodyCoords( int i )\n{\n    i = (i % (4*N) + 4*N) % (4*N);\n    \n    if (i<N)\n        return vec2(i, 0);\n    else if (i<2*N)\n        return vec2(N, i-N);\n    else if (i<3*N)\n        return vec2(N-(i-2*N), N);\n    else\n        return vec2(0, N-(i-3*N));    \n}\n\nvec4 getBody( int i, sampler2D iChannel0 )\n{   \n    i = (i % (4*N) + 4*N) % (4*N);\n    \n    return texelFetch(iChannel0, ivec2(i, 0), 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}