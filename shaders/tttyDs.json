{
    "Shader": {
        "info": {
            "date": "1610359119",
            "description": "just effects tests",
            "flags": 32,
            "hasliked": 0,
            "id": "tttyDs",
            "likes": 23,
            "name": "TwoGroundScanningLine",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 1,
            "username": "firegump",
            "viewed": 806
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //uv handle---------------------------------------------------\n    \n    vec2 p = fragCoord/iResolution.xy;\n    \n   \n    //vec4 col1 = texture(iChannel1,p);\n    //vec3 col2 = texture(iChannel0,p).xyz;\n    //vec3 col3 = texture(iChannel2,p).xyz;\n    \n    \n     //vec4 col1 = textureLod( iChannel1, p, 0. );\n     //vec3 col2 = textureLod( iChannel0, p, 1. ).xyz;\n     //vec3 col3 = textureLod( iChannel2, p, 4. ).xyz;\n    \n    //vec3 col = mix(col1,col2,step(p.x,0.5));\n    //vec3 col =  mix(col2,col1.xyz,step(col1.w,0.3));\n    //vec3 col =  mix(col2,col1.xyz,smoothstep(0.3,0.2,col1.w));\n         //col =  mix(col3,col,step(col1.w,0.7));\n         \n         \n     vec3 col = vec3(0.); \n     \n     // dof\n    const float focus =  0.15;\n    const vec2 offsetPixel = vec2(1200.0,600.0);//vec2(800.0,450.0);\n\n    vec4 acc = vec4(0.0);\n    const int N = 4;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel1, p + off/offsetPixel ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0/(coc*coc); \n            \n            acc += vec4(color*w,w);\n        }\n    }\n   \n    col = acc.xyz ;\n    \n    \n    \n    col = col*1.1 - 0.06;\n    \n    // vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y) );\n    \n    col *=  0.95;\n    vec4 col1 = texture( iChannel1, p );\n    col = mix(col,col1.xyz,smoothstep(2.1,0.4,col1.w));\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define AniTime 0.7\n\nfloat N21(vec2 p)\n{ \n  p = fract(p * vec2(123.34,345.45));\n  p += dot(p, p + 34.345); \n         return fract(p.x*p.y);}\n\n\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  \n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  \n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere(in vec3 pos, float rad)//ellipsoid sdf\n{\n    \n    return length(pos) - rad;\n}\n\n\nfloat map(in vec3 pos)             //all distance function put in here\n{\n    float d1 = sdSphere(pos - vec3(0.,0.,-2.), 0.25);         //sphere distance field\n   \n    float d2 = sdOctahedron(pos - vec3(3.3,1.,-7.), 1.35);  //plane distance field\n    \n    float d3 = sdSphere(pos - vec3(-5.3,0.,-3.),1.45);\n    d2 = min(d2,d3);\n    \n    float d8 = sdSphere(pos - vec3(-4.3,0.,-3.),1.45);\n    d2 = opSmoothSubtraction(d8,d2,0.5);\n    \n    \n    float d4 = sdRoundBox(pos - vec3(-3.3,1.,-5.), vec3(1.,1.,1.), 0.25);\n    d2 = min(d2,d4);\n    \n    float d6 = sdRoundBox(pos - vec3(-3.3,3.,-5.), vec3(0.8,0.8,0.8), 0.25);\n    d2 = min(d2,d6);\n    \n    float d5 = sdOctahedron(pos - vec3(3.3,1.,-10.), 2.35);\n    d2 = min(d2,d5);\n    \n    float d7 = sdRoundedCylinder( pos - vec3(5.3,0.2,-5.), .4, 0.2,0.3);\n    d2 = min(d2,d7);\n    \n    float d9 =  pos.y - (- 0.25);\n    d2 = min(d2,d9);\n    \n    //float d10 = opRep(pos, vec3(1.,1.,1.),  );\n    //d2 = min(d2,d9);\n    \n    return min(d1,d2);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(map(pos + e.xyy) - map(pos - e.xyy),\n                          map(pos + e.yxy) - map(pos - e.yxy),\n                          map(pos + e.yyx) - map(pos - e.yyx)));\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    \n    float t = 0.0;           //t is the raymarching total distance\n    for(int i = 0;i<100;i++)\n    {\n    \n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if(h< 0.001) break; //if ray hit something break loop\n        \n        \n        t += h;\n        if(t>20.0) break;                 //save cost\n    }\n    if(t > 20.0) t = -1.0;                //if ray doesn't hit something return  -1.\n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    //uv handle---------------------------------------------------\n    \n    vec2 p = fragCoord/iResolution.xy; \n    p     -= 0.5;                         //move 0,0 to screen center\n    p.x   *= iResolution.x/iResolution.y; //modify aspect ratio\n    p     *= 2.;                          //remap to -1,1 , result is same calculation as above\n    \n    //camera------------------------------------------------------\n    float an = 10.0*iMouse.x/iResolution.x;//iTime;\n    //an = 0.;\n    \n    vec3 ta  = vec3(0.0,1.1,0.0);\n    //ta = vec3(0.,0.,0.);\n    vec3 ro  = ta + vec3(2.0*sin(an),0.0,2.0*cos(an));//camera position\n    \n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    \n    vec3 rd  = normalize(p.x*uu + p.y*vv + 1.5* ww);//camera direction viewspace to worldspace\n    \n    //vec3 rd = normalize(vec3(p,1.));\n    \n    \n   \n   \n    \n    vec3 col = vec3(0.4,0.75,1.) - 0.7*rd.y;             //sky color Gradient\n    col = mix(col,vec3(0.7,0.75,0.8),exp(-10.0 * rd.y)); //make horizon\n    \n    \n    float t = castRay(ro,rd);\n    \n    \n    \n    \n    \n    \n    if(t>0.0)\n    {   vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 cameraOrientation = ww;\n        //cameraOrientation = normalize(vec3(2.0*sin(an),0.0,2.0*cos(an)));\n        \n        //noise grid\n        float id = N21(floor(pos.xz*0.8));\n        \n        \n        \n        //animation\n         vec3 PointPos = vec3(0.,0.,-10.);\n         //PointPos = ro;\n         float aT = fract(iTime*AniTime);\n         //dist 1-------------------------------------------------------------------\n         float  dist1 = length(pos - PointPos);//distance sample\n         //dist 2------------------------------------------------------------------\n         //float  dist2 =  dot(normalize(cameraOrientation.xz),(pos - ro).xz);\n         vec3 rd1 = normalize(p.x*uu + p.y*vv + 1.5* ww);\n         \n         float  dist2 =  dot(ww.xz,rd1.xz*t);\n         \n         \n         float m = mod(floor(iTime*AniTime),2.);\n         \n         float dist = mix(dist1,dist2,m);\n         //dist = dist2;\n         \n         \n         float distPoint = 25.*aT+0.;\n         float distRange = 0.28;\n         \n         float  ds = step(dist,distPoint );\n         float  dOutline = (1.-ds)*step(dist,distPoint + distRange);\n        \n         \n         \n        \n        \n        \n        \n        //material\n        vec3 uvPos = pos*0.1;\n        vec3 mate1 = texture(iChannel0,uvPos.xz).xyz* nor.y*nor.y;\n        vec3 mate2 = texture(iChannel0,uvPos.yz).xyz* nor.x*nor.x;\n        vec3 mate3 = texture(iChannel0,uvPos.xy).xyz* nor.z*nor.z;\n        \n        vec3 mate = mate1+ mate2 + mate3;\n        mate *= 0.28;\n        \n     \n        \n        \n        //get material illumination\n        //float illumination = 0.299*mate.x + 0.587*mate.y + 0.114*mate.z;\n        \n        //float norScale = 0.5;\n        //float norOffset =  2.0*(illumination - 0.5)*norScale;\n        //vec3 norX = normalize(vec3(nor.x,nor.y, nor.z + norOffset))* nor.y*nor.y;\n         //vec3 norY = normalize(vec3(nor.x,nor.y + norOffset, nor.z ))*nor.x*nor.x;\n          //vec3 norZ = normalize(vec3(nor.x,nor.y, nor.z + norOffset))*nor.z*nor.z;\n        \n        //nor = normalize(norX+ norY+ norZ);\n        \n        vec3  sun_dir = normalize(vec3(0.8,0.4,0.2));\n        float sun_dif = clamp(dot(nor,sun_dir),0.0,1.0);                     //sun diffuse sample\n        float sun_sha = step(castRay(pos + nor*0.001, sun_dir),0.0);         //shadow      sample\n        float sky_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0); //sky diffuse sample\n        float bou_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);//reflected light from the ground\n        float rim = pow(clamp(1.-dot(nor,-rd),0.0,1.0),8.);\n        \n        vec3 h = normalize(-rd + sun_dir);\n        float sun_spe = pow(clamp(dot(nor, h),0.,1.),64.);\n        \n        col =  mate*vec3(7.0,6.0,4.0)*sun_dif * sun_sha;\n        col += mate*vec3(0.5,0.8,0.9)*sky_dif;\n        col += mate*vec3(0.7,0.3,0.2)*bou_dif;\n        col += mate*vec3(3.7,2.3,2.2)*sun_spe;\n        \n        vec3 cubemapCol = textureLod( iChannel1, nor, 4. ).xyz;\n        col = mix(col,cubemapCol,rim);\n        \n        //lineSample\n        vec3 lineSa = step(fract(4.5*pos),vec3(0.08));\n        float lineS = lineSa.x+lineSa.y + lineSa.z;\n        \n        \n        //id = id*2. - 1.;\n        vec3 lineCol = vec3(0.0,1.5,1.2)*step(0.9,lineS);//vec3(0.0,1.5,1.2 + id )\n        \n        col = mix(col,mix(col,lineCol,lineS), ds) + vec3(dOutline);\n        //col = mate;\n        \n        //col = vec3(rim);\n        //col =  textureLod( iChannel1, nor, 4. ).xyz;\n        //col = vec3(id);\n        //col = vec3(dot(ww.xz,rd.xz*t))/300.;\n         \n        \n        \n    }\n    \n    //col = pow(col, vec3(0.4545));//gamma just 1/2.2;\n    \n    if(t<0.) t = 5.;\n    float depth = t/5.;\n    \n    \n    //show depth step value 0.3 0.7\n    //depth = step(depth,0.3)*0.5+ step(depth,0.7)*0.5;\n    //col = vec3(id);\n    \n    \n    \n    \n    \n    \n    //col = vec3(dot(ww.xz,rd.xz*t)/50.); //orientation test\n    \n\n    // Output to screen\n    fragColor = vec4(col,depth);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}