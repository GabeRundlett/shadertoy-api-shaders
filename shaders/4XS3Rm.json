{
    "Shader": {
        "info": {
            "date": "1708307252",
            "description": "I guess at this point its just an artistic rendition of a black hole, it follows... some of the laws of physics, has janky stars now, and better volumetrics\nAlso has very simple bloom. time to learn camera projection.",
            "flags": 32,
            "hasliked": 0,
            "id": "4XS3Rm",
            "likes": 27,
            "name": "Black Hole Raymarcher 3",
            "published": 3,
            "tags": [
                "procedural",
                "raymarch",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "Zentient",
            "viewed": 1577
        },
        "renderpass": [
            {
                "code": "/*\n    Copyright 2024 - Daniel Oren-Ibarra\n    Listed under GNU - GPL license: https://www.gnu.org/licenses/gpl-3.0.en.html \n    This software may be used, modified and distributed in any manner,\n    so long as the source code remains public.\n    \n    \n    Previous versions and feature developments of this shader\n===================================================================    \n    Black Hole Raymarcher 2: https://www.shadertoy.com/view/4XjGzz\n    Black Hole Raymarcher 1: https://www.shadertoy.com/view/M3lGD4\n    Fast 3d noise fog: https://www.shadertoy.com/view/XXj3Rz\n*/\nconst int doBloom = 1; //Change to 0 to disable bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    if(doBloom == 1)\n    {\n        vec3 bloom = textureLod(iChannel0, uv, 2.0).rgb;\n        bloom = pow(bloom, vec3(3.0));\n        col += bloom;\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Buffer A calculates the ray vectors from the camera. Badly implemented, have to look into camera matrixes\nconst vec2 camAngle = vec2(-5.0, 0.0);\nconst float FOV = 60.0 * 0.0174533; //Radians Conversion\nvoid mainImage( out vec4 pixVector, in vec2 fragCoord )\n{\n    //Calculate ray vector\n    vec2 newCam = camAngle;\n    if(iMouse.xy == vec2(0.0)) {newCam = vec2(-1.6, 0.55);}\n    newCam.y = newCam.y + (-0.15 * sin(((iTime + 15.0) / 15.0)) - 0.2);\n    vec2 pixAxis =  newCam + vec2(8.0, 3.5) * (iMouse.xy) / iResolution.xy - 0.5 + FOV * (0.5 + fragCoord) / iResolution.x;\n    \n    \n    //Send ray vectors to next buffer\n    pixVector = vec4(pixAxis, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define hashi(x)   lowbias32(x)\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\n#define steps  90\nconst int starAA = 8; //Multisamples the stars\nvec3 camPos = vec3(0.0, 220.0, 0.0);\nconst vec3 holePos = vec3(0.0, 0.0, -0.0);\nconst float holeRadius = 10.0; //Issues below three with star projection\nconst float detail = 3.0;//noise octaves, large performance impact\nconst float density = 3.0; //Largest noise value\nconst float stepVa = 20.0; //Maximum length of fine raymarching steps\nconst float bounds = 500.0; //Boundary distance for black hole\nconst float vol = 8.0;    //brightness of volume\nconst float volDen = 0.7; //opacity of volume, between 0 and 1\n\n\n//Random function and hash from https://www.shadertoy.com/view/WttXWX\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n\nfloat rand(vec3 position)\n{\n    uvec3 V = uvec3(position);\n    float h = hash( V.x + (V.y<<16) + (V.z<<8));  // Converted 3D hash\n    return h;\n\n}\n//=====================================================================\n//3d noise functions\n//=====================================================================\n\n//bilinear interpolation function \nfloat interpolate(vec3 position)\n{\n    vec3 quantPos = round((position + 0.5));\n    vec3 divPos = fract(1.0 * position);\n    \n\n    //Finds noise values for the corners, treats Z axis as a separate rectangle for ease of lerping\n    vec4 lerpXY = vec4(\n        rand(quantPos + vec3(0.0, 0.0, 0.0)),\n        rand(quantPos + vec3(1.0, 0.0, 0.0)),\n        rand(quantPos + vec3(1.0, 1.0, 0.0)),\n        rand(quantPos + vec3(0.0, 1.0, 0.0)));\n    \n    vec4 lerpXYZ = vec4(\n        rand(quantPos + vec3(0.0, 0.0, 1.0)),\n        rand(quantPos + vec3(1.0, 0.0, 1.0)),\n        rand(quantPos + vec3(1.0, 1.0, 1.0)),\n        rand(quantPos + vec3(0.0, 1.0, 1.0)));\n    \n    //Calculates the area of rectangles\n    vec4 weights = vec4(\n    abs((1.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (1.0 - divPos.y)),\n    abs((0.0 - divPos.x) * (0.0 - divPos.y)),\n    abs((1.0 - divPos.x) * (0.0 - divPos.y)));\n    \n    //linear interpolation between values\n    vec4 lerpFinal = mix(lerpXY, lerpXYZ, divPos.z);\n   \n    return weights.r * lerpFinal.r +\n           weights.g * lerpFinal.g +\n           weights.b * lerpFinal.b +\n           weights.a * lerpFinal.a;\n    \n}\n\n//Octaves of noise, sligtly less than a perfect octave to hide bilinear filtering artifatcs\nfloat octave(vec3 coord, float octaves, float div)\n{\n    \n    float col;\n    float it = 1.0;\n    float cnt = 1.0;\n    for(float i = 1.0; i <= octaves; i++)\n    {\n        col += interpolate((it * coord / (div))) / it;\n        it = it * 1.9;\n        cnt = cnt + 1.0 / it;\n       \n    }\n    return pow(col / cnt, 1.0);\n}\n\n//Procedural starmap\nfloat starField(vec3 vector)\n{\n    float b;\n    float sizeDiv = 500.0;\n    vector = sizeDiv * (1.0 + normalize(vector));\n    if(starAA > 0)\n    {\n        for(int i = 0; i < starAA; i++)\n        {\n           vector += 100.0 * rand(vec3(i)) / sizeDiv;\n           float a = 1.0 - (4.0 * rand((vector)));\n           if(a < 0.9) {a = 0.0;}\n           a = 6.0 * pow(a, 20.0);\n           b += a;\n        }\n    }\n    \n    return b / float(starAA);\n}\n\n//=====================================================================\n//Distance Fields and volumetrics\n//=====================================================================\nvec2 distField(vec3 position, vec3 origin)\n{\n    //Distance Field inputs\n    float radius = 45.0;\n    float dist = distance(origin, position);\n    float distXY = max(distance(origin.xy, position.xy) - holeRadius, 0.0);\n    float fieldZ = max(0.0, pow(distance((origin.z), position.z), 2.5));\n    \n    \n    //calculates angle to transform a 2d function to a radial one\n    float angle = atan((position.x - origin.x) / (position.y - origin.y));\n    if(position.y <= origin.y) {angle = angle + 3.1415;}\n    angle = angle + 0.05 * iTime;\n   \n    //Distance field components\n    float cloud = pow(clamp(radius / (dist - holeRadius), 0.0, 1.0), 2.5);\n    float i;\n    float spiral;\n    float occ;\n    spiral = octave(vec3(dist, 50.0 * (1.0 + sin(angle))\n    , 1.0 * distance(origin.z + 3.0 * iTime, position.z)), detail, density);//3d noise function\n\n    //Merge components\n    float finalDF = cloud * clamp(spiral / (fieldZ), 0.0, 1.0);\n    if(finalDF < volDen){occ =(volDen - spiral);}\n    return vec2(finalDF, max(occ / (dist * distance(position.z, origin.z) / 500.0), 0.0));\n}\n\n//=====================================================================\n//Ray marching function\n//=====================================================================\nvec3 rayCast(vec2 rayAxis)\n{\n    \n    float stepSize;\n    float gravDis = 2.0 * 1.666667 * 2392.3 * pow(1.0973, holeRadius);\n    \n    //Variables to determine position changes and ray vectors\n    float yTravel = camPos.y - holeRadius;\n    float timeOff = (iTime + 12.0) / 15.0;\n    vec3 newCam = vec3(camPos.x, camPos.y + cos(timeOff) * (yTravel), sin(timeOff) * 30.0);\n    vec3 rayPos = newCam;\n    vec3 rayVel = vec3(cos(rayAxis.x), sin(rayAxis.x), sin(rayAxis.y));\n    float rayDist = distance(rayPos, holePos);\n    float rayVol;\n    vec2 dField;\n    float colShift;\n    float occ = 1.0;\n    //Jump the ray forward to allow it to render the black hole at large distances\n    rayPos += rayVel * max(rayDist - bounds, 0.0); \n    \n    for(int i = 0; i <= steps; i++)\n    {\n        rayDist = distance(rayPos, holePos);\n        float boDist = pow(rayDist / 500.0, 2.0);\n        float diskDist = rayDist;//distance(rayPos.xy, holePos.xy);\n        \n        rayPos += rayVel;\n        \n        //vector of deflection\n        vec3 rayDefl = normalize(holePos - rayPos);\n        \n       \n       //Deflect the ray for gravity\n        rayVel += gravDis * pow(stepSize, 2.4) * vec3((rayDefl.x) * (1.0 / pow(rayDist, 4.0)),\n            (rayDefl.y) * (1.0 / pow(rayDist, 4.0)),\n            (rayDefl.z) * (1.0 / pow(rayDist, 4.0)) );\n       \n       //Distance field calculations\n        dField = distField(rayPos, holePos);\n\n        //float travel = distance(rayPos, newCam) / 300.0; \n        stepSize = min(clamp(rayDist - (holeRadius + stepVa), 0.05, stepVa), max(boDist + distance(holePos.z, rayPos.z),0.2));\n        \n        rayVel = normalize(rayVel) * stepSize;\n        \n        //Volumetric rendering of the Accretion Disk\n        occ += dField.g;\n        rayVol = rayVol + (dField.r * vol * stepSize) / occ;//mix((((dField.r) * vol) * stepSize), 0.0, 0.0);//(occ) / 2.0);\n        \n        if(rayDist >= 2.0 * bounds)\n        {return vec3((starField(rayVel) / (occ)) + rayVol, clamp(rayVol * colShift, 0.0, 1.0), rayVol);}\n        \n        if(rayDist <= holeRadius) \n        {return vec3(rayVol, clamp(rayVol * colShift, 0.0, 1.0), rayVol);}\n        \n        //Color things, fakes a subtle blueshift, but does a horrible job at it.\n        colShift += rayVol * rayPos.x / (float(steps) * 100.0);\n    }\n    if(rayDist >= holeRadius * 3.0){rayVol += starField(rayVel) / (occ);}\n    return vec3(rayVol, clamp(rayVol * colShift, 0.0, 1.0), rayVol);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //noise texture to distort rays\n    vec2 pixAxis = texture(iChannel0, uv).rg;\n    vec3 col = rayCast(pixAxis);\n    \n   \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Kelvin to RGB algorithm thanks to https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html\nvec3 tempConvert( float temp)\n{\n    vec3 color;\n    float newtemp = pow((temp / (1.0)), 3.0) * 255.0;\n    if(newtemp <= 66.0) \n        {\n            color.r = 255.0;\n            color.g = 99.4708025861 * log(newtemp) - 161.1195681661;\n            if(newtemp <= 19.0) {color.b = 0.0;}\n                else \n                {\n                    color.b = newtemp - 10.0;\n                    color.b = 138.5177312231 * log(color.b) - 305.0447927307;\n                }\n        }\n        else \n        {\n            color.r = newtemp - 60.0;\n            color.r = 329.698727446 * pow(color.r, -0.13321);\n            color.g = newtemp - 60.0;\n            color.g = 288.1221695283 * pow(color.g, -0.075515);\n            color.b = 255.0;\n        }\n   \n    return clamp(color / 610.0, 0.0, 1.0);\n}\n\n\n//ACES tonemapping\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 temp = tempConvert(col.r);\n    \n    //Quick and dirty faking of blue shift, mostly meant to look pretty\n    vec3 shift = mix(vec3(1.0, 0.3, 0.1), vec3(0.55, 0.7, 1.0), vec3(col.g));\n    \n    col = vec3(pow(col.r, 2.0) * (temp / (temp + 1.0)));\n    col *= shift;\n    col = pow(mix(col, ACESFilm(col), 1.0), vec3(1.0 / 2.2));\n     \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}