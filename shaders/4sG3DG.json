{
    "Shader": {
        "info": {
            "date": "1456090530",
            "description": "A very simple slope based erosion simulator. It just carves out slopes with 625 rain drops that evaporate over time.  It takes a short while to look OK, but not thousands of years! Click to change scenery",
            "flags": 48,
            "hasliked": 0,
            "id": "4sG3DG",
            "likes": 29,
            "name": "Water Erosion",
            "published": 3,
            "tags": [
                "heightmap",
                "mountain",
                "erosion",
                "watererosion"
            ],
            "usePreview": 0,
            "username": "Dave_Hoskins",
            "viewed": 2951
        },
        "renderpass": [
            {
                "code": "// Water erosion\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A very simple slope based erosion simulator.\n// It just carves out slopes with 2500 rain drops that evaporate over time.\n// It takes a short while to look OK, but not thousands of years! :)\n// Water rendered using a type of 'metaball' thing.\n\n#define NUMSQU 25.\n\n// Leaving out the water entirely is quite interesting to watch.\n#define RENDERWATER\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\tvec2 uv = coord.xy / iResolution.xy;\n\tcolour = texture(iChannel1, coord / iChannelResolution[1].xy);\n #ifdef RENDERWATER\n    if (mod(iTime, 4.0) < 3.0)\n    {\n        float v = 0.0;\n      for (float y = 0.; y < NUMSQU; y++)\n        {\n            for (float x = 0.; x < NUMSQU; x++)\n            {\n                vec2 xy = vec2(x, y)+.5;\n                vec2 pos = texture(iChannel0, xy / iChannelResolution[0].xy).xy;\n\t\t\t\tv += pow(2. / distance(pos, coord), 2.2);\n            }\n        }\n      \tcolour = mix(colour, vec4(0.4,.6,1.,1.), min(v, 1.0));\n    }\n#endif\n         \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Water erosion\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A very simple slope based erosion simulator.\n// It just carves out slopes with 2500 rain drops that evaporate over time.\n// It takes a short while to look OK, but not thousands of years! :)\n\n#define NUMSQU 25.0\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\nfloat terrain(vec2 p)\n{\n    p+=.5;\n    float h = texture(iChannel1, p/ iChannelResolution[1].xy).x;\n    return h;\n}\nvec3 getNormal( in vec2 pos)\n{\n    vec2  eps = vec2( 1., 0 );\n    return normalize( vec3( terrain(pos-eps.xy) - terrain(pos+eps.xy),\n                           2.*eps.x,\n                 \t\t   terrain(pos-eps.yx) - terrain(pos+eps.yx) ));\n}\n\nvec3 placeRainDrop(in vec2 coord)\n{\n    //vec2 pos = (coord / NUMSQU) *iResolution.xy;\n    vec2 pos = hash22(coord-iTime*33.33)*iResolution.xy;\n    pos = mod(pos, iResolution.xy);\n    float r = iResolution.y;\n    return vec3(pos,hash12(coord+iTime)*r*.5+r*.2);\n}\n\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n    if (coord.x >= NUMSQU || coord.y >= NUMSQU) discard;\n    \n    vec3 pos;    \n\n    if (iFrame <= 1 || iMouse.z > 0.5)\n    {\n\t\tpos = placeRainDrop(coord);\n    }else\n    {\n        vec4 loc = texture(iChannel0, coord / iChannelResolution[0].xy);\n        pos = loc.xyz;\n    }\n    vec3 nor = getNormal(pos.xy);\n\n    if (pos.z-- < 0.0 || nor.y >= 1.)\n    {\n     \tpos = placeRainDrop(coord);\n\t }\n\n\tpos.xy = mod(pos.xy+nor.xz*1.0*iResolution.xy, iResolution.xy);\n        \n    colour = vec4(pos,clamp(dot(nor.xz, nor.xz),.002,.007));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Water erosion\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A very simple slope based erosion simulator.\n// It just carves out slopes with 625 rain drops that evaporate over time.\n// It takes a short while to look OK, but not thousands of years! :)\n\n#define NUMSQU 25.0\n#define HASHSCALE1 .1031\n\n//--------------------------------------------------------------------------\nfloat hash12(in vec2 p, in float scale)\n{\n    p = mod(p, scale);\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------\n// Tiled noise to make it wrap around for flying...\nconst vec2 add = vec2(1,0);\nfloat noise( in vec2 x, in float scale )\n{\n    x *= scale;\n    x+=iTime+20.;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( hash12(p, scale), hash12(p + add.xy, scale),f.x),\n                    mix( hash12(p + add.yx, scale), hash12(p + add.xx, scale),f.x),f.y);\n    return res;\n}\nfloat fbm(vec2 pos)\n{\n\n    float a = 0.0;\n    float v = 1.;\n    float scale = 3.0;\n    for (int i = 0; i < 12; i++)\n    {\n        a+= pow(noise(pos, scale) * v,1.6);\n        scale *= 2.2;\n        v *= .54;\n    }\n    return a;\n}\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    vec2 uv = coord.xy / iResolution.xy;\n    if (iFrame <= 1 || iMouse.z > 0.5)\n    {\n        float h = fbm(uv);\n        colour = vec4(h);\n    }else\n    {\n        \n        colour = texture(iChannel1, uv);\n        for (float y = 0.; y < NUMSQU; y++)\n        {\n            for (float x = 0.; x < NUMSQU; x++)\n            {\n                vec2 xy = vec2(x, y)+.5;\n                vec4 pos = texture(iChannel0, xy / iChannelResolution[0].xy);\n                // The speed of the drop is taken as an erosion multiplier...\n                float l = clamp(1.3-length(pos.xy-coord), 0.0, 1.0);\n                colour -= l*pos.w;\n            }\n        }\n    }\n    colour = max(colour,0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}