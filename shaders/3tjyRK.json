{
    "Shader": {
        "info": {
            "date": "1595210514",
            "description": "Simulation of Burnish flames from the movie Promare.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tjyRK",
            "likes": 1,
            "name": "Burnish Flame",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "triangle"
            ],
            "usePreview": 0,
            "username": "oofydoodle",
            "viewed": 358
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\n// Flame colors\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\n\n// Triangle Wave\nfloat triWave(float x) {\n    return (3.0 / PI) * asin(sin(PI * x));\n}\n\n// Determine if a point is part of the flame\nbool inFlame(vec2 o, vec2 p, float radius, float height, float rise)\n{\n    // Within circle\n    if (distance(o, p) <= radius) return true;\n    \n    // Within point\n    vec2 top = vec2(o.x, o.y + rise + height);\n    vec2 bottom = vec2(o.x, o.y + rise);\n    \n    bool inYRange = p.y < top.y && p.y > bottom.y;\n    \n    float t = (p.y-bottom.y)/(top.y-bottom.y);\n\n    float botRad = radius * 0.7;\n    \n    float x = botRad * (1.0 - t) + 5.0;\n    float xRadiusAtY = clamp(x*x / 30.0, 0.0, botRad);\n    \n    bool inXRange = p.x < o.x + xRadiusAtY && p.x > o.x - xRadiusAtY;\n\n    if (inXRange && inYRange) return true;\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    // Point at center of flame\n    vec2 flameOrigin = vec2(iResolution.x / 2.0, (iResolution.y / 2.0) * 0.8);\n\n    // Move flame left/right\n    flameOrigin = vec2(flameOrigin.x + sin(iTime * 2.0) * 20.0, flameOrigin.y);\n\n    // Inner/outer flame radius\n    float baseRadius = 80.0;\n    float nshift = 2.0 * noise(fc + vec2(0, iTime));\n    float outerRadius = baseRadius - nshift + noise(vec2(iTime, 0)) * 2.0;\n    float innerRadius = baseRadius / 2.0 - nshift + noise(vec2(0, iTime)) * 2.0;\n\n    // Inner/outer flame height\n    float outerHeight = 150.0 + noise(vec2(iTime, 0)) * 10.0;\n    float innerHeight = 70.0 + noise(vec2(0, iTime)) * 10.0;\n    float outerRise = 0.0 + noise(vec2(iTime, 0)) * 2.0;\n    float innerRise = 30.0 + noise(vec2(0, iTime)) * 2.0;\n\n    // fragCoord gets shifted using a triangle wave\n    fc = vec2(fc.x + (triWave(iTime * 0.2) * fc.y / 10.0) + triWave(fc.y / 25.0 + iTime * 4.0) * 8.0, fc.y);\n\n    vec3 col = inFlame(flameOrigin, fc, outerRadius, outerHeight, outerRise) ? MAGENTA : vec3(0.0);\n    col = inFlame(flameOrigin, fc, innerRadius, innerHeight, innerRise) ? CYAN : col;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// rand and noise functions taken from:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}