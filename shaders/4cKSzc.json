{
    "Shader": {
        "info": {
            "date": "1718073768",
            "description": "Whatâ€™s next to learn after Box-O-Balls? Why, a Box of Boxes of course.\nI played with some new sounds. Which to use? All of them!\n",
            "flags": 8,
            "hasliked": 0,
            "id": "4cKSzc",
            "likes": 2,
            "name": "Box Of Noisy Boxes",
            "published": 3,
            "tags": [
                "sound",
                "boxes"
            ],
            "usePreview": 0,
            "username": "dray",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "/*\nThis really separates slower iPhone peformance from faster destop performance.\nPrevious spheres (balls) were easier and faster.\nFast performance is difficult with the random computations for box sizes,\ncontinuous rotations and colors.\nTo improve performance and because it looked messy,\nboxes do not cast shadows on other boxes or 2 of the walls.\nIn-lining by using macros does not help much or at all because the\ncompiler does that frequently.\nUsing pre-computed arrays of random values sometimes helps speed things\nas well as early exits from unneeded calculations, but both benefits\nare hard to measure and not consistent.\nMotion is dynamically slowed on slower gpus for less jerkyness.\n*/\n\n// Reduce this if too slow:\n#define NUMBALLS 25 // now boxes !\n\n//#define PRECOMP\n//#define PREHALF\n\n/*\nNUMBALLS PRECOM   PCfps   IPHONE fps\n  40        Y       23\n  30        Y       25\n  25        Y      30/7     4.8\n  25        N               5.7\n  20        Y      48.1\n  15        N                10\n  15        Y                6.5\n*/\n\n//#define iTime 9. // freeze a moment in time for testing\n\nfloat xTime; // slower speed on slower hardware\n\nfloat irnd=0.;\n#define rnd(L,H) ((irnd = fract( irnd*54.2+5./12.333 ))*(H-L)+L)\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define tri(X) (abs(fract(X)*4.-2.)-1.)\n\n#define scl(IN,IL,IH,OL,OH) ( ((IN)-(IL)) * ((OH)-(OL)) / ((IH)-(IL)) + (OL) )\n\n#define rsin(L,H,SPD) scl( sin(xTime*(SPD)), -1., 1., L, H )\n#define rtri(L,H,SPD) scl( tri(xTime*(SPD/TAU)), -1., 1., L, H )\n\nfloat pow2(float x,int p2) { // power of power of 2\n  while ( p2-- > 0 ) x *= x;\n  return x;\n}\n\n#define max3(V) max((V).x,max((V).y,(V).z))\n\n#define MINSZ (.1)\n#define MAXSZ (1.5)\n#define WALLS (9.)\n#define DEPTH (20.)\n\nint ixrnd = 0;\n\n#ifdef PRECOMP\n\nfloat pre[NUMBALLS*8];\n\nvoid Rndm() { // compute random box sizes and motions\n  irnd = 1.; // reset randomizer\n  int z = 0;\n  for ( int i; i < NUMBALLS; ++i ) {\n    pre[z++] = rnd(MINSZ,MAXSZ);\n    pre[z++] = rnd(MINSZ,MAXSZ);\n    pre[z++] = rnd(MINSZ,MAXSZ);\n#ifndef PREHALF\n    pre[z++] = rnd(.2,2.);\n    pre[z++] = rnd(.2,2.);\n    pre[z++] = rnd(.2,2.);\n    pre[z++] = rnd(-1.,1.);\n    pre[z++] = rnd(-1.,1.);\n#else\n#endif\n  }\n}\n\n\n#define xrnd(L,H) pre[ixrnd++]\n\n#else\n\n#define xrnd(L,H) rnd(L,H)\n\n#define Rndm()\n\n#endif\n\n\n// sdf of orthogonal box at 0, originally iq https://www.shadertoy.com/view/Xds3zN\nfloat sdBox( vec3 pt, vec3 box )\n{\n    vec3 d = abs(pt) - box; // everything is symmetrical so just 3 sides need examination\n    return min(max3(d),.0) + length(max(d,.0));\n}\n\nvec2 rot2d(vec2 inp,float ang) {\n  float s = sin(ang);\n  float c = cos(ang);\n  return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\nvec3 rot3dz(vec3 i,float x,float y) {\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  return vec3( i.x*cy+(i.z*cx-i.y*sx)*sy, i.y*cx+i.z*sx, (i.z*cx-i.y*sx)*cy-i.x*sy );\n}\n\nfloat sdAnyBox(vec3 pt,vec3 orig,vec3 rot,vec3 box)\n{\n  pt -= orig; // Move view, not box\n#define QUICKEXIT // does not help performance significantly\n#ifdef QUICKEXIT\n  float sz = max3(box);\n  float sph = length(pt)-sz; // theory: enclosing sphere\n  //return sph; // sphere\n  //if (sph>.0) return sph/2.; // sphere\n  //if (sph>.001) return sph/2.; // dithered sphere surface\n  if (sph>1.) return sph; // reality: needs lots of margins\n#endif\n#if 0\n  pt = rot3dz( pt, rot.x, rot.y ); // not always faster ?\n#else\n  pt.yz = rot2d(pt.yz,rot.x); // rotate view around box\n  pt.xz = rot2d(pt.xz,rot.y);\n  //pt.xy = rot2d(pt.xy,rot.z); // does not add much visually but performance loss\n#endif\n  return sdBox(pt,box);\n}\n\nvec3 light;\nfloat light_size = .2;\n\n// avoid green used for walls\n#define clr(T) (sin((mod(T,4.)+1.)+vec3(0.,6.28/3.,6.28*2./3.))*.5+.5)\n//#define clr(T) (sin((T)+vec3(0.,6.28/3.,6.28*2./3.))*.5.+.5)\n\n// Used N*2 Marches + 4*1 Normal\nvec2 Dist(vec3 pt) { // return distance to closest object and object\n\n  irnd = 1.; // reset randomizer\n  ixrnd = 0; // reset precomputed\n\n  float dist = 10000.;\n  int id = 1;\n\n#define IF(DIST,ID) { float tmp = DIST; if ( tmp < dist ) dist = tmp, id = ID; }\n\n  IF( distance( pt, light ) - light_size, 100 );\n\n  irnd = 1.; // reset randomizer\n  ixrnd = 0; // reset precomputed\n  for ( int bls = 0; bls < NUMBALLS; ++bls )\n  {\n    vec3 size = vec3(xrnd(MINSZ,MAXSZ),xrnd(MINSZ,MAXSZ),xrnd(MINSZ,MAXSZ));\n    float mx = max3(size);\n    vec3 origin = vec3(rtri(-WALLS+mx,WALLS-mx,xrnd(.2,2.)),\n                       rtri(-WALLS+mx,WALLS-mx,xrnd(.2,2.)),\n                       rsin(6.,DEPTH-mx,xrnd(.2,2.)));\n    IF(\n      sdAnyBox(\n        pt,\n        origin,\n        vec3(xrnd(-1.,1.),xrnd(-1.,1.),0.)*iTime, // rotation\n        size )\n      , bls+1000 )\n  }\n\n  IF( pt.y+WALLS, -52 ) \n  IF(-pt.y+WALLS, -2 )\n  IF( pt.x+WALLS, -52 )\n  IF( -pt.x+WALLS, -2 )\n  IF( -pt.z+DEPTH, -51 )\n\n  return vec2(dist,id);\n\n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n  float dist = 0.;\n  vec3 pos;\n  for ( int stps = 0; stps < 300; ++stps ) {\n    pos = beg + dir * dist;\n    if ( pos.z < -30. ) return vec4(pos,91.); // hit cameraman\n    vec2 obj = Dist( pos );\n    dist += obj.x;\n    if ( obj.x < .001 || dist > 1000. ) return vec4( pos, obj.y );\n  }\n  return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n  float dist = Dist(pt).x;\n  //float delta = .001;\n  float delta = .1; // large delta gives rounded corners\n  vec3 norm = dist - vec3(\n    Dist(pt-vec3(delta, 0., 0.)).x, \n    Dist(pt-vec3( 0.,delta, 0.)).x, \n    Dist(pt-vec3( 0., 0.,delta)).x );\n  return normalize( norm );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  xTime = min( iTime, float(iFrame) / 10. );\n  irnd = 0.;\n  Rndm();\n // fragCoord.x += fract(mod(iTime,iFrameRate))-.5;\n // fragCoord.y += fract(mod(iTime,iFrameRate))-.5;\n\n  vec2 uv = (fragCoord.xy - iResolution.xy/2.) / min(iResolution.x,iResolution.y);\n    \n  //uv = rot2d( uv, iTime/4.);\n\n  vec3 cam = vec3( 0.+sin(iTime*.45)*WALLS*.0, 0.+cos(iTime*.15)*0., -8.+sin(iTime*.3)*0.);\n  //vec3 cam = vec3( 1.*cos(iTime), 1.*sin(iTime), -6.+sin(iTime*.33) );\n  vec3 camdir = normalize( vec3( uv.x, uv.y, 1. ) );\n\n  light = vec3( WALLS*.9, WALLS*.6, -4. );\n\n  vec4 hit = March( cam, camdir );\n  int obj = int(hit.w);\n  \n  vec3 dir = normalize( light - hit.xyz );\n  float difu = .7;\n\n  vec4 shadow = obj <= -50 && abs(uv.x) < .7 ? March( hit.xyz+dir*.01, dir ) : vec4(100.);\n  if ( shadow.w == 100. ) // light is not blocked\n  {\n    vec3 norm = Normal(hit.xyz);\n    difu = clamp( pow( dot( norm, dir ), .25 ), difu, 1. );\n  }\n  \n  vec3 col = vec3(1.);\n\n  if ( obj == 90 ) // failed to find object\n    col = vec3(.9,.1,.1);\n  else\n  if ( obj != 100 ) // not light, etc\n  { \n    if ( obj >= 1000 )\n      col = clr(float(obj)*.77); // balls\n    else\n      col = vec3( .3, .9, .3 ); // walls\n    col *= difu;\n    col = col + ( vec3(pow2(difu,5)) - col ) * .5;\n  } // not light, etc\n\n  fragColor = vec4( col, 1. );\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat rnd3(float l,float h,float seed) {\n  return mod(seed*9.2+.5,12.33)*(h-l)/(12.33)+l;\n}\n\n#define PI (3.14159265)\n#define TAU (PI*2.)\n#define PI2 (PI*2.)\n//#define FS float(44100)\n#define FS iSampleRate\n\nfloat noise(int samp) {\n  int a = (samp * 123570) ^ (samp * 1487200);\n  a ^= a >> 7;\n  a ^= a >> 6;\n  a ^= a >> 5;\n  a ^= a >> 4;\n  a ^= a >> 3;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return float( a & 65535 ) / 32768. - 1.;\n}\n\n#define SIN(X) sin(mod(X,PI2))\n#define SINC(x) (SIN(x)/(x))\n\n#define Fs int(iSampleRate)\n\nvec2 sss(int samp)\n{\n  float time = float( samp % (Fs*16) ) / iSampleRate;\n  float left =0., right=0.;\n  float vv;\n#define VOL(K) clamp(sin(TAU/K*time),0.,1.)\n#define PAT(PP,TIM) float( ( (PP) >> int(fract(TIM)*16.) ) & 1 )\n#define BONG(F1,F2,FM,SPD,VOL) \\\n     ( vv = 1. - fract(time*SPD), \\\n     sin( TAU * F1 * time + sin( TAU * F2 * time ) * vv * FM ) * vv * VOL )\n#define BING(F1,F2,FM,SPD,VOL) \\\n     ( vv = fract(time*SPD), \\\n     sin( TAU * F1 * time + sin( TAU * F2 * time ) * vv * FM ) * vv * VOL )\n#define TWING(F1,DST,SPD,VOL) \\\n     ( vv = 1.-fract(time*SPD), \\\n     clamp( sin( TAU * F1 * time ) + DST, -1., vv ) * vv * VOL )\n#define RAND(SEED,L,H) (fract((SEED)*1.121314)*((H)-(L))+(L) )\n\n  right += BONG(55.,330.,10.,.5,.2) * VOL(6.);\n  left += BONG(440.,330.,20.,1.,.2) * PAT(0x1131,time);\n  right += BING(220.,550.,10.,2.,.2) * VOL(5.);\n  left += BING(330.,440.,2.,12.,.2) * VOL(7.);\n\n  left += BING(330.,660.,20.,11.,.2) * VOL(9.);\n  right += BONG(55.,550.,10.,9.,.2) * VOL(5.);\n  left += BONG(110.,330.,2.,8.,.2) * VOL(4.);\n  right += BONG(175.,650.,10.,5.,.2) * VOL(3.);\n\n  left += noise(samp) * PAT(0xAA33,time) * .4 * VOL(16.);;\n  right += noise(samp/32)*2. * PAT(0x010A,time) * .4 * VOL(16.);;\n  left += TWING(440.*4./5.*(1.+SINC(TAU*8.*time)),.2,1.,.4) * VOL(3.);\n // right += sin(TAU*time*55.*int(RAND(float(int(time*4.)),1.,40.));\n  right += sin(TAU*time*55.*float(int(1.+mod(time*32.,32.)))) * .2 * VOL(5.);\n  \n  return vec2(left,right);\n\n}\n\n\nvec2 mainSound( int samp, float xtime ) {\n  vec2 rr = vec2(0.);\n  rr += sss(samp);\n  /*\n  rr += sss(samp-Fs/6) * .5;\n  rr += sss(samp-Fs/6*2) * .25;\n  rr += sss(samp-Fs/6*3) * .125;\n  */\n  //rr += sss(samp-Fs) * .3;\n  return rr;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}