{
    "Shader": {
        "info": {
            "date": "1611002296",
            "description": "Click on Galaxies to go close.\nWhen close, click on it to enter inside. \nWhen inside, click on stars or clouds to go close or click another galaxy to go close to it.\nIf your computer is good enought you could try WITH_SUPERNOVA_REMNANT (by Duke)",
            "flags": 48,
            "hasliked": 0,
            "id": "ttGyDW",
            "likes": 13,
            "name": "click Star+Galaxy 1",
            "published": 3,
            "tags": [
                "interactive",
                "star",
                "space",
                "galaxy",
                "cosmos",
                "field",
                "supernova",
                "universe"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 1063
        },
        "renderpass": [
            {
                "code": "#define get(i)texture(iChannel0,vec2(i+.5,.5)/iChannelResolution[0].xy,-100.0)\n\n//abriceNeyret2 Black Body...  https://www.shadertoy.com/view/4tdGWM\nvec3 blackBody(float k\n){float T=(k*2.)*16000.\n ;vec3 c=vec3(1.,3.375,8.)/(exp((19e3*vec3(1.,1.5,2.)/T))- 1.)\n ;return c/max(c.r,max(c.g,c.b));}\n\n#define noiseTextureSize 256.\n\n// iq noise https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x\n){vec3 p=floor(x),f=fract(x)\n ;f*=f*(3.-f-f)\n ;vec2 uv=(p.xy+vec2(37.,17.)*p.z)+ f.xy\n ,rg=textureLod(iChannel1,(uv+.5)/noiseTextureSize,-100.).yx\n ;return mix(rg.x,rg.y,f.z);}\nfloat pn(vec3 x\n){vec3 p=floor(x),f=fract(x)\n ;f*=f*(3.-f-f)\n ;vec2 uv=(p.xy+vec2(37.,17.)*p.z)+ f.xy\n ,rg=textureLod(iChannel1,(uv+.5)/noiseTextureSize,-100.).yx\n ;return 2.4*mix(rg.x,rg.y,f.z)-1.;}\nfloat bm(vec3 x\n){vec3 p=floor(x),f=fract(x)\n ;f*=f*(3.-f-f)\n ;vec2 uv=(p.xy+vec2(37.,17.)*p.z)+ f.xy\n ,rg=textureLod(iChannel1,(uv+ .5)/noiseTextureSize,-100.).yx\n ;return 1.-.82*mix(rg.x,rg.y,f.z);}\nfloat fpn(vec3 p){return pn(p*.06125)*.5+pn(p*.125)*.25+pn(p*.25)*.125 ;}//+pn(p*.5)*.625\nfloat fbm(const in vec3 p){return bm(p*.06125)*.5+bm(p*.125)*.25+bm(p*.25)*.125+bm(p*.4)*.2;}\nfloat smoothNoise(in vec3 q\n){const mat3 msun=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64)\n ;float f=.5000*noise(q);q=msun*q*2.01\n ;f+=.2500*noise(q);q=msun*q*2.02\n ;f+=.1250*noise(q);q=msun*q*2.03\n ;f+=.0625*noise(q)\n ;return f;}\n\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\nfloat SpiralNoiseC(vec3 p,vec4 id\n){const float m=20.,n=inversesqrt(1.+m*m)\n ;float iter=2.,r=2.-id.x\n ;for (int i=0;i<SPIRAL_NOISE_ITER;i++\n ){r+=-abs(sin(p.y*iter)+ cos(p.x*iter))/iter\n  ;p.xy+=vec2(p.y,-p.x)*m;p.xy*=n\n  ;p.xz+=vec2(p.z,-p.x)*m;p.xz*=n\n  ;iter*=id.y+.733733;}return r;}\n\nfloat mapIntergalacticCloud(vec3 p,vec4 id\n){float k=2.*id.w+.1;// p/=k\n ;return k*(.5+SpiralNoiseC(p.zxy*.4132+333.,id)*3.+pn(p*8.5)*.12);}\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\n//Intersection functions (mainly iq)\n//return bool and 2 intersection distances\nbool traceSphere(v22 r,out float a,out float b//ray,near,far\n){float c=dot(r.b,r.a);b=c*c-dot(r.a,r.a)+8.\n ;if(b<0.0)return false\n ;b=sqrt(b);a=-c-b;b-=c;return b>0.;}\n//return bool,farIntersection and [edge]\nbool traceSphere(v22 r,float s,out vec2 v // b,out float e\n){v.x=dot(r.b,-r.a);v.y=v.x*v.x-dot(r.a,r.a)+s*s\n ;if(v.y<0.)return false\n ;v.y=sqrt(v.x);v.x=v.x-v.y;return v.x>0.;}\n \nfloat SpiralNoiseC2(vec3 p\n){const float m=.9;// size of perpendicular vector\n ;float n=inversesqrt(1.+m*m)\n ;float r=0.,iter=2.\n ;for (int i=0;i<8;i++\n ){r+=-abs(sin(p.y*iter)+ cos(p.x*iter))/ iter //abs is optional for rigged look\n  ;p.xy+=vec2(p.y,-p.x)*m;p.xy*=n\n  ;p.xz+=vec2(p.z,-p.x)*m;p.xz*=n\n  ;iter*=1.733733;}return r;}\nfloat length2(vec2 p){return sqrt(p.x*p.x+p.y*p.y);}\nfloat length8(vec2 p){p=p*p;p=p*p;p=p*p;return pow(p.x+p.y,.125);}\nfloat Disk(vec3 p,vec3 t\n){vec2 q=vec2(length2(p.xy)-t.x,p.z*0.5)\n ;return max(length8(q)-t.y,abs(p.z)- t.z);}\nfloat mapSupernovaRemnant(vec3 p\n){p*=2.\n ;float noi=Disk(p.xzy,vec3(2.0,1.8,1.25))+fbm(p*90.)+SpiralNoiseC2(p.zxy*0.5123+100.0)*3.\n ;return abs(noi*.5)+.07;}\n#endif // WITH_SUPERNOVA_REMNANT\n\nbool cylinder(vec3 ro,vec3 rd,float r,float h,out float tn,out float tf\n){float a=dot(rd.xy,rd.xy),b=dot(ro.xy,rd.xy)\n ,d=b*b- a*(dot(ro.xy,ro.xy)- r*r)\n ;if(d<0.)return false\n ;d=sqrt(d)\n ;tn=(-b- d)/a;tf=(-b+d)/a\n ;a=min(tf,tn);tf=max(tf,tn);tn=a// order roots\n ;a=ro.z+tn*rd.z\n ;b=ro.z+tf*rd.z\n ;vec2 zcap=h*vec2(.5,-.5),cap=(zcap- ro.z)/ rd.z\n ;tn=a<zcap.y?cap.y : a>zcap.x?cap.x : tn\n ;tf=b<zcap.y?cap.y : b>zcap.x?cap.x : tf\n ;return tf>0. && tf>tn;}\n\n//Awesome star by Foxes: https://www.shadertoy.com/view/4lfSzS\nfloat noise4q(vec4 x\n){vec4 n3=vec4(0,.25,.5,.75)\n ;vec4 p2=floor(x.wwww+n3)\n ;vec4 b=floor(x.xxxx+n3)+ floor(x.yyyy+n3)*157.+floor(x.zzzz+n3)*113.\n ;vec4 p1=b+fract(p2*.00390625)*vec4(164352.,-164352.,163840.,-163840.)\n ;p2=b+fract((p2+1.0)*.00390625)*vec4(164352.,-164352.,163840.,-163840.)\n ;vec4 f1=fract(x.xxxx+n3),f2=fract(x.yyyy+n3)\n ;f1*=f1*(3.0-f1-f1)\n ;f2*=f2*(3.0-f2-f2)\n ;vec4 n1=vec4(0,1.,157.,158.),n2=vec4(113.,114.,270.0,271.)\n ;f1=fract(x.zzzz+n3)\n ;f2=fract(x.wwww+n3)\n ;f1*=f1*(3.-2.*f1)\n ;f2*=f2*(3.-2.*f2)\n ;vec4 vs1=mix(mix(mix(h3(p1),h3(n1.yyyy+p1)    ,f1)\n          ,mix(h3(n1.zzzz+p1),h3(n1.wwww+p1)    ,f1),f2)\n          ,mix(mix(h3(n2.xxxx+p1),h3(n2.yyyy+p1),f1)\n          ,mix(h3(n2.zzzz+p1),h3(n2.wwww+p1)    ,f1),f2),f1)\n ;vec4 vs3=mix(mix(mix(h3(p2),h3(n1.yyyy+p2)    ,f1)\n          ,mix(h3(n1.zzzz+p2),h3(n1.wwww+p2)    ,f1),f2)\n          ,mix(mix(h3(n2.xxxx+p2),h3(n2.yyyy+p2),f1)\n          ,mix(h3(n2.zzzz+p2),h3(n2.wwww+p2)    ,f1),f2),f1)\n ;vs1=mix(vs1,vs3,f2)\n ;float r=dot(vs1,vec4(.25))\n ;return r*r*(3.-r-r);}\n\n// rays of a star\nfloat ringRayNoise(v22 r,float s,float size,float anim\n){float b=dot(r.b,r.a)\n ;vec3 pr=r.b*b-r.a\n ;float c=length(pr)\n ,m=max(0.,(1.-size*abs(s-c)))\n ;pr=pr/c\n ;float n=.4,ns=1.,nd=noise4q(vec4(pr*1.0,-anim+c))*2.\n ;if (c>s\n ){n=noise4q(vec4(pr*10.0,-anim+c))\n  ;ns=noise4q(vec4(pr*50.0,-anim*2.5+ c+c))*2.;}\n ;return m*m*(m*m+n*n*nd*nd*ns);}\n\n//Sun Lava effect\n\nvec3 getSunColor(vec3 p,vec4 id,float time\n){float lava=smoothNoise((p+vec3(time*.03))*50.*(.5+id.z))\n ;return blackBody(.02+3.*clamp(id.x*id.x,.05,1.)*(1.- sqrt(lava)));}\n\nvec4 renderSun(v22 r,in vec4 i,in float t//ray,id,time\n){r.a*=2.\n ;// Rotate view to integrate sun rotation \n ;// R(ro.zx,1.6-t*.5*i.w)\n ;// R(rd.zx,1.6-t*.5*i.w)\n ;vec4 c=vec4(0)\n ;if(traceSphere(r,1.,c.xy))c=vec4(getSunColor(r.a+r.b*c.x,i,t),smoothstep(0.,.2,c.y));\n ;r.a.x=ringRayNoise(r,1.0,5.-4.*i.y,t)\n ;c.a=max(c.a,clamp(r.a.x,0.,.98))\n ;c.rgb+=blackBody(i.x)*r.a.x\n ;c.rgb*=1.-.03*cos(5.*t+2.*hash(t))// twinkle\n ;return sat(c);}\n\n// Supernova remnant by Duke [https://www.shadertoy.com/view/MdKXzc]\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\nvec3 computeColorSR(float d,float r//density,radius\n){return mix(vec3(1.,.9,.8),vec3(.4,.15,.1),d)\n *mix(7.*vec3(.8,1.,1.),1.5*vec3(.48,0.53,.5),min((r+.5)/.9,1.15));}\n\nvec4 renderSupernova(v22 r\n){vec4 a=vec4(0.)//acc return\n ;float m=0.,n=0.\n ;if(traceSphere(r,m,n)\n ){float t=max(m,0.)+.01*hash(r.b)//calculate once\n  ;r.a*=3.\n  ;m=0.//acc conditional\n  ;for(int i=0;i<64;i++\n  ){if (m>.9 || a.w>.99 || t>n)break\n   ;vec3 pos=r.a+r.b*t\n   ;float d=mapSupernovaRemnant(pos)\n   ;float lDist=max(length(pos),.001)\n   ;a+=vec4(.67,.75,1.,1.)/(lDist*lDist*10.)*.0125// star \n   ;a+=vec4(1.,.5,.25,.6)/exp(lDist*lDist*lDist*.08)*.033// bloom\n   ;const float h=.1\n   ;if(d<h\n   ){m+=(1.-m)*(h-d)+.005\n    ;vec4 c=vec4(computeColorSR(m,lDist),m*.2)\n    ;a.rgb+=a.w*a.rgb*.2;c.rgb*=c.a;a+=c*(1.- a.w);}\n   ;m+=.014\n   ;// trying to optimize step size near the camera and near the light source\n   ;t+=max(d*.1*max(min(lDist,length(r.a)),1.0),0.01);}\n  ;//a*=1./exp(l*.2)*.6; //scatter\n  ;a=sat(a)\n  ;a.xyz*=a.xyz*(3.-a.xyz-a.xyz);}return a;}\n#endif\n\n//Galaxy\n\n//p,1/thickness,blurAmount,blurStyle\nfloat spiralArm(vec3 p,float t,float a,float s\n){float r=length(p.xz)\n ,l=log(r)\n ,d=(.5/2.- abs(fract(.5*(atan(p.x,p.z)-l*4.)/pi)-.5))*2.*pi*r*(1.-l)*t\n ;return sqrt(d*d+10.*p.y*p.y*t)-(.1-.25*r)*r*.2\n -a*mix(fpn(8.*vec3(r*43.,40.*d,24.*p.y)),fpn(p*400.),s)// Perturb\n ;}\n\nvoid galaxyTransForm(inout vec3 o,vec4 i\n){R(o.yz,(i.y-.5))\n ;// R(o.xy,.25*i.x*iTime);\n ;}\n\nfloat mapGalaxy(vec3 p,vec4 id\n){float t=.2/(1.+id.x)\n ;float d1=spiralArm(p.xzy*.2,t,.2+.3*id.y,id.z)\n #ifdef WITH_DOUBLE_GALAXY\n ;if(id.z<.25\n ){float d2=spiralArm(vec3(-p.y,p.z,p.x)*.205,t,.2+.3*id.y,id.z)\n  ;return min(d2,d1);}\n #endif \n ;return d1;}\n\nvec3 computeColor(float d,vec3 u//density,uv\n){u.x=length(u);return mix(vec3(.25,.22,.2),vec3(.1,.0375,.025),d)\n *mix(vec3(4.8,6.,6.), vec3(.96,1.06,1.),min((u.x+.5)*.5,1.15));}\n\nvec4 renderGalaxy(v22 r,in vec4 id,in bool fast\n){vec4 a=vec4(0)\n ;float min_dist=0.,max_dist=100.\n ;galaxyTransForm(r.a,id)\n ;galaxyTransForm(r.b,id)\n ;if(cylinder(r.a,r.b,3.,3.5,min_dist,max_dist)\n ){float b=0.//acc\n  ,l=max(min_dist,0.)+ .2*hash(r.b+iTime)//acc raylength\n  ;vec4 n,m//changes wiothin loop (composite vector)\n  ;for (int i=0;i<48;i++ //raymarch\n  ){if((fast&&i>20)|| b>.9 || a.w>0.99 || l>max_dist)break\n   ;vec3 u=r.a+r.b*l\n   ;float d=max(abs(mapGalaxy(3.5*u,id))+.05,.005)\n   ;const float h=.1\n   ;if(d<h\n   ){float l=h-d\n    ;l+=sat((l-mapGalaxy(u*3.5-.2*normalize(u),id))*2.5)\n    ;b+=(1.-b)*l+.005\n    ;vec4 c=vec4(computeColor(b,u),b*.25);c.rgb*=c.a;a+=c*(1.- a.w);}\n   ;b+=.014\n   ;n.xyz=u*.25\n   ;m.xyz=u*.05\n   ;m.z*=2.5\n   ;n.w=max(length(n.xyz),.0001)//max(length(n.xyz),0.001)\n   ;m.w=max(length(m.xyz),.0001)\n   ;vec3 lightColor=(1.-smoothstep(3.,4.5,n.w*n.w))\n   *mix(.07*vec3(1.,.5,.25)/n.w,.008*vec3(1.,1.7,2.)/m.w,smoothstep(.2,.7,n.w));// star in center\n   ;a.rgb+=lightColor/(n.w*20.);//bloom\n   ;d=max(d,.04)\n   ;l+=max(d*.3,.02);}\n  ;a=sat(a)\n  ;a.xyz*=a.xyz*(3.-a.xyz-a.xyz);}return a;}\n\n// Adapted from Planet Shadertoy- Reinder Nijhoff: https://www.shadertoy.com/view/4tjGRh\nvec3 renderGalaxyField(v22 r,bool fast\n){//out_id=vec3(9)\n ;float dint //changes within loop within point()\n ,l=0.       //acc rayLength\n ;vec3 h     //hash sepends on (pos) within loop\n ,o=r.a      //acc origin\n ,f=floor(o) //acc tileId pos\n ,v=1./r.b   //calculate once\n ,s=sign(r.b)//calculate once\n ,dis=(f-o+.5+s*.5)*v\n ;vec4 a=vec4(0)\n ;for(int i=0;i<GALAXY_FIELD_VOXEL_STEPS_HD;i++\n ){if(!fast||i!=0\n  ){h=hash33(f)\n   ;vec3 O=f+cl1(h,GALAXY_RADIUS)\n   ;l=point(o,r.b,O,dint)\n   ;if(dint>0. && l<GALAXY_RADIUS\n   ){vec4 c=renderGalaxy(v22((o-O)/GALAXY_RADIUS*3.,r.b),vec4(h,.5),fast)\n    ;c.rgb*=smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(r.a-f))\n    ;a+=(1.-a.w)*c\n    ;if(a.w>.99)break;}}\n  ;vec3 m=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=m*s*v;f+=m*s;}\n ;if(!fast && a.w<.99\n ){for(int i=GALAXY_FIELD_VOXEL_STEPS_HD;i<GALAXY_FIELD_VOXEL_STEPS;i++\n  ){h=hash33(f)\n   ;l=point(o,r.b,f+cl1(h,GALAXY_RADIUS),dint)\n   ;if(dint>0.\n   ){vec4 c=vec4(.9,.9,.8,1.)*(1.-smoothstep(GALAXY_RADIUS*.25,GALAXY_RADIUS*.5,l))\n    ;c.rgb*=smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(r.a-f))\n    ;a+=(1.-a.w)*c\n    ;if(a.w>.99)break;}\n   ;vec3 m=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n   ;dis+=m*s*v;f+=m*s;}}\n ;return a.xyz;}\n\n// Adapted from Planet Shadertoy- Reinder Nijhoff:  https://www.shadertoy.com/view/4tjGRh\nvec4 renderStarField(v22 r,inout float O\n){float dint   //changes within loop within point()\n ,l=0.         //acc rayLength\n ;vec3 n=1./r.b//calculate once\n ,rs=sign(r.b) //calculate once\n ,o            //changes within loop (offset)\n ,h            //changes within loop (hash)\n ,f=floor(r.a) //changes within loop (tileId)\n ,v=(f-r.a+.5+rs*.5)*n//acc voxel coods\n ;vec4 c              //acc color intermediate\n ,a=vec4(0)           //acc color return\n ;for(int i=0;i<STAR_FIELD_VOXEL_STEPS;i++\n ){h=hash33(f)\n  ;o=cl1(h,STAR_RADIUS)\n  ;l=point(r.a,r.b,f+o,dint)\n  ;if(dint>0.\n  ){if(dint<2. && l<STAR_RADIUS\n   ){r.a=(r.a-f-o)/STAR_RADIUS,\n    #ifdef WITH_SUPERNOVA_REMNANT\n     c=h.x>.8?renderSupernova(v22(r.a,r.b)):\n    #endif\n     c=renderSun(v22(r.a,r.b),vec4(h,.5),iTime)\n    ;if (c.a>.99)O=dint\n   ;}else c=(vec4(blackBody(max(h.x-.1,.01)),1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,l)))\n   ;c.rgb*=smoothstep(float(STAR_FIELD_VOXEL_STEPS),.5,dint)\n   ;c.rgb*=c.a\n   ;a+=(1.-a.w)*c\n   ;if (a.w>.99)break;}\n  ;vec3 mm=step(v.xyz,v.yxy)* step(v.xyz,v.zzx)\n  ;v+=mm*rs*n\n  ;f+=mm*rs;}\n return a;}\n\n\n//intergalactic clouds\n\n#ifdef WITH_INTERGALACTIC_CLOUDS\n\n\n// Based on \"Type 2 Supernova\" by Duke (https://www.shadertoy.com/view/lsyXDK)\nvec4 renderIntergalacticClouds(v22 r,float m\n){m=min(m,float(STAR_FIELD_VOXEL_STEPS)) //calculated once\n ;vec4 a=vec4(0),id=vec4(.5,.4,.16,.7)         //loop var\n ;vec3 u              //loop var\n ;float e=0.          //loop var       , edge color\n ,o=.05+.25*id.z      //calculated once, outer edge?\n ,l=hash(hash(r.b))*.1//calculated once, hashed rayLength\n ,b=smoothstep(m,0.,l)//calculated once\n ;for(int i=0;i<100;i++\n ){if(e>.9 || a.w>.99 || l>m)break\n  ;u=r.a+l*r.b\n  ;float d=abs(mapIntergalacticCloud(u,id))+.07//depends on var u\n  ,sp=4.5//quickly discarded scalar constant\n  ;sp=max(length(mod(u+sp,sp*2.)-sp),.001)\n  ;u.x=pn(.05*u)\n  ;vec3 c=mix(hsv2rgb(u.x,.5,.6),hsv2rgb(u.x+.3,.5,.6),smoothstep(2.*id.x*.5,2.*id.x*2.,sp))\n  ;a.rgb+=b*c/exp(sp*sp*sp*.08)/30.\n  ;if (d<o//color edges\n  ){e+=(1.-e)*(o-d)+.005\n   ;a.rgb+=a.w*a.rgb*.25/sp//emmissive\n   ;a+=(1.-a.w)*.02*e*b; }// uniform scale density+alpha blend in contribution \n  ;e+=.015\n  ;l+=max(d*.08*max(min(sp,d),2.),.01);}// trying to optimize step size\n ;a=sat(a)\n ;a.xyz*=a.xyz*(3.-a.xyz-a.xyz);return a;}\n\n#endif \n\n// Coordinate system conversions\nbool inGalaxy(vec3 u){vec3 f=floor(u)\n ;return length(u-f-cl1(hash33(f),GALAXY_RADIUS))<GALAXY_RADIUS;}\n\nv22 getCam(vec2 p\n){vec3 w=get(Bc1).xyz//is normalized on set()\n ,u=normalize(cross(w,normalize(vec3(.1*cos(.1*iTime),.3*cos(.1*iTime),1.))))\n ;return v22(get(Bc0).xyz,normalize(-p.x*u+p.y*normalize(cross(u,w))+2.*w) );}\n\nvoid mainImage(out vec4 o,in vec2 u\n){o.xyz=vec3(0)\n ;u=u/iResolution.xy\n ;u=u*2.-1.\n ;u.x*=iResolution.x/iResolution.y\n ;v22 r=getCam(u)\n ;vec3 galaxyId,galaxyPosU\n ;vec4 s=vec4(0)//star color\n ;float coo=get(Bvv).z\n ;coo=coo>2.5?IN_SOLAR_SYSTEM : coo>1.5?IN_GALAXY :  IN_UNIVERSE\n ;bool isU=coo==IN_UNIVERSE,isG=coo==IN_GALAXY\n ;vec3 galaxy_pos=get(Bg0).xyz\n ;if(inGalaxy(isU?r.a : g2u(galaxy_pos,r.a))\n ){vec3 roG=isU?u2g(galaxy_pos,r.a): r.a\n  ;float d=9999.\n  ;s=renderStarField(v22(roG,r.b),d)\n  #ifdef WITH_INTERGALACTIC_CLOUDS\n  ;vec4 c=renderIntergalacticClouds(v22(roG,r.b),d)\n  ;if(s.a!=0.)s=(1.-c.a)*sqrt(s)*s.a\n  ;s+=c\n  #endif \n  ;}\n ;if(isG)r.a=g2u(galaxy_pos,r.a)\n ;vec3 colGalaxy=renderGalaxyField(r,isG)\n ;s.rgb+=colGalaxy*(1.-s.a)\n ;o.xyz=s.rgb\n ;// float digit=PrintValue(fragCoord,iResolution.xy*vec2(.0,.7),vec2(20.),galaxy_pos.x,8.,10.);\n ;// digit+=PrintValue(fragCoord,iResolution.xy*vec2(.0,.6),vec2(20.),galaxy_pos.y,8.,10.);\n ;// digit+=PrintValue(fragCoord,iResolution.xy*vec2(.0,.5),vec2(20.),galaxy_pos.z,8.,10.);\n ;// o.xyz=mix(o.xyz,vec3(1,0,0),digit)\n ;if(isU)o.xyz+=vec3(0.03,0.,.1);}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI=acos(-1.);\nconst float DEG_TO_RAD=(PI/180.);\nconst float MAX=10000.;\n\nfloat key(int a){return texture(iChannel2,vec2((.5+float(a))/256.,0.25)).x;}\n\nfloat distanceRayPoint(vec3 ro,vec3 rd,vec3 p,out float h\n){h=dot(p-ro,rd);return length(p-ro-rd*h);}\n\n// Toujours en coordonnes Univers\nbool renderGalaxyField(vec3 roU,vec3 rd,out vec3 out_posU,out vec3 out_id\n){float d,dint\n ;vec3 ros=roU+rd*d\n ,pos=floor(ros)\n ,ri=1./rd\n ,rs=sign(rd)\n ,dis=(pos-ros+0.5+rs*0.5)* ri\n ,offset\n ,id\n ,galaxyro\n ;float pitch=10./iResolution.x\n ;for(int i=0;i<GALAXY_FIELD_VOXEL_STEPS;i++\n ){id=hash33(pos)\n  ;offset=clamp(id,GALAXY_RADIUS,1.-GALAXY_RADIUS)\n  ;d=distanceRayPoint(ros,rd,pos+offset,dint)\n  ;if(dint>0. && d<GALAXY_RADIUS*.5+dint*pitch\n  ){galaxyro=pos+offset\n   ;out_posU=galaxyro\n   ;out_id=id\n   ;return true;} \n ;vec3 mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n ;dis+=mm*rs*ri\n ;pos+=mm*rs;}return false;}\n\n\nbool renderStarField(vec3 galaxyId,in vec3 roG,in vec3 rd,out vec3 out_posG,out vec3 out_id\n){out_id=vec3(9)\n ;float d,dint\n ;vec3 ros=roG+rd*d\n ,pos=floor(ros)\n ,ri=1./rd\n ,rs=sign(rd)\n ,dis=(pos-ros+0.5+rs*0.5)* ri\n ,mm\n ,offset=vec3(0.),id,galaxyro\n ;float pitch=10./iResolution.x\n ;for(int i=0;i<STAR_FIELD_VOXEL_STEPS;i++\n ){id=hash33(pos)\n  ;offset=clamp(id,STAR_RADIUS,1.-STAR_RADIUS)\n  ;d=distanceRayPoint(ros,rd,pos+offset,dint)\n  ;if(dint>0.&&d<STAR_RADIUS*.5+dint*pitch\n  ){out_posG=pos+offset\n   ;out_id=id\n   ;return true;}\n  ;mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=mm*rs*ri\n  ;pos+=mm*rs;}return false;}\n\n// from iq shader Brick: https://www.shadertoy.com/view/MddGzf\nfloat inside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return-max(d.x,d.y);}\nvec4 set(vec2 r,vec4 v,vec4 o,vec2 u){if(inside(u,r)> 0.)o=v        ;return o;}\nvec4 set(vec2 r,vec3 v,vec4 o,vec2 u){if(inside(u,r)> 0.)o=vec4(v,0);return o;}\n\n\n#define CONF(id) texture(iChannel0,vec2(id+.5,.5)/ iChannelResolution[0].xy,-100.0).xyz\n#define CONF4(id)texture(iChannel0,vec2(id+.5,.5)/ iChannelResolution[0].xy,-100.0);\n\nbool inGal(in vec3 roU,out vec3 out_GalaxyId,out vec3 out_GalaxyPosU\n){vec3 pos=floor(roU)\n ;out_GalaxyId=hash33(pos)\n ;vec3 offset=clamp(out_GalaxyId,GALAXY_RADIUS,1.-GALAXY_RADIUS)\n ;out_GalaxyPosU=(pos+offset)\n ;return length(roU- out_GalaxyPosU)<GALAXY_RADIUS;}\n\n#define R(p,a)p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nvec3 R2(vec3 a,float b){R(a.yz,b);R(a.xy,b);return a;}\n\nvec3 getRd(vec3 ww//forward\n){vec2 m=iM.xy/iR.xy*2.-1.;m.x*=iR.x/iR.y\n ;ww=normalize(ww)\n ;vec3 uu=normalize(cross(ww,normalize(vec3(.1*cos(.1*iTime),.3*cos(.1*iTime),1.))))\n ;vec3 vv=normalize(cross(uu,ww))\n ;vec3 rd=normalize(-m.x*uu+m.y*vv+2.*ww)\n ;return rd;}\n\nvec4 init(vec2 u//initialization\n){vec3 c1=normalize(vec3(1.,0.,0.))\n ;vec3 pos=floor(vec3(10.))\n ;vec3 id=hash33(pos)\n ,offset=clamp(id,GALAXY_RADIUS,1.-GALAXY_RADIUS)\n ;vec3 a=pos+offset-.03*c1\n ;vec3 b=.03*c1\n ;vec3 e=a+b;b=R2(b,1.);a=e-b//offset rotation\n ;b=normalize(b)\n ;vec4 c=vec4(0)\n ;c=set(vec2(Bvv,0),vec4(STATIONARY,GALAXY,IN_UNIVERSE,iTime),c,u)\n ;c=set(vec2(Bg0,0),vec3(0),c,u)\n ;c=set(vec2(Bg1,0),vec3(1),c,u)\n ;c=set(vec2(Bc0,0),a,c,u)\n ;c=set(vec2(Bf0,0),a,c,u)\n ;c=set(vec2(Bt0,0),a,c,u)\n ;c=set(vec2(Bc1,0),b,c,u)\n ;c=set(vec2(Bf1,0),b,c,u)\n ;c=set(vec2(Bt1,0),b,c,u)\n ;return c;}\n\n//Each set() in of init() gets its own [**_() setter function] (for runtime case)\n//[**_() functions] calculate the color of ONE specific state-pixel.\n//they all are quite similar in their branch conditions, but converge onto one unique variable.\n//there is still lots to optimize here (planning subroutines)\n//\n//m() contains a condition-tree for **_() functions \n//**_() functions are best first seen as [minimized] functions\n//and then skip to the m() below them, for a quick overview\n//\n//the parent shader:   https://www.shadertoy.com/view/3tGyW1\n//does NOT split up the branches by their convergences (its a mess)\n\nvec4 c1_(vec2 u        //calc camera target\n){vec3 ww//rayOrigin,CamForward\n ;vec4 v=CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;ww=normalize(R2(mov,.05*s*t));\n  ;}else{ww=CONF(Bc1);R(ww.yz,.002);}}\n ;vec4 c=vec4(0)\n ;return set(vec2(Bc1,0),ww,vec4(0),u);}\n\nvec4 c0_(vec2 u        //calc camera origin\n){vec3 c0=CONF(Bc0)\n ;vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if(v.y!=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ro=CONF(Bt0)+mov-R2(mov,.05*s*t)\n  ;}else{ro=c0+.005*CONF(Bc1);}}\n ;vec3 galaxyId,gpu \n ;bool inGal=inGal(isU ? ro : g2u(CONF(Bg0),ro),galaxyId,gpu)\n ;c0=ro\n ;if(v.x!=STATIONARY\n ){if(inGal){if(isU)                             c0=u2g(gpu,c0)\n ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)c0=g2u(gpu,c0);}}\n ;return set(vec2(Bc0,0),c0,vec4(0.),u);}\n\nvec4 f1_(vec2 u        //calc from-direction\n){vec3 f1=CONF(Bf1)\n ;vec3 ww//rayOrigin,CamForward\n ;vec4 v=CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ww=mix(f1,CONF(Bt1),s)\n ;else{\n  ;if(v.y!=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ww=normalize(R2(mov,.05*s*t));\n  ;}else{ww=CONF(Bc1);R(ww.yz,.002);}}\n ;if (v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){f1=ww;}}\n ;return set(vec2(Bf1,0),f1,vec4(0.),u);}\n\nvec4 f0_(vec2 u        //calc from-origin\n){vec3 f0=CONF(Bf0)\n ;vec3 ro//rayOrigin\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ro=mix(f0,CONF(Bt0),s)\n ;else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ro=CONF(Bt0)+mov-R2(mov,.05*s*t)\n  ;}else ro=CONF(Bc0)+.005*CONF(Bc1);}\n ;\n ;vec3 galaxyId,gpu\n ;bool inGal=inGal(isU ? ro : g2u(CONF(Bg0),ro),galaxyId,gpu)\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){f0=ro;}\n ;}else{\n  if(inGal){if(isU                                )f0=u2g(gpu,f0)\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)f0=g2u(gpu,f0);}}\n ;return set(vec2(Bf0,0),f0,vec4(0.),u)\n ;}\n\nvec4 t1_(vec2 u        //calc target-direction\n){vec3 t1=CONF(Bt1),ww//t1,CamForward\n ;vec4 v=CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ww=mix(CONF(Bf1),t1,s)\n ;else{\n  ;if(v.y!=NONE\n  ){vec3 mov=t1*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ww=normalize(R2(mov,.05*s*t));\n  ;}else{ww=CONF(Bc1).xyz;R(ww.yz,.002);}}\n ;vec3 rd=getRd(ww)\n ;if (v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){t1=rd;}}\n ;return set(vec2(Bt1,0),t1,vec4(0.),u);}\n\nvec4 t0_(vec2 u,vec3 g0//calc target-origin\n){vec3 t0=CONF(Bt0)\n ;vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),t0,s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if(v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=t0+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{ww=CONF(Bc1);ro=CONF(Bc0)+.005*ww;R(ww.yz,.002);}};vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu,tpu,tpg,tid\n ;bool inGal=inGal(isU?ro:g2u(g0,ro),galaxyId,gpu)\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG?g2u(g0,ro):ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG&&length(roU- tpu)> 3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG&&!isHitGalaxy\n ){vec3 roG=ro\n  ;isHitStar=renderStarField(galaxyId,roG,rd,tpg,tid )\n  ;if(isHitStar)tpu=g2u(g0,tpg);}\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){vec3 g1=CONF(Bg1)\n    ;t0=isHitGalaxy ? (isU ? tpu-(g1==vec3(1)||tpu==g1?0.:.03)*rd : tpg-.03*rd*kU2G): isHitStar ? tpg-.03*rd : isHitPlanet ? tpg-.06*rd/PLANET_FIELD_SCALE :ro+3.*rd\n   ;}\n ;}else{\n  if(inGal){if(isU                                )t0=u2g(gpu,t0)\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)t0=g2u(gpu,t0)\n   ;}}\n ;return set(vec2(Bt0,0),t0,vec4(0.),u);}\n\nvec4 g1_(vec2 u,vec3 g0//calc galaxy-target\n){vec3 g1=CONF(Bg1)\n ;vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{\n   ;ww=CONF(Bc1)\n   ;ro=CONF(Bc0)+.005*ww\n   ;R(ww.yz,.002);}}\n ;vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu,tpu,tpg,tid\n ;bool inGal=inGal(isU ? ro : g2u(g0,ro),galaxyId,gpu)\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG ? g2u(g0,ro): ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG && length(roU- tpu)> 3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG && !isHitGalaxy\n ){vec3 roG=ro\n  ;isHitStar=renderStarField(galaxyId,roG,rd,tpg,tid)\n  ;if(isHitStar)tpu=g2u(g0,tpg);}\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){g1=isU ? tpu : tpg;}\n ;}else{\n  if(inGal){if(isU                                )g1=u2g(gpu,g1)\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)g1=g2u(gpu,g1)\n   ;}\n  ;}\n ;return set(vec2(Bg1,0),g1,vec4(0),u);} \n\nvec4 g0_(vec2 u,vec3 g0//calc galaxy-origin\n){vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if(v.y!=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{ww=CONF(Bc1);ro=CONF(Bc0)+.005*ww;R(ww.yz,.002);}}\n ;vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu,tpu,tpg,tid\n ;bool inGal=inGal(isU?ro:g2u(g0,ro),galaxyId,gpu)\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG?g2u(g0,ro):ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG&&length(roU-tpu)>3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG&&!isHitGalaxy\n ){if(renderStarField(galaxyId,ro,rd,tpg,tid))tpu=g2u(g0,tpg)\n ;}else{\n  if(inGal){if(isU                                )g0=gpu\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)g0=gpu;}}\n ;return set(vec2(Bg0,0),g0,vec4(0.),u);}\n\nvec4 vv_(vec2 u,vec3 g0//calc 4-states\n){vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{ww=CONF(Bc1);R(ww.yz,.002);}}\n ;\n ;vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu\n ;bool inGal=inGal(isU ? ro : g2u(g0,ro),galaxyId,gpu)\n ;vec3 tpu,tpg,tid\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG ? g2u(g0,ro): ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG && length(roU- tpu)> 3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG && !isHitGalaxy\n ){vec3 roG=ro\n  ;isHitStar=renderStarField(galaxyId,roG,rd,tpg,tid )\n  ;if(isHitStar)tpu=g2u(g0,tpg);}\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){v.x=MOVING\n   ;v.y=isHitGalaxy ? GALAXY : isHitStar ? STAR : isHitPlanet ? PLANET : NONE\n   ;v.w=iTime\n   ;}\n ;}else{\n  if(inGal){if(isU)v.z=IN_GALAXY\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)v.z=IN_UNIVERSE;}   \n  ;if(iTime- v.w>TRAVEL_DELAY+1.)v.xw=vec2(STATIONARY,iTime)\n  ;}\n ;return set(vec2(Bvv,0),v,vec4(0),u);}\n \nvec4 m(vec2 u //main function (return value simplifies code)\n){float v=floor(u.x)\n ;if(iFrame<10)return init(u)//init\n ;if(v==Bc1)return c1_(u)\n ;if(v==Bc0)return c0_(u) \n ;if(v==Bf1)return f1_(u) \n ;if(v==Bf0)return f0_(u) \n ;if(v==Bt1)return t1_(u)\n ;vec3 g0=CONF(Bg0)//read in many places in functions below\n ;if(v==Bt0)return t0_(u,g0)\n ;if(v==Bg1)return g1_(u,g0) \n ;if(v==Bg0)return g0_(u,g0)\n ;return vv_(u,g0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(u.y>0.5 || u.x>10.)discard\n ;c=m(u);}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Created by sebastien durand- 11/2016\n//License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//---Parents:\n//Reinder Nijhoff  Planet Shadertoy  : https://www.shadertoy.com/view/4tjGRh\n//Duke             Type 2 Supernova  : https://www.shadertoy.com/view/lsyXDK\n//Duke             Supernova remnant : https://www.shadertoy.com/view/MdKXzc\n//Foxes            Awesome star      : https://www.shadertoy.com/view/4lfSzS\n//FabriceNeyret2   Black Body        : https://www.shadertoy.com/view/4tdGWM\n//otaviogood       Alien Beacon      : https://www.shadertoy.com/view/ld2SzK\n//Dave_Hoskins     Hash without Sine : https://www.shadertoy.com/view/4djSRW\n//iq               Noise-value-3D    : https://www.shadertoy.com/view/4sfGzS\n//iq               Smooth HSV        : https://www.shadertoy.com/view/MsS3Wc\n\n\n/* ollj did\n- prefix semicolons\n- improved scopes\n- removed config{} struct (inefficient for a buffer to have every fragment load ALL fragments)\n*/\n\n/*\nto fix\ngo through bufferA and fix all scopes\nshorten the config struct and the get() et() logic\n*/\n\n/*\ndo add\nquaternion camera\nbetter hashes\nvolume marched galaxies\nrelativity\n*/\n\n#define iM iMouse\n#define iR iResolution\n\n//buffer addresses (because [dir] implies derivative, its [1])\n#define Bvv 0. //4 states (positional domains)\n#define Bc0 1. //camPos\n#define Bc1 2. //camDir\n#define Bg1 3. //galPos\n#define Bg0 4. //galDir\n#define Bf0 5. //tarPos\n#define Bt0 6. //tarDir\n#define Bf1 7. //froPos\n#define Bt1 8. //froDir\n//for animation, we do mix(froPos,tarPos,time)\n//for animation, we do mix(froDir,tarDir,time)\n\n// Time spend traveling to clicked point\n#define TRAVEL_DELAY 4.\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING 1.\n#define STATIONARY 2.\n\n#define NONE 0.\n#define GALAXY 1.\n#define STAR 2.\n#define PLANET 3.\n\n\n// in progress (incomplete defunct code)\n//#define WITH_PLANETS \n\n\n#define pi acos(-1.)\n#define sat(a) clamp(a,0.,1.)\n#define cl1(a,b) clamp(a,b,1.-(b))\n\nconst int GALAXY_FIELD_VOXEL_STEPS=10;// Unit=10 UA\nconst int GALAXY_FIELD_VOXEL_STEPS_HD=7;\nconst float GALAXY_FIELD_VOXEL_STEP_SIZE=250000.;// 2,500,000 AL\nconst float GALAXY_RADIUS=.015;// (% of 250000) 50,000 AL\nconst int STAR_FIELD_VOXEL_STEPS=13;\nconst float STAR_FIELD_VOXEL_STEP_SIZE=.5;// 5AL \nconst float STAR_RADIUS=.01;// 2e-8 in true life ! // (% of 5) 1e-8\nconst float PLANET_FIELD_SCALE=75.;\nconst int PLANET_FIELD_VOXEL_STEPS=10;\nconst float PLANET_FIELD_VOXEL_STEP_SIZE=.5;// 5AL \nconst float PLANET_RADIUS=.04;\nconst float kU2G=GALAXY_FIELD_VOXEL_STEP_SIZE/STAR_FIELD_VOXEL_STEP_SIZE;\nconst float kG2U=STAR_FIELD_VOXEL_STEP_SIZE/GALAXY_FIELD_VOXEL_STEP_SIZE;\n\n#define SPIRAL_NOISE_ITER 6\n\n\nconst vec3 SUN_COLOR=vec3(.3,.21,.165);\n\nfloat time;\n\n// Time spend traveling to clicked point\n#define TRAVEL_DELAY 4.\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING 1.\n#define STATIONARY 2.\n\n#define NONE 0.\n#define GALAXY 1.\n#define STAR 2.\n#define PLANET 3.\n\n#define bv 0.\n\n// Some stranges behaviours detected under \n// Ubunto- Firefox and \n// Manjaro linux- chromium- ati 280\n// => strange navigation,star disaper when clicked\n \n#define WITH_INTERGALACTIC_CLOUDS\n\n// in progress\n//#define WITH_PLANETS \n\n// If fast enougth\n#define WITH_SUPERNOVA_REMNANT\n//#define WITH_DOUBLE_GALAXY;\n\n\n#define R(p,a)p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nstruct v22{vec3 a,b;};\n\n\n// Hash without Sine by Dave_Hoskins [https://www.shadertoy.com/view/4djSRW]\n//----------------------------------------------------------------------------------------\n\n#define HASHSCALE3 vec3(.1031,.1030,.0973)\n#define HASHSCALE4 vec4(1031,.1030,.0973,.1099)\n#define HASHSCALE1 .1031\nfloat hash(float u\n){vec3 p=fract(vec3(u)* HASHSCALE1);p+=dot(p,p.yzx+19.19)\n ;return fract((p.x+p.y)*p.z);}\nfloat hash(vec2 u\n){vec3 p3=fract(vec3(u.xyx)*HASHSCALE1);p3+=dot(p3,p3.yzx+19.19);return fract((p3.x+p3.y)* p3.z);}\nfloat hash(vec3 u\n){u=fract(u*HASHSCALE1);u+=dot(u,u.yzx+19.19);return fract((u.x+u.y)*u.z);}\n\nvec3 hash33(vec3 u\n){u=fract(u*HASHSCALE3)\n ;u+=dot(u,u.yxz+19.19);return fract(vec3((u.x+u.y)*u.z,(u.x+u.z)*u.y,(u.y+u.z)*u.x));}\n\nvec4 h3(vec4 n){return fract(sin(n)*1399763.5453123);}\n\nvec4 h3(vec3 p\n){vec4 p4=fract(vec4(p.xyzx)*HASHSCALE4);p4+=dot(p4,p4.wzxy+19.19);\n return fract(vec4((p4.x+p4.y)*p4.z,(p4.x+p4.z)*p4.y,(p4.y+p4.z)*p4.w,(p4.z+p4.w)*p4.x));}\n\nfloat point(vec3 ro,vec3 rd,vec3 p,out float h\n){h=dot(p-ro,rd)\n ;return length(p-ro-rd*h);}\n\n// Adapted from iq:   https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(float x,float y,float z\n){return z+z*y*(clamp(abs(mod(x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-1.);}\n\n\nvec3 g2u(vec3 u,vec3 p){return p*kG2U+u;}//galaxyToUniverse\nvec3 u2g(vec3 u,vec3 p){return (p-u)*kU2G;}//universeToGalaxy\n\n\n\n/*\nfloat DigitBin(const int x )\n{\n return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const vec2 vStringCoords,const float fValue,const float fMaxDigits,const float fDecimalPlaces )\n{\n if ((vStringCoords.y<0.0)|| (vStringCoords.y >=1.0))return 0.0;\n float fLog10Value=log2(abs(fValue))/ log2(10.0);\n float fBiggestIndex=max(floor(fLog10Value),0.0);\n float fDigitIndex=fMaxDigits- floor(vStringCoords.x);\n float fCharBin=0.0;\n if(fDigitIndex>(-fDecimalPlaces- 1.01)){\n if(fDigitIndex>fBiggestIndex){\n if((fValue<0.0)&& (fDigitIndex<(fBiggestIndex+1.5)))fCharBin=1792.0;\n }else{ \n if(fDigitIndex==-1.0){\n if(fDecimalPlaces>0.0)fCharBin=2.0;\n }else{\n float fReducedRangeValue=fValue;\n if(fDigitIndex<0.0){ fReducedRangeValue=fract(fValue );fDigitIndex+=1.0;}\n float fDigitValue=(abs(fReducedRangeValue / (pow(10.0,fDigitIndex))));\n fCharBin=DigitBin(int(floor(mod(fDigitValue,10.0))));\n }\n }\n }\n return floor(mod((fCharBin / pow(2.0,floor(fract(vStringCoords.x)* 4.0)+ (floor(vStringCoords.y*5.0)* 4.0))),2.0));\n}\n// Original interface\n\nfloat PrintValue(const in vec2 fragCoord,const in vec2 vPixelCoords,const in vec2 vFontSize,const in float fValue,const in float fMaxDigits,const in float fDecimalPlaces)\n{\n vec2 vStringCharCoords=(fragCoord.xy- vPixelCoords)/ vFontSize;\n \n return PrintValue(vStringCharCoords,fValue,fMaxDigits,fDecimalPlaces );\n}\n*/\n\n#ifdef WITH_PLANETS\n\nbool renderPlanetField(in vec3 sunPos,in vec3 roG,in vec3 rd,out vec3 out_posG,out vec3 out_id\n){out_id=vec3(9)\n ;float scale=50.\n ;roG-=sunPos\n ;roG*=PLANET_FIELD_SCALE\n ;roG.z+=.5\n ;float rayon=3.\n ;float min_dist=0.,max_dist=100.\n ;vec4 col,sum=vec4(0)\n ;float pitch=10./iResolution.x\n ;float dint,d=max(0.,(length(roG)-rayon));//min_dist\n ;vec3 offset,id,ros=roG+rd*d,pos=floor(ros),ri=1./rd,rs=sign(rd)\n ,dis=(pos-ros+.5+rs*.5)* ri\n ;for(int i=0;i<PLANET_FIELD_VOXEL_STEPS;i++\n ){if(length(pos)<rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75\n  ){id=hash33(pos+sunPos)\n   ;offset=cl1(id,PLANET_RADIUS)\n   ;offset.z=.5\n   ;d=distanceRayPoint(ros,rd,pos+offset,dint)\n   ;if(dint>0. && d<PLANET_RADIUS+dint*pitch\n   ){vec3 pp=pos+offset\n    ;pp.z-=.5\n    ;out_posG=(pp/scale)+sunPos\n    ;out_id=id\n    ;return true;}}\n  ;vec3 mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=mm*rs*ri\n  ;pos+=mm*rs\n ;}return false;}\n\n#endif\n\n#ifdef WITH_PLANETS\n\nvec3 getPlanetColor(in vec3 p,vec4 id\n){float lava=smoothNoise(p*1.5*(5.*id.z))\n ;return blackBodyColor((.5+id.x)*(1.- pow(lava,2.*id.y)));}\n\nvec4 renderPlanet(in vec3 ro,in vec3 rd,in vec4 id,in vec3 lightDir,float dSun\n){vec4 color=vec4(0.)\n ;float r=1.\n ;float dist,edge\n ;if (intersectSphere(ro,rd,r,dist,edge)\n ){if (dist<dSun\n  ){vec3 pos=ro+rd*dist\n   ,nor=normalize(pos)\n   ;float a=smoothstep(0.,.8*r,edge)\n   ;vec3 oCol=getPlanetColor(pos,id)\n   ;vec3 norm=-normalize(pos)\n   ;float dif=sat(dot(lightDir,norm))\n   ;vec3 h=normalize(-rd+lightDir)\n   ;float spe=pow(sat(dot(h,norm)),4.)\n   ;oCol=dif*oCol\n   ;oCol+=dif*spe\n   ;color=vec4(oCol,1.);}}return sat(color);}\n\n// TODO ue 2D field ex: iq : https://www.shadertoy.com/view/4dSGW1\nvec4 renderPlanetField(in vec3 sunPos,in vec3 roG,in vec3 rd,inout float out_dStar,out vec3 out_id\n){out_id=vec3(9)\n ;roG-=sunPos\n ;roG*=PLANET_FIELD_SCALE\n ;roG.z+=.5\n ;float distSunDrawing=out_dStar*PLANET_FIELD_SCALE\n ;float rayon=3.\n ;float min_dist=0.,max_dist=100.\n ;vec4 col,sum=vec4(0)\n ;// if (cylinder(roG,rd,rayon,1.,min_dist,max_dist)){\n ;float dint,d=max(0.,(length(roG)-rayon));//min_dist\n ;vec3 offset,id,ros=roG+rd*d,pos=floor(ros),ri=1./rd,rs=sign(rd)\n ,dis=(pos-ros+.5+rs*.5)* ri\n ;for(int i=0;i<PLANET_FIELD_VOXEL_STEPS;i++\n ){if (length(pos)<rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75\n  ){id=hash33(pos+sunPos)\n   ;offset=cl1(id,PLANET_RADIUS)\n   ;offset.z=.5\n   ;col=renderPlanet((ros-(pos+offset))/PLANET_RADIUS,rd,vec4(id,.5),normalize((pos+offset)-ros),distSunDrawing)\n   ;out_id=id\n   ;if (col.a>.95)out_dStar=dint\n   ;col.rgb*=col.a\n   ;sum+=(1.-sum.a)*col\n   ;if(sum.a>.99)break;}\n  ;vec3 mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=mm*rs*ri\n  ;pos+=mm*rs;}return sum;}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}