{
    "Shader": {
        "info": {
            "date": "1501158653",
            "description": "pause time to diminish confusion.\n\nstretch1() utility:\n\nmouse.y folds space == extrude object-space's center of the object (for each tile center)\nmouse.x lerps between rounded corners and 90deg corners (and beyond)\ncenter position makes most sense.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsBBzV",
            "likes": 8,
            "name": "superprim extrude round polar",
            "published": 3,
            "tags": [
                "pacman",
                "normal",
                "symmetry",
                "rounding",
                "corner",
                "asteroids",
                "stretch",
                "extrude",
                "pmod",
                "superprim",
                "disymmetry",
                "dynamiceps",
                "bisymmetry"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1146
        },
        "renderpass": [
            {
                "code": "/*\nthere is a simple disymmetry in cylinder and torus, \nas in, they are basically /polar or carthesian) stretched 2d shapes.\nand the stretching can be done via stretch1()\nstretch1() folds a domain domain, stretching/extruding the DistanceField\nfDisc() should be stretchable to cylinder(), using stretch1()\nfDisc() and pacman() are 2d shapes, easily extruded or rounded.\n\n  return mix(round,sharp,2.*iMouse.x/iResolution.x);\n  ...lerps between 2 fDisc() and cylinder(), both extending on pacman()\n  ...but with different \"corner rounding\"\n\nI wanted to explore simple stretch1() extrusion of fDisc()\nI got sidetracked into a 3d \"superprim\" based on a 2d pacman shape.\nsidetracking results in messier code.\n\nthe pacman() code can be made much more symmetrical \n...with what i learned by making this shader.\n*/\n\n//time scaling\n#define time iTime*.5\n\n//maximum raymarching iterations\n#define rMaxIter 256.\n\n//maximum ray-marching distance from camera\n//if (marched further) it hits a \"weird cosmic microwave backkground\"\n#define rdMax 300.\n\n//content of tiles is rotated by tileID\n//has much more lipschitz discontinuity, due to modulo tesselation.\n#define tielsrotated\n\n//size of a tile (is a box, .y is smaller.)\n//tilesize>4. or else the content touches the tile border, getting cut by it.\n//larger tilesizes let you \"see further away\", seeing more diversity over distance.\n#define tilesize (((cos(time*2.-40.))*.5+.5)*4.+4.2)\n\n//rotate camera over time\n#define camrotate\n\n//field of view within a square part of the viewFrame; 1.=90deg,\n//is actually \"ideal distance of eyes to viewscreen, inverse ratio to screen height\"\n//if (screen is 0.5meter high && your head is 1 meter away from it)  #define fow (0.5/1.)\n#define fow .75\n\n//smarter raymarching, epsilon is a cubic function with distance and lastStelLength.\n//resulting in less overstepping and often better performance\n//but it sets the minimum barrier for low-quality-settings higher.\n#define dynamicEps\n\n//LipSchitsScale is only used if dynamicEps is DISABLED\n//lipshits_constant is abs() of first derivative of the distance field, projected on the ray.\n//if lipshits_constant>1., you likely overstep, raymarching becomes quantum unchertain, tunnels.\n//if lipshits_constant>2., you definitely overstep\n//lipshits_constant*=LipSchitsScale, sales steps down, you need more steps, for less overstepping\n//fract()mod() tesselation makes the distanceField c0_dscontinuous, \n//...therefore overstepping is much more likely.\n#define LipSchitsScale .25\n\n//eps is needed to calculate normals (and for raymarching without dynamicEps)...\n//epsilon for heuristics and gratients\n#define eps 0.00001\n\n/*\n//todo, replace line-segment subroutine of pacman code partially with sdf_line6n()\n//may require some \"new disymmetry\" knowledge.\n\n//i pledge for the Term \"disymmetry\"=\"gradient between the extremes; symmetry to asymmetry\"\n\n\n//return signed distance of point [p] to line [a]\n//where [a] is the differential of 2 points that the line goes trough;\n//... you have a line trough [c]and [d] then a=c-d OR a=d-c;\n//which one you chose to define [a] sets the sign of the distance == line direction.\nfloat sdf_line6(vec2 p,vec2 a){a.x=-a.x;return dot(a.yx,p);}\n//for the above, a must be normalized, which is done by wrapper below.\nfloat sdf_line6n(vec2 p,vec2 a){return sdf_line6(p,normalize(a));}\n//https://www.shadertoy.com/view/4dBfzG\n\n\n/*my main goal was to use this shape to cisualize quaternion slerp:\n\nstruct quat{vec3 a;float r;};//struct makes bloated code, more explicit, more worksafe.\n//enforcing prefix arithmetic\nquat v42c(vec4 a){return quat(a.xyz,a.w);}\nquat norm(quat a){return v42c(normalize(vec4(a.a,a.r)));}\nquat add(quat a,quat b){return v42c(vec4(a.a+b.a,a.r+b.r));}\nquat sub(quat a,quat b){return v42c(vec4(a.a-b.a,a.r-b.r));}\nquat mul(quat a,float b){return v42c(vec4(a.a*b,a.r*b));}\n\n//return spherical-linear-iterpolation from [a] to [b] by [x]\nquat slerp(quat a,quat b,float x){a=norm(a);b=norm(b);//must be normalized,else unpredictable.\n float d=dot(a.a,b.a);if(abs(d)>.9995){//if(inputs are too close)\n  return norm(add(mul(sub(b,a),d),a));}//linear interpolation is more precise.\n if(d<0.){//if(inputs have different signs)\n  b.a=-b.a;d=-d;} //flip chiralty/handetness to take shorter path\n d=clamp(d,-1.,1.);//make sure that acos(d) is defined.\n float t=acos(d)*x; //= angle between v0 and result \n  quat c=sub(b,mul(a,d));//quat v2=quat(v1.aâ€“v0.a*d);\n  c=norm(c);//{v0,v2} is now an orthonormal basis\n  return add(mul(a,cos(t)),mul(c,sin(t)));}//https://en.wikipedia.org/wiki/Slerp\n\n//return trilienar interpolation by [i] over the cube3d volume with the sides a,c,b\nvec2 blin(vec3 i, vec2 a, vec2 b,vec2 c){vec2 r=vec2(0);\n r=mix(r,r+a,i.x);//lerp in direction of a\n r=mix(r,r+b,i.y);//lerp in direction of b\n r=mix(r,r+c,i.z);//lerp in direction of c\n return r;}//imagine simple case: a=vec2(1,0,0) and b=vec2(0,1,0) and c=vec3(0,0,1);\n*/\n\n\n//#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\nif(iResolution.x>iResolution.y)u.x*=iResolution.x/iResolution.y;\nelse u.y*=iResolution.y/iResolution.x;return u*5.;}\n\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define ss(a) a=smoothstep(.003,-.003,a);\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n//does not check for non-intersecticn cases! intersection.y is not important.\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n\n//https://www.shadertoy.com/view/ldBBDw\n#define stretch(a) p.a=mix(p.a-m.a,mix(0.,p.a,step(p.a,0.)),step(p.a,m.a));\n/*          / stretch(a) is a linear funtion that looks like:\n           /\n          /\n    _____/ \n   /0    m.a\n  / \n /\n/  with 2 discontinuities at v.a=0 and v.a=m.a\nx axis is v.a*/\n#define stretch1(p,m) mix(p-m,mix(0.,p,step(p,0.)),step(p,m))\n/*          / stretch(p,m) is a linear funtion that looks like:\n           /\n          /\n    _____/ \n   /0    m\n  / \n /\n/  with 2 discontinuities at p=0 and p=m\nx axis is v.a*/\n\n//https://www.shadertoy.com/view/4ssBDs\n\n//return mirror matrix, mirror is rotated by r*0.5 radians; is a faster alternative to SINGLE rotations.\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//alternative to 2d rotation: mat2(-cos(a),sin(a),sin(a),cos(a))\n\n//return distance of [p] to line segment from vec2(0) to vec2(1,0)\nfloat ls(vec2 p){p.x-=.5;p=abs(p);return mix(length(p-vec2(.5,0)),p.y,step(p.x,.5));}\n//aove special case is faster than the more common dot()/dot() distance to line segment.\n\n//return distance of [p] to pacman-shape, line segment, polar extruded by [r] range [0..2*pi]\nfloat pacman(vec2 p,float r,vec3 t){//r=-3.14*.5;quater open mouth\n  //animated mouth poverwrite;\n  //r=sin(time*5.*(sqrt(5.)*.5+.5))*.5+.5;\n  //r*=1.5;r-=3.;\n                             \n //r=clamp(r,-acos(-1.),acos(-1.));//optionally, constrain th group of this shape!\n //out of bounds shapes \"extended\" this shape \"nicely\" \n //...to something harder do describe as \"overlayed polar extrusion\"?\n float m=atan(p.y,-p.x),ll=length(p)-1.,a=ls(p);p*=r2(-r);p.x+=1.;float b=ls(p);\n r=mix(max(max(ll,-a),-b),min(a,b),step(m,r));\n return r-sin((t.x*t.y+time)*5.)*.5;\n //if(m>r){return max(max(ll,-a),-b);}return min(a,b); \n}\n//return pacman(p,r), with a shortcut branch case if (closed circle)\nfloat pacman2(vec2 p,float r,vec3 t){if(r<=-acos(-1.))return length(p)-1.;return pacman(p,r,t);}\n\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n//except i replaced the circular disk with a distance field for pacman.\nfloat fDisc(vec3 p,float r,vec3 t){\n float l=pacman(p.xz,r,t);\n //l=length(p.xz)-r;//for circle\n float s=mix(abs(p.y),length(vec2(p.y,l)),step(0.,l));//branchless\n //float s= l < 0. ? abs(p.y):length(vec2(p.y, l));//branching\n return s;\n}//mercury.hg_sdf , Subtract some value to make a flat disc with rounded edge.\n/*\n//original disc code\nfloat fDiscO(vec3 p,float r){p*=.25;\n float l=length(p.xz)-r;\n return l<0.?abs(p.y):length(vec2(p.y,l));}\n*/\n\n//i should possibly just change fCylinder into fCylinderWrapper(fDisc())\nfloat fCylinder(vec3 p,float r,float h,vec3 t){\n    p.y=abs(p.y);\n    //p.y=stretch1(p.y,abs(h));\n    //return fDisc(p,r);\n    h=.1;\n    float circle=length(p.xz)-r;\n    float pac=pacman(p.xz,r,t);\n    return max(pac,abs(p.y)-h);}\n\n//return distance to \"cylindrical pacman\"\n//if (t is out of bounds) extends beyond a pacman shape; \"2sticks\" \"hall\" \"minifigHand\"\nfloat fCylPacman(vec3 p,vec3 t){\n //folding domains == extruding distance field. \n float tt=t.x+t.y*sqrt(2.)+t.z*acos(-1.);//very lazy \"hash31\", feed by tilePiy.xyz   \n \n #ifdef tielsrotated\n p.xy*=r2(tt);p.yz*=r2(t.z); \n #endif\n    \n float fold=.5*iMouse.y/iResolution.y;\n p.x=stretch1(p.x+fold*.5,fold);\n p.y=stretch1(p.y+fold*.5,fold);\n p.z=stretch1(p.z+fold*.5,fold);\n    \n //p.z=stretch1(p.z+fold*.1,fold*.2);//folding the .z domain too much is not the best idea\n \n  //if(circle)mm sets circle raduis\n  //else() radius is =1. and mm sets \"how far open pacman mouth is\"\n  float mm=sin((tt*9.+time)*(sqrt(5.)*.5+.5))*.5+.5;\n  mm*=16.;\n  mm-=8.;\n p.xz*=r2(-mm*.5);\n float round=fDisc(p,mm,t)-.1;//rounded corners\n float sharp=fCylinder(p,mm,.0,t);//sharp corrners\n return mix(round,sharp,2.*iMouse.x/iResolution.x);\n return round;//i could instead just interpolate the radius of fDisc(), but this allows overdoing it\n //return sharp;//fCylinder() could be expressed as tansforming wrapper onto fDisc();\n}\n\nvec2 pMod2(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pMod2(p,s);p*=mod(c,2.)*2.-1.;return c;}\n//return signed distance of [p] to implicit surface.\nfloat df(vec3 p){//this fnction mostly just handles the main tesselation(s)\n vec3 t;//t stores tileID\n //p=fract(p)-.5;//modulo p;\n t.y=floor(p.y*1.5/tilesize);\n p.y=fract(p.y*1.5/tilesize)*tilesize-tilesize*.5;//modulo p;\n t.xz=pModMirror1(p.xz,vec2(tilesize));//modmirror evades overstepping on disymmetry.\n \n return fCylPacman(p,t);\n// return length(p)-.25;//-.5 has spheres touch, which constrains camera placement\n //sinusoidial_blob():\n// float k = 50.*(sin(time*.3)*.5+.5);//k=0.;\n// return length(p)-.2 +.1*sin(k*p.x)*sin(k*p.y)*sin(k*p.z);\n}\n\n#ifndef dynamicEps\n//raymarching, root solver for a distance field.\nvoid rm(inout vec3 p,vec3 o,vec3 r){float u=0.;for(float i=0.;i<rMaxIter;++i){\n  p=o+u*r;float s=df(p);\n  if(d<eps)return;u+=s*LipSchitsScale;//if close enough to surface\n  if(u>rdMax)return;u+=s*LipSchitsScale;//if too far from camera\n}}\n#else\n//raymarching, root solver for a distance field.\n//dynmicEpsilon variant evades overstepping with often better performance.\nvoid rm(inout vec3 p,vec3 o,vec3 r){\n float d=0.;//distance of ray from camera\n float s=0.;//last step length\n for (float i=0.;i<rMaxIter;i++){\n  if (log(d*d/s/1e5)>0. || d>rdMax) break;\n  s=df(p);//step length\n  d+=s*.3;\n  p = o + r * d;\t\n}}\n#endif\n\n//return normal==normalized gradient at [p] with distance eps*2. over 3 domains\nvec3 normalb(const in vec3 p){vec2 e=vec2(-1.,1.)*eps*2.;\n return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)+e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n#define rs(r) mat2(sin(r+vec4(-1,0,0,1)*asin(1.)))\n#define ratio(r) r.x/r.y\n\n//great tiny 3d raymarching example: //http://glslsandbox.com/e#38217.0\nvec3 scene(vec3 ro,vec3 rd){\n vec3 O;\n vec3 p;//accululated total raymarched vector\n rm(p,ro,rd);\n float d=sqrt(dot(p,p)*.07+2.);//distance to camera, \n //... with scaling function for \"fake nearby ambient light\"\n //O=vec4(fract(p)*mod(p,3.)/d,1);//show xy positions by color\n p=normalb(p)*.5+.5;\n O=vec3(p.xzy/d);//mixing normal and .xyz position for nice fake-AO-depth\n O*=5.-3.;//overbrighten\n return O;}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n vec2 u=(U.xy/iResolution.xy)*2.-1.;//p(0,0) to center \n u.x*=ratio(iResolution);//aspect ratio adjustment\n float a=time*.3;//time\n vec3 o=+vec3(tilesize*.5);//o=vec3(0,0,sin(a)*3.);//camera position\n vec3 r=normalize(vec3(u*fow,1));//camera ray direction (lazy)\n mat2 m=rs(a*.5);//m=mat2(cos(a),-sin(a),sin(a),cos(a));//is slightly different\n #ifdef camrotate\n r.yz *=m;r.xy *=m;//rotate camera rayson 2 domain pairs.\n #endif\n r=r.yzx;//optional: swivel camera rays, for better view on time=0.\n O.xyz=scene(o,r);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}