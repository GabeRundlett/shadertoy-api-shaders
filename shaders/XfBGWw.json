{
    "Shader": {
        "info": {
            "date": "1704271818",
            "description": "Test of an explicit advection integration scheme. Potentially useful for simulation of fluids, soft bodies or continuous rigid body physics.\n\nIt's tested on viscosity physics because it's notoriously hard to integrate implicitly the way it's usually done.",
            "flags": 32,
            "hasliked": 0,
            "id": "XfBGWw",
            "likes": 8,
            "name": "Viscous soft body physics test",
            "published": 3,
            "tags": [
                "advection",
                "physics",
                "cfd"
            ],
            "usePreview": 0,
            "username": "Suslik",
            "viewed": 417
        },
        "renderpass": [
            {
                "code": "//The scheme conserves both mass and momentum, supports arbitrarily large time steps and is unconditionally stable.\n\n//The advection step GatherAdvectedPixel() is the interesting part, can be potentially used for something like gravity simulation,\n//liquid/gas interface simulaiton or rigid body physics.\n\n//Viscosity solver ComputeLocalInteraction() is really basic, based on relaxation and\n//is basically implemented to make the advection part do something.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(uv.x < 0.5f || true)\n        fragColor = texture(iChannel1, uv).aaaa;\n    else\n        fragColor = vec4(texture(iChannel1, uv).xy * 0.1f, texture(iChannel1, uv).z, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelIndex = fragCoord.xy;\n\n    vec4 res = vec4(0.0f);\n    if(iFrame < 10 || iMouse.z > 0.5f)\n    {\n        vec2 pos0 = vec2(iResolution.x * 0.3, iResolution.y * 0.4);\n        vec2 pos1 = vec2(iResolution.x * 0.7, iResolution.y * 0.6);\n        \n        if(iMouse.z > 0.5f)\n        {\n            pos0 = iMouse.xy;\n            pos1 = iResolution.xy - iMouse.xy;\n        }\n        vec2 delta0 = pixelIndex - pos0;\n        float dist0 = length(delta0);\n\n        vec2 delta1 = pixelIndex - pos1;\n        float dist1 = length(delta1);\n        \n        vec2 delta;\n        float dist;\n        vec2 velocity;\n        if(dist0 < dist1)\n        {\n            delta = delta0;\n            dist = dist0;\n            velocity = vec2(iResolution.x / 10.0f, 0.0f);\n        }else\n        {\n            delta = delta1;\n            dist = dist1;\n            velocity = vec2(-iResolution.x / 10.0f, 0.0f);\n        }\n        float color = 0.5f + 0.5f * Checkerboard(pixelIndex / 100.0f);\n        \n        //velocity = CrossProduct(delta, 0.5f);\n        //velocity = delta.y > 0.0f ? vec2(30.0, 0.0f) : vec2(-30.0f, 0.0f);\n        res = dist < iResolution.x / 7.0f ? PackPixel(velocity, 1.0f, color) : PackPixel(vec2(0.0f, 0.0f), 0.0f, 0.0f);\n    }else\n    {\n        //res = texture(iChannel0, fragCoord.xy / iResolution.xy);\n        res = ComputeLocalInteraction(iChannel0, ivec2(fragCoord), dt);\n    }\n    fragColor = res;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float dt = 0.01f;\nvec4 PackPixel(vec2 velocity, float density, float color)\n{\n    return vec4(velocity, density, color);\n}\n\nvec2 GetImpulse(vec4 pixel)\n{\n    return pixel.xy;\n}\n\nfloat GetDensity(vec4 pixel)\n{\n    return pixel.z;\n}\n\nfloat GetColor(vec4 pixel)\n{\n    return pixel.w;\n}\n\nvec4 GatherAdvectedPixel(sampler2D tex, ivec2 dstIndex, float dt)\n{\n    const int searchRadius = 10;\n    ivec2 srcIndex;\n    \n    vec2 resImpulse = vec2(0.0f);\n    float resDensity = 0.0f;\n    float resColor = 0.0f;\n    for(srcIndex.y = dstIndex.y - searchRadius; srcIndex.y < dstIndex.y + searchRadius; srcIndex.y++)\n    {\n        for(srcIndex.x = dstIndex.x - searchRadius; srcIndex.x < dstIndex.x + searchRadius; srcIndex.x++)\n        {\n            vec4 srcPixel = texelFetch(tex, srcIndex, 0);\n            vec2 srcImpulse = GetImpulse(srcPixel);\n            float srcDensity = GetDensity(srcPixel);\n            float srcColor= GetColor(srcPixel);\n            vec2 srcVelocity = srcImpulse / max(1e-7f, srcDensity);\n            \n            vec2 advectedIndex = vec2(srcIndex) + srcVelocity * dt;\n            vec2 weights = max(vec2(1.0f, 1.0f) - abs(advectedIndex - vec2(dstIndex)), 0.0f);\n            \n            float weight = weights.x * weights.y;\n            resImpulse += srcImpulse * weight;\n            resDensity += srcDensity * weight;\n            resColor += srcColor * weight;\n        }\n    }\n    return PackPixel(resImpulse, resDensity, resColor);\n}\n\nfloat CrossProduct(vec2 a, vec2 b) //returns a pseudoscalar\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec2 CrossProduct(vec2 a, float b) //b is a pseudoscalar\n{\n    return vec2(-a.y, a.x) * b;\n}\n\nvec4 ComputeLocalInteraction(sampler2D tex, ivec2 dstIndex, float dt)\n{\n    float totalDensity = 0.0f;\n    float totalColor = 0.0f;\n    float totalMass = 0.0f;\n    vec2 totalImpulse = vec2(0.0f, 0.0f);\n    vec2 totalMassCenter = vec2(0.0f, 0.0f);\n    float totalAngularImpulse = 0.0f;\n    float totalInertiaMoment = 0.0f;\n\n    vec2 dv = vec2(0.0f, -30.0f) * dt;\n    ivec2 size = textureSize(tex, 0);\n\n    vec4 centerPixel = texelFetch(tex, dstIndex, 0);\n    float resDensity = GetDensity(centerPixel);\n    float resColor = GetColor(centerPixel);\n    \n    int searchRadius = 10;\n    ivec2 offset;\n    for(offset.y = -searchRadius; offset.y <= searchRadius; offset.y++)\n    {\n        for(offset.x = -searchRadius; offset.x <=  searchRadius; offset.x++)\n        {\n            ivec2 srcIndex = dstIndex + offset * 4;\n            vec4 srcPixel = texelFetch(tex, srcIndex, 0);\n            vec2 srcImpulse = GetImpulse(srcPixel);\n            float srcDensity = GetDensity(srcPixel);\n            vec2 delta = -vec2(srcIndex);\n\n            /*srcImpulse += dv * srcDensity;\n            if(srcIndex.x < 0 || srcIndex.y < 0 || srcIndex.x >= size.x || srcIndex.y >= size.y)\n            {\n                srcImpulse = vec2(0.0f);\n                srcDensity = 1e3f;\n            }*/\n            float srcAngularImpulse = -CrossProduct(srcImpulse, delta);\n            float srcInertiaMoment = dot(delta, delta) * srcDensity;\n            vec2 srcMassCenter = srcDensity * vec2(srcIndex);\n            \n            totalMass += srcDensity;\n            totalImpulse += srcImpulse;\n            totalMassCenter += srcMassCenter;\n            totalAngularImpulse += srcAngularImpulse;\n            totalInertiaMoment += srcInertiaMoment;\n        }\n    }\n\n    float invMass = 1.0f / max(1e-7f, totalMass);\n    vec2 resMassCenter = totalMassCenter * invMass;\n    vec2 resMassCenterVelocity = totalImpulse * invMass;\n    \n    float resMassCenterAngularImpulse = totalAngularImpulse - CrossProduct(totalImpulse, resMassCenter);\n    float resMassCenterIntertiaMoment = totalInertiaMoment - dot(resMassCenter, resMassCenter) * totalMass;\n    float resAngularVelocity = resMassCenterAngularImpulse / max(1e-7f, resMassCenterIntertiaMoment);\n    \n    vec2 resVelocity = resMassCenterVelocity - CrossProduct(vec2(dstIndex) - resMassCenter, resAngularVelocity);\n    \n\n    return vec4(PackPixel(resVelocity * resDensity, resDensity, resColor));\n}\n\nfloat Checkerboard(vec2 uv)\n{\n    return step(0.5f, fract(uv.y + 0.5f * step(0.5f, fract(uv.x))));\n}\n\nvec4 VelocityToColor(vec2 v)\n{\n    return length(v) * vec4(v.x > 0.0f ? 1.0f : 0.0f, v.x < 0.0f ? 1.0f : 0.0f, 0.0f, 0.0f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelIndex = fragCoord.xy;\n    fragColor = GatherAdvectedPixel(iChannel0, ivec2(pixelIndex), dt);\n    //fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}