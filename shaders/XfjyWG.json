{
    "Shader": {
        "info": {
            "date": "1722911083",
            "description": "A gentle screen transition with disappearing hexagonal cells.\nDid you know a hexagonal grid is the densest possible arrangement of circles?",
            "flags": 0,
            "hasliked": 0,
            "id": "XfjyWG",
            "likes": 6,
            "name": "Hexagonal Wipe",
            "published": 3,
            "tags": [
                "colorful",
                "fun",
                "hexagon",
                "transition",
                "fade",
                "dots",
                "hex",
                "dithering",
                "nintendo",
                "wipe",
                "geometric",
                "satisfying",
                "clean",
                "bestagon",
                "gentle"
            ],
            "usePreview": 0,
            "username": "blandprix",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "const float density = 6. * 6.;\nconst float speed = 1.0;\nconst float boundary_size = 0.6; //0..1, ideally\nconst float antialiasing_intensity = 2.;\nconst vec4 primary_color_1 = vec4(1.0, 0.2, 0.1, 1.0);\nconst vec4 primary_color_2 = vec4(0.0, 0.2, 1.0, 1.0);\nconst vec4 primary_color_3 = vec4(1.0, 0.9, 0.0, 1.0);\n// ^ play with these constants!\n\nconst float PI = 3.1415926535897932385;\nconst float s3o2 = sqrt(3.)/2.;\nconst float cell_radius = 1./density;\n// ^ probably best not to touch these.\n\nfloat modulus(float a, float b) {\n    return a - b * floor(a / b);\n}\n\nvec2 axial_round(vec2 fractional_axial){\n\tfloat fractional_q = fractional_axial.x;\n\tfloat fractional_r = fractional_axial.y;\n\tfloat fractional_s = 0. - fractional_q - fractional_r;\n\n\tfloat whole_q = round(fractional_q);\n\tfloat whole_r = round(fractional_r);\n\tfloat whole_s = round(fractional_s);\n\n\tfloat q_diff = abs(fractional_q - whole_q);\n\tfloat r_diff = abs(fractional_r - whole_r);\n\tfloat s_diff = abs(fractional_s - whole_s);\n\n\tfloat q = mix(whole_q, -whole_r-whole_s, step(r_diff, q_diff) * step(s_diff, q_diff));\n\tfloat r = mix(whole_r, -whole_q-whole_s, step(q_diff, r_diff) * step(s_diff, r_diff));\n\n\treturn vec2(q, r);\n}\n\nvec2 axial_to_cartesian(vec2 axial, float grid_scale)\n{\n    float x = (sqrt(3.0) * axial.x + sqrt(3.0) / 2.0 * axial.y)/grid_scale;\n    float y = (3.0 / 2.0 * axial.y)/grid_scale;\n\t\n    return vec2(x, y);\n}\n\nvec2 cartesian_to_fractional_axial(vec2 cartesian, float grid_scale)\n{\n    float q = ((cartesian.x / sqrt(3.0)) - (cartesian.y / 3.0)) * grid_scale;\n    float r = (2.0 * cartesian.y / 3.0) * grid_scale;\n\n    return vec2(q, r);\n}\n\nvec2 cartesian_to_whole_axial(vec2 cartesian, float grid_scale)\n{\n\treturn axial_round(cartesian_to_fractional_axial(cartesian, grid_scale));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x; //only accounting for width, keeping aspect\n    \n    vec2 cell_center_axial = cartesian_to_whole_axial(uv, density);\n\tvec2 cell_center = axial_to_cartesian(cell_center_axial, density);\n        \n    float dist_from_cell_center = distance(cell_center, uv);\n    \n    vec4 secondary = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    float timer = iTime * speed;\n    float flip = step(sin(timer + uv.x), 0.0);\n    \n    float cycle_count = round(timer/(PI*2.) + 0.75);\n    \n    vec4 primary = primary_color_1;\n    primary = mix(primary, primary_color_2, step(modulus(cycle_count, 3.0)+1., 2.0));\n    primary = mix(primary, primary_color_3, step(modulus(cycle_count, 3.0)+1., 1.0));\n    \n    float oscillator = cos(timer + uv.x)*(1./boundary_size);\n        \n    float distance_threshold = mix(0., cell_radius, oscillator);\n    \n    ////leaving the un-antialiased version because it's easier to understand\n    //vec4 color = mix(primary, secondary, step(dist_from_cell_center, distance_threshold));\n    //vec4 flipped = mix(secondary, primary, step(dist_from_cell_center, distance_threshold*-1.));\n        \n    float proximity = (distance_threshold - dist_from_cell_center)*density;\n    float flipped_proximity = (distance_threshold*-1. - dist_from_cell_center)*density;\n    proximity = mix(proximity, flipped_proximity, flip);\n    float scaled_proximity = proximity*iResolution.x/density/antialiasing_intensity;\n    \n    vec4 color = mix(primary, secondary, smoothstep(0., 1., scaled_proximity));\n    vec4 flipped_color = mix(secondary, primary, smoothstep(0., 1., scaled_proximity));\n    \n    fragColor = mix(color, flipped_color, flip);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}