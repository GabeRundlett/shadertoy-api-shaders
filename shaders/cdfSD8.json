{
    "Shader": {
        "info": {
            "date": "1668763020",
            "description": "Port of a void and cluster implementation I did:\n[url]https://alister-chowdhury.github.io/posts/20221230-bluenoise-generator/[/url]\n\nSettings can be configured in Common (width, height, sigma)\n\nDoes one iteration per frame, so takes longer to converge.",
            "flags": 32,
            "hasliked": 0,
            "id": "cdfSD8",
            "likes": 7,
            "name": "Void And Cluster Bluenoise",
            "published": 3,
            "tags": [
                "noise",
                "bluenoise"
            ],
            "usePreview": 0,
            "username": "krax",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "// Faster tiled version:\n// https://www.shadertoy.com/view/XcyXDh\n\n\n#define TILE_SAMPLE 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if TILE_SAMPLE\n    ivec2 coord = ivec2(fract(gl_FragCoord.xy * textureSizeAndInvSize.zw) * textureSizeAndInvSize.xy);\n#else // TILE_SAMPLE\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    ivec2 coord = ivec2(uv * textureSizeAndInvSize.xy);\n#endif // TILE_SAMPLE\n\n    vec3 value = texelFetch(iChannel0, coord, 0).xxx;\n    fragColor = vec4(value, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define bluenoiseWidth  64\n#define bluenoiseHeight 64\n#define sigma           1.9\n\n\n#define log2e           1.4426950408889634073599246810018\n\nconst int maxIterations = bluenoiseWidth * bluenoiseHeight - 1;\nconst float valueMultiplier = 1.0 / float(maxIterations);\nconst float expMultiplier = 1.0 / (sigma * sigma) * log2e;\nconst vec4 textureSizeAndInvSize = vec4(float(bluenoiseWidth),\n                                        float(bluenoiseHeight),\n                                        1.0 / float(bluenoiseWidth),\n                                        1.0 / float(bluenoiseHeight));\n\n\nuint simpleHash32(uvec3 Seed)\n{\n    uint hx = (0xb543c3a6u ^ Seed.x);\n    uint hy = (0x526f94e2u ^ Seed.y);\n    uint hxy = hx * hy;\n    uint hz0 = 0x53c5ca59u ^ (hxy >> 5u);\n    uint hz1 = (0x74743c1bu ^ Seed.z);\n    uint h = hz0 * hz1;\n    return h;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background\n// energy.\n\n\n// Uses the last 23bits to construct a (non-linear) range\n// [0, 1.17549421069e-38]\nfloat backgroundEnergyBounded(uint seed)\n{\n    return uintBitsToFloat(seed & 0x007fffffu);\n}\n\nfloat getBackgroundEnergy()\n{\n    uint backgroundEnergySeed = simpleHash32(floatBitsToUint(iDate.yzw)) ^ floatBitsToUint(iTime);\n    uint S = simpleHash32(uvec3(uvec2(gl_FragCoord.xy), uint(backgroundEnergySeed)));\n    return backgroundEnergyBounded(S);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(any(greaterThanEqual(gl_FragCoord.xy, textureSizeAndInvSize.xy)))\n    {\n        return;\n    }\n\n    if(iFrame == 0)\n    {\n        fragColor = vec2(0., getBackgroundEnergy()).xyxx;\n        return;\n    }\n    \n    vec2 prevValue = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0).xy;\n    if(iFrame > maxIterations)\n    {\n        fragColor = prevValue.xyxx;\n        return;\n    }\n    \n    // Get the result from downscaling and finding the smallest void\n    float value = 1.0 - (valueMultiplier * float(iFrame - 1));\n    vec2 target = texelFetch(iChannel1, ivec2(0, 0), 0).yz;\n    vec2 coord = vec2(floor(gl_FragCoord.xy));\n    float noise = all(equal(target, coord)) ? value : 0.;\n\n    // Wrap around logic\n    vec2 delta = fract(abs(coord - target) * textureSizeAndInvSize.zw);\n    delta = 0.5 - abs(delta - 0.5);\n    delta *= textureSizeAndInvSize.xy;\n    float energy = exp2(-dot(delta, delta) * expMultiplier) * value;\n\n    noise += prevValue.x;\n    energy += prevValue.y;\n\n    fragColor = vec2(noise, energy).xyxx;\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Void and cluster reduce init\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 maxSize = uvec2(bluenoiseWidth, bluenoiseHeight);\n    uint seed = simpleHash32(floatBitsToUint(iDate.yzw)) ^ uint(iFrame);\n\n    uvec2 voidCoord = uvec2(0, 0);\n    float voidValue = 1e+35;\n\n    uvec2 start = min(uvec2(gl_FragCoord.xy) << 3u, maxSize - 1u);\n    uvec2 end = min(start + uvec2(8u, 8u), maxSize);\n\n    // Reduce 8x8 at a time, but mix up the order of comparison\n    // to prevent biasing in any one location\n    uint yh = simpleHash32(uvec3(start + 1u, seed)) >> 20u;\n    uint xh = simpleHash32(uvec3(start + uvec2(13u, 11u), yh)) >> 19u;\n   \n    for(uint yit=0u; yit < 8u; ++yit)\n    {\n        uint y = start.y + ((yh ^ yit) & 7u);\n        if(y >= end.y) { continue; }\n\n        for(uint xit=0u; xit < 8u; ++xit)\n        {\n            uint x = start.x + ((xh ^ xit) & 7u);\n            if(x >= end.x) { continue; }\n            \n            uvec2 coord = uvec2(x, y);\n            vec2 noiseEnergy = texelFetch(iChannel0, ivec2(coord), 0).xy;\n            if((noiseEnergy.x == 0.) && (noiseEnergy.y < voidValue))\n            {\n                voidValue = noiseEnergy.y;\n                voidCoord = coord;\n            }\n        }\n    }\n\n    vec2 outVoidData = vec2(voidValue,\n                            uintBitsToFloat(voidCoord.x | (voidCoord.y << 16)));\n\n    fragColor = outVoidData.xyxx;\n    fragColor = vec3(voidValue, vec2(voidCoord)).xyzx;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Void and cluster reduce iteration\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 maxSize = uvec2(bluenoiseWidth, bluenoiseHeight);\n    maxSize.x = (maxSize.x + 7u) / 8u;\n    maxSize.y = (maxSize.y + 7u) / 8u;\n    \n    uint seed = simpleHash32(floatBitsToUint(iDate.yzw * iTime)) ^ uint(iFrame);\n\n    vec2 packedVoidCoord = vec2(0.);\n    float voidValue = 1e+35;\n\n    uvec2 start = min(uvec2(gl_FragCoord.xy) << 3u, maxSize - 1u);\n    uvec2 end = min(start + uvec2(8u, 8u), maxSize);\n\n    // Reduce 8x8 at a time, but mix up the order of comparison\n    // to prevent biasing in any one location\n    uint yh = simpleHash32(uvec3(start + 1u, seed)) >> 20u;\n    uint xh = simpleHash32(uvec3(start + uvec2(13u, 11u), yh)) >> 19u;\n   \n    for(uint yit=0u; yit < 8u; ++yit)\n    {\n        uint y = start.y + ((yh ^ yit) & 7u);\n        if(y >= end.y) { continue; }\n\n        for(uint xit=0u; xit < 8u; ++xit)\n        {\n            uint x = start.x + ((xh ^ xit) & 7u);\n            if(x >= end.x) { continue; }\n            \n            uvec2 coord = uvec2(x, y);\n            vec3 packedData = texelFetch(iChannel0, ivec2(coord), 0).xyz;\n            if(packedData.x < voidValue)\n            {\n                voidValue = packedData.x;\n                packedVoidCoord = packedData.yz;\n            }\n        }\n    }\n\n    vec3 outVoidData = vec3(voidValue, packedVoidCoord);\n\n    fragColor = outVoidData.xyzx;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Final reduction, no 8x8 tiling, since we have no more buffers\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 maxSize = uvec2(bluenoiseWidth, bluenoiseHeight);\n    maxSize.x = (maxSize.x + 7u) / 8u;\n    maxSize.y = (maxSize.y + 7u) / 8u;\n    maxSize.x = (maxSize.x + 7u) / 8u;\n    maxSize.y = (maxSize.y + 7u) / 8u;\n\n    vec2 packedVoidCoord = vec2(0.);\n    float voidValue = 1e+35;\n    \n    uvec2 start = min(uvec2(gl_FragCoord.xy) << 3u, maxSize - 1u);\n    uvec2 end = min(start + uvec2(8u, 8u), maxSize);\n    \n    for(uint y=start.y; y<end.y; ++y)\n    for(uint x=start.x; x<end.x; ++x)\n    {\n        uvec2 coord = uvec2(x, y);\n        vec3 packedData = texelFetch(iChannel0, ivec2(coord), 0).xyz;\n        if(packedData.x < voidValue)\n        {\n            voidValue = packedData.x;\n            packedVoidCoord = packedData.yz;\n        }\n    }\n\n    vec3 outVoidData = vec3(voidValue, packedVoidCoord);\n    fragColor = outVoidData.xyzx;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}