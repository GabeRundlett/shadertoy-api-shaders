{
    "Shader": {
        "info": {
            "date": "1461672368",
            "description": "This shows how to extract a digit on a certain position of a floating point number related to a certain base.\nHere one can see the extraction of iGlobalTime related to the bases 16, 10, 8, 3, 2 ( from top to bottom ).\nFeel free to play with params!",
            "flags": 0,
            "hasliked": 0,
            "id": "MstXW2",
            "likes": 2,
            "name": "Bases And Digits",
            "published": 3,
            "tags": [
                "clock",
                "numbers",
                "counter",
                "digits",
                "bases"
            ],
            "usePreview": 0,
            "username": "samuelotherion",
            "viewed": 629
        },
        "renderpass": [
            {
                "code": "const float\n    BASES  = 5.,\n    FLOOR  = 12.,\n    FRACT  = 12.,\n    DIGITS = FLOOR + FRACT,\n    WIDTH  = .5;\n\n// base( i ) maps i = ( 0,1,2,3,4 ) => ( 2,3,8,10,16 )\nfloat \n    base( float i ) {\n    \n    return\n    \ti < 4.\n        \t? i < 2.\n        \t\t? i < 1.\n        \t\t\t? 2.\n        \t\t\t: 3.\n            \t: i < 3.\n                \t? 8.\n                \t: 16.\n\t\t\t: 32.;\n    }\n\n// extracts a digit of a floating point number\n// pos 0 is the one left to the dot     \n// pos -1 is the one right to the dot\n\n// number: 273.15\n// digits:  2  7  3  1  5\n// pos:    +3 +2 +1 -1 -2\n\nfloat\n    digitOfFloat( float num, float pos, float base ) {\n        \n        return mod( floor( num * pow( base, -pos ) ), base );\n    }\n\nvoid\n    mainImage( out vec4 o, vec2 p ) {\n\n        p /= iResolution.xy;\n        \n        vec2\n            pdb = p * vec2( DIGITS, float( BASES ) ),\t\n            db  = floor( pdb ),\n            xy  = fract( pdb );\n        \n        xy.y *= 1.5;\n                \n        float\n            b   = base( pdb.y ),\n            d   = b - 1.,\n            pos = FLOOR - 1. - db.x;\n        \n        vec2\n            grd = vec2( xy.x - .5 * WIDTH, fract( d * xy.y ) - .5 );\n        \n        float\n            a = 8. * ( .125 - dot( grd, grd ) );\n        \n\t\to = \n            xy.x < WIDTH && d * xy.y < digitOfFloat( iTime, pos, b ) \n            \t? pos < 1.\n            \t\t? pos < 0.\n            \t\t\t? vec4( a * vec3( 1, .75, .6 ), 1 )\n            \t\t\t: vec4( a * vec3( 1, 0,    0 ), 1 )\n            \t\t: vec4( a * vec3( .6, .75, 1 ), 1 ) \n            \t: xy.y < 1.\n                    ? vec4( a * vec3( .1, .05, .05 ), 1 )\n                    : vec4( vec3( .075, .05, .05 ), 1 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}