{
    "Shader": {
        "info": {
            "date": "1655745112",
            "description": "variant of 2011 GLSL1.2 code ( nVidia G80 :-D )  port https://shadertoy.com/view/7lsyzf\nwith direct gaussian (no table ) and better hash\n\nmouse.y : zoom\nshift-mouse.y: force LOD change",
            "flags": 16,
            "hasliked": 0,
            "id": "ssKyW3",
            "likes": 1,
            "name": "topdown starfield 2",
            "published": 3,
            "tags": [
                "poisson",
                "stars",
                "pointprocess"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 86
        },
        "renderpass": [
            {
                "code": "// variant \"topdown starfield\" by FabriceNeyret2. https://shadertoy.com/view/7lsyzf\n// with direct gaussian (no table ) and better hash\n\n/****** FroggyPerlin_FS.glsl **************************/\n\nfloat deltac = .5,    // userParam3.a  = x translation\n        cmoy = .5;    // userParam3.z  = y translation\nint N = 3;            // UserParam2.x  = LOD\nvec2 localCoord;      // varying vec4  = normalized pixel coords\nfloat xscale = .05;   // userParam1.x  = zoom\nvec4 C;               // output        = output color\n\n#define SQR(x) ((x)*(x))\n\n// --- User interface was:\n// key:            + -             →  N++ / --\n// mouse: shift-left: scale noise  →  1.x *= rx= 1.+dMouse.x/R.x\n//            middle: zoom         →  camera move ( 0,0,ry)\n//             right: translate    →  camera move (-rx,-ry,0)\n\n\n\n/******************************************************\\\n**                                                    **\n**      Stats.glsl           Fabrice NEYRET 30/06/11  **\n**                                                    **\n\\******************************************************/\n\n// rnd(seed)    Uniform[0,1]\n//                  (low quality and precision)\n// rnd3(xseed,yseed,seed)\n// gauss(u)     Normal(0,1)\n//                  use uniform as seed\n// intgauss(x)  cumulative distr func of Normal(0,1)\n//                  use x = (x-xm)/s for N(xm,s^2)\n\n//#line 15 1\n\n// seq(fsolve(1/2*(1+erf(x/sqrt(2)))=i/255.,x), i = 0..255);\nfloat invgauss[256] = float[](\n  -13.50858432, -2.658748992, -2.416134297, -2.264727419,   -2.152315053, -2.061916502, -1.985770403, -1.919651290,   -1.860993476, -1.808117371, -1.759861028, -1.715385840,   -1.674065908, -1.635421185, -1.599075078, -1.564726471,   -1.532130657, -1.501085946, -1.471424060, -1.443003065,   -1.415702094, -1.389417334, -1.364058929, -1.339548561,   -1.315817530, -1.292805229, -1.270457904, -1.248727645,   -1.227571561, -1.206951090, -1.186831433, -1.167181068,   -1.147971348, -1.129176158, -1.110771617, -1.092735829,   -1.075048664, -1.057691573, -1.040647418, -1.023900333,   -1.007435601, -0.9912395403, -0.9752994069, -0.9596033111,   -0.9441401408, -0.9288994918, -0.9138716087, -0.8990473298,   -0.8844180399, -0.8699756243, -0.8557124305, -0.8416212336,   -0.8276952018, -0.8139278686, -0.8003131056, -0.7868450995,   -0.7735183280, -0.7603275409, -0.7472677410, -0.7343341688,   -0.7215222841, -0.7088277541, -0.6962464387, -0.6837743800,   -0.6714077892, -0.6591430371, -0.6469766453, -0.6349052758,   -0.6229257234, -0.6110349080, -0.5992298682, -0.5875077530,   -0.5758658170, -0.5643014135, -0.5528119909, -0.5413950853,   -0.5300483169, -0.5187693864, -0.5075560692, -0.4964062122,   -0.4853177302, -0.4742886030, -0.4633168707, -0.4524006317,   -0.4415380391, -0.4307272994, -0.4199666679, -0.4092544476,   -0.3985889860, -0.3879686745, -0.3773919440, -0.3668572645,   -0.3563631432, -0.3459081219, -0.3354907758, -0.3251097114,   -0.3147635664, -0.3044510061, -0.2941707233, -0.2839214366,   -0.2737018897, -0.2635108491, -0.2533471031, -0.2432094621,   -0.2330967553, -0.2230078312, -0.2129415555, -0.2028968119,   -0.1928724988, -0.1828675299, -0.1728808328, -0.1629113487,   -0.1529580307, -0.1430198431, -0.1330957617, -0.1231847716,   -0.1132858673, -0.1033980512, -0.09352033436, -0.08365173407,   -0.07379127404, -0.06393798335, -0.05409089672, -0.04424905235,   -0.03441149226, -0.02457726114, -0.01474540668,   -0.004914977406, 0.004914977155, 0.01474540642, 0.02457726089,   0.03441149176, 0.04424905210, 0.05409089646, 0.06393798310,   0.07379127354, 0.08365173382, 0.09352033411, 0.1033980509,   0.1132858670, 0.1231847714, 0.1330957614, 0.1430198428,   0.1529580304, 0.1629113485, 0.1728808325, 0.1828675294,   0.1928724985, 0.2028968116, 0.2129415553, 0.2230078306,   0.2330967551, 0.2432094618, 0.2533471029, 0.2635108488,   0.2737018895, 0.2839214363, 0.2941707228, 0.3044510058,   0.3147635661, 0.3251097112, 0.3354907753, 0.3459081217,   0.3563631430, 0.3668572642, 0.3773919437, 0.3879686742,   0.3985889858, 0.4092544470, 0.4199666676, 0.4307272991,   0.4415380388, 0.4524006311, 0.4633168704, 0.4742886028,   0.4853177300, 0.4964062120, 0.5075560689, 0.5187693861,   0.5300483166, 0.5413950850, 0.5528119906, 0.5643014132,   0.5758658164, 0.5875077527, 0.5992298679, 0.6110349077,   0.6229257228, 0.6349052755, 0.6469766450, 0.6591430368,   0.6714077889, 0.6837743797, 0.6962464383, 0.7088277535,   0.7215222838, 0.7343341684, 0.7472677407, 0.7603275402,   0.7735183276, 0.7868450991, 0.8003131052, 0.8139278682,   0.8276952014, 0.8416212332, 0.8557124301, 0.8699756239,   0.8844180395, 0.8990473294, 0.9138716079, 0.9288994914,   0.9441401404, 0.9596033107, 0.9752994065, 0.9912395399,   1.007435601, 1.023900332, 1.040647417, 1.057691573,   1.075048664, 1.092735828, 1.110771616, 1.129176157,   1.147971347, 1.167181067, 1.186831432, 1.206951090,   1.227571560, 1.248727645, 1.270457904, 1.292805229,   1.315817529, 1.339548560, 1.364058929, 1.389417333,   1.415702093, 1.443003064, 1.471424059, 1.501085945,   1.532130656, 1.564726471, 1.599075077, 1.635421184,   1.674065907, 1.715385839, 1.759861026, 1.808117368,   1.860993475, 1.919651288, 1.985770401, 2.061916499,   2.152315051, 2.264727416, 2.416134292, 2.658748984, 13.50858432\n);\n\n//seq(evalf(1/2*(1+erf(((2*i/255-1)*3.2)/sqrt(2)))), i = 0..255);\nfloat Intgauss[256] = float[](\n0.6871380e-3, 0.7494356e-3, 0.8169004e-3, 0.8899146e-3, 0.9688851e-3, 0.10542440e-2, 0.11464499e-2, 0.12459894e-2, 0.13533781e-2, 0.14691620e-2, 0.15939188e-2, 0.17282592e-2, 0.18728282e-2, 0.20283069e-2, 0.21954132e-2, 0.23749034e-2, 0.25675740e-2, 0.27742627e-2, 0.29958497e-2, 0.32332593e-2, 0.34874612e-2, 0.37594717e-2, 0.40503552e-2, 0.43612252e-2, 0.46932459e-2, 0.50476330e-2, 0.54256549e-2, 0.58286340e-2, 0.62579476e-2, 0.67150286e-2, 0.72013666e-2, 0.77185082e-2, 0.82680583e-2, 0.88516803e-2, 0.94710962e-2, 0.101280874e-1, 0.108244945e-1, 0.115622174e-1, 0.123432152e-1, 0.131695056e-1, 0.140431650e-1, 0.149663273e-1, 0.159411831e-1, 0.169699787e-1, 0.180550152e-1, 0.191986463e-1, 0.204032774e-1, 0.216713632e-1, 0.230054056e-1, 0.244079514e-1, 0.258815900e-1, 0.274289497e-1, 0.290526957e-1, 0.307555258e-1, 0.325401674e-1, 0.344093732e-1, 0.363659176e-1, 0.384125920e-1, 0.405521998e-1, 0.427875528e-1, 0.451214648e-1, 0.475567470e-1, 0.500962022e-1, 0.527426190e-1, 0.554987662e-1, 0.583673862e-1, 0.613511885e-1, 0.644528440e-1, 0.676749772e-1, 0.710201601e-1, 0.744909052e-1, 0.780896580e-1, 0.818187898e-1, 0.856805910e-1, 0.896772632e-1, 0.938109124e-1, 0.980835408e-1, .1024970404, .1070531852, .1117536236, .1165998722, .1215933076, .1267351604, .1320265080, .1374682681, .1430611923, .1488058602, .1547026733, .1607518498, .1669534188, .1733072163, .1798128798, .1864698448, .1932773408, .2002343882, .2073397956, .2145921572, .2219898512, .2295310383, .2372136614, .2450354446, .2529938944, .2610862998, .2693097340, .2776610567, .2861369163, .2947337533, .3034478039, .3122751044, .3212114960, .3302526301, .3393939748, .3486308209, .3579582890, .3673713374, .3768647696, .3864332432, .3960712786, .4057732686, .4155334878, .4253461032, .4352051838, .4451047123, .4550385955, .4650006759, .4749847425, .4849845435, .4949937969, .5050062031, .5150154565, .5250152575, .5349993241, .5449614045, .5548952877, .5647948162, .5746538968, .5844665122, .5942267314, .6039287214, .6135667568, .6231352304, .6326286626, .6420417110, .6513691791, .6606060252, .6697473699, .6787885040, .6877248956, .6965521961, .7052662467, .7138630837, .7223389433, .7306902660, .7389137002, .7470061056, .7549645554, .7627863386, .7704689617, .7780101488, .7854078428, .7926602044, .7997656118, .8067226592, .8135301552, .8201871202, .8266927837, .8330465812, .8392481502, .8452973267, .8511941398, .8569388077, .8625317319, .8679734920, .8732648396, .8784066924, .8834001278, .8882463764, .8929468148, .8975029596, .9019164592, .9061890876, .9103227368, .9143194090, .9181812102, .9219103420, .9255090948, .9289798399, .9323250228, .9355471560, .9386488115, .9416326138, .9445012338, .9472573810, .9499037978, .9524432530, .9548785352, .9572124472, .9594478002, .9615874080, .9636340824, .9655906268, .9674598326, .9692444742, .9709473043, .9725710503, .9741184100, .9755920486, .9769945944, .9783286368, .9795967226, .9808013537, .9819449848, .9830300213, .9840588169, .9850336727, .9859568350, .9868304944, .9876567848, .9884377826, .9891755055, .9898719126, .9905289038, .9911483197, .9917319417, .9922814918, .9927986334, .9932849714, .9937420524, .9941713660, .9945743451, .9949523670, .9953067541, .9956387748, .9959496448, .9962405283, .9965125388, .9967667407, .9970041503, .9972257373, .9974324260, .9976250966, .9978045868, .9979716931, .9981271718, .9982717408, .9984060812, .9985308380, .9986466219, .9987540106, .9988535501, .9989457560, .9990311149, .9991100854, .9991830996, .9992505644, .9993128620\n);\n\n#if 1                                // $Fab\n    #define  gauss(u) sqrt(-2.*log(u.x)) * cos(2.*3.1415927*u.y ) // takes u = rand2_uniform()\n#else\nfloat gauss(float u) { // takes u = rand_uniform()\n    // return 4*(2*u-1);\n    u*=256.;\n    if (u>=255.) return invgauss[255];\n    int iu = int(u);\n    float fu = u-float(iu);\n    return (1.-fu)*invgauss[iu]+fu*invgauss[iu+1];\n}\n#endif\n\nfloat intgauss(float x) { // use (x-xm)/s for N(m,s^2)\n    x = (x/3.2)*128.+128.;\n    if (x<0.) return Intgauss[0];\n    if (x>255.) return Intgauss[255];\n    int ix = int(x);\n    float fx = x-float(ix);\n    return (1.-fx)*Intgauss[ix]+fx*Intgauss[ix+1];\n}\n\nfloat rnd(int i) { // attention: limited precision and quality.\n#define NB_CHIFFRES 1000. //  1000.\n#define POIDS_FAIBLE 1000000. // 1000000.\n    return mod((sin(0.01*float(i)+.1234567)*POIDS_FAIBLE), NB_CHIFFRES)/NB_CHIFFRES;\n}\n\n#define rnd3x2(x,y,z) ihash(uvec3(ivec3(x,y,z)+10000000)).xy  // $Fab\n\nfloat rnd3(int x,int y, int c) { // decorelated seeds (window=512)\n    return rnd(x+(y<<9)+(c<<18));\n}\n\n\n\nvec3 ihash( uvec3 x ) //  $Fab https://www.shadertoy.com/view/XlXcW4\n{\n    uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n\n/***************************************************\\\n**\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   **\n**\tstars.glsl\t\t\t\t  \tFabrice NEYRET  30/06/11 **\n**\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   **\n\\***************************************************/\n//#line 6 2\n\n// tirage procedural de bruit poissonnien scalable.\n// Principe: partant d'une densité d, on subdivise un quadtree\n// en y tirant la densité des tiles selon la loi de Poisson, recursivement.\n// Quand on atteint les petits nombres, on discretise d,\n// et on tire les positions d'étoiles dans le tile.\n// On affiche soit les etoiles, soit les densités par tile.\n\n\n//--- contribution d'une etoile à un tile\n\n#define LUM 5.76*10. // 1.E-2 // 1.E0 // 1.E8\n#define RAD .125 // rayon de l'etoile\n\n// etoile = gauss(xP,yP,s) pixel grid = x,y,x+l,y+l\nfloat star(float xP, float yP, float s, float x, float y, float l) {\n    float invs = 1./s, r=l*.5;\n    float d = sqrt(SQR(x+r-xP) + SQR(y+r-yP));\n    // à 3.2*s, moins de .5% de luminosité\n    if (d >  3.2*s+r) return 0.; // etoile hors pixel\n    if (d < -3.2*s+r) return 1.; // etoile dans pixel\n    else   // etoile en partie dans le pixel\n        return  (intgauss((x+l-xP)*invs)-intgauss((x-xP)*invs))\n               *(intgauss((y+l-yP)*invs)-intgauss((y-yP)*invs));\n}\n\n//--- processus de Poisson recursif\n\nvoid draw_points() {\n // NB: we need ints as index in the quadtree -> virtual grid\n#define Z 9       // resolution grille virtuelle\n#define L (1<<Z)\t//  > à largeur des etoiles (sinon clip!)\n#define root (-4) // extrapole la racine de la grille\n    float n = 0.05; // densité: 1 case sur 20 dans L*L\n  n *= float(1<<(2*(Z-root))); // conv en nombre sur grille\n\n    // coords ecrans -> coord grille\n    float scale = 20.*xscale;\n    float fx = scale*(localCoord.x-.5) +deltac;\n    float fy = scale*(localCoord.y-.5) +cmoy;\n    //  n *= 1./(.01+fx*fx+fy*fy);              // distrib pseudo-gaussienne\n    //  n *= 20*exp(-.5*(fx*fx+fy*fy)/SQR(.5)); // distrib gaussienne\n    fx *=float(L); fy *=float(L);\n    int x = int(floor(fx)), y = int(floor(fy));\n    //if (x*y==0) { gl_FragData[0].g=255; return; }\n\n    //int depth = 7;  // prof d'exploration\n  int depth = int(8.-log2(scale))-N+3; if (depth>Z) depth=Z;\n\n    // tirage de Poisson en quadtree: quel n dans tile courant ?\n    int xx,yy; // coord du tile\n    int k=1<<(Z-root), M=-k; // taille du tile et mask de coords\n#define COORDS 1\n#if COORDS // seed tile = coords du tile (par maskage de x,y)\n             // Pb: les fils gauche ont le meme seed que le pere !\n             // patch: rand(layer i)\n    xx = x&M; yy=y&M; // coord du tile\n#else      // seed tile = coords du tile (par division)\n             // Pb: seed = 0 pour tout tile > MSB\n    xx = x>>(Z-root); yy = y>>(Z-root); \n#endif\n\n#if 1\n    float d = 1.;\n#else\n    float d = pow(.5,1./float(depth-root)); // rectif pour assurer Poisson\n#endif\n    for(int i=root; i<depth; i++) {\n        //if (n>=10)\n    // n-poisson ~ N(l,l) + correction de continuité\n        // http://en.wikipedia.org/wiki/Poisson_distribution\n        // tile pere = densité 4n. on tire fluctuations Poissonniennes\n        n += sqrt(n*d)*gauss(rnd3x2(xx,yy,i*COORDS))-0.5; // approx si n<=5\n        // <><><> added i instead of 0. thus, correlated with next rands\n        //else\n        // // n = n*(2*rnd3(xx,yy,1));\n        // n = n*(1+1*(2*rnd3(xx,yy,1)-1));\n\n        if (n<4.) { // petit nombre\n         // if (rnd3(xx,yy,1)<(n-int(n))) n++; n=int(n); // frac -> proba\n            if (rnd3(xx,yy,1)<fract(n)) n++; n=floor(n); // frac -> proba\n            if (n<1.) return; // zone de ciel noir\n            if (n<4.) break; // draw stars\n        }\n\n        // on subdivise\n        n = n*0.25; // densité moyenne des fils\n        k>>=1; M |= k; // on passe aux tiles fils\n#if COORDS\n        xx = x&M; yy=y&M; // coord du tile\n#else\n        xx = x>>(Z-(i+1)); yy = y>>(Z-(i+1)); \n#endif\n\n        if (n<4.) {  // petit nombre\n            float n_=n;\n         // if (rnd3(xx,yy,0)<(n-int(n))) n++; n=int(n); // frac -> proba\n            if (rnd3(xx,yy,0)<fract(n)) n++; n=floor(n); // frac -> proba\n            if (n<1.) return; // zone de ciel noir\n#if 1\n            if (n_>=1.) { // on permute 1 etoile entre 2 fils (sinon 4 clones)\n#if COORDS\n                int u = int(rnd3(xx&~k,yy&~k,2)*16.); // 4 random bits\n                if ((bool(xx&k)==bool(u&1))&&(bool(yy&k)==bool(u&2))) n++;\n                if ((bool(xx&k)==bool(u&4))&&(bool(yy&k)==bool(u&8))) n--;\n#else\n                int u = int(rnd3(xx>>1,yy>>1,2)*16.); // 4 random bits\n                if ((bool(xx&1)==bool(u&1))&&(bool(yy&1)==bool(u&2))) n++;\n                if ((bool(xx&1)==bool(u&4))&&(bool(yy&1)==bool(u&8))) n--;\n#endif\n            }\n#endif\n            if (n<4.) break;\n        }\n    }\n\n#define SHOWTILE 2 // 1: tiles colorés 0: points+tiles 2: points ou tiles\n#define SHOWDENS 1\n\n#if 1\n    { // if (depth==Z) {\n    // petits n: on tire les coordonnées des etoiles\n    // puis on les dessine (integrale contrib sur pixel)\n    if (n<4.) {\n#define band 2.5 // 3 // bandguard au bords du tile\n        float x0=float(xx)+band*RAD, y0=float(yy)+band*RAD, l=float(k)-2.*band*RAD;\n        float x1 = x0+l*rnd3(xx,yy,1),  // au hasard dans le tile\n                y1 = y0+l*rnd3(xx,yy,2);\n        float v1, v2 = 0., v3 = 0. , x2,y2,x3,y3;\n        if (n>1.5) { // 2 etoiles\n            x2 = x0+l*rnd3(xx,yy,3), // au hasard dans le tile\n            y2 = y0+l*rnd3(xx,yy,4);\n            if (n>2.5) { // 3 etoiles\n                x3 = x0+l*rnd3(xx,yy,5), // au hasard dans le tile\n                y3 = y0+l*rnd3(xx,yy,6);\n            }\n        }\n\n        if ((SHOWTILE < 2)||(depth==Z)) { // on voit les points\n            float I = LUM*SQR(RAD)/SQR(scale); // intensité des étoiles\n            v1            = I*star(x1,y1,RAD, fx,fy,scale);\n            if (n>1.5) v2 = I*star(x2,y2,RAD, fx,fy,scale);\n            if (n>2.5) v3 = I*star(x3,y3,RAD, fx,fy,scale);\n        }\n\n#if\t SHOWTILE == 0      // points blancs\n        C.rgb = v1+v2+v3; \n        return; \n#elif SHOWTILE == 1     // points + tiles en couleur\n        // 1ere en blanc, 2eme en rouge, 3eme en bleu\n        C.r = v1+v2 + .05*int(n>1.5);\n        C.g = v1    + .05*int(n<1.5);\n        C.b = v1+v3 + .05*int(n>2.5);\n        return;\n#elif SHOWTILE == 2\n        if (depth==Z) {\n            C.rgb = vec3(v1+v2+v3);\n            return;\n        }\n        else {\n            M = -(1<<(Z-depth));\n            xx = x&M; yy=y&M; // coord du tile le plus fin (=LOD)\n            float v = 0.;     // on recalcule n dans ce tile\n            if (         ((int(floor(x1))&M)==xx)&&((int(floor(y1))&M)==yy)) v++;\n            if ((n>1.5)&&((int(floor(x2))&M)==xx)&&((int(floor(y2))&M)==yy)) v++;\n            if ((n>2.5)&&((int(floor(x3))&M)==xx)&&((int(floor(y3))&M)==yy)) v++;\n            float I = LUM*SQR(RAD);  // intensité des étoiles\n            C.rgb = vec3(v/float(M*M)*I);// gl_FragData[0].r=M/4.;\n            return;\n        }\n#endif\n\n    }\n    }\n#endif\n\n\n    // affichage là où on ne peut individualiser les etoiles\n#if SHOWDENS==1\n    // tracé des densités par tiles\n    float I = LUM*SQR(RAD); // /SQR(scale); // intensité des étoiles\n    C.rgb =  vec3(n/float(k*k)*I);\n#elif SHOWDENS==2\n    n = n/float(k*k)*20; // densité\n    // < moyenne: bleu\n    // > 16*moy: jaune\n    // > 80*moy: rouge\n    // au dela: vert\n    if (n<=1.)      C.b  = n;\n    else if (n<16.) C.rg = n/16.;\n    else if (n<64.) C.r  = n/64.;\n    else            C.g   = n/256.;\n#else\n    //   1..3   : draw\n    //   4..16  : jaune n/16\n    //  17..64  : blanc n/64\n    //  65..256 : bleu  n/256\n    // 257..    : vert  n/4096\n    if (n>256.)     C.g   = int(n)>>12; // n/4064\n    else if (n>64.) C.b   = int(n)>>8;  // n/256\n    else if (n>16.) C.rgb = int(n)>>6;  // n/64\n    else C.rg = int(n)>>4; // n/16\n#endif\n\n    return;\n}\n\n#undef Z\n#undef L\n\n// --- essai\n\nvoid draw_points0() {\n    float scale = 20.*xscale;\n    int Z=8; // / log2(scale)\n    int L=512;\n    float fx = (localCoord.x-.5)*scale + deltac;\n    float fy = (localCoord.y-.5)*scale + cmoy;\n    int x = int(floor(float(L)*fx));\n    int y = int(floor(float(L)*fy));\n    int xx=x, yy=y;\n    float p=1.; int r=1<<Z;\n    for(int i=0; i<Z; i++) {\n        //xx = (x/r); //xx*=r; \n        //yy = (y/r); //yy*=r; \n        p = rnd3(xx,yy,i)*pow(p,.25);\n        if (p < exp(-0.05*float(r*r))) return;\n        r /= 2;\n    }\n    C = vec4(1);\n}\n\n/* ============================================================== */\n\n#define shift   ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    localCoord = U/R.y;\n    if (iMouse.z>0.) { \n        if (shift) N = int(6.*iMouse.y/R.y);\n        else xscale *= 5.*iMouse.y/R.y;\n    }\n    draw_points();\n    O = C;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}