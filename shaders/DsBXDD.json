{
    "Shader": {
        "info": {
            "date": "1670284518",
            "description": "Simple denoising based on https://www.shadertoy.com/view/7lcyWM, which is a simplified variant of https://www.shadertoy.com/view/3dd3Wr\n\nLeft is unaltered, right is denoised.",
            "flags": 32,
            "hasliked": 0,
            "id": "DsBXDD",
            "likes": 6,
            "name": "Simple denoise",
            "published": 3,
            "tags": [
                "2d",
                "filter",
                "denoise"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "/*\nThe idea is to use a gaussian filter, but falling off\nby the difference of the currently sampled value\nto the value in the center of the kernel instead\nof spatial distance to the center.\n\nThis leads to edges to be much better preserved.\n\nMy changes are:\n\n* Using Vogel disk sampling for calculating sample positions\n* Additionally fall of based on spatial distance\n* Rename all variables to names i like more\n*/\n\nconst float num = 32.;\nconst float radius = 5.;\nconst float sigma = .3;\nconst float sigma2 = .05;\n\nvec4 denoise(sampler2D tex, vec2 uv, float num, float radius, float sigma, float sigma2)\n{\n\tfloat weight_sum = 0.;\n\tvec4 weighted_sum = vec4(0);\n    vec2 tex_size = vec2(textureSize(tex, 0));\n\n\tfor(float i=0.; i<num; i++){\n\t\tfloat angle = 2.3999629 * i;\n        float radius_squared = i / num;\n\n\t\tvec2 pos = sqrt(radius_squared) * vec2(sin(angle),cos(angle));\n\t\tvec4 value =  texture(tex, uv + radius * pos / tex_size);\n\n\t\tvec4 value_diff = value - texture(tex, uv);\n\t\tfloat weight = exp( -dot(value_diff, value_diff) * sigma -radius_squared * sigma2);\n\n\t\tweight_sum += weight;\n\t\tweighted_sum += weight * value;\n\t}\n\n    return weighted_sum / weight_sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(uv.x < .5){\n        fragColor = texture(iChannel0, uv);\n    }\n    else{\n        fragColor = denoise(iChannel0, uv, num, radius, sigma, sigma2);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float stripe_width = .1;\nconst float noise_amplitude = 1.7;\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\nfloat hash(vec2 uv)\n{\n    return float(iqint3(floatBitsToUint(uv))) / float(0xffffffffu) - .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspect_ratio = vec2(iResolution.x / iResolution.y, 1);\n    float col = .5 + .5 * sign(mod(uv.x + uv.y, stripe_width) - stripe_width * .5);\n    col *= step(distance(uv * aspect_ratio, vec2(.5) * aspect_ratio) - .2, .2);\n    col += noise_amplitude * hash(uv + iTime);\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}