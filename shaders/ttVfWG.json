{
    "Shader": {
        "info": {
            "date": "1615010383",
            "description": "The back is always empty! ",
            "flags": 0,
            "hasliked": 0,
            "id": "ttVfWG",
            "likes": 11,
            "name": "Super Jumbo Jet",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "plane",
                "airplane"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 379
        },
        "renderpass": [
            {
                "code": "// Cole Peterson (Plento)\n\n// A 2D infinite airplane !\n\n#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// Distance funcs from https://iquilezles.org/articles/distfunctions2d\nfloat box( in vec2 p, in vec2 b, float r){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Uneven capsule\nfloat ucap( vec2 p, float r1, float r2, float h ){\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n// Noise stuff\nfloat rand(vec2 n){ \n\treturn fract(sin(dot(n, vec2(17.12037, 5.71713))) * 12345.6789);\n}\nfloat noise(vec2 n){\n\tvec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b + d.xx), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm(vec2 n, float t){\n\tfloat sum = 0.0, amp = 1.0;\n\tfor (int i = 0; i < 10; i++){\n        n.x += t;\n\t\tsum += noise(n) * amp;\n\t\tn += n;\n\t\tamp *= 0.5;\n\t}\n\treturn sum;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 nv = uv;\n    \n    // Time scrubbing\n    float t = iTime + iMouse.x*.02 + 3.;\n    \n    // Slight curvyness\n    float k = exp((sin(uv.y*4. - 1.55)))+0.8;\n    uv.x *= k;\n    uv.x += t*.2;\n    \n    // Noise for clouds and fuselage\n    float nse = fbm(5.*vec2(uv.x, uv.y*14.5), 0.)-.5;\n    float nse2 = fbm(nv*4., iTime*.14)-.5;\n    vec3 cloud = vec3(nse2)*0.7;\n    \n    // Bg color\n    vec3 col = mix(vec3(.7, .8, .99), vec3(.8, .8, .8), nv.y) + cloud*cloud*.5;\n    \n    // plane base color\n    vec3 pcol = .97*abs(uv.y+.6)*vec3(.95, .95, 1.)*1.1;\n    \n    // Add the line details\n    pcol -= .04*ss(.004, .000, abs(uv.y-.02 + nse*.002));\n    pcol -= .05*ss(.008, .00, abs(uv.y+.2 + nse*.002));\n    \n    // Add metal like shine and noise\n    vec3 shn = vec3(.85, .9, .9)*.12*ss(-.99, .99, cos(uv.x*5.));\n    pcol += shn;\n    pcol -= nse*.03;\n    \n    // Darken underside \n    pcol *= max(ss(.01, .24, abs(uv.y+.36)), .8);\n    \n    // Add the fuselage\n    col = mix(col, pcol, ss(.3 + .005, .3, abs(uv.y)));\n    \n    // Window coords\n    vec2 wv = uv*4.;\n    wv.x = mod(wv.x, 1.)-.5;\n    \n    // Window color\n    vec3 winc = nse*.04+(.8+.08*cos(uv.x*20. + k*10.))*vec3(.75, .85, .98)+uv.y*4.;\n    \n    // Window shape\n    float window = box(wv, vec2(.1, .15), .07);\n    \n    // Add windows\n    col = mix(winc, col, ss(-.006, .006, window));\n    col -= .3*ss(.013, .002, abs(window-.02));\n    \n    // Exit door coord\n    vec2 exv = uv*2.;\n    exv.x = mod(exv.x+.3, 8.)-8.*.5;\n    \n    // Exit door shape\n    float ex = box(exv, vec2(.13, .17), .07);\n    float exw = box(exv-vec2(0., .1), vec2(.04, .05), .02);\n    \n    // Add door color\n    col = mix(shn*.5+vec3(.65)+nse*.04+cos(exv.y*10.+exv.x*10.)*.04, col, ss(.0, .01, ex));\n    col += ss(.01, .0, exw)*vec3(0.7, 0.85, 0.99)*.13;\n    col -= .4*ss(.006, -.006, abs(ex) - .001);\n    col -= .7*ss(.007, -.007, abs(exw)-.001);\n    col -= .3*ss(.004, -.004, abs(length(exv-vec2(.1, -.04))-.016)-.002);\n    \n    // Engine/ wing coords\n    vec2 ev = nv;\n    ev.x = mod(ev.x + t*.18, 2.5)-.5*2.5 + .25;\n    \n    // Engine shape\n    float eh = exp(-(ev.x*ev.x)*18.)*.1*sign(uv.y);\n    float eng = box(ev-vec2(0., -.31), vec2(.15, .03 - eh*.4), .02);\n    eng = min(eng, box(ev-vec2(0.04, -.31), vec2(.18, .03), .02));\n    \n    // Engine color\n    vec3 ecol = ss(.2, .3, abs(ev.y))*vec3(.5) + cos(ev.y*50.)*.07;\n    ecol -= .2*ss(.005, 0.0, abs(abs(ev.x-.04)-.13));\n    \n    // Add engines\n    col = mix(ecol, col, ss(-.001, .001, eng));\n    col *= ss(.0, .003, abs(eng)-.001);\n    \n    ev.x-=.25;\n    // Wing shape and color\n    float wing = ucap(rot(1.55)*(ev-vec2(.7, -.2)), .02, .06, 1.3);\n    vec3 wcol = 1.7*max(ss(.21, .4, abs(ev.y+.5))*vec3(.5), .1) + nse*.03;\n    \n    // Add wing\n    col = mix(wcol, col, ss(-.001, .001, wing));\n    col *= ss(-.002, .002, abs(wing)-.001);\n    \n    // Add a bit of sky blue-ness to everything\n    col += vec3(0., .01, .026)*.7;\n    \n    // Makes it pop a bit\n    col = col*col*col*col*col*1.3;\n    \n    // A tiny bit of cloud in foreground\n    col += (-nv.y-.05)*cloud*cloud*cloud*.6;\n    \n    // Smoothly clamp values > 1\n    col = 1.-exp(-col*1.3);\n    \n    // Side darkening\n    col *= ss(.95, .7, abs(nv.x));\n    \n    // Intro thing\n    if(iTime < 2.)\n        col *= ss(0.001, -0.001, length(nv)-iTime*1.6);\n    \n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}