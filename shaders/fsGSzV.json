{
    "Shader": {
        "info": {
            "date": "1634990564",
            "description": "some insta-like effect but for webcam",
            "flags": 2,
            "hasliked": 0,
            "id": "fsGSzV",
            "likes": 24,
            "name": "Refraction Metaballs",
            "published": 3,
            "tags": [
                "raymarching",
                "metaballs",
                "refraction",
                "webcam"
            ],
            "usePreview": 1,
            "username": "luckyballa",
            "viewed": 1094
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 40\n#define MAX_DIST 40.\n#define SURF_DIST .005\n#define samples 32\n#define LOD 2\n\nfloat hash(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 184.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(hash(b), hash(b + d.yx), f.x), mix(hash(b + d.xy), hash(b + d.yy), f.x), f.y);\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k; \n}\n\nfloat getDist(vec3 p) {\n    float final = MAX_DIST;\n    float iTime = iTime; \n    p = p - vec3(0.,0.5, 5.);\n    for (int i = 0; i < 10; i++) {\n        float iF = float(i);\n        float fi = iF + floor(iF / 5.);\n        vec3 pos = p;\n        pos.xy += vec2(sin(iTime + fi), cos(iTime + fi * 2.)) * 0.4;\n        pos.z += sin(iTime * cos(float(i * 4))) * 0.2;\n        float r = sin(fi + 1.) * 0.15;\n        float n = min(sin(pos.z * iF * 5.), cos(pos.x * pos.y * iF * 10.)) * 0.1;\n        float bubble = sdSphere(pos + vec3(n) * 0.1 - vec3(0.05), r);\n        \n        final = smin(final, bubble, 0.4);\n    }\n\n    \n    return final;\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float res = getDist(p);\n        float dS = res;\n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    return dif;\n}\n\nfloat gaussian(vec2 i) {\nconst float sigma = float(samples) * .25;\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    const int  sLOD = 1 << LOD;\n    vec4 O = vec4(0);\n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * texture(sp, U + scale * d);\n    }\n    \n    return O / O.a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro = vec3(.0, 0., 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y + 0.2 , 2.));\n    vec3 ld =  vec3(0., 0., 1.);\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = normals(p, 0.03);\n    float dif = diffuse(p, n, ld); \n    float fresnel = smoothstep(0.5, 0.3, dot(-rd, n));\n    vec3 oil = vec3(noise(n.xy * 2.7), noise(n.xy * 3.), noise(n.xy * 3.3)); \n    \n    vec2 camUV = fragCoord / iResolution.xy;\n    vec3 cam1 = texture(iChannel0, camUV).xyz * 0.9;\n    camUV += n.xy * 0.05 * dif;\n    vec3 cam2 = blur(iChannel0, camUV, 1./iResolution.xy).xyz * 0.9;\n    vec3 dispersion = vec3(0.);\n    dispersion.r = texture(iChannel0, vec2(camUV.x - n.x * 0.0075,camUV.y)).r;\n    dispersion.g = texture(iChannel0, camUV).g;\n    dispersion.b = texture(iChannel0, vec2(camUV.x + n.y * 0.0075, camUV.y)).b;\n\n    col = dif * cam2;\n    col += cam2 * 0.15;         \n    col += oil * 0.4;\n    col += fresnel * 0.3;\n    col = mix(col, dispersion, (abs(n.x) + abs(n.y)) * 0.3);\n    \n    if (d > MAX_DIST) { col = vec3(cam1);  }\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}