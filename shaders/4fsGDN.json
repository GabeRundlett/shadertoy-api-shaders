{
    "Shader": {
        "info": {
            "date": "1706791549",
            "description": "Strongly inspired by https://www.shadertoy.com/view/clKfWm by afl_ext",
            "flags": 0,
            "hasliked": 0,
            "id": "4fsGDN",
            "likes": 12,
            "name": "_Overcast clouds inspired",
            "published": 3,
            "tags": [
                "clouds"
            ],
            "usePreview": 0,
            "username": "pk1234",
            "viewed": 320
        },
        "renderpass": [
            {
                "code": "// shader strongly based on what I've seen in \n// https://www.shadertoy.com/view/clKfWm by afl_ext,\n// and other shaders like Clouds by iq, and Cloud Ten by nimitz\n\nconst float start_plane = 10.;\nconst float end_plane = 20.;\n\n/////////////////\n// density params - in general, we want density to increase as we go higher,\n/////////////////\n// having density 0. at start layer and 1. at end layer seems like a good default\n\n// reaching 1. faster, e.g. 2. -> clouds really fill sky, darker\n// reaching 1. slower, e.g 0.5 -> fewer clouds, lighter\nfloat density_grad_invspeed = 1.; // 1.\n\n// exponent of density gradient, has similar effect to the above,\n// adjusting this rather might also provide a bit of a nicer \"bouncy\" shape?\nfloat density_grad_pow = 0.8; //1.\n\n// higher value makes the cloud more scarce too\nfloat dens_tm_low_thr = 0.0; // 0.\n// lower value can promote a \"sharper\" look of the cloud creases\n// might only be due to the total (dens_tm_high_thr - dens_tm_low_thr) value,\n// as that value being low corresponds to raising the derivative\nfloat dens_tm_high_thr = 0.45; // 1.\n\n\n// raise in scattering contribution gradually as we go up\n// reaching 1. slightly earlier than top seems good\nfloat scattering_grad_invspeed = 0.9; // 1.\n// using 2. makes the bright creases a bit more pronounced\nfloat scattering_grad_pow = 1.75; //1.\n\nconst mat3 fbm_mat = mat3(\n2./3., 2./3., -1./3.,\n-1./3., 2./3., 2./3.,\n2./3., -1./3., 2./3.);\n\nconst mat3 fbm_mat2 = mat3(\n0.6, 0., 0.8,\n0., 1., 0.,\n-0.8, .0, 0.6);\n\n\n\n\n\nfloat rand(vec3 pos){\n    vec3 v = vec3(1234.1234, 2345.2345, 3456.3456);\n    return fract(1234.1234 * sin(dot(pos, v)));\n}\n\nfloat val_noise(vec3 pos){\n    vec3 pos_fract = fract(pos);\n    vec3 pos_floor = floor(pos);\n    \n    float e000 = rand(pos_floor + vec3(0.,0.,0.));\n    float e100 = rand(pos_floor + vec3(1.,0.,0.));    \n    float e010 = rand(pos_floor + vec3(0.,1.,0.));\n    float e110 = rand(pos_floor + vec3(1.,1.,0.)); \n    \n    float e001 = rand(pos_floor + vec3(0.,0.,1.));\n    float e101 = rand(pos_floor + vec3(1.,0.,1.));    \n    float e011 = rand(pos_floor + vec3(0.,1.,1.));\n    float e111 = rand(pos_floor + vec3(1.,1.,1.));\n    \n    // interpolate across x axis\n    float eX00 = mix(e000, e100, pos_fract.x);\n    float eX10 = mix(e010, e110, pos_fract.x);\n    float eX01 = mix(e001, e101, pos_fract.x);\n    float eX11 = mix(e011, e111, pos_fract.x);\n    \n    float eXY0 = mix(eX00, eX10, pos_fract.y);\n    float eXY1 = mix(eX01, eX11, pos_fract.y);\n    \n    float eXYZ = mix(eXY0, eXY1, pos_fract.z);\n    \n    return eXYZ;\n}\n\nfloat val_noise_super(vec3 pos){\n    float a = val_noise(pos);\n    float b = val_noise(pos + 13.5);\n    return (a+b)*0.5;\n}\n\nfloat fbm(vec3 pos){\n    pos += vec3(0., -iTime * 0.25, +iTime * 1.2);\n\n    // adjust pos scale by approximately 1/end_plane\n    pos *= 0.0488;    \n    \n    float sum = 0.;\n    float amplitude = 0.5;\n    \n    for (int i = 0; i<6; ++i){\n        float noise = val_noise_super(pos);\n        \n        // adjust noise shape\n        noise = (noise-0.5) * 2.; // [-1,1]\n        noise = abs(noise);\n        \n        // add it\n        sum += amplitude * noise;\n        \n        amplitude *= 0.6;\n        //pos *= fbm_mat;\n        pos *= fbm_mat2;\n        pos *= 2.03;\n        \n    }\n    \n    return clamp(sum * 2., 0.,1.);\n}\n\nvec2 cloud_info(vec3 pos){\n\n    // density\n    float fbm_val = fbm(pos) - 1.; // in [-1, 0]\n    \n    // density\n    float density_gradient = (pos.y - start_plane) / (density_grad_invspeed * (end_plane - start_plane));\n    density_gradient = clamp(density_gradient, 0., 1.);\n    \n    // adjust shape of the gradient\n    density_gradient = pow(density_gradient, density_grad_pow);\n    \n    float density = clamp(fbm_val + density_gradient, 0., 1.);\n    \n    \n    // scattering\n    float scattering_grad = (pos.y - start_plane) / (scattering_grad_invspeed * (end_plane - start_plane));\n    scattering_grad = clamp(scattering_grad, 0., 1.);\n    \n    // adjust shape of the scatter - make it more pronounced at large heights\n    scattering_grad = pow(scattering_grad, scattering_grad_pow);\n    \n    float scattering = clamp(scattering_grad, 0., 1.);\n    \n    return vec2(density, scattering);\n}    \n\nmat2 rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c);\n}\n\n\nfloat lerp_step(float a, float b, float x){\n    float v = (x-a) / (b-a);\n    return clamp(v, 0.,1.);\n}\n\nconst float num_steps = 64.;\n\nvec3 raymarch_clouds(vec3 start, vec3 end){\n    \n    vec4 sum_col = vec4(0.);\n    for (float i = 0.; i<num_steps; ++i){\n        if (sum_col.a > 0.98) break;\n    \n        // get pos where we will sample cloud density\n        vec3 pos = mix(start, end, i/num_steps);\n        \n        // get cloud info\n        vec2 cloud_info = cloud_info(pos);\n        float density = cloud_info.x;\n        float scattering = cloud_info.y;\n        \n        // scale the density\n        density = lerp_step(dens_tm_low_thr, dens_tm_high_thr, density);\n        \n        // scattering\n        scattering = lerp_step(0.0, 1., scattering);\n        \n        // set col element for current sample\n        vec4 col;\n        col.rgb = vec3(scattering) * 1.0;\n        col.a = density * 1.0;\n        \n        // premultiply alpha\n        col.rgb *= col.a;\n        \n        sum_col += (1. - sum_col.a) * col;\n        \n    }\n    \n    return sum_col.rgb * 1.;\n}\n\n// debug function, returns the \"accumulated\" density along a ray\nfloat raymarch_clouds_debug(vec3 start, vec3 end){\n    \n    float sum = 0.0;\n    \n    // measure length of single step by comparing start and vector after 1 step\n    float step_size = length(mix(start, end, 1./num_steps) - start);\n    \n    for (float i = 0.; i<num_steps; ++i){\n        // get pos where we will sample cloud density\n        vec3 pos = mix(start, end, i/num_steps);\n        \n        // get cloud info\n        vec2 cloud_info = cloud_info(pos);\n        float density = cloud_info.x;\n        \n        sum += density * step_size;        \n    }\n    \n    return sum;      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_screen_space = fragCoord/iResolution.xy;\n    vec2 uv = (uv_screen_space - 0.5) * 2.;\n    // ro, rd\n    vec3 ro = vec3(0,0,0);\n    vec3 rd = vec3(uv.x, uv.y, 1.2);\n    rd = normalize(rd);\n    \n    // mouse\n    if (iMouse.z > 0.){\n    vec2 m = iMouse.xy/iResolution.xy - 0.5;\n    rd.yz *= rot(m.y * 3.14);\n    rd.xz *= rot(m.x * 3.14);\n    }\n    \n    vec3 col = vec3(0);\n    if (rd.y > 0.){\n        float t_start = abs(start_plane - ro.y) / abs(rd.y);\n        float t_end = abs(end_plane - ro.y) / abs(rd.y);\n        \n        vec3 start = ro + rd * t_start;\n        vec3 end = ro + rd * t_end;\n        \n        \n        if (uv_screen_space.x < (iMouse.x/iResolution.x) || true){\n            col = raymarch_clouds(start, end) * 1.2;\n        }\n        \n        else{\n            float accumulated_density = raymarch_clouds_debug(start, end);\n            accumulated_density *= 0.5;\n            col = vec3(accumulated_density);\n        }\n        \n        float fog = clamp(exp(-t_start * 0.0025), 0., 1.);\n        \n        col = mix(vec3(0), col, fog);\n    }   \n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}