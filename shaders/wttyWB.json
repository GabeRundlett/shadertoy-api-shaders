{
    "Shader": {
        "info": {
            "date": "1609858256",
            "description": "salut",
            "flags": 0,
            "hasliked": 0,
            "id": "wttyWB",
            "likes": 3,
            "name": "temp toto",
            "published": 3,
            "tags": [
                "cineshader"
            ],
            "usePreview": 0,
            "username": "sixclones",
            "viewed": 9535
        },
        "renderpass": [
            {
                "code": "// Author Tom Brewe 2017\n\n/*#ifdef GL_ES\nprecision mediump float;\n#endif*/\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n   return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in float x) {\n   \n   // split x int its integer and fraction.\n   float i = floor(x);\n   float f = fract(x);\n   \n   float r = random(vec2(i, 1.0));\n   float r_next = random(vec2(i + 1.0, 1.0));\n   // return r;\n   // return mix(r, r_next, f);\n   return mix(r, r_next, smoothstep(0.0, 1.0, f));\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n   _st -= 0.5;\n   _st =  mat2(cos(_angle),-sin(_angle),\n   sin(_angle),cos(_angle)) * _st;\n   _st += 0.5;\n   return _st;\n}\n\n\nfloat posSin(in float val) {\n   return (sin(val) + 1.0) / 2.0;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    // make it perfectly square\n   float aspect = iResolution.y / iResolution.x; \n   _st.y *= _zoom * aspect;\n   _st.x *= _zoom;\n   return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.y * uv.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n   // noisify ALL the values!!!1\n   \n   vec2 st = fragCoord.xy / iResolution.xy;\n   vec3 color = vec3(0.0);\n   float tileNum = 3. + noise(iTime * 0.1 + 59349.0) * 5.;\n   \n   // Save original coordinates for later\n   vec2 st_orig = st;\n   \n   // Divide the space in tileNum (eg. 5)\n   st = tile(st, tileNum);\n   \n   // Calculate distance of vec(sinus time) and the actual position\n   float dist = distance(st_orig, vec2(noise(iTime), noise(iTime + 3000.)));\n   \n   // maxDist defines the radius of effect\n   // lower it, to see the diagonal movement (eg. try 0.1 * ...)\n   float maxDist = 1.0 * noise(iTime + 22355.);\n   \n   float rotation = smoothstep(0.0, maxDist, dist);\n   \n   // Use a matrix to rotate the space\n   st = rotate2D(st, PI * rotation);\n   \n   // Draw a square\n   color = vec3(box(st,vec2(0.7),0.01));\n   // fade gray along the x axis of each square\n   float fade = st.x;\n   \n   color *= mix(color, vec3(fade), (cos(iTime) + 1.0) * 0.5);\n   color *= vec3(noise(iTime * 0.5 + 1000.), noise(iTime * 0.5), noise(iTime + 800. * 0.5));\n   \n   fragColor = vec4(color, color.r * dist);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Wobbly Wob\",\n\t\"description\": \"Wobbly wobs wobblying around.\",\n\t\"model\": \"person\"\n}\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* //drag the window LR to control roughness\n\n//--graphics setting (lower = better fps)---------------------------------------------------------------------\n#define AVERAGECOUNT 16\n#define MAX_BOUNCE 32\n\n//--scene data---------------------------------------------------------------------\n#define SPHERECOUNT 6\n//xyz = pos, w = radius\nconst vec4 AllSpheres[SPHERECOUNT]=vec4[SPHERECOUNT](\n    vec4(0.0,0.0,0.0,2.0),//sphere A\n    vec4(0.0,0.0,-1.0,2.0),//sphere B\n    vec4(0.0,-1002.0,0.0,1000.0),//ground\n    vec4(0.0,0.0,+1002,1000.0),//back wall\n    vec4(-1004.0,0.0,0.0,1000.0),//left wall    \n    vec4(+1004.0,0.0,0.0,1000.0)//right wall\n);\n//-----------------------------------------------------------------------\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n//-----------------------------------------------------------------------\nstruct HitData\n{\n    float rayLength;\n    vec3 normal;\n};\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)\n{\n    HitData hitData;\n    hitData.rayLength = 999999.0;\n\n    for(int i = 0; i < 6; i++)\n    {\n        vec3 sphereCenter = AllSpheres[i].xyz;\n        float sphereRadius = AllSpheres[i].w;\n        //----hardcode sphere pos animations-------------------------------------\n        if(i == 0)\n        {\n            float t = fract(iTime * 0.7);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 0.7;\n            \n            sphereCenter.x += sin(iTime) * 2.0;\n            sphereCenter.z += cos(iTime) * 2.0;\n        }\n             \n        if(i == 1)\n        {\n            float t = fract(iTime*0.47);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 1.7;\n            \n            sphereCenter.x += sin(iTime+3.14) * 2.0;\n            sphereCenter.z += cos(iTime+3.14) * 2.0;\n        }             \n        //---------------------------------------\n                \n        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);\n        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)\n        {\n            //if a shorter(better) hit ray found, update\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n    \t\thitData.normal = normalize(hitPos - sphereCenter);\n        }\n    }\n    \n    //all test finished, return shortest(best) hit data\n    return hitData;\n}\n//--random functions-------------------------------------------------------------------\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)\n{\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n//---------------------------------------------------------------------\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex)\n{\n    //init\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n    \n    //only for CineShader, to show depth\n    float firstHitRayLength = -1.0;\n    \n    //can't write recursive function in GLSL, so write it in a for loop\n    //will loop until hitting any light source / bounces too many times\n    for(int i = 0; i < 16; i++)\n    {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001,rayDir);//+0.0001 to prevent ray already hit @ start pos\n        \n        //only for CineShader, to show depth\n        firstHitRayLength = firstHitRayLength < 0.0 ? h.rayLength : firstHitRayLength;\n        \n        if(h.rayLength > 99999.0)\n        {\n            vec3 skyColor = vec3(0.7,0.85,1.0);//hit nothing = hit sky color\n            finalColor = skyColor * absorbMul;\n            break;\n        }   \n               \n\t\tabsorbMul *= 0.8; //every bounce absorb some light(more bounces = darker)\n        \n        //update rayStartPos for next bounce\n\t\trayStartPos = rayStartPos + rayDir * h.rayLength; \n        //update rayDir for next bounce\n        float rougness = 0.05 + iMouse.x / iResolution.x; //hardcode \"drag the window LR to control roughness\"\n\t\trayDir = normalize(reflect(rayDir,h.normal) + randomInsideUnitSphere(rayDir,rayStartPos,AAIndex) * rougness);       \n    }\n    \n    return vec4(finalColor,firstHitRayLength);//alpha nly for CineShader, to show depth\n}\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; //aspect fix\n\n    vec3 cameraPos = vec3(sin(iTime * 0.47) * 4.0,sin(iTime * 0.7)*8.0+6.0,-25.0);//camera pos animation\n    vec3 cameraFocusPoint = vec3(0,0.0 + sin(iTime),0);//camera look target point animation\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n    \n    //TEMPCODE: fov & all ray init dir, it is wrong!!!!\n    //----------------------------------------------------\n    float fovTempMul = 0.2 + sin(iTime * 0.4) * 0.05;//fov animation\n    vec3 rayDir = normalize(cameraDir + vec3(uv,0) * fovTempMul);\n    //----------------------------------------------------\n\n    vec4 finalColor = vec4(0);\n    for(int i = 1; i <= 16; i++)\n    {\n        finalColor+= calculateFinalColor(cameraPos,rayDir, float(i));\n    }\n    finalColor = finalColor/float(AVERAGECOUNT);//brute force AA & denoise\n    finalColor.rgb = pow(finalColor.rgb,vec3(1.0/2.2));//gamma correction\n    \n    //only for CineShader, to show depth\n    float z = finalColor.w; //z is linear world space distance from camera to surface\n    float cineShaderZ; //expect 0~1\n    cineShaderZ = pow(clamp(1.0 - max(0.0,z-21.0) * (1.0/6.0),0.0,1.0),2.0);\n    \n    //result\n    fragColor = vec4(finalColor.rgb,cineShaderZ);\n} */\n\n\n\n\n\n\n\n\n// ==============\n//  `GL_ES` TEST\n// ==============\n\n/* precision mediump float;\n\n#define RADIANS 0.017453292519943295\n\nconst int zoom = 40;\nconst float brightness = 0.975;\nfloat fScale = 1.25;\n\nfloat cosRange(float degrees, float range, float minimum) {\n\treturn (((1.0 + cos(degrees * RADIANS)) * 0.5) * range) + minimum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 1.25;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p  = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfloat ct = cosRange(time*5.0, 3.0, 1.1);\n\tfloat xBoost = cosRange(time*0.2, 5.0, 5.0);\n\tfloat yBoost = cosRange(time*0.1, 10.0, 5.0);\n\t\n\tfScale = cosRange(time * 15.5, 1.25, 0.5);\n\t\n\tfor(int i=1;i<zoom;i++) {\n\t\tfloat _i = float(i);\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.25/_i*sin(_i*p.y+time*cos(ct)*0.5/20.0+0.005*_i)*fScale+xBoost;\t\t\n\t\tnewp.y+=0.25/_i*sin(_i*p.x+time*ct*0.3/40.0+0.03*float(i+15))*fScale+yBoost;\n\t\tp=newp;\n\t}\n\t\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(p.x+p.y));\n\tcol *= brightness;\n    \n    // Add border\n    float vigAmt = 5.0;\n    float vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));\n\tfloat extrusion = (col.x + col.y + col.z) / 4.0;\n    extrusion *= 1.5;\n    extrusion *= vignette;\n    \n\tfragColor = vec4(col, extrusion);\n}\n\n\n\n\n\n\n\n\n// ============\n//  MODEL TEST\n// ============\n\n/** SHADERDATA\n{\n\t\"title\": \"70s Melt\",\n\t\"description\": \"Variation of Sine Puke\",\n\t\"model\": \"car\"\n}\n*/\n\n\n\n\n/* void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Pirellyon\",\n\t\"description\": \"Next world\",\n\t\"model\": \"nothing\"\n}\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}