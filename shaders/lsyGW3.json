{
    "Shader": {
        "info": {
            "date": "1456670506",
            "description": "Inspired by https://www.youtube.com/watch?v=sbNxc2l98YY",
            "flags": 0,
            "hasliked": 0,
            "id": "lsyGW3",
            "likes": 0,
            "name": "Spacetime Warp",
            "published": 3,
            "tags": [
                "time",
                "space",
                "warp",
                "distance"
            ],
            "usePreview": 0,
            "username": "DrLuke",
            "viewed": 1921
        },
        "renderpass": [
            {
                "code": "/* \n\n\tInspired by this excellent video: https://www.youtube.com/watch?v=sbNxc2l98YY\n\n*/\n\n\n/* Simple rotation matrix, feel free to take it for your own shaders! */\nmat2 rotationMat(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n/*\n\tBig thanks to Inigo Quilez for those distance functions:\n*/\n\n/* https://www.shadertoy.com/view/XsXSz4 */\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n/* https://www.shadertoy.com/view/4llXD7 */\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    float d = (m.x > 0.0) ? length(q) : m.y; \n    return d - r;\n}\n\nfloat distance_segment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n// Lower edge of timewarp\n#define LOW -0.5\n// Upper edge of timewarp\n#define HIGH 0.5\n\n// These functions evalute to 1 below, above and in the middle of the timewarp respectively\n#define BELOW step(-LOW, -uv.x)\n#define ABOVE step(HIGH, uv.x)\n#define BETWEEN 1.0 - (step(-LOW ,-uv.x) + step(HIGH, uv.x))\n\n// Warp the UV coordinate to be 0 in the \"warpzone\" and continue seamlessly to the left and right\n#define UV vec2(-(uv.x - (BELOW*LOW) - (ABOVE*HIGH))*(1.0-BETWEEN) , uv.y)\n\n// On the left side, time runs normally, while time on the right side runs a bit further in the future.\n// The middle part is a linear ramp from current time to slightly future time, giving the neat illusion\n#define T (iTime*0.6 + clamp(uv.x, LOW, HIGH)*10.0)\n\nvec3 bgNormals(vec2 uv, vec2 uv2)\n{   \n    uv2.x *= iResolution.y / iResolution.x;\n    vec3 waveval = vec3(0.0);\n\tfor(int i = 0; i < 64; i++)\n    {\n        vec3 sam = texture(iChannel0, vec2(float(i)*0.9, uv2.y*0.3 + T*0.1)/32.0).rgb;\n        \n        waveval.r += sin(uv2.x*32.0 - (float(i)-31.5))/(uv2.x*32.0 - (float(i)-31.5))*sam.r*0.5;\n        waveval.g += sin(uv2.x*32.0 - (float(i)-31.5))/(uv2.x*32.0 - (float(i)-31.5))*sam.g*0.5;\n        waveval.b += sin(uv2.x*32.0 - (float(i)-31.5))/(uv2.x*32.0 - (float(i)-31.5))*sam.b*0.5;\n    }\n    \n    //waveval /= 8.0;\n    \n    return waveval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0 / iResolution.xy)-vec2(1);\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    mat2 rotMat = rotationMat(T*0.4);\n    \n    vec2 p = vec2(sin(T*0.467)*0.5 + 0.0, sin(T*0.246)*0.3 + 0.3);\n    vec2 p0 = p + rotMat*vec2(-.2,-.2);\n    vec2 p1 = p + rotMat*vec2(.0,.1 + sin(T*1.4)*0.1);\n    vec2 p2 = p + rotMat*vec2(.2,-.2);\n    \n    float d = abs(sdTriangle(p0, p1, p2, UV));\n    \n    d = min(d, abs(sdRoundBox(UV-p, vec2(0.7,0.4 + sin(T*0.7)*0.05), 0.1 + sin(T)*0.1)) );\n    \n    rotMat = rotationMat(T*0.6);\n    p = vec2(0.1,-0.8);\n    p0 = p - rotMat*vec2(-0.2,0);\n    p1 = p - rotMat*vec2(0.2,0);\n    \n    d = min(d, distance_segment(UV, p0,p1));\n    \n    vec3 ret = normalize(bgNormals(uv, UV) * vec3(0.5, 0.1, 0.6) + vec3(0.2))*(0.5 + (1.0-UV.y)*0.3);\n    \n    //fragColor = vec4(smoothstep(-0.01,-0.0,-abs(d)),ret.r,0,1.0);\n    fragColor = vec4(mix(ret,(vec3(0.4)-ret).grg, smoothstep(-0.015, -0.01, -d)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}