{
    "Shader": {
        "info": {
            "date": "1575864548",
            "description": " forked from https://www.shadertoy.com/view/wdVSR3\n\nHit spacebar to reset.",
            "flags": 48,
            "hasliked": 0,
            "id": "Wlc3zM",
            "likes": 7,
            "name": "forwards backwards",
            "published": 3,
            "tags": [
                "fluid",
                "mipmap",
                "dynamics",
                "mip",
                "multiscale",
                "cfd"
            ],
            "usePreview": 0,
            "username": "merlinbr",
            "viewed": 474
        },
        "renderpass": [
            {
                "code": "// Fork of \"Faster Multiscale MIP Fluid\" by cornusammonis. https://shadertoy.com/view/wdVSR3\n// 2019-12-09 00:39:59\n\n/*\n\tFor long-time Shadertoyers, you may notice that this bears a striking\n\tresemblance to Florian Berger's \"Spilled\" shader here: \n\t\thttps://www.shadertoy.com/view/MsGSRd\n\n\tI've used the same visualization code for the sake of comparison\n\t(and of course convenience).\n\n\tIn the spite of the visual similarity, the CFD algorithm itself bears \n\tnothing at all in common at first glance. Nonetheless, the resemblance\n\tis not a coincidence. This is not at all obvious without some fairly\n\tdeep analysis, but Florian's shader and mine are actually both \n\tapproximations of the same distribution, which boils down to sums of\n    second partial derivatives, which can be found here in the viscous stress \n\tportion of the filtered Navier-Stokes equations:\n\thttps://en.wikipedia.org/wiki/Large_eddy_simulation\n\n\tI may be wrong on this relation to Navier-Stokes, tell me if you\n\tknow otherwise.\n\n\tAt any rate, benchmarking this using Shadertoy Unofficial Plugin, here:\n\t\thttps://github.com/patuwwy/ShaderToy-Chrome-Plugin\n\tit can run at about 2400fps at 800x450, which is the default resolution \n\tfor me without going in fullscreen, or about 1100fps at 1200x675 on a 980Ti\n\t(64x paint calls). Pretty good! It runs well at 4K widescreen, but I'm not \n\tsure how to benchmark that in a browser.\n*/\n\n// This license applies to the visualization code below:\n/* \n\tCreated by florian berger (flockaroo) - 2016\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).xyy + 0.5f, 1.0f);\n    return;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),120.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*1.0;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tCreated by Cornus Ammonis (2019)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n\tFor long-time Shadertoyers, you may notice that this bears a striking\n\tresemblance to Florian Berger's \"Spilled\" shader here: \n\t\thttps://www.shadertoy.com/view/MsGSRd\n\n\tI've used the same visualization code for the sake of comparison\n\t(and of course convenience).\n\n\tIn the spite of the visual similarity, the CFD algorithm itself bears \n\tnothing at all in common at first glance. Nonetheless, the resemblance\n\tis not a coincidence. This is not at all obvious without some fairly\n\tdeep analysis, but Florian's shader and mine are actually both \n\tapproximations of the same distribution, which boils down to sums of\n    second partial derivatives, which can be found here in the viscous stress \n\tportion of the filtered Navier-Stokes equations:\n\thttps://en.wikipedia.org/wiki/Large_eddy_simulation\n\n\tI may be wrong on this relation to Navier-Stokes, tell me if you\n\tknow otherwise.\n\n\tAt any rate, benchmarking this using Shadertoy Unofficial Plugin, here:\n\t\thttps://github.com/patuwwy/ShaderToy-Chrome-Plugin\n\tit can run at about 2400fps at 800x450, which is the default resolution \n\tfor me without going in fullscreen, or about 1100fps at 1200x675 on a 980Ti\n\t(64x paint calls). Pretty good! It runs well at 4K widescreen, but I'm not \n\tsure how to benchmark that in a browser.\n*/\n\nbool reset() {\n    return \n        texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5\n        || texture(iChannel0,vec2(0)) == vec4(0);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define VELOCITY 1.0f\n#define SMEARING 0.5f\n#define ACCELERATION 0.0f\n#define DIFFERENCE (0.4f * (float(4) / 100.f))\n\nvec4 circle(vec2 circle_pos, float radius, vec4 circle_color, vec2 frag_pos, vec4 frag_color) {\n   vec2 dist = frag_pos - circle_pos;\n   if (dot(dist, dist) < radius*radius)\n       return circle_color;\n    else\n        return frag_color;\n}\n\n// neighbor from ´center´, pixels x y multiplied with 1<<level\n#define C(x,y) textureLod(iChannel0, t*(center+float(1<<level)*vec2(x,y)),float(level))\nvec2 slurp(vec2 center) {\n    vec2 t = 1./iResolution.xy, q = center*t - .5;\n    // copy a pixel from center+slurp to center\n    // (bc we cannot push this pixel according to the velocity, we slurp it)\n    vec2 slurp = vec2(0.f);\n    for (int level = 7; level >= 2; level--) {\n        vec2 s_velocity = // velocity for mipmap level s\n            -2.0 * vec2(C(0,1).x + C(0,-1).x, C(1,0).y + C(-1,0).y)\n            +4.0 * C(0,0).xy \n            - (C(1,-1) - C(1,1) - C(-1,-1) + C(-1,1)).yx;\n        slurp+= s_velocity / pow(1.f, float(level));\n    }\n    return slurp;\n}\n\nvec4 env_avg(vec2 center, int level) {\n     vec2 t = 1./iResolution.xy, q = center*t - .5;\n   return (C(1, 1) + C(1, 0) + C(1, -1)\n          +C(0, 1) + C(0, 0) + C(0, -1)\n          +C(-1,1) + C(-1,0) + C(-1,-1))/9.f;\n}\n\nvoid mainImage( out vec4 O, in vec2 center )\n{\n    O = O-O;\n    vec2 t = 1./iResolution.xy, q = center*t - .5;\n    // copy a pixel from U+slurp to U\n    // (bc we cannot push this pixel according to the velocity, we slurp it)\n    vec2 slurp = slurp(center);\n    int level = 0;\n    slurp*= VELOCITY;\n    O = mix(C(slurp.x, slurp.y), C(0, 0), SMEARING);\n    O = C(slurp.x, slurp.y);\n    \n    O*= pow(1.f + ACCELERATION, iTimeDelta);\n    float sqlen = dot(O, O);\n    if (sqlen > 1.f)\n        O/= sqrt(sqlen);//*/\n    \n    // exaggerate differences\n    vec2 env_diff = O.xy - env_avg(center, 5).xy;\n    O.xy+= env_diff * DIFFERENCE;\n    \n    O = circle(vec2(0, 0), 0.01, vec4(0, 0, O.zw), q, O);\n    \n    // this seems to be a good texture initialization method:\n if(iChannelResolution[1].z < 1.0) {\n    \tO = vec4(0);    \n    } else if((iChannelResolution[1].z == 1.0 && texture(iChannel0,vec2(0)) == vec4(0)) || reset()) {\n        O = texture(iChannel1,center*t) * 2.f;\n        O-= 1.f;\n        O.xy = O.yx;\n        O.y = -O.y;\n        O.xyz = vec3(1, 0, 1);\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}