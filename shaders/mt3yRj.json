{
    "Shader": {
        "info": {
            "date": "1699400760",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "mt3yRj",
            "likes": 10,
            "name": "spqr planetary survey: europa",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "// ANY and ALL adulation belongs to IQ, and his new sphere noise.\n// read about it here: https://iquilezles.org/articles/fbmsdf\n// see it in action in his shadertoy here: https://www.shadertoy.com/view/3dGSWR\n\nfloat rnd ( float t ) {\n  return fract( sin(t * 1841.63623 + 2714.23423));\n\n}\n\n\nvec3 jitter (float t ) {\n  return vec3(rnd(t), 0., rnd(t + 6.124))/3.;\n}\n\nvec3 sino3 ( float t ) {\n  vec3 r = vec3(0);\n  for (float i = 0. ; i < 19.; i ++ ){\n    r += vec3( sin(t + i), cos(t-i *.79),0)/pow((i+1.),1.4);  \n  }\n  return r/3.;\n\n}\nfloat sino ( float t ) {\n  float r = 0.;\n  float scale = 1.;\n  for (float i = 0. ; i < 10.; i ++ ){\n    r +=  sin(t + rnd(t))/scale;\n    scale *= 2.1;\n  }\n  return r;\n\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\n\nmat2 rot ( float a ) {\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat box (vec3 p, vec3 s) {\n  p = abs(p) -s ;\n  return max(p.x,max(p.y,p.z));\n}\nfloat cone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n} \nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// NuSan's improvement\nfloat sdBase(in vec3 p) {\nreturn length(fract(p)-0.5)-(0.3+dot(sin(p*vec3(2.21,1.13,1.7)),vec3(.2)));\n}\n\nfloat tick( float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  \n  for ( int n = 0; n < 1; n++) {\n    r = smoothstep(0.,1.,r);\n  }\n  return i + r;\n}\nvec2 sdFbmPositive( in vec3 p, in float th, in float d )\n{\n\n\n   \n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 10;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        \n        //mutate landscape\n        //float porous = mix(0.02,0.1,sin(tick(iTime/10000.))) + .01;  // default 0.1;\n        float porous = .1;\n        \n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n  \n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    \n    return vec2( d, t );\n}    \n\nvec2 sdFbmNegative( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        \n        //mutate landscape\n        float porous = mix(0.02,0.2,sin(iTime/10.)*.5+0.5);  // default 0.1;\n        //float porous = .15;\n        \n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n  \n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    \n    return vec2( d, t );\n}    \n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n   \n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    \n    \n    return mat3( cu, cv, cw );\n}\n\n//=========================================\n\nconst float precis = 0.0005;  // default 0.0005\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 off ( vec3 p) {\n  return vec2(sin(p.x/3.0), cos(p.y/4.1));\n}\nfloat layer (vec3 p, float r ) {\n  return length(p) -r ;\n}\nvec3 ro;\nvec3 ta;\n\nfloat dolmens (vec3 p) {\n  float box = box(p, vec3(.3,.3,.3));\n  return box;\n\n}\n\nfloat hash (float t ) {\n  return fract(sin(t * 123.853 + 6467.166) * 992.124); \n}\n\nvec3 vollight;\n\nint matter;\nvec2 map( in vec3 p, in float dis )\n{\n    // geo \n\n  \n    //p.y += sin((p.x/17.)+ iTime/2.1)*1.; \n    p.y += sin((p.z/15.12)+ iTime/4.)*.5; \n    p.y += sin((p.x/11.12)+ iTime/3.)*.5; \n   \n    \n    \n    p.y *= .8;\n    \n     vec3 w = p;\n    \n    // varies the base terrain in an interesting way\n    p.y *= (sin(p.z/3.2)*.5 + .5 ) + .4;\n    p.y *= (sin(p.x/3.91)*.5 + .5 ) + .45;\n    \n    vec3 q = p;\n    \n  \n\n    float d = p.y;\n    \n    \n \n    p.xz += (sin(p.x) + cos(p.z)/1000.) * .5; // seems to 'tilt' the formations\n    q.y += (sin(p.x) + cos(p.z)/1000.) * .5; // seems to 'tilt' the formations\n    \n    vec2 dt = sdFbmPositive( p * vec3(1), dis*precis, d );\n  \n    vec2 et = sdFbmNegative( q * vec3(1), dis*precis, d)/2.;\n    \n    \n   \n  \n    \n    float level = sin(iTime/14.1) * .5 + .3;  \n\n\n    //return dt;\n    vec2 ice = min(dt,et);\n    vec2 water = vec2(level + w.y,0.);\n    vec2 final =  min(water,ice);\n    \n\n    return final;\n   \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float res = 1.;\n    float k = 2.;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t,0.).x;\n        if( h<0.001 ){\n            return 0.0;\n        }\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nfloat probe( in vec3 ro, in vec3 rd)\n{\n\n    float t,dd;\n    vec3 pos = vec3(0);\n    for( float i = 0.; i < 120.;i++ )\n    {\n    \n       pos = ro + t*rd;\n    \n\t   float h = map( pos, 0. ).x;\n       \n       if ( h < .1 ) {\n         break;\n       }\n        t += h;\n       dd += t;\n      \n    \n    }\n    return dd;\n   \n}\n\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\n\n\n\n\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist,1.).x*3.0,0.0,1.0);\n}\n\n\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d,0.).x/d);\n}\n\nfloat getWave(float t) {\n  float str = 1.;\n  float fre = 1.;\n  float total = 0.;\n  for (float i=0.; i < 3.; i++) {\n    total += cos(t * fre) * str; \n    fre *=2.1;\n    str *= .5;\n  }\n  return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n \n    vec2 z = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n\n\n\t// scene setup\n  \n    float cr, fl, fad;\n    \n    float pi = acos(-1.);\n \n  \n  \n\n    // nav\n    float tt = iTime * 3. + 141.;\n \n \n    float height = getWave(iTime)/2.5;\n    float forward = tt * 2.5 ;\n    ro = vec3(0.0, height, forward); \n    ro.y += 1.;\n    ta = ro + vec3(0,0,1);\n   \n   \n    vec3 ro_off = getPos(tt);\n    ro.x /= 3.;\n    vec3 ta_off = getPos(tt + 7.11);\n    \n    ro += ro_off/36.;\n    ta += ta_off/66.;\n    \n    \n    float jitter = rnd(tick(tt))/79. * sino(tt);\n    ro.y += jitter;\n    //ta.y -= jitter;\n    \n    \n    \n    vec3 arm = vec3(0,0,10);\n    arm.xz *= rot(sin(iTime/6.7) * 2.1);///6.) * (3.14/2.) + (3.14/2.));\n   \n    //ta += arm/3.;\n   \n   \n   \n   \n    // camera matrix\n    \n    mat3 ca = setCamera( ro, ta, cr );\n    \n    vec3 rd = ca * normalize( vec3(z.xy,2.0));\n    \n    rd.xy *= rot(sin(iTime)*.1);\n    \n    float t = 0.;\n   \n    bool hit = false;\n    vec3 pos;\n    float dd;\n    float d;\n    float i;\n    \n    \n    \n    // spotlight\n    \n    //vec3 volarm = vec3(cos(iTime), .5 , sin(iTime))*0.5 ;\n    //vollight = ro + vec3(0,-3.4,3.5) + volarm;\n    //vec3 voltarget = vec3(cos(iTime*2.),3.*sin(iTime),sin(iTime*2.))*13.;\n    //float atm = 0.;\n    \n    // march\n    \n\tfor( i=0.; i<550.; i++ )\n\t{\n        pos = ro + t*rd;\n        float flip = sign(map(pos,t).x);\n\t\td = map( pos, 0. ).x*flip ;\n       \n        \n        //vec3 spotdir = vollight - pos;\n        //vec3 globalspotdir = normalize(voltarget - vollight);\n        //float spotdist = length(vollight-pos);\n        \n        //float cone = clamp( max(0., dot(normalize(spotdir),globalspotdir)) * .3, 0., 1.);\n        //cone = pow(cone,2.);// + abs(sin(iTime) * 10.));\n       \n        //atm +=  cone * (.1/pow(spotdist,2.));\n        \n        \n        \n        if( d<.001) {//(precis*t)) {\n          \n          hit = true;\n          break;\n        }\n       if (t>300.0 ) {\n          break;\n       }\n\t   t += d ; // overstepping\n       dd += t;\n\t}\n   \n\t\n    \n   \n    vec3 nor = calcNormal( pos, t );\n    vec3 sunlight = vec3(0,10,-10);\n    sunlight.xz *= rot(iTime * .98);\n    //sunlight.yz *= rot(iTime * .28);\n\n\n\n    // color\n   \n    \n    float shadow = shadow(pos, normalize(sunlight), .1, length(sunlight-pos));\n    float dif = dot(normalize(sunlight),nor) * 10.7; \n    float spec= pow(max(dot(reflect(sunlight,nor),-rd),.0), 3.2);\n    float fren = pow(1.+dot(nor,rd),1.);\n    float sss = getsss(pos,rd,1.); // \"10\" makes it look like the peaks are sunlit\n    float ao = pow(1. - i/1000.,8.);\n  \n    vec3 col = vec3(1);\n    vec3 hue = vec3(.7,.8,1.);\n    col *= dif * .2 * hue;\n    col *= shadow * hue * .25;\n    col += spec * .001 * hue;  \n    col += sss * 6.6;  \n    col += fren * hue;\n    col *= ao * hue;\n    col = mix(col, hue, pow(i/1500.,10.3));\n    \n  \n  \n \n  \n    \n    if (! hit ) {\n  \n      float x = dot(rd, normalize(sunlight))*.5 + .5;\n      x *= x * x;\n      col = vec3(.2,.3,.8) * x * .8 * (1.-rd.y);\n      if ( rd.y < .02) {\n        col *= .044;\n      }\n    }\n    //col += atm * 3.3;\n    // fog\n    \n  \n  \n   \n    col = pow(col,vec3(.5));\n    fragColor = vec4( col, 1.0 );\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}