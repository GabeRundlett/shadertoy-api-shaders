{
    "Shader": {
        "info": {
            "date": "1568272670",
            "description": "Been following along iq's live coding stream. ",
            "flags": 0,
            "hasliked": 0,
            "id": "tsc3zM",
            "likes": 17,
            "name": "That cat",
            "published": 3,
            "tags": [
                "animation",
                "cat"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 609
        },
        "renderpass": [
            {
                "code": "//#define TIME mod(iTime,10000.0)\n#define PI 3.1416\n#define TERRAIN_PATTERN 4.0*sin(12.0*pos.x)+sin(20.0*pos.y)+sin(15.0*pos.z)\n#define SPEED aTime*0.3\n#define MAX_DIST 20.0\n#define MAX_STEP 80\n#define SUN_DIRECTION vec3(0.8,0.3,0.9)\n#define SUNLIGHT_INTENSITY vec3(6.0,5.5,4.0)\n#define SUNSET_COLOR vec3(0.7,0.2,0.1)\n#define SKY_COLOR vec3(0.25, 0.35, 0.6)\n#define TERRAIN_COLOR vec3(0.07,0.04,0.03)\n#define RIM_COLOR vec3(0.85,0.1,0.1)\n#define RIM_POWER 0.15\n#define AA_SIZE 1\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nfloat sdSphere(in vec3 pos, in float r)\n{\n    return length(pos)-r;\n}\n\n//https://iquilezles.org/articles/ellipsoids\nfloat sdElipsoid(in vec3 pos, in vec3 r)\n{\n    float k0 = length(pos/r);\n    float k1 = length(pos/r/r);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float r = mix(r1, r2, h);\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return min(a,b) - h*h*0.25/k;\n}\n\nfloat smax(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return max(a,b) + h*h*0.25/k;\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nvec4 map(in vec3 pos, float aTime)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = fract(aTime);\n    float y = 3.0*t*(1.0-t); \n    vec3 cen = vec3(0.0,0.25+0.01*y,SPEED);\n    float sy = 0.8 + 0.2*y;\n    float sz = 1.0/sy;\n    vec3 r = vec3(0.35,0.32+0.02*sy,0.25+0.05*sz);\n    vec3 q = pos-cen;\n    vec3 h = q;\n    \n    //body\n    float d = sdElipsoid(q-vec3(0.0, 0.03, -0.09), r);\n    \n  \n    {\n    \n    //head\n    float hr = sin(aTime);\n    hr = 0.5*sign(hr)*smoothstep(0.5,1.0,abs(hr));\n    h.xz = mat2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    \n    float d1 = sdElipsoid(h - vec3(0.0, 0.32, 0.01), vec3(0.28, 0.2, 0.18));\n    float d2 = sdElipsoid(h - vec3(0.0, 0.30, -0.07), vec3(0.2));\n    d2 = smin(d1, d2, 0.08);\n    d = smin(d, d2, 0.08);\n    \n    \n    vec3 sh = vec3(abs(h.x), h.yz);//symmetric along x\n    \n    //legs\n    vec3 shh = vec3(abs(h.x), h.y, abs(h.z+0.1));//symmetric along x and z\n    //animation settings\n    float t1 = fract(aTime+4.71*sign(h.x));\n    float y1 = 3.0*t1*(1.0-t1); \n    float offset = y1;\n    \n    d1 = sdStick(shh - vec3(0.11,-0.24,0.22), vec3(0.0,0.18,-0.1), vec3(0.0,-0.1,-0.15*offset), 0.08, 0.05); \n    d = smin(d, d1, 0.04);\n        \n    //nose\n    d1 = sdStick(h, vec3(0.0,0.41,0.12), vec3(0.0,0.37,0.18), 0.05, 0.03);\n    d = smin(d,d1,0.01);\n    \n    //ears\n    d2 = sdElipsoid(sh - vec3(0.15, 0.47, -0.05), vec3(0.06, 0.09, 0.04));\n    d = smin(d, d2, 0.08);\n    res = vec4(d,2.0,0.0,0.0);\n    \n    //tail\n    d2 = sdStick(h, vec3(0.0,-0.3,-0.1), vec3(-0.1*y,0.2,-0.55), 0.03, 0.05);\n    d = smin(d, d2, 0.06);\n    res = vec4(d,2.0,0.0,0.0);\n    \n    \n    //eyelids\n    vec3 elPos = sh - vec3(0.04,0.33,0.09);\n    d2 = sdStick(elPos, vec3(0.0,0.12,0.02), vec3(0.05,0.1,-0.02), 0.02, 0.02);\n   \td = smin(d, d2, 0.03);\n    res = vec4(d,2.0,0.0,0.0);\n    \n     \n    //eyes\n    float d5 = sdSphere(sh - vec3(0.065,0.4,0.108), 0.07);\n    res = sdUnion(res, vec4(d5,3.0,0.0,0.0));\n    \n    float eyeOffsetY = 0.01*smoothstep(0.0, 0.8,sin(aTime));\n    \n    d5 = sdSphere(sh - vec3(0.066,0.40+eyeOffsetY,0.124), 0.056);\n    res = sdUnion(res, vec4(d5,4.0,0.0,0.0));\n         \n    //mouth\n    float d6 = sdElipsoid(h - vec3(0.0,0.29,0.16), vec3(0.06,0.03,0.04));\n    float d7 = sdElipsoid(sh - vec3(0.035,0.32,0.175), vec3(0.055,0.036,0.04));\n    d6 = smin(d6,d7,0.01);\n    res = sdUnion(res, vec4(d6,6.0,0.0,0.0));\n    \n    //terrain\n    float fh = -0.1+0.05*(sin(2.2*pos.x) + sin(1.5*pos.z));\n    d1 = pos.y - fh;\n    d1 -= .01*noise(vec2(pos.x*10.0,pos.z*10.0));\n    if (d1<res.x) res = vec4(d1,1.0,0.0,0.0);\n    \n    //watermelon\n    float b = 5.0;\n    vec3 rep = vec3(mod(abs(pos.x),b)-3.5, pos.y, mod(abs(pos.z+1.5), b)-2.5);\n    vec2 id = vec2(floor(abs(pos.x)/b),floor((pos.z+1.5)/b));\n    float fid = id.x*13.3 + id.y*31.7;\n    float wr = 1.4+0.5*sin(fid*1.312);\n    \n    d2 = sdSphere(rep, wr);\n    if (d2<res.x) res = vec4(d2,8.0,0.0,0.0);\n \n    }\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float aTime)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.16*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, aTime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        \n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos, in float aTime)\n{\n    vec2 e = vec2(0.001,0.0);\n    return normalize( vec3(map(pos + e.xyy,aTime).x - map(pos - e.xyy,aTime).x,\n                          map(pos + e.yxy,aTime).x - map(pos - e.yxy,aTime).x,\n                          map(pos + e.yyx,aTime).x - map(pos - e.yyx,aTime).x) );\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd, in float aTime)\n{\n    float res = 1.0;\n    float t = 0.01;\n    float tMax = MAX_DIST;\n\n    for (int i=0; i<MAX_STEP;++i)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos,aTime).x;\n        res = min( res, 18.0*h/t );\n        if (res<0.001) break;\n        t += h;\n        if (t>tMax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float aTime)\n{\n   float t = 0.01;\n   vec3 m = vec3(0.0);\n   float tMax = MAX_DIST;\n   /*\n   float hMax = 2.5;\n   float bt = (hMax-ro.y)/rd.y;\n   if ( bt>0.0 ) tMax = min(tMax, bt);\n   */\n   \n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t*rd;\n       vec4 h = map( pos,aTime );\n       m = h.yzw;\n       if ( abs(h.x)<(0.001*t) )\n       {\n           break;\n       }\n       t += h.x;\n       if ( t>tMax ) break;\n   } \n    \n   if ( t>tMax )\n   {\n       m = vec3(-1.0);\n   }\n   return vec4(t,m);\n}\n\nvec3 render(in vec2 fragCoord, in float aTime)\n{\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float angle = 10.0*iMouse.x/iResolution.x+1.0;\n    \n    vec3 ta = vec3(0.0,0.45,0.8+SPEED);\n    vec3 ro = ta+vec3( 1.0*cos(angle), mouse.y, 1.0*sin(angle) );;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross( ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    \n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0*ww);\n    vec3 sunDir = SUN_DIRECTION;//normalize( vec3(0.8,0.4,0.9) );\n    \n    vec3 col = SKY_COLOR - 0.8*rd.y;\n    \n    vec2 uv = rd.xz/rd.y; //sky dome( intersect the top )\n    float sinV = 1.0*(sin(1.0*uv.x )+sin(1.0*uv.y))\n        \t\t+ 0.5*(sin(2.0*uv.x+aTime)+sin(2.0*uv.y+aTime));\n    col = mix( col, vec3(0.9,0.85,0.6),smoothstep(-0.3,0.3,-0.5+sinV) );\n    col = mix(col, SUNSET_COLOR, exp(-4.0*rd.y));\n   \n    vec4 tm = castRay(ro, rd, aTime);\n    if ( tm.y>-1.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, aTime);\n        vec3 mate = vec3(0.18);\n        if (tm.y==8.0)\n        {\n            //watermelon\n            mate = vec3(0.03,0.1,0.07);\n            float f = 1.0-smoothstep(-0.2, 0.2, TERRAIN_PATTERN);\n            mate = mix(mate, vec3(0.0,0.05,0.03), f);\n        } \n        else if (tm.y==7.0)\n        {\n            mate = vec3(0.8,0.2,0.0);\n        }\n        else if (tm.y==6.0)\n        {\n            mate = vec3(0.2,0.2,0.2); //mouth\n        }\n        else if (tm.y==5.0)\n        {\n            mate = vec3(0.25)*pos.y; //tail\n        } \n        else if (tm.y==4.0)\n        {\n        \tmate = vec3(0.01, 0.01, 0.015); //eyes \n        }\n        else if (tm.y==3.0)\n        {\n            mate = vec3(0.5, 0.5, 0.5); //eyes\n        }\n        else if (tm.y==2.0)\n        {\n            mate = vec3(0.01,0.01,0.02);//body\n        } else\n        {\n            mate = TERRAIN_COLOR;//terrain\n        }\n        \n        float occ = calcOcclusion( pos, nor, aTime );\n        float fresnel = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float sunDiff = clamp( dot(nor, sunDir),0.0,1.0 );\n        float sunShadow = castShadow(pos+nor*0.01, sunDir, aTime);//step( castRay(pos+nor*0.001, sunDir).y,0.0 );\n        float skyDiff = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,1.0,0.0)),0.0,1.0 );\n        //Simulate how lights bounce off from the ground to the object surface.\n        float bounceDiff = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,-1.0,0.0)),0.0,1.0 );\n        col = mate*SUNLIGHT_INTENSITY*sunDiff*sunShadow;\n        col += mate*SKY_COLOR*skyDiff;\n        col += mate*SUNSET_COLOR*bounceDiff;\n        col *= occ;\n        col += RIM_POWER*RIM_COLOR*fresnel;\n        \n        if (tm.y==4.0 || tm.y==8.0)\n        {\n            vec3 viewDir = normalize(ro-pos);\n            vec3 reflectDir = normalize(reflect(-sunDir, nor));\n            float spec = pow(max(dot(reflectDir, viewDir), 0.0), 64.0);\n            vec3 speCol = vec3(1.0) * spec;\n            col += speCol;\n        }\n        \n        // fog\n        col = mix( col, SUNSET_COLOR, 1.0-exp( -0.005*t*t ) );\n    } \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.0);\n    \n#if AA_SIZE>1\n    //anti aliasing & motion blur\n    for (float aaY = 0.0; aaY < float(AA_SIZE); ++aaY)\n    {\n        for (float aaX = 0.0; aaX < float(AA_SIZE); ++aaX)\n        {\n            off = -0.5+vec2(aaY,aaX)/float(AA_SIZE);\n            \n            float md = texelFetch(iChannel0, ivec2(fragCoord)&255, 0).x;\n            float mb = (aaY*float(AA_SIZE)+aaX)/(float(AA_SIZE*AA_SIZE-1));\n            mb += (md-0.5)/float(AA_SIZE*AA_SIZE);\n            float aTime = iTime - mb*0.5*(1.0/24.0); //1 frame in 24fps for film\n#else\n            float aTime = iTime;\n#endif\n            \n            col += render(fragCoord+off, aTime);\n            \n#if AA_SIZE>1\n        }\n    }\n    col /= float(AA_SIZE*AA_SIZE);\n#endif\n    \n    //gamma\n    col = pow( col, vec3(0.4546));\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    fragColor = vec4(col,0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}