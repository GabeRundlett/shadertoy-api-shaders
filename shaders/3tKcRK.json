{
    "Shader": {
        "info": {
            "date": "1611338807",
            "description": "I dunno, copy and paste this into Cubemap A and replace the Cubemap in another shader...",
            "flags": 0,
            "hasliked": 0,
            "id": "3tKcRK",
            "likes": 0,
            "name": "Procedural Mandelbulb Cubemap",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb",
                "cubemap"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "#define camerafov 2.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 raydirection = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n\n    vec3 col = texture(iChannel0, raydirection).rgb;\n\n    // Output to screen\n    fragColor += vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define power 8.0\n#define collisiondistance 0.001\n\nfloat distanceestimator(vec3 pos){\n    pos *= 0.5;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8; i++){\n\t\tr = length(z);\n\t\tif (r > 4.0) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr = pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t// Convert back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;}\n\treturn 0.5*log(r)*r/dr;}\n\nvec3 raymarch(vec3 raydirection, vec3 rayorigin){\n    vec3 rayposition = rayorigin;\n    float distanceestimate = 0.0;\n    float distancetravelled = 0.0;\n    for(int i = 0; i < 128; i++){\n        distanceestimate = distanceestimator(rayposition);\n        if(distanceestimate < collisiondistance){return rayposition;}\n        distancetravelled += distanceestimate;\n        if(distancetravelled > 32.0){break;}\n        rayposition += raydirection*distanceestimate;}\n    return vec3(0.0);}\n\nvec3 normal(vec3 p){\n    const vec2 h = vec2(collisiondistance, 0.0);\n    return normalize(vec3(distanceestimator(p+h.xyy)-distanceestimator(p-h.xyy),\n                          distanceestimator(p+h.yxy)-distanceestimator(p-h.yxy),\n                          distanceestimator(p+h.yyx)-distanceestimator(p-h.yyx)));}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    // Ray direction as color\n    vec3 raymarched = raymarch(rayDir, vec3(0.0, 2.0, 0.0));\n    vec3 normals = normal(raymarched);\n\n    // Output to cubemap\n    fragColor = vec4(texture(iChannel0, normals).rgb, 1.0);\n    if(raymarched == vec3(0.0)){fragColor = vec4(texture(iChannel0, rayDir).rgb, 1.0);}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}