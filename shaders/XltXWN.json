{
    "Shader": {
        "info": {
            "date": "1480944719",
            "description": "a hopefully well-commented raymarched distance field inspired by the windows of my room and the feeling I had with my new glasses on before I got used to them\n\nno actual 3d distance functions were harmed during the making of this scene :octopusballoon:",
            "flags": 0,
            "hasliked": 0,
            "id": "XltXWN",
            "likes": 88,
            "name": "Collapsing Architecture",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "distortion",
                "architecture",
                "twist"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 2587
        },
        "renderpass": [
            {
                "code": "#define SPEED .5\n#define FOV 1.5\n\n#define MAX_STEPS 100\n#define EPS .00001\n#define RENDER_DIST 10.\n#define AO_SAMPLES 5.\n#define AO_RANGE 10.\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat _twist = 0.;\n\n// simple hash function\nfloat hash(vec3 uv) {\n  float f = fract(sin(dot(uv ,vec3(.009123898,.00231233, .00532234)))* 111111.5452313);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 5; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// dangerous distance-field invalidating space twisting function\nvoid tTwist(inout vec3 p, float a) {\n    tRotate(p.xy, p.z * a);\n}\n\n// repeat space along a single axis\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// repeat space along 2 axis\nvec2 tRepeat2(inout vec2 p, vec2 r) {\n    vec2 id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// rectangle distance\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// circle distance\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance estimation of the scene\nfloat map(vec3 p)\n{\n    // distort the scene\n    tTwist(p, _twist);\n    \n    // repeat the scene along x and z axis\n    tRepeat2(p.xz, vec2(.7, 1.));\n    \n    // mirror along x\n    p.x = abs(p.x);\n    \n    // lower everything by .5\n    p.y += .5;\n    \n    // add the wall\n    float d = abs(p.z) - .15;\n    \n    // carve out the window\n    float w = opU(sdCircle(p.xy - vec2(0, .75), .25), sdRect(p.xy - vec2(0, .375), vec2(.25, .375)));\n    d = opS(d, w);\n    \n    // make space for the columns\n    d = opS(d, sdRect(p.xy - vec2(0,.35), vec2(.45,.3)));\n    \n    // add the colums\n    d = opU(d, sdCircle(p.xz - vec2(.35, 0), .075));\n    \n    // mirror along z\n    p.z = abs(p.z);\n    \n    // remove extra wall at the column base and top\n    d = opS(d, sdRect(p.yz - vec2(.6, .5), vec2(.6,.4)));\n    \n    // add the ceiling and the floor\n    d = opU(d, -abs(p.y - .5) + .8);\n    return d;\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// actually there is some mold in the corners of my room that I wanted to show,\n// but for hygenic reasons I'm going to call this effect \"ambient occlusion\"\n// algorithm from Shane\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// check if the poin in question belongs to a column or the wall\nbool isWall(vec3 p) {\n    p.x += .35;\n    tRepeat2(p.xz, vec2(.7, 1));\n    return .375 < abs(p.y + .15) + length(p.xz);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 t;\n    \n    // apply the twist, so we don't use world coordinates\n    tTwist(p, _twist);\n    bool wall = isWall(p);\n    \n    // if we're in a column, apply distortion to the fbm space\n    t = fbm((p + (wall ? 0. : .1 + .9 * fbm(p * 5.))) * vec3(5., 20., 5.)) * vec3(1., .7, .4) * .75\n        + fbm(p * vec3(2., 10., 2.)) * vec3(1., .8, .5) * .25;\n    \n    // make the walls whiter\n    if (wall) t = mix(t, vec3(1), .5);\n    return saturate(t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * SPEED;\n    \n    // the degree of distortion\n    _twist = sin(time) * .4;\n    \n    // the camera follow a sinusoid path\n    vec3 ro = vec3(sin(time * PI / 2. + 1.) * 1., 0, time);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // the light source is two steps ahead of the camera\n    time += 2.;\n    vec3 light = vec3(sin(time * PI / 2. + 1.) * 1., 0, time);\n    time -= 2.;\n    \n    // rotate camea and light to compensate for the twist\n    tRotate(rd.xz, -cos(time * PI / 2. + 1.) * .5);\n    tRotate(ro.xy, -ro.z * _twist);\n    tRotate(light.xy, -light.z * _twist);\n    tRotate(rd.xy, -ro.z * _twist);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadowSteps, shadow = float(trace(shadowStart, l, shadowDistance, shadowSteps) > shadowDistance);\n    \n    // the fewer steps to march, the brighter the light\n    // probably no basis in light theory, but I thought it looked good \n    shadow *= 1. - sqrt(shadowSteps / float(MAX_STEPS));\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 8.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal);\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient + (specular + diffuse) * shadow);\n    \n    // edge glow\n    fragColor *= sqrt(steps / float(MAX_STEPS));\n    \n    // fog\n    fragColor = mix(fragColor, vec4(.9, .8, .7, 1.), saturate(dist * dist * .03));\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n    fragColor.a = 1. - dist / 10.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}