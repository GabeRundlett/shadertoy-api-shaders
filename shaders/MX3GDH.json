{
    "Shader": {
        "info": {
            "date": "1716416731",
            "description": "Using the integral (in cartesian space) of a semicircle function to find exact pixel coverage. Not optimized to be efficient.",
            "flags": 0,
            "hasliked": 0,
            "id": "MX3GDH",
            "likes": 3,
            "name": "Analytical \"Perfect\" Circle",
            "published": 3,
            "tags": [
                "math",
                "circle",
                "analytical",
                "analytic",
                "integral"
            ],
            "usePreview": 0,
            "username": "Real_NC",
            "viewed": 179
        },
        "renderpass": [
            {
                "code": "float f( float x, float r ) // semicircle function\n{\n    return sqrt(r*r - x*x);\n}\nfloat F( float x, float r ) // integral of semicircle function with respect to x\n{\n    float x2 = clamp(x/r, -1.0, 1.0);\n    return 0.5*r*(r*asin(x2) + x*sqrt(max(1.0 - x2*x2, 0.0)));\n}\n\nfloat circleShading( vec2 p, float r) // Always we will just assume to be integrating over a 1x1 square\n{\n    p = abs(p);\n    p = (p.x > p.y ? p : p.yx); // Using some domain repetition to simplify integration\n    if(p.y + p.x + 1.0 > r + r) return 0.0;\n    vec2 domain = p.x + vec2(-0.5, 0.5);\n    \n    float wHighEnough = f(p.y - 0.5, r); // Goldilocks math\n    float wTooHigh = f(min(p.y + 0.5, r), r);\n    \n    vec2 iHighEnough = vec2(clamp(-wHighEnough,domain.x,domain.y), clamp(wHighEnough,domain.x,domain.y)); // Clamping to our square domain\n    vec2 iTooHigh = vec2(max(-wTooHigh, domain.x), min(wTooHigh, domain.y));\n    \n    float shading = F(iHighEnough.y, r) - F(iHighEnough.x, r) - (p.y - 0.5)*(iHighEnough.y - iHighEnough.x);\n    \n    if(iTooHigh.y > iTooHigh.x)\n    {\n        shading -= F(iTooHigh.y, r) - F(iTooHigh.x, r) - (p.y + 0.5)*(iTooHigh.y - iTooHigh.x);\n    }\n    \n    return max(shading, 0.0);\n}\n\nfloat bruteCircleShading( vec2 p, float r)\n{\n    float c = 0.0;\n    for(float x = -0.5 + 0.025; x < 0.5; x += 0.05)\n    {\n        for(float y = -0.5 + 0.025; y < 0.5; y += 0.05)\n        {\n        c += step(dot(p + vec2(x,y),p + vec2(x,y)), r*r)/400.0;\n        }\n    }\n    return c;\n}\n// linear function of the circle's SDF\nfloat lerpCircleShading( vec2 p, float r)\n{\n    float r2 = length(p) - r;\n    return 0.5 - clamp(r2, -0.5, 0.5);\n}\n// hermite function of the circle's SDF. 0.65 was hand-picked to produce the best result, but this method is terrible. Never use this.\nfloat smoothstepCircleShading( vec2 p, float r)\n{\n    float r2 = length(p) - r;\n    return smoothstep(0.65, -0.65, r2);\n}\n\n// sRGB EOTF-1 from ttg\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centered but not normalized coordinates\n    vec2 uv = (fragCoord - 0.5*iResolution.xy);\n    \n    uv += vec2(cos(iTime*0.11), sin(iTime*0.1))*0.1 * iResolution.y;\n    \n    float radius = (cos(iTime*0.2)*0.125 + 0.175)*iResolution.y;\n    \n    fragColor.rgb = 1.0 - vec3((mod(iTime, 0.2) < 0.1 ? circleShading(uv, radius) : circleShading(uv,radius)));\n    \n    if(iMouse.x > fragCoord.x) fragColor.rgb = vec3(1.0 - lerpCircleShading(uv, radius));\n    if(floor(iMouse.x) == floor(fragCoord.x)) fragColor = mix(fragColor, vec4(1,0,0,0), 0.2);\n    \n    //uncomment to see error between the two \"correct\" functions. I'm not sure which is more accurate, but I expect the calculus method has some precision errors\n    //fragColor.rgb = vec3(3.0*abs(circleShading(uv, radius) - bruteCircleShading(uv,radius)));\n    \n    // Remember to do this srgb encode or anti-aliasing/gradients won't look right\n    fragColor.rgb = srgb_encode(fragColor.rgb);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}