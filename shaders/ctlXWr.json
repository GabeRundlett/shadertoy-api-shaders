{
    "Shader": {
        "info": {
            "date": "1674586075",
            "description": "3D",
            "flags": 0,
            "hasliked": 0,
            "id": "ctlXWr",
            "likes": 8,
            "name": "Mountain Lakes",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 1,
            "username": "FifthStateOfMatter",
            "viewed": 407
        },
        "renderpass": [
            {
                "code": "//Thanks to iq for some help with artifacts\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return (fract(p.x + p.y)*2.0) - 1.0;\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 8; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nfloat yPlane(vec3 p){\n    return p.y;\n}\n\nfloat scene(vec3 p){\n    return min((yPlane(p - vec3(0, -1, 0)) - fbm(p*0.05)*5.0)*0.65, (yPlane(p - vec3(0, -2, 0)) - noise2(p.xz*20.0)*0.002));\n}\n\nfloat raymarch(vec3 o, vec3 d, int ms, float md, float eps, out bool hit){\n    float t = 0.0;\n    hit = false;\n    for(int i = 0; i < ms && t < md && !hit; i++){\n        float s = scene(o + d*t);\n        t += s;\n        if(abs(s) < eps*t*0.1){\n            hit = true;\n            return t;\n        }\n    }\n    hit = false;\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    return normalize(vec3(\n        scene(vec3(h.x + 0.01, h.yz)) - scene(vec3(h.x - 0.01, h.yz)),\n        scene(vec3(h.x, h.y + 0.01, h.z)) - scene(vec3(h.x, h.y - 0.01, h.z)),\n        scene(vec3(h.xy, h.z + 0.01)) - scene(vec3(h.xy, h.z - 0.01))\n    ));\n}\n\nfloat getLighting(vec3 h, vec3 ldir, vec3 n){\n    float c = dot(n, -ldir);\n    float cr = c;\n    float lt = 0.0;\n    bool hit = false;\n    vec3 so = h + n*0.01;\n    for(int i = 0; i < 50 && lt <= 30.0 && !hit; i++){\n        float s = scene(so - ldir*lt);\n        lt += s;\n        if(abs(s) <= lt*0.001 && lt >= 0.0){\n            hit = true;\n            c -= 0.6;\n        }else{\n            c = cr;\n        }\n        //return c;\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec3 lDir = normalize(vec3(-10, -10, -10));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 4, iTime*3.0);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(15.0), iTime*0.1)));\n    bool hit;\n    float t = raymarch(o, d, 150, 120.0, 0.01, hit);\n    if(!hit) t = 500.0;\n    //t *= 0.9;\n    vec3 n = getNormal(o + d*t);\n    float ny = n.y - 0.1;\n    float rd = 1.0 - d.y;\n    col = mix(\n        vec3(\n            rd/5.0 + 0.2,\n            rd/2.0 + 0.2,\n            rd + 0.2\n        ),\n        vec3(1),\n        clamp(fbm((o + d*t).xzy*0.01) + 0.2, 0.0, 1.0)\n    );\n    \n    float c = clamp(getLighting(o + d*t, lDir, n), 0.0, 1.0);\n    \n    vec3 rfd = normalize(d - 2.0*n*dot(n, d));\n    \n    float spec = pow(clamp(dot(-lDir, rfd), 0.0, 1.0), 9.0);\n    bool rhit;\n    vec3 rfo = (o + d*t) + n*0.01;\n    float rft = raymarch(rfo, rfd, 100, 100.0, 0.01, rhit);\n    if(!rhit) rft = 500.0;\n    float rdy = 1.0 - rfd.y;\n    vec3 rfclouds = mix(\n        vec3(\n            rdy/5.0 + 0.2,\n            rdy/2.0 + 0.2,\n            rdy + 0.2\n        ),\n        vec3(1),\n        clamp(fbm((rfo + rfd*rft).xzy*0.01) + 0.2, 0.0, 1.0)\n    );\n    vec3 rn = getNormal(rfo + rfd*rft);\n    float rc = clamp(getLighting(rfo + rfd*rft, lDir, rn), 0.0, 1.0);\n    vec3 matcol = (o.y + d.y*t) > -1.94 ? mix(vec3(0.2, 0.15, 0.1) + spec/8.0, vec3(0.2, 0.5, 0) + spec/8.0, smoothstep(0.6, 0.7, ny))*c : (rhit ? mix(vec3(0.2, 0.5, 1)*c, mix(vec3(0.2, 0.15, 0.1), vec3(0.1, 0.5, 0), smoothstep(0.6, 0.7, ny))*rc, 0.3)*c + spec : mix(vec3(0.2, 0.5, 1), rfclouds, 0.3)*c + spec);\n    \n    if(hit){\n        col = vec3(\n            mix(matcol.r, col.r, 1.0 - exp(-t*0.01)),\n            mix(matcol.g, col.g, 1.0 - exp(-t*0.01)),\n            mix(matcol.b, col.b, 1.0 - exp(-t*0.012))\n        );\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}