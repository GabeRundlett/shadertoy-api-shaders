{
    "Shader": {
        "info": {
            "date": "1631364085",
            "description": "The Abyss movie from 1989, where a friendly 'visitor' has a look around the underwater habitat.\n(It's deliberately a bit dark.)\nYouTube: https://youtu.be/SZqlIZMQU6U\nYouTube (360°): https://youtu.be/-ayBRXhEDoU",
            "flags": 1,
            "hasliked": 0,
            "id": "NdKGDz",
            "likes": 47,
            "name": "The Abyss",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "reflection",
                "refraction",
                "water",
                "caustics",
                "movie",
                "tentacle",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 8082
        },
        "renderpass": [
            {
                "code": "// 'The Abyss' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NdKGDz (YouTube: https://youtu.be/SZqlIZMQU6U)\n//\n// YouTube: https://youtu.be/SZqlIZMQU6U\n// YouTube (360°): https://youtu.be/-ayBRXhEDoU\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// The Abyss movie from 1989, where a friendly 'visitor'\n// has a look around an underwater habitat.\n//\n// Quote: \"Keep your pantyhose on...\"\n//\n// Tricks to get the performance:\n// - The water and scene are raymarched separately, as only\n//   the water is reflective. When reflecting only the background\n//   needs to be processed.\n//   This also allows different max marching steps for each.\n// - Similarly I have two normal functions.\n//   One for the water, one for everything else.\n// - Textures applied during the lighting calculations, as far\n//   as possible.\n// - Fake shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define U\tnormalize\n#define L\tlength\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define minH(a, b)\t{ float h_ = a; if (h_ < h.x) h = vec2(h_, b); }\n\nfloat t, g = 0., g2 = 0.;\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max2(v.yz)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn L(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, vec2 hr) {\n\tp.x -= clamp(p.x, 0., hr.x);\n\treturn L(p) - hr.y;\n}\n\nfloat honk(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xy *= rot;\n\tfloat d = cap(p, vec2(h * .88, r));\n\tp.x -= h;\n\treturn d;\n}\n\n// Find most dominant uv coords.\nvec2 proj(vec3 p, vec3 n) {\n\tn = abs(n);\n\tfloat m = max3(n);\n\treturn n.x == m ? p.yz : n.y == m ? p.xz : p.xy;\n}\n\nfloat surf(vec2 p1, vec2 p2) {\n\tfloat d = t * .4;\n\treturn n31(vec3(p1.x + d, p1.y, d)) * .3 + n31(vec3(p2, d) * 2.) * .1 + n31(vec3(p2 + d * .5, d) * 3.6) * .05;\n}\n\nfloat face(vec3 p, float o) {\n\tfloat f, d,\n\t      ox = p.x;\n\tp.x = abs(p.x) - .15;\n\tp.y += .05;\n\tp.z += .15 - .3 + .3 * S(27., 30., t);\n\tf = S(29.5, 31., t);\n\td = L(p) - .08;\n\tp.x = ox;\n\tp.y -= .3 - 1. + cos(ox * 1.5 * (.3 + f * .8));\n\to = max(o, -box(p, vec3(.15 + f * .1, .02 + f * .015, .09)));\n\treturn -smin(-o, d, .03);\n}\n\nfloat wat(vec3 p) {\n\tvec3 h1, h2, h3, h4,\n\t     op = p;\n\tp.z -= 3.;\n\n\t// Twist room.\n\tp.xz *= mat2(.707, .707, -.707, .707);\n\n\t// Pool.\n\tfloat d, s = surf(p.xz, op.xz);\n\n\t// Clip pool to pool walls.\n\td = max(p.y + 6., box(p, vec3(8, 66, 8)));\n\n\t// Tentacle.\n\tp -= vec3(3, -7, 3);\n\tvec3 phNow = vec3(.3, .1, 0) * S(6., 10., t);\n\tphNow = mix(mix(mix(mix(mix(phNow, vec3(.37, -.12, 0), S(11., 13., t)), vec3(.3, .1, 0), S(14., 16., t)), vec3(1.09, .23, 0), S(16., 20., t)), vec3(.3, .1, 0), S(22., 24., t)), vec3(.31, .02, 1), S(24., 27., t));\n\tphNow *= S(35.5, 34., t);\n\tphNow.x += .01;\n\tp.y -= .2 * sin(t);\n\tmat2 bf = rot(phNow.z * .9);\n\tp.xz *= rot(.8 - phNow.y * 2.);\n\th1 = vec3(1.4, phNow.x * 4.5, 1.3 * (.5 + .5 * phNow.x));\n\td = smin(d, honk(p, rot(h1.x), h1.y, mix(1.5, h1.z, sat(p.y / h1.y))), 2.5); // angle, length, radius\n\tp.xy *= bf;\n\th2 = vec3(-.7 * phNow.x, h1.yz * vec2(.8, .9));\n\td = smin(d, honk(p, rot(h2.x), h2.y, mix(h1.z, h2.z, sat(p.x / h2.y))), .2);\n\tp.xz *= rot(-phNow.y);\n\th3 = vec3(-.4 * phNow.x, h2.yz * vec2(2.5, .7));\n\td = smin(d, honk(p, rot(h3.x), h3.y, mix(h2.z, h3.z, sat(p.x / h3.y))), .1);\n\tp.xz *= rot(phNow.y * -3.);\n\tp.xy *= bf;\n\th4 = vec3(-.2 * phNow.x, h3.yz * vec2(.4 + dot(phNow.xz, vec2(.15, 1)), .7));\n\td = smin(d, honk(p, rot(h4.x), h4.y, mix(h3.z, h4.z, sat(p.x / h4.y))), .2);\n\td -= s * S01(L(p) - .5 * (S(26.5, 27.5, t) - S(34., 34.5, t)));\n\td = face(p.zyx, d);\n\tg2 += .01 / (4. + d * d);\n\treturn d;\n}\n\nfloat pipe(vec3 p, float r) { return L(p.yz) - r - min(step(.96, fract(p.x * .2)) * r * .2, .1); }\n\nvec2 env(vec3 p) {\n\tp.z -= 3.;\n\tfloat d = max(abs(p.z - 30.), 20. - p.x);\n\n\t// Twist room.\n\tp.xz *= mat2(.707, .707, -.707, .707);\n\n\t// Left wall.\n\td = min(min(d, max(abs(20. - abs(p.z)) - 1.5, p.x - 24.)), 34. - p.z);\n\n\t// Right walls.\n\td = min(min(d, max(abs(25. - abs(p.x)) - 1.5, p.z - 7.7 - step(p.x, 0.) * 12.)), max(abs(5.2 - p.z) - .1, 24. - p.x));\n\n\t// Ceiling.\n\td = smin(d, 10. - p.y, 1.);\n\n\t// Right corner box.\n\td = min(d, max(box(p - vec3(21, 0, 12.6), vec3(2.5, 66, 6)), -box(p - vec3(32, 0, 12.6), vec3(10, 66, 5))));\n\n\t// Left door.\n\td = max(d, .5 - box(p - vec3(4, 0, 20), vec3(4, 4, 2)));\n\n\t// Right doors.\n\tvec3 q = p;\n\tq.y -= .8;\n\tq.z = abs(q.z - 7.) - 5.;\n\tif (p.x > 0.) d = max(max(d, 3. - box(q, vec3(26, 2, 0))), 4. - box(q, vec3(15.4, 2.8, 1)));\n\tvec2 h = vec2(d, 3);\n\n\t// Lamp.\n\td = cap(p.yxz - vec3(5, 23, -3), vec2(1.2, .6));\n\tg += .02 / (1. + d * d);\n\tminH(d, 5.);\n\n\t// Ground/pool hole.\n\tminH(max(p.y + 5., -box(p, vec3(8, 66, 8))), 2.);\n\n\t// Wall pipes.\n\tq = p.yxz - vec3(1, 20.5, 6.4);\n\tq.y = abs(abs(q.y) - .5) - .5;\n\td = pipe(q, .2);\n\n\t// LHS big jobs.\n\tq = p - vec3(0, 9, 18.5);\n\tq.y = abs(q.y) - .6;\n\td = min(d, pipe(q, .5));\n\n\t// Light wires.\n\tq = p.yzx - vec3(0, -11, 23.5);\n\tq.y = abs(abs(q.y) - 6.) - .3;\n\td = min(d, pipe(q, .2));\n\n\t// Roof big jobs.\n\tq = p - vec3(0, 9, 10);\n\tq.z = abs(abs(q.z + 3.5) - 3.) - 1.;\n\td = min(d, pipe(q, .7));\n\n\t// Corridor pipe.\n\td = min(d, pipe(p - vec3(0, -3, 32), 1.));\n\n\t// Floor pipe.\n\tq = p.zxy - vec3(1, 23, -4);\n\td = min(d, max(pipe(q, .8), p.z + 3.));\n\tq.x += 4.;\n\tminH(min(d, L(q) - .8), 4.);\n\treturn h;\n}\n\n// Environment normal.\nvec3 Ne(vec3 p) {\n\tfloat h = L(p) * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * env(p + e * h).x;\n\t}\n\n\treturn U(n);\n}\n\n// Water normal.\nvec3 Nw(vec3 p) {\n\tfloat h = L(p) * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * wat(p + e * h);\n\t}\n\n\treturn U(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float d) {\n\tp += d * n;\n\treturn min(wat(p) * .4, env(p).x) / d;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -4e-4); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, vec2 h) {\n\tif (h.y == 5.) return vec3(1.8 * L(n.xz) + .2);\n\tvec3 c, ld2,\n\t     ld = U(vec3(0, -5, 0) - p);\n\tfloat l1, l2, fre,\n\t      ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\t      sha = 1.,\n\t      l2c = 1.;\n\tvec2 spe = vec2(1.22, .1);\n\tif (h.y == 1.) {\n        // Tentacle.\n\t\tc = vec3(.35, .71, .53) * 1.6 * S(1., -5., p.y);\n\t\tspe = vec2(100, 8);\n\t}\n\telse {\n\t\tfloat n10 = n31(p * 10.);\n\t\tif (h.y == 3.) {\n            // Walls.\n\t\t\tc = vec3(1, .8, .6) - n10 * .06 - n31(p * .5) * .1;\n\t\t\tl2c = .05;\n\t\t}\n\t\telse if (h.y == 4.) {\n            // Pipes.\n\t\t\tc = vec3(1.85, .4, .235);\n\t\t\tspe = vec2(4, .3);\n\t\t}\n\t\telse if (h.y == 2.) {\n            // Chevrons.\n\t\t\tfloat f = step(-6., p.y) * step(max2(abs(p.xz * mat2(.7, .7, -.7, .7) - 2.)), 10.);\n\t\t\tc = mix(vec3(.2), f * (.01 + step(.5, fract(p.x + .75))) * vec3(16, 6, 1), f) * (.4 + .6 * n10);\n\t\t}\n\n\t\tsha = .3 + .7 * sat(S(-3.5, -2., p.y) + step(p.y, -5.));\n\n\t\t// Caustics.\n\t\tvec2 uv = proj(p, n) * .3 + t * .1,\n\t\t     dd = vec2(.1, 0);\n\t\tdd = vec2(surf(uv + dd, uv.yx + dd), surf(uv + dd.yx, uv.yx + dd.yx));\n\t\tc += pow(S01(abs(L((surf(uv, uv.yx) - dd) / .05) - .5)), 3.) * 4.;\n\t}\n\n\t// Primary and secondary lights.\n\tld2 = U(vec3(10, 15, 10) - p);\n\tl1 = sat(.1 + .9 * dot(ld, n)) * (.4 + .6 * ao);\n\tl2 = sat(dot(ld2, n)) * .01 + pow(sat(dot(rd, reflect(ld2, n))), spe.x) * spe.y;\n\tfre = S(.7, .8, 1. + dot(rd, n)) * .1;\n\n\t// Light falloff.\n\tl1 *= S(25., 1., L(vec3(0, -5, 0) - p)) * .8 + .025;\n\tl2 *= (.5 * S(30., 45., L(p)) + S(30., 5., L(vec3(10, 15, 10) - p))) * l2c * ao;\n\tl1 += S01(g2);\n\n\t// Combine into final color.\n\treturn mix(l1 * sha * vec3(.12, 1, 2.5) * c + l2, vec3(.012, .1, .25), fre * sha) + g;\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(0),\n\t     col = vec3(0);\n\tfloat i, d;\n\n\t// March the water.\n\tfor (i = Z0; i < 70.; i++) {\n\t\td = wat(p);\n\t\tif (abs(d) < .0015) break;\n\t\tp += d * rd;\n\t}\n\n\tvec2 h;\n\tif (abs(d) < .0015) {\n\t\tvec3 ord,\n\t\t     n = Nw(p);\n\t\tcol = lights(p, rd, n, vec2(d, 1));\n\t\tvec3 watP = p;\n\t\tord = rd;\n\n\t\t// Hit the water - Get reflection.\n\t\trd = U(reflect(p, n));\n\t\tfor (i = Z0; i < 120.; i++) {\n\t\t\th = env(p);\n\t\t\tif (abs(h.x) < .0015) break;\n\t\t\tp += h.x * rd;\n\t\t}\n\n\t\tif (abs(h.x) < .0015) col = mix(col, lights(p, rd, Ne(p), h) * fog(watP - p), .5);\n\n\t\t// ...and now the refraction.\n\t\tp = watP;\n\t\trd = refract(ord, n, .75);\n\t}\n\telse p = vec3(0);\n\n\t// March the environment.\n\tfor (i = Z0; i < 70.; i++) {\n\t\th = env(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\tp += h.x * rd;\n\t}\n\n\treturn col + lights(p, rd, Ne(p), h) * fog(p);\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t) * S(40., 39., t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 40.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 40.);\n\tvec2 m = mix(vec2(.744, .175), vec2(-.138, .138), S(0., 3.5, t)),\n\t\t uv = (fc - .5 * R.xy) / R.y,\n\t\t q = fc.xy / R.xy;\n\tm = mix(mix(mix(mix(mix(m, vec2(.031, -.208), S(2.5, 7., t)), vec2(.031, .042), S(8.5, 12., t)), vec2(.313, .208), S(16.5, 21., t)), vec2(.069, -.142), S(23., 28.5, t)), vec2(0, -.554), S(34., 37., t));\n\tvec3 lookAt = vec3(0, -.2, 1);\n\tlookAt.yz *= rot(m.y);\n\tlookAt.xz *= rot(m.x);\n\tvec3 r = U(cross(vec3(0, 1, 0), lookAt)),\n         col = scene(U(lookAt + r * uv.x + cross(lookAt, r) * uv.y));\n\tcol *= .1 + .9 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}