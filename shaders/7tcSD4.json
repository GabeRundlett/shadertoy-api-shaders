{
    "Shader": {
        "info": {
            "date": "1639100893",
            "description": "2d girl face",
            "flags": 0,
            "hasliked": 0,
            "id": "7tcSD4",
            "likes": 12,
            "name": "2d girl face",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "gir",
                "lface"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "//por jorge2017a2\n//2d girl face---9-dic-2021\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(0.5),b,d)\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n    colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj-0.05,0.0));\nreturn colOut;\n}\n\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.0001,0.0));\nreturn colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{   p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat ellipse(vec2 p, vec2 focus0, vec2 focus1, float radius) \n{  return distance(p, focus0) + distance(p, focus1) - distance(focus0, focus1) * radius;}\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\nfloat HacerBoca(vec2 p)\n{vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(-0.1,0.0);\n    B=vec2(0.1,-0.1);\n    C=vec2(0.2,0.1);\n\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\nfloat HacerNariz(vec2 p)\n{vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(0.0,0.1);\n    B=vec2(-0.1,-0.1);\n    C=vec2(0.1,-0.1);\n\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\n\nfloat HacerPestanaIzq(vec2 p)  //hacer pestañas\n{ vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(0.0,0.15);\n    B=vec2(0.0,-0.01);\n    C=vec2(0.15,0.0);\n    p*=vec2(1.5,1.5);\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\n\nfloat HacerPestanaDer(vec2 p)  //hacer pestañas\n{ vec2 p0=p;\n     \n    vec2 A,B,C ;\n    A=vec2(0.0,0.1);\n    B=vec2(0.0, 0.0);\n    C=vec2(-0.15,-0.05);\n    \n    p*=vec2(1.5,1.5);\n    float d1= sdBezier(p,A,B,C );\n    return d1;\n}\n\nfloat HacerBanda(vec2 p, float distOld)\n{ vec2 p0=p;\n    p.x= opRep1D(p.x, 0.4 );\n    float d2=sdCircle(p, 0.2 );\n    d2= intersectSDF(d2, distOld);\n    \n    return d2;\n    \n}\n\nvec3 HacerRostro2d(vec2 p, vec3 col)\n{\n    vec2 p0=p;     \n    //cabeza-pelo\n    float da1=sdCircle(p-vec2(0.0,1.2), 0.9 );\n    float da2=sdBox(p-vec2(0.0,0.0), vec2(1.2,0.5) );\n    da1= differenceSDF(da1, da2);\n    \n    //pelo der\n    p= rotatev2(p0-vec2(0.25,0.0), radians(-20.0));\n    float da2a=sdCircle(p-vec2(2.5,0.5), 2.5 );\n    float da2b=sdCircle(p-vec2(-1.5,0.5), 2.5 );\n    float da2a2b= intersectSDF(da2a,da2b);\n    \n    //pelo izq\n    p= rotatev2(p0-vec2(-1.25,0.35), radians(20.0));\n    float db2a=sdCircle(p-vec2(2.5,0.5), 2.5 );\n    float db2b=sdCircle(p-vec2(-1.5,0.5), 2.5 );\n    float db2a2b= intersectSDF(db2a,db2b);\n    \n    //unir pelo\n    float dpelo=da1;\n    dpelo=unionSDF(dpelo,db2a2b);\n    dpelo=unionSDF(dpelo,da2a2b);\n    \n    float r1, r2, he;\n    r1=0.35; r2=1.0; he=0.7;\n    p=p0;\n    float dr1= sdTrapezoid(p-vec2(0.0,-0.2),r1,r2,he);\n    r1=0.015; r2=0.375; he=0.135;\n    float dr2= sdTrapezoid(p-vec2(0.0,-1.0),r1,r2,he);\n     //dr1= unionSDF(dr1, dr2);\n     float t=iTime;\n     dr1=opSmoothUnion(dr1, dr2,0.025+abs(0.35*sin(0.5*sin(1.0-t)+cos(t+1.0))));\n    \n    //hacer Ojo izq\n    p= rotatev2(p0-vec2(-0.25,-0.4), radians(-35.0));\n    float dc1a=sdCircle(p*vec2(1.2,1.0), 0.2 );\n    \n    //ojo\n    p= rotatev2(p0-vec2(0.25,-0.4), radians(35.0));\n    float dc2a=sdCircle(p*vec2(1.2,1.0), 0.2 );\n    \n    //pupila izq\n    p= rotatev2(p0-vec2(-0.12,-0.45), radians(-1.0));\n    float dd1a=sdCircle(p*vec2(1.0,0.7), 0.06 );\n    dd1a= intersectSDF(dc1a,dd1a);\n    \n    //pupila der\n    p= rotatev2(p0-vec2(0.12,-0.45), radians(1.0));\n    float dd1b=sdCircle(p*vec2(1.0,0.7), 0.06 );\n    dd1b= intersectSDF(dc2a,dd1b);\n    \n    //ceja izq\n    p= rotatev2(p0-vec2(-0.2,-0.15), radians(35.0));\n    float de1a= sdBox(p, vec2(0.2,0.01) );\n    //ceja der\n     p= rotatev2(p0-vec2(0.2,-0.15), radians(-35.0));\n    float de1b= sdBox(p, vec2(0.2,0.01) );\n    \n    p=p0;\n    float df1a=HacerBoca(p-vec2(0.0,-0.85));\n    \n    \n    float dg1=HacerNariz(p-vec2(0.0,-0.65));\n    float dh1a=HacerPestanaIzq(p-vec2(-0.5,-0.25));\n    float dh1b=HacerPestanaIzq(p-vec2(-0.5,-0.35));\n    float dh1c=HacerPestanaIzq(p-vec2(-0.5,-0.45));\n    \n    float dh2a=HacerPestanaDer(p-vec2(0.4,-0.25));\n    float dh2b=HacerPestanaDer(p-vec2(0.5,-0.35));\n    float dh2c=HacerPestanaDer(p-vec2(0.5,-0.45));\n    \n    //cuello\n    float dia= sdBox(p-vec2(0.0,-1.2), vec2(0.25,0.4) );\n    \n    p.x=abs(p.x)-0.5;\n    float dja= sdCircle(p*vec2(1.0,0.8)-vec2(0.0,-0.4), 0.2 );//oreja izq\n    \n    p=p0;\n    float dka=HacerBanda(p-vec2(0.0,1.2),dpelo);\n    \n    \n    col= DrawFigBorde(vec3(1.0,0.878,0.878), col, dia);// cuello\n    col= DrawFigBorde(vec3(1.0,0.878,0.878), col, dja);// oreja\n    \n    \n    col= DrawFigBorde(vec3(1.0,0.878,0.878), col, dr1); //rostro\n    col= DrawFig(vec3(0.0,0.0,0.0), col, dpelo);\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col, dka);\n    \n    col= DrawFigDelgado(vec3(0.0), col, dh1a);//pestaña\n    col= DrawFigDelgado(vec3(0.0), col, dh1b);//pestaña\n    col= DrawFigDelgado(vec3(0.0), col, dh1c);//pestaña\n    \n    col= DrawFigDelgado(vec3(0.0), col, dh2a);//pestaña\n    col= DrawFigDelgado(vec3(0.0), col, dh2b);//pestaña\n    col= DrawFigDelgado(vec3(0.0), col, dh2c);//pestaña\n    \n    \n    col= DrawFigBorde(vec3(1.0), col, dc1a);  //ojo\n    col= DrawFigBorde(vec3(1.0), col, dc2a);//ojo\n    \n    col= DrawFigBorde(vec3(0.0), col, dd1a);//pupila izq\n    col= DrawFigBorde(vec3(0.0), col, dd1b);//pupila der\n    \n    col= DrawFigBorde(vec3(1.0), col, de1a); //ceja izq\n    col= DrawFigBorde(vec3(1.0), col, de1b); //ceja der\n    col= DrawFigBorde(vec3(1.0), col, df1a); //boca\n    \n    col= DrawFigBorde(vec3(1.0), col, dg1); //nariz\n    \n    \n    return col;\n}\n    \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    uv-=vec2(0.0,-0.2);\n    float esc=2.0+sin(iTime*2.0);\n    uv*=esc;\n    float t=iTime;\n   vec3 col=vec3(55,171,224)/255.0;\n   \n\n    uv.x= opRep1D(uv.x, 2.5);\n\n    col= HacerRostro2d(uv-vec2(0.0,0.3),col);\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}