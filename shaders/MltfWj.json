{
    "Shader": {
        "info": {
            "date": "1541120033",
            "description": "An optimized dashed circle :D",
            "flags": 0,
            "hasliked": 0,
            "id": "MltfWj",
            "likes": 2,
            "name": "Dashed Circle",
            "published": 3,
            "tags": [
                "circle",
                "dashed"
            ],
            "usePreview": 0,
            "username": "mrsaturn",
            "viewed": 1081
        },
        "renderpass": [
            {
                "code": "#define AA 1\n#define AA_SAMPLES 4\n#define AA_WIDTH 0.004\n\n#define BG_COLOR vec3(0.2, 0.6, 0.6)\n\n// Circle parameters\n#define CIRCLE_INNER_RADIUS_SQUARED 0.58\n#define CIRCLE_OUTER_RADIUS_SQUARED 0.6\n#define CIRCLE_COLOR vec3(1.0)\n#define CIRCLE_CENTER vec2(0)\n#define SEGMENTS 0\n\n// Effects parameters\n#define ROTATE_CLOCKWISE 1\n#define ROTATION_SPEED 1.0\n\n#define SCALE_CIRCLE 1\n#define SCALE_SPEED 1.5\n#define SCALE_LIMIT 1.8\n\n#define CLOCKWISE_HIDING 1\n#if CLOCKWISE_HIDING\n\t#define CIRCLE_DIR 0.0\n#else\n\t#define CIRCLE_DIR 1.0\n#endif\n\n// Mathematical constants\n#define PI_2 6.283185\n\n// Shader constants\nconst float SEGMENT_ANGLE = PI_2 / float(1 << SEGMENTS);\nconst float SAMPLE_INCREMENT = AA_WIDTH / max(float(AA_SAMPLES - 1), 1.0);\nconst float INIT_OFFSET = -AA_WIDTH / 2.0;\n\n// Returns angle of point relative to circle\nfloat theta(vec2 point)\n{\n    float angle = atan(point.y, point.x);\n    angle += PI_2 * float(angle < 0.0);\n    return angle;\n}\n\n// Returns whether or not a pixel should get drawn\nbool hide_pixel(vec2 dir)\n{\n    // use square distance to avoid taking the square root\n    float square_dist = dot(dir, dir);\n    // use 'or' operation to increase chances of avoiding the last check\n    return square_dist > CIRCLE_OUTER_RADIUS_SQUARED || \n           square_dist < CIRCLE_INNER_RADIUS_SQUARED ||\n           mod(floor(theta(dir) / SEGMENT_ANGLE), 2.0) != CIRCLE_DIR;\n}\n\n// Applies 2D rotation matrix to point\nvec2 rotate_2d(vec2 point, float angle)\n{\n    float s_theta = sin(angle);\n    float c_theta = cos(angle);\n    return vec2(point.x * c_theta - point.y * s_theta, \n                point.x * s_theta + point.y * c_theta);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // clamp coordinates from -1 to 1, and account for aspect-ratio\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n#if SCALE_CIRCLE\n    // make the circle shrink and grow\n    coord *= sin(iTime * SCALE_SPEED) + SCALE_LIMIT;\n#endif\n    \n#if ROTATE_CLOCKWISE\n    coord = rotate_2d(coord - CIRCLE_CENTER, iTime * ROTATION_SPEED);\n#else\n    coord = rotate_2d(coord - CIRCLE_CENTER, -iTime * ROTATION_SPEED);\n#endif\n    \n    float color_val\n#if AA\n \t= 0.0;\n\tfloat offset_y = INIT_OFFSET;\n    for (int i = 0; i < AA_SAMPLES; ++i)\n    {\n        float offset_x = INIT_OFFSET;\n        for (int j = 0; j < AA_SAMPLES; ++j)\n        {\n            color_val += float(hide_pixel(coord + vec2(offset_x, offset_y)));\n            offset_x += SAMPLE_INCREMENT;\n        }\n        \n        offset_y += SAMPLE_INCREMENT;\n    }\n    \n    color_val /= float(AA_SAMPLES * AA_SAMPLES);\n#else\n    = float(hide_pixel(coord));\n#endif\n    \n    fragColor = vec4(mix(CIRCLE_COLOR, BG_COLOR, color_val), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}