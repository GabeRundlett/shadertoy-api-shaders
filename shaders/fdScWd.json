{
    "Shader": {
        "info": {
            "date": "1644331459",
            "description": "Traversing a regular grid of rectangles, an offset grid of rectangles or hexagons.",
            "flags": 0,
            "hasliked": 0,
            "id": "fdScWd",
            "likes": 44,
            "name": "Offset Grid Traversal",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "brick",
                "traversal",
                "traverse"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 678
        },
        "renderpass": [
            {
                "code": "/*\n\n    Offset Grid Traversal\n    ---------------------\n    \n    Since there are so many traversers around, I figured I'd put up a less \n    common one just to show that it's possible to traverse 2D grids other \n    than regular polygons and Voronoi -- The 2D traversal here can be \n    extended to the extruded 3D version with relative ease.\n    \n    The default grid you can see consists of offset rectangles, or a brick\n    arrangement, if you prefer. There are also options for a regular rectangle \n    grid and a hexagonal one, which is inherently offset. The main routine is \n    fast enough, but could be faster. There are some very simple precalculations \n    that could be made to speed things up, but I wanted to illustrate the \n    concepts involved. You could certainly write much faster individual grid \n    traversers.\n    \n    I've been trying to render some isosurfaces lately that involve way too\n    much overlap for a simple sphere-tracing based raymarching routine, so \n    have had to resort to cell by cell grid traversal.\n    \n    I'm comfortable enough with the process, but still found it helpful to\n    reference various examples. There are heaps of nice demonstrations on \n    Shadertoy, but I found IQ and Fizzer's to be written in a style that I \n    prefer, so I referenced those most. If you'd like to learn 2D traversal,\n    then I'd recommend IQ's simple hexagon traverser. If you'd like to \n    tackle more difficult 3D traversers, have a look at some of Fizzer's\n    examples.\n    \n    Grid traversal is a pretty simple concept: Start at the ray origin point \n    and snap it to the nearest grid cell. Trace out from that point in the \n    direction of the unit direction ray to the nearest cell wall. Obtain the \n    neighboring cell, then trace out from the last point to the next cell \n    wall. Continue in the same manner until you reach the end.\n    \n    Anyway, I posted this for the novelty, but I have more interesting \n    traversals that I'll post at some stage. I also have a 3D version of this\n    that I'll put up later.\n    \n    \n    \n    // Other examples:\n    \n    \n    // There are various square cell traversal examples on here,\n    // but this is one I'd recommend looking at if you want to\n    // learn how to traverse regular polygons in 2D.\n    Hexagonal Grid Traversal - 2D -- iq\n    https://www.shadertoy.com/view/WtSBWK\n    \n    // IQ's 3D version: It's beautifully rendered and the traversal \n    // code leaves very little room for improvement.\n    Hexagonal Grid Traversal - 3D -- iq\n    https://www.shadertoy.com/view/WtSfWK\n    \n    // A very cool technical traversal example: For obvious reasons,\n    // it has a marching tetrahedron feel. It's on my list to combine\n    // one of these with the marching tetrahedrons example of mine\n    // on here. By the way, it's worth taking a look at Fizzer's other\n    // traversal examples as well.\n    Tetrahedral Voxel Traversal -- fizzer\n    https://www.shadertoy.com/view/wtfXWB\n    \n    // I think Mattz was the first to traverse hexagonal prisms\n    // on here. He's also written a box prism traverser.\n    hexwaves -- mattz\n    https://www.shadertoy.com/view/XsBczc\n    \n    // An unlisted simplified rectangle traversal example that \n    // should be much easier to understand.\n    Minimal Line Traversal - Shane\n    https://www.shadertoy.com/view/sdfBDM\n    \n    \n*/\n\n// Hexagon option. \n//#define HEXAGON\n\n// Offset grid rows.\n#define OFFSET\n\n// Hexgons must have an offset defined.\n#ifdef HEXAGON\n#ifndef OFFSET\n#define OFFSET\n#endif\n#endif\n\n// Dark layout option.\n//#define DARK\n\n#define sqrt3 1.7320508\n\n\n// Scale.\n#ifdef HEXAGON\n// Hexagons will only work with the \"1:sqrt3\" ratio, but scaling is fine.\n// At some stage, I'll arrange for anything to work, but it's not trivial.\nconst vec2 s = vec2(1, sqrt3); \n#else\n// Rectangle dimensions. Any numbers should work. Obviously, the same two\n// numbers will produce squares.\nconst vec2 s = vec2(1.5, 1); \n#endif\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n/*\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more, but it isn't\n   // a GPU intensive example, so it'll do.\n   float s = dot(p - ro, n)/dot(rd, n);\n   return s<0. ? 1e8 : s;\n\n}\n*/\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   return dot(p - ro, n)/dot(rd, n);\n\n}\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(in vec2 p, in vec2 a, in vec2 b){\n\t\n    p -= a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(p, ba)/dot(ba, ba), 0., 1.);\n\treturn length(p - ba*h);\n}\n \n\n\n\n\n// Grid cell function.\nvec4 getGrid(vec2 p){\n\n    \n    // Returns the local coordinates and cell center position-based\n    // IDs for a hexagon grid, offset rectangle grid and regular\n    // rectangle grid.\n\n    #ifdef HEXAGON\n    \n    // Hexagons.  \n    //\n    vec4 hC = floor(vec4(p/s, p/s - vec2(.5, sqrt3/3.))) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n    \n    #else\n    \n    // Rectangles.   \n    //    \n    #ifdef OFFSET\n    // Rectangles with an offset. \n    vec2 idOff = vec2(0);\n    if(mod(floor(p.y/s.y), 2.)>.5){\n       p.x -= s.x/2.;\n       idOff.x += .5;\n    }\n    vec2 ip = floor(p/s) + .5;\n    p -= (ip)*s;\n    return vec4(p, ip + idOff);\n    #else\n    // Rectangles with no offset. \n    vec2 ip = floor(p/s) + .5;\n    p -= (ip)*s;\n    return vec4(p, ip);\n    #endif    \n    \n    #endif\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor. With larger resolutions, you want larger \n    // cells, but not so large that everything lacks detail... I'm not a\n    // fan of catering to multiple resolutions, but it is what it is. :)\n    #ifdef HEXAGON\n    float sc = 1./8.*(450./iResolution.y*.5 + .5);\n    #else\n    float sc = 1./10.*(450./iResolution.y*.5 + .5);\n    #endif\n    float sf = 1./(iResolution.y*sc);\n    \n    \n    // Scaling.\n    vec2 p = uv/sc;\n\n    \n    // Note that the scale is partly dependent on screen size, which means\n    // the ray origin will be different for different resolutions.\n    vec2 ro = vec2(sin(iTime/2.)/3., cos(iTime/2.)/4.)/sc;\n    \n    // The unit direction vector. It's already normalized, but it's\n    // good practice to do it.\n    vec2 rd = normalize(vec2(cos(iTime/4.), sin(iTime/4.)));\n    \n    \n    // Moving the camera up, or the scene down, depending on your perspective.\n    // I like it, but Moire patterns (or something along those lines) get in \n    // the way at lower resolutions, so it's off by default.\n    //p.y += iTime/8.;\n    //ro.y += iTime/8.;\n     \n    \n    \n    // Creating the grid for the background cells.\n    vec4 cell = getGrid(p);\n    \n  \n    // Vertices and lines to render at each ray step.\n    float ln = 1e5;\n    float vert = 1e5; \n    \n    \n    // Describing the shape sides via their normals: You'll note that only\n    // half the faces (or sides) are described; That's because only half \n    // are in front of the ray at any given time. When the back face \n    // condition is met (dot(rd, n)<0.), we simply flip the normal, so that\n    // the face behind it is visible. If the the polygon didn't have the \n    // correct symmetry (like an assymetric hexagon, etc), then you'd have\n    // to list all sides.\n    //\n    // Note that the hexagon normals are in index form. They're multiplied\n    // by the scaling factor (s = vec2(1, 1.732)) to turn them into normalized\n    // hexagon side normals. Adding indices then scaling is more accurate, \n    // which is important when doing 3D traversals.\n    #ifdef HEXAGON\n    //\n    // Hexagon.\n    //\n    vec2 n1 = vec2(-.5, .5); // Left face down.\n    vec2 n2 = vec2(1, 0); // Right face.\n    vec2 n3 = vec2(.5, .5); // Right face down.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing\n    // cell wall, if you prefer), use the normal from the back back cell wall.\n    n1 = dot(rd, n1*s)<0.? -n1 : n1;\n    n2 = dot(rd, n2*s)<0.? -n2 : n2; \n    n3 = dot(rd, n3*s)<0.? -n3 : n3; \n    #else\n    //\n    // Rectangle.\n    //\n    vec2 n1 = vec2(0, 1); // Top face, or line.\n    vec2 n2 = vec2(1, 0); // Righ face, or line.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing\n    // cell wall, if you prefer), use the normal from the back back cell wall.\n    n1 = dot(rd, n1)<0.? -n1 : n1;\n    n2 = dot(rd, n2)<0.? -n2 : n2;\n\n    #endif\n \n \n \n    // Cell hit flag.\n    int hit = 0;\n    \n    // Initiate the ray position at the ray origin.\n    vec2 pos = ro;\n    \n     \n    // Iterate through 24 cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<24; i++){\n    \n        // Obtain the coordinates of the cell that the current ray position \n        // is contained in -- I've arranged for the cell coordinates to \n        // represent the cell center to make things easier.\n        //\n        // Note that we're edging the ray just over the line to avoid hitting \n        // the cell we've just come from. You could edge by the side normal, \n        // but that requires more calculation.\n        //\n        // The last thing to mention is that you'd normally do this outside \n        // the loop once, then add cell wall indices, but the offset rectangles\n        // complicate things a little, so we're doing it the slow way. Having\n        // said that, it's not a big calculation, so the GPU will get over it. :)\n        vec2 ip = getGrid(pos + rd*1e-4).zw;\n        // Technically, it should be this, but no one will notice. :)\n        //vec2 ip = getGrid(pos + min(float(i), 1.)*rd*1e-4).zw;\n        \n        // Ray intersection from the currect cell position to each of the \n        // visible cell walls: Note that the normal is inward facing. Also,\n        // the point on the line is the cell center plus half the cell scale\n        // distance in the direction of the cell wall.\n        #ifdef HEXAGON\n        // Ray origin, ray direction, point on the line and normal.\n        float t1 = rayLine(pos, rd, (ip + n1*.5)*s, -n1*vec2(1, sqrt3));\n        float t2 = rayLine(pos, rd, (ip + n2*.5)*s, -n2*vec2(1, sqrt3));\n        // Extra side consideration for the hexagon.\n        float t3 = rayLine(pos, rd, (ip + n3*.5)*s, -n3*vec2(1, sqrt3));\n        float t = min(min(t1, t2), t3); \n        #else\n        // Ray origin, ray direction, point on the line and normal.\n        float t1 = rayLine(pos, rd, (ip + n1*.5)*s, -n1);\n        float t2 = rayLine(pos, rd, (ip + n2*.5)*s, -n2);\n        float t = min(t1, t2);\n        #endif \n        \n     \n        // Mark the vertex point and ray\n        vert = min(vert, (length(p - pos)  - .1));\n        ln = min(ln, (distLine(p, pos, (pos + rd*t)) - .015));\n        \n     \n        // If this cell's ID matches the ID of the backgound cell, \n        // flag it as hit in order to color it, or whatever.\n        if(length(cell.zw - ip)<.001){ hit = 1; }\n        \n        \n        // Advance the ray position.\n        pos += rd*t;\n    \n    }\n    \n     \n    // Last vertex point.\n    vert = min(vert, (length(uv - pos)  - .01)/sc);\n    \n \n \n    // Rendering.\n    //\n    //\n    // Rendering the background grid. We're taking two samples for bump mapping\n    // purposes. An easier, and less lazy, way would be to use IQ's hexagon\n    // and rectangle gradient fields. :)\n    vec2 acell = abs(cell.xy);\n    vec2 acell2 = abs(cell.xy - normalize(vec2(1, -2))*.01*sc); // Offset sample.\n    #ifdef HEXAGON\n    // Hexagon grid hexagons.\n    float hx = max(acell.y*sqrt3/2. + acell.x*.5, acell.x) - s.x/2.;\n    float hx2 = max(acell2.y*sqrt3/2. + acell2.x*.5, acell2.x) - s.x/2.;\n    #else\n    acell -= s/2.;\n    acell2 -= s/2.;\n    float hx = max(acell.y, acell.x);\n    float hx2 = max(acell2.y, acell2.x);\n    #endif\n    \n    // Bump map, or highlight value.\n    float b = max(hx2 - hx, 0.)/(.01*sc);    \n    \n    // Two colors to decorate the background and hightlighted cells. There are\n    // two color schemes: Dark and textured.\n    #ifdef DARK\n    vec3 col1 = vec3(.04) + hash21(cell.zw)*.02;\n    vec3 col2 = vec3(5, 12, 1)*col1;\n    //vec3 col2 = vec3(3, .1, 15)*col1; // Reverse.\n    #else\n    // Using a texture to color the cells.\n    vec3 tx = texture(iChannel0, cell.zw*s*sc/8. + .5 + vec2(1, 2)*fract(iTime*.0002)).xyz; tx *= tx;\n    // Hacky way to brighten up the dark spots.\n    if(dot(tx, vec3(.299, .587, .114))<.1) tx = tx/(.5 + dot(tx, vec3(.299, .587, .114))) + .03;\n     // Two colors to decorate the background and hightlighted cells.\n    vec3 col1 = smoothstep(-.05, .5, tx.yzx);\n    vec3 col2 = smoothstep(-.02, .5, tx.yzx)*1.35;\n    #endif\n    \n   \n    \n    // Adding some bump highlighting.\n    col1 += (col1*.5 + .5)*b*b*.125;\n    col2 += (col2*.5 + .5)*vec3(4, 1, .5)*b*b*.25 + .03;\n    \n    // Line pattern.\n    float lnSc = 7.;\n    float pat = (abs(fract((p.x - p.y)*lnSc) - .5)*2. - .25)/lnSc;\n    pat = smoothstep(0., sf*2., pat);\n    \n    \n    \n    // Scene color.\n    vec3 col = vec3(0);\n    \n    sc = 1./12.;\n    if(hit == 0){\n        // If the cell hasn't been hit by the ray, render the purple background.\n        col = mix(col, mix(col1, col2.xxx, .05)*1.5, 1. - smoothstep(0., sf, hx + .004/sc));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, hx + (.0045 + .004)/sc));\n        col = mix(col, col1*(pat*.75 + .25), 1. - smoothstep(0., sf, hx + (.0045 + .008)/sc ));\n    }\n    else {\n        // Render the hit cells with something that stands out. I've chosen lime green...\n        // for better or worse. :D\n        col = mix(col, col2*1.5 + .1, 1. - smoothstep(0., sf, hx + .004/sc));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, hx + (.0045 + .004)/sc));\n        col = mix(col, col2.xzy*(pat*.5 + .5), 1. - smoothstep(0., sf, hx + (.0045 + .008)/sc ));\n        \n        float cCntr = length(cell.xy) - .1;\n        //float cCntr = hx + .4;    \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, cCntr))); // Border.\n        col = mix(col, col2, (1. - smoothstep(0., sf, cCntr + .004/sc))); // Top layer.\n\n    } \n     \n    // Render the ray over the background.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, ln))); // Dark line.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert))); // Vertices.\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, vert + .003/sc));\n    \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}