{
    "Shader": {
        "info": {
            "date": "1606675490",
            "description": "A screw is fired from a rotating square!!",
            "flags": 0,
            "hasliked": 0,
            "id": "wdGfzD",
            "likes": 11,
            "name": "Screw and Square",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.141592653;\nconst float PI2 = 2.0 * PI;\n\n// square\nconst int N = 4;\n\n// the circumradius of polygon\nconst float R_POLY = 0.4;\n\nconst float SCREW_THICKNESS = 0.02;\n\n// the half of thickness of polygon edges\nconst float THICKNESS = 0.025;\n\n// Good Colors!!\nconst vec3 COLOR[N] = vec3[](\n    vec3(226.0, 133.0, 27.0) / 255.0,\n    vec3(126.0, 107.0, 152.0) / 255.0,\n    vec3(238.0, 200.0, 80.0) / 255.0,\n    vec3(136.0, 175.0, 34.0) / 255.0\n);\n\n// the radius of the vertex of square\nconst float R_DOT = 0.04;\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0, 1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    return 2.0 * coord / iResolution[min_idx] - aspect_vec;\n}\n\n// Creates vertices of polygon\nvec2[N] createVertex() {\n    vec2 vertex[N];\n    for (int i = 0; i < N; i++) {\n        float theta = float(i) / float(N) * PI2;\n        vertex[i] = vec2(cos(theta), sin(theta)) * R_POLY;\n    }\n    return vertex;\n}\n\nfloat get_angle(in vec2 uv) {\n    float theta = acos(uv.x / length(uv));\n    if (uv.y < 0.0) theta = 2.0 * PI - theta;\n    return theta;\n}\n\nfloat torus_distance(in float x, in float y) {\n    float a = abs(x - y);\n    float b = abs(PI2 + x - y);\n    float c = abs(x - y - PI2);\n    return min(a, min(b, c));\n}\n\nvec4 renderScrew(in vec2 uv) {\n    float len = length(uv);\n    float theta = get_angle(uv);\n    float c = 0.0;\n    int idx = 0;\n    for (int i = 0; i < N; i++) {\n        if (len < R_POLY) continue;\n        float delta = float(i) / float(N);\n        float phase = fract((iTime - PI2 * len + PI2 * delta) / PI2) * PI2;\n        float dist = smoothstep(0.0, 1.0, (torus_distance(phase, theta) / PI2) / SCREW_THICKNESS);\n        if (c < 1.0 - dist * dist * dist) {\n            c = 1.0 - dist * dist * dist;\n            idx = i % N;\n        }\n    }\n    return vec4(c * COLOR[idx], 1.0);    \n}\n\nvec4 renderSquare(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    float plus = abs(uv.x + uv.y);\n    float minus = abs(uv.x - uv.y);\n    if (plus < R_POLY - THICKNESS && minus < R_POLY - THICKNESS)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else if (plus < R_POLY + THICKNESS && minus < R_POLY + THICKNESS) {\n        float k = 1.0 - abs(plus - R_POLY) / THICKNESS;\n        k = max(k, 1.0 - abs(minus - R_POLY) / THICKNESS);\n        k = 1.0 - pow(1.0 - k, 5.0);\n        vec3 col = vec3(0.0);\n        for (int i = 0; i < N; i++) {\n            float c = distance(vertex[i], uv) / R_POLY;\n            c = smoothstep(0.0, 1.0, c);\n            c = 1.0 - pow(c, 3.0);\n            col += c * COLOR[i] * k;\n        }\n        fragColor = vec4(col, 1.0);\n    }\n    return fragColor;\n}\n\nvec4 renderVertices(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    for (int i = 0; i < N; i++) {\n        if (distance(uv, vertex[i]) < R_DOT) {\n            float c = distance(uv, vertex[i]) / R_DOT;\n            c = 1.0 - pow(c, 5.0);\n            fragColor = vec4(COLOR[i] * c, 1.0);\n        }\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uv_coord(fragCoord);\n    vec2 vertex[N] = createVertex();\n    fragColor = renderScrew(uv);\n    fragColor = renderSquare(fragColor, uv, vertex);\n    fragColor = renderVertices(fragColor, uv, vertex);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}