{
    "Shader": {
        "info": {
            "date": "1398340227",
            "description": "mouse: freq and dir of Gabor.\nA: mouse.y tunes angular spread instead.\nT: mouse.x tunes gaussian thickness instead.\nRed: Fourier representation of the Gabor function.\nCyan: Signal representation of the Gabor function.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsfXzM",
            "likes": 19,
            "name": "Gabor3",
            "published": 3,
            "tags": [
                "gabor"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 2396
        },
        "renderpass": [
            {
                "code": "// inspired from https://www.shadertoy.com/view/MdjGWy#\n\n\n// for faster eval, you can decrease proportionnaly NB and GAUSS_F to keep coverage\nfloat GAUSS_F = .1;    // size of gabor blobs\n#define NB 100.        // number or gabor blobs\n\n#define SCALE 30.      // SCALING FACTOR for superimposing signal and fourier spaces\n\n#define PI 3.14159265358979\n\n// --- key toggles -----------------------------------------------------\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\n// --- util math func  -----------------------------------------------------\n\n#if 0  // 1: texture-based noise  0: function-based noise\nfloat rnd(vec2 uv, int z) \n{\n\tif      (z==0) return texture(iChannel1,uv).r;\n\telse if (z==1) return texture(iChannel1,uv).g;\n\telse if (z==2) return texture(iChannel1,uv).b;\n\telse           return texture(iChannel1,uv).a;\n}\nfloat rndi(float i, float j)\n{\n\tvec2 uv = vec2(.5+i,.5+j)/ iChannelResolution[1].x;\n\treturn texture(iChannel1,uv).r;\n}\n#else\nfloat rndi(float i, float j)\n{\n\treturn fract(sin(i+9876.*j)*12345.678);\n}\n#endif\n\nfloat gauss(float x, float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(float x) {\n    return exp(-.5*x*x); \n}\nfloat gauss(float s,vec2 D) {\n\tfloat d = dot(D,D)/(s*s);\n\treturn exp(-.5*d); \n}\n\n#define SQR(x) ((x)*(x))\n\nfloat gabor(vec2 pos, vec2 k, float gaussF, float phi) {\n\tfloat g = gauss(length(pos), 1./gaussF);\n    float s = .5*sin(2.*PI*dot(pos,k) - phi);\n\treturn g*s;\n}\n\n// -----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.85,.5));\n\n\t// --- tuning \n\t\n\tvec4 mouse; \n\tmouse.xy = 2.*(iMouse.xy/  iResolution.y - vec2(.85,.5));\n\tmouse.zw = 2.*(abs(iMouse.zw)/  iResolution.y - vec2(.85,.5));\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\n\tvec3 col;\n\tfloat vS=0.,vF=0.,A=0.;\n\t\n\tvec2 k = mouse.xy; // wave number\n\t\n\tif (!keyToggle(65)) { // tune angular spread\n\t\tA = PI/2.* .5*(1.+mouse.y);\n\t\tk.y = mouse.w;\n\t}\n\tif (keyToggle(84)) { // tune angular spread\n\t\tGAUSS_F *= 4.*iMouse.x/iResolution.x;\n\t\tk.x = abs(mouse.z);\n\t}\n\t\n\t\n\t// --- display\n\t\n\tvec2 k_ortho = vec2(-k.y,k.x);\n\t\n\t// in Fourier space, Gabor = Gauss(s)*F(sin) = 2 Gaussians at k and -k\n\t// in signal space, Gabor = Gauss(1/s).sin(kx)  * white\n\n\tfor (float i=0.; i<NB; i++) { \n\t\t\n\t\t// random sample within angular spread\n\t\tfloat a = A*(2.*i/NB-1.);\n\t\tvec2 Rk = cos(a)*k + sin(a)*k_ortho;\n\n\t\t// signal space:  white := Poisson point distrib -> sum random pos\n\t\tvec2 pos =2.*vec2(1.5*rndi(i,0.),rndi(i,1.))-1.;\t\t\n\t\tvS += gabor(SCALE*(uv-pos), Rk, GAUSS_F, 10.*iTime +float(i));\n\t\t// Fourier: (dirac+ + dirac-)*gauss\n\t\tvF += \t\t gauss(    GAUSS_F,uv-Rk) + gauss(    GAUSS_F,uv+Rk)\n\t\t\t - 10.*( gauss(.02*GAUSS_F,uv-Rk) + gauss(.02*GAUSS_F,uv+Rk) );\n\t}\n\t\n\tvF *= max(1., length(k)*2.*A/(PI*GAUSS_F)) /float(NB); // normalization\n\tvS = (1.-vF)*(vS*sqrt(3.*GAUSS_F)+1.)/2.;\n\n\tfragColor = vec4(vF,vS,vS,1.);\n}\n                  \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}