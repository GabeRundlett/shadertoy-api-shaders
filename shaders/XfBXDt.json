{
    "Shader": {
        "info": {
            "date": "1706939858",
            "description": "Arrows / WASD and Space\n\nthings to do:\n* find the five AIâ„¢ agents\n* find the tunnels\n* find the four secret tunnels\n* jump to the orbiting ring !",
            "flags": 48,
            "hasliked": 0,
            "id": "XfBXDt",
            "likes": 26,
            "name": "SDF Runner 3d",
            "published": 3,
            "tags": [
                "game",
                "refraction",
                "stereo",
                "dynamics",
                "optics",
                "fresnel",
                "schlick",
                "gravity",
                "awesome",
                "car",
                "driving",
                "ai",
                "playable",
                "playable",
                "morton"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "/***************************************************************************\n\nSDF Runner !\n2D version for detail on driving mechanics: https://www.shadertoy.com/view/4fBXDt\n3D version for driving around a huge SDF:   https://www.shadertoy.com/view/XfBXDt\n\nControls:\nArrow Keys or WASD, plus Space for Action!\nNumber keys change rendering options.\n\nBufferA: Handles car dynamics. Very siilar code in 2D and 3D versions.\nCommon:  The 'terrain' SDF is defined here,\n         so that it can be used by both BufferA and Image.\nImage:   Rendering.\n\nThe number of rays per pixel is dialed pretty far down here for performance.\nFor higher quality transparency, change \"gHQMult\" in \"Image\" to 3 or 5 or so.\n\nOrion Elenzil 2024\n\n***************************************************************************/\n\n//--------------------------------------------------------------------------\n// Viewport and Time\nconst float gZoom       = 0.8;\n      float gFOVZoom    = 1.0;\n      float gCamDist    = 3.0;\nconst float gToggleZoom = 2.0;\nconst float gStereoSep  = 0.3;\n\n//--------------------------------------------------------------------------\n// ray handling parameters\n\n#define SUBSURFACE 0   // not-quite-right subsurface scattering.\n#define FANCY_CARS 0   // they're not that fancy, but they are expensive.\n                       // if the perf is terrible with fancy cars,\n                       // try reducing the number of them in Common\n                       // at the start of \"car stuff\".\n\n// maximum number of rays per pixel.\n// reflection, diffuse, and transmission all spawn a ray,\n// and a single ray travels until it hits a boundary.\nconst uint  gHQMult         =   1u;\nconst uint  gMaxRays        =  11u * gHQMult;\nconst uint  gQueueSize      =   4u * gHQMult;\n\n// standard marching parameters\nconst uint  gMaxMarchSteps  = 200u * gHQMult;\n// const float gMarchEps       = 0.03;              // defined in common\n// const float gNormEps        = gMarchEps * 0.4;   // defined in common\nconst float gMarchMaxT      = 1e3;\nconst float gMarchUnderstep = 0.95 * 11.0 / (10.0 + float(gHQMult));\nconst float gHitBackoff     = gMarchEps * -1.0;\n\n// smallest contribution before extinguishing a ray\nconst float gMinAmt         = 0.015 / float(gHQMult);\n\n// direction to the light\nvec3  gLightDir             = normalize(vec3(2.0, 1.5, 1.0));\nfloat gAmbient              = 0.02;\n\n// heat map stuff toggle with '1'.\n      float gMapCount       = 0.0;\nconst float cHeatMapSteps   = 200.0;\nconst float cHeatMapRays    = 5.0;\n\n// debugging color\n      vec3  gDbg            = v0;\n\n\n// align the positive X axis with fwd.\nmat2 matFwdFromX(in vec2 fwd) {\n    vec2 prp = vec2(-fwd.y, fwd.x);\n    return -(mat2(prp.x, fwd.x, prp.y, fwd.y));\n}\n\ncar_t gCars   [gCarCount];\n#if FANCY_CARS\nmat3  gCarMats[gCarCount];\n#endif\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff\nbool kPipOn;        // 1. heat map\nbool kXEyedStereo;  // 2. x-eyed stereo\nbool kReflection;   // 5. transmission\nbool kTransmission; // 6. transmission\n// pbpaste | sed -e 's/.*\\/\\/ //' | pbcopy\n\nconst float cPipScale = 0.45;\nvec3  gMouse;\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn        =  KEY_TOGGLED(ZRO + 1, iChannel3);\n    kXEyedStereo  =  KEY_TOGGLED(ZRO + 2, iChannel3);\n    kReflection   = !KEY_TOGGLED(ZRO + 5, iChannel3);\n    kTransmission = !KEY_TOGGLED(ZRO + 6, iChannel3);\n    // car control keys are read in Buffer A.\n}\n\nvoid readMouse() {\n    gMouse = texelFetch(iChannel2, ivec2(0), 0).xyz;\n}\n\n//--------------------------------------------------------------------------\n// Materials\n\nmtl_t mtls[] = mtl_t[] (\n    //    albedo             opac   ior    absorption\n    mtl_t(vX * 1e9         , 1.0  , 1.0  , v41                     ), // 0 invalid\n    mtl_t(v1               , 0.0  , 1.0  , v41 * 0.5               ), // 1 air\n    mtl_t(v1 * 0.7         , 1.0  , 1.2  , v41                     ), // 2 floor\n    mtl_t(v1               , 0.0  , 1.3  , vec4(0.8, 0.1, 0.1, 2.9)), // 3 car\n    mtl_t(v1               , 0.0  , 1.3  , vec4(0.3, 0.8, 0.7, 3.9)), // 4 car\n    mtl_t(vZ * 0.6         , 0.3  , 1.4  , vec4(0.8, 0.7, 0.6, 0.7)), // 5 box\n    mtl_t(v0               , 0.0  , 1.3  , vec4(0.4, 0.5, 0.9, 0.2))  // 6 inclusions\n);\n\n\nvec3 albedo(hit_t hit) {\n    uint mtl = hit.ms.mtl;\n    vec3 rgb = mtls[mtl].albedo;\n    if (mtl == gMtlFloor) {\n        float f  = 0.0;\n        vec3  w   = hit.pnt;\n        float spinning = planetSpinAmt(w);\n        w.xz = mix(w.xz, w.xz * gRingMat, spinning);\n        vec3  xyz = mod(w + 10.0, 20.0) - 10.0;\n        // make the gridlines fuzzier at farther distances\n        float q = 0.9 + max(0.0, hit.t - 3.0) / 100.0;\n        f  = max(f, smoothstep(q, 0.3, abs(xyz.x)));\n        f  = max(f, smoothstep(q, 0.3, abs(xyz.y)));\n        f  = max(f, smoothstep(q, 0.3, abs(xyz.z)));\n        rgb = mix(rgb, rgb * 2.5, f);\n    }\n    return rgb;\n}\n\nvec4 absorption(uint mtl, in vec3 pnt) {\n    vec4 ret = mtls[mtl].absorption;\n    if (mtl == 6u) {\n        ret.rgb = spectrum((-pnt.x * 0.7 + 287.0) / (287.0 * 2.0), 0.0);\n    }\n    return ret;\n}\n\nfloat ior(MST ms) {\n    const float atmosphere = 1.0;\n\n    if (ms.dist > 0.0) {\n        return atmosphere;\n    }\n    \n    return mtls[ms.mtl].ior;\n}\n\nvec3 sky(ray_t ray) {\n\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * sat(ray.rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(ray.rd, gLightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(ray.rd.z, ray.rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(ray.rd.y)));\n    return c;\n}\n\n//--------------------------------------------------------------------------\n// ray-vs scene stuff\n\nMST msCar(in vec3 p, int n) {\n    car_t car = gCars[n];\n    float d;\n    \n    float carSize = car.siz;\n    \n    p -= car.pos;\n    \n    #if FANCY_CARS\n    p *= gCarMats[n];\n    p.xz = rot90(p.xz);\n    d = sdBox(p, vec3(carSize * 0.6, carSize * 0.2, carSize)) - carSize * 0.1;\n    #else\n    d = sdSphere(p, carSize);\n    #endif\n    \n    return MST(d, n == gPlayerCarIndex ? 4u : 3u);\n}\n\nmat2  gBoxRot;\nvec3  gCamAntiBob;\n\nvoid setupScene() {\n    gBoxRot = rot2(gT * 0.1);\n}\n\n// reports the distance to the surface\n// and the material which the sample point is in.\nMST sdScene(in vec3 p) {\n    gMapCount += 1.0;\n\n    MST ms = MST(1e9, gMtlAir);\n    float f;\n    \n    // the planet.\n    // this is the only thing that affects dynamics\n    opUnion(ms, MST(sdPlanet(p), gMtlFloor));\n    \n    // big turning rod\n    vec3 q = p;\n    q.zy *= gBoxRot;\n    const float rodRound    = 3.0;\n    const float rodLength = 286.5;\n    f = sdBox(q, vec3(rodLength, 8.0, 8.0) - rodRound) - rodRound;\n    opUnion(ms, MST(f, 5u));\n    // inclusions\n    const float stride = 44.0;\n    q.x = mod(q.x + stride / 2.0, stride) - stride / 2.0 + stride / 4.0;\n    vec3 qq = q;\n    qq.xz *= gBoxRot;\n    f = sdBox(qq, vec3(3.0, 11.0, 3.0) - 0.5) - 0.5;\n    q.x -= stride / 2.0;\n    q.xy *= gBoxRot;\n    f = min(f, sdBox(q, vec3(3.0, 3.0, 11.0) - 0.5) - 0.5);\n    f = abs(p.x) > rodLength + 1.0 ? 1e9 : f;\n    opReplace(ms, MST(f, 6u));\n\n    // cars\n    for (int n = 0; n < gCarCount; ++n) {\n        opUnion(ms, msCar(p, n));\n    }\n    \n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    \n    return ms;\n}\n\nvec3 normalScene(in vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n\nvoid rayVsFloor(ray_t ray, inout hit_t hit) {\n    // no floor\n}\n\nvoid rayMarch(ray_t ray, inout hit_t hit) {\n\n    float t = 0.0;\n    \n    MST ms;\n    uint n;\n    vec3 p;\n    for (n = 0u; n < gMaxMarchSteps; ++n) {\n    \n        // if our hit already has a hit\n        // and our t is not closer than it, return.\n        if (hit.hit && t >= hit.t) {\n            return;\n        }\n    \n        // sample the map (without floor)\n        p        = ray.ro + ray.rd * t;        \n        ms       = sdScene(p);\n        float d  = abs(ms.dist);\n\n        if (d < gMarchEps) {\n            // close to a surface!\n            // mark it the hit & return\n            hit.hit    = true;\n            hit.t      = t;\n            hit.pnt    = p;\n            hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n            hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n            \n            // the hit should be from the new material. need to re-sample.\n            hit.ms     = sdScene(p - hit.hf_nrm * gMarchEps * 2.0);\n            return;\n        }\n        \n        // advance\n        t += d * gMarchUnderstep;\n        \n        // if we're just too far away, return.\n        if (t > gMarchMaxT) {\n            return;\n        }\n    }\n    \n    if (t < gMarchMaxT) {\n        // ran out of steps.\n        hit.hit = true;\n        hit.t   = t;\n        hit.pnt = p;\n        hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = ms;        \n    }\n}\n\n//--------------------------------------------------------------------------\n\nhit_t rayVsScene(ray_t ray) {\n    hit_t hit;\n    hit.hit = false;\n    hit.t   = 1e9;\n    \n    rayVsFloor(ray, hit);\n    rayMarch  (ray, hit);\n    \n    return hit;\n}\n\n//------------------------------------------------------\n// ray-handling stuff.\n\n// FIFO queue of rays. see Common tab.\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES (gQueueSize)\nQ_IMPLEMENTATION\nhit_t rayVsScene(ray_t);\nvec3  sky(ray_t);\nvec3  albedo(hit_t);\nMST sdScene(vec3 p);\n\n// run a single ray.\nvec3 runRay(ray_t ray) {\n    hit_t hit = rayVsScene(ray);\n    \n    if (!hit.hit) {\n        // ray hit nothing.\n        \n        if (ray.isLightingRay) {\n            // a \"lighting ray\" is to the light.\n            return ray.amt;\n        }\n        else {\n            // it's a direct ray and sees the sky.\n            return ray.amt * sky(ray);\n        }\n    }\n    \n    // the ray hit something\n    \n    // get map samples on either side of the interface\n    MST ms1 = sdScene(hit.pnt + hit.hf_nrm * gMarchEps * 3.0);\n    MST ms2 = sdScene(hit.pnt - hit.hf_nrm * gMarchEps * 3.0);\n    mtl_t mtl1 = mtls[ms1.mtl];\n    mtl_t mtl2 = mtls[ms2.mtl];\n    \n    // just traveled through media, attenuate !  (but not through air)\n    if (ms1.mtl != gMtlAir) {\n        vec4 absorption = absorption(ms1.mtl, hit.pnt);\n        float density = absorption.w;\n        float absorptionDist = hit.t;\n        ray.amt *= sat(exp(-density * absorptionDist * (1.0 - absorption.rgb)));\n    }\n    \n    if (ray.isLightingRay && !QIsFull()) {\n        // lighting ray just keeps traveling\n        if (kTransmission) {\n            float R = reflectAmount(mtls[ms1.mtl].ior, mtl2.ior, dot(ray.rd, -hit.hf_nrm));\n            ray.amt *= 1.0 - mtl2.opacity;\n            ray.amt *= 1.0 - R;\n            ray.ro = hit.pnt - hit.hf_nrm * gMarchEps * 4.0;\n            QEnqueue(ray);\n        }\n        return v0;\n    }\n    \n    float dif;\n    vec4  rfl;\n    vec4  trn;\n    vec3  tmpAmt;\n    \n    thisRayWalksIntoAnInterface(\n        ray.rd,\n        hit.hf_nrm,\n        mtl1.ior,\n        mtl2.ior,\n        mtl2.opacity,\n        dif,\n        rfl,\n        trn);\n         \n    // diffuse\n    float normal_dot_light = dot(hit.of_nrm, gLightDir);\n    vec3 alb = albedo(hit);\n    float shade = sat(normal_dot_light);\n    tmpAmt = ray.amt * dif * alb * shade;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    \n    // subsurface\n    // this has issues.\n    #if SUBSURFACE\n    tmpAmt = ray.amt * dif * alb * (sat(-normal_dot_light + 0.5));\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 5.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    #endif\n    \n    // reflect\n    tmpAmt = ray.amt * rfl.w;\n    if (kReflection && vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // in the reflect direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = rfl.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n    // transmit\n    tmpAmt = ray.amt * trn.w;\n    if (kTransmission && vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // in the refraction direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = trn.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n    // AO\n    float AO = 1.0;\n    if (ms1.dist > 0.0) {\n        float aoOff  = gBlowholeRad * 1.5;\n        float aoDist = sdPlanet(hit.pnt + hit.hf_nrm * aoOff);\n        AO = aoDist / aoOff;\n    }\n\n    // return ambient lighting, no new ray.\n    return ray.amt * gAmbient * alb * dif * AO;\n}\n\n\nvec3 runRays() {\n\n    vec3 rgb = v0;\n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty() && rayCount < gMaxRays) {\n        rgb += runRay(QDequeue());\n        rayCount += 1u;\n    }\n    \n    if (rayCount >= gMaxRays) {\n    //    gDebugRGB.g = 1.0;\n    }\n    \n    return rgb;\n}\n\n//--------------------------------------------------------------------------\n// viewport, camera, initial ray stuff.\n\n\nray_t getCameraRay(vec2 xy, float stereoOffset) {\n    ray_t ret;\n    \n    car_t car         = gCars[gPlayerCarIndex];\n    \n    float speed       = length(car.vel);\n    \n    // car \"up\" is the planet normal\n    vec3 carUp        = normalPlanet(car.pos);\n    // add some tilting when turning\n    float tilt        = car.str * 0.5 * smoothstep(gCarSpdMax / 3.0, gCarSpdMax, speed);\n    carUp            += tilt * cross(carUp, car.fwd);\n    carUp             = normalize(carUp);\n    \n    \n    // car \"right\". also || to planet surface.\n    vec3 carRt        = cross(carUp, car.fwd);\n    \n    vec3 lookFrom     = car.pos + gCamDist * (carUp * 0.7 - car.fwd * 0.9);\n    lookFrom         += gCamAntiBob;\n\n    vec3 lookTo       = lookFrom + car.fwd;\n    \n    if (gMouse.z > 0.0) {\n        vec2 dMouse   = VIEWFROMSCREEN(gMouse.xy);\n        lookTo       += carRt * dMouse.x * 5.0;\n        lookTo       += carUp * dMouse.y * 5.0;\n    }\n    \n    vec3 camFw        = normalize(lookTo - lookFrom);\n    vec3 camRt        = normalize(cross(carUp, camFw));\n    vec3 camUp        = cross(camFw, camRt);\n    \n    ret.ro            = lookFrom;\n    ret.ro           += camRt * stereoOffset;\n    ret.rd            = normalize(camFw + (xy.x * camRt + xy.y * camUp) / gFOVZoom);\n    ret.amt           = v1;\n    ret.isLightingRay = false;\n        \n    return ret;\n}\n\n\n// slow the framerate to test dynamics at different Hz.\nfloat slowDown(float n) {\n    float a = 0.0;\n    for (int m = 0; m < int(n); ++m) {\n        a += pow(float(m), pi);\n    }\n    return a;\n}\n\nvoid readCars() {\n    for (int n = 0; n < gCarCount; ++n) {\n        car_t car = readCar(iChannel0, n);\n        float thrust  = max(0.0,  car.ths);\n        float brake   = max(0.0, -car.ths);\n        float speed   = length(car.vel);\n        car.siz      -= thrust * 0.2;\n        vec3 vUp      = normalPlanet(car.pos);\n        car.pos      -= vUp * thrust * 0.2;\n        car.siz      -= brake * 0.1;\n        \n#if FANCY_CARS\n        // rotation matrix for car\n        // including a little tilt when steering\n        vec3 vRt    = cross(vUp, car.fwd);\n        vUp         = normalize(vUp + vRt * car.str * 0.7);\n        vRt         = normalize(cross(vUp, car.fwd));\n        vec3 vFw    = car.fwd;\n        gCarMats[n] = mat3(vFw, vUp, vRt);\n#endif        \n        \n        // bob up and down\n        float bobAmount = 1.0;\n        // don't bob when thrusting or braking.\n        bobAmount *= (1.0 - max(thrust, brake));\n        // also don't bob while traveling. slightly redundant.\n        bobAmount *= smoothstep(0.1, 0.0, speed / gCarSpdMax);\n        // also don't bob while airborn\n        bobAmount *= 1.0 - sat(car.rbn);\n        \n        bobAmount *= sin(gT * float(n + 10)/10.0) * 0.2 + .1;\n        \n        vec3 bob   = bobAmount * vUp;\n        \n        car.pos += bob;\n        if (n == gPlayerCarIndex) {\n            gCamAntiBob = -bob;\n        }\n\n        gCars[n] = car;\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT = iTime;\n    \n    sdPlanetSetup();\n    readKeyboard();\n    readMouse();\n    readCars();\n    setupScene();\n\n\n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n\n    vec2  xy           = VIEWFROMSCREEN(XY);\n    float stereoOffset = 0.0;\n    \n    if (kXEyedStereo) {\n        float f = sign(xy.x);\n        xy.x -= f * VIEWFROMSCREEN_DIST(RES.x / 2.0);\n        xy   *= 2.0;\n        stereoOffset = -f * gStereoSep;\n    }\n    \n    QClear();\n    QEnqueue(getCameraRay(xy, stereoOffset));\n\n    RGBA.rgb  = runRays();\n    RGBA.rgb += gDbg;\n\n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(dot2(XY/RES - 0.5) * 1.8, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        RGBA.rgb = mix(cCool, cHot, pow(temp, 0.6));\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst vec4  v40 = v01.xxxx;\nconst vec4  v41 = v01.yyyy;\nconst float pi  = 3.14159265359;\n\nconst float gMarchEps       = 0.03;\nconst float gNormEps        = gMarchEps * 0.4;\n\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n\n//--------------------------------------------------------------------------\n// Math\nfloat sqr  (float a) { return a * a; }\nfloat dot2 ( vec2 v) { return dot(v,v); }\nfloat dot2 ( vec3 v) { return dot(v,v); }\nmat2  rot2 (float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvec2  rot90( vec2 v) { return vec2(-v.y, v.x); }\nint   vmax (ivec2 A) { return max(    A.x, A.y); }\nfloat vmax ( vec2 A) { return max(    A.x, A.y); }\nfloat vmax ( vec3 A) { return max(max(A.x, A.y), A.z); }\nint   vmin (ivec2 A) { return min(    A.x, A.y); }\nfloat vmin ( vec2 A) { return min(    A.x, A.y); }\nfloat vmin ( vec3 A) { return min(min(A.x, A.y), A.z); }\nfloat sat  (float A) { return clamp(A,      0.0 ,      1.0 ); }\nvec2  sat  ( vec2 A) { return clamp(A, vec2(0.0), vec2(1.0)); }\nvec3  sat  ( vec3 A) { return clamp(A, vec3(0.0), vec3(1.0)); }\nfloat dfdxy(float A) { return length(vec2(dFdx(A), dFdy(A))); }\n\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_MOMENT(key, chan)  (texelFetch(chan, ivec2(key, 1), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n#define KEY_SP (32)\n#define KEY_LF (37)\n#define KEY_UP (38)\n#define KEY_RT (39)\n#define KEY_DN (40)\n#define KEY_0  (48)\n#define KEY_A  (65)\n#define KEY_D  (68)\n#define KEY_S  (83)\n#define KEY_W  (87)\nvoid orKeyPressed(in sampler2D channel, in int key, inout bool value) {\n    value = value || KEY_IS_DOWN(key, channel);\n}\n\n//--------------------------------------------------------------------------\n// colors\n\n// by Stokastic\n// https://www.shadertoy.com/view/sttGDS\n// demo with graphs of RGB: https://www.desmos.com/calculator/e0j9ikcjti\n// lambda = [0, 1] -> [saturated, grey]\nvec3 spectrum(float x, float lambda) {\n    // map lambda from 0 -> 1 to 2/3 -> 1 to prevent dips in perceived lightness\n    // (see graph of L linked above)\n    lambda = (2.0 + lambda) / 3.0;\n    \n    vec3 abc = vec3(x) - vec3(lambda * 0.5, 0.5, 1.0 - lambda * 0.5);\n    vec3 rgb = 0.5 + 0.5 * cos(pi * clamp(abs(2.0 * abc / lambda), 0.0, 1.0));\n\n    const int INCLUDE_VIOLET = 1;\n    if (INCLUDE_VIOLET == 1) {\n        float f = 2.0;\n        rgb.r += (1.0 - lambda) * 0.25 * (1.0 +  cos(pi * clamp(f * abs(2.0 * (x - 1.0 + lambda / (2.0 * f)) / lambda), 0.0, 1.0)));\n    }\n\n    return rgb;\n}\n\n\n//--------------------------------------------------------------------------\n// signed distance functions\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d/\n// Isosceles Trapezoid - exact   (https://www.shadertoy.com/view/MlycD3)\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he ) {\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    \n    // if true, this is a ray looking for the light.\n    bool  isLightingRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\nstruct mtl_t {\n    vec3  albedo;\n    float opacity;         // opacity at the surface\n    float ior;\n    vec4  absorption;      // <vec3, permeability>\n};\n\n//--------------------------------------------------------------------------\n// optics\n\n// A modified Schlick's approximation\n// where reflectamount -> 0 as n2 -> n1.\nfloat reflectAmount(float n1, float n2, float incidentDotNormal) {\n    // from https://en.wikipedia.org/wiki/Schlick%27s_approximation \n    float R0 = sqr((n1 - n2) / (n1 + n2));\n    float R  = R0 + (1.0 - R0) * pow(1.0 - incidentDotNormal, 5.0);\n\n    // Schlick's approximation seems invalid when n1 ~= n2.\n    // Compensate with an additional fudge.\n    // https://physics.stackexchange.com/q/794963\n    float ndiffSqr      = sqr(n1 - n2);\n    float elenzilFudge  = ndiffSqr / (ndiffSqr + 0.01);\n    R                  *= elenzilFudge;\n\n    return R;\n}\n\n// n1 == n2          -> no reflection\nvoid thisRayWalksIntoAnInterface(\n    //  direction of the incoming ray.\n    in  vec3  incident,\n    \n    //  surface normal.\n    in  vec3  hit_facing_normal,\n    \n    //  indices of refraction.\n    in  float n1,\n    in  float n2,\n    \n    in  float opacity,\n    \n    //  amount allocated to diffuse lighting\n    out float out_sDiffuse,\n    \n    //  direction and amount for specular reflection\n    out vec4  out_vReflect,\n    \n    //  direction and amount for transmission\n    out vec4  out_vTransmit\n    ) {\n    \n    // 0 = transmit 1 = reflect 1\n    float transmitVsReflect = reflectAmount(n1, n2, dot(incident, -hit_facing_normal));\n    \n    // check for total internal reflection.\n    float eta     = n1 / n2;\n    out_vTransmit.xyz = refract(incident, hit_facing_normal, eta);\n    if (dot(out_vTransmit.xyz, out_vTransmit.xyz) == 0.0) {\n        // total internal\n        transmitVsReflect = 1.0;\n    }\n    \n    float amtDiffuse  = (1.0 - transmitVsReflect) * opacity;\n    float amtReflect  = transmitVsReflect;\n    float amtTransmit =  1.0 - amtDiffuse - amtReflect;\n    \n    out_sDiffuse      = amtDiffuse;\n    out_vTransmit.w   = amtTransmit;\n    out_vReflect.w    = amtReflect;\n    out_vReflect.xyz  = reflect(incident, hit_facing_normal);\n}\n\n//--------------------------------------------------------------------------\n\n// Queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n// CSG Operations.\n// These all mutate the first argument and return void.\n// MST types are used only where sensible.\n\nvoid opUnion(inout float A, in float B) {\n    A = min(A, B);\n}\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opReplace(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\nvoid opReplace(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/smin/\n// polynomial smooth min\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax(float a, float b, float k) {\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\n\n//--------------------------------------------------------------------------\n// Car Stuff\n\n// the cars are fairly expensive in the rendering,\n// try reducing this to get more performance.\nconst int   gCarCount = 6;\nconst int   gPlayerCarIndex = gCarCount / 2;\n\nconst float gCarSpdMax =  30.0;\n\nstruct car_t {\n    vec3  pos;\n    vec3  vel;\n    vec3  fwd;\n    float siz;\n    float str;  // cosmetic steering\n    float ths;  // cosmetic thrust\n    \n    vec3  uns;  // unused\n    float rbn;  // airborn\n};\n\nvoid readCarProp(in sampler2D channel, int carIndex, int propIndex, out vec3 prop, out float misc) {\n    vec4 val = texelFetch(channel, ivec2(propIndex, carIndex), 0);\n    prop = val.xyz;\n    misc = val.w;\n}\n\nvoid writeCarProp(out vec4 RGBA, in vec3 prop, in float misc) {\n    RGBA.xyz = prop;\n    RGBA.w   = misc;\n}\n\ncar_t readCar(in sampler2D channel, int index) {\n    car_t ret;\n    \n    readCarProp(channel, index, 0, ret.pos, ret.siz);\n    readCarProp(channel, index, 1, ret.vel, ret.str);\n    readCarProp(channel, index, 2, ret.fwd, ret.ths);\n    readCarProp(channel, index, 3, ret.uns, ret.rbn);\n    \n    return ret;\n}\n\nvoid writeCar(in int column, inout vec4 RGBA, in car_t car) {\n\n    switch(column) {\n        default:\n            break;\n        case 0:\n            writeCarProp(RGBA, car.pos, car.siz);\n            break;\n        case 1:\n            writeCarProp(RGBA, car.vel, car.str);\n            break;\n        case 2:\n            writeCarProp(RGBA, car.fwd, car.ths);\n            break;\n        case 3:\n            writeCarProp(RGBA, car.uns, car.rbn);\n            break;\n    }\n}\n\ncar_t newCar(int index) {\n    car_t car;\n    float findex = float(index);\n    float fcount = float(gCarCount);\n    float z      = (findex - (fcount - 1.0)/2.0);\n    \n    car.pos = vX * 40.0 + vY * z * 60.0 + vZ * z * 90.0 / float(gCarCount + 1);\n    car.fwd = normalize(vX * 4.0 + vZ * z);\n    car.vel = car.fwd * (4.0 - abs(z) * 0.4) * 0.0;\n    car.siz = 1.0 - abs(z) / float(gCarCount + 1);\n    float startOffsetFac = 1.0;\n    if (index == gPlayerCarIndex) {\n        car.siz = 1.0 * 0.75;\n    }\n//    car.pos = vX * -40.0;\n  //  startOffsetFac = -1.0;\n    \n    car.pos.x += 400.0 * startOffsetFac;\n    \n    car.str = 0.0;\n    car.ths = 0.0;\n    car.uns = v0;\n    car.rbn = 0.0;\n    \n    return car;\n}\n\n//--------------------------------------------------------------------------\n// Scene\n\nuint gMtlAir   = 1u;\nuint gMtlFloor = 2u;\n\nfloat gT;\nfloat gRingRate = 0.1;\nmat2  gRingMat  = mat2(1, 0, 0, 1);\nconst float gTorusRad1   = 180.0;\nconst float gTorusRad2   =  70.0;\nconst float gRingRad2    = gTorusRad1 * 0.1;\nconst float gRingRad1    = gTorusRad1 * 2.0 + gTorusRad2 + gRingRad2 + 3.1;\nconst float gBlowholeRad = gTorusRad2 * 0.07;\n\nvoid sdPlanetSetup() {\n    gRingMat = rot2(gRingRate * gT);\n}\n\nfloat sdPlanet(in vec3 p) {\n    float d = 1e9;\n    float f, g;\n    vec3 q;\n\n    // main figure-8\n    f = sdTorus(p + vX * gTorusRad1   , vec2(gTorusRad1, gTorusRad2));\n    d = min(d, f);\n    g = sdTorus(p - vX * gTorusRad1   , vec2(gTorusRad1, gTorusRad2));\n    d = sminCubic(d, g, 8.0);\n    g = d;\n    \n    // orbital ring\n    q = p;\n    q.xz *= gRingMat;\n    f = sdTorus(q.yxz, vec2(gRingRad1, gRingRad2 ));\n    d = min(d, f);\n    // ladder up to the orbital ring\n    f = sdCappedCylinder(q, gRingRad1, 4.0);\n    d = sminCubic(d, f, 6.0);\n    \n    // hollow section at the crux of the 8\n    f = sdBox(p, vec3(gTorusRad2 * 3.0, gTorusRad1 * 0.1, gTorusRad1 * 0.1)) - gTorusRad2 * 0.1;\n    d = smax(d, -f             , 0.4);\n    \n    // it's hollow !\n    f = 0.65;\n    d = smax(d, -(g + gTorusRad2 * f), 0.4);\n    \n    // blowholes\n    q = p;\n    q.x = abs(q.x);\n    q.x -= gTorusRad1 * 2.0;\n    f = sdCappedCylinder(q, gTorusRad2 * 1.1, gBlowholeRad);\n    d = smax(d, -f, 0.4);\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalPlanet(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdPlanet(p+e*gNormEps);\n    }\n    return normalize(n);\n}\n\nfloat planetSpinAmt(in vec3 p) {\n    float spinning = smoothstep(72.0, 74.0, abs(p.y));\n    spinning = max(spinning, float(dot2(p) > sqr(gRingRad1 - gRingRad2 * 1.02)));\n    return spinning;\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*******************************\n Dynamics\n\ntodo: \n[x] car damping must be exponential\n\n\n\n********************************/\n\n// false to drive all cars yourself\nbool  gAICars    = true;\n\n// \nfloat gCarDmp    =   1.3;\nfloat gCarAcc    =   1.0;\nfloat gCarTrn    =   3.0;\nfloat gCarDrift  =   0.998;    // 0 to 1\nfloat gCarBrake  =  30.0;\nfloat gCarGrav   =  40.0;\nfloat gBounds    = 800.0;\n\nfloat kUp, kDn, kLf, kRt, kSp;\nvoid readKeyboard() {\n    bool bUp, bDn, bLf, bRt, bSp = false;\n    orKeyPressed(iChannel3, KEY_UP, bUp);\n    orKeyPressed(iChannel3, KEY_W , bUp);\n    orKeyPressed(iChannel3, KEY_LF, bLf);\n    orKeyPressed(iChannel3, KEY_A , bLf);\n    orKeyPressed(iChannel3, KEY_RT, bRt);\n    orKeyPressed(iChannel3, KEY_D , bRt);\n    orKeyPressed(iChannel3, KEY_DN, bDn);\n    orKeyPressed(iChannel3, KEY_S , bDn);\n    bSp = KEY_MOMENT(KEY_SP, iChannel3);\n    \n    kUp = float(bUp);\n    kDn = float(bDn);\n    kLf = float(bLf);\n    kRt = float(bRt);\n    kSp = float(bSp);\n}\n\n// steering: -1 = left     , 1 = right\n// thrust  : -1 = brake    , 1 = go\n// action  :  0 = no action, 1 = action\nvoid processCar(inout car_t car, float steering, float thrust, float action, vec3 otherCars[gCarCount - 1], bool AI) {\n\n    // car \"up\" is the planet normal\n    vec3 carUp  = normalPlanet(car.pos);\n\n    if (action > 0.0) {\n        // AI and human get different \"actions\".\n        // AI gets fast reverse,\n        // human gets jump.\n        if (AI) {\n            // flip the car's heading\n            float speed = length(car.vel);\n            if (speed > 0.0) {\n                car.fwd = car.vel / -speed;\n            }\n            else {\n                car.fwd *= -1.0;\n            }\n        }\n        else {\n            // jump!\n            if (car.rbn == 0.0) {\n                car.rbn  = 1.0;\n                car.vel += carUp * gCarSpdMax;\n                car.pos += carUp * car.siz;\n            }\n        }\n    }\n\n    //---------------------------------------------\n    // Steering, aka determine car's \"forward\".\n    // We keep \"forward\" || to the planet surface.\n    \n    // Car \"right\". also || to planet surface.\n    vec3 carRt  = cross(carUp, car.fwd);\n    \n    // Adjust \"forward\" by adding in \"right\" times keyboard input.\n    // For smallish turns, this is fine, no need to actually rotate it.\n    // Not renormalized here because it's renormalized later.\n    car.fwd    += iTimeDelta * carRt * gCarTrn * steering;\n    \n    // Cosmetic steering, has not effect on actual dynamics.\n    car.str    *= pow(0.05, iTimeDelta);\n    car.str     = clamp(car.str + steering * iTimeDelta * 3.0, -1.0, 1.0);\n    \n    // Keep things tidy: force \"forward\" || to surface.\n    car.fwd    -= dot(car.fwd, carUp) * carUp;\n    car.fwd     = normalize(car.fwd);\n    \n    //---------------------------------------------\n    // drifting\n    // velocity without drift\n    vec3 naturalVel = length(car.vel) * car.fwd;\n    car.vel = mix(car.vel, naturalVel, (1.0 - gCarDrift) * pow(2.0, iTimeDelta));\n\n    // damp speed\n    float carSpeedFac = 1.0 / pow(car.siz, 2.0);\n    float decay = 1.0 / (gCarDmp * carSpeedFac + sat(-thrust) * gCarBrake * carSpeedFac);\n    car.vel *= pow(decay, iTimeDelta);\n    \n    // thrust\n    if (car.rbn == 1.0) {\n        // no thrust while airborn !\n        thrust = 0.0;\n    }\n    carSpeedFac  = 1.0 / pow(car.siz, 1.0);\n    car.vel     += car.fwd * gCarAcc * sat(thrust) * carSpeedFac;\n    \n    // cosmetic thrust\n    car.ths     *= pow(0.05, iTimeDelta);\n    car.ths      = clamp(car.ths + thrust * iTimeDelta * 8.0, -1.0, 1.0);\n    \n    // limit speed\n    float speed = length(car.vel);\n    if (speed > 0.0) {\n        car.vel  = normalize(car.vel) * min(length(car.vel), gCarSpdMax * carSpeedFac);\n    }\n    \n    // update position\n    car.pos += car.vel * iTimeDelta;\n    \n    // update due to being on moving ground\n    if (abs(car.rbn) < 0.0001) {\n        float spinAmt = planetSpinAmt(car.pos);\n        mat2 spinMat = rot2(spinAmt * -gRingRate * iTimeDelta);\n        car.pos.xz *= spinMat;\n        car.fwd.xz *= spinMat;\n        car.fwd     = normalize(car.fwd);\n    }\n\n    \n    \n    // separate\n    // super crude collision handling\n    for (int n = 0; n < gCarCount - 1; ++n) {\n        vec3  otherCarPos = otherCars[n];\n        vec3  vMeThem     = otherCarPos - car.pos;\n        float dMeThem     = length(vMeThem);\n        dMeThem -= 2.0;\n        float overlap     = max(0.0, car.siz * 2.0 - dMeThem);\n        vec3  vOffsetPrp  = vMeThem;\n        vOffsetPrp.xz     = rot90(vOffsetPrp.xz);\n        vec3  vOffset     = normalize(vMeThem + vOffsetPrp);\n        car.pos          -= vOffset * overlap / 2.0 * 1.5;\n    }\n\n    // gravity\n    float planetDist = sdPlanet(car.pos);\n    if (planetDist < car.siz) {\n        // no longer airborn\n        car.rbn = 0.0;\n    }\n    carUp    = normalPlanet(car.pos);\n    if (car.rbn == 0.0) {\n        // not airborn\n        // snap to the proper elevation\n        car.pos -= carUp * (planetDist - car.siz * 1.2);\n    }\n    else {\n        // airborn\n        car.vel -= carUp * iTimeDelta * gCarGrav;\n    }\n    \n    // don't go out of bounds\n    if (length(car.pos) > gBounds) {\n        car.pos = v0;\n    }\n}\n\nvoid processCarPlayer(inout car_t car, vec3 otherCars[gCarCount - 1]) {\n    float steering = kRt - kLf;\n    float action   = kSp;\n    float thrust   = kUp - kDn;\n    \n    processCar(car, steering, thrust, action, otherCars, false);\n}\n\n// don't try to reason about this routine, it's an AI black box.\nvoid processCarAI(inout car_t car, in car_t target, vec3 otherCars[gCarCount - 1]) {\n    // car \"up\" is the planet normal\n    vec3 carUp   = normalPlanet(car.pos);\n    // car \"right\". also || to planet surface.\n    vec3 carRt   = cross(carUp, car.fwd);\n    \n    vec3  vCarTrg = target.pos - car.pos;\n    float dCarTrg = length(vCarTrg);\n    vec3  nCarTrg = vCarTrg / dCarTrg;\n    \n    float speed  = length(car.vel);\n    \n    float headed = dot(car.fwd, nCarTrg);\n    bool  seesTarget = headed > 0.3 || dCarTrg < 30.0;\n    \n    float action   = 0.0;\n    float steering = 0.0;\n    float thrust   = 0.0;\n    if (seesTarget) {\n        float flip   = 1.0;\n        if (speed > gCarSpdMax * 0.99 && headed < -0.5) {\n            action =  1.0;\n            flip   = -1.0;\n        }\n    \n        steering = flip * sign(dot(carRt, nCarTrg));\n        if (headed > 0.99) {\n            steering = 0.0;\n        }\n        \n        thrust = 1.0;\n    }\n    \n    // slow down on approach\n    // note thrust needs to be either on or off,\n    // so we use a duty-cycle.\n    float f = smoothstep(15.0, 30.0, dCarTrg);\n    f = fract(iTime * 5.0) < f ? 1.0 : 0.0;\n    thrust *= f;\n    \n    processCar(car, steering, thrust, action, otherCars, true);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    gT = iTime;\n    sdPlanetSetup();\n\n    ivec2 IJ = ivec2(XY);\n    int carIndex = IJ.y;\n    \n    if (carIndex >= gCarCount || IJ.x > 5) {\n        discard;\n    }\n\n    car_t car;\n    \n    if (iFrame == 0 || (iMouse.z > 0.0 && length(iMouse.zw) < 100.0)) {\n        car = newCar(carIndex);\n    }\n    else {\n        car = readCar(iChannel0, carIndex);\n    }\n    \n    // compose list of all the other cars positions\n    vec3 otherCars[gCarCount - 1];\n    int otherIndex = 0;\n    for (int n = 0; n < gCarCount; ++n) {\n        if (n != carIndex) {\n            otherCars[otherIndex] = readCar(iChannel0, n).pos;\n            otherIndex += 1;\n        }\n    }\n    \n    readKeyboard();\n\n    \n    if (!gAICars || carIndex == gPlayerCarIndex) {\n        processCarPlayer(car, otherCars);\n    }\n    else {\n        processCarAI(car, readCar(iChannel0, gPlayerCarIndex), otherCars);\n    }\n    \n    writeCar(IJ.x, RGBA, car);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// mouse handling.\n\n// initial position (normalized)\nconst vec2  p0   = vec2(0.5, 0.5);\n\n// 1 to visualize the mouse position and reset circle.\n#define VISUALIZE 0\n\n// special texels\nconst ivec2 pos = ivec2(0, 0);\nconst ivec2 btn = ivec2(1, 0);\nconst ivec2 hrt = ivec2(3, 0);\n\n// data[0] <- bool mouseIsDown\n// data[1] <- bool mouseJustBecameDown\n// data.zw <- current mouse pos\nvoid trackButton(inout vec4 data) {\n    bool mouseIsDown         = iMouse.z > 0.0;\n    bool mouseWasDown        = bool(data[0]);\n    bool mouseJustBecameDown = !mouseWasDown && mouseIsDown;\n    \n    data[0] = float(mouseIsDown);\n    data[1] = float(mouseJustBecameDown);\n    data.zw = iMouse.xy;\n}\n\n// data.xy <- cumulative mousePos\n// data.zw <- raw last mousePos\nvoid trackMouse(inout vec4 data, in vec4 button) {\n    bool mouseIsDown = bool(button[0]);\n    bool mouseJustBecameDown = bool(button[1]);\n    vec2 mouse = button.zw;\n\n    vec2 home = p0 * iResolution.xy;\n    \n    if (iFrame == 0) {\n        data.xy = home;\n        data.zw = mouse;\n        return;\n    }\n\n    if (!mouseIsDown) {\n        data.zw = vec2(0.0);\n        return;\n    }\n    \n    if (mouseJustBecameDown) {\n        data.zw = mouse;\n    }\n    \n    vec2 strtMouse = data.zw;\n    vec2 deltMouse = mouse - strtMouse;\n    \n    data.xy = deltMouse + home;\n}\n\n// buffers are currently 100% broken on all browsers on iOS.\n// this provides a work-around so shaders can detect that.\nvoid trackHeartbeat(inout vec4 RGBA) {\n    RGBA.r = 1.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA = texelFetch(iChannel2, IJ, 0);\n    \n    if (iFrame == 0) {\n        RGBA = vec4(0);\n    }\n    \n    if (IJ == btn) {\n        trackButton(RGBA);\n        return;\n    }\n    \n    vec4 button = texelFetch(iChannel2, btn, 0);\n    \n    if (IJ == pos) {\n        trackMouse(RGBA, button);\n        return;\n    }\n    \n    if (IJ == hrt) {\n        trackHeartbeat(RGBA);\n        return;\n    }\n    \n    \n#if VISUALIZE\n    vec4 mouse = texelFetch(iChannel2, pos, 0);\n    \n    vec2  p = XY;\n    float d = 1e9;\n    d = min(d, abs(length(p - mouse.xy) - 20.0) - 2.0);\n    d = min(d, abs(length(p - mouse.zw) - 10.0) - 2.0);\n    float c = smoothstep(2.0, 0.0, d);\n    \n    RGBA.rgb = vec3(c);\n#else\n    discard;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}