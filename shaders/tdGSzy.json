{
    "Shader": {
        "info": {
            "date": "1574279601",
            "description": "From left\n1. linear = srgbToLin(linToSrgb(linear)+dither)\n2: linear = sqr(sqrt(linear)+dither)\n3: linear += sqrt(linear)*dither*2\n4: linear += dither\n5. no dither\nShows diff with original value ever few seconds(error)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tdGSzy",
            "likes": 8,
            "name": "srgb Dither comparision",
            "published": 3,
            "tags": [
                "dither",
                "bluenoise",
                "srgb"
            ],
            "usePreview": 0,
            "username": "Dain",
            "viewed": 616
        },
        "renderpass": [
            {
                "code": "//Based on casseveritt's https://www.shadertoy.com/view/MdXXzX\n//Different ways to apply dither when the output texture is srgb\n//From left\n//1. linear = srgbToLin(linToSrgb(linear)+dither) -- this is the \"correct\" way but slowest..\n//2: linear = sqr(sqrt(linear)+dither)            -- approximate srgb curve with x^2\n//3: linear += sqrtFast(linear)*dither*2\t\t  -- allows us to use a cheap sqrt since original color data isn't altered-- just the dithered part\n//4: linear += dither\t\t\t\t\t\t\t  -- dithering in linear space is no bueno\n//5. no dither\t\t\t\t\t\t\t\t\t  -- what it looks like without dithering\n//Shows diff with original value ever few seconds(white = error)\n\n\n#define NUM_SPLITS 8 //Real 8 bit srgb is 256, but we use a small # to see the artifacts\n\n#define GAMMA_SRGB\n\nfloat Round( float a, float l )\n{\n\treturn floor(a*l+0.5)/l;\n}\n//A very fast sqrt we can use for scaling dither\nfloat sqrtFast(float inX)\n{\n\tint x = floatBitsToInt(inX);\n\tx = 0x1FBD1DF5 + (x >> 1);\n\treturn intBitsToFloat (x);\n}\n//very approximate srgb--generated by a C++ program i wrote for finding such constants\nfloat pow_srgb(float inX)\n{\n\tuint x = floatBitsToUint(inX);\n\tx = (x >> 1)+526125520u ;\n\treturn uintBitsToFloat (x);\n}\n\n\n//CORRECT_SRGB_CONVERSION\n#if defined( GAMMA_SRGB )\n// see http://www.opengl.org/registry/specs/ARB/framebuffer_sRGB.txt\nfloat srgb2lin( float cs )\n{\n\tfloat c_lo = cs / 12.92;\n\tfloat c_hi = pow( (cs + 0.055) / 1.055, 2.4 );\n\tfloat s = step(0.04045, cs);\n\treturn mix( c_lo, c_hi, s );\n}\nfloat lin2srgb( float cl )\n{\n\tfloat c_lo = 12.92 * cl;\n\tfloat c_hi = 1.055 * pow(cl, 0.41666) - 0.055;\n\tfloat s = step( 0.0031308, cl);\n\treturn mix( c_lo, c_hi, s );\n}\n\nfloat srgbCheap(float a){\n    return sqrt(a);\n}\nfloat lin2srgbCheap(float a){\n    return a*a;\n}\n\n#endif //GAMMA_SRGB\n\n//This remapping is better than doing (bn.x + bn.y) - 1.0, as that adds unrelated blue noises together, and the entire point of blue noise is\n//that the values should be as far apart as possible from their neighbors\n//note: from https://github.com/Unity-Technologies/ScriptableRenderPipeline/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FinalPass.shader#L124\nfloat remap_pdf_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    return sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat val = srgb2lin(uv.y);\n\tval = pow(val, 1.5);  // adjust the curve in linear space, so we see more dark colors\n\n    vec2 bn = texture( iChannel0, fragCoord.xy/iChannelResolution[0].xy ).rg;\n    float nrnd = remap_pdf_tri_unity(bn.x);//triangular shaped blue noise in -1 to +1\n    \n    //float nrnd = (*2.0-1.0;\n\tfloat scale =float(NUM_SPLITS);\n\tfloat panels = 5.0;\n\t\n\tfloat o;\n\t//display values\n\tvec4 outcol = vec4(0);\n    \n    // non-linear transform, apply dither, then quantize signal \n\tfloat TrueVal = lin2srgb(val);\n\tfloat TrueValN = TrueVal + nrnd / scale;\n\tTrueVal = Round( TrueValN, scale );\n\tTrueVal = srgb2lin(TrueVal); //The correct srgb dithered value\n    \n    \t\t// non-linear transform, then quantize signal \n\tfloat p5 = lin2srgb(val);\n        \n\tfloat v5 = Round( p5, scale );\n\tv5 = srgb2lin(v5);\n    float original_val = val;\n    \n\tif ( uv.x < 1.0/panels ) {      \n        o = TrueVal;\n\n\t} else if ( uv.x < 2.0 / panels ) {\n\t\n        float v = srgbCheap(val);\n\t\tval = v + nrnd / scale;\n     \tval = lin2srgbCheap(val);\n\n\t\tval = lin2srgb(val);   \n\t\to = Round( val, scale );\n\t\to = srgb2lin(o);\n\n\n\t} else if ( uv.x < 3.0 / panels ) {                     \n\t\tval = val + (sqrtFast(val))*nrnd*2. / scale;\n        //val = val + ((pow_srgb(val))*nrnd*2.0) / scale;   \n\t\tval = lin2srgb(val);      \n\t\to = Round( val, scale );\n\t\to = srgb2lin(o);\n\n\t} else if ( uv.x < 4.0 / panels ) {        \n        val = val + nrnd / scale;\n        \n\t\tval = lin2srgb(val);     \n\t\to = Round( val, scale );\n\t\to = srgb2lin(o);\n\t} else {\n        o = v5;\n\n\t}\n    outcol.rgb = vec3(lin2srgb(o));\n    if( sin(iTime) > .5){\n\t\to = abs(lin2srgb(o)-lin2srgb(original_val));\n   \t//\to = o*5.0;\n        //o = abs((o)-(original_val));\n         outcol.rgb = vec3((o));\n    }\n\t\n\n\t//display lines\n\tfloat pad = 1.0 - floor( abs( fract( uv.x * panels ) * 2.0 - 1.0 ) + .02 ); \n\toutcol *= vec4(pad);\n\n\n\tfragColor = outcol;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}