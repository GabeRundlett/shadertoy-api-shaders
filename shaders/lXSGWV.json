{
    "Shader": {
        "info": {
            "date": "1708891886",
            "description": ".A 2d GPU based electromagnetic wave simulation showing a lens forming an image.",
            "flags": 32,
            "hasliked": 0,
            "id": "lXSGWV",
            "likes": 3,
            "name": "LensFocusSim",
            "published": 3,
            "tags": [
                "simulation"
            ],
            "usePreview": 0,
            "username": "10maurycy10",
            "viewed": 132
        },
        "renderpass": [
            {
                "code": "\n#define GET(dx, dy) texelFetch(iChannel0, ivec2(uv.x+dx, uv.y+dy), 0)\n#define GETP(dx, dy) texelFetch(iChannel1, ivec2(uv.x+dx, uv.y+dy), 0)\n\nvoid mainImage( out vec4 fragColor, in vec2 uv) {\n    // Highlight edges\n    vec3 edge = vec3(0.0, 0.0, 0.0);\n    if (length(GETP(0.0, 0.0) - GETP(0.0, -1.0)) + length(GETP(0.0, 0.0) - GETP(-1.0, 0.0)) > .1) {\n        edge = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Magnetic field\n    float b = GET(0.0, 0.0).z + GET(0.0, 1.0).z + GET(0.0, -1.0).z + GET(-1.0, 0.0).z + GET(1.0, 0.0).z;\n    b /= 5.0;\n    //b = b / (1.0 + abs(b)) *15.0;\n    vec3 color = vec3(max(0.0, b), 0.0, max(0.0, -b));\n    // Color\n    fragColor = vec4(color + edge, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Main Simulation\n\n#define pitch .05\n#define timestep .01\n#define GET(dx, dy) texelFetch(iChannel0, ivec2(uv.x+dx, uv.y+dy), 0)\n#define GETP() texelFetch(iChannel1, ivec2(uv.x, uv.y), 0)\n\n#define perm 0.5\n#define permit 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 uv) {\n    // x = Ex\n    // y = Ey\n    // z = B\n    \n    ivec2 res = ivec2(int(iResolution.x), int(iResolution.y));\n    \n    // Don't simulate edges, keep value the same\n    if (int(uv.x) == 0 || int(uv.x) == res.x - 1 || int(uv.y) == 0 || int(uv.y) == res.y - 1) {\n        fragColor = GET(0.0, 0.0);\n        return;\n    }\n    \n    // Initial conditions\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n   \n    float dB_dy = (GET(0.0,0.0).z - GET(0.0, -1.0).z)/pitch;\n    float dB_dx = (GET(0.0,0.0).z - GET(-1.0, 0.0).z)/pitch;\n    float dEx_dy = (GET(0.0,1.0).x - GET(0.0, 0.0).x)/pitch;\n    float dEy_dx = (GET(1.0,0.0).y - GET(0.0, 0.0).y)/pitch;\n    \n    // Conductivity * voltage + extra\n    float Jx = GETP().x * GET(0.0, 0.0).x + GETP().z;\n    float Jy = GETP().x * GET(0.0, 0.0).y + GETP().w;\n    \n    float dEx_dt = (dB_dy + Jx)/GETP().y;\n    float dEy_dt = (-dB_dx + Jy)/GETP().y;\n    float dB_dt = (dEx_dy - dEy_dx);\n\n    fragColor = GET(0.0, 0.0);\n    if (iFrame % 2 == 0) {\n    \n        fragColor.x += dEx_dt * timestep;\n        fragColor.y += dEy_dt * timestep;\n    } else {\n        fragColor.z += dB_dt * timestep;\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Sim Parameters:\n// X: Conductivity\n// Y: permitivity\n// Z: Added CurrentX\n// W: Added CurrentY\n\n#define PI 3.1415926538\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n    ivec2 res = ivec2(int(iResolution.x), int(iResolution.y));\n    fragColor = vec4(-0.0,0.5,0.0,0.0);\n    // Add a circular lens\n    if (length(uv.x - iResolution.x/2.0) < 10.0) fragColor.x = -5.0;\n    vec2 lenscord = vec2(length(uv.x-iResolution.x/2.0) + 230.0, uv.y-iResolution.y/2.0);\n    if (length(lenscord) < 300.0) {\n        fragColor.y = 1.0;\n        fragColor.x = 0.0;\n    }\n    // Add an excitation source\n    if (int(uv.x) == res.x/10 && int(uv.y) == res.y/3) fragColor.w += sin(iTime*1.0)*2000.0; // Sinc wavelet\n    if (int(uv.x) == res.x/10 && int(uv.y) == res.y*2/3) fragColor.w += sin(iTime*1.0)*2000.0; // Sinc wavelet\n    // absorbing edges\n    if (int(uv.x) < 40 || int(uv.x) > res.x - 40 || int(uv.y) < 40 || int(uv.y) > res.y - 40) fragColor.x = -1.0;\n    if (int(uv.x) < 30 || int(uv.x) > res.x - 30 || int(uv.y) < 30 || int(uv.y) > res.y - 30) fragColor.x = -2.0;\n    if (int(uv.x) < 20 || int(uv.x) > res.x - 20 || int(uv.y) < 20 || int(uv.y) > res.y - 20) fragColor.x = -3.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}