{
    "Shader": {
        "info": {
            "date": "1548433715",
            "description": "Testing low discrepancy sampling points. Simplified/adapted from lhog's [url]https://www.shadertoy.com/view/wd2GzD[/url]\nMouse.x controls density.\nNote that tiles appear after some density threshold, not sure why.\nswitch #if to see how H(x) correl H(x+64)",
            "flags": 0,
            "hasliked": 0,
            "id": "wdS3zm",
            "likes": 6,
            "name": "Low discrepancy: Hammersley set",
            "published": 3,
            "tags": [
                "random",
                "poisson",
                "hash",
                "bluenoise",
                "lowdiscrepancy",
                "hammersley",
                "pointset"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1059
        },
        "renderpass": [
            {
                "code": "// ---Low discrepancy points using Hammersley sets\n// adapted from lhog's https://www.shadertoy.com/view/wd2GzD\n// Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n\n\n// Low discrepancy on [0, 1] ^2\nvec2 HammersleyNorm(int i, int N) {\n    // principle: reverse bit sequence of i\n\tuint b =  ( uint(i) << 16u) | (uint(i) >> 16u );\n\tb = (b & 0x55555555u) << 1u | (b & 0xAAAAAAAAu) >> 1u;\n\tb = (b & 0x33333333u) << 2u | (b & 0xCCCCCCCCu) >> 2u;\n\tb = (b & 0x0F0F0F0Fu) << 4u | (b & 0xF0F0F0F0u) >> 4u;\n\tb = (b & 0x00FF00FFu) << 8u | (b & 0xFF00FF00u) >> 8u;\n\n\treturn vec2( i, b ) / vec2( N, 0xffffffffU );\n}\n\n// Low discrepancy on Disk \nvec2 HammersleyDisk(int i, int N) {\n    vec2 h = 2.* HammersleyNorm(i, N) - 1.;\n    return h * sqrt( 1. - .5 * h*h ).yx;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y,\n         M = iMouse.xy, D;\n    O-=O;\n    int N = int( 4096.* ( length(M) < 10. \n                             ? .5+.5*sin(iTime) \n                             :  M.x/R.x  ) );\n    \n#if 0    // test: H(x) very close to H(x+2^i) (the more as i grows)\n    O.r = float( u.y/R.y < HammersleyNorm(int(u.x)   ,N).y ); \n    O.g = float( u.y/R.y < HammersleyNorm(int(u.x)+64,N).y ); \n    return;\n#endif\n    \n    float d = 1e5;\n    if (U.x < 0.) { // left: square\n      //for (int i = 0; i < N; i++) // we can find the visible ones:\n        int j = int(float(N)*(.5+.5*U.x)),\n            r = int(float(N)*2.5/R.y)+1; \n        for (int i = j-r; i < j+r+1; i++)\n            D = 2.* HammersleyNorm(i, N) - 1. - U,\n            d = min(d, dot(D,D) );\n    }\n    else            // right: disk\n        for (int i = 0; i < N; i++)\n            D = HammersleyDisk(i, N) - U,\n            d = min(d, dot(D,D) );\n   \n    O[int(U.x<0.)] = smoothstep(10./R.y, 0., sqrt(d) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}