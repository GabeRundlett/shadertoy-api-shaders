{
    "Shader": {
        "info": {
            "date": "1703023943",
            "description": "Apollonian Spheres - given four spheres, find a sphere that touches all four. There are up to 16 solutions, shown here two at a time.\n\nUse mouse for rotation & up and down to zoom. See Common tab for the maths, which is quite fun.",
            "flags": 48,
            "hasliked": 0,
            "id": "XflGDH",
            "likes": 14,
            "name": "The Problem of Apollonius in 3D",
            "published": 3,
            "tags": [
                "spheres",
                "problem",
                "apollonius"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Problem of Apollonius in 3D, mla, 2023.\n//\n// Given four spheres, find another that touches them all. There are up to\n// 16 solutions (the configuration used here has all 16, shown two at a time).\n//\n// The tangent spheres are found by reducing one sphere to a point, which is\n// used as a centre of inversion. Then find a tangent plane to the inverted\n// spheres. Inverting that plane back gives the required sphere. The 16\n// solutions come from which side of the solution plane or circle the original\n// circles are.\n// \n// Controls:\n// <mouse>: rotate view\n// <up>/<down>: zoom in/out\n// 1,2: hide solution spheres 1,2\n// o: show orthogonal spheres\n// p: use zero sphere as animation base\n// r: rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 spheres[] = vec4[](vec4(1,1.5,0,1),\n                        vec4(1.2,-1.8,0,1.4),\n                        vec4(-1.5,0,2.1,1.2),\n                        vec4(-1,0,-2,1.1),\n                        vec4(0),\n                        vec4(0),\n                        vec4(0));\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    //p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 skycolor(vec3 r) {\n  //return vec3(1,1,0.5);\n  //return vec3(0.5,0.5,1);\n  //return pow(abs(r),vec3(2.0));\n  //return abs(transform(r));\n  return texture(iChannel0,r).rgb;\n}\n\nvec3 getcol(int i) {\n  if (i == 0) return vec3(1,0.75,0.75);\n  if (i == 1) return vec3(0.75,1,0.75);\n  if (i == 2) return vec3(0.75,0.75,1);\n  return vec3(1);\n}\n\nconst int NSPHERES = spheres.length();\nconst int MAXSTEPS = 20;\nfloat ambient = 0.2;\nfloat diffuse = 0.4;\nfloat specular = 0.6;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nvec3 raycolor(vec3 p, vec3 r) {\n  vec3 att = vec3(1);\n  vec3 col = vec3(0);\n  vec3 light = normalize(vec3(1,2,3));\n  for (int i = 0; i < MAXSTEPS; i++) {\n    float t = 1e8;\n    int hitsphere = -1;\n    for (int j = 0; j < NSPHERES; j++) {\n      if (key(CHAR_0+1) && j == 4) continue;\n      if (key(CHAR_0+2) && j == 5) continue;\n      bool transparent = j >= 4; // Need proper materials\n      vec2 tt;\n      if (intersectsphere(p,r,spheres[j],tt)) {\n        if (tt[0] > 0.0) {\n          if (tt[0] < t) {\n            t = tt[0];\n            hitsphere = j;\n          }\n        } else if (transparent && tt[1] > 0.0)\n          if (tt[1] < t) {\n            t = tt[1];\n            hitsphere = j;\n          }\n      }\n    }\n    if (hitsphere == -1) {\n      col += att*skycolor(r);\n      return col;\n    }\n    p += (t+1e-4)*r; // Try not to get trapped\n    vec3 n = normalize(p-spheres[hitsphere].xyz); // Normal is just direction from sphere centre\n    if (hitsphere >= 4) {\n      // Need to add some colour here\n      float s = pow(max(0.0,dot(reflect(light,n),vec3(r))),specularpow);\n      vec3 scol = getcol(hitsphere-4);\n      col += att*specular*s*specularcolor;\n      col += att*0.1*scol*(ambient+diffuse*max(0.0,dot(light,n)));\n      //return att*col;\n      att *= 0.8*scol;\n    } else {\n      //att *= 0.9;\n      r = reflect(r,n);\n    }\n  }\n  return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float AA = 2.0;\n  vec3 col = vec3(0);\n  int signs = int(0.2*iTime);\n  float t = mod(iTime,5.0);\n  t = min(t,4.0-t);\n  t = clamp(t,0.0,1.0);\n  float k = smoothstep(0.0,1.0,t);\n  mat2x4 res = apollonius(mat4(setsign(spheres[0],signs>>0),\n                               setsign(spheres[1],signs>>1),\n                               setsign(spheres[2],signs>>2),\n                               spheres[3]));\n  vec4 orth = orthogonal(spheres[0],spheres[1],spheres[2],spheres[3]);\n  vec4 base = vec4(0);\n  if (!key(CHAR_P)) base = orth;\n  if (key(CHAR_O)) spheres[6] = orth;\n  vec4 eps = vec4(0,0,0,1e-3);\n  spheres[4] = mix(base-eps,res[0],k);\n  spheres[5] = mix(base+eps,res[1],k);\n  if (key(CHAR_O)) spheres[6] = orth;\n  float camera = 8.0*exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec3 p = vec3(0,0,camera);\n      p = transform(p);\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,-2);\n      r = transform(r);\n      r = normalize(r);\n      col += raycolor(p,r);\n    }\n  }\n  col /= AA*AA;\n  //assert(max(col.x,max(col.y,col.z)) <= 1.0);\n  col = clamp(col,0.0,1.0);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n#define CHECK true\n\n// Use this to check our work\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-5;\n}\n\n// GLM compatibility\n#define xyz(a) (a.xyz)\n#define zxy(a) (a.zxy)\n#define yzx(a) (a.yzx)\n#define xy(a) (a.xy)\n#define yz(a) (a.yz)\n#define zx(a) (a.zx)\n\n// Circles are sometimes 'oriented', ie. the radius component is signed.\nfloat sgn(int n) {\n  if ((n&1) == 0) return 1.0;\n  else return -1.0;\n}\n\nvec4 setsign(vec4 s, int sign) {\n  s.w *= sgn(sign);\n  return s;\n}\n\nvec4 clearsign(vec4 s) {\n s.w = abs(s.w);\n return s;\n}\n\n// We really could do with a generic representation that covers\n// both planes and spheres. eg. something like (p,k) where p and\n// pk are ends of a diameter (so for k = infinity, we have a plane).\n// Inversion is then just (p,k) -> (p/dot(p,p),1/k)\n\nvec4 invertplane(vec4 s) {\n  // plane is (n,d) and point p: p.n+d = 0\n  // so if p = kn want kn.n+d = 0, k = -d/n.n\n  vec3 n = xyz(s); // n should be normalized\n  float d = -s.w; // distance from origin\n  float k = 0.5/d;\n  vec3 p = n*k;  // (2.0*d); // Half of inverse point\n  return vec4(p,-k); // That's the sphere!\n}\n\nvec4 invertsphere(vec4 s) {\n  // Note resemblance to Minkowski product\n  float sgn = sign(s.w);\n  vec4 H = vec4(1,1,1,-1);\n  float k = dot(H*s,s);\n  // If k = 0, then we have a sphere through the centre of inversion,\n  // which becomes a plane. Dealing with this is a nuisance, so we won't.\n  assert(k != 0.0);\n  s /= k;\n  // Possibly need to worry about the sign, but this seems OK.\n  return s;\n}\n\n// Find a point in both plane0 and plane1. This is simple except\n// for dealing with planes being parallel to the coordinate\n// planes.\nvec3 getintersectionpoint(vec4 plane0, vec4 plane1) {\n  // Find 3 intersections of line with reference planes and choose\n  // the best. Since this involves inverting a 2x2 matrix, use\n  // the one with the largest determinant.\n  vec3 m = xyz(plane0), n = xyz(plane1);\n  vec2 t = vec2(plane0.w,plane1.w);\n  mat2 m0 = mat2(xy(m),xy(n));\n  mat2 m1 = mat2(yz(m),yz(n));\n  mat2 m2 = mat2(zx(m),zx(n));\n  float d0 = abs(determinant(m0));\n  float d1 = abs(determinant(m1));\n  float d2 = abs(determinant(m2));\n  float dmax = max(d0,max(d1,d2));\n  if (dmax == d1) m0 = m1;\n  else if (dmax == d2) m0 = m2;\n  vec3 p = vec3(t*inverse(m0),0);\n  if (dmax == d1) p = zxy(p);\n  else if (dmax == d2) p = yzx(p);\n  assert(eq(dot(m,p),t[0]));\n  assert(eq(dot(n,p),t[1]));\n  return p;\n}\n\n// Find a plane, equation p.n = k, with |n| = 1, and satifying:\n// c0.n - r0 = c1.n - r1 = c2.n - r2 = k, for some k\n// this gives two equations which define a line:\n// n.(c0-c1) = r0-r1 & n.(c1-c2) = r1-r2\n// Get line direction with cross product & find a point on\n// the line, then intersect line with unit sphere to get\n// a normalized normal vector.\nmat2x3 gettangentnormals(vec4 s0, vec4 s1, vec4 s2) {\n  vec3 c0 = xyz(s0), c1 = xyz(s1), c2 = xyz(s2);\n  float r0 = s0.w, r1 = s1.w, r2 = s2.w;\n  vec3 r = cross(c0-c1,c1-c2); // Direction of plane intersection\n  if (r0 == r1 && r1 == r2) {\n    // The normal locus passes through origin, so just use\n    // origin and cross product for sample points.\n    // If centres collinear, an infinity of solutions\n    r = normalize(r);\n    return mat2x3(-r,r);\n  }\n  // Find a point in the intersections of the two planes\n  vec3 p = getintersectionpoint(vec4(c0-c1,r0-r1),vec4(c1-c2,r1-r2));\n\n  // Now intersect line p+tr line with unit sphere.\n  // Full equation is n.n = (p+tr)² = p.p+2tp.r+t²r.r = 1\n  // but we ensure that p.r = 0\n  p -= dot(p,r)/dot(r,r)*r; // Advance so p.r = 0\n  float A = dot(r,r);\n  float C = dot(p,p)-1.0;\n  float D = -A*C;\n  if (D < 0.0) return mat2x3(0);\n  float t = sqrt(D)/A;\n  return mat2x3(p-t*r,p+t*r);\n}\n\nmat2x4 gettangentplanes(vec4 s0, vec4 s1, vec4 s2) {\n  mat2x3 a = gettangentnormals(s0,s1,s2);\n  if (a[0] == vec3(0)) return mat2x4(0);\n  vec3 c0 = xyz(s0); float r0 = s0.w;\n  mat2x4 res;\n  for (int i = 0; i < 2; i++) {\n    vec3 n = a[i];\n    // Want (n,k).(c0,1) = n.c0 + k = r0 etc\n    vec4 p = vec4(n,r0-dot(n,c0));\n    res[i] = p;\n    if (CHECK){\n      vec3 c1 = xyz(s1), c2 = xyz(s2);\n      float r1 = s1.w, r2 = s2.w;\n      assert(eq(length(n),1.0));\n      assert(eq(dot(p,vec4(c0,1)),r0));\n      assert(eq(dot(p,vec4(c1,1)),r1));\n      assert(eq(dot(p,vec4(c2,1)),r2));\n    }\n  }\n  return res;\n}  \n\nmat2x4 apollonius0(mat4 s) {\n  // Solve the 3D problem of Apollonius for\n  // four spheres. Rebase the spheres with\n  // the fourth at origin. This also subtracts\n  // the radius, so we are now after a sphere\n  // through the origin tangent to three spheres.\n  // Having solved this, reduce the radius of\n  // the solution sphere to solve the original\n  // problem.\n  vec4 base = s[3];\n  for (int i = 0; i < 3; i++) {\n    s[i] -= base;\n    s[i] = invertsphere(s[i]);\n  }\n  // Now find a plane tangent to those 3 circles\n  mat2x4 res = gettangentplanes(s[0],s[1],s[2]);\n  for (int i = 0; i < 2; i++) {\n    vec4 plane = res[i];\n    if (plane == vec4(0)) continue;\n    vec4 a = invertplane(plane);\n    // Rebase a, but _subtract_ the base radius.\n    a += base*vec4(1,1,1,-1); // a is the Apollonian sphere\n    res[i] = a;\n  }\n  return res;\n}\n\nmat2x4 apollonius(mat4 s) {\n  mat2x4 res = apollonius0(s);\n  if (CHECK) {\n    vec4 s0 = s[0], s1 = s[1], s2 = s[2], s3 = s[3];\n    vec3 c0 = xyz(s0), c1 = xyz(s1), c2 = xyz(s2), c3 = xyz(s3);\n    float r0 = s0.w, r1 = s1.w, r2 = s2.w, r3 = s3.w;\n    for (int i = 0; i < 2; i++) {\n      vec3 ca = xyz(res[i]); float ra = res[i].w;\n      assert(eq(distance(ca,c0)-abs(r0+ra),0.0));\n    }\n  }\n  res[0] = clearsign(res[0]);\n  res[1] = clearsign(res[1]);\n  return res;\n}\n\n// \"cross product\" for ℝ⁴ - ie, given three 4-vectors, find\n// a fourth orthogonal to all three (unique up to scaling).\n// So for homogeneous coordinates, the function is finding\n// the plane spanned by three points, or the point of\n// intersection of three planes.\nvec4 cross3(vec4 p, vec4 q, vec4 r) {\n  mat4x3 m = transpose(mat3x4(p,q,r));\n#if 0\n  // det(a,b,c) = dot(a,cross(b,c)) so there is scope\n  // for optimization here\n  return vec4(determinant(mat3(m[1],m[2],m[3])),\n              -determinant(mat3(m[2],m[3],m[0])),\n              determinant(mat3(m[3],m[0],m[1])),\n              -determinant(mat3(m[0],m[1],m[2])));\n#else\n  // For example:\n  vec3 m01 = cross(m[0],m[1]);\n  vec3 m23 = cross(m[2],m[3]);\n  vec4 res = vec4(dot(m[1],m23),-dot(m[0],m23),\n                  dot(m[3],m01),-dot(m[2],m01));\n  return res;\n#endif\n}\n\nvec3 unhomogenize(vec4 p) {\n  return xyz(p)/p.w;\n}\n\nfloat dist2(vec3 a, vec3 b) {\n  return dot(b-a,b-a);\n}\n\nfloat power(vec3 p, vec4 s) {\n  return dist2(p,vec3(s))-s.w*s.w;\n}\n\nvec4 radical(vec4 s, vec4 S) {\n  vec3 n = vec3(s)-vec3(S);\n  float r2 = s.w*s.w, R2 = S.w*S.w;\n  float d2 = dot(n,n);\n  float A = 0.5*(d2+R2-r2)/d2;\n  vec3 p = xyz(S)+A*n;\n  float k = dot(n,p);\n  return vec4(n,-k);\n}\n\n// The centre of the unique orthogonal circle to a,b,c,d is at\n// the intersection of their pairwise radical planes (ie. the\n// point with the same power with respect to each of the spheres).\n// So construct 3 radical planes and intersect...\nvec4 orthogonal(vec4 a, vec4 b, vec4 c, vec4 d) {\n  vec4 p = radical(a,b);\n  vec4 q = radical(b,c);\n  vec4 r = radical(c,d);\n  vec3 centre = unhomogenize(cross3(p,q,r));\n  // Now find orthogonal sphere from centre to a:\n  float radius = sqrt(dist2(centre,xyz(a))-a.w*a.w);\n  return vec4(centre,radius);\n}\n\n///////////////////////////////////////////////////////////////////\n\nvec2 expi(float t) {\n  return vec2(cos(t),sin(t));\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nbool intersectsphere(vec3 p, vec3 r, vec4 sphere, out vec2 t) {\n  vec3 centre = sphere.xyz;\n  float radius = sphere.w;\n  p -= centre; // Centre on sphere\n  float r2 = radius*radius;\n  // Want dot(p+t*r,p+t*r) = r2\n  // ie. p.p - r2 + 2tp.r + t^2 = 0\n  float k = -dot(p,r);\n  p += k*r; // Advance p so p.r = 0\n  float C = r2-dot(p,p);\n  if (C < 0.0) return false;\n  float D = sqrt(C);\n  t = vec2(-D,D)+k;\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n// const int KEY_SHIFT = 16;\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}