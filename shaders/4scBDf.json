{
    "Shader": {
        "info": {
            "date": "1526969049",
            "description": "This is an idea for combining standard Blinn-Phong shading with (fake) fresnel... a poor-man's PBR so to speak :) What do you think? See line 197 for the faked fresnel.",
            "flags": 0,
            "hasliked": 0,
            "id": "4scBDf",
            "likes": 12,
            "name": "fake fresnel'ed blinn-phong blob",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "phong",
                "metaballs",
                "shadow",
                "fog",
                "blinn",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 1139
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"fake frenel'ed blinn-phong blob\" - poor man's PBR ;) \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .0001;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .7;\n\nmat2 r2d (in float a) {\n    float c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nvec2 opRepeat2 (inout vec2 p, in vec2 size) {\n    vec2 hsize = .5 * size;\n    vec2 cell = floor ((p + hsize) / size);\n    p = mod (p + hsize, size) - hsize;\n    return cell;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat sdHexPrism (in vec3 p, in vec2 h) {\n    vec3 q = abs (p);\n    return max (q.z - h.y, max ((q.x * .866025 + q.y * .5), q.y) - h.x);\n}\n\nfloat scene (in vec3 p) {\n    vec3 pBottom = p;\n    vec3 pTop = p;\n\n    float r1 = .1 + .3 * (.5 + .5 * sin (2. * iTime));\n    float r2 = .1 + .25 * (.5 + .5 * sin (3. * iTime));\n    float r3 = .1 + .3 * (.5 + .5 * sin (4. * iTime));\n    float r4 = .1 + .25 * (.5 + .5 * sin (5. * iTime));\n\n    float t = 2. * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t), .1, -.2*sin(t));\n    vec3 offset2 = vec3 (.2, .2*cos(t), .3*sin(t));\n    vec3 offset3 = vec3 (-.2*cos(t), -.2*sin(t), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t), .4*sin(t));\n    vec3 offset5 = vec3 (.4*cos(t), -.2, .3*sin(t));\n    vec3 offset6 = vec3 (-.2*cos(t), -.4, -.4*sin(t));\n    vec3 offset7 = vec3 (.3*sin(t), -.6*cos(t), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t), -.4*cos(t));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n    float metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    pBottom.yz *= r2d(90.);\n    vec2 cellBottom = opRepeat2 (pBottom.yx, vec2 (.75));\n\n    pTop.yz *= r2d(270.);\n    vec2 cellTop = opRepeat2 (pTop.yx, vec2 (.75));\n\n    float hexBottom = sdHexPrism (pBottom + vec3 (.0, .0, -3.), vec2 (.25, .75 + .2 * sin(cellBottom.y)*cos(cellBottom.x)));\n    float hexTop = sdHexPrism (pTop + vec3 (.0, .0, -3.), vec2 (.25, .75 + .2 * sin(cellTop.y)*cos(cellTop.x)));\n\n    return min (metaBalls, min (hexBottom, hexTop));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        t = scene (ro + d*rd);\n        if (abs (t) < EPSILON * (1. + .125*t)) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n    float d = scene (p);\n    vec3 e = vec3 (epsilon, .0, .0);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 lPos) {\n    float distanceToLight = distance (p, lPos);\n    vec3 n = normal (p, EPSILON);\n    float distanceToObject = raymarch (p + .01*n, normalize (lPos - p));\n    bool isShadowed = distanceToObject < distanceToLight;\n    return isShadowed ? .1 : 1.;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d) {\n    vec3 p = ro + d*rd;\n    vec3 amb = vec3 (.1);\n    vec3 diffC = vec3 (1., .5, .3);\n    vec3 specC = vec3 (1., .95, .9);\n    vec3 diffC2 = vec3 (.3, .5, 1.);\n    vec3 specC2 = vec3 (.9, .95, 1.);\n\n    vec3 n = normal (p, d*EPSILON);\n    vec3 lPos = ro + vec3 (.5, 1.0, -3.);\n    vec3 lPos2 = ro + vec3 (-1., 1.2, 2.);\n    vec3 lDir = lPos - p;\n    vec3 lDir2 = lPos2 - p;\n    vec3 lnDir = normalize (lDir);\n    vec3 lnDir2 = normalize (lDir2);\n    float sha = shadow (p, lPos);\n    float sha2 = shadow (p, lPos2);\n    float lDist = distance (p, lPos);\n    float lDist2 = distance (p, lPos2);\n    float attenuation = 8. / (lDist*lDist);\n    float attenuation2 = 8. / (lDist2*lDist2);\n\n    float diff = max (dot (n, lnDir), .0);\n    float diff2 = max (dot (n, lnDir2), .0);\n    vec3 h = normalize (lDir - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec = pow (max (dot (h, n), .0), 20.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    vec3 diffTerm = sha * attenuation * diff * diffC;\n    vec3 diffTerm2 = sha2 * attenuation2 * diff2 * diffC2;\n    vec3 specTerm = (sha > .1) ? attenuation * spec * specC : vec3 (.0);\n    vec3 specTerm2 = (sha2 > .1) ? attenuation2 * spec2 * specC2 : vec3 (.0);\n\n    return amb + diffTerm + specTerm + diffTerm2 + specTerm2;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv *2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float angle = radians (300. + 55. * iTime);\n    float dist = 3. + cos (1.5*iTime);\n    vec3 ro = vec3 (dist * cos (angle), .0, dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.05);\n    vec3 p = ro + d * rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (ro, rd, d);\n\n    // the reflection with the faked fresnel\n    vec3 refl = normalize (reflect (rd, n));\n    float refd = raymarch (p + .01*n, refl);\n    vec3 refc = shade (p, refl, refd);\n    float fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.75);\n    col += .35*fakeFresnel*fakeFresnel*refc;\n\n    col *= fog;\n    col = mix (col, vec3 (.95, .85, .7), pow (1. - 1. / d, 17.));\n    col = col / (.75 + col);\n    col = .2 * col + .8 * sqrt (col);\n    col *= .7 + .3 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}