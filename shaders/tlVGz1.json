{
    "Shader": {
        "info": {
            "date": "1578603672",
            "description": "An experiment in creating a dense detailed organic scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlVGz1",
            "likes": 18,
            "name": "Wildflower",
            "published": 3,
            "tags": [
                "raymarching",
                "flower",
                "grass",
                "organic",
                "natural"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 862
        },
        "renderpass": [
            {
                "code": "/*\n       _\n\\^/ILD|-LOWER\n\nby Hazel Quantock 2020\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n*/\n\n// create a simple repetetive patch of grass,\n// then blend it with copies of itself randomly offset and rotated\n\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\n{\n    // cone, curved from vertical to tip\n    // subtract a second cone, offset away from tip\n    // maybe curve more on shorter ones\n\n    float v = (pos.y-base.y) / (tip.y - base.y);\n    \n    // curve the blade\n    v = pow(v,1.5);\n\n    // apply the curved slope\n    pos.xz -= mix(base.xz,tip.xz,v);\n\n    // wrap space here, so it can follow the curve without needing duplicate blades\n    // even if blade curves enough to lean into next repeat!\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\n    \n    float r = .03*tip.y;\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\n    \n    if ( stalk )\n        r = .0005;\n    else\n        r *= (1.-v);\n    \n    float f = length(pos.xz) - r;\n\n    if ( !stalk )\n    {\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\n    }\n        \n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\n}\n\n\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\n{\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\n    \n//\tfloat f = length(tpos)-.003;\n    \n    // tilt, so the flower sits at a nice angle\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\n    \n    // petals: mirror tpos in a circle around z\n    tpos.xy = abs(tpos.xy);\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\n\n// too thin at the edges\n// better to intersect a thin sphere with a sphere to cut the shape\n/*    float f = max(\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\n        );*/\n    float f = max(\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\n        );\n    f = min( f,\n            max(\n\t            length(tpos-vec3(0,0,.000)) -.001,\n\t            length(tpos-vec3(0,0,.001)) -.001\n            )\n            )*.9;\n\n\tif ( grass ) f = min(min( f,\n                             BladeOfGrass( base, tip, tile, pos, true )),\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\n                            );\n    \n\treturn f;\n}\n\n\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\n{\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\n    \n//    invWeight = invWeight*invWeight; // should be 0 until about .5\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\n\n    // vary the height a little to make it look less even\n    pos.y += sqrt(rand.w)*.07;\n    \n    pos.xz += rand.xy;\n    float a = rand.z*6.283;\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\n    \n    float f = 1e20;\n    \n    if ( grass )\n    {\n        f = min(f,min(min(min(min(\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\n        )) + (1.-invWeight)*.0;\n    }\n    \n    // flowers\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\n    \n    return mix( max(.03,pos.y-.2), f, invWeight );\n//    return f;\n}\n\nfloat SDF( vec3 pos, bool grass )\n{\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\n    \n    vec2 gridSize = vec2(.1);//.04);\n    vec2 uv = pos.xz/gridSize;\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\n    uv -= floor(uv);\n    \n    uvec2 d = uvec2(0,1);\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\n\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\n\n    vec2 uvlo = smoothstep(1.,.5,uv);\n    vec2 uvhi = smoothstep(0.,.5,uv);\n\n    return min( pos.y,\n                min(\n                    min(\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\n                    ),\n                    min(\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\n                    )\n                )\n\t\t\t) * 1.;\n/*    return mix(\n                    mix(\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\n                        uv.x\n                    ),\n                    mix(\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\n                        uv.x\n                    ),\n        \t\t\tuv.y\n                );*/\n}\n\n// adjust trace quality/performance\nconst float epsilon = .00005;\nconst int loopCount = 200;\n\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\n{\n\tfloat t = epsilon;\n    for ( int i=0; i < loopCount; i++ )\n    {\n        float h = SDF( rayDirection*t+rayStart, true );\n        t += h;\n        if ( t > far || h < epsilon ) // *t )\n            return t;\n    }\n    \n    return t;\n}\n\n\nvec3 Normal( vec3 pos )\n{\n    vec2 d = vec2(-1,1) * .000004;\n    return\n        normalize(\n            SDF( pos + d.xxx, true )*d.xxx +\n            SDF( pos + d.xyy, true )*d.xyy +\n            SDF( pos + d.yxy, true )*d.yxy +\n            SDF( pos + d.yyx, true )*d.yyx\n        );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\n    float camZoom = 2.;\n    \n    vec3 camK = normalize(camLook-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\n    ray = normalize(ray);\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    \n    float t = Trace( camPos, ray, 1e20 );\n    \n    float far = 20.;\n    if ( t < far )\n    {\n        vec3 pos = camPos+ray*t;\n\n        float sdf = SDF(pos,true);\n        float sdfnograss = SDF(pos,false);\n\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\n\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\n\n        vec3 n = Normal( camPos+ray*t );\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\n        float nl = dot(n,normalize(vec3(1,3,2)));\n\n        fragColour.rgb = ambient;\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\n        fragColour.rgb *= albedo;\n    }\n    else\n    {\n        fragColour.rgb = vec3(1);\n        t = far; // so it gets fog applied\n    }\n    \n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\n \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}