{
    "Shader": {
        "info": {
            "date": "1471307779",
            "description": "for Fast circle tangents: Finding the most efficient way to return the distance to a [capsule with 2 different radii]. testing how accurately the tangent case scales. 3 colored Seeaws visualize distances. 2 Debug circles show tangent intersections.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ld3WS",
            "likes": 4,
            "name": "TangentCapsule() Pill with2radii",
            "published": 3,
            "tags": [
                "2d",
                "tutorial",
                "pill",
                "capsule",
                "tangent",
                "seesaw",
                "limb",
                "lever",
                "kinematic",
                "muscle",
                "bisymmetry"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1113
        },
        "renderpass": [
            {
                "code": "//calculate a circle-circle tangent with focus on efficiency, Seeaws visualize distance,\n//unifying 3 distance functions of; a tangential-line-segment and 2-circles; into one TangentCapsule(). \n//\"capsule\" is a geometrically better description than \"pill\"\n//\n//TangentCapsule() returns distance to a capsule with 2 radii.\n//\"tangent\"-> trickier than a trapezoid with 2 half circles on the parallel ends.\n//you can also describe it as a most-rounded-triangle, that usually converts linear to circular motion.\n//base function for limb/muscle/branch or steam-engine-lever like parts.\n//Kinematic objects usually have one thick and one thin round part with a tangent to transfer energy\n//...to keep angular momentum low at the thinner end that rotates around further.\n//For kinematic systems, The Large-circle-center is placed at (0,0) as far as TangentCapsule() LOCAL coordinates care.\n//TangentCapsule() only cares for the 1 positive tangent in 2d, you have to use/break symmetry to extrude or rotate this 2d shape:\n//rotate (2 dimensions of) input value p of TangentCapsule(p,vec3 scales) by doing: p.xy*=rot2(rotation_in_radians)\n//left circle h.x should always be larger than right circle h.y and not conpletely contain the right circle: h.z>h.x-h.y\n//because that defeats the purpose of the TangentCapsule() function by having no tangent\n//\n//by ollj, free use.\n\n//this only solves 1 tangent in 2d. \n//https://www.shadertoy.com/user/tdhooper \n//and the distance function for a torus\n//should teach you how to fold/mirror space and project points \n//and how to use x=abs(x) and dot() and cross()\n//to utilize TangentCapsule() for a 3d or 4d shape.\n\n// pib = pi*.5 = quater rotation,lower precision becomes visible,as this calculates: *(sin|cos(pi*.5-atan(x,y)))\nconst float pib=asin(1.);//1.5707963267948966192313216916398;\n\n//return a 2d rotation matrix set by rotation in radians.\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n//does not check for non-intersecticn cases! intersection.y is not important.\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n\n//return f[x] of a SeeSaw curve with [w]avelength and [a]mplitude; returns range [0..amp]\nfloat SeeSaw(float x,float w,float a){return mod(x,w)*a;}\n//set [a]mplitude = 1/[w]avelength\nfloat SeeSaw2(float x,float w){return SeeSaw(x,w,1./w);}\n///return sin(t), shifted to range [0...1]\nfloat sinP(float t){return(sin(t)+1.)*.5;}\n\n\n\n//As subroutine for TangentCapsule(), resolves a branching case;\n//... Point [p] is either closest to one of the 2 circles, or closest to the tangent between the circles.\n//a and b are tangent intersection points.\n//sdline() calculates 2 lines that are orthogonal to a line trough a and b, and that goes trough a, or b.\n//this creates 3 endless lines in a \"H\"-shaped-formation. Point [p] is in one of the 3 areas. \n//sdline() is used as branching function to tell in what area of that \"H\"-shape [p] is.\n//\n//return signed distance of [p] to a line that goes trough [a] and is orthogonal to a line trough [a] and [b].\nfloat sdline(vec2 p,vec2 a,vec2 b){mat2 m=rot2(-atan(b.x-a.x,b.y-a.y)); p*=m;a*=m;b*=m;return p.y-a.y;}\n\n//show tangent intersections. You do not want this in your use case.\n#define debug_show_intersections\n\n\n//return distace of p to cylinder with rounded caps;\nfloat TangentCapsule(vec2 p,vec3 h){h.x=max(h.x,h.y);//cheap safeguard enforces constrains\n//h.x=left rasius, h.y=right rdius; h.z distance between sphere center  \n//h.x>=h.y>0.0 ! h.z>=h.x-h.y, else there is no tangent, and this function comes down to \"distance to 2 circles\".\n float s=h.x-h.y;float i=cci(vec3(s,vec2(h.z*.5)));//this is why h.x>h.y!\n vec2 a=vec2(i,sqrt(s*s-i*i));//a is the left boundary point between larger circle and cone.\n vec2 b=vec2(h.z,0)-a;        //b is \"directional vector\"\n vec2 n=normalize(vec2(b.y,-b.x));p.y=abs(p.y);//using symmetry.\n#ifdef debug_show_intersections\n #define ap a-p-n*h.y)<.01)return 1.;//for debug below\n if (length(ap if (length(b+ap//show tangent intersections for debug\n#endif\n #define mo if(sdline(p,a\n #define mi b.xy)<0.)return length(p\n mo,a+mi)-h.x;mo+b,a-mi-vec2(h.z,0))-h.y;//left circle //right circle\n p=(vec2(p.x-h.z,p.y)-b)*rot2(atan(b.y, b.x));//align down, simplify....\n  //74 line instead of rot2( pi/2-atan(b.x, b.y)) you could simple write rot2(atan(b.y, b.x))\n return p.y-h.y;}//...rotate p around (h.z,0,0) by -atan(b.x,b.y)+quater and only return .y\n\n#define res iResolution.xy\nvoid mainImage(out vec4 r,in vec2 i){\n  r.a=1.;vec2 p=i.xy/min(res.x,res.y);//.xy screenPosition\n  float s=sin(iTime);\n  float t=sin(199.+s*.3)+.5;//swivel over time for 3 color dimensions displaying 3 SDF\n  vec3 h=vec3(sinP(iTime*3.)*.4+.4,.3,1.2+s*.4);//define a cylinder with rounded top and bottom\n  vec3 c=vec3(TangentCapsule(p,h));//TangentCapsule() function is demoed here\n  //c.rgb stores the same float distance to a shape, 3 times, to be colored below:\n  c.g=SeeSaw2(c.r          ,t);//red <- distance to whole thing (2 circles and tangent)\n  c.b=SeeSaw2(length(p)-h.x,t);p.r-=h.z;//green y- distance to left circle, radius h.x, center at (0,0)\n  c.r=SeeSaw2(length(p)-h.y,t);//blue <- distance to right circle, radius h.y center at (0,h.z)\n  if(abs(c.g)<.04)c*=vec3(.5);//dark border line\n  r.rgb=vec3(c);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}