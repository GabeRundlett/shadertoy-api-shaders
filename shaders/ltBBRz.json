{
    "Shader": {
        "info": {
            "date": "1514254232",
            "description": "change draw function like processing",
            "flags": 0,
            "hasliked": 0,
            "id": "ltBBRz",
            "likes": 6,
            "name": "Processing Library",
            "published": 3,
            "tags": [
                "processing"
            ],
            "usePreview": 0,
            "username": "alijaya",
            "viewed": 655
        },
        "renderpass": [
            {
                "code": "// Internal\n\nstruct State {\n    bool isSmooth;\n    float smoothness;\n    bool isFill;\n    vec4 fill;\n    bool isStroke;\n    vec4 stroke;\n    float strokeWeight;\n    float strokeCap;\n    int ellipseMode;\n    int rectMode;\n    mat4 invMatrix;\n    vec2 coord;\n};\n\nState p_states[10];\nint p_states_length;\nState p_state;\nvec4 p_fragColor;\nvec2 p_fragCoord;\n\n// premultiplied\nvoid p_pixel(vec4 color) {\n    vec4 src = vec4(color.rgb * color.a, color.a);\n    vec4 dst = p_fragColor;\n    p_fragColor = src + dst * (1.0 - src.a);\n}\n\nvoid p_fill(float value) {\n    vec4 color = p_state.fill;\n    color.a *= value;\n    if (p_state.isFill && color.a > 0.0) {\n        p_pixel(color);\n    }\n}\n\nvoid p_stroke(float value) {\n    vec4 color = p_state.stroke;\n    color.a *= value;\n    if (p_state.isStroke && color.a > 0.0) {\n        p_pixel(color);\n    }\n}\n\nvoid p_updateCoord() {\n    p_state.coord = (p_state.invMatrix * vec4(p_fragCoord, 0.0, 1.0)).xy;\n}\n\nfloat p_step(float edge, float x) {\n    if (p_state.isSmooth) {\n        float hs = p_state.smoothness * 0.5;\n        return smoothstep(edge - hs, edge + hs, x); \n    } else {\n        return step(edge, x);\n    }\n}\n\nfloat p_not(float a) {\n    return 1.0 - a;\n}\n\nfloat p_and(float a, float b) {\n    return a * b;\n}\n\nfloat p_or(float a, float b) {\n    return 1.0 - ((1.0 - a) * (1.0 - b));\n}\n\nfloat p_line(float x, float y, vec2 n, float o) {\n    vec2 pos = vec2(x, y);\n    n = normalize(n);\n    vec2 v = p_state.coord - pos;\n    float dist = dot(n, v);\n    return p_not(p_step(o, dist));\n}\n\nfloat p_cone(float x, float y, float start, float stop, float o) {\n    vec2 vstart = vec2(cos(start), sin(start));\n    vec2 vstop = vec2(cos(stop), sin(stop));\n    \n    vec2 nstart = vec2(vstart.y, -vstart.x);\n    vec2 nstop = vec2(-vstop.y, vstop.x);\n    \n    float coneStart = p_line(x, y, nstart, o);\n    float coneStop = p_line(x, y, nstop, o);\n    float cone = 0.;\n    if (cross(vec3(vstart, 0.), vec3(vstop, 0.)).z > 0.) {\n        cone = p_and(coneStart, coneStop);\n    } else {\n        cone = p_or(coneStart, coneStop);\n    }\n    return cone;\n}\n\nfloat p_circle(float x, float y, float d, float o) {\n    float r = abs(d) * 0.5;\n    float dist = distance(vec2(x, y), p_state.coord);\n    return p_not(p_step(r + o, dist));\n}\n\nfloat p_ellipse(float x, float y, float w, float h, float o) {\n    float hw = abs(w) * 0.5 + o;\n    float hh = abs(h) * 0.5 + o;\n    vec2 dist =  p_state.coord - vec2(x, y);\n    if (hw < hh) {\n        dist.y *= hw / hh;\n        return p_not(p_step(hw, length(dist)));\n    } else {\n        dist.x *= hh / hw;\n        return p_not(p_step(hh, length(dist)));\n    }\n}\n\nfloat p_rect(float x, float y, float w, float h, float o) {\n    if (w < 0.0) {\n        x += w;\n        w *= -1.0;\n    }\n    if (h < 0.0) {\n        y += h;\n        h *= -1.0;\n    }\n    return p_and(p_and(p_step(x - o, p_state.coord.x), \n                       p_not(p_step(x + w + o, p_state.coord.x))),\n                 p_and(p_step(y - o, p_state.coord.y), \n                       p_not(p_step(y + h + o, p_state.coord.y))));\n}\n\n// End of Internal Function\n\n// Constants\n#define HALF_PI 1.57079632679489661923\n#define PI 3.14159265358979323846\n#define QUARTER_PI 0.7853982\n#define TAU 6.28318530717958647693\n#define TWO_PI 6.28318530717958647693\n\n// Constants / angleMode\n#define DEGREES 0\n#define RADIANS 1\n\n// Constants / ellipseMode / rectMode\n#define CENTER 0\n#define RADIUS 1\n#define CORNER 2\n#define CORNERS 3\n\n// Constants /arc\n#define DEFAULT 0\n#define OPEN 1\n#define CHORD 2\n#define PIE 3\n\n\n// Color / Setting\n\nvoid background(vec4 color) {\n    p_pixel(color);\n}\n\nvoid clear() {\n    p_fragColor = vec4(0.0);\n}\n\n// void colorMode\n\nvoid fill(vec4 color) {\n    p_state.isFill = true;\n    p_state.fill = color;\n}\n\nvoid noFill() {\n    p_state.isFill = false;\n}\n\nvoid stroke(vec4 color) {\n    p_state.isStroke = true;\n    p_state.stroke = color;\n}\n\nvoid noStroke() {\n    p_state.isStroke = false;\n}\n\n// Shape / 2D Primitives\n\nvoid arc(float x, float y, float w, float h, float start, float stop, int mode) {\n    if (p_state.ellipseMode == CENTER) {\n        // nothing / default\n    } else if (p_state.ellipseMode == RADIUS) {\n        w *= 2.0;\n        h *= 2.0;\n    } else if (p_state.ellipseMode == CORNER) {\n        x += w * 0.5;\n        y += h * 0.5;\n    } else if (p_state.ellipseMode == CORNERS) {\n        w = w - x;\n        h = h - y;\n        x += w * 0.5;\n        y += h * 0.5;\n    }\n    \n    float fill    = p_ellipse(x, y, w, h, 0.0);\n    float istroke = p_not(p_ellipse(x, y, w, h, -p_state.strokeWeight * 0.5));\n    float ostroke = p_ellipse(x, y, w, h, p_state.strokeWeight * 0.5);\n    \n    vec2 vstart = vec2(cos(start) * w * 0.5, sin(start) * h * 0.5);\n    vec2 vstop = vec2(cos(stop) * w * 0.5, sin(stop) * h * 0.5);\n    start = atan(vstart.y, vstart.x);\n    stop = atan(vstop.y, vstop.x);\n    \n    float sx = x + vstart.x;\n    float sy = y + vstart.y;\n    vec2 v = vstop - vstart;\n    vec2 n = vec2(-v.y, v.x);\n    \n    if (mode == DEFAULT) {\n        float cone = p_cone(x, y, start, stop, 0.);\n        p_fill(p_and(fill, cone));\n        p_stroke(p_and(p_and(istroke, ostroke), cone));\n        \n    } else if (mode == OPEN) {\n        float line = p_line(sx, sy, n, 0.);\n        p_fill(p_and(fill, line));\n        p_stroke(p_and(p_and(istroke, ostroke), line));\n        \n    } else if (mode == CHORD) {\n        float fillLine = p_line(sx, sy, n, 0.);\n        float istrokeLine = p_not(p_line(sx, sy, n, -p_state.strokeWeight * 0.5));\n        float ostrokeLine = p_line(sx, sy, n, p_state.strokeWeight * 0.5);\n        p_fill(p_and(fillLine, fill));\n        p_stroke(p_and(p_or(istroke, istrokeLine), p_and(ostroke, ostrokeLine)));\n        \n    } else if (mode == PIE) {\n        float fillCone = p_cone(x, y, start, stop, 0.);\n        float istrokeCone = p_not(p_cone(x, y, start, stop, -p_state.strokeWeight * 0.5));\n        float ostrokeCone = p_cone(x, y, start, stop, p_state.strokeWeight * 0.5);\n        p_fill(p_and(fill, fillCone));\n        p_stroke(p_and(p_or(istroke, istrokeCone), p_and(ostroke, ostrokeCone)));\n        \n    }\n}\n\nvoid circle(float x, float y, float d) {\n    if (p_state.ellipseMode == CENTER) {\n        // nothing / default\n    } else if (p_state.ellipseMode == RADIUS) {\n        d *= 2.0;\n    } else if (p_state.ellipseMode == CORNER) {\n        x += d * 0.5;\n        y += d * 0.5;\n    }\n    \n    float fill    = p_circle(x, y, d, 0.0);\n    float istroke = 1.0 - p_circle(x, y, d, -p_state.strokeWeight * 0.5);\n    float ostroke = p_circle(x, y, d, p_state.strokeWeight * 0.5);\n    p_fill(fill);\n    p_stroke(p_and(istroke, ostroke));\n}\n\nvoid ellipse(float x, float y, float w, float h) {\n    if (p_state.ellipseMode == CENTER) {\n        // nothing / default\n    } else if (p_state.ellipseMode == RADIUS) {\n        w *= 2.0;\n        h *= 2.0;\n    } else if (p_state.ellipseMode == CORNER) {\n        x += w * 0.5;\n        y += h * 0.5;\n    } else if (p_state.ellipseMode == CORNERS) {\n        w = w - x;\n        h = h - y;\n        x += w * 0.5;\n        y += h * 0.5;\n    }\n    \n    float fill    = p_ellipse(x, y, w, h, 0.0);\n    float istroke = 1.0 - p_ellipse(x, y, w, h, -p_state.strokeWeight * 0.5);\n    float ostroke = p_ellipse(x, y, w, h, p_state.strokeWeight * 0.5);\n    p_fill(fill);\n    p_stroke(p_and(istroke, ostroke));\n}\n\nvoid line(float x1, float y1, float x2, float y2) {\n    vec2 v = vec2(x2 - x1, y2 - y1);\n    vec2 n = vec2(v.y, -v.x);\n    float istroke = 1.0 - p_line(x1, y1, n, -p_state.strokeWeight * 0.5);\n    float ostroke = p_line(x1, y1, n, p_state.strokeWeight * 0.5);\n    float bstroke = p_line(x1, y1, -v, 0.0);\n    float estroke = p_line(x2, y2, v, 0.0);\n    p_stroke(p_and(p_and(istroke, ostroke), p_and(bstroke, estroke)));\n}\n\nvoid point(float x, float y) {\n    float stroke = p_circle(x, y, p_state.strokeWeight, 0.0);\n    p_stroke(stroke);\n}\n\nvoid rect(float x, float y, float w, float h) {\n    if (p_state.rectMode == CORNER) {\n        // nothing / default\n    } else if (p_state.rectMode == CORNERS) {\n        w = w - x;\n        h = h - y;\n    } else if (p_state.rectMode == CENTER) {\n        x -= w * 0.5;\n        y -= h * 0.5;\n    } else if (p_state.rectMode == RADIUS) {\n        x -= w;\n        y -= h;\n        w *= 2.0;\n        h *= 2.0;\n    }\n    \n    float fill    = p_rect(x, y, w, h, 0.0);\n    float istroke = 1.0 - p_rect(x, y, w, h, -p_state.strokeWeight * 0.5);\n    float ostroke = p_rect(x, y, w, h, p_state.strokeWeight * 0.5);\n    p_fill(fill);\n    p_stroke(p_and(istroke, ostroke));\n}\n\n// Shape / Attributes\n\nvoid noSmooth() {\n    p_state.isSmooth = false;\n}\n\nvoid yesSmooth() {\n    p_state.isSmooth = true;\n}\n\nvoid ellipseMode(int mode) {\n    p_state.ellipseMode = mode;\n}\n\nvoid rectMode(int mode) {\n    p_state.rectMode = mode;\n}\n\n// void strokeCap\n\n// void strokeJoin\n\nvoid strokeWeight(float weight) {\n    p_state.strokeWeight = weight;\n}\n\n// Transform\n\nvoid applyInvMatrix(mat4 invMatrix) {\n    p_state.invMatrix = invMatrix * p_state.invMatrix;\n    p_updateCoord();\n}\n\nvoid rotate(float angle) {\n    mat4 im = mat4(1.0);\n    im[0][0] = cos(-angle);\n    im[0][1] = sin(-angle);\n    im[1][0] = -sin(-angle);\n    im[1][1] = cos(-angle);\n    applyInvMatrix(im);\n}\n\nvoid scale(float x, float y) {\n    mat4 im = mat4(1.0);\n    im[0][0] = 1. / x;\n    im[1][1] = 1. / y;\n    applyInvMatrix(im);\n}\n\nvoid translate(float x, float y) {\n    mat4 im = mat4(1.0);\n    im[3][0] = -x;\n    im[3][1] = -y;\n    applyInvMatrix(im);\n}\n\n// Structure\n\nvoid push() {\n    p_states[p_states_length] = p_state;\n    p_states_length++;\n}\n\nvoid pop() {\n    if (p_states_length > 0) {\n        p_states_length--;\n        p_state = p_states[p_states_length];\n    }\n}\n\n// End of Library\n\nvoid draw() {\n    vec4 black   = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 red     = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 green   = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 blue    = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 yellow  = vec4(1.0, 1.0, 0.0, 1.0);\n    vec4 cyan    = vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 magenta = vec4(1.0, 0.0, 1.0, 1.0);\n    vec4 white   = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    clear();\n    background(black);\n    fill(red);\n    stroke(green);\n    strokeWeight(2.0);\n    translate(iMouse.x, iMouse.y);\n    \n    circle(0., 0., 50.);\n    rectMode(CENTER);\n    \n    for (int i=0; i<10; i++) {\n        push();\n        rotate(iTime + float(i));\n        translate(100. + sin(iTime * 5. + float(i) * 2.) * 10., 0.);\n        rect(0., 0., 10., 10.);\n        rotate(iTime * 2.);\n        translate(20., 0.);\n        point(0., 0.);\n        pop();\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    p_state.isSmooth = true;\n    p_state.isFill = false;\n    p_state.fill = vec4(0.0);\n    p_state.isStroke = false;\n    p_state.stroke = vec4(0.0);\n    p_state.strokeWeight = 1.0;\n    p_state.smoothness = 1.0;\n    p_state.ellipseMode = CENTER;\n    p_state.rectMode = CORNER;\n    p_state.invMatrix = mat4(1.0);\n    p_state.coord = fragCoord;\n    \n    p_fragCoord = fragCoord;\n    p_states_length = 0;\n    \n    draw();\n    \n    fragColor = p_fragColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}