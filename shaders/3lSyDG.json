{
    "Shader": {
        "info": {
            "date": "1595219145",
            "description": "finally, maybe, cracked the sine SDF problem, in the most ad-hoc way possible",
            "flags": 0,
            "hasliked": 0,
            "id": "3lSyDG",
            "likes": 32,
            "name": "Sine SDF (No Root-Finding)",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "sine",
                "distance",
                "curve",
                "cosine"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 1030
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is a method of computing the distance to a sine function\n//it works by creating a rough estimate for the closest point,\n//then checking if there's a closer point by creating a line\n//segment that is tangent to the curve, and finding the closest\n//point on that segment, becoming the new closest point\n//\n//because this works on the idea of finding the closest point,\n//we can also return that point from the function alongside\n//the distance. unfortunately, the point is a little jittery\n//especially when far from the curve. oh well...\n//\n//other solutions:\n//  iq:      https://www.shadertoy.com/view/3t23WG\n//  fabrice: https://www.shadertoy.com/view/tsXXRM\n\n#define PI 3.141592653\n\nvec2 closest_on_line(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n    float wavelen = PI/freq;\n\n    //map p to be within the principal half cycle\n    float cell = round(p.x/wavelen)*wavelen;\n    float sgn = sign(cos(p.x*freq));\n    p.x = (p.x-cell)*sgn;\n\n\t//sloppy initial estimate to the closest point using a line\n    //inexplicably, setting the height of the line to be proportional\n    //to the point's y position gives a *really* good estimate when \n    //far away from the curve.\n    float correction = max(1.,abs(p.y));\n    vec2 estimateline = vec2(wavelen/2.,correction);\n    vec2 cp = closest_on_line(p, -estimateline, estimateline);\n\n    //any less than 2 iterations looks bad, any more does not improve it\n    for(int i = 0; i < 2; i++) {\n        //refine the closest point by checking if there's a closer point on the tangent line\n    \tcp.y = sin(cp.x*freq);\n        float derivative = freq*cos(cp.x*freq);\n        vec2 localline = vec2(1,derivative)/freq/correction*.25;\n    \tcp = closest_on_line(p, cp-localline, cp+localline);\n        cp.x = clamp(cp.x, -wavelen/2., wavelen/2.);\n    }\n\n    cp.y = sin(cp.x*freq);\n    float dist = length(p-cp)*sign(p.y-sin(p.x*freq));\n\n    //map the closest point back to global coordinates\n    cp.x *= sgn; cp.x += cell;\n    return vec3(dist, cp);\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tfloat scale = 5.;\n    uv*=scale; mouse*=scale;\n    float pixel_size = scale/iResolution.y;\n    \n    float t = sin(iTime)*.5+.5;\n    float freq = mix(20.,.5,sqrt(t));\n\n    vec3 mousedist = sine_SDF(mouse, freq);\n    vec3 col = shadeDistance(sine_SDF(uv, freq).x);\n    if (iMouse.z > 0.) {\n        col *= smoothstep(-pixel_size,pixel_size, distance(mouse, uv) - abs(mousedist.x)) *.5 +.5;\n        col = mix(vec3(.8,.9,.4), col, smoothstep(-pixel_size,pixel_size, distance(mousedist.yz, uv) - .05));\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}