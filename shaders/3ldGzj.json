{
    "Shader": {
        "info": {
            "date": "1576875398",
            "description": "Streaming creative coding stuff daily for the next month at http://twitch.com/wwrighter\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3ldGzj",
            "likes": 9,
            "name": "[Twitch] Day 2 of MDTMJVM",
            "published": 3,
            "tags": [
                "twitch",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*0.8 + right*uv.x + up*uv.y;\n}\n\nfloat r;\n#define dmin(a, b) (a.x < b.x) ? a : b\n\n\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1)/k,0.,1.);\n    return mix(d2, d1, h) - k*h*(1. - h);  \n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1)/k,0.,1.);\n    return mix(d2, -d1, h) + k*h*(1. - h);  \n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCyllinder(vec3 p, float h, float w) {\n    if (abs(p.y) > h) {\n      return 10e3;\n    } else {\n      return length(p.xz) - w;\n    }\n} \n\n\nvec2 wind (vec3 p) {\n  return vec2(sin(p.y + iTime + 2.6*p.x + 2.5*p.z), sin(p.y + iTime + 3.*p.x + 0.4*p.z ));\n}\nvec2 sdPlantCreature(vec3 p) {\n  vec2 d = vec2(10e4, 1);\n\n  p.xz -= wind(p)*0.1;  \n  float creatureHeight = 0.5;\n  \n  vec2 dHead = vec2(sdSphere(p, 0.4), 0.);\n  vec2 dEye = vec2(sdSphere(p + vec3(0,0,0.25), 0.3), 2);\n  vec2 dHeadB = vec2(sdSphere(p - vec3(0,1,0), 0.4), 0.);\n  vec2 dBody = vec2(sdCyllinder(p + vec3(0,creatureHeight,0), creatureHeight, 0.23), 2);\n  vec2 dFeet = vec2(sdSphere(p + vec3(0,creatureHeight*2.2,0), 0.4), 0.);\n  \n  d.x = opSmoothUnion(dBody.x, dHead.x, 0.25);\n  d.x = opSmoothUnion(d.x, dFeet.x, 0.25);\n  d.x = opSmoothSubtraction(dEye.x - 0.02, d.x, 0.04);\n  d = dmin(d, dEye);\n  \n  return d;\n}\n// ids\n// creature 1 2\n\nvec2 sdTentaclePlant(vec3 p) {\n  vec2 d = vec2(10e3);\n  float height = 1.;\n  float width = 0.3;\n  //float dBase = max(length(p.xz) - width, -0.4);\n  \n  if (p.y < 0.) {\n      return vec2(10e3);\n  }\n  \n  \n  float modifier = p.y*0.18 + 0.7;\n  float dBase = length(p.xz)*modifier- 0.2;\n  \n  d.x = min(d.x, dBase);\n  \n  return d;\n}\n\n\n\nvec2 sdTree(vec3 p) {\n  vec2 d = vec2(10e3, 5.);\n  float height = 1.4 + r*4.;\n  float width = 0.6;\n  //float dBase = max(length(p.xz) - width, -0.4);\n  \n  p.xz -= wind(p)*0.1;\n  \n  p.y += 1.7;\n  \n  vec2 uv = vec2(atan(p.x, p.z));\n  \n  //p.x -= wind(p).x*0.1;\n  float dBig = length(p.xz) - width;\n  float dSmall= length(p.xz) - width*0.6;\n  \n  d.x = opSmoothUnion(dSmall,dBig, - 0.4* p.y/height);\n  \n  d.x -= sin(uv.x*10.+ p.y)*0.1 * max(1. - 0.3*p.y/height,0.);\n  \n  \n    \n  if (p.y < 0.) {\n    \n      return vec2(10e3);\n  }\n  return d/1.;\n}\n\nfloat sdGround(vec3 p) {\n  p.y += (sin(p.z) + sin(p.z) + sin(p.x))*0.04;\n  p.y += 1.;\n  p.y -= fbm(p.xz*1.)*0.2;\n  return p.y;\n}\n\n#define dmod(d, x) mod(d, x) - x*0.5\n#define pi acos(-1.)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n\nfloat r21(vec2 p) {return abs(cos(p.x*5562235.61254125 + p.y * 2645125.15425));}\n\nvec2 map(vec3 p) {\n  vec2 d = vec2(10e4);\n  vec2 dGround = vec2(sdGround(p- vec3(0,0,0)),0); \n  d = dmin(d, dGround);\n  \n  float seperation = 7.;\n  vec3 pModded = p;\n  pModded.xz = dmod(p.xz, seperation);\n  \n  vec2 id = floor((p.xz - 0.5)/seperation);\n  r = random(id);\n    vec3 q = p;\n    pModded.xz = mod(q.xz, seperation);\n    pModded.xz -= seperation*0.5;\n    pModded.xz *= rot(pi + r*pi*2. );\n    //pModded.x = -pModded.x;\n  \n  vec3 pPlantCreature = pModded- vec3(-1. ,0,-1.);\n  \n  //p.y += dGround.x;\n  d = dmin(d, sdTree(pModded- vec3(1.2,0,1.)));\n  //d = dmin(d, sdTentaclePlant(pModded- vec3(0,0,-0)));\n  \n  d = dmin(d, sdPlantCreature(pPlantCreature- vec3(0.8,0,0.)));\n  \n  d.x *= 0.45;\n  return d;\n}\n\n\nvec3 getNormal(vec3 p) {\n  vec2 t = vec2(0.001, 0);\n  return normalize(\n  vec3(map(p).x) -\n  vec3(\n    map(p + t.xyy).x,\n    map(p + t.yxy).x,\n    map(p + t.yyx).x\n  ));  \n}\n#define spectra(x) (0.5 + cos(6.3*x + vec3(22,61,30)))\n\nvec3 glow = vec3(0);\nvec4 render(vec2 uv) {\n  vec3 ro = vec3(0. + sin(iTime*0.4)*1.,1.7,0. +iTime*1.);\n  vec3 lookAt = ro + vec3(0. + sin(iTime*0.2)*sin(iTime*0.2)*sin(iTime*0.2)*sin(iTime*0.2)*2.,0. + sin(iTime)*0.2,1. + sin(iTime)*0.1);\n  //lookAt.y = 1.;\n  vec3 rd = getRd(ro, lookAt, uv);\n  vec3 col = vec3(0);\n\n  vec3 p = rd;\n  vec2 t = vec2(0.);\n  \n  for (int i = 0; i < 270; i ++) {\n  \n    vec2 d = map(p);\n\n    glow += spectra(d.x/10. + 16.)*0.002;\n    \n    if (d.y == 2.) {\n      \n      glow *= 1.2 * vec3(1,1.,1.);  \n    }\n    \n    vec3 posLightA = vec3(ro - vec3(0,5,-8));\n    \n    if (d.x < 0.001) {\n      \n      vec3 n = getNormal(p);\n      //vec3 l = normalize(posLightA - p);\n      vec3 l = normalize(vec3(-1,-0.3,1));\n      \n      col += glow;\n      if (d.y == 1.) {  \n        vec3 h = normalize(l + -rd);\n        float diff = max(dot(n, l),0.);\n        float fres = pow(1. -  max(dot(n, l),0.), 15.);\n        float spec = pow(max(dot(h,-rd),0.), 6.);\n        //col += diff;\n        col += fres*3.;\n        col *= glow;\n        col *= vec3(0.5,0.1,4.4);\n      }\n      \n      if (d.y == 0.) {\n        n.xy += fbm(p.xz*8.)*0.3;\n        //n.xz += sin(p.xz*100.)*0.03;\n        vec3 h = normalize(l + -rd);\n        float diff = max(dot(n, l),0.);\n        float fres = pow(1. -  max(dot(n, l),0.), 5.);\n        float spec = pow(max(dot(h,-rd),0.), 6.);\n        //col += diff;\n        //col += fres * diff;\n          col += diff;\n        col *= glow;\n        //col += 1.;\n        \n      }\n      if (d.y == 5.) {\n        col.b = col. r;\n        col *= vec3(0.5,0.9,0.05);\n          //col += 1;\n      }\n      //col += spec;\n      //col = n;\n      //col = vec3(1);\n      break;;\n    }\n    if (d.x > 1000.) {\n      col = vec3(0);\n      break;\n    }\n    \n    t.y = d.y;\n    t.x += d.x;\n    p = ro + rd*t.x;\n  }\n  \n  vec3 fog = smoothstep(0.,1.,pow(t.x*0.03, 1.9)) * vec3(0.8,0.5,2.) * 1.;\n  col += fog;\n  col = mix(col, fog, pow(fog.y*2., 10.));\n  \n  col *= 0.5;\n  col = pow(col, vec3(0.44));\n\n  return vec4(col, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    col.g *= 0.55;\n    col.b *= 0.3;\n    col *= 1.6;\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(in vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 2; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}