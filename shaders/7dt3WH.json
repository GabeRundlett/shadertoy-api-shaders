{
    "Shader": {
        "info": {
            "date": "1629804106",
            "description": "Hannibal Lecter's cell from the 'Silence of the Lambs' movie.",
            "flags": 1,
            "hasliked": 0,
            "id": "7dt3WH",
            "likes": 34,
            "name": "Silence of the Lambs",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "voronoi",
                "rock",
                "dungeon",
                "horror",
                "movie",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 7052
        },
        "renderpass": [
            {
                "code": "// 'Silence of the Lambs' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/7dt3WH (YouTube: https://youtu.be/DkaaJbfpNxE)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Hannibal Lecter's cell from the 'Silence of the Lambs' movie.\n// I wish my GPU has enough power to render some posters and drawings\n// on the cell wall! Probably quite doable if I used multiple buffers,\n// but I always try to make my code single-buffer with no predefined\n// textures.\n//\n// Tricks to ('try and'!) get the performance:\n// - The stone walls are flat planes, and the material is bump-mapped.\n//   Adding texture by adjusting the SDF would look nice, but increase\n//   the number of steps in the march loop.\n//   (I use dFdx and dFdy to approximate the normal of the texture.)\n// - The material code (lights()) is called _outside_ the raymarch loop\n//   to keep the loop code minimal (should the compiler decide to unroll it).\n// - The glass is a flat plane, so the normal passed into 'reflect()'\n//   can be hard-coded.\n// - The FBM noise function is only called once in lights(), and then used\n//   by several materials.\n// - Lots of use of abs() to mirror along axis.\n//   (There's only one 'actual' prison cell - The other is mirrored.)\n// - Use of fract() on the x-axis to repeat the holes in the glass.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle, totetmatt, byt3_m3chanic, and a bunch of others for sharing\n// their time and knowledge! If you want to get into shader coding, I'd\n// recommend giving them a 'Google'.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define LIGHT_RGB\tvec3(4.9, 3.9, 3.5)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define NM normalize\n#define minH(a, b)\t{ float u = a; if (u < h.x) h = vec2(u, b); }\n\nfloat g = 0.;\n\nvec2 h22(vec2 v) {\n\tvec3 p = fract(v.xyx * vec3(.1031, .103, .0973));\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.xx + p.yz) * p.zy);\n}\n\nvec4 h44(vec4 p) { p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p)); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat min3(vec3 v) { return min(v.x, min(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = NM(lookAt - ro),\n\t     r = NM(cross(vec3(0, 1, 0), f));\n\treturn NM(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec4 brkT(vec3 p) {\n\tfloat n = n31(p * 7.),\n\t      s = step(.4, dot(vec3(n31(p), n, n31(p * 15.)), vec3(.75, .15, .1)));\n\tp.y -= .03;\n\tp.x -= step(fract(p.y * 1.87 - .05), .5) * 2.6;\n\tp.z -= .33;\n\tvec3 c = vec3(.2, .03, .01);\n\tc *= .2 + n * n * .5;\n\treturn vec4(mix(vec3(.2), c, sat(S(0., .02, min3(abs(fract(p * vec3(1, 3.74, 2.23)) - .1))) - s)), (s + n) * .01);\n}\n\nvec2 proj(vec3 p, vec3 n) {\n\tn = abs(n);\n\tfloat m = max3(n);\n\treturn n.x == m ? p.zy : n.y == m ? p.xz : p.xy;\n}\n\nfloat vor(vec2 p) {\n\tvec2 o,\n\t     g = floor(p);\n\tp -= g;\n\tvec3 d = vec3(2);\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\to = vec2(x, y);\n\t\t\to += h22(g + o) * vec2(.5, .7) - p;\n\t\t\td.z = dot(o, o);\n\t\t\td.y = max(d.x, min(d.y, d.z));\n\t\t\td.x = min(d.x, d.z);\n\t\t}\n\t}\n\n\treturn d.y - d.x;\n}\n\nvec2 map(vec3 p, bool addGlass) {\n\tfloat f, e, l,\n\t      d = 1e7;\n\tvec2 h;\n\th.x = 1e7;\n\tvec3 pp,\n\t     cp = p,\n\t     op = p;\n\tif (addGlass) {\n        minH(max(abs(p.z - 3.2), abs(p.x) - 4.), 11);\n\t} else {\n\t\tp.x = fract(p.x * 1.74) / 1.74 - .25;\n\t\tp.y = abs(p.y + .7) - 1.5;\n\t\tp.z -= 3.4;\n\t\tminH(max(abs(length(p.xy) - .06) - .0015, abs(p.z) - .03), 9);\n\t}\n\n\tp = cp;\n\tp.y += 3.5;\n\tp = p.zyx;\n\tp.xz *= rot(.2);\n\tminH(max(max(cap(p, 1., .45), abs(p.y) - .05), -p.x), 8);\n\tp.x -= .15;\n\tp.z = abs(p.z) - .5;\n\tp.xy *= rot(-.1);\n\td = max(length(p.xz) - .04, p.y - .5);\n\tp.xy *= rot(.6);\n\tp.x -= .3;\n\tminH(smin(d, max(length(p.xz) - .04, p.y - .8), .04), 3);\n\tp.z = cp.x - .03;\n\tp.xy = p.yx;\n\tminH(max(max(cap(p, .6, .45), abs(p.y) - .04), .3 - p.x), 8);\n\tp = cp;\n\tp -= vec3(9, -4.7, 5);\n\tmat2 r = rot(.36);\n\tfor (f = 0.; f < 5.; f++) {\n\t\tminH(max(box(p, vec3(2, .3, 10)), p.z - .5), 1);\n\t\td = smin(d, abs(-8.1 - p.z), 2.);\n\t\tp.xz *= r;\n\t\tp.y -= .6;\n\t}\n\n\tminH(d, 1);\n\tp = cp;\n\tp.y++;\n\td = min(box(p, vec3(90, 4, 3)), 8. - p.x);\n\tp.x = abs(p.x + 8.) - 8.;\n\tp.z -= 7.;\n\tcp = p;\n\td = -min(d, box(p, vec3(4, 4, 4.1)));\n\tminH(d, 1);\n\td = length(p - vec3(0, 4, 0)) - .2;\n\tg += .005 / (.01 + d * d);\n\tminH(d, 12);\n\tp += vec3(-2.48, 1.8, 2.4);\n\te = box(p, vec3(1.4, .02, .5));\n\tp.x = abs(p.x) - .8;\n\td = max(box(p, vec3(.05, 5, .05)), p.y);\n\tp = cp - vec3(0, .8, 3.95);\n\tminH(box(p, vec3(.5, .7, .01)), 10);\n\tminH(box(p, vec3(.6, .8, .01)), 8);\n\tp.y += 2.;\n\tl = length(p) - .8;\n\tf = min(max(max(min(min(l + .05, max(l, abs(p.x) - .2)), max(l, abs(p.y) - .1)), p.y - .1), -l - .1), max(box(p, vec3(.65, .8, .1)), -p.y - .2));\n\tminH(f, 4);\n\tp.x = abs(p.x) - .3;\n\tp.y -= .35;\n\td = min(d, length(p) - .1);\n\tp = cp + vec3(-2.48, 2.5, 1.2);\n\te = min(e, box(p, vec3(1.4, .02, .3)));\n\tp.x = abs(p.x) - .8;\n\td = min(d, max(box(p, vec3(.05, 5, .05)), p.y));\n\te -= .03;\n\tp = cp + vec3(3.7, -.5, -2);\n\te = min(e, box(p, vec3(.3, .05, 1)));\n\tp.y -= .48;\n\tp.z = abs(abs(p.z - .4) - .3) - .15;\n\tminH(box(p, vec3(.2, .4, .05)) - .03, 5);\n\tminH(d - .04, 3);\n\tminH(e, 8);\n\tp = cp;\n\tp.x += 2.8;\n\tp.y += 2.4;\n\tminH(box(p, vec3(.94, .08, 2.9)) - .1, 7);\n\tp.y += .23;\n\td = box(p, vec3(1.02, .08, 3.05));\n\tp.y += .7;\n\tp.z = abs(p.z) - 3.;\n\td = min(d, box(p, vec3(1.02, .78, .08)));\n\tp = cp;\n\tp.x = abs(abs(p.x) - 2.1) - .75;\n\tp.z += 3.8;\n\td = min(d, box(p, vec3(.1, 4, .1)));\n\tpp = p;\n\tp.y = fract(p.y) - .5;\n\tp.z += .12;\n\td = min(d, length(p) - .01);\n\tp = pp;\n\tminH(d - .04, 3);\n\td = box(cp - vec3(0, 3.5, -3.8), vec3(4, .5, .5));\n\tp.x = abs(cp.x) - 3.5;\n\tp.z = abs(p.z + 3.175) - 3.175;\n\td = min(d, box(p, vec3(.5, 4, .5)));\n\td -= brkT(op).a;\n\tminH(d, 2);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, false).x;\n\t}\n\n\treturn NM(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = (lp - p) / mxt;\n\tfor (float i = Z0; i < 2e2; i++) {\n\t\td = map(t * ld + p, false).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p, true).x / h; }\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tvec4 t;\n\tfloat spe = 1.,\n\t      gg = g,\n\t      f = h.y <= 6. ? fbm(p * 7.5) : 0.;\n\tvec3 c,\n\t     ld = NM(vec3(0, 2.8, 7) - p),\n\t     n = N(p, d);\n\tif (h.y == 1.) {\n\t\tvec2 uv = proj(p, n) * vec2(1, 2);\n\t\tfloat d = S(0., .15, vor(uv) * f);\n\t\tn.xy += vec2(dFdx(d), -dFdy(d)) * 1.5;\n\t\tn = NM(n);\n\t\td += f;\n\t\tc = mix(vec3(.15, .09, .06), vec3(.04, .03, .04) + S(.4, 1., S(.6, .5, d + f) * n31(p)) * vec3(.054, .06, .04), S01(d + .4));\n\t\tspe = .3;\n\t}\n\telse if (h.y == 2.) {\n\t\tt = brkT(p);\n\t\tc = t.rgb;\n\t\tn.xy += f;\n\t\tn = NM(n);\n\t\tspe = .1;\n\t}\n\telse if (h.y == 7.) c = vec3(.01, .013, .01);\n\telse if (h.y == 10.) {\n\t\tc = vec3(.02);\n\t\tspe = 15.;\n\t}\n\telse if (h.y == 3.) c = mix(vec3(.15, .05, .01), vec3(.16, .2, .24) * (.2 + .8 * f), S(0., .15, f));\n\telse if (h.y == 8.) c = mix(vec3(.04, .02, .02), vec3(.06, .04, .02), S01(n31(p * vec3(2.3, 1, 20))));\n\telse if (h.y == 5.) c = vec3(.12, .11, 0) - f * .2;\n\telse if (h.y == 4.) c = vec3(.4, .4, .38) - f * .4;\n\telse if (h.y == 9.) c = vec3(.9);\n\telse return LIGHT_RGB;\n\n\tfloat ao = sat(mix(ao(p, n, .2), ao(p, n, 2.), .7)),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.05 + .95 * shadow(p, vec3(0, 2.8, 7))) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(rd, reflect(ld, n))), 10.) * spe;\n\tg = gg;\n\treturn (l1 + l2 * ao) * c * LIGHT_RGB;\n}\n\nbool hitGlass;\nvec3 ghit;\nvec3 march(inout vec3 p, vec3 rd, float s) {\n\tfloat i,\n\t      d = .01;\n\tg = 0.;\n\tvec2 h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p, !hitGlass);\n\t\tif (abs(h.x) < .0015) {\n\t\t\tif (h.y == 11.) {\n\t\t\t\thitGlass = true;\n\t\t\t\tghit = p;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\td += h.x;\n\t\tp += h.x * rd;\n\t}\n\n\treturn g * LIGHT_RGB + lights(p, rd, d, h);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\thitGlass = false;\n\tvec3 p = ro,\n\t     col = march(p, rd, 120.) * exp(dot(p - ro, p - ro) * -.001);\n\tif (hitGlass) {\n\t\trd = reflect(rd, vec3(0, 0, -1));\n\t\tp = ghit;\n\t\tcol += .01 + .99 * sat(march(p, rd, 64.));\n\t}\n\n\treturn col;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(iTime), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(ro, rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime, 25.),\n\t      f = S(0., 18., t);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     q = fc.xy / R.xy;\n\tvec3 ro = vec3(-23. + 22.5 * f, 0, 0),\n\t     col = scene(ro, rayDir(ro, vec3(0, mix(-1. - sat(t), 0., S(16., 20., t)), -sin(S01(f) * 5.7) * 5.), uv));\n\tcol *= .2 + .4 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}