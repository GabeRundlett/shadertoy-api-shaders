{
    "Shader": {
        "info": {
            "date": "1547511890",
            "description": "Had fun using Mercury lib to mirror space many time to create a quite complicated scene. \n1rst anim : drawn trip (thanks to HLorenzi)\n2nd: textured scene trip (thanks to Shane)",
            "flags": 32,
            "hasliked": 0,
            "id": "tdX3D2",
            "likes": 88,
            "name": "Carcassonne_",
            "published": 3,
            "tags": [
                "cartoon",
                "pencil",
                "castle",
                "ink",
                "drawing",
                "mercury",
                "pastel"
            ],
            "usePreview": 1,
            "username": "iapafoto",
            "viewed": 2262
        },
        "renderpass": [
            {
                "code": "// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n\n// [Dave_Hoskins] Rolling hills - https://www.shadertoy.com/view/Xsf3zX\n// [Shane] Voxel Corridor - https://www.shadertoy.com/view/MdVSDh\n// [HLorenzi] Hand-drawn Sketch  - https://www.shadertoy.com/view/MsSGD1\n// [Mercury] Lib - http://mercury.sexy/hg_sdf for updates\n// [dr2] White Folly - https://www.shadertoy.com/view/ll2cDG\n\n// Buf A: Calculate distance to scene\n// Buf B: Calculate ao and shadows\n// Buf C: Textures and light\n// Image: DOF post processing\n\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float aperture = 3.;\n\nconst float cosAngle = cos(radians(aperture/2.));\nconst float GA =2.399;  // golden angle = 2pi/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n    \n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.08, (2./iResolution.y) * (1.+t));\n}\n\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * iRes.x/iRes.y,  (2.* q.y - 1.), 3.));\n}\n\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n    const float amount = 1.;\n\tvec4 colMain = texture(tex, uv);\n    \n    fdist = min(30., fdist);\n    float rad = min(.3, coc(abs(colMain.w-fdist)));//.3; // TODO calculate this for Max distance on picture\n    float r=2.;\n    \n    vec3 cn = RD(uv),    // Cone axis    \n         co = cn*fdist,  // Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    vec2 pixScreen,\n         pixel = 1./iResolution.xy,        \n         angle = vec2(0, rad);\n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<60;j++) {  \n        r += 1./r;\n\t    angle *= rot;\n        pixScreen = uv + pixel*(r-1.)*angle; // Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    // Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   // Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        // true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n \treturn (!isInCone) ? colMain.xyz : // Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz/sum;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\n    iRes = iResolution.xy;\n\tfCoord = fragCoord;\n\ttime = iTime+100.*iMouse.x/iResolution.x;\n\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec3 c;\n\n    if (isDrawing()) {\n        c = texture(iChannel0,uv).rgb;\n    } else {\n        float fdist = texture(iChannel0,vec2(0.,-.4)).w;//length(ro);//; 64.;\n        c = dof(iChannel0,uv,fdist); \n    }\n    c *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .3); // Vigneting\n\n    fragColor = vec4(c,1.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0,uv);\n    c *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .25); // Vigneting\n\tfragColor = c; //*.01; \n}\n\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n\n// [Dave_Hoskins] Rolling hills - https://www.shadertoy.com/view/Xsf3zX\n// [Shane] Voxel Corridor - https://www.shadertoy.com/view/MdVSDh\n// [HLorenzi] Hand-drawn Sketch  - https://www.shadertoy.com/view/MsSGD1\n// [Mercury] Lib - http://mercury.sexy/hg_sdf for updates\n// [dr2] White Folly - https://www.shadertoy.com/view/ll2cDG\n\n\n\n\n//#define ALTERNATE_MODE\n\n\n#define EDGE_WIDTH 5e-3\n#define NB_ITER 100\n#define MAX_DIST 90.\n#define PRECISION 2e-4\n#define PI 3.14159265\n#define TAO 6.28318530718\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define SQRT2 1.41421356237 // sqrt(2.)\n#define _SQRT2 .70710678118\n\n\n\n\nvec3 sunLight = normalize(vec3(15,25,10));\nvec2 iRes;\nvec2 fCoord;\nfloat time;\n\n\n\n// -- START OF MERCURY LIB -----------------------------------\n// !!! Be careful, this is an adaptation !!!\n// for true lib, go to http://mercury.sexy/hg_sdf\n// -----------------------------------------------------------\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Cheap Box: distance to corners is overestimated\n#define fBoxCheap( p,  b) vmax(abs(p)-(b))\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * .75* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\treturn max(length(p.xz) - r, abs(p.y) - height);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nvoid pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = TAO/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*.5;\n\ta = mod(a,angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\n// Repeat in two dimensions\nvoid pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvoid pMirrorOctant (inout vec2 p, vec2 dist) {\n    p = abs(p)-dist;\n\tp.xy = p.y>p.x ? p.yx : p.xy;\n}\n\n// Reflect space at a plane\nvoid pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tp -= step(0.,-t)*2.*t*planeNormal;\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif (a < r && b < r) {\n\t\tvec2 p = vec2(a, b);\n//\t\tfloat columnradius = r*SQRT2/n/2.0;\n//\t\tcolumnradius = r*SQRT2/((n-1.)*2.+SQRT2);\n\t\tfloat columnradius = r*SQRT2/((n-1.)*2.+SQRT2);\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= SQRT2/2.*r;\n\t\tp.x += -columnradius*SQRT2*.5;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\n// -- END OF MERCURY STUFF ---------------------------------------------\n\n\n\n\n// -- Distance functions -----------------------------------------------\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n, u = b-r;\n\treturn min(min(a,b), .5 * (u + a + abs (mod (u - a + s, 2. * s) - s)));\n}\n\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float rout, in float rin) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    float d = length(pa-ba*h);  \n    return max(rout-d, d-rin);\n}\n\n// iq: https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec2 c) {\n    // c must be normalized\n    return dot(c,vec2(length(p.zx),p.y));\n}\n\nfloat sdTorus82(in vec3 p, float r, vec2 sz) {\n\treturn max(abs(length(p.xz) - r)-sz.x, abs(p.y) - sz.y);\n}\n\nfloat sdWindow(vec2 p) {\n    p.x = abs(p.x)+.05; // gothique\n    return min(length(p.xy)-.1, max(p.x-.1, abs(p.y+.07)-.05));\n}\n\nfloat sdWall(vec3 p, float h, float s) {\n    float d = max(p.y-h, abs(p.z) -.05);  // Mur droit\n    p.x = mod(p.x+.4,.8) -.4;\n    return -fOpUnionStairs(s*sdWindow((p.xy - vec2(0., h*.8))/s), -d, .05, 2.);\n}\n\nfloat sdHouse(vec3 p0) {\n    const float h = .7;\n    vec3 p = p0;\n    p.z += 1.3;\n    p.x -= .4;\n    p.z = abs(p.z);\n    pReflect(p, vec3(-_SQRT2,0,_SQRT2),.0);\n    pReflect(p, vec3(_SQRT2,0,_SQRT2),.6);\n\n    vec3 p2 = p;\n    \n    p.y -= h+.58;\n    float d = max( abs(p.z+.38)*.6+p.y*.5, -(p.y-.2)) -.5;  // toit\n#ifdef MAP_FULL\n    d = max(d, -(   max(abs(p.z+.35)*.6+(p.y+.02)*.5,-(p.y+.02)) -.5   ) );  // toit\n#endif\n    p.y += h+.58;\n\t\n    pR(p2.zy, .1);\n    d = min(d, max(max(p2.z-.7, .5-p.z), p.y-h*1.5));  // Mur droit\n    d = max(d, -fBoxCheap(p0-vec3(-.5,.4,-.5), vec3(.18,.45,.2))); // ouverture porte\n#ifdef MAP_FULL\n    d = min(d, fBoxCheap(p0-vec3(-.5,.4,-.65), vec3(.18,.44,.02))); // porte\n#endif    \n    p.x = mod(p.x+1.,2.) -1.;\n    d = max(d, -fBoxCheap(p.xy-vec2(0,h+.03), vec2(.17,.15)));  // fenetres\n    return d;\n}\n\n\nfloat sdLineCreneaux(vec3 p) {\n    float d =  max(abs(p.z)-.025, abs(p.y+.13)-.26); // mur du creneau\n    d = min(d, max(abs(p.z+.15)-.15, abs(p.y+.11)-.05)); // chemin de ronde\n    p.x = mod(p.x+.1, .2)-.1;\n    d = min(d, length(p.zy-vec2(.025,-.11))-.01); // petit cylindre decoratif\n    vec3 p1 = p.zyx;\n    pR45(p.yz);\n\td = max(d, p.z-.18); // champfrein\t\n\treturn max(d, \n        -min(fBoxCheap(p1.yz-vec2(-.25,0.), vec2(.05,.07)), // fentes du bas\n        \t fBoxCheap(p1.yz-vec2(.08,0.), vec2(.1,.03)))); // fente dans les meurtrieres\n}\n\n\nfloat sdRoundCreneaux(vec3 p, float r) {\n\tfloat height = 2.6;\n    \n    float dc = length(p.xz)-r;\n    float d = min(max(p.y-.1, max(dc, -dc-.05)),\n                  max(p.y+.1, max(dc, -dc-.3)));\n    d = max(d, sdCone(vec3(p.x,-r-.2-p.y,p.z), normalize(vec2(1.))));\n\t\n    pModPolar(p.xz, r*90./3.);\n    d = max(d, \n        -min(fBoxCheap(p.yz-vec2(-.25,0.), vec2(.05,.07)), // fentes du bas\n        \t fBoxCheap(p.yz-vec2(.08,0.), vec2(.1,.03)))); // fente dans les meurtrieres\n\n    d = max(-p.y-.29,d);\n    \n    return min(d, fTorus(p+vec3(0,.11,0), .01,r)); \n}\n\n\n// [dr2] White Folly - https://www.shadertoy.com/view/ll2cDG\nfloat sdCircleStairs (vec3 q) {\n  float a = length (q.xz) > 0. ? atan (q.z,- q.x) / TAO : 0.;\n  q.xz = vec2(24.* a, length(q.xz) - 6.);\n  pR45(q.xy);\n  float s = mod(q.x, sqrt(.5));\n  return max (q.y - min(s, sqrt(.5) - s), abs(q.z-3.)-6.);\n}\n\n\nfloat sdStairs(vec3 q0) {\n  q0.x *= 1.3;\n  const float k = .04;\n  vec3 q = q0;\n  pR45(q.yx);\n  float s = mod(q.x, k*sqrt (2.));\n  return .5*min(fBoxCheap(q0-vec3(-1.4,1.2,0.),vec3(.2,.05,.1)),max(q0.y-1.2,max(max(q.y - min(s, k*sqrt (2.)-s), abs(q.z)-.1), -k - q.y)));\n}\n\n\nvoid malaxSpace(inout vec3 p0) {\n    pReflect(p0, normalize(vec3(.8,0,.8)),2.0);\n//    pReflect(p0, normalize(vec3(.3,0,.8)),2.0);\n/*\n  //  pReflect(p0, normalize(vec3(-.6,0,1.02)),3.5);\n    pReflect(p0.zyx, normalize(vec3(-.05,0,1.)),.75);\n    pReflect(p0, normalize(vec3(-.35,0,.15)),2.);\n    pReflect(p0.zyx, normalize(vec3(-.4,0,.9)),3.7);\n  */\n       // pR45(p0.xz);\n   // p0.x += 2.*cos(iTime);\n  //  pMirrorOctant(p0.xz,vec2(0.,10.));\n}\n\n// Standard Ray-Marching stuff --------------------------------------------\n// [Dave_Hoskins] Hash without Sine - https://www.shadertoy.com/view/4djSRW\n//--------------------------------------------------------------------------\n#define MOD2 vec2(3.07965, 7.4235)\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 1019.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 1019.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 1019.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat HashT( float p ) {\n\tvec2 p2 = fract(vec2(p) / MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n//--------------------------------------------------------------------------\n// [Dave_Hoskins] Rolling hills - https://www.shadertoy.com/view/Xsf3zX\n//--------------------------------------------------------------------------\n\nfloat NoiseT( in vec2 x ) {\n    vec2 p = floor(x), f = fract(x);\n    f = f*f*(3.-2.*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( HashT(n     ), HashT(n+  1.),f.x),\n               mix( HashT(n+ 57.), HashT(n+ 58.),f.x),f.y);\n}\n\nfloat Terrain( in vec2 p) {\n\tfloat w = 50., f = .0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tf += NoiseT(p)* w;\n\t\tw *= .62;\n\t\tp *= 2.5;\n\t}\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\n\n\nfloat map(vec3 p0) { \n    \n\tfloat d= 999.;\n    float h = Terrain(p0.xz*.3);\n        \n    malaxSpace(p0);\n \td = p0.y - h*mix(.002,.04, smoothstep(.1,3.,sign(p0.z)*abs(p0.x))*smoothstep(10.,MAX_DIST,length(p0.xz)));\n    \n    vec3 p = p0;\n    float dc = length(p.xz-vec2(0,2));\n    \n \t// Rempart\n    d = min(d, max(-min(.8-p.y, dc-6.-.3),sdCone(p-vec3(0,6.*8.4,2.), normalize(vec2(1.,.13)))));   \n\td = min(d, sdRoundCreneaux(p-vec3(0,.9,2.), 6.55));\n    d = min(d, sdStairs(p-vec3(1.2,-.45,8.2))); // Escaliers \n    \n    vec3 p1 = p-vec3(0,0,2);\n    pMirrorOctant(p1.xz, vec2(3.9)); // pour faire 4 tours d'un coups\n    \n    p.x = abs(p.x);\n    d = min(d, max(-1.1+p1.y, sdCone(p1 - vec3(2.4,5.,-2.4), normalize(vec2(1.,.1))))); // Tour rampart\n    d = max(d, -sdTorus82(p-vec3(0,.91,2.), 6.375, vec2(.08, .15))); // Porte tour rampart\n    d = min(d, sdRoundCreneaux(p1-vec3(2.4,1.3,-2.4), .5));\n\n    p.z += .05;\n  \n    vec3 p2 = p, ph = p;\n\n    // Chemin de ronde\n    p.z -= .1;\n    pReflect(p, normalize(vec3(-1.,0,1.)),1.7);\n    pReflect(p, normalize(vec3( 1.,0,1.)),1.2);\n\n    p1 = p;\n    p1.x = abs(p1.x); // Pour doubler les tours\n    p1 -= vec3(1.2,0.,0.);\n\n    // Tour du chemin de ronde\n    d = min(d, max(-1.7+p1.y, sdCone(p1 - vec3(0,7.,0.), normalize(vec2(1.,.05)))));\n    d = min(d, sdRoundCreneaux(p1-vec3(0,1.9,0), .35));\n    d = min(d, sdWall(p-vec3(.5,0.,-.07), 1.1,1.));  // Mur droit\n    d = min(d, sdLineCreneaux(p-vec3(0.,1.3,.0)));\n\n    // Donjon\n    d = min(d, sdHouse((vec3(p.x-.2,p.y,p.z+1.2)).zyx*1.6)/1.6);\n    d = min(d, sdWall(p-vec3(.0,0.,-1.28),2.,1.));\n    \n    // Tour du donjon\n    float d2 = sdLineCreneaux(p-vec3(0.,2.2,-1.2));\n    d2 = min(d2, sdCapsule(p, vec3(.28,1.9,-1.3), vec3(.28,2.7,-1.3), .09, .17));\n\n#ifdef FULL_MAP    \n    d = fOpUnionStairs(d, d2, .04, 3.);\n#else\n    d = min(d, d2);\n#endif\n    d = min(d, max(-p.y+2.7,\n                   min(sdCone((p-vec3(.28,3.3,-1.3)), vec2(1.,.4)),\n                       sdCone((p-vec3(.28,3.6,-1.3)), vec2(1.,.22)))));\n \tfloat dWin = sdWindow(p.xy-vec2(.28,2.45));\n  \n\td = -fOpUnionStairs(dWin,-d, .05,2.);\n\n    ph.z -= .5;\n\tpR45(ph.zx);\n    ph.z -= 4.6;\n    ph.x += 1.;\n \n    pReflect(ph, normalize(vec3(-1.,0,.7)),1.);\n    \n    d = min(d, fBlob((ph-vec3(0,1.,0))*4.)/4.); // arbre feuilles\n    d = min(d, max(ph.y-1.,length(ph.xz)-.04)); // arbre tronc\n\n    pMirrorOctant(ph.xz, vec2(1.5,1.6));\n\n    // Petites maisons\n    d = min(d, sdHouse((vec3(ph.x-.2,ph.y,ph.z+.6))*3.)/3.);\n#ifdef FULL_MAP  \n    d = min(d, fBoxCheap(ph-vec3(.15,0.,-.95), vec3(.05,.9,.05)));  // cheminee\n#endif  \n    \n    d = min(d, sdStairs(p2-vec3(1.2,-.01,-.285)));    // escaliers\n\n   // r = length(p0.yz-vec2(.4,-2.2));\n   // d = min(d, max(abs(p0.x)-.2, r-.04)); \n    \n    // Grande porte\n    p0.x = abs(p0.x)+.1; // gothique    \n \n    float dDoor = min(fCylinder(p0.xzy-vec3(0.,3.5,0.5),.2,6.), fBoxCheap(p0-vec3(0.,.35,3.5), vec3(.2,.18,6.)));\n\n\td = max(-fBoxCheap(p-vec3(1.5,1.35,-.15), vec3(3.5,.15,.07)), d); // Porte chemin de ronde\n    d = fOpUnionStairs(d, fBoxCheap(p0-vec3(0,.18,-1.35),vec3(.4,.6,.1)),.1,5.);\n    d = -fOpUnionStairs(-d, fBoxCheap(p0-vec3(0,.18,-1.1),vec3(.37,.57,.1)),.02,2.);\n    d = fOpDifferenceColumns(d, dDoor, .03,3.);\n    d = min(d, fBoxCheap(p0-vec3(0,.185,-1.2),vec3(.38,.05,.1)));\n    d = min(d,.025*sdCircleStairs(40.*(vec3(.45-p0.x,p0.y+.09,p0.z+1.1)))); // escalier circulaires de l'entree\n\td = min(d, fBoxCheap(vec3(p.x,abs(p.y-1.15)-.95,p.z+1.8), vec3(10.5,.02,0.5)));\n\n    // Puit\n    float r = length(p0.xz-vec2(3.,3.1));\n    d = min(d, max(p0.y-.3, r-.2)); \n\td = max(d, .14-r);\n\n    return d;\n}\n\n\n\nvec3 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\tfloat d = MAX_DIST;\n\tfloat lastt, t = PRECISION*10.0;\n    \n\t// edge detection\n    float lastDistEval = 1e10;\n\tfloat edge = 0.0;\n    float iter = 0.;\n    //float dmin = MAX_DIST; // min sur le chemin (ne compte pas l'intersection)\n    \n    for( int i=0; i<NB_ITER; i++ ) {\n\t\tif (d<PRECISION || t>maxd) break;\n        \n\t\td = map(ro+rd*t);       \n        if (d < lastDistEval) {\n            lastt = t;\n            lastDistEval = d;\n        } else if (d > lastDistEval + 0.00001 && lastDistEval/lastt < EDGE_WIDTH) {\n\t\t\tedge = 1.0;\n\t\t}\n\t\tt += d;// + t*1e-3;\n       // iter++;\n\t}\n\treturn vec3(t, edge, iter);\n}\n\n\n// -- Calculate normals -------------------------------------\n\nvec3 calcNormal(in vec3 pos, in vec3 ray, in float t) {\n\n\tfloat pitch = .2 * t / iRes.x;\n\tpitch = max( pitch, .002 );\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, p1 = pos+d.xyy, p2 = pos+d.yxy, p3 = pos+d.yyx;\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2), f3 = map(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0, dot (grad,ray))*ray);\n}\n\n\n\n\n// - Camera -------------------\n\n#define NB 16\nfloat[] \n    camx = float[] ( 0.,   0.,  0.,  3., 8. ,  8.,  0.,  .6,  -3.6,     1.,   1.,   3.3, .1,   0., -1.25, -2.2,-15.),\n\tcamy = float[] ( 0.3,  0.3,7.3, 7.3, 6.3, 7.3,  .4,  .3,  .6,     1.05, 20.55,   2.,  .5, .2, .35, .37, .37),\n\tcamz = float[] ( 40.,  6.,  4., -3., -8., -6., -.4,  4.,  5.3,     8.2,  8.75,  0.,  1.2, -.03, -.65, -2.9, -2.9),\n//                    0    1   2    3    4     5    6    7     8        9     10    11    12   13  14   15   16\n    lookx = float[] ( 0.,  0.,  0., -2., -2., -6.,  0.,  -2., -2.,     -4.2, -.35,  0., .08, -.0, -3., -5., -20.),\n\tlooky = float[] ( 7.2, 1.,  2.,  0.,  0.,  0.,  .4,  .6,  .6,      1.15,  1.4,  1., .6,  .4,  .3,  .35, .35),\n\tlookz = float[] ( 0.,  0., -2.,  5., -2.,  -1.,  5.,  3.6, 1.5,     7.5,  .05,   -1.,-.87, -.87,-2., -3., -3.);\n\n    \nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 uv, vec2 res) {\n    return LookAt(cp-ro, vec3(0,1,0))*normalize(vec3((2.*uv-res.xy)/res.y, 3.5));\n}\n\nbool isDrawing() {  \n#ifdef ALTERNATE_MODE    \n\treturn (.2*time) < 16. && sin(time)>0.;\n#else\n    return !((.16*time) < 16.);\n#endif    \n}\n\nvoid getCam(in vec2 uv, in vec2 res, in float time, out vec3 ro, out vec3 rd) {\n       \n\tvec2 q = uv/res;\n    \n    float t = .16* time,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    // - Interpolate positions and fractal configuration ---------------------\n    int  i0 = int(t)%NB, i1 = i0+1;\n    \n    vec3 cp = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt); \n  \n    ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n    ro += vec3(.01*cos(2.*time), .01*cos(time),0.);\n    rd = RD(ro, cp, uv, res);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n\n// [Dave_Hoskins] Rolling hills - https://www.shadertoy.com/view/Xsf3zX\n// [Shane] Voxel Corridor - https://www.shadertoy.com/view/MdVSDh\n// [HLorenzi] Hand-drawn Sketch  - https://www.shadertoy.com/view/MsSGD1\n// [Mercury] Lib - http://mercury.sexy/hg_sdf for updates\n// [dr2] White Folly - https://www.shadertoy.com/view/ll2cDG\n\n\n// Calculate distance to scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    iRes = iResolution.xy;\n\tfCoord = fragCoord;\n\ttime = iTime+100.*iMouse.x/iResolution.x;\n\t\n    vec3 ro, rd;\n    getCam(fragCoord.xy, iResolution.xy, time, ro, rd);\n    \n    vec3 res = castRay(ro,rd, MAX_DIST);\n    // distance, edge (0/1), iter\n    fragColor = vec4(res.xyz,0.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n\n// [Dave_Hoskins] Rolling hills - https://www.shadertoy.com/view/Xsf3zX\n// [Shane] Voxel Corridor - https://www.shadertoy.com/view/MdVSDh\n// [HLorenzi] Hand-drawn Sketch  - https://www.shadertoy.com/view/MsSGD1\n// [Mercury] Lib - http://mercury.sexy/hg_sdf for updates\n// [dr2] White Folly - https://www.shadertoy.com/view/ll2cDG\n\n\n// Calculate Shadows and AO\n\nfloat SoftShadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0, h, t = .005+hash13(ro)*.02;\n    float dt = .01;\n    for( int i=0; i<32; i++ ) {\n\t\th = map( ro + rd*t );\n\t\tres = min( res, 10.*h/t );\n\t\tt += dt;\n        dt+=.0025;\n        if (h<PRECISION) break;\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat CalcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<4; aoi++ ) {\n        dd = map(nor * hr + pos);\n        totao += -(dd-hr)*sca;\n        sca *= .8;\n        hr += .03;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    iRes = iResolution.xy;\n\tfCoord = fragCoord;\n\ttime = iTime+100.*iMouse.x/iResolution.x;\n\t    \n    vec3 ro,rd;\n    getCam(fragCoord.xy, iResolution.xy, time, ro, rd);\n    \n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 res = texture(iChannel0,uv);\n       \n \tfloat ao = 0., sh = 0., t = res.x;\n    if (t<MAX_DIST) {\n        vec3 pos = ro + rd * t;\n    \tvec3 nor = calcNormal(pos, rd, t);\n        ao = CalcAO(pos, nor ),\n\t\tsh = SoftShadow( pos, sunLight); \n    }\n    \n    fragColor = vec4(res.x, ao, sh, res.y);    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n\n// [Dave_Hoskins] Rolling hills - https://www.shadertoy.com/view/Xsf3zX\n// [Shane] Voxel Corridor - https://www.shadertoy.com/view/MdVSDh\n// [HLorenzi] Hand-drawn Sketch  - https://www.shadertoy.com/view/MsSGD1\n// [Mercury] Lib - http://mercury.sexy/hg_sdf for updates\n// [dr2] White Folly - https://www.shadertoy.com/view/ll2cDG\n\n\n// Calculate textures and lights\n\n\n//--------------------------------------------------------------------------\n// Simply Perlin clouds that fade to the horizon...\n// 200 units above the ground...\nvec3 GetSky(in vec3 ro, in vec3 rd, sampler2D channel) {\n    ro = vec3(0,1,0);\n    vec3 col = 2.5*vec3(0.18,0.33,0.45) - rd.y*1.5;\n\tcol *= 0.9;\n    float sun = clamp( dot(rd,sunLight), 0.0, 1.0 );\n\tcol += vec3(1., .6, .2)*.8*pow( sun, 32.0 );\n /*   \n    vec2 cuv = ro.xz + rd.xz*(100.-ro.y)/rd.y;\n    float cc = texture( channel, 0.0003*cuv +0.1+ 0.0023*time ).x;\n    cc = 0.65*cc + 0.35*texture( channel, 0.0003*2.0*cuv + 0.0023*.5*time ).x;\n    cc = smoothstep( 0.3, 1.0, cc );\n    \n    return clamp(mix( col, vec3(1.0,1.0,1.0)*(0.95+0.20*(1.0-cc)*sun), 0.7*cc ), vec3(0), vec3(1));\n*/\n    return clamp(col, vec3(0), vec3(1));\n}\n\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(.299, .587, .114)); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// The brick groove pattern. Thrown together too quickly.\n// Needs some tidy up, but it's quick enough for now.\n//\nconst float w2h = 2.; // Width to height ratio.\nconst float mortW = 0.05; // Morter width.\n\n\nfloat brick(vec2 p){\n\tp = fract(p*vec2(0.5/w2h, 0.5))*2.;\n    p.x -= step(1., p.y)*.5;\n    p = abs(fract(p + vec2(0, .5)) - .5)*2.;\n    // Smooth grooves. Better for bump mapping.\n    return smoothstep(0., mortW, p.x)*smoothstep(0., mortW*w2h, p.y);\n    \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n //   n = abs(n);\n    return brick(n.x > .5 ? p.zy : n.y > .5 ? p.zx : p.xy);\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMapBrick(in vec3 p, in vec3 nor, float bumpfactor){\n\tvec3 n = abs(nor);\n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, n), bumpSurf3D(p - e.yxy, n), bumpSurf3D(p - e.yyx, n) )-ref)/e.x;                     \n    grad -= nor*dot(nor, grad);                            \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; \n    g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n//---------------------------------------------\n\n\n#define ID_GROUND 1\n#define ID_SMALL_TOUR 2\n#define ID_CASTLE 3\n#define ID_STONE 4\n#define ID_TREE_1 5\n#define ID_TREE_2 6\n#define ID_HOUSE_WALL 7\n#define ID_HOUSE_ROOF 8\n#define ID_GROUND_CASTLE 9\n#define ID_PUIT 10\n\nvec3 getTexture(vec3 p0, vec3 rd, inout vec3 n, inout vec2 spe, float t,\n                sampler2D channel1, sampler2D channel2, sampler2D channel3){ \n    float h = Terrain(p0.xz*.3);\n    float elev = p0.y - .002*h;\n    \n    spe = vec2(0.,1000.);\n    \n\tvec3 p = p0;\n   \tmalaxSpace(p);\n\n    p.x = abs(p.x);\n  \n    // Texture scale factor.        \n    const float tSize1 = 1.; //.5;//1./6.;\n\t\n    // puit\n    vec3 pp = p;\n    pp.x = abs(pp.x) +.1;// gothique  \n  //  pMirror(pp.x, -.1);  \n    float rp = length(pp.xz-vec2(3.,3.1));\n    \n    // arbre\n    p.z += .05;\n   \n    vec3 ph = p;\n   \n    //vec3 p2 = p, ph = p;\n\n    // Chemin de ronde\n    ph.z -= .5;\n\tpR45(ph.zx);\n    ph.z -= 4.6;\n    ph.x += 1.;\n    pReflect(ph, normalize(vec3(-1.,0,.7)),1.);\n    \n    vec3 pm = ph;\n    pMirrorOctant(pm.xz, vec2(1.5,1.6));\n\n    float ra = length(ph.xz);\n    \n    int id = rp < .202 ? ID_PUIT :\n        //rp<3.1 ? ID_HOUSE_WALL :\n        elev<.002 || length(p.xz)>10. ? (abs(p.z+1.9) < 1.9 && abs(p.x) < 2.3 ? ID_GROUND_CASTLE : ID_GROUND) :// sol\n        p.y>2.7 ? ID_SMALL_TOUR : // toit tour conique \n        abs(p.z+2.) < 1.55 && abs(p.x) < 2. ? ID_CASTLE :  // chateau\n        (length(p.xz-vec2(0,2.)) > 5.83 || (rp>3. && p.z<0.6)) ? ID_STONE :  // rempart \n        //abs(p.x) > 1.8 ? p.y < 2.5 ? vec3(.4,.4,.1) : vec3(.5,.9,.7) : //arbres\n        ra < .5 ? (ra < .051 && p.y<.7 ? ID_TREE_1 : ID_TREE_2) :\n        p.y < .325 ? ID_HOUSE_WALL : // mur maisonettes   \n        ID_HOUSE_ROOF;  // toit maisonettes\n\n    \n    vec3 c = vec3(1);\n    \n    switch(id) {\n        case ID_TREE_1 : \n        \tn = doBumpMap(channel1, p0.xyz*vec3(1.,.1,1.)*tSize1, n, .07/(1. + t/MAX_DIST));\n        \tc = vec3(.4,.3,.2); break;\n        case ID_TREE_2 :\n        \tn = doBumpMap(channel1, p0*4.*tSize1, n, .07/(1. + t/MAX_DIST)); \n        \tc = vec3(.2,.5,.4); break;\n        case ID_PUIT : \n        \tn = doBumpMap(channel2, p0*1.95*tSize1, n, .007/(1. + t/MAX_DIST)); \n        \tn = doBumpMapBrick(p*30., n, .015); c = .5*vec3(1.,.9,.7); break;\n        case ID_GROUND :\n        \n        \n            n = doBumpMap(channel1, p0*tSize1, n, .007/(1. + t/MAX_DIST));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\n\t\t\tc = NoiseT(1000.*p0.xz)*mix(vec3(.7,.7,.6), vec3(.3,.5,.4), smoothstep(.0,.05, abs(abs(p.x*1.2+.05)-.1)));\n       \t// test\n        \tbreak;\n        \n        case ID_GROUND_CASTLE :  \n        \tn = doBumpMapBrick(p0*5., n, .005); \n        \tc = vec3(.8,.8,.7); break;\n        case ID_SMALL_TOUR : \n        \tc = vec3(1.,.7,1); break;\n        case ID_CASTLE : \n        \tn = doBumpMap(channel3, p0*4.*tSize1, n, .007/(1. + t/MAX_DIST));\n        \t\n        //\tc = vec3(.95,.9,.85), smoothstep(0.,.1, sin(10.*p.y))); \n        \tc = mix(vec3(1.), vec3(.95,.9,.85), smoothstep(0.,.1, sin(15.*p.y))); \n        \tbreak;\n        case ID_STONE : \n        \tspe = vec2(.5,99.); \n        \tn = doBumpMapBrick(p*8., n, .03);\n        \tn = doBumpMap(channel1, p0*1.5*tSize1, n, .01/(1. + t/MAX_DIST));\n        \tc = .5*vec3(1.,.85,.7); break;\n        case ID_HOUSE_WALL :\n        \t//if (length(pm.xz)-.2\n        \t//n = doBumpMapBrick(p*15., n, .03); \n        \t//c = vec3(1.,.9,.7);\n            if (abs(pm.x-.0335) <.06 && abs(pm.z+.8) <.2 && pm.y<.285) {\n                // porte\n                n = doBumpMapBrick(vec3(.3, pm.x+.13, pm.z)*32., n, .03); \n                n = doBumpMap(channel1, 3.*pm.yxz*tSize1, n, .02/(1. + t/MAX_DIST));\n                c = .6*vec3(0.,.6,1); \n            } else {\t\n\t        \tn = doBumpMap(channel2, p0*1.95*tSize1, n, .007/(1. + t/MAX_DIST)); \n                c = vec3(1.,.95,.9);\n            }\n                c = c * mix(.4*vec3(.2,.6,.7), vec3(1), \n                      1.-.5*smoothstep(.3,.05, p0.y)*smoothstep(.3, .6,texture(channel2, p0.xy*4.*tSize1).x));\n            break;\n        case ID_HOUSE_ROOF :\n        \tspe = vec2(1.,9.); \n        \t//n = doBumpMapBrick((p-vec3(0.,.01,0.))*30., n, .03); \n        \tn = doBumpMap(channel3, p0*tSize1, n, .025/(1. + t/MAX_DIST));\n        \tc = vec3(.55,.32,.2) * mix(vec3(1), .7*vec3(.2,.6,.7), \n                  .5*smoothstep(.2,.9,texture(channel2, p0.xy*4.*tSize1).x));\n                   //  tex3D(channel2, p0*4.*tSize1, n).x));\n        \tbreak;        \t\n    }\n    \n    \t// prevent normals pointing away from camera (caused by precision errors)\n\tn = normalize(n - max(.0, dot (n,rd))*rd);\n    \n    return c;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, in float res, in vec3 pos, in vec3 nor, in vec2 spe, in vec3 c0, float sh, float ao,\n           sampler2D channel0, sampler2D channel1, sampler2D channel2, sampler2D channel3) {\n\t\n\t\tvec3 col;\t\n        float \n          amb = clamp(.5+.5*nor.y, .0, 1.),\n          dif = clamp(dot( nor, sunLight ), 0., 1.);\n\t\tdif *= sh; \n\n\t\tvec3 brdf =\n\t\t\tao*.5*(amb)+// + bac*.15) +\n\t\t\t1.*dif*vec3(1.,.9,.7);\n\t\n\t\tfloat\n\t\t\tpp = clamp(dot(reflect(-sunLight,nor), -rd),0.,1.),\n\t\t\tfre = (.7+.3*dif)* ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\t\tvec3 sp = spe.x*sh*pow(pp,spe.y)*vec3(1., .6, .2);\n\t\n\t\tcol = c0*(brdf + sp) + fre*(.5*c0+.5);\n\treturn col;\n}\n\n\nfloat triangle(float x)\n{\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\n\nconst vec3 COL_PAPER = .9*vec3(.8,0.7,0.6);\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    iRes = iResolution.xy;\n\tfCoord = fragCoord;\n\ttime = iTime+100.*iMouse.x/iResolution.x;\n\t\n    vec3 ro,rd;\n    getCam(fragCoord.xy, iResolution.xy, time, ro, rd);\n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 res = texture(iChannel0,uv);\n\tvec3 c0;\n    \n\tbool drawing = isDrawing(); \n    \n    if( res.x < MAX_DIST ) {  \n        vec3\n        \tpos = ro + res.x * rd,\n        \tnor = calcNormal(pos, rd, res.x);\n        vec2 spe = vec2(1.,9.);\n        c0 = drawing ? vec3(1.) : getTexture(pos, rd, nor, spe, res.x, iChannel1, iChannel2, iChannel3); \n        c0 = render(ro, rd, res.x, pos, nor, spe, c0, res.z, res.y, iChannel0, iChannel1, iChannel2, iChannel3);\t\t\n \n    } else {        \t\n         c0 = GetSky(ro, rd, iChannel0);\n    }\n   \n\n    if (drawing) {\n        \n        float grey = getGrey(c0.rgb);\n        grey = pow(grey,2.);\n\n        float t = floor(iTime * 16.0) / 16.0;\n        \n        vec2 p = -1.+2.*uv;\n        p.x *= -iResolution.x/iResolution.y;\n\n        p += vec2(triangle(p.y * rand(time) * 4.0) * rand(time * 1.9) * 0.015,\n                triangle(p.x * rand(time * 3.4) * 4.0) * rand(time * 2.1) * 0.015);\n        p += vec2(rand(p.x * 3.1 + p.y * 8.7) * 0.01,\n                  rand(p.x * 1.1 + p.y * 6.7) * 0.01);\n\n//        float contour = texture(iChannel0, uv+.002*vec2(rand(time + p.x),rand(time + p.y)),.8).w;  // mipmap eable kind of free antialiasing\n        float contour = texture(iChannel0, uv,.8).w;  // mipmap eable kind of free antialiasing\n\n        float frq = 30.;\n        float space = (rand(t * 6.6) * 0.1 + 0.9);\n        float xs = 1.1*space;\n        float ys = 1.1*space;\n        float \tht = 170.0 + rand(t) * frq,\n              \tht1 = 110.0 + rand(t * 1.91) * frq,\n             \tht3 = -110.0 + rand(t * 4.74) * frq,\n            \tht4 = 170.0 + rand(t * 3.91) * frq;\n        float hatchingB = max(\n            clamp((sin(p.x * xs * ht  + p.y * ys * ht1) * 0.5 + 0.5) - grey, 0.0, 1.0),\n            clamp((sin(p.x * xs * ht3 + p.y * ys * ht4) * 0.5 + 0.5) - grey - 0.4, 0.0, 1.0));\n       \n        p.y = 1.-p.y;\n        grey *=.5;\n\n    //    xs = 1.1*space;\n    //    ys = 1.1*space;\n\n        float hatchingW = max(            \n            clamp((sin(p.x * xs * ht  + p.y * ys * ht1) * 0.5 + 0.5) - (1.-grey), 0.0, 1.0),\n            clamp((sin(p.x * xs * ht3 + p.y * ys * ht4) * 0.5 + 0.5) - (1.-grey) - 0.4, 0.0, 1.0));\n\n        c0 = COL_PAPER;  \n      \tc0 = mix(c0, .25*vec3(1.,.4,.1), smoothstep(.3,1.,hatchingB));  // Sanguine  \n      \tc0 = mix(c0, vec3(.85,.9,1.1), smoothstep(.6,1.,hatchingW));    // Pastel\n//        c0 = mix(c0, .25*vec3(1.,.4,.1), smoothstep(.3,1.,contour)); // Contours Sanguine\n        c0 = mix(c0, .125*vec3(1.,.4,.1), contour*contour); // Contours Sanguine\n        \n        ro = vec3(2.,5,2.);\n    \trd = RD(ro, vec3(.01*iTime,0,.01*iTime), fragCoord.xy, iResolution.xy);\n        \n        res.x = -ro.y/rd.y;\n\n        sunLight = normalize(vec3(-15.,25,10));\n        \n        vec3 pos = ro + res.x * rd;\n        vec3 nor = doBumpMap(iChannel1, pos*.2, vec3(0,-1.,0), .05/(1. + res.x/MAX_DIST));\n        vec3 c = render(ro, rd, res.x, pos, nor, vec2(1.,9.), c0, 1., 1., iChannel0, iChannel1, iChannel2, iChannel3);\t\n        \n        c0 *= c; \n        \n    } else {\n        // Distance Fog (2 steps)\n       \tc0 = mix(c0, 2.*vec3(0.28,0.33,0.45), smoothstep(20., 1.5*MAX_DIST, res.x));\n        c0 = mix(c0, 2.*vec3(0.28,0.33,0.45), .5*smoothstep(0., 20., res.x));\n    }\n    \n    c0 = pow(c0,vec3(.7));\n    fragColor = vec4(clamp(c0,0.0,1.0), res.x>0. ? res.x : 1000.);\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}