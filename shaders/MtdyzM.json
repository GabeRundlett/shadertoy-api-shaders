{
    "Shader": {
        "info": {
            "date": "1532083457",
            "description": "barycentric coordinates easily usable to return if a poingt is in a triangle, outside of it (including ouztside of what sides), or on on any of its sides or on any of its points.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdyzM",
            "likes": 1,
            "name": "barycentric triangle bound",
            "published": 3,
            "tags": [
                "triangle",
                "barycentric",
                "bound"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "\nfloat suv(vec2 a){return a.x+a.y;}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\n#define ViewZoom 9.\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\nvec2 fra2(vec2 u){float r=iResolution.x/iResolution.y;u-=.5;u*=ViewZoom;u.x*=r;return u;}//fra2(u)=fra(u*iResolution)\n\nfloat segment2(vec2 p,vec2 a,vec2 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}\nfloat segment(vec2 p,vec2 a,vec2 b){return sqrt(segment2(p,a,b));}\n\n//can be used to calculate if a point is inside or outsiode a triangle:\n//- i can see this but its off by factor *2, so i must do m*=2. and l*=.5 to make the below generally true:\n//iff(point is outside triangle) at least one l.xyz component is <0\n//iff(point is inside triangle) all l.xyz elements are in range ]0..1[\n//iff(point is on triangle corner) one l.xyz element is ==1 (the corner associated one)\n//iff(point is on triangle edge) one l.xyz element is ==0 (point not on the line) and the other 2 are range ]0..1[\n\n\n//this solves the rope-pulling problems in barycentric coordinate transforms.\n//as in b2c() gets you the point of normalized 3 pulls.\n//as in c2b() translattes a vec2 in the required 3 pulls.\n\n//triangle set by 3 points, a,b,c\n//a 3rd point [u] can be written as linear combination;\n//the sum of the scales eqquals 1, this is different from normalizing!\n\n//barycentric to carthesian, carthesian is weighted average of barycentrics. \nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){//Barycentric2Carthesian\n ;return vec2(suv(vec3(a.x,b.x,c.x)*l),suv(vec3(a.y,b.y,c.y)*l))\n //;mat3 m=matrixCompMult(transpose(mat3(a,0,b,0,c,0)),mat3(l,l,0,0,0));return vec2(suv(m[0]),suv(m[1]))\n ;} \n//carthesian to barycentric\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c//there are more elegant versions of this with inverse() of the right matrix.\n){u-=c;b.y-=c.y;a.x-=c.x;c.x-=b.x;b.x=b.y*a.x+c.x*(a.y-c.y)//determinant\n ;vec3 r=vec3(suv(u*vec2(b.y,c.x)),suv(u*vec2(c.y-a.y,a.x)),0);r.z=suv(r.xy);r/=b.x;r.z=1.-r.z ;return r;}\n\nvoid mainImage(out vec4 O,in vec2 u){\n ;u=fra(u)\n ;vec2 m=fra(iMouse.xy)\n ;vec2 n=fra(iMouse.zw)\n ;float p=(length(m.xy-u)*5.)\n ;float q=(length(n.xy-u)*7.)\n ;vec2 d=fract(u)\n ;float t=0.\n ;vec2 a=vec2( 1,-2)+cs(-t)\n ;vec2 b=vec2( 4,1)+cs(t)\n ;vec2 c=vec2(-3,2)-cs(t)\n ;vec3 r\n ;vec3 l=c2b(m,a,b,c)\n //;l=normalize(l)//to show that barycentric is different from a normalized vector\n \n ;vec2 s=vec2(0)\n ;r.x=segment(u,s,s+a*l.x)-.03;s+=a*l.x\n ;r.y=segment(u,s,s+b*l.y);s+=b*l.y\n ;r.z=segment(u,s,s+c*l.z)\n\n ;r.y=min(r.y,segment(u,vec2(0),b*l.y)-.03);s=b*l.y\n ;r.z=min(r.z,segment(u,s,s+c*l.z));s+=c*l.z\n ;r.x=min(r.x,segment(u,s,s+a*l.x))\n \n ;r.z=min(r.z,segment(u,vec2(0),c*l.z)-.03);s=c*l.z\n ;r.x=min(r.x,segment(u,s,s+a*l.x));s+=a*l.x\n ;r.y=min(r.y,segment(u,s,s+b*l.y))\n  /*\n  //this ends up as a parallel projection of a box:\n ;s=c*l.z\n ;r.z=min(r.z,segment(u,vec2(0),c*l.z));\n ;r.x=min(r.x,segment(u,s,s+a*l.x));*/\n \n ;r.x=min(r.x,length(a-u)-.1)\n ;r.y=min(r.y,length(b-u)-.1)\n ;r.z=min(r.z,length(c-u)-.1)\n \n \n ;r=smoothstep(.02,-.02,r-.03)\n \n ;float w\n \n ;w=segment(u,a,b)*mix(.2,1.,step(l.z,0.));r=max(r,smoothstep(.05,-.05,w-.02))\n ;w=segment(u,c,b)*mix(.2,1.,step(l.x,0.));;r=max(r,smoothstep(.05,-.05,w-.02))\n ;w=segment(u,c,a)*mix(.2,1.,step(l.y,0.));;r=max(r,smoothstep(.05,-.05,w-.02))\n \n ;l=c2b(vec2(0),a,b,c);w=length(u-(a*l.x+b*l.x+c*l.z)*.3);r=max(r,smoothstep(.05,-.05,w-.02))//getting the center of the triangle\n  \n //;vec3 r=vec3(fract(min(p,q)),d)\n ;O=vec4(r,1);}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}