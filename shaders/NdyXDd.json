{
    "Shader": {
        "info": {
            "date": "1635499943",
            "description": "Generates random graphs and runs a physics simulation! Use mouse to drag vertices around\nGo to Common for some params to change!",
            "flags": 32,
            "hasliked": 0,
            "id": "NdyXDd",
            "likes": 14,
            "name": "Erdős–Rényi Random Graphs",
            "published": 3,
            "tags": [
                "simulation",
                "physics",
                "graphs"
            ],
            "usePreview": 0,
            "username": "gauravity",
            "viewed": 385
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(209.,205., 219., 255.)/255.;\n    vec2 uv = fragCoord / iResolution.x;\n    vec4 blu =  vec4(.3, .8, 1, 1);\n\n    #ifdef drawLines\n    for(int i =0; i < n; i++){\n        vec3 c = hsv2rgb(vec3(rand(vec2(i, i)),0.5, 1.));\n        \n        for(int j=0; j < n; j++){\n            if(j <= i){\n                continue;\n            }\n            if (getEdge(i, j)) {\n                line(fragColor, uv, getVertex(i).xy, getVertex(j).xy, lineThickness, vec4(1));\n            }\n        }\n    }\n    #endif\n    for(int i =0; i < n; i++){\n        vec3 c = hsv2rgb(vec3(rand(vec2(i, i)),0.5, 1.));\n        circle(fragColor, uv, getVertex(i).xy, radius, vec4(c, 1));\n     }\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Comment out the following line to disable drawing the lines between vertices\n// Drawing lines is the most expensive operation, without it you can simulate\n// Hundreds of vertices (even while simulating the springs)\n#define drawLines \n//change seed for different random graph\n#define seed vec2(420., 69.)\n//number of vertices (up to min(iResolution.x, iResolution.y)\n#define n 30\n//probability that any two vertices have a edge between them. \n// p*n is the average degree of a vertex (best results around p*n = 3)\n#define p  0.1\n// radius of each vertex\n#define radius 0.015\n// attracting force between vertices with spring (hooks law)\n#define k 15.\n// repellant force between vertices/wall (q/r^2)\n#define q .005\n// velocity wil *= drag once per second, lower = more drag\n#define drag 0.01\n// amount each particle repels the wall (as a fraction of q)\n#define wallRatio 3.\n// thickness of line\n#define lineThickness 0.0015\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n// Official HSV to RGB conversion \n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid circle(inout vec4 fragColor, in vec2 x, vec2 c, float r, vec4 color) {\n    if (length(c-x) < r) {\n        fragColor = color;\n    }\n}\nfloat rand(vec2 co){ return fract(sin(dot(co.xy + seed,vec2(12.9898,78.233))) * 43758.5453); }\n\n\nvoid line(inout vec4 fragColor, in vec2 x, vec2 p1, vec2 p2, float thicc, vec4 color) {\n    vec2 relx = x - p1;\n    vec2 dir = p2 - p1;\n    float projFactor = dot(relx, dir)/dot(dir, dir);\n    vec2 proj = projFactor*dir;\n    vec2 diff = proj - relx;\n    if (dot(diff, diff) < thicc*thicc && projFactor > 0. && projFactor < 1.) {\n        fragColor = color;\n    }\n}\n// https://www.shadertoy.com/view/tdGBDG\n// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n\n#define fetchData(addr) texelFetch(iChannel0, addr, 0)\n#define getVertex(i) fetchData(ivec2(i, i))\n#define getEdge(i, j) (fetchData(ivec2(i, j)).x>0.5)\n\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define PI 3.14159265\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 index = ivec2(fragCoord);\n    if(index.x >= n || index.y >= n || index.x > index.y) {\n        \n        return;\n    }\n    vec2 dims = iResolution.xy / iResolution.x;\n\n    \n    // edge, initialize once\n    if (index.x != index.y) {\n        fragColor = vec4(0., 0., 0., 0.);\n        if(rand(fragCoord) < p) {\n            fragColor += 1.;\n        }\n        return;\n    }\n    \n    float theta = 2.*PI*float(index.x)/float(n);\n    fragColor.xy = dims/2. + vec2(cos(theta),sin(theta))*.1; \n    fragColor.zw = vec2(0,0);\n    if (iFrame < 1) {\n        return;\n    }\n    fragColor = fetchData(index);\n    for(int i =0; i < n; i++) {\n        if (i == index.x) {\n            continue;\n        }\n        if (length(fragColor.xy-getVertex(i).xy) == 0.) {\n            fragColor.xy += fragCoord.xy*.00001;\n        }\n        float chargeForce = q/pow(length(fragColor.xy - getVertex(i).xy), 2.);\n        vec2 direction = normalize(fragColor.xy - getVertex(i).xy);\n        fragColor.zw += direction*chargeForce*iTimeDelta;\n        if (getEdge(i, index.x) || getEdge(index.x, i)) {\n            fragColor.zw += k*(getVertex(i).xy - fragColor.xy)*iTimeDelta;\n        }\n        \n    }\n    vec2 c = fragColor.xy*fragColor.xy;\n    vec2 d = (dims-fragColor.xy)*(dims-fragColor.xy);\n    fragColor.zw += iTimeDelta * (wallRatio*q/c - wallRatio*q/d);\n    fragColor.zw *= pow(drag, iTimeDelta);\n    fragColor.zw = clamp(fragColor.zw, -1., 1.);\n    vec2 mouseProj = iMouse.xy/iResolution.x;\n    if (length(mouseProj-fragColor.xy) < radius) {\n        fragColor = vec4(mouseProj, 0, 0);\n    }\n    fragColor.xy += fragColor.zw * iTimeDelta;\n    fragColor.xy = clamp(fragColor.xy, vec2(0,0), dims);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}