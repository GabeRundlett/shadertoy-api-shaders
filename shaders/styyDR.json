{
    "Shader": {
        "info": {
            "date": "1661295362",
            "description": "An infinite zoom animation of a rearranging checkerboard, with anti-aliasing. I did my best to golf the code, but I am hoping someone will join in to make it even smaller.",
            "flags": 0,
            "hasliked": 0,
            "id": "styyDR",
            "likes": 19,
            "name": "Checker Shuffle Zoom (262 chs)",
            "published": 3,
            "tags": [
                "antialiasing",
                "checkerboard",
                "golf",
                "swirled"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 380
        },
        "renderpass": [
            {
                "code": "// From FabriceNeyret2 (262 chars)\n//*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy,a;\n    O*=0.;\n    for (float x,e, i = 0.; i < 9.; m.x*m.y < 0. ? O += .11 : O )\n        x = .004 * i++ - iTime,\n        e = fract(x+x), \n        a = abs( m = mod( 9.*(u-R/2.)/R.y * ++e, 2.) - 1. ) -.5,\n        fract(x) > .5 ? m = m.yx : m,\n        m *= sign(m.y),\n        a.y * a.x < 0. ? m.x -= sign(a.y)/e : e,\n        m = fract(m) - .5;\n}\n/**/\n\n// From Xor (266 chars)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy,a;\n    O=vec4(0);\n    for (float x,e, i = 0.; i < 9.; m.x*m.y < 0. ? O += .11 : O )\n        x = .004 * i++ - iTime,\n        e = fract(x+x), \n        a = abs( m = mod( 9.*(u-R/2.)/R.y * ++e, 2.) - 1. ) -.5,\n        fract(x) > .5 ? m = m.yx : m,\n        m *= sign(m.y),\n        a.y * a.x < 0. ? m.x -= sign(a.y)/e : e,\n        m = fract(m) - .5;\n}\n/**/\n\n// From FabriceNeyret2 (267 chars)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy,a;\n    O=vec4(0);\n    for (float x,e, i = 0.; i < 9.;  m.x*m.y < 0. ? O += .11 : O )\n        x = .004 * i++ - iTime,\n        e = fract(x+x), \n        a = abs( m = mod( 9.*(u-R/2.)/R.y * ++e, 2.) - 1. ) -.5,\n        fract(x) > .5 ? m = m.yx : m,\n        m.y > 0. ? m = -m : m,\n        a.y * a.x < 0. ? m.x += sign(a.y)/e : e,\n        m = fract(m) - .5;\n}\n/**/\n\n// From Xor (291 chars)\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 m, R = iResolution.xy;\n    u -= R * .5;\n    O = vec4(0);\n\n    for (float x, y, e, a, A = 9., s = A / R.y, i = 0.; i < A; O += vec4(m.x > .5 ^^ m.y > .5) / A)\n    \n        x = fract(.004 * i++ - iTime) * s * 2.,\n        y = mod(x, s),\n        e = s + y,\n        a = y / e,\n        m = mod(u * e, 2.),\n        x > s ? m = m.yx : m,\n        m.y > 1. ? m = 2. - m : m,\n        m.y > .5 ^^ abs(m.x - 1.) < .5 ? m.x -= m.y > .5 ? -a : a : a,\n        m = fract(m);\n}\n/**/\n\n// My initial golfing attempt (315 chars)\n\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec3 R = iResolution;\n    u -= R.xy * .5;\n    O = vec4(0);\n\n    for (float A = 9., s = A / R.y, i = 0.; i < A; ++i)\n    {\n        float x = fract(.004 * i - iTime) * (s + s),\n            y = mod(x, s),\n            e = s * (1. + y / s),\n            a = y / e;\n            \n        vec2 m = mod(u * e, 2.);\n        if (x > s) m = m.yx;\n        if (m.y > 1.) m = 2. - m;\n        if (m.y > .5) a = -a;\n        if (m.y > .5 ^^ abs(m.x - 1.) < .5) m.x -= a;\n        m = fract(m);\n        \n        O += vec4(m.x > .5 ^^ m.y > .5) / A;\n    }\n}\n/**/\n\n\n// Original: 492 chars\n\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    u -= iResolution.xy * 0.5;\n    float size = 10.0 / iResolution.y;\n    \n    float AA = 16.;\n    O = vec4(0);\n    for (float i = 0.; i < AA; ++i)\n    {\n        float factor = -(iTime - iTimeDelta * (i / AA)) * 2.0;\n        float mm = mod(factor * size, size * 2.);\n        float mm0 = mod(mm, size);\n        float scale = size * (1.0 + mm0 / size);\n        float animate = mm0 / scale;\n        vec2 m = mod(u * scale, 2.0);\n        if (mm > size) m = m.yx;\n        if (m.y > 1.0) m = 2.0 - m;\n        if (m.y < 0.5 && m.x > 0.5 && m.x < 1.5) m.x += animate;\n        if (m.y > 0.5 && (m.x > 1.5 || m.x < 0.5)) m.x -= animate;\n        m = mod(m, 1.0);\n        O += vec4(m.x > 0.5 ^^ m.y > 0.5) / float(AA);\n    }\n}\n/**/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}