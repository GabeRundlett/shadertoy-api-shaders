{
    "Shader": {
        "info": {
            "date": "1600265636",
            "description": "Demonstrating simple refraction via a basic animated Transparent Truchet scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "3l2fDt",
            "likes": 79,
            "name": "Transparent Truchet",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "truchet",
                "extrude"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1178
        },
        "renderpass": [
            {
                "code": "/*\n\n\tTransparent Truchet\n\t-------------------\n\n\tThis is a basic refractive example. The scene isn't particularly exciting,\n\tbut the refractive element adds a little extra flavor... Not much, but a\n\tlittle. :) \n\n\tA few years ago, GPUs didn't enjoy branching, and seemed to hate nesting. \n    Even now, I try not to nest things too much. Anyway, for whatever reason,\n    these are not as big an issue as they once were, so we can at least put\n\ttogether simple scenes with multiple bounces.\n\n    By the way, in case it needs to be said, a real refractive\\reflective example \n    would require a stack to handle simultaneous reflective and refractive passes, \n    whereas this takes a lesser approach. By that, I mean this will attempt to \n    refract the surface normal of a refractive surface, then continue without \n    reflecting, and only reflect in the invent that it's not possible. The results \n    are good enough for simple examples like this, but definitely not production\n\tgrade.\n\n\tIf this were a path tracing example, I'd put a lot more effort into the\n\tcorrectness of the coloring. However, it's not, since I've basically thrown\n\tstuff in that I felt suited the situation, so don't pay too much attention\n\tto it. Having said that, I was going for a kind of smokey glass casing look, \n    and it's close enough, so it'll do. :) The refractive based logic is from \n    memory... Visually, things seem about right, but if you spot any mistakes, \n    feel free to let me know.\n\n\tFor anyone interested, the background is a custom version of the box divide \n    formula, which is related to KD trees. The coloring is provided via IQ's \n    versatile cosine palette formula.\n    \n\n    \n    Other examples:\n\n\t// An old favorite. Simple and pretty.\n    Spout - P_Malin\n\thttps://www.shadertoy.com/view/lsXGzH\n\n    // If you're trying to implement a basic multipass refraction and reflection \n    // example, I'd recommend this one. There are subtle differences, but I'm\n    // using similar logic. I adopted some of the naming conventions as well.\n    Glass Polyhedron - Nrx\n    https://www.shadertoy.com/view/4slSzj\n\n \n*/\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 5\n\n// Global block scale.\n#define GSCALE vec2(1./3.)\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Based on the UE4 random function: I like this because it incorporates a modulo\n// 128 wrap, so in theory, things shouldn't blow up with increasing input. Also, \n// in theory, you could tweak the figures by hand to get a really scrambled output... \n// When I'm feeling less lazy, I might do that.\n//\n// By the way, GPU's are fickle things, so if this isn't working on your\n// system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    //p -= floor(p/128.)*128. + vec2(64.340627, 72.465623);\n    //return fract(dot(p.xyx*p.xyy, vec3(20.390625, 60.703123, 2.4281207)));\n    \n    p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n \n}\n\n/*\n// My own experimental hash \n// Seems to work for the right range, but I don't trust it yet.\n\nfloat hash21(vec2 p){\n    \n    p = fract(p*2.0143)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n    //p.x = dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217));\n    //return p.x - floor(p.x);\n}\n\n// Another, based on the \"17*17 = 289\" thing.\nfloat hash21(vec2 p) {\n    float x = dot(p, vec2(97, 37));\n    x *= 288./289.;                \n    x = (x - floor(x))*289.;                         \n    x = (x*34. + 113.)*x/289.;                       \n    return x - floor(x);                            \n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n// The scene. All of it is pretty standard. There's a wall, extruded\n// hollowed out Truchet tubing and some metallic elements. To be honest, \n// this was a little rushed, but the field doesn't have a lot going on, \n// so tightening it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;\n     \n    // Truchet object and animated metallic balls: This is just a\n    // standard 2D animated Truchet with an extruded factor. If you're\n    // not sure how it works, myself and others have plenty of \n    // animated Truchet examples on Shadertoy to refer to.\n    //\n    // Grid construction: Cell ID and local cell coordinates.\n    const vec2 sc = 1./GSCALE, hsc = .5/sc;    \n    vec2 iq = floor(p.xy*sc) + .5;    \n    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;\n    \n    // Flip random cells. This effectively rotates random cells,\n    // but in a cheaper way.\n    float rnd = hash21(iq + .37);\n    if(rnd<.5) q.y = -q.y;\n      \n    // Circles on opposite square vertices.\n    vec2 d2 = vec2(length(q - hsc), length(q + hsc));\n    // Using the above to obtain the closest arc.\n    float crv = abs( min(d2.x, d2.y) - hsc.x);\n    \n    // Flipping the direction on alternate squares so that the animation\n    // flows in the right directions -- It's a standard move that I've\n    // explained in other examples.  \n    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;\n    // Using repeat polar coordinates to create the moving metallic balls.\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot2(iTime*dir); // Animation occurs here.\n    float a = -atan(pp.y, pp.x); // Polar angle.\n    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.\n    // Polar coordinate.\n    vec2 qr = rot2(-a*6.2831853)*pp; \n    qr.x -= hsc.x;\n     \n    // Ridges, for testing purposes.\n    //crv += clamp(cos(a*16. + dir*iTime*3.)*2., 0., 1.)*.003;\n    \n    // A rounded square Truchet tube. Look up the torus formula, if you're\n    // not sure about this. However, essentially, you place the rounded curve\n    // bit in one vector position and the Z depth in the other, etc. Trust me,\n    // it's not hard. :)\n    //float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .035;\n    float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .01), vec2(.035, .035), .01);\n    \n    // 3D ball position.\n    vec3 bq = vec3(qr,  p.z + .05/2. + .01);\n    //float ball = max(length(bq.zx) - .05, abs(bq.y) - .06);\n    float ball = length(bq) - .015; // Ball.\n    ball = min(tr + .03, ball); // Adding in the railing.\n    \n    // Hollowing out the Truchet tubing. If you don't do this, it can cause\n    // refraction issues, but I wanted the tubes to be hollow anyway.\n    tr = max(tr, -(tr + .01));\n \n    // Metallic elements, which includes the joins, metal ball joints\n    // and the tracks they're propogating along.\n    q = abs(abs(q) - .5/sc);\n    float mtl = min(q.x, q.y) - .01;\n    mtl = max(max(mtl, tr - .015), -(tr - .005));\n    \n    // Adding the balls. I should probably give them their own ID, but this \n    // involves less work, and I'm always up for that. :D\n    mtl = min(mtl, ball);\n    \n    // Storing the object ID.\n    vObjID = vec4(wall, tr, mtl, 1e5);\n    \n    // Returning the closest object.\n    return min(min(wall, tr), mtl);\n \n}\n\n \n// Basic raymarcher, but with an added distance factor that is\n// required when refracting through the inside of an object.\nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n \n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<72; i++){\n    \n        d = map(ro + rd*t)*distanceFactor;\n   \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        //if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        if((d<0. && abs(d)<DELTA) || t>FAR) break; \n       \n        t += d*.9; \n        //t += max(d, DELTA); // For cheap on pass refraction... Not used here.\n         \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n \n\n\n\n// Custom box divide formula: I wrote this from scratch, and based it on various \n// techniques, but changed a lot of it to cut down on operations. I also went to\n// some trouble to take a space and position preserving approach, which should make\n// it much easier to work with. The routines I've come across don't do that. :)\n//\n// The idea is simple, in theory, and the solution was simple, but as usual, I had\n// to make way too many mistakes to get there. Basically, you start in one of the\n// corners of the grid square, produce a random number, then split space vertically \n// or horizontally, according to the random factor. For instance, if the random number\n// is \".6,\" then split the space in a 60% to 40% ratio, update postions (depending\n// which side of the line you're on), reduce the space dimensions accordingly, etc.\n//\n// Simple, right? It should have been. :D Anyway, it's done now, so feel free to\n// use it for whatever you want.\n//\nvec4 boxDivide(in vec2 p){\n    \n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    const float sc = 1.;\n    p *= sc;\n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n    \n    // Vertical offset. \n    #define VERT_OFFSET\n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 8;\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i=0; i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.35 + (1. - .35)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        \n        // Minimum width... Thrown in at the last minute to enforce a\n        // minimum box size. There are probably better ways, but it works\n        // well enough.\n        const float mW = .125;\n        if(l.x<mW && l.y<mW) break;\n        if(l.x<mW && r2>.5) { r2 = 0.; }// r = .5;\n        if(l.y<mW && r2<=.5) { r2 = 1.; }\n        \n        //if(hash21(ip + 113.523 + l.yx + float(i)/float(iNum))<.3) continue;\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n              // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n        }\n        \n        // There are many ways to vary the line width.\n        #ifdef VARIABLE_LINE_WIDTH\n        l *= 1. - r*.03;\n        //l *= 1. - length(l)*.02;\n        //l *= .986;\n        #endif\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimenting, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    float d = sBoxS(p - s - l/2., l/2., .05*sqrt(rf));// + .001*sc;\n    \n   \n    \n    // Smoothing factor.\n    float sf = 1./450.*sc;//1./iResolution.y*sc;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n    \n    \n    // Using the ID to color the individual tile.\n   \n    // Random colors using IQ's cosine palette.\n    float rnd = hash21(id/sc);\n    vec3 pCol = .5 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);\n    pCol = mix(pCol, pCol.xzy, .2);//vec3(.2 + rnd*.4);//\n    \n    \n    // Another random colored version.\n    //pCol = vec3(1, hash21(id), hash21(id*57. + .5)*.8);\n    //pCol = mix(pCol, pCol.xzy, .35);//vec3(.2 + rnd*.4);\n    \n     // Textured version. Note that this is not an overlay -- Each tile has \n    // a uniform color.\n    //vec3 tx = texture(iChannel0, id/sc + .5).xyz; tx *= tx;\n    //vec3 pCol = smoothstep(0., .5, tx);\n    \n    \n   \n    // Rectangular cell border and coloring.\n    vec3 col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    col = mix(col, pCol, 1. - smoothstep(0., sf, d + .003*sc)); \n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    \n    // Center, space preserving dots.\n    // Just the center dot.\n    //float d2 = length(p - s - l/2.) - .004/sc;\n    // Splitting space to produce four rivot-looking dots.\n    p = abs(p - s - l/2.) - l/2. + .015;\n    float d2 = length(p) - .004/sc;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n    // Very subtle bump element for some highlighting.\n    sf *= 2.;\n    d += .002*sc;\n    float b = mix(.05, 0., 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    b = mix(b, .5, 1. - smoothstep(0., sf, d + .003*sc)); \n    //b = mix(b, 0., 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    b = mix(b, 0., 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n      \n    // Return the color and the bump value.\n    return vec4(col, b);\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n\tvec3 ro = vec3(iTime/8., 0, -1); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.03, -.02, .25); \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(-.5, 1., 0); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the Truchet tubing. Normally, you'd have\n    // diferent ones for different object, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object.\n        float svObjID = vObjID.x<vObjID.y && vObjID.x<vObjID.z? 0. : vObjID.y<vObjID.z? 1. : 2.;\n \n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n        //if((d<0. && abs(d)<delta) && t<FAR){\n\n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel0, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            //if(j < 2) \n                gSh = softShadow(sp, lp, sn, 12.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + .3 + ao*.3, 1.); // Adding a touch of light to the shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            \n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n             \n           if(svObjID == 0.){ // Back wall.\n               \n               // Texturing... but I decided against it. \n               //vec3 tx = tex3D(iChannel1, (sp*1.), sn);\n               //tx = smoothstep(0., .5, tx);\n\n               // The box divide color and bump factor.\n               vec4 bxD = boxDivide(sp.xy);\n               // A second sample for some highlighting.\n               vec4 bxD2 = boxDivide(sp.xy - normalize(ld.xy)*.003);\n               float b = max(bxD2.w - bxD.w, 0.)/.003;\n               oCol = bxD.xyz*(b*.015 + .95);//*(tx*.5 + .5);//vec3(.05);//\n        \n               // Stripes.\n               //vec2 q = rot2(-3.14159/4.)*(sp.xy);\n               //float str = abs(fract(q.x*15.*1.4142) - .5)*2. - .35;\n               //oCol = mix(vec3(1), vec3(0), 1. - smoothstep(0., sf*8., str));\n\n               // The wall has no reflection of refraction, so setting the\n               // reflective or transmission power to zero will cause the\n               // loop to terminate early, which saves a lot of work.\n               objRef = .0;\n\n               spe *= freS;\n\n               // Reflection only override. This ensures that no refraction\n               // will occur... It's hacky, but it works. :)\n               refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass Truchet tubes.\n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dard, in order to look transparent.\n                vec3 tx = tex3D(iChannel0, (sp*sz0), sn);\n                tx = smoothstep(.05, .5, tx);\n                oCol = tx*.125;//*vec3(1, 2, 3); // Color.\n                objRef = 1.; \n                \n                // Faking more of a glass look.\n                //oCol *= tx;\n                //objRef = 1.2; \n                \n            }\n            else { // Metallic stuff.\n                \n                // Joins and animated metal portion.\n                vec3 tx = tex3D(iChannel0, (sp*1.), sn);\n                tx = smoothstep(0.05, .5, tx);\n                oCol = tx*vec3(1, .85, .6)/3.;\n                objRef = .125; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*2.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n\n                \n            }\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .25 + vec3(1, .5, .3)*spe*16. + vec3(.1, .25, 1)*pow(fre, 2.)*8.);\n            \n            // Shading.\n            colL *= sh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}