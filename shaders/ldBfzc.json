{
    "Shader": {
        "info": {
            "date": "1501457796",
            "description": "mouse does stuff\nmakes most sense to keep mouse at upper right part of screen, due to a reasonable min() constraint.\n\nhow to i simplify the thing at line 120 further?",
            "flags": 0,
            "hasliked": 0,
            "id": "ldBfzc",
            "likes": 4,
            "name": "pModMirror1interval",
            "published": 3,
            "tags": [
                "mod",
                "modulo",
                "fract",
                "symmetry",
                "hgsdf",
                "interval",
                "pmodmirror",
                "disymmetry",
                "sawcos",
                "pmodinterval1",
                "pmodmirror1",
                "pmodinterval"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 938
        },
        "renderpass": [
            {
                "code": "/*\nthis is meant to generalize \npModMirror1() \nand \npMidInterval() \nof hg_sdf, and to make the mix less branching than its 2 sources.\n\n\nThe core trick is to spot mirror symmetry where ever it ocurs.\noften symmetry is hidden, most likely within offset modifiers or coordinate transforms.\npractice builds intuition, and symmetry if sull of moments of serendipidy.\n\nThen the core method to reduce ANYTHING to maximum symmetry (and max efficiency) is:\n(for complex number planes. first step is always to substitute i*i=-1.;)\n\n...substitute\n-min(-a,-b)\n...by\nmax(a,b)\n...by\nif(a>b)return c;else return d;\n...by \nmix(c,d,step(a,b))  \n...or by \nmix(c,d,sign(a-b)*.5+.5) //i might have swapped things here\n...by\nc*step(a,b)+ d*step(b,a)                          //i might have swapped things here\n...by\n.5*(sign(a-b)*c+c+ sign(b-a)*d+d)\n...\n###And if you do this for multiple of these, \n...you usually get a long sum af factors\n...and if your intuition is true, some factors cancel out.\n...you then still likely are left with a messy matrix of (almost) binominals.\n...and some signs can be flipped without changing anything visually due to symmetry)\n...this is where things get messy, often a bit recursive.\n...the core method to solving these matrices is to...\n...substitute\nsign(-a)\n...by\n-sign(a)\n...\n###And in the end the symmetry is caught when you\n...substitute\nsign(b)*sign(b)\n...by \n1.\n\nand you end up with VERY basic diymmetry functions, \nthat you can call within each other,\nor to be given parameters of offset modifiers and matrix transformations\n\n*/\n\n//sharpness of FullScreenAntiAliasing\n#define fsaa 15./iResolution.y\n//view zoom\n#define viewZoom 17.\n\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\n//#define mainImage(o,u)o=vec4(co(u),1.);\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.8)/(abs(c)+.5)\nvec3 SawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 SawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n////By discarding the whole part (of a line) with x=fract(x), you get a seesaw with range.y [0 .. 1];\n#define frac(a) a=fract(a)\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n\n//return triangle wave y for u.x;\nfloat triTon(float u){\n //u*=.5; //initial scaling is often better done outside this function\n u=abs(fract(u)*2.-1.);\n //u.x*.5;//last scaling is often better done outside of this functio\n return u;\n}\n\n//vector dotproduct with vecN(1) is a faster sum.\nfloat sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\nfloat sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n\n#define branchless\n//return pModInterval1(pModMirror1())\n//[m.x=interval.End] [m.y]=interval.start (is usually=0., therefore .y\n//inside the invercal, it returns a triangle wave, projecting like pModMirror1()\n//outside the interval, it returns u.x+n, \n//...where n is a floor() continuation of the triangle wave.\nfloat pModMirrorInterval1(float u,vec2 m){m*=.5;\n float ass=u;\n bool a=u>floor(m.x);\n int i;if(a)i=0;else i=1;\n #ifdef branchless\n float b=abs(fract(u)*2.-1.);//triTon(u);\n float c=((floor(m[i])-u)*2.+1.);//diagonals\n m=floor(m);\n float w=sign(m.y-u);\n u=sign(u-m.x);                                           \n//my intuition says there is a way to simplify these, but i can not find it:   \n//this has simple and hard cases, this one was a bit trickier.\n  float e= c*(u+1.)+.5*(\n      \n\n            //   c*(w+1.)*(c-b) ish ?\n      \n      //and the real provblem is, how to i know i can no longer remove something?\n      \n             +  c \n             +    b\n             +  c*  w\n             +u*  b*w\n             -u*c\n             -u*c*  w\n             -u*  b\n             -    b*w\n          \n      \n  );\n  \n      \n  /*  \n     -u*(c*(w+1.)+b*(1.-w))\n     +c*(w+1.)\n     +b*(1.-w)\n      \n      \n  );\n  \n         \n                                          \n   /*                                       \ne=\n  \n\n    \n   +sign(u)*c    \n   -sign(u)*d\n   \n    +d+c\n      \n  ;\n  e*=.5;\n                                          \n                                          /*\n  e=\n    \n    step(u,0.)*d\n      +\n      step(0.,u)*c\n      \n  ;\n                                          \n  //e*=2.; \n  /*\n  if(u>0.) e=c;    //(1+u) is either  0 or 2)\n  else     e=d;    //(1-u) is either  2 or 0)\n      ;\n          \n          /**/\n return    \n     .5*e;                                      \n                                          /*\n\n // d=mix(e,f,step(w,0.));  \n float d=(c*(w+1.)+b*(1.-w))*.5; \n return         \n        .5*(sign(u)+1.)*c       //(1+u) is either  0 or 2)\n       -.5*(sign(u)-1.)*d    //(1-u) is either  2 or 0)\n        ;\n                                          /*\n        float d=\n    (\n     sign(1.+sign(w))*c\n    +sign(1.-sign(w))*b \n        )\n ; \n\n          \n                                          /*\n float d=\n     sign(1.+sign(w))*c  //abs(1+z) is either  0 or 2)\n    +sign(1.-sign(w))*b //abs(1-z) is either  2 or 0)\n ; \n return \n        sign(1.+sign(u))*c       //(1+u) is either  0 or 2)\n       +sign(1.-sign(u))*d    //(1-u) is either  2 or 0)\n        ;\n                                          \n                                          \n         /*\n         \n     .5*( .5*(\n         \n        +      c\n        +  b\n        +    z*c  \n        +u*b*z\n        +u*b    *s\n        +  b*z  *s\n        +u*    c*s   \n        +u*  z*c*s\n         \n         )+c*(1.+u)   \n\n\n\n       //  -b*   (m.y-.5)*(1.-u)      \n         \n         \n      );    \n                                          \n                                          \n                                          \n                                          /*\n     \n     .5*( .5*(\n         \n        +      c\n        +  b\n        +u*b*z \n        +    z*c  \n        -u*b\n        -u*  z*c\n        -  b*z\n        -u*    c\n         \n         )+c*(1.+u)   \n\n-------\n\n\n\n     .5*(c*(1.+u+(1.-u)*h)\n      +j*(1.-u)\n      );    \n\n\n        +    c\n        +  u*c\n        -h*u*c\n        +h*  c\n      -j  *u\n      +j\n             \n\n\n\n     .5*(\n      e*d\n      +f*c\n         \n\n     );   \n*/\n //if(u<floor(m.x)&&u>floor(m.y))   \n #else\n if(a||u<floor(m.y)) //a is more likely true.\n  return (floor(m[i])-u)*2.+1.; //diagonals outside frame\n return abs(fract(u)*2.-1.);//triTon(u) in frame.\n #endif\n}\n\nvec3 co(vec2 u){\n vec2 m=fr(iMouse.xy);u=fr(u);\n //if(mouse up) autoMouse\n if(iMouse.z<0.){m=vec2(3,-2)+9.*vec2(sin(iTime*.61),cos(iTime)*Phi);}\n vec3 c;\n c.r=triTon(             u.x*.5  )+u.y;    \n m.y=-m.y-2.;//modifying for pModMirrorInterval1() \n c.g=pModMirrorInterval1(u.x*.5,m)+u.y;\n c.b=grid(u); \n //below distance gradient indicators are scaled by 0.61 to aboid overlap along the diagonals.\n c=SawCos3(c*phi,.9);//smoothest gradient visualization, this function may replace it?\n c=sqrt(c);//more evenly gamma correcting\n \n return c*.5+c.yzx*.2;}\n \nvoid mainImage(out vec4 o, vec2 u )\n{\n    o=vec4(co(u),1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}