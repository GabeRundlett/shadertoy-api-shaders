{
    "Shader": {
        "info": {
            "date": "1676300174",
            "description": " You can change the number of particles in Common if you have performances issues (NPARTICLES).",
            "flags": 32,
            "hasliked": 0,
            "id": "Dl2XRy",
            "likes": 11,
            "name": "Tornado with Particles Light",
            "published": 3,
            "tags": [
                "sdf",
                "light",
                "particles",
                "volumetric",
                "tornado"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 319
        },
        "renderpass": [
            {
                "code": "// Comment this line to see the particles as Sphere with a little bloom effect \n#define CUBE 1\n#define CUBE_BLOOM\n\n#ifdef CUBE\nconst float RAD = 10.;\n#else\nconst float RAD = 3.;\n#endif\n\n\n// Flickering the cube brightness\nfloat flicker(float i){\n    // Random flickering frequency and flickering amplitude\n    return pow(noise1(iTime*(2.+10.*hash11(i/7.453)), i), 1.+7.*hash11(i/2.473))*.95+.05;\n}\n\nfloat gyroid(vec3 p){\n    return abs(dot(cos(p), sin(p.zxy)));\n}\n\nfloat fbm(vec3 p, float dmin){\n    // FBM on gyroid noise, really cheap and high variety of texture\n    // Amplitude\n    float A = 1.;\n    // Total density\n    float d = 0.;\n    // Offset\n    float k = .6;\n    // Frequency deformation\n    float f = 1.;\n    // Add movement on the deformation\n    float V = 2.;\n    // Rescale\n    p/= 10.;\n    // Move to top\n    p.y +=  iTime*4.5;\n    // rotate the noise\n    p.xz = p.xz*rot(iTime*4.)*S(8., 0., length(p.xz)) + p.xz*S(7.5, 8.5, length(p.xz))*rot(iTime/8.);\n    \n\n    for (int i=0; i<5; i++){\n        p += .1*sin(p.xzy*.75*f+iTime*.2*V); // p deformation\n        p.y += iTime; // Move to top faster for higher frequencies (why not?)\n        d -= gyroid(p)*(A+((dmin-7.)/7.))-k; // Gyroid\n        A *= .63; // Amplitude\n        p *= 1.95*ROT3; // p rescale and rot\n        k -= .1; // change offset\n        f *= 2.5; \n        V *= 10.;\n    }\n    // Return the density at position p\n    return d;\n}\n\n// Map tornado\nfloat mapTornadoDensity(vec3 p)\n{\n  // Map tornado as a deformed cone \n  // Centering\n  vec3 c = vec3(0.,0.,4.);\n  p -= c;\n  // Cone angle\n  vec2 t = vec2(.07, .02)*4.;\n  \n  // Cone size\n  float h = 300.;\n  \n  // Reverse and translate cone\n  p.y *= -1.;\n  p.y -= 50.;\n  // Add sinusoidal movement on the cone\n  p.xz += vec2(cos(p.y/17.+iTime*2.435)*2., sin(p.y/17.+iTime*1.4532)*2.)*(.75+.25*cos(iTime/8.))*(10.);\n  // Finally compute the SDF \n  // SDF is not exact (and more because of all the deformation) but we don't care since we are doing volumetric marching\n  float d = sdCone(p, t, h);\n  // Add noise to get density\n  return fbm(p, d);\n}\n\n// ---------------------- MAP PARTICLES ------------------------\n\nfloat sdCube(vec3 p, vec3 c, float rad, int id){\n    // Cube SDF with rotation considering the cube's ID\n    float phi = 2.*3.1415*(float(id));\n    float psi = 2.*3.1415*(float(id)+.6);\n    float theta = 2.*3.1415*(float(id)+.7);\n\n    mat3 rot = rot3D(iTime*(1.+hash11(float(id))*.2), phi, psi, theta);\n\n    vec3 b = vec3(rad);\n    p = rot*(p-c);\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Map the cube\nfloat mapParticles(vec3 p, out vec3 col, out int id, out vec3 bloom){\n    bloom = vec3(0.);\n    col = vec3(0.);\n    id = 0;\n    float d = 1e10;\n    float dC;\n    for (int i=0; i<int(NPARTICLES); i++){\n        vec3 pos = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n        float d_bloom = sdSphere(p, pos, RAD);\n        #ifdef CUBE\n        float dC = sdCube(p, pos, RAD, i);\n        #else\n        float dC = d_bloom;\n        #endif\n        if (dC<d && dC<0.){\n           col = palette(float(i)/NPARTICLES);\n           d = dC;\n           id = i;\n        }\n        \n        bloom += palette(float(i)/NPARTICLES) * exp(-d_bloom*.1)*.02*pow(flicker(float(i)/NPARTICLES), 1.5);\n    }\n    return d;\n}\n\n// ---------------------- VOLUMETRIC RAYMARCHING ------------------------\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec4 col, out int id, out bool on_sph, out float density_when_hit, out vec3 bloom) {  \n  \n  bloom = vec3(0.);\n  col = vec4(0.);\n  // Init id object to -1\n  id = -1;\n  on_sph = false;\n  density_when_hit = 0.;\n  bool update_dwh = false;\n  \n  // Light vector\n  vec3 lp = vec3(0.), ld = vec3(0.);\n  \n  //Density activation treshold\n  float thresh= .1;\n  \n  // Total density\n  float td = 0.;\n  \n  // Raymarching parameters (dithering, marching step, depth)\n  float dit = fract(sin(dot(rd, vec3(14.456, 17.2154, 73.156))*4678.123))*2.;\n  float marchStep = 0.;\n  float t = START; // Starting point (depth)\n  \n  vec3 p = vec3(0.);\n  vec3 col_sph = vec3(0.);\n  \n  for (int i = 0; i < MAX_MARCHING_STEPS; i++){\n      \n      // Stop condition (ie total density > 1)\n      if (td > .99) break;\n      \n      // Map tornado and particles\n      p = ro + (t+dit)*rd;\n      float d = mapTornadoDensity(p);\n      int first_id;\n      vec3 new_bloom;\n      float dC = mapParticles(p, col_sph, first_id, new_bloom); \n      new_bloom *= 1./(1.+.004*max(length(p-ro)-START, 0.));\n      \n      bloom += new_bloom*2.;\n      // Hit Cube\n      if (dC<.1 && on_sph == false){\n          // If we hit a cube we keep the id of the first we hit\n          on_sph = true;\n          id = first_id;\n          density_when_hit = td;\n          update_dwh = true;\n      }\n      \n      \n      // Correct density\n      float den = step(thresh, d)*(d-thresh)*marchStep;\n      den = (1.-td)*den*.1;   \n      td += den*den*den;\n      \n      // Init New Color\n      vec3 ncol = vec3(0.);\n      \n      if (d>thresh){           \n          \n          // Cube color lightning\n          vec3 colS = vec3(0.);\n          for (int i=0; i<int(NPARTICLES); i++){\n              // Cube pos\n              vec3 lp = texelFetch(iChannel0, ivec2(i, 0.), 0).xyz;\n              ld = lp-p;\n              float lDist = (length(ld));\n              ld = normalize(ld);\n              \n              // Dist to cube attenuation\n              float atten = 1./(1.+ .002*pow(lDist*.1, 4.));\n              vec3 sn = -rd;\n              \n              // Classic lightning module\n              vec3 colL = palette(float(i)/NPARTICLES);\n              float lint = flicker(float(i))*1.5;\n              float diff = clamp(dot(sn, ld), 0., 1.);\n              float spec = clamp(dot(reflect(sn, ld), -rd), .0, 1.);\n              colS += lint*colL*(diff+spec*.15)*atten;\n          }\n          // Aggregate color for this voxel\n          col.rgb += .4*(colS*den)*(1.-td);\n      }\n      \n      // Adaptative marching step\n      marchStep = (4.-3.8*S(.0, .05, den));\n      \n      float dit2 = fract(sin(dot(p, vec3(14.456, 17.2154, 73.156))*4678.123))*marchStep*.5;\n      \n      // Update depth\n      t += marchStep + dit2;\n  }\n  \n  if (td < .97 && ! update_dwh){\n      density_when_hit = td;\n  }\n  \n  // Store total density\n  col.a = td;\n  return length(p-ro);\n}\n\n// ---------------------- RENDER AND LIGHTNING ------------------------\n\n//iq's function\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in float radius, in int id, out vec3 outNormal, vec3 pos_cube) \n{\n    // Centerize ro\n    ro -= pos_cube;\n     \n    float phi = 2.*3.1415*(float(id));\n    float psi = 2.*3.1415*(float(id)+.6);\n    float theta = 2.*3.1415*(float(id)+.7);\n\n    mat3 txx = rot3D(iTime*(1.+hash11(float(id))*.2), phi, psi, theta);\n    mat3 txi = inverse(txx);\n    // Rotate ro and rd\n    ro = txx*ro;\n    rd = txx*rd;\n\n    // Intersect\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*vec3(radius);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n\n    // Inverse rotate Normal\n    outNormal = txi*outNormal;\n    return vec2( tN, tF );\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, float ra, int id, vec3 pos_cube)\n{\n    ro -= pos_cube;\n     \n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    \n    return vec2( -b-h, -b+h );\n}\n\n// Coloring the particles\nvec3 getLightPart(vec3 ro, vec3 rd, int id, vec3 col, out float cubedepth, float density_when_hit, vec3 bloom){\n      // Since we use volumetric ray marching, the position do not represent cube surface.\n      // So we need to check the SDF another time considering only the cube \"id\"\n      \n     vec3 pos_cube = texelFetch(iChannel0, ivec2(id, 0.), 0).xyz;\n      \n     // Cube Case\n     #ifdef CUBE\n        float density = pow(density_when_hit, .2);\n        float depth = 0.;\n        // Ray intersect the nearest Cube with a radius slightly samller from the volumetric marcher\n        // Because we use a fixed step size around a cube the ray can miss the intersection around the edge.\n        // So, using a smaller radius reduce alliasing from this effect\n        // In counter part, it create black border when two cube are superposed but it's a minor effect\n        float radius = RAD - 2.;\n        vec3 normal = vec3(1.);\n        depth = boxIntersection(ro, rd, radius, id, normal, pos_cube).x;\n        if (depth == -1.){\n            #ifdef CUBE_BLOOM\n                return col + bloom;\n            #else\n                return col;\n            #endif\n        }\n        cubedepth = depth;\n        vec3 p = ro+rd*depth;\n        vec3 ld = normalize(p-pos_cube);\n        vec3 colS = palette(float(id)/NPARTICLES);\n\n        // Diffuse lightning\n        // The pow enforce darker edge on the cube\n        float dotLN = clamp(dot(ld, normal), 0., 1.);\n        vec3 diffuse = colS * pow(dotLN, 6.)*3.; \n\n        float flick = flicker(float(id));\n        vec3 final_col = flick*diffuse*exp(-max(depth-START, 0.)*.02);\n\n\n        final_col = final_col*(1.-density)+col.rgb*density;\n\n        return final_col;\n\n    // Sphere Case\n    #else\n        float radius = RAD - 2.;\n        float d = sphIntersect(ro, rd, radius, id, pos_cube).x;\n        float depth = d;\n        if (depth == -1.){\n        return col;\n        }\n        vec3 p = ro+rd*depth;\n        // No lightning since the source is the center of the ball\n        vec3 colS = palette(float(id)/NPARTICLES);\n        float flick = flicker(float(id));\n        vec3 final_col = flick*colS*exp(-max(depth-START, 0.)*.02);\n        float density = pow(density_when_hit, .2);\n        final_col = final_col*(1.-density)+col.rgb*density;\n        return final_col*10.*flick;\n    #endif\n}\n\n// Rendering\nvec4 render(vec3 ro, vec3 rd, out float depth){\n  vec4 col = vec4(0.);\n  int id = -1;\n  bool on_sph = false;\n  float density_when_hit = 0.;\n  vec3 bloom;\n  depth = rayMarch(ro, rd, col, id, on_sph, density_when_hit, bloom);\n  \n  // If we hit a cube compute the corresponding lightning else we have the volumetric color\n  if (on_sph){\n      float depthC = 0.;\n      col.rgb = getLightPart(ro, rd, id, col.rgb, depthC, density_when_hit, bloom);\n  }\n  #ifdef CUBE\n      #ifdef CUBE_BLOOM\n          else{\n              col.rgb += bloom;\n          }\n      #endif\n      return col;\n  #else\n      return col + vec4(bloom, 0.);\n  #endif\n}\n\n// ---------------------- MAIN ------------------------\n\n// Camera thing's\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  // Setup ray origin, camera, ray direction\n  vec3 ro = vec3(0, 0, -185); \n  vec2 m = iMouse.xy/iResolution.xy;\n  if (iMouse.z == 0.){\n      m = vec2(.5, .4);\n  }\n  vec3 lookat = vec3(0., 0., 4.);\n  ro.yz = ro.yz * 1. * rot(mix(PI/2., 0., m.y*2.));\n  ro.xz = ro.xz * rot(mix(-PI, PI, m.x)) + vec2(lookat.x, lookat.z);\n  vec3 rd = camera(ro, lookat)*normalize(vec3(uv, -.5));\n\n  float depth = 0.;\n  vec4 col = render(ro, rd, depth);\n  \n  // Gamma correction\n  fragColor = vec4(pow(max(vec3(0.), col.rgb*4.), vec3(.5)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NPARTICLES 20.\n#define PI 3.14159\n#define S(a,b,c) smoothstep(a,b,c)\n#define ROT mat3(cos(.7), 0., sin(.7), 0., 1., 0., -sin(.7), 0., cos(.7))\n#define ROT2 ROT*mat3(1., 0., 0., 0., cos(7.), sin(.7), 0., -sin(.7), cos(.7))\n#define ROT3 ROT2*mat3(cos(.7), sin(.7), 0., -sin(.7), cos(.7), 0., 0., 0., 1.)\n#define START 70.\nconst int MAX_MARCHING_STEPS = 60;\n\n\nfloat noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nmat2 rot(float t){\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat hash11(float p){\n    return fract(sin(p*12.789)*7896.4563);\n}\n\nfloat noise1(float p, float id)\n{\n    float i = floor(p);\n    float f = fract(p);\n    return mix(hash11(i+hash11(id*10.)*100.), hash11(i+1.+hash11(id*10.)*100.), smoothstep(0., 1., f));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, .5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0., 0.33, 0.67);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdSphere(vec3 p, vec3 c, float rad){\n    return length(p-c)-rad;\n}\n\nmat3 rot3D(float t, float phi, float psi, float theta){\n    float ca = cos(phi+t);\n    float sa = sin(phi+t);\n    float cb = cos(psi+t);\n    float sb = sin(psi+t);\n    float cg = cos(theta+t);\n    float sg = sin(theta+t);\n\n    return mat3(cb*cg, sa*sb*cg-ca*sg, ca*sb*cg+sa*sg,\n                cb*sg, sa*sb*sg+ca*cg, ca*sb*sg-sa*cg,\n                -sb,   sa*cb,           ca*cb);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Particles displacement buffer\n\nvec3 init_position(vec3 seed){\n    vec3 pos = vec3(seed);\n    float phi = 2.*3.1415*pos.x;\n    float rad = 100.;\n    return vec3(cos(phi), hash11(seed.y)/5., sin(phi))*(200.+hash11(seed.x)*rad)+vec3(0.,-80.,0.);\n}\nvec3 init_velocity(vec3 seed){\n    vec3 vel = vec3(seed.yxz);\n    return vec3(vel.x, 0., vel.z);\n}\n\n\nvec3 get_vel_change(vec3 p, int id) {\n  // Get a new velocity considering the position of the particles from the tornado\n  vec3 part = p;\n  vec3 nvel;\n  p.y *= -1.;\n  vec2 t = vec2(.07, .02)*4.;\n  float h = 300.;\n  p.y -= 80.;\n  p.xz += vec2(cos(p.y/17.+iTime*2.435)*2., sin(p.y/17.+iTime*1.4532)*2.)*(.75+.25*cos(iTime/8.))*(10.);\n  float dist;\n  // Cone's SDF\n  float d = sdCone(p, t, h);\n  \n  if (d<0.)\n      dist = 1.;\n  \n  // Custom velocity field\n  // Not perfect but do the job\n  else dist = 1./(1.+d*20.);\n  vec2 phi = normalize(p.xz).yx;\n  vec3 rot_around_cone = vec3(-phi.x, 0., phi.y)*500.; // Circle tangent \n  vec3 dir_to_cone = normalize(-p)*sign(d); \n  vec3 gravity = step(0., p.y)*vec3(0., -1, 0.)*abs(p.y)*10.; \n  nvel = mix(dir_to_cone*.75+gravity, rot_around_cone + vec3(0., 1., 0.)*.01, dist)*4.;\n  \n  // Slightly repulse cube from eachother\n  // Poor technique to replace collision\n  vec3 pos_other;\n  for (int i=0; i<int(NPARTICLES); i++){\n      if (i == id){\n          continue;\n      }\n      pos_other = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n      vec3 dir = pos_other-part;\n      float dist = length(dir);\n      dir = normalize(dir);\n      nvel -= 30.*dir * 1./(1.+.5*dist*dist);\n  }\n  \n  return nvel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord.xy);\n    \n    \n    if (uv.x>int(NPARTICLES) || uv.y>1){\n        // Pass most of time\n        fragColor = vec4(0.);\n        return;\n    }\n\n    vec3 center_obj = vec3(0.);\n    \n    vec3 pos;\n    vec3 vel;\n    \n    // Initialize position and velocity\n    if (iFrame <= 1){\n        float seedx = hash11( float(uv.x)+.1);\n        float seedy = hash11( float(uv.x)+5.);\n        float seedz = hash11(  float(uv.x)+1.);\n        pos = init_position(vec3(seedx, seedy, seedz));\n        vel = init_velocity(vec3(seedx, seedy, seedz));\n    }\n        \n    else{\n        // Get previous position and velocity\n        pos = texelFetch(iChannel0, ivec2(uv.x, 0), 0).xyz;\n        vel = texelFetch(iChannel0, ivec2(uv.x, 1), 0).xyz;\n        \n        // Update vel and pos\n        vel = (.95 * vel + .05 * (get_vel_change(pos, uv.x)));\n        pos += vel*.5;\n              \n        // Bound on y coordinate\n        if (abs(pos.y)>300.){\n            pos = init_position(hash33(pos+float(uv.x)));\n            vel = init_velocity(hash33(pos));     \n       }\n    }\n    \n    // Write position on first row\n    if (uv.y == 0){\n        fragColor.xyz = pos;\n    }\n    // Write velocity on second row\n    if (uv.y == 1){\n        fragColor.xyz = vel;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}