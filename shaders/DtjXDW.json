{
    "Shader": {
        "info": {
            "date": "1676270122",
            "description": "More 4d tests",
            "flags": 0,
            "hasliked": 0,
            "id": "DtjXDW",
            "likes": 7,
            "name": "Raymarching Tesseracts",
            "published": 3,
            "tags": [
                "raymarching",
                "4d",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "SpencerKuan",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "/*\n\n\n    This program demonstrates a render of a grid of \n    4D cube wireframes. Each cube has a blobby hypersphere \n    in the center as a point of reference. There is no movement\n    in the scene other than the camera's rotation.\n    \n    Each color represents a different direction in 4D space \n    (there are 8 sides to every 4D cube)\n    \n    To render the scene, a 4D camera takes a 3D 'picture' of \n    the scene using raymarching. A 2D 'slice' of this 3D picture\n    is displayed on the screen.\n    \n    You can control which 'slice' of the scene is rendered \n    by dragging the mouse along the x-axis on the screen.\n\n*/\n\n\n//  --- SETTINGS ---  // (remove the slashes to change the settings)\n\n// #define WALLS\n\n// \n\n\n\n// based on the 3D equivalent by IQ \nfloat sdBox( vec4 p, vec4 b ){\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.w, max(q.x,max(q.y,q.z))),0.0);\n}\n\n\n\n// the 4D SDF for the scene\nfloat map(vec4 p){\n\n    float d;\n    \n    #ifdef WALLS\n    \n        // room walls\n        const float wallDist = 7.0;\n        float wall = min(wallDist - p.x, wallDist + p.x);\n        wall = min(wall, wallDist + p.y);\n        wall = min(wall, wallDist - p.y);\n        wall = min(wall, wallDist + p.z);\n        wall = min(wall, wallDist - p.z);\n        wall = min(wall, wallDist + p.w);\n        wall = min(wall, wallDist - p.w);\n\n         d = (wall);\n\n        // domain repitition\n        p = mod(p + 5.0, 10.0) - 5.0;\n\n        // basic box\n        d = min(d, sdBox(p, vec4(1.2)));\n    #else\n    \n        // domain repitition\n        p = mod(p + 5.0, 10.0) - 5.0;\n        d = sdBox(p, vec4(1.2));\n    \n    #endif\n    \n    // box cutouts\n    float rem = sdBox(p, vec4(2, 1, 1, 1));\n    d = max(d, -rem);\n    rem = sdBox(p, vec4(1, 2, 1, 1));\n    d = max(d, -rem);\n    rem = sdBox(p, vec4(1, 1, 2, 1));\n    d = max(d, -rem);\n    rem = sdBox(p, vec4(1, 1, 1, 2));\n    d = max(d, -rem);\n    \n    \n    const float r = 5.0;\n    float disp = sin(p.x * r) * sin(p.y * r) * sin(p.z * r) * sin(p.w * r);\n    \n    // central sphere\n    d = min(d, (length(p) - 0.8 + disp * 0.2));\n    \n    return d;\n}\n\n// in: a point in 4D space\n// out: the normal of the surface using a central difference method on the 4D SDF\nvec4 normal(vec4 p){\n    vec2 e = vec2(0.001, 0);\n    float v = map(p);\n    \n    return normalize(vec4(\n        map(p + e.xyyy) - v,\n        map(p + e.yxyy) - v,\n        map(p + e.yyxy) - v,\n        map(p + e.yyyx) - v\n    ));\n}\n\n// finds the intersection between a ray starting at a \n// start position and a point on the 4D scene\n// out: distance to the intersection \nfloat intersect (vec4 start, vec4 dir){\n    // minimum distance for a intersection\n    const float eps = 0.01;\n    \n    // max constraints \n    const float maxD = 100.0;\n    const int maxIts = 200;\n    \n    // total distance traveled so far\n    float total = 0.0;\n    \n    // current position\n    vec4 pos = start;\n    \n    // current distance to a object\n    float d = 0.0;\n    \n    for(int i = 0; i < maxIts; i ++){\n        d = map(pos);\n        total = total + d;\n        pos += dir * d;\n        \n        if (d < eps) return total;\n        if (total > maxD) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n\n// returns the color contributions of a light on a surface\nvec3 shade (vec3 col, vec4 n, vec4 dir){\n    return col * max(dot(n, dir), 0.0);\n}\n\n// renders a point on a 3D viewport\nvec3 render3D (vec3 screen){\n    /*\n    \n        In 3D space, a camera works by projecting light to a 2D\n        screen. In 3D rendering, this plane usually spans the XY plane. \n        The point used for perspective is in the center of this plane \n        but is removed by some unit on the Z plane.\n    \n        In a similar manner, 4D space can be accurately captured with a \n        point camera using a 3D lense. Thus, the resulting 'image' is \n        really a 3D object. \n        \n        The camera point is a 4D point in the center of the cubish \n        camera picture but is removed by some unit on the W-dimension.\n    \n        Thus, this function takes an input in XYZ, projects a ray from \n        the camera point to that point, and then traces that ray until \n        it hits a point on the 4D scene to find an intersection to render. \n    \n    */\n\n\n    // pixelate the output\n    // screen = floor(screen * 50.0) / 50.0;\n\n    // camera rotation for the scene\n    mat4 rot = mat4(1.0);\n    \n    // animation variable for the rotation\n    float animate = (iTime) * 0.2;\n    \n    // composite rotations\n    \n    rot = rot * rotateXY(animate * 0.2);\n    rot = rot * rotateXZ(animate * 0.3);\n    rot = rot * rotateXW(animate * 0.4);\n    \n    rot = rot * rotateYZ(animate * 0.5);\n    rot = rot * rotateYW(animate * 0.6);\n    \n    rot = rot * rotateZW(animate * 0.7);\n\n    // 4D camera position, spun around the axis\n    vec4 cam = vec4 (0, 0, 0, -6) * rot;\n    \n    // 4D camera direction for that particular 3D viewport\n    vec4 dir = normalize(vec4(screen, 2.0)) * rot;\n    \n    // the total distance to a intersection with the 4D scene\n    float d = intersect(cam, dir);\n   \n    // black background for no collisions\n    if (d == -1.0) return vec3(0);\n    \n    // position and normal of the intersection in the 4D scene\n    vec4 p = cam + dir * d;\n    vec4 n = normal(p);\n    \n    // resulting output color\n    vec3 col = vec3(0);\n    \n    const vec3 colors[8] = vec3[8](\n        vec3(255, 105, 97) / 255.,\n        vec3(255, 180, 128) / 255.,\n        vec3(248, 243, 141) / 255.,\n        vec3(66, 214, 164) / 255.,\n        vec3(8, 202, 209) / 255.,\n        vec3(89, 173, 246) / 255.,\n        vec3(157, 148, 255) / 255.,\n        vec3(199, 128, 232) / 255.\n    );\n    \n    // shading for each of the 8 spacial directions in 4D space\n    col += shade(colors[0], n, vec4(+1, 0, 0, 0)); // +x\n    col += shade(colors[1], n, vec4(0, +1, 0, 0)); // +y\n    col += shade(colors[2], n, vec4(0, 0, +1, 0)); // +z\n    col += shade(colors[3], n, vec4(0, 0, 0, +1)); // +w\n    col += shade(colors[4], n, vec4(-1, 0, 0, 0)); // -x\n    col += shade(colors[5], n, vec4(0, -1, 0, 0)); // -y\n    col += shade(colors[6], n, vec4(0, 0, -1, 0)); // -z\n    col += shade(colors[7], n, vec4(0, 0, 0, -1)); // -w\n    \n    // make everything a little less bright\n    col = col * min(exp(-d * 0.08), 1.0);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvo = (fragCoord/iResolution.xy * 2.0 - 1.0);\n    vec2 uv = uvo * iResolution.xy / min(iResolution.x, iResolution.y);\n\n    // mouse position (from 0 to 1)\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    /* \n        To show the 3D render on a computer's 2D screen, \n        I just take a slice of the resulting 3D image \n        and display that instead.\n        \n        The following z variable is which slice is chosen\n    */\n\n    // z position of the 3D viewport (another dimension of the screen)\n    float z = mouse.x == -1.0 ? sin(iTime * 0.25) * 0.5 : mouse.x;\n    \n    // 3D screen position for the particular pixel\n    vec3 screenCoord = vec3(uv, z).xyz;\n    \n    // rendered color\n    vec3 col = render3D(screenCoord);\n    \n    // gamma correction\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    \n    // output\n    fragColor = vec4(col, 1.0);\n    \n    if (abs(z - uvo.x) < 0.001 && abs(uvo.y) > 0.9) {\n        fragColor = fragColor * 0.5 + vec4(vec3(0.5), 1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 4D utils\n\nmat4 rotateXY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s, c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, 0.0, -s,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        s, 0.0, 0.0, c\n    );\n}\n\nmat4 rotateYZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        0.0, s, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateYW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, 0.0, -s,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, s, 0.0, c\n    );\n}\n\nmat4 rotateZW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, c, -s,\n        0.0, 0.0, s, c\n    );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}