{
    "Shader": {
        "info": {
            "date": "1584513728",
            "description": "trying to create the Mandelbrot Set",
            "flags": 0,
            "hasliked": 0,
            "id": "ttyXRy",
            "likes": 1,
            "name": "Testing The Mandelbrot Set",
            "published": 3,
            "tags": [
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "abhinavneelam",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "#define COLOR_RED vec4(1.0f,0.0f,0.0f,1.0f)\n#define COLOR_GREEN vec4(0.0f,1.0f,0.0f,1.0f)\n#define COLOR_BLUE vec4(0.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_YELLOW vec4(1.0f,1.0f,0.0f,1.0f)\n#define COLOR_LBLUE vec4(0.0f,1.0f,1.0f,1.0f)\n#define COLOR_PINK vec4(1.0f,0.0f,1.0f,1.0f)\n\n#define COLOR_BLACK vec4(0.0f,0.0f,0.0f,1.0f)\n#define COLOR_WHITE vec4(1.0f,1.0f,1.0f,1.0f)\n\n#define W iResolution.x\n#define H iResolution.y\n#define WH iResolution.xy\n\nvec4 out_color;\nvec2 in_coord;\n\nconst int iter_c = 80;\n\nconst vec4 background = COLOR_BLACK;\n\nvoid drawRect(in vec2 pos, in vec4 color, in vec2 size)\n{\n    if(in_coord.x >= pos.x && (in_coord.x) <= pos.x + size.x && in_coord.y >= pos.y && (in_coord.y) < pos.y + size.y)\n        out_color = color;\n}\n\nvec2 multiplyComplex(vec2 a, vec2 b)\n{\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec4 pipeColor(float value)\n{\n\t//0.25,0.50,0.75,1.0f\n\tvec4 ret = COLOR_BLACK;\n    \n    ret = vec4(value);\n    \n    ret.y=0.0f;\n    ret.z=0.0f;\n        \n    return ret;\n    \n    if(value > 0.75f)\n    {\n        value -= 0.75f;\n        \n      \tret = vec4(1.0f, 1.0f, value, 1.0f);\n    }else if(value > 0.5f)\n    {\n     \tvalue -= 0.5f;\n        \n        ret = vec4(1.0f, value, 0.0f, 1.0f);\n    }else if(value > 0.25f)\n    {\n     \tvalue -= 0.25f;\n        \n        ret = vec4(value, 0.0f, 0.0f, 1.0f);\n    }\n    \n    //ret=vec4(1.0f)-ret;\n    return ret;\n}\n\nfloat convertWindowToLinearCoord(float x, float y, float norm)\n{\n    float length = distance(x,y);\n    \n    return norm * length + x;\n}\n\nfloat invert(float t)\n{\n \treturn 1.0f/t;   \n}\n\nfloat lockdown(float x, float c)\n{\n    return -5.0f * pow(0.5,x) + c;\n}\n\nfloat slowdown(float x)\n{\n \treturn 16.0 + 2.0f * log(x);\n}\n\nvoid drawMandelBrot()\n{\n\tvec2 norm_coord = (in_coord.xy/WH - vec2(0.5)) * vec2(2.0f);\n    \n    float scalingFactor = 0.05f;\n    \n    vec4 vp = vec4(-2,1,-1,1);\n    vec2 point = vec2(-0.75,-0.1);\n    \n    point=vec2(-0.761574,-0.0847596);\n    point=vec2(0.42884,-0.231345);\n    \n    vec4 vpnorm = vec4(distance(point.x,vp.x), distance(point.x,vp.y),\n                       distance(point.y,vp.z),distance(point.y,vp.w));\n\n    vec4 ratios = vpnorm;\n    \n    //debugging\n    float fakeTime = 20.0f;\n    fakeTime = slowdown(iTime);\n    \n    ratios = ratios * (scalingFactor * fakeTime);    \n    \n    vp = vec4(vp.x + ratios.x, vp.y - ratios.y, vp.z + ratios.z, vp.w - ratios.w);\n    \n    if(vp.x > point.x)\n        vp.x=lockdown(vp.x, point.x);\n    \n    if(vp.y < point.x)\n        vp.y=lockdown(vp.y, point.x);\n    \n    if(vp.z > point.y)\n        vp.z=lockdown(vp.z, point.y);\n    \n    if(vp.w < point.y)\n        vp.w=lockdown(vp.w, point.y);\n    \n    norm_coord.x = convertWindowToLinearCoord(vp.x, vp.y, in_coord.x/W);\n    norm_coord.y = convertWindowToLinearCoord(vp.z, vp.w, in_coord.y/H);\n    \n    float scalar = 3.0f;\n    \n    vec2 value = vec2(0);\n    int index=0;\n    for(int i=0;i<iter_c;++i)\n    {\n        value = multiplyComplex(value,value) + norm_coord;\n        \n        if(length(value) > 2.0f)\n        {\n            out_color = COLOR_WHITE * pipeColor(float(i)/float(iter_c));\n            return;\n        }\n        index=i;\n    }\n    out_color = COLOR_BLACK;\n}\n\nvoid drawMain()\n{\n\tdrawMandelBrot();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    in_coord = fragCoord-vec2(0.5);\n    drawMain();\n    fragColor = out_color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}