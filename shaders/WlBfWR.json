{
    "Shader": {
        "info": {
            "date": "1598844836",
            "description": "Simple 2D disintegration of an input texture to alpha using overlapping circle patterns.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlBfWR",
            "likes": 4,
            "name": "Disintegrate to Circles",
            "published": 3,
            "tags": [
                "2d",
                "circles",
                "disintegration"
            ],
            "usePreview": 1,
            "username": "hugoaboud",
            "viewed": 582
        },
        "renderpass": [
            {
                "code": "/*\n\tThis program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, version 3.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Shader properties */\n\nvec4 transp = vec4(0.0,0.0,0.0,0.0);\nvec4 color1 = vec4 (0.867, 0.675, 0.557, 1.0);\nvec4 color2 = vec4 (0.871, 0.843, 0.804, 1.0);\n\nfloat w = 0.008; // width of grid (UV coords)\nfloat shrinkSpeed = 0.7; // shrinking\nfloat lineSpeed = 0.2; // line scan\nfloat fadeSpeed = 1.0; // color fade\n\nfloat time = 0.0; // animation time\n\n/* Random */\n\n#define SEED 987654.321\n// Generates a random float from another 2D vector\n// seed must be a large number\n// output range: [0..1[\nfloat randFloat(in vec2 vec, in float seed)\n{\n    return fract(sin(vec.x*99.9+vec.y)*seed);\n}\n\n/* DisintegrateToCircles Shader\n\n\tThis shader uses a pattern from \"A Handbook of Ornament\", by Franz Sales Meyer (page 21, pattern 2).\n\tAfter filling the original 90Â° arcs for each block of the grid, the shader completes each circle\n\tby drawing arcs from the opposite end of the block.\n\tThe radiuses are shrunk in random rates, calculated by the original semicircle position on grid.\n\tThe color is faded from the original color to two different colors, which adds depth to the pattern,\n\tand a nice \"glow\" effect on the border of the disintegration.\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // To visualize the animation in Shadertoy, the time is updated to global time\n    // When using the shader, the time property should be animated extternally\n    time = iTime;\n    \n    // Calculate UV and get input color\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 img = texture(iChannel0, uv.xy);\n    \n    // Calculate height from aspect, for square grid\n    float h = w * (iResolution.x/iResolution.y);\n    \n    // Scale grid so that each square goes from 0..1   \n    uv.x /= w;\n    uv.y /= h;\n    \n    // Offset rows 3 and 4\n    if (int(uv.y)%4>1) uv.x += 2.0;\n    \n    // Calculate local coordinates in the block\n    // And grid coordinates\n    vec2 local = fract(uv);\n    int xg = int(uv.x);\n    int yg = int(uv.y);\n\n    // Line sweep position\n    float line = time * lineSpeed * (1.0/h);\n    \n    // Draw\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    // Above the line, just draw the image\n    if (yg/2 > int(line/2.0)) {\n        color = img;\n    }\n    // Below the line, draw pattern\n    else {\n        // Flip local coordinates according to pattern\n        int xp = xg%4;\n        int yp = yg%2;\n        if (yp == 0) {\n            if (xp == 0 || xp == 1) local.y = 1.0 - local.y;\n            if (xp == 1 || xp == 2) local.x = 1.0 - local.x;\n        }\n        else if (yp == 1) {\n            if (xp == 1 || xp == 2) local.x = 1.0 - local.x;\n            if (xp == 2 || xp == 3) local.y = 1.0 - local.y;\n        }\n\n        // Get random scale for each main semi-circle\n        float rscale = 0.0;\n        if (xp < 2) rscale = randFloat(vec2(xg,yg/2), SEED);\n        else rscale = randFloat(vec2(xg/2,yg), SEED);\n\n        // Get random scale of neighbour semi-circle\n        float nrscale = 0.0;\n        if (xp < 2) {\n            if (yp == 1) {\n                if ((yg/2)%2 == 0) nrscale = randFloat(vec2(xg/2+1,yg+1), SEED);\n                else nrscale = randFloat(vec2(xg/2-1,yg+1), SEED);\n            }\n            else {\n                if ((yg/2)%2 == 0) nrscale = randFloat(vec2(xg/2+1,yg-1), SEED);\n                else nrscale = randFloat(vec2(xg/2-1,yg-1), SEED);\n            }\n        }\n        else {\n            if (xp == 2) nrscale = randFloat(vec2(xg-1,yg/2), SEED);\n            else nrscale = randFloat(vec2(xg+1,yg/2), SEED);\n        }\n\n        // Clip scales to range [0,0.5[\n        rscale = rscale/2.0+0.5;\n        nrscale = nrscale/2.0+0.5;\n\n        // Calculate distance and neighbour distance to center\n        float dist = length(local);\n        float ndist = length(1.0-local);\n\n        // Animate radius\n        float radius = 1.0 - time * rscale * shrinkSpeed;\n        float nradius = 1.0 - time * nrscale * shrinkSpeed;\n\n        // Time offset for y position\n        float t = ((uv.y*h)/lineSpeed);\n        radius += t*rscale*shrinkSpeed;\n        nradius += t*nrscale*shrinkSpeed;\n        \n        // Color fade time\n        if (time > t) t = (time-t)*fadeSpeed;\n        else t = 0.0;\n        \n        // Draw circles\n        if (xp < 2) {\n            if (dist <= radius) color += mix(img, color1, t);\n            else if (ndist <= nradius) color += mix(img, color2, t);\n        }\n        else {\n            if (dist <= radius) color += mix(img, color2, t);\n            else if (ndist <= nradius) color += mix(img, color1, t);\n        }\n    }\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}