{
    "Shader": {
        "info": {
            "date": "1551485378",
            "description": "mouse x => rotate\nmouse y => count slices\nspace key,=> pause music historic\n\nyou have some defines in the buffer B\n",
            "flags": 48,
            "hasliked": 0,
            "id": "WsXSRS",
            "likes": 24,
            "name": " Reactive Julia Revolute Sliced",
            "published": 3,
            "tags": [
                "julia",
                "reactive",
                "revolute",
                "sliced"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 1495
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// https://www.shadertoy.com/view/WsXSRS\n\n// Reactive Julia Revolute Sliced\n\n//mouse x    => rotate\n//mouse y    => count slices\n//space key  => pause music historic\n\n// based on my shader Julia Revolute Sliced => https://www.shadertoy.com/view/WslXWr\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// simple music historic\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = iResolution.xy;\n    \n    if (max(fragCoord.x,fragCoord.y) > 200.) return;\n    \n    if (fragCoord.y < 1. || iFrame < 1)\n    {\n        if (texture(iChannel2, vec2(32./256.,0.)).x > 0.0) // space key\n        {\n            fragColor = vec4(0);\n        }\n        else\n        { \n    \t\tfragColor = texture(iChannel1, vec2(fragCoord.x,1.)/size);\n        }\n    }\n    else\n    {\n    \tfragColor = texture(iChannel0, (fragCoord - vec2(0,1))/size);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 20,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// julia fractal extruded along a torus path and sliced\n\n//#define COLOR_FULL\n//#define HISTO_PLANE\n#define JULIA_ITERS 3\n#define BASE_COUNT_SLICES 75./6.28318\n\nfloat countSlices;\nfloat amp;\n// section\nfloat sId;\nfloat an;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.14159 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat julia(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (int i=0;i<JULIA_ITERS;i++)\n    {\n        h *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);\n}\n\nvec2 fractus(vec3 p, float o, float a)\n{\n\tvec2 c = vec2(mix(0.2, -0.5, sin(a * 2.)), mix(0.5, 0.0, sin(a * 3.)));   \n    float path = length(p.xz) - 3.;\n    vec2 rev = vec2(path - o * 3., p.y - o + 1.);\n    float aa = a + iTime;\n    rev *= mat2(cos(aa),-sin(aa),sin(aa),cos(aa)); // rot near axis y    \n    return vec2(julia(rev, c),1.);\n}\n\nvec2 maxObj(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nvec2 fractusSliced(vec3 p, float a, float n, float oa)\n{\n    a += oa/n;\n\tvec2 cutter = vec2(abs(abs(fract(a*n)-0.5) - 0.2)-0.2,2.);\n    \n    an = a*n;\n\ta = floor(an)/n;\t\n    \n    sId = a;\n    amp = texture(iChannel1, clamp(vec2(3, sId*3.)/200.,0.,1.)).x;\n    an += oa/n*2.;\n    \n    return maxObj(\n        cutter,\n        fractus(p, amp, sId));\n}\n\nvec2 minObj(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    float a = fullAtan(p.xz);\n\t\n    float d = length(p.xz);\n    \n    float wave = p.y + 2.5; \n    \n#ifdef HISTO_PLANE\n    wave -= texture(iChannel1, clamp(vec2(d, sId)/200.,0.,1.)).x * d * 0.1;\n#endif\n    \n    return minObj(\n        vec2(wave,0.), \n        fractusSliced(p,a,countSlices,0.));\n}\n\nfloat march( in vec3 ro, in vec3 rd )\n{\n\tfloat s = 1.;\n    float d = 0.;\n\tfor( int i=min(iFrame,0); i<200; i++ )\n    {\n        if( abs(s)<d*d*1e-6 || d>50. ) break;\n\t    s = map( ro+rd*d ).x;\n        d += s*0.5;\n    }\n    return d;\n}\n\nvec3 getNor( vec3 p, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(p+eps.xyy).x - map(p-eps.xyy).x,\n\t    map(p+eps.yxy).x - map(p-eps.yxy).x,\n\t    map(p+eps.yyx).x - map(p-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// iq code\nfloat getSha( in vec3 ro, in vec3 rd, in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, hn*h/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// iq code\nfloat getAO( in vec3 p, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float(i)/4.0;\n        vec3 aopos =  nor * hr + p;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// shane code\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// shane code\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec3 light( in vec3 ld, in vec3 lc, in vec3 tex, in vec3 n, in vec3 rd )\n{    \n    float diff = pow(dot(n, -ld) * .5 + .5,2.0);\n    float spe = pow(max(dot(-rd, reflect(ld, n)), 0.0), 32.0);\n    \n    return (tex * diff + spe) * lc * 1.5;\n}\n\n// https://www.shadertoy.com/view/ld3fzf\nvec3 GetRainBow(float r)\n{\n\tint i = int(3.*fract(r)); \n\tvec4 c = vec4(.25);   \n\tc[(i+1)%3] += r = fract(3.*r);\n\tc[i] += 1.-r;\n\treturn c.rgb;\n}\n\nvec3 shade( in vec3 ro , in vec3 rd, in float d )\n{    \n\tvec3 p = ro + rd * d;\n\t\n\tvec3 n = getNor(p, 0.01);\n    \n    vec3 d1 = -normalize(vec3(1,2.5,3));\n    vec3 d2 = -normalize(vec3(5,3.5,0.5));\n    \n    float m = map(p).y;\n    \n    vec3 sn = texBump(iChannel0, p * 0.5, n, 0.01);\n\tvec3 texCol = tex3D(iChannel0, p * 0.1, sn);\n    \t\n    float sha = 0.5 + 0.5 * getSha(p, sn, 2.0);\n    float ao = getAO(p, sn);\n    \n    vec3 l1 = light(d1, vec3(1,1,1), texCol, sn, rd);\n    vec3 l2 = light(d2, vec3(1.2), texCol, sn, rd);\n    \n\tvec3 col = texCol * ao + (l1 + l2) * sha;\n\t\n    float lr = amp - 2.;\n    vec3 rb = GetRainBow(sId*0.25*lr);\n        \n    if (m < 1.) // wave\n    {\n#ifdef COLOR_FULL\n        col += rb * 0.01 * (15.-length(p)) / (abs(fract(an)-0.5)*2.);\n#endif\n    }\n    else if (m < 2.) // julia skin\n    {\n#ifdef COLOR_FULL\n        col += rb * 0.05 / (abs(fract(an)-0.5)*2.);\t\n#endif\n    }\n    else if (m < 3.) // julia section\n    {\n        col = rb * 2. / (abs(fractus(p + n*3., amp, sId).x)*2.);\n    }\n    \n    float b = dot(sn,normalize(ro-p)) * 0.9;\n    col /= (b * vec3(0.9,0.8,0.1) + pow(b, 0.2)) * (1.0 - d * .02);\n    \n\treturn mix(col, vec3(0), 1.0-exp(-0.004*d*d));\n}\n\nvoid InitVars()\n{\n\tamp = 0.;\n    sId = 0.;\n    an = 0.;\n    countSlices = BASE_COUNT_SLICES;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitVars();\n    \n    float ca = 3.;\n    float ce = 8.;\n    float cd = 12.;\n    \n    if (iMouse.z>0.0)\n    {\n        countSlices = (floor(iMouse.y / iResolution.y * 100.) + 3.)/6.28318;\n        ca = iMouse.x / iResolution.x * -6.28318;\n    }\n    \n\tvec2 uv = (fragCoord*2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 ro = vec3(cos(ca), ce, sin(ca)); ro.xz *= cd;\n    vec3 rov = normalize(-ro);\n    vec3 u = normalize(cross(vec3(0,1,0),rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + 0.5*uv.x*u + 0.5*uv.y*v);\n    \n\tfloat d = march(ro, rd);\n    \n    vec3 c = shade(ro, rd, d);\n\n\tfragColor = vec4(sqrt(c*c*c*1.2),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}