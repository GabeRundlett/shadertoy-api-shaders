{
    "Shader": {
        "info": {
            "date": "1703988178",
            "description": "Human readable fractal with comments to explain each piece.\n\nClick and drag to look around the scene",
            "flags": 0,
            "hasliked": 0,
            "id": "4f23zm",
            "likes": 8,
            "name": "Fractal V3 (Human Readable)",
            "published": 3,
            "tags": [
                "fractal",
                "camera",
                "readable",
                "human",
                "v3",
                "lookaround",
                "forhumans"
            ],
            "usePreview": 0,
            "username": "spenceryonce",
            "viewed": 268
        },
        "renderpass": [
            {
                "code": "// Define macros to simplify repeated operations\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a) // Rotation operation\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5) // Hue shift function\n\n// The main image function\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = vec4(0); // Initialize the fragment color to black\n\n    // Set up camera and resolution\n    vec3 cameraPosition, resolution = iResolution; // Camera position and resolution\n\n    // Calculate view direction with mouse input\n    vec2 mouse = iMouse.xy / iResolution.xy; // Normalize mouse coordinates\n    float mouseAngleX = mix(-0.5, 0.5, mouse.x); // Convert mouse X to an angle\n    float mouseAngleY = mix(-0.5, 0.5, mouse.y); // Convert mouse Y to an angle\n    mat2 mouseRotationX = mat2(cos(mouseAngleX), sin(mouseAngleX), -sin(mouseAngleX), cos(mouseAngleX)); // Rotation matrix for X\n    mat2 mouseRotationY = mat2(cos(mouseAngleY), sin(mouseAngleY), -sin(mouseAngleY), cos(mouseAngleY)); // Rotation matrix for Y\n\n    // Apply mouse rotation to view direction\n    vec3 viewDirection = normalize(vec3((fragCoord.xy - 0.5 * resolution.xy) / resolution.y, 1));\n    viewDirection.xy *= mouseRotationX; // Rotate view direction based on mouse X\n    viewDirection.yz *= mouseRotationY; // Rotate view direction based on mouse Y\n\n    // Initialize ray marching variables\n    float rayLength = 0.0, globalScale = 0.0, scaleMultiplier, stepSize, hueShift, amplitude;\n\n    // Ray marching loop\n    for (float stepCount = 0.0; stepCount < 99.0; stepCount++) {\n        // Calculate position along the view direction\n        vec3 position = globalScale * viewDirection;\n        position.z += iTime * 0.2; // Animate position over time\n        position = sin(position); // Apply sine distortion to position\n        position = R(position, vec3(.577), iTime * .577); // Rotate position over time\n        position = abs(position) - .4; // Apply absolute value and constant offset\n        // Rearrange components of position vector\n        position = position.x < position.y ? position.zxy : position.zyx;\n        position = position.x < position.y ? position.zxy : position.zyx;\n        scaleMultiplier = 1.4; // Initialize scale multiplier\n\n        // Fractal iteration loop\n        for (int fractalIteration = 0; fractalIteration < 5; fractalIteration++) {\n            // Scale and transform the position vector\n            scaleMultiplier *= stepSize = 2.0 / clamp(dot(position, position), .3, 1.2);\n            position = abs(position) * stepSize - vec3(0.95, .01, 4);\n        }\n        amplitude = 1.0; // Set amplitude for clamping\n        position -= clamp(position, -amplitude, amplitude); // Clamp position vector\n        globalScale += stepSize = length(position) / scaleMultiplier; // Update global scale\n\n        // Calculate color adjustment based on the scale multiplier\n        vec3 colorAdjustment = H(scaleMultiplier * .01) + .5;\n        // Update fragment color with exponential falloff\n        fragColor.rgb += colorAdjustment * .01 * exp(-.4 * stepCount * stepCount * stepSize);\n    }\n    fragColor = pow(fragColor, vec4(4)); // Apply gamma correction to the final color\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}