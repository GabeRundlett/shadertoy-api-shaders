{
    "Shader": {
        "info": {
            "date": "1457561339",
            "description": "Simple Perlin-like noise in 2D, homemade custom algorithm. Not perfect but easy to understand for learning.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdcXzH",
            "likes": 11,
            "name": "Simple Perlin 2D ",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "simple",
                "terrain",
                "perlin"
            ],
            "usePreview": 0,
            "username": "bleedingtiger2",
            "viewed": 1103
        },
        "renderpass": [
            {
                "code": "#define _PerlinPrecision 8.0\n#define _PerlinOctaves 8.0\n#define _PerlinSeed 0.0\n\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\t\t\t\t\t// Final heightmap value\n    uv.x += sin(iTime*0.2)*0.4 + 3.0;\t// Used for camera movement\n    uv.y += iTime*0.1;\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta----b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|    |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc----d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    float p = perlin(uv * (0.6+cos(iTime*0.4)*0.15)); // Zoom animation\n    \n    if(p<0.4) // Water\n        fragColor = vec4(0.05, 0.75, 1.0, 1.0);\n    else if(p<0.45) // Sand\n        fragColor = vec4(0.870588, 0.721569, 0.529412, 1.0) + p*0.5;\n    else if(p<0.85) // Grass\n        fragColor = vec4(0.13333, 0.5451, 0.13333, 1.0) + p*0.25;\n    else if(p<0.999) // Rock\n        fragColor = vec4(0.5, 0.5, 0.5, 1.0) * ((p-0.75)*7.0);\n    else // Snow\n        fragColor = vec4(0.9, 0.95, 0.95, 1.0) + p*0.2;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}