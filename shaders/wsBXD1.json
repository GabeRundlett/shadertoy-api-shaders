{
    "Shader": {
        "info": {
            "date": "1553603318",
            "description": "mouse.x sets box ratio AND checkerBoardZoom\nmouse.xy offsets ChecklerBoard\n\ntranslating from domain [0..1] to range [1/zFar,zFar] (and back)  ends up being surprisingly precise \nand efficient and is easily made work-safe",
            "flags": 0,
            "hasliked": 0,
            "id": "wsBXD1",
            "likes": 3,
            "name": "Line2Ratio,pow(b,zFar)/b,Inverse",
            "published": 3,
            "tags": [
                "zoom",
                "aspect",
                "bijection",
                "logn",
                "linear2ratio2linear",
                "libraryofdiscord",
                "1byx",
                "finitism"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 415
        },
        "renderpass": [
            {
                "code": "\n\n//self:  https://www.shadertoy.com/view/wsBXD1\n\n\n//todo, use iMouse.zw to make zoom independent from offset.\n//i have not yet decided \n//on what way to implement this UI is least confusing.\n\n\n//2 problems solved in one:\n//- you have a linear slider domain [0..1]\n//- , and want to scale a zoom level\n//- , to range [1/zFar...zFar] \n//- (to zoom into many places and also zoom out fast)\n//\n//- you want to define an aspect ratio with a linear slider\n//-, and the inverse function of that.\n\n//You have a linear slider domain [0..2] or domain [0..1] \n//(set by iMouse.x)\n//, that outputs a ratio of range [1/zfar,zfar]\n//that is useful to set a zoom.\n//, and its inverse (asserting a constant zFar)\n//its surprsingly simple; pow(b,a)/b AND its inverse\n\n//you resolved the absurdity of the [axiom of infinity]\n//...while; 0.0<zFar=lessThanOrEqualTo(AddressSpace)\n//, range [1/zfar,zfar] is a finite closed interval.\n//\n//the axiom of infinity may aswell; let epsilon < 0.\n\n\n//FoW (in 2d)\n#define viewZoom 4. \n//alost-infinity, bound by address space.\n#define zFar 10.\n\nvec2 fra(vec2 u,vec2 r){u*=viewZoom/r; u-=.5*viewZoom; u.x*=r.x/r.y;return u;}\n//checkerboard by https://www.shadertoy.com/view/4tG3Wh\nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n\n\nfloat aA(vec2 r){return max(r.x,r.y);}\n#define Aa(r) 1./aA(r)\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\n\n\n\n//[from 0 to zFar or 1./zFar and within]\n//i got bored of infinity and infinitessimals and with the assertion of [infinity=zFar] you get [infinitessimal=1/zfar]\n//now, if only we could translate these 2 ratios into one single linear scale, //this has great potential in improving spheretracking logeps():\n//we use logn():\n//logN(x) to logE(x)=log(x) (conversion by division), log(n) is a log() in any EXPLICIT base \nfloat logn(float base,float x){return log2(x)/log2(base);}//may also work with log(x)/log(base), possibly slower or less precise or both, just test it!\n//as long as base=zFar is constant, we only do 1 runtime log() here; else use a LookUpTable of a list of log([zfar0,zFar2,zFar2...]) as divisor\n\n//4 functions below convert bijectively between a 2d-Ratio [from infinitessimal to infinity] and a 1d-linear scale [from  0 to 1]\n//its top 2/4 are subroutines of its bottom 2/4 (with different InOut scaling)\n//[b] is a [bijective constant] that is [uniform within its context] (to uphold a bijection in 2 directions)\n//here: b=zFar>0  (or our lookup table of zFar values)\n//b can be large, because b is always wrapped within log(b) these functions are fast and precise 1x pow() is its slowest\nfloat l2r2(float a,float b){return pow(b,a)/b;}                  //[  0..2] <= [1/b..b] //read this like F# syntax\nfloat r2l2Ws(float a,float b){return logn(b,clamp(a,1./b,b)*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nfloat l2r(float a,float b){return l2r2(a*2.,b);}        //[  0..1] <= [1/b..b]\nfloat r2l(float a,float b){return r2l2Ws(a,b)/2.;}        //[1/b..b] <= [  0..1]\n//just like carthesian2polar()&&polar2carthesian() (BUT it deals with [zFar and 1/zFar] instead)\n//, you may apply the above bijection to the gratient and bake both into a faster/specific (sub) form, that somehow incooperates 1/x\n\nvec2 logn(vec2 base,vec2 x){return log2(x)/log2(base);}//may also work with log(x)/log(base), possibly slower or less precise or both, just \nvec2 r2l2Ws(vec2 a,float b){return logn(vec2(b),clamp(a,1./vec2(b),vec2(b))*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nvec2 l2r2(vec2 a,vec2 b){return pow(b,a)/b;}                   //[  0..2] <= [1/b..b] //read this like F# syntax\nvec2 l2r(vec2 a,float b){return l2r2(a*2.,vec2(b));}          //[  0..1] <= [1/b..b]\n\nfloat ratioDemo(vec2 u,vec2 r,vec4 m\n){float ratio=l2r2(m.x*2./viewZoom,zFar);\n ;m.xy=vec2(ratio,1./ratio)//m.xy marks corner of box\n ;r.x=length(u-m.xy)-.1//dot at box corner\n ;vec2 box=m.xy*.5//cemter of box\n //taxicap-distance to box xenter (distante2Box):\n ;box=abs(u-box)-box\n ;box.x=max(box.x,box.y)\n ;r.x=min(abs(r.x),abs(box.x))//composite and abs(line)\n ;r.x=ss(.5,r.x-.05)//smoothstep\n ;return r.x;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){u=fra(u,iResolution.xy)\n ;vec4 m=vec4(fra(iMouse.xy,iResolution.xy),fra(iMouse.zw,iResolution.xy))\n ;float anchor=ss(.5,length(u)-.1)//a dot inscreenspace center as screenspace anchor to not get lost.\n\n ;float offset=.4 //offset screenspace center\n  ;u+=offset*viewZoom\n  ;m.xz+=offset*viewZoom//offset context as we only care for positive values\n  // 1/x_zooming checkerboard raster\n ;float c=checkerBool(4.*(m.xy-u+vec2(0,viewZoom*offset))/l2r2(m.x,zFar))\n\n ;float now=1.-ss(.5,min(u.x,u.y))//mark x=0, y=0 with a corner\n ;//float wavelength=abs(m.z)\n ;//u.x/=wavelength\n ;//m/=wavelength\n ;float g=ratioDemo(u,iResolution.xy,m)\n ;//o=vec4(fract(iDate.w)+i.x/iResolution.x)\n ;g=max(g,anchor)\n ;o=vec4(g,now,c,1);}\n\n\n\n//code dumpster for later composites.\n\n/*\n//c0env*() asserts normalizedTime, so that a period is ==1.\nfloat c0env(vec2 u,vec4 m\n){m.y-=m.x//offset by start\n ;u.x-=m.x//offset by start\n ;if(u.x<0.)return ss(-2.-u.y,.01)//left  of envelope multiply by *0\n ;if(u.x>m.y)return ss(-2.-u.y,.01)//right of envelope multiply by *0 \n ;if(floor(m.y)<u.x)return ss(-u.y,.01)//right of full wave multiply by *0\n ;//return *1 full volume\n ;float y=sin(u.x*acos(-1.)*2.)-u.y\n ;return ss(y,.01);}\n/**/\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}