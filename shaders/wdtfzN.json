{
    "Shader": {
        "info": {
            "date": "1655685256",
            "description": "https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/Aerophones.pdf\n\nMouse + Keyboard: See comment in Image",
            "flags": 48,
            "hasliked": 0,
            "id": "wdtfzN",
            "likes": 11,
            "name": "Aerophones in Flatland",
            "published": 3,
            "tags": [
                "sound",
                "simulation",
                "aerophone"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "/*\nGLSL implementation of:\n  https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/Aerophones.pdf\n\nKeyboard:\n  Toggle controls, current state is visible at the left side.\n  0 = inflow (mouse)\n  1 = wall (mouse)\n  2 = erase (mouse)\n  3 = draw ellipse\n  4 = draw trumpet\n  5 = trumpet path A\n  6 = trumpet path B\n\nBuffer D: interaction\nCommon: simulation + physical constants\n*/\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    vec4 M = texelFetch(iChannel0, ivec2(O), 0);\n    if (false)\n    {\n        C = M;\n        //C.xy = C.yx;\n        C.xy *= 1. * deltat / deltas;\n        C.xy += .5;\n        C.w = .5 + C.w / 2e5;\n        //C.xyz = C.xyw;\n        C.xyz = mix(C.xyw, vec3(1,0,1), C.z);\n    }\n    else\n    {\n        float f = M.a;\n        f /= 2e4;\n        //f = sign(f) * sqrt(abs(f / 5e4));\n        //f = sign(f) * log(max(0., abs(f / 1e2))) / log(2e4 / 1e2);\n        C = vec4(1,.2,0,0) * max(0., f) + vec4(0,.05,1,0) * max(0., -f);\n        C = mix(C, vec4(1,0,1,0), M.z);\n    }\n    \n    if (O.x < 10.)\n    {\n        int key = 0x30 + int(O.y/iResolution.y*10.);\n        float v = texelFetch(iChannel2, ivec2(key, 2), 0).r;\n    \tC = mix(\n            vec4(.2),\n            vec4(1,0,0,0),\n            key == 0x30 || key == 4 ? 1.-v : v\n        );\n    }\n\n    if (false)\n    {\n        ivec2 I = ivec2(O);\n        vec4 U = 1. - vec4(I, iResolution.xy - 1. - vec2(I)) / 6.;\n        float border = max(0., max(max(U.x, U.y), max(U.z, U.w)));\n        C = vec4(border);\n    }\n    \n    C = sqrt(C);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// offset to reference temperature [K]\nconst float deltaT = 0.;\n\n// density [kg / mÂ³]\nconst float rho    = 1.1760    * (1. - 0.00335 * deltaT);\n\n// speed of sound at reference pressure [m / s]\nconst float c      = 3.4723e2  * (1. + 0.00166 * deltaT);\n\nconst float gamma  = 1.4017    * (1. - 0.00002 * deltaT);\n\nconst float mu     = 1.8460e-5 * (1. + 0.0025  * deltaT);\n\nconst float P      = 0.7073    * (1. - 0.0004  * deltaT);\n\n// time-step [s]\n//const float deltat = 7.81e-6;\n//const float deltat = 7.70e-6;\n//const float deltat = 7.81e-7;\nconst float deltat = 7.81e-6 / 4.;\n\n// grid resolution [m]\nconst float deltas = 3.83e-3;\n\n// air pressure at equilibrium [Pa]\nconst float P0     = 1.01325e5;\n\nconst float betac  = 1.2;\n\nfloat next_p(vec4 L, vec4 M, vec4 D, float sigmaprime_M)\n{\n    // local speed of sound\n    float cn = c;\n    if (true)\n        cn *= clamp(1. + betac * M.a / P0, 0.9, 1.1);\n    \n    vec2 dvdxy = (M.xy - vec2(L.x, D.y)) / deltas;\n    float divergencev = dvdxy.x + dvdxy.y;\n\n    float next_p_M = (M.a - rho * cn * cn * deltat * divergencev) / (1. + sigmaprime_M * deltat);\n    return next_p_M;\n}\n\nvec4 fetch(sampler2D iChannel, ivec2 RI, ivec2 I, ivec2 dI)\n{\n    I = min(RI - 1, max(ivec2(0, 0), I + dI));\n    return texelFetch(iChannel, I, 0);\n}\n\nvoid boundary(out float sigmaprime, out float beta, ivec2 RI, ivec2 I, float wall)\n{\n    vec4 U = 1. - vec4(I, RI - 1 - I) / 6.;\n    float border = max(0., max(max(U.x, U.y), max(U.z, U.w)));\n\n    beta = 1. - wall;\n    float sigma = .5 / deltat * border;\n    sigmaprime = 1. - beta + sigma;\n}\n\nvec4 update(sampler2D iChannel, vec3 iResolution, ivec2 O)\n{\n    ivec2 I = ivec2(O);\n    ivec2 RI = ivec2(iResolution.xy);\n\n    /*\n        A T -\n        L M R\n        - D B\n\n\t\tx: vx M -> R\n\t\ty: vy M -> T\n\t\tb:  b @ M\n\t\ta:  p @ M\n    */\n    vec4 A = fetch(iChannel, RI, I, ivec2(-1, +1));\n    vec4 T = fetch(iChannel, RI, I, ivec2( 0, +1));\n    vec4 L = fetch(iChannel, RI, I, ivec2(-1,  0));\n    vec4 M = fetch(iChannel, RI, I, ivec2( 0,  0));\n    vec4 R = fetch(iChannel, RI, I, ivec2(+1,  0));\n    vec4 D = fetch(iChannel, RI, I, ivec2( 0, -1));\n    vec4 B = fetch(iChannel, RI, I, ivec2(+1, -1));\n    \n    float sigmaprime_T, sigmaprime_M, sigmaprime_R;\n    float beta_T, beta_M, beta_R;\n    boundary(sigmaprime_T, beta_T, RI, I + ivec2( 0, +1), T.b);\n    boundary(sigmaprime_M, beta_M, RI, I + ivec2( 0,  0), M.b);\n    boundary(sigmaprime_R, beta_R, RI, I + ivec2(+1,  0), D.b);\n\n    float next_p_T = next_p(A, T, M, sigmaprime_T);\n    float next_p_M = next_p(L, M, D, sigmaprime_M);\n    float next_p_R = next_p(M, R, B, sigmaprime_R);\n    \n    vec2 betav_M = min(vec2(beta_M), vec2(beta_R, beta_T));\n    vec2 next_vb = vec2(0);\n\n    vec2 next_gradient_p = (vec2(next_p_R, next_p_T) - next_p_M) / deltas;\n    vec2 next_v\n        = ( betav_M * M.xy\n          - betav_M * betav_M * deltat * next_gradient_p / rho\n          + sigmaprime_M * deltat * next_vb\n          )\n        / ( beta_M\n            + sigmaprime_M * deltat\n          )\n        ;\n\n    return vec4(next_v, M.b, next_p_M);\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float i, float j)\n{\n    vec2 v = b - a;\n    vec2 l = p - a;\n    float h = dot(l, v) / dot(v, v);\n    return length(l - v * clamp(h, i, j));\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    return sdLine(p, a, b, 0., 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n\n    bool inflow = texelFetch(iChannel2, ivec2(0x30, 2), 0).r == 0.;\n    bool wall   = texelFetch(iChannel2, ivec2(0x31, 2), 0).r != 0.;\n    bool erase  = texelFetch(iChannel2, ivec2(0x32, 2), 0).r != 0.;\n    bool pipe   = texelFetch(iChannel2, ivec2(0x33, 2), 0).r == 0.;\n    bool ellipse= texelFetch(iChannel2, ivec2(0x34, 2), 0).r != 0.;\n    bool pathA  = texelFetch(iChannel2, ivec2(0x35, 2), 0).r != 0.;\n    bool pathB  = texelFetch(iChannel2, ivec2(0x36, 2), 0).r != 0.;\n    bool mouse  = iMouse.z >= 0.;\n    bool init = iFrame < 20 || (texelFetch(iChannel2, ivec2(0x33, 1), 0).r != 0.) || (texelFetch(iChannel2, ivec2(0x34, 1), 0).r != 0.);\n    float rmouse = length(iMouse.xy - O);\n    \n    //if (false)\n    if (ellipse)\n    {\n        //C = vec4(0.);\n        //C.x += 1e3 * exp(-4. * pow((O.x - iResolution.x / 2.) / 50., 2.));\n        //C.y += 1e3 * exp(-4. * pow((O.y - iResolution.y / 2.) / 50., 2.));\n        //C.x += 1e3* exp(-4. * pow((length(O - iResolution.xy / 2.)) / 50., 2.));\n        \n        vec2 o = (O - iResolution.xy / 2.) / iResolution.x;\n        vec2 a = o + vec2(.1, 0);\n        vec2 b = o - vec2(.1, 0);\n        float r = length(a) + length(b);\n        C.b = float(r > .4);\n        if (init)\n            C.a = exp(-pow(length(a) / .01, 2.)) * 1e5;\n    }\n    if (pipe)\n    {\n        //C = vec4(0);\n        // Position [mm]\n        vec2 o = (O - floor(iResolution.xy / 2.) + .5) * deltas / 1e-3;\n        float r = 1e3;\n        if (pathA)\n        {\n            r = min(r, sdLine(o, vec2(-400, 30), vec2(-30, 30)) - 3.);\n            r = min(r, sdLine(o, vec2(30, 30), vec2(400, 30)) - 3.);\n        }\n        else\n        {\n            r = min(r, sdLine(o, vec2(-400, 30), vec2(400, 30)) - 3.);\n        }\n        if (pathB)\n        {\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(-200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(-140, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(200, -150), vec2(200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(140, -90), vec2(140, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(200, -150)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(140, -90)) - 3.);\n            r = min(r, sdLine(o, vec2(-400, -30), vec2(400, -30)) - 3.);\n        }\n        else\n        {\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(-200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(-140, 30)) - 3.);\n            r = min(r, sdLine(o, vec2(200, -150), vec2(200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(140, -90), vec2(140, 30)) - 3.);\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(200, -150)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(140, -90)) - 3.);\n            r = min(r, sdLine(o, vec2(-400, -30), vec2(-200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -30), vec2(140, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(200, -30), vec2(400, -30)) - 3.);\n        }\n        r = min(r, sdLine(o, vec2(-400, 30), vec2(-400, -30)) - 3.);\n        C.b = float(r < 0.);\n        if (init)\n            C.a = length((o - vec2(-370., 0))) < 30. ? 1e5 : 0.;\n    }\n\n    if (mouse)\n    {\n        if (inflow)\n        {\n            float r = 1. - rmouse / 10.;\n            if (r > 0.)\n            {\n                r = 3. * r * r - 2. * r * r * r;\n                C.a += r * 1e5 * (1. - C.b);\n\n            }\n        }\n        if (wall)\n        {\n            if (rmouse < 3.)\n            {\n                C.b = 1. - float(erase);\n                C.a *= (1. - C.b);\n            }\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}