{
    "Shader": {
        "info": {
            "date": "1593017661",
            "description": "Volumetric projector laser show forked from https://www.shadertoy.com/view/wtlczl",
            "flags": 0,
            "hasliked": 0,
            "id": "WlfcWj",
            "likes": 13,
            "name": "Projector Laser Show",
            "published": 3,
            "tags": [
                "projection",
                "laser"
            ],
            "usePreview": 0,
            "username": "Danguafer",
            "viewed": 690
        },
        "renderpass": [
            {
                "code": "// Forked from https://www.shadertoy.com/view/wtlczl\n\n\nvec3 eye \t\t\t\t\t= vec3(0.f,0.f,5.f);\nvec4 sphere\t\t\t\t\t= vec4(0.f,0.f,0.f, 0.7f);\n// vec3 spotLightDir \t\t\t= normalize(vec3(0.0f,0.0f,-1.f)); // front\nvec3 spotLightDir \t\t\t= normalize(vec3(-0.75f,-0.15f,-1.f));\nvec3 spotLightColor\t\t\t= vec3(0.7f);\nvec3 ambientColor \t\t\t= vec3(0.3f);\nfloat camerafov \t\t\t= 45.f;\nfloat scatteringProbability = 1.f;\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nbool anyHit_sphere(vec3 rayEye, vec3 rayDir, vec4 sphere) {\n    vec3 a = sphere.xyz - rayEye;\n    float a1 = dot(a, rayDir);\n    vec3 a2 = a - a1 * rayDir;\n    float distSq = dot(a2,a2);\n    float rSq = sphere.w*sphere.w;\n    if (distSq < rSq) {\n        float cSq = rSq - distSq;\n        float t = a1 - sqrt(cSq);\n        return t >= -0.01f;\n    } else\n        return false;\n}\n\nbool closestHit_sphere(vec3 rayEye, vec3 rayDir, vec4 sphere, out vec3 hit, out vec3 normal) {\n    vec3 a = sphere.xyz - rayEye;\n    float a1 = dot(a, rayDir);\n    vec3 a2 = a - a1 * rayDir;\n    float distSq = dot(a2,a2);\n    float rSq = sphere.w*sphere.w;\n    if (distSq < rSq) {\n        float cSq = rSq - distSq;\n        float t = a1 - sqrt(cSq);\n        hit = rayEye + rayDir * t;\n        normal = normalize(vec3(hit-sphere.xyz));\n        return true;\n    } else\n        return false;\n}\n\nbool closestHit_plane(vec3 rayEye, vec3 rayDir, vec4 plane, out vec3 hit, out vec3 normal) {\n\tvec3 p0 = plane.xyz * plane.w;\n    vec3 n = -plane.xyz;\n    float d = dot(p0-rayEye,n)/dot(rayDir, n);\n    hit = rayEye + rayDir * d;\n    normal = n;\n    return true;\n}\n\nfloat saturate(float x) { return clamp(x, 0.f, 1.f); }\n\nbool inLightFoV(vec3 Ln, vec3 spotLightDir, float cosHalfAngle) {\n    // return true;\n    return dot(Ln, -spotLightDir) > cosHalfAngle;\n}\n\nvec2 lightUV(vec3 Ln, float fov, vec3 lightLookVector, vec3 lightUpVector, vec3 lightRightVector) {\n    float x = dot(Ln, lightRightVector);\n    float y = dot(Ln, lightUpVector);\n    float d = -1. / dot(Ln, lightLookVector); // 'un-normalize Ln'\n    \n    float q = 1. / (2. * tan(fov));\n    \n    float u = d * x * q + 0.5;\n    float v = d * y * q + 0.5;\n\n    return vec2(u, v);\n}\n\nvoid shading(vec3 Nn, vec3 Ln, vec3 lightColor, inout vec3 result) {\n \t// Diffuse (lambertian) reflectance\n\tfloat dotNL = saturate(dot(Nn, Ln));\n\tvec3 diffuse = dotNL * lightColor;\n    result += diffuse;\n}\n\n// Fast inverse for affine matrix:\nmat4 affineInverse(mat4 m) {\n\tmat3 rot;\n\trot[0] = m[0].xyz;\n\trot[1] = m[1].xyz;\n\trot[2] = m[2].xyz;\n\n\tmat3 invRot = transpose(rot);\n\n\tmat4 result;\n\tresult[0] = vec4(invRot[0], 0);\n\tresult[1] = vec4(invRot[1], 0);\n\tresult[2] = vec4(invRot[2], 0);\n\tresult[3] = vec4(-(invRot * m[3].xyz), 1);\n\treturn result;\n}\n\nvoid SolveQuadratic(float a, float b, float c, out float minT, out float maxT)\n{\n\tfloat discriminant = b*b - 4.0*a*c;\n\n\tif (discriminant < 0.0)\n\t{\n\t\t// no real solutions so return a degenerate result\n\t\tmaxT = 0.0;\n\t\tminT = 0.0;\n\t\treturn;\n\t}\n\n\t// numerical receipes 5.6 (this method ensures numerical accuracy is preserved)\n\tfloat t = -0.5 * (b + sign(b)*sqrt(discriminant));\n\tfloat closestT = t / a;\n\tfloat furthestT = c / t;\n\n\tif (closestT > furthestT)\n\t{\n\t\tminT = furthestT;\n\t\tmaxT = closestT;\n\t}\n\telse\n\t{\n\t\tminT = closestT;\n\t\tmaxT = furthestT;\n\t}\n}\n\nvoid IntersectCone(vec3 rayOrigin, vec3 rayDir, mat4 invConeTransform, float tanAperture, float height, out float minT, out float maxT)\n{\n\tvec4 localOrigin = invConeTransform * vec4(rayOrigin, 1.0);\n\tvec4 localDir = invConeTransform * vec4(rayDir, 0.0);\n\n\tfloat tanTheta = tanAperture * tanAperture;\n\n\tfloat a = localDir.x*localDir.x + localDir.z*localDir.z - localDir.y*localDir.y*tanTheta;\n\tfloat b = 2.0*(localOrigin.x*localDir.x + localOrigin.z*localDir.z - localOrigin.y*localDir.y*tanTheta);\n\tfloat c = localOrigin.x*localOrigin.x + localOrigin.z*localOrigin.z - localOrigin.y*localOrigin.y*tanTheta;\n\n\tSolveQuadratic(a, b, c, minT, maxT);\n\n\tfloat y1 = localOrigin.y + localDir.y*minT;\n\tfloat y2 = localOrigin.y + localDir.y*maxT;\n\n\tif (y1 > 0.0 && y2 > 0.0)\n\t{\n\t\t// both intersections are in the reflected cone so return degenerate value\n\t\tminT = 0.0;\n\t\tmaxT = -1.0;\n\t}\n\telse if (y1 > 0.0 && y2 < 0.0)\n\t{\n\t\t// closest t on the wrong side, furthest on the right side => ray enters volume but doesn't leave it (so set maxT arbitrarily large)\n\t\tminT = maxT;\n\t\tmaxT = 10000.0;\n\t}\n\telse if (y1 < 0.0 && y2 > 0.0)\n\t{\n\t\t// closest t on the right side, largest on the wrong side => ray starts in volume and exits once\n\t\tmaxT = minT;\n\t\tminT = 0.0;\n\t}\n}\n\nfloat InScatter(vec3 start, vec3 dir, vec3 lightPos, float d, vec3 attenuation)\n{\n\t// calculate quadratic coefficients a,b,c\n\tvec3 q = start - lightPos;\n\n\tfloat b = dot(dir, q);\n\tfloat c = dot(q, q);\n\n\t// evaluate integral\n\tfloat s = 1.0f / sqrt(c - b*b);\n\n\tfloat l = s * (atan((d + b) * s) - atan(b*s));\n\n    // attenuation:\n\t//float lightDist = length(q);\n\t//l = l * saturate(1.0 / dot(vec3(1, sqrt(lightDist), lightDist), attenuation));\n\treturn l;\n}\n\nvec4 get_image(vec2 uv) {\n    uv = 2.0 * (uv - 0.5);\n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 nuv = uv;\n        float n = float(i) * 0.1 + iTime * 100.0;\n        nuv.x += sin(n*(0.8 + sin(iTime / 200.0) * 0.1))*0.5;\n        nuv.y += cos(n*(0.5 + sin(iTime / 100.0) * 0.1))*0.5;\n    \tcol += vec3(smoothstep(0.05,0.0,length(nuv)));\n\t}\n    return vec4(col.x,0.0,0.0,1.0);\n\t//return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = rayDirection(camerafov, iResolution.xy, fragCoord.xy);\n\n    float spotLightHalfAngle = 25.0f + sin(iTime) * 10.0f;\n    // float spotLightHalfAngle = 35.0f;\n    if (iMouse.z > 0.5f)\n     \t// spotLightDir = normalize(vec3(-normalize(iMouse.xy - iResolution.xy / 2.f), -1.f));\n        spotLightDir = normalize(vec3(sin(6.28*iMouse.x/iResolution.x), cos(3.14*iMouse.y/iResolution.y), cos(6.28*iMouse.x/iResolution.x)));\n    vec3 spotLightOrigin \t= (sphere.xyz - spotLightDir) * 1.4;\n    vec3 lightUp = normalize(cross(spotLightDir, vec3(1,0,0)));\n    vec3 lightRight = cross(spotLightDir, lightUp);\n    float spotfov = radians(spotLightHalfAngle);\n    float cosSpotHalfAngle = cos(spotfov);\n\n    vec3 result = vec3(0.f);\n\n    // lit sphere:\n    vec3 hitPos, hitNormal;\n    float hitDist = 1e5;\n    if (closestHit_sphere(eye, rayDir, sphere, hitPos, hitNormal)) {\n    // if (closestHit_plane(eye, rayDir, vec4(0,0,-1, 0), hitPos, hitNormal)) {\n        hitDist = length(hitPos-eye); // used for cone\n        \n        // for each spotlight:\n        vec3 Ln = normalize(spotLightOrigin-hitPos);\n        if (inLightFoV(Ln, spotLightDir, cosSpotHalfAngle)) {\n            // gobo:\n            vec2 goboUV = lightUV(Ln, spotfov, spotLightDir, lightUp, lightRight);\n            vec4 goboColor = get_image(goboUV);\n            \n        \tshading(hitNormal, Ln, goboColor.xyz * goboColor.a * spotLightColor, result);\n        }\n        \n        shading(hitNormal, normalize(vec3(0.f,0.f,1.f)), ambientColor, result); // directional light\n    } else {\n        // checkerboard background\n        int ix = int(fragCoord.x);\n        int iy = int(fragCoord.y);\n        \n        result = (ix / 16) % 2 == 0 ^^ (iy / 16) % 2 == 0 ? vec3(0.1f) : vec3(0.15f);\n    }\n    \n    // volumetric fog:\n\tfloat height = 30.0;\n\tfloat minT = 0.0;\n\tfloat maxT = 0.0;\n\n\tmat4 LightToWorld;\n\tLightToWorld[0] = vec4(lightRight, 0.0);\n\tLightToWorld[1] = vec4(-spotLightDir, 0.0); // change of basis from XYZ to X-ZY to rotate forward facing cone downward\n\tLightToWorld[2] = vec4(lightUp, 0.0);\n\tLightToWorld[3] = vec4(spotLightOrigin, 1);\n\t\t\t\n\tmat4 invLightToWorld = affineInverse(LightToWorld);\n\n\tfloat tanSpotAngle = tan(radians(spotLightHalfAngle));\n\n\tIntersectCone(eye, rayDir, invLightToWorld, tanSpotAngle, height, minT, maxT);\n\n\tminT = max(minT, 0.f);\n\tmaxT = min(maxT, hitDist);\n\tfloat dt = max(0.0, maxT - minT);\n\n    // analytic fog integral:\n\tvec3 scatter = spotLightColor * /* vec3(0.2, 0.5, 0.8) * */\n        max(0.f, InScatter(eye + rayDir*minT, rayDir,spotLightOrigin, dt, vec3(1,1,1))) \n        * scatteringProbability * 0.5;\n    \n    // ray marched gobo fog:\n    vec3 coneGoboColor = vec3(0.f);\n    for (int i = 0; i < 16; ++i) {\n    \tfloat t = mix(minT, maxT, float(i) / float(16-1));\n        vec3 p = eye + rayDir*t; // point in volume\n        vec3 Ln = normalize(spotLightOrigin-p);\n        // shadow ray:\n        if (!anyHit_sphere(p, Ln, sphere)) \n        {\n        \tvec2 goboUV = lightUV(Ln, spotfov, spotLightDir, lightUp, lightRight);\n        \tvec4 goboColor = get_image(goboUV);\n        \tconeGoboColor += goboColor.xyz * goboColor.a * spotLightColor;\n        }\n    }\n    coneGoboColor /= 16.f;\n\n\tresult += scatter * coneGoboColor;\n    \n    fragColor = vec4(result, 1.f);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}