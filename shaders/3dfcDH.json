{
    "Shader": {
        "info": {
            "date": "1584637564",
            "description": "Graphs the inverse of complex functions.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dfcDH",
            "likes": 3,
            "name": "Complex Grid Mapping",
            "published": 3,
            "tags": [
                "grid",
                "graph",
                "complexnumbers"
            ],
            "usePreview": 0,
            "username": "encryptedmaze",
            "viewed": 469
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535897932384626433832795;\nvec2 cmul (vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);\n}\nvec2 cexp (vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\nvec2 clog (vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\nvec2 cpow (vec2 z, vec2 a) {\n\treturn cexp(cmul(a, clog(z)));\n}\nfloat animate() {\n\treturn -1.0f * cos((iTime) / 5.0f) * 0.996f + 1.004f;\n}\n// Any complex-valued function. The inverse of this function is graphed.\nvec2 transformation (vec2 uv) {\n\tvec2 ret = cpow(uv, vec2(animate(), 0.0f));\n    // vec2 pos = (vec2(iMouse.xy / iResolution.xy) - vec2(0.5f)) * 2.5f;\n    // vec2 ret = cpow(uv, cexp(pos));\n    // vec2 ret = vec2(uv.x + sin(uv.y + iTime * 0.05f) * 0.5f, uv.y + sin(uv.x + iTime * 0.1f) * 0.5f);\n\treturn ret;\n}\n// Compute gradient vector (this is used to keep line width consistent)\nvec2 gradient (vec2 uv, vec2 delta) {\n\treturn (transformation(uv + delta) - transformation(uv)) / delta;\n}\n// Creates smooth line edges\nvec2 smoothstep2d (float lineWidth, vec2 pos) {\n\tvec2 ret;\n\tret.x = smoothstep(-lineWidth, 0.0f, pos.x) - smoothstep(0.0f, lineWidth, pos.x);\n\tret.y = smoothstep(-lineWidth, 0.0f, pos.y) - smoothstep(0.0f, lineWidth, pos.y);\n\treturn ret;\n}\n// mod of each element in a vec2\nvec2 mod2d (vec2 a, vec2 b) {\n\treturn vec2(mod(a.x, b.x), mod(a.y, b.y));\n}\n// Draws the grid using an input \"UV\" vector\nvec3 drawGrid(vec2 uv, float lineWidth) {\n\tfloat modulator = 0.25f;\n\t\n\t// Compute \"Distortion\" to prevent variable line width\n\tlineWidth *= length(gradient(uv, vec2(0.0005f)));\n\t\n    // \"Transformed Vector\"\n    // take the input \"uv\" vector an apply a function to it\n    vec2 tv = transformation(uv) + vec2(modulator / 2.0f);\n    \n    // Some modular arithmetic to draw multiple lines\n\tvec2 gv = vec2(floor(tv.x / modulator), floor(tv.y / modulator));\n   \tvec2 mv = mod(tv, vec2(modulator));\n\tvec2 line = smoothstep2d(lineWidth, mv - vec2(modulator / 2.0f));\n\t\n\t// 3blue1brown style line colors\n\tvec3 col = vec3(0.0f, 0.15f, 0.2f) * length(line);\n    if (mod(gv.x, 2.0f) == 0.0f) col = max(col, vec3(0.0f, 0.6f, 0.8f) * vec3(line.x));\n\tif (mod(gv.y, 2.0f) == 0.0f) col = max(col, vec3(0.0f, 0.6f, 0.8f) * vec3(line.y));\n\tif (gv.x == 0.0f) col = max(col, vec3(line.x));\n\tif (gv.y == 0.0f) col = max(col, vec3(line.y));\n\t\n\treturn col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat lineWidth = 0.015f;\n\tint sampleCount = 3;\n\tfloat sampleSize = 0.001f;\n    // Get \"input\" uv vector\n\tvec2 uv = (fragCoord - 0.5f * iResolution.xy) / (iResolution.y) * vec2(5.0f, -5.0f);\n\tvec3 col = drawGrid(uv, lineWidth);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}