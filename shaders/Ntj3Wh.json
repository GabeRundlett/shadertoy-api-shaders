{
    "Shader": {
        "info": {
            "date": "1623825283",
            "description": "https://www.shacknews.com/\n\ncheck out my game! https://store.steampowered.com/app/1153850/Super_Space_Towers/",
            "flags": 0,
            "hasliked": 0,
            "id": "Ntj3Wh",
            "likes": 3,
            "name": "ShackNews3D",
            "published": 3,
            "tags": [
                "logo"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 613
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define TWO_PI 6.2831853\n\n//------------------------------------------------------------------------\n// Distance Funcs\n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat circle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Text\nfloat char(inout vec2 p, int C,float d,float w)\n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.)\n    {\n        p.x -= w;\n        return d;\n    }\n    vec4 cc = textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , dFdx(p/16.),dFdy(p/16.) );\n    p.x -= w;\n    return min(d,(cc.w-0.505));\n}\n\nfloat fontDist(vec2 p)\n{\n    p.x *= 2.0;\n    p.x += 5.8;\n    p.y -= 1.0;\n    p.y *= 0.7;\n    \n    float d = 1e5;\n    float w = 0.514;\n    \n    d =  char(p,83,d,w);\n    d =  char(p,72,d,w);\n    d =  char(p,65,d,w);\n    d =  char(p,67,d,w);\n    d =  char(p,75,d,w+0.2);\n    d =  char(p,78,d,w);\n    d =  char(p,69,d,w);\n    d =  char(p,87,d,w);\n    d =  char(p,83,d,w+5.2);\n    p = 1.0-p;\n    d =  char(p,50,d,w);\n    d =  char(p,53,d,w+0.2);\n    d =  char(p,89,d,w);\n    d =  char(p,69,d,w);\n    d =  char(p,65,d,w);\n    d =  char(p,82,d,w);\n    d =  char(p,83,d,w);\n    \n    return d;\n}\n\nfloat CircleText(vec2 p)\n{\n\tfloat r = length(p*1.3);\n\tfloat a = atan(p.y,p.x);\n    float yp = (2.0* PI*(r*r));\n    float xp = -a;\n    vec2 p2 = vec2(xp, yp);\n    return fontDist(p2)+0.01;\n}\n\nfloat DateText(vec2 p)\n{\n    float d = 1e5;\n    float w = 0.5;\n    p*=14.0;\n    p.y += 0.77;\n    p.x -= 4.27;\n    d =  char(p,50,d,w);\n    d =  char(p,48,d,w);\n    d =  char(p,50,d,w);\n    d =  char(p,49,d,w-13.1);\n    d =  char(p,49,d,w);\n    d =  char(p,57,d,w);\n    d =  char(p,57,d,w);\n    d =  char(p,54,d,w);\n    return d;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float dist = 5.5;\n    float vv = sin(iTime*1.1);\n    float yoff = 1.5+vv;\n    dist += vv*0.5;\n    float an = PI*0.5;\n\tcamPos = vec3(dist*sin(an),yoff,dist*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 doModel( vec3 p )\n{\n    vec2 res = vec2(0.0,0.0);\t\t\t// distance,material index\n    \n    vec3 pp = p;\n    pp.xz*=rot(iTime-1.1f);\n    float d1 = sdCylinder(pp,vec3(-0.2,0.0,0.0),vec3(0.2,0.0,0.0),2.0)-0.15;\n    \n    p.y += 2.2;\n    float d2 = sdPlane(p);\n    \n    res = opU(vec2(d1,2.0),vec2(d2,1.0));\n    return res;\n}\n\nvec3 GetShack(vec2 p)\n{\n    vec3 background = vec3(0.04);\n\n    //p.y *= 1.2+sin(fract(iTime*0.9)*6.28)*0.1;// bounce\n    //p.x *= 1.2+cos(fract(iTime*0.9)*6.28)*0.1;// bounce\n\n    \n    float blur = 0.005;\n    \n    //vec3 background = vec3(0.0);\n    vec3 grey = vec3(0.2,0.2,0.2)*0.45;\n    vec3 txtcol = vec3(0.8,0.8,0.8)*0.45;\n    vec3 blue = vec3(0.2,0.6,0.6)*0.45;\n    \n    float _d = length(p);\n    vec3 color = background;\n    float d = smoothstep(0.0,blur, _d-0.3);\n    color = mix(grey,color,d);\n\n\n    d = _d-0.23;\n    d = abs(d)-0.01;\n    d = smoothstep(0.0,blur, d);\n    color = mix(blue,color,d);\n\n    d = _d-0.51;\n    d = abs(d)-0.012;\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n\n\n\tvec2 tri = vec2(0.22,-0.13); // width, height\n\n\tfloat td = sdTriangleIsosceles( p-vec2(-0.05,0.18), tri );\n    d = smoothstep(0.0,blur, td-0.0125);\n    color = mix(grey,color,d);\n\n    d = smoothstep(0.0,blur, td);\n    color = mix(txtcol,color,d);\n    \n    \n    vec2 pp = p-vec2(-0.05,0.0);\n    \n    d = sdOrientedBox(pp,vec2(-0.09,0.05),vec2(-0.0795,-0.14),0.05);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n    \n    d = sdOrientedBox(pp,vec2(0.09,0.05),vec2(0.0795,-0.14),0.05);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n    \n    d = circle(p+vec2(0.07,0.055),0.0125);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n\n    d = CircleText(p);\n    d = min(d,DateText(p));\n    d = smoothstep(0.0,0.03,d);\n    if (p.y > 0.1)\n        color = mix(txtcol,color,d);\n    else\n        color = mix(blue,color,d);\n\n    return color;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\nvec3 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n        float f = mod( floor(1.0*pos.z) + floor(1.0*pos.x), 2.0);\n        vec3 col2 = vec3(0.05,0.35,0.45);\n        vec3 col1 = col2*0.4;\n\t    return mix(col1,col2,f);\n    }\n\n    mat2 m = rot(iTime-1.1f);\n    nor.xz*=m;\n\n    vec3 dir = vec3(1.0,0.0,0.0);\n    float dif = dot(nor,dir);\n    \n    if (abs(dif)<0.01)\n        return vec3(0.04);\n    vec3 p = pos;\n    p.xz*=m;\n    vec2 uv = vec2(p.y,p.z);\n    uv *= rot(-PI*0.5);\n    uv.x *= sign(dif);\n    uv *= 0.27;\n    return GetShack(uv);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n\n    // hack in some specular\n    vec3 ref = reflect(rd, nor);\n\tfloat spe = max(dot(ref, lig), 0.0);\n\tdif += pow(spe,16.0);\n\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.0075*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 40.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<120; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n  \tvec3 col = mix( vec3(0.2, 0.2, 0.5), vec3(0.5, 0.7, 1.0), fragCoord.y / iResolution.y );\n    col *= 0.5;\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}