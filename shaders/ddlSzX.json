{
    "Shader": {
        "info": {
            "date": "1669378715",
            "description": "Reproducing a common op-art inspired triangulated spiral pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddlSzX",
            "likes": 37,
            "name": "Triangulated Spiral Pattern",
            "published": 3,
            "tags": [
                "triangle",
                "spiral",
                "optical",
                "pattern",
                "polar",
                "art"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 450
        },
        "renderpass": [
            {
                "code": "/*\n\n    Triangulated Spiral Pattern\n    ---------------------------\n    \n    This is a pretty common op-art related tessellated spiral pattern -- or \n    double spiral pattern, if you prefer. It's a pretty simple variation, but \n    there are other far more interesting ones out there. There'd be cleverer \n    ways to produce it, and I'm sure the code golf crowd could make a much more \n    concise version. However, I took a direct approach and used a triangle grid, \n    which was converted to polar coordinates.\n    \n    For anyone not familiar with the geometric double spiral trick, you take a \n    regular circular pattern, then shift the top and bottom halves by a radial \n    cell unit.\n    \n    I happen to like the flat shaded black and white op-art look, but figured \n    I should at least attempt to lift the pattern a bit, so added highlights \n    and a splash of color. Grey tones with a splash of color is a design cliche, \n    but it saves having to think of color combinations to use. :)\n    \n    \n    Other examples:\n    \n    // Another polar black and white pattern. The spiral is cleverly\n    // created via optical illusion.\n    entangled circles - FabriceNeyret2\n    https://www.shadertoy.com/view/cdsXRX\n    \n    // A more interesting black and white op-art example.\n    drain vortex marching-less - FabriceNeyret2\n    https://www.shadertoy.com/view/ws23D3\n    \n*/\n\n\n// Shifting upper and lower halves to create the spiral pattern.\n// Commenting this out will display a regular polar pattern.\n#define SPIRAL\n\n// Use highlighting. Commenting it out will display the flat shaded \n// pattern -- Depending on the situation, sometimes that is preferable.\n#define HIGHLIGHT\n\n// Add the colorful blinking lights.\n#define BLINK\n\n// Rounded spiral, as opposed to straight edge sections.\n#define ROUND\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// IQ's vec2 to float hash formula. I remember coming across a discussion regarding\n// the origins of this formula, but have since forgotten. However, it was definitely\n// popularized by people like IQ, the authors of \"The Book of Shaders\", etc.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.617, 57.643)))*43758.5453); }\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n\n\tvec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nvec2 scale = vec2(1./18., 1./6.);//vec2(1./8., 1./1.);\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(length(vec2(1./3., 1)), 1))*scale;\n    //vec2 rect = (vec2(1, 1))*scale.x;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale.y; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    // Base on the bottom (1.) or upside down (-1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = vec2[3](vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = vec2[3](vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n    // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 1./iRes; \n    \n    // Scaling (trivial, in this case) and rotation.\n    vec2 p = r2(iTime/16.)*uv;\n    \n    // Coordinate perturbation.\n    //p += sin(p*3.35 + cos(p.yx*5. + iTime)*1.57)*.004;\n    \n    // Concave warping.\n    //p *= (1.05 - dot(uv, uv)*.1);\n    \n    \n    vec2 ld = normalize(vec2(-1, -1));  // Light direction.\n    //ld *= r2(-iTime/16.); // Rotating the light to match, if desired.\n    \n    \n     // Radial rings.\n    const float rNum = 6.;\n      \n    \n    #ifdef SPIRAL\n    // If you're not aware of the geometric spriral trick, you simply shift \n    // the lower (or upper) half of a polar pattern along one radial unit.\n    // Omitting this will give you a regular polar pattern again.\n    float yDir = p.y<0.? -1. : 1.;\n    p.x -= yDir*length(vec2(1./3., 2))/rNum/4.; \n    #endif\n \n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    // Only 18 will work at present, but I'm pretty sure other numbers working\n    // when I first put this together... I'll take a look later.\n    const float CELL_NUM = 18.;\n    float na = floor(a/6.2831853*CELL_NUM);\n    // Partitioning the angle into the number of cells.\n    float ia = (na + .5)/CELL_NUM;\n \n  \n    // Converting square coordinates to polar ones. I.e. Angular and radial.\n    // Technically, the above statement isn't entirely correct, since we're \n    // merely rotating plane coordinates in a fan shape to create wedges, but\n    // it's similar.\n    p *= r2(ia*6.2831853);\n     \n    // Transforming the lighting to match above.\n    ld *= r2(ia*6.2831853);\n    \n    #ifdef ROUND\n    // At present, the coordinates are still in square form, so this hack will\n    // round things off... There are other ways to do this.\n    p.x = length(p); // Circular coordinates.\n    #endif\n \n    // Radial region number. Only used for debugging below.\n    float iR = floor(p.x/scale.y); \n \n    // Triangle IDs and vertices.\n    vec2[3] vID, v;\n    \n    \n     // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    //scale = 1./2.5; //1./2.\n    vec4 p4 = getTriVerts(p.yx, vID, v);//vec2(a/6.2831*ir, p.x)//r2(3.14159/CELL_NUM)*\n    p = p4.xy;\n    \n    \n    // Triangle distance, and a nearby sample for highlighting.\n    float tri = sdTri(p, v[0], v[1], v[2]);\n    float triHi = sdTri(p - ld.yx*.001, v[0], v[1], v[2]);\n    //float tri = length(p) - .02;\n    //float triHi = length(p - ld.yx*.001) - .02;\n    \n    // Bump highlights from either direction. It's a cheap way to add\n    // two colored lights from opposing directions.\n    float b = max(triHi - tri, 0.)/.001;\n    float b2 = max(tri - triHi, 0.)/.001;\n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(na, 2.)<.5? -1. : 1.;  \n  \n    \n    // Triangle color.\n    vec3 tCol = vec3(.9, .95, 1);\n    // Multicolored.\n    //vec3 tCol = .6 + .4*cos(6.2831*hash21(p4.zw + na + dir*iR*128.) + vec3(0, 1, 2)*1.5);\n     \n    #ifdef BLINK\n    // Randomly highlihgt cells in a blinking fashion. If you want to animate something\n    // bland, but aren't sure what to do, this can sometimes help. \n    float rnd = hash21(p4.zw + na + dir*iR*128.);\n    float blink = smoothstep(.96, .985, sin(6.2831*rnd + mod(iTime, 6.2831))*.5 + .5);\n    //\n    if(gTri*dir>0.) tCol = mix(tCol, tCol*vec3(3, .9, .35), blink); // White cells turn orange.\n    else tCol = mix(tCol, tCol*vec3(1.25, 1, .75), blink); // Slight highlighting for dark cells.\n    \n    // Gradient coloring.\n    tCol = mix(tCol, tCol.xzy, max(-uv.y, 0.));\n    #endif\n \n    // Highlight color.\n    #ifdef HIGHLIGHT\n    vec3 lCol = vec3(.3, .6, 1)*b*b + vec3(1, .6, .2)*b2*b2;\n    #else \n    vec3 lCol = vec3(.66); // No highlights.\n    if(gTri*dir<0.) lCol *= .4; // Make the dark a bit darker.\n    #endif\n    \n    // Applying the highlight colors to the triangle.\n    tCol = tCol*(.65 + lCol*.5);\n    \n    // Rendering alternate triangles in a darker color. You don't have to do this,\n    // but the pattern doesn't look as interesting without it.\n    if(gTri*dir<0.) tCol = tCol/4.*(.35 + lCol);\n    \n    // Region debug.\n    //if(iR == 0.) tCol *= vec3(.8, 1.5, .4);\n  \n    \n    \n    // Apply the triangles to the canvas.\n    vec3 col = mix(vec3(.05), tCol, 1. - smoothstep(0., sf, tri + .02*scale.y));\n    #ifdef HIGHLIGHT\n    // Edge shading for some subtle faux ambient occlusion.\n    float shF = iResolution.y/450.; // Resolution shadow width factor.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*shF*4., abs(tri)))*.35);\n    #endif\n    \n    // Vignette.\n    // Using IQ's box formula to produce a more configurable border overlay.\n    // Equivalent to: float bord = sBox(uv, vec2(iResolution.x/iResolution.y, 1)/2.);\n    vec2 d = abs(uv) - vec2(iResolution.x/iResolution.y, 1)/2.;\n    float bord = min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n    col = mix(col, vec3(.3, .6, 1)/8., (1. - smoothstep(0., .05, abs(bord)))*.5);\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}