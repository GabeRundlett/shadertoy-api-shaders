{
    "Shader": {
        "info": {
            "date": "1579532864",
            "description": "Rendering one pixel row at a time. Scene lit by a point light behind the wall.",
            "flags": 32,
            "hasliked": 0,
            "id": "wlVGRc",
            "likes": 7,
            "name": "Scrolling path tracing",
            "published": 3,
            "tags": [
                "pathtracing",
                "hack",
                "bidirectional",
                "scrolling"
            ],
            "usePreview": 0,
            "username": "kig",
            "viewed": 477
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define THRESHOLD 0.003\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n    \nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat cylinder(vec3 p, vec3 c, float r) {\n    return length(p.yz-c.yz) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat cube = length(max(abs(p + vec3(0.75, 1., -2.4)) - vec3(0.25, 0.07, 1.0), 0.0)) - 0.025;\n\tcube = min(cube, length(max(abs(p + vec3(-0.25, 1.6, -2.4)) - vec3(0.25, 0.07, 1.0), 0.0)) - 0.025);\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s3 = length(max(abs(p+vec3(-2.5, -1.3, 0.0)) - vec3(0.05, 2.5, 2.5), 0.0));\n    s3 = max(s3, -(length(max(abs(p - vec3(2.5, 0., 2.)) - vec3(0.25, 3.0, 0.035), 0.0)) - 0.025));\n    s3 = max(s3, -(max(cylinder(p, vec3(2.5, 1.85, -1.8), 0.35), -cylinder(p, vec3(2.5, 1.85, -1.8), 0.28))));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.25, 0.035), 0.0)) - 0.025));\n    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.035, 0.25), 0.0)) - 0.025));\n\tfloat s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(8.5, 2.95, 0.05), 0.0));\n\t//s4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(0.0, 2.5, 0.0)) - vec3(8.5, 0.05, 8.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(2.0, -2.5, 0.0)) - vec3(4.5, 0.05, 2.5), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(-0.7, 0.0, -2.5)) - vec3(8.5, 2.5, 0.05), 0.0)));\n\ts4 = min(s4, length(max(abs(p+vec3(3.75, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));;\n\ts4 = min(s4, length(max(abs(p+vec3(-3.9, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));\n\treturn min( min( min( min(cube, s1), s2 ), s3 ), s4);\n}\n\nmat material(vec3 p, float rayNumber)\n{\n\t//float cube = length(max(abs(p) - vec3(0.95), 0.0)) - 0.05;\n\tfloat s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;\n\tfloat s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;\n\tfloat s5 = length(max(abs(p+vec3(-1.0, 1.5, 1.2)) - vec3(1.0, 0.05, 1.65), 0.0));\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\n\tm.diffuse = 0.0;\n/*\tif (cube < s1 && cube < s2 && cube < s5) {\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.6;\n\t} else */\n    if (s2 < 0.01) {\n\t\tm.emit = vec3(5.0, 3.5, 3.0)*20.0;\n\t\tm.transmit = vec3(0.9, 0.6, 0.3);\n\t\tm.diffuse = 0.85;\n\t} else if (s1 < 0.01 || abs(sin(p.z*p.y)) < 0.5) {\n\t\tm.transmit = vec3(0.8, 0.6, 0.4);\n        if (s1 < 0.01 && abs(p.z-2.0) < 0.1)\n\t        m.emit = vec3(1.1, 0.2, 0.1);\n\t\tm.diffuse = 0.15;\n    } else if ((p.z > 0.0 || p.z < -2.0 && p.y < 0.0) && mod(rayNumber, 8.0) < 1.0) { // && mod(abs(length(p.xy-vec2(2.0, -1.5))-2.5), 1.0) < 0.25) {\n        m.diffuse = 0.05;\n        m.transmit = vec3(0.8, 0.6, 0.4);\n\t} else {\n\t\tm.diffuse = 1.0;\n\t\tm.transmit = 0.5 * vec3(0.9, 0.93, 0.96); //min(vec3(1.0), abs(p));\n\t}\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, float t)\n{\n    return vec3(0.0);\n    \n    vec3 lightPos_ = vec3(\n        -cos(t)*-8.5, \n        sin(t)*3.0 - 4.0, \n        -(sin(t)*4.0)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += bgDiff*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nray setupRay(vec2 uv, float k, float t) {\n\n\tmat3 rot = rotationXY( vec2( t*0.501, t*0.602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.3, -2.0, -3.5);\n\tr.d = rot * normalize(vec3(uv.x, uv.y+0.75, 1.3));\n\n\treturn r;\n}\n\nvec3 traceLight(ray r, vec3 nml, ray light) {\n    vec3 dir = normalize(light.p - r.p);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<30; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * dir;\n\t\tif (length(r.p - light.p) < THRESHOLD*4.0) {\n            col = max(0.0, dot(nml, dir)) * max(0.0, dot(-dir, light.d)) * light.light;\n            break;\n\t\t} else if (dist < THRESHOLD || dist > MAX_DISTANCE) {\n            break;\n    \t}\n    }\n\treturn col;\n}\n\nvec4 trace(vec2 fragCoord, vec2 uv, vec2 uvD, inout float rayNumber, float convergeCount)\n{\t\n\tvec3 accum = vec3(0.0);\n    \n    float k = 0.0;\n\n    vec2 rc = fragCoord + (5.0+mod(iTime, 1.73728))*vec2(rayNumber*37.0, rayNumber*63.0);\n    vec4 rand = texelFetch(iChannel0, ivec2(mod(rc, vec2(256.0))), 0);\n\n    float time = 64.0 + 11.5; //floor(float(iFrame)/300.0);\n    float shutterSpeed = 0.01;\n    \n    float t = time + shutterSpeed*rand.x;\n\t\n    int bounces = 0;\n    ray lights[3];\n\n    ray r;\n    r.d = normalize(rand.xyz);\n    rand = rand.yzwx;\n    r.p = vec3(2.75, -1.35, 0.) + r.d * 0.06;\n    r.d = normalize(r.p - vec3(2.75, -1.35, 0.));\n    r.light = vec3(5.0, 3.5, 3.0)*20.0;\n    r.transmit = vec3(1.0);\n    lights[0] = r;\n    \n    for (int i=0; i<100; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            mat m = material(r.p, rayNumber);\n            if (bounces == 0) {\n                r.transmit *= m.transmit;\n                lights[1] = r;\n                lights[1].light = r.light * r.transmit;\n\t            bounces++;\n                float diffuse = m.diffuse;\n                offset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n                r.d = reflect(r.d, nml);\n                lights[1].d = nml;\n                r.p += 4.0*THRESHOLD * r.d;\n            } else {\n                r.transmit *= m.transmit;\n                lights[2] = r;\n                lights[2].light = r.light * r.transmit;\n                float diffuse = m.diffuse;\n                offset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n                r.d = reflect(r.d, nml);\n                lights[2].d = nml;\n                break;\n            }\n\t\t} else if (dist > MAX_DISTANCE) {\n            break;\n    \t}\n    }\n        \n    rand = texelFetch(iChannel0, ivec2(mod(rc+vec2(37.0,63.0), vec2(256.0))), 0);\n\tr = setupRay(uv+(uvD*vec2(rand.x, rand.y)), k+rayNumber, t);\n    bounces = 0;\n    k = 0.0;\n\n    vec3 startP = r.p;\n    float hitD = 1000000.0;\n\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tfloat dist = scene(r.p);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n            if (bounces == 0) hitD = length(r.p - startP);\n            mat m = material(r.p, rayNumber);\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n            float diffuse = m.diffuse;\n            r.light += r.transmit * m.emit;\n            r.transmit *= m.transmit;\n\t\t\toffset(r.d, rayNumber+k, rand.x+rayNumber+k+10.0*dot(nml, r.d), diffuse*0.5);\n            r.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\t\n            vec3 collected = vec3(0.0);\n\t\t\tcollected += traceLight(r, nml, lights[0]);\n\t\t\tcollected += traceLight(r, nml, lights[1]);\n\t\t\tcollected += traceLight(r, nml, lights[2]);\n\t\t\taccum += r.light*3.0 + r.transmit * collected;\n\n            k += 3.0;\n\t\t\t\n            //r.light += 0.1;\n            \n            rand = rand.yzwx;\n            bounces++;\n            if (bounces > 3) {\n                break;\n            }\n\t\t} else if (dist > MAX_DISTANCE) {\n            //r.light += r.transmit * 2.0*r.d.yxx;\n            break;\n\t\t}\n\t}\n    accum += r.light;\n    k++;\n\trayNumber += k;\n\treturn vec4(accum, hitD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = iFrame % int(3.0 * iResolution.y);\n    if (frame == 0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    float scrollY = max(0.0, float(frame) - iResolution.y);\n    vec2 sy = scrollY > 0.0 ? vec2(0.0, -1.0) : vec2(0.0);\n    vec4 color = texelFetch(iChannel1, ivec2(fragCoord + sy), 0);\n    int samples = 20;\n    float rayNumber = 0.0;\n    if (scrollY > 0.0) {\n        if (floor(fragCoord.y) > 0.0) {\n            fragColor = color;\n            return;\n        }\n        color *= 0.0;\n    } else {\n        if (int(iResolution.y - fragCoord.y) != frame) {\n            fragColor = color;\n            return;\n        }\n    }\n\n    vec3 c = texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n\n    vec4 lightD = vec4(color.rgb, 0.0);\n\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy + vec2(0.0, -scrollY+300.0)) / iResolution.xy;\n    uv = (2.0*uv - 1.0) * aspect;\n\n    vec2 uvD = ((2.0*((fragCoord.xy + vec2(0.0, -scrollY+300.0))+vec2(1.0, 1.0)) / iResolution.xy - 1.0) * aspect) - uv;\n \n    for (int i = 0; i < samples; i++) {\n        lightD += trace(fragCoord + vec2(0.0, -scrollY+300.0), uv, uvD, rayNumber, 0.0);\n    }\n    lightD.rgb /= rayNumber;\n    lightD.a /= rayNumber;\n    \n    fragColor = lightD;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 accum = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = (1.0 - exp(-accum * 1.5));\n    fragColor.a = accum.a;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}