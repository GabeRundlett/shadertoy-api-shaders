{
    "Shader": {
        "info": {
            "date": "1462713712",
            "description": "Point lit, transparent lattice. Adding fake diffuse and specular lighting to the transparency formula. Kind of interesting, but not to be taken too seriously.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xd3SDs",
            "likes": 135,
            "name": "Transparent Lattice",
            "published": 3,
            "tags": [
                "transparent",
                "lattice"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 9747
        },
        "renderpass": [
            {
                "code": "/*\n\t\n    Transparent Lattice\n\t-------------------\n\n\tJust a transparent lattice. Not much different to my other transparent examples, \n\texcept this one is point lit... In case it needs to be said, a lot of it is faked, \n\tso is more of a novelty than anything else. \n\n\tI wrote it some time ago, then forgot about it. I thought I'd put it up just in \n\tcase it's of any use to anyone. It runs reasonably fast, considering that the \n\tlighting is calculated multiple times a pass, but could benefit from a little more \n\ttweaking.\n\n\tRelated shaders:\n\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n\tVirtually the same thing, but with rounded cubes and less interesting lighting.\n\tTransparent Cube Field - Shane\n\thttps://www.shadertoy.com/view/ll2SRy\n\t\n*/\n\n\n\n// Cheap vec3 to vec3 hash. Works well enough, but there are other ways.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n/*\n// Rounded cube field, for comparison. It runs at full speed, believe it or not.\nfloat map(vec3 p){\n   \n\t// Creating the repeat cubes, with slightly convex faces. Standard,\n    // flat faced cubes don't capture the light quite as well.\n    \n    // 3D space repetition.\n    p = fract(p)-.5; // + o \n    \n    // A bit of roundness. Used to give the cube faces a touch of convexity.\n    float r = dot(p, p) - 0.21;\n    \n    // Max of abs(x), abs(y) and abs(z) minus a constant gives a cube.\n    // Adding a little bit of \"r,\" above, rounds off the surfaces a bit.\n    p = abs(p); \n\treturn max(max(p.x, p.y), p.z)*.95 + r*0.25 - 0.21;\n   \n    \n    // Alternative. Egg shapes... kind of.\n    //float perturb = sin(p.x*10.)*sin(p.y*10.)*sin(p.z*10.);\n\t//p += hash33(floor(p))*.15;\n\t//return length(fract(p)-.5)-0.3 + perturb*0.05;\n\t\n}\n*/\n\n/*\n// A fake noise looking field. Pretty interesting.\nfloat map(vec3 p){\n\n   \n\tp = (cos(p*.315*2.5 + sin(p.zxy*.875*2.5)));\t    // + iTime*.5\n     \n    float n = length(p);\n    \n    p = sin(p*6. + cos(p.yzx*6.));\n    \n    return n - 1. - abs(p.x*p.y*p.z)*.05;\n\n    \n}\n*/\n\nfloat map(vec3 p){\n\n    \n    \n    vec2 c;\n \n    // SECTION 1\n    //\n    // Repeat field entity one, which is just some tubes repeated in all directions every \n    // two units, then combined with a smooth minimum function. Otherwise known as a lattice.\n    p = abs(fract(p/3.)*3.-1.5);\n    //c.x = sminP(length(p.xy),sminP(length(p.yz),length(p.xz), 0.25), 0.25)-0.75; // EQN 1\n    //c.x = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-0.75; // EQN 2\n    c.x = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.75; // EQN 3\n    //p = abs(p); c.x = max(p.x,max(p.y,p.z)) - .5;\n    \n\n    // SECTION 2\n    //\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(fract(p*4./3.)*.75 - 0.375);\n    c.y = min(p.x,min(p.y,p.z)); // EQN 1\n    //c.y = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.125; //-0.175, etc. // EQN 2    \n    //c.y = max(p.x,max(p.y,p.z)) - .4;\n    \n    // SECTION 3\n    //\n    // Combining the two entities above.\n    //return length(c)-.1; // EQN 1\n    //return max(c.x, c.y)-.05; // EQN 2\n    return max(abs(c.x), abs(c.y))*.75 + length(c)*.25 - .1;\n    //return max(abs(c.x), abs(c.y))*.75 + abs(c.x+c.y)*.25 - .1;\n    //return max(abs(c.x), abs(c.y)) - .1;\n    \n}\n\n\n\n\n// Not big on accuracy, but lower on operations. Few distance function calls are important\n// during volumetric passes.\nvec3 calcNormal(in vec3 p, float d) {\n\tconst vec2 e = vec2(0.01, 0);\n\treturn normalize(vec3(d - map(p - e.xyy), d - map(p - e.yxy),\td - map(p - e.yyx)));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. Unfortunately, still\n// not fast enough in this particular instance.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.x * map(p + e.xxx));\n}\n*/\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5 )/iResolution.y;\n\t\n    // Unit direction ray. The last term is one of many ways to fish-lens the camera.\n    // For a regular view, set \"rd.z\" to something like \"0.5.\"\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5)); // Fish lens, for that 1337, but tryhardish, demo look. :)\n    \n    // There are a few ways to hide artifacts and inconsistencies. Making things go fast is one of them. :)\n    // Ray origin, scene color, and surface postion vector.\n    vec3 ro = vec3(0., 0., iTime*1.5), col=vec3(0), sp, sn, lp, ld, rnd;\n    \n\t\n    // Swivel the unit ray to look around the scene.\n    // Compact 2D rotation matrix, courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.375);\n    rd.xz = mat2(a, -a.y, a.x)*rd.xz;    \n    rd.xy = mat2(a, -a.y, a.x)*rd.xy; \n    \n    \n    lp = vec3(0, 1, 4);\n    lp.xz = mat2(a, -a.y, a.x)*lp.xz;    \n    lp.xy = mat2(a, -a.y, a.x)*lp.xy; \n    lp += ro;\n    \n    \n    // Unit ray jitter is another way to hide artifacts. It can also trick the viewer into believing\n    // something hard core, like global illumination, is happening. :)\n    //rd *= 0.99 + hash33(rd)*0.02;\n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    rnd = hash33(rd+311.);\n    \n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n    // Note the slight jittering to begin with. It alleviates the subtle banding.\n\tfloat t = length(rnd)*.2, layers = 0., d, aD;\n\t\n\t// Light variables.\n\tfloat lDist, s, l;\n    \n    // Surface distance threshold. Smaller numbers gives a thinner membrane, but lessens detail... \n    // hard to explain. It's easier to check it out for yourself.\n    float thD = .0125; // + smoothstep(-0.2, 0.2, sin(iTime*0.75 - 3.14159*0.4))*0.025;\n \n\t\n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(float i=0.; i<64.; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>31. || dot(col, vec3(.299, .587, .114)) > 1. || t>16.) break;\n        \n        // Current ray postion. Slightly redundant here, but sometimes you may wish to reuse\n        // it during the accumulation stage.\n        sp = ro+rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point on the noise surface.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. You could smoothly interpolate it, if you wanted.\n        //\n        // 1/.(1. + t*t*0.1) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d)*31./32.)/thD;\n        //aD += dot(hash33(sp + 113.) - .5, vec3(.2)); // Extra jitter.\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n        \n            \n            // Add the accumulated surface distance value, along with some basic falloff using the \n            // camera to light distance, \"lDist.\" There's a bit of color jitter there, too.\n            \n            sn = calcNormal(sp, d)*sign(d);\n            ld = (lp - sp); //vec3(.5773)\n            lDist = max(length(ld), .001);\n            ld /= lDist;\n            s = pow(max(dot(reflect(-ld, sn), -rd), 0.), 8.);\n            l = max(dot(ld, sn), 0.);\n            \n\n            //float c = dot(sin(sp*128. - cos(sp.yzx*64.)), vec3(.166))+.5;\n            col += ((l + .1) + vec3(.5, .7, 1)*s)*aD/(1. + lDist*0.25 + lDist*lDist*0.05)*.2;\n            // Failed experiment with color jitter to take out more banding.\n            //col += ((l + .05 + fract(rnd + i*27.)*.1) + vec3(.5, .7, 1)*s)*aD/(1. + lDist*0.25 + lDist*lDist*0.05)*.2;\n            \n            \n            // The layer number is worth noting. Accumulating more layers gives a bit more glow.\n            // Lower layer numbers allow a quicker bailout. A lot of it is guess work.\n            layers++;\n            \n        }\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit \n        // of knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.75, thD*.25);\n        \n\t\t\t    \n\t}\n\t\n\tt = min(t, 16.);\n    \n     \n    col = mix(col, vec3(0), 1.-exp(-0.025*t*t));////1.-exp(-0.01*t*t) 1.-1./(1. + t*t*.1)\n  \n    // Mixing the greytone color with a firey orange vignette. There's no meaning\n    // behind it. I just thought the artsy greyscale was a little too artsy.\n    uv = abs(fragCoord.xy/iResolution.xy - .5); // Wasteful, but the GPU can handle it.\n    col = mix(col, pow(min(vec3(1, 1.2, 1)*col.x, 1.), vec3(2.5, 1, 12)),\n               min( dot(pow(uv, vec2(4.)), vec2(1))*8., 1.));\n               \n    //col = vec3(min(col.z*1.5, 1.), pow(col.z, 2.5), pow(col.z, 12.));\n\n    \n\t// Mixing the vignette colors up a bit more.\n    col = mix(col, col.zxy, dot(sin(rd*5.), vec3(.166)) + 0.166);\n\n    \n\t// Presenting the color to the screen.\n\tfragColor = vec4( sqrt(clamp(col, 0., 1.)), 1.0 );\n    \n     \n }",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}