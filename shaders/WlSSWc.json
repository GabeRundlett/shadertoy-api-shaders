{
    "Shader": {
        "info": {
            "date": "1567259463",
            "description": "buffers:\naccumulator | debug\ncurrent image | (motion vector, depth, prev_depth)",
            "flags": 32,
            "hasliked": 0,
            "id": "WlSSWc",
            "likes": 20,
            "name": "Simple TAA(halton jitter+reproj)",
            "published": 3,
            "tags": [
                "taa"
            ],
            "usePreview": 0,
            "username": "aschrein",
            "viewed": 2234
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 ui = textureLod(iChannel1, uv, 0.0);\n    fragColor = pow(textureLod(iChannel0, uv, 0.0), vec4(0.5)) + ui * ui.w;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uint BB_SIZE_K = 2u;\nconst float PI = 3.14159265;\nconst float SKYBOX_RADIUS = 1000.0;\nfloat halton(int i, int b)\n{\n    /* Creates a halton sequence of values between 0 and 1.\n\thttps://en.wikipedia.org/wiki/Halton_sequence\n\tUsed for jittering based on a constant set of 2D points. */\n    float f = 1.0;\n    float r = 0.0;\n    while(i > 0)\n    {\n        f = f / float(b);\n        r = r + f * float(i % b);\n        i = i / b;\n    }\n    return r;\n}\n\n// Halton<2, 3> 16\nvec2 Jitter(vec2 fragCoord, int frame)\n{\n    int num = 8;\n    return (vec2(\n    \thalton(frame % num + int(fragCoord.x) % num + 1, 2),\n    \thalton(frame % num + int(fragCoord.y) % num + 1, 3)) - vec2(0.5));\n}\n\n//------------------------------------------------------------------------------------------\n// Hammersley Sampling\n//------------------------------------------------------------------------------------------\n// Src: https://www.shadertoy.com/view/4lscWj\n\nvec2 Hammersley(float i, float numSamples)\n{   \n    uint b = uint(i);\n    \n    b = (b << 16u) | (b >> 16u);\n    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);\n    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);\n    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);\n    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);\n    \n    float radicalInverseVDC = float(b) * 2.3283064365386963e-10;\n    \n    return vec2((i / numSamples), radicalInverseVDC);\n} \n\nvec3 SampleHemisphere_Uniform(float i, float numSamples)\n{\n\tvec2 xi = Hammersley(i, numSamples);\n    \n    float phi      = xi.y * 2.0 * PI;\n    float cosTheta = 1.0 - xi.x;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\nvec3 SampleHemisphere_Cosinus(float i, float numSamples)\n{\n    vec2 xi = Hammersley(i, numSamples);\n    \n    float phi      = xi.y * 2.0 * PI;\n    float cosTheta = sqrt(1.0 - xi.x);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n     \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n\n}\n\n//------------------------------------------------------------------------------------------\n//------------------------------------------------------------------------------------------\n\n// Src: https://www.shadertoy.com/view/4dSBDt\n// Enscape Cube\n\nivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n// Advection filter from Sebbbi\n// SRC: https://www.shadertoy.com/view/lsG3D1\n\n// Perlin's smootherstep (quintic)\n// https://en.wikipedia.org/wiki/Smoothstep\nvec4 textureSmootherstep(sampler2D tex, vec2 uv, vec2 res)\n{\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);\n\tuv = (uv - 0.5)/res;\n\treturn texture( tex, uv );\n}\n\nvec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nvec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nvec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nvec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nvec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nvec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\nvec4 PS_A = vec4(   1.25,-2.25,   0.0,  1.0 ) /  1.0;\nvec4 PS_B = vec4(  -0.75, 3.75,  -6.0,  3.0 ) /  1.0;\n\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca, cb;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t, vec2 res )\n{\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- User Interface\n * -----------------------------------------------------------\n *\n *     'UI Easy to Integrate' - XT95\n *     https://www.shadertoy.com/view/ldKSDm\n */\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(0.0)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\nvoid setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uv = fragCoord.xy;\n    \n    int rx = int(iResolution.x * 0.5) - 150;\n    int ry = int(iResolution.y) - 10;\n    \n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n        \n    _slider(15, ry, 0, 0.1) _W _e _i _g _h _t\n        \n    _slider(170, ry, 1, 0.2) _t _h _r _e _s _h _o _l _d\n        \n    fragColor = min(col.rgba, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene_dist(in vec3 p)\n{\n    \n    return min(\n        min(sdBox(p-vec3( 1.0,0.25, -32.03), vec3(30.25) ),\n        min(\n        \tsdBox(p-vec3( 1.33, .25, 0.33), vec3(5.25)),\n        \tlength(p - vec3(6.0, 0.0, -5.0)) - 6.5\n        )),\n        min(\n        \tlength(p - vec3(-2.0, 0.0, 4.0)) - 3.5,\n        \tlength(p - vec3(6.0, 0.0, 0.0)) - 5.5\n        )\n        )\n        ;\n}\n\nvec3 scene_normal(in vec3 p)\n{\n    vec3 e = vec3(-1.0, 1.0, 0.0) * 0.001;\n    return normalize(\n          e.xxx * scene_dist(p+e.xxx)\n        + e.xyy * scene_dist(p+e.xyy)\n        + e.yxy * scene_dist(p+e.yxy)\n        + e.yyx * scene_dist(p+e.yyx) );\n}\n\nfloat black_stripe(float x) {\n\tfloat fr = fract(abs(x) * 8.0);\n    float frh = abs(2.0 * (fr - 0.5));\n    return max(0.0, min(1.0, (exp(frh*48.0) - 1.0)/(pow(2.7, 48.0) - 1.0)));\n}\n\nvec3 scene_color(\n    vec3 pos,\n    vec3 ray, vec3 normal)\n{\n    \n    if (length(pos) > 100.0) {\n        return pow(textureLod(iChannel3, normalize(pos).xzy, 0.0).xyz, vec3(2.2));\n    }\n    // Simple lambert\n    //if (pos.z < 0.0) {\n        //vec3 binormal = cross(normal, vec3(0.0, 0.0, 1.0));\n        //vec3 tangent = normalize(cross(normal, binormal));\n        //binormal = normalize(cross(normal, tangent));\n    \t\tfloat stepx = black_stripe(pos.x * 4.0e-2);\n            float stepy = black_stripe(pos.y * 4.0e-2);\n            float stepz = black_stripe(pos.z * 4.0e-2);\n                // vec3(nor*0.5 + 0.5)\n        return vec3(0.5 * max(stepx, max(stepy, stepz)), 0.0, 0.0) +\n            pow(texture(iChannel1, (pos.xy)/ 10.0).xyz, vec3(4.2)) *\n            (0.01 + 0.8 *\n            \tclamp(dot(normal, normalize(vec3(0.0, 0.0, 1.0))), 0.0, 1.0)\n            );\n             //}\n    \n    \n    //vec3 refl = reflect(ray, normal);\n    /*vec3 acc = vec3(0.0);\n        for (float iter = 0.0; iter < 4.0; iter += 1.0) {\n        \tvec3 nn = normalize(refl + 0.9 * cosineDirection(17.7*float(iFrame)  + 73.1 * iter, refl));\n            //vec3 nn = normalize(normal * s.z + tangent * s.x + binormal * s.y);\n            acc += 2.0 * pow(textureLod(iChannel3, nn.xzy, 0.0).xyz, vec3(2.2));\n        }\n        return acc / 4.0;*/\n    \n    //return 2.0 * pow(textureLod(iChannel3, refl.xzy, 0.0).xyz, vec3(2.2));\n        //\n}\n\nconst float EPS = 1.0e-1;\n\nvec2 trace(in vec3 pos, in vec3 dir)\n{\n    float t = 0.;\n    float d = scene_dist(pos);\n    for (int i = 0; i < 70; ++i)\n    {\n        if (d <= EPS)\n            break;\n        \n        vec3 p = pos + t * dir;\n        \n        d = scene_dist(p);\n        \n        t += d * 1.0;\n    }\n    // Handle skybox\n    if (d > EPS) {\n        float d = dot(pos, dir);\n        float r = SKYBOX_RADIUS;\n        float t = sqrt(r * r - d * d);\n        return vec2(EPS, d + t);\n    }\n    return vec2(d, t);\n}\n\n\nvoid camera_state(\n    \t\t\t float time,\n    \t\t\t vec2 mouse_uv, vec2 screen_uv,\n                 out vec3 camera_pos,\n                 out vec3 camera_up,\n                 out vec3 camera_look,\n                 out vec3 camera_left,\n                 out vec3 ray_dir\n                 ) {\n    //mouse_uv *= 0.1;\n\tfloat camera_distance = 15.0;\n    camera_up = vec3(0.0, 0.0, 1.0);\n    vec3 camera_lookat = vec3(0.0, 0.0, 0.0)/2.0;\n    float theta = mouse_uv.y;// + 3.141592/4.0;\n    theta = 3.141592/3.0;//clamp(theta, 0.0, 3.141592/3.0);\n    camera_pos = camera_distance * vec3(\n        sin(theta) * cos(mouse_uv.x * 10.0 + time * 0.1),\n        sin(theta) * sin(mouse_uv.x * 10.0 + time * 0.1),\n        cos(theta)\n    ) + camera_lookat;\n    \n    camera_look = normalize(camera_lookat - camera_pos);\n    camera_left = normalize(cross(camera_look, camera_up));\n    camera_up = normalize(cross(camera_left, camera_look));\n    ray_dir = normalize(camera_look + screen_uv.x * camera_left + screen_uv.y * camera_up);\n}\n\nvec2 project(\n    vec3 p,\n    vec3 camera_pos,\n    vec3 camera_up,\n    vec3 camera_look,\n    vec3 camera_left)\n{\n\tvec3 dr = p - camera_pos;\n    float x = dot(dr, camera_left);\n    float y = dot(dr, camera_up);\n    float z = dot(dr, camera_look);\n    return vec2(x, y)/z;\n}\n\nvec3 render(vec2 uv)\n{\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    vec3 camera_pos;\n    vec3 camera_up;\n\tvec3 camera_look;\n\tvec3 camera_left;\n    vec3 ray_dir;\n    camera_state(iTime, mouse_uv, uv, camera_pos, camera_up, camera_look, camera_left, ray_dir);\n    \n    vec3 color = vec3(0.);\n    vec3 n, p;\n    \n    vec3 pos = camera_pos;\n    vec3 dir = ray_dir;\n    \n    vec2 col = trace(pos, dir);\n   \t\n    if (col.x <= EPS && col.y < 100.0)\n    {\n        p = pos + dir * col.y;\n        n = scene_normal(p);\n        color += scene_color(p, dir, n);\n        float it = 0.0;\n    } else {\n        float d = dot(pos, dir);\n        float r = SKYBOX_RADIUS;\n        float t = sqrt(r * r - d * d);\n        p = pos + dir * (d + t);\n    \tcolor = pow(textureLod(iChannel3, normalize(p).xzy, 0.0).xyz, vec3(2.2));\n    }\n    return color;\n}\n\nvec4 render_color(vec2 fragCoord)\n{\n    vec2 jitter = Jitter(fragCoord, int(iFrame));\n\tvec2 uv = vec2(float(BB_SIZE_K)) * (fragCoord.xy + jitter) / iResolution.xy;\n    if (uv.x > 1.0 || uv.y > 1.0 || uv.x < 0.0 || uv.y < 0.0)\n        return vec4(0.0);\n    float aspect = iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= aspect;\n    \n    vec3 col = render(uv);\n\n    return vec4(pow(col, vec3(1./2.2)),1.0);\n}\n\nvec4 render_vel(vec2 fragCoord)\n{\n    //vec2 jitter = Jitter(fragCoord, int(iFrame));\n\tvec2 uv = vec2(float(BB_SIZE_K)) * (fragCoord.xy) / iResolution.xy;\n    uv.x -= 1.0;\n    if (uv.x > 1.0 || uv.y > 1.0 || uv.x < 0.0 || uv.y < 0.0)\n       return vec4(0.0);\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    \n    // Save prev camera state\n    if (uv.x <= float(BB_SIZE_K)/ iResolution.x && uv.y <= float(BB_SIZE_K) / iResolution.y)\n        return vec4(mouse_uv, iTime, 0.0);\n    // Restore prev camera state\n    vec2 prev_mouse_uv = textureLod(iChannel0, vec2(floor(iResolution.x)/2.0 + 0.5, 0.5) / iResolution.xy, 0.0).xy;\n    float prev_time = textureLod(iChannel0, vec2(floor(iResolution.x)/2.0 + 0.5, 0.5) / iResolution.xy, 0.0).z;\n    \n    vec3 camera_pos;\n    vec3 camera_up;\n\tvec3 camera_look;\n\tvec3 camera_left;\n    vec3 ray_dir;\n    float aspect = iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= aspect;\n    camera_state(iTime, mouse_uv, uv, camera_pos, camera_up, camera_look, camera_left, ray_dir);\n    \n    vec3 prev_camera_pos;\n    vec3 prev_camera_up;\n\tvec3 prev_camera_look;\n\tvec3 prev_camera_left;\n    vec3 prev_ray_dir;\n    camera_state(prev_time, prev_mouse_uv, uv, prev_camera_pos, prev_camera_up, prev_camera_look, prev_camera_left, prev_ray_dir);\n    \n    vec2 col = trace(camera_pos, ray_dir);\n    \n    vec3 p = camera_pos + ray_dir * col.y;\n    \n    \n    vec2 proj = project(\n        p,\n        prev_camera_pos,\n        prev_camera_up,\n        prev_camera_look,\n        prev_camera_left\n    );\n    float prev_depth = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0).z;\n    //if (col.x <= EPS)\n    \treturn vec4((proj - uv) * vec2(1.0/aspect, 1.0), length(camera_pos - p)/10.0, prev_depth);\n    //return vec4(0.0);\n}\n\nfloat get_slider(int id)\n{\n    return texture(iChannel2, vec2(float(id)+.5,0.5)/iResolution.xy).r;\n}\n\nvec2 closest_fragment(ivec2 fragCoord) {\n    ivec2 closest = fragCoord;\n    float depth = texelFetch(iChannel0,\n                         ivec2(fragCoord.xy), 0).z;\n    for(int i = 0; i < 8; i++)\n    {\n        float new_depth = texelFetch(iChannel0,\n                         fragCoord.xy + offsets[i], 0).z;\n        if (new_depth < depth) {\n        \tdepth = new_depth;\n            closest = fragCoord.xy + offsets[i];\n        }\n    }\n    return (vec2(closest) + vec2(0.5)) / iResolution.xy;\n}\n\nvec2 closest_fragment_YCoCg(vec3 value, vec2 uv) {\n    ivec2 fragCoord = ivec2(uv * iResolution.xy);\n    ivec2 closest = fragCoord;\n    \n    vec3 cur_value = RGBToYCoCg(texelFetch(iChannel0,\n                         ivec2(fragCoord.xy), 0).rgb);\n    float dist = distance(cur_value, value);\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 new_value = RGBToYCoCg(texelFetch(iChannel0,\n                         fragCoord.xy + offsets[i], 0).rgb);\n        float new_dist = distance(new_value, value);\n        if (new_dist < dist) {\n        \tdist = new_dist;\n            closest = fragCoord.xy + offsets[i];\n        }\n    }\n    return vec2(closest) / iResolution.xy;\n}\n\nvec4 _render_acc(\n    vec2 fragCoord,\n\tvec2 uv_origin,\n    bool red_acc,\n    bool clamp_color\n) {\n    vec2 uv = vec2(float(BB_SIZE_K)) * (fragCoord.xy) / iResolution.xy;\n    uv -= uv_origin * 2.0;\n    if (\n           uv.x > 1.0\n        || uv.y > 1.0\n        || uv.x < 0.0\n        || uv.y < 0.0)\n       return vec4(0.0);\n    //uv /= float(BB_SIZE_K);\n    float weight = get_slider(0);\n    vec2 closest_uv = fragCoord.xy / iResolution.xy;//closest_fragment(ivec2(fragCoord.xy));\n    vec3 cur = RGBToYCoCg(textureLod(iChannel0, fragCoord.xy / iResolution.xy - uv_origin, 0.0).xyz);\n    vec4 vel = textureLod(iChannel0, closest_uv - uv_origin + vec2(0.5, 0.0), 0.0);\n    float depth = vel.z;\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 mvec = (vel.xy);\n    vec2 disp = (vec2(\n        //ivec2(\n            fragCoord.xy +\n        \tmvec/(4.0) * iResolution.xy\n        //\t)\n    )\n                 //+ 0.5\n                )/ iResolution.xy;\n    \n    \n\t\n    // Photoshop filter\n    ca=CR_A; cb=CR_B;\n    vec3 acc = RGBToYCoCg(\n        //textureLod(iChannel0, disp, 0.0).xyz\n        texture_Bicubic(iChannel0, disp, iChannelResolution[0].xy).xyz\n    );\n    \n    if (clamp_color) {\n    \tvec3 colorAvg = cur;\n        vec3 colorVar = cur*cur;\n\n        // Marco Salvi's Implementation (by Chris Wyman)\n        for(int i = 0; i < 8; i++)\n        {\n            vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n            colorAvg += fetch;\n            colorVar += fetch*fetch;\n        }\n        colorAvg /= 9.0;\n        colorVar /= 9.0;\n        float gColorBoxSigma = 16.;\n        vec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n        vec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n        vec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n\n        acc = clamp(acc, colorMin, colorMax);\n    }\n    \n    if (red_acc) {\n        \n        /*if (weight == 1.0\n           )\n      \t return vec4(clamp(black_stripe(uv.x * 4.0) + black_stripe(uv.y * 2.0), 0.0, 1.0));\n        else*/\n            weight = 0.0;\n    }\n    \n    float prev_depth = textureLod(iChannel0, disp - uv_origin + vec2(0.5, 0.0), 0.0).w;\n    \n    if (length(mvec) > 1.0e-4 && abs(prev_depth - depth)/(prev_depth + depth) > 2.0e-1 * get_slider(1)) {\n    \tweight = 1.0;\n    }\n    \n    if (\n           disp.x < uv_origin.x + 2.0/iResolution.x\n        || disp.x > uv_origin.x + 0.5 - 2.0/iResolution.x\n        || disp.y < uv_origin.y + 2.0/iResolution.y\n        || disp.y > uv_origin.y + 0.5 - 2.0/iResolution.y)\n        weight = 1.0;\n    \n\n    \n    return //vec4(depth);//cur;//textureLod(iChannel0, cur_uv, 0.0);\n       vec4(YCoCgToRGB(mix(acc.xyz, cur.xyz, weight)), 1.0);\n}\n\nvec4 render_acc(vec2 fragCoord )\n{\n\treturn _render_acc(fragCoord, vec2(0.0, 0.5), false, true);\n}\n\nvec4 render_db(vec2 fragCoord)\n{\n\treturn _render_acc(fragCoord, vec2(0.5, 0.5), true, true);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = render_color(fragCoord) + render_vel(fragCoord) + render_acc(fragCoord) + render_db(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}