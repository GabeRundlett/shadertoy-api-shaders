{
    "Shader": {
        "info": {
            "date": "1576924248",
            "description": "Inktober, but with shaders",
            "flags": 0,
            "hasliked": 0,
            "id": "wdcSWf",
            "likes": 9,
            "name": "shadetober #28 (ride)",
            "published": 3,
            "tags": [
                "pseudo",
                "inktober",
                "shadertober",
                "shadetober",
                "inktober2019"
            ],
            "usePreview": 0,
            "username": "percentcer",
            "viewed": 851
        },
        "renderpass": [
            {
                "code": "// === original ===================================================================\n const vec3 GRASS = vec3(0., .5, 0.);\n const vec3 WHITE = vec3(1., 1., 1.);\n const vec3 WARN = vec3(1., 1., 0.);\n const vec3 ROAD = vec3(.2, .2, .2);\n const vec3 KERB = vec3(1., 0., 0.);\n const float ROWS = 20.;\n\n vec3 scanlineRoad(in vec2 p, in float row, in float scaling)\n {\n     row += floor(iTime * 20.);\n    \n \tvec2 mirp = abs(p);\n     mirp *= scaling;\n    \n     if (mirp.x < .02) { \n         return mix(WHITE, ROAD, mod(floor(row * .5), 2.)); \n     }\n     if (mirp.x < .53) { return ROAD; }\n     if (mirp.x < .55) { \n         return mix(WHITE, WARN, mod(floor(row * .333333), 2.)); \n     }\n     if (mirp.x < .6) { return ROAD; }\n     if (mirp.x < .64) {\n         return mix(WHITE, KERB, mod(row, 2.));\n     }\n     else { return GRASS; }\n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = (fragCoord * vec2(1., ROWS)) / iResolution.xy;\n     uv.y *= 4.;\n    \n     float row = floor(uv.y);\n     // float row = pow(2.0, floor(uv.y + 1.0) * 0.07); // suggestion from jaszunio15 for a perspective tweak\n     uv.y = fract(uv).y;\n     uv.x -= 0.5;\n    \n     uv.x += sin(iTime + row * .1) * .1;\n        \n     // Time varying pixel color\n     vec3 col = scanlineRoad(uv, row, row * .1 + 1.);\n\n     // Output to screen\n     fragColor = vec4(col,1.0);\n }\n// ================================================================================\n\n// below, some code golfing suggestion from Fabrice!\n\n// --- after some code golfing... -------------------------------------------------\n\n// vec3 scanlineRoad(vec2 p, float row, float scaling)\n// {\n//     row += floor(iTime * 20.);\n// \tfloat x = abs(p.x) * scaling;\n\n//     // some features are dashed lines which are sometimes white, sometimes a different color (e.g. check the red/white kerbs).\n//     // k is a scaling factor so that the on/off state can span over multiple rows\n// #define m(C,k) mod(floor(row * k), 2.) == 0. ? WHITE : C\n\n//     return   x < .02 ? m(ROAD,.5)\n//            : x < .52 ? ROAD \n//            : x < .55 ? m(WARN,.33)\n//            : x < .6  ? ROAD\n//            : x < .68 ? m(KERB,1.)\n//            :           GRASS; \n// }\n\n// void mainImage( out vec4 fragColor, in vec2 fragCoord )\n// {\n//     vec2 uv = (fragCoord * vec2(1., 4. * ROWS)) / iResolution.xy;\n//     float row = floor(uv.y);\n//     uv.y = fract(uv.y);\n//     uv.x += .1 * sin(iTime + row * .1) - .5;\n//     fragColor.rgb = scanlineRoad(uv, row, row * .1 + 1.);\n// }\n\n// --- after more code golfing ----------------------------------------------------\n// #define m(k)  int( k * (r + ceil(iTime*20.)) )%2 < 1 ? vec4(1) : //\n// #define mainImage(O,u)                         \\\n//     vec2  U = u/iResolution.xy;                \\\n//     float r = floor(U.y*=80.),                 \\\n//           x = abs( U.x + .1 * sin(iTime + r*.1) - .5 ) * (r*.1+1.); \\\n//     vec4 R = O+.2;                             \\\n//     O  =     x < .02 ? m(.5) R                 \\\n//            : x < .52 ? R                       \\\n//            : x < .55 ? m(.33) O.wwxw           \\\n//            : x < .6  ? R                       \\\n//            : x < .68 ? m(1.)  O.wxxw           \\\n//            :           vec4(0,.5,0,1)",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}