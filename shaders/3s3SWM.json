{
    "Shader": {
        "info": {
            "date": "1572295499",
            "description": "raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "3s3SWM",
            "likes": 3,
            "name": "simpleRaymarching",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "zrcoy",
            "viewed": 573
        },
        "renderpass": [
            {
                "code": "#define MAX_STEP 100\n#define DIST_SURFACE .01\n#define DIST_MAX 100.\n\nfloat DistToLine(vec3 p, vec3 ro, vec3 rd)\n{\n    return length(cross(p-ro,rd)) / length(rd);\n}\n\nfloat MakePoint(vec3 p , vec3 ro, vec3 rd)\n{\n\treturn smoothstep(0.1f,0.09f,DistToLine(p,ro,rd));\n}\n\n\n//Setup Lookat system for camera\nvec3 Get_rd(vec3 ro, vec2 uv, vec3 lookat, float zoom, vec3 offset)\n{\n \t\n    vec3 worldUp = vec3(0,1,0);\n    vec3 worldRight = vec3(1,0,0);\n    vec3 worldForward = vec3(0,0,1);\n  \t//offset = vec3(0.5f);\n    ro+=offset;\n\n    //look at system\n    //find intersection point    \n    vec3 forward = normalize(lookat - ro);\n    lookat+=offset;\n    vec3 left = normalize(cross(worldUp,forward));\n    vec3 up = normalize(cross(forward, left));\n\tvec3 c = ro + forward * zoom;                           \n    vec3 i = c + uv.x * left + uv.y * up;//intersection point   \n    vec3 rd = i - ro;\n    return rd;\n}\n\nfloat Torus(vec3 p, float r1, float r2 , vec3 pos)//r1 bigger radius\n{\n    p = p-pos;\n    float x = length(p.xz) - r1;\n    float y = p.y;\n    float d = length(vec2(x,y));\n    return d - r2;\n}\n\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r, vec3 pos)\n{\n    p-=pos;\n \tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float ratio = clamp((dot(ap, ab) / dot(ab,ab)), 0., 1.);\n    \n    vec3 PointC = a + ab * ratio;\n    return length(PointC - p)-r;\n}\n\nfloat Box(vec3 p, float side, vec3 pos)\n{\n    p-=pos;\n    float dx = max(abs(p.x) - side,0.);\n    float dy = max(abs(p.y) - side,0.);\n    float dz = max(abs(p.z) - side,0.);\n    return length(vec3(dx,dy,dz));\n}\n\nfloat Cylinder(vec3 p, vec3 a, vec3 b, float r, vec3 pos)\n{\n    p-=pos;\n \tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ap, ab) / dot(ab,ab);    \n    vec3 PointC = a + ab * t;\n    float d = length(PointC - p)-r;\n    float y = abs(t-.5f) - .5f;// make the dist on y range from infinite...0...-0.5...0...infinite \n\tfloat e = length(max(vec2(d,y),0.));\n    float i = min(max(d,y),0.);\n    return e+i;\n}\n\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 ,vec3 pos )\n{\n    p-=pos;\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat GetDist(vec3 p)//a simple scene with just a ground plane and a sphere\n{\n    vec4 Sphere = vec4(.0f, 1.f, 6.f, 1.f);\n    float dP = p.y;\n    float dSphere = length(Sphere.xyz - p) - Sphere.w;\n    float dCapsule = Capsule(p, vec3(0,1,6), vec3(1,2,6),.2f, vec3(0));\n    float dTorus = Torus(p , 1.5f,.2f, vec3(0, .5f, 6.f));\n    float dBox = Box(p,.75f,vec3(-3,1.75f,6.f));\n    float dCylinder = Cylinder(p,vec3(0,.5f,8), vec3(1.5,.5f,4),.4f, vec3(2.f,0,0));\n    float dLink = sdLink(p,1.,.3f,.2f , vec3(0,3,9) );\n    float minD = min(dP,dCapsule);\n    minD = min(minD, dTorus);\n    minD = min(minD, dBox);\n    minD = min(minD, dCylinder);\n    minD = min(minD, dLink);\n    return minD;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarching(vec3 ro, vec3 rd)\n{\n    float dO = .0f;\n    for(int i=0;i<MAX_STEP;i++)\n    {\n     \tvec3 p = ro + rd * dO;\n        float dScene = GetDist(p);\n        dO += dScene;\n        if(dScene < DIST_SURFACE || dScene > DIST_MAX) break;\n    }\n    return dO;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0. , 1.);\n    float shadowR = RayMarching(p + n * DIST_SURFACE * 2., l);\n    if(shadowR < length(p -  lightPos))\n        dif *= .1f;\n    return dif;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 uv = (fragCoord -.5f * iResolution.xy)/ iResolution.y;\n    \n    //primitive camera\n\tvec3 ro = vec3(0, 2, -1);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarching(ro,rd);    \n    \n    vec3 p = ro + rd * d;\n\tfloat dif = GetLight(p);\n    //vec3 col = vec3(sin(iTime),cos(iTime),.5f);\n    vec3 col = vec3(1.f);\n    col*=dif;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}