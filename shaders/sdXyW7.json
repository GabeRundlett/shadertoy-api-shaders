{
    "Shader": {
        "info": {
            "date": "1643762514",
            "description": "While dragging the mouse, press:\n    D: diffuse\n    L: light\n    G: glass\n    M: mirror\nPress R to reset\nSettings are in the Common tab",
            "flags": 48,
            "hasliked": 0,
            "id": "sdXyW7",
            "likes": 51,
            "name": "Drawing Path Tracer",
            "published": 3,
            "tags": [
                "2d",
                "interactive",
                "sdf",
                "draw"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 1046
        },
        "renderpass": [
            {
                "code": "// Try dragging the mouse while pressing D, L, G or M!\n\n// This buffer displays the result from Buffer B.\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    frag_color = texture(iChannel1, frag_coord / iResolution.xy);\n    frag_color.rgb /= frag_color.a;\n    frag_color.rgb = pow(frag_color.rgb, vec3(1.0 / GAMMA));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This buffer's red channel holds the SDF for the drawing,\n// and the blue channel holds information about the type\n// of surface. Whenever the user draws a line segment, the\n// minimum between the current SD and the SD\n// between the pixel and segment is stored. \n\nconst float INFINITY = 1e10;\n\nbool key_pressed(float key_code)\n{\n    return texture(iChannel1, vec2((key_code + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nfloat line_sdf(vec2 p, vec2 a, vec2 b)\n{\n    if (a == b)\n    {\n        return distance(a, p);\n    }\n    \n\tvec2 ab = b - a;\n\tvec2 ap = p - a;\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n\treturn distance(h * ab, ap);\n}\n\nvec2 new_sd(vec2 p)\n{\n    // reset the SDF texture\n    if (iFrame == 0 || key_pressed(KEY_RESET))\n    {\n        return vec2(INFINITY);\n    }\n    \n    // the current SD\n    vec2 sd = texture(iChannel0, p / iResolution.xy).rg;\n    \n    // if currently drawing\n    if (iMouse.z > 0.0 && (key_pressed(KEY_DIFFUSE) || key_pressed(KEY_LIGHT) || key_pressed(KEY_GLASS) || key_pressed(KEY_MIRROR)))\n    {\n        // get previous frame's mouse location if it's valid\n        vec2 prev_mouse = texture(iChannel0, vec2(0.5) / iResolution.xy).ba;\n        prev_mouse = prev_mouse == vec2(-1.0) ? iMouse.xy : prev_mouse;\n        \n        // the new SD is the minimum of the SD to the line segment\n        // and the current\n        float ld = line_sdf(p, prev_mouse, iMouse.xy) - BRUSH_RADIUS * iResolution.y;\n        if (ld < max(sd.r, 0.0))\n        {\n            sd.r = ld;\n            if (key_pressed(KEY_DIFFUSE)) sd.g = float(DIFFUSE);\n            if (key_pressed(KEY_LIGHT)) sd.g = float(EMISSIVE);\n            if (key_pressed(KEY_GLASS)) sd.g = float(GLASS);\n            if (key_pressed(KEY_MIRROR)) sd.g = float(MIRROR);\n        }\n    }\n    \n    return sd;\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    // store the SD in the red channel\n    frag_color.rg = new_sd(frag_coord);\n    \n    // store the mouse position for the next frame in the\n    // blue and alpha channels of the lower left pixel if\n    // it is currently pressed\n    if (frag_coord == vec2(0.5))\n    {\n        if (iMouse.z > 0.0)\n        {\n            frag_color.ba = iMouse.xy;\n        }\n        else\n        {\n            frag_color.ba = vec2(-1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define CF const float\n#define CV const vec3\n#define CI const int\n\n// SETTINGS //\n// SDF RAY MARCHING //\nCI NUM_SAMPLES     = 1;\nCI NUM_BOUNCES     = 5;\nCI MAX_STEPS       = 100;\n\n// DRAWING //\nCF BRUSH_RADIUS    = 0.01; // relative to y resolution\n\n// VISUALS //\nCV SKY_LIGHT       = vec3(0.65, 0.65, 0.70) * 0.6;\nCV DIFFUSE_COLOR   = vec3(1.0, 0.0, 0.0);\nCV EMISSIVE_COLOR  = vec3(1.0, 1.0, 1.0);\nCF EMISSIVITY      = 1.0;\nCV GLASS_COLOR     = vec3(0.0, 1.0, 0.0);\nCF GLASS_IR        = 2.0;\nCV MIRROR_COLOR    = vec3(1.0, 1.0, 1.0);\nCF GAMMA           = 2.2;\n\n// NOT SETTINGS //\nCI DIFFUSE  = 1;\nCI EMISSIVE = 2;\nCI GLASS    = 3;\nCI MIRROR   = 4;\n\nCF KEY_D = 68.0;\nCF KEY_L = 76.0;\nCF KEY_G = 71.0;\nCF KEY_M = 77.0;\nCF KEY_R = 82.0;\n\nCF KEY_DIFFUSE = KEY_D;\nCF KEY_LIGHT   = KEY_L;\nCF KEY_GLASS   = KEY_G;\nCF KEY_MIRROR  = KEY_M;\nCF KEY_RESET   = KEY_R;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This buffer ray traces against the SDF from buffer A.\n// It accumulates samples and stores the number of\n// samples so far in the alpha channel.\n\nconst float PI = 3.141592564;\n\nbool key_pressed(float key_code)\n{\n    return texture(iChannel2, vec2((key_code + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\n// gamma correct colors\nconst vec3 diffuse_color = pow(DIFFUSE_COLOR, vec3(GAMMA));\nconst vec3 emissive_color = pow(EMISSIVE_COLOR, vec3(GAMMA));\nconst vec3 glass_color = pow(GLASS_COLOR, vec3(GAMMA));\nconst vec3 mirror_color = pow(MIRROR_COLOR, vec3(GAMMA));\nconst vec3 sky_light = pow(SKY_LIGHT, vec3(GAMMA));\n\nint seed;\n\nfloat rand()\n{\n    int n = (seed++ << 13) ^ seed;\n    return float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483647.0;\n}\n\nfloat rand(int seed)\n{\n    int n = (seed++ << 13) ^ seed;\n    return float((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 2147483647.0;\n}\n\nvoid set_seed(vec2 p)\n{\n    seed = int(p.x + p.y * iResolution.x);\n\tseed = int(rand() * 2147483647.0) + iFrame;\n}\n\nvec2 sdf(vec2 p)\n{\n    return texture(iChannel0, p / iResolution.xy).rg;\n}\n\nvec2 grad(vec2 p)\n{\n    const vec2 e = vec2(1.0, 0.0);\n    return vec2(\n        sdf(p + e.xy).x - sdf(p - e.xy).x, \n        sdf(p + e.yx).x - sdf(p - e.yx).x\n    ) / 2.0;\n}\n\nstruct Mat\n{\n    int type;\n    vec3 c; // color\n    float e; // emissivity\n};\n\nMat mat(vec2 p)\n{\n    float s = sdf(floor(p) + 0.5).y;\n    Mat m;\n    m.type = int(s);\n    m.c =\n        m.type == DIFFUSE  ? diffuse_color  :\n        m.type == EMISSIVE ? emissive_color :\n        m.type == GLASS    ? glass_color    : \n        m.type == MIRROR   ? mirror_color   :\n        vec3(0.0);\n    m.e = m.type == EMISSIVE ? EMISSIVITY : 0.0;\n    m.type = m.type == EMISSIVE ? DIFFUSE : m.type;\n    return m;\n}\n\nfloat ray_march(vec2 o, vec2 d)\n{\n    const float EPSILON = 0.1;\n    float t = 0.0;\n    vec2 p = o;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = abs(sdf(p).x);\n        \n        if (EPSILON < t && dist < EPSILON)\n        {\n            return t;\n        }\n        \n        t += dist;\n        p = o + d * t;\n        \n        if (p.x < 0.0 || iResolution.x <= p.x || p.y < 0.0 || iResolution.y <= p.y)\n        {\n            break;\n        }\n    }\n    \n    return -1.0;\n}\n\nstruct Hit \n{\n    vec2 p; // position\n    vec2 n; // normal\n    Mat m; // material\n};\n\nHit hit(vec2 o, vec2 d)\n{\n    float t = ray_march(o, d);\n    \n    if (t == -1.0)\n    {\n        return Hit(vec2(0.0), vec2(0.0), Mat(0, vec3(0.0), 0.0));\n    }\n    \n    Hit h;\n    h.p = o + d * t;\n    h.n = normalize(grad(h.p));\n    h.m = mat(h.p);\n    return h;\n}\n\n\nvec2 sample_semicircle(vec2 n, float t)\n{\n    t *= 2.0 * PI;\n    vec2 s = vec2(cos(t), sin(t));\n    return s * sign(dot(s, n));\n}\n\nvec3 trace(vec2 o, vec2 d)\n{    \n    vec3 final_color = vec3(0.0);\n    vec3 multiplier = vec3(1.0);\n    \n    // handle case when ray origin is inside drawing\n    if (sdf(o).x < 0.0)\n    {\n        Mat m = mat(o);\n        switch (m.type)\n        {\n            case MIRROR:\n            case DIFFUSE:\n            {\n                float t = ray_march(o, d);\n                o += d * (t + 1.0);\n                multiplier *= m.c;\n                final_color += multiplier * m.e;\n                break;\n            }\n        }\n    }\n    \n    for (int i = 0; i < NUM_BOUNCES; ++i)\n    {\n        Hit h = hit(o, d);\n        \n        if (h.n == vec2(0.0))\n        {\n            final_color += multiplier * sky_light;\n            break;\n        }\n        \n        h.n *= -sign(dot(h.n, d));\n        multiplier *= h.m.c;\n        final_color += multiplier * h.m.e;\n        \n        switch (h.m.type)\n        {\n            case DIFFUSE:\n            {\n                o = h.p;\n                d = sample_semicircle(h.n, rand());\n                multiplier *= dot(d, h.n);\n                break;\n            }\n            \n            case GLASS:\n            {                \n                // i think this is incorrect :c\n                float n1 = 1.0;\n                float n2 = GLASS_IR;\n                \n                if (sdf(h.p).x < 0.0)\n                {\n                    n1 = GLASS_IR;\n                    n2 = 1.0;\n                }\n                \n                float eta = n1 / n2;\n                float c1 = -dot(h.n, d);\n                float k = 1.0 - eta * eta * (1.0 - c1 * c1);\n                \n                if (k < 0.0)\n                {\n                    o = h.p;\n                    d = reflect(d, h.n);\n                \n                    break;\n                }\n                \n                float c2 = sqrt(k);\n                float rs = (n1 * c1 - n2 * c2) / (n1 * c1 + n2 * c2);\n                \n                if (rand() < rs)\n                {\n                    o = h.p;\n                    d = reflect(d, h.n);\n                \n                    break;\n                }\n                \n                o = h.p;\n                d = eta * d - (eta * -c1 + c2) * h.n;\n                o += d;\n                \n                break;\n            }\n            \n            case MIRROR:\n            {\n                o = h.p;\n                d = reflect(d, h.n);\n                break;\n            }\n        }\n    }\n    \n    return final_color;\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    set_seed(frag_coord);\n    \n    vec3 result = vec3(0.0);\n    \n    // accumulate samples by tracing rays in all directions\n    for (int i = 0; i < NUM_SAMPLES + min(0, iFrame); ++i)\n    {\n        float blue_noise = fract(\n            texture(iChannel3, frag_coord / iChannelResolution[3].xy).r +\n            fract(float(iFrame * NUM_SAMPLES + i) * 0.61803399)\n        );\n        float r = blue_noise;\n        //r = rand();\n        float a = 2.0 * PI * (float(i) + r) / float(NUM_SAMPLES);\n        vec2 o = floor(frag_coord) + vec2(rand(), rand());\n        vec2 d = vec2(cos(a), sin(a));\n        result += trace(o, d);\n    }\n    \n    result /= float(NUM_SAMPLES);\n    frag_color = vec4(result, 1.0);\n    \n    // accumulate samples from previous frame if \n    // scene hasn't changed. alpha channel keeps\n    // track of how many frames have been accumulated\n    if (iMouse.z <= 0.0 && !key_pressed(KEY_RESET))\n    {\n        vec4 t = texture(iChannel1, frag_coord / iResolution.xy);\n        \n        if (t.a >= 1e10)\n        {\n            frag_color = t;\n        }\n        else\n        {\n            frag_color += t;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}