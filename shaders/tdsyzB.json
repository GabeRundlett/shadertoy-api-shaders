{
    "Shader": {
        "info": {
            "date": "1585076049",
            "description": "\"Sampling Projected Spherical Caps in Real Time\"\nhttp://momentsingraphics.de/I3D2019.html\nComparing different sampling strategies:\nLeft - Area sampling\nMiddle- Solid Angle sampling\nRight - Projected solid Angle sampling",
            "flags": 0,
            "hasliked": 0,
            "id": "tdsyzB",
            "likes": 23,
            "name": "Sampling Projected Spherical Cap",
            "published": 3,
            "tags": [
                "light",
                "sampling",
                "solidangle",
                "optimal"
            ],
            "usePreview": 0,
            "username": "koiava",
            "viewed": 982
        },
        "renderpass": [
            {
                "code": "#define PIXEL_SAMPLES \t\t1\t\t\t//Increase for higher quality(better AA)\n#define LIGHT_SAMPLES\t\t1\t\t\t//Increase for higher quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\t\t\t//shadows are broken for PSA\n#define SHOW_LIGHT\n#define LIGHT_CLIPPING\n#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t0\n#define SAMPLE_SA\t\t\t\t1\n#define SAMPLE_PSA\t\t\t\t2\n#define SAMPLE_NONE\t\t\t\t3\nint samplingTechnique;\nfloat split1;\nfloat split2;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_TRIANGLE\t4\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createTriangle(mat4 transform, vec2 v1, vec2 v2, vec2 v3, int mtl, out Object obj) {\n    obj.type_ = OBJ_TRIANGLE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = v1.x;\t\t\t\n    obj.params_[1] = v1.y;\t\t\t\n    obj.params_[2] = v2.x;\t\t\t\n    obj.params_[3] = v2.y;\t\t\t\n    obj.params_[4] = v3.x;\t\t\n    obj.params_[5] = v3.y;\t\t\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float z = -1.0;\n    mat4 trans = createCS(\tvec3(-0.2, -0.401 + (1.0 + sin(iTime)*1.7), z),\n                          \tvec3(0.0, 0.0, 1.0),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n    createSphere(trans, 0.6, MTL_LIGHT, objects[0] );\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -7.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.3, -0.15, -3.0, 1.0 ));\n\n    createSphere(trans, 0.6, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.25), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool rayIntersectsTriangle(in Ray ray, vec3 v0, vec3 v1, vec3 v2, in bool forShadowTest, out float t, out SurfaceHitInfo isect){\n    vec3 p = ray.origin;\n    vec3 d = ray.dir;\n    \n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn false;\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tif (u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\t//uv = vec2(u, v);\n\t\n\tif (t > 0.00001) // ray intersection\n\t\treturn true;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n        isect.uv_.x = isect.position_.x;\n        isect.uv_.y = isect.position_.y;\n    }\n\n\t// this means that there is a line intersection\n\t// but not a ray intersection\n\treturn false;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_TRIANGLE ) {\n        vec3 v1 = vec3(obj.params_[0], obj.params_[1], 0.0);\n        vec3 v2 = vec3(obj.params_[2], obj.params_[3], 0.0);\n        vec3 v3 = vec3(obj.params_[4], obj.params_[5], 0.0);\n        hitResult = rayIntersectsTriangle(rayLocal, v1, v2, v3, forShadowTest, t, currentHit);\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n\n        if( dot( ray.dir, hit.normal_ ) > 0.0 )\n            hit.normal_ *= -1.0;\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n#ifdef SHOW_LIGHT\n    CHECK_OBJ( objects[0] );\n#else\n    if(forShadowTest) {\n    \tCHECK_OBJ( objects[0] );\n    }\n#endif\n    CHECK_OBJ( objects[1] );\n    CHECK_OBJ( objects[2] );\n    CHECK_OBJ( objects[3] );\n    CHECK_OBJ( objects[4] );\n    CHECK_OBJ( objects[5] );\n    CHECK_OBJ( objects[6] );\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformPointWitinTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in float Xi1, in float Xi2 ) {\n    Xi1 = sqrt(Xi1);\n    return (1.0-Xi1)*v1 + Xi1*(1.0-Xi2)*v2 + Xi1*Xi2*v3;\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, -1.2, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\nvoid sampleSphereArea(vec3 pos, vec3 normal, vec2 xi, out vec3 dir, out float pdf) {\n    float pdfA;\n    float d2;\n    float aCosThere;\n    \n    float rad = objects[0].params_[0];\n    float rad2 = objects[0].params_[1];\n    \n    vec3 n = randomDirection(xi.x, xi.y);\n    vec3 p = n*rad;\n    pdfA = 1.0/(4.0*PI*rad2);\n\n    dir = p - pos;\n    d2 = dot(dir,dir);\n    dir /= sqrt(d2);\n    aCosThere = max(0.0,dot(-dir,n));\n\n    pdf = PdfAtoW( pdfA, d2, aCosThere );\n}\n\nvoid sampleSphereSolidAngle(vec3 pos, vec3 normal, vec2 xi, out vec3 dir, out float pdf) {\n\tfloat rad = objects[0].params_[0];\n    float rad2 = objects[0].params_[1];\n    \n    vec3 w = -pos;\t\t\t//direction to light center\n    float dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n\n    if(dc > rad) {\n        float sin_theta_max_2 = rad2 / dc_2;\n        float cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n        float cos_theta = mix( cos_theta_max, 1.0, xi.x );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n        float sin_theta = sqrt(sin_theta_2);\n        dir = uniformDirectionWithinCone( w, TWO_PI*xi.y, sin_theta, cos_theta );\n        pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n    } else {\n        dir = vec3(0.0);\n        pdf = 0.0;\n    }\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(4.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = L;\n        } else {\n            float rad = objects[0].params_[0];\n            //convert position to object space\n            vec3 lp = toVec3( objects[0].transform_inv_*vec4(hit.position_, 1.0) );\n            vec3 ln = toVec3( objects[0].transform_inv_*vec4(hit.normal_, 0.0) );\n            ProjectedSphericalCap cap;\n            \n            if(samplingTechnique == SAMPLE_PSA){\n                prepareProjectedSphericalCapSampling(cap, ln, -lp, rad);\n            }\n            \n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                vec3 lwi;\n                float pdfWi;\n                \n            \tvec2 xi = vec2(rnd(), rnd());\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                xi.y = strataSize * (float(i) + xi.y);\n#endif\n                \n                if(samplingTechnique == SAMPLE_TOTAL_AREA){\n                    sampleSphereArea(lp, ln, xi, lwi, pdfWi);\n                } else if(samplingTechnique == SAMPLE_SA){\n                    sampleSphereSolidAngle(lp, ln, xi, lwi, pdfWi);\n                } else {\n                    // Spherical cap sampling from : http://momentsingraphics.de/I3D2019.html\n                    // Method samples projected spherical cap which has 4 cases:\n                    // 1 - entirely above the horizon\n                    // 2 - mostly above (intersecting horizon)\n                    // 3 - mostly below (intersecting horizon)\n                    // 4 - entirely below the horizon\n                    // problem simplifies to a partial elipse sampling. for more details read paper :)\n                    lwi = sampleProjectedSphericalCap(pdfWi, cap, xi);\n                    pdfWi *= dot(lwi, ln);\n                \t\n                }\n                \n                //convert dir to world space\n    \t\t\tWi = toVec3( objects[0].transform_*vec4(lwi, 0.0));\n                \n\n                float dotNWi = dot( lwi, ln );\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + hit.normal_*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x/iResolution.x;\n    if(iMouse.z<0.0 || iMouse.x==0.0) {\n      \tsplit1 = 0.0;\n        split2 = 0.0;  \n    } else {\n        split1 = iMouse.x*k;\n        split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    }\n    \n    if(p < split1-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if((p > split1+1.0) && (p < split2-1.0)) {\n        samplingTechnique = SAMPLE_SA;\n    } else if(p > split2+1.0){\n        samplingTechnique = SAMPLE_PSA;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, -1.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Copyright (c) 2019, Christoph Peters\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Karlsruhe Institute of Technology nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n#define M_PI 3.14159265\n#define M_PI2 (3.14159265*2.0)\n\n#define mad(v1, v2, v3) (v1*v2+v3)\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat lerp(float a, float b, float p) { return a + (b - a) * p; }\n\n/*! This structure carries intermediate results that only need to be computed \n\tonce per spherical cap for sampling proportional to projected solid angle. \n\tOnce it is available, the sampling is relatively fast. Dependent on the \n\tgeometric configuration, some of the entries have undefined values. Each \n\tentry has a corresponding comment referring to the following cases:\n\t- Case 1: The spherical cap is entirely above the horizon.\n\t- Case 2: The spherical cap intersects the horizon but has its center above \n\t\tthe horizon.\n\t- Case 3: The spherical cap intersects the horizon but has its center below \n\t\tthe horizon.*/\nstruct ProjectedSphericalCap{\n\t/*! These three vectors define an orthonormal, positively oriented frame \n\t\tin which the spherical cap has its center at y-coordinate zero.\n\t\t\\note Available in cases 1, 2, 3.*/\n\tvec3 tangent;\n\tvec3 bitangent;\n\tvec3 normal;\n\t/*! The normalized vector towards the center of the spherical cap.\n\t\t\\note Available in cases 1, 2 and 3 but only used by \n\t\t\t\tcomputeProjectedSphericalCapSampleDensity().*/\n\tvec3 normalizedCenter;\n\t/*! The boundary of the spherical cap is a circle. This vector stores half \n\t\tthe extent of its axis-aligned bounding box along x and y. By \n\t\tconvention, the x-extent is negative if and only if the center of the \n\t\tspherical cap is below the horizon.\n\t\t\\note Available in cases 1, 2 and 3.*/\n\tvec2 circleHalfExtent;\n\t/*! The reciprocal of what would go into circleHalfExtent.z if it existed.\n\t\t\\note Available in case 3.*/\n\tfloat invCircleHalfExtentZ;\n\t/*! The x-coordinate of the center of the circle bounding the spherical \n\t\tcap. The y-coordinate is zero due to the choice of the local \n\t\tcoordinate-frame.\n\t\t\\note Available in cases 1 and 2.*/\n\tfloat circleCenterX;\n\t/*! Minus the z-coordinate of the center of the circle bounding the \n\t\tspherical cap, divided by half its extent along z.\n\t\t\\note Available in case 3. Then this is positive.*/\n\tfloat centerOverHalfExtentZ;\n\t/*! The distance between the origin and the plane of the circle bounding \n\t\tthe spherical cap.\n\t\t\\note Available in cases 1, 2 and 3 but only used by \n\t\t\t\tcomputeProjectedSphericalCapSampleDensity().*/\n\tfloat planeOriginDistance;\n\t/*! The plane of the circle bounding the spherical cap intersects the \n\t\tx-axis at this coordinate. It is <1.0f iff the cap is partially below \n\t\tthe horizon.\n\t\t\\note Available in cases 1, 2 and 3.*/\n\tfloat diskCutX;\n\t/*! 1.0f-diskCutX*diskCutX. This is the square of the y-coordinate of the \n\t\tlocation where the plane intersects the horizon.\n\t\t\\note Available in case 3.*/\n\tfloat squaredDiskCutY;\n\t/*! The factor by which sample points need to be scaled along the z-axis to \n\t\twarp them into the spherical cap.\n\t\t\\note Available in case 3.*/\n\tfloat scaleZ;\n\t/*! In cases 1 and 2, this is the constant sampled density, i.e. the \n\t\treciprocal of the projected solid angle. In case 3, it is a constant \n\t\tfactor that is pulled out of the computation of the probability density \n\t\tfunction. It is exactly 0.0f if the spherical cap is entirely below \n\t\tthe horizon.\n\t\t\\note Available in cases 1, 2 and 3.*/\n\tfloat densityFactor;\n\t/*! The threshold for the random number at which we need to transition from \n\t\tsampling of the cut ellipse to sampling of the cut disk. In other \n\t\twords, it is the ratio of these two areas.\n\t\t\\note Available in case 2.*/\n\tfloat cutEllipseAreaRatio;\n\t/*! The factor needed to turn a random number into a normalized area (i.e. \n\t\tfrom 0 to pi) for the cut ellipse.\n\t\t\\note Available in case 2.*/\n\tfloat randomToCutEllipseAreaFactor;\n\t/*! The factor needed to turn a random number into the area to the right of \n\t\tthe point on the cut disk that is sampled.\n\t\t\\note Available in cases 2 and 3.*/\n\tfloat randomToCutDiskAreaFactor;\n\t/*! The projected solid angle of the spherical cap. Exactly 0.0f if it is \n\t\tentirely below the horizon. Uncomment the appropriate lines in \n\t\tprepareProjectedSphericalCapSampling() if you need this. It only incurs \n\t\tan additional cost in case 3.\n\t\t\\note Available in cases 1, 2 and 3 if uncommented.*/\n\t//float projectedSolidAngle;\n};\n\n\n/*! This structure carries intermediate results that only need to be computed \n\tonce per spherical cap for sampling proportional to solid angle.*/\nstruct SphericalCap{\n\t/*! These three vectors define an orthonormal, positively oriented frame \n\t\tin which the normal points towards the center of the spherical cap and \n\t\tthe other two directions are arbitrary.*/\n\tvec3 tangent,bitangent,normal;\n\t/*! The minimal dot product between normal and a point inside the spherical\t\n\t\tcap. This is an efficient way to express the opening angle of the cap.*/\n\tfloat minimalDot;\n\t/*! The solid angle of the spherical cap in steradians.*/\n\tfloat solidAngle;\n};\n\n\n/*! Returns the signed area enclosed by the unit disk between x=0 and \n\tx=MaximalX.*/\nfloat getCutDiskArea(float maximalX){\n\treturn mad(sqrt(mad(-maximalX,maximalX,1.0f)),maximalX,asin(maximalX));\n}\n\n\n/*! Implements the inverse of getCutDiskArea().\n   \\note This implementation factors the inverse function into a part with a \n\t\t singularity and a quintic polynomial. The worst-case error is around \n\t\t 4e-6.*/\nfloat getAreaDiskCut(float area){\n\tfloat absArea=min(0.5f*M_PI,abs(area));\n\tfloat polynomial=mad(mad(mad(mad(mad(absArea,-0.0079908617f,0.0238255409f),absArea,-0.0283903598f),absArea,0.0198450184f),absArea,-0.0574433620f),absArea,0.7400712465f);\n\tfloat result=1.0f-polynomial*pow(0.5f*M_PI-absArea,2.0f/3.0f);\n\treturn (area<0.0f)?(-result):result;\n}\n\n\n/*!\tPrepares all intermediate values to sample a spherical cap proportional to \n\tprojected solid angle. The surface normal and sphere center are given in \n\tthe same space, the sphere center is relative to the surface point for \n\twhich samples are taken. The surface normal has to be normalized.\n\t\\note For directional lights sphereCenter should be a normalized direction \n\t\t\tvector towards the light source and sphereRadius should be \n\t\t\tsin(0.5f*alpha) where alpha is the angle spanned by the light \n\t\t\tsource.*/\nvoid prepareProjectedSphericalCapSampling(out ProjectedSphericalCap cap, vec3 surfaceNormal,vec3 sphereCenter,float sphereRadius){\n\tfloat invCenterDistance= 1.0 / sqrt(dot(sphereCenter,sphereCenter));\n\t// Construct a tangent frame where the normal is aligned with the positive \n\t// z-axis and the projection of the sphere center onto the surface tangent \n\t// plane is aligned with the positive x-axis.\n\tcap.normal=surfaceNormal;\n\tcap.normalizedCenter=invCenterDistance*sphereCenter;\n\tfloat normalizedCenterZ = dot(cap.normal,cap.normalizedCenter);\n\tcap.tangent = mad(-normalizedCenterZ,cap.normal,cap.normalizedCenter);\n\tfloat invTangentLength = 1.0 / sqrt(dot(cap.tangent,cap.tangent));\n\tcap.tangent*=invTangentLength;\n\tfloat normalizedCenterX=dot(cap.tangent,cap.normalizedCenter);\n\tcap.bitangent=cross(cap.normal,cap.tangent);\n\t// Compute the radius of the circle that bounds the spherical cap. It \n\t// agrees with half the diameter of the ellipse, which is also the extent \n\t// along y.\n\tcap.circleHalfExtent.y=sphereRadius*invCenterDistance;\n\t// Compute the width of the ellipse (extent along x). Negative if the \n\t// sphere center is below the horizon.\n\tcap.circleHalfExtent.x=cap.circleHalfExtent.y*normalizedCenterZ;\n\t// Compute the location of the center of the ellipse along the x-axis\n\tcap.planeOriginDistance=sqrt(mad(-cap.circleHalfExtent.y,cap.circleHalfExtent.y,1.0f));\n\tcap.circleCenterX=cap.planeOriginDistance*normalizedCenterX;\n\t// Compute where the plane of the circle bounding the spherical cap \n\t// intersects the x-axis\n\tcap.diskCutX=cap.planeOriginDistance*invTangentLength;\n\t// Case 1: The spherical cap is entirely above the horizon or maybe\n\t// case 4: The spherical cap is entirely below the horizon and thus empty\n\tif(cap.diskCutX>=1.0f){\n\t\t// The projected solid angle is an ellipse\n\t\tfloat projectedSolidAngle=M_PI*cap.circleHalfExtent.x*cap.circleHalfExtent.y;\n\t\t//cap.projectedSolidAngle=projectedSolidAngle;\n\t\tcap.densityFactor=max(0.0f,1.0f/projectedSolidAngle);\n\t\t// Set irrelevant variables to bogus values\n\t\tcap.invCircleHalfExtentZ=cap.centerOverHalfExtentZ=cap.scaleZ=cap.squaredDiskCutY=cap.cutEllipseAreaRatio=cap.randomToCutEllipseAreaFactor=cap.randomToCutDiskAreaFactor=0.0f;\n\t}\n\t// Cases 2 and 3, the spherical cap intersects the horizon\n\telse{\n\t\t// The area of the cut disk is needed for case 2 and 3\n\t\tfloat cutDiskArea=0.5f*M_PI-getCutDiskArea(cap.diskCutX);\n\t\t// Case 3, the spherical cap intersects the horizon but its center is \n\t\t// below the horizon\n\n\t\tif(cap.circleHalfExtent.x<=0.0f){\n\t\t\tfloat circleCenterZ=normalizedCenterZ*cap.planeOriginDistance;\n\t\t\tfloat circleHalfExtentZ=cap.circleHalfExtent.y*normalizedCenterX;\n\t\t\tfloat circleMaxZ=circleCenterZ+circleHalfExtentZ;\n\t\t\tcap.invCircleHalfExtentZ=1.0f/circleHalfExtentZ;\n\t\t\tcap.centerOverHalfExtentZ=-circleCenterZ*cap.invCircleHalfExtentZ;\n\t\t\tcap.squaredDiskCutY=saturate(mad(-cap.diskCutX,cap.diskCutX,1.0f));\n\t\t\tcap.scaleZ=circleMaxZ*(1.0 / sqrt(cap.squaredDiskCutY));\n\t\t\tcap.densityFactor=cap.squaredDiskCutY/(circleMaxZ*circleMaxZ*cutDiskArea);\n\t\t\tcap.randomToCutDiskAreaFactor=cutDiskArea;\n\t\t\t// Set irrelevant variables to bogus values\n\t\t\tcap.cutEllipseAreaRatio=cap.randomToCutEllipseAreaFactor=0.0f;\n\t\t\t// Optionally compute the projected solid angle. We do not need it for \n\t\t\t// sampling but it may be useful in some contexts.\n\t\t\t//float ellipseCutRatioX=-saturate(-(cap.diskCutX-cap.circleCenterX)/cap.circleHalfExtent.x);\n\t\t\t//float normalizedEllipseArea=0.5f*M_PI+getCutDiskArea(ellipseCutRatioX);\n\t\t\t//cap.projectedSolidAngle=cap.circleHalfExtent.x*cap.circleHalfExtent.y*normalizedEllipseArea+cutDiskArea;\n\t\t}\n\t\t// Case 2, the spherical cap intersects the horizon but its center is \n\t\t// above the horizon\n\t\telse{\n\t\t\t// Compute the area of the cut ellipse and the total projected solid \n\t\t\t// angle\n\t\t\tfloat ellipseCutRatioX = saturate((cap.diskCutX-cap.circleCenterX)/cap.circleHalfExtent.x);\n\t\t\tfloat normalizedEllipseArea=0.5f*M_PI+getCutDiskArea(ellipseCutRatioX);\n\t\t\tfloat cutEllipseArea=cap.circleHalfExtent.x*cap.circleHalfExtent.y*normalizedEllipseArea;\n\t\t\tfloat projectedSolidAngle=cutEllipseArea+cutDiskArea;\n\t\t\t//cap.projectedSolidAngle=projectedSolidAngle;\n\t\t\tcap.densityFactor=1.0f/projectedSolidAngle;\n\t\t\t// Prepare the decision which cut disk will be sampled\n\t\t\tcap.cutEllipseAreaRatio=cutEllipseArea*cap.densityFactor;\n\t\t\tcap.randomToCutEllipseAreaFactor=normalizedEllipseArea/cap.cutEllipseAreaRatio;\n\t\t\tcap.randomToCutDiskAreaFactor=cutDiskArea/(1.0f-cap.cutEllipseAreaRatio);\n\t\t\t// Set irrelevant variables to bogus values\n\t\t\tcap.invCircleHalfExtentZ=cap.centerOverHalfExtentZ=cap.scaleZ=cap.squaredDiskCutY=0.0f;\n\t\t}\n\t}\n\t// For points inside the light source, we treat the projected spherical cap \n\t// as empty\n\tcap.densityFactor=(cap.circleHalfExtent.y>=1.0f)?0.0f:cap.densityFactor;\n\t//cap.projectedSolidAngle=(cap.circleHalfExtent.y>=1.0f)?0.0f:cap.projectedSolidAngle;\n}\n\n\n/*! \\return true iff the given projected spherical cap is empty.*/\nbool isProjectedSphericalCapEmpty(ProjectedSphericalCap cap){\n\treturn cap.densityFactor<=0.0f;\n}\n\n\n/*! Given the output of prepareProjectedSphericalCapSampling(), this function \n\tmaps given random numbers in the range from 0 to 1 to a normalized \n\tdirection vector providing a sample of the spherical cap in the original \n\tspace (used for arguments of prepareSphericalCapSampling()). If the input \n\trandom numbers are independent and uniform, the distribution of the output \n\trandom variables has the probability density function outDensity with \n\trespect to the planar Lebesgue measure. The density is constant (i.e. \n\tindependent of the random numbers) unless the sphere center is below the \n\thorizon. Otherwise the ratio between maximum and minimum is bounded by \n\tsqrt(2).*/\n    vec3 sampleProjectedSphericalCap(out float outDensity,ProjectedSphericalCap cap, vec2 randomNumbers){\n\tfloat area;\n\tbool sampleEllipse;\n\t// If the sphere center is below the horizon, we want to sample the cut \n\t// unit disk\n\tif(cap.circleHalfExtent.x<=0.0f){\n\t\tarea=mad(randomNumbers.x,-cap.randomToCutDiskAreaFactor,cap.randomToCutDiskAreaFactor);\n\t}\n\t// If the sphere center is above the horizon but the sphere intersects it, \n\t// we need to decide whether we want to sample the cut unit disk or the cut \n\t// ellipse\n\telse if(cap.diskCutX<1.0f){\n\t\tsampleEllipse=(randomNumbers.x<cap.cutEllipseAreaRatio);\n\t\tarea=sampleEllipse?\n\t\t\t(randomNumbers.x*cap.randomToCutEllipseAreaFactor):\n\t\t\tmad(randomNumbers.x,-cap.randomToCutDiskAreaFactor,cap.randomToCutDiskAreaFactor);\n\t}\n\t// If the sphere is entirely above the horizon, we sample the ellipse\n\telse{\n\t\tarea=M_PI*randomNumbers.x;\n\t}\n\t// Sample the cut disk\n\tvec3 disk;\n\tdisk.x=getAreaDiskCut(area-0.5f*M_PI);\n\tdisk.y=sqrt(mad(-disk.x,disk.x,1.0f))*mad(randomNumbers.y,2.0f,-1.0f);\n\t// If the sphere center is below the horizon, we need to warp the samples \n\t// further and compute the density\n\tvec3 local;\n\toutDensity=cap.densityFactor;\n        \n\tif(cap.circleHalfExtent.x<=0.0f){\n\t\tdisk.x=-disk.x;\n\t\tdisk.z=sqrt(saturate(mad(-disk.x,disk.x,mad(-disk.y,disk.y,1.0f))));\n\t\t// Scale down along Z to get the appropriate maximal Z\n\t\tlocal.z=disk.z*cap.scaleZ;\n\t\t// Scale down along Y to account for the different shape of the cut disk\n\t\tfloat zQuotient=mad(local.z,cap.invCircleHalfExtentZ,cap.centerOverHalfExtentZ);\n\t\tfloat scaleY=cap.circleHalfExtent.y*sqrt(max(0.0f,mad(-zQuotient,zQuotient,1.0f)/mad(-disk.z,disk.z,cap.squaredDiskCutY)));\n\t\tlocal.y=disk.y*scaleY;\n\t\t// Turn it into a normalized vector to get X\n\t\tlocal.x=sqrt(saturate(mad(-local.y,local.y,mad(-local.z,local.z,1.0f))));\n\t\t// Compute the proper density\n\t\toutDensity*=local.x/(disk.x*scaleY);\n\t}\n\t// If the sphere center is above the horizon but the sphere intersects it, \n\t// we may be sampling the cut disk\n\telse if(cap.diskCutX<1.0f && !sampleEllipse){\n\t\tlocal.x=-disk.x;\n\t\tlocal.y=disk.y;\n\t\tlocal.z=sqrt(saturate(mad(-local.x,local.x,mad(-local.y,local.y,1.0f))));\n\t}\n\t// Otherwise we are sampling the ellipse (either the cut ellipse or the \n\t// entire ellipse, it does not make a difference here)\n\telse{\n\t\tlocal.x=mad(disk.x,cap.circleHalfExtent.x,cap.circleCenterX);\n\t\tlocal.y=cap.circleHalfExtent.y*disk.y;\n\t\tlocal.z=sqrt(saturate(mad(-local.x,local.x,mad(-local.y,local.y,1.0f))));\n\t}\n\t// Go back to the original coordinate frame\n\treturn local.x*cap.tangent+local.y*cap.bitangent+local.z*cap.normal;\n}\n\n\n/*! Given a normalized direction and a projected spherical cap, this function \n\treturns the probability density for sampleProjectedSphericalCap() returning \n\tthe given direction. In particular, it returns 0 if the given direction is \n\tnot within the spherical cap and the upper hemisphere. This functionality \n\tis useful for multiple importance sampling when the given direction has \n\tbeen produced by a different sampling technique.\n\t\\note As for sampleProjectedSphericalCap() the returned density is defined \n\t\t\twith respect to the projected solid angle measure. If you want a \n\t\t\tdensity with respect to the solid angle measure, you have to \n\t\t\tmultiply by dot(cap.normal,sampledDirection).*/\nfloat computeProjectedSphericalCapSampleDensity(vec3 sampledDirection,ProjectedSphericalCap cap){\n\t// Early out if the sample is not in the spherical cap\n\tif(dot(cap.normalizedCenter,sampledDirection)<cap.planeOriginDistance){\n\t\treturn 0.0f;\n\t}\n\t// Early out if the sample is in the lower hemisphere\n\tvec3 local;\n\tlocal.z=dot(cap.normal,sampledDirection);\n\tif(local.z<0.0f){\n\t\treturn 0.0f;\n\t}\n\t// If the sphere center is below the horizon, things are a little \n\t// complicated\n\tif(cap.circleHalfExtent.x<=0.0f){\n\t\tlocal.x=dot(cap.tangent,sampledDirection);\n\t\tlocal.y=dot(cap.bitangent,sampledDirection);\n\t\t// Reconstruct the scaling along the y-axis\n\t\tvec3 disk;\n\t\tdisk.z=local.z/cap.scaleZ;\n\t\tfloat zQuotient=mad(local.z,cap.invCircleHalfExtentZ,cap.centerOverHalfExtentZ);\n\t\tfloat scaleY=cap.circleHalfExtent.y*sqrt(max(0.0f,mad(-zQuotient,zQuotient,1.0f)/mad(-disk.z,disk.z,cap.squaredDiskCutY)));\n\t\t// Get the whole point in the disk that would have been sampled to \n\t\t// produce this sample\n\t\tdisk.y=local.y/scaleY;\n\t\tdisk.x=sqrt(saturate(mad(-disk.y,disk.y,mad(-disk.z,disk.z,1.0f))));\n\t\t// Compute the density\n\t\treturn cap.densityFactor*local.x/(disk.x*scaleY);\n\t}\n\telse{\n\t\t// Otherwise the density is constant and has already been computed\n\t\treturn cap.densityFactor;\n\t}\n}\n\n\n/*!\tPrepares all intermediate values to sample a spherical cap proportional to \n\tsolid angle. The sphere center is given relative to the surface point for \n\twhich samples are taken.*/\nvoid prepareSphericalCapSampling(out SphericalCap cap, vec3 sphereCenter,float sphereRadius){\n\tfloat invCenterDistance = 1.0 / sqrt(dot(sphereCenter,sphereCenter));\n\t// Construct a coordinate frame where z is aligned with the vector to the \n\t// sphere center\n\tcap.normal = invCenterDistance*sphereCenter;\n\tcap.tangent = normalize(cross(cap.normal,vec3(0.0f,1.0f,0.0f)));\n\tcap.bitangent=cross(cap.normal,cap.tangent);\n\t// Compute the radius of the circle that bounds the spherical cap\n\tfloat maximalRadius=sphereRadius*invCenterDistance;\n\tcap.minimalDot=sqrt(saturate(mad(-maximalRadius,maximalRadius,1.0f)));\n\tcap.solidAngle=mad(-cap.minimalDot,M_PI2,M_PI2);\n}\n\n\n/*! Maps independent, uniform random numbers from 0 to 1 to world space samples \n\tin the given spherical cap. Samples are distributed in proportion to solid \n\tangle.\n\t\\param cap The output of prepareProjectedSphericalCapSampling().\n\t\\return The sampled direction in world space.*/\n\tvec3 sampleSphericalCap(SphericalCap cap, vec2 randomNumbers){\n\tvec3 local;\n\tlocal.z = lerp(cap.minimalDot,1.0f,randomNumbers.x);\n\t// Complete to a point on the sphere\n\tfloat radius=sqrt(saturate(mad(-local.z,local.z,1.0f)));\n\tlocal.x=radius*cos(M_PI2*randomNumbers.y);\n\tlocal.y=radius*sin(M_PI2*randomNumbers.y);\n\t// Now turn that into a world space sample\n\treturn local.x*cap.tangent+local.y*cap.bitangent+local.z*cap.normal;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}