{
    "Shader": {
        "info": {
            "date": "1548810630",
            "description": "A simple ray marched scene for learning purposes.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sS3DW",
            "likes": 5,
            "name": "Ray Marching playground",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "lams3",
            "viewed": 563
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001f;\n\nstruct intersection {\n    bool hit;\n    vec3 point;\n    vec3 normal;\n};\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n\tvec3 z = normalize(eye - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    mat4 translation = mat4(\n        vec4(1.0, 0.0, 0.0, eye.x),\n    \tvec4(0.0, 1.0, 0.0, eye.y),\n        vec4(0.0, 0.0, 1.0, eye.z),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 rotation = transpose(\n        mat4(\n            vec4(x, 0.0),\n            vec4(y, 0.0),\n            vec4(z, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0)\n        )\n    );\n    return translation * rotation;\n}\n\nvec3 getRayDir(mat4 camera, float fov, vec2 pixel) {\n    vec2 p = 2.0 * ((pixel / iResolution.xy) - vec2(0.5, 0.5));\n    vec2 h = vec2(\n        tan(fov / 2.0) * (iResolution.x / iResolution.y), \n        tan(fov / 2.0)\n    );\n    vec3 pCam = vec3(p * h, -1.0);\n\treturn normalize((inverse(camera) * vec4(pCam, 0.0)).xyz);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1,d2);\n}\n\nfloat subtractionSDF(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nfloat intersectionSDF(float d1, float d2, float k) {\n    return max(d1,d2);\n}\n\nfloat smoothUnionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat smoothSubtractionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smoothIntersectionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 point) {\n    return length(point) - 1.0f;\n}\n\nfloat torusSDF(vec3 point) {\n    vec2 t = vec2(1.5f, 0.2f);\n\tvec2 q = vec2(length(point.xy) - t.x, point.z);\n    return length(q) - t.y;\n}\n\nfloat sceneSDF(vec3 point) {\n\t//return torusSDF(point - vec3(0.0f, 0.0f, 5.0f));\n    return smoothUnionSDF(\n        sphereSDF(point - vec3(0.0f, 0.0f, 5.0f + cos(iTime))),\n        torusSDF(point - vec3(0.0f, 0.0f, 5.0f)),\n        1.25f\n    );\n}\n\nvec3 estimateNormal(vec3 p) {\n\treturn normalize(vec3(\n    \tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n    \tsceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n    \tsceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nintersection rayMarch(vec3 origin, vec3 direction, float tMin, float tMax) {\n    for (float t = tMin; t < tMax; ) {\n        vec3 p = origin + t * direction;\n    \tfloat d = sceneSDF(p);\n        if (d < EPSILON)\n            return intersection(true, p, estimateNormal(p));\n        t += abs(d);\n    }\n    return intersection(false, vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(5.0, 0.0, 0.0);\n    vec3 target = vec3(0.0, 0.0, 5.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float fov = radians(45.0);\n    \n    mat4 camera = lookAt(eye, target, up); \n    vec3 rayDir = getRayDir(camera, fov, fragCoord);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime + uv.xyx + vec3(0,2,4));\n\n    // Output to screen\n    intersection itsc = rayMarch(eye, rayDir, 1.0, 100.0);\n    float diff = clamp(dot(itsc.normal, normalize(eye - itsc.point)), 0.0, 1.0);\n    if (itsc.hit)\n    \tfragColor = vec4(col * diff, 1.0);\n    else\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}