{
    "Shader": {
        "info": {
            "date": "1717280622",
            "description": "terraced terrain rendered using 3D DDA and thresholded bilinear pieces with procedural music.",
            "flags": 8,
            "hasliked": 0,
            "id": "4XVGRh",
            "likes": 13,
            "name": "Bilinear blocks",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "3d",
                "terrain",
                "sound",
                "music",
                "dda",
                "bilinear",
                "terraced"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 234
        },
        "renderpass": [
            {
                "code": "\nvec3 getRay(in vec3 cameraDir, in vec2 uv) {\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir*min(iTime, 0.7) + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nstruct hit {\n    vec3 normal;\n    float dist;\n    int type;\n};\nconst hit nohit = hit(vec3(1), 1000.0, -1);\nhit place(in vec3 o, in vec3 d, in vec4 p) {\n    if (mix(mix(p.x, p.y, o.x), mix(p.z, p.w, o.x), o.y) < 0.0) return hit(vec3(1), 1000.0, -2);\n    float i = p.x-p.z+p.w-p.y;\n    float a = 2.0*d.y*d.x*i;\n    float b = dot(d.xy, p.yz+o.yx*i-p.x);//d.x*(p.y+o.y*i-p.x)+d.y*(p.z+o.x*i-p.x);;\n    float disc = b*b-2.*a*(p.x*(1.-o.x-o.y)+o.x*(o.y*i+p.y)+p.z*o.y);\n    if (disc < 0.0) return nohit;\n    float dist = (b+sqrt(disc))/a;\n    if (dist > 0.) return nohit;\n    return hit(vec3(0), -dist, 1);\n}\nvec2 getNormal(in vec2 p, in vec4 z) {\n    return normalize(vec2(z.y-z.x-(z.y-z.x-z.w+z.z)*p.y, z.z-z.x-(z.y-z.x-z.w+z.z)*p.x));\n}\nfloat get(in vec3 p) {\n    return noise(p.xy*0.1)*20. + noise(p.xy*0.4)*5. +p.z-6.0;//(p.x*p.x + p.y*p.y)-p.z;//hash13(p);\n}\nvec4 cell(in vec3 p) {\n    return vec4(get(p), get(p+vec3(1, 0, 0)), get(p+vec3(0, 1, 0)), get(p+vec3(1, 1, 0)));\n}\nconst float h = 6.0;\nhit rayCast(in vec3 ro, in vec3 rd) {\n    vec3 rdi = 1./rd;\n    float mm = 1000.;;\n    float plain = -(ro.z-h)*rdi.z;\n    if (plain < 0.0) return nohit;\n    ro += rd*plain;\n    \n    ivec3 pos = ivec3(floor(ro));\n    float dd = 0.0;\n    float od = 0.0;\n    vec3 srd = sign(rd);\n    vec3 p = vec3(pos);\n    for (int i = 0; i < 256; i += 1) {\n        vec3 d = (p+srd*0.5+0.5-ro)*rdi;\n        float nd = min(min(d.x, d.y), d.z);\n        vec3 m = ro+rd*dd-p;\n        vec4 c = cell(p);\n        if (c.x < 0.0 || c.y < 0.0 || c.z < 0.0 || c.w < 0.0) {\n            hit h = place(m, rd, c);\n            if (h.type > 0 && h.dist < nd-dd) return hit(vec3(getNormal(m.xy+rd.xy*h.dist, c), 0), h.dist+dd+plain, 1);\n            if (h.type == -2) return hit(vec3(0, 0, 1), dd+plain, 1);\n        }\n        dd = nd;\n        pos += ivec3(equal(d, vec3(dd)))*ivec3(srd);\n        p = vec3(pos);\n    }\n    return nohit;//hit(vec3(normal), -1.0, -1);\n}\nvec3 fogI(in vec3 ro, in vec3 rd, in float d) {\n    return vec3(-exp(-((ro.z)+rd.z*d)*0.15)/rd.z*2.0, \n                -exp(-((ro.z)+rd.z*d)*0.1)/rd.z,\n                -exp(-((ro.z)+rd.z*d)*0.05)/rd.z*0.5);//0.1*pow(ro.z+rd.z*d, n+1.)/(rd.z*(n+1.));\n}\nvec3 fog(in vec3 ro, in vec3 rd, in vec2 d) {\n    return 0.4*(fogI(ro, rd, d.x)-fogI(ro, rd, d.y));\n}\nvec3 colors[4] = vec3[4](\n    vec3(1, 0.5, 0.3),\n    vec3(1, 0.1, 0.1),\n    vec3(0.5, 0, 0),\n    vec3(1, 0.5, 0.5)\n);\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    \n    hit t = rayCast(ro, rd);\n    if (t.dist > 999.) {\n        return vec3(1);\n    }\n    vec3 p = ro+rd*t.dist;\n    float light = t.dist*0.01;\n    vec3 f = fog(ro+vec3(0, 0, 5.0), rd, vec2(t.dist, 0.0));\n    int layer = int(floor(5.999+p.z))-2;\n    float ao = .3*get(p)+0.7;\n    if (p.z > 3.999) ao = 1.0;\n    ao -= (exp((4.-p.z)*0.1)*0.1);//(4.-p.z)*0.1;\n    ao *= dot(t.normal, -rd);\n    vec3 color = colors[(layer+100)%4];\n    return vec3(1.-exp(-(f+color*ao)));//vec3(0.5+0.5*dot(t.normal, normalize(vec3(1, 2, 3))));//mix(vec3(0.5+0.5*sin(ro+rd*t.dist)), vec3(0), 1.-exp(-t.dist*0.1));//vec3(0.5+0.5*dot(t.normal, normalize(vec3(1, 2, 3))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = vec2(sin(iTime*0.5)+2.8, 0.8+sin(iTime)*0.1);\n    if (iMouse.z > 0.0) m = (iMouse.xy/iResolution.xy)*vec2(6.28, 3.14159263);\n    vec3 ro = vec3(1, 2, 10);\n    vec3 rd = getRay(-vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y)), uv);\n    ro += vec3(iTime*20., iTime*10., 0);\n    vec3 color = getColor(ro, rd)+hash33(uvec3(fragCoord.xy, iTime))*0.00390625;\n    \n    fragColor = vec4(mix(color, sin(0.1/color*(sin(iTime*10.)*0.4+0.6)), clamp(abs(mod(iTime+4.0, 16.)-8.)*4.0-16.0, 0.0, 1.0)), 1);\n    fragColor.xyz += vec3(hash33(vec3(fragCoord, iFrame))-0.5)/256.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 box( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash14(uvec4 q)\n{\n\tq *= UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash14(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tuint n = (q.x ^ q.y ^ q.z ^ q.w) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec4 hash44(uvec4 q)\n{\n\tq *= UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec4(q) * UIF;\n}\n\nvec3 hash44(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec3(q) * UIF;\n}\n\n\nfloat noise(in vec2 p) {\n    vec2 fp = floor(p);\n    return mix(\n        mix(hash12(fp+vec2(0,0)), hash12(fp+vec2(1, 0)), fract(p.x)),\n        mix(hash12(fp+vec2(0,1)), hash12(fp+vec2(1, 1)), fract(p.x)), fract(p.y));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nfloat hash(float p)\n{\n\tvec3 p3 = fract(p * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract(fract(fract(p3.x)*100.*p3.y)*1000.*p3.z+dot(fract(p3), fract(p3.xzy)));//fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat noise(float p) {\n    float f = fract(p);\n    f = f*f*(3.-2.*f);\n    return mix(hash(floor(p)*0.001), hash(0.001*floor(p+1.)), f);\n}\nfloat mmm(in float t) {\n    float v = fract(t*float[5](100., 200., 800., 500., 880.)[int(floor(t*5.)+floor(t*10.))%5])*exp(-fract(t*5.0));\n    v = fract(t*float[5](200., 440., 100., 500., 400.)[int(floor(t*2.)+floor(t*5.))%5])*exp(-fract(t*5.0));\n    return v;\n}\nfloat fbm(in float t) {\n    float sum = 0.;\n    for (int i = 0; i < 10; i++) {\n        sum += pow(2., -float(i))*noise(t*pow(2., float(i)));\n    }\n    return sum*0.5;\n}\nfloat sound(in float time) {\n    float t = time;\n    time = mod(time, 4.);\n    time = fract(time*(floor(time*0.5)*2.0+1.0));\n    time = log(time*0.1)*0.25;\n    time *= hash(floor(time))*2.+1.0;\n    time = mod(time, 2.0)*2.0;\n    time *= 300.0+noise(time*1000.)*fract(time*3.);\n    float v = (sin(sin(fract(time*0.03)*50.+sin(2.*time))*2.0) + sin(sin(time+sin(2.*time))*noise(time)*10.))*0.5;//vec2(exp(-fract(time)*2.)*clamp(sin(pow(t, n))/pow(t, n-1.), 0.0, 1.0));\n    v = clamp(v, -1.0, 1.0);\n    //v += sin(t*2000.*(1.0+hash(floor(t*10.))));\n    //v *= 0.0;\n    //v = 0.0;\n    v = mix(v, fract(t*float[5](100., 200., 800., 500., 880.)[int(floor(t*5.)+floor(t*10.))%5])*exp(-fract(t*5.0)), 1.-pow(noise(time+523.623), 2.0));\n    v = mix(v, fract(t*float[5](200., 440., 100., 500., 400.)[int(floor(t*2.)+floor(t*5.))%5])*exp(-fract(t*5.0)), 1.-pow(noise(time), 2.0));\n    \n    float ttt = mmm(t*0.5);//mix(mmm(t*0.5), (sin(t*220.*6.283+fbm(t*100.)*50.)*sin(t+523.623)+noise(t*500.)*cos(t)+noise(t*2000.)*sin(t))*0.25, 0.5);\n    //ttt = sin(t*440.*3.141592*2.0 + ttt*10.0)*ttt*0.2;\n    if (mod(t, 16.) > 8.0) v = mix(mix(fract(ttt*5.0)*0.5, sin(ttt*20.0)*0.5, sin(t)*0.5+0.5), (sin(t*220.*6.283+fbm(t*100.)*50.)*sin(t+523.623)+noise(t*500.)*cos(t)+noise(t*2000.)*sin(t))*0.25, 0.5);\n    return v;\n}\nfloat square(in float x, in float smoothness) {\n    x *= 6.282;\n    return sin(x)/(smoothness+abs(sin(x)));\n}\nfloat sound1(in float time) {\n    float t = time;\n    time *= 0.5;\n    float v = square(time*220., 1.-pow(fract(time), 2.));\n    v += square(time*110., 1.-pow(fract(time*0.5+0.5), 2.));\n    v += sin(square(time*(220.+110.*(abs(mod(floor(time*2.0), 5.0)-1.0))), 1.-pow(fract(time*2.0), 2.))*exp(fract(time*4.0)*2.0)+fract(time*0.5)*5.0);\n    time *= 8.0;\n    time = mod(time, 4.0);\n    v += 0.5*sin(v + square(time*float[4](500., 220., 440., 600.)[int(floor(time))%4], 0.0));\n    v += 0.5*sin(v + 0.5*square(time*float[4](300., 880., 500., 600.)[int(floor(time+0.5))%4], 0.0));\n    \n    v += noise(time*440.*6.283)*exp(-fract(time*0.5))*2.0;\n    v += 0.5*sin(v*2.0);\n    v *= 0.333;\n    int k = int(floor(t*50.));\n    v += fract(t*(k%3!=0?500.:220.))*fract(t);\n    //v = mix(v, fbm(log(pow(fract(t*0.5), 2.0))*100.)*2.0, pow(1.-fract(t*0.5), 2.0));\n    return v;\n}\nvec2 mainSound( int samp, float time ) {\n    return vec2(sound(time)*3.0+0.5*sound1(log(fract(time*0.1)*10.))+fbm(time*1000.)*sin(time)+fbm(time*2000.)*cos(time))*0.25;//vec2(sin(sound(time)*sin(time*100.)*10.));\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}