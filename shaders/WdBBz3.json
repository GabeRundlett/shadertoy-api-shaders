{
    "Shader": {
        "info": {
            "date": "1592021456",
            "description": "Modified version of my previous shader: https://www.shadertoy.com/view/WdSczh",
            "flags": 0,
            "hasliked": 0,
            "id": "WdBBz3",
            "likes": 57,
            "name": "Glass Cube With Dispersion",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "refraction",
                "reflections",
                "translucency",
                "dispersion"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 1132
        },
        "renderpass": [
            {
                "code": "//June 21, 2020: Added chromatic abberation\n\n#define ABSORBTION \t\t\t\tvec3(0.03)\n#define IOR \t\t\t\t\t1.5\n#define DISPERSION \t\t\t\t0.03\n#define CHROMATIC_ABBERATION\t0.01\n\n#define TIMESCALE 0.35\n#define INTERNAL_REFLECTIONS 4\n#define SAMPLES 30.0\n\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nvec3 rotate ( vec3 p, vec3 r ) {\n    p.yz *= rot2(r.x);\n    p.xz *= rot2(-r.y);\n    p.xy *= rot2(r.z);\n    return p;\n}\n\n\nfloat InteriorCubeReflection ( vec3 ro, vec3 rd ) {\n    vec3 d = (0.5*sign(rd)-ro)/rd;\n    return min( min(d.x, d.y), d.z );\n}\n\n\nfloat IntersectCube ( vec3 ro, vec3 rd ) {\n    float dfront = -InteriorCubeReflection(-ro,rd);\n    float dback  = InteriorCubeReflection(ro,rd);\n    return dback>=dfront ? dfront : -1.0;\n}\n\n\nfloat GetReflectance ( vec3 i, vec3 t, vec3 nor, float iora, float iorb ) {\n    vec2 c = nor * mat2x3(i,t);\n    vec2 ior = vec2(iora,iorb);\n    vec2 sp = ( mat2(c,-c.yx)*ior ) / ( mat2(c,c.yx)*ior );\n    return dot(sp,sp)/2.0;\n}\n\n\nvec3 GetSky ( vec3 rd ) {\n    float v = dot(rd, vec3(0.5,-0.15,0.85));\n    v = smoothstep(-0.05, 0.05, sin(v*50.0));\n    return vec3( v );\n}\n\n\nvec3 GetDispersedColor( float w ) {\n    return max( sin( ( w - vec3(0.0,0.25,0.5) ) * 6.28318531 ), 0.0);\n    /*\n    vec3 s = vec3(0.9, 1.0, 0.8);\n    vec3 c = w - vec3( 0.0, 0.25, s.b-0.5 );\n    c = clamp(c*s, 0.0, 1.0) * 6.28318531;\n    c = sin(c) * s;\n    return max( c, 0.0);\n\t*/\n}\n\n\nvec3 GetRenderSample ( vec3 ro, vec3 rd, float df ) {\n\tfloat rl = IntersectCube( ro, rd );\n    \n    if ( rl > 0.0 ) {\n        \n        float iord = IOR + DISPERSION*(df-0.5);\n        \n        vec3 xyz = ro + rd*rl;\n        vec3 nor = round( xyz*1.00001 );\n        vec3 power = vec3(1.0);\n        vec3 refractd = refract( rd, nor, 1.0/iord );\n        vec3 reflectd = reflect( rd, nor );\n        float refl = GetReflectance ( rd, refractd, nor, 1.0, iord );\n        vec3 c = GetSky(reflectd) * refl;\n        power *= 1.0-refl;\n        rd = refractd;\n\n        for ( int i=0; i<INTERNAL_REFLECTIONS; i++ ) {\n        \trl = InteriorCubeReflection( xyz, rd );\n        \txyz += rd*rl;\n            nor = round( xyz*1.00001 );\n        \trefractd = refract( rd, -nor, 1.0/iord );\n        \treflectd = reflect( rd, -nor );\n        \trefl = GetReflectance ( rd, refractd, -nor, iord, 1.0 );\n        \tpower *= exp( -ABSORBTION * rl );\n            c += GetSky(refractd) * (1.0-refl) * power;\n            power *= refl;\n            rd = reflectd;\n        }\n        return c;\n    } else {\n    \treturn GetSky(rd);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x;\n    \n    vec3 col = vec3(0.0);\n    for ( float f = 0.0; f<SAMPLES; f++ ) {\n        float w = f/SAMPLES;\t\t// wavelength sample ( 0 => 1 across visible spectrum )\n        \n        float b = (fract(f*134.102119) - 0.5) / 60.0;\t\t\t\t\t\t\t//temporal offset for motion blur\n        vec2 aa = (fract((f+uv)*134.102119+iTime)-0.5)/iResolution.x*3.0;\t\t//quick and sloppy positional offset for aa\n        \n        vec3 cp = vec3( aa, -2.5);\n        vec3 cr = normalize( vec3(uv,1.0+w*CHROMATIC_ABBERATION) );\n    \tcp = rotate( cp, vec3( (iTime + b) * TIMESCALE ) );\n        cr = rotate( cr, vec3( (iTime + b) * TIMESCALE ) );\n        \n        vec3 c = GetRenderSample( cp, cr, w );\n        \n        vec3 sp = GetDispersedColor(w);\n    \tcol += c * sp;\n    }\n    col /= SAMPLES/3.0;\n    \n    col = smoothstep(0.0, 1.0, col);\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}