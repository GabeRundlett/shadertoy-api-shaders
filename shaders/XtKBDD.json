{
    "Shader": {
        "info": {
            "date": "1542616678",
            "description": "Descrates Circle",
            "flags": 0,
            "hasliked": 0,
            "id": "XtKBDD",
            "likes": 4,
            "name": "Descrates Circle",
            "published": 3,
            "tags": [
                "2d",
                "circle",
                "descrates"
            ],
            "usePreview": 0,
            "username": "zhimo",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "// Author: 185202204@qq.com\n\n//coding by unity shader,github:\n//https://github.com/zhimo1997/ShaderToy\n//more details on my blog :\n//https://blog.csdn.net/qq_36383623/article/details/84237042\n\n\n\n//if uv is in Circle or not\nfloat IsInCircle(vec2 uv,vec2 center,float radius) {\n\tfloat r = distance(uv,center);\n\tif (r < radius) {\n\t\treturn r / radius;\n\t}\n\treturn -1.0;\n}\n\nfloat CaculateAngle(vec2 v1, vec2 v2) {\n\tfloat magnitude1 = sqrt(v1.x*v1.x + v1.y*v1.y);\n\tfloat magnitude2 = sqrt(v2.x*v2.x + v2.y*v2.y);\n\tfloat cosValue = dot(v1, v2) / (magnitude1*magnitude2);\n\tfloat finalAngle = acos(cosValue);\n\tfinalAngle = degrees(finalAngle);\n\n\tvec3 dir = cross(vec3(v1, 0), vec3(v2, 0));\n\tif (dir.z >= 0.0) {\n\t\treturn finalAngle;\n\t}\n\telse{\n\t\treturn 360.0 - finalAngle;\n\t}\n}\n\nfloat CalculateRadius(float r1,float r2,float r4) {\n\tfloat k1 = 1.0/ r1;\n\tfloat k2 = 1.0/ r2;\n\tfloat k4 = 1.0/ r4;\n\n\tfloat t1 = k1 + k2 - k4;\n\tfloat t2 = k1 * k1 + k2 * k2 + k4 * k4;\n\t\t\n\tfloat a = 1.0;\n\tfloat b = -2.0*t1;\n\tfloat c = 2.0 * t2 - t1 * t1;\n\tfloat delta = b * b - 4.0 * a*c;\n\tif (delta < 0.0) {\n\t\treturn -1.0;\n\t}\n\tfloat d1 =( -b + sqrt(delta))/(2.0*a);\n\t//float d2 =（ -b - sqrt(delta)）/(2.0*a);\n\treturn 1.0/d1;\n}\n\nvec4 CaculateFourthCircleCenter(vec2 center1,vec2 center2,float r1,float r2) {\n\tfloat m = -(center2.x-center1.x)/(center2.y-center1.y);\n\tfloat n = 0.5*((r2*r2-r1*r1)/(center1.y-center2.y)+center2.y+center1.y+(center1.x*center1.x-center2.x*center2.x)/(center1.y-center2.y));\n\tfloat a = 1.0 + m * m;\n\tfloat b = 2.0 * m*(n - center1.y) - 2.0*center1.x;\n\tfloat c = center1.x*center1.x + (n-center1.y)*(n-center1.y) - r1 * r1;\n\tfloat x1 = (-b + sqrt(b*b-4.0*a*c))/(2.0*a);\n\tfloat y1 = m * x1 + n;\n\tfloat x2 = (-b - sqrt(b*b - 4.0 * a*c)) / (2.0 * a);\n\tfloat y2 = m * x2 + n;\n\n\tvec3 v0 = vec3(center1.x-center2.x,center1.y-center2.y,0.0);\n\tvec3 v1 = vec3(center1.x-x1,center1.y-y1,0.0);\n\tvec3 t = cross(v0, v1);\n\tif ( t.z>= 0.0) {\n\t\treturn vec4(x1,y1,x2,y2);\n\t}\n\treturn vec4(x2,y2,x1,y1);\n\t\t\n}\n\nvec4 DrawCircle(vec2 uv,vec2 center,float aspect,vec4 centerColor,vec4 contourCol) {\n    float alpha = aspect;\n\tfloat angle = CaculateAngle(vec2(1,0),uv-center);\n    float ColorRotateSpeed=10.0;\n\tangle = mod(angle+ColorRotateSpeed*iTime,360.0);\n\tfloat index =floor(angle/20.0);\n\t//alpha = index * alpha;\n\talpha *= abs(0.5-index / 18.0);\n\treturn mix(centerColor,contourCol,alpha);\n}\n\n//return the background color\nvec4 DrawBg(vec2 uv){\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    return vec4(col,1.0);\n}\n\n//draw the shape of Descrates\nvec4 DrawDescrates(vec2 uv){\n    float aspect=iResolution.x/iResolution.y;\n    \n    float RotateSpeed=4.0;\n    float angle = RotateSpeed * iTime;\n    float ScaleChangeSpeed=1.5;\n\tfloat scale = 0.1*(sin(ScaleChangeSpeed*iTime));\n    float CenterX=0.5;\n    float CenterY=0.5;\n\tvec2 center = vec2(CenterX,CenterY);\n    center.x*=aspect;\n\tfloat radius = 0.5;\n\tfloat R[5];\n\tvec2 CircleCenter[5];\n\t//计算各个圆的半径及圆心\n\tint Amount = 5;\n\tR[0] = radius;\n\tCircleCenter[0] = vec2(CenterX, CenterY);\n    CircleCenter[0].x*=aspect;\n\n    float radius2=0.35;\n\tR[1] = radius2+scale;\n\t//CircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1]);\n\t//CircleCenter[1].y = CircleCenter[0].y;\n\tCircleCenter[1].x = CircleCenter[0].x - (R[0] - R[1])*cos(angle);\n\tCircleCenter[1].y = CircleCenter[0].y + (R[0] - R[1])*sin(angle);\n\t\t\n\tR[2] = R[0] - R[1]-0.0001;\n\tfloat l = (R[0]-R[1]) / (R[1]+R[2]);\n\tCircleCenter[2] = CircleCenter[1]-(1.0/l)*(CircleCenter[1]-CircleCenter[0]);\n\n\tvec4 CenterColor = vec4(0.7,0.9,0.9,1.0);\n\tvec4 ContourColor = vec4(0.8,0,0.4,1.0);\n\n\tvec4 centerColor;\n    vec4 contourColor;\n\t//第一个内圆\n\tfloat flag = IsInCircle(uv, CircleCenter[1], R[1]);\n\tif (flag >= 0.0) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.7);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.7);\n\t\treturn DrawCircle(uv, CircleCenter[1],flag, centerColor, contourColor);\n\t}\n\t//第二个内圆\n\tflag = IsInCircle(uv, CircleCenter[2], R[2]);\n\tif (flag >= 0.0) {\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.3);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.3);\n\t\treturn DrawCircle(uv, CircleCenter[2],flag, centerColor, contourColor);\n\t}\n\n\t//第三个内圆\n\tfloat r = CalculateRadius(R[1], R[2], R[0]);\n\n\tif (r < 0.0) {\n\t\treturn vec4(0, 0, 0, 1);\n\t}\n\n\tvec4 center4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[2], R[1] + r, R[2] + r);\n\t//center4.x*=aspect;\n    //center4.z*=aspect;\n    //float2 center4 = CaculateFourthCircleCenter(CircleCenter[0],float2(0.35,0.5), float2(0.85, 0.5), R[0], R[1] + r, R[2] + r);\n\tflag = IsInCircle(uv, center4.xy, r);\n\tif (flag >= 0.0) {\n\t\t//return fixed4(0,0,0,1);\n\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\treturn DrawCircle(uv, center4.xy,flag, centerColor, contourColor);\n\t}\n\t\tflag = IsInCircle(uv, center4.zw, r);\n\t\tif (flag >= 0.0) {\n\t\t\t//return fixed4(0,0,0,1);\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.4);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.4);\n\t\t\treturn DrawCircle(uv, center4.zw,flag, centerColor, contourColor);\n\t\t}\n\n\t\tCircleCenter[3] = center4.xy;\n\t\tR[3] = r;\n\n\t\tCircleCenter[4] = center4.zw;\n\t\tR[4] = r;\n\n\t\tint amount = 6;\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1],R[3],R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[3], R[1] + r, R[3] + r);\n\t\t\tflag = IsInCircle(uv, center4.xy, r);\n\t\t\tif (flag >= 0.0) {\n\t\t\t\t//return fixed4(1,1,1,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5+float(j)*0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5+float(j)*0.1);\n\t\t\t\treturn DrawCircle(uv, center4.xy,flag, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[3] = center4.xy;\n\t\t\tR[3] = r;\n\t\t}\n\n\t\tfor (int j = 0; j < amount; j++) {\n\t\t\tr = CalculateRadius(R[1], R[4], R[0]);\n\t\t\tcenter4 = CaculateFourthCircleCenter(CircleCenter[1], CircleCenter[4], R[1] + r, R[4] + r);\n\t\t\tflag = IsInCircle(uv, center4.zw, r);\n\t\t\tif (flag >= 0.0) {\n\t\t\t\t//return fixed4(0,0,0,1);\n\t\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.5 + float(j) * 0.1);\n\t\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.5 + float(j) * 0.1);\n\t\t\t\treturn DrawCircle(uv, center4.zw,flag, centerColor, contourColor);\n\t\t\t}\n\t\t\tCircleCenter[4] = center4.zw;\n\t\t\tR[4] = r;\n\t\t}\n\t\t\n\t\t//contourColor=vec4(0.7,0.9,0.9,1);\n\t\tflag = IsInCircle(uv, CircleCenter[0], R[0]);\n\t\tif (flag >= 0.0) {\n\t\t\tcenterColor = mix(CenterColor, ContourColor, 0.0);\n\t\t\tcontourColor = mix(ContourColor, CenterColor, 0.0);\n\t\t\treturn DrawCircle(uv, CircleCenter[0],flag, centerColor, contourColor);\n\t\t}\n\n\t\treturn DrawBg(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect=iResolution.x/iResolution.y;\n    uv.x=uv.x*aspect;\n\n   fragColor=DrawDescrates(uv);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}