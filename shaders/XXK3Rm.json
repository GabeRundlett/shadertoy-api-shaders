{
    "Shader": {
        "info": {
            "date": "1717444749",
            "description": "cross eyed 3D ray marching fractal\ninstructions at top of source code.",
            "flags": 48,
            "hasliked": 0,
            "id": "XXK3Rm",
            "likes": 0,
            "name": "cycle22 Dark Surf v2",
            "published": 3,
            "tags": [
                "raymarching",
                "3dfractal"
            ],
            "usePreview": 1,
            "username": "kosalos",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "/*\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<X>   : toggle animation\n<I>   : toggle spherical inversion\n<S>   : toggle cross eyed stereo\n<Q>   : toggle secondSurface\n<W>   : toggle secondSurface refract vs reflect\n<Spc> : reset\n\nNote: toggles off by default\n\nNote: hold down <Shift> then drag mouse to affect camera.xy regardless of focus.\nNote: hold down <Alt><Shift> then drag mouse to affect aim.xy regardless of focus.\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1  \nHold down <Z> for change Amount * 10. \nHold down both <A><Z> for change Amount * 50. \n\nWidgets --------------------------------------\nraymarching DE() params : Shape; MinRad; Scale; FoldX,Y,Z; ModX,Y,Z; Angle\ncamera position and aim : cameraX,Y,Z;  aimX,Y,Z\nspherical inversion     : position-> InvPosX,Y,Z; radius-> InvRad; angle-> InvAngle\nsecondsurface           : distance-> SSdist; angle-> Sangle; amount-> Samount; mix-> SSmix\nphong lighting          : color-> PhoColR,G,B; position-> PhoPosX,Y,Z; diffuse-> PhoDiff; specular-> PhoSpec; ambient-> PhoAmb\nspotl light             : strength-> SpotV; location-> SpotX,Y; exponent-> SpotE; color-> SpotR,G,B\norbit trapping          : strength-> OrbitS; cycle-> OrbitC, weight&color-> OwhtX,OcolX (same for Y,Z,W); center-> OcntX,Y,Z\n---------------------------------------------\n\n<S> Cross-eyed 3D \nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n\n<Q>,<W> Second Surface\nRaymarching algorithm calculates a unique \"ray\" from the camera to every pixel of the image.\nRaymarching algorithm \"marches\" along each ray, until the DE() function says to go no farther.\nWhen \"second surface\" is enabled we ask the raymarching to continue past the first stopping point,\nto instead continue marching until a second (or third,fourth) stopping point is reached, \nthereby exposing objects inside the original surface.\nssDistance : how far to jump ahead on the ray before beginning the search for the second surface.\nssAngle    : how much to change the aim of the ray before continuing\nssAmount   : if refraction is enabled ( <W> toggle), how much to refract the ray before continuing\nssMix      : how to blend the color of the 1st surface vs. the second.\n\nbased on: https://www.shadertoy.com/view/lstyR4\n*/\n\nstruct Dataset {\n    // DE() params\n    vec3 p1,p2,p3;\n    float angle;\n            \n    vec3 camera,aim;    \n\n    vec3 invpos;\n    float invradius;\n    float invangle;    \n\n    vec3 phongColor;\n    vec3 phongPosition;\n    vec3 phongParam; // diffuse, specular, ambient\n    \n    float spotLight;      // strength\n    vec3 spotLightData;  // x,y,exp\n    vec3  spotLightColor; // rgb\n    \n    int maxsteps;\n    int ssIterations;\n    float ssDistance,ssAngle,ssAmount,ssMix;\n    float epsilon;\n    float ambient,contrast,vibrant,dim;\n    float fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n    \n    float Ostrength; // 0.0 -> disable orbit trapping\n    float Ocycle;\n    float OXwt,OXcr; // weight, color code\n    float OYwt,OYcr;\n    float OZwt,OZcr;\n    float OWwt,OWcr;\n    vec3  Ocenter;   // origin offset\n    \n    float parallax;  // adjust for best stereo effect 0 ... 0.2\n\n    // calculated params \n    vec3 direction;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n    float depth;\n    int iter;\n    vec4 orbitTrap;\n    \n    int focus,row,displayCount;\n    bool animationEnable,stereoEnable,inversionEnable,secondsurfaceEnable,refractEnable;\n    vec3 viewVector,sideVector,topVector;\n};\n\n// --------------------------------------------------------\n\nvec3 rotatePosition(vec3 pos, int axis, float angle) {\n    float ss = sin(angle);\n    float cc = cos(angle);\n    float qt;\n    \n    switch(axis) {\n        case 0 :    // XY\n            qt = pos.x;\n            pos.x = pos.x * cc - pos.y * ss;\n            pos.y =    qt * ss + pos.y * cc;\n            break;\n        case 1 :    // XZ\n            qt = pos.x;\n            pos.x = pos.x * cc - pos.z * ss;\n            pos.z =    qt * ss + pos.z * cc;\n            break;\n        case 2 :    // YZ\n            qt = pos.y;\n            pos.y = pos.y * cc - pos.z * ss;\n            pos.z =    qt * ss + pos.z * cc;\n            break;\n    }\n    return pos;\n}\n\nfloat DE(vec3 pos,inout Dataset data) {\n#define scale_43 data.p1.x\n#define MinRad2_43 data.p1.y\n#define Scale_43 data.p1.z\n#define fold_43 data.p2\n#define foldMod_43 data.p3\n\n    float absScalem1 = abs(Scale_43 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(Scale_43), float(1 - data.maxsteps));\n    vec3 ot;\n    vec4 p = vec4(pos,1.), p0 = p;  // p.w is the distance estimate\n    \n    for(int i=0;i < 100; ++i) {\n        if(i >= data.maxsteps) break;\n        \n        p.xyz = rotatePosition(p.xyz,0,data.angle);\n        p.xyz = rotatePosition(p.xyz,1,data.angle);\n        \n        //dark-beam's surfboxfold ported by mclarekin-----------------------------------\n        vec3 sg = p.xyz; // or 0,0,0\n        sg.x = sign(p.x);\n        sg.y = sign(p.y);\n        sg.z = sign(p.z);\n        \n        vec3 folder = p.xyz; // or 0,0,0\n        vec3 Tglad = abs(p.xyz + fold_43) - abs(p.xyz - fold_43) - p.xyz;\n        \n        folder.x = sg.x * (p.x - Tglad.x);\n        folder.y = sg.y * (p.y - Tglad.y);\n        folder.z = sg.z * (p.z - Tglad.z);\n        \n        folder = abs(folder);\n        \n        folder.x = min(folder.x, foldMod_43.x);\n        folder.y = min(folder.y, foldMod_43.y);\n        folder.z = min(folder.z, foldMod_43.z);\n        \n        p.x -= sg.x * folder.x;\n        p.y -= sg.y * folder.y;\n        p.z -= sg.z * folder.z;\n        //----------------------------------------------------------\n        \n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(MinRad2_43/r2, MinRad2_43), 0.0, 1.0);\n        p = p * scale_43 + p0;\n        if ( r2>1000.0) break;\n        \n        ot = p.xyz - data.Ocenter;\n        data.orbitTrap = min(data.orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n    \n    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\n// --------------------------------------------------------\n// distance estimation function wrapped by spherical inversion code.\n\nfloat DE_plusSpherical(vec3 pos,inout Dataset data) {\n    if(data.inversionEnable) {\n        pos = pos - data.invpos;\n        float r = length(pos);\n        float r2 = r*r;\n\t\tfloat radius2 = data.invradius * data.invradius;\n        pos = (radius2 / r2) * pos + data.invpos;\n        \n        float an = atan(pos.y,pos.x) + data.invangle;\n        float ra = length(pos.xy);\n        pos.x = cos(an) * ra;\n        pos.y = sin(an) * ra;\n\t\t\t\t\n        float de = DE(pos,data);\n        return r2 * de / (radius2 + r * de);\n    }\n    \n    return DE(pos,data);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\t//x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor(inout Dataset data) {\n    vec3 orbitColor;\n    \n    if (data.Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(data.Ocycle,generateColor(data.OXwt,data.OXcr), data.orbitTrap.x) * data.OXwt * data.orbitTrap.x +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OYwt,data.OYcr), data.orbitTrap.y) * data.OYwt * data.orbitTrap.y +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OZwt,data.OZcr), data.orbitTrap.z) * data.OZwt * data.orbitTrap.z +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OWwt,data.OWcr), data.orbitTrap.w) * data.OWwt * data.orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(data.OXwt,data.OXcr) * data.OXwt * data.orbitTrap.x +\n        \tgenerateColor(data.OYwt,data.OYcr) * data.OYwt * data.orbitTrap.y +\n        \tgenerateColor(data.OZwt,data.OZcr) * data.OZwt * data.orbitTrap.z +\n        \tgenerateColor(data.OWwt,data.OWcr) * data.OWwt * data.orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\nvec3 spotLighting(inout Dataset data) { \n    const float PI = 3.141592654;\n\tfloat a1 = data.spotLightData.x * PI;\n\tfloat a2 = data.spotLightData.y * PI * 0.5;\n\tfloat s1 = sin(a1);\n\tvec3 spotDir = vec3(s1 * cos(a2), s1 * sin(a2), cos(a1));\n\tspotDir = normalize(spotDir);\n\tvec3 halfVector = normalize(spotDir - data.direction);\n\n\tfloat nDotL = max(0., dot(data.normal, spotDir));\n\tfloat hDotN = max(0., dot(data.normal, halfVector));\n\n    float exp = data.spotLightData.z;\n    return data.spotLight * data.spotLightColor * ((exp + 2.) / 2.) * pow(hDotN, exp) \n\t\t* (exp + (1. - exp) * pow(1. - hDotN, 5.)) * nDotL * data.spotLight;\n}\n\nvec3 phongLighting(inout Dataset data) { \n\tvec3 L = normalize(data.phongPosition - data.position);\n\tfloat dotLN = dot(L, data.normal);\n\tif (dotLN < 0.0)\n\t\treturn vec3(0.);\n\t\t\n\tfloat t1 = data.phongParam.x * dotLN;\n\n\tvec3 V = normalize(data.camera - data.position);\n\tvec3 R = normalize(reflect(-L, data.normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0)\n\t\treturn vec3(data.phongColor * t1);\n\n\tfloat t2 = data.phongParam.y * pow(abs(dotRV), data.phongParam.z);\n\treturn data.phongColor * (t1 + t2);\n}\n\nvoid applyColoring(inout Dataset data) { \n    data.color = vec3(data.ambient) + vec3(1.0 - (data.normal * data.vibrant + sqrt(float(data.iter) * data.dim)));\n    data.color = vec3(0.5) + (data.color - vec3(0.5)) * data.contrast;\n    \n    if(length(data.phongColor) > 0.0) \n\t\tdata.color += phongLighting(data);\n    if(data.spotLight > 0.)\n        data.color += spotLighting(data); \n        \n    if(data.Ostrength > 0.0) {\n        vec3 oColor = getOrbitColor(data);\n        data.color = mix(data.color, oColor, data.Ostrength);\n    }\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal(inout Dataset data) {\n    float ex = data.epsilon;\n    float ey = -ex;\n    vec3 pos = data.position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE(t1,data);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE(t2,data);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE(t3,data);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE(t4,data);\n\n    data.normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n// viewVectors already calculated in Buffer A\n\nvoid setDirection(vec2 fragCoord,inout Dataset data) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(data.stereoEnable) {\n        vec3 soffset = data.sideVector * data.parallax;\n\t\txsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n\t\t\tsrcP.x -= xsize;      // base 0  X coordinate\n\t\t\tdata.camera -= soffset;// adjust for right side parallax\n\t\t}\n\t\telse {\n\t\t\tdata.camera += soffset;// adjust for left side parallax\n\t\t}\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    data.direction = normalize(data.viewVector + vPos.x * data.sideVector + vPos.y * data.topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 20.0;\n\nvoid rayMarch(inout Dataset data) {\n\tvec3 position = data.camera;\n\tfloat distance;\n\tdata.iter = 0;\n\tdata.depth = MIN_DIST;\n \t\n\tfor(int i = 0;i < 100;++i) {\n\t\tdistance = DE_plusSpherical(position,data);\n        if(abs(distance) < MIN_DIST || data.depth > MAX_DIST) break;\n        data.iter += 1;\n\t\t\n        data.depth += distance;\n        position = data.camera + data.direction * data.depth;\n  }\n}\n\n// --------------------------------------------------------\n\nvoid displayData(inout Dataset data,inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.35) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.95) return; \n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(30,30);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.7, 1) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n\n    declString(gap, 1, (cSp));\n\n    String str;\n    float value = 0.;\n    \n    switch(data.focus) {\n        case  0 : setString(str,5,(cS,ch,ca,cp,ce)); value = data.p1.x; break;\n        case  1 : setString(str,6,(cM,ci,cn,cR,ca,cd)); value = data.p1.y; break;\n        case  2 : setString(str,5,(cS,cc,ca,cl,ce)); value = data.p1.z; break;\n        case  3 : setString(str,5,(cF,co,cl,cd,cX)); value = data.p2.x; break;\n        case  4 : setString(str,5,(cF,co,cl,cd,cY)); value = data.p2.y; break;\n        case  5 : setString(str,5,(cF,co,cl,cd,cZ)); value = data.p2.z; break;\n        case  6 : setString(str,4,(cM,co,cd,cX)); value = data.p3.x; break;\n        case  7 : setString(str,4,(cM,co,cd,cY)); value = data.p3.y; break;\n        case  8 : setString(str,4,(cM,co,cd,cZ)); value = data.p3.z; break;\n        case  9 : setString(str,5,(cA,cn,cg,cl,ce)); value = data.angle;  break;\n\n        case 18 : setString(str,7,(cC,ca,cm,ce,cr,ca,cX)); value = data.camera.x; break;\n        case 19 : setString(str,7,(cC,ca,cm,ce,cr,ca,cY)); value = data.camera.y; break;\n        case 20 : setString(str,7,(cC,ca,cm,ce,cr,ca,cZ)); value = data.camera.z; break;\n        case 21 : setString(str,4,(cA,ci,cm,cX)); value = data.aim.x; break;\n        case 22 : setString(str,4,(cA,ci,cm,cY)); value = data.aim.y; break;\n        case 23 : setString(str,4,(cA,ci,cm,cZ)); value = data.aim.z; break;\n        case 24 : setString(str,7,(cI,cn,cv,cP,co,cs,cX)); value = data.invpos.x; break;\n        case 25 : setString(str,7,(cI,cn,cv,cP,co,cs,cY)); value = data.invpos.y; break;\n        case 26 : setString(str,7,(cI,cn,cv,cP,co,cs,cZ)); value = data.invpos.z; break;\n        case 27 : setString(str,6,(cI,cn,cv,cR,ca,cd)); value = data.invradius; break;\n        case 28 : setString(str,8,(cI,cn,cv,cA,cn,cg,cl,ce)); value = data.invangle; break;\n\n        case 29 : setString(str,6,(cS,cS,cd,ci,cs,ct)); value = data.ssDistance; break;\n        case 30 : setString(str,7,(cS,cS,ca,cn,cg,cl,ce)); value = data.ssAngle; break;\n        case 31 : setString(str,8,(cS,cS,ca,cm,co,cu,cn,ct)); value = data.ssAmount; break;\n        case 32 : setString(str,5,(cS,cS,cm,ci,cx)); value = data.ssMix; break;\n\n        case 33 : setString(str,7,(cP,ch,co,cC,co,cl,cR)); value = data.phongColor.x; break;\n        case 34 : setString(str,7,(cP,ch,co,cC,co,cl,cG)); value = data.phongColor.y; break;\n        case 35 : setString(str,7,(cP,ch,co,cC,co,cl,cB)); value = data.phongColor.z; break;\n        case 36 : setString(str,7,(cP,ch,co,cP,co,cs,cX)); value = data.phongPosition.x; break;\n        case 37 : setString(str,7,(cP,ch,co,cP,co,cs,cY)); value = data.phongPosition.y; break;\n        case 38 : setString(str,7,(cP,ch,co,cP,co,cs,cZ)); value = data.phongPosition.z; break;\n        case 39 : setString(str,7,(cP,ch,co,cD,ci,cf,cf)); value = data.phongParam.x; break;\n        case 40 : setString(str,7,(cP,ch,co,cS,cp,ce,cc)); value = data.phongParam.y; break;\n        case 41 : setString(str,6,(cP,ch,co,cA,cm,cb)); value = data.phongParam.z; break;\n\n        case 42 : setString(str,5,(cS,cp,co,ct,cV)); value = data.spotLight; break;\n        case 43 : setString(str,5,(cS,cp,co,ct,cX)); value = data.spotLightData.x; break;\n        case 44 : setString(str,5,(cS,cp,co,ct,cY)); value = data.spotLightData.y; break;\n        case 45 : setString(str,5,(cS,cp,co,ct,cE)); value = data.spotLightData.z; break;\n        case 46 : setString(str,5,(cS,cp,co,ct,cR)); value = data.spotLightColor.x; break;\n        case 47 : setString(str,5,(cS,cp,co,ct,cG)); value = data.spotLightColor.y; break;\n        case 48 : setString(str,5,(cS,cp,co,ct,cB)); value = data.spotLightColor.z; break;\n\n        case 49 : setString(str,6,(cO,cr,cb,ci,ct,cS)); value = data.Ostrength; break;\n        case 50 : setString(str,6,(cO,cr,cb,ci,ct,cC)); value = data.Ocycle; break;\n        case 51 : setString(str,5,(cO,cw,ch,ct,cX)); value = data.OXwt; break;\n        case 52 : setString(str,5,(cO,cc,co,cl,cX)); value = data.OXcr; break;\n        case 53 : setString(str,5,(cO,cw,ch,ct,cY)); value = data.OYwt; break;\n        case 54 : setString(str,5,(cO,cc,co,cl,cY)); value = data.OYcr; break;\n        case 55 : setString(str,5,(cO,cw,ch,ct,cZ)); value = data.OZwt; break;\n        case 56 : setString(str,5,(cO,cc,co,cl,cZ)); value = data.OZcr; break;\n        case 57 : setString(str,5,(cO,cw,ch,ct,cW)); value = data.OWwt; break;\n        case 58 : setString(str,5,(cO,cc,co,cl,cW)); value = data.OWcr; break;\n        case 59 : setString(str,5,(cO,cc,cn,ct,cX)); value = data.Ocenter.x; break;\n        case 60 : setString(str,5,(cO,cc,cn,ct,cY)); value = data.Ocenter.y; break;\n        case 61 : setString(str,5,(cO,cc,cn,ct,cZ)); value = data.Ocenter.z; break;\n    }\n\n    printInt(data.focus+1,t);\n    printString(gap,t);\n    printString(str,t);\n    printString(gap,t);\n    printFloat(value, t);\n    drawText(t, iChannel3, fragColor);\n}   \n\n// animation routines ----------------------------------------\n\nvoid cycleValue(int pDataIndex,inout float value, float vmin,float vmax, float speed) {\n    float ratio = 0.5 + 0.5 * cos(iTime * speed);  // 0 ... 1    \n    value = clamp(vmin + (vmax - vmin) * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);    \n}\n\nvoid cycleValue2(int pDataIndex,inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = clamp(baseValue-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);  \n}\nvoid cycleValue2b(int pDataIndex,inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + sin(iTime * speed);  // 0 ... 2\n    value = clamp(baseValue-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);  \n}\n\nvoid cycleValue3(int pDataIndex,inout float value, float baseValue, float amount, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    float deviation = baseValue * amount * 0.5;    \n    value = clamp(baseValue-deviation + deviation * ratio,pData[pDataIndex].vmin, pData[pDataIndex].vmax); \n}\n\nvoid cycleValue3Vec3(int pDataIndex,inout vec3 value, vec3 baseValue, float amount, float speed) {\n    for(int i=0;i<3;++i)\n        cycleValue3(pDataIndex+i,value[i],baseValue[i],amount,speed);\n}\n\n// ----------------------------------------------------\n\nvoid changeAim(inout Dataset data) {\n    cycleValue2(indexAim,data.aim.x,-1.0,8.0, 0.3);\n    cycleValue2(indexAim+1,data.aim.y,0.0,8.0, 0.4);\n    cycleValue2(indexAim+2,data.aim.z,0.0,8.0, 0.5);\n}\n    \nvoid alterPhongLight(inout Dataset data) {\n   cycleValue(indexPhong,data.phongColor.x,0.,5.,0.3);\n   cycleValue(indexPhong+1,data.phongColor.y,0.,5.,0.4);\n   cycleValue(indexPhong+2,data.phongColor.z,0.,5.,0.5);\n   \n   const float dist = 1.0;\n   cycleValue(indexPhong+3,data.phongPosition.x,-dist,dist,0.3);\n   cycleValue(indexPhong+4,data.phongPosition.y,-dist,dist,0.35);\n   cycleValue(indexPhong+5,data.phongPosition.z,-dist,dist,0.4);\n   \n   cycleValue(indexPhong+6,data.phongParam.x,0.,1.,0.2); // diffuse\n   cycleValue(indexPhong+7,data.phongParam.y,0.,1.,0.3); // specular\n   cycleValue(indexPhong+8,data.phongParam.z,5.,10.,0.4); // ambient\n}\n\nvoid alterSpotLight(inout Dataset data) {\n   cycleValue2(indexSpot,data.spotLight,data.spotLight,1.,0.03);   \n   cycleValue2(indexSpot+1,data.spotLightData.x,data.spotLightData.x,15.,0.01);\n   cycleValue2(indexSpot+2,data.spotLightData.y,data.spotLightData.y,15.,0.02);\n   cycleValue2(indexSpot+3,data.spotLightData.z,data.spotLightData.z,3.,0.004 );\n   cycleValue2(indexSpot+4,data.spotLightColor.x,data.spotLightColor.x,0.5,0.03);\n   cycleValue2(indexSpot+5,data.spotLightColor.y,data.spotLightColor.y,0.5,0.04);\n   cycleValue2(indexSpot+6,data.spotLightColor.z,data.spotLightColor.z,0.5,0.05);\n}\n\nvoid alterOrbitColors(inout Dataset data) {\n    const float weight = 2.;\n    cycleValue(indexOrbit+2,data.OXwt,-weight,weight,0.2); // weights\n    cycleValue(indexOrbit+4,data.OYwt,-weight,weight,0.3);\n    cycleValue(indexOrbit+5,data.OZwt,-weight,weight,0.5);\n //   cycleValue(indexOrbit+8,data.OWwt,-weight,weight,0.07);\n\n    const float color = 2.0;\n    cycleValue(indexOrbit+3,data.OXcr,-color,color,0.1);  // color code\n    cycleValue(indexOrbit+5,data.OYcr,-color,color,0.2);\n    cycleValue(indexOrbit+7,data.OZcr,-color,color,0.3);\n    cycleValue(indexOrbit+9,data.OWcr,-color,color,0.5);\n    \n    cycleValue(indexOrbit+10,data.Ocenter.x,-1.,1.0,0.3);\n    cycleValue(indexOrbit+11,data.Ocenter.y,-1.,1.0,0.5);\n    cycleValue(indexOrbit+12,data.Ocenter.z,-1.,1.0,0.7);\n}\n\nvoid moveCamera(inout Dataset data) {\n    float angle = iTime * 0.1;\n    float angle2 = iTime * 0.3;\n    float amt = 1.2;\n    \n    data.camera.x += cos(angle) * amt;\n    data.camera.y += cos(angle2) * amt;\n    data.camera.z += sin(angle) * amt;\n}\n\nvoid alterparams(inout Dataset data) {\n   float amt = 0.05;\n   cycleValue2(0,data.p1.x,data.p1.x,amt,0.1);\n   cycleValue2(1,data.p1.y,data.p1.y,amt,0.2);\n   cycleValue2(2,data.p1.z,data.p1.z,amt,0.3);\n   cycleValue2(3,data.p2.x,data.p2.x,amt,0.4);\n   cycleValue2(4,data.p2.y,data.p2.y,amt,0.5);\n   cycleValue2(5,data.p2.z,data.p2.z,amt,0.6);\n   cycleValue2(6,data.p3.x,data.p3.x,amt,0.5);\n   cycleValue2(7,data.p3.y,data.p3.y,amt,0.4);\n   cycleValue2(8,data.p3.z,data.p3.z,amt,0.3);\n   cycleValue2(8,data.angle,data.angle,amt,0.2);\n}\n\nvoid animateSpecifiedVariables(inout Dataset data) {\n    if(!data.animationEnable) return; \n\n    alterPhongLight(data); \n    alterparams(data);\n//    alterSpotLight(data);\n\n //   cycleValue(data.Ostrength,0.01,0.3,0.2);\n    alterOrbitColors(data);\n    \n/*\n    alterPhongLight(data); \n    //moveCamera(data);\n    //changeAim(data);\n\n    //cycleValue3(data.Ocycle,OcycleDefault,1.2,0.1);\n    //alterOrbitColors(data);\n\n    //cycleValue3(data.Ostrength,OstrengthDefault,1.2,0.1);\n*/\n\n}\n\n// --------------------------------------------------------\n    \nvoid downloadData(ivec2 address,inout float v1,inout float v2,inout float v3) {\n    vec3 d = fetchData(iChannel0, address).xyz;\n    v1 = d.x; v2 = d.y; v3 = d.z;\n}    \n\nvoid readStoredData(inout Dataset data) {\n    float unused = 0.;\n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    data.focus = int(sd.x);\n    data.displayCount = int(sd.y);\n    data.animationEnable = bool(sd.z == 1.0);\n    \n    downloadData(P0_ADDR,data.p1.x,data.p1.y,data.p1.z);\n    downloadData(P1_ADDR,data.p2.x,data.p2.y,data.p2.z);\n    downloadData(P2_ADDR,data.p3.x,data.p3.y,data.p3.z);\n    downloadData(P3_ADDR,data.angle,unused,unused);\n\n    downloadData(P6_ADDR,data.camera.x,data.camera.y,data.camera.z);\n    downloadData(P7_ADDR,data.aim.x,data.aim.y,data.aim.z);\n    downloadData(P8_ADDR,data.invpos.x,data.invpos.y,data.invpos.z);\n    downloadData(P9_ADDR,data.invradius,data.invangle,data.ssDistance);\n    downloadData(P10_ADDR,data.ssAngle,data.ssAmount,data.ssMix);\n    downloadData(P11_ADDR,data.phongColor.x,data.phongColor.y,data.phongColor.z);\n    downloadData(P12_ADDR,data.phongPosition.x,data.phongPosition.y,data.phongPosition.z);\n    downloadData(P13_ADDR,data.phongParam.x,data.phongParam.y,data.phongParam.z);\n    downloadData(P14_ADDR,data.spotLight,data.spotLightData.x,data.spotLightData.y);\n    downloadData(P15_ADDR,data.spotLightData.z,data.spotLightColor.x,data.spotLightColor.y);\n    downloadData(P16_ADDR,data.spotLightColor.z,data.Ostrength,data.Ocycle);\n    downloadData(P17_ADDR,data.OXwt,data.OXcr,data.OYwt);\n    downloadData(P18_ADDR,data.OYcr,data.OZwt,data.OZcr);\n    downloadData(P19_ADDR,data.OWwt,data.OWcr,data.Ocenter.x);\n    downloadData(P20_ADDR,data.Ocenter.y,data.Ocenter.z,unused);\n    \n    sd = fetchData(iChannel0, UNIFORM_1).xyz;\n    data.inversionEnable = bool(sd.x == 1.0);\n    data.stereoEnable = bool(sd.y == 1.0);\n\n    sd = fetchData(iChannel0, UNIFORM_2).xyz;\n    data.secondsurfaceEnable = bool(sd.x == 1.0);\n    data.refractEnable = bool(sd.y == 1.0);\n    \n    data.viewVector = fetchData(iChannel0, VV_1).xyz;\n    data.sideVector = fetchData(iChannel0, VV_2).xyz;\n    data.topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\nvoid initializedNonStoredData(inout Dataset data) {\n    data.maxsteps = 5;\n    data.orbitTrap = vec4(10000.);\n    data.epsilon = 0.0005; // deviation when calculating normal\n    \n    data.ambient = 0.0;\n    data.contrast = 1.;\n    data.vibrant = 0.01;\n    data.dim = 0.013;\n\tdata.color = vec3(0,0,0); \n\n    data.fogDistance = 0.; //-1.5; // set to 0.0 to disable fog\n    data.fogAmount = 0.21;\n    data.fogColor = 0.52;\n    \n    data.ssIterations = 1;\n    data.parallax = 0.01; // use smaller values when viewing closeup objects\n}\n\n// --------------------------------------------------------\n\nvec3 Refract(vec3 incidentVec, vec3 normal, float eta) {\n  float N_dot_I = dot(normal, incidentVec);\n  float k = 1.0 - eta * eta * (1.0 - N_dot_I * N_dot_I);\n  if (k < 0.0)\n    return vec3(0.0);\n  else\n    return eta * incidentVec - (eta * N_dot_I + sqrt(k)) * normal;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(0.); \n\n    Dataset data;\n    readStoredData(data);\n    initializedNonStoredData(data);\n    animateSpecifiedVariables(data);\n\n    setDirection(fragCoord,data);\n\trayMarch(data);\n    \n\tif(data.depth < MAX_DIST) {  \n        data.position = data.camera + data.direction * data.depth;\n        calcNormal(data);\n        applyColoring(data);\n\n        // second surface -------------------------------\n        if(data.secondsurfaceEnable) {\n            vec3 originalCamera = data.camera;\n            \n            for(int i=0;i<5;++i) {\n                if(i >= data.ssIterations) break;\n\n                if(data.refractEnable)\n                    data.direction = Refract(data.direction, data.normal * data.ssAngle,data.ssAmount);\n                else\n                    data.direction = reflect(data.direction, data.normal * data.ssAngle);\n                data.direction = normalize(data.direction);\n\n                data.camera = data.position + data.ssDistance * data.direction;\n                rayMarch(data);\n\n                if(data.depth < MAX_DIST) { \n                    data.position = data.camera + data.direction * data.depth;\n                    calcNormal(data);\n                    vec3 previousColor = data.color;\n                    applyColoring(data);\n                    data.color = mix(previousColor,data.color,data.ssMix); \n                }\n                else\n                    break;\n            }\n            \n            data.camera = originalCamera;\n        }\n    }\n\n    if(data.fogDistance != 0.0) {\n        float f = data.depth - data.fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * data.fogAmount);\n            data.color = mix(data.color, vec3(0.2 + f * data.fogColor),f);\n        }\n    }\n\n    fragColor = vec4(data.color,1.0);\n    \n    if(data.displayCount > 0) \n        displayData(data,fragColor,fragCoord);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float p1xD = 8.78;\nconst float p1yD = 0.34999707;\nconst float p1zD = -4.549979;\nconst float p2xD = 0.;\nconst float p2yD = 0.549999;\nconst float p2zD = 0.88503367;\nconst float p3xD = 0.99998015;\nconst float p3yD = 1.8999794;\nconst float p3zD = 3.349999;\nconst float pangle = -1.5399;\n\nconst vec3  cameraDefault = vec3(-0.7081,-1.7807,1.6260);\nconst vec3  aimDefault = vec3(-1.1471,-0.1999,-2.6989);\n\nconst float spotStrength = 0.65;\nconst vec3  spotData = vec3(-0.21,-4.69,1.26);\nconst vec3  spotColor = vec3(1.,0.6,0.);\n\nconst vec3  invposDefault = vec3(0.081,0.2915,0.7482);\nconst float invradiusDefault = 1.3589;\nconst float invangleDefault = 0.9706;\n\nconst float OstrengthDefault = 0.02;\nconst float OcycleDefault = 0.0;\nconst float OXwtDefault = 2.0736677;\nconst float OXcrDefault = -3.9815997;\nconst float OYwtDefault = 2.03396538;\nconst float OYcrDefault = 1.71172849;\nconst float OZwtDefault = -2.74972636;\nconst float OZcrDefault = -0.55577678;\nconst float OWwtDefault = 0.0; \nconst float OWcrDefault = -4.24845531;\nconst vec3  OcenterDefault = vec3(-0.5); \n\nconst float ssDistanceDefault = 0.0093;\nconst float ssAngleDefault = 0.7899;\nconst float ssAmountDefault = 1.3;\nconst float ssMixDefault = 1.;\n\nconst vec3 pColorD = vec3(0.5,0.5,0.5);\nconst vec3 pPosD = vec3(0.5,0.5,0.5);\nconst vec3 pParamD = vec3(0.5,0.5,0.5);\n\n// ========================================================================\nconst float pDelta = 0.001;\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n// leave room for future entries without having to adjust hardwired param array positions\n#define UNUSED  999.\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\n// leave room for future entries without having to adjust hardwired param array positions\n#define UNUSED  999.\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\nconst ParamData[] pData = ParamData[]( \n    //  0 p0 ---------------\n    ParamData(p1xD, -10.,10.,0.01),\n    ParamData(p1yD, -10.,10.,0.001),\n    ParamData(p1zD, -10.,10.,0.01),\n    //  3 p1 ---------------\n    ParamData(p2xD, -10.,10.,0.01),\n    ParamData(p2yD, -10.,10.,0.01),\n    ParamData(p2zD, -10.,10.,0.01),\n    //  6 p2 ---------------\n    ParamData(p3xD, -10.,10.,0.01),\n    ParamData(p3yD, -10.,10.,0.01),\n    ParamData(p3zD, -10.,10.,0.01),\n    //  9 p3 ---------------\n    ParamData(pangle, -4.,4.,0.01),\n    UNUSEDP,\n    UNUSEDP,\n    // 12 p4 ---------------\n    UNUSEDP,\n    UNUSEDP,\n    UNUSEDP,\n    // 15 p5 ---------------\n    UNUSEDP,\n    UNUSEDP,\n    UNUSEDP,\n    // 18 p6 ---------------    \n    ParamData(cameraDefault.x, -20., 20., 0.01), \n    ParamData(cameraDefault.y, -20., 20., 0.01),\n    ParamData(cameraDefault.z, -20., 20., 0.01),\n    // 21 p7 ---------------\n    ParamData(aimDefault.x, -20., 20., 0.01), \n    ParamData(aimDefault.y, -20., 20., 0.01),\n    ParamData(aimDefault.z, -20., 20., 0.01),\n    // 24 p8 ---------------\n    ParamData(invposDefault.x, -15., 15., 0.01),\n    ParamData(invposDefault.y, -15., 15., 0.01),\n    ParamData(invposDefault.z, -15., 15., 0.01),\n    // 27 p9 ---------------    \n    ParamData(invradiusDefault, 0.01, 10., 0.01),\n    ParamData(invangleDefault, -5., 5., 0.001), \n    ParamData(ssDistanceDefault, 0., 5., 0.01),\n    // 30 p10 ---------------    \n    ParamData(ssAngleDefault, -1., 1., 0.01),\n    ParamData(ssAmountDefault, 0.3, 1.3, 0.01),\n    ParamData(ssMixDefault, 0., 1., 0.01),\n    // 33 p11 ---------------    \n    ParamData(pColorD.x, 0.,3., 0.01),\n    ParamData(pColorD.y, 0.,3., 0.01),\n    ParamData(pColorD.z, 0.,3., 0.01),\n    // 36 p12 ---------------    \n    ParamData(pPosD.x, -20.,20., 0.01),\n    ParamData(pPosD.y, -20.,20., 0.01),\n    ParamData(pPosD.z, -20.,20., 0.01),\n    // 39 p13 ---------------    \n    ParamData(pParamD.x, 0.,5., 0.01),\n    ParamData(pParamD.y, 0.,5., 0.01),\n    ParamData(pParamD.z, 0.,5., 0.01),\n    // 42 p14 ---------------    \n    ParamData(spotStrength, 0., 3., 0.01),\n    ParamData(spotData.x, -6., 6., 0.01),\n    ParamData(spotData.y, -6., 6., 0.01),\n    // 45 p15 ---------------    \n    ParamData(spotData.z, -2., 2., 0.01),\n    ParamData(spotColor.x, 0., 1., 0.01),\n    ParamData(spotColor.y, 0., 1., 0.01),\n    // 48 p16 ---------------    \n    ParamData(spotColor.z, 0., 1., 0.01),\n    ParamData(OstrengthDefault, 0., 5., 0.01),\n    ParamData(OcycleDefault, 0., 5., 0.01),\n    // 51 p17 ---------------    \n    ParamData(OXwtDefault, -5., 5., 0.01),\n    ParamData(OXcrDefault, -5., 5., 0.01),\n    ParamData(OYwtDefault, -5., 5., 0.01),\n    // 54 p18 ---------------    \n    ParamData(OYcrDefault, -5., 5., 0.01),\n    ParamData(OZwtDefault, -5., 5., 0.01),\n    ParamData(OZcrDefault, -5., 5., 0.01),\n    // 57 p19 ---------------    \n    ParamData(OWwtDefault, -5., 5., 0.01),\n    ParamData(OWcrDefault, -5., 5., 0.01),\n    ParamData(OcenterDefault.x, -5., 5., 0.01),\n    // 60 p20 ---------------    \n    ParamData(OcenterDefault.y, -5., 5., 0.01),\n    ParamData(OcenterDefault.z, -5., 5., 0.01),\n    UNUSEDP\n); \n\nconst int indexCamera = 18;\nconst int indexAim = 21;\nconst int indexInversion = 24;\nconst int indexSecondSurf = 29;\nconst int indexPhong = 33;\nconst int indexSpot = 42;\nconst int indexOrbit = 49;\n\nconst int PDATA_SIZE = 62;\nconst int PDATA_ADDR_COUNT = (PDATA_SIZE+2)/3;\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR =  ivec2( 2, 0);\nconst ivec2 P1_ADDR =  ivec2( 3, 0);\nconst ivec2 P2_ADDR =  ivec2( 4, 0);\nconst ivec2 P3_ADDR =  ivec2( 5, 0);\nconst ivec2 P4_ADDR =  ivec2( 6, 0);\nconst ivec2 P5_ADDR =  ivec2( 7, 0); \nconst ivec2 P6_ADDR =  ivec2( 8, 0); \nconst ivec2 P7_ADDR =  ivec2( 9, 0); \nconst ivec2 P8_ADDR =  ivec2(10, 0); \nconst ivec2 P9_ADDR =  ivec2(11, 0); \nconst ivec2 P10_ADDR = ivec2(12, 0); \nconst ivec2 P11_ADDR = ivec2(13, 0); \nconst ivec2 P12_ADDR = ivec2(14, 0); \nconst ivec2 P13_ADDR = ivec2(15, 0); \nconst ivec2 P14_ADDR = ivec2(16, 0); \nconst ivec2 P15_ADDR = ivec2(17, 0); \nconst ivec2 P16_ADDR = ivec2(18, 0); \nconst ivec2 P17_ADDR = ivec2(19, 0); \nconst ivec2 P18_ADDR = ivec2(20, 0); \nconst ivec2 P19_ADDR = ivec2(21, 0); \nconst ivec2 P20_ADDR = ivec2(22, 0); \n\nconst ivec2[] storeAddr = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,\n    P10_ADDR,P11_ADDR,P12_ADDR,P13_ADDR,P14_ADDR,P15_ADDR,P16_ADDR,P17_ADDR,P18_ADDR,P19_ADDR,\n    P20_ADDR);\n\nconst ivec2 UNIFORM_1 = ivec2(23, 0); // booleans\nconst ivec2 UNIFORM_2 = ivec2(24, 0);\nconst ivec2 VV_1 = ivec2(25, 0);   // view vectors\nconst ivec2 VV_2 = ivec2(26, 0);\nconst ivec2 VV_3 = ivec2(27, 0);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ========================================================================\n// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n//    vec2 uvSize = f.charSize / f.texSize;\n//    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\n/*\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n*/\n\nvoid printInt(int val, inout TextCursor t)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor)\n{\n    fragColor = t.outColor;\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = vec4(0.4,0.4,0.4,10.);\n        \n/*      \n    fragColor = vec4(0.);\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = t.outColor;\n*/\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < PDATA_SIZE) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 viewVector = normalize(fetchData(iChannel0, P7_ADDR).xyz);  // aim\n        vec3 sideVector = vec3(0.0, 1.0, 0.0);\n        sideVector = cross(sideVector,viewVector);\n        sideVector = normalize(sideVector);\n        vec3 topVector = viewVector;\n        topVector = cross(topVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT  = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT  = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis,inout vec3[PDATA_ADDR_COUNT] memory) {\n    if(focus > PDATA_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 3;  // memory index\n    int focusField = focus % 3;  // x,y,z field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.001;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n                if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.); \n    if(fragCoord.x > 30.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    updateViewVectors(fragColor, fragCoord);\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    vec3 m = vec3(0.);\n    vec3[PDATA_ADDR_COUNT] memory = vec3[](m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m);\n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    //-------------\n    // if <Alt><Shift> alter target position.xy regardless of focus    \n    if(getKeyState(KEY_SHIFT) && getKeyState(KEY_ALT)) \n        focus = 21;\n    else\n    \n    // if <Shift> alter camera position.xy regardless of focus\n    if(getKeyState(KEY_SHIFT)) \n        focus = 18;\n    //-------------\n    \n    if(alterFocusedVariable(focus,  0,memory)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1,memory)) resetDisplayCount = true;\n    \n    // output possibly altered values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange == 0. && (iFrame % 12 == 0)) { // slow down auto repeat of up/dn arrows\n            if(getKeyState(KEY_UP))   focusChange = -1.;\n            if(getKeyState(KEY_DOWN)) focusChange = +1.;\n        }\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(PDATA_SIZE-1);\n                if(fragColor.x >= float(PDATA_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'  animationEnable\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n      \n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_1)) {\n        fragColor = fetchData(iChannel0, UNIFORM_1); \n        if(iFrame < 10) fragColor.xyz = vec3(0.);\n\n        bool ki = getKeyClick(73); // 'I'\n        bool ks = getKeyClick(83); // 'S'\n        if(ki) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n        if(ks) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n    }\n\n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_2)) {\n        fragColor = fetchData(iChannel0, UNIFORM_2); \n        if(iFrame < 10) fragColor.xyz = vec3(0.);\n\n        bool kq = getKeyClick(81); // 'Q'\n        bool kw = getKeyClick(87); // 'W'\n        if(kq) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n        if(kw) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}