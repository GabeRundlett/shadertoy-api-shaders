{
    "Shader": {
        "info": {
            "date": "1569834314",
            "description": "Analytic Filtering of GaborNoise/Local Random Phase Noise based on the methodology introduced by Lagae et al. in the original paper from 2009.\nFind more details on the calculations here : [url]https://h4w0.frama.io/pages/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3dKGRD",
            "likes": 19,
            "name": "Filtered LRPN",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "texture",
                "filtering",
                "lrpn"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 930
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= Filtered Local Random Phase Noise \n//=======================================================\n//== Based on the filtering process of Gabor Noise from Lagae et al. 2009\n//== http://graphics.cs.kuleuven.be/publications/LLDD09PNSGC/\n//== replaced the Kaiser Bessel Window of the original paper by a Gaussian Window\n//== https://www.unilim.fr/pages_perso/guillaume.gilet/publications/pdf/ProcTextures.pdf\n//== A blog post explaining the details of calculation : https://h4w0.frama.io/pages/posts/2019-09-30-FilteredLRPN.html\n//== Author : Arthur Cavalier\n//=======================================================\n\n// User Parameters -----------------------------------------------------------------\nconst int   LRPN_COSINES     = 5;\nconst float LRPN_RESOLUTION  = 15.0;\n\n//--------------------------------------------------------------------------------------------------------\n//-- Filtered Local Random Phase Noise -------------------------------------------------------------------\nfloat filtered_local_random_phase_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    float lrpn   = 0.;\n    float weight = 1. / float(cosines);\n    float alpha  = 1./1.2;\n\n    mat2  Jacobian = mat2( 0.5*dFdx(scaled_coords), 0.5*dFdy(scaled_coords) );\n    mat2  Filter_Sigma = Jacobian*transpose(Jacobian);\n    mat2  Filter_InvSigma = inverse(Filter_Sigma);\n    float Filter_Lambda = 1.0 / (m_2_pi*sqrt(determinant_2x2(Filter_Sigma)));\n\n    mat2 Gabor_Sigma = mat2( 1.0 / (m_2_pi*alpha*alpha) );\n    mat2 Gabor_InvSigma = mat2( m_2_pi*alpha*alpha );\n    mat2 Product_InvSigma = Filter_Sigma+Gabor_Sigma;\n    mat2 Product_Sigma = inverse(Product_InvSigma);\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        \n        float sum_of_cosines    = 0.; \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            \n            vec2 Gabor_Mean = m_2_pi * fr * vec2(cos(or),sin(or));  // Oriented Frequency\n\t\t\t\n            // Now we compute the product of the gaussian footprint and the \n            // fourier transform of the gabor kernel in the spectral domain\n            \n            vec2 Product_Mean = Product_Sigma * Gabor_Sigma * Gabor_Mean; // \\mu_3\n\n            float scale_gabor = sqrt(determinant_2x2(Gabor_Sigma)*determinant_2x2(Product_Sigma));\n            scale_gabor *= gaussian(vec2(0.),1.,Gabor_Mean,Filter_InvSigma+Gabor_InvSigma); //\\lambda_3\n            scale_gabor *= gaussian_inv_sigma(xy,1.,vec2(0.),Product_Sigma); // new window\n            float filtered_harmonic = dot(xy, Product_Mean) + ph; // new harmonic\n\n            sum_of_cosines   += scale_gabor * cos(filtered_harmonic) ; // the new anisotropic gabor kernel\n        }\n        lrpn += weight * sum_of_cosines;\n    }\n    return lrpn;\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = ((2.*fragCoord.xy-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(0.1*iTime + 6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(0.1*iTime + 6.0*mouse) );\n    vec3 target = vec3( 0.5, -0.4, -0.5 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(0.),1.);\n  \n    // Noise Parameters\n    float R = LRPN_RESOLUTION;\n    int   K = LRPN_COSINES;\n    vec2  F = vec2( 0.1, 0.1+ (0.5+0.5*cos(0.5*iTime)) );\n    vec2  O = vec2( 0.1, 0.1+ (0.5+0.5*sin(0.2*iTime))*m_pi_2 );\n\n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,0.));\n    if(hit>0.0)\n    {\n        vec3 hit_position = (origin + hit*direction);\n        vec2 texture_coords = hit_position.xz/5.;\n        float lrpn = 0.; \n        if(coords.x<0.)\n        {\n            lrpn = local_random_phase_noise(texture_coords,R,K,F,O);\n        }\n        else\n        {\n           lrpn = filtered_local_random_phase_noise(texture_coords,R,K,F,O);\n        }\n        fragColor.rgb = vec3(0.5+0.5*lrpn);\n    }\n    fragColor.rgb *= smoothstep( 0.0, 0.01, abs(coords.x) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uint  LRPN_GLOBAL_SEED = 0u;\n\n// Constants -----------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n// RayTracing -----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n// Quick Matrix Maths\nfloat determinant_2x2(in mat2 m)         {return (m[0][0]*m[1][1] - m[0][1]*m[1][0]);}\n\n// PRNG ----------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Gaussian Window Function ----------------------------------------------------------------------------\nfloat gaussian(in vec2 st, in float c, in vec2 mu, in mat2 sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inverse(sig)*p);\n    return c*exp(body);\n}\n\nfloat gaussian_inv_sigma(in vec2 st, in float c, in vec2 mu, in mat2 inv_sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inv_sig*p);\n    return c*exp(body);\n}\n\n\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Unfiltered Local Random Phase Noise -----------------------------------------------------------------\nfloat local_random_phase_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    float lrpn   = 0.;\n    float weight = 1. / float(cosines);\n    mat2  sigma  = mat2( 1.2*1.2/m_2_pi );\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        \n        float sum_of_cosines    = 0.;  \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            float ff = m_2_pi * dot(xy, fr * vec2(cos(or),sin(or)) );                               // Oriented Frequency\n            sum_of_cosines   += cos(ff+ph);\n        }\n        lrpn += gaussian(xy, 1., vec2(0.0), sigma) * weight * sum_of_cosines;\n    }\n    return lrpn;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}