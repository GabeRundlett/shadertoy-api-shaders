{
    "Shader": {
        "info": {
            "date": "1678912320",
            "description": "This model creater for printing in 3d printer",
            "flags": 0,
            "hasliked": 0,
            "id": "csyGRd",
            "likes": 2,
            "name": "My Holo3DModel",
            "published": 3,
            "tags": [
                "model"
            ],
            "usePreview": 0,
            "username": "Behzod",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "#define MAX_STEP  20.\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat SDsphere(vec3 pos, float R){\n  return length(pos) - R;\n}\n\n// vertical cylinder\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  h = h / 2.;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat footMale(vec3 pos){\n  float d2 = sdCappedCone(pos, 0.02, 0.015 + 0.01, 0.035 + 0.01);\n  float d = sdCylinder(pos, 0.1, 0.015);\n  \n  d = max(d2, -d);\n\n  return d;\n}\n\nfloat footFemale(vec3 pos){\n  float d2 = sdCappedCone(pos, 0.03, 0.07, 0.04);\n  float d = sdHexPrism(pos * rotateX(3.1415/2.), vec2(0.055/2., 0.05));\n\n  d = max(d2, -d);\n  return d;\n}\n\nfloat TinyBox(vec3 pos, vec3 off){\n  float d2 = sdBox(pos - off, vec3(0.01, 0.20, 0.20));\n  d2 = max(d2, -sdCylinder((pos - off - vec3(0, 0.4,0.4))*rotateX(3.14/2.)*rotateZ(3.14/2.), 0.06, 0.60));\n  return d2;\n}\n\nfloat Z = 1.7;\n\nfloat model3D(vec3 pos, float d){\n  \n  pos /= Z;\n\n  float d2 = sdCylinder(pos, 0.03, (0.341 + 0.085) );\n  d = min(d2, d);\n\n/*  4ta teshik */\n  d2 = sdCylinder((pos - vec3(-0.2438, 0, 0.2299)), 0.04, 0.015 );\n  d = max(-d2, d);\n\n  d2 = sdCylinder((pos - vec3(0.2109, 0, 0.2667)), 0.04, 0.015 );\n  d = max(-d2, d);\n\n  d2 = sdCylinder((pos - vec3(-0.1943, 0, -0.2781)), 0.04, 0.015 );\n  d = max(-d2, d);\n\n  d2 = sdCylinder((pos - vec3(0.2642, 0, -0.2273)), 0.04, 0.015 );\n  d = max(-d2, d);\n/* 8mm lik ustuncha */\n  d2 = sdCylinder((pos - vec3(0.0, 0.12/2. + 0.03/2., 0.0)), 0.12, 0.075 / 2. );\n  d = min(d2, d);\n\n/* Female model */\n  d2 = footFemale((pos - vec3(-0.2438, 0.03, 0.2299)) );\n  d = min(d2, d);\n\n  d2 = footFemale((pos - vec3(0.2109, 0.03, 0.2667)) );\n  d = min(d2, d);\n\n  d2 = footFemale((pos - vec3(-0.1943, 0.03, -0.2781)) );\n  d = min(d2, d);\n\n  d2 = footFemale((pos - vec3(0.2642, 0.03, -0.2273)) );\n  d = min(d2, d);\n\n/* Male model */\n  d2 = footMale((pos - vec3(-0.2438, -0.015, 0.2299)) );\n  d = min(d2, d);\n\n  d2 = footMale((pos - vec3(0.2109, -0.015, 0.2667)) );\n  d = min(d2, d);\n\n  d2 = footMale((pos - vec3(-0.1943, -0.015, -0.2781)) );\n  d = min(d2, d);\n\n  d2 = footMale((pos - vec3(0.2642, -0.015, -0.2273)) );\n  d = min(d2, d);\n\n// Main Catcher\n  vec3 off = vec3(0., 0.25/2., 0.);\n  d2 = sdCylinder(pos - off,  0.26, 0.19/2.); //  INNER CYL\n  d2 = max(-d2, sdCylinder(pos - off, 0.25, 0.22/2.));// OUTTER CYL\n  d = min(d2, d);\n  \n  d2 = sdCylinder((pos - vec3(0, 0.04+0.015, 0)) * rotateX(3.14/2.) * rotateZ(3.1415/4.),  0.26, 0.025/2.); //  INNER CYL\n  d = max(-d2, d);\n\n  d2 = sdCylinder((pos - vec3(0, 0.04+0.015, 0)) * rotateX(3.14/2. + 3.1415) * rotateZ(3.1415/4.),  0.26, 0.025/2.); //  INNER CYL\n  d = max(-d2, d);\n// Tiny Box \n  pos *= 2.;\n  off = vec3(0, 0.20, 0.20 + 0.21);\n  d2 = TinyBox(pos * rotateY(3.14/2.), off);\n  d = min(d2, d);\n  d2 = TinyBox(pos * rotateY(3.14), off);\n  d = min(d2, d);\n  d2 = TinyBox(pos * rotateY(3.14*3./2.), off);\n  d = min(d2, d);\n  d2 = TinyBox(pos, off);\n  d = min(d2, d);\n\n  return d;\n}\n\nfloat map(vec3 pos)\n{\n  float d1 = SDsphere(pos - vec3(0, 0, 0), .1);\n  float d2 = pos.y + 1.;\n  float d = min(d2, d2);\n\nif(iTime < 20.)\n  pos *= rotateX( -3.14 / 2. + iTime) * rotateZ( 3.14/2. );\nelse if(iTime < 40.)\n  pos *= rotateX( -3.14 / 2. + 3.14/12.) ;\nelse\n  pos *= rotateX( -3.14 / 2. + iTime/2.) * rotateZ( 3.14/2. + iTime/3.);\n\n\n  d2 = model3D(pos, d2);\n\n  d = min(d, d2);\n\n  return d;\n}\n\nvec3 calcNorm(in vec3 pos)\n{\n   vec2 e = vec2(0.0001, 0.0);\n   \n   return normalize( vec3(map(pos+e.xyy)-map(pos-e.xyy) ,\n                          map(pos+e.yxy)-map(pos-e.yxy) ,\n                          map(pos+e.yyx)-map(pos-e.yyx) ));\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n     float t = 0.;\n     for(int i = 0; i < 100; i++)\n     {\n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n          break;\n        t += h;\n        \n        if(t > MAX_STEP)\n          break;\n     }\n     if(t > MAX_STEP) t = -1.;\n     \n     return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 p = (fragCoord*2. - iResolution.xy)/iResolution.y;\n     \n     vec3 ro = vec3(0., 0., 2.);\n     vec3 rd = normalize(vec3(p, -1.));\n     \n     vec3 col = vec3(0.6, 0.7, 0.8) - 0.5*rd.y;\n     \n     \n     float t = castRay(ro, rd);\n     \n     if(t > 0.0)\n     {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNorm(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        vec3 sun_dir = vec3(0.8, 0.4, 0.2);\n        vec3 sky_dir = vec3(0.0, 1.0, 0.3);\n        vec3 bou_dir = vec3(0.0, -1.0, 0.0);\n        \n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0 );\n        float sun_shad = step( castRay(pos + nor*0.001, sun_dir), 0.0);\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, sky_dir), 0.0, 1.0 );\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, bou_dir), 0.0, 1.0 );\n        \n        \n        col  = mate*vec3(7., 4.5, 3.) * sun_dif*sun_shad;\n        col += mate*vec3(0.5, 0.8, 0.9) * sky_dif;\n        col += mate*vec3(0.7, 0.3, 0.2)*bou_dif;\n     }\n     \n     col = pow(col, vec3(0.454789));\n     fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}