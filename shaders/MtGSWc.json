{
    "Shader": {
        "info": {
            "date": "1486396243",
            "description": "GPGPU sound test",
            "flags": 8,
            "hasliked": 0,
            "id": "MtGSWc",
            "likes": 126,
            "name": "My First Shader Sound",
            "published": 3,
            "tags": [
                "sound"
            ],
            "usePreview": 0,
            "username": "keim",
            "viewed": 6153
        },
        "renderpass": [
            {
                "code": "// Constants ----------\n#define PI 3.14159265358979\n#define P2 6.28318530717959\n\nconst int   MAX_TRACE_STEP = 60;\nconst float MAX_TRACE_DIST = 180.;\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR = .82;\nconst vec3  GAMMA = vec3(1./2.2);\n\nconst float GI_LENGTH = .8;\nconst float GI_STRENGTH = .4;\nconst float AO_STRENGTH = .4;\nconst int   MAX_SHADOW_TRACE_STEP = 10;\nconst float MAX_SHADOW_TRACE_DIST = 10.;\nconst float MIN_SHADOW_MARCHING = .2;\nconst float SHADOW_SHARPNESS = 4.;\n\nconst float LENS_BLUR = .3;\n\n\n// Structures ----------\nstruct Surface {\n  float d;\n  vec4 kd;  // should be \"kd.w=1\" for ao shadow strength\n};\nSurface _min(Surface s,Surface t) {if(s.d<t.d)return s;return t;}\n\nstruct Ray {\n  vec3 org, dir;\n  float len, stp;\n};\nvec3 _pos(Ray r) {return r.org+r.dir*r.len;}\n\nstruct Hit {\n  vec3 pos;\n  Ray ray;\n  Surface srf;\n};\n\nstruct Camera {\n  vec3 pos, tgt;\n  float rol, fcs;\n};\nmat3 _mat3(Camera c) {\n  vec3 w = normalize(c.pos-c.tgt);\n  vec3 u = normalize(cross(w,vec3(sin(c.rol),cos(c.rol),0)));\n  return mat3(u,normalize(cross(u,w)),w);\n}\n\nstruct AmbientLight {\n  vec3 dir, col;\n};\nvec3 _lit(vec3 n, AmbientLight l){return clamp((dot(n, l.dir)+1.)*.5,0.,1.)*l.col;}\n\n\n// Grobal valiables ----------\nconst float bpm = 144.;\nconst AmbientLight amb = AmbientLight(vec3(0,1,0), vec3(.7,.7,.7));\nconst AmbientLight dif = AmbientLight(normalize(vec3(1,2,1)), vec3(.7,.7,.7));\nfloat phase;\n\n\n// Utilities ----------\nvec3 _rgb(vec3 v) {\n  return ((clamp(abs(fract(v.x+vec3(0,2./3.,1./3.))*2.-1.)*3.-1.,0.,1.)-1.)*v.y+1.)*v.z;\n}\n\nmat3 _sMat(float th, float ph) {\n  float x=cos(th), y=cos(ph), z=sin(th), w=sin(ph);\n  return mat3(y,w*z,-w*x,0,x,z,w,-y*z,y*x);\n}\n\n\n// Distance Functions ----------\nfloat fPlane(vec3 p, vec3 n, float d) {\n  return dot(p,n) + d;\n}\n\nfloat fBox(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.)) - r;\n}\n\nvec3 repXZ(vec3 p, vec2 r){\n  vec2 hr = r * .5;\n  return vec3(mod(p.x+hr.x, r.x)-hr.x, p.y, mod(p.z+hr.y, r.y)-hr.y);\n}\n\nfloat fHex(vec3 p, vec2 h, float r) {\n  vec3 q = abs(p);\n  q.x = max(q.x*0.866025+q.z*0.5,q.z);\n  return length(max(q.xy-h.xy,0.)) - r;\n}\n\n// World Mapping ----------\nSurface map(vec3 p){\n  float lv = min(1., iTime / 16.);\n  float es = exp(sin(phase*.5-length(p)*.2));\n  vec2  bs = vec2(.6/es,.6*es);\n  vec3  hx = vec3(1.73205081,1,0)*4.;\n  vec3  rp =  repXZ(p, hx.xy);\n  vec3  rp2 = repXZ(p+hx.xzy*.5, hx.xy);\n  vec3  col = _rgb(vec3(phase/256.,.4,.4));\n  rp.y -= bs.y+.4-length(p)*.01;\n  rp2.y -= bs.y+.4-length(p)*.01;\n\n  return _min(\n    Surface(fPlane(p, vec3(0,1,0), lv*3.8-3.8), vec4(col,1)), \n    _min(\n      Surface(fHex(rp,  bs, .4), vec4(.7,.7,.7,1)),\n      Surface(fHex(rp2, bs, .4), vec4(.3,.3,.3,1))\n    )\n  );\n}\n\n\n// Lighting ----------\nvec3 calcNormal(in vec3 p){\n  vec3 v=vec3(.001,0,map(p).d);\n  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));\n}\n\nfloat ss(in vec3 pos, in vec3 dir) {\n  float sdw=1., len=.01;\n  for( int i=0; i<MAX_SHADOW_TRACE_STEP; i++ ) {\n    float d = map(pos + dir*len).d;\n    sdw = min(sdw, SHADOW_SHARPNESS*d/len);\n    len += max(d, MIN_SHADOW_MARCHING);\n    if (d<TRACE_PRECISION || len>MAX_SHADOW_TRACE_DIST) break;\n  }\n  return clamp(sdw, 0., 1.);\n}\n\nvec4 gi(in vec3 p, in vec3 n) {\n  vec4 col = vec4(0);\n  for (int i=0; i<4; i++) {\n    float hr = .01 + float(i) * GI_LENGTH / 4.;\n    Surface s = map(n * hr + p);\n    col += s.kd * (hr - s.d);\n  }\n  col.rgb *= GI_STRENGTH / GI_LENGTH;\n  col.w = clamp(1.-col.w * AO_STRENGTH / GI_LENGTH, 0., 1.);\n  return col;\n}\n\nvec3 lighting(in Hit h) {\n  vec3 n = calcNormal(h.pos);\n  vec4 gin = gi(h.pos, n);\n  //   lin = ([Ambient]    + [Diffuse]    * [Soft shadow])      * [A.O] + [G.I.]\n  vec3 lin = (_lit(n, amb) + _lit(n, dif) * ss(h.pos, dif.dir)) * gin.w + gin.rgb;\n  return  h.srf.kd.rgb * lin;\n}\n\n\n// Ray tracing ----------\nRay ray(in vec2 p, in Camera c) {\n  return Ray(c.pos, normalize(_mat3(c) * vec3(p.xy, -c.fcs)), .0, .0);\n}\n\nRay bray(in Ray r, Camera c, float b) {\n  vec3 p = c.pos + normalize(cross(r.dir, vec3(1))) * b;\n  return Ray(p, normalize(r.org + r.dir * length(c.tgt - c.pos) - p), .0, .0);\n}\n\nHit trace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION || r.len > MAX_TRACE_DIST) break;\n  }\n  return Hit(_pos(r), r, s);\n}\n\nvec4 render(in Hit h){\n  if (h.ray.len > MAX_TRACE_DIST) return vec4(.8,.8,.8,h.ray.len);\n  return vec4(lighting(h), h.ray.len);\n}\n\nvec4 gamma(in vec4 i) {\n  return vec4(pow(i.xyz, GAMMA), i.w);\n}\n\n\n// Entry point ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  phase = iTime * bpm / 60. * P2;\n\n  Camera c = Camera(vec3(sin(phase/32.)*20., exp(cos(phase/64.)*1.2)*40., cos(phase/32.)*20.), vec3(0), .4, 1.73205081);\n  Ray    r = ray((fragCoord.xy * 2. - iResolution.xy) / iResolution.x, c);\n\n  vec4 col = render(trace(r));\n  col += render(trace(bray(r, c, LENS_BLUR)));\n  col += render(trace(bray(r, c, -LENS_BLUR)));\n  fragColor = gamma(col/3.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI2 6.28\n\nconst float bpm=144.;\n\n// envelope ----------\nfloat rr(float t, float r) {\n  return exp(-t*r);\n}\nfloat adsr(float t, vec4 e, float gt) {\n  return min(t/max(.00001,e.x),max(exp(-e.y*(t-e.x)),min(e.z,e.z*exp(-e.w*(t-gt)))));\n}\n\n\n// wave genelators ----------\nfloat noiz(float s){\n  return fract(sin(s*78.233)*43758.5453)*2.-1.;\n}\n\nfloat ssin(float t, float e){\n  return clamp(sin(t)*e,-1.,1.);\n}\n\nfloat ssaw(float t, float e){\n  return clamp((mod(t/PI2,1.)*2.-1.)*e,-1.,1.);\n}\n\nfloat n2f(float nn){\n  return pow(2.,((nn-69.)/12.))*440.*PI2;\n}\n\n\n// patterns ----------\n#define L(i,l) float x=99.9,y=15.0*float(i)/bpm,z=0.,w=0.,u=mod(t,y*float(l));\n#define D(s) if(u>float(s)*y){x=u-float(s)*y;}\n#define E(s,l) if(u>float(s)*y){x=u-float(s)*y;z=float(l);}\n\nvec2 bd(float t) {\n  L(1,4)D(0)\n  return vec2(0.4,0.4) * ssin(x*n2f(30.-x*5.),8.*rr(x,18.));\n}\n\nvec2 hh(float t) {\n  L(1,16)E(2,60)E(3,60)E(6,10)E(10,60)E(11,60)E(14,10)\n  return vec2(0.1,0.2) * noiz(x)*rr(x,z);\n}\n\nvec2 sn(float t) {\n  L(1,8)D(4)\n  return vec2(0.4,0.4) * noiz(x)*rr(x,12.);\n}\n\nvec2 rev(float t) {\n  L(16,1)D(0)\n  return vec2(0.4,x*0.4) * noiz(x)*adsr(x,vec4(2.2,5,0.2,5),2.2);\n}\nvec2 cym(float t) {\n  L(16,4)D(0)\n  return vec2(0.4,0.4) * noiz(x)*adsr(x,vec4(0,9,.5,3),.4);\n}\n\nvec2 bs(float t, float n) {\n  L(1,16)E(0,33)E(2,0)E(3,33)E(4,0)E(5,33)E(6,31)E(9,33)E(11,33)E(12,33)E(14,31)\n  float f=x*n2f(z+n);\n  return vec2(0.2,0.2) * (ssin(f+ssin(f*11.1,2.*rr(x,32.)),3.)*rr(x,6.));\n}\n      \nvec2 sq(float t) {\n  L(2,6)E(0,69)E(1,74)E(2,76)E(3,69)E(4,74)E(5,81)\n  float f=x*n2f(z);\n  return abs(vec2(cos(t*1.2),sin(t*1.2)))*0.25 * ssin(f+sin(f*7.)*rr(x,16.)*(2.+sin(t)*3.2),4.)*rr(x,10.);\n}\n\nvec2 pd(float t) {\n  L(2,4)E(0,69)\n  float f=x*n2f(z),f2=x*n2f(z+5.),f3=x*n2f(z+7.);\n  return vec2(.2,.2)*(ssaw(f,4.)+ssaw(f2,4.)+ssaw(f3,4.))*adsr(x,vec4(.04,16.,.2,4.),.3);\n}\n\n\n// sequence ---------\n#define S(s,m) if(float(s)*240./bpm<t){o=m;}\n#define LOOP(s,l) if(float(s)*240./bpm<t){t=mod(t-float(s)*240./bpm,float(l)*240./bpm);\n#define LEND() }\n\nvec2 mainSound( in int samp,float t){\n  vec2 o = vec2(0,0);\n  S( 0, bs(t,0.)+ pd(t) );\n  S( 4, bs(t,0.)+ bd(t) + hh(t) + pd(t) );\n  S( 8, bs(t,0.)+ bd(t) + sn(t) + hh(t) + pd(t) );\n  S(15, bs(t,0.)+ rev(t));\n  S(16, bs(t,5.)+ bd(t) + sn(t) + hh(t) + sq(t) + sq(t+75./bpm)*0.6 + cym(t));\n  LOOP(20,8)\n    S(0, bs(t,0.)+ bd(t) + sn(t) + hh(t) + sq(t) + sq(t+75./bpm)*0.6);\n    S(4, bs(t,5.)+ bd(t) + sn(t) + hh(t) + sq(t) + sq(t+75./bpm)*0.6);\n  LEND()\n  return o;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}