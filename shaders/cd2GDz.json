{
    "Shader": {
        "info": {
            "date": "1667474431",
            "description": "Using \"Fuzzy Signed Distance Fields\" over a perlin noise heightmap, one can easily generate highly detailed and natural looking erosion with branching rivers and cliffs!\nDiscovered by accident!\n\nRaymarch borrowed from https://www.shadertoy.com/view/MlGBD1",
            "flags": 32,
            "hasliked": 0,
            "id": "cd2GDz",
            "likes": 75,
            "name": "Large Mountains Erosion Terrain",
            "published": 3,
            "tags": [
                "procedural",
                "terrain",
                "distance",
                "field",
                "signed",
                "erosion"
            ],
            "usePreview": 1,
            "username": "Hatchling",
            "viewed": 1545
        },
        "renderpass": [
            {
                "code": "float maxHeight()\n{\n    return 500.0 / iChannelResolution[0].x;        \n}\n\nfloat precis()\n{\n    return 1.5 / iChannelResolution[0].x;        \n}//\n\n\nvec3 worldToTerrain(vec3 p)\n{\n    p.x /= iChannelResolution[0].x / iChannelResolution[0].y;\n    p.xz += 0.5;\n    p.y /= maxHeight();\n    return p;\n}\n\nvec3 terrainToWorld(vec3 p)\n{\n    p.y *= maxHeight();   \n    p.xz -= 0.5;\n    p.x *= iChannelResolution[0].x / iChannelResolution[0].y;\n    return p;\n}\n\nfloat terrain(vec2 p){\n\n    p.x /= iChannelResolution[0].x / iChannelResolution[0].y;\n    \n    p += 0.5;\n    \n\n    \n    if(clamp(p,0.0,1.0) != p) return 0.;\n    \n    vec4 t = texture(iChannel0, p);\n    return t.r / t.a * maxHeight();\n}\n\nvec2 calculate_curvature(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = precis();\n    float heightC = terrain(p.xz)*height_mod;\n    \n    vec3 posC = vec3(p.x, heightC, p.z);\n    vec3 posR = p + vec3(prec, 0.0,  0.0);\n    vec3 posL = p - vec3(prec, 0.0,  0.0);\n    vec3 posT = p + vec3( 0.0, 0.0, prec);\n    vec3 posB = p - vec3( 0.0, 0.0, prec);\n    \n    posR.y = terrain(posR.xz)*height_mod;\n    posL.y = terrain(posL.xz)*height_mod;\n    posT.y = terrain(posT.xz)*height_mod;\n    posB.y = terrain(posB.xz)*height_mod;\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    vec3 normal = normalize(cross(dx, dy));\n    \n    float curveX = -dot(posC + posC - posR - posL, normal);\n    float curveY = -dot(posC + posC - posT - posB, normal);\n    \n    return vec2(curveX, curveY) / prec;\n}\n\nvec3 calculate_normal(vec3 p)\n{    \n    float height_mod = 1.;\n    float prec = precis();\n    float heightC = terrain(p.xz)*height_mod;\n    \n    vec3 posC = vec3(p.x, heightC, p.z);\n    vec3 posR = p + vec3(prec, 0.0,  0.0);\n    vec3 posL = p - vec3(prec, 0.0,  0.0);\n    vec3 posT = p + vec3( 0.0, 0.0, prec);\n    vec3 posB = p - vec3( 0.0, 0.0, prec);\n    \n    posR.y = terrain(posR.xz)*height_mod;\n    posL.y = terrain(posL.xz)*height_mod;\n    posT.y = terrain(posT.xz)*height_mod;\n    posB.y = terrain(posB.xz)*height_mod;\n    \n    vec3 dx = posR - posL;\n    vec3 dy = posT - posB;\n    \n    return -normalize(cross(dx, dy));\n}\n\nbool pointTerrain(vec3 p){\n    return terrain(p.xz) >= p.y;\n}\n\nvec3 skybox(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    gradient *= gradient;\n    gradient *= gradient;\n   \n    gradient = 1.-gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient *= gradient;\n    gradient = 1.-gradient;\n    \n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    gradient = smoothstep(0., 1., gradient);\n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    \n    return color;\n}\n\nvec3 skyboxBlurry(vec3 dir)\n{\n    float gradient = dir.y * 0.5 + 0.5;\n    \n    \n    \n   \n    //gradient *= gradient;\n   ;\n    gradient = 1.-gradient;\n    gradient *= gradient * gradient;\n    gradient = 1.-gradient;\n    \n    \n    vec3 gradient3 = pow(vec3(gradient), vec3(8.0, 1.0, 1.0));\n    gradient3 = vec3(1.)-gradient3;\n    gradient3 = pow(gradient3, vec3(0.4, 0.5, 4.0));\n    gradient3 = vec3(1.)-gradient3;\n    \n    vec3 color = mix(vec3(0.99,0.99,0.99), vec3(0.01,0.02,0.2), gradient3) * 2.0;\n    \n    \n    return color;\n}\n\nvec3 castRayTerrain2(vec3 camPos, vec3 camDir){\n    bounds b;\n    b.mini = terrainToWorld(vec3(0));\n    b.maxi = terrainToWorld(vec3(1));\n    \n    vec3 near, far;\n    if(!rayIntersectBounds(b, camPos, camDir, near, far))\n    {\n        return skybox(camDir);\n    }\n    \n    vec3 p = near;\n    float minD = 0.0, maxD = 1.0;\n    bool hit = false;\n    for(float i=0.; i<=1.; i+=.005)\n    {\n        float j = i*i;\n    \tp = mix(near, far, j);\n        \n        maxD = j;\n        \n        \n        if(pointTerrain(p))\n        {\n            hit = true;\n            break;\n        }\n        \n        minD = j;\n    }\n    \n    if(!hit) return skybox(camDir);\n\n    maxD = (minD + maxD) * 0.5;\n    float stepSize = (maxD - minD) * 0.5;\n\n    for(int i = 0; i < 5; i++, stepSize *= 0.5)\n    {\n    \tp = mix(near, far, maxD);\n        if(!pointTerrain(p))\n        {\n            minD = maxD;\n            maxD += stepSize;\n        }\n        else\n        {\n            maxD -= stepSize;\n        }\n    }\n    \n    \n    vec3 normal = calculate_normal(p);\n    vec2 curve2 = calculate_curvature(p);\n    \n    vec2 posCurve2 = max(vec2(0), curve2);\n    vec2 negCurve2 = -min(vec2(0), curve2);\n    \n    float posCurve = posCurve2.x + posCurve2.y;\n    posCurve = posCurve / (0.2 + posCurve);\n    float negCurve = negCurve2.x + negCurve2.y;\n    negCurve = negCurve / (0.2 + negCurve);\n    float curve = (curve2.x + curve2.y);\n    curve = curve / (0.2 + abs(curve));\n    \n    p = vec3(p.x, terrain(p.xz), p.z);\n\n    vec3 lightDir = normalize(vec3(0, 3, 5));\n    vec3 lightColor = max(0.0,dot(normal, lightDir)) * vec3(1.0, 0.75, 0.5) * 2.0;\n    \n    vec3 ambientDir = vec3(0, 1, 0);\n    float ambient = dot(normal, ambientDir) * 0.5 + 0.5;\n    ambient *= ambient;\n    //ambient *= ambient;\n    //ambient *= ambient;\n    ambient *= curve * 0.5 + 0.5;\n    vec3 ambientColor = ambient * skyboxBlurry(normal);\n    \n    vec3 totalDiffuse = ambientColor + lightColor;\n\n    vec3 eyeDir = normalize(camPos-p);\n    vec3 reflec = reflect(-lightDir, normal);\n    float spec = max(0.0,dot(eyeDir, reflec));\n    spec = pow(spec*1.01, 100.);// * 10.;\n\n    vec3 albedo  = vec3(1.);\n    \n    float slopeFactor;\n    float heightFactor;\n    {\n        heightFactor = p.y / maxHeight();\n        \n        heightFactor = smoothstep(0., 1., heightFactor);        \n        heightFactor = smoothstep(0., 1., heightFactor);\n        \n        slopeFactor = abs(normal.y);\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        slopeFactor *= slopeFactor;\n        slopeFactor *= slopeFactor;\n        //slopeFactor *= slopeFactor;\n        slopeFactor = 1.-slopeFactor;\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        //slopeFactor = smoothstep(0., 1., slopeFactor);\n        \n        vec3 flatLow = vec3(0.1, 0.4, 0.05);\n        vec3 flatHigh = vec3(0.7, 0.7, 0.5);\n        \n        vec3 slopeLow = vec3(0.4, 0.7, 0.2);\n        vec3 slopeHigh = vec3(0.3, 0.2, 0.05);\n        \n        vec3 flatColor = mix(flatLow, flatHigh, heightFactor);\n        vec3 slopeColor = mix(slopeLow, slopeHigh, heightFactor);\n        \n        albedo = mix(slopeColor, flatColor, slopeFactor);\n    }\n    \n    albedo = mix(albedo, (albedo*1.0+vec3(0.75))*vec3(0.7,0.65,0.3), posCurve); \n    \n    // Add rivers.\n    float rivers;\n    {\n        rivers = max(0.,negCurve - posCurve);\n        \n        rivers = pow(rivers, pow(2., mix(0.5, -0.7, slopeFactor) + mix(-0.7, 0.7, heightFactor)));   \n\n        //rivers = pow(rivers, heightFactor + 1.0);   \n        //rivers = pow(rivers, heightFactor*3.+0.5);         \n        \n        rivers = smoothstep(0., 1., rivers);\n        rivers = smoothstep(0., 1., rivers);\n        \n        //rivers = 1.-rivers;\n        //rivers *= rivers;\n        //rivers = 1.-rivers;\n        \n        albedo = mix(albedo, vec3(0.1,0.2,0.5), rivers); \n    }\n\n    albedo *= albedo;\n\n    //albedo = mix(albedo, curve > 0.0 ? vec3(1,0.7,0.3) : vec3(0.3,0.7,1), vec3(abs(curve))); \n\n    float specMult = 0.0;\n    specMult = mix(specMult, 0.5, posCurve);//length(color)*length(color)*0.2;\n    specMult = mix(specMult, 1.5, rivers);//length(color)*length(color)*0.2;\n\n    vec3 color = albedo*totalDiffuse + lightColor*spec*specMult;\n    \n    float fogDist = dot(p - camPos, p - camPos);\n    \n    color = mix(skybox(camDir), color, pow(vec3(0.98), fogDist * vec3(0.1,0.4,2.))); \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camRay = normalize(vec3((fragCoord - iResolution.xy * 0.5) / iResolution.yy, 1));\n    vec3 camPos = vec3(0.0, maxHeight() * 1.0, -1.0);\n    \n    vec3 lookDir = vec3(0, maxHeight() * 0.0, 0) - camPos;\n    \n    quaternion pan = FromAngleAxis(vec3(0, iTime * 0.125, 0));\n    quaternion tilt = FromToRotation(vec3(0,0,1), lookDir);\n    \n    camPos = mul(pan, camPos);\n    //camRay = mul(, camRay);\n    camRay = mul(mul(pan, tilt), camRay);\n    \n    vec3 col = castRayTerrain2(camPos, camRay);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    col = col / sqrt(0.5+col*col);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float getOccupancy(vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nbool isIn(vec2 uv, float threshold)\n{\n\treturn getOccupancy(uv) > threshold;\n}\n\nfloat squaredDistanceBetween(vec2 uv1, vec2 uv2)\n{\n    vec2 difference = uv1 - uv2;\n    return dot(difference, difference);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy) / iResolution.xy;\n    vec4 oldColor = texture(iChannel2, uv);\n    \n    // This block of code was to make the terrain\n    // \"grow\" instead of expose the poorly resolved\n    // initial state with few samples.\n    if(oldColor.a == 0. || iMouse.z > 0.)\n    {\n        oldColor.rgb = vec3(25.);\n        oldColor.a = 50.;\n    }\n    \n    // Stop after enough iterations.\n    if(oldColor.a > 512.)\n    {\n        fragColor = oldColor;\n        return;\n    }\n        \n    \n    //fragColor = vec4(vec3(getOccupancy(uv)), 1);\n    //return;\n    \n    // Compute the noise.\n    vec3 noise;\n    {\n        \n        // Cycle the noise.\n        // We do the cycling FIRST to prevent\n        // loss of precision that might\n        // round away the noise values.\n        //   - Use the golden ratio as it should land\n        //     on all fractional values eventually.\n        noise = vec3(iFrame, iFrame+1, iFrame+2);\n        noise *= 1.618033;\n        noise -= floor(noise);\n    \n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n        // (Disable to prevent gradient noise).\n        //vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        //noise += texture(iChannel1, noiseUV).r;\n        //noise -= floor(noise);\n        \n        noise.xy -= 0.5f;\n    }\n    \n    // Compare with and without fuzziness.\n    //if(uv.x > 0.5)\n    //    noise.z = 0.5;\n       \n    vec2 samplingCenter = fragCoord + noise.xy;\n    vec2 samplingCenterUV = samplingCenter / iResolution.xy;\n    \n    const float halfRange = 32.0;\n    const int iRange = int(halfRange);\n    const float maxSqrDist = halfRange*halfRange;\n    vec2 startPosition = samplingCenter;\n    \n    bool fragIsIn = isIn(samplingCenterUV, noise.z);\n    float squaredDistanceToEdge = maxSqrDist*2.;\n    \n    for(int dx=-iRange; dx <= iRange; dx++)\n    {\n        for(int dy=-iRange; dy <= iRange; dy++)\n        {\n            vec2 delta = vec2(dx, dy);\n            vec2 circlizer = abs(delta);\n            circlizer /= max(circlizer.x, circlizer.y);\n            delta /= length(circlizer);\n            vec2 scanPosition = startPosition + vec2(dx, dy);\n            float scanDistance = squaredDistanceBetween(samplingCenter, scanPosition);\n                \n            //if(scanDistance > maxSqrDist)\n            //    continue;\n                \n            bool scanIsIn = isIn(scanPosition / iResolution.xy, noise.z);\n            if (scanIsIn != fragIsIn)\n            {\n                if (scanDistance < squaredDistanceToEdge)\n                    squaredDistanceToEdge = scanDistance;\n            }\n        }\n    }\n    \n    float distanceToEdge = sqrt(squaredDistanceToEdge);\n\n    if (fragIsIn)\n    {\n        // We add 1.0 here since the edge is on the inside\n        // of the boundary.\n        distanceToEdge = 1.0-distanceToEdge;\n    }\n        \n    distanceToEdge /= halfRange * 2.;\n        \n    distanceToEdge = 0.5 - distanceToEdge;\n    \n    distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    //distanceToEdge = smoothstep(0., 1., distanceToEdge);\n    \n    fragColor = vec4(distanceToEdge, distanceToEdge, distanceToEdge, 1.0);\n\n    \n   \n    fragColor += oldColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float perlin(vec2 uv)\n{\nuv += vec2(3.1982,4.73234);\n    uv /= 1.0;\n    vec2 occ = vec2(0);\n    float a = 1.0;\n    for(int i = 0; i < 10; i++)\n    {\n        occ += vec2(texture(iChannel0, uv).r, 1) * a;\n        uv *= 0.5;\n        a *= 2.0;\n    }\n\n    float v = occ.x / occ.y;\n    \n    v = v * 2.0 - 1.0;\n    \n    v = tanh(v * 2.0);\n    \n    v = v * 0.5 + 0.5;\n    \n    v *= v;\n    \n    return v;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iChannelResolution[0].xy;\n    float height = perlin(uv);\n    \n    fragColor = vec4(height, height, height, 1.);\n    \n    \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 0.5+0.5*(130.0 * dot(m, g));\n}\n\nfloat snoise(float p){\n\treturn snoise(vec2(p,0.));\n}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n#define NUM_OCTAVES 16\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat turbulent(vec2 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn (v+1.)/2.;\n}\n\nfloat turbulent(vec3 x) {\n\tfloat v = fbm(x);\n    return 1.-abs((v-0.5)*2.);\n}\n\nfloat pattern( in vec2 p )\n  {\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n\n    return fbm( p + 4.0*q );\n  }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint radius = 1;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}