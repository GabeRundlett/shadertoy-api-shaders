{
    "Shader": {
        "info": {
            "date": "1519432104",
            "description": "https://soundcloud.com/super_noise/our_kingdoms",
            "flags": 64,
            "hasliked": 0,
            "id": "XtlfWX",
            "likes": 24,
            "name": "â™« SuperNoise",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "glow"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1066
        },
        "renderpass": [
            {
                "code": "\n\n#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t (iChannelTime[0])\n\n#define FOV 70.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat hash(vec2 x){\n\treturn fract(572.612*sin(1413.7613*sin(t*41.12)+1175.2126*fract(dot(x, 1114.41256*vec2(56.0,1.37)))));\n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n\nvec3 lightColor = (vec3(0.)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\n// from Mercury's sdf framework.\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\ngeometry DE(vec3 p, vec3 modifier) {\n \tconst float scale = 6.5;\n\tconst float offset = 15.0;\n    const int FRACTALITERATIONS = 18;\n    vec3 op = p;\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        p = abs(p);\n        //pR(p.xz, -.03);\n        p.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\t\tp.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\n\t\tp.y -= 2.;\n        p.z += 3.;\n        p.x += 2. ;//+ cos(-op.y * .08) * 10. + 5.;\n\n        p.xyz = scale * p.xyz - offset*(scale-1.0) * modifier.xyz;\n\t}\n    \n \tgeometry obj;\n    obj.dist = length(p.xz) * (pow(scale, -float(FRACTALITERATIONS))) - 0.05; \n\tobj.space = p;\n    return obj;\n}\n\ngeometry map(vec3 p) {\n    vec3 bp = p;\n    vec3 floor_p = p;\n    \n    p = p.xzy;\n\tp.z = mod(p.z, 150.) - 75.;\n    \n    pR(p.xy, ceil(p.z / 80.) * (1. + sin(t / 2.)));\n    pR(p.yx, ceil(p.z / 60.));\n    \n    float pM = pModPolar(p.xy, 6.);\n    \n    vec3 sp = p;\n    \n\tpMirrorOctant(p.zy, vec2(2., -30.));\n    pMirrorOctant(p.xy, vec2(-30., 20.));\n    \n    p.x += cos(p.z / 4. + t) ;\n    p.z -= 15. + p.y - p.x + t;\n    p.yx += - sin(t / 10. + p.y / 20.) * 1.;\n\t\n    geometry obj, obj2, obj3;\n    \n    obj = DE(p, vec3(3.9 ,.1, .5));\n    obj.material = vec2(1., 0.);\n    \n    obj2.dist = length(bp.xz) - .5;\n    obj2.material = vec2(5., 0.);\n    \n    obj = geoU(obj, obj2);\n    \n    \n    pMod1(bp.y, 150.);\n    //obj = obj3;\n    obj3 = obj2;\n    obj3.dist = max(fBox(bp, vec3(40., 1., 40.)), -fBox(bp, vec3(38., 4., 38.)));\n    \n    obj = geoU(obj, obj3);\n    return obj;\n}\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 300;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t1 = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 180.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t1 + o);\n\t\t\n        minDist = min(minDist, mp.dist * .8);\n        mp.glow = pow(1. / minDist, .8);\n        \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else { \n        stepLength = signedRadius * omega * .3;\n        }\n        previousRadius = radius;\n        float error = radius / t1;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t1;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t1 > t_max) break;\n        t1 += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    return mp;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 18;\n    vec3 rd = (lp - ro);\n\n    float shade = 1.;\n    float dist = 4.0;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.05), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.3, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, inout geometry obj) {\n    vec3 col = vec3(1.0);\n    obj.glow = 0.;\n        \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, inout geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; \n    float lDist = max(length(ld / 2.), 0.001);\n    ld /= lDist; \n\n    float diff = max(dot(sn, ld), 1.);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), .2);\n    vec3 objCol = getObjectColor(sp, sn, obj);\n    sceneCol += (objCol * (diff + .15) + spec * .5 );\n\n    return sceneCol;\n}\n\nvec4 pixelColor(in vec2 fragCoord) {\n    vec4 fragColor = vec4(0.);\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    vol = texture(iChannel0, vec2(.8, .25)).r;\n    vol = pow(vol * 2., 10.);\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .4) * 166.0, \n        ck = cos(-t2 * .4) * 162.0,\n        \n        mat = 0.;\n    \n    uv.x += pow(\n        ceil(hash(uv) * floor(vol) / 10. * 14.) / 12. * abs(ceil(2. * uv.y + hash(uv.yx))),\n        4.\n    );\n    \n    if (iChannelTime[0] > 45. && vol > 0.9 && hash(uv) > .6) uv = ceil(uv * 32.) / (32. + hash(uv)) ;\n\n    vec3 \n        vuv = vec3(0., 1., 0.),\n    \tca = vec3(ck, 0., sk);\n    \n    vec3 cameraPos = vec3(30., 0. - t * 20., -20.);\n    \n\tfloat focus = -78. - uv.x * 50. + 20.;\n    \n    vec3 ro = cameraPos;\n    \n    vec3\n        vrp =  vec3(-30., 53. + ck / 5., 4.+ ck / 20.) + ro, \n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n                  \n    rd = normalize(rd);\n\n\tcameraPos -= rd * focus;\n    ro = cameraPos;\n         \n    vec3 sceneColor = vec3(0.);\n \tvec3 light ;\n\n    geometry tr = trace(ro, rd); \n    \n    tr.hit = ro + rd * tr.dist;\n    \n    tr.sn = getNormal(tr.hit);\t\n\tlight = tr.hit;\n    light.xy *= 0.;    \n    \n    if (tr.dist < FAR) { \n        float sh = softShadow(tr.hit, ro + light, 1.2);\n\n        float \n            ao = getAO(tr.hit, tr.sn, 1.9);\n        \n        vec3 col = (doColor(tr.hit, rd, tr.sn, light, tr) * .5);\n        sceneColor = col;\n\n        sceneColor *= ao; \n        sceneColor *= sh;\n    } else {\n        sceneColor = vec3(.06) * length(rd.xy);\n        sceneColor = mix(\n            sceneColor, \n            saturate(vec3(.5 * vol, sk, ck) * cos(uv.y * 2.) * 10.),\n            abs(float(tr.glow) / 4. * vol)\n        );\n    }\n    \n    sceneColor += float(tr.glow) / 10. * vec3(0. , 0., 1.);\n    fragColor = vec4(clamp(sceneColor * (1.5 - length(uv) / .5), 0.0, 1.0), 1.0);\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pixelColor(fragCoord);\n    fragColor = pow(fragColor, 1./ vec4(2.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 13588,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/super_noise/our_kingdoms"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}