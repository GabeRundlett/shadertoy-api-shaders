{
    "Shader": {
        "info": {
            "date": "1506606526",
            "description": "Animating some flow lines on a square Truchet pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtfyDX",
            "likes": 86,
            "name": "Square Truchet Flow",
            "published": 3,
            "tags": [
                "animation",
                "square",
                "truchet",
                "flow",
                "pattern",
                "polar",
                "tile"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2196
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSquare Truchet Flow\n\t-------------------\n\n\tAfter looking at Fabrice's \"Smallest Truchet\" example then reading one of \n\tIapafoto's comments regarding Truchet animation, I searched Shadertoy for a \n\tsimple Truchet flow-lines demonstration, but the only one I could find was a\n\tflowing hexagonal Truchet shader by \"klk,\" and no square Truchet ones at all, \n\twhich surprised me, since they're kind of interesting looking and easy to produce.\n\n\tWith that in mind, I dusted off some old code and put one together in less than \n\tfive minutes... then proceeded to waste way too much time prettying it up when I \n\tshould've been doing other things. :)\n\n\tHere's a brief explanation of the process: Partition into a grid, render the tile,\n\tuse the grid coordinates to obtain the angle using the standard \"atan(p.y, p.x)\"\n\tformula, then use that angle and the time to animate something. At that point you'll\n\tnotice that the flowing objects cross the boundaries in opposing directions. You\n\tcan correct that by reversing the flow direction for all neighboring tiles, which\n\tmeans in a checkerboard fashion - You perform a similar step when rendering a grid\n\tof repeat rotating gears. There's a little more to it, but that's the basic idea.\n\n\tBy the way, I almost rendered some gears on all the corners of the square cells,\n\tbut decided it would complicate the example too much. Besides, I figured it'd be the\n\tkind of thing that someone like Dr2 would prefer to do anyway. :D\n\n\tAnyway, I'm going to get back to the example I'm supposed to be working on. Later,\n\tI'll have yet another go at animating a 3D Truchet. The comments are very rushed, \n\tso I'll get in and tidy those up later too.\n\t\n\tIf you take the comments away, there's not a great deal of code here, but just in \n\tcase there's too much window dressing, I've put a much simpler example together \n\tusing a smaller code imprint here:\n\n\t// A minimal implementation to show the main concept - for anyone who doesn't\n\t// want to sift through all the aesthetic related code in this one. :)\n\tMinimal Animated Truchet - Shane\n\thttps://www.shadertoy.com/view/XtfyDf\n\n\tOther examples:\n\n\t// Hexagonal Truchet flow. I'll do one of these later.\n\tHexlicity - klk\n\thttps://www.shadertoy.com/view/lt2SzG\n\n\t// Fabrice has many Truchet examples. This one sidetracked me into making the \n\t// example you're currently viewing. :D\n\tsmallest truchet - FabriceNeyret2\n\thttps://www.shadertoy.com/view/XllyWS\n\n*/\n\n\n#define SCROLL\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\nfloat df(vec2 p, float tF, float s){\n    \n    return max(abs(p.x)*.866025 + tF*p.y*.5, -tF*p.y) - s;\n    \n}\n\nfloat df2(float a, float s){ return abs(a) - s; }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    float res = clamp(iResolution.y, 200., 600.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Some minor fish-eye distortion to break up the monotony of the square grid\n    // lines, and to give it some subtle - albeit fake - depth.\n    uv *= 1. + dot(uv, uv)*.05;\n    \n    // Wavy screen coordinate distortion... Probably a bit much for this example.\n    //uv -= sin(uv*3.14159/2. - cos(uv.yx*3.14159/4. + iTime)*3.14159)*.01;\n    \n    // Right to left scrolling. I wanted this in to show the continuity of the pattern,\n    // but kind of interferes with the flow effect... Anyway, it's optional.\n    #ifdef SCROLL\n    float tm = iTime/32.;\n    // Slowing things down at larger resolutions - Based on Flockaroo's observation.\n    if(iResolution.x>800.) tm *= 1.5;\n    uv += vec2(tm, 7.);\n    #endif\n    \n    \n    // TRUCHET PATTERN\n    //\n    // Scaling the slightly distorted screen coordinates.\n    vec2 p = uv*5.;\n    \n\t// Cell ID. Used to generate unique random numbers for each grid cell.\n    vec2 ip = floor(p);\n    \n    // Grid partitioning. Converting to unit cell coordinates centered at the origin.\n    p -= ip + .5; // Equivalent to \"p = fract(p) - .5;.\"\n\n    \n    // Flow direction: The flow direction must be reversed every time you enter a \n    // neighboring tile. What this means is that you flip the direction for half the tiles \n    // in a checkerboard pattern. The line below is the way to do that... If you're as slow \n    // as I am, knowing the aforementioned will save you a lot of wasted time. :D\n    //\n    // I figured this out for myself ages ago, but it took me \"way\" too long. Set the \n    // direction variable, \"dir,\" to \"1.\" then note that every single neighboring tile has \n    // its direction reversed. Yes, it's obvious, and anyone who's rendered repeat animated \n    // gears would know this, but like I said, I'm a bit slow on the uptake. :D\n    // \n    float dir = fract(dot(ip, vec2(.5)))>.25 ? -1. : 1.; \n    // Another - more intuitive - way to write the above:\n    //float dir = mod(ip.x + ip.y, 2.)>.5 ? -1. : 1.; \n    \n    // A unique random number assigned to each grid tile.\n    float rnd = hash21(ip);\n    \n    \n    // Vertical tile flipping. If the random ID for the tile is more than the threshold,\n    // reverse the cell's Y coordinate, which effectively vertically flips the tile. Comment\n    // the line out and all tiles will have the same orientation, resulting in a pretty\n    // lacklustre pattern.\n    p.y *= (rnd >.5)? -1. : 1.;\n    \n    \n\t\n    // This line requires a bit of an explanation: The standard 2D Truchet tile consists of\n    // two arcs centered on opposite diagonal corners. Each are mirror reflections of the\n    // other about the diagonal line cutting the square grid cell. The following line of\n    // code is just a way to repeat space about the diagonal. What this means is that you \n    // can draw just one arc (corner torus) and the one in the other diagaonal corner will\n    // be rendered too. The easiest way to see this is to comment the line out and you'll\n    // see half the pattern disappear.\n    p = p.x>-p.y ? p : -p; \n    // \"p *= sign(p.x + p.y)\" would be nice, but it can sometimes return zero.\n    \n    \n\n    // Storage vector. \n    vec2 q;\n    \n    const float th = .3; // Arc thickness.\n    \n    // The arc, centered in the top right of the grid cell - or the bottom right if flipped.\n    float d = length(p - .5) - .5 - th/2.;\n    d = max(d, -th - d); // Remove the inner circles to produce an arc of thickness \"th.\"\n    \n    // The dashed grid lines.\n    float bord = max(abs(p.x), abs(p.y)) - .49;\n    q = abs(mod(p, 1./8.) - .5/8.);\n    float lines = (min(q.x, q.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    // Manipulating the resultant distant field for some cheap edges.\n    float ed = max(d -.035, -d);\n    ed = smoothstep(0., .0005/max(ed, .0005), ed);\n    \n    \n    // Used for the Truchet pattern border shadows. Produced through trial and error, so \n    // there's probably a cleaner way to write it.\n    float sh = smoothstep(0., .075, d - .01) - smoothstep(0., .3, d+.05);\n    \n    \n    \n    // Rendering the moving arrows and border dashes.\n    \n    // Moving the grid coordinates to the corner, or the center of the arc - in order to\n    // determine the angle of the pixel subtended to the arc center.\n    q = p - .5; \n    \n    // The actual animation. You perform that before polar partitioning.\n    q = r2(iTime*dir)*q;\n    \n    // Using the angle to convert into polar coordinates in order to partition into cells \n    // (8, in this case) around the arc, then rendering an object in each.\n    const float aNum = 8.;\n    float a = atan(q.y, q.x); // Pixel angle.\n    float ia = floor(a/6.283*aNum) + .5; // Obtaining the cell centers.\n    \n    q = r2(ia*6.283/aNum)*q; // Converting to polar coordinates: p.x = radius, p.y = angle.\n    q.x -= .5; // Moving the radial coordinate out to the radius of the arc.\n    \n    // Rendering the arrows - I could have made life easy for myself, rendered a nice \n    // symmetrical dot and left it at that, but I thought arrows would look cooler. It\n    // was a bit fidly, but I managed. :)\n    //\n    // The arrow line - I had to use the angle coordinate itself, and finally figured out\n    // that I'd need to used the truchet lines themselves to give the arrow lines curvature...\n    // Yeah, I should've rendered animated dots. :D\n    float d2 = df2(mod(a - .15*dir, 6.283/aNum) - .5*6.283/aNum, .2);\n    d2 = max(d + .14, -d2); // Control the arrow line width with the Truchet distance field.\n    \n    // Arrow head, or a triangle if you want to get technical. :) The triangles need to be\n    // flipped on neighboring cells. I figured that out via observation.\n    d2 = min(d2, df(q, dir, .025)); \n    \n    // Refining the 2D distance field - Analogous to honing in on the surface edges.\n    d2 = smoothstep(0., .015, d2); \n    \n\n    // Border dashes - More lines shaped by the Truchet borders.\n    float d4 = df2(mod(a - .15*dir, 6.283/aNum/3.) - .5*6.283/aNum/3., .03);\n    d4 = max(abs(abs(d) + .09/3.) - .09, -d4); // Control arrow width.\n    d4 = max(d4, d + .05);\n    // Refining the distance field - Analogous to honing in on the surface edges.\n    d4 = smoothstep(0., .015, d4);\n    \n\n    \n    // Refining the distance field - Analogous to honing in on the surface edges. I performed \n    // this down here because I think \"d\" was needed above somewhere to shape some lines.\n    d = smoothstep(0., .0005/max(d, .0005), d);\n    \n    \n    // COMBINING ALL THE LAYERS.\n\t//\n    // Mix the background in with the border first. For anyone who isn't aware, if you're mixing\n    // in a few layers, you start with the bottom layer first, then progress through to the\n    // front layer like so:\n    //\n    // col = mix(layer1, layer2, maskLayer1*alpha1);\n    // col = mix(col, layer3, maskLayer2*alpha2)\n    // col = mix(col, layer4, maskLayer3*alpha3)\n    // etc.\n    //\n    // The background - Just some subtle blending between redish colors and some randomized\n    // looking hatching. It's a design cliche, but it works. :)\n    float blend = dot(sin(uv*3.14159/8. - cos(uv.yx*3.14159/4.)*3.14159), vec2(.25)) + .5;\n    vec3 bG = mix(vec3(1.1, .05, .08)*1.1, vec3(.9, .1, 0)*1.1, length(p)*blend);\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((uv.x - uv.y)*3.14159*160.)*2. + .5, 0., 1.); // Diagonal lines.\n    float hRnd = hash21(floor(uv*240.));\n    if(hRnd>.66) hatch = hRnd; // Slight, randomization of the diagonal lines.  \n    bG *= hatch*.25 + .75; // Combining the colorful gradient background with the lines.\n    \n    // Mix the background with the border overlay. Note the \".8\" value for transparency.\n    vec3 col = mix(bG, vec3(0), bord*.8);\n\n    // Back shadow.\n    col = mix(col, vec3(.1, .02, .04), sh*.85);\n    \n    // Truchet overlay.\n    vec3 tCol = mix(vec3(1.2), vec3(.7, .75, .8), cos(a*2.*dir)*.5 + .5);\n    // \"mix(tCol, col, d)\" is the same, and more concise, but I wanted to show order.\n    col = mix(col, tCol, 1. - d); \n    \n    \n    // Adding in the edging.\n    col = mix(col, vec3(.05, 0, 0), 1. - ed);\n    \n    \n    // Mix in the arrows.\n    col = mix(col, vec3(.5, .05, .05), (1. - d2)*.95);\n    \n\n    // Dashed borders beside the arrows.\n    col = mix(col, vec3(0), (1. - d4)*.75);\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    col = mix(pow(min(vec3(1.5, 1, 1).zyx*col, 1.), vec3(1, 3, 16).zyx), col, \n             pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));    \n    \n    \n    \n    // Screen color.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}