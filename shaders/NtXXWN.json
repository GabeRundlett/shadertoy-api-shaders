{
    "Shader": {
        "info": {
            "date": "1625670952",
            "description": "Mandelbrot and Julia sets\n\nClick and drag in the window to see the Julia set.",
            "flags": 0,
            "hasliked": 0,
            "id": "NtXXWN",
            "likes": 4,
            "name": "Mandelbrot 9002",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "johannesCmayer",
            "viewed": 305
        },
        "renderpass": [
            {
                "code": "//#define animateIterations\n//#define zoom\n//#define animateColor\n//#define SHOW_ID\n#define PI 3.14159265359\n\nfloat maxIterationsC = 100.;\nfloat minIterationsC = 10.;\n\nvec2 offset = vec2(-30., 0.);\n\nstruct Coordinates\n{\n    float real;\n    float imagenary;\n};\n    \nstruct Frac_Return_Val\n{\n\tfloat iterations;\n    float real;\n    float imaginary;\n};\n    \nFrac_Return_Val MandelbrotFunc(float maxIterations, Coordinates coordinates)\n{\n    float real;\n    float imaginary;\n    float c_real;\n    float c_imaginary;\n    \n    //Mandelbrot\n    real = 0.;\n    imaginary = 0.;\n    c_real = coordinates.real;\n    c_imaginary = coordinates.imagenary;\n    \n    //Julia\n    if (iMouse.z > 0.)\n    {\n        real = coordinates.real;\n        imaginary = coordinates.imagenary;\n        c_real = (iMouse.x - iResolution.x / 2.) / iResolution.x * 4.;\n        c_imaginary = (iMouse.y - iResolution.y / 2.) / iResolution.y * 4.;\n    }\n    \n    //Julia Mandel\n    /*\n    real = coordinates.real;\n    imaginary = coordinates.imagenary;\n    c_real = coordinates.real;\n    c_imaginary = coordinates.imagenary;\n    */\n    \n    float iterations = 0.;    \n    \n   \tfor (float i = 0.; i < maxIterations; i++)\n    {\n        iterations++;\n                        \n        if (pow(real, 2.) + pow(imaginary, 2.) > 4.) \n        {\n            Frac_Return_Val r_Val;\n    \t\tr_Val.iterations = iterations;\n    \t\tr_Val.real = real;\n    \t\tr_Val.imaginary = imaginary;\n                \n            return r_Val;\n        }              \n               \n        float temp = real;\n        real = pow(real, 2.) - pow(imaginary, 2.) + c_real;\n        imaginary = 2. * temp * imaginary + c_imaginary;\n    } \n    \n    Frac_Return_Val r_Val;\n    r_Val.iterations = iterations;\n    r_Val.real = real;\n    r_Val.imaginary = imaginary;\n    \n    return r_Val;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\n/*\nvec4 id_color()\n{\n    float modulus = sqrt(pow(coordinates.real, 2.) + pow(coordinates.imagenary, 2.));\n    float a = (atan(coordinates.imagenary, coordinates.real)+2.*PI) / (2.*PI);\n    color = vec4(a,0.,0.,0);\n    float mod_2 = 2./PI*atan(modulus* 10.);\n    \n    color = vec4(hsv2rgb(vec3(a, 1., mod_2)), 1.);\n    //color = vec4(a, 0., 0., 1.);\n    float b = atan(1.,0.);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef animateIterations\n    float maxIterations = maxIterationsC * abs(sin(iTime)) + minIterationsC;    \n    #else\n    float maxIterations = maxIterationsC;\n    #endif\n        \n    Coordinates coordinates;\n  \n    #ifdef constantCoordinate\n    coordinates.real = 1. / 100.;\n    coordinates.imagenary = 1. / 100.;\n    #else\n    coordinates.real = (fragCoord.x - iResolution.x / 2. + offset.x) / iResolution.y * 3.;\n    coordinates.imagenary = (fragCoord.y - iResolution.y / 2. + offset.y) / iResolution.y * 3.;\n    #endif\n    \n    #ifdef zoom\n    coordinates.real /= (sin(iTime * 0.1) * 1000.);\n    coordinates.imagenary /= (sin(iTime * 0.1) * 1000.);\n    #endif\n    \n    Frac_Return_Val r_Val = MandelbrotFunc(maxIterations, coordinates);\n         \n    vec4 color;\n    \n    if (r_Val.iterations >= maxIterations) {\n        float modulus = sqrt(pow(r_Val.real, 2.) + pow(r_Val.imaginary, 2.));\n        float a = (atan(r_Val.imaginary, r_Val.real) + 2.*PI) / (2.*PI);\n        float mod_2 = 2./PI*atan(modulus* 10.);\n        color = vec4(hsv2rgb(vec3(a, 1., mod_2)), 1.);\n    }\n    else {\n    \tcolor = vec4(r_Val.iterations / 64., r_Val.iterations / 128., r_Val.iterations / 32., 1.);\n        //color = vec4(0,0,0,0);\n    }\n    \n    #ifdef SHOW_ID\n    float modulus = sqrt(pow(coordinates.real, 2.) + pow(coordinates.imagenary, 2.));\n    float a = (atan(coordinates.imagenary, coordinates.real)+2.*PI) / (2.*PI);\n    float mod_2 = 2./PI*atan(modulus* 10.);\n    color = vec4(hsv2rgb(vec3(a, 1., mod_2)), 1.);\n    #endif\n    \n    #ifdef animateColor\n    float st = abs(sin(iTime)) * 2. + 1.;\n    color *= vec4(1. * st, 1. * st , 1. * st , 1.);\n    #endif\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}