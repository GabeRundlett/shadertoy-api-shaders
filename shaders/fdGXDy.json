{
    "Shader": {
        "info": {
            "date": "1635189611",
            "description": "demonstrating closed form integral for color interpolated fog on an animated 3-simplex",
            "flags": 0,
            "hasliked": 0,
            "id": "fdGXDy",
            "likes": 60,
            "name": "3-Simplex Fog",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "intersection",
                "tetrahedron"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1277
        },
        "renderpass": [
            {
                "code": "#define DEBUG_LIGHT 0\n#define DEBUG_NORMAL 0\n\n// calculates the definite line integral of alphablending two colors through a fog volume\n// T is the logarithmic transmittance (0 .. -inf)\n// d is the distance of the ray\n// x is the end of the integral (0..1); pass 1 here if not sure\n// returns color mixing factors and alpha\nvec3 color_fog_mix_coeffs(float T, float d, float x) {\n    float Td = T*d; // scale transmittance by ray length\n    float acc_alpha = exp(Td*x); // occlusion accumulated along integral    \n    // integrated alpha\n    float w = 1.0 - acc_alpha;\n    // integrated color\n    float v = x * acc_alpha / (acc_alpha - 1.0) - 1.0 / Td;\n    float u = 1.0 - v;\n    return vec3(u, v, w);\n}\n\n// compute the barycentric transform matrix\nmat3 compute_bary_transform(vec3 p[4]) {\n    vec3 e[6];\n    e[0] = p[2] - p[1];\n    e[1] = p[0] - p[2];\n    e[2] = p[1] - p[0];\n    e[3] = p[1] - p[3];\n    e[4] = p[2] - p[3];\n    e[5] = p[0] - p[3];\n    mat3 m = mat3(\n    \tcross(e[0], e[3]),\n    \tcross(e[1], e[4]),\n    \tcross(e[2], e[5]));\n    float invdet = 1.0/dot(m[0], e[1]);\n    // premultiply the plane orthogonals by the inverse determinant\n    return m * invdet;\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec4 to_bary(vec3 p3, mat3 m, vec3 t) {\n    // weights are scaled distance of point to individual planes\n    vec3 w = (t - p3) * m;\n    float ww = 1.0 - w.x - w.y - w.z;\n    return vec4(w, ww);    \n}\n\nvec3 from_bary(vec3 p[4], vec4 w) {\n\treturn p[0] * w.x + p[1] * w.y + p[2] * w.z + p[3] * w.w;\n}\n\nvec3 normal_from_bary(mat3 m, vec4 w) {\n    return normalize(m * (w.w - w.xyz));\n}\n\nstruct Hit {\n    // ray scalar\n    float t;\n    // barycenter\n    vec4 b;\n    // normal\n    vec3 n;\n};\n\n// return normal of nearest plane in barycentric coordinates\nvec4 select_plane_normal(vec4 b) {\n    float lc = min(min(b.x, b.y), min(b.z, b.w));\n    return step(b, vec4(lc));\n}\n\n// return the intersection of ray and tetrahedron\n// as well as the barycentric coordinates and normals of the hit points\nbool iSimplex3(vec3 p[4], vec3 ro, vec3 rd, \n\tout Hit near, out Hit far) {\n    \n    mat3 m = compute_bary_transform(p);\n    \n    // convert ray endpoints to barycentric basis\n    vec4 r0 = to_bary(p[3], m, ro);\n    vec4 r1 = to_bary(p[3], m, ro + rd);\n\n    // build barycentric ray direction from endpoints\n    vec4 brd = r1 - r0;\n    \n    // compute ray scalars for each plane\n    vec4 t = -r0/brd;\n    \n    // valid since GL 4.1\n    near.t = -1.0 / 0.0;\n    far.t = 1.0 / 0.0;\n    \n#if 0\n    for (int i = 0; i < 4; ++i) {\n        // equivalent to checking dot product of ray dir and plane normal\n        if (brd[i] < 0.0) {\n            far.t = min(far.t, t[i]);\n        } else {\n            near.t = max(near.t, t[i]);\n        }\n    }\n#else\n    // loopless, branchless alternative\n    // equivalent to checking dot product of ray dir and plane normal    \n    bvec4 comp = lessThan(brd, vec4(0.0));\n    vec4 far4 = mix(vec4(far.t), t, comp);\n    vec4 near4 = mix(t, vec4(near.t), comp);\n    far.t = min(min(far4.x,far4.y),min(far4.z,far4.w));\n    near.t = max(max(near4.x,near4.y),max(near4.z,near4.w));\n#endif\n    \n    if ((far.t <= 0.0) || (far.t <= near.t))\n        return false;\n    near.b = r0 + brd * near.t;\n    far.b = r0 + brd * far.t;\n\n    vec4 n0 = select_plane_normal(near.b);\n    vec4 n1 = select_plane_normal(far.b);\n    near.n = normal_from_bary(m, n0);\n    far.n = normal_from_bary(m, n1);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = iTime * 0.1;\n    float d = 2.5;\n\tcamPos = vec3(d*sin(an),1.0,d*cos(an));\n    camTar = vec3(0.0,-0.3,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 feet_curve(float t) {\n    float subt = mod(t, 3.0);\n    float x = sin(radians(min(subt*180.0,180.0)));\n    float a0 = radians((t - subt)/3.0 * 30.0);\n    float a1 = a0 + radians(30.0);\n    float a = mix(a0, a1, min(subt,1.0));\n\treturn vec3(cos(a),sin(a),mix(-1.0,-0.8,x));\n}\n\nfloat fog_light(vec3 n, vec3 l) {\n    return mix(0.1, 1.0, 0.5+0.5*-dot(n, l));\n}\n\nvec3 calc_intersection( in vec3 ro, in vec3 rd ) {\n    ro = ro.zxy;\n    rd = rd.zxy;\n    vec3 p[4];\n    float ti = iTime * 8.0;\n    p[0] = feet_curve(ti);\n    p[1] = feet_curve(ti + 12.0 + 1.0);\n    p[2] = feet_curve(ti + 24.0 + 2.0);\n    // do a little spring animation\n    ti = iTime * 4.0;\n    vec2 cuv = hash21(float(int(ti / 5.0))) * 2.0 - 1.0;\n    ti = mod(ti, 5.0) * 2.0;\n    float rk = (10.0 - ti) / (1.0 + (10.0 - ti));\n    float spr = clamp(rk * ((8.0 - sin(ti * 8.0) / (ti * ti))/8.0), 0.0, 2.0);\n    p[3] = vec3(0.0,0.0,0.5);//vec3(mix(vec2(0.0), cuv, spr), mix(-0.7, 0.5, spr));\n    \n    vec3 l = normalize(vec3(1.0, -1.0, -1.0));\n    \n    float plane_t = -(ro.z + 1.0) / rd.z;\n    \n    float alpha = 0.8;\n    \n    Hit h0, h1;\n    vec3 col = vec3(0.0);\n    if (plane_t > 0.0) {\n\t    vec3 plane_p = ro + rd * plane_t;\n        col = vec3(abs(rd.z));\n        float sh = 0.5;\n        if (iSimplex3(p, plane_p, -l, h0, h1)) {\n            vec3 fog = color_fog_mix_coeffs(1.0 - 1.0/(1.0 - alpha), h1.t - h0.t, 1.0);\n            sh = mix(sh, 0.25, fog.z);\n        }\n        col *= sh;\n    } else {        \n        col = vec3(0.0);\n    }\n    \n    // smooth normals for the fog\n    vec3 n0 = normalize(p[0] - (p[1] + p[2] + p[3])/3.0);\n    vec3 n1 = normalize(p[1] - (p[2] + p[3] + p[0])/3.0);\n    vec3 n2 = normalize(p[2] - (p[3] + p[0] + p[1])/3.0);\n    vec3 n3 = normalize(p[3] - (p[0] + p[1] + p[2])/3.0);\n    \n    if (iSimplex3(p, ro, rd, h0, h1)) {\n        Hit w0, w1;\n        \n#if 1\n        vec3 C[4] = vec3[](\n            vec3(0.0, 1.0, 0.5)*fog_light(n0, l),\n            vec3(1.0, 0.5, 0.0)*fog_light(n1, l),\n            vec3(1.0, 0.0, 0.5)*fog_light(n2, l),\n            vec3(0.5, 0.0, 1.0)*fog_light(n3, l)\n        );\n#else\n        vec3 C[4] = vec3[](\n            vec3(0.1, 1.0, 0.1),\n            vec3(1.0, 0.1, 0.1),\n            vec3(0.1, 0.1, 1.0),\n            vec3(0.0)\n        );\n#endif\n        \n        vec3 c0 = h0.b.x * C[0] + h0.b.y * C[1] + h0.b.z * C[2] + h0.b.w * C[3];\n        vec3 c1 = h1.b.x * C[0] + h1.b.y * C[1] + h1.b.z * C[2] + h1.b.w * C[3];\n        \n        vec3 fog = color_fog_mix_coeffs(1.0 - 1.0/(1.0 - alpha), h1.t - h0.t, 1.0);\n        \n        col = mix(col, c0*fog.x + c1*fog.y, fog.z);\n    }\n    \n    return col;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    col = calc_intersection( ro, rd );\n\t   \n    fragColor = vec4( linear_srgb(ACESFitted(col*1.5)), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat linear_srgb(float x) {\n    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));\n}\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}