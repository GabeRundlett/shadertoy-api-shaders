{
    "Shader": {
        "info": {
            "date": "1719632279",
            "description": "Similar to a toy I have on my desk.\n\nThis is lit only with an environment map and ambient occlusion, which looks nice as long as you use big, soft lights. \n",
            "flags": 0,
            "hasliked": 0,
            "id": "M3sXDS",
            "likes": 35,
            "name": "Fidget Cube",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "TheBen27",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "#define MAX_DEPTH 8.0\n#define CUBE_COUNT 8\n\nconst float minDepth = 0.01;\nconst float matchEps = 0.0001;\n\n// Global vars\nfloat time;\n// For some reason, making this a global variable is good for performance,\n// despite the fact that shaders don't have a stack. Maybe this array is\n// copied into inner functions?\nmat4[CUBE_COUNT] transforms;\nfloat shapeFactor;\n\nfloat snapping(float a, float b, float t) {\n    t = clamp(t, a, b);\n    t = (t - a) / (b - a);\n    t = clamp(t * 2.0, 0.0, 1.0);\n    \n    float s = step(0.5, t);\n    float ta = pow(t * 2.0, 2.0) * 0.5;\n    float tb = 0.5 + pow(max(0.0, t * 2.0 - 1.0), 0.5) * 0.5;\n    t = mix(ta, tb, s);\n    \n    return t;\n}\n\nfloat beat() {\n    return mod(time * 2.0, 8.0);\n}\n\nmat4[CUBE_COUNT] cubeTransforms() {\n    \n    // 120BPM\n    float time = beat();\n\n    mat4 preT = translate(vec3(0.25, -0.25, -0.25));\n    \n    mat4 mats[CUBE_COUNT];\n    mats[0] = rotY(0.0) * preT;\n    mats[1] = rotY(PI / 2.0) * preT;\n    mats[2] = rotY(PI) * preT;\n    mats[3] = rotY(PI * 3.0 / 2.0) * preT;\n    mat4 sy = translate(vec3(0.0, -1.0, 0.0)) * rotX(PI);\n    mats[4] = sy * mats[0];\n    mats[5] = sy * mats[1];\n    mats[6] = sy * mats[2];\n    mats[7] = sy * mats[3];\n    \n    // first folding out\n    float s1 = snapping(0.0, 1.0, time);\n    mat4 t1 = translate(vec3(0.0, -s1 * 0.5, 0.0));\n    mat4 r1 = t1 * rotX(s1 * PI / 2.0);\n    mat4 r1i = t1 * rotX(-s1 * PI / 2.0);\n    mats[0] = r1i * mats[0];\n    mats[1] = r1  * mats[1];\n    mats[2] = r1  * mats[2];\n    mats[3] = r1i * mats[3];\n    mats[4] = r1  * mats[4];\n    mats[5] = r1i * mats[5];\n    mats[6] = r1i * mats[6];\n    mats[7] = r1  * mats[7];\n    \n    // second folding\n    float s2 = snapping(1.0, 2.0, time);\n    mat4 t2 = translate(vec3(0.0, -s2 * 0.5, 0.0));\n    mat4 r2 = t2 * rotZ(s2 * PI / 2.0);\n    mat4 r2i = t2 * rotZ(-s2 * PI / 2.0);\n    mats[0] = r2i *  mats[0];\n    mats[1] = r2i * mats[1];\n    mats[2] = r2  * mats[2];\n    mats[3] = r2  * mats[3];\n    mats[4] = r2i * mats[4];\n    mats[5] = r2i * mats[5];\n    mats[6] = r2  * mats[6];\n    mats[7] = r2  * mats[7];\n    \n    // third folding\n    float s3 = snapping(2.0, 3.0, time);\n    mat4 t3 = translate(vec3(0.0, -s3 * 0.5, 0.0));\n    mat4 r3 = t3 * translate(vec3(0.0, 0.0, 0.5)) * rotX(s3 * PI) * translate(vec3(0.0, 0.0, -0.5));\n    mat4 r3i = t3 * translate(vec3(0.0, 0.0, -0.5)) * rotX(-s3 * PI) * translate(vec3(0.0, 0.0, 0.5));\n    mats[0] = t3  *  mats[0];\n    mats[1] = t3  * mats[1];\n    mats[2] = t3  * mats[2];\n    mats[3] = t3  * mats[3];\n    mats[4] = r3  * mats[4];\n    mats[5] = r3i * mats[5];\n    mats[6] = r3i * mats[6];\n    mats[7] = r3  * mats[7];\n    \n    // TODO can get rid of remaining foldings\n    \n    // fourth folding\n    float s4 = snapping(4.0, 5.0, time);\n    mat4 t4 = translate(vec3(0.0, -s4 * 0.5, 0.0));\n    mat4 r4 = t4 * rotZ(s4 * PI / 2.0);\n    mat4 r4i = t4 * rotZ(-s4 * PI / 2.0);\n    mats[0] = r4i * mats[0];\n    mats[1] = r4i * mats[1];\n    mats[2] = r4 * mats[2];\n    mats[3] = r4 * mats[3];\n    mats[4] = r4i * mats[4];\n    mats[5] = r4i * mats[5];\n    mats[6] = r4 * mats[6];\n    mats[7] = r4 * mats[7];\n    \n\n    // fifth folding\n    float s5 = snapping(5.0, 6.0, time);\n    mat4 t5 = translate(vec3(0.0, -s5 * 0.5, 0.0));\n    mat4 r5 = t5 * rotX(s5 * PI / 2.0);\n    mat4 r5i = t5 * rotX(-s5 * PI / 2.0);\n    mats[0] = r5i * mats[0];\n    mats[1] = r5 * mats[1];\n    mats[2] = r5 * mats[2];\n    mats[3] = r5i * mats[3];\n    mats[4] = r5 * mats[4];\n    mats[5] = r5i * mats[5];\n    mats[6] = r5i * mats[6];\n    mats[7] = r5 * mats[7];\n    \n    // sixth and final folding\n    float s6 = snapping(6.0, 7.0, time);\n    mat4 t6 = translate(vec3(0.0, -s6 * 0.5, 0.0));\n    mat4 r6 = t6 * translate(vec3(-0.5, 0.0, 0.0)) * rotZ(s6 * PI) * translate(vec3(0.5, 0.0, 0.0));\n    mat4 r6i = t6 * translate(vec3(0.5, 0.0, 0.0)) * rotZ(-s6 * PI) * translate(vec3(-0.5, 0.0, 0.0));\n    mats[0] = r6i * mats[0];\n    mats[1] = r6i * mats[1];\n    mats[2] = r6 * mats[2];\n    mats[3] = r6 * mats[3];\n    mats[4] = t6 * mats[4];\n    mats[5] = t6 * mats[5];\n    mats[6] = t6 * mats[6];\n    mats[7] = t6 * mats[7];\n    \n    // spin every fourth beat\n    mat4 spin = rotY(\n        PI * 0.5 * (snapping(7.0, 8.0, time) + snapping(3.0, 4.0, time))\n    );\n    mats[0] = spin * mats[0];\n    mats[1] = spin * mats[1];\n    mats[2] = spin * mats[2];\n    mats[3] = spin * mats[3];\n    mats[4] = spin * mats[4];\n    mats[5] = spin * mats[5];\n    mats[6] = spin * mats[6];\n    mats[7] = spin * mats[7];\n    \n    return mats;\n}\n\nvec2 sceneSDF(vec3 pos) {\n    vec2 sm = vec2(MAX_DEPTH, 0.0);\n    vec4 p = vec4(pos, 1.0);\n    \n    for (int i = 0; i < CUBE_COUNT; i++) {\n        float tri = sdTriBox((p * transforms[i]).xyz);\n        float cir = sdCircleBox((p * transforms[i]).xyz);\n        float mixed = mix(tri, cir, shapeFactor);\n        if (mixed < sm.x) {\n            sm.x = mixed;\n            sm.y = float(i);\n        }\n    }\n    return sm;\n}\n\nvec3 sceneNormal( in vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h).x + \n                      k.yyx*sceneSDF( p + k.yyx*h).x + \n                      k.yxy*sceneSDF( p + k.yxy*h).x + \n                      k.xxx*sceneSDF( p + k.xxx*h).x );\n}\n\nbool intersectPlane(vec3 normal, vec3 planeOrigin, vec3 eye, vec3 dir, out float dist)\n{\n    eye.y = -eye.y;\n    dir.y = -dir.y;\n    // Assuming vectors are all normalized\n    float denom = dot(normal, dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = planeOrigin - eye;\n        dist = dot(p0l0, normal) / denom; \n        return (dist >= 0.0);\n    }\n\n    return false;\n}\n\nbool intersectFloor(float height, vec3 eye, vec3 dir, out float t) {\n    return intersectPlane(vec3(0.0, 1.0, 0.0), vec3(0.0, height, 0.0), eye, dir, t);\n}\n\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nvec2 getDepthAndMaterial(vec3 eye, vec3 dir) {\n    // AABB check\n    vec2 boxCheck =\n        intersectAABB(\n            eye,\n            dir,\n            vec3(-0.75, -0.25, -1.25),\n            vec3(0.75, 1.25, 1.25)\n    );\n    if (boxCheck.x > boxCheck.y) {\n        return vec2(MAX_DEPTH, 0.0);\n    }\n\n    float depth = boxCheck.x;\n    float sdf = matchEps;\n    float mat = 0.0;\n    for (int steps = 0;\n         sdf >= matchEps && depth < MAX_DEPTH && steps < 40;\n         steps++) {\n        vec2 sdf = sceneSDF(eye + depth * dir);\n        depth += sdf.x;\n        mat = sdf.y;\n    }\n    depth = min(depth, MAX_DEPTH);\n    \n    return vec2(depth, mat);\n}\n\nfloat occ( in vec3 p, in vec3 n)\n{\n    const float maxDist = 0.5;\n    const float falloff = 1.0;\n    const int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = rand(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal for self occlusion problems!\n\n        ao += (l - max(sceneSDF( p + rd).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 getTexCoords(vec3 pos, float mat) {\n    vec4 p = vec4(pos, 1.0);\n    return (p * transforms[int(mat)]).xyz;\n}\n\n// surprisingly acceptable for something so simple\nvec2 boxMapping(vec3 tc, vec3 norm) {\n    vec2 uvTop = tc.xz;\n    vec2 uvRight = tc.zy;\n    vec2 uvFront = tc.xy;\n    float weightTop = abs(norm.y);\n    float weightRight = abs(norm.x);\n    float weightFront = abs(norm.z);\n    float totalWeights = weightTop + weightRight + weightFront;\n    \n    return (uvTop * weightTop + uvRight * weightRight + uvFront * weightFront) / totalWeights;\n}\n\nvec3 textureAt(vec3 tc, vec3 norm, float mat) {\n    norm = (vec4(norm, 0.0) * transforms[int(mat)]).xyz;\n    \n    // box mapping\n    vec2 uv = boxMapping(tc, norm);\n    \n    vec3 color;\n    \n    // outside faces:\n    // (0, 0, 1)\n    // (0, -1, 0)\n    // (-1, 0, 0)\n    float isOutside = step(0.9, dot(norm, vec3(-1.0, -1.0, 1.0)));\n    \n    // base colors\n    float checker = step(mod(mat, 2.0), 0.99);\n    vec3 outside = mix(\n        vec3(1.0, 0.5, 0.9), // pink\n        vec3(0.5, 0.7, 0.8), // blue\n        checker\n    );\n    vec3 inside = mix(\n        vec3(0.8, 0.2, 0.2), // red\n        vec3(0.2, 0.8, 0.2), // green\n        checker\n    );\n    color = mix(inside, outside, isOutside);\n    \n    // add an edge outline\n    \n    // \"snap\" the normal vector to the nearest cardinal direction\n    // not sure if there's a better way to do this...\n    // bias the snap based on what side of the cube's diagonal we're on\n    // this makes the diagonal side look right\n    float bias = sign(-tc.x - tc.z) * 0.001;\n    vec3 snorm;\n    \n    if (abs(norm.x) + bias > abs(norm.y) && abs(norm.x) + bias > abs(norm.z)) {\n        snorm = vec3(sign(norm.x), 0.0, 0.0);\n    } else if (abs(norm.y) + bias > abs(norm.z)) {\n        snorm = vec3(0.0, sign(norm.y), 0.0);\n    } else {\n        snorm = vec3(0.0, 0.0, sign(norm.z));\n    }\n    \n    // proj a onto b = dot(a, b) / dot(b, b) * b\n    // since |b| = 1...\n    vec3 p = dot(tc, snorm) * snorm;\n    vec3 r = tc - p;\n    float boxDist = max(abs(r.x), max(abs(r.y), abs(r.z)));\n    float edgeHighlight = smoothstep(0.24, 0.25, boxDist);\n    \n    // apply edge highlight\n    color = mix(color, vec3(1.0, 0.8, 0.9), edgeHighlight);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    if (iMouse.z > 0.0) {\n        time = 4.0 * iMouse.x / iResolution.x;\n    } else {\n        time = iTime - 0.5 * texture(iChannel3, uv).r * iTimeDelta; \n    }\n \n    float shape1 = snapping(3.0, 4.0, mod(beat(), 4.0));\n    shapeFactor = beat() > 4.0 ? (1.0 - shape1) : shape1;\n \n    vec3 eye, dir;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = -2.5;\n    mat2 rx = rot(PI / 6.5);\n    mat2 ry = rot(PI / 4.0);\n    eye = vec3(0.0, 0.25, dist);\n    eye.yz *= rx;\n    eye.xz *= ry;\n    dir = normalize(vec3(uv, 1.0));\n    dir.yz *= rx;\n    dir.xz *= ry;\n   \n    vec3 col = vec3(1.0, 1.0, 0.0);\n    \n    // it looks like we do something wrong here...\n    transforms = cubeTransforms();\n    \n    vec2 sdf = getDepthAndMaterial(eye, dir);\n    float depth = sdf.x;\n    float mat = sdf.y;\n    \n    if (depth >= MAX_DEPTH) {\n        float dist;\n        bool hitFloor = intersectFloor(0.0, eye, dir, dist);\n        if (hitFloor) {\n            depth = dist;\n            mat = -1.0;\n        }\n    }\n    \n    if (depth < MAX_DEPTH || mat == -1.0) {\n        vec3 pos = eye + dir * depth;\n        vec3 norm;\n        \n        if (mat < 0.0) {\n            norm = vec3(0.0, 1.0, 0.0);\n            col = vec3(1.0);\n        } else {\n            // texture\n            norm = sceneNormal(pos);\n            vec3 color = textureAt(getTexCoords(pos, mat), norm, mat);\n            col = color;\n        }\n        pos += norm * 0.001;\n        \n        // diffuse light\n        col *= texture(iChannel0, norm).rgb;\n\n        // specular highlights\n        float fresnel = 0.8 * fresnelFactor(1.2, dir, norm);\n        float spec = texture(iChannel0, reflect(dir, norm)).a;\n        col = mix(col, vec3(spec), max(0.0, fresnel));\n        \n        float occ = occ(pos, norm);\n        occ *= occ;\n        col *= occ;\n        \n    } else {\n        col = sky(dir);\n    }\n\n    // Output to screen\n    fragColor = vec4(sqrt(Tonemap_ACES(col * 0.8)),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n#define MAT_METAL -1.0\n\nvec3 Tonemap_ACES(vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat fresnelFactor(float r0, vec3 dir, vec3 normal) {\n    float f = 1.0 - dot(normal, dir);\n    return r0 + (1.0 - r0) * (f * f * f * f * f);\n}\n\nvec3 skyLight(vec3 dir, vec3 col, vec3 center, float size, float smoothness) {\n    float falloff = max(0.0, dot(dir, normalize(center)));\n    float sizeMin = 1.0 - size;\n    falloff = smoothstep(sizeMin, mix(sizeMin, 1.0, smoothness), falloff);\n    // energy correction - smaller lamps should be brighter\n    return col * falloff / size;\n}\n\nvec3 sky(vec3 dir) {\n    vec3 top = vec3(0.4, 0.4, 0.6);\n    vec3 bottom = vec3(0.3, 0.3, 0.5);\n    vec3 ambient = mix(top, bottom, -dir.y);\n    \n    vec3 fill = skyLight(dir, vec3(1.0), vec3(-0.1, 1.0, 0.5), 0.5, 1.0);\n    vec3 key = skyLight(dir, vec3(0.6), vec3(-0.2, 0.3, -0.2), 0.2, 1.0);\n    return ambient + fill + key;\n}\n\nfloat rand(float p)\n{\n    p = fract(p * .1031);\n    p += 0.1;\n    p *= p + 33.33;\n    p *= p + p;\n    p -= 0.1;\n    return fract(p);\n}\n\nfloat rand2(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(rand(i+1.), rand(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\nmat2 rot(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nconst mat4 id = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n);\n\nmat4 scale(vec3 p) {\n    return mat4(\n        p.x, 0.0, 0.0, 0.0,\n        0.0, p.y, 0.0, 0.0,\n        0.0, 0.0, p.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 translate(vec3 p) {\n    return mat4(\n        1.0, 0.0, 0.0, p.x,\n        0.0, 1.0, 0.0, p.y,\n        0.0, 0.0, 1.0, p.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotZ(float t) {\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n         ct, -st, 0.0, 0.0,\n         st,  ct, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotY(float t) {\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n         ct, 0.0,  st, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -st, 0.0,  ct, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotX(float t) {\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,  ct, -st, 0.0,\n        0.0,  st,  ct, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCircleBox(vec3 p) {\n    float smoothness = 0.01;\n    float b = sdBox(p, vec3(0.25) - smoothness) - smoothness;\n    \n    float c = distance(p, vec3(-0.25, -0.25, 0.25)) - 0.5;\n    return max(b, c);\n}\n\nfloat sdTriBox(vec3 p) {\n    float smoothness = 0.01;\n    float b = sdBox(p, vec3(0.25) - smoothness) - smoothness;\n    \n    float magic = 0.577;\n    float cutter = dot(p, normalize(vec3(magic, magic, -magic))) - (0.15);\n    return max(b, cutter);\n}\n\nvec2 sdfMin(vec2 s1, vec2 s2) {\n    if (s1.x < s2.x) {\n        return s1;\n    }\n    return s2;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Precompute environment map\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (iFrame > 1) {\n        fragColor = texture(iChannel0, rayDir);\n        return;\n    }\n    \n    // Diffuse\n    vec3 diff = vec3(0.0);\n    const int diff_samples = 512;\n    for (int i = 0; i < diff_samples; i++) {\n        vec3 dir = randomHemisphereDir(rayDir, float(i));\n        diff += dot(rayDir, dir) * sky(dir);\n    }\n    diff /= float(diff_samples);\n    // not physical\n    diff *= 2.0;\n    \n    // Specular\n    vec3 specColor = sky(rayDir);\n    float spec = specColor.r + specColor.g + specColor.b;\n    spec /= 3.0;\n    \n    // Output to cubemap\n    fragColor = vec4(diff, spec);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}