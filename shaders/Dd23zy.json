{
    "Shader": {
        "info": {
            "date": "1667844086",
            "description": "Use the mouse to look around. WASD to move. Shift to run. Press Space to detach from ground while moving",
            "flags": 48,
            "hasliked": 0,
            "id": "Dd23zy",
            "likes": 1,
            "name": "Clouds with walking and flying",
            "published": 3,
            "tags": [
                "clouds"
            ],
            "usePreview": 1,
            "username": "ilia87",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "#define FBM_ORDER 6\nvec3 camPos;\nvec3 L;\nconst mat2 m2 = mat2(.6,.8,-.8,.6);\nconst mat3 m3 = mat3(0.7213075,  0.0909291,  0.6866202,\n   0.0448847,  0.9831243, -0.1773473,\n  -0.6911591,  0.1587406,  0.7050536);\nconst mat4 m4 = mat4(\n     0.56205435, -0.81788519, -0.05012413,  0.11245573,\n 0.05973262,  0.12274471,  0.53602604,  0.83309173,\n-0.67219756, -0.37512639, -0.48469787,  0.41532951,\n 0.47820222,  0.41866184, -0.68937046,  0.34758203);\n\nconst float cloudStartHeight = 6.;\nconst float cloudEndHeight = 22.;\nconst float morphSpeed = 1.5;\n\nfloat noise(float i)\n{\n    float x = fract(i*3.453462472+.45623426)*50.;\n    return 2.*fract(x*x)-1.;\n}\n\n\nfloat noise(vec2 ij)\n{\n    vec2 xy = fract(ij*vec2(3.453462472,6.76235421)+vec2(.45623426,.57422783))*50.;\n    return 2.*fract(xy.x*xy.y*(xy.x+xy.y))-1.;\n}\n\nfloat noise(vec3 ijk)\n{\n    vec3 xyz = fract(ijk*vec3(3.453462472,6.76235421,1.2452341)+vec3(.45623426,.57422783,.7552213513))*50.;\n    return 2.*fract((xyz.x*xyz.y + xyz.y*xyz.z + xyz.z*xyz.x)*(xyz.x+xyz.y+xyz.z))-1.;\n}\n\nfloat noise(vec4 ijk)\n{\n    vec4 xyz = fract(ijk*vec4(3.453462472,6.76235421,1.2452341,2.86987991)+vec4(.45623426,.57422783,.7552213513,.91231514))*50.;\n    return 2.*fract((xyz.x*xyz.y + xyz.y*xyz.z + xyz.z*xyz.x + xyz.w*(xyz.z + xyz.y + xyz.x))*(xyz.x+xyz.y+xyz.z+xyz.w))-1.;\n}\n\n\nvec2 SmoothStep_d(float edge0, float edge1, float x)\n{\n    float scale = 1. / (edge1 - edge0);\n    float t = clamp((x - edge0) * scale, 0.0, 1.0);\n    float v = t * t * (3.0 - 2.0 * t);\n    float dv = scale * 6. * t * (1. - t);\n    return vec2(v,dv);\n}\n\nfloat CloudFBM_d(vec4 p, out vec4 dk)\n{\n    float k = 0.;\n    dk = vec4(0.);\n    float factor=1.;\n    float uvFactor = 1.;\n    mat4 mTotal = mat4(\n        1,0,0,0,\n        0,1,0,0,\n        0,0,1,0,\n        0,0,0,1);\n    for ( int i=0;i<FBM_ORDER;++i)\n    {\n        p+=vec4(7.436525461,8.32524631,3.2465756,2.254107789);\n        vec4 q = floor(p);\n        \n        vec2 SX = SmoothStep_d(0.,1.,fract(p.x));\n        vec2 SY = SmoothStep_d(0.,1.,fract(p.y));\n        vec2 SZ = SmoothStep_d(0.,1.,fract(p.z));\n        vec2 SW = SmoothStep_d(0.,1.,fract(p.w));\n        vec4 s = vec4(SX.x,SY.x,SZ.x,SW.x);\n        vec4 ds = vec4(SX.y,SY.y,SZ.y,SW.y);\n        \n        float h[4];\n        vec2 dh[4];\n        for ( int jz = 0;jz<2;++jz)\n        {\n            for ( int kw = 0;kw<2;++kw)\n            {\n                float a1 = noise(q+vec4(0.,0.,float(jz),float(kw)));\n                float b1 = noise(q+vec4(1.,0.,float(jz),float(kw)));\n                float c1 = noise(q+vec4(0.,1.,float(jz),float(kw)));\n                float d1 = noise(q+vec4(1.,1.,float(jz),float(kw)));\n                h[jz*2+kw] = (\n                    a1\n                    + (b1-a1)*s.x\n                    + (c1-a1)*s.y\n                    + (a1-b1-c1+d1)*s.x*s.y);\n                dh[jz*2+kw] = vec2(\n                    ds.x*((b1-a1) + (a1-b1-c1+d1)*s.y),\n                    ds.y*((c1-a1) + (a1-b1-c1+d1)*s.x)\n                );\n            }\n        }\n        float g = h[0]\n                    + (h[2]-h[0])*s.z\n                    + (h[1]-h[0])*s.w\n                    + (h[0]-h[1]-h[2]+h[3])*s.z*s.w;\n        vec4 dg;\n        dg.xy = dh[0]\n            + (dh[2] - dh[0]) * s.z\n            + (dh[1] - dh[0]) * s.w\n            + (dh[0] - dh[1] - dh[2] + dh[3])*s.z*s.w;\n        \n        dg.zw = vec2((h[2]-h[0] + (h[0]-h[1]-h[2]+h[3])*s.w) *ds.z\n                    ,(h[1]-h[0] + (h[0]-h[1]-h[2]+h[3])*s.z) *ds.w);\n        \n        k += factor * g;\n        dk += (factor * uvFactor)*(mTotal * dg);\n        \n        factor *=.4;\n        uvFactor *= 1.5;\n        p *= 2.5;\n        p *= m4;\n        mTotal = mTotal * m4;\n    }\n    return k;\n}\n\nfloat CloudFBM(vec4 p,int n)\n{\n    float k = 0.;\n    float factor=1.;\n    for ( int i=0;i<n;++i)\n    {\n        p+=vec4(7.436525461,8.32524631,3.2465756,2.254107789);\n        vec4 q = floor(p);\n        \n        vec4 s = smoothstep(0.,1.,fract(p));\n        \n        float h[4];\n        for ( int jz = 0;jz<2;++jz)\n        {\n            for ( int kw = 0;kw<2;++kw)\n            {\n                float a1 = noise(q+vec4(0.,0.,float(jz),float(kw)));\n                float b1 = noise(q+vec4(1.,0.,float(jz),float(kw)));\n                float c1 = noise(q+vec4(0.,1.,float(jz),float(kw)));\n                float d1 = noise(q+vec4(1.,1.,float(jz),float(kw)));\n                h[jz*2+kw] = (\n                    a1\n                    + (b1-a1)*s.x\n                    + (c1-a1)*s.y\n                    + (a1-b1-c1+d1)*s.x*s.y);\n            }\n        }\n        float g = h[0]\n                    + (h[2]-h[0])*s.z\n                    + (h[1]-h[0])*s.w\n                    + (h[0]-h[1]-h[2]+h[3])*s.z*s.w;\n                    \n        k += factor * g;\n        \n        factor *=.55;\n        p *= 2.5;\n        p *= m4;\n    }\n    return k;\n}\n\nfloat CloudFBM(vec3 p, int n)\n{\n    float k = 0.;\n    float factor=1.;\n    for ( int i=0;i<n;++i)\n    {\n        p += vec3(5.434573,7.5436727,1.3453572);\n        vec3 q = floor(p);\n        \n        float a0 = noise(q);\n        float b0 = noise(q+vec3(1.,0.,0.));\n        float c0 = noise(q+vec3(0.,1.,0.));\n        float d0 = noise(q+vec3(1.,1.,0.));\n        \n        float a1 = noise(q+vec3(0.,0.,1.));\n        float b1 = noise(q+vec3(1.,0.,1.));\n        float c1 = noise(q+vec3(0.,1.,1.));\n        float d1 = noise(q+vec3(1.,1.,1.));\n        \n        vec3 s = smoothstep(0.,1.,fract(p));\n        \n        float k0 = (\n            a0\n            + (b0-a0)*s.x\n            + (c0-a0)*s.y\n            + (a0-b0-c0+d0)*s.x*s.y);\n        float k1 = (\n            a1\n            + (b1-a1)*s.x\n            + (c1-a1)*s.y\n            + (a1-b1-c1+d1)*s.x*s.y);\n        k+=factor*((k1-k0)*s.z+k0);\n        factor *=.55;\n        p *= 2.5;\n        p *= m3;\n    }\n    return k;\n}\n\nfloat CloudFBM_ld(vec4 p)\n{\n    float k = 0.;\n    float factor=1.;\n    for ( int i=0;i<5;++i)\n    {\n        p+=vec4(7.436525461,8.32524631,3.2465756,2.254107789);\n        vec4 q = floor(p);\n        \n        vec4 s = smoothstep(0.,1.,fract(p));\n        \n        float h[4];\n        for ( int jz = 0;jz<2;++jz)\n        {\n            for ( int kw = 0;kw<2;++kw)\n            {\n                float a1 = noise(q+vec4(0.,0.,float(jz),float(kw)));\n                float b1 = noise(q+vec4(1.,0.,float(jz),float(kw)));\n                float c1 = noise(q+vec4(0.,1.,float(jz),float(kw)));\n                float d1 = noise(q+vec4(1.,1.,float(jz),float(kw)));\n                h[jz*2+kw] = (\n                    a1\n                    + (b1-a1)*s.x\n                    + (c1-a1)*s.y\n                    + (a1-b1-c1+d1)*s.x*s.y);\n            }\n        }\n        float g = h[0]\n                    + (h[2]-h[0])*s.z\n                    + (h[1]-h[0])*s.w\n                    + (h[0]-h[1]-h[2]+h[3])*s.z*s.w;\n                    \n        k += factor * g;\n        \n        factor *=.6;\n        p *= 2.;\n        p *= m4;\n    }\n    return k;\n}\n\nfloat CloudFBM_ld(vec3 p)\n{\n    float k = 0.;\n    vec3 dk = vec3(0.);\n    float factor=1.;\n    float uvFactor = 1.;\n    mat3 mTotal = mat3(1,0,0,0,1,0,0,0,1);\n    for ( int i=0;i<3;++i)\n    {\n        p+=vec3(1.56437612,6.415345893,8.62512677);\n        vec3 q = floor(p);\n        \n        float a0 = noise(q);\n        float b0 = noise(q+vec3(1.,0.,0.));\n        float c0 = noise(q+vec3(0.,1.,0.));\n        float d0 = noise(q+vec3(1.,1.,0.));\n        \n        float a1 = noise(q+vec3(0.,0.,1.));\n        float b1 = noise(q+vec3(1.,0.,1.));\n        float c1 = noise(q+vec3(0.,1.,1.));\n        float d1 = noise(q+vec3(1.,1.,1.));\n        \n        vec3 s = smoothstep(0.,1.,fract(p));\n        \n        float k0 = (\n            a0\n            + (b0-a0)*s.x\n            + (c0-a0)*s.y\n            + (a0-b0-c0+d0)*s.x*s.y);\n        float k1 = (\n            a1\n            + (b1-a1)*s.x\n            + (c1-a1)*s.y\n            + (a1-b1-c1+d1)*s.x*s.y);\n        k+=factor*((k1-k0)*s.z+k0);\n        factor *=.6;\n        p *= 2.;\n        //p.y*=2.5;\n        p *= m3;\n    }\n    return k;\n}\n\nfloat CloudDensity_ld(vec3 p)\n{\n    float v = clamp(CloudFBM_ld(vec4(p*vec3(.1,.1,.1)*.04,morphSpeed*iTime*.005)),-1.,1.)*.5 + .5;\n    float d = (p.y-cloudStartHeight) / (cloudEndHeight - cloudStartHeight);\n    v *= smoothstep(0.,0.4,d);\n    v *= 1. - smoothstep(0.6,1.,d);\n    return v;\n}\n\nfloat CloudDensity_hd(vec3 p, int detail)\n{\n    float v = clamp(CloudFBM(vec4(p*vec3(.1,.1,.1),morphSpeed*iTime*.02),detail),-1.,1.)*.5 + .5;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mouse = iMouse;\n    resolution = iResolution;\n    camPos = texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    //fragColor.xyz = camPos;\n    //return;\n    mat3 viewRot;\n    if(iMouse.x==0. && iMouse.y==0. || texelFetch(iChannel3,ivec2(76,0),0).x != 0.)\n        viewRot = Rotation(radians(220.),radians(40.));\n    else\n        viewRot = MouseToRot();\n    \n    if(iMouse.x==0. && iMouse.y==0. || texelFetch(iChannel3,ivec2(76,0),0).x == 0.)\n        L = normalize(vec3(0,-.5,1));\n    else\n        L = MouseToRot() * vec3(0,0,-1);\n    \n    vec3 rd = vec3((2.*fragCoord-iResolution.x) / iResolution.x,1.);\n    rd = viewRot * rd;\n    \n    //vec3 ro = camPos + rd + vec3(0.,0.,1.)*iTime;\n    vec3 ro = camPos + vec3(0.,0.,1.)*iTime + vec3(-40.,0.,-170.);\n    rd = normalize(rd);\n    \n    const int N = 100;\n    \n    float dr_min = .45;\n    float dr_max = 1.5;\n    \n    const vec3 lightColor = vec3(.85);\n    const vec3 darkColor = vec3(.5,.5,.7);\n    const vec3 horizonColor = vec3(.5,.5,.55)*1.5;\n    const float ldThreshold = .3;\n    const float hdThreshold = .4;\n    //float dr = dr0;\n    vec4 colSum=vec4(0.);\n    float currDist;\n    if ( rd.y > 0. )\n    {\n        currDist = (cloudStartHeight-camPos.y)/rd.y;\n    }\n    else\n    {\n        currDist = (cloudEndHeight-camPos.y)/rd.y;\n    }\n    currDist = max(currDist,0.);\n    int i=0;\n    for ( ;i<N;++i)\n    {\n        vec3 p = ro + rd * currDist;\n        float ld = CloudDensity_ld(p);\n        //float dr = dr_min;\n        float dr = mix(dr_max,dr_min,smoothstep(0.,ldThreshold*2.5,ld));\n        //float dr = mix(dr_max,dr_min,smoothstep(0.,1.,v*4.));\n        float drAddition = max((currDist-100.)/50.,0.);\n        dr += drAddition;//*drAddition*.1;\n        dr *= .95 + .1*fract(439.526363543*(p.x+p.y+p.z));\n        \n\n        //float dr = mix(dr_max,dr_min,smoothstep(-.0,1.,ld));\n        //float dr = dr_max;\n        currDist += dr;\n        if ( ld < ldThreshold)\n            continue;\n\n        float hd = CloudDensity_hd(p,6);//int(6./(currDist*.01+1.)));\n        float v = smoothstep(ldThreshold,1.,ld) * smoothstep(hdThreshold,1.,hd);\n\n        float alpha = min(1.,2.0*v*dr);\n        //float alpha = min(1.,1.0*v);\n        \n        \n        float dlDist = .05;\n        float dL = (smoothstep(0.,1.,CloudDensity_ld(p+L*dlDist)) - smoothstep(0.,1.,ld)) /dlDist;\n        vec3 col = mix(darkColor,lightColor*2.9*exp(-currDist*.003),smoothstep(-1.0,1.,dL*6.0));\n        col = mix(col,horizonColor*1.7,1.-exp(-currDist*.003));\n        alpha *= exp(-currDist*.003);\n\n        colSum.xyz += col.xyz * alpha * (1.-colSum.w);\n        //colSum.xyz += col.xyz * (1.-colSum.w);\n        //colSum.xyz = mix(colSum.xyz,col.xyz,1.-colSum.w);\n        //colSum.xyz += col.xyz * alpha;\n        colSum.w += alpha;\n        if (colSum.w >= 1.0)\n            break;\n        if (   (p.y > cloudEndHeight && rd.y > 0.) \n            || (p.y < cloudStartHeight && rd.y < 0.) )\n            break;\n        if ( currDist > 800.)\n            break;\n    }\n    colSum.w = min(colSum.w,1.);\n    colSum.w = smoothstep(0.,2.,colSum.w)*2.;\n    vec3 envColor = vec3(0.);\n    if (rd.y<0.)\n    {\n        //fragColor.xyz=vec3(0.);\n        //return;\n        vec3 p = camPos + (-2.-camPos.y)/rd.y*rd;\n        envColor = texture(iChannel0, p.xz*.01).xyz * vec3(1.,1.,.7);\n    }\n    else\n    {\n        float theta = atan(rd.y,length(rd.xz))+fract(942348796.23523424*(rd.y+rd.z+rd.x+254235.6572974893487))*.2;\n        envColor = mix(horizonColor,vec3(.3,.3,.5)*1.5,smoothstep(radians(0.),radians(15.),theta));\n        envColor = mix(envColor,vec3(.2,.2,.4)*1.5,smoothstep(radians(10.),radians(60.),theta+fract(4234232.23523424*(rd.y+rd.z+rd.x))*.1));\n        //const vec3 skyColor = vec3(.5,.5,.7);\n        //envColor = skyColor;\n    }\n    //envColor =  vec3(.6,.6,1);\n    colSum.xyz = mix(envColor,colSum.xyz,colSum.w);\n    fragColor = vec4(colSum.xyz,1.);\n    //fragColor.x = float(i)/float(N);\n    //fragColor.yz = vec2(0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    if ( iFrame<5 || int(fragCoord.x) != 0 || int(fragCoord.y)!=0 )\n    {\n        return;\n    }\n    mouse = iMouse;\n    resolution = iResolution;\n    mat3 viewRot;\n    if(iMouse.x==0. && iMouse.y==0. || texelFetch(iChannel3,ivec2(76,0),0).x != 0.)\n        viewRot = Rotation(radians(220.),radians(40.));\n    else\n        viewRot = MouseToRot();\n    \n    vec3 currPos = texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    vec3 move = vec3(0.);\n    if ( texelFetch(iChannel3,ivec2(87,0),0).x != 0. )\n        move.z += 1.;\n    if ( texelFetch(iChannel3,ivec2(83,0),0).x != 0. )\n        move.z -= 1.;\n    if ( texelFetch(iChannel3,ivec2(65,0),0).x != 0. )\n        move.x -= 1.;\n    if ( texelFetch(iChannel3,ivec2(68,0),0).x != 0. )\n        move.x += 1.;\n    move = viewRot*move;\n    if ( texelFetch(iChannel3,ivec2(32,0),0).x == 0. )\n        move.y=0.;\n    float lm = length(move);\n    if (lm != 0.)\n    {\n        move /= lm;\n    }\n    float speed = .1;\n    if ( texelFetch(iChannel3,ivec2(16,0),0).x != 0.)\n        speed *= 5.;\n    fragColor.xyz = currPos + move*speed;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.1415927\n\nmat3 Rotation(float phi, float theta)\n{\n    float cp = cos(phi);\n    float sp = sin(phi);\n    float ct = cos(theta);\n    float st = sin(theta);\n    mat3 Mp = mat3(\n        cp,0.,-sp,\n        0.,1.,0.,\n        sp,0.,cp);\n    mat3 Mt = mat3(\n        1.,0.,0.,\n        0.,ct,-st,\n        0.,st,ct);\n    return Mp*Mt;\n}\n\nvec4 mouse;\nvec3 resolution;\n\nmat3 MouseToRot()\n{\n    vec2 mouse = (2.*mouse.xy-resolution.xy) / resolution.xy;\n    float phi = mouse.x*PI;\n    float theta = (mouse.y)*PI*.5;\n    return Rotation(phi,theta);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}