{
    "Shader": {
        "info": {
            "date": "1458567735",
            "description": "Simple approximation of indirect light without additional ray casting. Setting normalizeIndirect to false will show the total amount  of indirect light, which makes it easier to see. Setting it to true then averages the result. Mouse click for camera",
            "flags": 0,
            "hasliked": 0,
            "id": "MstXz7",
            "likes": 5,
            "name": "Simple Indirect Light Approx",
            "published": 3,
            "tags": [
                "distancefield",
                "spheretracing",
                "indirectlight"
            ],
            "usePreview": 0,
            "username": "sibaku",
            "viewed": 1288
        },
        "renderpass": [
            {
                "code": "const float eps = 0.0001;\nconst float pi = 3.14159265359;\n\n// Scales the scene for indirection -> better visibility for demonstration\nconst float scale = 0.5;\n\n// Tolerance for normal direction in indirect light computation -> surfaces giving off indirect light\n// should more or less face off against the receiver surface\nconst float normalTolerance = 0.2;\n\n// Threshold for indirect light contribution. Values below this won't have \n// the object's gradient evaluated\nconst float contributionTolerance = 0.01;\n\n// Maximum number of sphere trace steps\nconst int maxSteps = 150;\n\n// Set to true to average over the all used indirect lights\nconst bool normalizeIndirect = false;\n\n// Set to true to use only the two closest surfaces\nconst bool useSimpleIndirect = false;\n\n// Samples taken for shadow\nconst int shadowSteps = 30;\n\nmat3 rotY(float theta)\n{\n \n    \n    return mat3(cos(theta),0.,-sin(theta),\n                0.,1.,0.,\n                sin(theta),0.,cos(theta));\n    \n}\n\nfloat DE_Sphere(in vec3 p, in vec3 center, in float r)\n{\n \treturn length(p-center)-r;   \n}\n\nfloat DE_Box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat Object0(vec3 p)\n{\n    return DE_Sphere(p,vec3(0.,1.,-2.4),1.);\n}\n\nfloat Object1(vec3 p)\n{\n\treturn DE_Box(rotY(radians(30.))*(p-vec3(0.0,1.,3.)),vec3(1.0,1.,0.5));    \n}\n\nfloat Object2(vec3 p)\n{\n\treturn DE_Box(p-vec3(0.,-1.,0.),vec3(100.,1.,100.));    \n}\n\nfloat Object3(vec3 p)\n{\n\treturn DE_Box(p-vec3(-5.,0.,0.),vec3(1.,100.,100.));    \n}\n\nfloat Object4(vec3 p)\n{\n\treturn DE_Box(p-vec3(0.,0.,-5.),vec3(100.,100.,1.));    \n}\n\nfloat Object5(vec3 p)\n{\n\treturn DE_Box(p-vec3(0.,0.,5.),vec3(100.,100.,1.));    \n}\n\nfloat Object6(vec3 p)\n{\n\treturn DE_Box(p-vec3(0.,6.,0.),vec3(100.,1.,100.));    \n}\n\nvec3 grad0(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject0(p + vec3(eps,0.,0.)) - Object0(p - vec3(eps,0.,0.)),\n        Object0(p + vec3(0.,eps,0.)) - Object0(p - vec3(0.,eps,0.)),\n        Object0(p + vec3(0.,0.,eps)) - Object0(p - vec3(0.,0.,eps))\n    ));    \n}\n\nvec3 grad1(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject1(p + vec3(eps,0.,0.)) - Object1(p - vec3(eps,0.,0.)),\n        Object1(p + vec3(0.,eps,0.)) - Object1(p - vec3(0.,eps,0.)),\n        Object1(p + vec3(0.,0.,eps)) - Object1(p - vec3(0.,0.,eps))\n    ));    \n}\n\nvec3 grad2(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject2(p + vec3(eps,0.,0.)) - Object2(p - vec3(eps,0.,0.)),\n        Object2(p + vec3(0.,eps,0.)) - Object2(p - vec3(0.,eps,0.)),\n        Object2(p + vec3(0.,0.,eps)) - Object2(p - vec3(0.,0.,eps))\n    ));    \n}\n\n\nvec3 grad3(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject3(p + vec3(eps,0.,0.)) - Object3(p - vec3(eps,0.,0.)),\n        Object3(p + vec3(0.,eps,0.)) - Object3(p - vec3(0.,eps,0.)),\n        Object3(p + vec3(0.,0.,eps)) - Object3(p - vec3(0.,0.,eps))\n    ));    \n}\n\n\nvec3 grad4(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject4(p + vec3(eps,0.,0.)) - Object4(p - vec3(eps,0.,0.)),\n        Object4(p + vec3(0.,eps,0.)) - Object4(p - vec3(0.,eps,0.)),\n        Object4(p + vec3(0.,0.,eps)) - Object4(p - vec3(0.,0.,eps))\n    ));    \n}\n\nvec3 grad5(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject5(p + vec3(eps,0.,0.)) - Object5(p - vec3(eps,0.,0.)),\n        Object5(p + vec3(0.,eps,0.)) - Object5(p - vec3(0.,eps,0.)),\n        Object5(p + vec3(0.,0.,eps)) - Object5(p - vec3(0.,0.,eps))\n    ));    \n}\n\nvec3 grad6(in vec3 p)\n{\n\treturn normalize(vec3(\n    \tObject6(p + vec3(eps,0.,0.)) - Object6(p - vec3(eps,0.,0.)),\n        Object6(p + vec3(0.,eps,0.)) - Object6(p - vec3(0.,eps,0.)),\n        Object6(p + vec3(0.,0.,eps)) - Object6(p - vec3(0.,0.,eps))\n    ));    \n}\nvoid closest(in vec3 P, out int index, out float d)\n{\n    d = Object0(P);\n    index = 0;\n\n    float d2 = Object1(P);\n\n    if(d2 < d)\n    {\n        index = 1;\n        d = d2;\n    }\n    \n    d2 = Object2(P);\n    \n    if(d2 < d)\n    {\n        index = 2;\n        d = d2;\n    } \n    \n     d2 = Object3(P);\n    \n    if(d2 < d)\n    {\n        index = 3;\n        d = d2;\n    } \n    \n    d2 = Object4(P);\n    \n    if(d2 < d)\n    {\n        index = 4;\n        d = d2;\n    } \n   \n      d2 = Object5(P);\n    \n    if(d2 < d)\n    {\n        index = 5;\n        d = d2;\n    }\n    \n    d2 = Object6(P);\n    \n    if(d2 < d)\n    {\n        index = 6;\n        d = d2;\n    }\n        \n}\n\nvoid trace(in vec3 p, in vec3 dir, out float t, out float dist, out int steps, out vec3 color,\n           out int index,out vec3 N)\n{\n   \n    \n    \n    steps = 0;\n    color = vec3(0.,0.,0.);\n    dist = 10000.0;\n    t = 0.;\n    index = 0;\n    N = vec3(0.,0.,0.);\n    \n    float lastT = 0.;\n    for(int i= 0; i < maxSteps;i++)\n    {\n        vec3 pos = p+t*dir;\n     \tfloat d;\n        int indexTemp;\n        \n        closest(pos,indexTemp,d);\n        \n        \n        if(d < 2.0*eps)\n        {\n            dist = 0.;\n            t = lastT;\n            index = indexTemp;\n            return;\n        }\n        \n        lastT = t;\n        t += d;\n        steps++;\n    }\n}\n\nvec3 normal(in vec3 P, int index)\n{\n   if(index == 0)\n      {\n\n      \treturn grad0(P);\n\n      }else if(index == 1)\n      {\n      \treturn grad1(P);\n      }\n    else if(index == 2)\n      {\n      \treturn grad2(P);\n      }\n     else if(index == 3)\n      {\n      \treturn grad3(P);\n      }\n    else if(index == 4)\n      {\n      \treturn grad4(P);\n      }\n     else if(index == 5)\n      {\n      \treturn grad5(P);\n      }\n     else if(index == 6)\n      {\n      \treturn grad6(P);\n      }\n   \t  else\n      {\n      \treturn vec3(0.,0.,0.);\n      }\n}\n\nvec3 color(in vec3 P, int index)\n{\n      if(index == 0)\n      {\n\n      \treturn vec3(1.,1.,1.);\n\n      }else if(index == 1)\n      {\n      \treturn vec3(1.,1.,1.);\n      }else if(index == 2)\n      {\n      \treturn vec3(0.,1.,0.);\n      }\n    else if(index == 3)\n      {\n      \treturn vec3(1.,1.,1.);\n      }\n     else if(index == 4)\n      {\n      \treturn vec3(0.,0.,1.);\n      }\n    else if(index == 5)\n      {\n      \treturn vec3(1.,0.,0.);\n      }\n    else if(index == 6)\n      {\n      \treturn vec3(1.,1.,1.);\n      }\n   \t  else\n      {\n      \treturn vec3(0.,0.,0.);\n      }\n}\n\nvec3 shade(in vec3 P, in vec3 N, in vec3 color, in vec3 LPos,int index)\n{\n    vec3 L = normalize(LPos-P);\n    \n    return color*max(0.,dot(L,N));\n}\n\nvec3 indirect(in vec3 P, in int index, in vec3 LPos,in vec3 N)\n{\n \n    vec3 L = normalize(LPos-P);\n    vec3 col = vec3(0.,0.,0.);\n    \n   \tfloat d;\n    vec3 g;\n    float factor = 1.;\n   \n    \n    // Or just find the two closest ones and blend them. Less calculations. Result similar?\n    float contributors = 0.0;\n    if(index != 0)\n    {\n        d = Object0(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad0(P);\n            float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,0)*factor*weight;\n            contributors += 1.0;\n        }\n        \n        \n    }\n    \n    \n    if(index != 1)\n    {\n        d = Object1(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad1(P);\n            float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,1)*factor*weight;\n            contributors += 1.0;\n        }\n        \n    }\n    \n    if(index != 2)\n    {\n        d = Object2(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad2(P);\n           \n         \tfloat weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,2)*factor*weight;\n            contributors += 1.0;\n        }\n        \n    }\n    \n    if(index != 3)\n    {\n        d = Object3(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad3(P);\n            float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,3)*factor*weight;\n            contributors += 1.0;\n        }\n        \n    }\n    \n    if(index != 4)\n    {\n        d = Object4(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad4(P);\n            float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,4)*factor*weight;\n            contributors += 1.0;\n        }\n        \n    }\n    \n    \n        if(index != 5)\n    {\n        d = Object5(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad5(P);\n            float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,5)*factor*weight;\n            contributors += 1.0;\n        }\n        \n    }\n    \n        if(index != 6)\n    {\n        d = Object6(P)*scale;\n        \n        factor = clamp(exp(-d*d),0.,1.);\n        \n        if(factor > contributionTolerance)\n        {\n        \tg = grad6(P);\n            float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n            col += color(P,6)*factor*weight;\n            contributors += 1.0;\n        }\n        \n    }\n    \n    return col/(normalizeIndirect? 6. : 1.);\n}\n\n\n\nvec3 indirectSimple(in vec3 P, in int index, in vec3 LPos,in vec3 N)\n{\n \n    vec3 L = normalize(LPos-P);\n    vec3 col = vec3(0.,0.,0.);\n    \n   \tfloat d1 = 10000.;\n    float d2 = 10000.;\n    int index1 = -1;\n    int index2 = -1;\n    float d;\n    vec3 g;\n    float factor = 1.;\n   \n    \n    // Or just find the two closest ones and blend them. Less calculations. Result similar?\n    float contributors = 0.0;\n    if(index != 0)\n    {\n        d = Object0(P)*scale;\n        \n        if(d < d1)\n        {\n         \td1 = d;\n            index1 = 0;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 0;\n        }      \n    }\n    \n    if(index !=1)\n    {\n        d = Object1(P)*scale;\n        \n        if(d < d1)\n        {\n            d2 = d1;\n            index2 = index1;\n         \td1 = d;\n            index1 = 1;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 1;\n        }      \n    }\n    \n    \n     if(index !=2)\n    {\n        d = Object2(P)*scale;\n        \n        if(d < d1)\n        {\n            d2 = d1;\n            index2 = index1;\n         \td1 = d;\n            index1 = 2;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 2;\n        }      \n    }\n    \n     if(index !=3)\n    {\n        d = Object3(P)*scale;\n        \n        if(d < d1)\n        {\n            d2 = d1;\n            index2 = index1;\n         \td1 = d;\n            index1 = 3;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 3;\n        }      \n    }\n    \n     if(index !=4)\n    {\n        d = Object4(P)*scale;\n        \n        if(d < d1)\n        {\n            d2 = d1;\n            index2 = index1;\n         \td1 = d;\n            index1 = 4;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 4;\n        }      \n    }\n    \n    if(index !=5)\n    {\n        d = Object5(P)*scale;\n        \n        if(d < d1)\n        {\n            d2 = d1;\n            index2 = index1;\n         \td1 = d;\n            index1 = 5;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 5;\n        }      \n    }\n    \n     if(index !=6)\n    {\n        d = Object6(P)*scale;\n        \n        if(d < d1)\n        {\n            d2 = d1;\n            index2 = index1;\n         \td1 = d;\n            index1 = 6;\n            \n        }else if(d < d2)\n        {\n         \td2 = d;\n            index2 = 6;\n        }      \n    }\n    \n    factor = clamp(exp(-d1*d1),0.,1.);\n        \n    if(factor > contributionTolerance)\n    {\n        g = normal(P,index1);\n        float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n        col += color(P,index1)*factor*weight;\n    }\n        \n    factor = clamp(exp(-d2*d2),0.,1.);\n        \n    if(factor > contributionTolerance)\n    {\n        g = normal(P,index2);\n        float weight = max(dot(g,L),0.)*clamp(-dot(g,N) + normalTolerance,0.,1.);\n        col += color(P,index2)*factor*weight;\n    }\n    \n    return col/(normalizeIndirect? 6. : 1.);\n}\n\n\nfloat smoothShadow2(in vec3 P,in vec3 LPos)\n{\n    vec3 l = LPos - P;\n    float llen = length(l);\n    vec3 L = l/llen;\n   \n    \n    \n    float m = 1.;\n     float startDist;\n    int startIndex;\n    closest(P,startIndex,startDist);\n    \n    float t = abs(startDist);\n    float factor = 2.;\n    float endRadius;\n    closest(LPos,startIndex,endRadius);\n    for(int i = 1; i <= maxSteps; i++)\n    {\n        \n        if(t >= llen)\n            return m;\n        \n        vec3 pos = P + t*L;\n        \n        int ind;\n        float d = 0.;\n       \n        \n        closest(pos,ind,d);\n        \n        \n        \n        \n        float radius = endRadius*t/llen;\n        \n        m = min(factor*d/radius,m);\n        if(m <eps)\n        {\n         \treturn 0.;   \n        }\n        \n        t += d;\n    }\n    \n    return clamp(m,0.,1.);\n}\n\nfloat smoothShadow(in vec3 P,in vec3 LPos)\n{\n    vec3 l = LPos - P;\n    float llen = length(l);\n    vec3 L = l/llen;\n   \n    \n    \n    float m = 1.;\n     float startDist;\n    int startIndex;\n    closest(P,startIndex,startDist);\n    \n    \n    float endRadius;\n    closest(LPos,startIndex,endRadius);\n    for(int i = 1; i <= shadowSteps; i++)\n    {\n        float stepsize = float(i)/float(shadowSteps);\n        \n        float len = stepsize*stepsize*llen;\n        \n        vec3 pos = P + len*L;\n        \n        //len = len + startDist;\n        int ind;\n        float d = 0.;\n        \n        closest(pos,ind,d);\n        \n        float radius = endRadius*len/llen;\n        m = min(max(d/radius,0.),m);\n    }\n    \n    return clamp(1.5*m,0.,1.);\n}\n\n\nfloat ao(in vec3 P, in vec3 N)\n{\n \t  const int steps = 6;\n    \n    float delta = 0.05;\n    float k = 4.;\n    \n    float startDist;\n    int startIndex;\n    closest(P,startIndex,startDist);\n    \n    float occl = 0.;\n   \tfor(int i = 1; i <= steps;i++)\n    {\n        \n     \t vec3 pos = P +  delta*float(i)*N;\n         int index;\n         float d;\n        \n        closest(pos,index,d);\n        float realDist = delta*float(i)+ startDist;\n        \n        occl += abs((realDist - d)/pow(2.,float(i)));\n        \n        \n        \n    }\n    \n    return clamp(1.0-k*occl,0.,1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n\tvec2 camRes = vec2(2.,2.*iResolution.y/iResolution.x);\n    float focal = 1.;\n    \n    vec3 eye = vec3(6.,2.,0.);\n    //eye += vec3(sin(2.*pi/10.*iTime),0.,cos(2.*pi/10.*iTime))*0.5;\n    // Better camera thanks to stb\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5/iResolution.xy) : iMouse.xy/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    vec3 center = vec3(0.,2.,0.);\n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 right = cross(dir,up);\n    \n    vec3 p = eye + focal*dir - right*camRes.x/2.0 - up*camRes.y/2.0 + uv.x*camRes.x*right + uv.y*camRes.y*up;\n    \n    \n    vec3 rayDir = normalize(p-eye);\n    \n    vec3 LPos = vec3(1.,2.,0.);\n    LPos += vec3(0.,sin(2.*pi/10.*iTime),0.)*1.5;\n   \tvec3 col;\n    float t;\n    int steps;\n    float d;\n    int index;\n    vec3 N;\n    \n    trace(p,rayDir,t,d,steps,col,index,N);\n    \n    vec3 P = p + t*rayDir;\n    N = normal(P,index);\n    col = color(P,index);\n    \n    col *= ao(P,N);\n    col *= smoothShadow2(P,LPos);\n    col = shade(P,N,col,LPos,index);\n    if(useSimpleIndirect)\n    \tcol += indirectSimple(P, index, LPos, N);\n    else\n        col += indirect(P, index, LPos, N);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}