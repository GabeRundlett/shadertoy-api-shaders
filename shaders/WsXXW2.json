{
    "Shader": {
        "info": {
            "date": "1552154398",
            "description": "Should be watched in fullscreen. The attenuation of two points is visualized with circles and differently size grids. ",
            "flags": 32,
            "hasliked": 0,
            "id": "WsXXW2",
            "likes": 19,
            "name": "Subdivided grid - forked",
            "published": 3,
            "tags": [
                "2d",
                "circles",
                "lines",
                "subdivision"
            ],
            "usePreview": 0,
            "username": "alvarobyrne",
            "viewed": 643
        },
        "renderpass": [
            {
                "code": "// Fork of \"Subdivided grid\" by quisten. https://shadertoy.com/view/4s3Xzf\n// 2019-03-09 17:55:04\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nfloat time = iTime+10.0;\nvec2 screenRatio =vec2(1.0, iResolution.y/iResolution.x); \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = vec4(1.0,0,0,1);\n    fragColor = texture(iChannel0, uv);\n    \n    // distort \n    float stepSize = 0.017; \n    float dist = pow(length(uv-.5)*.5, 2.0);\n    vec2 dir = normalize(uv-.5);\n    vec4 p = texture(iChannel0, uv);\n    p.r += texture( iChannel0, uv-dir*dist*stepSize ).r;\n    p.g += texture( iChannel0, uv-dir*dist*stepSize*2.0 ).g;\n    p.b += texture( iChannel0, uv-dir*dist*stepSize*3.0 ).b;\n    p.rg += texture( iChannel0, uv-dir*dist*stepSize*1.5 ).rg;\n    p.gb += texture( iChannel0, uv-dir*dist*stepSize*2.5 ).gb;\n\tp.rgb /= vec3(3,4,3);\n    \n    fragColor = p;\n    \n    //fragColor = vec4(1.0);\n#if 1 //finishing touches    \n\t\n    float v = 1.0-length(uv-.5); \n    float vv = 1.0*pow(v*.95+.05*rand(uv+time), 1.15);\n    fragColor *= vec4(vv);\t\t\t\t\t\t          // vignetting\n    fragColor = sqrt(fragColor);\t\t\t\t\t      // gamma correction\n #endif \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float pi = 3.14159265; \nfloat sFactor = .50;\nfloat sFactor2 = .570;\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotateXY(vec2 uv, float r)\n{\n    float s = sin(r);\n    float c = cos(r);\n    return vec2(uv.x*c + uv.y*s, uv.y*c-uv.x*s);\n}\n\n\nfloat dots(vec2 uv, float s)\n{\n    \n\tfloat scale = 2.0*80.0;\n    float spacing = 2.0;\n    float dotSize = .70;\n \n    float dotPattern = 0.0;\n    float d1 = sqrt(length(mod((uv)*scale, spacing)-(spacing/2.0))); \n    float d2 = sqrt(length(mod((uv-vec2(0.0125, .0125))*scale, spacing)-(spacing/2.0)));\n\n    float aaDotSize = 1.0-1.0*s; \n    dotPattern = 2.0*pow(max(0.0, (1.0-d1)-aaDotSize), .20);\n    dotPattern += 2.0*pow(max(0.0, (1.0-d1)-(aaDotSize+aaDotSize*.2)), .30);\n    dotPattern = 2.0*pow(max(0.0, (1.0-d2)-aaDotSize), .20);\n    dotPattern += 2.0*pow(max(0.0, (1.0-d2)-(aaDotSize+aaDotSize*.2)), .30);\n    \n    return dotPattern;\n}\n\nfloat lines(vec2 uv, float s)\n{\n    vec2 puv2 = uv*2.0;\n    float scale = 20.0*2.0*pi;\n    float glowFactor = 30.0; \n\n    float lineWidth = 1.95*s*s;\n    float lineX = abs(sin((puv2.x+puv2.y)*scale));\n    float lineY = abs(sin((-puv2.x+puv2.y)*scale));\n    float linePattern = max(.0, 99.0*max(lineWidth-lineX,lineWidth-lineY));\n    \n   lineWidth *= 1.5;\n   linePattern += glowFactor*pow(max(0.0, 1.0*max(max(0.0, lineWidth-lineX), max(0.0,lineWidth-lineY))), 2.0);\n    \n    return linePattern;//-.9; \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat time = iTime+10.0;\nvec2 screenRatio =vec2(1.0, iResolution.y/iResolution.x); \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = uv*vec2(1.0, iResolution.y/iResolution.x);\n    vec2 uv3 = uv*vec2(1.0, iResolution.y/iResolution.x);\n   \n    // Background\n    fragColor = vec4(.25*uv.y);\n    fragColor +=  0.4*vec4(max(0.0, 1.0-length((uv-vec2(0.0,.75))-.5)));\n    \n    // Tweak UVs\n    uv2 -= .5*screenRatio;\n    float l = pow(length(uv2), 2.0);\n    //uv2 = rotateXY(uv2, .04*sin(time*length(uv-vec2(rand(vec2(1.0))))*.04-time));\n    //uv2 = rotateXY(uv2, .04*sin(time*length(uv-vec2(rand(vec2(4.0))))*.04-time*.5));\n    //uv2 = rotateXY(uv2, .04*sin(time*length(uv.yx-vec2(rand(vec2(8.0))))*.04-time*1.5));\n  \n    \n    //uv2 = rotateXY(uv2, .5*sin(time*.1));\n      //uv2 = rotateXY(uv2, pi/4.0);\n  \n  //  uv2 *= 1.0+1.0*(sin(time*.1));\n    uv2 += .5*screenRatio;\n    \n    // Create 'Scale' Field\n    float scaleSeed = fract(time*sFactor)-(time*sFactor); \n    float scaleSeed2 = fract(time*sFactor2)-(time*sFactor2);\n    float scaleField = length(uv2-1.0*screenRatio*vec2(rand(vec2(scaleSeed)),rand(vec2(scaleSeed*23.0))));\n    float scaleField2 = length(uv2-1.0*screenRatio*vec2(rand(vec2(scaleSeed2+34.32)),rand(vec2(.23+scaleSeed2*23.0))));\n    scaleField = pow(1.0-scaleField*.60, 8.5);\n    scaleField *= abs(sin(time*sFactor*pi*1.0)); \n    scaleField2 = pow(1.0-scaleField2*.260, 8.5);\n    scaleField2 *= abs(sin(time*sFactor2*pi*1.0));\n \tscaleField = clamp(1.0, 0.0, scaleField+scaleField2);\n    \n    //\n    //scaleField = pow(abs(sin(5.0*(uv2.y-pi*fract(time*sFactor*.4)))), 5.0);\n   // scaleField = max(0.0, 1.0-((2.0*fract(time*sFactor)-uv2.x)));\n  \n   // scaleField *= 1.0*abs(sin(uv2.x*pi));\n    \n    // Patterns\n    float patterns = 0.0;\n    uv3 = uv2;\n    patterns += dots(uv3, pow(scaleField, 2.5))*max(pow(scaleField, 2.5), 0.1);\n    patterns += .2*lines(uv3, .4*pow(scaleField, 1.7))*max(pow(scaleField,1.7), 0.1);\n    patterns += .2*lines(uv3*.25, .2*pow(scaleField, 1.0))*max(scaleField, 0.1);\n    patterns += .2*lines(uv3*.25/4.0, .2*pow(scaleField, .8))*max(scaleField, 0.1);\n    \n    fragColor = vec4(clamp(1.0, 0.0, patterns));\n \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}