{
    "Shader": {
        "info": {
            "date": "1623587776",
            "description": "test of importance sampling of any hdr environnement map",
            "flags": 32,
            "hasliked": 0,
            "id": "NssSW2",
            "likes": 3,
            "name": "Importance sampling test",
            "published": 3,
            "tags": [
                "pathtracing",
                "importancesampling"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 406
        },
        "renderpass": [
            {
                "code": "#define noiseFilter\n#define Kernel 6\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n#ifdef noiseFilter\n    float sigma = 3.0;\n    float kernel[Kernel*2+1];\n    for (int j = 0; j <= Kernel; ++j)\n    {\n        kernel[Kernel+j] = kernel[Kernel-j] = normpdf(float(j), sigma);\n    }\n\n    vec4 data = texture(iChannel1, uv);\n    vec3 n0 = data.xyz;\n    float depth0 = data.w;\n    float z = 0.0;\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    vec3 p0 = camPos + depth0 * rd;\n    \n    for(int i = - Kernel; i <= Kernel; i++){\n        for(int j = - Kernel; j <= Kernel; j++){\n            vec2 uv2 =  uv + vec2(i, j)/iResolution.xy;\n            data = texture(iChannel1,uv2);\n            vec3 n = data.xyz;\n            float depth = data.w;\n            \n            rd = normalize(dir0 + right*uv.x + up*uv.y);\n            vec3 p = camPos + depth * rd;\n            //same normal, on the same plane and not to far away\n            if (dot(n, n0)>0.95 \n                && abs(dot(n0, p - p0)) < 0.09\n                && dot(p-p0, p-p0)<max(0.02, 0.02*depth0)){\n                \n                col += kernel[Kernel+j]*kernel[Kernel+i]*texture(iChannel0, uv2).rgb;\n                z += kernel[Kernel+j]*kernel[Kernel+i];\n            }\n        }\n     }\n     col /= z;\n     if (depth0 == -1.0) col = texture(iChannel0, uv).rgb;\n    \n    col = 1.0-exp(-0.5*col); \n    \n#else\n    col = texture(iChannel0, uv).xyz;\n    \n    col = 1.0-exp(-0.5*col); \n    col = pow(col, vec3(0.7)); \n#endif\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//where all the stuff append\n\n#define MAXDEPTH 8\n\n\nstruct Mat{vec3 c, e;}; //color, emission\n\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x) + uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nvec4 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z);\n    if(dot(n, v) < 0.0) return vec4(-v, 1.0);\n    return vec4(v, 1.0);\n}\n\nvec4 newDirImpSamp(vec3 n){\n     //dichotomie\n    float total = texture(iChannel2, vec2(1.0, 1.0/float(downSample))).x*2.0;\n    float goal = random();\n    float y, val;\n    vec2 data;\n    float Min = 0.0;\n    float Max = 1.0;\n    for(int i = 0; i < 1024; i++){\n      float Mid = 0.5*(Min+Max);\n      vec2 data = texture(iChannel2, vec2(1.0, Mid/float(downSample))).xy;\n      val = data.x/total;\n      if(abs(val - goal) < 0.008){y = Mid; break;}\n      (val < goal) ? Min = Mid : Max = Mid;\n      \n    }\n    \n    float weightY = data.y/total;\n    \n    //ont the x-axis at position y\n    data = texture(iChannel2, vec2(1.0, y)/float(downSample)).xy;\n    total = data.x*2.0;\n    goal = random();\n    float x;\n    Min = 0.0;\n    Max = 1.0;\n    for(int i = 0; i < 1024; i++){\n      float Mid = 0.5*(Min+Max);\n      data = texture(iChannel2, vec2(Mid, y)/float(downSample)).xy;\n      val = data.x/total;\n      if(abs(val - goal) < 0.008){x = Mid; break;}\n      (val < goal) ? Min = Mid : Max = Mid;\n    }\n    float weightX = data.y/total;\n    \n    \n    float teta = x*2.0*PI;\n    float z = y*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), z, sqrt(1.0-z*z)*sin(teta));\n    if(dot(v, n) < 0.0)return newDir(n);\n    \n    float weightF = float(downSample*downSample)/(iResolution.x*iResolution.y);\n    float weightG = weightX*weightY + 0.0001;\n    float weight = weightF / weightG;\n    return vec4(v, weight);\n\n}\n\nfloat intersect(vec3 ro, vec3 rd, out Mat obj, out vec3 n){\n\n    float t = 1e7;\n    obj = Mat(vec3(0.9), vec3(0.0));\n    for(int i = 0; i < NUMBOX; i++){\n        Box B = boxs[i];\n        float t2 = box(ro, rd, B).x;\n        \n        if( t2 > 0.0 && t2 < t){\n            t = t2;\n            n = normal(ro + t*rd, B);\n            \n            if(i==3)obj = Mat(vec3(0.0, 0.9, 0.0), vec3(0.0));\n            if(i==9)obj = Mat(vec3(0.9, 0.0, 0.0), vec3(0.0));\n            if(i==11)obj = Mat(vec3(0.9, 0.9, 0.1), vec3(0.0));\n            if(i!=3 && i!=9 && i!= 11)obj = Mat(vec3(0.9), vec3(0.0));\n        }\n        \n        \n    }\n    if(t > 1e6){ obj = Mat(vec3(0.0), texture(iChannel1, rd).xyz);return -1.0;}\n    return t;\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd){\n\tvec3 col = vec3(0.0);\n\tvec3 mask = vec3(1.0);\n    vec3 n;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tMat obj;\n        float t = intersect(ro, rd, obj, n);\n        \n\t\tro = ro + t * rd;\n#ifdef ImportanceSampling\n        vec4 new = newDirImpSamp(n);\n#else\n\t\tvec4 new = newDir(n);\n#endif\n        rd = new.xyz;\n\t\tcol += mask * obj.e * new.w;\n\t\tmask *= obj.c * new.w;\n        \n        if(t<=0.0)break; // dont intersect anything\n        if (dot(mask, mask)<0.000001)break; // have absorbed to much light that the ray is useless\n\n\t}\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initBoxs();\n    initRandomGenerator(fragCoord);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    \n    vec3 col = march(camPos, rd);\n    \n    //mix with previous frames\n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float weight = 1.0/float(max(0, iFrame - frameDelay - 5) + 1);\n    col = mix(last, col, weight);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n//the nevironnement map with just a sun and a blue sky\n//you can add as many light here with any shape\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3, 0.7, 1.0)*4.9; //sky color\n    \n    vec3 sunColor = vec3(0.9764, 0.8058, 0.641);\n    vec3 sunDir = normalize(vec3(-0.2, 0.2, 1.0));\n    if(dot(sunDir, rd) > 0.999) col = sunColor*vec3(700.0); //small but powerful sun\n    col += sunColor*50.0*pow(0.5 + 0.5*dot(sunDir, rd), 200.0);\n    col += sunColor*pow(0.5 + 0.5*dot(sunDir, rd), 8.0);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/float(downSample);\n    vec3 col = vec3(0.5);\n    \n    // if all the work is already done\n    if(iFrame - frameDelay > 5){\n        col = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    //get the values from the cube map\n    if(iFrame - frameDelay < 4 && all(lessThanEqual(fragCoord, res))){\n        vec2 uv = fragCoord/res;\n\n        float teta = uv.x*2.0*PI;\n        float z = uv.y*2.0-1.0;\n        vec3 rd = vec3(sqrt(1.0-z*z)*cos(teta), z, sqrt(1.0-z*z)*sin(teta));\n        col = textureLod(iChannel0, rd, log2(float(downSample))).rgb;\n        col = vec3((col.r + col.g + col.b)/3.0);\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    //sum the row values\n    if(iFrame - frameDelay == 4){  // initialisation with delay if some frames are skip\n        if(all(lessThanEqual(fragCoord, res))){\n            vec2 invRes = 1.0/res;\n            vec2 uv = fragCoord/res;\n            col = texture(iChannel1, uv/float(downSample)).xyz;\n            col.x = 0.0;\n            for(int i = 0; i < 8000; i++){\n                if(uv.x < 0.0) break;\n                col.x += texture(iChannel1, uv/float(downSample)).x;\n                uv.x -= invRes.x;\n            }  \n        }\n        if(fragCoord.y <= res.y && fragCoord.x > iResolution.x - 3.0){\n            vec2 invRes = 1.0/res;\n            vec2 uv = vec2(1.0, fragCoord.y/res.y);\n            for(int i = 0; i < 8000; i++){\n                if(uv.x < 0.0) break;\n                col += texture(iChannel1, uv/float(downSample)).xyz;\n                uv.x -= invRes.x;\n            }  \n            \n        }\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    //sum the values of the final column\n    if(iFrame - frameDelay == 5 && fragCoord.y <= res.y && fragCoord.x > iResolution.x - 3.0){\n        vec2 invRes = 1.0/res;\n        vec2 uv = vec2(1.0, fragCoord.y/res.y);\n        col = texture(iChannel1, uv/vec2(1.0, float(downSample))).xyz;\n        col.x = 0.0;\n        for(int i = 0; i < 8000; i++){\n            if(uv.y < 0.0) break;\n            col.x += texture(iChannel1, uv/vec2(1.0, float(downSample))).x;\n            uv.y -= invRes.y;\n        }\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    col = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159265359\n\n#define downSample 2   // error due to float numbers; better with 2, and 6 if you go full screen\n#define frameDelay 0\n\n//comment here to try without importance sampling\n#define ImportanceSampling\n\n\n#define NUMBOX 14\nstruct Box{vec3 up, down;};\nBox[NUMBOX] boxs;\n\n\nconst vec3 camPos = vec3(0.5, 1.0, -1.8)*0.8;\nconst vec3 target = vec3(0.0, 0.0, 0.0);\n\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid initBoxs(){\n    seed = 34267554u;\n    for(int idx = 0; idx < NUMBOX - 1; idx++){\n        vec3 a = vec3(random(), random(), random());\n        vec3 b = vec3(random(), random(), random());\n        a = 2.0*a - 1.0;\n        b = 2.0*b - 1.0;\n        vec3 s = vec3(1.1);\n        a *= s; b *= s;\n        boxs[idx] = Box(max(a, b), min(a, b));\n    }\n    boxs[NUMBOX - 1] = Box(vec3(10.0, -0.95, 10.0), vec3(-10.0, -1.0, -10.0));\n}\n/////////////////////////////////////////////////////////////////////////\n\nvec2 box(vec3 ro, vec3 rd, Box AABB){\n        vec3 down = AABB.down;\n        vec3 up = AABB.up;\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (down.x - ro.x)*dirfrac.x;\n        float t2 = (up.x - ro.x)*dirfrac.x;\n        float t3 = (down.y - ro.y)*dirfrac.y;\n        float t4 = (up.y - ro.y)*dirfrac.y;\n        float t5 = (down.z - ro.z)*dirfrac.z;\n        float t6 = (up.z - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\n\nvec3 normal(vec3 pos, Box b){\n    pos -= 0.5*(b.up + b.down);\n    pos /= 0.5*abs(b.up - b.down);\n    vec3 n = vec3(0.0);\n    if(abs(pos.x)>0.995){n.x = pos.x;}\n    if(abs(pos.y)>0.995){n.y = pos.y;}\n    if(abs(pos.z)>0.995){n.z = pos.z;}\n    n = normalize(n);\n    return n;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//get normal information and depth info\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 n){\n\n    float t = 1e7;\n    for(int i = 0; i < NUMBOX; i++){\n        Box B = boxs[i];\n        float t2 = box(ro, rd, B).x;\n        \n        if( t2 > 0.0 && t2 < t){\n            t = t2;\n            n = normal(ro + t*rd, B);\n        }\n        \n        \n    }\n    if(t > 1e6) return -1.0;\n    return t;\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd){\n    vec3 n;\n    float t = intersect(ro, rd, n);\n    return vec4(n, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame - frameDelay > 3){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initBoxs();\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    \n    fragColor = march(camPos, rd);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}