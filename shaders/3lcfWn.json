{
    "Shader": {
        "info": {
            "date": "1612475777",
            "description": "pot",
            "flags": 32,
            "hasliked": 0,
            "id": "3lcfWn",
            "likes": 23,
            "name": "Day 415",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "// http://roy.red/infinite-regression-.html#infinite-regression\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),iResolution.xy/4.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,iResolution.xy/4.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.7,1.1,1.5));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.5545 - n*0.15));\n    \n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.4;\n    \n    \n    fragColor.xyz += n*0.15;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\n\n#define pmod(p,a) mod(p - 0.5*(a),(a)) - 0.5*(a)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(0.5);\n    float amp = 1.;\n    float gain = 0.9 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp = 2.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*(1.4 - 0.4*smoothstep(0.5,1.,iTime-2.));\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 uvuv = uv;\n    float a = 0.;\n    \n    \n    \n    \n    float s = 4.;\n    vec2 offs = vec2(0);\n    \n    \n    float t = iTime*0.1;\n    t = 35.*0.1 - t;    \n        \n    float unenv = smoothstep(1.,0.9,mod(t/2., 2.));\n    unenv = 1.;\n    unenv *= 1.- smoothstep(0.8,1.,t - 2.);\n    \n    if(iMouse.z < 1.){\n    \n        //float id\n        float side = mod(floor(t/2.), 2.)*2. - 1.;\n        //t = mod(t,4.);\n        side = sign(-1.);\n        \n        offs = vec2(\n            0. + side*smoothstep(0.,0.1,t/1.-1.)*s + 0.,0. + sin(iTime)*0.00001\n        );\n    } else {\n        offs = vec2(\n            0. + muv.x*s,0. + muv.y*s*iResolution.x/iResolution.y\n        );\n    }\n    \n    \n    float zoomAmt = 0.95;\n    \n    \n    float zoomA = mix( 0., 1., abs(offs.x)/s);\n    float zoomB = smoothstep(0.,0.8,t - 1.)*(1.-zoomAmt)*0.999;\n    \n    zoomB *= zoomA;\n    zoomA *= zoomAmt;\n    \n    \n    if(iMouse.z < 1.){\n        zoomA *= unenv;\n        zoomB *= unenv;\n        offs *= unenv;\n    }\n    \n    \n    //*zoomAmt\n    float zoom = 6.*(1. - \n            + zoomA\n            - zoomB) + sin(iTime)*0. - 0.;\n    \n    \n    uv *= zoom;\n    \n    uv += offs;\n    \n    \n    \n    //uv = pmod(uv,0.76);\n    \n    \n    \n    \n    vec2 ouv = uv;\n    \n    uv.x = abs(uv.x);\n    \n    float scale = 1./pow(2., floor(log2(\n            abs(\n                max(\n                (mod(abs(uv.x),8.)) - 4.,\n                (mod(abs(uv.y),8.)) - 4.\n                )\n            )\n        )) );\n    \n    \n    vec2 id = floor(uv*scale);\n    vec2 fuv = fract(uv*scale);\n    \n    \n    fuv = abs(fuv - 0.5) - 0.5;\n    float d = abs(fuv.x);\n    \n    d = min(d,abs(fuv.y));\n    \n    d /= scale;\n    \n    float n = cyclicNoise(vec3(uvuv,floor(iTime*10.))*(51.), false, 0.); \n    \n    //d -= n*0.0001/dFdx(ouv.x);\n    d -= n*dFdx(ouv.x)*1.;\n    \n    \n    \n    if(iFrame > 2){\n        //vec2 uv = fragCoord/iResolution.xy;\n        vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n        //uv -= scale*0.1;\n        //uv -= 0.5;\n        uv -= id/scale - offs;\n        uv*=rot(0.3 + iTime*0.02 + id.x + sin(id.y));\n        \n        uv += id/scale - offs;\n        \n        uv *= iResolution.y;\n        uv += 0.5*iResolution.xy;\n        uv /= iResolution.xy;\n        //uv += 0.5;\n        fragColor.xyz =texture(iChannel0,uv).xyz*0.5;\n    } else {\n        fragColor.xyz -= fragColor.xyz ;\n    }\n    \n    fragColor.xyz = mix( fragColor.xyz,vec3(1.),smoothstep(dFdx(ouv.x),0.,d - 0.0));\n    \n    n = cyclicNoise(vec3(uvuv,4.)*140., false, 0.); \n    \n    d = abs(abs(uvuv.x) - iResolution.x/iResolution.y*0.5) - n*0.005;\n    \n    d = min(d,abs(abs(uvuv.y) - 0.5) - n*0.005);\n    \n    fragColor.xyz = mix( fragColor.xyz,vec3(1.),smoothstep(dFdx(uvuv.x),0.,d ));\n    \n    \n    \n    \n    \n    \n    \n    //fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}