{
    "Shader": {
        "info": {
            "date": "1501423062",
            "description": "No harder than making shader.",
            "flags": 0,
            "hasliked": 0,
            "id": "ld2fzV",
            "likes": 19,
            "name": "[SH17C]Make Atomic Bomb",
            "published": 3,
            "tags": [
                "bomb",
                "sh17c",
                "atoms"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 1138
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// It take several seconds to compile,\n// so I put more time for the first frame.\n\n\n#define GR 1.618\nfloat time;\n#define PI 3.14159265\n\n// font texture sampling from gPlatl: https://www.shadertoy.com/view/MtySzd\n#define FONT_SPACE 0.5\n#define S(a) col+=text(float(a), p); p.x-=FONT_SPACE;\n#define _left S(16);\n#define _up S(17);\n#define _right S(18);\n#define _down S(19);\n#define _left_top S(22);\n#define _right_top S(23);\n#define _right_bot S(24);\n#define _left_bot S(25);\n#define _note  S(10);\n#define _star  S(28);\n#define _smily S(29);\n#define _    S(32);\n#define _dash S(45);\n#define _exc S(33);\n#define _add S(43);\n#define _dot S(46);\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n\n\n#define SCENE_0 6.\n#define SCENE_1 11.\n#define SCENE_2 14.\n#define SCENE_3 17.\n#define SCENE_4 20.\n#define SCENE_5 24.\n#define SCENE_6 30.\n#define SCENE_7 33.\n#define SCENE_8 60.\n\n#define BOMB_ROT_SPEED 0.2\n\nvec2 rot2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n\nvoid ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n} \nvoid rx(inout vec3 p, float a)\n{\n    float c,s;vec3 q=p;\n    c = cos(a); s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nfloat rbox(vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nvec2 merge(vec2 d0, vec2 d1)\n{\n    if(d0.x < d1.x) return d0;\n    else return d1;\n}\n\nvec2 smerge(vec2 d0, vec2 d1, float k)\n{\n    vec2 res = merge(d0,d1);\n    return vec2(smin(d0.x,d1.x,k),res.y);\n}\n\n// Based on mplanck's \"Bubble Buckey Balls\":  https://www.shadertoy.com/view/lslSRf\nvec2 u235(vec3 p, float scale)\n{    \n    float r=0.4*scale;\n    p.xy=rot2(p.xy,0.6);\n    p.yz=rot2(p.yz,0.5);\n    vec2 d = vec2(1000., 0.);\n    vec3 ap = abs(p);\n    vec3 p1 = scale*vec3(         .66, .33+.66 * GR,   .33 * GR);\n    vec3 p2 = scale*vec3(         .33, .66+.33 * GR,   .66 * GR);\n    vec3 p3 = scale*vec3(    .33 * GR,          .66, .33+.66*GR);\n    vec3 p4 = scale*vec3(    .66 * GR,          .33, .66+.33*GR);\n    vec3 p5 = scale*vec3(.33+.66 * GR,     .33 * GR,        .66);\n    vec3 p6 = scale*vec3(.66+.33 * GR,     .66 * GR,        .33);\n    vec3 p7 = (p1+p2+p3+p4+p5+p6)/6.;\n\tvec3 p8 = scale*vec3(1.5,0.,0.);\n    vec3 p9 = scale*vec3(0.,1.5,0.);\n\tvec3 p10 = scale*vec3(0.,0.,1.5);\n\n\td=merge(d, vec2(sphere(ap-p1,r), 0.));\n   \td=merge(d, vec2(sphere(ap-p2,r), 1.));\n\td=merge(d, vec2(sphere(ap-p3,r), 0.));\n\td=merge(d, vec2(sphere(ap-p4,r), 1.));\n\td=merge(d, vec2(sphere(ap-p5,r), 0.));\n\td=merge(d, vec2(sphere(ap-p6,r), 1.));\n\td=merge(d, vec2(sphere(ap-p7,r), 0.));\n\td=merge(d, vec2(sphere(ap-p8,r), 1.));\n\td=merge(d, vec2(sphere(ap-p9,r), 0.));\n\td=merge(d, vec2(sphere(ap-p10,r),1.));\n\n    \n    return d;\n}\n\nvec2 neutron(vec3 p)\n{\n    return vec2(sphere(p, 0.2), 1.);\n}\n\nvec2 plane(vec3 p, float y)\n{\n    return vec2(abs(p.y+y), 4.);\n}\n\nvec2 screw(vec3 p)\n{\n    float d0 = cylinder(p.xyz+vec3(0.08,0.0,0.0), vec2(.035, .46));\n    p.xz=rot2(p.xz,-0.5);\n    float d1 = box(p.xyz+vec3(0.07,0.0,-0.04), vec3(0.012,1.,0.033));\n    float d = max(d0,-d1);\n    return vec2(d, 0.);\n}\n\nvec2 atomic_bomb(vec3 p)\n{\n    vec3 pos = p;\n    // It was iq's watermelon:  https://www.shadertoy.com/view/ldl3zl\n    vec3 c = p;\n    float r = 2.0 - 0.007*sin(10.0*(-c.x+c.y-c.z));\n    vec2 d0 = vec2(0.65*(length(3.0*c*vec3(1.,1.5,1.5)) - r)/3.0, 3.0);\n    \n    vec3 q = vec3(p.x,abs(p.y)-.22,abs(p.z)-.22);\n    q.yz=rot2(q.yz,-0.5);\n    vec2 d1 = vec2(box(q+vec3(0.55,0.,0.), vec3(0.22,0.1,0.01)),1.);\n    \n    float t1 = cylinder(vec3(p.z+0.,p.x+.8, p.y), vec2(.2, .09));\n    float t2 = cylinder(vec3(p.z,p.x+.8, p.y), vec2(.18,.15)); \n    vec2 d2 = vec2(max(t1,-t2), 3.0);\n    \n    p.x+=.7;\n    t1 = cylinder(p.zxy, vec2(.45, .19));\n    t2 = cylinder(p.zxy, vec2(.42, .21));\n    rx(p,0.785);\n    q = vec3(p.x+.1, abs(p.y)-.26, abs(p.z)-.26);\n    q.yz=rot2(q.yz,0.785);\n    float t3 = box(q, vec3(0.1,0.12+0.02*sin(10.*-q.x),0.15));\n    float t = max(t1,-t2);\n    t = smax(t, -t3, 0.1);\n    vec2 d3 = vec2(t, 3.0);\n    \n    p=pos;\n    vec2 d4 = vec2(cylinder(p.yxz+vec3(0.,-0.1,0.), \n                            vec2(.46-0.02*sin(10.*p.x), .07)), 1.);\n    vec2 d5 = vec2(cylinder(p.yxz+vec3(0.,0.2,0.), \n                            vec2(.41-0.04*sin(10.*p.x), .04)), 3.);\n    \n    rx(p,-0.5);\n    vec2 d6 = screw(p);\n    vec2 d7 = screw(p.xzy);\n    \n    vec2 d = d0;\n    d=smerge(d,d4,.07);\n    d=smerge(d,d5,.06);\n    d=merge(d,d6);\n    d=merge(d,d7);\n   \td=merge(d,d1);\n    d=merge(d,d2);\n    d=merge(d,d3);\n    return d;\n}\n\nint get_scene_id()\n{\n    int id;\n    \n\tif(time < SCENE_0)id= 0;\n    else if(time < SCENE_1)id= 3;  \n    else if(time < SCENE_2)id= 4;\n    else if(time < SCENE_3)id= 5;\n    else if(time < SCENE_4)id= 6;\t\n    else if(time < SCENE_5)id= 1;\n    else if(time < SCENE_6)id= 7;\n    else if(time < SCENE_7)id= 2;\n    else if(time < SCENE_8)id= 8;\n                     \n    return id;\n}\n\nfloat get_scene_time(int id)\n{\n    float t;\n    if(id==0)t=SCENE_0;\n    else if(id==1)t=SCENE_5;\n    else if(id==2)t=SCENE_7;\n    else if(id==3)t=SCENE_1;\n    else if(id==4)t=SCENE_2;\n    else if(id==5)t=SCENE_3;\n    else if(id==6)t=SCENE_4;\n    else if(id==7)t=SCENE_6;\n    else if(id==8)t=SCENE_8;\n\treturn t;\n}\n\nvec2 design(vec3 p)\n{\n    float d0 = sphere(p, 1.);\n    float d1 = box(p+vec3(-1.,-1.,1.)*.5, vec3(.6));\n    float d2 = sphere(p, 0.2);\n    float d = d0;\n    float mid = 5.;\n    \n    d = max(d, -d1);\n    \n    if(d > d2)\n    {\n        d=d2;\n        mid=2.;\n    }\n    \n    return vec2(d, mid);\n}\n\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(1000.,0.);\n    vec3 p0 = vec3(1.7,0.,0.);\n    vec3 p1 = vec3(-2.,2.,0.);\n    vec3 p2 = vec3(-2.,-2.,0.);\n    vec3 p3 = vec3(5.5,0.0,0.);\n        \n   \tint id = get_scene_id();\n   \n    // I have to calculate time here or the scene will magically stop\n    // somewhere after several rewinds/compilations\n  \tif(time>SCENE_0&&time<SCENE_1 || time>SCENE_1&&time<SCENE_2)\n    {\n        vec2 d0 = u235(p+p0,.5);\n        vec2 d1 = u235(p+p1,.5);\n        vec2 d2 = u235(p+p2,.5);\n        \n        float t = id==4 ? time - SCENE_1 : 0.;\n       \tvec2 d3 = neutron(p+p3+vec3(-t,0.0,0.0));\n        d = merge(d0, d1);\n        d = merge(d, d2);\n        d = merge(d, d3);\n    }\n    else if(id==5)\n    {\n        float t=time-SCENE_2;\n        vec2 d0 = u235(p+p0+vec3(-t*0.6,t*1.6,0.),.25);\n        vec2 d1 = u235(p+p0+vec3(-t*0.6,-t*1.6,0.),.25);\n        vec2 d2 = u235(p+p1,.5);\n        vec2 d3 = u235(p+p2,.5);\n\n        vec3 dir4=normalize(p1-p0);\n        vec3 dir5=normalize(p2-p0);\n        vec2 d4 = neutron(p+p0+t*1.1*dir4);\n        vec2 d5 = neutron(p+p0+t*1.1*dir5);\n\n        d = merge(d0, d1);\n        d = merge(d, d2);\n        d = merge(d, d3);\n        d = merge(d, d4);\n        d = merge(d, d5);  \n    }\n    else if(id==6)\n    {\n        float t=time-SCENE_3;\n        vec2 d0 = u235(p+p1+vec3(-t*0.6,t*1.6,0.),.25);\n        vec2 d1 = u235(p+p1+vec3(-t*0.6,-t*1.6,0.),.25);\n        vec2 d2 = u235(p+p2+vec3(-t*0.6,t*1.6,0.),.25);\n        vec2 d3 = u235(p+p2+vec3(-t*0.6,-t*1.6,0.),.25);\n       \n        vec3 dir4=normalize(p1-p0);\n        vec3 dir5=normalize(p2-p0);\n        vec2 d4 = neutron(p+p1+t*dir4);\n        vec2 d5 = neutron(p+p1+t*dir5);\n\t\tvec2 d6 = neutron(p+p2+t*dir4);\n        vec2 d7 = neutron(p+p2+t*dir5);\n        d = merge(d0, d1);\n        d = merge(d, d2);\n        d = merge(d, d3);\n        d = merge(d, d4);\n        d = merge(d, d5); \n        d = merge(d, d6); \n        d = merge(d, d7); \n\n    }\n    else if(id==7)\n    {\n        d=design(p);\n    }\n    else if(id == 8)\n    {\n        vec2 d0 = atomic_bomb(p);\n        vec2 d1 = plane(p, .5);\n        d=merge(d0,d1);\n    }\n\n    return d;\n}\n\nfloat softshadow(vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 1.01;\n\tfloat h = 1.0;\n    for( int i=0; i<22; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.005 ) break;\n        t += 0.03 + h;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.002, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x, \n                          map(p + e.yxy).x-map(p - e.yxy).x,    \n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    vec2 res;\n    float t = 0.01;\n    for(int i = 0; i < 64; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = map(p);\n        if(res.x < 0.002 * t || res.x > 20.)\n            break;\n        t += res.x;\n    }\n    \n    if(res.x > 20.) t = -1.;\n    return vec2(t, res.y);\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nvec4 star(vec2 uv)\n{\n    vec2 fl = vec2(12.0, 14.0);\n    uv = fl + fract(uv+0.5)-0.5;\n    return texture(iChannel0, (uv+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\nfloat text(float ch, vec2 p)\n{\n  \tvec4 f = texture(iChannel0,\n                     clamp(p,0.,1.)/16.+\n                     fract(floor(vec2(ch,15.999-float(ch)/16.))/16.), -100.);\n \treturn f.x;  \n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat direct_light(vec3 p, vec3 lpos, vec3 n, float radius)\n{\n    vec3 ldir = (lpos - p);\n    float r = length(ldir);\n    ldir /= r;\n    float res = 1.;\n    res *= max(0., dot(ldir,  n))/r;\n    return (3.4-p.y)/3.4*res * (1. - smoothstep(0., radius, r));\n}\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 p, vec3 n, float mid, float dist)\n{\n    vec3 l0_pos = vec3(1.,2.,-1.);\n    vec3 l0_dir = normalize(vec3(1.,1.,-1.));\n    vec3 l0_col = vec3(1.);\n    \n    vec3 mc = vec3(1., 1.02, 0.92);\n    int id = get_scene_id();\n   \n    if(mid > 4.)\n    {\n        if(length(p) > 0.5 && length(p)<0.8)\n            mc = vec3(0.0,1.,0.0);\n        else if(length(p)<0.5)\n            mc=vec3(0.8, 0.0, 0.0);\n        else mc=vec3(0.5, 0.5, 0.2);\n           \n    }\n    else if(mid > 3.)\n    {\n        mc=texture(iChannel1, p.xz*0.3).xyz;\n        mc.yz-=vec2(star((p.zx+vec2(.4,.7))).x*1.);\n        mc.yz = max(vec2(0.),mc.yz);\n    }\n    else if(mid > 2.)\n    {\n        mc=1.2*(vec3(0.478,.6,0.478) * texcube(iChannel1, p, n).xyz);\n    }\n    else if(mid > 1.)\n    {\n        mc=vec3(0.,0.3,1.);\n    }\n  \telse if(mid > 0.)\n    {\n        mc=vec3(.6,.3,0.3) * texcube(iChannel1, p, n).xyz;\n    }\n    else\n    {\n        mc=vec3(1.);\n    }\n    float occ = get_ao(p, n);\n    float dif;\n    \n    \n    if(id==8)\n    {\n       dif = 2.*direct_light(p, l0_pos, n, 2.3);\n    }\n    else\n    {\n        dif = 2.*max(0., dot(l0_dir, n));\n    }\n    float bac = max(0., dot(vec3(0.,-1.,0.), n));\n    float bce = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float spe = max(0.0, pow(clamp(dot(l0_dir, reflect(rd, n)), 0.0, 1.0), 32.0));\n\n    float env = 1.;\n    \n    vec3 lin = vec3(0.);\n    \n    lin += 2. * dif * occ ;\n    lin += 1.5 * bac * vec3(1.) * occ;\n    lin += 1.2 * bce * vec3(1.) * occ;\n    lin += 1.3 * env *occ;\n    lin += 2.0* spe * vec3(1.);\n    lin = lin * 0.2 * mc ;\n    return lin;\n}\n    \nvoid camera(inout vec3 ro, inout vec3 rd, in vec2 p)\n{\n    float v = 2.;\n    float fov = 1.5;\n    vec3 look_at;\n    int id=get_scene_id();\n    \n    /*\n    float mx=-iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;\n    */\n    if(id <= 6)\n    {\n        look_at=vec3(0.,0.,v);\n        ro=look_at+vec3(0.,0.,-8.);\n    }\n\n    else if(id ==7)\n    {\n        look_at = vec3(0., 0., 0.);\n\n        ro = look_at + vec3(1., 2., -2.)*0.7;\n    }\n    else if(id==8)\n    {\n        look_at = vec3(0., 0., 0.);\n        ro = look_at + vec3(.6, 2., -2.)*0.7;\n        ro.xz=rot2(ro.xz , sin(time*BOMB_ROT_SPEED)*0.3);\n   \t\t//ro = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n    }\n\n    vec3 f = normalize(look_at - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    rd = normalize(p.x * r + p.y * u + fov * f);\n}\n\nvec3 get_background()\n{\n    vec3 col = vec3(0.);\n    int id = get_scene_id();\n    if(id < 8) col = vec3(0.2,0.5,1.0)*.5;\n    return col;\n}\n\nvec3 prelude(vec2 p)\n{\n    vec2 pos = p;\n    vec3 col = vec3(0.);\n    \n    int id = get_scene_id();\n    \n    if(id == 0)\n    {\n        p=pos*3.+vec2(2.5,0.);\n        _1 _dot _T _h _e _o _r _y\n    }\n    else if(id == 1)\n    {\n        p=pos*3.+vec2(2.5,0.);\n        _2 _dot _D _e _s _i _g _n\n    }\n    else if(id == 2)\n    {\n        p=pos*3.+vec2(3.5,0.);\n        _3 _dot _P _r _o _d _u _c _t _i _z _e\n    }\n    return col;\n}\n\nvec3 text_render(vec2 p)\n{\n    vec2 pos = p;\n    vec3 col = vec3(0.);\n    int id = get_scene_id();\n    \n    if(id == 7)\n    {\n        p=pos*2.5 + vec2(-1.1);\n        _left_bot\n\n        p=pos*7.+vec2(-3.5, -5.3);\n        _E _x _p _l _o _s _i _v _e\n\n        p=pos*2.5 + vec2(-0.6, 1.8);\n        _left_top\n\n        p=pos*7.+vec2(-3., 5.5);\n        _D _i _r _e _c _t _i _n _g _ _C _o _r _e\n\n        p=pos*2.5 + vec2(1.1, -0.2);\n        _right_bot\n\n        p=pos*7.+vec2(9., -3.4);\n        _P _l _u _t _o _n _i _u _m _dash _2 _3 _9\n\n        p=pos*2.5 + vec2(1., 1.);\n        _right_top\n\n        p=pos*7.+vec2(10., 3.6);\n        _N _e _u _t _r _o _n _ _I _n _i _t _i _a _t _o _r\n        \n    }\n    else if(id == 3)\n    {\n        p=pos*2.5+vec2(3.95,1.2);\n        _up\n        \n        p=pos*7.+vec2(11.5,4.);\n        _N _e _u _t _r _o _n\n            \n        p=pos*2.5+vec2(1.6,-.6);\n        _down\n            \n        p=pos*7.+vec2(6., -4.6);\n        _U _r _a _n _i _u _m _dash _2 _3 _5\n    }\n    return col;  \n}\n\n// post processing from Loadus: https://www.shadertoy.com/view/MllSz4\nfloat curve (float value, float amount, float correction) \n{\n\tfloat curve = 1.0; \n    if (value < 0.5)\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    else\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    return pow(curve, correction);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2. * q - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    time = mod(iTime, SCENE_8);\n    vec3 ro, rd;\n\tcamera(ro, rd, p); \n    \n    int id = get_scene_id();\n    \n    \n    vec3 col = get_background();\n    \n    if(id <= 2)\n    {\n       col = prelude(p);\n    }\n    else\n    {\n        vec2 res = intersect(ro, rd);\n\n        if(res.x > -0.5)\n        {\n            vec3 pos = ro + res.x * rd;\n            vec3 n = get_normal(pos);\n\n            col = lighting(ro, rd, pos, n, res.y, res.x);\n            if(id==8)\n        \t\tcol *= 1.0-smoothstep( 2.0,4.0,length(pos.xz-vec2(0.,1.5)) );\n\n            col=mix(col, vec3(0.), 1.0-exp(-0.02*res.x*res.x) );\n\n        }\n\n        col += text_render(p);\n    }\n    \n\n    col=tonemap(col);\n    col = pow(col, vec3(0.45));    \n    col = clamp(col*0.5+0.5*col*col*1.5,0.0,1.0);\n    col=pow(col,vec3(1.1,1.,1.0));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    if(id ==8)\n    {\n        col = vec3(curve(col.r, 3.0, 0.8),\n                   curve(col.g, 2.8, 0.9), \n                   curve(col.b, 1.9, 1.0)); \n    }\n    fragColor.xyz = col;\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}