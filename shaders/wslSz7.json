{
    "Shader": {
        "info": {
            "date": "1551099919",
            "description": "My raymarching hello world\n\nBased on an amazing tutorial by \"The Art of Code\"\nhttps://youtu.be/PGtv-dBi2wE",
            "flags": 32,
            "hasliked": 0,
            "id": "wslSz7",
            "likes": 17,
            "name": "Belly of the Beast",
            "published": 3,
            "tags": [
                "raymarching",
                "blur",
                "texture",
                "fog"
            ],
            "usePreview": 1,
            "username": "tomdns",
            "viewed": 1264
        },
        "renderpass": [
            {
                "code": "// Post process\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // heat distortion\n    float mask = clamp(length(vec2(.5,.5) - uv * 2. + .5) * (2. + .5 * sin(iTime * 2.)), 0.,1.);\n    uv += snoise(uv.xyx * 10. + vec3(0,-iTime * .3,0)) * .007 * (1. - mask);\n   \n    vec2 dir = (uv - vec2(.5,.5));\n  \n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    vec4 og = texture(iChannel0, uv);\n    \n    // radial blur\n    float str = .1;\n    int steps = 64;\n    for (int i = 0; i < steps; i++)\n    {  \n        float j = float(i) / float(steps);\n        color += texture(iChannel0, uv + j * dir * str);\n    }    \n    \n    color /= float(steps);\n    color = mix(color, og, mask);\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define SURF_DIST .01\n#define SPEED iTime*7.\n\n#define saturate(x) clamp(x, 0., 1.)\n#define iGlobalTime iTime\n\n/* Operations */\n// https://iquilezles.org/articles/distfunctions\n\nvec3 OpRepeatXZ(in vec3 p, in vec2 factor)\n{\n\tvec2 tmp = mod(p.xz, factor) - 0.5*factor;\n\treturn vec3(tmp.x, p.y, tmp.y);\n}\n\nvec3 OpRepeatZ(in vec3 p, float f)\n{\n    float t = mod(p.z, f) - .5 * f;\n    return vec3(p.x, p.y, t);\n}\n\nvec3 OpRepeat( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return ( q );\n}\n\nvec3 OpBend(vec3 p)\n{\n    const float k = .1;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return (q);\n}\n\nfloat OpSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat OpSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec4 OpElongate( in vec3 p, in vec3 h )\n{ \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat OpSub( float d1, float d2 ) \n{ \n    return max(-d1,d2); \n}\n\nvec3 RotateX(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x,\n        pos.y * cos(angle) - pos.z * sin(angle),\n        pos.y * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nvec3 GlobalOffset(vec3 p) \n{\n    vec3 pp = p;\n    pp.y += sin(p.z * .05 + iGlobalTime * 5.) * .2;\n    \n\n    return pp;\n}\n\nfloat Spread(vec3 p)\n{\n    p = GlobalOffset(p);\n    return (1. - saturate(distance(p.z, SPEED + cubicOut(saturate(mod(iGlobalTime * .05, .4)) * 50.)) * .13));\n}\n\n/* Primitives */\n\nfloat PrimSphere(vec3 p, float s) \n{\n    return length(p)-s;\n}\n\nfloat PrimCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat PrimTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n/* Scene Objects */\n\nfloat ObjWeb(vec3 p)\n{\n    p = GlobalOffset(p);\n    vec2 repeat = vec2(10.0, 15.0);\n\n    float dist = 1000.;\n    int count = 10;\n    for(int i = 0; i < count; i++) \n    {\n        float j = float(i);\n        float ratio = j / float(count);\n\n        vec3 pos = RotateX(p.zxy + vec3(0,0,-3.), (j / float(count)) * 3.14);\n        float size = .1 + .05 * (sin(iGlobalTime) * .5 + .5);\n        dist = OpSmoothUnion(dist, PrimCylinder(OpRepeatXZ(pos, repeat), vec3(.0, .0, size)), .8);\n    }\n\n    return dist;\n}\n\nfloat ObjTeeth(vec3 p)\n{\n   // p = GlobalOffset(p);\n    \n    vec3 pp = OpRepeatZ(p, 10.);\n    float r = 10.;\n    float height = 2.5;\n    float dist = 10000.;\n    \n    for(int i = 0; i < 6; i++) \n    {\n        r *= .8;\n    \tfloat teeth = PrimTorus(pp.yzx - vec3(height,3.,0.).xyz, vec2(r,1.));\n    \tfloat sub = PrimSphere(pp.yzx - vec3(height + 1.,3.,0.).xyz, r+.5);\n    \tfloat sub2 = PrimSphere(pp.yzx - vec3(height + 11.,3.,0.).xyz, r+4.0);\n    \tfloat sub3 = PrimSphere(pp.yzx - vec3(height + 1.,5.,0.).xyz, r+.9);\n        \n        teeth = OpSub(sub,teeth);\n    \tteeth = OpSub(sub2, teeth);\n    \tteeth = OpSub(sub3, teeth);\n        \n        dist = min(dist, teeth);\n    }\n    \n    return dist;\n}\n\nfloat ObjTunnel(vec3 p)\n{\n    p = GlobalOffset(p);\n\n    vec3 tunnelOffsetShape = vec3(sin(p.x + 5. * pow(sin(iGlobalTime), 2.) * 1.), sin(p.y), sin(p.z)) * .2;\n    tunnelOffsetShape += sin(p.z * 10.) * .01;\n\n    float radius = 8.;\n    radius -= Spread(p) * .5;\n    radius -= snoise(p * .25) * .5;\n    radius -= sin(p.y) * .8;\n    radius -= sin(p.z * .2) * .7;\n\n    float tunnel = PrimTorus(OpElongate(tunnelOffsetShape + p.yzx - vec3(7.,20. + SPEED,0.), vec3(1., 50., 1.)).xyz, vec2(radius,1.));\n\n    return tunnel;\n}\n\nfloat ObjGround(vec3 p)\n{\n    p = GlobalOffset(p);\n    return p.y + .5 + sin(p.z + cos(p.z) + sin(p.z * 10.) * .5) * .2;\n}\n\nfloat Fog(vec3 p, float dist)\n{\n    return ((dist / min(dist, length(p))) - 1.);\n}\n\nfloat Scene(vec3 p) \n{\n    float bump = texture(iChannel1, (p).zy * .1).r * .5;\n    \t  bump *= 1. - saturate(p.y * .5 - 5.); // ceiling mask\n    \n    p.y -= bump;\n    \n    float dist = ObjWeb(p);\n          dist = OpSmoothUnion(dist, ObjGround(p), 2.5);\n          dist = OpSmoothUnion(dist, ObjTunnel((p)), 2.0);\n          //dist = OpSmoothUnion(dist, ObjTeeth(p), .2);\n    \n    return dist;\n}\n\nvec4 Raymarch(vec3 ro, vec3 rd, out float emission) \n{\n\tfloat dO=0.;\n    vec3 color = vec3(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        float dS = Scene(p);\n        dO += dS;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n\n        float tunnel = 1. - saturate(abs(dS - ObjTunnel(p)));\n\n        color = vec3(.2,.05,.05); // ground\n        color = mix(color, vec3(1,0,0), smoothstep(0.2, 1., tunnel));\n    }\n    \n    return vec4(dO, color);\n}\n\nvec3 Normal(vec3 p) \n{\n\tfloat d = Scene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        Scene(p-e.xyy),\n        Scene(p-e.yxy),\n        Scene(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvec4 Light(vec3 p, vec3 rd) \n{\n    vec3 lightPos = vec3(0, 5, 15. + SPEED);\n    vec3 l = normalize(lightPos-(p));\n    vec3 n = Normal(p);\n    \n    float dif = saturate(dot(n, l));\n\n    float fog = Fog(lightPos-(p), 50.) * .1;\n    dif *= fog;\n\n    vec3 color = vec3(1) * dif;\n\n    vec3 v = -rd;\n\tvec3 r = normalize(2. * dif * n - l); \n\tfloat spec = pow(saturate(dot(r, v)), 10.0) * dif;\n          spec *= 1.2;\n          spec = pow(spec, 5.) * 5.;\n    \n    return vec4(color, spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = vec3(0, 5, SPEED);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \t rd.x += sin(iGlobalTime) * .025;\n    \n    vec3 col = vec3(0);\n    float emission = 0.;\n    vec4 rm = Raymarch(ro, rd, emission);\n    float dist = rm.x;\n    vec3 color = rm.yzw;\n    vec3 p = ro + rd * dist;\n    \n    // Lighting\n    vec4 lighting = Light(p, rd);\n    vec3 lightingColor = lighting.rgb;\n    float lightingSpec = lighting.a;\n    col = lightingColor * color;\n    col += lightingSpec * vec3(1.,.7,.2);\n    \n    float detail = texture(iChannel1, GlobalOffset(p).zy * .1 + vec2(0, -iGlobalTime * .2)).r * 1.5;\n    col = mix(col, col * detail, .3); \n    \n    // CC\n    col *= (1. - dot(Normal(p), vec3(0,1,0))) + .2;\n    col += .13;\n    col.b += .02;\n    \n    // Fog\n    float pulse = (5. * (sin(iGlobalTime * 2.) * .5 + .5));\n    col += saturate((p.z - SPEED - 15.) * .01) * vec3(1,.05,0) * 2.;\n    col += saturate((p.z - SPEED - 40. + pulse) * .01) * vec3(1,1,.3) * 1.;\n    col += saturate((p.z - SPEED - 100. + pulse) * .01) * vec3(1,1,1) * 1.;\n    \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* Noises */\n// https://github.com/ashima/webgl-noise\n// https://github.com/stegu/webgl-noise\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    float n_ = 0.142857142857; \n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );  \n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0,0,0,0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    vec4 norm = (vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n         norm = 1.79284291400159 - 0.85373472095314 * norm;\n\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 randomCircle(vec2 pt, float r) \n{\n    float angle = radians(noise(pt.xyy) * 360.);\n    float x = r * cos(angle);\n\tfloat y = r * sin(angle);\n    \n    return vec2(x,y);\n}\n\n/* Easing */\n// https://github.com/glslify/glsl-easings\n\nfloat cubicOut(float t) \n{\n    float f = t - 1.0;\n    return f * f * f + 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}