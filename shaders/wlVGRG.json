{
    "Shader": {
        "info": {
            "date": "1579409355",
            "description": "I wanted to practice modeling with distance functions. This is my attempt to reinterpret the Urban light art piece at the LACMA.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlVGRG",
            "likes": 2,
            "name": "Urban Light",
            "published": 3,
            "tags": [
                "raymarch",
                "infinite",
                "lamps",
                "la"
            ],
            "usePreview": 0,
            "username": "kstyler",
            "viewed": 231
        },
        "renderpass": [
            {
                "code": "//distance functions from https://iquilezles.org/articles/distfunctions\nconst int MAX_DST = 800;\nconst float EPSI = 0.001;\nint mat = 0;//coloring objects\n\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),\n               \tsin(a), cos(a));\n}\n\nfloat roundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sphere(vec3 p,float radius){\n    return length(p)-radius;\n}\n\nfloat box(vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat octagon(vec3 p, vec3 b){//Using 4 boxes to cut off the 4 conrers of another box and make an octagon.\n    float b1 =  box(p,b);\n    \n    vec3 b2Rot = p;\n    b2Rot.xz*= rotate(0.8);\n    float b2 =  box(b2Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    vec3 b3Rot = p;\n    b3Rot.xz*= rotate(2.4);\n    float b3 =  box(b3Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n        \n    vec3 b4Rot = p;\n    b4Rot.xz*= rotate(4.0);\n    float b4 =  box(b4Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    vec3 b5Rot = p;\n    b5Rot.xz*= rotate(5.5);\n    float b5 =  box(b5Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    float sm = 0.05;\n    return smoothSub(b5,smoothSub(b4,smoothSub(b3,smoothSub(b2,b1,sm),sm),sm),sm);\n}\n\nfloat lampBase(vec3 p){\n    vec3 octPos = vec3 (0.,10.5,0.);\n    vec3 octPos2 = vec3 (0.,-0.8,0.);\n    return smoothUnion(octagon(p+octPos,vec3(2.0,0.4,2.0)),octagon(p+octPos2+octPos,vec3(1.8,0.4,1.8)),0.3);\n}\n\nfloat cyl(vec3 p){\n    float rad = 0.8;\n    rad -= 0.03*p.y;\n    rad -= 0.15*(0.3+0.3*sin(13.*atan(p.x,p.z)));\n    float d = length(p.xz)- rad;\t\n    d = max(d,p.y-10.);\n    d = max(d,-p.y-10.);\n\treturn d;\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p, bool setMat){\n    float c = 10.;\n    p.x = mod(p.x+c*0.5,c)-c*0.5;\n    p.z = mod(p.z+c*0.5,c)-c*0.5;\n    vec3 cylPos = vec3 (0.,0.,0.); \n    float bulb = roundCone(p+vec3(0,-11.0,0),1.2,1.4,1.);\n    float tip1 = sphere(p+vec3(0,-13.35,0),0.3);\n    float tip2 = sphere(p+vec3(0,-13.1,0),0.5);\n    \n    float minD =min(tip1,\n               \tmin(tip2,\n               \tmin(bulb,\n               \tsmoothUnion(torus(p+vec3(0,-10.2,0),vec2(0.7,0.4)),\n        \t\tsmoothUnion(octagon(p+vec3(0,6.5,0),vec3(1.05,0.4,1.05)),\n               \tsmoothUnion(torus(p+vec3(0,-8.6,0),vec2(0.53,0.1)),\n                smoothUnion(torus(p+vec3(0,-7.8,0),vec2(0.56,0.1)),\n                smoothUnion(cyl(p+cylPos),lampBase(p),1.0),0.1),0.1),0.1),0.5))));\n    \n    if(setMat){\n    if(minD == bulb ||minD == tip1 ||minD == tip2){//Lamp Light\n            mat = 2;\n    }else{mat =3;}//Lamp Body\n        \n    }\n    return minD;\n    \n}\n\nfloat rayMarch(vec3 ro,vec3 rd, bool setMat){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i < MAX_DST; i++){\n        vec3 p = ro + rd*tot;\n        dst = map(p,setMat);\n        tot+=dst;\n        if(dst<EPSI||tot>float(MAX_DST)){\n        \ttot = float(i)/float(MAX_DST);\n            break;\n        }\n     }\n    if(dst>EPSI && setMat){//sky\n    \tmat = 1;\n    }\n\treturn tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x; \n    vec3 ro = vec3(5,-3,-50. + iTime*10.);\n    vec3 rd = normalize(vec3(uv,1.));\n    float rm = rayMarch(ro,rd,true);\n    vec3 col =vec3(rm);\n    \n    if(mat == 1)col = vec3(1);\n    if(mat == 2)col = vec3(1.,1.,0.85); \n    if(mat == 3)col += vec3(0.7,0.73,0.7);\n                \n    col = mix(col,vec3(1),1.-exp(-3.*rm));//fog\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}