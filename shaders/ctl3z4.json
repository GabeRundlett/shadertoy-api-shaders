{
    "Shader": {
        "info": {
            "date": "1671403214",
            "description": "The audio is very loud at the beginning, I apologize if it scared you!",
            "flags": 64,
            "hasliked": 0,
            "id": "ctl3z4",
            "likes": 18,
            "name": "Yet Another Audio Reactive Scene",
            "published": 3,
            "tags": [
                "raymarching",
                "music",
                "animation",
                "visualizer",
                "lights",
                "live",
                "neon",
                "song"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "/* @kishimisu - 2022 \n   Wait for the drop!\n\n   Another attempt at isolating frequencies in order to\n   animate parts of the scene separately, especially the\n   lighting & colors.\n   \n   Here the scene is animated using 5 distinct (hand-picked)\n   frequencies as well as the current audio volume.\n   \n   Restart the shader after the audio has loaded for a better experience.\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n\n// Hand-picked frequencies\n#define fBeat  1.215\n#define fBeat2 -.8\n#define fBass  -.615\n#define fHigh  2.26\n#define fBall  -1.\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   const float c = 0.8, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float smin ,float smax, float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return smoothstep(smin, smax, logisticAmp(getLevel(freq)));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// We don't need to query the audio texture at each step (it's expensive), \n// so they are calculated once and passed as parameters.\nfloat map(vec3 p, inout vec3 lgt, float v, float fbeat, float fbeat2, float fbass, float fhigh, float fball) {    \n    // ball\n    float d = length(p - vec3(0,0,8.+2.*sin(iTime))) - .5-v*.8;  \n    lgt += mix(vec3(.1,.8,.6), vec3(.2,.6,1.), fbeat2)\n           * light(d, 10.) * fball * smoothstep(19., 20., iTime);\n    \n    // pillars\n    vec3 q = p;\n    vec3 id = floor(p);\n    q.xz = fract(p.xz)-.5;\n    q.y = abs(q.y);\n    float h = .3*sin(id.x+id.z+iTime) + max(0., (length(id)-1.))*.05;\n    float d2 = sdBox(q - vec3(0,3,0), vec3(.1, 1.5 + v + h, .1));\n    d = min(d, d2);\n       \n    // front\n    d2 = sdBox(p - vec3(0,0,22), vec3(18., 18., 10));\n    d = min(d, d2);\n    lgt += vec3(2.,.1,.0) * light(d2, 20.) * fbeat;\n    \n    // edges\n    float g = -sdBox(p, vec3(14., 8., 14));\n    lgt += mix(vec3(.55,.55,1.), vec3(.2,.8,.8), fbass) * light(g, 10.) * (fbass+fhigh*2.5);\n    d = min(d,g);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col;\n    \n    if (abs(uv.x)>.9 || abs(uv.y)>.9) {\n        fragColor = vec4(0.);\n        return; \n    }\n    \n    float vol    = getVol(8.),\n          fbeat  = getPitch(st(17., 20., .05, 0.), st(17., 20., .8, .1), fBeat, 1.),\n          fbeat2 = getPitch(0., .8, fBeat2, 1.),\n          fbass  = getPitch(0., .8, fBass, 1.),\n          fhigh  = getPitch(0., .8, fHigh, 1.),\n          fball  = getPitch(0., .8, fBall, 1.);\n     \n    if (iChannelTime[0] <= 0.) fbeat  = fhigh = fball = .5;\n\n    for (float i = 0., t = 0.; i < 50.; i++) {\n        vec3 p = t*normalize(vec3(uv, 1.));        \n        t += map(p, col, vol, fbeat, fbeat2, fbass, fhigh, fball);\n    }\n\n    fragColor = vec4(col,1.0);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 31304,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/the-williver/the-williver-the-devourer"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}