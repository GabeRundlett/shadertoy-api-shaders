{
    "Shader": {
        "info": {
            "date": "1683994005",
            "description": "Binocular visor with blue tv like (Star Wars inspired)",
            "flags": 0,
            "hasliked": 0,
            "id": "mtG3DD",
            "likes": 1,
            "name": "Visor",
            "published": 3,
            "tags": [
                "noise",
                "tv",
                "starwars",
                "visor"
            ],
            "usePreview": 0,
            "username": "dikadk",
            "viewed": 173
        },
        "renderpass": [
            {
                "code": "#define M_PI (3.1415926535897932384626433832795)\n\nfloat qScanLine (vec2 uv, float n, float rotation) {\n\tuv -= 0.5; // move origin to center\n    float theta = radians(rotation); // convert to degrees\n\n    // Apply rotation\n    float x = uv.x * cos(theta) - uv.y * sin(theta);\n    float y = uv.x * sin(theta) + uv.y * cos(theta);\n\n    uv = vec2(x, y);\n    uv += 0.5; // move origin back to corner\n\n    return abs(sin(uv.y * M_PI * n));\n}\n\nfloat qVignete (vec2 uv,float q, float o) {\n\tfloat x = clamp (1.0 - distance (uv, vec2 (0.5,0.5))*q, 0.0, 1.0);\n\treturn (log((o - 1.0/exp (o))*x + 1.0/exp (o)) + o)/(log(o) + o);\n}\n\n\nvec2 vCrtCurvature (vec2 uv, float q) {\n\tfloat x = 1.0- distance (uv, vec2 (0.5, 0.5));\n\tvec2 g = vec2 (0.5, 0.5) - uv;\n\treturn uv + g*x*q;\n}\n\nvec4 v2DNoiseSample (vec2 gPos) {\n\tvec2 nPos = vec2(\n\t\tmod (gPos.x+iTime*9.66,1.0),\n\t\tmod (gPos.y+iTime*7.77,1.0)\n\t);\t\t\n\treturn texture (iChannel1, nPos);\n}\n\nvec4 v1DNoiseSample (float idx, float s) {\t\n\treturn texture (iChannel1, vec2 (\n\t\tmod (idx, 1.0), \n\t\tmod (iTime*s, 1.0))\n\t);\n}\n\nfloat q2DNoiseSample (vec2 gPos) {\n \tvec4 nPnt = v2DNoiseSample (gPos);\n\treturn nPnt.x;\n}\n\nfloat q1DNoiseSample (float idx, float s){\n\tvec4 nPnt = v1DNoiseSample (idx, s);\n\treturn nPnt.x;\n}\n\nvec4 cSignalNoise (vec4 c,float q, vec2 gPos) {\n\treturn c*(1.0 - q) + q*q2DNoiseSample(gPos);\n}\n\nvec2 vScanShift (vec2 uv, float q, float dy, float dt) {\n\treturn vec2 (uv.x + q1DNoiseSample (uv.y*dy, dt)*q, uv.y);\n}\n\nvec2 vFrameShift (vec2 uv, float q, float dt) {\n\tfloat s = (q1DNoiseSample (0.5, dt) - 0.5)/500.0;\n\treturn vec2 (uv.x, mod (uv.y + iTime*(q+s), 1.0));\t\n}\n\nvec2 vDirShift (vec2 uv, float angle, float q) {\n\tfloat a =(angle/180.0)*M_PI;\n\tvec2 dir = vec2 (sin (a), cos (a));\n\treturn uv + dir*q;\n}\n\nvec4 vRGBWithShift (vec2 uv, float angle, float q) {\n\tvec2 rPos = vDirShift (uv, angle, q);\n\tvec2 gPos = uv;\n\tvec2 bPos = vDirShift (uv, -angle, q);\n\tvec4 rPix = texture (iChannel0, rPos);\n\tvec4 gPix = texture (iChannel0, gPos);\n\tvec4 bPix = texture (iChannel0, bPos);\n\treturn vec4 (rPix.x, gPix.y, bPix.z, 1.0);\n}\n\nvec4 vPowerNoise (vec4 col, vec2 uv, float b, float dt, float w) {\n\tfloat s = q1DNoiseSample (0.0, 0.001)/500.0;\n\tfloat y = mod (iTime * (dt + s) , 1.0);\n\tfloat d = 1.0 - clamp (abs (uv.y - y), 0.0, w)/w;\n\treturn pow (col,vec4(1.0/(1.0 + b*d)) ) ;\n}\n\nvec4 qGamma (vec4 i, vec4 g){\n\treturn pow(i, 1.0/g);\n}\n\nvec4 vRGBTint (vec4 col, vec3 g, float q) {\t\n\treturn qGamma (col, vec4 (g, 1.0))*q + (1.0 - q)*col;\t\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 vColorDrift (vec4 col, float q) {\n\tvec3 hsv = rgb2hsv (col.xyz);\n\thsv.y = mod (hsv.y * q, 1.0);\n\treturn vec4 (hsv2rgb (hsv), col.w);\n}\n\nvec4 vColorFilter(vec4 color, vec3 cFilter) {\n    vec3 adjustedColor = color.rgb * cFilter;\n    return vec4(adjustedColor, color.a);\n}\n\nvec4 vApplyMask(vec4 baseColor, vec2 uv) {\n    // Sample mask color from iChannel2\n    vec4 maskColor = texture(iChannel2, uv);\n\n    // Multiply baseColor by the red channel of the mask color\n    // Assuming mask is a grayscale image, so red, green, and blue channels are equal\n    return baseColor * maskColor.r;\n}\n\nvec4 applyTint(vec4 baseColor, vec4 tintColor, float tintStrength) {\n    return mix(baseColor, tintColor, tintStrength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 cRes = iChannelResolution [0].xy;\n\tvec2 gRes = iResolution.xy;\n\tvec2 gPos = fragCoord.xy / gRes;\t\n\tvec2 cPos = gPos ;\n\tvec4 cCol = vec4(1.0);\n\tvec2 bPos = vec2(1.0);\n\tfloat qNoise = q1DNoiseSample(0.01,0.01);\n\t\n\t//cPos = vScanShift (cPos, 0.02, 0.1, 0.1);\t\t\t// snaline shift\n\t//cPos = vCrtCurvature (cPos, 0.3);\t\t\t\t\t// crt curving of coords\n\t//bPos = vCrtCurvature (gPos, 0.3);\t\t\t\t\t// curvature for the noize bar\n\t//cPos = vFrameShift (cPos, 0.01, 0.001);\t\t\t\t// frame shift\t\t\n\t//cCol = vColorDrift (cCol, 1.0 - qNoise);\t\n\tcCol = vRGBWithShift (cPos, 100.0, 0.00); \t\t\t// sample signal color\t\n\t//cCol = cSignalNoise (cCol, qNoise * 0.8, gPos);\t\t\t\t// add signal noise\n\t//cCol = vPowerNoise (cCol, bPos, 4.0, -0.2, 0.1); \t// power line noize\n\t//cCol = vRGBTint (cCol, vec3 (0.5, 0.5, 1.0), 1.0);\t// gamma tint\n\tcCol = cCol * qScanLine (gPos, 150.0, 0.0); \t\t\t\t// add scanlines\n\t//cCol = cCol * qVignete (gPos, 1.5, 3.0); \t\t\t// add edge darkening\n    cCol = vColorFilter(cCol, vec3 (0.5, 0.5, 1.0));\n    \n    cCol = applyTint(cCol, vec4(0.0, 0.0, 1.0, 1.0), 0.4);\n    cCol = vApplyMask(cCol, gPos); //apply mask\n\tfragColor = cCol;\n\t\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}