{
    "Shader": {
        "info": {
            "date": "1624850842",
            "description": "A remastered version of [url=https://www.shadertoy.com/view/Ml3GDX]Reactive Voronoi[/url]. Adds a better traversal inspired by tomkh's [url=https://www.shadertoy.com/view/4lyGDV]Voronoi Column Tracing[/url], stronger lighting, softer shadows and AO.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lB3Dc",
            "likes": 4,
            "name": "Reactive Voronoi Remastered v0.5",
            "published": 3,
            "tags": [
                "3d",
                "voronoi",
                "interactive",
                "reactive",
                "ao",
                "semisoftshadows"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 341
        },
        "renderpass": [
            {
                "code": "// Fork of \"Reactive Voronoi Remastered draf\" by firebreathz. https://shadertoy.com/view/7tS3D3\n// 2021-06-28 03:21:55\n\n// Fork of \"Reactive Voronoi Remastered\" by glk7. https://shadertoy.com/view/MtyGWK\n// 2021-06-27 21:09:21\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float PI = 30.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//Derived from https://iquilezles.org/articles/voronoilines\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 1.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 1.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 80.0;\n    vec2 ml = vec2(0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = .1 + 0.1*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(r-mr,r-mr)>0.00001 ) {\n            vec2 l = normalize(r-mr);\n            float d = dot( 0.05*(mr+r), l );\n            if (md > d) { \n        \t\tmd = d;\n                ml = l;\n            }\n        }           \n    }\n\n    return vec3(md, ml);\n}\n\n\n\nvoid voronoi_s(in vec2 x, inout vec2 n,  inout vec2 f, \n                          inout vec2 mg, inout vec2 mr) {\n\n    n = floor(x);\n    f = fract(x);\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md) {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }   \n}\n\nvec3 voronoi_n(inout vec2 rd, inout vec2 n,  inout vec2 f, \n                              inout vec2 mg, inout vec2 mr) {\n    float md = 1e5;\n    vec2 mmg = mg;\n    vec2 mmr = mr;\n    vec2 ml = vec2(0.0);\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {   \n        vec2 g = mmg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n    \tvec2 l = r-mmr;\n \t\tif((dot(l, l) * dot(rd, l)) > 1e-5) {\n            float d = dot(0.5*(mmr+r), l)/dot(rd, l);\n            if (d < md) {\n                md = d;\n                mg = g;\n                mr = r;\n                ml = l;\n            }\n        }\n    }\n    \n    return vec3(md, ml);\n}\n\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, \n               out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n \n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nconst vec3 background = vec3(0.04);\nconst vec3 scmin = -vec3(1.77, 1.0, 1.77);\nconst vec3 scmax = vec3(1.77, 1.5, 1.77);\n\n\nfloat map(in vec2 p) {\n    vec2 h = exp(-(p*p*0.5));\n    return scmin.y + 0.1 + hash2(p).x * 0.5 \n        + texture(iChannel0, vec2(hash2(p).x, 0.0)).r*2.0 + h.x*h.y*0.5;\n}\n\n// From https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(vec2 p) {\n    return 1.5 *\n           pal(3.434+(hash2(p).x*0.02), vec3(0.5,0.5,0.5), \n                                        vec3(0.5,0.5,0.5),\n                                        vec3(1.0,0.7,0.4),\n                                        vec3(0.000,0.000,1.0)  );\n}\n\nfloat voronoi_ao(in float h, inout vec2 n, inout vec2 f, inout vec2 mg) {\n    float a = 0.0;\n    \n    for (int j = -1; j <= 1; ++j)\n    for (int i = -1; i <= 1; ++i) \n    {\n    \tvec2 g = mg + vec2(float(i), float(j));\n        a += max(0.0, map(n + g) - h);\n    }\n    \n    return exp(-a*0.5) + 0.2;\n    return max(0.0, 1.0 - a*0.2) + 0.2;\n}\n\nvec2 ShadowAndAmbient(in vec3 ro, in vec3 rd) {\n    vec3 p0 = vec3(0.0), p1 = vec3(0.0);\n    \n    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);\n    \n    if (length(ro - p1) < 0.01) return vec2(1.0);\n    \n    p0 = ro + rd*0.01;\n    vec2 dir = normalize(rd.xz);\n    float s = rd.y / length(rd.xz);\n    \n    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);\n    voronoi_s(p0.xz*2.0, n, f, mg, mr);\n    \n    float h = map(n + mg);\n    \n    float a = voronoi_ao(ro.y, n, f, mg);\n    vec3 dn = voronoi_n(dir, n, f, mg, mr);\n    \n    float rh = 0.0, prh = p0.y;\n    \n  \tfloat dmax = length(p0.xz - p1.xz);\n\tfloat mh = 1.0;\n    \n    const int steps = 20;\n    for (int i = steps; i > 0; --i) {\n        dn.x *= 0.1;\n        rh = p0.y + dn.x*s;\n       \n        if (dn.x > dmax || h > prh || h > rh) break; \n        \n        prh = rh;\n       \n        h = map(n + mg);\n        \n        mh = min(mh, 1.0*(rh-h)/(dn.x*s));\n        \n        dn = voronoi_n(dir, n, f, mg, mr);\n    }\n    \n    if (h > prh || h > rh) return vec2(0.0, a);\n    \n    return vec2(clamp(mh, 0.0, 1.0), a);\n}\n\nvec3 Shade(in vec3 p, in vec3 p0, in vec3 v, in vec3 n, in vec3 l, in vec2 c) {\n    vec3 col = color(c);\n    vec2 lc = vec2(max(0.0, dot(n,l))*0.9, 1.0);\n    \n    if (length(p - p0) < 0.01) return 1.0*col*(lc.x + lc.y)*.5;\n    \n    vec2 sa = ShadowAndAmbient(p + n*0.02, l);\n   \tlc *= sa;\n    return col*(lc.x + lc.y);\n}\n\nvec3 Render(in vec3 ro, in vec3 rd, in vec3 ld) {\n    vec3 p0 = vec3(0.0), p1 = vec3(0.0);\n    \n    if (!IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1)) return background;\n    \n    vec2 dir = normalize(rd.xz);\n    float s = rd.y / length(rd.xz);\n    \n    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);\n    voronoi_s(p0.xz*15.0, n, f, mg, mr);\n    \n    vec2 pmg = mg, pmr = mr;\n    float h = map(n + pmg);\n    \n    vec3 dn = voronoi_n(dir, n, f, mg, mr);\n    vec3 pdn = vec3(0.0, -AABoxNormal(scmin, scmax, p0).xz); \n    \n    float rh = 0.0, prh = p0.y;\n    \n  \tfloat dmax = length(p0.xz - p1.xz);\n\t\n    const int steps = 1000;\n    for (int i = steps; i > 0; --i) {\n        dn.x *= .05;\n        rh = p0.y + dn.x*s;\n        \n        if (dn.x > dmax || h > prh || h > rh) break; \n        \n        prh = rh;\n        \n        pmg = mg; pmr = mr;\n        h = map(n + pmg);\n        \n        pdn = dn;\n        dn = voronoi_n(dir, n, f, mg, mr);\n    }\n    \n    if (!(h > prh || h > rh)) return background;\n    \n    vec3 p = vec3(p0.xz + dir*pdn.x, p0.y + pdn.x*s).xzy;\n    vec3 nor = vec3(normalize(-pdn.yz), 0.0).xzy;\n    \n    if (h < prh) {\n    \tfloat dt = abs((p0.y - h)/s);\n        \n        if (dt > dmax) return background;\n        \n        p = vec3(p0.xz + dir*dt, h).xzy;\n        \n        vec3 v = voronoi(p.xz*2.0)*5.5;\n        nor = normalize(mix((vec3(normalize(v.yz), 0.0).xzy), \n                            vec3(0.0, 1.0, 0.0), smoothstep(0.0, 0.03, v.x)));\n    }\n    \n    return Shade(p, p0, rd, nor, ld, n + pmg);\n    \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.6 + 0.6;\n        \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(1.0, 1.0, -1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    \n    CameraOrbitRay(fragCoord, 1.0, vec3(0.0), 10.0, ro, rd, t);\n\tfragColor = vec4(pow(Render(ro, rd, LightDir(t)), vec3(0.9)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}