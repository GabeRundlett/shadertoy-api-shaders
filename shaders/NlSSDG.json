{
    "Shader": {
        "info": {
            "date": "1628452763",
            "description": "License CC0: DragonEye II\nA year or so ago I played with quasi crystals and I found they looked like \"dragon eyes\" with certain parameters\nThis is an evolution of that idea.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "NlSSDG",
            "likes": 55,
            "name": "DragonEye II",
            "published": 3,
            "tags": [
                "2d",
                "fbm"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 975
        },
        "renderpass": [
            {
                "code": "// License CC0: DragonEye II\n// A year or so ago I played with quasi crystals and I found they looked like \"dragon eyes\" with certain parameters\n// This is an evolution of that idea.\n\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define LAYERS      6\n#define FBM         3\n#define DISTORT     1.4\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float eyeAngle = 0.8;\nconst mat2  eyeRot = ROT(eyeAngle);\nconst vec2  eyeRef = vec2(cos(eyeAngle), sin(eyeAngle));\n\nfloat g_psy_th = 0.0;\nfloat g_psy_hf = 0.0;\n\nvec2 g_psy_vx = vec2(0.0);\nvec2 g_psy_vy = vec2(0.0);\n\nvec2 g_psy_wx = vec2(0.0);\nvec2 g_psy_wy = vec2(0.0);\n\nconst vec3 lightPos1 = 100.0*vec3(-1.3, 1.9, 2.0);\nconst vec3 lightPos2 = 100.0*vec3(9.0,  3.2, 1.0);\nconst vec3 lightDir1 = normalize(lightPos1);\nconst vec3 lightDir2 = normalize(lightPos2);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\nconst vec3 skinCol1  = vec3(0.6, 0.2, 0.2);\nconst vec3 skinCol2  = vec3(0.6);\n\nvec3 saturate(in vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's smooth min: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat outer(vec2 p) {\n  p *= eyeRot;\n  return vesica(p, 1.0*vec2(0.5, 0.25))-0.15;\n}\n\nfloat inner(vec2 p) {\n  p *= eyeRot;\n  return vesica(p, 1.0*vec2(0.125, 0.35));\n}\n\n\nfloat qc_wave(float theta, vec2 p) {\n  return (cos(dot(p,vec2(cos(theta),sin(theta)))));\n}\n\nfloat qc_noise(vec2 p) {\n  float sum = 0.;\n  float a = 1.0;\n  for(int i = 0; i < LAYERS; ++i)  {\n    float theta = float(i)*PI/float(LAYERS);\n    sum += qc_wave(theta, p)*a;\n    a*=DISTORT;\n  }\n\n  return abs(tanh_approx(sum));\n}\n\nfloat qc_fbm(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  float f = 1.0;\n  for(int i = 0; i < FBM; ++i)  {\n    sum += a*qc_noise(p*f);\n    a *= 2.0/3.0;\n    f *= 2.31;\n  }\n\n  return 0.45*(sum);\n}\n\nfloat qc_height(vec2 p) {\n  float od = outer(p);\n  float l = length(p);\n  const float s = 5.0;\n  p *= s;\n//  return -5.0*pmin(fbm(p), 0.75, 2.5)*exp(-5.0*l);\n  float sm = 0.05;\n  float oh = smoothstep(0.0, sm, od); \n  \n  float h =  -5.0*qc_fbm(p, TIME)*exp(-4.0*l)*oh;\n  return h;\n}\n\nvec3 qc_normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = qc_height(p + e.xy) - qc_height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = qc_height(p + e.yx) - qc_height(p - e.yx);\n  \n  return normalize(n);\n}\n\nfloat psy_noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat psy_fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*psy_noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\nfloat psy_warp(vec2 p, out vec2 v, out vec2 w) {\n  float id = inner(p); \n  \n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  p   -= eyeRef*pmax(0.0, dot(p, eyeRef), 0.25)*2.0;\n  p   -= 0.25*eyeRef;\n\n  f = smoothstep(-0.1, 0.15, id);\n  const float rep = 50.0;\n  const float sm = 0.125*0.5*60.0/rep;\n  float  n = smoothKaleidoscope(p, sm, rep);\n  p.y += TIME*0.125+1.5*g_psy_th;\n\n  g_psy_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_psy_vx;\n  vec2 vy = g_psy_vy;\n\n  vec2 wx = g_psy_wx;\n  vec2 wy = g_psy_wy;\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(psy_fbm(p + vx, aa), psy_fbm(p + vy, aa))*f;\n  w = vec2(psy_fbm(p + 3.0*v + wx, aa), psy_fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(psy_fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 psy_normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = psy_warp(p + e.xy, v, w) - psy_warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = psy_warp(p + e.yx, v, w) - psy_warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvec3 psy_weird(vec2 p) {\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = psy_warp(p, v, w);\n  float hf = g_psy_hf;\n  vec3  n  = psy_normal(p);\n\n  vec3 lcol1 = lightCol1;\n  vec3 lcol2 = lightCol2;\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  float diff1 = max(dot(n, lightDir1), 0.0);\n  float diff2 = max(dot(n, lightDir2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, lightDir1), 0.0);\n  float ref2  = max(dot(ref, lightDir2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col -= 0.5*hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col -= 0.5*hsv2rgb(vec3(fract(sqrt(0.5)*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col -= 0.5*(length(v)*col1 + length(w)*col2*1.0);\n   /*\n  col += 0.25*diff1;\n  col += 0.25*diff2;\n  */\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return max(col, 0.0);\n}\n\nfloat vmax(vec2 v) {\n  return max(v.x, v.y);\n}\n\nfloat corner(vec2 p) {\n  return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n  vec3 final     = vec3(0.0);\n\n  rd.xy *= ROT(-1.);\n  vec2 bp = rd.xz/max(0.0,rd.y);\n  float bd = corner(-bp);\n  final += 0.3*exp(-5.0*max(bd, 0.0)); \n  final += 0.20*smoothstep(0.025, 0.0, bd); \n  \n  final += 8.0*lightCol1*pow(ld1, 100.0);\n  final += 8.0*lightCol2*pow(ld2, 100.0);\n  \n  return final;\n}\n\nvec3 eyeColor(vec2 p, vec3 ro, vec3 rd, vec3 po, float od) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 sc    = vec3(0.0);\n  float sd   = raySphere(ro, rd, vec4(sc, 0.75));\n  vec3 spos  = ro + sd*rd;\n  vec3 snor  = normalize(spos - sc);\n  vec3 refl  = reflect(rd, snor);\n  vec3 scol  = skyColor(spos, refl);\n  float dif1 = max(dot(snor, lightDir1), 0.0);\n  float dif2 = max(dot(snor, lightDir2), 0.0);\n\n\n  vec3 pcol = psy_weird(p);\n  vec3 col1 = vec3(0.0);\n  col1 += pcol;\n  col1 += scol;\n  col1 += 0.025*(dif1*dif1+dif2*dif2);\n\n  vec3 col2 = 0.125*(skinCol1)*(dif1 + dif2)+0.125*sqrt(scol);\n \n  snor.xz *= ROT(-0.5*eyeAngle);\n  snor.xy *= ROT(-2.4*smoothstep(0.99, 1.0, sin(TTIME/12.0)));\n  float a = atan(snor.y, snor.x);\n\n  vec3 col = mix(col1, col2, step(a, 0.0));\n\n  col *= smoothstep(0.0, -0.1, od);\n  \n  return col;\n}\n\nvec3 skinColor(vec2 p, vec3 ro, vec3 rd, vec3 po, float od) {\n  float lp = length(p);\n  float aa = 2.0/RESOLUTION.y;\n\n  float qch = qc_height(p);\n  vec3  qcn = qc_normal(p);\n\n  float diff1 = max(dot(qcn, lightDir1), 0.0);\n  float diff2 = max(dot(qcn, lightDir2), 0.0);\n\n  vec3  ref   = reflect(rd, qcn);\n  vec3  scol  = skyColor(po, ref);\n\n  vec3 lcol1 = lightCol1;\n  vec3 lcol2 = lightCol2;\n  vec3 lpow1 = 0.25*lcol1;\n  vec3 lpow2 = 0.5*lcol2;\n  vec3 dm = mix(1.0*skinCol1, skinCol2, 1.0+tanh_approx(2.0*qch))*tanh_approx(-qch*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*sqrt(diff1)*lpow1;\n  col += dm*sqrt(diff2)*lpow2;\n\n  const float ff = 0.6;\n  float f = ff*exp(-2.0*od);\n\n  col *= f;\n  col += 0.5*ff*sqrt(scol);\n  col -= (1.0-tanh_approx(10.0*-qch))*f;\n  col *= smoothstep(0.0, 0.025, od);\n  return col;\n}\n\nvoid compute_globals() {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_psy_vx = vx;\n  g_psy_vy = vy;\n  \n  g_psy_wx = wx;\n  g_psy_wy = wy;\n}\n\nvec3 color(vec2 p) {\n  compute_globals();\n  \n  float aa = 2.0/RESOLUTION.y;\n  float od = outer(p);\n\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, 0.0, p.y);\n  vec3 rd = normalize(po-ro);\n\n\n  vec3 col = od > 0.0 ? skinColor(p, ro, rd, po, od) : eyeColor(p, ro, rd, po, od); \n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float a = PCOS(TTIME/60.0);\n  p *= mix(0.8, 1.2, 1.0-a);\n  vec3 col = color(p);\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}