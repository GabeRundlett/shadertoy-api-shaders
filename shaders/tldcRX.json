{
    "Shader": {
        "info": {
            "date": "1609642632",
            "description": "Mouse         : Move\nW, A, S, D    : Move\nQ, E             : Zoom\nR, Num 0      : Reset\nF                  : Toggle z0 Animation\n1 - 7             : Change Color Palettes\nNumpad 1 - 9 : Cool Spots I like (#4 reminds me of the islandic vegvisir symbol)",
            "flags": 48,
            "hasliked": 0,
            "id": "tldcRX",
            "likes": 2,
            "name": "Mandelbrot - Explore with UI",
            "published": 3,
            "tags": [
                "fractal",
                "julia",
                "mandelbrot",
                "complex",
                "ui",
                "set",
                "explore"
            ],
            "usePreview": 0,
            "username": "LerpDieRepeat",
            "viewed": 297
        },
        "renderpass": [
            {
                "code": "// I always wanted to give fractal shaders a try, so I started with the Hello World of Fractals, the Mandelbrot-Set.\n// This project helped me understand the Mandelbrot-Set a bit more and how to work with complex numbers.\n// I also learned about using buffers for state persistency, which is useful for the user inputs.\n// \n// comment ANIMATE_COLOR to stop color animation\n// uncomment GRID to show a grid overlay\n\n\n#define MAXIMUM_ITERATIONS 200\n#define ANIMATE_COLOR\n//#define GRID\n\n//defining product of imaginary numbers\n#define product_i(a, b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)\n\n\nint MandelbrotSet(vec2 z0, vec2 c, int iterMax)\n{\n    float zLength = 0.0;\n    int i = 0;\n    vec2 z = z0; //z.x = real part; z.y = imaginary part\n    \n    // if zLength is bigger than 2 the series diverges, then return the iterations needed\n    // otherwise go until max-iterations, which suggests the series is converging\n    while (zLength <= 2.0 && i < iterMax)\n    {\n        i++;\n        z = product_i(z, z) + c; //zn+1 = znÂ²+c\n        zLength = length(z);     //absolut value of imaginary number z is it's length\n    }\n    return i;\n}\n\n\n// using palettes by inigo quilez : https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 colorGradient(float gradient, int iter, int iterMax, float choose_palette)\n{\n    //vec3 color1 = vec3(0.1, 0.0, 0.6); //blue\n    //vec3 color2 = vec3(1.0, 0.6, 0.0); //orange\n    //vec3 palette = mix(color1, color2, gradient);\n    \n    #ifdef ANIMATE_COLOR\n        gradient += 0.2 * iTime;\n    #endif\n    \n    vec3                     palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if(choose_palette == 2.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if(choose_palette == 3.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if(choose_palette == 4.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if(choose_palette == 5.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if(choose_palette == 6.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if(choose_palette == 7.) palette = pal(gradient, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    vec3 col = iter == iterMax ? vec3(0) : palette;\n    return col;\n}\n\n\nfloat grid(vec2 uv, float space, float width)\n{\n    return\n    step(space * 0.5 - width * 0.5, abs(mod(uv.x, space) - space * 0.5)) +\n    step(space * 0.5 - width * 0.5, abs(mod(uv.y, space) - space * 0.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //squaring coordinates and centering\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy))/iResolution.yy;\n    \n    vec4 mouse;\n    mouse = texture(iChannel0, vec2(0.5, 0.5)).rgba; // read movement buffer (and palette)\n    uv = uv * mouse.z + mouse.xy;\n    \n    vec2 z0 = vec2(0.0, 0.0);\n    \n    // animating z0 in a circle when toggling F\n    int KEY_F = 70;\n    if(bool(texelFetch(iChannel1, ivec2(KEY_F,2),0).x))\n    {\n        z0 = vec2(0.05 * sin(iTime), 0.05 * cos(iTime));\n    }\n    \n    int iterMax = MAXIMUM_ITERATIONS;\n    \n    int iterations = MandelbrotSet(z0, uv, iterMax);\n    \n    float gradient = pow(float(iterations) / (0.5 * float(iterMax)), 0.5);\n    \n    vec3 finalColor = colorGradient(gradient, iterations, iterMax, mouse.a);\n\n    #ifdef GRID\n        finalColor += vec3(clamp(grid(uv, 1.0, 0.02) + grid(uv, 0.1, 0.005), 0.0, 0.2));\n    #endif\n\n    fragColor = vec4(finalColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Movement Input Buffer A\n\nconst int KEY_R     = 82;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_6     = 54;\nconst int KEY_7     = 55;\n\nconst int KEY_NUM0  = 96;\nconst int KEY_NUM1  = 97;\nconst int KEY_NUM2  = 98;\nconst int KEY_NUM3  = 99;\nconst int KEY_NUM4  = 100;\nconst int KEY_NUM5  = 101;\nconst int KEY_NUM6  = 102;\nconst int KEY_NUM7  = 103;\nconst int KEY_NUM8  = 104;\nconst int KEY_NUM9  = 105;\n\nbool IsPressed(int key)\n{\n   return bool(texelFetch(iChannel1, ivec2(key,0),0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // mouse input centered and scaled to go from -1 to 1\n    vec2 mouse = vec2(0);\n    if(iMouse.z > 0.0)\n    {\n        mouse = 2.0 * (iMouse.xy - (0.5 * iChannelResolution[0].xy)) / iChannelResolution[0].xy;\n    }\n    vec3 movement;          // rg = mouse; b = zoom;\n    float choose_palette;   // palette\n    float moveSpeed = 0.03;\n    float zoomSpeed = 0.05;\n    float borderThreshold = 0.3;\n\n\n    if (iFrame == 0) // Reset\n    {\n        // initial values\n        movement.rg = vec2(-0.5, 0.0);  // position\n        movement.b = 2.3;               // zoom\n        choose_palette = 2.0;           // palette\n    }\n    else\n    {\n        // read last buffer\n        movement = texture(iChannel0, vec2(0.0)).rgb;\n\n        // zoom\n        if(IsPressed(KEY_E)){movement.b *= 1.0 - zoomSpeed;} // Zoom In\n        if(IsPressed(KEY_Q)){movement.b *= 1.0 + zoomSpeed;} // Zoom Out\n\n        // movement keys\n        if(IsPressed(KEY_W)){movement.rg += vec2( 0,  1) * moveSpeed * movement.b;} //UP\n        if(IsPressed(KEY_S)){movement.rg += vec2( 0, -1) * moveSpeed * movement.b;} //DN\n        if(IsPressed(KEY_A)){movement.rg += vec2(-1,  0) * moveSpeed * movement.b;} //L\n        if(IsPressed(KEY_D)){movement.rg += vec2( 1,  0) * moveSpeed * movement.b;} //R\n\n        // movement mouse\n        if (length(mouse) < borderThreshold)\n        {\n            movement.rg += vec2(0);\n        }\n        else\n        {\n            // add to buffer: mouse-position, scaled by speed, masked, scaled to compensate zoom\n            movement.rg += mouse * moveSpeed * smoothstep(borderThreshold, 1.0, length(mouse)) * movement.b;\n        }\n\n        choose_palette = texture(iChannel0, vec2(0)).a;\n        if(IsPressed(KEY_1)){choose_palette = 1.;}\n        if(IsPressed(KEY_2)){choose_palette = 2.;}\n        if(IsPressed(KEY_3)){choose_palette = 3.;}\n        if(IsPressed(KEY_4)){choose_palette = 4.;}\n        if(IsPressed(KEY_5)){choose_palette = 5.;}\n        if(IsPressed(KEY_6)){choose_palette = 6.;}\n        if(IsPressed(KEY_7)){choose_palette = 7.;}\n    }\n    \n    if(IsPressed(KEY_NUM0) || IsPressed(KEY_R)){movement = vec3(-0.5, 0.0, 2.3);}\n\n    // cool spots\n    if(IsPressed(KEY_NUM1)){movement = vec3(-0.106, -0.925,   0.013);}\n    if(IsPressed(KEY_NUM2)){movement = vec3(-0.4692, 0.5412,  0.001);}\n    if(IsPressed(KEY_NUM3)){movement = vec3(-0.4661, 0.54355, 0.0013);}\n    if(IsPressed(KEY_NUM4)){movement = vec3( 0.4071, 0.60635, 0.0008);}\n    if(IsPressed(KEY_NUM5)){movement = vec3( 0.3505, 0.5815,  0.01);}\n    if(IsPressed(KEY_NUM6)){movement = vec3(-1.112, -0.2293,  0.0025);}\n    \n    if(IsPressed(KEY_NUM7)){movement = vec3(-1.2275, 0.165,   0.008);}\n    if(IsPressed(KEY_NUM8)){movement = vec3(-0.1045, 0.8845,  0.004);}\n    if(IsPressed(KEY_NUM9)){movement = vec3( 0.298, -0.0195,  0.008);}\n\n    fragColor = vec4(movement, choose_palette);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}