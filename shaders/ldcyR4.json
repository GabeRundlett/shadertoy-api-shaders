{
    "Shader": {
        "info": {
            "date": "1518012635",
            "description": "more simplex noise and hsv",
            "flags": 0,
            "hasliked": 0,
            "id": "ldcyR4",
            "likes": 44,
            "name": "rainbow flow 2",
            "published": 3,
            "tags": [
                "noise",
                "rainbow"
            ],
            "usePreview": 0,
            "username": "teriyaki",
            "viewed": 9268
        },
        "renderpass": [
            {
                "code": "#define      PI 3.14159265358979323846264338327950288419716939937511 // mm pie\n#define     TAU 6.28318530717958647692528676655900576839433879875021 // pi * 2\n#define HALF_PI 1.57079632679489661923132169163975144209858469968755 // pi / 2\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1. / 289.)) * 289.;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.) + 1.) * x);\n}\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p = permute( permute( i.y + vec3(0., i1.y, 1. )) + i.x + vec3(0., i1.x, 1. ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2. * fract(p * C.www) - 1.;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - .85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130. * dot(m, g);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvec2 pq(vec2 uv) {\n  return vec2(atan(uv.x, uv.y) / TAU + .5, length(uv));;\n}\n\nvec4 glorb(vec2 uv, vec2 offset, float radius) {\n  vec2 pq = pq(uv + offset);\n  float r = radius * snoise(uv + iTime * .2);\n  float s = 8. / iResolution.y;\n  float m = smoothstep(r + s, r - s, pq.y);\n  vec3 c = hsv2rgb(vec3(pq.x, 1., 1.));\n  return vec4(c, 1.) * m;\n}\n\nvec4 field(vec2 uv, vec2 offset, float radius) {\n  vec4 c0 = glorb(uv, offset, radius);\n  vec4 c1 = glorb(uv, offset, radius * .92);\n  return c0 - c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec4 r0 = field(uv, vec2( .0, .0), 1.66);\n  vec4 r1 = field(uv, vec2( .33, .33), 1.66);\n  vec4 r2 = field(uv, vec2( .33, -.33), 1.66);\n  vec4 r3 = field(uv, vec2(-.33, -.33), 1.66);\n  vec4 r4 = field(uv, vec2(-.33, .33), 1.66);\n  fragColor = r0+r1+r2+r3+r4;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}