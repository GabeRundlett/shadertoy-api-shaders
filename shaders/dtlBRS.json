{
    "Shader": {
        "info": {
            "date": "1693130549",
            "description": "2018-10-07 I released on shadertoy 'a study of glass' which was the first shader of mine to make it as a 'Shader of the week'.\nFor my first 4KiB intro I thought it made sense to do 'a study of glass II'.\nThanks to Virgill for providing the music!!",
            "flags": 96,
            "hasliked": 0,
            "id": "dtlBRS",
            "likes": 38,
            "name": "A study of glass II",
            "published": 3,
            "tags": [
                "raymarching",
                "4k",
                "glass"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 731
        },
        "renderpass": [
            {
                "code": "//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//      release name: A study of glass II       |\n//              type: Windows 4k intro          |\n//   release date: 26.08.2023                   |\n//   party/compo: Xenium 2023                   |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - 2018-10-07 I released on shadertoy  |\n// 'a study of glass' which was the first       |\n// shader of mine to make it as a               |\n// 'Shader of the week'.                        |\n//                                              |\n// Since then I have been very fortunate and    |\n// had other shaders make it as well but the    |\n// first one is always special to us.           |\n//                                              |\n// For my first 4KiB intro I thought it         |\n// made sense to do 'a study of glass II'.      |\n//                                              |\n// Thanks to Virgill for providing the very     |\n// nice and fitting music as well as assisting  |\n// me in squeezing it all into 4KiB.            |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n// Uploaded here: https://www.pouet.net/prod.php?which=94949\n// Youtube: https://www.youtube.com/watch?v=wNh-X0Ny1UI\n\n// Greetings to (I probably forgotten a few. I add you next time!) =>\n// Big Wings     - Soaring with mind-bending shader magic!\n// Byt3 M3chanic - Engineering genius of breathtaking visuals!\n// Dave Hoskins  - Mad scientist, blowing minds one pixel at a time!\n// EvilRyu       - Unleashing wickedly awesome shaders that drop jaws!\n// Evvvil        - Conjuring atmospheric realms of awe and a hint of terror!\n// FabriceNeyrat2- Shader virtuoso, reigning with cryptic elegance in the realm of concise chaos!\n// Impulse       - Veterans of my crew, aging like fine wine, still rocking the tv sofa scene!\n// IQ            - Mind-boggling shaders that question reality itself!\n// Kali          - Enchantress weaving mesmerizing visual spells!\n// lug00ber      - Mixing the beats, creating musical magic in the demo scene!\n// msm01         - Shaping extraterrestrial realms with scenic shaders, a true interstellar artist!\n// Nimitz        - Navigating shader seas with finesse and artistic flair!\n// Shane         - Crafting symphonies of light and color that dance!\n// Totetmatt     - Master sculptor molding stunning digital art!\n// Virgill       - Overworked maestro of 4klang, turning symphonies into code!\n// XorDev        - Shader sorcerer and explainer of FXAA algorithm!\n\n\n// All my code is licensed under CC0\n//  Others code I have indicated where I found it\n//  and what license was available at the time of\n//  discovery\n\n// The FXAA post processing provided by XorDev\n//  Applies fullscreen antialiasing to the input in IChannel0\n//  The input to iChannel0 is connected to Buffer A (see tabs on top)\n\n#define RESOLUTION      iResolution\n\n// License: Unknown, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n      \n  fragColor = fxaa(iChannel0, q, sqrt(2.0)/RESOLUTION.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//      release name: A study of glass II       |\n//              type: Windows 4k intro          |\n//   release date: 26.08.2023                   |\n//   party/compo: Xenium 2023                   |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - 2018-10-07 I released on shadertoy  |\n// 'a study of glass' which was the first       |\n// shader of mine to make it as a               |\n// 'Shader of the week'.                        |\n//                                              |\n// Since then I have been very fortunate and    |\n// had other shaders make it as well but the    |\n// first one is always special to us.           |\n//                                              |\n// For my first 4KiB intro I thought it         |\n// made sense to do 'a study of glass II'.      |\n//                                              |\n// Thanks to Virgill for providing the very     |\n// nice and fitting music as well as assisting  |\n// me in squeezing it all into 4KiB.            |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n// Uploaded here: https://www.pouet.net/prod.php?which=94949\n// Youtube: https://www.youtube.com/watch?v=wNh-X0Ny1UI\n\n// Greetings to (I probably forgotten a few. I add you next time!) =>\n// Big Wings     - Soaring with mind-bending shader magic!\n// Byt3 M3chanic - Engineering genius of breathtaking visuals!\n// Dave Hoskins  - Mad scientist, blowing minds one pixel at a time!\n// EvilRyu       - Unleashing wickedly awesome shaders that drop jaws!\n// Evvvil        - Conjuring atmospheric realms of awe and a hint of terror!\n// FabriceNeyrat2- Shader virtuoso, reigning with cryptic elegance in the realm of concise chaos!\n// Impulse       - Veterans of my crew, aging like fine wine, still rocking the tv sofa scene!\n// IQ            - Mind-boggling shaders that question reality itself!\n// Kali          - Enchantress weaving mesmerizing visual spells!\n// lug00ber      - Mixing the beats, creating musical magic in the demo scene!\n// msm01         - Shaping extraterrestrial realms with scenic shaders, a true interstellar artist!\n// Nimitz        - Navigating shader seas with finesse and artistic flair!\n// Shane         - Crafting symphonies of light and color that dance!\n// Totetmatt     - Master sculptor molding stunning digital art!\n// Virgill       - Overworked maestro of 4klang, turning symphonies into code!\n// XorDev        - Shader sorcerer and explainer of FXAA algorithm!\n\n// All my code is licensed under CC0\n//  Others code I have indicated where I found it\n//  and what license was available at the time of\n//  discovery\n\n#define RESOLUTION    iResolution\n#define TIME          iTime\n\n\nconst float PI              = acos(-1.)   ;\nconst float SPLIT           = 0.02        ;\nconst float INIT            = SPLIT-.001  ;\nconst float TOLERANCE       = 1.0E-4      ;\nconst float MAX_RAY_LENGTH  = 10.         ;\nconst float NORM_OFF        = 0.001       ;\nconst float MAX_RAY_MARCHES = 70.0        ;\nconst float Z               = log2(2.05)  ;\n// Virgill's song is 64 BPM meaning\n//  7.5 sec per switch lines up to 16 beats per switch\nconst float PERIOD          = 7.5         ;\n\nconst int   MAX_BOUNCES     = 5           ;\nconst int   SCRIPT_PARTS    = 17          ;\n\nconst vec4 Units = vec4(0,.5,1,2);\n\nconst vec3 lightPos  = vec3(0,9.,1)                   ;\nconst vec3 skyCol    = vec3(1,.53,.15)                ;\nconst vec3 beerCol0  = vec3(1.5,.56,.15)              ;\nconst vec3 beerCol1  = -vec3(2.,1.3,1)                ;\nconst vec3 sphereCol = vec3(.6,3.,1.85)               ;\nconst vec3 glassCol  = skyCol                         ;\nconst vec3 sphereMat = Units.xyz                      ;\nconst vec3 glassMat  = vec3(.75,.5,.87)               ;\nconst vec3 mirrorCol = glassCol                       ;\nconst vec3 mirrorMat = Units.xzz                      ;\nconst vec3 sunDir    = normalize(vec3(-.55, -.58, 1)) ;\nconst vec3 RO1       = vec3(0,-1,2.5)                 ;\nconst vec3 RO0       = 1.2*abs(RO1)                   ;\nconst vec3 luma      = vec3(.299, .587, .114)         ;\n\nstruct part {\n  float flash_control ;\n  float ray_origin    ;\n  int   variant       ;\n};\n\n// The demo script, controlling the flashing of light, the ray origin and what object to show\nconst part parts[SCRIPT_PARTS] = part[SCRIPT_PARTS](\n  //   flash    ray_origin variant\n  part(-1.0   , 0.0     , 0       ),// 0\n  part(-1.0   , 0.0     , 1       ),\n  part(-1.0   , 0.0     , 3       ),\n  part(-1.0   , 0.0     , 2       ),\n  part(+0.0   , 0.0     , 5       ),// 4\n  part(+0.0   , 0.0     , 3       ),\n  part(+0.0   , 0.0     , 2       ),\n  part(+0.0   , 2.0     , 1       ),\n  part(+1.0   , 0.0     , 6       ),// 8\n  part(+1.0   , 1.0     , 5       ),\n  part(+1.0   , 1.0     , 4       ),\n  part(+1.0   , 2.0     , 3       ),\n  part(+1.0   , 2.0     , 4       ),// 12\n  part(+1.0   , 2.0     , 6       ),\n  part(+1.0   , 2.0     , 7       ),\n  part(+1.0   , 0.0     , 2       ),\n  part(-1.0   , 0.0     , 0       ) // 16\n  );\n\n// Love us some global variables\nmat2 g_rot_x; \nmat2 g_rot_y;\nvec3 g_mat;\nvec3 g_diffCol;\nint g_variant;\n\nmat2 rot(float a) {\n  float c=cos(a);\n  float s=sin(a);\n  return mat2(c,s,-s,c);\n}\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) { \n  return fract(sin(co*12.9898) * 13758.5453); \n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a,float b,float k) {\n  float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);return mix(b, a, h)-k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a,float b,float k) {\n  return -pmin(-a,-b,k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b){\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0))+min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat sphere4(vec3 p, float r) {\n  p*=p;\n  return pow(dot(p, p),.25)-r;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  // The sky \"box\"\n  \n  // The glow in the horizon\n  vec3 col = vec3(.0025*skyCol)/abs(rd.y);\n  \n  float tp0 = rayPlane(ro, rd, vec4(Units.xzx,5.));\n  float tp1 = rayPlane(ro, rd, vec4(-Units.xzx,5.));\n\n  if (tp1 > 0.0) {\n    // Place a glowing box above the the scene\n    //  This makes the reflections \"pop\"\n    \n    float db = box((ro + tp1*rd).xz, vec2(6.0, 9.0))-1.0;\n    col += 3.0*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += 0.6*skyCol*exp(-0.5*max(db, 0.0));\n    col += -0.05*min(0.0, db);\n  }\n\n  if (tp0 > 0.0) {\n    // A glow from below helps illuminate bottom parts of box \n    col += 0.25*skyCol*exp(-0.5*(length((ro + tp0*rd).xz)));\n  }\n\n  // The sun is just an explosion\n  col += 6E-3*sqrt(skyCol).zyx/(1.01+dot(rd, sunDir));\n\n  return min(col,4.);\n}\n\n// The distance field function\nfloat df(vec3 p) {\n  vec3 pp = p;\n  // Some global rotation\n  p.yz *= g_rot_x;\n  p.xz *= g_rot_y;\n\n  // The inner sphere\n  float d0 = sphere(pp, 1.05);\n  float d1 = d0-.2;\n  \n  // Compute some ridges\n  vec3 p1 = pp*(PI*40.);\n  float h = .5+.5*sin(p1.y+p1.x-p1.z);\n  h*=h;h*=h;h*=h;\n  // Apply ridges to the sphere\n  d0 += 5E-4*h;\n  \n  // The outer box\n  float d2 = sphere4(p, 1.5);\n\n  // The glass \n  float dg;\n  // The modified outer box\n  float db;\n\n  float dtmp;\n  vec3 ptmp;\n\n  int variant = g_variant;\n  switch(variant) {\n  default:\n  case 0:\n    // Just the sphere\n    dg = MAX_RAY_LENGTH;\n    db = MAX_RAY_LENGTH;\n    break;\n  case 1:\n    // A transparent box\n    dg = d2;\n    db = MAX_RAY_LENGTH;\n    break;\n  case 2:\n    // A box with two glass stripes, my favorite in it's simplicity\n  \n    // The plane\n    dtmp = dot(normalize(vec3(1.0, 1.0, -1.0)), pp);\n  \n    // Onionize the plane to get two stripes\n    dtmp = abs(dtmp)-0.5;\n    dtmp = abs(dtmp)-0.25;\n  \n    // Glass is the box smooth intersected with the stripes\n    dg = pmax(d2, dtmp, 0.0125);\n  \n    // Box is the box smooth diffences with the stripes\n    // SPLIT need to not overstep when crossing materials\n    db = pmax(d2, -(dtmp-SPLIT), 0.0125);\n    break;\n  case 3:\n    // A box with circular windows\n  \n    // A cross\n    dtmp = min(min(length(p.xy), length(p.xz)), length(p.yz))-.75;\n  \n    // Glass is the box smooth intersected with the cross\n    dg = pmax(d2, dtmp, 0.05);\n  \n    // Box is the box smooth diffences with the cross\n    // SPLIT need to not overstep when crossing materials\n    db = pmax(d2, -(dtmp-SPLIT), 0.05);\n    break;\n  case 4:\n    // A box with \"bubbles\"\n  \n    //  A callback to the box with bubbles in the original 'a study of glass'\n    //  I don't think this is a good looking but it's more compact code which\n    //  is what is needed for 4KiB\n    \n    ptmp = pp;\n    // Apply some rotation to give the impression the bubbles are floating upwards\n    ptmp.yz *= g_rot_y;\n  \n    // Many bubbles please\n    ptmp -= round(ptmp);\n    \n    // The bubble\n    dtmp = sphere(ptmp, 0.43);\n    \n    // Glass is the box smooth intersected with the bubbles\n    dg = pmax(d2, dtmp, 0.05);\n  \n    // Box is the box smooth diffences with bubbles\n    // SPLIT need to not overstep when crossing materials\n    db = pmax(d2, -(dtmp-SPLIT), 0.05);\n    break;\n  case 5:\n    // A box with glass on top.\n    // Kind of like a filler box, looks ok but not the favorite\n    \n    dtmp = sphere4(pp-vec3(0.0, 1.5, 1.0), 1.25);\n  \n    // Glass is the box smooth intersected with the sphere4\n    // SPLIT need to not overstep when crossing materials\n    dg = pmax(d2, dtmp, 0.025)+SPLIT;\n  \n    // Box is the box smooth diffences with the sphere4\n    db = pmax(d2, -dtmp, 0.025);\n    break;\n  case 6:\n    // It's a magic box!\n  \n    ptmp = abs(p)-1.5;\n    float fp_6= exp2(length(ptmp)*Z);\n    float n_6 = floor(fp_6);\n    float x0_6 = log2(n_6)/Z;\n    float x1_6 = log2(n_6+1.0)/Z;\n    float m_6 = (x0_6+x1_6)*.5;\n    float w_6 = x1_6-x0_6;\n    dtmp = abs(length(ptmp)-m_6)-(w_6*0.5)+0.1;\n    dg = pmax(d2, dtmp, 0.0075)+SPLIT*0.5;\n    db = pmax(d2, -dtmp, 0.0075)+SPLIT*.5;\n  \n    break;\n  case 7:\n    // Glassy box distored by spheres\n    //  Wanted something I show just once that I hope give a little bit of wow effect\n    //  The music also has a nice buzz to it here\n    \n    // Shrink the spheres somewhat \n    const float z_7 = .75;\n    ptmp = pp/z_7;\n  \n    // Apply some rotation\n    ptmp.xy *= g_rot_y;\n  \n    // Many sphers please\n    ptmp -= round(ptmp);\n  \n    // The bubble\n    dtmp = sphere(ptmp.yzx, .4);\n  \n    dtmp *= z_7;\n  \n    // Glass is the box smooth intersected with the sphere4\n    // SPLIT need to not overstep when crossing materials\n    dg = pmax(d2, -(dtmp-SPLIT), .05);\n  \n    // No box\n    db = MAX_RAY_LENGTH;\n    break;\n  }\n\n\n  // Compute final distance\n  // Start with the box\n  float d = db; \n  // Then the glass\n  d = min(d, dg);\n  // Remove the sphere surrounding the inner sphere\n  d = max(d, -d1);\n  // Remove the inner sphere\n  d = min(d, d0);\n\n  // Material checking\n  \n  if (d == d0) {\n    // The inner sphere  \n    g_mat     = sphereMat;\n    g_diffCol = sphereCol;\n  } else if (d == db) {\n    // The box\n    g_mat     = mirrorMat;\n    g_diffCol = mirrorCol;\n  } else {\n    // The glass\n    g_mat     = glassMat;\n    g_diffCol = glassCol;\n  }\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  // This is the classic normal from distance field computation\n  // Essentially it is an approximate derivate of the distance field in each axis\n  //  then normalized\n  \n  vec2 eps = Units.zx*NORM_OFF;\n  return normalize(vec3(\n      df(pos+eps.xyy)-df(pos-eps.xyy)\n    , df(pos+eps.yxy)-df(pos-eps.yxy)\n    , df(pos+eps.yyx)-df(pos-eps.yyx))\n    );\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dm) {\n  // Classic raymarching with support being inside an object (being glass)\n\n  float t     = 0.0;\n  float tol   = dm*TOLERANCE;\n  vec2 nti = vec2(MAX_RAY_MARCHES,0);\n  float i;\n\n  for (i = 0.0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) break;\n    float d = dm*df(ro + rd*t);\n    if (d<nti.x) nti = vec2(d,t);\n    if (d < tol) break;\n    t += d;\n  }\n\n  // A trick learnt from a comment from IQ here: https://www.shadertoy.com/view/NdyyW3\n  //  It doesn't always improve things so thanks to tinkering around I found\n  //  I should only apply it when not inside the glass thus the extra dm>0.0\n  if(i==MAX_RAY_MARCHES && dm>0.0) t = nti.y;\n\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd, float fade) {\n  // Computes the color of the main object\n\n  // Aggregated color  \n  vec3 agg = vec3(0);\n  \n  // Aggregation reduction of color (to simulate glass absorbtion)\n  vec3 ragg= vec3(1);\n  \n  // Are we inside or outside when we begin?\n  bool isInside = df(ro) < 0.0;\n\n  // Outer loop for bounces inside glass or reflections\n  //  Can't both refract and reflect though :)\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n\n    // Check if we absorb so much light so that we can stop bouncing \n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < .025) break;\n\n    // Find the intersection with object\n    float st = rayMarch(ro, rd, dfactor);\n\n    // Capture mat and diffuse color early as these global variables might be messed up later\n    vec3 mat = g_mat, diffCol = g_diffCol;\n    if (st >= MAX_RAY_LENGTH) {\n      // Missed the object, compute the skyColor and add it to the aggregated color adjusted for absorbtion \n      agg += ragg*skyColor(ro, rd);\n      break;\n    }\n\n    // Point of intersection\n    vec3 sp = ro+rd*st;\n    // Normal at intersection, adjust for if we are inside or outside\n    vec3 sn = dfactor*normal(sp);\n\n    // Fresnel effect, this decreases reflection if the ray direction aligns with normal\n    //  This can be observed when standing in water\n    //  Looking down water doesn't reflect much but when you lift your eyes the reflection\n    //  of water increases more and more as it stretches toward the horizon\n    //  My way to compute it is a HUGE fake, quite compact though\n    float fre = 1.0+dot(rd, sn);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    // Direction to the light source\n    vec3 ld   = normalize(lightPos - sp);\n\n    // Diffuse lighting factor\n    float dif = max(dot(ld, sn), 0.0);\n\n    // Reflect the incoming ray \n    vec3 ref  = reflect(rd, sn);\n\n    // And refract it\n    vec3 refr = refract(rd, sn, isInside ? 1.0/mat.z : mat.z);\n\n    // Compute the reflect sky\n    //  This is a huge approximation as the reflected might not even be visible\n    //  at this point or might be impact by refraction or reflections\n    //  Too hard to do all that and this looks ok\n    vec3 rsky = skyColor(sp, ref);\n\n    // The diffuse color + the reflected sky adjusted for the material and fresnel    \n    vec3 col  = diffCol*dif*dif*(1.0-mat.x)+rsky*mat.y*fre;\n\n    // The beer effect to simulate absorbtion of light in the glass\n    //  To emulate glow we use a negative beer \"absorbtion\" factor \n    if (isInside) ragg *= exp((st+INIT)*mix(beerCol1, beerCol0, fade));\n\n    // aggregate the color adjusted for the absorbtion\n    agg += ragg*col;\n\n    // Check if the refraction instead was a full reflection\n    if (refr == Units.xxx) {\n      // Yes it was, so next ray direction is the reflected ray\n      rd = ref;\n    } else {\n      // We are either entering or leaving the glass\n\n      // Adjusted absorbtion factor depending on the material \n      ragg *= mat.x;\n\n      // Turn it inside out, just like in galaxy quest\n      isInside = !isInside;\n\n      // Ray direction is the refracted ray\n      rd = refr;\n    }\n    \n    // new ray origin is current pos + a small step in the ray direction in order to not get stuck here\n    ro = sp+INIT*rd;\n  }\n  return agg;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  // Center should be 0,0\n  vec2 p = -1.0+2.0*q;\n  // Adjust for screen ratio\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  int period        = int(floor(TIME/PERIOD))%SCRIPT_PARTS;\n  part period_part  = parts[period];\n  g_variant         = period_part.variant;\n  float periodTime  = mod(TIME,PERIOD);\n  // Setup global rotation\n  g_rot_x = rot(-0.2);\n  g_rot_y = rot(-0.125*TIME);\n\n  vec3 ro = mix(RO0,RO1,period_part.ray_origin*0.5);\n\n  // I have seen people make the setup of rd shorter but I never understood how that works.\n  vec3 ww = normalize(-ro);\n  vec3 uu = normalize(cross(Units.xzx, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + 1.5*ww);\n\n  // Emulating light flickering on, this code I am pretty satisfied with :)\n  float fade0 = smoothstep(PERIOD/4.0, 0.5*PERIOD, periodTime)+period_part.flash_control > hash(floor(TIME*30.0)) ? 1.0 : 0.0;\n\n  // Symmetric fade in/fade out\n  float fade1 = smoothstep(0.5*PERIOD, 0.5*PERIOD-PERIOD/8.0, abs(periodTime-0.5*PERIOD));\n\n  // Do the raytrace and compute the color\n  vec3 col = render(ro, rd, fade0);\n\n  // Dirt simple trick to increase saturation and remove undesired glow\n  col -= 0.025*Units.zwx*length(p);\n\n  col = max(col, 0.0);\n  col *= fade1*fade1;\n\n  // Inaccurate sRGB conversion \n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 34546,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virgill/4klang-studies-of-glass-ii"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}