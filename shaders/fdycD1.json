{
    "Shader": {
        "info": {
            "date": "1654753086",
            "description": "apply fbm to sphere",
            "flags": 0,
            "hasliked": 0,
            "id": "fdycD1",
            "likes": 3,
            "name": "werid sphere",
            "published": 3,
            "tags": [
                "raymarch",
                "sdf",
                "fbm",
                "sphere"
            ],
            "usePreview": 0,
            "username": "fl0a1e",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "// \n// try fbm \n//\n// Created by fl0a1e 06/09/2022\n// \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// sdf and noise from shaders by inigo quilez, https://iquilezles.org/articles/distfunctions/\n\n#define PI 3.14159265359\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION  0.001\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x ){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n\nfloat fbm (vec3 p)\n{\n    float f = 0.0;\n    float freq = 4.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float n = 4. * noise(p * freq) / freq;\n        f += n;\n        freq *= 1.5;\n    }\n    return f;\n}\n\n\n\nfloat sdSphere( vec3 p, float r)\n{\n    return length(p)-(r+fbm(p));\n}\n\n\n\n\nfloat map( vec3 p )\n{\n    float d = sdSphere(p, 1.0);\n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n\nfloat calcAO( vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 4; i++)\n    {\n        float h = .001 + 0.015 * float(i);\n        float d = map(pos + nor * h);\n        occ = (h - d) * sca;\n        sca *= .95;\n        if( occ > 0.35 ) break;\n    }\n    \n    return clamp( 1.0 - 1.0*occ, 0.0, 1.0 );\n}\n\nfloat raymarch( vec3 ro, vec3 rd)\n{\n    float dist = 0.0;\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + rd * dist;\n        float d = map(p);\n        if(abs(d) < 0.001 || d > MAX_DIST) break;\n        dist += d*0.75;\n    }\n\n\n    return dist;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    \n    vec3 col;\n    vec3 background = vec3(.01, .01, .01);\n    // raymarch\n    float d = raymarch(ro, rd);\n    \n    if(d > MAX_DIST)\n    {\n        \n    }\n    else // if hit something\n    {\n        vec3 pos = ro + rd * d;\n        vec3 nor = calcNormal(pos);\n        \n        // shadow\n            pos += nor * PRECISION * 2.0; \n            float ao = calcAO(pos, nor);\n        \n        // sun\n        {\n            vec3 sunPos = vec3(13.*sin(iTime*.5), 7., 5.*cos(iTime*.5));\n            vec3 ld = normalize(sunPos - pos);\n            float dif = clamp( dot( nor, ld ), 0.0, 1.0 );\n            \n            \n            float spe = pow( clamp( dot( nor, ld ), 0.0, 1.0 ),16.0);\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0-dot(ld, sunPos),0.0,1.0),5.0);\n            \n            col += 1.2*dif * vec3(.6, .6, 1.);\n        }\n        col *= ao;\n        \n    }\n    \n    // fog\n    col = mix(col, background, 1.0 - exp(-0.0001 * d * d * d));\n    \n    return col;\n}\n\nmat3 camera(vec3 campos, vec3 camtar)\n{\n    float roll = 0.0;\n    vec3 cw = normalize(camtar - campos); // camera watch\n    vec3 cr = normalize(cross(cw, vec3(sin(roll), cos(roll), 0.0))); // camera right\n    vec3 cu = normalize(cross(cr, cw));   // camera up\n    \n    return mat3(cr, cu, -cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    float time = iTime*.2;\n    vec2 mouse = PI * (-1.0 + 2.0 * iMouse.xy / iResolution.xy);\n    \n    // camera\n    vec3 ro = vec3(0.0+sin(mouse.x)*15., 2.0, 15.0-15.*(cos(mouse.x)+1.));\n    vec3 camtar = vec3(0.0, 0.0, 0.0);\n    mat3 cam = camera(ro, camtar);\n    vec3 rd = normalize(cam*vec3(uv, -1.3)); // ray direction\n    \n    vec3 col = render(ro, rd);\n    \n    // gamma\n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}