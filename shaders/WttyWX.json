{
    "Shader": {
        "info": {
            "date": "1610034146",
            "description": "testing spherical uniformity",
            "flags": 32,
            "hasliked": 0,
            "id": "WttyWX",
            "likes": 2,
            "name": "Uniformity tester",
            "published": 3,
            "tags": [
                "rng"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 520
        },
        "renderpass": [
            {
                "code": "// Fork of \"RNG utilities\" by michael0884. https://shadertoy.com/view/wltcRS\n// 2021-01-07 15:40:39\n\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec4 a =texture(iChannel0, p.xy/iResolution.xy);\n    c = vec4(400.*a.x/a.y);\n    c=sin(c*30.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n//normal distribution RNG\n\n//inverse error function\nfloat ErfInv(float x){\n   float lnx = log((1.0 - x)*(1.0 + x));\n   float tt1 = 4.3308 + 0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1 + sqrt(tt1*tt1 - tt2)));\n}\n\nfloat nrand()\n{\n    return ErfInv(rand()*2.0 - 1.0);\n}\n\n//box muller\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxyy)) * \n           vec4(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w),sin(TWO_PI * Z.w));\n}\n\n\n//uniformly spherically distributed\nvec3 udir()\n{\n    vec2 rng = rand2();\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nvec3 udir1()\n{\n    vec2 rng = rand2();\n    float phi = 2.*PI*rng.x;\n    float cos_theta = 2.*rng.y-1.;\n    float sin_theta = sqrt(1.0-cos_theta*cos_theta);\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return vec3(cos_phi*sin_theta, sin_phi*sin_theta, cos_theta);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    \n    vec4 prev = texture(iChannel0, p.xy/iResolution.xy);\n    float phi = PI*2.0*p.x/iResolution.x;\n    float theta = PI*p.y/iResolution.y;\n    \n    float jacobian = sin(theta);\n    \n    float sum = 0.;\n    float n = 3.*p.x/iResolution.x;\n    for(int i = 0; i < 128; i++)\n    {\n        vec3 dir = normalize(rand3() - 0.5); //really BAD\n        //vec3 dir = normalize(tan(0.5*PI*(rand3() - 0.5))); //BAD\n        //vec3 dir = normalize(tan(2.*rand3() - 1.0)); //Better\n        //  vec3 dir = normalize(nrand3(1., vec3(0.))); //Perfect\n       // vec3 dir = udir(); //Perfect\n       //vec3 dir = udir1();\n        float phi0 = atan(dir.y, dir.x) + PI;\n        float theta0 = acos(dir.z);\n        \n        sum += step(distance(vec2(phi0, theta0), vec2(phi, theta)), 0.1);\n    }\n    \n    // Output to screen\n    c = prev + vec4(sum/jacobian,256.,0,0);\n    \n    if(iFrame < 1) c = vec4(0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}