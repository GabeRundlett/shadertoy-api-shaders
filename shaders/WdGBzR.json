{
    "Shader": {
        "info": {
            "date": "1606344927",
            "description": "https://www.shadertoy.com/view/X\ncleaned, type int\nthis is experimental, to be simpler and more user friendly.\nto see, how i can improve on it, if only by making it less messy.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdGBzR",
            "likes": 0,
            "name": "(i)rationalStride (type int)",
            "published": 3,
            "tags": [
                "starguitar",
                "irrationalstride",
                "arpshepardtone",
                "ditherhairlinequantize",
                "chromaticscalecordtartanweave",
                "euclideanbeats",
                "euclideanrythm"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "//this shader simplifies previous  [stride] shaders\n//it mostly succeeds, but it has 1 remainding rounding-error-case\n//, that may duplicate the 0th row/column\n//This is a precision issue, because 0.0 duplicates into -0.000001 unpredictably\n//https://www.shadertoy.com/view/Xl3BD4 seems to adress this precision error\n//, at the cost of a LOT of arbitrary epsilon+buerocracy.\n\n//a better/slower solution is\n//https://www.shadertoy.com/view/4ttBD4\n\n//three voice harmony minor major chord (old)\n//parent: https://www.shadertoy.com/view/lsffDM \n//parent: https://www.shadertoy.com/view/XtdfDH\n/*\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\n*/\n\n/*\nI thought of a rather simple way to represent longer chords, \nascending and descending melodies.\n\nthis is the simple more constrained approach, only 3 dots.\nsolve a special case BEFORE trying a general case!\n\nThe reason why tesselation of music pitches works is\n...because we fail do distinguish hiigher resolutions of pitches.\nBlack piano keys ARE Moire ARE aliasing:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\n*/\n\n\n/*\na problem suupoptimal case i keep running into is\na sequence of notes on a sheet \n...that are pretty much an ascending or descending line.\nof 4 to 8 notes.\n\ni want a very general case to check \nif(at time [t] note [n] exists in pith [y]) \nfor a linear equation of notes.\nto be checked AFTER applying a floor() tesselation.\nvia pModInterval1() of \nhttp://mercury.sexy/hg_sdf/\n\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n#define u5(a) ((a)*.5+.5)\n\n#define vec1 float\n//red circle radius\n#define radius 1.\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n#define viewZoom mix(9.,hl2,u5(-cos(cos(iTime))))\n#define hl (viewZoom/hl2)\n#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\nfloat ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n\n//return distance of [u] to line srgment from [a] to [b]\nfloat Segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n a.x=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a.x);}\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n//return square tesselaion grod for [u]fragmentPos\nfloat grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);\n return smoothstep(hl,-hl,abs(r-1.)-hl);}\n\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define dd(a) dot(a,a)\n\n//[u]FragmentPos, [m]=start [n]=end\n   \n//rationalStride() is pmodfm() BUT muich simpler (only for vec2)\n//rationalStride() is pmodfm() BUT without planckEpsilon and without CentricOffset\n//u=uv point you want to test if there is a note or not. \n//  (only has repeating grid constrain, does not filter the diagonal)\n//m=first/lowest  note  of a chord or arpeggio (frequency=.x time =.y) (set to offset+ 0.)\n//n=last /highest note  of a chord or arpeggio (frequency=.x time =.y) (set to offset+12.)\n//F=number of     notes of a chord or arpeggio == number of [A] in [BABABBABABAB] (length of 12)\nvec2 rationalStride(vec2 u,vec2 m,vec2 n,float F){\n ;n-=m;u-=m//offset by m\n ;vec2 a=floor(u)\n //above basically turns relevant intputs into type int:\n //;float F=2. //numberoif [A] in [AABAABAA..]\n ;vec2 b=F/max(vec2(F),abs(n-1.)) //how to convert this into integer modulo?\n ;// x%y = x-y*floor(x/y) //type float modulo\n ;// x%y = x-y*(x/y)      /type int version needs no floor\n ;b=floor(fract(a*b)/b)\n ;return b;}\n\n//return rational Stride; user friendly version in derms of shuffling a deck\n//a (binary) [stride] here is an evenly shuffled deck of only 2 different cards\n//but the distribution is as EVEN as possibly (not random, just offset)\n//eg: rationalStrideUserFriendly(0,7,5) \n//7,5 defines a ChromaticScale of 7 white keys to 5 black keys)\n//note that, if these values would not be rational\n//,a WHITE overwrites a BLACK (to evade flickering)\n//\n//eg: rationalStrideUserFriendly(vec2(iTime)%iResolution.xy,1.,iResolution.x-1.)\n//should be a moving hairline (untested, .y may be wild here)\n//\n//offset=UV coords\n//green= number of Green lines (green==white, but rgba coded)\n//black= number of Black lines\nvec2 rationalStrideUserFriendly(vec2 offset,float green,float black\n){return rationalStride(offset,offset+green,offset+green+black,green);}\n\nvec3 chord(vec2 u, vec2 m, vec2 n,float F\n){F-=1.\n ;//u*=iResolution.xy\n ;//m*=iResolution.xy \n ;//n*=iResolution.xy \n ;//m=vec2(0)//debug overwrite to a null-offset\n ;vec3 r=vec3(0)  \n ;r.z=Segment(u,m,n)//blue lineSegment\n ;//float d=length(m-u)//iResolution.x//3 red circles\n  //     ,e=length(n-u)//iResolution.x\n //      ,f=length(n+m-u*2.)*.5//iResolution.x  //decappped\n ;r.x=0.//min(min(d,e),f)                    //3 red circles end\n ;r.xz=ss(abs(r.xz-radius*vec2(1,.2))-hl)//yellow circles\n\n ;m=floor(m)//new concept, of making rationalStride() work with type int\n //this type int constrain seems to work [just fine]\n //, but i am not too suire about it.\n ;vec2 b=rationalStride(u,m,n,F)\n     \n ;//above code still works, even if you give it values, scaled by IResolution (or anything)\n ;//therefore this should just rasterize to type integer, i speculate.\n ;//the floor() method then just becomes something like a small shift, or a division by /256;\n ;//and the fract() function becomes a bitvise mask of &255\n ;ivec2 Iu=ivec2( u    *256.)\n ;ivec2 In=ivec2((n-1.)*256.)\n ;int If=2\n ;ivec2 Ib=If/max(ivec2(If),abs(In))\n ;//If=(Iu*Ib)&ivec2(255)\n ;if(all(equal(abs(b),vec2(0))))r.y+=.4;//oversimplified dots\n ;if(any(equal(abs(b),vec2(0))))r.y+=.2;//oversimplified crosses    \n ;//if(all(lessThan(abs(u),vec2(planckT))))r.y+=.4;//dots\n ;//if(any(lessThan(abs(u),vec2(planckT))))r.y+=.2;//crosses\n ;//vec3 r=vec3(d,t,)\n ;return r;}\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec3 c=vec3(0)\n ;vec2 u=fra(U)\n ;vec2 m=fra(abs(iMouse.zw));//start of holding mouse\n ;vec2 n=fra(    iMouse.xy);//current mouse pos held\n ;if(iMouse.z<=0.\n ){n=vec2(.0)\n  ;vec2 rr=viewZoom*vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=cs(iTime*.61).yx*(rr.x-rr.y)\n  ;m=cs(iTime    )   *(rr.x+rr.y)\n  ;c.xy+=.2*ss(abs(abs(length(u)-rr.x)-rr.y)-viewZoom*.5/hl2)//yellow circles show path of red dots\n  ;}\n ;c+=chord(u,m,n,4.)//core function, dodo split in 3 parts.\n ;c+=grid(u)*.2;// greyscale grid    \n ;O=vec4(c,1.)\n ;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}