{
    "Shader": {
        "info": {
            "date": "1654365012",
            "description": "Mandelbrot set (connectedness locus of Julia sets) for a family of functions g_A(z) = z +1/z + A, which have a parabolic fixed point at infinity.",
            "flags": 0,
            "hasliked": 0,
            "id": "fsyczh",
            "likes": 9,
            "name": "Parabolic Mandelbrot Set M1",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbrot",
                "complex",
                "parabolic"
            ],
            "usePreview": 0,
            "username": "amoser",
            "viewed": 388
        },
        "renderpass": [
            {
                "code": "// I first heard of this fractal, which is homeomorphic to the Mandelbrot set, in this lecture by Luna Lomonaco https://www.youtube.com/watch?v=QXQkRjeFCcM&t=3034s\n// I wasn't able to find any code for rendering it, despite its relative simplicity, so I wanted to share this first pass. Feel free to reuse it.\n// It's not at all optimized for the sake of readability. In fact, it's quite slow.\n\nconst bool julia = false;\nconst float iterations = 100.0;\nconst float escapeDistance = 60.0;\nconst float pi = 3.1415926;\n\nvec3 hue(float x)\n{\n    return vec3(0.6 + 0.6*cos(2.0*pi*(x) + vec4(0,-2.0*pi/3.,2.0*pi/3.0,0)));\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), -sin(x), sin(x), cos(x));\n}\n\nvec2 cmul(vec2 za,vec2 zb)\n{\n    return za*mat2(zb.x, -zb.y, zb.yx);\n}\n\nvec2 cinv(vec2 z) \n{\n    return z*vec2(1, -1)/dot(z, z);\n}\n\nvec2 cexp(vec2 z) \n{\n    return exp(z.x)*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(vec2 z) \n{\n    return vec2(log(length(z)), atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float n)\n{\n    return cexp(n*clog(z));\n}\n\n//https://www.shadertoy.com/view/WlfXRN\nvec3 magma(float t) \n{\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float escaped = iterations;\n\n\tvec2 coord = vec2(-2.0,0) + 3.0*(2.0*fragCoord.xy-iResolution.xy)/(iResolution.x);\n    vec2 mouse = vec2(-2.0,0) + 3.0*(2.0*iMouse.xy-iResolution.xy)/(iResolution.x);\n    \n    vec2 B = julia ? mouse : coord;\n    vec2 A = cpow(-B, 0.5);\n    // As far as I know, for the general class of functions conformally conjugate to g_A(z) = z +1/z + A, we'd need to check the orbit of both -1 and 1.\n    // Just -1 seems to be sufficient for this particular construction.\n    vec2 z = julia ? coord : vec2(-1,0);\n\n    vec2 zStop = vec2(0);\n    float i = 0.0;\n    for (; i < iterations; i++)\n    {\n        // Note that \"escapeDistance\" is just a useful fiction for coloring the exterior. It doesn't guarantee divergence.\n        if(length(z) > escapeDistance && escaped >= iterations) \n        {\n            escaped = i;\n            zStop = z;\n        }\n        z = z + cinv(z) + A;\n    }\n    \n    // \"Smooth iteration count\" naively adapted from the standard Mandelbrot. \n    // Looks OK but isn't really correct.\n    if(zStop != vec2(0))\n    {\n        escaped += 1.0-2.0*escapeDistance*log(log(length(zStop))/log(escapeDistance));\n        escaped = max(escaped, 0.0);\n    }\n    \n    float escapeTime = escaped/iterations;\n    vec2 gridOrigin = z + 50.0*mouse + vec2(0,15)*rot(iTime/4.0);\n    float grid = 0.5*(0.5*sin(0.4*gridOrigin.x)+0.5) + 0.5*(0.5*sin(0.4*gridOrigin.y)+0.5);\n    grid = pow(grid+0.4975, 200.0);\n    grid = clamp(grid, 0.0, 1.0);\n    vec3 col = magma(mix(escapeTime, grid*escapeTime, 0.05*smoothstep(0.0, 10.0, length(z)-5.0)));\n    col = mix(col, hue(0.2*iTime+-0.5*mouse.y+4.0/pi*atan(z.y,z.x)).rgb, 0.1);\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}