{
    "Shader": {
        "info": {
            "date": "1689593577",
            "description": "underwater pool noise fbm caustics",
            "flags": 0,
            "hasliked": 0,
            "id": "dsSfzz",
            "likes": 9,
            "name": "Pool water",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "caustics",
                "underwater",
                "pool"
            ],
            "usePreview": 1,
            "username": "Jan300100",
            "viewed": 535
        },
        "renderpass": [
            {
                "code": "vec3 hash( uvec3 x )\n{  \n    //https://www.shadertoy.com/view/4lXyWN\n    \n    //multiply large prime value first.\n    uint k = 1103515245U;\n    x*= k;\n    //mix x, y, z values.\n    //Without shift operator, x, y and z value become same value.\n    x = ((x>>2u)^(x.yzx>>1u)^x.zxy)*k;\n \n    return (vec3(x)*(1.0/float(0xffffffffU)));\n}\n\nvec3 noise(vec3 p)\n{\n    uvec3 fl = uvec3(floor(p));\n    vec3 fr = fract(p);\n    fr = smoothstep(0.0,1.0,fr);\n    vec3 tr = hash(fl + uvec3(0,0,0));\n    vec3 tl = hash(fl + uvec3(1,0,0));\n    vec3 br = hash(fl + uvec3(0,1,0));\n    vec3 bl = hash(fl + uvec3(1,1,0));\n    vec3 tr2 = hash(fl + uvec3(0,0,1));\n    vec3 tl2 = hash(fl + uvec3(1,0,1));\n    vec3 br2 = hash(fl + uvec3(0,1,1));\n    vec3 bl2 = hash(fl + uvec3(1,1,1));\n        \n    \n    vec3 res = mix(mix(mix(tr, tl, fr.x), mix(br, bl, fr.x), fr.y)\n            ,mix(mix(tr2,tl2,fr.x), mix(br2,bl2, fr.x), fr.y),fr.z);\n    \n    vec3 result = (1.0 + res)*0.5; //map to [0,1]\n\n    return res;\n}\n\n\nvec3 fbm_levels(vec3 p, int levels)\n{\n    vec3 r = vec3(0);\n    \n    float m = 1.0f;\n    for (int i = 0; i < levels; i++)\n    {\n       m *= 0.5f;\n       r += m * noise(p); \n       p *= 2.03;\n    }\n    return r;\n}\n\nvec3 fbm(vec3 p)\n{\n    return fbm_levels(p,4);\n}\n\n\nvec3 pattern(vec3 p)\n{\n    vec3 q = fbm(p);\n    vec3 r = fbm(p + 4.*q);\n    \n    vec3 result;\n    result.x = fbm(p + fbm(p + 2.*fbm(p + q))).x;\n    result.y = q.x;\n    result.z = r.x;\n    return result;\n}\n\nvec3 sampleFloor(vec2 coord)\n{    \n    coord = coord * 1.8f + 0.25;\n    float g1 = 0.10f;\n    float g2 = 0.025f;\n    bool b1 = ((1.0 - fract(coord.x - g1/2.0f)) < g1 || (1.0 - fract(coord.y - g1/2.0f) < g1));\n    bool b2 = ((1.0 - fract(coord.x - g2/2.0f)) < g2 || (1.0 - fract(coord.y - g2/2.0f) < g2));\n    \n    vec3 baseCol;\n    \n    vec3 nRes = noise(vec3(coord * 100.0f,1.0f));\n    if (!b1 && !b2)\n    {\n        vec3 fRes = fbm_levels(vec3(coord * 5.0f,1.0f),3);\n        baseCol = vec3(0.3 + fRes.r * 0.3f+ nRes.r * 0.2f);\n    }\n    else if (b1 && !b2)\n    {\n        baseCol = vec3(0.1 + 0.2 * nRes.y);\n    }\n    else\n    {\n        baseCol = vec3(0.7 + 0.2 * nRes.z);\n    }\n    \n    //\n    vec3 timed_p = vec3(coord * 0.3f,iTime*0.4f + fbm(vec3(coord + 5.0,10.0))); \n    vec3 fRes = fbm_levels(timed_p,2);\n    \n    float cPow = 50.0f;\n    vec3 cCol = vec3(1);\n    \n    vec3 caustics = vec3(0);\n    caustics += pow(clamp(1.0-abs((fRes.y - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n    caustics += pow(clamp(1.0-abs((fRes.x - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n    caustics += pow(clamp(1.0-abs((fRes.z - 0.5f)),0.0f , 1.0f),cPow) * cCol;\n\n    return clamp(baseCol + caustics * 0.2f,0.0,1.0);\n}\n\nvec2 CalcUV(vec2 coord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = coord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float zoom = 5.0f;\n    uv *= zoom;\n    uv += vec2(50.0,25.0);\n    return uv;\n}\n\nfloat sampleWater(vec2 coord)\n{\n    vec2 uv = CalcUV(coord);\n\n    // Time varying pixel color\n    vec3 p = vec3(uv,iTime/3.0f + fbm(vec3(uv + 5.0,10.0)));\n    vec3 res = pattern(p);\n    vec3 color;\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((res.x*res.x)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                1.0-res.y);\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                1.0-res.z);\n\n    return (color.r + color.g + color.b)/3.0f;\n}\n\n// normals using dfdx dfdy, same for the entire quad\n#define CHEAP_NORMALS 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = CalcUV(fragCoord);\n    vec3 finalCol = sampleFloor(uv);\n#if 1\n    float greyscale = sampleWater(fragCoord);\n\n    // normal \n    float height = 0.05f * iResolution.x; // scales with resolution, because noise also scales with the resolution.\n#if CHEAP_NORMALS\n    float offset = 1.0f;\n    float greyscale_dx = dFdx(greyscale);\n    float greyscale_dy = dFdy(greyscale);\n#else\n    float offset = 0.1f;\n    float greyscale_dx = (sampleWater(fragCoord + vec2(offset,0)) - greyscale);\n    float greyscale_dy = (sampleWater(fragCoord + vec2(0,offset)) - greyscale);\n#endif\n    vec2 dxdy = vec2(greyscale_dx, greyscale_dy);\n    vec3 normal = normalize(vec3(dxdy,offset/height));\n    \n    // light\n    vec3 viewDir = vec3(0,0,-1);\n    vec3 lDir = normalize(vec3(-0.477,-0.477,-0.277));\n    \n    vec3 reflectDir = reflect(lDir, normal);\n    float spec = pow(max(dot(reflectDir,viewDir),0.0f),2.0f);\n        \n    // Output to screen\n    vec3 waterCol = vec3(145, 239, 255) / 255.0f;\n    \n    vec2 samplePos = uv + greyscale;\n    finalCol = sampleFloor(samplePos) * waterCol + spec * 0.5f;\n#endif\n    fragColor = vec4(finalCol,0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}