{
    "Shader": {
        "info": {
            "date": "1662302695",
            "description": "Infinite Soothing Balls - though a nice little log-polar coordinates (now mouseable!)",
            "flags": 32,
            "hasliked": 0,
            "id": "ftKyDV",
            "likes": 48,
            "name": "Infinite Soothing Balls",
            "published": 3,
            "tags": [
                "infinitesoothingballs"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Infinite Soothing Balls \n    09/04/22 @byt3_m3chanic \n    \n    Rework of a little animation though a nice little log-polar coordinates.\n    (my original shader) https://www.shadertoy.com/view/fsscWf \n*/\n\nfloat offset[3] = float[](.05,.75,2.25);\nfloat weight[3] = float[](.2,.25,.075);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, .0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, .0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float mask = distance(uv.xy,vec2(.5));\n    mask = smoothstep(.52,.965,1.-mask);\n    vec3 CR = mix(R,C,mask);\n    \n    // output\n    CR=pow(CR, vec3(.4545));\n    fragColor = vec4(CR,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Infinite Soothing Balls \n    09/04/22 @byt3_m3chanic \n    \n    Rework of a little animation though a nice little log-polar coordinates.\n    (my original shader) https://www.shadertoy.com/view/fsscWf \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    100.\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat box(vec2 p, vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat capp( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nvec3 hp= vec3(0),hitPoint= vec3(0);\nfloat tmod=0.,ga1,ga2,ga3,ga4,ga5;\nmat2 rpi,rnp,rg1,rg2,rg3,rg4,rg1a,rg2a,rg3a,rg4a;\n\nconst float scale = 4.;\nconst float quad = scale/2.;\nconst float cell = quad/2.;\nconst float spce = cell/2.;\nconst vec2 l = vec2(scale,scale);\nconst vec2 s = l*2.;\n\nconst float density = 12.;\nconst float dshalf = density/2.;\nfloat shorten = 1.5, lpscale=0., movement=0., time=0.;\n\nvec2 map(vec3 q3) {\n    vec2 res = vec2(1e5,0.);\n\n    q3=-q3;\n    q3.y-=.5;\n    q3.xz*=rot(T*.152);\n    \n    // log-spherical map\n    float r = length(q3);\n    float mul = r/lpscale;\n    q3 = vec3(log(r), acos(q3.y / r ), atan(q3.z, q3.x));\n    q3 *= lpscale;\n    q3 -= vec3(movement,dshalf,2.);\n\n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    \n    float ld=1e5,lf=1e5,lb=1e5,bx=1e5;\n    \n    // Multi Tap distance map picked up from @Shane\n    // https://www.shadertoy.com/view/WtffDS\n    for(int i = 0; i<4; i++) {\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\t// Block center.\n        p = q3.xz - ct*s;\t\t\t\t// Local coordinates. \n        ip = floor(p/s) + .5;\t\t\t// Local tile ID. \n        p -= (ip)*s; \t\t\t\t\t// New local position.\t\t   \n        vec2 idi = (ip + ct)*s;\t\t\t// Correct position & tile ID.\n\n        vec3 q = vec3(p.x,q3.y,p.y);\n\n        vec3 q1 = vec3(p.x+cell,q3.y,p.y+cell);\n\n        q1.xz=abs(abs(q1.xz)-scale)-quad;\n \n        if(tmod<1.){\n            q1.z+=ga1*quad;\n            q1.yz*=rg2;\n        }else if(tmod<2.){\n            q1.z+=quad;\n            q1.x+=ga2*quad;\n            q1.yz*=rnp;\n            q1.yx*=rg3;\n\n        }else if(tmod<3.){\n            q1.z-=quad;\n            q1.x-=quad;\n            q1.z+=ga3*quad;\n            q1.yz*=rg2a;\n        } else {\n            q1.x+=quad;\n            q1.x-=ga4*quad;\n            q1.yx*=rpi;\n            q1.yx*=rg3a;\n        }\n\n        float s1 = length(q1)-.65;\n\n        s1=max(box(q1+vec3(spce,0,spce),vec3(.5,1,.5)),s1);\n        ld = min(ld,s1);\n\n        if(ld<res.x) {\n            res = vec2(ld,1.);\n            hp=q3-cell;\n        }\n        q.xz=abs(abs(q.xz)-quad)-cell;\n        lb = min( capp(q,.05,.75), bx); \n        lb = min( capp(q,.05,.75), lb);\n    }\n\n    if(lb<res.x) {\n        res = vec2(lb,5.);\n        hp=q3;\n    }\n        \n    float fx = q3.y+.625;\n    if(fx<res.x) {\n        res = vec2(fx,6.);\n        hp=q3;\n    }\n    \n    res.x *= mul/shorten;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<1e-8) hit = true;\n        d += i<32? t.x*.5:t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>175.) break;\n    } \n    return vec2(d,m);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*4.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 128);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-1.5,8,-2.5);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        float t=.025;\n        for( int i =0; i<16; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h * .9;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 15.);\n        fresnel = mix(.0, .9, fresnel);\n\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(normalize(p - ro), ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n\n        if(m==1.) {\n            vec2 id = floor(hitPoint.xz*.5);\n            h=vec3(.25);\n            if(mod(id.x+id.y,2.)<1.)h=vec3(.75);\n            ref = h*.5;\n        }\n        \n        if(m==5.) {\n            h=vec3(0.502,0.502,0.502);\n            ref = h*.25;\n        }\n\n        if(m==6.) {\n            vec2 id = floor(hitPoint.xz*.5);\n            vec2 uv = fract(hitPoint.xz*.5)-.5;\n            h=vec3(.3);\n            float fs = mod(hash21(id)*PI2,.4);\n            vec3 clr = hsv2rgb(vec3(T*.075+fs,.9,.25));\n            uv*=rot(.78);\n            float d = box(uv,vec2(.315))-.05;\n            float d1 = box(uv,vec2(.3))-.05;\n            float d2 = box(uv,vec2(.275))-.05;\n            float px = 4./R.x;\n            d1= smoothstep(px,-px,abs(d1)-.015);\n            d2= smoothstep(px,-px,abs(d2)-.035);\n            d=smoothstep(px,-px,d);\n            h=mix(h,clr,d);\n            h=mix(h,h*.5,d2);\n            h=mix(h,vec3(.9),d1);\n            ref=h;\n        }\n\n        RC = h * diff + min(spec,shdw);\n        \n        if(bnc<2) RC = mix(RC,vec3(.05), 1.-exp(-.0025*d*d*d));\n        \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.149,0.157,0.173);\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tmod = mod(T*.5,4.);\n    float t1 = lsp(0.0, 1.0, tmod);\n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n\n    float t2 = lsp(1.0, 2.0, tmod);\n    ga2 = eoc(t2);\n    ga2 = ga2*ga2*ga2;\n    \n    float t3 = lsp(2.0, 3.0, tmod);\n    ga3 = eoc(t3);\n    ga3 = ga3*ga3*ga3;\n\n    float t4 = lsp(3.0, 4.0, tmod);\n    ga4 = eoc(t4);\n    ga4 = ga4*ga4*ga4;\n    \n    rpi = rot(PI);\n    rnp = rot(-PI);\n\n    rg2 = rot(-ga1*PI);\n    rg3 = rot(ga2*PI);\n\n    rg2a = rot(-ga3*PI);\n    rg3a = rot(ga4*PI);\n\n    lpscale = floor(density)/PI;\n    movement = .55*-T*lpscale*.25;\n    \n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 5.;\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0.,0.,1.5);\n\n    float y = M.xy==vec2(0) || M.z<1. ? .0 : -(M.x/R.x*2.-1.)*PI;\n    mat2 rx =rot(.42);\n    mat2 ry =rot(y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float d = 0., fA = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    \n    C = mix(C,vec3(.05), 1.-exp(-.0001*fA*fA*fA));\n    C = clamp(C,vec3(.001),vec3(.9999));\n   // C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}