{
    "Shader": {
        "info": {
            "date": "1705610065",
            "description": "gyrnoise and bump mapping",
            "flags": 32,
            "hasliked": 0,
            "id": "clG3RG",
            "likes": 13,
            "name": "Iridescent smoke",
            "published": 3,
            "tags": [
                "cartoon",
                "smoke"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "#define M(uv) dot(texture(iChannel0, uv*.25).rgb, vec3(.115, .5, .3))*45.\n#define R iResolution\n\nvec3 get_mCol(vec2 p){\n    float k = .5/R.y;\n    vec3 sn =  normalize(\n      vec3( M(p - vec2(k,.0)) - M(p + vec2(k,.0)),\n             M(p - vec2(.0,k)) - M(p + vec2(0.,k)),\n            1.));\n    vec3 sp = vec3(p, .0); \n    vec3 rd = normalize(vec3(p-.5, 1.)); \n    vec3 lp = vec3(10.,-4., -1.); \n \tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n    vec3 ldf = vec3(-ld.xy, ld.z);\n    float fresnel = pow( 1.+ dot(sn, ldf), 5. );\n   return vec3(fresnel)*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = get_mCol(uv)*texture(iChannel0, uv).rgb;\n    fragColor = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return (a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nfloat hash21( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n)).x;\n}\nfloat noise21(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define ROT mat3(cos(.7), 0., sin(.7), 0., 1., 0., -sin(.7), 0., cos(.7))\n#define ROT2 ROT*mat3(1., 0., 0., 0., cos(7.), sin(.7), 0., -sin(.7), cos(.7))\n#define ROT3 ROT2*mat3(cos(.7), sin(.7), 0., -sin(.7), cos(.7), 0., 0., 0., 1.)\n\nvec3 palette(float t){\n\n    vec3 a = vec3(.5);\n    vec3 b = vec3(.5);\n    vec3 c = vec3(1.);\n    vec3 d = vec3(.33,.66,.99);\n    vec3 col = a + b * cos((c*t*.2+d)*3.14159*2.);\n    return col*.3 + .7*vec3(0.800,0.714,0.980);\n}\n\nfloat gyroid(vec3 p){\n    return abs(dot(cos(p), sin(p.zxy)));\n}\nfloat gyronoise(vec2 uv){\n    vec3 p = uv.xyx;\n    float A = 1.;\n    float n = 0.;\n    float k = .5;\n    float f = 1.;\n    float dt = 1.;\n    for (int i=0; i<4; i++){\n        p += .1*sin(p.xzy*.75*f+iTime*2.);\n        n += gyroid(p + iTime*.1*dt)*A-k; \n        A *= .7;\n        dt *= 1.1;\n        p *= 1.5*ROT3;\n        k -= .2 + .1 * cos(iTime*.2 + float(i)*17.2);\n        f *= 1.4;\n    }\n    return n*.5;\n}\n\nvec3 color(vec3 a, float value, float f){\n    return a * step(value-.1, f)*step(value+.1, f);\n}\n\nfloat s(float x){\n    float n = 15.;\n    return (pow(x, n) - pow(1.-x, n))*.5;\n}\n\nfloat smoothfloor(float x){\n    return s(mod(x, 1.))+floor(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float f = clamp(gyronoise(uv*6. + iTime/10.), 0., 1.);\n    f = smoothfloor(pow(f, .12)*20.)/5.;\n\n    vec3 col = vec3(0.);\n    //col = vec3(0.141,0.259,0.204)*pow(f/5., 3.)*4.;\n    col = pow(palette(f*2. + noise21(uv*7.+ noise21(iTime*.5+4.*uv.xy)) + iTime), vec3(1./(1.+pow(f/5., 8.))))*pow(f/5., 4.)*4.5;\n    //vec2 shadow = texture(iChannel0, uv).xy;\n    //float s = floor(shadow.y*4.)/4.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}