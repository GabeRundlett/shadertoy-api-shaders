{
    "Shader": {
        "info": {
            "date": "1720636426",
            "description": "from https://www.shadertoy.com/view/ct2yDd",
            "flags": 0,
            "hasliked": 0,
            "id": "XXVSWt",
            "likes": 1,
            "name": "galaxy spiral remix",
            "published": 3,
            "tags": [
                "spiral",
                "galaxy"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 111
        },
        "renderpass": [
            {
                "code": "/*\n    from: Mermersk (ic4ruz39@gmail.com)\n*/\n#define PI 3.1415926\n#define PI2 6.283186\n#define e 2.71828\n\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat noise1d(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\t\n\treturn mix(hashwithoutsine11(i), hashwithoutsine11(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,711.7)),\n              dot(st,vec2(619.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*23758.545123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 rotZ(vec3 p, float angle) {\n\t\n\tmat3 m = mat3(cos(angle), -sin(angle), 0.0,\n\t\t\t\t  sin(angle), cos(angle), 0.0,\n\t\t\t\t  0.0, 0.0, 1.0);\n\t\t\t\t  \n\treturn m * p;\n}\n\n\n/*\nFractal brownian motion\nIs about adding noise together. From book of shaders:\nBy adding different iterations of noise (octaves), where we successively \nincrement the frequencies in regular steps (lacunarity) and decrease the amplitude (gain) \nof the noise we can obtain a finer granularity in the noise and get more fine detail. \nThis technique is called \"fractal Brownian Motion\" (fBM), or simply \"fractal noise\".\n\nFor each octave(iteration): Increase the frequency of the wave(by 2.0) -> Called the lacunarity value.\n\t\t\t\t\t\t\tDecrease the amplitude of the wave(by 0.5) -> Called the gain.\n*/\nfloat fbm(vec2 uv, float seed, int o, float l, float g, float a, float f, bool rot, bool absolute) {\n\tfloat fbm = 0.0;\n\t\n\t//Constant value, octaves is the number of iterations.\n\tint octaves = o;//16;\n\tfloat lacunarity = l;//8.0;\n\tfloat gain = g;//0.85;\n\t\n\t//Initial values, are changed on each ocatve/iteration.\n\tfloat amplitude = a;//0.5;\n\tfloat frequency = f;//10.0;\n\t\n\tfor (int i = 0; i < octaves; i++) {\n        float newVal = amplitude * noise(uv * frequency + seed);\n        \n        if (absolute) newVal = abs(newVal);\n        \n\t\tfbm += newVal;\n\t\t\n        if (rot) uv = rotZ(vec3(uv.x, uv.y, 0.0), float(i)).xy;\n        \n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t\n\t}\n\t\n\treturn fbm;\n}\n\n//Trying oyut domain warping of noise: https://iquilezles.org/articles/warp/\nfloat dwPattern(vec2 p) {\n    \n    float n = 0.0;\n    \n    //p = rotZ(vec3(p.x, p.y, 0.0), iTime*0.1).xy;\n    \n    vec2 q = vec2(fbm(p + vec2(20.0, 0.0), 549.0, 8, 1.3, 0.75, 0.85, 0.45, true, true), fbm(p + vec2(3.6, 4.2), 339.0, 8, 1.3, 0.75, 0.85, 0.45, true, false));\n    \n    n = fbm(p + q, 784.0, 6, 2.5, 0.35, 0.003, 2.75, true, false);\n    \n    //n = fbm(p, 39.0, 8, 1.3, 0.75, 0.85, 0.45, true, true);\n    \n    return n*1.0;\n\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvec3 galaxy(vec2 uv, vec2 polarUV, vec3 col) {\n    \n    float size = 25.0;\n    float len = polarUV.x*size;\n    float angle = polarUV.y;\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;\n    //Archimedean spiral\n    float d = abs(mod(len - angle*4.0, PI2)-PI);\n    float spiralD = d;\n    //SpiralAngle from 0 to infinty\n    float spiralAngle = angle + (PI2 * floor(len/PI2));\n    \n    //Control distance between each spiral arm, neede more blackess between\n    float spiralArmRadius = 3.0;\n    spiralD = 1.0-smoothstep(0.0, spiralArmRadius, spiralD);\n    \n    //Cut out circle of siral galaxy and fade to black\n    spiralD *= smoothstep(1.0, 0.0, length(uv))*150.0;\n    \n    float starN = fbm(uv, 239.0, 8, 1.8, 0.85, 0.5, 10.0, true, false);\n    \n    float starN2 = fbm(uv, 69.0, 8, 1.8, 0.85, 0.5, 10.0, true, false);\n    \n    starN = starN*starN*starN*starN*starN;\n    starN2 = starN2;\n    \n    //Galaxy cloud like pattern inbetween stars\n    float cloudN = dwPattern(uv);\n    \n    //galaxyColor is color of the stars in this area\n    float galaxyColorInput = len*0.1 + 169.0 + noise1d(angle*1.0+55.0);\n    vec3 galaxyCol =  hash31(ceil(galaxyColorInput));\n    vec3 nextGalaxyCol = hash31(ceil(galaxyColorInput + 1.0));\n    \n    galaxyCol = mix(galaxyCol, nextGalaxyCol, smoothstep(0.5, 1.0, fract(galaxyColorInput)));\n    \n    galaxyCol *= vec3(1.0, 1.2, 10.74);\n    \n    vec3 cloudCol = cloudN * galaxyCol;//mix(clamp(dwNoise * vec3(1.0, 1.0, 2.0), 0.0, 1.0), vec3(1.0), 0.0005);\n    \n    vec3 starCol = mix(vec3(0.0), galaxyCol, 1.0-exp(starN*50.0));\n    \n    vec3 starCol2 = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), 1.0-exp(starN2*10.0));\n    \n    vec3 combinedStarCol = max(starCol/starCol2, 0.0);\n    \n    vec3 finalCol = mix(vec3(1.0), combinedStarCol, spiralD);\n    \n    finalCol += mix(vec3(1.0), cloudCol*100.0, spiralD*0.25 + smoothstep(1.25, 0.0, length(uv))*20.0); //smoothstep(1.25, 0.0, length(uv))*20.0\n    \n    return finalCol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv * 2.0) - 1.0;\n    \n    vec3 col = vec3(0.0);\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x *= ar;\n    \n    //uv = rotZ(vec3(uv.x, uv.y, 0.0), iTime*0.001).xy;\n    \n    vec2 polarUV = vec2(length(uv), atan(uv.y, uv.x)+PI);\n    \n    col = galaxy(uv, polarUV, col);\n    \n    col = pow(col, vec3(1.4545));\t// gamma correction\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(.35,0.2,1.35)*5.1, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}