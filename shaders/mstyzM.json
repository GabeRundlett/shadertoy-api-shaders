{
    "Shader": {
        "info": {
            "date": "1694877998",
            "description": "Using 2D rotation to make our Quad rotate against the pivot of the screen.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "mstyzM",
            "likes": 1,
            "name": "SoftUni - Waving Quad",
            "published": 3,
            "tags": [
                "wavingquad"
            ],
            "usePreview": 0,
            "username": "angle_",
            "viewed": 140
        },
        "renderpass": [
            {
                "code": "vec4 TRIANGLE(vec3 color, vec3 background, vec2 v0, vec2 v1, vec2 v2, vec2 uv);\n\n// Rotation matrix around the X axis.\nmat2 Rotate2D(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    \n    return mat2(cosAngle, -sinAngle,\n                    sinAngle, cosAngle);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0; 1] - for the width and height of the screen\n    vec2 screen_uv = fragCoord/iResolution.xy;\n\t\n    // [0; 1] - Color - Red, Green, Blue\n    vec3 color = vec3(0.0);\n    \n    vec4 VERTEX_BUFFER[4] = vec4[]\n    (\n        vec4(0.7, 0.75, 1.0, 1.0), //top-right\n        vec4(0.3, 0.25, 0.0, 0.0), //bottom-left\n        vec4(0.7, 0.25, 0.0, 1.0), //bottom-right\n        vec4(0.3, 0.75, 1.0, 0.0)  //top-left\n        \n    );\n\n    ivec3 INDEX_BUFFER[2] = ivec3[]\n    (\n        ivec3(0, 1, 2),\n        ivec3(0, 1, 3)\n    );\n    \n    // Index Buffer Render\n    for(int i = 0; i < 2; i += 1) {\n        ivec3 idx = INDEX_BUFFER[i];\n        \n        float mils = (iDate.w) * 1.0 ;\n        vec2 v0 =  Rotate2D(sin(mils) * 0.78539816339) * vec2(VERTEX_BUFFER[idx.x].xy);                \n        vec2 v1 =  Rotate2D(sin(mils) * 0.78539816339) * vec2(VERTEX_BUFFER[idx.y].xy);\n        vec2 v2 =  Rotate2D(sin(mils) * 0.78539816339) * vec2(VERTEX_BUFFER[idx.z].xy);\n        \n        vec2 v0_uv = vec2(VERTEX_BUFFER[idx.x].zw);                \n        vec2 v1_uv = vec2(VERTEX_BUFFER[idx.y].zw);\n        vec2 v2_uv = vec2(VERTEX_BUFFER[idx.z].zw);\n        \n        // Channel X, Y, Z = v0, v1, v2 barycentric weights, \n        // Channel W = 0.0 -> miss || 1.0 -> hit\n        vec4 result = TRIANGLE(vec3(0.0), color, v0,  v1,  v2 , screen_uv);\n        \n        if(result.w == 1.0) {\n            vec2 vertex_uv = v0_uv * result.x + v1_uv * result.y + v2_uv * result.z;\n            \n            // Bary Render\n            color = result.xyz;\n            \n            //UV Render\n            //color = vec3(vertex_uv, 0.0);\n            \n            //Texture Render\n            vertex_uv.x = vertex_uv.x * iChannelResolution[0].x;\n            vertex_uv.y = vertex_uv.y * iChannelResolution[0].y;\n            //color = texelFetch(iChannel0, ivec2(vertex_uv), 0).xyz;\n            \n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\nfloat TRIANGLE_sign(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nvec3 barycentrics(vec2 p, vec2 a, vec2 b, vec2 c){\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float den = v0.x * v1.y - v1.x * v0.y;\n    float x = (v2.x * v1.y - v1.x * v2.y) / den;\n    float z = (v0.x * v2.y - v2.x * v0.y) / den;\n    //Няма смисъл да го изчисляваме трето ако\n    // x + y + z = 1.0\n    float y = 1.0f - x - z; \n    \n    return vec3(x, y, z);\n}\n\nvec4 TRIANGLE(vec3 color, vec3 background, vec2 v0, vec2 v1, vec2 v2, vec2 uv)\n{\n    bool b1 = TRIANGLE_sign(uv, v0, v1) < 0.0f;\n    bool b2 = TRIANGLE_sign(uv, v1, v2) < 0.0f;\n    bool b3 = TRIANGLE_sign(uv, v2, v0) < 0.0f;\n    \n    vec3 bary_res = barycentrics(uv, v0, v1, v2);\n    if((b1 == b2) && (b2 == b3)) return vec4(bary_res, 1.0);\n    return vec4(background, 0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}