{
    "Shader": {
        "info": {
            "date": "1532425995",
            "description": "Lots more ducks...  (mouseable)",
            "flags": 0,
            "hasliked": 0,
            "id": "4tdcW8",
            "likes": 15,
            "name": "Plenty O'Dux",
            "published": 3,
            "tags": [
                "wheel",
                "icosahedron",
                "gear",
                "symmetry",
                "polyhedron",
                "duck"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "// \"Plenty O'Dux\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Lots more ducks than in my earlier \"Dodecahedral Duckohedron\" (mouseable).\n  Starting from Shane's \"Polyhedral Gears\" -- see his comments for background, including\n  work by DjinnKahn and Knighty, as well as Goldberg polyhedra.\n*/\n\n#define AA    0\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 OrthMat (vec3 n);\n\nmat3 icMat[4], hxMat[3];\nvec3 vf[3], qWhl, ltDir;\nfloat dstFar, tCur, dSpoke, dAxl, dTooth, dWhl, dDuk;\nint idObj;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec3 IcosSymP (vec3 p)\n{\n  vec3 s;\n  s = sign (p);\n  for (int k = 0; k < 3; k ++) {\n    p = icMat[k] * abs (p);\n    s *= sign (p);\n  }\n  return abs (p) * vec3 (s.x * s.y * s.z, 1, 1);\n}\n\nfloat DukDist (vec3 p, float szFac, float a)\n{\n  vec3 q;\n  vec2 r, cs;\n  float d, h, s;\n  d = dstFar / szFac;\n  p /= szFac;\n  p.xz = Rot2D (p.xz, a);\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (d, min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h));\n  q = p;  q.x = abs (q.x);  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (d, SmoothMin (min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h), d, 0.01));\n  q = p;  q.yz -= vec2 (0.15, -0.08);\n  d = min (d, SmoothMin (PrEllipsDf (q, vec3 (0.08, 0.07, 0.1)), d, 0.02));\n  q = p;  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = min (d, max (PrEllCylDf (q, r, h), - PrEllCylDf (q - vec3 (0., 0., h), r - 0.004, 2. * h)));\n  return d * szFac;\n}\n\nfloat ToothDist (vec3 p, float nt, float a, float rad, float thk)\n{\n  vec3 q;\n  q = p;\n  q.xy = Rot2D (q.xy, (floor (a * nt) + 0.5) * 2. * pi / nt);\n  q.x += rad;\n  thk *= 0.7 + 2. * q.x;\n  q = abs (q);\n  return max (0.5 * (max (q.x - 0.05, q.y - 0.02) + length (q.xy * vec2 (0.71, 1.)) - 0.025), q.z - thk);\n}\n\nvoid PentDist (vec3 p, float rad, float thk)\n{\n  vec3 q;\n  float a, tRad;\n  tRad = (0.9 + p.z) * rad;\n  p.xy = Rot2D (p.xy, - mod (tCur / 1.5, 2. * pi / 5.) - pi);\n  a = atan (p.y, abs (p.x)) / (2. * pi);\n  q = p;\n  q.xy = Rot2D (q.xy, (floor (a * 5.) + 0.5) * 2. * pi / 5.);\n  dAxl = max (max (abs (q.x), abs (q.y)) - 0.15 * rad, abs (q.z - 0.5 * thk) - 0.5 * thk);\n  q += vec3 (0.5 * rad, 0., -0.5 * thk);\n  dSpoke = PrCylDf (q.zyx, 0.1 * rad, 0.4 * rad);\n  q += vec3 (0.3 * rad, 0., -0.6 * thk);\n  dDuk = DukDist (q.yzx, 0.8 * rad, tCur / 1.5);\n  dWhl = PrRoundBox2Df (vec2 (length (p.xy) - 0.8 * tRad, p.z), vec2 (0.2 * tRad, thk), 0.05 * thk);\n  qWhl = q;\n  dTooth = ToothDist (p, 15., a, tRad, thk);\n}\n\nvoid HexLDIst (vec3 p, float rad, float thk)\n{\n  vec3 q;\n  float a, tRad;\n  p.z = - p.z;\n  tRad = (0.9 + p.z) * rad;\n  p.xy = Rot2D (p.xy, - mod (tCur / 1.8, pi / 3.) - pi / 3.);\n  a = atan (p.y, abs (p.x)) / (2. * pi);\n  q = p;\n  q.xy = Rot2D (q.xy, (floor (a * 6.) + 0.5) * 2. * pi / 6.);\n  dAxl = max (max (abs (q.x), abs (q.y)) - 0.15 * rad, abs (q.z - 0.5 * thk) - 0.5 * thk);\n  q += vec3 (0.5 * rad, 0., -0.5 * thk);\n  dSpoke = PrCylDf (q.zyx, 0.1 * rad, 0.4 * rad);\n  q += vec3 (0.3 * rad, 0., -0.6 * thk);\n  dDuk = DukDist (q.yzx, 0.8 * rad, - 2. * tCur / 1.8);\n  dWhl = PrRoundBox2Df (vec2 (length (p.xy) - 0.8 * tRad, p.z), vec2 (0.2 * tRad, thk), 0.05 * thk);\n  qWhl = q;\n  dTooth = ToothDist (p, 18., a, tRad, thk);\n}\n\nvoid HexSDist (vec3 p, float rad, float thk)\n{\n  vec3 q;\n  float a, tRad, t;\n  tRad = (0.9 + p.z) * rad;\n  t = sign (p.x) * tCur / 1.2;\n  p.x = abs (p.x);\n  q = p;\n  q.xy = Rot2D (q.xy, - mod (t, pi / 3.) - 2. * pi / 3.);\n  q.xy = Rot2D (q.xy, (floor (atan (q.y, abs (q.x)) / (2. * pi) * 6.) + 0.5) * pi / 3.);\n  dAxl = max (max (abs (q.x), abs (q.y)) - 0.15 * rad, abs (q.z - 0.5 * thk) - 0.5 * thk);\n  q += vec3 (0.5 * rad, 0., -0.5 * thk);\n  dSpoke = PrCylDf (q.zyx, 0.1 * rad, 0.4 * rad);\n  q += vec3 (0.3 * rad, 0., -0.6 * thk);\n  dDuk = DukDist (q.yzx, 0.8 * rad, 2. * t);\n  dWhl = PrRoundBox2Df (vec2 (length (p.xy) - 0.8 * tRad, p.z), vec2 (0.2 * tRad, thk), 0.05 * thk);\n  qWhl = q;\n  q = p;\n  q.xy = Rot2D (q.xy, - mod (t + pi / 12., pi / 6.) - 5. * pi / 6.);\n  dTooth = ToothDist (q, 12., atan (q.y, abs (q.x)) / (2. * pi), tRad, thk);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 hxv, qqw1, qqw2;\n  float dMin, d, thk;\n  dMin = dstFar;\n  d = length (p) - 1.2;\n  if (d < 0.02) {\n    thk = 0.1;\n    hxv = IcosSymP (p);\n    for (int k = 0; k < 4; k ++) {\n      if (k == 0) PentDist (icMat[3] * hxv - vec3 (0., 0., 1.), 0.185, thk);\n      else if (k == 1) HexLDIst (hxMat[0] * (hxv - vf[2]), 0.25, thk);\n      else HexSDist (hxMat[k - 1] * (hxv - vf[k - 2]), 0.16, thk);\n      if (dSpoke < dMin) { dMin = dSpoke;  idObj = 1; }\n      if (dWhl < dMin) {\n        dMin = dWhl;\n        if (k < 2) { idObj = 2;  qqw1 = qWhl; }\n        else { idObj = 3;  qqw2 = qWhl; }\n      }\n      if (dTooth < dMin) { dMin = dTooth;  idObj = 4; }\n      if (dAxl < dMin) { dMin = dAxl;  idObj = 5; }\n      if (dDuk < dMin) { dMin = dDuk;  idObj = 6; }\n    }\n    if (idObj == 2) qWhl = qqw1;\n    if (idObj == 3) qWhl = qqw2;\n    dMin *= 0.9;\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = 1.; j <= 4.; j ++) {\n    d = 0.02 * j;\n    ao += max (0., d - 5. * ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - ao, 0., 1.);\n}\n\nvoid InitBasis ()\n{\n  vec3 v0, v1, v2, u;\n  vec2 e = vec2 (1., -1.);\n  float c;\n  v0 = vec3 (0, 1., phi - 1.);\n  v1 = v0.zxy;\n  v2 = v1 * e.yxx;\n  vf[0] = (2. * v0 + v2) / 3.;\n  vf[1] = (2. * v0 + v1) / 3.;\n  vf[2] = (v0 + vec3 (0., 0., 2.)) / 3.;\n  hxMat[0] = OrthMat (cross (vf[2] - v0, vf[2] - v1));\n  hxMat[1] = OrthMat (vf[0]);\n  hxMat[2] = OrthMat (vf[1]);\n  c = 1. / sqrt (phi + 2.);\n  vf[0] *= 1.1547 * c * phi;\n  vf[1] *= 1.1547 * c * phi;\n  vf[2] *= 1.2425 * c * phi;\n  u = 0.5 * vec3 (1., phi - 1., phi);\n  icMat[0] = mat3 (u.xzy * e.xyx, u.zyx * e.xxy, u.yxz);\n  icMat[1] = mat3 (u.zyx * e.xxy, u.yxz, u.xzy * e.xyx);\n  icMat[2] = mat3 (u.yxz * e.yyx, u.xzy * e.xyy, u.zyx);\n  icMat[3] = 0.5 * mat3 (sqrt (3. - phi), - phi, 0., - c * phi, 1. - phi, 2. * c * phi,\n     c * sqrt (2. + 3. * phi), 1., 2. * c);\n}\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  InitBasis ();\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (0.6, 0.6, 0.65);\n    else if (idObj == 2) col = vec3 (0.7, 0.7, 0.3);\n    else if (idObj == 3) col = vec3 (0.7, 0.7, 0.3);\n    else if (idObj == 4) col = vec3 (0.7, 0.7, 0.3);\n    else if (idObj == 5) col = vec3 (0., 0.4, 0.1);\n    else if (idObj == 6) col = vec3 (1., 0.2, 0.1);\n    if (idObj == 2 || idObj == 3) col *= 0.6 + 0.4 * step (0.003, abs (qWhl.y));\n    col = col * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n       0.3 * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col *= ObjAO (ro, vn) * (1. - smoothstep (3., 5., dstObj));\n  } else col = vec3 (0.1);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  zmFac = 2.2;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 3. * SmoothBump (0.25 * pi, 0.75 * pi, 0.2 * pi, mod (az, pi));\n  } else {\n    az += 0.05 * pi * tCur;\n    el -= 0.2 * pi * sin (0.06 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -3.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (1., 1., -1));\n  dstFar = 10.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 OrthMat (vec3 n)\n{\n  mat3 mm;\n  float a;\n  n = normalize (n);\n  if (n.z > -1.) {\n    a = 1. / (1. + n.z);\n    mm = mat3 (1. - n.x * n.x * a, - n.x * n.y * a, n.x,\n       - n.x * n.y * a, 1. - n.y * n.y * a, n.y, - n.x, - n.y, n.z);\n  } else mm = mat3 (1., 0., 0., 0., 1., 0., 0., 0., -1.);\n  return mm;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}