{
    "Shader": {
        "info": {
            "date": "1633287447",
            "description": "A noisy ball of fur for your enjoyment",
            "flags": 0,
            "hasliked": 0,
            "id": "NdtXW8",
            "likes": 11,
            "name": "Tumble",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fur"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "// Tumble by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define sat(x) (clamp((x), 0., 1.))\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(1.433, 1.512))) * 4313.441);\n}\n\nfloat hash13(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(1.433, 1.512, 2.421))) * 4313.441);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(mix(hash12(i),hash12(i+o),f.x),\n               mix(hash12(i+o.yx),hash12(i+1.),f.x),\n               f.y);\n}\n\nfloat noise3(vec3 p)\n{\n\tvec3 i = floor(p);\n    vec3 f = smoothstep(0.,1.,p-i);\n    const vec2 o = vec2(1.,0.);\n    \n    return mix(\n               mix(mix(hash13(i),hash13(i+o.xyy),f.x),\n                   mix(hash13(i+o.yxy),hash13(i+o.xxy),f.x),\n                   f.y),\n               mix(mix(hash13(i+o.yyx),hash13(i+o.xyx),f.x),\n                   mix(hash13(i+o.yxx),hash13(i+1.),f.x),\n                   f.y),\n               f.z);\n}\n\nfloat fur(vec3 p)\n{\n    float len = length(p);\n    p = normalize(p);\n    float thickness = noise3(normalize(p) * 140.);\n    return len - 2. + (thickness * len) * .25;\n}\n\nvec3 spin(vec3 p, float d)\n{\n    float t = iTime * .5 - d * d * .125;\n    p.xz *= rot(sin(t * 2.));\n    p.zy *= rot(sin(t * 1.5));\n    return p;\n}\n\nfloat scene(vec3 p)\n{\n    float d = length(p);\n    if(d <= 2.)\n    {\n        return fur(spin(p, d));\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec2 e = vec2(.0001, 0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30 && t < maxDist; ++i)\n    {\n        d = scene(ro + rd * t);\n        t += d;\n    \tif(abs(d) < .00001)\n            return 0.;\n    }\n    return 1.;\n}\n\nvec3 color(vec3 p)\n{\n    float d = length(p);\n    p = normalize(p);\n    \n    float a = noise3(spin(p, d).xyz * 20.);\n    vec3 c = vec3(1., .01, .8) * (a * .8 + .2);\n    return erot(c, normalize(vec3(1)), fract(a * 11.) * 2. - 1.);\n}\n\nvoid img( inout vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy * .5)/iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 ro = vec3(0, 0, -4);\n    vec3 p;\n    \n    float d, t = 2.;\n    float i = 0.;\n    // shorten the raymarching step at grazing angles\n    float tangentBias = 1. / (1. + smoothstep(.25, .5, length(uv)) * .75);\n    for(; i < 1. && t < 6.; i += 1./32.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        t += d * tangentBias * sat(length(p) * .5);\n        if(abs(d) < .0001)\n            break;\n    }\n    \n    vec3 col = vec3(.025, .025, .035);\n    if (t < 6.)\n    {\n        \n        vec3 n = normal(p, d);\n        vec3 dirL = normalize(vec3(1, 1, -2));\n        n.xz *= rot(iTime * .4);\n        float l = dot(max(n, 0.), vec3(.4,.5,.3));\n        l *= shadow(p + n * .01, vec3(0,1,0), 10.);\n        col = color(p);\n        float lum = dot(col, vec3(.2,.7,.1));\n        col = mix(col * l + vec3(0.,.001,.002), vec3(1., .98, .95) * l, l*l*(.5 + lum));\n        float ao = (1. - max(i - l*l, 0.) * .8);\n        col *= ao;\n    }\n\n    fragColor += vec4(col,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0);\n    img(fragColor, fragCoord);\n    vec2 o = vec2(.03125, .015625);\n    for(float i = 0.; i < 4.; i++)\n    {\n        img(fragColor, fragCoord + o);\n        o = vec2(o.y,-o.x);\n    }\n    fragColor /= 5.;\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n    float vignette = length((fragCoord - iResolution.xy * .5) / iResolution.xy) * 2.;\n    fragColor.rgb *= 1. - vignette * vignette * vignette * .15;\n    fragColor.rgb += noise3(vec3(fragCoord, iFrame)) * .01 - .005;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}