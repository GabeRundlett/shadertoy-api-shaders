{
    "Shader": {
        "info": {
            "date": "1483933822",
            "description": "Playing with repeating infinite lines in the arrangement of a polygon ",
            "flags": 0,
            "hasliked": 0,
            "id": "MtKSDR",
            "likes": 8,
            "name": "Infinite Polygon Lines Repeated",
            "published": 3,
            "tags": [
                "lines",
                "polygon",
                "repeating"
            ],
            "usePreview": 0,
            "username": "cacheflowe",
            "viewed": 833
        },
        "renderpass": [
            {
                "code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\n// infinite line function from http://stackoverflow.com/a/26902185/352456\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.7;\t\t\t\t\t\t\t\t\t// adjust time\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// center coordinates\n    float dist = length(uv);\t\t\t\t\t\t\t\t\t\t// get dist from center\n    uv *= 1. + (0.75 + sin(time) * 0.25 * dist);\t\t\t\t\t// bulge based on dist from center\n    float rot = 0.5 + 0.75 * sin(time) * dist;\t\t\t\t\t\t// oscillate rotation\n    uv *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\t\t\t// rotate\n    float segmentRads = TWO_PI / 6.;\n    float col = 1.;\n    float distThresh = 0.07 + 0.01 * cos(time);\n    float radius = 0.2 + 0.0 * abs(sin(time));\n    float distToLine = 9999.;\n    float totalDist = 0.;\n    float fractZoom = 4. + 1.0 * sin(PI + time);\n    float fractRepeat = 0.55 + 0.1 * sin(PI + time);;\n    for(int i = 0; i < 6; i++) {\n        float curRads = float(i) * segmentRads;\n        float nextRads = float(i + 1) * segmentRads;\n        vec2 point1 = vec2(radius * sin(curRads), radius * cos(curRads));\n        vec2 point2 = vec2(radius * sin(nextRads), radius * cos(nextRads));\n        float dist = distanceToLine(point1, point2, uv);\n        distToLine = min(distToLine, fractRepeat * fract(fractZoom * dist));\n    }\n    if(distToLine < distThresh) {\n        col = smoothstep(0.3, 0.8, distToLine / distThresh);\n    }\n    col += sin(-time) * (length(uv) * 0.35);\n\tfragColor = vec4(vec3(col),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}