{
    "Shader": {
        "info": {
            "date": "1689534720",
            "description": "Inspired by this video by Nils Berglund:\n\nhttps://www.youtube.com/watch?v=pN-gi_omIVE\n\nSimulating refraction with the wave equation, demonstrating total internal reflection and fresnel equations.\n\n* mouse: emit wave\n* space: reset",
            "flags": 48,
            "hasliked": 0,
            "id": "DsBfRm",
            "likes": 11,
            "name": "Wave Refraction",
            "published": 3,
            "tags": [
                "2d",
                "reflection",
                "wave",
                "simulation"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this video by Nils Berglund:\n//\n//      https://www.youtube.com/watch?v=pN-gi_omIVE\n//\n//  Another wave equation shader! Here are some of my other ones if you like this one:\n//\n//      Wave Equation           https://shadertoy.com/view/csXfRS\n//      Parabolic Reflectors    https://shadertoy.com/view/DdffzB\n//      Courant Noise           https://shadertoy.com/view/cslBWX\n//\n//  This shader shows a wavefront refracting when hitting a medium boundary. The bottom\n//  half has a slower speed of light/sound than the upper half. So the bottom might be\n//  water or glass while the top is air. You can see in the waves evidence of total\n//  internal refraction and the fresnel equations.\n//\n//  Here again the incomplete absorbtion of the boundary bedevils me. Definitely\n//  interested in any ideas how to improve that.\n// ---------------------------------------------------------------------------------------\n\nvec4 getColorFromHeight(float d)\n{\n    vec4 c = sin(d * 6e2 * vec4(9, 2, 5, 0));\n    return pow(abs(c), vec4(3));\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float wh = texelFetch(iChannel0, ivec2(u), 0).x; // wave height\n\n    O = getColorFromHeight(wh); // colorize\n    \n    O += abs(u.y / iResolution.y - .5) < .01 ? vec4(.2) : vec4(0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, true); // true for last parameter => update state, emit waves\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define U(u) texelFetch(prevBuffer, ivec2(u), 0) //\nconst float FOCUS_DIST = .45;\n\n#define keyClick(ascii)   ( texelFetch(keyBuffer,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nconst float BOUND_GAMMA = .1; // damping factor for boundary\n\nvec2 initWave(vec2 u, vec2 c, vec2 R)\n{\n    vec2 delta = u - c;\n    float d2 = dot(delta, delta);\n\n    float df = sqrt(d2);\n    return 3. * R.x * vec2(sin(df), cos(df)) / (1. + d2 * 1e6);\n}\n\nvoid updateBuffer(out vec4 O, vec2 u, vec2 R, int iFrame, vec4 iMouse, sampler2D prevBuffer, sampler2D keyBuffer, bool bufferA)\n{\n    vec2 o = vec2(1, 0),\n         p = (u - .5 * R) / R.y;\n\n    vec4 state = texelFetch(prevBuffer, ivec2(0), 0);\n    \n    // handle persistent state\n    if (ivec2(u) == ivec2(0))\n    {\n        if (iFrame == 0 ||\n            state.w != R.x * R.y ||\n            keyClick(KEY_SPACE))\n        {\n            O = vec4(0);\n            O.w = R.x * R.y;\n            return;\n        }\n        \n        O = state;\n        \n        if (bufferA && ++O.z > 25.)\n            O.z = 0.;\n        \n        return;\n    }\n    \n    if (iFrame == 0 ||\n        state.w != R.x * R.y ||\n        keyClick(KEY_SPACE))\n    {\n        // init\n        O = vec4(0);\n        return;\n    }\n    else\n    {\n        float C = p.y > 0. ? .5 : .2; // lower wave speed in lower half\n\n        O = U(u).xxyy; // copies the current value from x to y coordinate to record new previous, put current previous into z for us to use\n\n        if (int(u.y) < 5)\n            O.x = O.x - C * (O.x - U(u + o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing bottom boundary\n        else if (int(u.y) == int(R.y) - 1)\n            O.x = O.x - C * (O.x - U(u - o.yx).x) - BOUND_GAMMA*(O.x-O.z); // absorbing top boundary\n        else if (int(u.x) == 0)\n            O.x = O.x - C * (O - U(u + o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing left boundary\n        else if (int(u.x) == int(R.x) - 1)\n            O.x = O.x - C * (O - U(u - o)).x - BOUND_GAMMA*(O.x-O.z); // absorbing right boundary\n        else\n            O.x = -O.z + 2.*O.x + C*(U(u + o) + U(u - o) + U(u + o.yx) + U(u - o.yx) - 4. * O).x; // apply wave equation\n    }\n\n    if (bufferA)\n    {\n        vec2 h = vec2(.5, .4);\n        \n        // add disturbance at the center\n        if (state.z < 1. || iFrame == 0)\n            O.xy += initWave(u, h * R.xy, R);\n\n        // add disturbance for mouse click\n        if (iMouse.z > 0. && (state.z < 1. || iMouse.w > 0.))\n            O.xy += initWave(u, iMouse.xy, R);\n    }\n    \n    O *= .9995;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 u)\n{\n    updateBuffer(O, u, iResolution.xy, iFrame, iMouse, iChannel0, iChannel3, false);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}