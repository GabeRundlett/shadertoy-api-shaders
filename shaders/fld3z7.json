{
    "Shader": {
        "info": {
            "date": "1635891633",
            "description": "Raymarched Fractal\n\nDepth",
            "flags": 0,
            "hasliked": 0,
            "id": "fld3z7",
            "likes": 1,
            "name": "Fractelligence LookingGlass",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal"
            ],
            "usePreview": 0,
            "username": "PsyPhi",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "//Transforms\nfloat RotX = 1.5; //0 to 3\nfloat RotY = 0.77;\nfloat RotZ = 0.5;\nfloat TransX = 0.92;  //0 to 5\nfloat TransY = 1.8;\nfloat TransZ = 0.6;\nfloat Scale = 0.;\nfloat Range = 0.001;\nfloat RX = 0.;\nfloat RY = 0.;\nfloat RZ = 0.;\nfloat TX = 0.;\nfloat TY = 1.;\nfloat TZ = 0.;\nfloat TwistY = 0.07; //0 to 0.2\nint MirrorX = 1;\nint MirrorY = 1;\nint MirrorZ = 1;\n//Rectange\nint Rectangle = 1;\nfloat RecScale = 1.;\n//Sphere\nint Sphere = 1;\nfloat SphereScale = 1.;\nfloat SphereTX = 0.5;\nfloat SphereTY = 0.2;\nfloat SphereTZ = 0.1;\n//Shapes\nint InfPre = 1;\nint InfPost = 0;\nint Merge = 1;\nfloat ShapeMix = 0.5;\nfloat FractalScale = 0.1;\nfloat NearClip = 5.;\n//Color\nint Iterations = 1;\nfloat IHue = 0.;\nfloat Proximity = 1.;\nfloat PHue = 0.;\nfloat Distance = 1.;\nfloat DHue = 5.;\nfloat light = 0.;\nfloat DepthHue = 0.0;\n//Time\nfloat TimeRotX = 0.3;\nfloat TimeRotY = 0.25;\nfloat TimeTransX = 0.1;\nfloat TimeTransY = 0.05;\n\n\n\n\n\n\n\n#define MAX_STEPS 50\n\n#define MAX_DIST 25.\n\n#define SURF_DIST .001\n\n#define FRACT_STEPS 20\n\n#define PI 3.14159\n\nfloat map(float x, float inMin, float inMax, float outMin, float outMax) {\n    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 hs(vec3 c, float s){\n    vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n    return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nmat2 rotate(float a) {\n\n\tfloat c = cos(a),\n\n\t\ts = sin(a);\n\n\treturn mat2(c, -s, s, c);\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )  //smooth merges two objects\n\n{\n\nfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\nreturn mix( d2, d1, h ) - k*h*(1.0-h);\n\n}\n\n\n\n//_+_+_+_+_+_+_SHAPING FUNCTIONS_+_+_+_+_+_+_+_\nfloat GetDist(vec3 p) {\n\n\n\n\tfloat d = 1.; //Just to have the d var declaired\n\n//\tfloat perStep = 1/FRACT_STEPS;\n\n\tfor (int i = 0; i < FRACT_STEPS ; i++){\n\nif(InfPre == 1) p = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n\t\tif(MirrorX == 1) p.x = abs(p.x); //Mirror X\n\t\tif(MirrorY == 1) p.y = abs(p.y); //Mirror Y\n\t\tif(MirrorZ == 1) p.z = abs(p.z); //Mirror Z\n\n\t\tp.x -= TransX\n        +iMouse.x*Range\n        +TimeTransX*sin(iTime*0.2);\n\t\tp.y -= TransY+iMouse.y*Range\n        +iMouse.y*Range\n        +TimeTransY*cos(iTime*0.1);;\n\t\tp.z -= TransZ;\n\n\n\t\tp.xy *= rotate(RotX+sin(iTime*0.2)*TimeRotX); //Audio rct\n\t\tp.xz *= rotate(RotY+cos(iTime*0.1)*TimeRotY);\n\t\tp.yz *= rotate(RotZ);\n\n    p.xz *= rotate(p.y*TwistY); //Twist\n\nif(InfPost == 1)\t\tp = mod(p+2.5, 5.)-2.5;   //Createts infinity\n\n}\n\nif (Sphere == 1){\n\t\tvec4 sphere = vec4(SphereTX, SphereTY, SphereTZ, SphereScale);\n\t  float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    if(Merge == 1) d = opSmoothUnion(sphereDist, d, ShapeMix);\n    else d = min(sphereDist,d);\n  }\n\n\n\t\t if (Rectangle == 1){//Adds in the Rectangle\n\t\t\t vec4 rec = vec4(0.0, 0.0, 0.0, RecScale);\n\t\t\t float recDist = length(max(abs(p) - rec.w, 0.));\n\t\t\t if(Merge == 1) d = opSmoothUnion(recDist, d, ShapeMix);\n       else d = min(recDist,d);\n\t\t }\n\n\n\t\t// d = min(sphereDist,d);\n\n\n\t//}\n    return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 dO = vec3(NearClip,0.,10.);  //  x = distance ray has traveled, y = Iterations to hit, z = Closest distance to surface\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        float dS = GetDist(p);\n        dO.x += dS;\n\t\t\t\tdO.z = min(dS, dO.z);\n\t\t\t\tdO.y = float(i);\n        if(dO.x>MAX_DIST || dS<SURF_DIST) break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 1, -6);\n    //lightPos.xz += vec2(sin(TIME), cos(TIME))*2.; //light movement\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).x;\n    if(d<length(lightPos-p)) dif *= .1;\n\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd)\n\n{\n\n    vec2 uv = (fragCoord+fragCoord - (iResolution.xy) ) / iResolution.y ;\n    \n\n    vec3 color = vec3(0);\n\n\t\tfloat prox = 0.0;\n\n    vec3 ro = vec3(0, 0, -6+\n      (InfPre+InfPost));  //Audio rct\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    ro = _ro;\n    rd = _rd;\n\n\n    vec3 d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p);  //lighting\n    //color = vec3(dif);\t\t\t\t//lighting\n\n\t\tvec3 n = GetNormal(p);\n\n\n    //+_+_+_+_+_+_+COLORING_+_+_+_+_+_+_\n\n  //vec3 tex =  textureLod(syn_UserImage, _uv, 0.0).rgb;\n\n\t\tcolor.r = (d.y*0.05-(1.-step(d.x*0.04, 1.)))*float(Iterations);\n\n    color = hs(color, IHue);\n\n    color.g = (1.-(d.z+step(d.x*0.04, 1.)))*Proximity\n    // *1.-tex.r\n    ;\t\t\t\t\t\t//G\n\n    color = hs(color, PHue);\n\n    color.b = (1.-d.x*0.04)*Distance;\n\n\n\n    color = hs(color, DHue);\n\n    color += dif*light;       //light\n  //  color += hs(color, 5*dif*light);       //light hue rotate\n\n\t\t  color = hs(color, d.y*DepthHue); //iterations to hue rot\n\n//\t\tcolor -= dif*0.5;\n\n\n\n    fragColor = vec4(color,1.0);\n}\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(15.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}