{
    "Shader": {
        "info": {
            "date": "1604683915",
            "description": "An attemp to reproduce this kind of visual :\nhttps://twitter.com/VisuallySt/status/1314514705222955008/photo/1",
            "flags": 0,
            "hasliked": 0,
            "id": "3dtBR7",
            "likes": 9,
            "name": "Round painting effect",
            "published": 3,
            "tags": [
                "effectuv"
            ],
            "usePreview": 1,
            "username": "ophiase",
            "viewed": 587
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\n\n//////////////////////////////\n/// RANDOM FUNCTIONS\nconst uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fractNoise( in vec2 uv )\n{\n    float f = 0.0;\n    \n    uv *= 8.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    \n    return f;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/////////////////////////////////\n// EFFECT\n\nfloat getAngle(vec2 v)\n{\n    float angle = acos(v.x);\n    if (v.y < 0.0) return -angle;\n\treturn angle;\n}\n\nfloat d_angle(float a, float b)\n{\n    float d1 = abs( mod(a + PI, 2.0 * PI) - mod(b + PI, 2.0 * PI) );\n    float d2 = abs( a - b );\n    return min(d1,d2);\n}\n\nvec2 effect (vec2 uv, vec2 center)\n{\n    vec2 relPos = uv - center;\n    \n    float a  = 700.0;\n    int   b  = 15;\n    float c  = 0.07;\n    \n    float module  = length(relPos);// * (1. + (fractNoise((vec2(334.,15.) + relPos)*10.)*.005) );\n    \n    float angle   = getAngle(relPos/module);\n    \n    module += (fractNoise((vec2(334.,15.) + relPos)*50.)*.002);\n    module = float(floor(module*a)/a);\n    module += (noise((vec2(3324.,125.) + relPos)*30.)*.0000001);\n    \n    ////////////////////////////////////\n    float seed = rand(vec2(module) + center);\n    \n    int nExt = int(floor(seed * 20.0 * module))*b;\n    \n    float nearExtPos = rand( vec2(seed*100.,-1.*20.) ) * 2. * PI;\n    for (int i = 0; i < nExt; i++)\n    {\n        float currentExtPos = rand( vec2(seed*100.,float(i)*20.) ) * 2.*PI;\n        if (d_angle(currentExtPos, angle) < d_angle(nearExtPos, angle))\n        \tnearExtPos = currentExtPos;\n    }\n    \n    //////\n    \n    float curSize = rand( vec2(nearExtPos*293.) ) * c / module;\n    if (d_angle(nearExtPos, angle)  < curSize) \n        angle = nearExtPos;\n    \n         \n    ///////////////////////////////\n    \n    angle = mod(angle, 2.*PI);\n         \n    return center + (module * vec2(cos(angle), sin(angle)));\n}\n\n\n////////////////////////\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec2 center = vec2(iMouse)/vec2(iResolution.x);\n    center.y *= 1.0;\n    \n    // PROCESS\n    uv = effect(uv, center);\n    \n    // OUTPUT\n    \n    //vec3 col = vec3(uv, 0.);\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}