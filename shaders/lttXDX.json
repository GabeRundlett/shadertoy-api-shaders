{
    "Shader": {
        "info": {
            "date": "1481951829",
            "description": "Yoink.\n\nhttps://www.shadertoy.com/view/Ml3SDX#",
            "flags": 96,
            "hasliked": 0,
            "id": "lttXDX",
            "likes": 5,
            "name": "TSAA Study Rip",
            "published": 3,
            "tags": [
                "study",
                "rip",
                "tsaa"
            ],
            "usePreview": 0,
            "username": "voz",
            "viewed": 632
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2016\n\n//Testing out temporal super sampling using 1/2 the resolution,\n//this has no reprojection its more a test on mapping low res pixels -> high res\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0+seedling)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.333, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\nconst int numWeights = 32;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel1, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nvec2 last_uv = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nfloat uv_sound = 1.0;\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0*PI;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n\tfloat plant = f+s+ (last_uv.x+last_uv.y)/2.0/PI;    \n    vec3 c = vec3(flux(plant)+\n                      (1.0-smoothstep(0.0, 1.0/5.0, saw(plant-time))))\n        *(1.0-smoothstep(4.0/5.0, 1.0, saw(plant-time)));\n    return vec4(clamp(c*f+f*f*f*f, 0.0, 1.0), (saw(f*1.0*PI)));\n}\n\n\nvec4 galaxy(vec2 uv)\n{\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), iTime*PI).xy;;\n    vec2 uv0 = uv;\n    float r = length(uv);\n    scale = 2.5*(GR);\n\tuv *= scale;\n    \n    \n    float r1 =  pow(log(length(uv)+1.), 2.0);\n    float r2 = pow(log(length(uv)+1.), 1.5);\n    \n    float rotation = time*4.0*PI;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5-rotation;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5-rotation;\n    \n    float plant = (1.0/GR+time)*4.0*PI;\n    \n    \n    \n    \n    \n    float arms = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0);\n    \n    plant = plant*PI+arms+ \n                           atan(last_uv.x,last_uv.y)\n                           ;\n    vec4 color = vec4(flux(plant)+\n                      (1.0-smoothstep(0.0, .5/5.0, saw(plant-time))), 1.0)\n        *(1.0-smoothstep(4.5/5.0, 1.0, saw(plant-time)));\n    \n    color += stars(uv)*arms;\n    vec4 final = clamp(color/2.0, 0.0, 1.0);\n         \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    \n    float weight = smoothstep(1.0/PI/GR/E, 1.0/PI, saw(arms*PI*2.0+time)*length(clamp(final.rgb, 0.0, 1.0)));\n    return weight*clamp(final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r), 0.0, 1.0);\n}\n\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 16;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, sin(vec2(time+seedling-sin(-iteration+time/GR), time/GR+seedling-sin(iteration+time))));\n        vec2 denominator =rotatePoint(vec3(cmul(uv, sin(vec2(time+seedling-sin(-iteration+time/GR), time/GR+seedling-sin(iteration+time)))), 0.0), vec3(0.0, 0.0, 1.0), time*PI).xy\n            +vec2(cos(iteration*16.0*PI-(time*PI+seedling)), sin(iteration*16.0*PI-(time*PI+seedling)))*iteration*2.0;\n        vec2 final = (cdiv(numerator, denominator));\n        quotient += final/(float(bends))*(weights[i].r*weights[i].r/PI+1.0);\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv)\n{\n    vec2 final = mobius(uv);\n    \n    seedling += (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float height = max(lowAverage(), last_height)-1.0/30.0;\n    float beat = clip(height);\n\n    last_height = height;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = PI*(2.0+sin(time*PI*PI+beat*PI));\n    uv = uv*scale-scale/2.0;\n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        seedling = iteration;\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv);\n        \n        float fw = length(fwidth(uv));\n        antispeckle *= clamp(1.0/fw, 0.0, 1.0)*(abs(sign(fw)));\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n\n        float draw = clamp(border*(1.0-length(color.rgb)), 0.0, 1.0);\n\n        float skip = saw(seedling*PI);\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        border *= draw;//*antispeckle;\n        \n        border = pow(border, 1.0/float(i+1)/3.0);\n        \n        color = clamp(saw((color+galaxy((p.xy)*2.0-1.0)+stars(p.xy))*PI), 0.0, 1.0);\n\n    }\n\n\n    float weight = clamp(color.a+border, 0.0, 1.0);//*pow(antispeckle, 1.0/float(max_iterations));\n    vec4 sample = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    \n    fragColor = saw(clip(beat+.333)*clamp(vec4(vec3((color.rgb))*weight+sample.rgb*(1.0-weight), weight*color.a/(1.0+length(color.rgb))), 0.0, 1.0)*PI);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 5897,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/maggs-2/bassnectar-magical-world-feat"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\n\n#define CONE_PATHS 1\n\n\n    \n#define EPSILON .01\n\n#define nObjects 2\nfloat objectDistances[nObjects];\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float roughness,metallic;\n};\n\nvec2 rot(vec2 p, float ang) {\n    return p*mat2(sin(ang),cos(ang),-cos(ang),sin(ang));\n}\n\nfloat df(vec3 p) {\n    objectDistances[0] = min(length(max(abs(abs(p)-6.)-vec3(1.,10.,1.), 0.)),\n        \t\t\t\t\tlength(p-vec3(0.,8.,0.))-2.);\n    \n    vec3 d = abs(p) - vec3(20.,10.,20.);\n    objectDistances[1] = abs(min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)));\n    \n    return min(objectDistances[0], objectDistances[1]);\n}\n\nvec3 normal(vec3 p) {\n    vec2 NE = vec2(EPSILON, 0.);\n    return normalize(vec3( df(p+NE.xyy)-df(p-NE.xyy),\n                           df(p+NE.yxy)-df(p-NE.yxy),\n                           df(p+NE.yyx)-df(p-NE.yyx) ));\n}\n\nmaterial mat(vec3 p) {\n   \tbool isph = length(p-vec3(0.,8.,0.)) < 2.01;\n    if (objectDistances[0] < objectDistances[1] && ! isph) {\n        //pillars\n        return material(vec3(.8), vec3(.8), vec3(0.), 0.8, 0.);\n    } else {\n        if (abs(p.y)/10. > max(abs(p.x),abs(p.z))/20. && !isph) {\n            //floor and ceiling\n        \treturn material(vec3(0.93,.93,0.92), vec3(0.), vec3(0.), .2, 0.);\n        } else {\n            if (abs(p.x) > abs(p.z) || isph) {\n                //emissive music visualizer wall + sphere\n                vec3 ts = pow(texture(iChannel0, (p.zy)*.025+.5).xyz, vec3(2.2*1.6));\n        \t\treturn material(vec3(0.0), vec3(0.0), ts*100., 0., 0.);\n            } else {\n                //walls\n        \t\treturn material(vec3(.84,.83,.84), vec3(0.8), vec3(0.0), .6, 0.);\n            }\n        }\n    }\n}\n\n\nfloat rand(vec3 s) {\n    \n    //Thanks to Shane for the improved random function\n    return fract(cos(dot(s, vec3(7, 157, 113)))*43758.5453);\n\n    /* old\n    return fract( (fract(s.x*32.924)*8. + fract(s.x*296.234) +\n                 fract(s.y*32.924)*8. + fract(s.y*296.234) +\n                 fract(s.z*32.924)*8. + fract(s.z*296.234))*98.397 );*/\n}\nvec3 randDir(vec3 s) {\n    return vec3(sin(rand(s.yzx+.89234)*34.24),\n                cos(rand(s.zxy-1.445)*34.24),\n                -cos(rand(s)*34.35));\n}\n\n\nvec3 ilTrace(vec3 rp, vec3 rd, float rough, float seed) {\n     \n    float blur = rough;\n    float coneSize = 16.*blur,//10.*(blur*.8+.2),\n        \t\tconeRand = .5*blur,\n        \t\taddMult = .1,\n        \t\talphaMult = .5;//.25+(1.-blur)*.5;\n    \n    \n    vec4 c = vec4(0.);//color sum, w is alpha/opacity\n    vec3 lp = rd;\n    float s = 0.,ld = 0.;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = rp+normalize(rd+randDir(lp+vec3(seed,seed*1.1294,seed*.1294))*coneRand)*s;\n        float d = df(p);\n        \n        float alpha = max(0., 1.-abs(d)/min(s*.2,coneSize))*addMult;\n        c += vec4(mat(p).emissive*alpha,alpha*alphaMult);\n        \n        if (c.w > 1.) break;\n        \n        s += d*(.1+rand(p+vec3(seed,seed*1.1294,seed*.1294))*.4);\n    \tlp = p;\n        ld = d;\n    }\n    \n    return c.xyz*c.w*.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy/2.,\n        uv = fragCoord.xy*2.;//(fragCoord.xy*2. - R)/R.y;\n    \n    //uv jitter for temporal sampling\n    uv += randDir(vec3(uv,float(iFrame)/60.)).xy;\n        \n    uv = (uv-R)/R.y;\n    \n    vec2 suv = fragCoord/iResolution.xy;\n    if (suv.x > 0.5 || suv.y > 0.5) {\n        return;\n    }\n    \n    \n    vec3 rp = vec3(sin(float(iFrame)/660.)*15., 4., cos(float(iFrame)/660.)*15.);\n    vec3 rd = normalize(vec3(uv,-1.));\n    rd.y = -rd.y;\n    rd.yz = rot(rd.yz,1.8);\n    rd.zx = rot(rd.zx,float(iFrame)/660.+1.5);\n    \n    float s = 0.;\n    for (int i = 0; i < 77; i++) {\n        float d = df(rp+rd*s);\n        if (d < EPSILON) break;\n        s += d;\n    }\n    \n    vec3 hp = rp+rd*s;\n    if (df(hp) >= EPSILON) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 n = normal(hp);\n    material m = mat(hp);\n    \n    vec3 c = m.emissive;\n    \n    vec3 il = vec3(0.);\n    //cone paths\n    for (int i = 0; i < CONE_PATHS; i++) {\n        il += ilTrace(hp+n*.1, mix(reflect(rd,n),n,max(0.0,m.roughness-0.5)*2.0), m.roughness*.95+0.05, float(i));\n    }\n    c += m.diffuse*il/float(CONE_PATHS);\n    \n    \n    fragColor = vec4(pow(c,vec3(1.0/2.2)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Ethan Alexander Shulman 2016\n\n\nfloat rand(vec3 s) {\n    \n    //Thanks to Shane for the improved random function\n    return fract(cos(dot(s, vec3(7, 157, 113)))*43758.5453);\n\n    /* old\n    return fract( (fract(s.x*32.924)*8. + fract(s.x*296.234) +\n                 fract(s.y*32.924)*8. + fract(s.y*296.234) +\n                 fract(s.z*32.924)*8. + fract(s.z*296.234))*98.397 );*/\n}\nvec3 randDir(vec3 s) {\n    return vec3(sin(rand(s.yzx+.89234)*34.24),\n                cos(rand(s.zxy-1.445)*34.24),\n                -cos(rand(s)*34.35));\n}\n\n\nvec2 rot(vec2 p, float ang) {\n    return p*mat2(sin(ang),cos(ang),-cos(ang),sin(ang));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 suv = fragCoord/iResolution.xy;\n    vec4 c = vec4(texture(iChannel1, suv).xyz,1.)*10.;\n    \n    \n    vec2 R = iResolution.xy*2.,\n         cuv = fragCoord.xy,\n         buv = floor(fragCoord.xy/2.);//lower res base uv\n    \n    //add temporal sample portions from surrounding pixels\n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            vec2 uv = buv*2.+vec2(x,y)+0.5;//(fragCoord.xy*2. - R)/R.y;\n            \n            //uv jitter\n            uv += randDir(vec3(uv,float(iFrame)/60.)).xy;\n\n            float portion = max(0.,1.-length(cuv-uv));\n            c += vec4(texture(iChannel0, uv/R).xyz,1.)*portion;\n            //fragColor = texture(iChannel0, suv/2.);\n        }\n    }\n    \n    //fragColor = texture(iChannel0, suv/2.);\n    fragColor = vec4(clamp(c.xyz/c.w,0.,1.),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}