{
    "Shader": {
        "info": {
            "date": "1659034275",
            "description": "Following Painting a Landscape with Maths by Inigo Quilez\nhttps://www.youtube.com/watch?v=BFld4EBO2RE\nhttps://iquilezles.org/articles/morenoise/\nhttps://www.shadertoy.com/view/4ttSWf",
            "flags": 32,
            "hasliked": 0,
            "id": "sdKfDc",
            "likes": 2,
            "name": "winter denouement",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "prishainabox",
            "viewed": 164
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;        \n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// write color to buffer A\nfloat PI = 3.14159265;\nfloat  E = 2.71828182;\nint AA = 3; // sqrt(samples per pixel)\n\n/*******************************************************/\n\n// return smoothstep and its derivative from https://www.shadertoy.com/view/4ttSWf (Inigo Quilez)\nvec2 smoothstepd( float a, float b, float x) {\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nfloat random(in vec2 pt) {\n    vec2 uv = 50.0*(fract(pt / PI));\n    return fract(uv.x * uv.y * (uv.x + uv.y));\n}\n\n// https://iquilezles.org/articles/morenoise/\nfloat noise(in vec2 pt) {\n    \n    vec2 i = floor(pt); // integer component\n    vec2 f = fract(pt); // fractional component\n    f = 3.0 * f * f - 2.0 * f * f * f; // smooth interpolation\n    \n    // values of four corners\n    float a = random(i + vec2(0, 0)),\n          b = random(i + vec2(1, 0)),\n          c = random(i + vec2(0, 1)),\n          d = random(i + vec2(1, 1));\n          \n    float k0 = a,\n          k1 = b - a,\n          k2 = c - a,\n          k3 = a - b - c + d;\n          \n    // interpolate between four values x * (1−a) + y * a\n    return 2.0 * (k0 + k1*f.x + k2*f.y  + k3*f.x*f.y) - 1.0;      \n\n}\n\n// yz -> derivative, x -> noise value\n// learn this later\nvec3 noised(in vec2 pt) {\n    \n    vec2 i = floor(pt); // integer component\n    vec2 f = fract(pt); // fractional component\n    vec2 u = 3.0 * f * f - 2.0 * f * f * f; // smooth interpolation\n    \n    // heights of four corners\n    float a = random(i + vec2(0, 0)),\n          b = random(i + vec2(1, 0)),\n          c = random(i + vec2(0, 1)),\n          d = random(i + vec2(1, 1));\n          \n    float k0 = a,\n          k1 = b - a,\n          k2 = c - a,\n          k3 = a - b - c + d;\n          \n    // interpolate between four heights (basically mix function)  x * (1−a) + y * a\n    return vec3(\n        2.0 * (k0 + k1*u.x + k2*u.y  + k3*u.x*u.y) - 1.0,\n        2.0*(6.0*f*(1.0-f)) * vec2(k1 + k3*u.y, k2 + k3*u.x)\n    );      \n\n}\n\nmat2 getRotMatrixFromTriangle(in float x, in float y, in float h) {\n    // sin, cos, -cos, sin\n    return mat2(y/h, x/h, -x/h, y/h);\n}\n\nfloat fbm(in vec2 uv, in mat2 rot, in int iterations) {\n    float a = 0.0;\n    for (int i = 0; i < iterations; i++) {\n        vec2 t = pow(2.0, float(i)) * uv;\n        for (int j = 0; j < i; j++) {\n            t *= rot;\n        }\n        a += (1.0 / pow(2.0, float(i))) * noise(t);\n    }\n    return a;\n}\n\nmat2 rot;\nmat2 rot2;\n\nvoid initMatrices() {\n    rot = getRotMatrixFromTriangle(3.0, 4.0, 5.0);\n    rot2 = getRotMatrixFromTriangle(5.0, 12.0, 13.0);\n}\n\n// https://www.shadertoy.com/view/4ttSWf\nvec3 fbmd(in vec2 uv, in mat2 rot, in int iterations) {\n    float acc = 0.0;\n    float k = 1.0;\n    vec2 der = vec2(0);\n    mat2  m = mat2(1.0, 0.0, 0.0, 1.0);\n    vec2 t = uv;\n    for (int i = 0; i <= iterations; i++) {\n        vec3 n = noised(t); // calc noise & derivative\n        acc += k*n.x; // accumulate val\n        der += k*m*n.yz; // accumulate derivatives\n        k *= 0.5; // half amplitude\n        t *= rot*2.0; // double freq & rotate\n        m *= 2.0*rot;\n    }\n    return vec3(acc, der);\n}\n\n/*******************************************************/\n\nvec3 sunClr = vec3(11, 9, 5);\nvec3 skyClr = vec3(0.56, 0.7, 1.0);\nvec3 sunDir = normalize(vec3(0.1*float(-3.25), 0.1*float(3.5), 0.1*float(-2.5)));\n\n/*******************************************************/\n\n// TERRAIN\n\nfloat terrainMap(in vec2 pt) {\n    // noise terrain\n    pt /= 2000.0;\n    float a = fbm(pt, rot, 6);\n    a = a * 600.0 + 600.0;\n    // cliff\n    a += 160.0 * smoothstep(-230.0, 40.0, a);\n    // return height\n    return a;\n}\n\nvec4 terrainMapD(in vec2 pt) {\n    // noise derivative\n    vec3 e = fbmd(pt / 2000.0, rot, 12);\n    e.x = e.x * 600.0 + 600.0;\n    e.yz *= 600.0;\n    // cliff\n    vec2 c = smoothstepd(-230.0, 40.0, e.x);\n\te.x  = e.x  + 160.0*c.x;\n\te.yz = e.yz + 160.0*c.y*e.yz; // chain rule (from https://www.shadertoy.com/view/4ttSWf)\n    e.yz /= 2000.0;\n    return vec4(e.x, normalize(vec3(-e.y, 1.0, -e.z)));\n}\n\nfloat raymarchTerrain(in vec3 ro, in vec3 rd) {\n\n    // total distance traveled\n    float td = 0.01;\n    vec3 nor = vec3(0);\n    \n    for (int i = 0; i < 128; i++) {\n        vec3 pt = ro + rd*td;\n        // height of terrain\n        float h = terrainMap(pt.xz);\n        float d = 0.35 * (pt.y - h); \n        // if distance is close\n        if (abs(d) < 0.0001*td) {\n            break;\n        }\n        // add to total distance\n        td += d;\n        // if too far, break\n        if (td >= 1800.0) {\n            td = -1.0;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\nvec3 terrainNormal(in vec3 pt, in int mode) {\n    if (mode == 0) {\n        return terrainMapD(pt.xz).yzw;\n    } else {\n        vec2 e = vec2(0.03,0.0);\n        return normalize(vec3(\n            terrainMap(pt.xz - e.xy) - terrainMap(pt.xz + e.xy),\n            2.0*e.x,\n            terrainMap(pt.xz - e.yx) - terrainMap(pt.xz + e.yx) \n        ));\n    }\n  \n}\n\nfloat terrainShadow(in vec3 ro, in vec3 rd, in float shadowSoftness) {\n\n    // total distance traveled\n    float td = 0.05;\n    // shadow\n    float sha = 1.0;\n    \n    for (int i = 0; i < 128 && td < 1800.0; i++) {\n        vec3 pt = ro + rd*td;\n        // height of terrain\n        float h = terrainMap(pt.xz);\n        float d = pt.y - h;\n        // if distance is close\n        if (d < td*0.0001)\n            // intersection, so return shadow\n            return 0.0;\n        // add to total distance\n        sha = min(sha, shadowSoftness * d/td);\n        td += d;\n    }\n    \n    return clamp(sha, 0.0, 1.0);\n    \n}\n\nvec3 colorTerrain(in vec3 ro, in vec3 rd, in float d) {\n\n    vec3 pt = ro + rd*d;\n    vec3 tnor = terrainNormal(pt, 0);\n    vec3 nor = terrainNormal(pt, 1);\n    nor = mix(tnor, nor, smoothstep(0.0, 1.0, min(0.8, nor.y)));\n    \n    // base material color brown\n    vec3 mat = vec3(0.13, 0.08, 0.06);\n    vec3 clr = mat;\n    // use normal y component to figure out grass and snow color\n    float grass = smoothstep(0.6, 0.8, mix(tnor.y, nor.y, nor.y));\n    float snow  = smoothstep(0.7, 0.95, 0.15*tnor.y + 0.85*nor.y);\n    snow = snow*snow;\n    \n    // mix mat and grass and snow color\n    vec3 snowClr = 0.65*vec3(0.1, 0.1, 0.25) + sunClr*0.005*dot(nor, sunDir);\n    vec3 grassClr = vec3(0.07, 0.08, 0.005)*0.8 + snow*snowClr;\n    clr = clr*(1.0 - grass) + grass*grassClr;\n    \n    // lighting\n    vec3 light = vec3(0);\n    light += max(dot(nor, sunDir), 0.0) * sunClr * terrainShadow(pt, sunDir, 40.0); // sun\n    light += ((nor.y + 1.0) * 0.5) * skyClr * 0.5; // sky diffuse\n    light += mat * 6.0 * dot(nor, -sunDir); // bounce\n    \n    clr *= light;\n    \n    return clr;\n    \n}\n\n/*******************************************************/\n\n// CLOUDS\n\nfloat cloudMap(in vec3 pt) {\n    // plane\n    return dot(pt, vec3(0, -1, 0)) + 600.0;\n}\n\nfloat raymarchClouds(in vec3 ro, in vec3 rd) {\n\n    // total distance traveled\n    float td = 0.01;\n    \n    for (int i = 0; i < 128; i++) {\n        float d = cloudMap(ro + rd*td);\n        // if distance is close\n        if (abs(d) < td*0.0001) {\n            break;\n        }\n        // add to total distance\n        td += d;\n        // if too far, break\n        if (td >= 5000.0) {\n            td = -1.0;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n/*******************************************************/\n\nvec4 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n\n    vec3 clr = skyClr - 0.4*uv.y;\n\n    int mat = -1;\n    float d = 6000.0;;\n    \n    // land\n    {\n        float d0 = raymarchTerrain(ro, rd);\n        if (d0 > 0.0 && d0 < d) {\n            mat = 0;\n            d = d0;\n        }\n    }\n    \n    // clouds\n    {\n        float d1 = raymarchClouds(ro, rd);\n        if (d1 > 0.0 && d1 < d) {\n            mat = 1;\n            d = d1;\n        }\n    }\n    \n    // material colors\n    if (mat == 0) {\n        clr = colorTerrain(ro, rd, d);\n    } else if (mat == 1) {\n        // mix sky and cloud clr\n        vec3 pt = ro + rd*d;\n        vec3 cl = 0.4 * vec3(smoothstep( \n            -0.05, 1.0, fbm(pt.xz * 0.003 + 10.5, getRotMatrixFromTriangle(5.0, 12.0, 13.0), 5)\n        ));\n        clr = clr*(1.0-cl) + cl;\n    }\n    \n    // mix fog\n    vec3 f = pow(vec3(2.718281), -0.0001*d*vec3(1, 2, 4));\n    clr = f * clr + (1.0 - f) * vec3(0.9);\n    \n    // mix sun\n    clr += sunClr * 0.05 * pow(dot(sunDir, rd), 10.0);\n\n    clr.r = smoothstep(0.0, 1.0, clr.r);\n    clr.g = smoothstep(0.0, 1.0, clr.g);\n    clr.b = smoothstep(0.0, 1.0, clr.b);\n    return vec4( pow(clr, vec3(0.4545)), 1.0 );\n    \n}\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(uv.x * right + uv.y * up + 1.2 * forward);\n}\n\n/*******************************************************/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 clr = vec3(0.0);\n    float d = 1.0;\n    float time = iTime;\n    \n    initMatrices();\n    \n    // camera\n    vec3 ro = vec3(-400, -300.0, -90) + vec3(130, 70, -240);\n    vec3 target = ro + vec3(0.11, 0.1, -0.6) + vec3(-0.60, -0.1, 0.0);\n    \n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            // Normalized pixel coordinates\n            vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n            vec2 uv = (2.0*f - iResolution.xy) / min(iResolution.x, iResolution.y);\n            vec3 rd = setCamera(uv, ro, target);\n            // calculate color based on distance, etc\n            vec4 rendered = render(uv, ro, rd);\n            if (i == 0 && j == 0) d = rendered.a;\n            clr += rendered.rgb;\n        }\n    }\n\n    clr /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(clr, d);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}