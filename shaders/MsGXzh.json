{
    "Shader": {
        "info": {
            "date": "1462790376",
            "description": "A simple function graphing tool.\n\nRed is sine\nCyan is iq's value noise\nBlue is the same but the signed variant\nGreen is fBm with 7 octaves\n\nrange is [-1, +1] change it on line 68",
            "flags": 0,
            "hasliked": 0,
            "id": "MsGXzh",
            "likes": 15,
            "name": "Animated Function Plotter",
            "published": 3,
            "tags": [
                "graph",
                "function",
                "plot"
            ],
            "usePreview": 0,
            "username": "valentingalea",
            "viewed": 1135
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY\n\n#if defined(GL_ES) || defined(GL_SHADING_LANGUAGE_VERSION)\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define _mutable(T) T\n#define _constant(T) const T\n#define mul(a, b) (a) * (b)\n#endif\n\n#if defined(__cplusplus) || defined(SHADERTOY)\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n#endif\n\n// Noise function by iq from https://www.shadertoy.com/view/4sfGzS\nfloat hash(\n\t_in(float) n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(\n\t_in(vec3) x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\n#if 1\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n#else\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n#endif\n}\n\n#define noise(x) noise_iq(x)\n#define snoise(x) (noise_iq(x) * 2. - 1.)\n\nfloat fbm(\n    _in(vec3) pos,\n    _in(float) lacunarity\n){\n    vec3 p = pos;\n    float gain = .5;\n    float t = 0.;\n    \n    for (int i = 0; i < 7; i++) {\n        t += gain * noise(p);\n        p *= lacunarity;\n        gain *= .5;\n    }\n    \n    return t;\n}\n\n#define SCALE 1.\n#define D (.0125 * SCALE)\n\nvec3 plot(\n\t_in(float) f,\n\t_in(float) x,\n\t_in(vec3) color\n){\n\tfloat y = smoothstep (f-D, f+D, x);\n\ty *= 1.- y;\n\t\n\treturn y * color * 5.;\n}\n\nvoid mainImage(\n\t_out(vec4) fragColor,\n#ifdef SHADERTOY\n\tvec2 fragCoord\n#else\n\t_in(vec2) fragCoord\n#endif\n){\n// go from [0..resolution] to [0..1]\n\tvec2 t = fragCoord.xy / u_res.xy;\n#ifdef HLSL\n\tt.y = 1. - t.y;\n#endif\n\n// optional: center around origin by going to [-1, +1] and scale\n\tt = (t * 2. - 1.) * SCALE;\n\t\n// plot the axes\n\tvec3 col = vec3(0, 0, 0);\n\tcol += plot(0., t.y, vec3(1, 1, 1));\n\tcol += plot(t.x, 0., vec3(1, 1, 1));\n\t\n// plot custom functions\t\n\tt.x += u_time * SCALE;\n\tcol += plot(sin(t.x), t.y, vec3(1, 0, 0));\n\tcol += plot(noise(vec3(t.x, 0, 0)), t.y, vec3(0, 1, 1));\n    col += plot(snoise(vec3(t.x, 0, 0)), t.y, vec3(0, 0, 1));\n\tcol += plot(fbm(vec3(t.x, 0, 0) * 1., 2.), t.y, vec3(0, 1, 0));\n\n// output\n\tfragColor = vec4 (col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}