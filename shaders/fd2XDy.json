{
    "Shader": {
        "info": {
            "date": "1620940493",
            "description": "Basic 2D lighting shader, definitely could use some more clean up and optimization but I'm still happy with it.\nUnfortunately it needs a way to upload custom textures or else it won't do anything.",
            "flags": 0,
            "hasliked": 0,
            "id": "fd2XDy",
            "likes": 3,
            "name": "Basic 2D lighting",
            "published": 3,
            "tags": [
                "2d",
                "lighting"
            ],
            "usePreview": 0,
            "username": "Salmon_e",
            "viewed": 565
        },
        "renderpass": [
            {
                "code": "// NOTE: This won't work with out a custom texture in channel 0, so use chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda?hl=en\n// or the js console to upload a custom texture. \n// White is treated as air, and all other colors are treated as solid ground\n\n\n// Converts from pixel space into texture coord space\nvec2 convert(vec2 p){\n    return vec2(p.x/iResolution.x, p.y/iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 lightPos = iMouse.xy;\n    \n    // How deep the light penetrates into solid ground\n    float lightPenetration = 50.0;\n    \n    // Size of the step for the ray. Higher is lower quality, but faster\n    float lightQuality = 3.0;\n    \n    // direction vector of the ray\n    vec2 dir = lightPos - fragCoord;    \n    float dist = distance(lightPos, fragCoord);\n    \n    // The number of solid pixels encountered by the ray\n    float solidCount = 0.0;\n    \n    vec4 color = texture(iChannel0, convert(fragCoord));\n    for(float i = 0.0; i <= 1.0; i += lightQuality/dist){\n        // Get the next point on the line\n        vec2 p = i*dir + fragCoord;\n        \n        // Stop calculating things in the pixel is off screen\n        if(p.x < 0.0 || p.y < 0.0 || p.x > iResolution.x || p.y > iResolution.y){\n            continue;\n        }\n        // Check if the color at the current point is solid, if so, increase the counter\n        if(texture(iChannel0, convert(p)).rgb != vec3(1,1,1)){\n            solidCount++;\n            // break if the the solidCount gets high enough to block all light, no need to increase it further\n            if(solidCount > lightPenetration * lightQuality){\n                break;\n            }\n        }\n    }\n    // This was created with my go to strategy of \"slap numbers together until it looks ok\"\n    float light = 1.0-solidCount/lightPenetration*lightQuality;\n    // Add some ambient light to empty space\n    if(color.rgb == vec3(1,1,1)){    \n        light = clamp(light, 0.3, 1.0);\n    }\n    \n    fragColor = color*light;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}