{
    "Shader": {
        "info": {
            "date": "1660547470",
            "description": "feel free to use. integration to any kind of open source software is appreciated.\nPlease read the Common tab for info.\nretroarch slang shader: https://github.com/whkrmrgks0/Advanced-CRT-shader\n\ntodo: maike a multi-pass version with better performance",
            "flags": 0,
            "hasliked": 0,
            "id": "slccDj",
            "likes": 12,
            "name": "advanced CRT filter",
            "published": 3,
            "tags": [
                "postprocessing",
                "filter",
                "crt"
            ],
            "usePreview": 0,
            "username": "whkrmrgks0",
            "viewed": 1420
        },
        "renderpass": [
            {
                "code": "#define tau 6.28318530718\n#define cr vec2(4.,0.)\n#define cb vec2(2.,0.)\n#define cg vec2(0.,0.)\n#define cw vec2(3.,1.)\n\nfloat sawtooth(float inp){\n    return inp-floor(inp);\n}\n\nfloat square(float zed,float marchpoint,float floaz){\n    return step(sawtooth(zed/floaz),marchpoint/floaz);\n}\n\nfloat triangle(float zed){\n    return abs(sawtooth(zed+0.5)-.5)*2.;\n}\n\nvec2 hash22(vec2 seed){\n    return fract(75.345*sin(623.3754*seed));\n}\n\nfloat grd(vec2 uv, vec2 disp){\n    uv +=disp*dts;\n    uv /= dts;\n    return square(uv.x,2.,6.)*square(uv.y,1.,2.);\n}\n\nvec3 tpscany (vec3 bef,vec3 ucj,vec3 dcj,float temp){\n    vec3 scan = vec3(.0);\n    scan += max((triangle(temp)-1.+(bef*sling)),.0);\n    scan += max((clamp(.0,1.,temp*2.-1.)-2.)+(ucj*sling),.0);\n    scan += max((clamp(.0,1.,-(temp*2.-1.))-2.)+(dcj*sling),.0);\n    return scan/(sling*0.5);\n}\n \nvoid pinc(vec2 uv, inout vec2 uv2, inout float mxbf, inout float vign, float ar){\n    uv2 = (uv*vec2(2.)-vec2(1.))*vec2((1.+marginv),(1.+marginv*ar));\n    uv2 = vec2(uv2.x/(cos(abs(uv2.y*cus)*tau/4.)),uv2.y/(cos(abs(uv2.x*cus*ar)*tau/4.)));\n    vec2 uvbef = abs(uv2)-vec2(1.);//boarder\n    mxbf = max(uvbef.x,uvbef.y);\n    vign = max(uvbef.x*uvbef.y,.0);\n    uv2 = (uv2+vec2(1.))*vec2(.5);//recoordination\n}\n\nfloat scimpresp(float range){//scanline IR\n    return sin(pow(range,capashape)*tau)+1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv2;\n    float mxbf, vign;\n    vec2 ratd = fragCoord;\n    vec2 uv = fragCoord/iResolution.xy;\n    pinc(uv,uv2,mxbf,vign,iResolution.x/iResolution.y);\n    vec2 nuv = uv2;\n    vec2 nuvyud = vec2(floor(nuv.y*scanline-1.)/scanline,floor(nuv.y*scanline+1.)/scanline);\n    nuv.y = floor(nuv.y*scanline)/scanline;\n\n    vec3 bef = vec3(.0);\n    vec3 ucj = vec3(.0);\n    vec3 dcj = vec3(.0);\n    \n    float capatemp, capainteg = .0;\n    for(float i=-capaiter/2.;i<capaiter/2.;i++){\n        capatemp = scimpresp((i+capaiter/2.)/capaiter);\n        capainteg += capatemp;\n        bef += texture(iChannel0,vec2(sawtooth(nuv.x-capa/scanline*i/(capaiter/2.)),nuv.y)).xyz*capatemp;\n        ucj += texture(iChannel0,vec2(sawtooth(nuv.x-capa/scanline*i/(capaiter/2.)),nuvyud.y)).xyz*capatemp;\n        dcj += texture(iChannel0,vec2(sawtooth(nuv.x-capa/scanline*i/(capaiter/2.)),nuvyud.x)).xyz*capatemp;\n    }\n    dcj /= capainteg;\n    bef /= capainteg;\n    ucj /= capainteg;\n    \n    vec3 scan =vec3(.0);\n    float temp;\n    float snippet;\n    float integral = .0;\n    for(float i = -AAz/2.; i<=AAz/2. ;i++){\n        snippet = (AAz/2.-abs(i))/AAz/2.;\n        integral += snippet;\n        temp = sawtooth(uv2.y*scanline);\n        scan += tpscany(bef,ucj,dcj,temp+(i/AAz*2.)*vex/iResolution.y*scanline)*snippet;//antimoire convololution\n    }\n    scan /= integral;\n\n    float brd = step(mxbf,.0);\n    vign = pow(vign,vstr);\n    \n    vec3 grid = vec3(grd(ratd,cr),grd(ratd,cg),grd(ratd,cb));\n    grid += vec3(grd(ratd,cr+cw),grd(ratd,cg+cw),grd(ratd,cb+cw));\n    \n    float mask = brd*vign;\n    \n    scan /= sling;\n    scan = pow(scan,vec3(0.5));\n    scan = pow(scan,vec3(1.+1./3.));\n    scan = pow(scan,vec3(gma));\n    \n    vec3 grided = scan*grid*3.;\n    vec3 final = min(vec3(mix(grided,scan,scan)),vec3(1.))*mask;\n    \n    fragColor = vec4(final,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-------notes for integration--------\n\n//CRT curvature\nconst float cus = 0.15;\n\n//Vignette strength\nconst float vstr = .05;\n\n//Display margin\nconst float marginv = .02;\n\n//Phosper size (should be an integer)\nconst float dts = 1.;\n\n//De-moire convolution iteration (if you see moire, up this value)\nconst float AAz = 64.;\n\n//De-moire convolution width (don't touch if you have no idea)\nconst float vex = 2.;\n\n//Capacitance (scanline horizontal blur)\nconst float capa = 1.;\n\n//Capacitnace iteration\nconst float capaiter  = 5.0;\n\n//Capacitance IR shape parameter\nconst float capashape = 3.0;\n\n//Scanline count\nconst float scanline =240.;\n\n//Gamma correction\nconst float gma = 1.0;\n\n//Line bleed\nconst float sling = 2.0;\n\n//------------------------------------\n\n\n/*\n\nGPLv3\n\nThis file is part of advanced CRT filter by whkrmrgks0.\n\nadvanced CRT filter by whkrmrgks0 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\nadvanced CRT filter by whkrmrgks0 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with advanced CRT filter by whkrmrgks0. If not, see <https://www.gnu.org/licenses/>.\n\n\nunlike the one i made before, this one is made with authenticity and performance in mind.\n\n\nthis shader features:\n\n1x1 to whatever size you want\nScanline width modulation\nCustomisable scanlines\nCustomisable curvature\nCustomisable vignette\nCustomisable capacitance artifact\nCustomisable horizontal pre-sharpen filter\nPhosper pattern without any dimming\nAnti moire convolution filter\n\nall of those in a single pass\n\naug 15 2022\n\ncopyright 2022\nwhkrmrgks0\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}