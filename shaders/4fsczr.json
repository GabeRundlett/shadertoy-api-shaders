{
    "Shader": {
        "info": {
            "date": "1720834291",
            "description": "find least expensive path",
            "flags": 48,
            "hasliked": 0,
            "id": "4fsczr",
            "likes": 6,
            "name": "ZombieWalk",
            "published": 3,
            "tags": [
                "pathfinding"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 130
        },
        "renderpass": [
            {
                "code": "// Demonstration of path finding algorhyithm\n// Walls are impassible barriers\n// Terrain height has effect on the 'shortest' path.\n//\n// Use mouse to move the walls\n// Press <Spc> to reset\n//\n// Cell contents: xyz = color;  w = terrain height (and wall markers)\n//--------------------------------------------------------------\n\nvoid highlight(ivec2 p1, ivec2 p2, inout vec4 fragColor) {\n    p1 -= p2;\n    float dist = sqrt(float(p1.x*p1.x) + float(p1.y*p1.y));\n    if(dist < 2.0) fragColor.xyz = vec3(1.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // screen coord -> grid\n    fragCoord /= iResolution.xy;  // 0 ... 1\n    ivec2 addr = ivec2(int(float(GRIDX) * fragCoord.x),int(float(GRIDY) * fragCoord.y));\n\n    fragColor = fetchData(iChannel0, addr); \n\n    getSettings(iChannel0);\n    if(qState == STATE_ASSIGN_WEIGHTS && fragColor.w > 0.) fragColor *= 1.2;\n    \n    // highlight the path start and end\n    if(qState == STATE_MARK_PATH) {\n        highlight(START,addr,fragColor);\n        highlight(END,addr,fragColor);\n    \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void saveSettings(inout vec4 fragColor,vec2 fragCoord) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(fragCoord, addrList[i])) {\n            fragColor.xyz = settings[i];\n            return;\n        }\n}\n\n// ----------------------------------------------------------\n\nconst ivec2[] neighborOffsets = ivec2[](\n    ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),\n    ivec2(-1,0),ivec2(1,0),\n    ivec2(-1,1),ivec2(0,1),ivec2(1,1));   \n\nivec2 neighborCoord(ivec2 base, int offsetIndex) {\n    ivec2 ans = base + neighborOffsets[offsetIndex];\n    ans.x = min(max(ans.x,0),GRIDX-1);\n    ans.y = min(max(ans.y,0),GRIDY-1);\n    return ans;\n}\n\n// ----------------------------------------------------------\n\nvoid markPath(inout vec4 color,vec2 coord) {\n    // grid position previously marked as on the path\n    ivec2 adr = ivec2(coord);\n    if(adr == ivec2(qPosition.xy)) {\n        color.xyz = vec3(1.,0.,0.);\n        return;\n    }\n    \n    // from the current end of the path: scan all neighbors for the lowest terrain value.\n    // store that position for the next frame\n    if(adr == Q1) {  // qPosition storage\n        const float HIGHMARK = 99999.;\n        vec4 neighbor;\n        float lowestValue = HIGHMARK;\n        int lowestIndex = 0;\n\n        for(int i=0;i<8;++i) {\n            neighbor = fetchData(iChannel0,neighborCoord(ivec2(qPosition),i));\n            if(neighbor.w < 0.) continue;\n            if(neighbor.w == WALL) continue;\n\n            if(neighbor.w < lowestValue) {\n                lowestValue = neighbor.w;\n                lowestIndex = i;\n            }\n        }\n\n        qPosition = vec2(neighborCoord(ivec2(qPosition),lowestIndex));\n    }    \n}\n\n// ----------------------------------------------------------\n\nvoid assignTerrainWeights(inout vec4 color,vec2 coord) {\n    ivec2 adr = ivec2(coord);\n    if(adr.x >= GRIDX || adr.y >= GRIDY) return;\n    \n    color = fetchData(iChannel0,adr);\n    if(color.w == WALL) return;       // walls don't count    \n    if(color.w != UNASSIGNED) return; // already assigned a weight\n    \n    // find lowest valued neighbor. our value = his value + our terrain penalty\n    const float HIGHMARK = 99999.;\n    vec4 neighbor;\n    float lowestValue = HIGHMARK;\n    \n    for(int i=0;i<8;++i) {\n        neighbor = fetchData(iChannel0,neighborCoord(adr,i));\n        if(neighbor.w == UNASSIGNED || neighbor.w == WALL) continue;\n        if(neighbor.w < lowestValue) lowestValue = neighbor.w;\n    }\n    \n    if(lowestValue == HIGHMARK) return; // have no neighbors yet\n    \n    color.w = 1. + lowestValue + (color.x + color.y + color.z) * 10.;\n}\n\n// ----------------------------------------------------------\n\n#define WALL_WIDTH 15\nconst vec4 WALLPIP   = vec4(1.0,0.0,0.9,WALL);\nconst vec4 WALLCOLOR = vec4(0.3,0.9,0.4,WALL);\n\nvoid horizontalWall(inout vec4 color,vec2 wall,ivec2 coord) {\n    if(coord.y != int(wall.y)) return;\n    \n    for(int x = -WALL_WIDTH; x <= +WALL_WIDTH; ++x) {\n        ivec2 pos = ivec2(int(wall.x)+x, int(wall.y));\n        if(pos == coord) color = (x == 0) ? WALLPIP : WALLCOLOR;\n    }\n}\n\nvoid verticalWall(inout vec4 color,vec2 wall,ivec2 coord) {\n    if(coord.x != int(wall.x)) return;\n    \n    for(int y = -WALL_WIDTH; y <= +WALL_WIDTH; ++y) {\n        ivec2 pos = ivec2(int(wall.x), int(wall.y)+y);\n        if(pos == coord) color = (y == 0) ? WALLPIP : WALLCOLOR;\n    }\n}\n\nvoid initializeCells(inout vec4 color,vec2 fragCoord) {\n    qState = STATE_RESET;\n    qFrame = float(iFrame);\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    if(coord.x < GRIDX && coord.y < GRIDY) {\n        vec2 uv = fragCoord / iResolution.xy + vec2(iTime * 0.01, iTime * 0.003);\n        color = vec4(vec3(texture(iChannel1,uv * 2.3)),UNASSIGNED);\n        \n        horizontalWall(color,qwall1,coord);\n        horizontalWall(color,qwall2,coord);\n        horizontalWall(color,qwall3,coord);\n        verticalWall(color,qwall4,coord);\n        verticalWall(color,qwall5,coord);\n        verticalWall(color,qwall6,coord);\n    }\n    \n    if(coord == END) color.w = 0.; // seed point for determining cell weights\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(iFrame < 30 || keyClick(32,iChannel3)) {\n        qwall1 = vec2(20.,20.);\n        qwall2 = vec2(50.,20.);\n        qwall3 = vec2(80.,20.);\n        qwall4 = vec2(20.,40.);\n        qwall5 = vec2(50.,40.);\n        qwall6 = vec2(80.,40.);\n        saveSettings(fragColor,fragCoord);\n\n        initializeCells(fragColor,fragCoord);\n        return;\n    }\n\n    getSettings(iChannel0); \n    fragColor = fetchData(iChannel0, ivec2(fragCoord));\n    \n    // -----------------------------------\n    // moving walls sets qState -> STATE_RESET\n       \n    if(iMouse.z > 0.) {     // mouse down or dragged\n        vec2 mPos = vec2(GRIDX,GRIDY) * iMouse.xy / iResolution.xy; // mouse as grid position\n    \n        if(iMouse.w > 0.) { // mouse down\n            float dist,bestDist = 999.;\n            int bestIndex = -1;\n            qMouseIndex = -1.; // assume click was too far away\n\n            for(int i=0;i<6;++i) {\n                dist = length(settings[2+i].xy - mPos);\n                if(dist < 10. && dist < bestDist) {\n                    bestDist = dist;\n                    bestIndex = i;\n                }\n            }\n\n            if(bestIndex >= 0) qMouseIndex = float(bestIndex);\n        }\n        \n        if(qMouseIndex >= 0. && iMouse.w < 0.) { // mouse drag\n            vec2 mPos = vec2(GRIDX,GRIDY) * iMouse.xy / iResolution.xy; // mouse as grid position\n            settings[2+ int(qMouseIndex)].xy = mPos;\n            initializeCells(fragColor, fragCoord);\n        }\n    }\n    \n    // -----------------------------------\n    \n    if(qState == STATE_RESET && qFrame != float(iFrame))\n        qState = STATE_ASSIGN_WEIGHTS;   \n        \n    if(qState == STATE_ASSIGN_WEIGHTS) {\n        vec4 color = fetchData(iChannel0,START);\n        if(color.w != UNASSIGNED) {\n            qState = STATE_MARK_PATH;\n            qPosition = vec2(START);\n        }\n        else\n            assignTerrainWeights(fragColor,fragCoord); \n    }\n\n    if(qState == STATE_MARK_PATH)\n        markPath(fragColor,fragCoord); \n\n    saveSettings(fragColor,fragCoord); \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GRIDX 100  // terrain size\n#define GRIDY  60\n#define START      ivec2(1,GRIDY-2) // path start/end coordinates\n#define END        ivec2(GRIDX-2 ,2)\n#define UNASSIGNED -2.\n#define WALL       -1.\n\n#define STATE_RESET          1.\n#define STATE_ASSIGN_WEIGHTS 2.\n#define STATE_MARK_PATH      3.\n\n#define qState      settings[0].x\n#define qFrame      settings[0].y\n#define qMouseIndex settings[0].z\n#define qPosition settings[1].xy\n#define qwall1    settings[2].xy\n#define qwall2    settings[3].xy\n#define qwall3    settings[4].xy\n#define qwall4    settings[5].xy\n#define qwall5    settings[6].xy\n#define qwall6    settings[7].xy\nconst int ADDR_COUNT =     8;\n\nvec3[ADDR_COUNT] settings;\n\nconst ivec2 Q0 =  ivec2( 0,GRIDY+1);\nconst ivec2 Q1 =  ivec2( 1,GRIDY+1);\nconst ivec2 Q2 =  ivec2( 2,GRIDY+1);\nconst ivec2 Q3 =  ivec2( 3,GRIDY+1);\nconst ivec2 Q4 =  ivec2( 4,GRIDY+1);\nconst ivec2 Q5 =  ivec2( 5,GRIDY+1);\nconst ivec2 Q6 =  ivec2( 6,GRIDY+1);\nconst ivec2 Q7 =  ivec2( 7,GRIDY+1);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i) \n        settings[i] = texelFetch(channel, addrList[i],0).xyz;\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n\treturn (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode,sampler2D channel) {\n    return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}