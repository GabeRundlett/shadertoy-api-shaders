{
    "Shader": {
        "info": {
            "date": "1481017102",
            "description": "\"modulo in cartesian and polar coordinates\" created this beautiful belly",
            "flags": 0,
            "hasliked": 0,
            "id": "MtdSRX",
            "likes": 28,
            "name": "ich bin der koch",
            "published": 3,
            "tags": [
                "fractal",
                "recursive",
                "modulo",
                "snowflake",
                "symmetry"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 1839
        },
        "renderpass": [
            {
                "code": "/** Modulo in space (cc) 2016, stefan berke\n\n    The structure is a single tube folded in space.\n\n\trepeat_transform() applies the modulo function to cartesian coordinates\n\tfan_transform_XX() applies the modulo to polar coordinates\n\n\tThe glsl for the distance field is generated by a python program using this script:\n\n    o = Tube(radius=0.1, axis=1)\n    o = Fan(o, axis=2, angle=(0, 30))\n    o = Repeat(o, repeat=(2,2,0))\n    o = Fan(o, axis=2, angle=(0,60))\n    o = Repeat(o, repeat=(5,5,0))\n    o = Fan(o, axis=2, angle=(0, 90))\n    o = Fan(o.set_transform(mat4().translate((0,0,6))), axis=1, angle=(0,60))\n    o = Fan(o, axis=2, angle=(0, 60))\n    o = Repeat(o, repeat=vec3(36,36,0))\n\n\tresulting in this branch-less tree:\n\n    Repeat(repeat=vec3(36, 36, 0))\n    \\-Fan(angle=(0, 60), axis=2)\n      \\-Fan(angle=(0, 60), axis=1)\n        \\-Fan(angle=(0, 90), axis=2, transform=mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,6,1))\n          \\-Repeat(repeat=vec3(5, 5, 0))\n            \\-Fan(angle=(0, 60), axis=2)\n              \\-Repeat(repeat=vec3(2, 2, 0))\n                \\-Fan(angle=(0.0, 30.0), axis=2)\n                  \\-Tube(radius=0.1, axis=1)\n\n\n\tsource is here: https://github.com/defgsus/pector/tree/dev-csg/csg\n\n\n\tbe fun :)\n*/\n\n\nvec3 fan_transform_xy(in vec3 pos, in float center, in float range) {\n    center *= 0.017453292519943295;\n    range *= 0.017453292519943295;\n    float start = (center - range/2.),\n          ang = atan(pos.x, pos.y),\n          len = length(pos.xy);\n    ang = mod(ang-start, range) - range/2. + center;\n    pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nvec3 fan_transform_xz(in vec3 pos, in float center, in float range) {\n    center *= 0.017453292519943295;\n    range *= 0.017453292519943295;\n    float start = (center - range/2.),\n          ang = atan(pos.x, pos.z),\n          len = length(pos.xz);\n    ang = mod(ang-start, range) - range/2. + center;\n    pos.xz = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nvec3 repeat_transform(in vec3 pos, in vec3 repeat) {\n    if (repeat.x > 0.) pos.x = mod(pos.x + repeat.x/2., repeat.x) - repeat.x/2.;\n    if (repeat.y > 0.) pos.y = mod(pos.y + repeat.y/2., repeat.y) - repeat.y/2.;\n    if (repeat.z > 0.) pos.z = mod(pos.z + repeat.z/2., repeat.z) - repeat.z/2.;\n    return pos;\n}\n\n\nfloat DE(in vec3 pos) {\n    return length(fan_transform_xy(\n        \t\t\trepeat_transform(\n                        fan_transform_xy(\n                            repeat_transform(\n                                fan_transform_xy(\n                                    (fan_transform_xz(\n                                        fan_transform_xy(\n                                            repeat_transform(pos, vec3(36.0, 36.0, 0.0))\n                                         , 0.0, 60.0)\n                                     , 0.0, 60.0) + vec3(0.0, 0.0, -6.0))\n                                 , 0.0, 90.0), vec3(5.0, 5.0, 0.0))\n                            , 0.0, 60.0), vec3(2.0, 2.0, 0.0))\n        \t\t\t\t, 0.0, 30.0).xz) - 0.1;\n}\n\n\nvec3 DE_norm(in vec3 p)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(\n        DE(p + e.xyy) - DE(p - e.xyy),\n        DE(p + e.yxy) - DE(p - e.yxy),\n        DE(p + e.yyx) - DE(p - e.yyx) ));\n}\n\nfloat sphere_trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    for (int i=0; i<70; ++i)\n    {\n        float d = DE(ro + rd * t);\n        if (d < 0.001)\n            return t;\n        t += d;\n        if (t > 100.)\n            break;\n    }\n    return -1.;\n}\n\nvec3 sky_c(in vec3 rd)\n{\n    return mix(vec3(0.0,.1,.0)*.3,\n               vec3(0.0,.5,.8)*.2, rd.y*.5+.5);\n}\n\nvec3 light(in vec3 p, in vec3 n, in vec3 refl, in vec3 lp, in vec3 co)\n{\n    vec3 ln = normalize(lp - p);\n    float ph = max(0., dot(n, ln));\n    float sh = max(0., dot(refl, ln));\n    return co * pow(ph, 5.)\n         + co * pow(sh, 9.) * .5;\n}\n\nmat4 camera = mat4(1);\n\nvoid get_ray(in vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0,0,0);\n    rd = normalize(vec3(uv, -1.2+.3*length(uv)));\n\n    ro = (camera * vec4(ro, 1.)).xyz;\n    rd = (camera * vec4(rd, 0.)).xyz;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 ro, rd, col=vec3(0);\n    get_ray(uv, ro, rd);\n    float t = sphere_trace(ro, rd);\n    if (t < 0.)\n        return sqrt(sky_c(rd));\n\n    vec3 po = ro+t*rd;\n    vec3 n = DE_norm(po);\n    vec3 refl = reflect(rd, n);\n\n    float amp = 4.*max(0., sin(iTime*3.+po.x/3.+po.z));\n    col += sky_c(refl)*.3;\n    col += (sky_c(rd)*amp) * pow(max(0., dot(rd, refl)), 1.);\n    col += light(po, n, refl, camera[3].xyz+vec3(10,10,-3), vec3(.3,.7,1.));\n    col += light(po, n, refl, (camera[3] * vec4(-2,-4,10,1.)).xyz, vec3(1,.8,.5));\n\t\n    col = mix(col, sky_c(rd), min(1., t/60.));\n    return sqrt(col);\n}\n\n// some nifty helper to uniformly set the rotation of a mat2, mat3 or mat4 \nvoid set_rot(in float deg, inout vec2 a, inout vec2 b, in vec4 sig)\n{\n    deg = deg / 180. * 3.14159265; vec2 sc = vec2(sin(deg), cos(deg));\n    a = sc.yx * sig.xy;\n    b = sc.xy * sig.zw;\n}\nmat4 rotate_x(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[1].yz, r[2].yz, vec4(1,1,-1,1)); return m*r; }\nmat4 rotate_y(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xz, r[2].xz, vec4(1,-1,1,1)); return m*r; }\nmat4 rotate_z(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xy, r[1].xy, vec4(1,1,-1,1)); return m*r; }\n\nvoid mainImage(out vec4 fragc, in vec2 fc)\n{\n    float t = iTime;\n\tcamera = rotate_x(camera, 90.+20.*sin(t/3.)); \n\tcamera = rotate_y(camera, -90.+20.*sin(t/4.)); \n    camera = rotate_z(camera, sin(t/7.)*90.); \n\tcamera = rotate_x(camera, 20.*sin(t/1.1)); \n    camera[3].xyz = vec3(t*3., sin(t*3.141593/12.-.1)*6., sin(t/3.-1.))+0.001;\n\t\n    // un-comment to see structure from outside\n    //camera[3].z += 15.; camera = rotate_x(camera, -50.); \n    \n    vec2 uv = (fc - iResolution.xy*.5) / iResolution.y * 2.;\n    \n    vec3 col = vec3(0.);\n\n    col = render(uv);\n\n    fragc = vec4(col,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}