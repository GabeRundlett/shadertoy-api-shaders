{
    "Shader": {
        "info": {
            "date": "1677074052",
            "description": "A random animated 2D asymmetric rounded quad grid.",
            "flags": 32,
            "hasliked": 0,
            "id": "ms3GzH",
            "likes": 94,
            "name": "Random Asymmetric Quad Grid",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "text",
                "font",
                "quad",
                "aymmetric"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1098
        },
        "renderpass": [
            {
                "code": "/*\n\n    Random Asymmetric Quad Grid\n    ---------------------------\n\n    Rendering the buffer.\n \n    See Buffer A for an explanation.\n    \n*/\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a couple of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\nvec4 bloom(sampler2D iCh, vec2 uv, float radius){\n\n\tvec4 tot = vec4(0);\n    \n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*3.;\n    \n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){\n           \n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            vec4 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7); \n            tot += mix(c, pow(c, vec4(1.25))*3.4, rnd2.x*rnd2.x); //ow(c, vec4(1.5))*4.\n            \n        }\n    }\n    \n\treturn tot/float((n*2 + 1)*(n*2 + 1));\n}\n \n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n   \n    // Custom DOF bloom-like function.\n    col = bloom(iChannel0, uv, 1.);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Random Asymmetric Quad Grid\n    ---------------------------\n    \n    I coded up an asymmetric quad cell grid some time ago, just for\n    the fun of it, then forgot about it. I came across it the other \n    day and decided to add some bump mapping, highlights, etc, and \n    wound up with whatever this is. :) It's a 2D example, so should \n    run at a reasonable pace on most machines.\n    \n    Out of sheer boredome, I put some letters in the cells, then \n    proceeded to hack away at it until it looked like... a picture of\n    a keyboard that's been run through a poorly written AI art \n    generating algorithm or something. :)\n    \n    I originally used static cells, which is a little more believable,\n    since hardened graphite material doesn't flow, but I thought the\n    animation made it a little more interesting.\n    \n    There's nothing ground breaking in here, but the grid code might\n    be interesting to some. The code was originally written with \n    extruded grids in mind. I have a few examples, and will post one \n    or two at some stage. There's a custom bloom-like postprocessing \n    routine in the \"Image\" tab that someone might find useful also.\n    \n\n*/\n\n\n// Animate the blocks or not. The animation reduces the beveled \n// letter illusion a bit, but it's more interesting.\n#define ANIMATE\n\n// Different color configurations.\n// Orange: 0, Blue: 1, Green 2, Orange and blue: 3.\n#define COLOR 0\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n \n\n// Entirely based on IQ's signed distance to a 2D triangle -- Very handy.\n// I have a generalized version somewhere that's a little more succinct,\n// so I'll track that down and drop it in later.\nfloat quad(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3){\n\n    //////////////////\n    // Extra calculations here.\n    //////////////////\n    \n    // Unfortunately, to render rounded quads on a grid, the vertices need to \n    // be moved inward in order to add a rounding factor and have the quad still\n    // fit within the cell. Contracting all vertices by a simple shrinking factor \n    // doesn't preserve edge width, so some extra trigonometry is required.\n    //\n    // By the way, I can't but help think there must be a simpler way to go about\n    // this that I'm not seeing, so if someone can figure out a way to produce \n    // the same without the following addition, feel free to let me know. :)\n\n\n    // Nudge factor to move the vertices inward. \n    const float ndg = .02;\n    \n    // Normalized edge lines.\n\tvec2 e0 = normalize(p1 - p0);\n\tvec2 e1 = normalize(p2 - p1);\n\tvec2 e2 = normalize(p3 - p2);\n\tvec2 e3 = normalize(p0 - p3);\n    \n    // Angle between vectors. Calculating four at a time, which one would\n    // assume is less draining on the GPU.\n    vec4 ang, sl;\n    ang = acos(vec4(dot(e0, -e3), dot(e1, -e0), dot(e2, -e1), dot(e3, -e2)));\n    sl = ndg/tan(ang/2.);\n    // Using the above to move the vertices in by the nudge factor.\n    p0 += sl.x*e0 + ndg*e0.yx*vec2(1, -1);\n    p1 += sl.y*e1 + ndg*e1.yx*vec2(1, -1);\n    p2 += sl.z*e2 + ndg*e2.yx*vec2(1, -1);\n    p3 += sl.w*e3 + ndg*e3.yx*vec2(1, -1);\n    \n    // Setting the new edge vectors.\n    e0 = p1 - p0;\n    e1 = p2 - p1;\n    e2 = p3 - p2;\n    e3 = p0 - p3;\n    \n    //////////////////\n    //////////////////\n\n    // Continuing with IQ's quad calculations... Actually, this is a \n    // slighlty modified version of his triangle function. \n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 v3 = p - p3;\n   \n\tvec2 pq0 = v0 - e0*clamp(dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp(dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp(dot(v2, e2)/dot(e2, e2), 0., 1.);\n\tvec2 pq3 = v3 - e3*clamp(dot(v3, e3)/dot(e3, e3), 0., 1.);\n    \n    float s = sign(e0.x*e3.y - e0.y*e3.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n    \n    d = min(d, vec2(dot(pq3, pq3), s*(v3.x*e3.y - v3.y*e3.x)));\n \n    // Signed, rounded quad distance.\n\treturn -sqrt(d.x)*sign(d.y) - ndg;\n}\n\n\n// IQ's vec2 to float hash.\nvec2 hash22TA(vec2 p){ \n\n    p = texture(iChannel3, p/63.2453).xy;\n    return sin(p*6.2831853 + iTime);//p;//\n    \n  \n}\n\n// IQ's vec2 to float hash.\nvec2 hash22T(vec2 p){ return texture(iChannel3, p/65.6217).xy*2. - 1.; }\n\n\nvec4 gVal; // Storage for the cell contents.\nvec2 gSID; // Static ID.\n\n// Global normal. It's a weird place to put it, but I'm doing the \n// bump mapping inside the \"map\" function to save calculations.\nvec3 gN; \n\nvec2 scale = vec2(1.5, 1)/10.; // Scale.\n\n// The asymmetric quad grid. \nvec4 map(vec2 p){\n    \n    // Distance and edge width.\n    float d = 1e5;\n    float ew = .005;\n    \n    // Scale.\n    vec2 sc = scale;\n    \n    \n    // Centers for all four tiles.\n    const mat4x2 cntr = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5)); \n    \n    // Saving the local coordinates and four vertices of the nearest quad. \n    // Only used for bump mapping.\n    vec2 svQ;\n    mat4x2 svV;\n    \n    // Because the asymmetric boundaries of the quads overlap neighboring cells, \n    // neighbors need to be considered. In this case four cell renders will do.\n    const int n = 2;\n    //const float m = floor(float(n)/2. + .001) - .5;\n    for(int i = 0; i<n*n; i++){\n\n        // Local coordinates and ID.\n        vec2 q = p.xy;\n        vec2 iq = floor(q/sc - cntr[i]) + .5; \n        q -= (iq)*sc;\n        \n        // The four vertices for this cell.\n        mat4x2 v = cntr;\n        \n        // Offset the vertices.\n        #ifdef ANIMATE\n        v[0] += hash22TA(iq + v[0])*.2;\n   \t\tv[1] += hash22TA(iq + v[1])*.2;\n        v[2] += hash22TA(iq + v[2])*.2; \n        v[3] += hash22TA(iq + v[3])*.2;\n        #else\n        v[0] += hash22T(iq + v[0])*.2;\n   \t\tv[1] += hash22T(iq + v[1])*.2;\n        v[2] += hash22T(iq + v[2])*.2; \n        v[3] += hash22T(iq + v[3])*.2;\n        #endif\n        // Scale.\n        v[0] *= sc; v[1] *= sc; v[2] *= sc; v[3] *= sc;\n        \n\n        // Render the quad. This is a modified version of one of IQs\n        // polygon functions to render rounded general quads that\n        // fit on a grid.\n        float d2 = quad(q, v[0], v[1], v[2], v[3]) + ew;\n        \n        // If this quad distance is nearer, update.\n        if(d2<d){\n            \n            // New distance, static ID and moving ID.\n            // The zero field is an unused height value holder.\n            d = d2;\n            gSID = iq;\n            iq += (v[0] + v[1] + v[2] + v[3])/4./sc;\n            gVal = vec4(d2, 0., iq);\n            \n            // Saving the local coordinates and vertices to perform \n            // some bump mapping. These were hacked in as an afterthough.\n            // Normally, you wouldn't need to do this.\n            svQ = q;\n            svV = v;\n      \n        }\n    \n    }\n    \n    // Set the normal to the back plane.\n    gN = vec3(0, 0, -1);\n    \n    // If we've hit a quad, bump map the normal.\n    if(d<1e5){\n    \n        // Saving some calculations by constructing the normal here,\n        // instead of calling the entire map function two more times.\n        //\n        vec2 e = vec2(.005, 0); // Sample spread.\n\n        vec2 q = svQ;\n        mat4x2 v = svV;\n\n        // Nearby X and Y samples -- Standard gradient calculations.\n        float d2X = quad(q - e, v[0], v[1], v[2], v[3]) + ew;// - .02;\n        float d2Y = quad(q - e.yx, v[0], v[1], v[2], v[3]) + ew;// - .02;\n        // Modifying the samples to give a slightly rounded beveled look.\n        d = mix(d, smax(d, smax(d*2., -.01, .01), .1), .75); \n        d2X = mix(d2X, smax(d2X, smax(d2X*2., -.01, .01), .1), .75);  \n        d2Y = mix(d2Y, smax(d2Y, smax(d2Y*2., -.01, .01), .1), .75);  \n        /*\n        // Alternative flatter tops, which are more button like.\n        d = smax(smax(d*6., -.03, .01), smax(d*2., -.02, .01), .03); \n        d2X = smax(smax(d2X*6., -.03, .01), smax(d2X*2., -.02, .01), .03); \n        d2Y = smax(smax(d2Y*6., -.03, .01), smax(d2Y*2., -.02, .01), .03); \n        */\n        // Applying the gradient to the flat plane normal, vec3(0, 0, -1).\n        float bf = .7; // Bump factor.\n        gN = normalize(vec3((d - d2X)/e.x, (d - d2Y)/e.x, -1./bf));\n    }\n    \n    \n    // Combining the floor with the extruded object.\n    return  gVal;\n \n}\n\n// Obtaining an ASCII character from the font texture. This is pretty standard.\n// I think I based it on one of Fabrice's early examples. I'll find it and put\n// in the link later.\nvec4 chTx(vec2 p, int n){\n\n    vec2 i = vec2(n&15, 15 - (n>>4))/16.;\n    return (p.x<0. || p.x>1./16. || p.y<0. || p.y>1./16.)? \n            vec4(0, 0, 0, 1e5) : texture(iChannel1, p + i);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Moving coordinates.\n    vec2 p = r2(-3.14159/16.)*uv + vec2(0, 2)*iTime/64.;//r2(-3.14159/12.)*\n     \n    // Unit direction ray and light direction.\n    vec3 rd = normalize(vec3(uv, 1)); \n    vec3 ld = normalize(vec3(-.5, .5, -3) - vec3(uv, 0));\n\n    // Obtaining the asymmetric quad cell information.\n    vec4 d4 = map(p);\n    \n    // Set the normal to the one calculated in the \"map\" function.\n    vec3 sn = gN;\n    \n    // Smoothing factor.\n    float sf = 1./iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    // Random graphite cell color.\n    float rnd = hash21(gSID); // Random object value.\n    vec3 oCol = vec3(rnd*rnd*.04 + .05);\n    \n    // Random color for blinking light cells.\n    vec3 oColL = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2)*1.2); // Orange.\n    //vec3 oColL = .5 + .45*cos(6.2831*rnd/15. + vec3(0, 1, 2.2)*1.1 + 1.15);\n    //vec3 oColL = .5 + .38*cos(6.2831*rnd/7.5 + vec3(0, 1, 2.2)/1.2 + .7);\n    \n    // Mixing in another color.\n    oColL = mix(oColL, oColL.xzy, hash21(gSID + .42)*.25);\n    \n    #if COLOR == 1\n    oColL = oColL.zyx; // Blue.\n    #elif COLOR == 2\n    oColL = mix(oColL, oColL.yxz*.8, .8); // Green.\n    #elif COLOR == 3\n    // Random compliment colors.\n    oColL = mix(oColL.zyx, oColL, step(.5, hash21(gSID + .44)));\n    #endif\n    \n\n    \n    // Random lighter grey.\n    if(hash21(gSID + .17)<.5) {\n        oColL = vec3(.88, .9, 1)*(rnd*.12 + .18);//dot(oColL, vec3(.299, .587, .114));\n    }\n         \n    // Random blinking colors. I overuse this trick a bit, but it's effective.    \n    float rnd2 = hash21(gSID + .23);\n    oCol = mix(oCol, oColL*1.5, smoothstep(.93, .96, sin(6.2831*rnd2 + iTime/4.)*.5 + .5));\n\n    \n    ///// FONTS /////\n    // Adding text to the cells.\n    vec2 sc = scale;\n    vec2 tPos = p - d4.zw*sc - vec2(1, 2)*32./1024.*sc + vec2(sc.x/4., sc.y/2.4);\n    int nc = int(floor(hash21(gSID)*93.) + 33.);\n    float sD = .003;\n    float bF = 2.;\n    // Texture samples.\n    vec4 dC = chTx(tPos, nc);\n    vec4 dCX = chTx(tPos - vec2(sD, 0), nc);\n    vec4 dCY = chTx(tPos - vec2(0, sD), nc);\n    // Gradient indentation -- I was in a hurry, so there are probably neater\n    // ways to do this... Probably a question for Fabrice. :)\n    dC.x = smoothstep(0., .25, -(dC.w - .53));\n    dCX.x = smoothstep(0., .25, -(dCX.w - .53));\n    dCY.x = smoothstep(0., .25, -(dCY.w - .53));\n    \n    // Applying the font indentation bump to the normal. It's not perfect, but it'll do.\n    float bf = .5;\n    sn = normalize(sn + vec3((dC.x - dCX.x)*bf, (dC.x - dCY.x)*bf, 0)/sD*bF);\n   \n    // Applying a font overlay color to the font indentation.\n    vec3 fCol = oCol/(.5 + dot(col, vec3(.299, .587, .114)));  \n    float gr = dot(fCol, vec3(.299, .587, .114));\n    fCol = max(vec3(1) - gr*gr*8., .0)*.9 + .05;\n    //svC = mix(oColL, svC*, smoothstep(.93, .96, sin(6.2831*rnd2 + iTime/4.)*.5 + .5));\n    oCol = mix(oCol, fCol, (1. - smoothstep(0., sf*3., dC.w - .51))*.9);\n    //////////////\n    \n    \n    // Diffuse and specular calculations. \n    float dif = max(dot(ld, sn), 0.); \n    float spe = pow(max(dot(reflect(ld, sn), rd), 0.), 8.);\n    //float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 16.);\n\n    \n    // Overall coloring and lighting for the cell.\n    oCol *= (dif*.35 + .3 + vec3(1, .97, .92)*spe*.5);\n    \n    // Using the cube map for some fake specular reflections.\n    vec3 tx = texture(iChannel2, reflect(rd, sn)).xyz; tx *= tx;\n    oCol += (oCol*.75 + .25)*mix(tx.zyx, tx.yyy, .3)*4.*spe;\n \n    // Applying the cell to the background.\n    col = mix(col, oCol, 1. - smoothstep(0., sf, d4.x));\n \n \n  \n    #if 1\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./3.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), d4.x), blend);\n    #else\n    // Output to screen.\n    fragColor = vec4((max(col, 0.)), d4.x);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}