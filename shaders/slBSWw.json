{
    "Shader": {
        "info": {
            "date": "1627783265",
            "description": "Volumetric light as described in this post by Inconvergent: https://inconvergent.net/2021/volumetric-light/",
            "flags": 0,
            "hasliked": 0,
            "id": "slBSWw",
            "likes": 7,
            "name": "Inconvergent-style Volumetrics ",
            "published": 3,
            "tags": [
                "volumetrics",
                "ziggurat"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "const int sampleCount = 4;\n\nconst float cameraDistance = 2.;\nconst float cameraHeight = 3.0;\n\nRay getHitRay(vec2 uv)\n{\n    const vec3 cameraPosition = vec3(cameraDistance, cameraHeight, cameraDistance);\n    \n    float angle = 5.6;\n    vec3 pos = cameraPosition;\n    pos.x *= sin(angle);\n    pos.z *= cos(angle);\n    //camera calculations\n    vec3 target = vec3(.0);\n    vec3 rayOrigin = target + pos;\n    vec3 front = normalize(target-rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    return Ray(rayOrigin, rayDir);\n}\n\nvec3 lineSample(vec3 start, vec3 end, vec2 uv, int iteration)\n{\n    return mix(start, end, pseudorandScalar(uv+float(iteration)+sin(iTime), uv, iChannel0)); \n}\n\nfloat traceScene(Ray ray)\n{\n    const int boxAmount = 3;\n    Box boxes[boxAmount] = Box[boxAmount]\n    (\n        Box(vec3(.0, .2, .0), vec3(1.5, .2, 1.5))\n       ,Box(vec3(.0, .4, .0), vec3(1., .2, 1.))\n       ,Box(vec3(.0, .8, .0), vec3(.5, .2, .5))\n    );\n\n\n    float result = missValue;\n    for(int i = 0; i < boxAmount; i++)\n    {\n        result = min(result, boxIntersection(ray, boxes[i]).near);\n    }\n    \n    Box zobb = Box(vec3(-1.0, .2, .0), vec3(1.0, .5, .4));\n    const float rotation = 2.8;\n    result = min(result, zobbIntersection(ray, zobb, rotation).near);\n    \n    const Plane plane = Plane(vec3(.0), vec3(.0,1.,.0));\n    \n    return min(result, planeIntersection(ray, plane));\n}\n\nbool pathClear(vec3 start, vec3 end)\n{\n    vec3 delta = end-start;\n    float dist = length(delta);\n    vec3 direction = delta/dist;\n    float result = traceScene(Ray(start, direction));\n    return result < .0 || result > dist;\n}\n\nvec3 Image(vec2 uv)\n{\n    Ray currentRay = getHitRay(uv);\n    float dist = traceScene(currentRay);\n    vec3 hit = currentRay.origin + currentRay.direction * dist;\n    \n    vec3 lightPosition = vec3(sin(iTime*.3)*10.0, 2.0, cos(iTime*.3)*-10.0);\n    const float lightStrength = 1.; \n    \n    \n    float pixelValue = .0;\n    \n    for(int i = 0; i < sampleCount; i++)\n    {\n        vec3 randPosition = lineSample(currentRay.origin, hit, uv, i);\n        if(pathClear(randPosition, lightPosition))\n        {\n            vec3 delta = randPosition-lightPosition;\n            float lightDistSquared = dot(delta, delta);\n            pixelValue += dist / (1.0 + lightDistSquared);\n        } \n    }\n    \n    pixelValue *= lightStrength / float(sampleCount);\n    \n    return vec3(pixelValue, pixelValue, pixelValue);\n}\n\nMAIN_FUNCTION(Image)",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int aa = 2;\n\n\nstruct Box\n{\n    vec3 center;\n    vec3 halfDimensions;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n};\n\nstruct BoxReturn\n{\n    float near;\n    float far;\n};\nconst float missValue = 100000000.0;\nconst BoxReturn boxReturnMiss = BoxReturn(missValue, missValue);\n\nBoxReturn boxIntersection(Ray ray, Box box)\n{\n    vec3 maximum = box.center + box.halfDimensions;\n    vec3 minimum = box.center - box.halfDimensions;\n    //from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n    bool xSign = ray.direction.x >= 0.;\n    bool ySign = ray.direction.y >= 0.;\n    vec3 inverseDir = 1.0/ray.direction;\n    \n    float nearest = ((xSign ? minimum : maximum).x - ray.origin.x) * inverseDir.x; \n    float nextNearest = ((xSign ? maximum : minimum).x - ray.origin.x) * inverseDir.x; \n    float nearestY = ((ySign ? minimum : maximum).y - ray.origin.y) * inverseDir.y; \n    float nextNearestY = ((ySign ? maximum : minimum).y - ray.origin.y) * inverseDir.y; \n \n    if (nearest > nextNearestY || nearestY > nextNearest) \n        return boxReturnMiss;\n    \n    nearest = max(nearestY, nearest);\n    nextNearest = min(nextNearestY, nextNearest);\n    \n    bool zSign = ray.direction.z >= 0.;\n    float nearestZ = ((zSign ? minimum : maximum).z - ray.origin.z) * inverseDir.z;\n    float nextNearestZ = ((zSign ? maximum : minimum).z - ray.origin.z) * inverseDir.z; \n    \n    if ((nearest > nextNearestZ) || (nearestZ > nextNearest)) \n        return boxReturnMiss;\n    \n    nearest = max(nearest, nearestZ);\n    nextNearest = min(nextNearestZ, nextNearest);\n    \n    return BoxReturn(nearest, nextNearest);\n}\n\nvec3 rotateZ(vec3 v, float angle)\n{\n    mat3 rotation = mat3(\n        cos(angle), -sin(angle), .0,\n        sin(angle), cos(angle), .0,\n        .0, .0, 1.0\n    );\n    return v * rotation;\n}\n\nBoxReturn zobbIntersection(Ray ray, Box box, float zRotation)\n{\n    ray.origin -= box.center;\n    box.center = vec3(.0);\n    ray.origin = rotateZ(ray.origin, zRotation);\n    ray.direction = rotateZ(ray.direction, zRotation);\n    return boxIntersection(ray, box);\n}\n\nfloat planeIntersection(Ray ray, Plane plane)\n{\n    float denom = dot(plane.normal, ray.direction);\n    if (abs(denom) > 0.0001)\n    {\n        float result = dot(plane.point - ray.origin, plane.normal) / denom;\n        return result < .0 ? missValue : result;\n        \n    }\n    return missValue;\n}\n\nfloat pseudorandScalar(vec2 randseed, vec2 uv,  sampler2D tex)\n{\n    //blue noise with toroidal shifting\n\treturn fract(texture(tex, uv).x + fract(sin(dot(randseed, vec2(1.0,113.0)))*43758.5453123));\n}\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \t\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    \\\n    /*Output to screen*/\\\n    fragColor = colorCorrect(total);\\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}