{
    "Shader": {
        "info": {
            "date": "1478465545",
            "description": "In cooperation with [url=https://www.shadertoy.com/user/mu6k]Mu6k[/url].\nPresented at QB Party, May 2016.\n\nmore info:\nhttp://www.pouet.net/prod.php?which=67380",
            "flags": 0,
            "hasliked": 0,
            "id": "XttXRN",
            "likes": 15,
            "name": "â™« Living Structure [Patu & Mu6k]",
            "published": 3,
            "tags": [
                "raymarching",
                "intro",
                "demoscene",
                "ifs",
                "qbparty"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 1052
        },
        "renderpass": [
            {
                "code": "/*\n * \n * \"Living Structure\" by Mu6k and Patu.\n * Released at QB Party, 2016\n * \n */\n\n// samples (final quality)\nconst int samplesX = 3, samplesY = 2;\n\n#define getNormal getNormalHex\n#define FAR 400.\n#define INFINITY 1e32\n#define time (iChannelTime[0] * 2.45)\n\n#define FOV 140.0\n#define FOG .5\n\n#define PI 3.14159265\n#define TAU (2. * PI)\n#define PHI (1.618033988749895)\n\nfloat s(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat\n    iv = 0.,\n\tmf1,\n\tmf2,\n\tsr,\n    cth,\n\tfc,\t\n\tap,\n    st = 0.,\n    ste = 0.,\n    nst = 0.,\n    r1 = -0.1,\n    t_min = 0.01, t_max = FAR;\n\nvec3\n    cp = vec3(0.),\n    cla = vec3(0.),\n    gfm = vec3(0.);\n\n#define fR(r, g, b) (vec3(float(r), float(g), float(b)) / 255.);\n\n// compute fade. 0 full black, 1 normal.\nfloat msz() {\n\treturn min(s(st / 2.), s(ste / 2.));\n}\n\nstruct G {\n    float dist,glow;\n    vec3 space,hit,sn;\n    vec2 mat;\n    int iy;\n};\n\nG map(vec3 p); //forward\n\n/**\n  * Computes current stage.\n  */\nint cs = 0;\nconst float sst[] = float[](0., 63.5, 127.3, 192., 256., 322., 384., 448., 576., 642., 768.);\n\nvoid ms() {\n    for (int a = 0; a < 10; a++) {\n        float _ca = sst[a];\n        float _cb = time;\n        if (_ca < _cb) {\n            cs = a;\n            st = time - _ca;\n            ste = sst[a + 1] - _ca;\n            nst = st / ste;\n        }\n    }\n}\n\n// set variables.\nvoid sv() {\n    float\n        t2 = time - 35.,\n        sk = sin(st * .05) * 13.,\n        ck = cos(st * .05) * 13.;\n\n    sr = 15. * msz();\n    cth = 1.;\n\n    mf1 = 0.;\n    mf2 = 0.;\n\n    if (cs == 0) {\n     \tsr = 15.;\n\n        mf1 = 11.4;\n        mf2 = 8.;\n\n        cp = vec3(13., 19., cos(st * .04) * 123. + 15.);\n        cla = vec3(0., 0., 0.);\n\n\t\tfc = distance(cp, cla);\n\t\tap = .01;\n\n        gfm.y = 2.;\n        gfm.z = -1.;\n        gfm.x = 2.;\n        return;\n    }\n\n    if (cs == 1) {\n        sr = 15.;\n\n        mf1 = 32.;\n        mf2 = -3.;\n\n\t\tap = .0;\n\n        cp = vec3(1., 14., 10. - st / 3.);\n        cla = vec3(st * 0.2, 0., st * 0.2);\n\n\t\tfc = mix(1.0,distance(cp, cla)+20.0, st/64.0);\n\n\t\tap = .0025;\n\n        gfm.x = 1.;\n        return;\n    }\n\n    if (cs == 2) {\n        sr = min(st * 0.4, 16.);\n    \tmf1 = 50.;\n    \tmf2 = 19.;\n\n\t\tfc = 10.0;\n\t\tap = .001;\n\n        cp = vec3(-st * .3, -14., 10.);\n        return;\n    }\n\n    if (cs == 3) {\n        sr = st / 2.;\n\n        mf1 = 20. + st;\n        mf2 = 17.;\n\n\n        cp = vec3(20., -20. , 22.);\n        cla = vec3(0., 0., 0.);\n\n\t\tfc = distance(cp, cla);\n\t\tap = .0025;\n\t\treturn;\n        //gfm.yz += 3.;\n    }\n\n    if (cs == 4) {\n        sr = 15. + st * 0.3;\n\n        mf1 = 12.;\n        mf2 = st / 3. + 5.;\n\n        cp = vec3(sk * 1., -1. , 3. + ck);\n\n\t\tfc = map(cp).dist+0.0;\n\t\tap = .1/(st);\n\n        gfm.y = 1.;\n        gfm.x = -2.3;\n        return;\n    }\n\n    if (cs == 5) {\n        sr = 25.;\n\n        mf1 = 12.;\n        mf2 = 12.;\n\n        cp = vec3(4. - st / 7., 1. , 0.);\n        cla = vec3(10., ck, sk);\n\n\t\tfc = 9.0;\n\t\tap = .01;\n\n        gfm.y = -1.;\n        gfm.z = 1.;\n        return;\n    }\n\n    if (cs == 6) {\n        sr = 125.;// + st;\n\n        mf1 = 11.;\n        mf2 = 12.;\n\n        cp = vec3(13. , -1.+ st / 15. , 5. - st / 18.);\n        cla = vec3(10., 0., 0.);\n\n\t\tfc = mix(.0, 15.0, st*0.01);\n\t\tap = .01;\n\n        gfm.y = 3.0;\n        gfm.z = -1.3;\n        return;\n    }\n\n    if (cs == 7) {\n        cth = 0.;\n        sr = 6. + st * 1.5;\n\n        mf1 = 1.;\n        mf2 = -8.;\n\n        cp = vec3(-13.9+st*.049, 12. , 14. - st / 14.);\n        cla = vec3(st, 10., 0.);\n\n\t\tfc = 10.+sin(st*.1)*5.0;\n\n\t\tap = .007;\n\n        gfm.x = -.9 ;\n        gfm.z = .3 + st / 141.;\n        return;\n    }\n\n    if (cs == 8) {\n        cth = 0.;\n        sr = 6. + st * 1.5;\n\n        mf1 = 1.;\n        mf2 = -7.;// + st * 0.02;\n\n        cp = vec3(-10.9 , 22.+ st / 4., 4.);\n        cla = vec3(st * 5., 0, 0);\n\n\t\tfc = 13. - (pow(nst, 3.0) * 13.);\n\t\tap = .02;\n\n        gfm.x = -.9;\n        gfm.y = -2.2;\n        gfm.z = .25;\n        return;\n    }\n\n    if (cs == 9) {\n        cth = 1.;\n        sr = max(0., 56. - st * .5);\n\n        mf1 = 1.;\n        mf2 = -7.4;// + st * 0.02;\n\n\t\tfc = 10.0*(1.0-1.0/(1.0+pow(st,4.0)*.0125));\n\t\tap = .01;\n\n        cp = vec3(-12.9 + st / 12., 12. , 12.);\n        cla = vec3(0);\n\n        //gfm.x = -.3 / st;\n        gfm.y = -1.2 - st * 0.01;\n        gfm.z = 1.4 - st * 0.01;\n    }\n\n    \n}\n\nvec3\n    lightPos = vec3(8., 110., 381.);\n\nvec2 spc(in vec3 normal, float delta) {\n     return vec2(\n         atan(normal.z, normal.x) / PI * 2. + delta,\n         asin(normal.y) / TAU\n     );\n}\n\nvec3 opRep( vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nvec2 pmm2(inout vec2 p, vec2 s) {\n\tvec2 h = s*.5;\n\tvec2 c = floor((p + h)/s);\n\tp = mod(p + h, s) - h;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nG unionObjects(G g1, G g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nG io(G g1, G g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2(vec3 d1, vec3 d2) {\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2(vec3 d1, vec3 d2) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pmi (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pmo (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpmi(p.x, dist.x);\n\tpmi(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Box: correct distance to corners\nfloat fb(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.))) + vmax(min(d, vec3(0.)));\n}\n\nfloat fsh(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nG DE(vec3 p, float c) {\n \tconst float scale = 3.4;\n\tconst float offset = 10.0;\n    const int FRACTALiy = 8;\n    vec3 modifier = vec3(c +  4.4 ,4.4 + c , 2.3) + gfm;\n\n\n    for(int n=0; n< FRACTALiy; n++) {\n        p = abs(p);\n\n\t\t//p.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n\t\tp.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n        p.x += c + .9;\n\n        p.xyz = scale* p.xyz - offset*(scale-1.0) * modifier.xyz;\n    }\n\n \tG obj;\n    obj.dist = length(p.xz) * 1.3 * (pow(scale, -float(FRACTALiy)));\n\tobj.space = p;\n\n    return obj;\n}\n\n\nG map(vec3 p) {\n\n    vec3 bp = p;\n\n    p.x += mf1;\n    p.x = mod(p.x, 120.);\n\n\tpmm2(p.yz, vec2(30.));\n\n    vec2 c =  pmo(p.zy, vec2(50. , 50. ));\n\n    pmo(p.xz, vec2(13., 4. + mf2));\n\n    pR(p.xz, -0.1);\n\n    p.z += 19.;\n    p.yx += 4.;\n\tp.x -= 18. + mf2;\n\n    G obj;\n\n    obj = DE(p, 4.5 - mf2);\n    pR(p.xz, .4);\n\n    p.x += 2.9;\n    p.z += 9.;\n\n    obj.dist = smin(\n        obj.dist - .1,\n        DE(p.zyx, 2.).dist - 1. ,\n        .21\n    );\n\n    obj.mat = vec2(1., 0.);\n    obj.space = p;\n\n    p = bp;\n\n    G obj2;\n    // mix sphere with box\n    obj2.dist = mix(\n        fb(p, vec3(sr - 4.)),\n        fsh(p, sr),\n        cth\n    );\n\n    obj2.mat = vec2(2., 0.);\n    obj2.space = p;\n\n    obj = io(obj, obj2);\n\n    return obj;\n}\n\n\n\nconst int MAX_iy = 90;\n\nG trace(vec3 o, vec3 d) {\n    float omega = 1.3,\n\t\tt = t_min,\n\t\tce = INFINITY,\n\t\tct = t_min,\n\t\tpr = .0,\n\t\tsl = 0.,\n\t\tpa = 1./ 250.;\n\n    G mp = map(o);\n\n    mp.glow = 0.;\n\n    float fus = mp.dist < 0. ? -1. : +1.;\n    float minDist = INFINITY;\n\n    for (int i = 0; i < MAX_iy; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iy = i;\n\n        minDist = min(minDist, abs(mp.dist * .2));\n        mp.glow = pow(3. / minDist, .9);\n\n        float signedRadius = fus * mp.dist;\n        float r = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (r + pr) < sl;\n        if (sorFail) {\n            sl -= omega * sl;\n            omega = 1.;\n        } else sl = signedRadius * omega;\n        \n        pr = r;\n        float e = r / t;\n        if (!sorFail && e < ce) {\n            ct = t;\n            ce = e;\n        }\n        if (!sorFail && e < pa || t > t_max) break;\n        t += sl;\n   \t}\n\n    mp.dist = ct;\n\n    if (\n        (t > t_max || ce > pa)\n    \t) mp.dist = INFINITY;\n\n    return mp;\n}\n\n\nfloat ssh(vec3 ro, vec3 lp, float k) {\n    const int maxiyShad = 3;\n    vec3 rd = (lp - ro); \n\n    float h = 4.;\n    float dist = 4.5;\n    float e = max(length(rd), .01);\n    float s = e / float(maxiyShad);\n\n    rd /= e;\n    for (int i = 0; i < maxiyShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        h = min(h, k*h/dist);\n        dist += min(h, s * 2.);\n        if (h < .001 || dist > e) break;\n    }\n    return min(max(h, 0.), 1.);\n}\n\nvec3 getNormalHex(vec3 p) {\n\tfloat d=map(p).dist;\n\tfloat e=.001;\n\treturn normalize(\n        vec3(\n            map(\n                p+vec3(e,0,0)).dist-d,\n                map(p+vec3(0,e,0)).dist-d,\n                map(p+vec3(0,0,e)).dist-d\n        \t)\n    \t);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist) {\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, .0, 1.0);\n}\n\nvec3 getObjectColor(G tr) {\n    vec3 col = vec3(.0);\n\n    if (tr.mat.x == 1.0) {\n        col = fR(204, 141, 96);\n    }\n\n    return col;\n}\n\nvec3 doColor(in vec3 rd, G tr) {\n    vec3 ld = lightPos;\n    ld /= max(length(ld), 0.001);\n\n    float a = pow(max( dot( reflect(-ld, tr.sn), -rd ), 0.0 ), 4.0);\n\n    // fresnel\n    vec3 H = normalize(normalize(ld) + rd);\n    float x = pow(1. - dot(rd, H), 5.0);\n    a *= x + 5. * (1. - x);\n\n    return (getObjectColor(tr) * (max(dot(tr.sn, ld), 1.) + .15) * a * .5);\n}\n\nfloat h(vec2 x){\n\treturn fract(572.612*sin(1413.7613*sin(time*41.12)+1175.2126*fract(dot(x, 1114.41256*vec2(56.0,1.37)))));\n}\n\nvoid mi(out vec4 q, in vec2 xc) {\n    vec2\n        ouv = xc,\n   \t\tuv = ouv - .5;\n\n    if (abs(uv.y) > .4) {\n    \tq = vec4(0., 0. ,0. ,1.);\n        return;\n    }\n\n    sv();\n\tcp.yx += sin(st * .4 - cos(time / 3.) / 3.) / 13.;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    vec3\n        vuv = vec3(1., 0., 0.),\n        vpn = normalize(cla - cp),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (cp + vpn),\n    \tscrCoord = (vcv + uv.x * u * 16.0/9.0 + uv.y * v),\n    \trd = normalize(scrCoord - cp),\n\t\tw = vec3(0.);\n\n\tcp += rd *fc;\n\tvec3 hd = vec3(h(xc*.2-0.027), h(xc*.4+0.06412), h(xc*.3+0.05120))-.5;\n\tvec3 perp = normalize(hd - rd * dot(hd, rd) / dot(rd, rd));\n    rd+=perp*ap*(1.0-pow(h(xc*.171),2.0));\n\n\trd = normalize(rd);\n\n\tcp -= rd*fc;\n\n\tfloat id = map(cp).dist;\n\tfloat is = sign(id);\n\n\tcp+=rd * h(xc) * abs(id) * .1;\n\tcp+=rd * h(xc*-.5) * abs(map(cp).dist) * .1;\n\n    G tr = trace(cp, rd);\n\n    tr.hit = cp + rd * tr.dist;\n    tr.sn = getNormal(tr.hit);\n\n    float\n        sh = ssh(tr.hit, lightPos, 4.),\n        ao = getAO(tr.hit, tr.sn, 1.);\n\n  \n\tif (is<.0) ao = (1.0-ao)*2.0;\n\n    if (tr.dist < FAR) {\n\n        w = doColor(rd, tr)*4.0*vec3(.9,.7,.6);\n\n        w *= sh*ao;\n        w += ao*vec3(.9,.7,.6)*.05;\n\n        w *= 1. + length(\n            max(0.,\n                1. + max(\n                    0.,\n                    length(normalize(lightPos.xy) * max(vec2(0.), tr.sn.xy))\n                )\n        ));\n\n        // waving\n        w += .5 * (pow((sin(PI * fract(time * 0.1 +  (sin(tr.hit.y + time * 0.1) - sin(tr.hit.x)) / 10. + time / 3.)) + 1.), 6.) / 10.) / 30.;\n\n        if (tr.mat.x == 2.) {\n           w += pow(tr.dist, 3.) / 10000.;\n        } else {\n            w += pow(sin(float(tr.iy) / 180.), 0.4) * 0.8;\n        }\n\n\n    } else {\n        w += abs(tr.glow) / 80.;        \n\t\tw +=tr.glow/(0.001+pow(abs(rd.x),.75))*.125;\t\n\n    }\n\tw = max(w,vec3(.0));\n\tw += abs(spc(rd, 1.).y) * .4;\n\tw += pow(abs(rd.y),1.5)*.4;\n    w *= 1. + float(tr.iy) / 96.;\n    w = w * (1.5 - length(ouv - .5) * 2.);\n\n\tw += vec3(h(w.xy+xc))*0.05;\n\tvec3 k = mix(vec3(1.05,1.01,1.6),vec3(1.6,1.2,1.0), -cos(time/60.0)*.5+.5);\n\tk = mix(k, vec3(1.01,1.1,1.05), cos(time/40.0)*.5+.5);\n\tk += xc.y*vec3(.1,.2,.4);\n\tfloat x = 1.9;\n\n    // tonemapping\n    w = x*k * w / (1. + w);\n\n    q = vec4(w * min(s(st), s(ste)), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tms();\n\t\n    vec4 acc = vec4(0.);\n    \n    vec2 recp = vec2(1.0)/vec2(samplesX, samplesY);\n    for (int x=0; x<samplesX; x++){\n        for (int y=0; y<samplesY; y++){\n            vec4 tmp;\n            mi(tmp,(fragCoord.xy + vec2(x, y)*recp) / iResolution.xy);\n            acc += tmp;\n        }\n    }\n\tacc /= float(samplesX*samplesY);\n    \n    iv = max(.5, min(.8, texture(iChannel0, vec2(.85, .25)).g * 1.4)) - .5;\n\tfragColor = acc + iv;\n    fragColor = pow(fragColor, vec4(.6)) - .5;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 21,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}