{
    "Shader": {
        "info": {
            "date": "1551925895",
            "description": "[b]AI/BOTS DISABLED[/b] to enable edit Common no_AI.\n\nboards playable\n\n[b]Control:[/b]\nplayer arrows [b]left/right/top/down[/b]\nclick [b]red square[/b] for reset\nclick on visible board to display it\nscroll up/down(white scroll on sides or click on table)",
            "flags": 48,
            "hasliked": 0,
            "id": "3dlSzs",
            "likes": 131,
            "name": "GLSL Auto Tetris",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "tetris",
                "ai"
            ],
            "usePreview": 1,
            "username": "morimea",
            "viewed": 10940
        },
        "renderpass": [
            {
                "code": "// REQUAREMENT webGL float should support 0xffffff value in it (24bit int)\n// 2020 remark - when I wrote this code, I forgot that uint!=int and I thought that only 0xffffff max for 32bit float fbo...\n\n\n// More info - watch/read:\n// https://youtu.be/rcgpwVLydLw\n// https://danilw.github.io/blog/Launching_619_thousand_Tetris_on_GPU/\n\n\n// Update 2022 - added map option - from \"naive [220] int array\" to 7(seven)-uints and use bits\n// in Common #define use_uint_map\n// it does speedup shader execution\n// BUT turned off by default - because this entire shader build around:\n// \"WebGL2 is not ready for 32-bit uints\" - and in original I used float 0xffffff-range and bits emulation (pack/unpacl bits in loop)\n\n\n// IDEA - \"run max numbers of tetris bots for one framebuffer, to see whos gonna win\"\n// <max number> for this code= (Res.x*Res.y/3) (691k for 1920x1080)\n\n// WHAT IS IT\n// <num>(yellow) tetris AI launched same time on GPU\n\n// the AI\n// VERY minimal it die at ~30 lines burn\n\n// how it work:\n\n// DATA tetris board need 10*22=220 bits to store data(1/0 block free/non)\n// 1 pixel can store 24*4=96bits\n// to save full board used\n// 2*96(two pixels) + 24(1 component of third pixel)+4(four bits second component third pixel)\n// [pixel 1] [pixel 2] [x, 4 bit of y, z unused, w unused]\n\n// LOGIC saved in unused blocks\n// logic work this way:\n// data pixels(1-3) execute action_e, logic pixel(3) check if action_l is valid for map\n// so data logic load only \"self\" part of map(does not load full map)\n// \"logic\"(3 pixel) load full map (debug_draw ~20% faster, it does not load full map)\n\n\n\n// also read my comment under shader\n\n\n\n// Created by Danil (2019+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\n//antialiasing set 3+\n#define AA 0\n\n//other useful defines in Common\n\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define res (iResolution.xy / iResolution.y)\n\nfloat zv;\nvec2 res_g;\nivec2 ipx;\n\n#define alp min(0, iFrame)\n\nconst vec3 white = vec3(0xa4, 0xc4, 0xd8) / float(0xff);\nconst vec3 whitel = vec3(0xdc, 0xe0, 0xd1) / float(0xff);\nconst vec3 dark = vec3(0x1d, 0x1d, 0x2b) / float(0xff);\nconst vec3 darkb = vec3(0x00, 0x20, 0x59) / float(0xff);\nconst vec3 redd = vec3(0xe1, 0x46, 0x14) / float(0xff);\nconst vec3 green = vec3(0x00, 0x66, 0x33) / float(0xff);\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel0, ipx, 0);\n}\n\nvec4 loadval2(ivec2 ipx) {\n    return texelFetch(iChannel1, ipx, 0);\n}\n\n#if AA>1\nbool once_AAlgs = false;\nbool once_AAlgs2 = false;\nvec4 retv_AAlgs = vec4(0.);\nvec4 retv_AAlgs2 = vec4(0.);\n\nvec4 lgs() {\n    if (!once_AAlgs)retv_AAlgs = loadval2(ivec2(0., 0.));\n    once_AAlgs = true;\n    return retv_AAlgs;\n}\n\nvec4 lgs2() {\n    if (!once_AAlgs2)retv_AAlgs2 = loadval2(ivec2(0., 1.));\n    once_AAlgs2 = true;\n    return retv_AAlgs2;\n}\n#else\n\nvec4 lgs() {\n    return loadval2(ivec2(0., 0.));\n}\n\nvec4 lgs2() {\n    return loadval2(ivec2(0., 1.));\n}\n#endif\n\nint gai() {\n#if AI > 0\n    return AI;\n#endif\n    return int((iResolution.x * iResolution.y) / 3.);\n}\n\nfloat block(vec2 p, float z) {\n    float d = 0.;\n    p *= z;\n    float zv = zv*z;\n    d = max(d, SS(zv, -zv, sdBox(p, vec2(0.25)) - 0.05));\n    float td = SS(zv, -zv, (sdBox(p, vec2(0.3))) - 0.15);\n    td *= 1. - SS(zv, -zv, (sdBox(p, vec2(0.3))) - 0.075);\n    d = max(d, td);\n    return d;\n}\n\nint maptmp(int id, int midg);\n\nfloat board_box(vec2 p, vec2 bpp, float bsz, int midg) {\n    float d = 0.;\n    p += bpp;\n    if (any(lessThanEqual(p, vec2(0.))) || any(greaterThanEqual(p, bsz * vec2(msize - ivec2(0, 2))))) return d;\n    int mid = int(floor((p.y) / bsz) * float(msize.x) + floor((p.x) / bsz));\n    p = mod(p, bsz) - bsz / 2.;\n    d = block(p, 25.);\n    float mv = 1.;\n    if (d > 0.)if (maptmp(mid, midg) == 0)mv = 0.05;\n    d *= mv;\n    return d;\n}\n\nfloat block_z(vec2 p, float z) {\n    float d = 0.;\n    p *= z;\n    float zv = zv * z * 5.; //*5 for small resolution\n    d = max(d, SS(zv, -zv, sdBox(p, vec2(0.4))));\n    return d;\n}\n\nfloat board_box_vz(vec2 p, vec2 bpp, float bsz, float z, int midg) {\n    float d = 0.;\n    p += bpp;\n    if (any(lessThanEqual(p, vec2(0.))) || any(greaterThanEqual(p, bsz * vec2(msize - ivec2(0, 2))))) return d;\n    int mid = int(floor((p.y) / bsz) * float(msize.x) + floor((p.x) / bsz));\n    p = mod(p, bsz) - bsz / 2.;\n    d = block_z(p, z + 25.);\n    float mv = 1.;\n    if (d > 0.)if (maptmp(mid, midg) == 0)mv = 0.05;\n    d *= mv;\n    return d;\n}\n\nivec3 logicw = ivec3(0);\nbool is_end = false;\nvoid loadlogic(int midg);\nivec4 loadat(int id, int midg);\n\nfloat lines(vec2 p, vec2 bpp, float bsz, float z, int idx, bool xx) {\n    float d = 0.;\n    vec2 bszx = bsz * vec2(msize);\n    p += bpp - bszx / 2.;\n    d = max(d, SS(zv*z, -zv*z, abs(sdBox(p, bszx / 2.) - 0.01) - 0.002));\n    if (xx)if (idx == int(lgs2().x) + 1) d = max(d, 0.25 * SS(zv * z, -zv * z, (sdBox(p, bszx / 2.) - 0.01) - 0.002));\n    if (p.y > 0.35)d = max(d, float(PrintInt((p + vec2(0.197, -0.36)) * vec2(25., 12.), idx, 6)));\n    if (p.y > 0.35) {\n        loadlogic(idx);\n        d = max(d, 0.5 * float(PrintInt((p + vec2(-0.046, -0.385)) * vec2(25., 20.),\n                (logicw.y << 8) + logicw.z, 4)));\n    }\n    return d;\n}\n\nvec4 main_c(vec2 p) {\n    vec3 col = white;\n    if ((abs(p.x) > .862)&&(abs(p.x) < 0.9))\n        col = mix(whitel * 0.9, dark, 0.5 *\n            step(abs(p.y + clamp((p.x < 0. ? (-0.5 + 7. * lgs().z / float(gai()))*01. : (-0.5 + 7. * lgs().w / float(gai()))*01.), -.5, .5)), 0.05));\n    float d = 0.;\n    float bsz = 1. / 25.; //block size\n    vec2 bpp = vec2((bsz * 10.) / 2., 0.45); //board pos\n    // mid table\n    if (abs(p.x) <= bpp.x + 0.02) {\n        int mid = int(lgs2().x);\n        d = lines(p, bpp, bsz, 1., mid + 1, false);\n        col = mix(col, darkb, d);\n        d = board_box(p, bpp, bsz, mid);\n        col = mix(col, dark, d);\n        d = 0.7 * step(0.46, p.y) * step(0.1, p.x) * step(p.x, 0.2);\n        col = mix(col, redd, d);\n        d = step(0.42, p.y) * step(abs(p.x + 0.05), 0.15);\n        if (d > 0.)\n            col = mix(col, redd.rrb, 0.65 * float(PrintInt((p + vec2(0.197, -0.445)) * vec2(25., 20.),\n                int(gai()), 6)));\n    } else {\n        //tiles on sides\n        float zo = 5.;\n        vec2 msize = vec2(msize);\n        //this is bad, and I wont rewrite it xD (instead of use szt to divide (uv) I divide it on msize..idk why)\n        //it was late night\n        if (((abs(p.x) >= 0.5 * (msize.x / msize.y) / zo + 2. * (msize.x / msize.y) / zo))&&\n                ((abs(p.x) <= 0.5 * (msize.x / msize.y) / zo + 9. * (msize.x / msize.y) / zo))) {\n            // [7,5] size\n            vec2 szt = vec2(7., 5.);\n            bool pl = p.x < 0.;\n            p *= zo;\n            vec2 vt = vec2(float(msize.x) / float(msize.y), 1.);\n            p += vt / 2.;\n            float tv = pl ? (lgs().z) : (lgs().w);\n            p.y += (mod(tv, szt.y)); //protection from float precision\n\n            //...this number come because I use msize to divide uv and szt as tables/screen...weird\n            vec2 rt = vec2(1.815, 1.2);\n\n            int mid = int(floor((p.y + rt.y * zo / 2.) / vt.y - 1.) * szt.x + floor(mod((p.x + rt.x * zo / 2.) / vt.x, 12.) - 1.));\n\n            //protection from float precision(2)\n            mid += int((tv < 0. ? -(5. - tv) : tv) / 5.) * int(szt.y * szt.x); //this has bug if tv close to -0.0....low\n            p = mod(p, vt) - vt / 2.;\n            if ((mid >= 0)&&(mid < gai())) {\n                d = lines(p, bpp, bsz, zo, mid + 1, true);\n                col = mix(col, (is_end?green:redd* 0.7 ), d);\n\n                d = board_box_vz(p, bpp, bsz, zo, mid);\n                col = mix(col, dark, d);\n            }\n        }\n    }\n\n    return vec4(col, d);\n}\n\nfloat zoom_calc(float zx) {\n    float ex = (1. * zx) / (iResolution.y);\n    return ex;\n}\n\n#if AA>1\nbool once_AA = false; //dont unpack again if AA enabled\nint retv_AA = 0;\nint maptmpAA(int id, int midg);\n\nint maptmp(int id, int midg) {\n    if (!once_AA)retv_AA = maptmpAA(id, midg);\n    once_AA = true;\n    return retv_AA;\n}\n#endif\n\nivec4 loadat(int id, int midg) {\n    int itt = (id / 24) / 4; //data pixel id 0-2\n    int midy = (3 * midg) / int(iResolution.x);\n    int midx = (midg * 3 - (midy) * int(iResolution.x));\n    midx += itt;\n    if (midx >= int(iResolution.x)) {\n        midx = midx - int(iResolution.x);\n        midy += 1;\n    } //fix for screen edges\n    return ivec4(loadval(ivec2(midx, midy)));\n}\n\n#if AA>1\nbool once_AA_l = false;\n#endif\n\nvoid loadlogic(int midg) {\n#if AA>1\n    if (once_AA_l)return;\n    once_AA_l = true;\n#endif\n    ivec2 tpx = loadat(2 * 96, midg - 1).zw; // -1 because in func line +1\n    logicw = decodeval16(tpx[1]);\n    if(tpx.x<0)is_end=true;\n}\n\n\n//unpack bits (optimized no loops) load only needed bit\n#if AA>1\n\nint maptmpAA(int id, int midg) {\n#else\n\nint maptmp(int id, int midg) {\n#endif\n    int nBits = 8;\n    ivec4 pixeldata = loadat(id, midg);\n    int itt = (id / 24) / 4; //data pixel id 0-2\n    int jtt = (id - itt * 24 * 4) / 24; //component in data pizel id 0-3\n    int ott = (id - itt * 24 * 4 - jtt * 24) / 8; //component in unpacked value 0-2\n    int ttt = (id - itt * 24 * 4 - jtt * 24 - ott * 8); //bit after int2bit 0-7\n    ivec3 val = decodeval16(pixeldata[jtt]);\n    int n = val[ott];\n    for (int i = 0; i < nBits; ++i, n /= 2) {\n        if (i == ttt) {\n            if ((n % 2) == 0)return 0;\n            else return 1;\n            //switch + return does not work on windows(Angle)\n            /*switch (n % 2) {\n               case 0:return 0;break;\n               case 1:return 1;break;\n            }*/\n        }\n    }\n    return 0;\n}\n\nvoid init_globals(vec2 fragCoord) {\n    zv = zoom_calc(1.);\n    ipx = ivec2(fragCoord - 0.5);\n    res_g = res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord.xy) / iResolution.y - res / 2.0;\n\n    init_globals(fragCoord);\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for (int mx = 0 + alp; mx < AA; mx++)\n        for (int nx = 0 +alp ; nx < AA; nx++) {\n            vec2 o = vec2(float(mx), float(nx)) / float(AA) - 0.5;\n            uv = (fragCoord.xy + o) / iResolution.y - res / 2.0;\n#endif\n\n            vec3 col = main_c(uv).rgb;\n\n            tot += col;\n#if AA>1\n        }\n    tot /= float(AA * AA);\n#endif\n    float vignetteAmt = 1. - dot(uv * 0.65, uv * 0.65);\n    tot *= vignetteAmt;\n    tot = tot / 2. + tot*tot;\n    tot += (rand(uv) - .5)*.07;\n    //tot=sqrt(tot);\n    fragColor = vec4(clamp(tot, vec3(0.), vec3(1.)), 1.0);\n\n    //fragColor=texture(iChannel0,fragCoord/iResolution.xy)/float(0xffffff);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Danil (2019+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// logic (bit display)\n\n// data\n\n// tetris board need 10*22=220 bits to store data(1/0 block free/non)\n// 1 pixel can store 24*4=96bits\n// to save full board used\n// 2*96(two pixels) + 24(1 component of third pixel)+4( four bits second component third pixel)\n\n// [pixel 1] [pixel 2] [x (24bit), 4 bit of y, z unused, w unused,]\n// AI logic saved in unused blocks\n\n\n// unused blocks [pixel3].zw (3 values in each compoinent)\n\n// z used for player board and AI\n// z [a,b,c] a = position of current block(as id in map array)\n// b = time to live left for block animation(move down animation) (time to live in frames)\n// c = ID of current block (0=random new)\n\n// w [a,b,c]  a = action(look define actions)\n// [b,c] (0xffff) = score, and sign(+- of whole pixel) for game over for this board\n\n// logic\n// on the \"every 3-rd pixel\" and \"data\" pixels execute saved action\n\nivec2 ipx;\n\n//no unrol loops, disabled it make shader work much slower and comile same slow\n//#define alp min(0, iFrame)\n#define alp 0\n\nint bits2Int(int start);\nvoid rotate_la(inout int el_ID);\n\nint gai() {\n#if AI > 0\n    return AI;\n#endif\n    return int((iResolution.x * iResolution.y)) / 3;\n}\n\nint index_idx() {\n    return (ipx.y * int(iResolution.x) + ipx.x) / 3;\n}\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel0, ipx, 0);\n}\n\nvec4 loadval2(ivec2 ipx) {\n    return texelFetch(iChannel1, ipx, 0);\n}\n\nvec4 lgs2() {\n    return loadval2(ivec2(0., 1.));\n}\n\nvec4 lll() {\n    return loadval2(ivec2(iResolution.xy - 1.));\n}\n\nvoid init_globals(vec2 fragCoord) {\n    ipx = ivec2(fragCoord - 0.5);\n}\n\n//save state\nvec4 save_map() {\n    int exidx = index_idx();\n#ifdef debug\n    //show that pixels on \"screen edge\" is okey (where pixel line go to next line on heigh)\n    if (exidx >= int(iResolution.x) / 3)if (((exidx) % (int(iResolution.x) / 3)) == 0)return vec4(0xffffff);\n#endif\n    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;\n    vec4 retc = vec4(0.);\n    for (int i = 0 + alp; i < 4; i++) {\n        ivec3 packme = ivec3(bits2Int(imidx * 4 * 24 + i * 24), bits2Int(imidx * 4 * 24 + i * 24 + 8), bits2Int(imidx * 4 * 24 + i * 24 + 16));\n        retc[i] = float(encodeval16(packme));\n    }\n    return retc;\n}\n\n//logic pixels\nivec3 logicz = ivec3(0);\nivec3 logicw = ivec3(0);\nbool is_end = false;\nbool is_end_lg = false;\n\nvoid save_logic(inout vec4 fragColor) {\n    int exidx = index_idx();\n    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;\n    if (imidx != 2)return;\n    fragColor.zw = vec2(encodeval16(logicz), encodeval16(logicw));\n    if(is_end||is_end_lg)fragColor.z=-100.;\n}\n\n//load map[array] on init(first frame or reset\nvoid init_tablepx(out vec4 fragColor) {\n    fragColor=vec4(0.);\n    if (index_idx() >= gai()) {\n        fragColor = vec4(0.);\n        return;\n    }\n    fragColor = save_map();\n    save_logic(fragColor);\n}\n\n// only data logic\n//-----------------------------\n\n//same as in Image\nivec4 loadat(int itt, int midg) {\n    int midy = (3 * midg) / int(iResolution.x);\n    int midx = (midg * 3 - (midy) * int(iResolution.x));\n    midx += itt;\n    if (midx >= int(iResolution.x)) {\n        midx = midx - int(iResolution.x);\n        midy += 1;\n    }\n    return ivec4(loadval(ivec2(midx, midy)));\n}\n\nvoid loadlogic() {\n    int midg = index_idx();\n    ivec2 tpx = loadat(2, midg).zw;\n    logicz = decodeval16(tpx[0]);\n    logicw = decodeval16(tpx[1]);\n    if(tpx.x<0)is_end=true;\n}\n\n// little optimized\nvoid load_mapbits() {\n    int exidx = index_idx();\n    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;\n    // load only single pixel(96bits) for data logic, and full map for player(AI) logic(every 3-rd pixel)\n    // load 2 pixels if action afc_e (burn lines)\n    int iml = 1;\n    if(logicw[0]==afc_e)iml=2;\n#ifndef debug\n    if (imidx == 2) {\n        iml = 3;\n        imidx = 0;\n    }\n#endif\n    for (int jji = 0 + alp; jji < iml; jji++) {\n        int nBits = 8;\n        ivec4 pixeldata = loadat(imidx, exidx);\n        vec4 unppixeldata[3];\n        vec3 val1 = vec3(decodeval16(pixeldata[0]));\n        vec3 val2 = vec3(decodeval16(pixeldata[1]));\n        vec3 val3 = vec3(decodeval16(pixeldata[2]));\n        vec3 val4 = vec3(decodeval16(pixeldata[3]));\n        unppixeldata[0] = vec4(val1, val2.x);\n        unppixeldata[1] = vec4(val2.yz, val3.xy);\n        unppixeldata[2] = vec4(val3.z, val4);\n        int gidx = 96 * imidx;\n        for (int ii = 0 + alp; ii < 3; ii++)\n            for (int jj = 0 + alp; jj < 4; jj++) {\n                int n = int(unppixeldata[ii][jj]);\n#ifndef debug\n                if (n == 0) {gidx += 8;continue;} //work only on free map array\n#endif\n                for (int i = 0 + alp; i < nBits; ++i, n /= 2) {\n                    if (gidx >= msize.x * msize.y)break;\n                    switch (n % 2) {\n                        case 0:set_map_global(gidx, 0);break;\n                        case 1:set_map_global(gidx, 1);break;\n                    }\n                    gidx++;\n                }\n            }\n        imidx++;\n    }\n}\n//-----------------------------\n\n\nvoid debug_draw() {\n    //exidx is bord id, you can debug draw anything to any board for debug\n    //set map[index]=0 or 1;\n    int exidx = index_idx();\n    //debug draw, anim bits\n    //frame\n    int imid = int(mod(float(iFrame) / 3. + float(exidx), float(msize.x * msize.y)));\n    //time\n    //int imid=int(mod(iTime*10.+mod(float(exidx),float(msize.x*msize.y)),float(msize.x*msize.y)));\n    set_map_global(imid, 1);\n    imid = imid - 3 >= 0 ? imid - 3 : msize.x * msize.y + (imid - 3);\n    set_map_global(imid, 0);\n    // look save_map() function also\n}\n\n\n// rest is player/AI logic\n//-----------------------------\n\nint block_it[bsize*bsize];\n\nvoid block_byid(int id){\n    switch (id) {\n        case 0:block_it=block_I0;break;\n        case 1:block_it=block_I1;break;\n        case 2:block_it=block_T0;break;\n        case 3:block_it=block_T1;break;\n        case 4:block_it=block_T2;break;\n        case 5:block_it=block_T3;break;\n        case 6:block_it=block_L0;break;\n        case 7:block_it=block_L1;break;\n        case 8:block_it=block_L2;break;\n        case 9:block_it=block_L3;break;\n        case 10:block_it=block_Lr0;break;\n        case 11:block_it=block_Lr1;break;\n        case 12:block_it=block_Lr2;break;\n        case 13:block_it=block_Lr3;break;\n        case 14:block_it=block_O0;break;\n        case 15:block_it=block_Z0;break;\n        case 16:block_it=block_Z1;break;\n        case 17:block_it=block_Zr0;break;\n        case 18:block_it=block_Zr1;break;\n    }\n}\n\nvoid draw_block_at(int el_pos, int el_ID) {\n    block_byid(el_ID);\n    int gid = el_pos;\n    for (int i = 0 + alp; i < b_sizes[el_ID][1]; i++) {\n        for (int j = 0 + alp; j < b_sizes[el_ID][0]; j++) {\n            if ((gid >= msize.x * msize.y) || (gid < 0))break;\n            if (block_it[i * bsize + j] == 1)set_map_global(gid, 1);\n            gid++;\n        }\n        gid += 10 - b_sizes[el_ID][0];\n    }\n}\n\n//same as draw\nvoid delete_block_at(int el_pos, int el_ID) {\n    block_byid(el_ID);\n    int gid = el_pos;\n    for (int i = 0 + alp; i < b_sizes[el_ID][1]; i++) {\n        for (int j = 0 + alp; j < b_sizes[el_ID][0]; j++) {\n            if ((gid >= msize.x * msize.y) || (gid < 0))break;\n            if (block_it[i * bsize + j] == 1)set_map_global(gid, 0);\n            gid++;\n        }\n        gid += 10 - b_sizes[el_ID][0];\n    }\n}\n\n//check for free blocks\nbool check_block_at(int el_pos, int el_ID) {\n    if(el_pos-(el_pos/10)*10>10-b_sizes[el_ID][0])return false;\n    if (el_pos < 0)return false;\n    block_byid(el_ID);\n    int gid = el_pos;\n    for (int i = 0 + alp; i < b_sizes[el_ID][1]; i++) {\n        for (int j = 0 + alp; j < b_sizes[el_ID][0]; j++) {\n            if (gid >= msize.x * msize.y)break;\n            if ((block_it[i * bsize + j] == 1)&&(get_map_global(gid) == 1))return false;\n            gid++;\n        }\n        gid += 10 - b_sizes[el_ID][0];\n    }\n    return true;\n}\n\nvoid delete_line_at(int el_pos) {\n    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;\n    int gidx = 96 * imidx;\n    for (int i = el_pos + alp; i < gidx+96; i++) {\n        if(i>=msize.x*msize.y)break; //OpenGL bug, without this rule score(el_sc) of board ruined\n        set_map_global(i, (i+10<msize.x*msize.y)?get_map_global(i+10):0);\n    }\n}\n\nint apply_move(int el_pos, int el_act, inout int el_ID);\n\nvoid data_action() {\n    int exidx = index_idx();\n    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;\n\n    //save modified values if this is logic pixel imidx==2\n    ivec3 logicz_l = logicz;\n    ivec3 logicw_l = logicw;\n    if (imidx == 2)loadlogic();\n\n    int el_pos = logicz[0];\n    int el_ID = logicz[2];\n    int el_act = logicw[0];\n    if ((el_act == draw) || (el_act == down_e) || (el_act == left_e) || (el_act == right_e) || (el_act == rotate_e)) {\n        delete_block_at(el_pos, el_ID);\n        el_pos = apply_move(el_pos, el_act, el_ID);\n        draw_block_at(el_pos, el_ID);\n    }\n    if (el_act == afc_e) {\n        delete_line_at(el_pos);\n    }\n    //return saved logic values\n    logicz = logicz_l;\n    logicw = logicw_l;\n}\n\nvoid save_ltmp(int el_pos, int el_ttl, int el_ID, int el_act, int el_sc) {\n    //save result\n    logicz[0] = el_pos;\n    logicz[1] = el_ttl;\n    logicz[2] = el_ID;\n    logicw[0] = el_act;\n    logicw.yz = ivec2(el_sc >> 8, el_sc & 0xff);\n}\n\nvoid rotate_la(inout int el_ID);\n\n//check for block hit and apply action\nint ltoe_action(int el_pos, int el_act, int el_ID) {\n    delete_block_at(el_pos, el_ID);\n    if (el_act == down_l) {\n        int tact = afc;\n        if (el_pos - 10 >= 0)if (check_block_at(el_pos - 10, el_ID))tact = down_e;\n        return tact;\n    }\n    if (el_act == left_l) {\n        int tact = draw;\n        if ((el_pos - 1 >= 0)&&((el_pos - 1) / 10 == el_pos / 10))if (check_block_at(el_pos - 1, el_ID))tact = left_e;\n        return tact;\n    }\n    if (el_act == right_l) {\n        int tact = draw;\n        if ((el_pos + b_sizes[el_ID][0]) / 10 == (el_pos) / 10)if (check_block_at(el_pos + 1, el_ID))tact = right_e;\n        return tact;\n    }\n    if (el_act == rotate_l) {\n        int tact = draw;\n        rotate_la(el_ID);\n        if ((el_pos + b_sizes[el_ID][0] - 1) / 10 == (el_pos) / 10)if (check_block_at(el_pos, el_ID))tact = rotate_e;\n        return tact;\n    }\n    return draw;\n}\n\nint apply_move(int el_pos, int el_act, inout int el_ID) {\n    if (el_act == down_e) {\n        el_ID = el_ID;\n        el_pos = (el_pos - 10);\n        return el_pos;\n    }\n    if (el_act == left_e) {\n        el_ID = el_ID;\n        el_pos = (el_pos - 1);\n        return el_pos;\n    }\n    if (el_act == right_e) {\n        el_ID = el_ID;\n        el_pos = (el_pos + 1);\n        return el_pos;\n    }\n    if (el_act == rotate_e) {\n        rotate_la(el_ID);\n        el_pos = el_pos;\n        return el_pos;\n    }\n    return el_pos;\n}\n\n//burn lines\nint after_ac(inout int el_pos, int el_ID, inout int el_sc) {\n    for(int k=0 + alp;k<b_sizes[el_ID][1];k++){\n        int eval=(el_pos/10)*10+k*10;\n        if(eval>=msize.x*msize.y)return nac;\n        int gid=0;\n        for(int i=eval + alp;i<eval+10;i++){if(get_map_global(i)==0){break;}else gid++;};\n        if(gid==10){el_pos=eval;el_sc++;return afc_e;}\n    }\n    return nac;\n}\n\n// AI\n//-----------------------------\n\n// its imposible to code \"good tetris AI(bot)\" for GLSL\n// \"good bot\" need too many loops for calculate all scores for al rotations on full board\n// I tried... it(good AI) crash Nvidia driver at 10k bots, and very slow even on 100 bots(freez frame on calcultion)\n// and ~20 sec shader compile time\n\n// code better bot if you can, my bot is VERY bad\n\n\n// this is \"very bad bot\" it can burn ~30 lines then it dead\n// logic check only \"place block to have minimal height\" thats all\n\nint AI_pos_gen(inout int el_ID) {\n    int result_ID = el_ID;\n    int result_pos = 20 * 10 + 0;\n    \n    //get max height for every line\n    int maxh = 0;\n    int tval_h[msize.x] = int[](0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    for (int i = msize.y - 1 + alp; i >= 0; i--) {\n        for (int j = 0 + alp; j < msize.x; j++) {\n            if (!bool(tval_h[j]) && bool(get_map_global(i * msize.x + j))) {\n                tval_h[j] = i;\n                maxh = max(maxh, i);\n            }\n        }\n    }\n\n    int gtth = 999;\n    int bht = 999;\n    int start_id = el_ID;\n    const int exceptit[5] = int[](11, 12, 9, 8, 4); //list of better rotation for same height\n    for (int k = 0 + alp; k < 4; k++) {\n        for (int i = 0 + alp; i < msize.x - b_sizes[el_ID].x + 1; i++) {\n            int tmax = tval_h[i];\n            for (int lm = i + alp; (lm < i + b_sizes[el_ID].x)&&(lm < 10); lm++)tmax = max(tmax, tval_h[lm]);\n            for (int j = maxh + alp; j >= tmax; j--) {\n                if (check_block_at(j * 10 + i, el_ID)) {\n                    if ((j < bht) || ((j == bht)&&(b_sizes[el_ID].y < gtth))) {\n                        gtth = b_sizes[el_ID].y;\n                        bht = j;\n                        result_ID = el_ID;\n                        result_pos = 20 * 10 + i;\n                    } else if ((j == bht)&&(b_sizes[el_ID].y <= gtth)) {\n                        bool imv = false;\n                        if (b_sizes[el_ID].y == gtth)for (int op = 0; (op < 5)&&(!imv); op++)imv = exceptit[op] == el_ID;\n                        if (imv) {\n                            gtth = b_sizes[el_ID].y;\n                            bht = j;\n                            result_ID = el_ID;\n                            result_pos = 20 * 10 + i;\n                        }\n                    }\n                }\n            }\n        }\n        rotate_la(el_ID);\n        if (start_id == el_ID)break;\n    }\n\n    el_ID = result_ID;\n    return result_pos;\n}\n\n//-----------------------------\n\n//if any block(1) on 21 line then end\nvoid isend(int el_pos){\n    if(el_pos>17*10)for(int i=20*10 + alp;i<20*10+10;i++)if(get_map_global(i)==1){is_end_lg=true;return;};\n    is_end_lg=false;\n}\n\n// AI and player logic work by \"switching state per frame\" on logic values\nvoid player_AI_logic() {\n    int exidx = index_idx();\n    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;\n    if (imidx != 2)return;\n    bool is_player=false;\n    int el_pos = logicz[0]; //position in array\n    int el_ttl = logicz[1]; //timer\n    int el_ID = logicz[2]; //element id\n    int el_act = logicw[0]; //action\n    int el_sc = (logicw[1] << 8) + logicw[2]; //score\n    //el_sc++; //debug\n    \n#ifndef no_AI\n    is_player=(exidx == 0);\n    if ((is_player) && (lgs2().x != 0.))return; //check for pause if player board not selected\n#else\n    is_player=(exidx == int(lgs2().x));\n    if ((!is_player)&&(el_pos < 17 * 10)&&(el_act!=nac))return;\n#endif\n    \n    //spawn new block\n    if (el_act == nac) {\n        el_act = draw;\n        el_ID = int(float(barr - 1) * rand(vec2(ipx) + vec2(mod(iTime, float(0xffff)), mod(iTime, float(0xffff)) / 2.)));\n        //el_ID = exidx%(barr); //debug\n        el_ttl = is_player?speed:AIspeed;\n#ifdef no_AI\n        el_pos = 20 * 10 + 4;\n#else\n        el_pos = is_player?20 * 10 + 4:AI_pos_gen(el_ID);\n#endif\n        save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n        return;\n    }\n    \n    //check after block is down\n    if (el_act == afc) {\n        el_act = after_ac(el_pos, el_ID,el_sc);\n        isend(el_pos);\n        save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n        return;\n    }\n    \n    if (el_act == afc_e) {\n        el_act = afc;\n        save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n        return;\n    }\n    \n//move down on timer\n    el_ttl = (el_ttl - 1 > 0) ? el_ttl - 1 : 0;\n    \n    if(is_player){\n    //key press move\n    int tac = int(lgs2().z);\n    if ((tac != nac)&&(el_act == draw)) {\n        el_act = ltoe_action(el_pos, tac, el_ID);\n        save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n        return;\n    }\n    if ((el_act == down_e) || (el_act == left_e) || (el_act == right_e) || (el_act == rotate_e)) {\n        el_pos = apply_move(el_pos, el_act, el_ID);\n        if (el_act == down_e)el_ttl = is_player?speed:AIspeed;\n        el_act = draw;\n        save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n        return;\n    }\n    }\n\n    \n    if (el_ttl == 0) {\n        if (el_act == draw) {\n            el_act = ltoe_action(el_pos, down_l, el_ID);\n            save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n            return;\n        }\n        if (el_act == down_e) {\n            el_pos = apply_move(el_pos, el_act, el_ID);\n            el_act = draw;\n            el_ttl = is_player?speed:AIspeed;\n            save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n            return;\n        }\n    }\n    save_ltmp(el_pos, el_ttl, el_ID, el_act, el_sc);\n}\n//-----------------------------\n\nvoid table_worker(out vec4 fragColor) {\n    fragColor = vec4(0.);\n    loadlogic();\n    if(is_end){fragColor = loadval(ipx);return;}\n    load_mapbits();\n#ifdef debug\n    debug_draw();\n#else\n    player_AI_logic();\n    data_action();\n#endif\n    fragColor = save_map();\n    save_logic(fragColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.);\n    init_globals(fragCoord);\n    if (lll().x >= 0.) {\n        init_tablepx(fragColor);\n        return;\n    }\n    if (index_idx() < gai()) {\n        table_worker(fragColor);\n        return;\n    }\n}\n\n//convert bits to int\nint bits2Int(int start){\n    int ret = 0;\n    int nBits=8;\n    int ncv = 1;\n    start+=7;\n    for(int i=nBits-1+alp; i>=0; i--){\n        int eval=0;\n        if(start-i<msize.x*msize.y)eval=get_map_global(start-i);\n        if(eval == 1)\n            ret+=ncv;\n        ncv *= 2;\n    }\n    return ret;\n}\n\n//rotate ID switch\nvoid rotate_la(inout int el_ID){\n        switch (el_ID) {\n        case 0:el_ID=1;break;\n        case 1:el_ID=0;break;\n        case 2:el_ID=3;break;\n        case 3:el_ID=4;break;\n        case 4:el_ID=5;break;\n        case 5:el_ID=2;break;\n        case 6:el_ID=7;break;\n        case 7:el_ID=8;break;\n        case 8:el_ID=9;break;\n        case 9:el_ID=6;break;\n        case 10:el_ID=11;break;\n        case 11:el_ID=12;break;\n        case 12:el_ID=13;break;\n        case 13:el_ID=10;break;\n        case 14:el_ID=14;break;\n        case 15:el_ID=16;break;\n        case 16:el_ID=15;break;\n        case 17:el_ID=18;break;\n        case 18:el_ID=17;break;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by Danil (2019+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// UI control\n\n// pixel [iRes.x,iRes.y] (right top) \"is it launched\" and resolution change\n\n// [0,0] scroll board by mouse\n// x, y buffer for scroll\n// z, w Mouse.y for left and right side\n\n// [0,1]\n// x ID for main table on screen\n// y control click once\n// z action(key press)\n\n\n#define res (iResolution.xy / iResolution.y)\n\nivec2 ipx;\nvec2 res_g;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_SPACE = 32;\n\nbool key_press(int key) {\n    return texelFetch(iChannel3, ivec2(key, 1), 0).x != 0.;\n}\n\nbool key_state(int key) {\n    return texelFetch(iChannel3, ivec2(key, 0), 0).x != 0.;\n}\n\nint key_control() {\n    if (key_press(KEY_LEFT)) {\n        return left_l;\n    }\n    if (key_press(KEY_RIGHT)) {\n        return right_l;\n    }\n    if (key_press(KEY_UP)) {\n        return rotate_l;\n    }\n    if (key_state(KEY_DOWN)) {\n        return down_l;\n    }\n    return nac;\n}\n\nint gai() {\n    ivec2 szt = ivec2(7, 5);\n#if AI > 0\n    return AI / szt.x;\n#endif\n    return int((iResolution.x * iResolution.y) / 3.) / szt.x;\n}\n\nint gaio() {\n#if AI > 0\n    return AI;\n#endif\n    return int((iResolution.x * iResolution.y) / 3.);\n}\n\nvec4 loadval(ivec2 ipx) {\n    return texelFetch(iChannel1, ipx, 0);\n}\n\nvec4 lll() {\n    return loadval(ivec2(iResolution.xy - 1.));\n}\n\nvec4 lgs() {\n    return loadval(ivec2(0., 0.));\n}\n\nint index_idx(ivec2 p) {\n    return (p.y * int(iResolution.x) + p.x) / 3;\n}\n\nvoid init_globals(vec2 fragCoord) {\n    ipx = ivec2(fragCoord - 0.5);\n    res_g = res;\n}\n\nvec4 init_global_st() {\n    return vec4(0., 0., -3.0, float(2 + gai()));\n}\n\nvec2 postmove(vec2 mzw) {\n    for (int i = 0; i < 2; i++) {\n        // 0.0001 to fix some bug(maybe because float precision) (look line 215 in Image)\n        //mzw[i]=mzw[i]<0.?mzw[i]-(mzw[i])/5.:mzw[i]; //test bug, left side of board blink after ~6-7 sec\n        mzw[i] = mzw[i] < 0. - 1. ? mzw[i]-(mzw[i] + 1.) / 20. + 0.0001 : mzw[i]; //comment this for test bug\n        mzw[i] = (mzw[i]>float(gai())*0.2 * 5. - 2.) ? mzw[i]-(mzw[i] - float(gai())*0.2 * 5. + 2.) / 20. - 0.0001 : mzw[i];\n    }\n    return mzw;\n}\n\nvoid global_st(out vec4 fragColor) {\n    vec4 retc = loadval(ipx);\n    if (lll().x >= 0.) {\n        fragColor = init_global_st();\n        return;\n    }\n\n    if (iMouse.z > 0.) {\n        vec2 im = abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n        if (retc.xy == vec2(0.)) {\n            if (iMouse.z > iResolution.x / 2.)retc.y = retc.w;\n            else retc.x = retc.z;\n        }\n        vec2 ima = (iMouse.xy) / iResolution.y - res_g / 2.0;\n        float bsz = 1. / 25.;\n        if ((abs(im.x) > bsz * 5. + 0.02)&&(abs(im.x) < .862)) {\n            if (im.x > 0.)retc.w = ((0.5 - ima.y)-(0.5 - im.y))*5. + retc.y;\n            else retc.z = ((0.5 - ima.y)-(0.5 - im.y))*5. + retc.x;\n        }\n        if (im.x > 0.)retc.z = postmove(retc.zw).x;\n        else retc.w = postmove(retc.zw).y;\n        if (!((abs(im.x) > bsz * 5. + 0.02)&&(abs(im.x) < .862))) {\n            if ((abs(im.x) > .862)&&(abs(im.x) < 0.9)) {\n                if (im.x > 0.)retc.w = (0.5 - ima.y)*(float(gaio()) / 7.);\n                else retc.z = (0.5 - ima.y)*(float(gaio()) / 7.);\n            } else retc.zw = postmove(retc.zw);\n\n        }\n    } else {\n        retc.xy = vec2(0.);\n        retc.zw = postmove(retc.zw);\n    }\n    fragColor = retc;\n}\n\nvoid map_id(out vec4 fragColor) {\n    vec4 retc = loadval(ipx);\n    if (lll().x >= 0.) {\n        fragColor = vec4(0.);\n        return;\n    }\n    if (retc.y < 0.)\n        if (iMouse.z > 0.) {\n            //copy of main_c in image\n            vec2 p = abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n            float bsz = 1. / 25.;\n            vec2 bpp = vec2((bsz * 10.) / 2., 0.45);\n            if (abs(p.x) <= bpp.x + 0.02) {\n\n            } else {\n                float zo = 5.;\n                vec2 msize = vec2(msize);\n                if (((abs(p.x) >= 0.5 * (msize.x / msize.y) / zo + 2. * (msize.x / msize.y) / zo))&&\n                        ((abs(p.x) <= 0.5 * (msize.x / msize.y) / zo + 9. * (msize.x / msize.y) / zo))) {\n                    vec2 szt = vec2(7., 5.);\n                    bool pl = p.x < 0.;\n                    p *= zo;\n                    vec2 vt = vec2(float(msize.x) / float(msize.y), 1.);\n                    p += vt / 2.;\n                    float tv = pl ? (lgs().z) : (lgs().w);\n                    p.y += (mod(tv, szt.y));\n                    vec2 rt = vec2(1.815, 1.2);\n                    int mid = int(floor((p.y + rt.y * zo / 2.) / vt.y - 1.) * szt.x + floor(mod((p.x + rt.x * zo / 2.) / vt.x, 12.) - 1.));\n                    mid += int((tv < 0. ? -(5. - tv) : tv) / 5.) * int(szt.y * szt.x);\n                    p = mod(p, vt) - vt / 2.;\n                    if ((mid >= 0)&&(mid < gaio())) {\n                        retc.x = float(mid);\n                    }\n                }\n            }\n\n        }\n    retc.y = iMouse.z > 0. ? 1. : -1.;\n    retc.z = float(key_control());\n    fragColor = retc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy) / iResolution.y - res / 2.0;\n    fragColor = vec4(0.);\n    init_globals(fragCoord);\n    if (ipx == ivec2(iResolution.xy - 1.)) {\n        //reset\n        if (iMouse.z > 0.) {\n            vec2 im = abs(iMouse.zw) / iResolution.y - res_g / 2.0;\n            if (step(0.46, im.y) * step(0.1, im.x) * step(im.x, 0.2) > 0.) {\n                fragColor += 1.;\n                return;\n            }\n        }\n        fragColor += -1.;\n        return;\n    }\n    if (ipx == ivec2(0., 0.)) {\n        global_st(fragColor);\n        return;\n    }\n    if (ipx == ivec2(0., 1.)) {\n        map_id(fragColor);\n        return;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//delete define no_AI to have AI boards, Angle comile time ~20+sec\n//OpenGL compile time ~6sec\n#define no_AI\n\n//set number of launched AI bots, set 0 for max (debug use its also)\n#define AI 199\n\n\n// 2022 update uint map\n//#define use_uint_map\n\n\n//define debug for debug draw\n//#define debug\n\n//debug for tetris block drop on line 479 BufA\n\n//speed of faling blocks for player and AI, speed in frames (255 max)\n#define speed 35\n#define AIspeed 5\n\n\nconst ivec2 msize=ivec2(10,22);\n\n//actions\n// _l logic actions\n// _e action to execute\n#define nac 0\n#define left_l 1\n#define right_l 2\n#define down_l 3\n#define rotate_l 4\n#define left_e 11\n#define right_e 12\n#define down_e 13\n#define rotate_e 14\n#define draw 100\n#define afc 200\n#define afc_e 201\n\n#ifndef use_uint_map\n#ifndef debug\nint map[msize.x*msize.y]=int[](\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0\n);\n#else\n//debug map to see its loaded and work correct\nint map[msize.x*msize.y]=int[](\n    0,0,1,0,0,0,1,0,0,0,\n    0,0,1,0,0,0,1,0,0,0,\n    0,0,1,0,0,0,1,0,0,0,\n    1,0,1,0,0,0,1,1,1,0,\n    0,1,1,0,0,0,0,0,1,0,\n    0,0,1,0,0,1,1,1,1,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,1,0,1,0,0,0,\n    0,0,0,1,0,1,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0,\n    1,1,1,1,1,1,1,1,1,1,\n    0,0,0,0,0,0,0,0,0,0\n);\n#endif\nint get_map_global(int idx){return map[idx];}\nvoid set_map_global(int idx, int val){map[idx]=val;}\n\n#else\n// 2022 update - uint map\n\n#ifndef debug\nuint map[7]=uint[](0u,0u,0u,0u,0u,0u,0u);\n#else\nuint map[7]=uint[](0x22088222u, 0x8E6089E0u, 0u, 0u, 0x3FF00028u, 0x14000FFCu, 0x00FFC000u);\n#endif\n\n\n// index 0-3\nuint getByteFromUint(uint number, uint index)\n{\n    return (number >> (index << 3u)) & 0xFFu;\n}\n\n// index 0-7\nuint getBitFromByte(uint byte, uint index)\n{\n    return ((byte >> index) & 1u);\n}\n\n// idx = 0-31\nuint setBitUint(uint val, int bit, int idx){\n    if(bool(bit)) val |= 1u<<idx;\n    else val &= ~(1u<<uint(idx));\n    return val;\n}\n\nint get_map_global(int idx){\n    uint val=map[idx/32];\n    idx=(31-(idx%32));\n    uint tv = getBitFromByte(getByteFromUint(val,uint((idx%32)/8)),uint((idx%32)%8));\n    return int(tv);\n}\nvoid set_map_global(int idx, int val){\n    map[idx/32]=setBitUint(map[idx/32], val, 31-(idx%32));\n    return;\n}\n\n#endif\n\n\n// 0xff max\nivec3 decodeval16(int varz) {\n    ivec3 iret=ivec3(0);\n    iret.x=varz>>16;\n    iret.y=(varz>>8)&0xff;\n    iret.z=(varz>>0)&0xff;\n    return iret;\n}\n\n// &0xff just to make each val max 0xff\nint encodeval16(ivec3 colz) {\n    return int(((colz[0]&0xff)<<16)|((colz[1]&0xff)<< 8)|((colz[2]&0xff)<< 0));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst int bsize=4;\n\nconst int barr=19;\n\nconst ivec2 b_sizes[barr]=ivec2[](\n    ivec2(4,1),\n    ivec2(1,4),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(2,2),\n    ivec2(3,2),\n    ivec2(2,3),\n    ivec2(3,2),\n    ivec2(2,3)\n);\n\n//webgl GLSL does not suport arrays of arrays(can be packed as array[19] of vec4, and (0x1111>>4)&0xf)\n\nconst int block_I0[bsize*bsize]=int[](\n    1,1,1,1,\n\t0,0,0,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_I1[bsize*bsize]=int[](\n    1,0,0,0,\n\t1,0,0,0,\n\t1,0,0,0,\n\t1,0,0,0\n);\n\nconst int block_T0[bsize*bsize]=int[](\n    0,1,0,0,\n\t1,1,1,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_T1[bsize*bsize]=int[](\n    0,1,0,0,\n\t1,1,0,0,\n\t0,1,0,0,\n\t0,0,0,0\n);\n\nconst int block_T2[bsize*bsize]=int[](\n    1,1,1,0,\n\t0,1,0,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_T3[bsize*bsize]=int[](\n    1,0,0,0,\n\t1,1,0,0,\n\t1,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_L0[bsize*bsize]=int[](\n    0,0,1,0,\n\t1,1,1,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_L1[bsize*bsize]=int[](\n    1,0,0,0,\n\t1,0,0,0,\n\t1,1,0,0,\n\t0,0,0,0\n);\n\nconst int block_L2[bsize*bsize]=int[](\n    1,1,1,0,\n\t1,0,0,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_L3[bsize*bsize]=int[](\n    1,1,0,0,\n\t0,1,0,0,\n\t0,1,0,0,\n\t0,0,0,0\n);\n\nconst int block_Lr0[bsize*bsize]=int[](\n    1,0,0,0,\n\t1,1,1,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Lr1[bsize*bsize]=int[](\n    1,1,0,0,\n\t1,0,0,0,\n\t1,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Lr2[bsize*bsize]=int[](\n    1,1,1,0,\n\t0,0,1,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Lr3[bsize*bsize]=int[](\n    0,1,0,0,\n\t0,1,0,0,\n\t1,1,0,0,\n\t0,0,0,0\n);\n\nconst int block_O0[bsize*bsize]=int[](\n    1,1,0,0,\n\t1,1,0,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Z0[bsize*bsize]=int[](\n    1,1,0,0,\n\t0,1,1,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Z1[bsize*bsize]=int[](\n    0,1,0,0,\n\t1,1,0,0,\n\t1,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Zr0[bsize*bsize]=int[](\n    0,1,1,0,\n\t1,1,0,0,\n\t0,0,0,0,\n\t0,0,0,0\n);\n\nconst int block_Zr1[bsize*bsize]=int[](\n    1,0,0,0,\n\t1,1,0,0,\n\t0,1,0,0,\n\t0,0,0,0\n);\n\n//https://www.shadertoy.com/view/ldsyz4\n// The MIT License\n// Copyright 2017 Inigo Quilez\n// Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000, 100000, 1000000);\n\nint PrintInt( in vec2 uv, in int value, const int maxDigits )\n{\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);//(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n//using https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}