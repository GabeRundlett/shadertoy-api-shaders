{
    "Shader": {
        "info": {
            "date": "1542225790",
            "description": "Nipples remix",
            "flags": 0,
            "hasliked": 0,
            "id": "4tVfDR",
            "likes": 5,
            "name": "Raymarch anything 3 (nipple mix)",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "Del",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "// raymarch anything #3 (nipple mix) - Del 14/11/2018\n\n#define\tTAU 6.28318\nfloat objID = 0.0;\nfloat svobjID = 0.0;\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p)\n{\n    float time = iTime;\n    float modz = mod(time*6.75, 44.0);\n    float t2 = fract(time*1.1) * TAU;\n    float t3 = fract(time*0.7) * TAU;\n    float t4 = fract(time*0.14)* TAU;\n\n    p.xy *= rotate(p.z * 0.08 + t4);\n    \n    float m = 0.5+sin(t2+p.z*0.4)*0.5;\n    m += 0.5+cos(p.z*0.4+t3+p.x*0.4)*0.5;\n    \n\tp.z += modz;\n    pMod1(p.z,44.0);\n    \n\tfloat dist = 4.5 -abs(p.y)+m;\n    \n    vec3 p2 = p;\n\tfloat cz = pMod1(p2.z,4.0);\n\tfloat cx = pMod1(p2.x,4.0);\n\n    float r = hash(vec2(cz+(cz*0.31),cx+(cx*0.61)));\n    \n    if (r>0.875)\n    {\n\t\tfloat d2 = sdSphere(p2+vec3(0.0,4.0+m,0.0),0.4);\n\t\tfloat d3 = sdSphere(p2-vec3(0.0,4.0+m,0.0),0.4);\n        dist = smin(dist,d2,1.1);\n        dist = smin(dist,d3,1.1);\n    }\n\n    objID = abs(p.z)/44.0;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\nvec3 render(vec2 uv)\n{\n    float time = iTime;\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 80; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += .5 * d;\n\t}\n    \n    svobjID = objID;\n\tvec3 l = ro+vec3(0.0,0.0,15.0);\n\tvec3 n = normal(p);\n\tvec3 lp = normalize(l - p);\n\tfloat diff = 1.2 * max(dot(lp, n), 0.);\n    \n    vec3 c1 = vec3(2.84,2.0,1.45);\n    vec3 c2 = vec3(2.54,1.6,1.85);\n\treturn vec3(0.1)+mix(c1,c2,svobjID) * diff / (1. + t * t * .01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\t// vignette\n    col *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\tfragColor = vec4(col, 1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}