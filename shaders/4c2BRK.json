{
    "Shader": {
        "info": {
            "date": "1725205241",
            "description": "machine motion via heat transfer\n\nA little bit better.",
            "flags": 48,
            "hasliked": 0,
            "id": "4c2BRK",
            "likes": 8,
            "name": "SteamEngine3",
            "published": 3,
            "tags": [
                "steamenginesimulator"
            ],
            "usePreview": 1,
            "username": "kosalos",
            "viewed": 119
        },
        "renderpass": [
            {
                "code": "// -------------------------------------------\n// Press <Spc> to reset\n// -------------------------------------------\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,inout vec4 O,vec2 I) {\n    float d = ptLineDistance(I,p1,p2);\n    \n \n //   if(d < 160.) O.xyz += 1./(d * 0.3); // glow\n\n    if(d < width) {\n        float d2 = ptLineDistance(I - vec2(-width * 0.5,width * 0.5),p1,p2);\n        O.xyz = color - vec3(d2 / (width * 2.5));\n    }\n    if(abs(d - width)< 1.) O.xyz = vec3(0.);\n}\n\nvoid drawCircle(vec2 pt, float radius, vec3 color,inout vec4 O,vec2 I) {\n    float d = length(I-pt);\n    if(d < radius) {\n        float d2 = length(I - vec2(-radius * 0.3,radius * 0.3) - pt);\n        O.xyz = color - vec3(d2 / (radius * 3.5));\n    }\n    if(abs(d - radius)< 1.) O.xyz = vec3(0.);\n}\n\nvoid drawCircle2(vec2 pt, float radius, float thickness, vec3 color,inout vec4 O,vec2 I) {\n    float d = length(I-pt);\n    if(abs(d - radius) < thickness) O.xyz = vec3(0.); \n    if(abs(d - radius) < thickness*0.6) O.xyz = color;\n}\n\n// -------------------------------------------\n\nfloat gx,gy;\n\nvoid drawEngine(int offset,float piston,inout vec2 endPoint,inout vec4 O,vec2 U) {\n    float sbase = float(sc.x + offset) + piston+0.5;\n    vec2 p1 = vec2(sbase * gx,float(sc.y+10) * gy);\n    vec2 p2 = p1 + vec2(-28. * gx, 0.);\n    vec2 p2b = p2;\n    \n    // valve\n    int base = vc.x+offset+1 + int((MAX_PISTON-piston) * valveXscale) + valveXoffset; \n    vec2 p3 = vec2(float(base) * gx,float(vc.y+4) * gy);\n    vec2 p4 = p3 + vec2(-18. * gx, 0.);\n  \n    // piston, valve shafts and linkage\n    drawLine(p1,p2,3.,SHAFT_COLOR,O,U);\n    drawLine(p3,p4,3.,SHAFT_COLOR,O,U);\n    drawLine(p2,p4,3.,SHAFT_COLOR,O,U);\n    \n    // balls on valve,piston shafts\n    drawCircle(p2,15.,SHAFT_COLOR,O,U);\n    drawCircle(p4,15.,SHAFT_COLOR,O,U);\n  \n    // ball on pivot point of piston-valve linkage\n    vec2 p5 = vec2(float(sc.x + offset - 13)*gx,float(sc.y+28)*gy);\n    drawCircle(p5,25.,SHAFT_COLOR,O,U);\n\n    // piston\n    vec2 pp1 = vec2((sbase+1.) * gx,float(sc.y+2) * gy);\n    vec2 pp2 = vec2((sbase+1.) * gx,float(sc.y+19) * gy);\n    drawLine(pp1,pp2,10.,SHAFT_COLOR,O,U);\n    \n    // vertical connecting rods\n    vec2 verticalShaft = vec2(0.,-iResolution.y * 0.23);\n    vec2 p6 = p2 + verticalShaft;\n    drawLine(p2,p6,3.,SHAFT_COLOR,O,U);\n    drawCircle(p6,15.,SHAFT_COLOR,O,U);\n    \n    endPoint = p2 + verticalShaft;\n}\n\n// -------------------------------------------\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    vec2 U2 = U / iResolution.xy;  // 0 ... 1\n    ivec2 I = ivec2(int(float(GRIDX) * U2.x),int(float(GRIDY) * U2.y));\n\n    vec4 cell = fetchData(iChannel0,I);\n    if(cell.w == WALL) O.xyz = WALL_COLOR;\n    if(cell.w == PISTON) O.xyz = SHAFT_COLOR;\n    if(cell.w == STEAM) {\n        cell.y = cell.x / MAX_PRESSURE;  // steam pressure as 0...1\n        if(cell.y > 0.1) cell.y -= random(U + iTime) * 0.04;  // add flickering to pressure display\n        \n        O.xyz = jetColorMap(cell.y);        \n    }\n    \n    getSettings(iChannel0);\n    if(qPiston == RESET) return;    \n    gx = iResolution.x / float(GRIDX);\n    gy = iResolution.y / float(GRIDY);\n\n    vec2 endPoint1,endPoint2;\n    drawEngine(0,qPiston,endPoint1,O,U);\n    drawEngine(offset,qPiston2,endPoint2,O,U);\n\n    // wheel connections\n    const float PI = 3.141592654;\n    const float PI2 = PI * 2.;\n    float aa = (qPiston-MIN_PISTON) / (MAX_PISTON - MIN_PISTON);\n    float angle = aa * PI + PI;\n    if(qPiston <= qOldPiston)\n        angle = PI2 - angle;\n    aa = (qPiston2-MIN_PISTON) / (MAX_PISTON - MIN_PISTON);\n    float angle2 = aa * PI + PI;\n    if(qPiston2 <= qOldPiston2)\n        angle2 = PI2 - angle2;\n    \n    // wheel\n    vec2 pt = iResolution.xy * vec2(0.345,0.18);\n    float radius = iResolution.x * 0.25;\n    \n    float spoke = angle;\n    for(int i=0;i<16;++i) {\n        vec2 pt2 = vec2(pt.x + cos(spoke) * radius,pt.y + sin(spoke)*radius);\n        spoke += PI2 / 16.;\n        drawLine(pt,pt2,4.,SHAFT_COLOR,O,U);\n    }\n    drawCircle2(pt,radius,10.,SHAFT_COLOR,O,U);\n    drawCircle2(pt,radius*0.3,10.,SHAFT_COLOR,O,U);\n    drawCircle(pt,20.,SHAFT_COLOR,O,U);\n\n    float radius2 = radius * 0.3;\n    vec2 p8 = vec2(pt.x + cos(angle) * radius2,pt.y + sin(angle)*radius2);\n    vec2 p9 = vec2(pt.x + cos(angle2) * radius2,pt.y + sin(angle2)*radius2);\n    drawLine(endPoint1,p8,3.,SHAFT_COLOR,O,U);\n    drawLine(endPoint2,p9,3.,SHAFT_COLOR,O,U);\n    drawCircle(p8,15.,SHAFT_COLOR,O,U);\n    drawCircle(p9,15.,SHAFT_COLOR,O,U);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define GRIDX  130 // cell grid size\n#define GRIDY  (GRIDX * 720 / 1280)\n\n#define qPiston     settings[0].x\n#define qOldPiston  settings[0].y\n#define qPiston2    settings[0].z\n#define qOldPiston2 settings[0].w\n\nconst int ADDR_COUNT =       1;\nconst ivec2 Q0 = ivec2(0,GRIDY);\nconst ivec2[ADDR_COUNT] addrList = ivec2[](Q0);\n\nconst float WALL =    1.; // solid wall\nconst float PISTON =  2.; // piston, valve\nconst float STEAM =   3.; // open area for steam\nconst float RESET =   0.;\n\nconst float MAX_PRESSURE = 1000.;\nconst float MIN_PISTON = 3.;\nconst float MAX_PISTON = 24.;\n\nconst vec3 WALL_COLOR = vec3(0.2);\nconst vec3 SHAFT_COLOR = vec3(113./255.,121./255.,126./255.) * 1.5;\n\nconst ivec4 sc = ivec4(90,20,30,20);      // steam chest\nconst ivec4 vc = sc + ivec4(-3,35,6,-10); // valve chest\nconst float valveXscale = 0.6;\nconst int valveXoffset = 2;\nconst int valveWidth = 17;\nconst int offset = -62;\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\nvec4[ADDR_COUNT] settings;\n\nvoid getSettings(sampler2D channel) { \n    for(int i=0;i<ADDR_COUNT;++i)\n        settings[i] = texelFetch(channel, addrList[i],0);\n}\n\n// ----------------------------------------------------------\n\nbool keyClick(int ascii,sampler2D channel) {\n    return (texture(channel,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,0), 0).x != 0.);\n}\n   \nbool getKeyClick(int keyCode,sampler2D channel) {\n   return bool(texelFetch(channel, ivec2(keyCode,1), 0).x != 0.);\n}\n\n// ----------------------------------------------------------\n\nvec3 jetColorMap(float t) { // 0 ... 1\n    return clamp(vec3(1.5) - abs(4.0 * vec3(t) + vec3(-3., -2., -1.)), vec3(0.), vec3(1.));\n}\n\n// ----------------------------------------------------------\n// https://www.shadertoy.com/view/MtfGWM\n\nfloat random(vec2 c) { return fract(sin(dot(vec2(1.317 - c.x,19.753 + c.y),c))*413.7972); } // 0...1\n\n// ----------------------------------------------------------\n    \nvoid hline(int x1,int x2,int y,inout vec4 O, ivec2 I,float kind) {\n    ivec2 pt = ivec2(x1,y);\n    \n    for(int i=x1;i<=x2;++i) {\n        pt.x = i;\n        if(pt == I) {\n            O = vec4(0.,0.,0.,kind);\n            return;\n        }\n   }\n}\n\nvoid vline(int x,int y1,int y2,inout vec4 O, ivec2 I,float kind) {\n    ivec2 pt = ivec2(x,y1);\n    \n    for(int i=y1;i<=y2;++i) {\n        pt.y = i;\n        if(pt == I) {\n            O = vec4(0.,0.,0.,kind);\n            return;\n        }\n   }\n}\n\nvoid rectangle(int x1,int y1,int xs,int ys,inout vec4 O, ivec2 I,float kind) {\n    int x2 = x1 + xs, y2 = y1 + ys;\n    hline(x1,x2,y1,O,I,kind); hline(x1,x2,y2,O,I,kind);\n    vline(x1,y1,y2,O,I,kind); vline(x2,y1,y2,O,I,kind);\n}\n\nvoid rect(ivec4 v,inout vec4 O, ivec2 I,float kind) { // v = x,y,xs,ys\n    rectangle(v.x,v.y,v.z,v.w,O,I,kind);\n}\n\nvoid rectOffset(ivec4 v,ivec2 offset,inout vec4 O, ivec2 I,float kind) { // v = x,y,xs,ys\n    rectangle(v.x+offset.x, v.y+offset.y, v.z,v.w,O,I,kind);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void saveSettings(inout vec4 O, in vec2 U) {\n    for(int i=0;i<ADDR_COUNT;++i)\n        if(storeDataAddr(U, addrList[i])) {\n            O = settings[i];\n            return;\n        }\n}\n\n// ----------------------------------------------------------\n\nconst ivec4 \n    t1 = sc + ivec4(8,24,-26,-9),   // s-v connections\n    t2 = t1 + ivec4(10,0,0,0),\n    t1b = sc + ivec4(0,20,-18,-16), // s-v connection jogs\n    t2b = sc + ivec4(18,20,-18,-16),\n    t3 = sc + ivec4(13,27,-26,-12), // outlet\n    t3b = t3 + ivec4(4,0,15,-4),    // outlet to edge\n    t4 = t3 + ivec4(0,18,0,17),      // inlet\n    o1 = t1 + ivec4(1,0,-2,0),      // erase connections between rectangles\n    o2 = t2 + ivec4(1,0,-3,0),\n    o2c = t2 + ivec4(2,0,-3,0),\n    o3 = t3 + ivec4(1,1,-2,-1),     // inlet\n    o4 = t4 + ivec4(1,0,-2,0),      // outlet\n    o1b = t1b + ivec4(1,1,-2,-2), \n    o1c = o1b + ivec4(0,-1,-8,0), \n    o2b = t2b + ivec4(1,1,-2,-2), \n    o2d = o2b + ivec4(8,-1,-8,-2), \n    o3b = o3 + ivec4(1,0,0,-5),\n    o3c = o3b + ivec4(21,0,0,0);\n\nconst ivec4[]\n    rList = ivec4[](sc,vc,t1,t2,t3,t4,t1b,t2b,t3b),\n    oList = ivec4[](o1,o1b,o1c,o2,o2b,o2c,o2d,o3,o3b,o3c,o4);\n    \nvoid initializeCells(inout vec4 O, in vec2 U) {\n    ivec2 I = ivec2(U);\n    \n    if(I == Q0) {\n        qPiston = RESET;\n        qPiston2 = RESET;\n        saveSettings(O,U);\n        return;\n    }\n    \n    if(I.x < GRIDX && I.y < GRIDY) {\n        O = vec4(0.,0.,0.,STEAM);    \n        for(int i=0;i<rList.length();++i) {\n            rect(rList[i],O,I,WALL);\n            rectOffset(rList[i],ivec2(offset,0),O,I,WALL);\n        }\n        for(int i=0;i<oList.length();++i) {\n            rect(oList[i],O,I,STEAM);\n            rectOffset(oList[i],ivec2(offset,0),O,I,STEAM);\n        }       \n    }\n}\n\n// ----------------------------------------------------------\n\nvoid updateSteamPressure(inout vec4 O, ivec2 I) {\n    int count = 0;\n    float v,total = 0.,highest = 0.;\n    \n    for(int x=-1;x<=1;++x)\n        for(int y=-1;y<=1;++y) {\n            ivec2 adr = ivec2(I.x+x,I.y+y);\n            adr.x = clamp(adr.x,0,GRIDX-1);\n            adr.y = clamp(adr.y,0,GRIDY-1);\n    \n            vec4 O = fetchData(iChannel0,adr);\n            if(O.w == STEAM) {\n                count += 1;\n                v = O.x;\n                if(x != 0 && y != 0) v *= 0.85; // diagonal readings are lessened (changes shape of wave)\n                total += v;        \n                highest = max(highest,v);\n            }\n        }\n        \n    if(count > 0) {\n        highest *= 0.9995; // cool off a little\n        O.x = (highest*100. + total) / float(count+100); // bias average pressure with highest reading\n    }\n}\n\n// ----------------------------------------------------------\n\nbool updateEngine(ivec2 offset, inout vec4 O, vec2 U) {\n    ivec2 I = ivec2(U);    \n    getSettings(iChannel0);\n    \n    // Piston position & movement -------------------\n    if(I == Q0) {               \n        qOldPiston = qPiston;\n        if(qPiston == RESET) \n            qPiston = MIN_PISTON + (MAX_PISTON - MIN_PISTON) * 0.2;\n        \n        const float maxDelta = 0.6; // 0.2;\n        // read pressure on both sides of piston\n        int base = sc.x+1 + int(qPiston);\n        vec4 t1 = fetchData(iChannel0,ivec2(base-2,sc.y+12));\n        vec4 t2 = fetchData(iChannel0,ivec2(base+3,sc.y+12));\n        float qDelta = clamp(t1.x - t2.x,-maxDelta,maxDelta);        \n        qPiston = clamp(qPiston+qDelta,MIN_PISTON,MAX_PISTON);\n\n        qOldPiston2 = qPiston2;\n        if(qPiston2 == RESET) \n            qPiston2 = MIN_PISTON + (MAX_PISTON - MIN_PISTON) * 0.7;\n        \n        // same for 2nd engine\n        base = sc.x+1 + int(qPiston2) + offset.x;\n        t1 = fetchData(iChannel0,ivec2(base-2,sc.y+12));\n        t2 = fetchData(iChannel0,ivec2(base+3,sc.y+12));\n        qDelta = clamp(t1.x - t2.x,-maxDelta,maxDelta);        \n        qPiston2 = clamp(qPiston2+qDelta,MIN_PISTON,MAX_PISTON);\n\n        saveSettings(O,U);\n        return false;\n    }    \n \n    if(I.x >= GRIDX || I.y >= GRIDY) return false;    \n    O = fetchData(iChannel0,I);\n\n    // add hot steam to inlet pipe\n    if(I == o4.xy + ivec2(1,6)) {\n        O = vec4(MAX_PRESSURE,0.,0.,STEAM);\n        return false;\n    }\n    if(I == o4.xy + ivec2(1,6) + offset) {\n        O = vec4(MAX_PRESSURE,0.,0.,STEAM);\n        return false;\n    }\n\n    // copy exhaust steam past the blocking steam tube\n    const ivec2 exhaustHopDst = o4.xy + ivec2(9,-16);\n    const ivec2 exhaustHopSrc = exhaustHopDst + ivec2(-6,0);\n    if(I == exhaustHopDst) {\n        O = fetchData(iChannel0,exhaustHopSrc);\n        return false;\n    }\n    if(I == exhaustHopDst + offset) {\n        O = fetchData(iChannel0,exhaustHopSrc + offset);\n        return false;\n    }\n\n    if(O.w == STEAM) {\n        updateSteamPressure(O,I); // propagate pressure differences throughout steam regions    \n        O.x *= 0.995;                // steam cools down\n    }\n\n    bool pistonMoved = false;\n\n    // piston and valve moved?\n    int deltaPiston = int(qPiston) - int(qOldPiston);\n    if(deltaPiston != 0) { // assume -1,0,1\n        pistonMoved = true;\n        // copy neighboring steam into cells vacated by piston\n        int base = sc.x+1 + int(qPiston);\n        int dstX = base + ((deltaPiston > 0) ? -1 : 2); // to this column\n        int srcX = dstX + ((deltaPiston > 0) ? -1 : 1); // copy these steam temperatures\n\n        if(I.x == dstX && I.y >= sc.y+1 && I.y < sc.y+sc.w) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            O = vec4(src.x,0.,0.,STEAM);\n        }\n\n        rectangle(base,sc.y+1,1,sc.w-2,O,I,PISTON); \n        \n        // valve -------------------------------------------\n        // copy neighboring steam into cells vacated by valve\n        base = vc.x+1 + int((MAX_PISTON-qPiston) * valveXscale) + valveXoffset;\n\n        dstX = base + ((deltaPiston < 0) ? -1 : valveWidth+2); // outer edges\n        srcX = dstX + ((deltaPiston < 0) ? -1 : 1);            \n        if(I.x == dstX && I.y >= vc.y+1 && I.y < vc.y+7) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            if(src.w == STEAM)\n                O = vec4(src.x,0.,0.,STEAM);\n        }            \n\n        dstX = base + ((deltaPiston < 0) ? 14 : 4); // inner edges \n        srcX = dstX + ((deltaPiston < 0) ? -1 : 1);            \n        if(I.x == dstX && I.y >= vc.y+1 && I.y < vc.y+5) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            if(src.w == STEAM)\n                O = vec4(src.x,0.,0.,STEAM);\n        }\n\n        rectangle(base,vc.y+5,valveWidth+1,1,O,I,PISTON); \n        rectangle(base,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+valveWidth-2,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+1,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+valveWidth-1,vc.y+1,2,4,O,I,PISTON); \n    }\n    \n    // piston2 and valve moved?\n    deltaPiston = int(qPiston2) - int(qOldPiston2);\n    if(deltaPiston != 0) { // assume -1,0,1\n        pistonMoved = true;\n        // copy neighboring steam into cells vacated by piston\n        int base = sc.x+1 + int(qPiston2) + offset.x;\n        int dstX = base + ((deltaPiston > 0) ? -1 : 2); // to this column\n        int srcX = dstX + ((deltaPiston > 0) ? -1 : 1); // copy these steam pressures\n\n        if(I.x == dstX && I.y >= sc.y+1 && I.y < sc.y+sc.w) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            O = vec4(src.x,0.,0.,STEAM);\n        }\n\n        rectangle(base,sc.y+1,1,sc.w-2,O,I,PISTON); \n        \n        // valve -------------------------------------------\n        // copy neighboring steam into cells vacated by valve\n        base = vc.x+1 + int((MAX_PISTON-qPiston2) * valveXscale) + valveXoffset + offset.x;\n\n        dstX = base + ((deltaPiston < 0) ? -1 : valveWidth+2); // outer edges\n        srcX = dstX + ((deltaPiston < 0) ? -1 : 1);            \n        if(I.x == dstX && I.y >= vc.y+1 && I.y < vc.y+7) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            if(src.w == STEAM)\n                O = vec4(src.x,0.,0.,STEAM);\n        }            \n\n        dstX = base + ((deltaPiston < 0) ? 14 : 4); // inner edges \n        srcX = dstX + ((deltaPiston < 0) ? -1 : 1);            \n        if(I.x == dstX && I.y >= vc.y+1 && I.y < vc.y+5) {  \n            vec4 src = fetchData(iChannel0,ivec2(srcX,I.y));\n            if(src.w == STEAM)\n                O = vec4(src.x,0.,0.,STEAM);\n        }\n\n        rectangle(base,vc.y+5,valveWidth+1,1,O,I,PISTON); \n        rectangle(base,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+valveWidth-2,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+1,vc.y+1,2,4,O,I,PISTON); \n        rectangle(base+valveWidth-1,vc.y+1,2,4,O,I,PISTON); \n    }\n\n    return pistonMoved;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    if(iFrame < 2 || keyClick(32,iChannel3)) {\n        initializeCells(O,U);\n        return;\n    }\n    \n    updateEngine(ivec2(0),O,U);\n    updateEngine(ivec2(offset,0),O,U);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}