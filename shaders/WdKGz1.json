{
    "Shader": {
        "info": {
            "date": "1569737156",
            "description": "Calculates fluence of single scattered light from a thin beam through a semi infinite slab via Monte Carlo\nMainly looked through https://benedikt-bitterli.me/bachelor-thesis.pdf\n\nRevisiting the math this most definitely doesn't work lol",
            "flags": 32,
            "hasliked": 0,
            "id": "WdKGz1",
            "likes": 4,
            "name": "Single scatter semi-inf slab",
            "published": 3,
            "tags": [
                "scattering"
            ],
            "usePreview": 0,
            "username": "kjfung",
            "viewed": 724
        },
        "renderpass": [
            {
                "code": "const float curvePow = 0.4;\nconst float curveScale = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = pow(texture(iChannel0, uv), vec4(curvePow));\n\tfragColor *= curveScale;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define N float(iFrame)\nconst float sigmaS = 0.6; // scattering coefficient\nconst float sigmaA = 0.1; // absorbtion coefficient\nconst float sigmaT = sigmaS + sigmaA; // extinction coefficient\nconst float albedo = sigmaS / sigmaT;\nconst float Li = 1.0; // radiance of beam\nconst float g = 0.75; // anisotropy constant\nconst float g2 = g * g;\n\nconst float beamWidth = 0.03; // how thick the illustrative beam is\n\nfloat random01(vec2 co)\n{\n    co.x += iTime;\n    co.y -= iTime;\n    return abs(sin(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)));\n}\n\n// Distribution of scattering directions\nfloat phase(vec2 d0, vec2 d1)\n{\n    float cosTheta = dot(d0, d1);\n    \n    float result = (1.0 - g2);\n    result /= pow((1.0 + g2 - 2.0 * g * cosTheta), 1.5);\n    result *= 0.25 / 3.14159;\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Clear stuff just to be sure\n    if (N == 0.0) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n\n    // Warp uv to match aspect ratio\n    vec2 uv = fragCoord / iResolution.xy;\n    const float r = 2.0;\n    uv = uv * 2.0 - 1.0;\n    uv *= r;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Get position in space\n\tfloat depth = -uv.y;\n    vec2 x = vec2(uv.x, depth);\n\n    // Stuff outside of the medium\n    if (depth < 0.0) {\n        // Draw a beam for illustrative purposes\n        if (abs(x.x) < beamWidth) {\n            fragColor = vec4((beamWidth - abs(x.x)) / beamWidth) * exp(2.0 * depth);\n        }\n        // Draw interface between air and slab\n        if (depth >= -0.01) {\n            fragColor = vec4(0.5);\n        }\n        return;\n    }\n\n    // Importance sample a position on the beam\n    float kappa = max(0.001, abs(random01(uv * iTime)));\n    float beamDepth = -log(kappa) / sigmaT;\n    float pdf = sigmaT * exp(-sigmaT * beamDepth);\n    vec2 xb = vec2(0, beamDepth);\n\n    // Get radiance from xb to x\n    float si = beamDepth; // distance travelled by incident beam\n    float so = length(x - xb); // distance travelled by scattered beam\n    vec2 d0 = vec2(0.0, -1.0); // direction of incident beam\n    vec2 d1 = normalize(x - xb); // direction of scattering\n\n    float L = exp(-sigmaT * (si + so)) * albedo * phase(d0, d1) * Li;\n\n    // Monte carlo integration\n    vec4 oldValue = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = (oldValue * N + (L / pdf)) / (N + 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}