{
    "Shader": {
        "info": {
            "date": "1559573266",
            "description": "This is a collection of ray-primitive intersection routines ([url=http://iquilezles.org/articles/intersectors/intersectors.htm]by Íñigo Quílez[/url]).\n\nUse your mouse to change the camera viewpoint.",
            "flags": 32,
            "hasliked": 0,
            "id": "tl23Rm",
            "likes": 215,
            "name": "Ray Tracing - Primitives",
            "published": 3,
            "tags": [
                "3d",
                "raytracer",
                "ray",
                "intersection",
                "dof",
                "primitives",
                "field",
                "tracing",
                "depth",
                "path",
                "of"
            ],
            "usePreview": 1,
            "username": "reinder",
            "viewed": 16350
        },
        "renderpass": [
            {
                "code": "// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// The MIT License\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\n// I wanted to create a reference shader similar to \"Raymarching - Primitives\" \n// (https://www.shadertoy.com/view/Xds3zN), but with ray-primitive intersection \n// routines instead of sdf routines.\n// \n// As usual, I ended up mostly just copy-pasting code from Íñigo Quílez: \n// \n// https://iquilezles.org/articles/intersectors\n// \n// Please let me know if there are other routines that I should add to this shader.\n// \n// You can find all intersection routines in the Common tab. The routines have a similar \n// signature: a routine returns the distance to the first hit inside the \n// [distBound.x, distBound.y] interval and will set the normal if an intersection is found.\n// If no intersection is found, the routine will return MAX_DIST.\n//\n// I made a simple ray tracer (Buffer A) to visualize a scene with all primitives.\n//\n// Use your mouse to change the camera viewpoint.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb / data.w;\n    \n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// The MIT License\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\n// I wanted to create a reference shader similar to \"Raymarching - Primitives\" \n// (https://www.shadertoy.com/view/Xds3zN), but with ray-primitive intersection \n// routines instead of sdf routines.\n// \n// As usual, I ended up mostly just copy-pasting code from Íñigo Quílez: \n// \n// https://iquilezles.org/articles/intersectors\n// \n// Please let me know if there are other routines that I should add to this shader.\n// \n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n//\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n//\n\n#define MAX_DIST 1e10\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Plane \nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 pa, in vec3 pb, float ra ) {\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return MAX_DIST;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\n    \n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca*sign(y)/caca);\n        return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Torus:           https://www.shadertoy.com/view/4sBGDy\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec2 torus ) {\n    // bounding sphere\n    vec3 tmpnormal;\n    if (iSphere(ro, rd, distBound, tmpnormal, torus.y+torus.x) > distBound.y) {\n        return MAX_DIST;\n    }\n    \n    float po = 1.0;\n    \n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\n#if 1\n\tfloat k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n\tfloat k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n#else\n\tfloat k = (m - Ra2 - ra2)/2.0;\n\tfloat k3 = n;\n\tfloat k2 = n*n + Ra2*rd.z*rd.z + k;\n\tfloat k1 = k*n + Ra2*ro.z*rd.z;\n\tfloat k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n#endif\n    \n#if 1\n    // prevent |c1| from being too close to zero\n    if (abs(k3*(k3*k3-k2)+k1) < 0.01) {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n#endif\n    \n    // reduced cubic\n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    \n    float h = R*R - Q*Q*Q;\n    float t = MAX_DIST;\n    \n    if (h>=0.0) {\n        // 2 intersections\n        h = sqrt(h);\n        \n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n    \n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n\n        if (t1 >= distBound.x) t=t1;\n        if (t2 >= distBound.x) t=min(t,t2);\n\t} else {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n\n        float d2 = -(w+c2); if( d2<0.0 ) return MAX_DIST;\n        float d1 = sqrt(d2);\n\n        float h1 = sqrt(w - 2.0*c2 + c1/d1);\n        float h2 = sqrt(w - 2.0*c2 - c1/d1);\n        float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n        float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n\n        if (t1 >= distBound.x) t=t1;\n        if (t2 >= distBound.x) t=min(t,t2);\n        if (t3 >= distBound.x) t=min(t,t3);\n        if (t4 >= distBound.x) t=min(t,t4);\n    }\n    \n\tif (t >= distBound.x && t <= distBound.y) {\n        vec3 pos = ro + rd*t;\n        normal = normalize( pos*(dot(pos,pos) - torus.y*torus.y - torus.x*torus.x*vec3(1,1,-1)));\n        return t;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in vec3 pa, in vec3 pb, in float r ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if (h >= 0.) {\n        float t = (-b-sqrt(h))/a;\n        float d = MAX_DIST;\n        \n        float y = baoa + t*bard;\n        \n        // body\n        if (y > 0. && y < baba) {\n            d = t;\n        } else {\n            // caps\n            vec3 oc = (y <= 0.) ? oa : ro - pb;\n            b = dot(rd,oc);\n            c = dot(oc,oc) - r*r;\n            h = b*b - c;\n            if( h>0.0 ) {\n                d = -b - sqrt(h);\n            }\n        }\n        if (d >= distBound.x && d <= distBound.y) {\n            vec3  pa = ro + rd * d - pa;\n            float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n            normal = (pa - h*ba)/r;\n            return d;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\nfloat iCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n             in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n    if (m1 < 0.) { \n        if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {\n            float d = -m1/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = -ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n    else if (m2 > 0.) { \n        if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) {\n            float d = -m2/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n                       \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h < 0. ) return MAX_DIST;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\n        return t;\n    } else {   \n\t    return MAX_DIST;\n    }\n}\n\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\nfloat iEllipsoid( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                  in vec3 rad ) {\n    vec3 ocn = ro / rad;\n    vec3 rdn = rd / rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.);\n    \n    if (h < 0.) {\n        return MAX_DIST;\n    }\n    \n\tfloat d = (-b - sqrt(h))/a;\n    \n    if (d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize((ro + d*rd)/rad);\n    \treturn d;\n    }\n}\n\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\nfloat iRoundedCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                    in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n\tvec3  ob = ro - pb;\n    float rr = ra - rb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\tfloat m6 = dot(ob,rd);\n    float m7 = dot(ob,ob);\n    \n    float d2 = m0-rr*rr;\n    \n\tfloat k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2. - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n    if (h < 0.0) {\n        return MAX_DIST;\n    }\n    \n    float t = (-sqrt(h)-k1)/k2;\n    \n    float y = m1 - ra*rr + t*m2;\n    if (y>0.0 && y<d2) {\n        if (t >= distBound.x && t <= distBound.y) {\n        \tnormal = normalize( d2*(oa + t*rd)-ba*y );\n            return t;\n        } else {\n            return MAX_DIST;\n        }\n    } else {\n        float h1 = m3*m3 - m5 + ra*ra;\n        float h2 = m6*m6 - m7 + rb*rb;\n\n        if (max(h1,h2)<0.0) {\n            return MAX_DIST;\n        }\n\n        vec3 n = vec3(0);\n        float r = MAX_DIST;\n\n        if (h1 > 0.) {        \n            r = -m3 - sqrt( h1 );\n            n = (oa+r*rd)/ra;\n        }\n        if (h2 > 0.) {\n            t = -m6 - sqrt( h2 );\n            if( t<r ) {\n                n = (ob+t*rd)/rb;\n                r = t;\n            }\n        }\n        if (r >= distBound.x && r <= distBound.y) {\n            normal = n;\n            return r;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 v0, in vec3 v1, in vec3 v2 ) {\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0. || v<0. || (u+v)>1. || t<distBound.x || t>distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize(-n);\n        return t;\n    }\n}\n\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\nfloat iSphere4( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in float ra ) {\n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    \n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k0 = ka* dot(ro,d3);\n    float k1 = ka* dot(o2,d2);\n    float k2 = ka* dot(o3,rd);\n    float k3 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c0 = k1 - k0*k0;\n    float c1 = k2 + 2.0*k0*(k0*k0 - (3.0/2.0)*k1);\n    float c2 = k3 - 3.0*k0*(k0*(k0*k0 - 2.0*k1) + (4.0/3.0)*k2);\n\n    float p = c0*c0*3.0 + c2;\n    float q = c0*c0*c0 - c0*c2 + c1*c1;\n    float h = q*q - p*p*p*(1.0/27.0);\n\n    // -----------------------------\n    // skip the case of 3 real solutions for the cubic, which involves \n    // 4 complex solutions for the quartic, since we know this objcet is \n    // convex\n    // -----------------------------\n    if (h<0.0) {\n        return MAX_DIST;\n    }\n    \n    // one real solution, two complex (conjugated)\n    h = sqrt(h);\n\n    float s = sign(q+h)*pow(abs(q+h),1.0/3.0); // cuberoot\n    float t = sign(q-h)*pow(abs(q-h),1.0/3.0); // cuberoot\n\n    vec2 v = vec2( (s+t)+c0*4.0, (s-t)*sqrt(3.0) )*0.5;\n    \n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n    \n    float r = length(v);\n\tfloat d = -abs(v.y)/sqrt(r+v.x) - c1/r - k0;\n\n    if (d >= distBound.x && d <= distBound.y) {\n\t    vec3 pos = ro + rd * d;\n\t    normal = normalize( pos*pos*pos );\n\t    return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\n\nfloat iGoursat( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in float ra, float rb ) {\n// hole: x4 + y4 + z4 - (r2^2)·(x2 + y2 + z2) + r1^4 = 0;\n    float ra2 = ra*ra;\n    float rb2 = rb*rb;\n    \n    vec3 rd2 = rd*rd; vec3 rd3 = rd2*rd;\n    vec3 ro2 = ro*ro; vec3 ro3 = ro2*ro;\n\n    float ka = 1.0/dot(rd2,rd2);\n\n    float k3 = ka*(dot(ro ,rd3));\n    float k2 = ka*(dot(ro2,rd2) - rb2/6.0);\n    float k1 = ka*(dot(ro3,rd ) - rb2*dot(rd,ro)/2.0  );\n    float k0 = ka*(dot(ro2,ro2) + ra2*ra2 - rb2*dot(ro,ro) );\n\n    float c2 = k2 - k3*(k3);\n    float c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n    float c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c0*c2 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    \n    // 2 intersections\n    if (h>0.0) {\n        h = sqrt(h);\n\n        float s = cuberoot( R + h );\n        float u = cuberoot( R - h );\n        \n        float x = s+u+4.0*c2;\n        float y = s-u;\n        \n        float k2 = x*x + y*y*3.0;\n  \n        float k = sqrt(k2);\n\n\t\tfloat d = -0.5*abs(y)*sqrt(6.0/(k+x)) \n                  -2.0*c1*(k+x)/(k2+x*k) \n                  -k3;\n        \n        if (d >= distBound.x && d <= distBound.y) {\n            vec3 pos = ro + rd * d;\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\n            return d;\n        } else {\n            return MAX_DIST;\n        }\n    } else {\t\n        // 4 intersections\n        float sQ = sqrt(Q);\n        float z = c2 - 2.0*sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n\n        float d1 = z   - 3.0*c2;\n        float d2 = z*z - 3.0*c0;\n\n        if (abs(d1)<1.0e-4) {  \n            if( d2<0.0) return MAX_DIST;\n            d2 = sqrt(d2);\n        } else {\n            if (d1<0.0) return MAX_DIST;\n            d1 = sqrt( d1/2.0 );\n            d2 = c1/d1;\n        }\n\n        //----------------------------------\n\n        float h1 = sqrt(d1*d1 - z + d2);\n        float h2 = sqrt(d1*d1 - z - d2);\n        float t1 = -d1 - h1 - k3;\n        float t2 = -d1 + h1 - k3;\n        float t3 =  d1 - h2 - k3;\n        float t4 =  d1 + h2 - k3;\n\n        if (t2<0.0 && t4<0.0) return MAX_DIST;\n\n        float result = 1e20;\n             if (t1>0.0) result=t1;\n        else if (t2>0.0) result=t2;\n             if (t3>0.0) result=min(result,t3);\n        else if (t4>0.0) result=min(result,t4);\n\n        if (result >= distBound.x && result <= distBound.y) {\n            vec3 pos = ro + rd * result;\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\n            return result;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\nfloat iRoundedBox(in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n   \t\t\t\t  in vec3 size, in float rad ) {\n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    if (tN > tF || tF < 0.0) {\n    \treturn MAX_DIST;\n    }\n    float t = (tN>=distBound.x&&tN<=distBound.y)?tN:\n    \t\t  (tF>=distBound.x&&tF<=distBound.y)?tF:MAX_DIST;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    vec3 ros = ro*s;\n    vec3 rds = rd*s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if (min(min(pos.x,pos.y),pos.z)<0.0) {\n        if (t >= distBound.x && t <= distBound.y) {\n            vec3 p = ro + rd * t;\n            normal = sign(p)*normalize(max(abs(p)-size,0.0));\n            return t;\n        }\n    }\n    \n    // some precomputation\n    vec3 oc = ros - size;\n    vec3 dd = rds*rds;\n\tvec3 oo = oc*oc;\n    vec3 od = oc*rds;\n    float ra2 = rad*rad;\n\n    t = MAX_DIST;        \n\n    // corner\n    {\n    float b = od.x + od.y + od.z;\n\tfloat c = oo.x + oo.y + oo.z - ra2;\n\tfloat h = b*b - c;\n\tif (h > 0.0) t = -b-sqrt(h);\n    }\n\n    // edge X\n    {\n\tfloat a = dd.y + dd.z;\n\tfloat b = od.y + od.z;\n\tfloat c = oo.y + oo.z - ra2;\n\tfloat h = b*b - a*c;\n\tif (h>0.0) {\n\t  h = (-b-sqrt(h))/a;\n      if (h>=distBound.x && h<t && abs(ros.x+rds.x*h)<size.x ) t = h;\n    }\n\t}\n    // edge Y\n    {\n\tfloat a = dd.z + dd.x;\n\tfloat b = od.z + od.x;\n\tfloat c = oo.z + oo.x - ra2;\n\tfloat h = b*b - a*c;\n\tif (h>0.0) {\n\t  h = (-b-sqrt(h))/a;\n      if (h>=distBound.x && h<t && abs(ros.y+rds.y*h)<size.y) t = h;\n    }\n\t}\n    // edge Z\n    {\n\tfloat a = dd.x + dd.y;\n\tfloat b = od.x + od.y;\n\tfloat c = oo.x + oo.y - ra2;\n\tfloat h = b*b - a*c;\n\tif (h>0.0) {\n\t  h = (-b-sqrt(h))/a;\n      if (h>=distBound.x && h<t && abs(ros.z+rds.z*h)<size.z) t = h;\n    }\n\t}\n    \n\tif (t >= distBound.x && t <= distBound.y) {\n        vec3 p = ro + rd * t;\n        normal = sign(p)*normalize(max(abs(p)-size,1e-16));\n        return t;\n    } else {\n        return MAX_DIST;\n    };\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/tl23Rm\n//\n// I have combined different intersection routines in one shader (similar \n// to \"Raymarching - Primitives\": https://www.shadertoy.com/view/Xds3zN) and\n// added a simple ray tracer to visualize a scene with all primitives.\n//\n\n#define PATH_LENGTH 12\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray tracer helper functions\n//\n\nfloat FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {\n    vec2 r = hash2(seed);\n    \n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\t\n    float a = roughness*roughness;\n    \n\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\n\tfloat ra = sqrt(abs(1.-rz*rz));\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    \n    vec3 ret = normalize(rr);\n    return dot(ret,normal) > 0. ? ret : n;\n}\n\nvec2 randomInUnitDisk( inout float seed ) {\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n//\n// Scene description\n//\n\nvec3 rotateY( const in vec3 p, const in float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 opU( vec3 d, float iResult, float mat ) {\n\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\n}\n\nfloat iMesh( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal) {\n\tconst vec3 tri0 = vec3(-2./3. * 0.43301270189, 0, 0);\n\tconst vec3 tri1 = vec3( 1./3. * 0.43301270189, 0, .25);\n\tconst vec3 tri2 = vec3( 1./3. * 0.43301270189, 0,-.25);\n\tconst vec3 tri3 = vec3( 0, 0.41079191812, 0);\n    \n    vec2 d = distBound;\n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri0, tri1, tri2));   \n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri0, tri3, tri1));  \n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri2, tri3, tri0));   \n\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri1, tri3, tri2));\n    \n    return d.y < distBound.y ? d.y : MAX_DIST;\n}\n         \nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\n    \n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\n    d = opU(d, iBox        (ro-vec3( 1,.250, 0), rd, d.xy, normal, vec3(.25)), 2.);\n    d = opU(d, iSphere     (ro-vec3( 0,.250, 0), rd, d.xy, normal, .25), 3.);\n    d = opU(d, iCylinder   (ro,                  rd, d.xy, normal, vec3(2.1,.1,-2), vec3(1.9,.5,-1.9), .08 ), 4.);\n    d = opU(d, iCylinder   (ro-vec3( 1,.100,-2), rd, d.xy, normal, vec3(0,0,0), vec3(0,.4,0), .1 ), 5.);\n    d = opU(d, iTorus      (ro-vec3( 0,.250, 1), rd, d.xy, normal, vec2(.2,.05)), 6.);\n    d = opU(d, iCapsule    (ro-vec3( 1,.000,-1), rd, d.xy, normal, vec3(-.1,.1,-.1), vec3(.2,.4,.2), .1), 7.);\n    d = opU(d, iCone       (ro-vec3( 2,.200, 0), rd, d.xy, normal, vec3(.1,0,0), vec3(-.1,.3,.1), .15, .05), 8.);\n    d = opU(d, iRoundedBox (ro-vec3( 0,.250,-2), rd, d.xy, normal, vec3(.15,.125,.15), .045), 9.);\n    d = opU(d, iGoursat    (ro-vec3( 1,.275, 1), rd, d.xy, normal, .16, .2), 10.);\n    d = opU(d, iEllipsoid  (ro-vec3(-1,.300, 0), rd, d.xy, normal, vec3(.2,.25, .05)), 11.);\n    d = opU(d, iRoundedCone(ro-vec3( 2,.200,-1), rd, d.xy, normal, vec3(.1,0,0), vec3(-.1,.3,.1), 0.15, 0.05), 12.);\n    d = opU(d, iRoundedCone(ro-vec3(-1,.200,-2), rd, d.xy, normal, vec3(0,.3,0), vec3(0,0,0), .1, .2), 13.);\n    d = opU(d, iMesh       (ro-vec3( 2,.090, 1), rd, d.xy, normal), 14.);\n    d = opU(d, iSphere4    (ro-vec3(-1,.275,-1), rd, d.xy, normal, .225), 15.);\n    \n    tmp1 = opU(d, iBox     (rotateY(ro-vec3(0,.25,-1), 0.78539816339), rotateY(rd, 0.78539816339), d.xy, tmp0, vec3(.1,.2,.1)), 16.);\n    if (tmp1.y < d.y) {\n        d = tmp1;\n        normal = rotateY(tmp0, -0.78539816339);\n    }\n    \n    return d;\n}\n\n//\n// Palette by Íñigo Quílez: \n// https://www.shadertoy.com/view/ll2GD3\n//\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos(6.28318530718*(c*t+d));\n}\n\nfloat checkerBoard( vec2 p ) {\n   return mod(floor(p.x) + floor(p.y), 2.);\n}\n\nvec3 getSkyColor( vec3 rd ) {\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\n    return col;\n}\n\n#define LAMBERTIAN 0.\n#define METAL 1.\n#define DIELECTRIC 2.\n\nfloat gpuIndepentHash(float p) {\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid getMaterialProperties(in vec3 pos, in float mat, \n                           out vec3 albedo, out float type, out float roughness) {\n    albedo = pal(mat*.59996323+.5, vec3(.5),vec3(.5),vec3(1),vec3(0,.1,.2));\n\n    if( mat < 1.5 ) {            \n        albedo = vec3(.25 + .25*checkerBoard(pos.xz * 5.));\n        roughness = .75 * albedo.x - .15;\n        type = METAL;\n    } else {\n        type = floor(gpuIndepentHash(mat+.3) * 3.);\n        roughness = (1.-type*.475) * gpuIndepentHash(mat);\n    }\n}\n\n//\n// Simple ray tracer\n//\n\nfloat schlick(float cosine, float r0) {\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\n    vec3 albedo, normal, col = vec3(1.); \n    float roughness, type;\n    \n    for (int i=0; i<PATH_LENGTH; ++i) {    \n    \tvec3 res = worldhit( ro, rd, vec2(.0001, 100), normal );\n\t\tif (res.z > 0.) {\n\t\t\tro += rd * res.y;\n       \t\t\n            getMaterialProperties(ro, res.z, albedo, type, roughness);\n            \n            if (type < LAMBERTIAN+.5) { // Added/hacked a reflection term\n                float F = FresnelSchlickRoughness(max(0.,-dot(normal, rd)), .04, roughness);\n                if (F > hash1(seed)) {\n                    rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);\n                } else {\n                    col *= albedo;\n\t\t\t        rd = cosWeightedRandomHemisphereDirection(normal, seed);\n                }\n            } else if (type < METAL+.5) {\n                col *= albedo;\n                rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);            \n            } else { // DIELECTRIC\n                vec3 normalOut, refracted;\n                float ni_over_nt, cosine, reflectProb = 1.;\n                if (dot(rd, normal) > 0.) {\n                    normalOut = -normal;\n            \t\tni_over_nt = 1.4;\n                    cosine = dot(rd, normal);\n                    cosine = sqrt(1.-(1.4*1.4)-(1.4*1.4)*cosine*cosine);\n                } else {\n                    normalOut = normal;\n                    ni_over_nt = 1./1.4;\n                    cosine = -dot(rd, normal);\n                }\n            \n\t            // Refract the ray.\n\t            refracted = refract(normalize(rd), normalOut, ni_over_nt);\n    \t        \n        \t    // Handle total internal reflection.\n                if(refracted != vec3(0)) {\n                \tfloat r0 = (1.-ni_over_nt)/(1.+ni_over_nt);\n\t        \t\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, roughness);\n                }\n                \n                rd = hash1(seed) <= reflectProb ? reflect(rd,normalOut) : refracted;\n                rd = modifyDirectionWithRoughness(-normalOut, rd, roughness, seed);            \n            }\n        } else {\n            col *= getSkyColor(rd);\n\t\t\treturn col;\n        }\n    }  \n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool reset = iFrame == 0;\n            \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n        \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    vec3 ro = vec3(.5+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, -.5+2.5*sin(1.5+6.*mo.x));\n    vec3 ta = vec3(.5, -.4, -.5);\n    mat3 ca = setCamera(ro, ta, 0.);    \n    vec3 normal;\n    \n    float fpd = data.x;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        // Calculate focus plane.\n        float nfpd = worldhit(ro, normalize(vec3(.5,0,-.5)-ro), vec2(0, 100), normal).y;\n\t\tfragColor = vec4(nfpd, mo*iResolution.xy, iResolution.x);\n    } else { \n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n        float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n\n        // AA\n        p += 2.*hash2(seed)/iResolution.y;\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n\n        // DOF\n        vec3 fp = ro + rd * fpd;\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.02;\n        rd = normalize(fp - ro);\n\n        vec3 col = render(ro, rd, seed);\n\n        if (reset) {\n           fragColor = vec4(col, 1);\n        } else {\n           fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}