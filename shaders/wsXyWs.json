{
    "Shader": {
        "info": {
            "date": "1585826135",
            "description": "Hey they said dress for the job you want and since I'm working from home I wanted to be Max Headroom in zoom\n\nIt should be noted that using raymarching for something this simple is total overkill., shoulda just raytraced it.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsXyWs",
            "likes": 7,
            "name": "max headroom zoom background",
            "published": 3,
            "tags": [
                "80s",
                "remotework",
                "workingfromhome",
                "maxheadroom"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 1022
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 1000.0\n#define MAX_STEPS 1000\n#define EPSILON 0.01\n#define STEP_RATIO 0.75\n\n\n#define NORMAL_DELTA 0.001\n\nvec2 measure(vec3 point) {\n    vec3 rv = vec3(mod(point.x+5.0, 10.0)-5.0, \n                  point.y, \n                  point.z);\n    \n    float r = max(length(rv.xy) - 0.75,\n    \tmax(point.z,-point.x-0.5));\n\tvec2 closest = vec2(r, 1.0);\n    \n    vec3 gv = vec3(point.x,\n        mod(point.y+5.0, 10.0)-5.0, \n        point.z);\n    float g = max(length(gv.yz) - 0.50,\n\t    max(-point.x+0.5, -point.y-5.5));\n    if (g < closest.x) {\n        closest = vec2(g, 2.0);\n    }\n    // yellow\n    vec3 bv = vec3(point.x,\n        point.y,\n        mod(point.z+5.0, 10.0)-5.0);\n    float b = max(length(bv.zx) - 0.75,\n    \tmax(point.z-5.5, -point.y+0.5));\n    if (b < closest.x) {\n        closest = vec2(b, 3.0);\n    }\n    \n    return closest;\n}\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\nvec4 aaTrace(in vec2 fragCoord )\n{\n    // apply smooth sawtooth time distortion for eye\n    // this makes the eye move very slow, then fast, over and over\n    float eyeTime = iTime*2.0/3.1415926536 + sin(iTime) \n        +sin(iTime*2.0) / 4.0\n        +sin(iTime*3.0) / 9.0\n        +sin(iTime*4.0) / 16.0\n        +sin(iTime*5.0) / 25.0;\n    vec3 eye = vec3(\n        sin(eyeTime*0.11)* 150.0 + 300.0,\n        sin(eyeTime*0.05)* 150.0 + 300.0,\n        cos(eyeTime*0.13)* 150.0 - 300.0\n    );\n    // minor time distortion for whatever we're looking at\n    float lookTime = 4.0*(iTime + sin(iTime+2.0));\n    // keep us looking more or less at the back corner but\n    // move your around a bit\n    vec3 look_at = vec3(\n        sin(lookTime*0.0730)*50.0+50.0,\n        sin(lookTime*0.0101)*20.0+30.0,\n        cos(lookTime*0.0710)*50.0+50.0\n    );\n    // let's do the time warp again\n    float upTime = iTime + sin(iTime*1.7+1.0);\n    // get a bit of roll going by adjusting the up vector too\n    vec3 up = normalize(vec3(\n        sin(upTime*0.0610)*1.0,\n        sin(upTime*0.0430)*1.0+3.0,\n        cos(upTime*0.0310)*1.0\n    ));\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    float current_dist = 0.0;\n    float best_dist = MAX_DIST;\n    // main raymarching loop\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        // lazy bailout if we go past the back walls\n        if (where.y < -1.0 || where.x < -1.0 || where.z > 1.0) {\n            break;\n        }\n        current = measure(where);\n        current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        if (current_dist < best_dist) {\n            best_dist = current_dist;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n    if (who == 1){\n        float glow = clamp(15.0 - best_dist, 0.0, 15.0) / 15.0;\n        vec3 pink = vec3(1.0, 0.6, 0.5);\n        return vec4(glow * pink, 1.0);\n    }\n    if (who == 2){\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 green = vec3(0.5, 1.0, 0.5);\n        return vec4(glow * green, 1.0);\n    }\n    if (who == 3){\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 cc = vec3(0.8, 0.8, 0.2);\n        return vec4(glow * cc, 1.0);\n    }\n    return vec4(0);\n}\n\n#define AA_JITTER 0.1\n#define AA_SPREAD 1.0\n#define AA_DEPTH  4\n#define AA_DEPTH_F 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (int aax = 0; aax < AA_DEPTH; aax++) {\n\t    for (int aay = 0; aay < AA_DEPTH; aay++) {\n            vec2 dp = AA_SPREAD * vec2(float(aax), float(aay)) / AA_DEPTH_F;\n            vec2 subpixel = dp + fragCoord;\n            ivec2 ip = ivec2(int(subpixel.x * AA_DEPTH_F), int(subpixel.y*AA_DEPTH_F));\n            vec2 jitter = vec2(\n                float(((2621 * ip.x + ip.y) * 1709) &255) / 256.0 - 0.5,\n            \tfloat(((1999 * ip.x + ip.y) * 3119) &255) / 256.0 - 0.5\n            ) * AA_JITTER;\n            fragColor += aaTrace(subpixel + jitter);\n        }\n    }\n    fragColor /= 16.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}