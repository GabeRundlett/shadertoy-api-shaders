{
    "Shader": {
        "info": {
            "date": "1716496432",
            "description": "projectile effect test for https://github.com/Krapas2/BlindEnding",
            "flags": 0,
            "hasliked": 0,
            "id": "M33GW8",
            "likes": 12,
            "name": "fireball projectile",
            "published": 3,
            "tags": [
                "noise",
                "plasma",
                "projectile"
            ],
            "usePreview": 0,
            "username": "Krapas",
            "viewed": 216
        },
        "renderpass": [
            {
                "code": "vec3 n_rand3(vec3 p) {\n    vec3 r = \n        fract(\n            sin(\n                vec3(\n                    dot(p, vec3(127.1,311.7,371.8)),\n                    dot(p,vec3(269.5,183.3,456.1)),\n                    dot(p,vec3(352.5,207.3,198.67))\n                )\n            ) * 43758.5453\n        ) * 2.0 - 1.0;\n    return normalize(vec3(r.x/cos(r.x), r.y/cos(r.y), r.z/cos(r.z)));\n}\n\nfloat noise(vec3 p) {\n\n    vec3 fv = fract(p);\n    vec3 nv = vec3(floor(p));\n    \n    vec3 u = fv*fv*fv*(fv*(fv*6.0-15.0)+10.0);\n    \n    return (\n        mix(\n            mix(\n                mix(\n                    dot( n_rand3( nv+vec3(0.0,0.0,0.0) ), fv-vec3(0.0,0.0,0.0)), \n                    dot( n_rand3( nv+vec3(1.0,0.0,0.0) ), fv-vec3(1.0,0.0,0.0)), \n                    u.x\n                ), \n                mix(\n                    dot( n_rand3( nv+vec3(0.0,1.0,0.0) ), fv-vec3(0.0,1.0,0.0)), \n                    dot( n_rand3( nv+vec3(1.0,1.0,0.0) ), fv-vec3(1.0,1.0,0.0)), \n                    u.x\n                ), \n                u.y\n            ),\n            mix(\n                mix(\n                    dot( n_rand3( nv+vec3(0.0,0.0,1.0) ), fv-vec3(0.0,0.0,1.0)), \n                    dot( n_rand3( nv+vec3(1.0,0.0,1.0) ), fv-vec3(1.0,0.0,1.0)), \n                    u.x\n                ), \n                mix(\n                    dot( n_rand3( nv+vec3(0.0,1.0,1.0) ), fv-vec3(0.0,1.0,1.0)), \n                    dot( n_rand3( nv+vec3(1.0,1.0,1.0) ), fv-vec3(1.0,1.0,1.0)), \n                    u.x\n                ), \n                u.y\n            ),\n            u.z\n       )\n  );\n}\n\nfloat oct_noise(vec3 pos, float o)\n{\n\n    float ns = 0.0;\n    float d = 0.0;\n    \n    int io = int(o);\n    float fo = fract(o);\n    \n    for(int i=0;i<=io;++i)\n    {\n        float v = pow(2.0,float(i));\n        d += 1.0/v;\n        ns += noise(pos*v)*(1.0/v);\n    }\n    \n    \n    float v = pow(2.0,float(io+1));\n    d+= 1.0*fo/v;\n    ns += noise(pos*v)*(1.0*fo/v);\n    \n    return ns/d;\n}\n\nfloat posterize(float v, int n)\n{\n    float fn = float(n);\n    return floor(v*fn)/(fn-1.);\n}\n\nvec3 HP[] = vec3[4](\n    vec3(.85, .1, .0),\n    vec3(.9, .3, .1),\n    vec3(.9, .5, .2),\n    vec3(.9, .9, .3)\n);\n\nvec3 PF[] = vec3[4](\n    vec3(.65625, 0., .68359375),\n    vec3(.8515625, .19921875, .703125),\n    vec3(1., .59765625, .8359375),\n    vec3(.9375, .859375, .83203125)\n);\n\n\nfloat f (vec2 uv) {\n    vec2 pos = uv;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *=  10.0;\n    \n    float base = (-pow(abs(uv.y-.5)*2.,2.)+pow(uv.x+.1,8.)-pow(uv.x+.1,10.))*10.-pow(1.1-uv.x, 10.);\n    float wave = oct_noise(vec3(pos+vec2(iTime*8.,0.), iTime*.5), (1.-uv.x)*4.)/2.;\n    float flares = pow(sin(1.-(noise(vec3(pos*2.+vec2(iTime*16.,0.),iTime)))*3.141592653689),4.)/16.;\n    \n    return base+wave+flares;\n}\n\n\nvec2 grad( vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\nfloat border (vec2 uv)\n{\n\n    float v = f( uv );\n    vec2  g = grad( uv );\n    float de = abs(v)/length(g);\n    float eps = .01;\n    \n    return smoothstep( 1.0*eps, 2.0*eps, de );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = uv;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *=  10.0;\n    \n    vec3 pal[] = HP;\n    int pl = pal.length();\n\n    float value = f(uv);\n    \n    float b = step(.5,border(uv));\n    float alpha = step(0.,value);\n    vec3 color = pal[int(posterize(value, pl)*float(pl))] - vec3(1.-alpha) - (1.-b);\n    \n    vec4 result = vec4(alpha == 1. ? color : vec3(.5), alpha);\n\n    fragColor = vec4(result);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}