{
    "Shader": {
        "info": {
            "date": "1496706647",
            "description": "To find distance to quadratic bezier, we need only 2 roots i.e. we can ignore 3rd one (blue), because it is local maximum.\nIt's not much faster, but at least few cycles :)\n[url=http://polycu.be/edit/?h=L1VihH]Polycu.be[/url] version (with more control).",
            "flags": 0,
            "hasliked": 0,
            "id": "MdXBzB",
            "likes": 35,
            "name": "Bezier distance with 2 roots",
            "published": 3,
            "tags": [
                "bezier",
                "distance",
                "optimization"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 2470
        },
        "renderpass": [
            {
                "code": "// Distance to quadratic bezier with 2 roots by Tom'2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// 3rd root is in all cases unnecessary (there is no blue area),\n// because it is local maximum (note: circle always contains two other roots).\n// This was actually suggested to me by Ken Silverman in 2010, while playing with distance\n// functions to Bezier curves, but we didn't come up with any actual proof.\n// It seems to be also true for 3d, which is pretty much the same code/formula,\n// you can just replace input \"vec2\" with \"vec3\".\n\n// As iq suggested here https://www.shadertoy.com/view/4dsfRS,\n// we can just draw diagram showing which root is the closest\n// (this doesn't really prove anything, but gives us a little bit of intuition)\n#define ROOT_DIAGRAM 1\n // 0 to just show color based on sign\n\n// Area/dots color coding:\n// 1st root (t_1) = orange\n// 2nd root (t_2) = green\n// 3rd root (t_3) = blue\n// if there is only one root: purple\n\n// Sketch of the proof:\n// Let's denote f(t) = d + (c + b*t)*t, as a quadratic bezier curve relative to the query point \"p\",\n// where b = A-2*B-C, c = 2*(B-A), d = A-p.\n// We want to find the global minimum of |f(t)|^2.\n// |f(t)|^2 has local extrema when d |f(t)|^2 / dt = 2*f(t).f'(t) = 0 <=> f(t).f'(t) = 0\n// (see http://ricedit.com/roots_of_quadratic.png).\n// We can derive that f(t).f'(t) = g(t) = 2b^2*t^3 + 3bc*t^2 + (2bd+c^2)*t + cd\n// Therefore g(t) = 0 is a cubic polynomial with 3 possible real roots at t in {t_1, t_2, t_3}.\n// Just by looking at http://mathworld.wolfram.com/CubicFormula.html,\n// we can see that roots can be found as follows:\n//  v = acos( x )/3 for some \"x\"\n//  assuming \"x\" can be anywhere within -1..1 range, v is between 0..pi/3 range\n//  t_1 = s*cos(v) - o, for some positive \"s\"\n//  t_2 = s*cos(v + 2pi/3) - o\n//  t_3 = s*cos(v + 4pi/3) - o\n// Now it is trivial (left as an excercise;)) to show that for all v in 0..pi/3:\n//  cos(v + 2pi/3) <= cos(v + 4pi/3) <= cos(v)\n// Therefore t_2 <= t_3 <= t_1.\n// We know that |f(t)|^2 has all local extrema at t_2, t_3 and t_1.\n// Therefore we have only two cases:\n//   1. We have local minima at t_1 and t_2 and local maximum at t_3\n//   2. We have local maxima at t_1 and t_2 and local minimum at t_3\n// By Fermat theorem, we know that extremum is a local maximum if second derivative is negative\n// (https://en.wikipedia.org/wiki/Derivative_test#Second_derivative_test_.28single_variable.29).\n// We can derive that g'(t) =  6b^2*t^2 + 6bc*t + 2bd+c^2\n// Assuming b!=0 (otherwise f(t) is a straight line, which is not interesting),\n// we know that 6b^2 > 0 and the parabola is opening up (going to +infinity at the boundaries),\n// therefore t_2 <= t_3 <= t_1 implies that g'(t_3) < max(g'(t_1), g'(t_2)).\n// This excludes case 2, where local maxima are at t_1 and t_2, \n// because g'(t_1) < 0 and g'(t_2) < 0 implies g'(t_3) < 0 and t_3 would have \n// to be local maximum as well, which is contradictory to this case.\n// The only case left is case 1, and local maximum obviously cannot be global minimum.\n// Q.E.D. ;)\n\n// Convenient implementation of cubic polynomial solver\n// https://www.shadertoy.com/view/ltXSDB by Adam Simmons, T21 and others\n// Additionally: returns number of roots\nvec4 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec4(vec3(offset + uv.x + uv.y), 1.0);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec4(vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset, 3.0);\n}\n\n// Find the signed distance from a point to a bezier curve without clamping\nvec2 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out vec4 rf)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec4 t = solveCubic(k.x, k.y, k.z);\n\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n    // note: 3rd root is unnecessary\n    \n  #if ROOT_DIAGRAM == 1\n    // return which root is closest, it's just for testing, otherwise can be removed\n    vec2 dp3 = d + (c + b*t.z)*t.z;\n    float d3 = dot(dp3, dp3);\n    vec3 rd = sqrt(vec3(d1,d2,d3)); rd -= min(min(rd.x,rd.y),rd.z);\n    rf = vec4(rd, t.w);\n  #endif\n\n    // Find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n\n    // Sign is just cross product with gradient\n    vec2 g = 2.*b*r.y + c;\n    float s =  sign(g.x*r.w - g.y*r.z);\n\n    return vec2(s*sqrt(r.x), r.y);\n}\n\nfloat sdSegment(vec2 a,vec2 b,vec2 p)\n{\n\tb -= a; p -= a;\n    return length(b*clamp(dot(p,b)/dot(b,b),0.,1.) - p);\n}\n\nfloat getRoots(vec2 A, vec2 B, vec2 C, vec2 p, out vec3 r[3])\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec4 t = solveCubic(k.x, k.y, k.z);\n    \n    r[0] = vec3(A + (c + b*t.x)*t.x, t.x);\n    r[1] = vec3(A + (c + b*t.y)*t.y, t.y);\n    r[2] = vec3(A + (c + b*t.z)*t.z, t.z);\n    return t.w;\n}\n\n// Define root colors:\nconst vec3 rcol0 = vec3(1.,.6,.1);\nconst vec3 rcol1 = vec3(.1,.8,.1);\nconst vec3 rcol2 = vec3(.1,.6,1.);\nconst vec3 rcol3 = vec3(.8,.2,.8); // special color if there is only 1 root\n\nvoid plotRoot(vec3 rt, vec2 m, vec2 p, float ss, vec3 rcol, inout vec4 col)\n{\n    vec2 rd = rt.xy - m;\n\tfloat w  = length((p - vec2(rt.z,dot(rd,rd)))/vec2(8.,32.));\n    float alpha = smoothstep(.009,.006,w)*(1.-col.w);\n    col += vec4(mix(rcol,vec3(0),smoothstep(.006-ss*.2,.006,w)),1)*alpha;\n}\n\n// Plot |f(t)|^2\nvec4 plotDistance(vec2 A, vec2 B, vec2 C, vec2 m, float rn, vec3 rt[3], vec2 fragCoord, float ss)\n{\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - m;\n    vec2 p = fragCoord/iResolution.x;\n    p = vec2(p.x*8. - .6, p.y*32. - 2.);\n    if (p.x > 2. || p.y > 6.) return vec4(0);\n    vec2 r = d + (c + b*p.x)*p.x;\n    vec4 col = vec4(0);\n    float w, alpha;\n    if (rn < 1.5) {\n        plotRoot(rt[0],m,p,ss,rcol3,col);\n    } else {\n        plotRoot(rt[0],m,p,ss,rcol0,col);\n        plotRoot(rt[1],m,p,ss,rcol1,col);\n        plotRoot(rt[2],m,p,ss,rcol2,col);\n    }\n    w = p.y-dot(r,r);\n    w = smoothstep(fwidth(w)*1.5,0.,abs(w))*(1.-col.w);\n    col += vec4(1)*w*.9;\n    return col;\n}\n\nfloat cross2(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = vec2(-0.8, +0.6);\n\n    // Get the signed distance to bezier curve\n    vec4 rf;\n    vec2 r = sdBezier(A, B, C, p, rf);\n    \n    // Anti-alias factor\n    float ss = 1.5/iResolution.y;\n\n    float s = smoothstep(-ss,ss,r.x)*2. - 1.; // smooth sign\n    s *= sign(cross2(B-C,A-C)); // flip sign to always be positive on \"inside\"\n\n  #if ROOT_DIAGRAM == 0\n    // show sign\n    fragColor = vec4(.5) - .5*s*vec4(0.1,0.4,0.8,1.0);\n    fragColor *= fragColor; // to linear-space (for correct blending)\n  #else\n    // Show root field\n    rf.xyz = clamp((1.-rf.xyz*.5/ss),0.,1.);\n    vec3 rcol = mix((rcol0*rf.x + rcol1*rf.y + rcol2*rf.z)/(rf.x + rf.y + rf.z + 1e-6),\n                    rcol3, 1.-(rf.w-1.)*.5);\n    fragColor = vec4(rcol*rcol*.6,1);\n  #endif\n\n    // Display distance isolines\n    fragColor *= 1. + smoothstep(.02+ss*28.,.02,abs(fract(22.*r.x+.5)-.5))*.5;\n\n    // Make negative sign slightly lighter\n    fragColor = mix(fragColor, vec4(1), (-s+1.)*.05);\n    \n    vec3 rt[3];\n    float rn = getRoots(A, B, C, m, rt);\n    \n    // Plot polynomial:\n    vec4 rp = plotDistance(A,B,C,m,rn,rt,fragCoord,ss);\n    fragColor = mix(fragColor, vec4(rp.xyz,1), rp.w);\n    \n    // Show AA curve.\n    fragColor = mix(vec4(1), fragColor, smoothstep(0.01,0.01+ss,abs(r.x)) );\n    \n    // Render root points to mouse cursor:\n    float pd = min(min(sdSegment(m,rt[0].xy,p), sdSegment(m,rt[1].xy,p)), sdSegment(m,rt[2].xy,p));\n    fragColor = mix(fragColor, vec4(1), (1.-smoothstep(.002,0.002+ss,abs(pd)))*.6 );\n    \n    float dm = distance(p, m);\n    float d0 = distance(p, rt[0].xy);\n    vec4 crt = (d0 < dm) ? vec4(rcol3,d0) : vec4(1.,.1,.1,dm);\n    if (rn > 2.5)\n    {\n        float d1 = distance(p, rt[1].xy);\n        float d2 = distance(p, rt[2].xy);\n        if (d0 < dm) crt = vec4(rcol0,d0);\n        if (d1 < crt.w) crt = vec4(rcol1,d1);\n        if (d2 < crt.w) crt = vec4(rcol2,d2);\n        \n        // Show that 3rd root is local maximum by drawing circle crossing it:\n        fragColor = mix(fragColor, vec4(1),\n                        smoothstep(ss*1.5,0.,abs(distance(p,m)-distance(m,rt[2].xy)))*.8);\n    }\n    fragColor = mix(vec4(1.0 - smoothstep(0.03-ss, 0.03, crt.w))*vec4(crt.xyz,1),\n                    fragColor, smoothstep(0.03, 0.04, crt.w));\n    \n    // Render the control points\n    pd = min(distance(p, A),(min(distance(p, B),distance(p, C))));\n    fragColor = mix(vec4(1.0 - smoothstep(0.03-ss, 0.03, pd)), \n                    fragColor, smoothstep(0.03, 0.04, pd));\n    \n    // Back to gamma-space\n    fragColor = sqrt(fragColor);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}