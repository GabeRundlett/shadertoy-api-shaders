{
    "Shader": {
        "info": {
            "date": "1520971899",
            "description": "Like [url]https://www.shadertoy.com/view/4sS3zz[/url], but with arcs. Use mouse to play with parameters, or click in bottom left corner to reset.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dyyR1",
            "likes": 21,
            "name": "Elliptical arc distance",
            "published": 3,
            "tags": [
                "distance",
                "quartic",
                "ellipse",
                "analytic",
                "exact"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 3123
        },
        "renderpass": [
            {
                "code": "/* \"Elliptical arc distance\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   This is similar to iq's \"Ellipse - Distance shader\"\n   at https://www.shadertoy.com/view/4sS3zz, except that \n   it can also compute distances to elliptical arcs (i.e. \n   circular arcs with nonuniform scaling along the x- and\n   y- axes). \n\n   I'm borrowing iq's awesome color scheme for visualizing \n   signed distance fields -- it really makes things pop and \n   also makes it easy to see when the SDF is incorrect.\n\n   This shader uses the quartic solver demonstrated in \n   https://www.shadertoy.com/view/XdKyRR to find all candidate\n   closest points on the ellipse to a given point; they are\n   then filtered against the given angular extents.   \n\n   See also \"Bezier - Signed Distance\" by ajs15822 at \n   https://www.shadertoy.com/view/ltXSDB which works similarly,\n   for a quadratic Bezier curve segment.\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n// closed-form solver from https://www.shadertoy.com/view/XdKyRR \n// but without special-case checks\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from angle around circle\n\nvec2 from_angle(float t) {\n    return vec2(cos(t), sin(t));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from cosine of angle\n\nvec2 from_cos(float u) {\n    u = clamp(u, -1., 1.);\n    return vec2(u, sqrt(1. - u*u));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct 2D vector perpendicular to input \n\nvec2 perp(vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\n//////////////////////////////////////////////////////////////////////\n// return whichever vector has smaller x-coordinate\n\nvec2 smaller_x(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// return distance from point p to ellipse centered at origin\n// with radii given by ab and angular limits given by alim.\n//\n// alim.x = start angle\n// alim.y = angular delta (use 0 or >2*PI for full ellipse)\n\nfloat ellipse_arc_dist(vec2 p, vec2 ab, vec2 alim) {\n    \n\t// constants    \n    const float PI = 3.141592653589793;\n    \n    // distance and sign\n    vec2 ds = vec2(1e5, -1);\n    \n    // needed for deciding sign for distance later\n    float orig_sign = -1.;\n    \n    // are we going all the way around ellipse?\n    bool full_ellipse = (alim[1] == 0. || abs(alim[1]) >= 2.*PI);\n\n    // construct unit vectors corresp. to start and end angles\n    vec2 n0 = from_angle(alim.x);\n    vec2 n1 = from_angle(alim.x + alim.y);\n\n    // determine some tangent vectors along ellipse at \n    // endpoints\n    float delta_sign = sign(alim.y);\n    vec2 t0 = -perp(n0)*delta_sign;\n    vec2 t1 = perp(n1)*delta_sign;\n    \n    // angular extents bigger than 1/2 rotation are\n    // treated differently than those less \n    float wedge_sign = 1.;\n    \n    if (abs(alim[1]) > PI) {\n        t0 = -t0;\n        t1 = -t1;\n        wedge_sign = -1.;\n    }\n\n    // determine endpoints of ellipse \n    vec2 p0 = ab * n0;\n    vec2 p1 = ab * n1;\n\n    // determine whether we are inside the wedge\n    // formed by the normal vectors at the endpoints\n    if (!full_ellipse) {\n        orig_sign = sign(max(dot(p - p0, ab.yx*n0), dot(p - p1, ab.yx*n1)));\n        ds = vec2(min(length(p - p0), length(p - p1)), orig_sign);\n    }\n    \n    \n    // circles need special-case handling because the quartic\n    // degenerates into a quadratic.    \n    if (abs((ab.x - ab.y) / ab.x) < 1e-2) {\n        \n        // a and b are pratically equal, so treat this as a circle\n        \n        float dc = length(p) - ab.x;\n        \n        if (full_ellipse || max(dot(p, t0), dot(p, t1))*wedge_sign <= .0) {\n            ds = smaller_x(ds, vec2(abs(dc), dc));\n        }\n        \n    } else {\n        \n        // general ellipse case\n        \n        // the quartic is numerically ill-conditioned\n        // near the y-axis, so keep on the nicely behaved\n        // side of the diagonal\n        if (abs(p.x) < abs(p.y)) {\n            p.xy = p.yx;\n            ab.xy = ab.yx;\n            t0 = t0.yx;\n            t1 = t1.yx;\n        }\n        \n        // formulate the quartic polynomial that represents\n        // this ellipse. we are solving for the position \n        // u = cos(theta) along the ellipse such that the\n        // tangent at the point [a*u, b*sqrt(1-u^2)] is \n        // perpendicular to the displacement between p\n        // and the point itself.\n        //\n        // there may be multiple valid solutions for this \n        // polynomial -- for a full ellipse we could just \n        // grab the maximal root but we actually need\n        // to inspect each of them in the arc case.\n        \n        float l = ab.y*ab.y - ab.x*ab.x;\n\n        float ax = ab.x*p.x / l;\n        float by = ab.y*p.y / l;\n\n        float a2x2 = ax*ax;\n        float b2y2 = by*by;\n\n        // vector of polynomial coefficients\n        vec4 coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);\n\n        // solve for up to 4 roots \n        vec4 roots;\n        solve_quartic(coeffs, roots);\n\n        // for each root\n        for (int i=0; i<4; ++i) {\n            \n            // construct point on unit circle\n            vec2 uv = from_cos(roots[i]);\n            \n            // need to check this point both above and below x-axis\n            for (int j=0; j<2; ++j) {\n                \n                // if we are considering the entire ellipse or\n                // the given uv is inside the angle clip region,\n                if (full_ellipse ||\n                    max(dot(uv, t0), dot(uv, t1))*wedge_sign <= .0) {\n                    \n                    // get the absolute distance to the closest point on \n                    // the ellipse, as well as its sign\n                    vec2 pc = ab*uv;\n                    ds = smaller_x(ds, vec2(length(p - pc), dot(p-pc, pc)));\n                    \n                }\n                \n                // mirror the root point across the x-axis\n                uv.y *= -1.;\n                \n            }\n        }\n        \n    }\n    \n    // combine the absolute distance with the sign of the \n    // distance, respecting original sign classification\n    // before root finding\n    return ds.x*max(sign(ds.y), orig_sign);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tfloat scl = 2.0 / iResolution.y;\n    \n    vec2 p = (fragCoord.xy - 0.5*iResolution.xy) * scl;\n    \n    vec2 ab = vec2(cos(iTime + 1.2)*.6 + .8, sin(iTime*0.1 - 0.5)*.2 + .6);\n    vec2 alim = vec2(0.5*iTime, 7.*cos(0.3*iTime));\n    \n    if (max(iMouse.x, iMouse.y) > 20.) {\n        \n        ab = abs(iMouse.xy - 0.5*iResolution.xy) * scl;\n        ab = max(ab, vec2(.125));    \n        alim = 16. * iMouse.xy / iResolution.xy - 8.;\n\n    }\n    \n    float d = ellipse_arc_dist(p, ab, alim);\n    \n    // iq's lovely color scheme\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n    fragColor = vec4(col, 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}