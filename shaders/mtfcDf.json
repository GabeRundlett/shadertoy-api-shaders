{
    "Shader": {
        "info": {
            "date": "1691256401",
            "description": "Pack it up",
            "flags": 32,
            "hasliked": 0,
            "id": "mtfcDf",
            "likes": 32,
            "name": "Colored Bubble Pack",
            "published": 3,
            "tags": [
                "bubble",
                "packing"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 394
        },
        "renderpass": [
            {
                "code": "// Colored Bubble Pack\n// by Leon Denise\n// 05/08/2023\n\n// inspired by stb with his amazing shape packing:\n// https://www.shadertoy.com/view/MdGGWt\n\n// this is a very naive understanding and implementation of distance packing\n// with a weird fancy light rendering so it feels a bit special\n\n// Buffer A: color pass\n// Buffer B: distance packing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    float radius = map.y;\n    vec2 pos = map.zw;\n    \n    // shape position\n    vec2 p = 2.*(uv-pos)*vec2(R.x/R.y,1);\n    float dist = length(p);\n    \n    // circle shape from distance\n    float shape = smoothstep(.0,-.01,dist-radius);\n    \n    // seed per shape\n    vec2 seed = floor(pos*R.xy);\n    \n    // uv per shape\n    uv = (p/radius)*.5+.5;\n    \n    // color palette\n    // by Inigo Quilez at\n    // https://iquilezles.org/articles/palettes/\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*5.+hash12(seed+196.)*6.+uv.x*1.5);\n    tint *= step(hash12(seed),.8);\n    \n    // normal randomized\n    vec3 ray = normalize(vec3(p*2., 1.-dist/radius));\n    ray = rndrot(ray, hash42(seed)*2.-1.);\n    \n    // the cubemap version (you'll have to load the texture)\n    //fragColor = vec4(shape*texture(iChannel2, ray).r*tint,1);\n    \n    float shade = dot(ray, vec3(0,1,0))*.5+.5;\n    \n    // the tint light version\n    //fragColor = vec4(tint*shape*shade,1);\n    \n    // the weird version\n    fragColor = vec4(shape*(mix(tint * pow(1.-shade, 10.), vec3(1), shade)),1);\n    \n    // the debug viewer\n    // fragColor = vec4(p/map.y, shape, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;\n    \n    // random\n    float t = float(iFrame)+iDate.x+iDate.y+iDate.z+iDate.w;\n    vec2 q = hash21(t);\n    \n    // position\n    p -= (q-.5)*2.*vec2(R.x/R.y,1);\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    vec4 d = texture(iChannel0, q);\n    float radius = d.x;\n    \n    // distance test\n    float dist = length(p)-radius;\n    \n    // if farer, choose previous result\n    if (map.x < dist)\n    {\n        dist = map.x;\n        radius = map.y;\n        q = map.zw;\n    }\n    \n    // init and reset\n    if (iFrame < 1 || mod(float(iFrame), 60.*40.) < 1.\n    \n    // resolution changed\n    || texture(iChannel0, vec2(0)).xy != iResolution.xy)\n    {\n        // border distance\n        float edge = min(min(abs(uv.y), abs(1.-uv.y)), min(abs(uv.x), abs(1.-uv.x)));\n        float maxRadius = .5;\n        \n        // make it special sometimes\n        dist = hash11(t) > .9 ? maxRadius : edge;\n        \n        // init/reset values\n        radius = maxRadius;\n        q = vec2(-1);\n    }\n    \n    // serve\n    fragColor = vec4(dist,radius,q);\n    \n    // store resolution so we can reset if it change the next frame\n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor = vec4(iResolution.xy, 0, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define R iResolution.xy\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// Blackle\n// https://suricrasia.online/blog/shader-functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd)\n{\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*acos(-1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}