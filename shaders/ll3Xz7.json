{
    "Shader": {
        "info": {
            "date": "1478884148",
            "description": "For today's #codevember, trying out some blob effect with a 3D Noise algo by Patricio Gonzalez Vivo https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83",
            "flags": 0,
            "hasliked": 0,
            "id": "ll3Xz7",
            "likes": 5,
            "name": "#codevember - 11",
            "published": 3,
            "tags": [
                "noise",
                "blob",
                "rotation"
            ],
            "usePreview": 0,
            "username": "jcksmssng",
            "viewed": 889
        },
        "renderpass": [
            {
                "code": "const float SURFACE_HIT_PRECISION = .001;\nconst float MAX_DIST = 10.;\nconst int MAX_STEPS = 100;\n\n// EyeRay Transformation Matrix from the great @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nmat3 rotateX( float angle )\n{\n    return mat3(1, 0, 0,\n                0, cos(angle), -sin(angle),\n                0, sin(angle), cos(angle));\n}\n\nmat3 rotateY( float angle )\n{\n    return mat3(cos(angle), 0, sin(angle),\n                0, 1, 0,\n                -sin(angle), 0, cos(angle));\n}\n\nmat3 rotateZ( float angle )\n{\n    return mat3(cos(angle), -sin(angle), 0,\n                sin(angle), cos(angle), 0,\n                0, 0, 1);\n}\n\nfloat map( float value, float oldMin, float oldMax, float newMin, float newMax ) \n{\n    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);\n}\n\n\nfloat mod289( float x )\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289( vec4 x )\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 perm(vec4 x) \n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat noise3(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nvec2 sphere ( vec3 ray ) \n{\n    vec3 orig = vec3( 0. , 0. , -3.0 );\n    vec3 dist = ray - orig;\n    dist *= rotateY( iTime );\n    float noise = noise3( ray ) * sin( iTime ) + sin( iTime / 2.0 );\n    dist += noise;\n    float radius = 1.1;\n   \tfloat le = length( dist ) - radius;\n    \n    float id = 1.;\n    \n\treturn vec2( le, id );\n}\n\n\nvec2 useShape( vec3 ray )\n{\n    return sphere( ray );\n}\n\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec2 checkRayHit( vec3 eyePos, vec3 rayDir )\n{\n  \tfloat distToSurface = SURFACE_HIT_PRECISION * 2.;\n    \n  \t// The total distance traveled by the ray obviously should start at 0\n  \tfloat totalDist = 0.;\n  \tfloat finalDist = 0.;\n    \n  \t// if our id is less that 0. , it means we haven't hit anything\n  \tfloat id = -1.;\n\n  \tfor( int i = 0; i < MAX_STEPS; i++ ) {\n    \t// Break if we hit the surface\n    \tif( distToSurface < SURFACE_HIT_PRECISION ) break;\n    \n    \t// Break if we reach end of the scene\n    \tif( totalDist > MAX_DIST ) break;\n    \n    \t// Current pos starts at eyePos then follows rayDir along the total distance traveled by the ray\n    \tvec3 currentPos = eyePos + rayDir * totalDist;\n    \tvec2 distToObj = useShape( currentPos );\n \t\n\t\tid = distToObj.y;\n        totalDist += distToObj.x;\n\t}\n\n  \tif( totalDist < MAX_DIST ) {\n  \t\tfinalDist = totalDist;\n  \t}\n\n  \tif( totalDist > MAX_DIST ){ \n  \t\tfinalDist = MAX_DIST;\n    \tid = -1.;\n  \t}\n\n  \treturn vec2( finalDist , id );\n}\n\n// Original function from @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 getSurfaceNormal( vec3 hitPos )\n{    \n\tvec3 x = vec3( 0.001, 0.0, 0.0 );\n    vec3 y = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 z = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX = useShape( hitPos + x ).x; \n    float downTinyChangeInX = useShape( hitPos - x ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = useShape( hitPos + y ).x; \n    float downTinyChangeInY = useShape( hitPos - y ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = useShape( hitPos + z ).x; \n    float downTinyChangeInZ = useShape( hitPos - z ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3( tinyChangeInX, tinyChangeInY, tinyChangeInZ );\n    \n\treturn normalize(normal);\n}\n\nvec3 bgColor(vec3 rayDir)\n{\n    float b = map(rayDir.x, -1., 1., 0., 1.);\n\treturn vec3( .18, .18, b );\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 objColor( vec3 hitPos, vec3 surfaceNormal )\n{\n    vec3 lightPos = vec3( 1. , 1. , 1. );\n\n    // Get direction of light relative to the hit\n    vec3 lightDir = lightPos - hitPos;\n    lightDir = normalize( lightDir );\n    \n    // The dot product of the lightDir to the surfaceNormal of the hit\n    // Gives us how much that hit is facing the light source\n    // -1: faces opposite\n    // 1: faces completely the light\n    float faceValue = dot( lightDir , surfaceNormal );\n    faceValue = max( 0.3 , faceValue );\n    \n    float b = map( hitPos.x, -1., 1., 0., .8 );\n    vec3 color = vec3( .18 , .18 , b );\n   \t\n    // here's how we do some shadowing !\n    color *= faceValue;\n\treturn color;\n}\n\n// Inspired by @cabbibo\n// https://www.shadertoy.com/view/Xl2XWt\nvec3 colorize( vec2 rayHitInfo, vec3 eyePos, vec3 rayDir )\n{\n    vec3 color;\n    \n  \tif( rayHitInfo.y < 0.0 ) {\n  \t\tcolor = bgColor(rayDir);  \n  \t} else {\n      \tvec3 hitPos = eyePos + rayHitInfo.x * rayDir;\n\n      \tvec3 surfaceNormal = getSurfaceNormal( hitPos );\n      \n      \tif( rayHitInfo.y >= 1. ){\n        \tcolor = objColor( hitPos , surfaceNormal ); \n      \t}\n  \t}\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fixes the aspect ratio to match a square frame\n\t// get values between -1 and +1 for the current pixel\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    fract(uv);\n    vec3 eyePos = vec3( 0., 0., 2.);\n    vec3 lookAt = vec3( 0. , 0. , 0. );\n  \n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePos, lookAt, 0. ); \n   \n    // For every pixel we throw a ray from the eye\n    vec3 ray = normalize( eyeTransformationMatrix * vec3( uv.xy , 2. ) ); \n    vec2 rayHitInfo = checkRayHit( eyePos , ray );\n    \n\tvec3 color = colorize( rayHitInfo, eyePos, ray );\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}