{
    "Shader": {
        "info": {
            "date": "1497326449",
            "description": "Wintergatan's Marble Machine\nhttps://www.youtube.com/watch?v=IvUU8joBb1Q\n\nCode borrowed from a few places, in particular:\nhttps://www.shadertoy.com/view/Xds3zN\nhttps://www.shadertoy.com/view/XsXSWN\n",
            "flags": 8,
            "hasliked": 0,
            "id": "lslfWn",
            "likes": 30,
            "name": "Marble Machine",
            "published": 3,
            "tags": [
                "raytracing",
                "sound",
                "softshadows",
                "loops"
            ],
            "usePreview": 1,
            "username": "hubbe",
            "viewed": 1091
        },
        "renderpass": [
            {
                "code": "#define TIME_OFFSET  0.0  // (0.5 - 3.0/iFrameRate)\n#define LIGHT_STRENGTH 0.6\n\n// AO\n// Optimize drums\n// Add rims to map2()\n// Optimize glock?\n// Optimize everything with loops?\n// soft ball shadows?\n// Unify map/trace data.\n\n// #define AA 2\n\n#define GLOCK_Z 60.0\n#define GLOCK_X -34.0\n#define GLOCK_KEY_SIZE 4.0\n\n#define BASE_Z 22.0\n\n#define MATERIAL_BG 0\n#define MATERIAL_CHROME 1\n#define MATERIAL_DARK 2\n#define MATERIAL_LIGHT 3\n#define MATERIAL_BRASS 4\n#define MATERIAL_DARK_PERL 5\n#define MATERIAL_DARK_WOOD 6\n#define MATERIAL_FLOOR 7\n\nfloat TIME = 0.0;\n\nstruct Ray {\n    vec3 start, dir;\n};\n\n\nfloat marble_dist;\nRay global_ray;\nvec3 marble_center;\n\nvoid marble(vec3 pos) {      \n    vec3 L = pos - global_ray.start;\n    float tca = dot(L, global_ray.dir);\n    if (tca < 0.0) return;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > 1.0) return;\n    float dist = tca - sqrt(1.0 - d2);\n    if (dist < marble_dist) {\n        marble_dist = dist;\n        marble_center = pos;\n    }\n}\n\nvoid Play(int n) {\n    float t = iTime - TIME - TIME_OFFSET;\n    float x = float(n)*GLOCK_KEY_SIZE + GLOCK_X;\n    float y = 16.0 - pow(4.0 - 8.0 * abs(t), 2.0);\n    float z = GLOCK_Z+t*80.0;\n    marble(vec3(x, y, z));\n}\n\n#define P(X) n=X\n   \nvoid play(int t) {\n    if (t < 0) return;\n  t %= 64;\n    \n  if (t % 4 == 2 && t != 50 && t != 54) {\n    Play( t <= 30 ? 0 : 7);\n    Play( t <= 14 ? 5 : 3);\n  }\n  int n = 0;\n  if (t == 0) P(17);\n  if (t == 3) P(12);\n  if (t == 7) P(10);\n  if (t == 8) P(8);\n  if (t == 9) P(10);\n  if (t == 11) P(12);\n  if (t == 13) P(8);\n  if (t == 14) P(10);\n  if (t == 15) P(15);\n  if (t == 19) P(12);\n  if (t == 23) P(10);\n  if (t == 24) P(8);\n  if (t == 25) P(10);\n  if (t == 27) P(7);\n  if (t == 29) P(8);\n  if (t == 30) P(10);\n  if (t == 31) P(15);\n  if (t == 35) P(12);\n  if (t == 39) P(15);\n  if (t == 40) P(13);\n  if (t == 41) P(12);\n  if (t == 43) P(10);\n  if (t == 45) P(8);\n  if (t == 46) P(10);\n  if (t == 47) P(5);\n  if (t == 49) P(1);\n  if (t == 50) P(5);\n  if (t == 51) P(12);\n  if (t == 52) P(0);\n  if (t == 53) P(1);\n  if (t == 54) P(3);\n  if (t == 55) P(15);\n  if (t == 56) P(13);\n  if (t == 57) P(12);\n  if (t == 59) P(10);\n  if (t == 61) P(8);\n  if (t == 62) P(10);\n  if (n != 0) Play(n);\n}\n#undef P\n\nvoid P2(vec3 pos, vec3 dir) {\n    float t = iTime - TIME - TIME_OFFSET;\n    pos.y += 16.0 - pow(4.0 - 8.0 * abs(t), 2.0);\n    pos += t * dir*50.0;\n    marble(pos);\n}\n\n#define SNARE_POS vec3(-5.0, -3.0, 35.0)\n#define KICK_POS vec3(20.0, -15.0, 30.0)\n#define CRASH_POS vec3(-20.0, 5.0, 25.0)\n\nvoid snare() { P2(SNARE_POS, vec3(1.6, 0.0, 0.4)); }\nvoid crash() { P2(CRASH_POS, vec3(1.0, 0.0, 1.0)); }\nvoid kick() {\n    vec3 pos = KICK_POS;\n    float t = iTime - TIME - TIME_OFFSET;\n    float bounce_t = 0.23;\n    pos.y += 20.0 - pow(4.0 + bounce_t * 8.0 - abs(8.0 * (t-bounce_t)), 2.0);\n    pos.x -= t * 20.0;\n    pos.z -= abs(t * 70.0);\n    marble(pos);\n}\n\nvoid kick_drum(int t) {\n  if (t >= 128) {\n      bool do_kick = false;\n    int T = t % 64;\n    if ((t % 16) == 0) do_kick = true;\n    if ((t % 16) == 13) do_kick = true;\n    if (t/16%4 == 3) {\n      if ((t % 16) == 2) do_kick = true;\n      if ((t % 16) == 7) do_kick = true;\n      if ((t % 16) == 10) do_kick = true;\n    } else {\n      if ((t % 16) == 4) do_kick = true;\n      if ((t % 16) == 8) do_kick = true;\n      if ((t % 32) == 11) do_kick = true;\n    }\n    if (do_kick) kick();\n  }\n}\n\nvoid drums(int t) {\n  if (t > 64) {\n       bool do_snare = false;\n    int T = t % 64;\n    if (T <= 48) {\n      if ((T % 4)== 2) do_snare = true;\n    } else if (T < 56) {\n      if ((T % 4)== 0) do_snare = true;\n    } else if (T == 57 || T == 60) {\n      do_snare = true;\n    }\n    if (do_snare) snare();\n  }\n  if (t % 128 == 0 && t > 0) crash();\n}\n\n#define B(X) n=X\n\nint last_note;\nfloat arm_pos;\n\nvoid base(int t) {\n  if (t < 128) return;\n  t = t % 128;\n  t += 128;\n  int n = 0;\n  if (t == 128) { B(7); }\n  if (t == 130) { B(19); }\n  if (t == 132) { B(31); }\n  if (t == 133) { B(19); }\n  if (t == 135) { B(43); }\n  if (t == 136) { B(19); }\n  if (t == 137) { B(7); }\n  if (t == 140) { B(22); }\n  if (t == 141) { B(24); }\n  if (t == 142) { B(26); }\n  if (t == 143) { B(29); }\n  if (t == 145) { B(22); }\n  if (t == 146) { B(10); }\n  if (t == 148) { B(22); }\n  if (t == 149) { B(10); }\n  if (t == 151) { B(41); }\n  if (t == 153) { B(34); }\n  if (t == 155) { B(22); }\n  if (t == 156) { B(21); }\n  if (t == 157) { B(22); }\n  if (t == 158) { B(24); }\n  if (t == 159) { B(29); }\n  if (t == 160) { B(14); }\n  if (t == 162) { B(14); }\n  if (t == 164) { B(26); }\n  if (t == 165) { B(14); }\n  if (t == 167) { B(14); }\n  if (t == 168) { B(26); }\n  if (t == 169) { B(14); }\n  if (t == 171) { B(26); }\n  if (t == 172) { B(26); }\n  if (t == 173) { B(14); }\n  if (t == 174) { B(17); }\n  if (t == 175) { B(19); }\n  if (t == 176) { B(15); }\n  if (t == 180) { B(27); }\n  if (t == 184) { B(17); }\n  if (t == 187) { B(29); }\n  if (t == 190) { B(31); }\n  if (t == 192) { B(7); }\n  if (t == 194) { B(19); }\n  if (t == 196) { B(31); }\n  if (t == 197) { B(7); }\n  if (t == 199) { B(43); }\n  if (t == 201) { B(31); }\n  if (t == 204) { B(19); }\n  if (t == 205) { B(22); }\n  if (t == 206) { B(24); }\n  if (t == 207) { B(29); }\n  if (t == 209) { B(22); }\n  if (t == 210) { B(10); }\n  if (t == 212) { B(22); }\n  if (t == 213) { B(10); }\n  if (t == 215) { B(41); }\n  if (t == 217) { B(34); }\n  if (t == 219) { B(22); }\n  if (t == 220) { B(21); }\n  if (t == 221) { B(22); }\n  if (t == 222) { B(24); }\n  if (t == 223) { B(29); }\n  if (t == 224) { B(14); }\n  if (t == 226) { B(14); }\n  if (t == 228) { B(26); }\n  if (t == 229) { B(14); }\n  if (t == 231) { B(14); }\n  if (t == 232) { B(26); }\n  if (t == 233) { B(14); }\n  if (t == 235) { B(24); }\n  if (t == 237) { B(22); }\n  if (t == 238) { B(21); }\n  if (t == 240) { B(12); }\n  if (t == 244) { B(24); }\n  if (t == 245) { B(12); }\n  if (t == 248) { B(14); }\n  if (t == 251) { B(26); }\n  if (t == 254) { B(14); }   \n  if (n != 0) {\n    last_note = n;\n    float t = iTime - TIME - TIME_OFFSET;\n      float frequency = 27.5 * pow(2.002, float(n) / 12.0);\n      float pos = -50.0 + 4000.0 / frequency;\n      if (t > 0.0) {\n          arm_pos = pos;\n      } else if (t > -0.1) {\n          arm_pos = mix(arm_pos, pos, 1.0 + t * 10.0);\n      }\n    float x = /* float(n)*2.0 */ - 40.0;\n    float y = 8.0 - pow(4.0 - 8.0 * abs(t), 2.0);\n    float z = BASE_Z + t*100.0;\n    marble(vec3(x, y, z));\n  }\n}\n\nvoid itermarbles() {\n    float tempo = 5.0;\n    int T = int(floor(iTime * tempo));\n    for (int i = -12; i < 5; i++) {\n        TIME = float(T + i) / tempo;\n        play(T + i);\n        drums(T + i);\n        base(T + i);\n        kick_drum(T + i);\n    }\n}\n\n#define NOHIT 20000.0\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    int material;\n};\n\nstruct SimpleCylinder {\n    vec2 pos;\n    float r;\n    int material;\n};\n            \nstruct Cylinder {\n    vec3 a, b;\n    float r;\n    int material;\n};\n    \nstruct CappedCylinder {\n    vec3 a, b;\n    float r;\n    int material;\n};\nstruct SimpleCappedCylinderX {\n\tvec3 pos;\n    float h;\n    float r;\n    int material;\n    int side_material;\n};\nstruct SimpleCappedCylinderY {\n\tvec3 pos;\n    float h;\n    float r;\n    int material;\n    int side_material;\n};\nstruct SimpleCappedCylinderZ {\n\tvec3 pos;\n    float h;\n    float r;\n    int material;\n    int side_material;\n};\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n    int material;\n};\n\nstruct Box {\n    vec3 pos;\n    vec3 dims;\n    int material;\n};\n    \nstruct RBox {\n   \tvec3 pos;\n\tvec3 dims;\n    float r;\n    int material;\n};\n      \nstruct Hit {\n    float dist;\n    vec3 normal;\n    int material;\n};\n    \nstruct Range {\n    Hit begin;\n    Hit end;\n};\n    \nHit FAR() {\n    return Hit(NOHIT, vec3(0), MATERIAL_BG);\n}\nHit NEAR() {\n    return Hit(0.0, vec3(0), MATERIAL_BG);\n}\n \nRange Everything() {\n    return Range(NEAR(), FAR());\n}\n\nRange Nothing() {\n    return Range(FAR(), NEAR());\n}\n\nHit Max(Hit a, Hit b) {\n    if (a.dist > b.dist)\n        return a;\n    else\n        return b;\n}\n\nHit Min(Hit a, Hit b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\nRange Intersect(Range a, Range b) {\n    return Range(Max(a.begin, b.begin),\n                 Min(a.end, b.end));\n}\n\nbool Empty(Range a) {\n    return a.begin.dist >= a.end.dist;\n}\n\n// Note, Union and Subtract should technically return multiple\n// ranges in many cases. This can becomes a problem if you want to do\n// further intersections/subtractions on the result.\n// Basically, the rule of thumb is that only convex objects can be intersected\n// or subtracted.\n\nRange Union(Range a, Range b) {\n    if (Empty(a)) return b;\n    if (Empty(b)) return a;\n    return Range(Min(a.begin, b.begin),\n                 Max(a.end, b.end));\n}\n\nHit Invert(Hit hit) {\n    return Hit(hit.dist, -hit.normal, hit.material);\n}\n\nHit Range2Hit(Range r) {\n    if (r.begin.dist >= r.end.dist) return FAR();\n    if (r.end.dist <= 0.0) return FAR();\n    if (r.begin.dist <= 0.0) return NEAR();\n    return r.begin;\n}\n\n\nRange Subtract(Range a, Range b) {\n    if (Empty(b) || Empty(a)) return a;\n    Range ret = Range(a.begin, Invert(b.begin));\n    if (!Empty(ret)) return ret;\n    return Range(Invert(b.end), a.end);\n}\n\nRange TracePlane(Ray ray, Plane o) {\n    vec3 pos = o.pos;\n    vec3 normal = o.normal;\n    float tmp = dot(pos - ray.start, normal);\n   \tfloat div = dot(ray.dir, normal);\n    if (div == 0.0) {\n        if (tmp > 0.0) {\n            return Everything();\n        } else {\n            return Nothing();\n        }\n    }\n    float dist = tmp / div;\n    if (div > 0.0) {\n        return Range(NEAR(), Hit(dist, normal, o.material));\n    } else {\n        return Range(Hit(dist, normal, o.material), FAR());\n    }\n}\n\nvec3 Project( vec3 a, vec3 b )\n{\n\treturn a - b * dot(a, b);\n}\n\nfloat SQ(vec3 x) { return dot(x,x); }\n\n\nRange TraceCylinder(Ray ray, Cylinder o) {\n    vec3 cylinder_dir = normalize(o.b - o.a);\n\t\n\tvec3 offset = o.a - ray.start;\n\t\n\tvec3 projected_offset = Project(offset, cylinder_dir);\n\tvec3 projected_dir = Project(ray.dir, cylinder_dir);\n\tfloat scale = length(projected_dir);\n\tprojected_dir /= scale;\n\t\n\t// intersect circle in projected space\n\t\n\tfloat fTClosest = dot(projected_offset, projected_dir);\n\t\n\tvec3 vClosest = projected_dir * fTClosest;\n\tfloat fDistClosest = length(vClosest - projected_offset);\n\tif(fDistClosest > o.r) return Nothing();\n\tfloat fHalfChordLength = sqrt(o.r * o.r - fDistClosest * fDistClosest);\n    float d1 = (fTClosest - fHalfChordLength) / scale;\n    float d2 = (fTClosest + fHalfChordLength) / scale;\n\treturn Range(Hit(d1, projected_dir * (fTClosest - fHalfChordLength) - projected_offset, o.material),\n                 Hit(d2, projected_dir * (fTClosest + fHalfChordLength) - projected_offset, o.material));\n}\n\nRange TraceSimpleCylinder(Ray ray, SimpleCylinder o) {\n    // Like sphere, but only use x & z\n    vec2 dir = normalize(ray.dir.xz);\n    vec2 L = o.pos - ray.start.xz;\n    float tca = dot(L, dir);\n    float d2 = dot(L, L) - tca * tca;\n    float toroot = o.r * o.r - d2;\n    if (toroot < 0.0001) return Nothing();\n    float thc = sqrt(toroot);\n    float p1 = tca - thc;\n    float p2 = tca + thc;\n    vec2 n1 = (dir * p1 - L) / o.r;\n    vec2 n2 = (dir * p2 - L) / o.r;\n    p1 *= length(ray.dir) / length(ray.dir.xz);\n    p2 *= length(ray.dir) / length(ray.dir.xz);\n    return Range(Hit(p1, vec3(n1.x, 0, n1.y), o.material),\n                 Hit(p2, vec3(n2.x, 0, n2.y), o.material));\n}\n\nRange cut(Range hit, Ray ray, vec3 p, vec3 n, int material) {\n    return Intersect(hit, TracePlane(ray, Plane(p, n, material)));\n}\n\nRange TraceSimpleCappedCylinderZ(Ray ray, SimpleCappedCylinderZ o) {\n    Range ret = TraceSimpleCylinder(Ray(ray.start.xzy,ray.dir.xzy),\n                      SimpleCylinder(o.pos.xy, o.r, o.side_material));\n    if (Empty(ret)) return ret;\n    ret = Range(Hit(ret.begin.dist, ret.begin.normal.xzy, ret.begin.material),\n                Hit(ret.end.dist, ret.end.normal.xzy, ret.begin.material));\n    ret = cut(ret, ray, o.pos + vec3(0,0,1)*o.h, vec3(0,0,1), o.material);\n    ret = cut(ret, ray, o.pos - vec3(0,0,1)*o.h, vec3(0,0,-1), o.material);\n    return ret;\n}\nRange TraceSimpleCappedCylinderY(Ray ray, SimpleCappedCylinderY o) {\n    Range ret = TraceSimpleCylinder(ray, SimpleCylinder(o.pos.xz, o.r, o.side_material));\n    if (Empty(ret)) return ret;\n    ret = cut(ret, ray, o.pos + vec3(0,1,0)*o.h, vec3(0,1,0), o.material);\n    ret = cut(ret, ray, o.pos - vec3(0,1,0)*o.h, vec3(0,-1,0), o.material);\n    return ret;\n}\nRange TraceSimpleCappedCylinderX(Ray ray, SimpleCappedCylinderX o) {\n    Range ret = TraceSimpleCylinder(Ray(ray.start.yxz, ray.dir.yxz),\n                      SimpleCylinder(o.pos.yz, o.r, o.side_material));\n    if (Empty(ret)) return ret;\n    ret = Range(Hit(ret.begin.dist, ret.begin.normal.yxz, ret.begin.material),\n                Hit(ret.end.dist, ret.end.normal.yxz, ret.end.material));\n    ret = cut(ret, ray, o.pos + vec3(1,0,0)*o.h, vec3(1,0,0), o.material);\n    ret = cut(ret, ray, o.pos - vec3(1,0,0)*o.h, vec3(-1,0,0), o.material);\n    return ret;\n}\n\n#if 1\n\nRange TraceCappedCylinder(Ray ray, CappedCylinder o) {\n    Range ret = TraceCylinder(ray, Cylinder(o.a, o.b, o.r, o.material));\n    if (Empty(ret)) return ret;\n    ret = cut(ret, ray, o.a, normalize(o.a - o.b), o.material);\n    ret = cut(ret, ray, o.b, -normalize(o.a - o.b), o.material);\n    return ret;\n}\n\n#else\nRange Trace(Ray ray, CappedCylinder o) {\n\tvec3 y = normalize(o.b - o.a);\n    float h = length(o.b - o.a) / 2.0;\n    vec3 offset = (o.a + o.b) / 2.0;\n    vec3 x = y.yzx;\n    vec3 z = y.zxy;\n    mat3 m2 = mat3(x,y,z);\n    mat3 m = inverse(m2);\n    Range ret = Trace(Ray(m * (ray.start - offset), m * ray.dir),\n\t\t              SimpleCappedCylinderY(vec3(0,0,0), h, o.r));\n    if (!Empty(ret)) {\n        mat3 m2 = transpose(m2);\n        ret = Range(Hit(ret.begin.dist, m2 * ret.begin.normal),\n                    Hit(ret.end.dist, m2 * ret.end.normal));\n\n    }\n    return ret;   \n}\n#endif\n\nRange TraceSphere(Ray ray, Sphere o)\n{\n    vec3 L = o.pos - ray.start;\n    float tca = dot(L, ray.dir);\n    if (tca < 0.0) return Nothing();\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > o.radius * o.radius) return Nothing();\n    float root = sqrt(o.radius * o.radius - d2);\n    return Range(Hit(tca - root, ray.start + (tca - root) * ray.dir - o.pos, o.material),\n                   Hit(tca + root, ray.start + (tca + root) * ray.dir - o.pos, o.material));\n}\n\nRange Trace(Ray ray, Box o) {\n    vec3 x = vec3(1,0,0);\n    vec3 y = vec3(0,1,0);\n    vec3 z = vec3(0,0,1);\n   \tPlane planes[6] = Plane[6](\n        Plane(o.pos - x * o.dims.x, -x, o.material),\n        Plane(o.pos + x * o.dims.x, x, o.material),\n        Plane(o.pos - y * o.dims.y, -y, o.material),\n        Plane(o.pos + y * o.dims.y, y, o.material),\n        Plane(o.pos - z * o.dims.z, -z, o.material),\n        Plane(o.pos + z * o.dims.z, z, o.material) );\n        \n    Range ret = Everything();\n    for (int i = 0; i < 6; i++) {\n        ret = Intersect(ret, TracePlane(ray, planes[i]));\n    }\n    return ret;\n}\n\nfloat udBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0)) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nstruct GlockN {\n   float Q;\n};\n\n#define GEN_GETNORMAL(X)                          \\\nvec3 getNormal(vec3 p, X o) {                     \\\n  float E = 0.0001;                               \\\n  vec3 X = vec3(E,0.0,0.0);                       \\\n  vec3 Y = vec3(0.0,E,0.0);                       \\\n  vec3 Z = vec3(0.0,0.0,E);                       \\\n  float D = map(p, o);                            \\\n  return normalize(vec3(map(p + X, o) - D,        \\\n                        map(p + Y, o) - D,        \\\n                        map(p + Z, o) - D));      \\\n}\n\n\nfloat map(vec3 p, GlockN o) {\n    int n = int(floor((p.x - GLOCK_X + 2.0)/4.0));\n    if (n < 0) n = 0;\n    if (n > 17) n = 17;\n    float glockdist = udBox(p + vec3(-(float(n)*GLOCK_KEY_SIZE + GLOCK_X), 1.1, - GLOCK_Z),\n                            vec3(1.5, 0.1, 19.0 - float(n)), 0.05);\n    if (n > 0) {\n        n = n - 1;\n        glockdist = min(glockdist, udBox(p + vec3(-(float(n)*GLOCK_KEY_SIZE + GLOCK_X), 1.1, - GLOCK_Z),\n                            vec3(1.5, 0.1, 19.0 - float(n)), 0.05));\n    }\n    return glockdist;\n}\n\nGEN_GETNORMAL(GlockN)\n\nHit Trace(Ray ray, GlockN o) {\n    vec3 glock_pos = vec3(GLOCK_X + GLOCK_KEY_SIZE * 17.0 / 2.0, -1.1, GLOCK_Z);\n    vec3 glock_dims = vec3(GLOCK_KEY_SIZE * 17.0, 0.2, 19.0);\n    Range tmp = Trace(ray, Box(glock_pos, glock_dims, MATERIAL_BRASS));\n    if (Empty(tmp)) return FAR();\n\n\tfloat dist = Range2Hit(tmp).dist;\n    float MAX = dist + length(glock_dims);\n    for (int i = 0; i < 100; i++) {\n        float tmp = map(ray.start + dist * ray.dir, o);\n        dist += tmp;\n        if (tmp > MAX) return FAR();\n        if (tmp < 0.00001 * dist) {\n            vec3 n = getNormal(ray.start + ray.dir * dist, o);\n\t\t    if (dot(n, ray.dir) > 0.0) return FAR(); \n  \t\t\treturn Hit(dist, n, MATERIAL_BRASS);            \n        }\n    }\n  \treturn FAR();\n}\n\nfloat map(vec3 p, RBox o) {\n    return udBox(p - o.pos, o.dims, o.r);\n}\n\nGEN_GETNORMAL(RBox)\n\n\nHit Trace(Ray ray, RBox o) {\n    Range tmp = Trace(ray, Box(o.pos, o.dims + vec3(o.r), o.material));\n    if (Empty(tmp)) return FAR();\n\n\tfloat dist = Range2Hit(tmp).dist;\n    float MAX = dist + length(o.dims);\n    for (int i = 0; i < 100; i++) {\n        float tmp = map(ray.start + dist * ray.dir, o);\n        dist += tmp;\n        if (tmp > MAX) return FAR();\n        if (tmp < 0.00001 * dist) {\n            vec3 n = getNormal(ray.start + ray.dir * dist, o);\n\t\t    if (dot(n, ray.dir) > 0.0) return FAR(); \n  \t\t\treturn Hit(dist, n, o.material);            \n        }\n    }\n  \treturn FAR();\n}\n\nstruct Cymbal {\n    vec3 pos;\n    float r;\n    int material;\n};\n    \nfloat map(vec3 pos, Cymbal c) {\n    vec3 A = c.pos;\n    float ball_radius = c.r * 5.0;\n    float bump_radius = c.r / 4.0;\n    A.y -= ball_radius + bump_radius / 3.0;\n    vec3 B = A;\n    B.y -= 0.05;\n    vec3 C = c.pos;\n    C.y -= bump_radius;\n    float l1 = length(pos - A) - ball_radius;\n    float l2 = length(pos - B) - ball_radius;\n    float l3 = length(pos - C) - bump_radius;\n    float l4 = length(pos - C) - c.r; \n    return max(max(min(l1, l3), -l2), l4);\n//    float b = length(pos - B) - ball_radius;\n//    return min(a, -b);\n}\n\nGEN_GETNORMAL(Cymbal)\n\nHit Trace(Ray ray, Cymbal o) {\n    #if 1\n    vec3 A = o.pos;\n    float ball_radius = o.r * 5.0;\n    float bump_radius = o.r / 4.0;\n    A.y -= ball_radius + bump_radius / 3.0;\n    vec3 B = A;\n    B.y -= 0.05;\n    vec3 C = o.pos;\n    C.y -= bump_radius;\n    Range r4 = TraceSphere(ray, Sphere(C, o.r, o.material));\n    if (Empty(r4)) return FAR();\n    Range r1 = TraceSphere(ray, Sphere(A, ball_radius, o.material));\n    Range r2 = TraceSphere(ray, Sphere(B, ball_radius, o.material));\n    Range r3 = TraceSphere(ray, Sphere(C, bump_radius, o.material));\n//\treturn Subtract(Union(Intersect(r1, r4), r3), r2).begin;\n//\treturn Intersect(r1, r4).begin;\n    return Range2Hit(\n        Union(\n\t        Subtract(Intersect(r1, r4), r2),\n            Subtract(r3, r2)));\n//  \treturn Subtract(r4, r2).begin;  \n    #else\n    \n    \n\t#if 1\n    float ball_radius = o.r * 5.0;\n    float bump_radius = o.r / 4.0;\n    Range tmp = TraceSphere(ray, Sphere(o.pos - vec3(0,bump_radius,0), ball_radius, o.material));\n    if (Empty(tmp)) return FAR();\n\tfloat dist = Range2Hit(tmp).dist;\n    float MAX = dist + ball_radius * 2.0;\n    #else\n    float dist = 0.0;\n    float MAX = dist + 10000.0;\n    #endif\n\n    for (int i = 0; i < 100; i++) {\n        float tmp = map(ray.start + dist * ray.dir, o);\n        dist += tmp;\n        if (tmp > MAX) return FAR();\n        if (tmp < 0.00001 * dist) {\n            vec3 n = getNormal(ray.start + ray.dir * dist, o);\n\t\t    if (dot(n, ray.dir) > 0.0) return FAR(); \n  \t\t\treturn Hit(dist, n, o.material);            \n        }\n    }\n  \treturn FAR();\n    #endif\n}\n\nfloat sdDrum(vec3 p, vec2 h) {\n    float bbox = sdCappedCylinder(p, h + vec2(0.1, 0.5));\n    float sub1 = sdCappedCylinder(p, h + vec2(0.2, -0.5));\n    float sub2 = sdCappedCylinder(p, h + vec2(-0.1, 0.6));\n    float body = sdCappedCylinder(p, h);\n    return min(body, max(max(bbox, -sub1), -sub2));\n}\n\nfloat map2(vec3 p, out int o) {\n\tfloat ret = udBox(p - vec3(0.0,-11.0, BASE_Z), vec3(53.0,1.0,2.0), 0.06);\n    ret = min(ret, map(p, GlockN(1.0)));\n\tfloat snaredist = sdDrum(p - SNARE_POS - vec3(0.0,-4.0,0.0), vec2(8.0, 3.0));\n\tfloat snaredist2 = sdCappedCylinder(p - SNARE_POS - vec3(0.0,-18.0,0.0), vec2(0.5, 15.0));\n//\tfloat crashdist = sdCappedCylinder(p - CRASH_POS - vec3(0.0,-1.0,3.0), vec2(5.0, 0.1));   \n    float crashdist = map(p,  Cymbal(CRASH_POS + vec3(0,0,3), 5.0, MATERIAL_BRASS));\n    float crashdist2 = sdCappedCylinder(p - CRASH_POS - vec3(0.0,-19.0,3.0), vec2(0.2, 20.0));\n    float grounddist = sdCappedCylinder(p - vec3(0.0,-130.0,50.0), vec2(100.0, 100.0));\n    float basedist = sdCappedCylinder((p - vec3(0.0,-9.0,BASE_Z)).yxz, vec2(0.15, 50.0));\n    float armdist = sdCappedCylinder((p - vec3(arm_pos, -8.0, BASE_Z)).xzy, vec2(0.85, 3.0));;\n    float leg1 = sdCappedCylinder(p - vec3(25,-18, GLOCK_Z), vec2(0.75, 15.0));\n    float leg2 = sdCappedCylinder(p - vec3(-25,-18, GLOCK_Z), vec2(0.75, 15.0));\n    float leg3 = sdCappedCylinder(p - vec3(50,-23, BASE_Z), vec2(0.75, 15.0));\n    float leg4 = sdCappedCylinder(p - vec3(-50,-23, BASE_Z), vec2(0.75, 15.0));\n     \n    vec3 tmp = (p - KICK_POS);\n    tmp = vec3(tmp.x, -tmp.z, tmp.y);\n    float kickdist = sdDrum(tmp - vec3(0.0,-9.0,0.0), vec2(15.0, 8.0));\n    ret = min(ret, kickdist);\n\n    ret = min(ret, leg1);\n    ret = min(ret, leg2);\n    ret = min(ret, leg3);\n    ret = min(ret, leg4);\n    ret = min(ret, armdist);\n    ret = min(ret, basedist);\n    ret = min(ret, grounddist);\n    ret = min(ret, min(crashdist, crashdist2));\n    ret = min(ret, snaredist2);\n    ret = min(ret, snaredist);\n    return ret;\n}\n\n\nfloat marble_ray(Ray ray) {\n    global_ray = ray;\n    marble_dist = 1000000.0;\n    itermarbles();\n    return marble_dist;\n}\n\nHit Trace(Ray r) {\n    global_ray = r;\n    marble_dist = 1000000.0;\n    itermarbles();\n\n#if 0  \n    Range ret = TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,9), 8.0, 15.0, MATERIAL_LIGHT, MATERIAL_DARK_PERL));\n\n    Range base_rim1 = TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,1), 0.5, 15.2, MATERIAL_CHROME, MATERIAL_CHROME));\n    Range base_rim2 = TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,1), 0.6, 14.8, MATERIAL_CHROME, MATERIAL_CHROME));\n\n    Range base_rim3 = TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,17), 0.5, 15.2, MATERIAL_CHROME, MATERIAL_CHROME));\n    Range base_rim4 = TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,17), 0.6, 14.8, MATERIAL_CHROME, MATERIAL_CHROME));\n    ret = Union(ret, Subtract(base_rim1, base_rim2));\n    ret = Union(ret, Subtract(base_rim3, base_rim4));\n#else\n    Range ret = TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,9), 8.5, 15.2, MATERIAL_CHROME, MATERIAL_CHROME));\n    if (!Empty(ret)) {\n      ret = Subtract(ret, TraceSimpleCappedCylinderZ(r,\n          SimpleCappedCylinderZ(KICK_POS + vec3(0,0,9), 8.6, 14.8, MATERIAL_CHROME, MATERIAL_CHROME)));      \n      ret = Subtract(ret, TraceSimpleCappedCylinderZ(r,\n          SimpleCappedCylinderZ(KICK_POS + vec3(0,0,9), 7.5, 15.3, MATERIAL_CHROME, MATERIAL_CHROME)));      \n\n      ret = Union(ret, TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(KICK_POS + vec3(0,0,9), 8.0, 15.0, MATERIAL_LIGHT, MATERIAL_DARK_PERL)));\n    }\n#endif\n    \n#if 1\n    Range snare = TraceSimpleCappedCylinderY(r, \n            SimpleCappedCylinderY(SNARE_POS + vec3(0, -4, 0), 3.5, 8.2, MATERIAL_CHROME, MATERIAL_CHROME));\n    if (!Empty(snare)) {\n        snare = Subtract(snare, TraceSimpleCappedCylinderY(r,\n            SimpleCappedCylinderY(SNARE_POS + vec3(0, -4, 0), 3.6, 7.8, MATERIAL_CHROME, MATERIAL_CHROME)));\n        snare = Subtract(snare, TraceSimpleCappedCylinderY(r,\n            SimpleCappedCylinderY(SNARE_POS + vec3(0, -4, 0), 2.5, 8.3, MATERIAL_CHROME, MATERIAL_CHROME)));\n        snare = Union(snare, TraceSimpleCappedCylinderY(r,\n            SimpleCappedCylinderY(SNARE_POS + vec3(0, -4, 0), 3.0, 8.0, MATERIAL_LIGHT, MATERIAL_DARK_PERL)));\n        ret = Union(ret, snare);\n    }\n#else\n    Range snare_rim1 = TraceSimpleCappedCylinderY(r,\n        SimpleCappedCylinderY(SNARE_POS + vec3(0,-1,0), 0.5, 8.2, MATERIAL_CHROME, MATERIAL_CHROME));\n    Range snare_rim2 = TraceSimpleCappedCylinderY(r,\n        SimpleCappedCylinderY(SNARE_POS + vec3(0,-1,0), 0.6, 7.8, MATERIAL_CHROME, MATERIAL_CHROME));\n\n    Range snare_rim3 = TraceSimpleCappedCylinderY(r,\n        SimpleCappedCylinderY(SNARE_POS + vec3(0,-7,0), 0.5, 8.2, MATERIAL_CHROME, MATERIAL_CHROME));\n    Range snare_rim4 = TraceSimpleCappedCylinderY(r,\n        SimpleCappedCylinderY(SNARE_POS + vec3(0,-7,0), 0.6, 7.8, MATERIAL_CHROME, MATERIAL_CHROME));\n    ret = Union(ret, Subtract(snare_rim1, snare_rim2));\n    ret = Union(ret, Subtract(snare_rim3, snare_rim4));\n #endif\n\n\n    ret = Union(ret, TraceSimpleCappedCylinderX(r,\n        SimpleCappedCylinderX(vec3(0,-9, BASE_Z), 50.0, 0.15, MATERIAL_DARK, MATERIAL_DARK)));\n\n    \n    // Glock supports\n    ret = Union(ret, TraceCappedCylinder(r, CappedCylinder(vec3(36,-1.8,GLOCK_Z-1.0),\n                                             vec3(-36,-1.8,GLOCK_Z-18.0),\n                                             0.5, MATERIAL_DARK)));\n    ret = Union(ret, TraceCappedCylinder(r, CappedCylinder(vec3(36,-1.8,GLOCK_Z+1.0),\n                                            vec3(-36,-1.8,GLOCK_Z+18.0), 0.5, MATERIAL_DARK)));\n \n    SimpleCappedCylinderY CY[7] = SimpleCappedCylinderY[](\n//        SimpleCappedCylinderY(SNARE_POS + vec3(0, -4, 0), 3.0, 8.0, MATERIAL_LIGHT, MATERIAL_DARK_PERL),\n        SimpleCappedCylinderY(SNARE_POS + vec3(0, -18, 0), 15.0, 0.5, MATERIAL_CHROME, MATERIAL_CHROME),\n        SimpleCappedCylinderY(CRASH_POS + vec3(0, -19, 3), 20.0, 0.2, MATERIAL_CHROME, MATERIAL_CHROME),\n        SimpleCappedCylinderY(vec3(0, -130, 50), 100.0, 100.0, MATERIAL_FLOOR, MATERIAL_DARK),\n        SimpleCappedCylinderY(vec3(50,-23, BASE_Z), 15.0, 0.75, MATERIAL_CHROME, MATERIAL_CHROME),\n        SimpleCappedCylinderY(vec3(-50,-23, BASE_Z), 15.0, 0.75, MATERIAL_CHROME, MATERIAL_CHROME),\n        SimpleCappedCylinderY(vec3(25,-18, GLOCK_Z), 15.0, 0.75, MATERIAL_CHROME, MATERIAL_CHROME),\n        SimpleCappedCylinderY(vec3(-25,-18, GLOCK_Z), 15.0, 0.75, MATERIAL_CHROME, MATERIAL_CHROME)\n        );\n    for (int i = 0; i < 7; i++) {\n        ret = Union(ret, TraceSimpleCappedCylinderY(r, CY[i]));\n    }\n\n    ret = Union(ret, TraceSimpleCappedCylinderZ(r,\n        SimpleCappedCylinderZ(vec3(arm_pos, -8, BASE_Z), 3.0, 0.85, MATERIAL_CHROME, MATERIAL_CHROME)));    \n\n    #if 1\n    Range arm = TraceSimpleCappedCylinderX(r,\n                       SimpleCappedCylinderX(vec3(arm_pos, -12, BASE_Z + 2.0),\n                                             1.0, 1.5, MATERIAL_CHROME, MATERIAL_CHROME));\n    arm = Subtract(arm, Trace(r, Box(vec3(arm_pos, -10, BASE_Z + 2.0),\n                                        vec3(2,2,2), MATERIAL_CHROME)));\n    arm = Subtract(arm, TraceSimpleCappedCylinderX(r,\n                       SimpleCappedCylinderX(vec3(arm_pos, -12, BASE_Z + 2.0),\n                                             2.0, 1.0, MATERIAL_CHROME, MATERIAL_CHROME)));\n    arm = Union(arm, Trace(r, Box(vec3(arm_pos, -9.5, BASE_Z + 3.25),\n                                        vec3(1, 2.5, 0.25), MATERIAL_CHROME)));\n\tret = Union(ret, arm);\n    #endif\n    Hit h = Range2Hit(ret);\n\n    h = Min(h, Trace(r, Cymbal(CRASH_POS + vec3(0,0,3), 5.0, MATERIAL_BRASS)));\n    h = Min(h, Trace(r, GlockN(0.0)));\n    h = Min(h, Trace(r, RBox(vec3(0.0,-11.0, BASE_Z), vec3(53.0,1.0,2.0), 0.1, MATERIAL_DARK_WOOD)));\n\n    if (marble_dist < h.dist) {\n        vec3 hp = r.start + r.dir * marble_dist;\n        return Hit(marble_dist, hp - marble_center, MATERIAL_CHROME);\n    }\n    return h;\n}\n\n\n\nvec3 getNormal2(vec3 p) {\n  float E = 0.0001;\n  vec3 X = vec3(E,0.0,0.0);\n  vec3 Y = vec3(0.0,E,0.0);\n  vec3 Z = vec3(0.0,0.0,E);\n  int o;\n  float D = map2(p, o);\n  return normalize(vec3(map2(p + X, o) - D,\n                        map2(p + Y, o) - D,\n                        map2(p + Z, o) - D));\n}\n\n\nfloat softshadow(Ray ray) {\n    float dist = 0.001;\n    float ret = 1.0;\n    for (int i = 0; i < 100; i++) {\n        int o;\n        float tmp = map2(ray.start + dist * ray.dir, o);\n        ret = min(ret, 30.0 * tmp / dist);\n        if (ret < 0.01 || dist > 200.0) break;\n        dist += clamp(tmp, 0.01, 1.0);\n    }\n    return clamp(ret, 0.0, 1.0);\n}\n\nfloat AO(Ray ray) {\n\t// Doesn't work very well, needs tuning or something.\n    #if 1\n    return 1.0;\n    #else\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float dist = 0.1 + 0.5 * float(i);\n        int o;\n        float tmp = map2(ray.start + dist * ray.dir, o);\n        occ += -(tmp - dist) * sca;\n        sca *= 0.65;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n    #endif\n}\n\nvec3 light;\n\nstruct Material {\n    float albedo;\n    float reflectance;\n    vec3 color;\n};\n\nMaterial getMaterial(Hit h, vec3 hp) {\n    #if 1\n    if (h.material == MATERIAL_CHROME)\n\t    return Material(0.3, 0.5, vec3(1,0.7,0.7));\n     if (h.material == MATERIAL_BRASS)\n\t    return Material(0.5, 0.2, vec3(1,0.7,0.1));\n    if (h.material == MATERIAL_DARK)\n\t    return Material(0.1, 0.1, vec3(1,0.7,0.7));\n    if (h.material == MATERIAL_DARK_PERL) {\n      vec4 color = 5.0 * texture(iChannel1, vec2(hp.x, (hp.z + hp.y)/2.0) / 7.0);\n      return Material(0.2, 0.2, color.xyz);\n    }\n    if (h.material == MATERIAL_DARK_WOOD) {\n      vec4 color = vec4(3,4,4,1) * texture(iChannel2, vec2(hp.z + hp.y/10.0 + hp.z/10.0, hp.y) / 7.0);\n      return Material(0.1, 0.1, color.xyz);\n    }\n    if (h.material == MATERIAL_FLOOR) {\n      vec4 color = 5.0 * texture(iChannel3, vec2(hp.x/5.0, (hp.z + hp.x)/6.0) / 7.0);\n      return Material(0.5, 0.2, color.xyz);\n    }\n    #endif\n    return Material(1.4, 0.0, vec3(1,1,1));\n}\n\nvec3 BG(Ray ray) {\n    return texture(iChannel0, normalize(ray.dir * 600.0 + ray.start).zyx).xyz;\n}\n\n#define NUM_REFLECTIONS 3\n\nvec3 RenderRay(Ray ray) {\n    vec3 ret = vec3(0);\n    float contribution = 1.0;\n    for (int i = 0; i < NUM_REFLECTIONS; i++) {\n        if (contribution < 0.01) break;\n\t\tvec3 iter_color;\n        Hit h = Trace(ray);\n        if (h.material == MATERIAL_BG) {\n        \tret += contribution * BG(ray);\n            break;\n        } else {\n        \tvec3 hp = ray.start + ray.dir * h.dist;\n            Material m = getMaterial(h, hp);\n    \t\tvec3 normal = normalize(h.normal);\n    \t\tvec3 light_dir = normalize(light - hp);\n    \t\tfloat l = dot(light_dir, normal) * LIGHT_STRENGTH;\n            l = max(0.0, l);\n    \t\tfloat s = marble_ray(Ray(hp, light_dir));\n\t\t\t\n            vec3 hp_prime = ray.start + ray.dir * (h.dist - 0.01);\n            hp_prime += normal * 0.01;\n\t\t    if (s < 100.0) l = 0.0;\n    \t\telse l *= softshadow(Ray(hp_prime, light_dir));\n        \tl += 0.1 * AO(Ray(hp_prime, h.normal));  // ambient\n\t        ret += contribution * m.color * l * m.albedo;\n\n            ray = Ray(ray.start + ray.dir * (h.dist - 0.01), reflect(ray.dir, normal));\n            contribution *= m.reflectance;\n    \t}\n    }\n    return ret;\n}\n\nvec3 Render(vec2 fragCoord) {\n    vec3 fragColor;\n        arm_pos = 0.0;\n          \n    light = vec3(2.0, 150.0, -50.0);\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position;\n    vec3 ray_direction = normalize(vec3(uv, 1.0));\n    float rz = 0.0;\n    float rx = 0.0;\n    float T = mod(iTime, 180.0);\n#if 1\n    if (T < 35.0) {\n\t   camera_position = vec3(0, 6.0 , 10.0 - T * 2.0);\n    } else if (T < 40.0) {\n       // Base\n       camera_position = vec3(65, -5.0, 20);\n      rz = 1.3;\n    } else if (T < 45.0) {\n        // Glockenspiel\n        camera_position = vec3(-55, 3.0 , 63);\n        rz =  -1.8;\n    } else if (T < 50.0) {\n        // Snare\n\t\tcamera_position = vec3(-30, 3.0 , 0);\n        rz =  -0.6;\n        rx = 0.3;\n    } else if (T < 54.0) {\n        // Cymbal\n        camera_position = vec3(-35, 8.0,18);\n        rz = -1.1;\n    } else {\n        // Rot\n        float t = (iTime - 14.0) / 3.0;\n        camera_position = vec3(sin(t) * 50.0, 6, -cos(t) * 60.0 + 40.0);\n        rz = t;\n        rx = 0.2;\n    }\n    #else\n        // camera_position = vec3(-30, -10.0 , 10);\n        // rz =  -0.6;\n        // rx = -0.5;\n        camera_position = vec3(-20, -10.0 , 25);\n        rz =  -1.6;\n        rx = 0.0;\n    #endif\n    float sz = sin(rz);\n    float cz = cos(rz);\n    mat3 rot_z = mat3(cz, 0, sz, 0, 1, 0, -sz, 0, cz);\n    float sx = sin(rx);\n    float cx = cos(rx);\n    mat3 rot_x = mat3(1,0,0,0,cx,sx,0,-sx,cx);\n    \n    // Cast a ray, see if we hit anything.\n    Ray ray = Ray(camera_position,  rot_z * rot_x * ray_direction);\n//    return shade_bg(ray, Trace(ray));\n\treturn RenderRay(ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef AA\n    vec3 avg;\n    for (int x = 0; x < AA; x++) {\n        for (int y = 0; y < AA; y++) {\n           \tvec3 tmp = Render(fragCoord + vec2(-0.5/float(AA)) + vec2(1.0/float(AA)) * vec2(x, y));\n            avg += tmp;                \n        }\n    }\n    \n    avg /= float(AA*AA);\n    fragColor = vec4(avg, 1.0);\n    #else\n    fragColor = vec4(Render(fragCoord), 1.0);\n    #endif\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0/2.2)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float pi = 3.1415926536;\n\nfloat si(float i) { return sin(fract(i) * pi * 2.0); }\nfloat pianoish(float time, int key) {\n    float frequency = 27.5 * pow(2.002, float(key) / 12.0);\n    // Maybe express this in terms of frequency.\n    // Model bottom curve.\n    float B = pow(10.0, (float(key) + 1.0) / 24.0 - 5.15);\n    \n    float ret = 0.0;\n    for (int i = 1; i < 15; i++) {\n      float f = frequency * float(i) * sqrt(1.0 + float(i) * float(i) * B);\n      ret += si(f * time) * pow(0.65, float(i)) *  exp((-0.25 - 0.15 * float(i)) * time);\n    }\n  //  return ret * 0.6;\n    return ret * 10.0 / sqrt(frequency);\n}\n    \nfloat glock(float time, int key) {\n    float frequency = 27.5 * pow(2.002, float(key) / 12.0);\n    \n    // Glockenspiel\n   return si(frequency * time) * exp(-3.8 * time)/2.0 +\n          si(frequency * time * 4.0) * exp(-3.0 * time) / 4.0  +\n          si(frequency * time * 9.3) * exp(-5.0 * time) / 10.0;\n}\n// quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s / c) * c;\n}\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    \n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nfloat kick(float time) {\n    return si(40.0 * sqrt(time)) * (0.5+rand(vec2(quan(time, 0.0005))/2.0)) * 5.0 * exp(-10.0 * time);\n}\n\n#if 0\nfloat rand(float t){\n    return fract(sin(t*1793.326) * 43758.5453);\n}\n\nfloat ws(float x,float a)\n{\n\treturn x*(abs(x) + a)/(x*x + (a-1.0)*abs(x) + 1.0);\n}\n\nfloat snare(float _time)\n{\n    float freq=680.0;\n\tfloat c=0.0;\n    const int  num=7;\n    for (int i=0;i<num;i++)\n    {\n        float time=_time-float(i)*(0.09+float(i)*0.01);\n\n        if (time<0.0)\n            continue;\n        \n        float t=1.0-(time*1.0);\n        t=max(t,0.0);\n        t=pow(t,2.0);\n\n        float f=sin(t*freq)/pi;\n\n    \tf=ws(f,2.9);\n        t=time;\n        f*=pow(max(0.0,1.0-(t*6.0)),4.0);\n        f+=rand(time)*0.4*pow(1.0-t,20.0);\n    \tf=ws(f,1.9);\n\t    f= clamp(f,-1.0,1.0);\n        f*=0.7;\n        c+=f/float(1+(i*i*4));\n        \n    }\n    \n    return c*0.35;        \n}\n\n\n#elif 1\nfloat snare(float time) {\n    return si(110.0 * time) * (rand(vec2(time))) * 5.0 * exp(-10.0 * time);\n}\n\n#else\n\nfloat snare(float time) {\n     return (rand(vec2(quan(time, 0.0001)))) * 5.0 * exp(-10.0 * time);\n}\n#endif\n\n\n\nfloat crash(float time) {\n      return si(5000.0 * time +rand(vec2(quan(time, 0.001)))/time )  * (0.5+rand(vec2(quan(time, 0.0005)))/2.0) * 2.0 * exp(-3.0 * time);\n}\n\n#define KEYS 18\n#define B_KEYS 50\nfloat s[KEYS];\nfloat snare_t;\nfloat base_t;\nfloat crash_t;\nfloat b_time;\nint b_key;\n\nfloat TIME;\n\nvoid P(int n) {\n    s[n] = TIME;\n}\n\nvoid play(int t) {\n  t %= 64;\n    \n  if (t % 4 == 2 && t != 50 && t != 54) {\n    if (t <= 30) {\n      P(0);\n    } else {\n      P(7);\n    }\n    if (t <= 14) {\n      P(5);\n    } else {\n      P(3);\n    }\n  }\n  if (t == 0) P(17);\n  if (t == 3) P(12);\n  if (t == 7) P(10);\n  if (t == 8) P(8);\n  if (t == 9) P(10);\n  if (t == 11) P(12);\n  if (t == 13) P(8);\n  if (t == 14) P(10);\n  if (t == 15) P(15);\n  if (t == 19) P(12);\n  if (t == 23) P(10);\n  if (t == 24) P(8);\n  if (t == 25) P(10);\n  if (t == 27) P(7);\n  if (t == 29) P(8);\n  if (t == 30) P(10);\n  if (t == 31) P(15);\n  if (t == 35) P(12);\n  if (t == 39) P(15);\n  if (t == 40) P(13);\n  if (t == 41) P(12);\n  if (t == 43) P(10);\n  if (t == 45) P(8);\n  if (t == 46) P(10);\n  if (t == 47) P(5);\n  if (t == 49) P(1);\n  if (t == 50) P(5);\n  if (t == 51) P(12);\n  if (t == 52) P(0);\n  if (t == 53) P(1);\n  if (t == 54) P(3);\n  if (t == 55) P(15);\n  if (t == 56) P(13);\n  if (t == 57) P(12);\n  if (t == 59) P(10);\n  if (t == 61) P(8);\n  if (t == 62) P(10);\n}\n\n\nvoid drums(int t) {\n  if (t > 64) {\n    int T = t % 64;\n    if (T <= 48) {\n      if ((T % 4)== 2) snare_t = TIME;\n    } else if (T < 56) {\n      if ((T % 4)== 0) snare_t = TIME;\n    } else if (T == 57 || T == 60) {\n      snare_t = TIME;\n    }\n  }\n  if (t >= 128) {\n    int T = t % 64;\n    if ((t % 16) == 0) base_t = TIME;\n    if ((t % 16) == 13) base_t = TIME;\n    if (t/16%4 == 3) {\n      if ((t % 16) == 2) base_t = TIME;\n      if ((t % 16) == 7) base_t = TIME;\n      if ((t % 16) == 10) base_t = TIME;\n    } else {\n      if ((t % 16) == 4) base_t = TIME;\n      if ((t % 16) == 8) base_t = TIME;\n      if ((t % 32) == 11) base_t = TIME;\n    }\n  }\n  if (t % 128 == 0 && t > 0) crash_t = TIME;\n  // if (t % 4 == 2) crash_t = TIME;\n}\n\n\nvoid B(int n) {\n    b_time = TIME;\n    b_key = n;\n}\n\n\nvoid base(int t) {\n  if (t < 128) return;\n  t = t % 128;\n  t += 128;\n  if (t == 128) { B(7); }\n  if (t == 130) { B(19); }\n  if (t == 132) { B(31); }\n  if (t == 133) { B(19); }\n  if (t == 135) { B(43); }\n  if (t == 136) { B(19); }\n  if (t == 137) { B(7); }\n  if (t == 140) { B(22); }\n  if (t == 141) { B(24); }\n  if (t == 142) { B(26); }\n  if (t == 143) { B(29); }\n  if (t == 145) { B(22); }\n  if (t == 146) { B(10); }\n  if (t == 148) { B(22); }\n  if (t == 149) { B(10); }\n  if (t == 151) { B(41); }\n  if (t == 153) { B(34); }\n  if (t == 155) { B(22); }\n  if (t == 156) { B(21); }\n  if (t == 157) { B(22); }\n  if (t == 158) { B(24); }\n  if (t == 159) { B(29); }\n  if (t == 160) { B(14); }\n  if (t == 162) { B(14); }\n  if (t == 164) { B(26); }\n  if (t == 165) { B(14); }\n  if (t == 167) { B(14); }\n  if (t == 168) { B(26); }\n  if (t == 169) { B(14); }\n  if (t == 171) { B(26); }\n  if (t == 172) { B(26); }\n  if (t == 173) { B(14); }\n  if (t == 174) { B(17); }\n  if (t == 175) { B(19); }\n  if (t == 176) { B(15); }\n  if (t == 180) { B(27); }\n  if (t == 184) { B(17); }\n  if (t == 187) { B(29); }\n  if (t == 190) { B(31); }\n  if (t == 192) { B(7); }\n  if (t == 194) { B(19); }\n  if (t == 196) { B(31); }\n  if (t == 197) { B(7); }\n  if (t == 199) { B(43); }\n  if (t == 201) { B(31); }\n  if (t == 204) { B(19); }\n  if (t == 205) { B(22); }\n  if (t == 206) { B(24); }\n  if (t == 207) { B(29); }\n  if (t == 209) { B(22); }\n  if (t == 210) { B(10); }\n  if (t == 212) { B(22); }\n  if (t == 213) { B(10); }\n  if (t == 215) { B(41); }\n  if (t == 217) { B(34); }\n  if (t == 219) { B(22); }\n  if (t == 220) { B(21); }\n  if (t == 221) { B(22); }\n  if (t == 222) { B(24); }\n  if (t == 223) { B(29); }\n  if (t == 224) { B(14); }\n  if (t == 226) { B(14); }\n  if (t == 228) { B(26); }\n  if (t == 229) { B(14); }\n  if (t == 231) { B(14); }\n  if (t == 232) { B(26); }\n  if (t == 233) { B(14); }\n  if (t == 235) { B(24); }\n  if (t == 237) { B(22); }\n  if (t == 238) { B(21); }\n  if (t == 240) { B(12); }\n  if (t == 244) { B(24); }\n  if (t == 245) { B(12); }\n  if (t == 248) { B(14); }\n  if (t == 251) { B(26); }\n  if (t == 254) { B(14); }    \n}\n\nvoid melody(float t) {\n\tfloat tempo = 5.0;\n    int T = int(floor(t * tempo));\n    for (int i = -10; i < 0; i++) {\n        TIME = float(T + i) / tempo;\n        play(T + i);\n        base(T + i);\n        drums(T + i);\n    }\n}\n\nfloat sound(float t) {\n    for (int i = 0; i < KEYS; i++) {\n       s[i] = -100.0;\n    }\n    b_time = -100.0;\n    b_key = 0;\n    snare_t = -100.0;\n    base_t = -100.0;\n    crash_t = -100.0;\n\n    melody(t);\n    \n    float ret = 0.0;\n #if 1   \n    for (int i = 0; i < KEYS; i++) {\n        ret += glock(t - s[i], i + 50);\n    }  \n  \n    ret += pianoish(t - b_time, b_key) * 0.8;\n  \n    ret += snare(t - snare_t) * 1.6;\n    ret += kick(t - base_t) * 1.6;\n    #endif\n    ret += crash(t - crash_t);    \n    return ret;\n}\n\nvec2 mainSound( in int samp,float time) {\n    float l = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    for (int i = 0; i < 5; i++) {\n        s+=sound(time - (float(i) + sin(float(i)))/8.0) * exp(-1.5 * float(i)); \n    }\n    \n    return vec2(s);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}