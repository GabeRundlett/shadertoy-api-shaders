{
    "Shader": {
        "info": {
            "date": "1692221840",
            "description": "really bright",
            "flags": 0,
            "hasliked": 0,
            "id": "mtByDy",
            "likes": 11,
            "name": "Colorful Backup Spirals",
            "published": 3,
            "tags": [
                "raymarching",
                "domainrepetition",
                "glow"
            ],
            "usePreview": 0,
            "username": "Aurcereal",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "// Fork of \"graphic 3dtest5w\" by Aurcereal. https://shadertoy.com/view/DlScDy\n// 2023-08-16 21:02:27\n\n// Fork of \"graphic 3dtest\" by Aurcereal. https://shadertoy.com/view/dlBcD1\n// 2023-08-16 17:38:30\n\n// Fork of \"graphic ctest\" by Aurcereal. https://shadertoy.com/view/dtByD1\n// 2023-08-10 23:33:27\n\n#define MAXDIST 100.\n#define MAXSTEPS 300\n#define SDEPS 0.0001\n#define NORMEPS 0.0001\n\nvec2 getDomainDim()\n{\n    float tt = t*.5;\n    float rep = 120.*.5*.67;\n    tt = mod(tt, rep);\n    tt = tt + step(rep*.5, tt) * (rep*.5 - (tt - rep*.5) - tt);\n\n    return vec2(4.+tt*.4, 4.);\n}\n\nvec3 currCol;\n\nvec3 getCol(vec3 p)\n{\n\n    vec2 domxy = getDomainDim().x * vec2(1., 1.);\n    p.xy = p.xy - (mod(p.xy, domxy) - domxy*.5);\n    p.xy /= domxy;\n    \n    float domz = getDomainDim().y;\n    p.z = p.z - (mod(p.z+domz*.5, domz) - domz*.5);\n    \n    float h = hash31flr(p*10.+100.);\n    \n    return hsv2rgb(vec3(h, .9, 1.)); //.8 .8\n    \n}\n\nfloat smin(float a, float b, float k)\n{\n    float d = abs(a - b);\n    float h = pow(1. - max(0., d/k), 2.);\n    return min(a, b) - .25 * k * h;\n}\n\nfloat getFog(float dist)\n{\n    return saturate(exp(-dist*.1+2.));\n}\n\nfloat sdrails(vec3 p)\n{\n\n    vec3 wp = p;\n    \n    float spiralRep = getDomainDim().x;\n    vec2 xyID = p.xy - (mod(p.xy, spiralRep) - spiralRep*.5); //xyID *= 0.;\n    p.xy = p.xy - xyID;\n\n    p.z += (8.+2.) * t;\n    \n    \n\n    float rotAmount = hash21(xyID/spiralRep+50.)*100.+t+.1*max(0., p.z - 10.);\n    p = rot(p, V.yyx, rotAmount);\n    //p = rot(p - .1*vec3(1., 1., 0.), V.yyx, .1*rotAmount);\n    currCol = getCol(p+vec3(xyID.x, xyID.y, 0.));\n    \n\n    vec2 domainDim = vec2(2.7, getDomainDim().y);\n    vec2 highlightDim = vec2(.2, 2.);\n    \n    float thickness = 0.005*100. * (1. + .5 * smoothstep(2., 7., length(xyID)));\n    \n    //\n    p.z = mod(p.z+domainDim.y*.5, domainDim.y) - domainDim.y*.5;\n    p.x = abs(p.x) - domainDim.x*.5;\n    \n    p = abs(p);\n    \n    return sdBox(p, vec3(highlightDim.x, thickness, highlightDim.y));\n    \n    \n}\n\nfloat sdf(vec3 p)\n{\n    return sdrails(p); //be careful chaining too far\n}\n\nfloat sdGlowObject(vec3 p)\n{\n    return sdf(p);\n}\n\nvec3 sampleGlow(vec3 p, float squeeze, float size, float offset)\n{\n    return 4.*currCol * getFog(p.z) * .3*(1.-exp(-size/pow(sdGlowObject(p)+offset, squeeze))); //*1.4\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(NORMEPS, 0.);\n    \n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n        ));\n}\n\nfloat march(vec3 ro, vec3 rd, out int steps, out vec3 glow)\n{\n    \n    steps = 0; glow = vec3(0.);\n    float sd, d = 0.;\n    \n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        sd = min(.5+100.*0., sdf(ro + rd*d));\n        d += sd;\n        steps++;\n        glow += sd * sampleGlow(ro + rd * d, 10., 0.3, .9);\n        if(abs(sd) < SDEPS || d >= MAXDIST) return d;\n    }\n    \n    return d;\n    \n}\n\nfloat aspect;\n\nvec3 skybox(vec3 rd, vec3 lrd, vec2 wp)\n{\n\n    return hsv2rgb(vec3(acos(rd.y) * IPI+t*.05, .8, .8)) * .3 + V.xxx * pow(hash21(100.*vec2(acos(lrd.y), atan(lrd.z, lrd.x))), .5*10.*356.);\n}\n\nvec3 shade(vec3 camPos, vec3 rd, vec3 p, vec3 norm, int steps, out float fog)\n{\n\n    //\n    vec3 lightDir = -V.yxy;//-V.xyx/sqrt(2.);//genUnconstrainedDir(hash11(1.44), hash11(2.44), vec2(0.0004));//\n    \n    //\n    float diffuse = saturate(-.1+dot(norm, lightDir));\n    diffuse = pow(diffuse, 0.5);\n    \n    //\n    float specular = pow(max(0., dot(reflect(rd, norm), lightDir)), 8.);\n    \n    //\n    fog = getFog(dot(p - camPos, rd));\n    float AO = max(0., 1. - float(steps) / 20.);\n    \n    //\n    return mix(mix((diffuse * .9 + specular * .9 + AO * .8) * 2.4*currCol, currCol, 0.9), (1.+2.*.7)*texture(iChannel0, reflect(rd, norm)).rgb, .2);\n}\n\nvec3 postProcess(vec3 col, vec2 p)\n{\n    vec2 lp = abs(p);\n    lp = vec2(aspect, 1.) - lp;\n    float d = min(lp.x, lp.y);\n    float vignette = smoothstep(0.4, 0., d);\n    \n    float bg = sample2DBackground(p);\n    return (1.- bg) * mix(col, V.yyy, vignette*0.3) + bg * V.xxx;\n}\n\nvec3 render(vec2 fragCoord)\n{\n    //\n    t = iTime*2.;\n\n    //\n    float fAng = -.4*.3*sin(.3*t); //-.1\n    float twist = .4 * .2 * cos(.2*t+10.);\n    vec3 fo = -rot(vec3(0., sin(fAng), cos(fAng)), V.yxy, twist);\n    vec3 ro = vec3(0., 2., -5.);\n\n    vec3 lrd = normalize(vec3((fragCoord/iResolution.xy)*2.-1., 1.) * vec3(1., .577, 1.));\n    \n    float o = 0.;//t*.7;\n    vec3 up = vec3(-sin(o), cos(o), 0.);\n    vec3 ri = normalize(cross(up, fo)); up = cross(fo, ri);\n    \n    vec3 rd = mat3(ri, up, fo) * lrd;\n    \n    //\n    int steps; vec3 glow;\n    float dist = march(ro, rd, steps, glow);\n    \n    vec2 wp = (fragCoord/iResolution.xy*2.-1.)*vec2(aspect, 1.);\n    vec3 skySample = glow + skybox(rd, lrd, wp);\n    float fog; vec3 solidSample = (glow + shade(ro, rd, ro+rd*dist, normal(ro+rd*dist), steps, fog));\n    \n    if(dist >= MAXDIST) return postProcess(skySample, wp);\n    return postProcess(mix(solidSample, skySample, 1.-fog), wp);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   aspect = iResolution.x/iResolution.y;\n   \n   vec2 d = vec2(.5,0.); //1.\n   vec3 col = render(fragCoord+d.yy);// + render(fragCoord+d.xy) + render(fragCoord+d.yx) + render(fragCoord+d.xx); col *= .25;\n   fragColor = vec4(pow(col, vec3(.5)), 1.);\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define IPI 0.318309\n#define TAU 6.28318\n#define V vec2(1., 0.)\n\n//Hash functions from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31flr(vec3 p3)\n{\n    p3 = p3 - mod(p3, .1);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, 0., 1.);\n}\n\nvec3 saturate(vec3 c)\n{\n    return vec3(saturate(c.x), saturate(c.y), saturate(c.z));\n}\n\nvec2 fold(vec2 v, vec2 n)\n{\n    return v - 2. *  n * min(0., dot(v, n));\n}\n\nvec3 fold(vec3 v, vec3 n)\n{\n    return v - 2. *  n * min(0., dot(v, n));\n}\n\nfloat unlerp(float a, float b, float t)\n{\n    return saturate((t-a)/(b-a));\n}\n\nvec3 rot(vec3 v, vec3 a, float o)\n{\n    float along = dot(v, a);\n    \n    vec3 up = normalize(cross(v, a));\n    vec3 ri = cross(up, a);\n    \n    float r = length(cross(v, a));\n    \n    return a * along + ri * r * cos(o) + up * r * sin(o);\n}\n\nfloat t;\n\nfloat randLinear(float t, vec2 range, float rand)\n{\n    float rangeRand = abs(rand-.5)*2.;\n    float sig = step(rand, 0.5)*2.-1.;\n    return t * (range.x + (range.y-range.x)*rangeRand) * sig;\n}\n\nvec3 genDir(float rand, float phiBound) // ~ [0, 1]\n{\n    float theta = randLinear(1.+t, vec2(1., 2.), rand);\n    float phi = phiBound * sin(randLinear(1.+t, vec2(0.7, 1.4), rand));\n    \n    return vec3(cos(phi) * cos(theta), sin(phi), cos(phi) * sin(theta));\n}\n\nvec3 genUnconstrainedDir(float rand1, float rand2, vec2 speedRange)\n{\n    float theta = randLinear(1.+t, speedRange, rand1);\n    float phi = randLinear(1.+t, speedRange, rand2);\n    \n    return vec3(cos(phi) * cos(theta), sin(phi), cos(phi) * sin(theta));\n}\n\nvec3 genUnconstrainedDir(float rand1, float rand2)\n{\n    return genUnconstrainedDir(rand1, rand2, .4*vec2(1., 2.));\n}\n\n//2D\n\nvec2 rot(vec2 p, float o)\n{\n    return mat2(cos(o), sin(o), -sin(o), cos(o)) * p;\n}\nvec2 perp(vec2 p)\n{\n    return rot(p, PI*.5);\n}\nvec2 toCart(vec2 polar)\n{\n    return polar.x * vec2(cos(polar.y), sin(polar.y));\n}\nfloat sdRect(vec2 p, vec2 fo, vec2 dim)\n{\n    p = abs(vec2(dot(p, fo), dot(p, perp(fo)))) - dim*.5;\n    float s = sqrt(max(0., p.x*p.x*sign(p.x)) + max(0., p.y*p.y*sign(p.y)));\n    return s + step(s, 0.) * max(p.x, p.y);\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n//\n\n// Official HSV to RGB conversion taken from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//fullscreen\n\nfloat bellCurve(float x)\n{\n    return exp(-x*x);\n}\n\nfloat sample2DBackground(vec2 p)\n{\n    float exists = 0.;\n\n    //\n    p = abs(p) * sign(p.x) * sign(p.y); //it'd be nice to have the rings have a bit of a delayed bounce\n    \n    // it'd also be cool to have a rectangle highlight that connects the circles instead of the highlights going offscreen\n    float r = 0.6;\n    float thetaRepLen = 0.2;\n    vec2 highlightDim = vec2(0.1, 0.05);\n    \n    float it = unlerp(4., 4.4, t);\n    float scale = 1.-pow(1.-it, 2.); scale += .3*bellCurve((it-.4)*2.); //.6, 10\n    scale *= 1.-step(it, 0.);\n    \n    p = p - vec2(1.67, 1.);\n    p /= scale;\n    exists += step(sdCircle(p, r), 0.);\n    \n    vec2 polar = vec2(length(p), .4*t+atan(p.y, p.x));\n    polar.y = mod(polar.y, thetaRepLen) - thetaRepLen*.5;\n    polar.x = polar.x - r*1.1;\n    polar = abs(polar);\n    exists += step(polar.x, highlightDim.y*.5) * step(polar.y, highlightDim.x*.5);\n    \n    return exists;\n}\n\n\n//3D\n\nfloat sdBox(vec3 p, vec3 dim)\n{\n    p = abs(p) - dim*.5;\n    float s = sqrt(max(p.x*p.x*sign(p.x), 0.) + max(p.y*p.y*sign(p.y), 0.) + max(p.z*p.z*sign(p.z), 0.));\n    return s + step(s, 0.) * max(max(p.x, p.y), p.z);\n}\n\nfloat sdEdgedBox(vec3 p, vec3 dim, float thickness, vec3 fo)\n{\n    //\n    vec3 ri = normalize(cross(fo, vec3(0., 1., 0.)));\n    vec3 up = cross(ri, fo);\n    p = vec3(dot(p, ri), dot(p, up), dot(p, fo));\n    \n    //\n    p = abs(p);\n    p = p - dim*.5;\n    \n    p = fold(p, 1./sqrt(2.) * vec3(-1., 0., 1.));\n    p = fold(p, 1./sqrt(2.) * vec3(1., -1., 0.));\n    \n    return sdBox(p - vec3(0., thickness*.5-(dim.y+thickness)*.25, 0.), vec3(thickness, 5.*(dim.y+thickness)*.5, thickness));\n}\n\nfloat sdCone(vec3 p, vec2 dim, vec3 up) //sparse on ring slightly smaler than ud think maybe\n{\n    vec2 lp = vec2(length(cross(p, up)), dot(p, up));\n    lp /= dim;\n    return max(dot(vec2(1., 1.)/sqrt(2.), lp - vec2(0., 1.)), -lp.y);\n}\n\nfloat sdRing(vec3 p, vec3 dim, vec3 fo)\n{\n    vec2 lp = vec2(dot(p, fo), length(cross(p, fo)));\n    return sdRect(lp - vec2(0., dim.z), vec2(1., 0.), dim.xy);\n}\n\nfloat sdRingConed(vec3 p, vec3 dim, vec3 fo, vec3 up, float coneOffset, vec2 coneDim, float coneCount, float t)\n{\n    vec3 lp = vec3(dot(p, fo), dot(p, up), dot(p, cross(fo, up)));\n    \n    vec2 plp = vec2(lp.x, length(lp.yz));\n    float sdRing = sdRect(plp - vec2(0., dim.z), vec2(1., 0.), dim.xy);\n    \n    vec2 polar = vec2(length(lp.yz), t + atan(lp.z, lp.y));\n    polar.y = mod(polar.y, TAU/coneCount) - .5 * TAU/coneCount;\n    lp = vec3(lp.x, polar.x * sin(polar.y), polar.x * cos(polar.y));\n    float sdC = sdCone(lp - vec3(0., 0., dim.z + dim.y * .5 + coneOffset), coneDim, vec3(0., 0., 1.));\n    \n    return min(sdC, sdRing);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}