{
    "Shader": {
        "info": {
            "date": "1660693445",
            "description": "Approximating a circle with n quadratic bezier curves",
            "flags": 0,
            "hasliked": 0,
            "id": "stdyDX",
            "likes": 4,
            "name": "Quadratic bezier circle approx",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "circle",
                "approximation",
                "quadratic",
                "numeric"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "/*\nQuick experiment on approximating a circle with n=3,...,10 quadratic bezier curves.\nThe control point is taken as lying on the angle bisector between the endpoints\nand the length of that vector is optimized with respect to two different constraints:\n\n1. Smoothness: We want two neighbouring curves to have the same tangents\n2. Global Error: Minimize how far away the curve is from the perfect circle on average\n\nBoth variants look like the circle for bigger n, but for smaller n they are quite\ndifferent and it probably depends on your application which is better\n(or maybe something in between?)\n\nValues are computed using sage:\nhttps://gist.github.com/Ninja-Koala/05d32186364901f69c65f2f30804f282\n*/\n\n//#define N_CURVES 3\n//#define MOUSE\n//#define SHOW_CIRCLE\n\nconst vec3 line_col=vec3(0);\nconst vec3 bg_col=vec3(1);\nconst vec3 circ_col=vec3(1,0,0);\n\nconst float zoom=5.;\nconst float speed=1.;\n\nconst float pi=3.1415925;\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec3 t0=vec3(0.,.5,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat quadratic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\treturn sqrt(quadratic_bezier_dis_approx_sq(uv,p0,p1,p2));\n}\n\nvec2 circle(float angle){\n\treturn vec2(cos(angle), sin(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\n\tfloat time=iTime*speed;\n\n\t//x value optimizes for smoothness\n\t//y value optimizes global error\n\tvec2 params[]=vec2[](vec2(2.0000000,1.5266269717117547),\n\t                     vec2(1.4142137,1.302540332610836),\n\t                     vec2(1.2360680,1.1952007055159193),\n\t                     vec2(1.1547005,1.1360708085570863),\n\t                     vec2(1.1099162,1.1001848642387122),\n\t                     vec2(1.0823922,1.0768091648486144),\n\t                     vec2(1.0641778,1.0607443753104062),\n\t                     vec2(1.0514622,1.0492315540059483));\n\n    #ifndef N_CURVES\n\tfloat n_curves=mod(floor(time),7.)+3.;\n    #else\n    float n_curves=float(N_CURVES);\n    #endif\n\n\tint index=int(n_curves-3.);\n    \n    #ifdef MOUSE\n    float t1=iMouse.x/iResolution.x;\n    #else\n    float t1=fract(time);\n    #endif\n    \n\n\tvec2 p0=circle(0.);\n\tvec2 p1=mix(params[index].x,params[index].y,t1)*circle(pi/n_curves);\n\tvec2 p2=circle(2.*pi/n_curves);\n\n\tfloat angle=atan(uv.y,uv.x);\n\tangle=mod(angle,2.*pi/n_curves);\n\tuv=length(uv)*circle(angle);\n\n\tfloat dis=quadratic_bezier_dis_approx(uv,p0,p1,p2);\n\t//dis=min(dis,abs(length(uv)-1.));\n\t\n\tvec3 color=bg_col;\n\tcolor=mix(line_col,color,smoothstep(0.,border,dis));\n    \n    #ifdef SHOW_CIRCLE\n    dis=abs(length(uv)-1.);\n    color=mix(circ_col,color,smoothstep(0.,border,dis));\n    #endif\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}