{
    "Shader": {
        "info": {
            "date": "1699543531",
            "description": "Projet réalisé par Temirboulatov Koureich p1707160 et Rezaoui Yanis p1810590",
            "flags": 0,
            "hasliked": 0,
            "id": "mtccR8",
            "likes": 0,
            "name": "Projet infographie M1 info",
            "published": 3,
            "tags": [
                "projetinfographie"
            ],
            "usePreview": 1,
            "username": "smirboulack",
            "viewed": 128
        },
        "renderpass": [
            {
                "code": "/*\n\nRéalisé par Temirboulatov Koureich p1707160 et Rezaoui Yanis p1810590 UCBL LYON 1 - 2023\n\nPyramide réalisé en suivant les instructions : \n - https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution.html\n - https://www.shadertoy.com/view/MlGcDz\n*/\n\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\n// Structure représentant un disque\nstruct Disque_cylindre {\n    vec3 centre; // Centre du disque\n    vec3 normal; // Normale du disque\n    float rayon; // Rayon du disque\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant un cylindre\nstruct Cylinder {\n    vec3 c; // Centre de la base du cylindre\n    vec3 top; // Point du haut du cylindre\n    float r; // Rayon du cylindre\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant un tore\nstruct Tore {\n    vec3 c; // Centre du tore\n    vec2 t; // Rayons majeur et mineur du tore\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant une capsule\nstruct Capsule {\n    vec3 a; // Point de départ de la capsule\n    vec3 b; // Point de fin de la capsule\n    float r; // Rayon de la capsule\n    int i; // Identifiant de la texture\n};\n\n// Structure représentant un ellipsoïde\nstruct Ellipsoid {\n    vec3 c; // Centre de l'ellipsoïde\n    vec3 r; // Rayons dans les directions x, y et z\n    int i; // Identifiant de la texture\n};\n\nstruct Triangle {\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\nstruct Pyramid {\n    Triangle sides[4]; // Un pyramide avec une base carrée a 4 côtés triangulaires\n    int i; // Identifiant de texture\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\n//Matrices de rotation\nmat3 rotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotationMatrixY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotationMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.x * axis.z + axis.y * s,\n        oc * axis.y * axis.x + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.z * axis.y + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    float reflectivity; // Reflectivity coefficient, 0.0 for matte, 1.0 for fully reflective\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nvec3 UniformTexture(vec3 color) {\n    return color;\n}\n\nvec3 Damier(vec3 p, float sideSize) {\n    vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n    vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n\n    // Déterminer l'indice de la case dans laquelle se trouve le point\n    ivec3 boxIndex = ivec3(floor(p / sideSize));\n\n    // Calculer si la somme des indices de la case est paire ou impaire\n    int checker = int(boxIndex.x + boxIndex.y + boxIndex.z) % 2;\n\n    // Retourner la couleur correspondante\n    return checker == 0 ? color1 : color2;\n}\n\nvec3 StripedTexture(vec3 p, vec3 color1, vec3 color2, float stripeWidth) {\n    // Calculer le motif à rayures en fonction de la coordonnée x\n    float pattern = sin(p.x * stripeWidth);\n\n    // Déterminer si nous sommes dans une rayure ou non\n    float stripe = step(0.5, pattern);\n\n    // Mélanger les deux couleurs en fonction de la valeur de la rayure\n    return mix(color1, color2, stripe);\n}\n\nMaterial TexturePlane(vec3 p, int i) {\n    if (i == 0) {\n        // Définir les couleurs pour les rayures\n        vec3 color1 = vec3(1.0, 1.0, 1.0); // Couleur blanche\n        vec3 color2 = vec3(0.0, 0.0, 0.0); // Couleur noire\n        float stripeWidth = 3.1415 * 2.0; // Largeur des rayures\n\n        // Obtenir la texture à rayures\n        vec3 col = StripedTexture(p, color1, color2, stripeWidth);\n        return Material(col, 0.0); // Matériau non réfléchissant\n    }\n    // Ajouter d'autres cas de textures si nécessaire\n    return Material(vec3(0), 0.0); // Matériau mat par défaut\n}\n\n//Texture arc-en-ciel\nvec3 RainbowTexture(vec3 p) {\n    float pi = 3.14159265359; // Définir la valeur de pi\n\n    // S'assurer que la coordonnée Y est entre 0 et 1\n    float y = mod(p.y, 1.0); \n\n    // Convertir y en une valeur entre 0 et 2*pi\n    float angle = 2.0 * pi * y;\n\n    // Calculer les valeurs RGB en utilisant des fonctions trigonométriques\n    float r = 0.5 * sin(angle) + 0.5; // Calculer la composante rouge\n    float g = 0.5 * sin(angle + 2.0 * pi / 3.0) + 0.5; // Calculer la composante verte\n    float b = 0.5 * sin(angle + 4.0 * pi / 3.0) + 0.5; // Calculer la composante bleue\n    vec3 color = vec3(r, g, b); // Combiner les composantes RGB en une couleur\n    // Retourner la couleur\n    return color;\n}\n\n// Fonction de bruit simple\nfloat noise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Fonction de texture d'herbe\nvec3 GrassTexture(vec3 p) {\n    // Couleur de base de l'herbe\n    vec3 grassColor = vec3(0.1, 0.5, 0.1);\n\n    // Ajouter une variation de couleur\n    float variation = noise(p.xz * 5.0); // Ajuster l'échelle pour contrôler la fréquence de variation\n    grassColor *= 0.7 + 0.3 * variation; // Assombrir et éclaircir la couleur de base\n\n    // Ajouter des taches plus sombres pour simuler des ombres ou différents types d'herbe\n    float darkPatches = smoothstep(0.4, 0.6, noise(p.xz * 10.0)); // Ajuster l'échelle pour la taille des taches\n    grassColor *= mix(vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0), darkPatches);\n\n    return grassColor;\n}\n\nvec3 ConcentricTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif concentrique basé sur la distance au centre\n    float distToCenter = length(p - centerPoint);\n    float concentricValue = sin(distToCenter * frequency);\n\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Combiner les deux motifs\n    float pattern = (concentricValue + radialValue) * 0.5;\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(vec3(0.2, 0.4, 0.6), vec3(0.8, 0.6, 0.4), (pattern + 1.0) * 0.5);\n\n    return color;\n}\n\nvec3 RadialTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n\n    return color;\n}\n\nvec3 multicolorTexture(vec3 p, vec3 centerPoint, vec3 axis, float frequency) {\n    // Motif radial basé sur la distance à un axe\n    // Projeter le point sur l'axe pour trouver le point le plus proche\n    vec3 proj = dot(p - centerPoint, axis) * axis + centerPoint;\n    float distToAxis = length(p - proj);\n    float radialValue = sin(distToAxis * frequency);\n\n    // Mapper la valeur radiale à une couleur\n    // Couleur noire\n    vec3 color1 = vec3(0.0, 0.0, 0.0);\n    // Couleur jaune\n    vec3 color2 = vec3(1.0, 1.0, 0.0);\n    // Couleur rouge\n    vec3 color3 = vec3(1.0, 0.0, 0.0);\n    // Couleur bleue\n    vec3 color4 = vec3(0.0, 0.0, 1.0);\n\n    // Créer le motif radial\n    float pattern = 0.5 * (1.0 + sin(frequency * distToAxis));\n\n    // Mapper la valeur du motif à une couleur\n    vec3 color = mix(color1, color2, pattern);\n    color = mix(color, color3, pattern);\n    color = mix(color, color4, pattern);\n\n    return color;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        return Material(vec3(.8, .5, .4), 0.5); // Matte material\n    }else if(i==2){\n         return Material(Damier(p, 0.5), 0.5);\n    } else if(i==3){\n        return Material(ConcentricTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2);\n    }\n    else if(i==4){\n        return Material(RainbowTexture(p),0.4);\n    }\n    else if(i==5){\n        return Material(StripedTexture(p, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), 3.1415 * 2.0), 0.5);\n    }\n    else if(i==6){\n        return Material(RadialTexture(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0), 0.2);\n    }\n    else if(i==7){\n        //mirror\n        return Material(vec3(0.0, 0.0, 0.0), 1.0);\n    }else if(i==8){\n        //uniform yellow\n        return Material(vec3(1.0, 1.0, 0.0), 0.0);\n    }\n    else if (i == 0) {\n        /* float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col, 0.0); // Non-reflective material */\n        return Material(GrassTexture(p), 0.3); // Non-reflective grass material\n    }\n    // Add more materials with different reflectivity as needed\n\n    return Material(vec3(0), 0.0); // Default matte material\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectRotatingSphere(Ray ray, Sphere sph, out Hit x, float angle, vec3 axis) {\n    // 1. Calculer le centre de la sphère\n    vec3 center = sph.c;\n\n    // 2. Calculez la matrice de rotation en fonction de l'axe et de l'angle spécifiés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transform ray\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // 3. Effectuez l'intersection comme si la sphère n'était pas tournée\n    if (IntersectSphere(transformedRay, sph, x)) {\n        return true;\n    }\n    return false;\n}\n\nvoid translateSphere(out Sphere s, vec3 maxTranslation, float translation_speed, float time) {\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    s.c += maxTranslation * oscillation;\n}\n\n\nvoid rotateSphere(out Sphere s, float angle, vec3 axis) {\n    axis = normalize(axis); // Assurez-vous que l'axe est normalisé\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    s.c = s.c * cosTheta +\n        cross(axis, s.c) * sinTheta +\n        axis * dot(axis, s.c) * (1.0 - cosTheta);\n}\n\nvoid scaleSphere(out Sphere s, float scaleMin, float scaleMax, float scale_speed, float time) {\n    // Oscillation entre scaleMin et scaleMax\n    float scaleFactor = mix(scaleMin, scaleMax, 0.5 * (1.0 + sin(time * scale_speed)));\n\n    s.r *= scaleFactor;\n}\n\nbool IntersectDisqueCylindre(Ray ray, Disque_cylindre d, out Hit x) {\n    float t = -dot(ray.o - d.centre, d.normal) / dot(ray.d, d.normal);\n    if (t > 0.) {\n        vec3 p = Point(ray, t);\n        if (distance(p, d.centre) <= d.rayon) {\n            x = Hit(t, d.normal, d.i);\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n\n\nbool intersectCylinder(Ray ray, Cylinder cylinder, out Hit hit) {\n\n    // Calculer le décalage entre l'origine du rayon et le centre du cylindre\n    vec3 oc = ray.o - cylinder.c;\n\n    // Extraire les composantes x et y de la direction du rayon\n    vec2 dxy = ray.d.xy;\n\n    // Calculer les coefficients pour l'équation quadratique\n    float a = ray.d.x * ray.d.x + ray.d.y * ray.d.y;\n    float b = 2. * (oc.x * ray.d.x + oc.y * ray.d.y);\n    float c = oc.x * oc.x + oc.y * oc.y - cylinder.r * cylinder.r;\n\n    // Calculer le discriminant de l'équation quadratique\n    float discriminant = b * b - 4.0 * a * c;\n\n    // Si le discriminant est positif, le rayon intersecte le cylindre\n    if (discriminant > 0.0) {\n\n        // Calculer les deux points d'intersection possibles\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Choisir le point d'intersection le plus proche\n        float t = min(t1, t2);\n\n        // Vérifier si le point d'intersection est devant le rayon et à l'intérieur de la hauteur du cylindre\n        if (t > 0.) {\n            vec3 p = Point(ray, t);\n            if (p.z > cylinder.c.z && p.z < cylinder.top.z) {\n\n                // Calculer le vecteur normal au point d'intersection\n                vec3 u = cylinder.top - cylinder.c;\n                vec3 q = cylinder.c + (dot(u, p - cylinder.c) / dot(u, u)) * u;\n                vec3 n = normalize(p - q);\n\n                // Stocker les détails de l'intersection dans la structure hit\n                hit.t = t;\n                hit.n = n;\n                hit.i = cylinder.i;\n\n                return true;\n            }\n        }\n\n        // Si le rayon pointe vers le haut, vérifier l'intersection avec le disque inférieur du cylindre\n        if (ray.d.z > 0.0) {\n            Disque_cylindre disque = Disque_cylindre(cylinder.c, vec3(0., 0., -1), cylinder.r, cylinder.i);\n            if (IntersectDisqueCylindre(ray, disque, hit)) {\n                return true;\n            }\n        } \n        // Si le rayon pointe vers le bas, vérifier l'intersection avec le disque supérieur du cylindre\n        else {\n            Disque_cylindre disque = Disque_cylindre(cylinder.top, vec3(0., 0., 1), cylinder.r, cylinder.i);\n            if (IntersectDisqueCylindre(ray, disque, hit)) {\n                return true;\n            }\n        }\n    }\n\n    // Si aucune intersection n'a été trouvée, retourner false\n    return false;\n}\n\n\nbool IntersectCylinderRotation(Ray ray, Cylinder cyl, float angleX, float angleY, float angleZ, out Hit hit) {\n    // 1. Calculer le centre du cylindre\n    vec3 center = 0.5 * (cyl.c + cyl.top);\n\n    // 2. Calculez les matrices de rotation pour chaque axe\n    mat3 rotX = rotationMatrix(vec3(1, 0, 0), angleX);\n    mat3 rotY = rotationMatrix(vec3(0, 1, 0), angleY);\n    mat3 rotZ = rotationMatrix(vec3(0, 0, 1), angleZ);\n\n    // Multipliez les matrices de rotation pour obtenir une matrice composite\n    mat3 compositeRotation = rotZ * rotY * rotX;\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(compositeRotation); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformez le rayon pour le mettre dans l'espace du cylindre rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // 3. Effectuez l'intersection comme si le cylindre n'était pas tourné\n    if (intersectCylinder(transformedRay, cyl, hit)) {\n        return true;\n    }\n    return false;\n}\n\nvoid TranslateCylinder(inout Cylinder cyl, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n\n    cyl.c += translation;\n    cyl.top += translation;\n}\n\n\nvoid ScaleCylinder(out Cylinder cyl, float scaleFactorAxis, float scaleFactorRadius, float scaleSpeed, float time) {\n    vec3 center = 0.5 * (cyl.c + cyl.top);\n\n    float oscillationAxis = 0.5 * sin(time * scaleSpeed) + 1.5; // Oscille entre 1.0 et 2.0\n    float oscillationRadius = 0.5 * sin(time * scaleSpeed) + 1.5; // Oscille entre 1.0 et 2.0\n\n    float finalScaleFactorAxis = scaleFactorAxis * oscillationAxis;\n    float finalScaleFactorRadius = scaleFactorRadius * oscillationRadius;\n\n    cyl.c = center + (cyl.c - center) * finalScaleFactorAxis;\n    cyl.top = center + (cyl.top - center) * finalScaleFactorAxis;\n    cyl.r *= finalScaleFactorRadius;\n}\n\n\nvoid RotateCylinder(out Cylinder cyl, vec3 axis, float angle) {\n    axis = normalize(axis);\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    cyl.c = cyl.c * cosTheta +\n        cross(axis, cyl.c) * sinTheta +\n        axis * dot(axis, cyl.c) * (1.0 - cosTheta);\n    cyl.top = cyl.top * cosTheta +\n        cross(axis, cyl.top) * sinTheta +\n        axis * dot(axis, cyl.top) * (1.0 - cosTheta);\n}\n\n// Signed distance function for a torus\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nbool IntersectTorus(Ray ray, Tore tor, out Hit x) {\n    float tMin = 0.0; // Distance minimale pour l'intersection\n    float tMax = 1000.0; // Distance maximale arbitraire pour l'intersection\n    float epsilon = 0.001; // Petite valeur pour vérifier la proximité à la surface\n    float tCurrent = tMin;\n\n    // Ray marching loop\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = Point(ray, tCurrent); // Point sur le rayon à la distance tCurrent\n        vec3 localP = p - tor.c; // Convertir le point en coordonnées locales du tore\n\n        // Calcul de la distance signée du point au tore\n        float dist = sdTorus(localP, tor.t);\n\n        // Si la distance est inférieure à epsilon, on a une intersection\n        if (abs(dist) < epsilon) {\n            // Approximation of the normal using the gradient of the SDF\n            vec3 nor = normalize(vec3(\n                sdTorus(localP + vec3(epsilon, 0.0, 0.0), tor.t) - dist,\n                sdTorus(localP + vec3(0.0, epsilon, 0.0), tor.t) - dist,\n                sdTorus(localP + vec3(0.0, 0.0, epsilon), tor.t) - dist\n            ));\n\n            // Stocker les informations d'intersection dans la structure Hit\n            x = Hit(tCurrent, nor, tor.i);\n            return true; // Intersection trouvée\n        }\n\n        // Avancer le long du rayon de la distance calculée\n        tCurrent += dist;\n\n        // Si on dépasse tMax, il n'y a pas d'intersection\n        if (tCurrent >= tMax) {\n            return false;\n        }\n    }\n\n    // Si on sort de la boucle sans trouver d'intersection\n    return false;\n}\n\n\nbool IntersectTorusRotation(Ray ray, Tore tor, float angle, vec3 axis, out Hit hit) {\n    // Obtenir le centre du tore\n    vec3 center = tor.c;\n\n    // Calculer la matrice de rotation basée sur l'axe et l'angle donnés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculer la matrice de rotation inverse pour transformer le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformer le rayon pour le positionner dans l'espace du tore rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translation vers le centre, rotation, puis translation inverse\n    transformedRay.d = normalize(invRot * ray.d);\n\n    // Effectuer l'intersection comme si le tore n'avait pas été tourné\n    return IntersectTorus(transformedRay, tor, hit);\n}\n\nbool IntersectTorusRotation2(Ray ray, Tore tor, float anglex, float angley, float anglez, out Hit hit) {\n    // Calculer le centre du tore\n    vec3 center = tor.c;\n\n    // Calculez la matrice de rotation\n    mat3 rot = rotationMatrixX(anglex) * rotationMatrixY(angley) * rotationMatrixZ(anglez);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformez le rayon pour le mettre dans l'espace du tore rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translate to center, rotate, then translate back\n    transformedRay.d = invRot * ray.d;\n\n    // Effectuez l'intersection comme si le tore n'était pas tourné\n    return IntersectTorus(transformedRay, tor, hit);\n}\n\nvoid translateTorus(inout Tore tor, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n    tor.c += translation;\n}\n\nvoid scaleTorus(inout Tore tor, float scalespeed, float minscale, float maxscale, float time) {\n\n    // Calculer le facteur d'oscillation\n    float oscillation = 0.5 * sin(time * scalespeed) + 0.5; // Oscille entre 0 et 1\n\n    // Adapter l'oscillation pour qu'elle varie entre minscale et maxscale\n    float scaleFactor = mix(minscale, maxscale, oscillation);\n\n    tor.t *= scaleFactor;\n}\n\nvoid rotateTore(out Tore tor, vec3 origin, float rayon, float time) {\n    float angle = time; // Vous pouvez ajuster la vitesse de rotation en multipliant \"time\" par un facteur\n\n    // Calculer la position relative du tore par rapport à \"origin\"\n    vec3 relativePos = tor.c - origin;\n\n    // Trouver une position sur le cercle de rotation\n    tor.c.x = origin.x + rayon * cos(angle);\n    tor.c.y = origin.y + rayon * sin(angle);\n    tor.c.z = origin.z; // Assumons que le mouvement est dans le plan XY\n\n    // Ajouter le décalage pour centrer le tore autour du point d'origine\n    tor.c += relativePos;\n}\n\n\n/**\n * Vérifie si un rayon intersecte une capsule.\n * La capsule est définie par deux sphères (aux extrémités) et un cylindre (au milieu).\n * La fonction teste d'abord l'intersection avec les sphères, puis avec le cylindre.\n * Si une intersection est trouvée, les informations d'intersection sont stockées dans la structure 'Hit'.\n *\n * @param ray Le rayon à tester pour l'intersection.\n * @param capsule La capsule avec laquelle tester l'intersection.\n * @param x Structure de sortie pour stocker les informations d'intersection si une intersection est trouvée.\n * @return 'true' si une intersection est trouvée, 'false' sinon.\n */\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n\n    // Créer deux sphères représentant les extrémités de la capsule\n    Sphere s1 = Sphere(capsule.a, capsule.r, capsule.i);\n    Sphere s2 = Sphere(capsule.b, capsule.r, capsule.i);\n\n    Hit hit1;\n    Hit hit2;\n    // Tester l'intersection avec les deux sphères\n    bool intersectS1 = IntersectSphere(ray, s1, hit1);\n    bool intersectS2 = IntersectSphere(ray, s2, hit2);\n\n    // Calculer la direction entre les deux centres des sphères\n    vec3 ba = capsule.b - capsule.a;\n    vec3 oa = ray.o - capsule.a;\n\n    // Calculer les coefficients pour l'équation quadratique\n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, ba), 2.0) / dot(ba, ba);\n    float b = 2.0 * (dot(ray.d, oa) - (dot(ray.d, ba) * dot(oa, ba)) / dot(ba, ba));\n    float c = dot(oa, oa) - pow(dot(oa, ba), 2.0) / dot(ba, ba) - capsule.r * capsule.r;\n\n    // Calculer le discriminant\n    float h = b * b - 4.0 * a * c;\n\n    // Si le discriminant est positif, il y a une intersection avec le cylindre de la capsule\n    if (h >= 0.0) {\n        float t1 = (-b - sqrt(h)) / (2.0 * a);\n        float t2 = (-b + sqrt(h)) / (2.0 * a);\n\n        // Choisir le point d'intersection le plus proche\n        float t = (t1 > 0.0) ? t1 : t2;\n\n        // Calculer le point d'intersection\n        vec3 pt = Point(ray, t);\n        // Projeter ce point sur la ligne reliant les centres des sphères\n        vec3 projection = capsule.a + (dot(pt - capsule.a, ba) / dot(ba, ba)) * ba;\n\n        // Vérifier si le point projeté est entre les deux centres des sphères\n        if (t > 0.0 && dot(ba, projection - capsule.a) > 0.0 && dot(-ba, projection - capsule.b) > 0.0) {\n            x = Hit(t, normalize(pt - projection), capsule.i);\n            return true;\n        }\n    }\n\n    // Si l'intersection avec la première sphère est valide et plus proche que la deuxième\n    if (intersectS1 && (intersectS2 && hit1.t < hit2.t || !intersectS2)) {\n        x = hit1;\n        return true;\n    }\n\n    // Si l'intersection avec la deuxième sphère est valide\n    if (intersectS2) {\n        x = hit2;\n        return true;\n    }\n\n    // Si aucune intersection n'a été trouvée\n    return false;\n}\n\n\nbool IntersectCapsuleRotate(Ray ray, Capsule cap, float angle, vec3 axis, out Hit hit) {\n    // Calculer le centre de la capsule\n    vec3 center = 0.5 * (cap.a + cap.b);\n\n    // Calculer la matrice de rotation basée sur l'axe et l'angle donnés\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculer la matrice de rotation inverse pour transformer le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformer le rayon pour le positionner dans l'espace de la capsule rotative\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - center) + center; // Translation vers le centre, rotation, puis translation inverse\n    transformedRay.d = invRot * ray.d;\n\n    // Effectuer l'intersection comme si la capsule n'avait pas été tournée\n    return IntersectCapsule(transformedRay, cap, hit);\n}\n\nvoid translateCapsule(inout Capsule cap, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n\n    cap.a += translation;\n    cap.b += translation;\n}\n\nvoid scaleCapsule(inout Capsule cap, float minscale, float maxscale, float time) {\n    float scaleSpeed = 4.0;\n    float oscillation = 0.5 * sin(time * scaleSpeed) + 0.5;\n    float scaleFactor = mix(minscale, maxscale, oscillation);\n\n    vec3 midPoint = (cap.a + cap.b) * 0.5;\n    cap.a = midPoint + (cap.a - midPoint) * scaleFactor;\n    cap.b = midPoint + (cap.b - midPoint) * scaleFactor;\n    cap.r *= scaleFactor;\n}\n\n\nvoid rotateCapsule(inout Capsule cap, float angleSpeed, float time) {\n    float theta = angleSpeed * time;\n\n    // Matrice de rotation autour de l'axe Y\n    mat3 rotationMatrix = mat3(\n        cos(theta), 0, sin(theta),\n        0, 1, 0,\n        -sin(theta), 0, cos(theta)\n    );\n\n    cap.a = rotationMatrix * cap.a;\n    cap.b = rotationMatrix * cap.b;\n}\n\n/**\n * Vérifie si un rayon intersecte un ellipsoïde.\n * Si une intersection est trouvée, les informations d'intersection sont stockées dans la structure 'Hit'.\n *\n * @param ray Le rayon à tester pour l'intersection.\n * @param ell L'ellipsoïde avec lequel tester l'intersection.\n * @param x Structure de sortie pour stocker les informations d'intersection si une intersection est trouvée.\n * @return 'true' si une intersection est trouvée, 'false' sinon.\n */\nbool IntersectEllipsoid(Ray ray, Ellipsoid ell, out Hit x) {\n    // Calculer le vecteur entre l'origine du rayon et le centre de l'ellipsoïde\n    vec3 ro = ray.o - ell.c;\n    vec3 rd = ray.d;\n\n    // Calculer l'inverse des rayons de l'ellipsoïde\n    vec3 invR = 1.0 / ell.r;\n    // Transformer l'origine et la direction du rayon par l'inverse des rayons de l'ellipsoïde\n    vec3 ood = ro * invR;\n    vec3 d = rd * invR;\n\n    // Calculer les coefficients pour l'équation quadratique\n    float A = dot(d, d);\n    float B = 2.0 * dot(d, ood);\n    float C = dot(ood, ood) - 1.0;\n\n    // Calculer le discriminant de l'équation quadratique\n    float det = B * B - 4.0 * A * C;\n\n    // Si le discriminant est positif, il y a une intersection\n    if (det > 0.) {\n        float t = (-B - sqrt(det)) / (2.0 * A);\n        // Vérifier si le point d'intersection est en avant du rayon\n        if (t > 0.) {\n            // Calculer le point d'intersection\n            vec3 p = Point(ray, t);\n            // Calculer la normale à la surface de l'ellipsoïde au point d'intersection\n            vec3 normal = normalize(2.0 * (p - ell.c) * invR);\n\n            // Stocker les informations d'intersection dans la structure Hit\n            x = Hit(t, normal, ell.i);\n            return true;\n        }\n    }\n\n    // Si aucune intersection n'a été trouvée\n    return false;\n}\n\nbool IntersectEllipsoidRotate(Ray ray, Ellipsoid ell, float angle, vec3 axis, out Hit hit) {\n    // Calculez la matrice de rotation\n    mat3 rot = rotationMatrix(axis, angle);\n\n    // Calculez la matrice de rotation inverse pour le rayon\n    mat3 invRot = transpose(rot); // La transposition d'une matrice de rotation est son inverse\n\n    // Transformez le rayon pour le mettre dans l'espace de l'ellipsoïde rotatif\n    Ray transformedRay;\n    transformedRay.o = invRot * (ray.o - ell.c) + ell.c; // Translation vers le centre, rotation, puis translation inverse\n    transformedRay.d = invRot * ray.d;\n\n    // Effectuez l'intersection comme si l'ellipsoïde n'était pas tourné\n    return IntersectEllipsoid(transformedRay, ell, hit);\n}\n\n\nvoid translateEllipsoid(inout Ellipsoid ell, vec3 maxTranslation, float translation_speed, float time) {\n    // Oscillation entre 0 et 1\n    float oscillation = 0.5 * (1.0 + sin(time * translation_speed));\n    vec3 translation = mix(vec3(0.0), maxTranslation, oscillation);\n\n    ell.c += translation;\n}\n\nvoid scaleEllipsoid(inout Ellipsoid ell, float scaleMin, float scaleMax, float scale_speed, float time) {\n    // Oscillation entre scaleMin et scaleMax\n    float oscillation = 0.5 * (1.0 + sin(time * scale_speed));\n    float scaleFactor = mix(scaleMin, scaleMax, oscillation);\n\n    ell.r *= scaleFactor;\n}\n\n\nvoid rotateEllipsoid(inout Ellipsoid ell, float angleSpeed, float time) {\n    float theta = angleSpeed * time;\n\n    // Matrice de rotation autour de l'axe Y\n    mat3 rotationMatrix = mat3(\n        cos(theta), 0, sin(theta),\n        0, 1, 0,\n        -sin(theta), 0, cos(theta)\n    );\n\n    // Appliquer la rotation à la position de l'ellipsoïde\n    ell.r = rotationMatrix * ell.r;\n}\n\n// Intersection de triangle\nbool IntersectTriangle(Ray ray, Triangle triangle, out Hit x) {\n    // Calcul des vecteurs de côté du triangle\n    vec3 v1v0 = triangle.v1 - triangle.v0;\n    vec3 v2v0 = triangle.v2 - triangle.v0;\n    // Vecteur entre l'origine du rayon et le premier sommet du triangle\n    vec3 rov0 = ray.o - triangle.v0;\n\n    // Calcul de la normale du triangle\n    vec3 n = cross(v1v0, v2v0);\n    // Calcul du vecteur q pour l'intersection\n    vec3 q = cross(rov0, ray.d);\n    // Inverse du dénominateur pour l'intersection\n    float d = 1.0 / dot(ray.d, n);\n    // Calcul des coordonnées barycentriques u et v\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    // Calcul de la distance t le long du rayon jusqu'à l'intersection\n    float t = d * dot(-n, rov0);\n\n    // Vérification si l'intersection est à l'intérieur du triangle\n    if (u < 0.0 || v < 0.0 || (u + v) > 1.0) return false;\n\n    // Mise à jour de l'information de l'impact\n    x.t = t;\n    x.n = n;\n    x.i = 0; // L'identifiant de texture n'est pas utilisé dans cet exemple\n    return t >= 0.0;\n}\n\n\n// Intersection de pyramide\nbool IntersectPyramid(Ray ray, Pyramid pyramid, out Hit hit) {\n    // Initialisation de la distance d'impact à une valeur très élevée\n    hit.t = 1e10;\n    bool intersected = false;\n    Hit tempHit;\n\n    // Vérification de l'intersection avec chaque côté de la pyramide\n    for (int i = 0; i < 4; ++i) {\n        if (IntersectTriangle(ray, pyramid.sides[i], tempHit)) {\n            // Si une intersection plus proche est trouvée, mise à jour de l'impact\n            if (tempHit.t < hit.t) {\n                hit = tempHit;\n                hit.i = pyramid.i; // Assignation de l'identifiant de texture de la pyramide\n                intersected = true;\n            }\n        }\n    }\n\n    // Vérification de l'intersection avec la base de la pyramide, divisée en deux triangles\n    // Définition des sommets pour la base de la pyramide\n    vec3 pBase1 = pyramid.sides[0].v1; // On suppose que c'est le premier sommet de la base\n    vec3 pBase2 = pyramid.sides[1].v1; // On suppose que c'est le deuxième sommet de la base\n    vec3 pBase3 = pyramid.sides[2].v1; // On suppose que c'est le troisième sommet de la base\n    vec3 pBase4 = pyramid.sides[3].v1; // On suppose que c'est le quatrième sommet de la base\n\n    Triangle baseTri1, baseTri2;\n\n    // Attribution des sommets pour le premier triangle de la base\n    baseTri1.v0 = pBase1;\n    baseTri1.v1 = pBase3;\n    baseTri1.v2 = pBase2;\n\n    // Attribution des sommets pour le second triangle de la base\n    baseTri2.v0 = pBase1;\n    baseTri2.v1 = pBase4;\n    baseTri2.v2 = pBase3;\n\n    // Test d'intersection avec les triangles de la base\n    if (IntersectTriangle(ray, baseTri1, tempHit)) {\n        if (tempHit.t < hit.t) {\n            hit = tempHit;\n            hit.i = pyramid.i; // Assignation de l'identifiant de texture de la pyramide\n            intersected = true;\n        }\n    }\n\n    if (IntersectTriangle(ray, baseTri2, tempHit)) {\n        if (tempHit.t < hit.t) {\n            hit = tempHit;\n            hit.i = pyramid.i; // Assignation de l'identifiant de texture de la pyramide\n            intersected = true;\n        }\n    }\n\n    // Si une intersection a eu lieu, normalisation de la normale de l'impact\n    if (intersected) {\n        hit.n = normalize(hit.n);\n    }\n\n    return intersected;\n}\n\n\n// Fonction pour faire tourner un point en utilisant une matrice de rotation\nvec3 rotatePoint(mat3 m, vec3 p) {\n    return m * p;\n}\n\nbool IntersectRotatingPyramid(Ray ray, Pyramid pyramid, float angle, vec3 axis, out Hit hit) {\n    // Créer une matrice de rotation à partir de l'axe et de l'angle\n    mat3 rotMat = rotationMatrix(axis, angle);\n    \n    // Faire tourner les sommets de la pyramide\n    Pyramid rotatedPyr;\n    for (int i = 0; i < 4; ++i) {\n        rotatedPyr.sides[i].v0 = rotatePoint(rotMat, pyramid.sides[i].v0);\n        rotatedPyr.sides[i].v1 = rotatePoint(rotMat, pyramid.sides[i].v1);\n        rotatedPyr.sides[i].v2 = rotatePoint(rotMat, pyramid.sides[i].v2);\n    }\n    rotatedPyr.i = pyramid.i;\n    \n    // Utiliser la fonction existante IntersectPyramid ou une logique similaire ici\n    return IntersectPyramid(ray, rotatedPyr, hit);\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.) {\n\n        x = Hit(t, vec3(0, 0, 1), 0);\n        return true;\n    }\n    return false;\n}\n\nvec3 Background(vec3 rd) {\n    // Définir les couleurs du ciel : haut et horizon\n    vec3 skyTopColor = vec3(0.0, 0.5, 0.8); // Bleu profond\n    vec3 skyHorizonColor = vec3(0.7, 0.9, 1.0); // Bleu clair presque blanc\n\n    // Mélanger en fonction de la direction vers le haut (z dans ce cas)\n    // En supposant que rd est normalisé et que rd.z est dans l'intervalle [-1, 1]\n    float t = 0.5 * (rd.z + 1.0); // Échelle à l'intervalle [0, 1]\n    return mix(skyHorizonColor, skyTopColor, t); // Interpoler entre les couleurs de l'horizon et du haut\n}\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n// Fonction pour créer une pyramide avec un centre de base et une hauteur donnés\nvoid createPyramid(out Pyramid pyr, vec3 baseCenter, float baseSize, float height, int textureId) {\n    float halfBase = baseSize * 0.5;\n    vec3 pTop = baseCenter + vec3(0.0, height, 0.0); // Ajuster la hauteur pour le sommet supérieur\n    vec3 pBase1 = baseCenter + vec3(-halfBase, 0.0, halfBase);\n    vec3 pBase2 = baseCenter + vec3(halfBase, 0.0, halfBase);\n    vec3 pBase3 = baseCenter + vec3(halfBase, 0.0, -halfBase);\n    vec3 pBase4 = baseCenter + vec3(-halfBase, 0.0, -halfBase);\n\n    // Attribuer les sommets aux côtés de la pyramide\n    pyr.sides[0].v0 = pTop; pyr.sides[0].v1 = pBase1; pyr.sides[0].v2 = pBase2;\n    pyr.sides[1].v0 = pTop; pyr.sides[1].v1 = pBase2; pyr.sides[1].v2 = pBase3;\n    pyr.sides[2].v0 = pTop; pyr.sides[2].v1 = pBase3; pyr.sides[2].v2 = pBase4;\n    pyr.sides[3].v0 = pTop; pyr.sides[3].v1 = pBase4; pyr.sides[3].v2 = pBase1;\n    pyr.i = textureId; // Attribuer l'identifiant de texture pour la pyramide\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    Sphere sph1=Sphere(vec3(0.,0.,1.),1.,2);\n    Sphere sph2=Sphere(vec3(2.,0.,2.),1.,3);\n    rotateSphere(sph2,iTime,vec3(0.,0.0,1.));\n    \n    //Cylindre\n    Cylinder cyl1 = Cylinder(vec3(5.0, 6.0, 2.0), vec3(5.0, 6.0, 4.0), 1.0, 2);\n    \n    //Ellipsoid\n    Ellipsoid ell1 = Ellipsoid(vec3(0.0, 5.0, 1.0), vec3(1.0, 1.5, 0.5), 4);\n    \n    //Capsule\n    Capsule cap1 = Capsule(vec3(5.0, 0.0, 3.0), vec3(5.0, 0.0, 1.0), 0.5, 6);\n    translateCapsule(cap1, vec3(1.0, 1.0, 2.0), 2.0, iTime);\n    \n    //Tore\n    Tore tor1 = Tore(vec3(-3.0, 3.0, 3.5), vec2(1.0, 0.5), 7);\n    scaleTorus(tor1, 4.0, 0.5, 1.0,iTime);\n    //Pyramid\n    Pyramid pyramid;\n    createPyramid(pyramid,vec3(0.0, 0.0, 5.0), 2.0, 2.0, 4);\n    \n    //PLAN\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectRotatingPyramid(ray,pyramid,iTime,vec3(0.0, 0.0, 1.0),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCapsule(ray,cap1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectTorus(ray,tor1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoidRotate(ray,ell1,iTime,vec3(0.0, 0.0, 1.0),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinderRotation(ray,cyl1,iTime,0.0,0.0,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\n\n// Teste si le point est dans l'ombre\nbool InShadow(vec3 point, vec3 lightPos, out float shadowFactor)\n{\n    vec3 toLight = lightPos - point;\n    float distanceToLight = length(toLight);\n    toLight = normalize(toLight);\n\n    Ray shadowRay = Ray(point + toLight * 0.001, toLight); // Décalage pour éviter l'auto-intersection\n    Hit shadowHit;\n\n    // Vérifie les intersections avec n'importe quel objet de la scène\n    if (Intersect(shadowRay, shadowHit))\n    {\n        // Si l'intersection est plus proche que la lumière, le point est dans l'ombre\n        if (shadowHit.t < distanceToLight)\n        {\n            shadowFactor = 0.0; // Dans l'ombre\n            return true;\n        }\n    }\n\n    shadowFactor = 1.0; // Pas dans l'ombre\n    return false;\n}\n\n// Calcul de l'occlusion ambiante\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    float ao = 0.0;\n    float occlusion = 0.0;\n    float radius = 1.0; // Définit le rayon dans lequel vérifier l'occlusion\n\n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // Direction dans l'hémisphère\n        Ray aoRay = Ray(p + n * 0.001, d); // Décalage de l'origine un peu le long de la normale pour éviter l'auto-intersection\n\n        Hit aoHit;\n        if (Intersect(aoRay, aoHit) && aoHit.t < radius) {\n            occlusion += 1.0; // Ce rayon a frappé quelque chose, donc augmenter l'occlusion\n        }\n    }\n\n    ao = 1.0 - occlusion / float(N); // La fraction de rayons qui n'ont rien frappé\n    return ao;\n}\n\nvec3 PhongIllumination(Material m, vec3 n, vec3 v, vec3 lightPos, float shininess, vec3 point)\n{\n    float shadowFactor;\n    if (InShadow(point, lightPos, shadowFactor))\n    {\n        return vec3(0.0); // Dans l'ombre, pas de composante diffuse ou spéculaire\n    }\n\n    vec3 ambient = 0.5 * m.d; // Couleur ambiante\n\n    // Composante diffuse\n    vec3 l = normalize(lightPos - point);\n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = diff * m.d * shadowFactor;\n\n    // Composante spéculaire\n    vec3 r = reflect(-l, n); // Réfléchir le vecteur lumineux sur la normale\n    float spec = pow(max(dot(r, v), 0.0), shininess);\n    vec3 specular = vec3(1.0) * spec * shadowFactor; // En supposant des reflets spéculaires blancs\n\n    return ambient + diffuse + specular;\n}\n\n// Applique le modèle de couleur avec l'illumination de Phong et les ombres\nvec3 Color(Material m, vec3 n, vec3 v, vec3 point)\n{\n    // Définit les positions des lumières\n    vec3 lightPos1 = vec3(1, 10, 10); // Position de la première lumière\n    \n    // Calcule la direction de vue\n    vec3 viewDir = normalize(v); // Calcule la direction de vue\n    \n    // Calcule l'occlusion ambiante avant l'éclairage direct\n    float ao = AmbientOcclusion(point, n, 16); // Utilisation de 16 échantillons pour l'AO\n\n    // Illumination de Phong avec ombres pour la première lumière\n    vec3 col = PhongIllumination(m, n, viewDir, lightPos1, 10.0, point);\n\n    // Applique l'occlusion ambiante à la couleur finale\n    col *= ao;\n\n    return col;\n}\n\n// Rendu\nvec3 Shade(Ray ray)\n{\n    vec3 color = vec3(0.0); // Initialise la couleur à noir\n    vec3 attenuation = vec3(1.0); // Commence sans atténuation\n\n    // Intersect contient toute la détection géométrique\n    Hit x;\n    bool hitSomething = Intersect(ray, x);\n    \n    if (hitSomething)\n    {\n        vec3 p = Point(ray, x.t); // Point d'intersection\n        Material mat = Texture(p, x.i);\n        \n        // Calcule la direction de vue\n        vec3 viewDir = normalize(-ray.d);\n        \n        // Calcule la couleur avec l'illumination de Phong et les ombres\n        color += attenuation * Color(mat, x.n, viewDir, p);\n\n        // Si le matériau est réfléchissant, calcule la réflexion\n        if (mat.reflectivity > 0.0)\n        {\n            // Calcule la direction de réflexion et crée un nouveau rayon\n            vec3 reflectedDir = reflect(ray.d,x.n);\n            Ray reflectedRay = Ray(p + reflectedDir * 0.001, reflectedDir); // Décalage pour éviter l'auto-intersection\n            \n            // Effectue un test d'intersection secondaire pour le rayon réfléchi\n            Hit reflectedHit;\n            if (Intersect(reflectedRay, reflectedHit))\n            {\n                vec3 reflectedPoint = Point(reflectedRay, reflectedHit.t);\n                Material reflectedMat = Texture(reflectedPoint, reflectedHit.i);\n                vec3 reflectedViewDir = normalize(-reflectedRay.d);\n                \n                // Calcule la couleur au point d'intersection du rayon réfléchi\n                vec3 reflectedColor = Color(reflectedMat, reflectedHit.n, reflectedViewDir, reflectedPoint);\n                \n                // Mélange la couleur réfléchie avec la couleur actuelle en fonction de la réflectivité du matériau\n                color = mix(color, reflectedColor, mat.reflectivity);\n            }\n            else\n            {\n                // S'il n'y a pas d'intersection pour le rayon réfléchi, utilise la couleur de fond\n                color = mix(color, Background(reflectedRay.d), mat.reflectivity);\n            }\n        }\n    }\n    else\n    {\n        color = Background(ray.d);\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=20.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}