{
    "Shader": {
        "info": {
            "date": "1534550044",
            "description": "A slight variation of an older shader I wrote months ago (https://www.shadertoy.com/view/MlffDs). This time trying out boolean ops, which sort of reveal almost classic 2D factal shapes as the planer surface cuts. Trying the same with 3D-julia sets later.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl3cWs",
            "likes": 5,
            "name": "boolean cut mandelbulb",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "mandelbulb",
                "spheretracing",
                "pbr",
                "booleanops"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 736
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// cut mandelbulb - trying out boolean ops on a mandelbulb object\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\nconst int MAX_ITER = 96;\nconst float STEP_SIZE = .75;\nconst float EPSILON = .001;\nconst float PI = 3.1415926;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Result {\n    vec3 point;\n    vec3 normal;\n    float dist;\n    int iter;\n    int id;\n};\n\nconst Result nullResult = Result (vec3 (.0), vec3 (.0), .0, 0, -1);\n\nmat2 r2d (in float a)\n{\n    float c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nfloat mandelbulb (vec3 pos, in float n, in float bail, in int iter)\n{\n    vec3 z = pos;\n    float dr = 1.;\n    float r = .0;\n    for (int i = 0; i < iter; i++) {\n        r = length (z);\n        if (r > bail) break;\n\n        // from cartesian to polar\n        float theta = acos (z.z / r);\n        float phi = atan (z.y, z.x);\n        dr = pow(r, n - 1.) * n * dr + 1.;\n\n        // scale and rotate the point\n        float zr = pow (r, n);\n        theta = theta * n;\n        phi = phi * n;\n\n        // back to cartesian\n        z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n        z += pos;\n    }\n\n    return .5 * log (r) * r / dr; // I just don't get this distance estimator here\n}\n\nfloat sdBox (in vec3 p, in vec3 size)\n{\n    vec3 d = abs (p) - size;\n    return min (max (d.x, max (d.y, d.z)), .0) + length (max (d, .0));\n}\n\nfloat map (in vec3 p)\n{\n    float d = mandelbulb (p, 8. + 8.*(.5 + .5*cos(iTime)), 4., 8);\n    p.xz *= r2d (45.*iTime);\n    p.yz *= r2d (75.*iTime);\n    float box = sdBox (p + vec3 (-.75*(.5 + .5*cos(iTime)), -.5, .0), vec3 (1., .5, .5 + 1.*(.5 + .5*cos (iTime))));\n\n    return max (d, -box);\n}\n\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    float d = map (p);\n    vec2 e = vec2 (epsilon, .0);\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d);\n\n    return normalize (n);\n}\n\nvec3 shadePBR (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p, d*EPSILON);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo = vec3 (.25);\n    float metallic = .35;\n    float roughness = .25;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.7, .4, .2)*7.;\n    lightColors[1] = vec3 (.2, .7, .4)*9.;\n\n    vec3 lightPositions[2];\n    float t = iTime;\n    float c = cos (t);\n    float s = sin (t);\n    lightPositions[0] = vec3 (1.14, 1.5, -1.75);\n    lightPositions[1] = vec3 (-.125, 1.5, 1.75);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (.04);\n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3 (.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for (int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize (lightPositions[i] - p);\n        vec3 H = normalize (V + L);\n        float dist = distance (p, lightPositions[i]);\n        float attenuation = 4./(dist*dist);\n        vec3 radiance = lightColors[i]*attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1., 2.);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX (N, H, roughness);\n        float G = geomSmith (N, V, L, roughness);\n        vec3 F = fresnelSchlick (max (dot (H, V), .0), F0, roughness);\n\n        vec3 kS = F;\n        kD = vec3 (1.) - kS;\n        kD *= 1. - metallic;\n        \n        vec3 nominator = NDF * G * F;\n        float denominator = 4. * max (dot (N, V), .0) * max (dot (N, L), .0);\n        vec3 specular = nominator / max (denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max (dot (N, L), .0);                \n        Lo += (kD*albedo/PI + specular)*radiance*NdotL;\n    }\n\n    vec3 ambient = kD * albedo;\n\n    return ambient + Lo;\n}\n\nResult raymarch (in Ray ray)\n{\n    Result res = nullResult;\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        res.iter = i;\n        float tmp = map (ray.ro + res.dist * ray.rd);\n        if (tmp < EPSILON) break;\n        res.dist += tmp * STEP_SIZE;\n    }\n\n    res.point = ray.ro + res.dist * ray.rd;\n    res.normal = normal (res.point, EPSILON*res.dist);\n\n    return res;\n}\n\nfloat shadow (in Ray ray, in vec3 lPos)\n{\n    float distToLight = distance (lPos, ray.ro);\n    float dist = .0;\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        float tmp = map (ray.ro + dist * ray.rd);\n        if (tmp < EPSILON) {\n            if (dist < distToLight)\n                return .125;\n            else\n                return 1.;\n        }\n        dist += tmp * STEP_SIZE;\n    }\n\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = 1.5 + .5 * (cos (iTime)*.5+.5);\n    float theta = (iMouse.x / iResolution.x) * PI;\n    float phi = -(iMouse.y / iResolution.y * 2. - 1.) * PI;\n    float x = r * sin (theta) * cos (phi);\n    float y = r * sin (theta) * sin (phi);\n    float z = r * cos (theta);\n    vec3 ro = vec3 (x, y, z);\n    float zoom = 2.;\n    vec3 lookAt = vec3 (.0);\n    vec3 forward = normalize (lookAt - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 right = normalize (cross (worldUp, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + zoom * forward;\n    vec3 i = camCenter + uv.x * right + uv.y * up;\n    vec3 rd = normalize (i - ro);\n\n    Ray ray = Ray (ro, rd);\n    Result res = raymarch (ray);\n    vec3 col = shadePBR (ro, rd, res.dist);\n\n    float fog = float (res.iter) / float (MAX_ITER);\n    col *= 1. - (fog * fog);\n\n    col = col / (.85 + col);\n    col *= vec3 (.95, .9, .85);\n    col = .3*col + .7*sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}