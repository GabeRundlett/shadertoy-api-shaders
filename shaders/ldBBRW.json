{
    "Shader": {
        "info": {
            "date": "1625659947",
            "description": "Raymarcher\nMove the mouse in the viewport to look around.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldBBRW",
            "likes": 2,
            "name": "Raymacher  9001.5",
            "published": 3,
            "tags": [
                "raymacher"
            ],
            "usePreview": 0,
            "username": "johannesCmayer",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "#define MAXRAYSTEPS 1000\n#define RAYEPSILON 0.0001\n#define NORMALEPSILON 0.0001\n\n#define SATURATION 0.4\n\n#define t iTime\n    \n//>>>>>>>>>>>>>>>>>>>>>>>>>>> Print Util\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nfloat print(vec2 fragCoord, float value, vec2 coord)\n{\n    // Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(16.0, 13.0);\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;    \n    vec3 vColour;        \n\tvec2 vPixelCoord1 = coord;\n    fDigits = 15.0;   \n\t\n\treturn PrintValue( (fragCoord - vPixelCoord1) / vFontSize, value, fDigits, fDecimalPlaces);     \n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\nstruct HitData\n{\n    float depth;\n    vec3 hitP;\n};\n \n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DistanceFunctions    \nmat2 rot(float a) \n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec4 formula(vec4 p) \n{\n    p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\n    //p.xz = abs(sin(p.xz+1.))-abs((p.xz-1.))-mod(p.xz, p.y);\n    p.y-=.25;\n    //p.xz*=rot(radians(35.*sin(iTime)+50.)); //Hier Sinus rein!\n    p.xy*=rot(radians(20.));\n    p=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\n\treturn p;\n}\n\nfloat de(vec3 pos) {\n#ifdef WAVES\n\t//pos.y+=sin(pos.z-t*6.)*.15; //waves!\n    pos.y+= tan(pos.z * 0.1); //waves!\n#endif\n    pos.z = mix(pos.z, pos.z*(4. - min(3.1,iTime)), max(iTime - 1., 1. )); //Zeit Raum Kontinuum brechen\n\t//float hid=0.;\n\tvec3 tpos=sin(pos);\n\ttpos.z=abs(3.-mod(tpos.z,6.));\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\treturn fr;\n}\n\nfloat udBox( vec3 p, vec3 pos, vec3 b )\n{\n  return length(max(abs(p + pos)-b,0.0));\n}\n\nfloat sphereF(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Operators\nfloat opRepSphere( vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereF( q , vec3(0.,0.,0.), 1.);\n}\n\nfloat opRepCube( vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5 * c;\n    return udBox( q , vec3(0.,0.,0.), vec3(1., 1., 1.));\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = opRepCube(p, vec3(20., 20., 20.));\n    float d2 = (sin(2.*p.x)*sin(2.*p.y)*sin(2.*p.z)) * 2.;\n    return d1+d2;\n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nfloat scene(vec3 p)\n{\n    //return de(p);\n    //return opDisplace(p);\n    //return opRepCube (p, vec3(20.,20.,20.));\n    return opRepSphere(p, vec3(20.,20.,20.));\n    //float s = opRepSphere(p, vec3(20.,20.,20.));\n    \n    //return min(c, s);\n    \n    return sphereF(p, vec3(0.,0.,5.), 1.);\n}\n\n//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Rotation\nvec3 RotateX(vec3 toRotate, vec3 camRot)\n{\n    mat3 rX = mat3 (\n        1.0, 0.0, 0.0,\n        0.0, cos(camRot.x), -sin(camRot.x),\n        0.0, sin(camRot.x), cos(camRot.x)\n        );  \n\n        return toRotate * rX;\n}\n\nvec3 RotateY(vec3 toRotate, vec3 camRot)\n{\n    mat3 rY = mat3 (\n        cos(camRot.y), 0.0,sin(camRot.y),\n        0.0, 1.0, 0.0,\n        -sin(camRot.y), 0.0, cos(camRot.y)\n        );  \n\n        return toRotate * rY;\n}\n\nvec3 RotateZ(vec3 toRotate, vec3 camRot)\n{\n    mat3 rZ = mat3 (\n        cos(camRot.z), -sin(camRot.z), 0.0,\n        sin(camRot.z), cos(camRot.z), 0.0,\n        0.0, 0.0, 1.0\n        );  \n\n        return toRotate * rZ;\n}\n\nvec3 Rotate(vec3 toRotate, vec3 camPos, vec3 camRot)\n{\n    return RotateZ(RotateY(RotateX(toRotate, camRot), camRot), camRot);    \n}\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 n= vec3(scene(vec3(p.x + NORMALEPSILON, p.y, p.z)) - scene(vec3(p.x - NORMALEPSILON, p.y, p.z)),\n                 scene(vec3(p.x, p.y + NORMALEPSILON, p.z)) - scene(vec3(p.x, p.y - NORMALEPSILON, p.z)),\n                 scene(vec3(p.x, p.y, p.z + NORMALEPSILON)) - scene(vec3(p.x, p.y, p.z - NORMALEPSILON))\n               );\n    \n    return normalize(n);\n}\n\nHitData raymarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = 0.;\n    HitData hd;\n    \n    rayDirection = normalize(rayDirection);\n    \n    for (int i = 0; i < MAXRAYSTEPS; i++)\n    {\n        float d = scene(rayOrigin + rayDirection * t);\n        if (d < RAYEPSILON)\n        {\n            hd.depth = d;\n            hd.hitP = rayOrigin + rayDirection * t;            \n            return hd;\n        }\n        t += d;\n    }\n    hd.depth = t;\n    hd.hitP = rayOrigin + rayDirection * t;\n    return hd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(t, t*1.5, t);\n    vec3 camRot = vec3((iMouse.y - iMouse.y / 2.) / 100., (-iMouse.x - iMouse.x / 2.) / 100., 0.);\n    \n    float screenSpaceX = fragCoord.x;\n    float screenSpaceY = fragCoord.y;\n    \n    screenSpaceX = (screenSpaceX - iResolution.x / 2.) / iResolution.y;\n    screenSpaceY = (screenSpaceY - iResolution.y / 2.) / iResolution.y;\n       \n    HitData hit = raymarch(camPos, Rotate(vec3(screenSpaceX, screenSpaceY, 1.)\n                                          , camPos, \n                                          \tcamRot));\n    \n    vec3 db = Rotate(vec3(screenSpaceX, screenSpaceY, 1.), camPos, camRot);\n    vec3 db2 = vec3(screenSpaceX, screenSpaceY, 1.);\n    \n    float printColor =  print(fragCoord, hit.depth, vec2(0., 0.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(hit.hitP).x, vec2(0., 20.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(vec3(1.,1.,1.)).y, vec2(0., 40.)) +\n        \t\t\t\tprint(fragCoord, calcNormal(vec3(1.,1.,1.)).z, vec2(0., 60.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 80.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 100.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 120.)) +\n        \t\t\t\tprint(fragCoord, 0., vec2(0., 140.));\n    \n    float printLerp = 0.;\n    \n    vec4 color;\n    \n    if (hit.depth > 200.)\n        color = vec4(0.,0.,0.2,1.);\n    else\n    \tcolor = vec4(mix((calcNormal(hit.hitP).x + 1.5 / 3.), printColor, printLerp),\n                     mix((calcNormal(hit.hitP).y + 1.5 / 3.), printColor, printLerp),\n                     mix((calcNormal(hit.hitP).z + 1.5 / 3.), printColor, printLerp), 1.);\n    \n    fragColor = color * vec4(SATURATION, SATURATION, SATURATION, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}