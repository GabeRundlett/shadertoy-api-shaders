{
    "Shader": {
        "info": {
            "date": "1538976437",
            "description": "Simulation of 2 fixed dipoles. Mouseable",
            "flags": 32,
            "hasliked": 0,
            "id": "MttBRN",
            "likes": 4,
            "name": "Dipolar Duo Dynamics",
            "published": 3,
            "tags": [
                "simulation",
                "physics"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 589
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    C = texture(iChannel0, U/R);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 R;\n#define N 2\nvec3 rot (vec3 p, vec3 d) {\n    float t = length(d);\n    if (t==0.)return p;\n    d = normalize(d);\n    vec3 q = p-d*dot(d,p);\n   \treturn normalize(p+(q)*(cos(t)-1.) + cross(d,q)*sin(t))*length(p);\n}\nvec3 F (vec3 A, vec3 B) {\n    A = A-B;\n\treturn A/dot(A,A)/length(A);\n}\nvec3 T (vec3 a, vec3 b, vec3 A, vec3 B) {\n\tvec3\n        ap = a+A,\n        an = a-A,\n        bp = b+B,\n        bn = b-B,\n        Fp = F(ap,bp)-F(ap,bn),\n        Fn = F(an,bn)-F(an,bp);\n    return cross(A,Fp)-cross(A,Fn);\n}\nvec3 O (int D, int d) {return texture(iChannel0, vec2(3*D+d,0)/R).xyz;}\nvec3 stepT (int D) {\n\tvec3 A = O (D, 1),\n   \t\ta = O (D, 0),\n        t = vec3(0);\n    for (int i = 0; i < N; i++) {\n    \tif (D==i) continue;\n        t += T(a, O(i,0), A, O(i,1));\n    }\n    // CHANGE THESE VALUES\n    // LEFT IS ENERGY LOSS\n    // RIGHT IS MOMENT OF INERTIA \n    return O(D,2)*0.998 + 0.005*t;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n   R = iResolution.xy;\n   int D = int(floor(U.x/3.));\n   if (D > N*3) discard;\n   int d = int(floor(mod(U.x,3.)));\n   if (d == 0) {\n   \t C = D==0?vec4(0.25,0,0,0):vec4(-.25,0,0,0);\n   } else if (d == 1) {\n     vec3 o = O(D,1);\n    C = vec4(rot(o,.5*O(D,2)),1);\n   \tif (D==0 && iMouse.z > 0.) {\n            vec4 mou = 2.*(iMouse-0.5*R.xyxy)/R.y;\n            vec3 k = normalize(vec3(mou.xy-4.*O(D,0).xy,-.4));\n        \tC.xyz = length(C.xyz)*k;\n        }\n    if (iFrame < 1) C = D==0?vec4(0,0,.13,0):vec4(1e-7,.13,0,0);\n   } else {\n    C = vec4(stepT(D),0);\n       if (D==0 && iMouse.z > 0.) C.xyz *= 0.;\n   \tif (iFrame < 1) C = vec4(0);\n   }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R;\nfloat intersect (vec2 coes) {\n    float det = coes.x*coes.x-4.*coes.y;\n    if (det < 0.) return 1e4;\n    return 0.5*(-coes.x-sqrt(det));\n}\nfloat sphere (vec3 p, vec3 d, vec3 c, float r) {\n\tc = p-c;\n    return intersect(vec2(2.*dot(c,d),dot(c,c)-r*r));\n}\nfloat ellipse (vec3 p, vec3 d, vec3 a, vec3 b, float r) {\n\ta = p-a;b = p-b;\n    float \n        rr = r*r,\n        ad = dot(a,d),\n        bd = dot(b,d),\n        aa = dot(a,a),\n        bb = dot(b,b);\n    return intersect(vec2(\n    \tad*aa-ad*bb+bd*bb-bd*aa-rr*(ad+bd),\n        -aa*bb+0.25*(aa*aa+bb*bb+rr*rr)+0.5*(aa*bb-rr*(aa+bb))\n    )/(ad*ad+bd*bd-rr-2.*ad*bd));\n}\nvec3 norEllipse (vec3 p, vec3 a, vec3 b) {\n    return normalize(normalize(p-a)+normalize(p-b));\n}\nvec3 O (int D, int d) {return texture(iChannel0, vec2(3*D+d,0)/R).xyz;}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    R = iResolution.xy;\n    vec4 pr = texture(iChannel2,U/R);\n    float w = pr.w;\n    U = 2.*(U-0.5*R)/R.x;\n    vec3 n,\n        p = vec3(0,0,-1),\n        d = normalize(vec3(U,2)),\n        A = O(0,1),\n        B = O(1,1),\n        a = O(0,0),\n        b = O(1,0),\n    \tap = a+A,\n        an = a-A,\n        bp = b+B,\n        bn = b-B;\n   \tfloat \n         ea = ellipse(p, d, ap, an, .3),\n         eb = ellipse(p, d, bp, bn, .3);\n    vec3 q = p+d*min(ea,eb);\n    if (ea < eb) n=norEllipse(q,ap,an);\n    else       n=norEllipse(q,bp,bn);\n    float ot = dot(ea<eb?normalize(A):normalize(B),n);\n    \n    \n    C = (0.2+0.8*max(0.,dot(n,vec3(0,0,-1))))*(ot<0.?vec4(.5,.1,.1,1):vec4(1))*(0.9+0.1*texture(iChannel1,reflect(d,n)) );\n       \n    if (ea>1e2&&eb>1e2) C = texture(iChannel1, d);\n\n    \n    \n    C.xyz += sin(vec3(1,2,3)*sqrt(w)*.5);\n    C.xyz = mix(C.xyz,pr.xyz,0.7);\n    float tracer = sphere (p,d,ap,0.005);\n    if (tracer > 1e2) {ap=bp; tracer = sphere(p,d,ap,0.005);}\n    if (tracer < 1e2) {\n    \tn = normalize(p+tracer*d-ap);\n    \tC.w = (max(0.,dot(n,vec3(0,0,-1))));\n    } else C.w = 0.;\n    C.w += 0.99*w;\n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R;\n#define N 2\nvec3 rot (vec3 p, vec3 d) {\n    float t = length(d);\n    if (t==0.)return p;\n    d = normalize(d);\n    vec3 q = p-d*dot(d,p);\n   \treturn normalize(p+(q)*(cos(t)-1.) + cross(d,q)*sin(t))*length(p);\n}\nvec3 F (vec3 A, vec3 B) {\n    A = A-B;\n\treturn A/dot(A,A)/length(A);\n}\nvec3 T (vec3 a, vec3 b, vec3 A, vec3 B) {\n\tvec3\n        ap = a+A,\n        an = a-A,\n        bp = b+B,\n        bn = b-B,\n        Fp = F(ap,bp)-F(ap,bn),\n        Fn = F(an,bn)-F(an,bp);\n    return cross(A,Fp)-cross(A,Fn);\n}\nvec3 O (int D, int d) {return texture(iChannel0, vec2(3*D+d,0)/R).xyz;}\nvec3 stepT (int D) {\n\tvec3 A = O (D, 1),\n   \t\ta = O (D, 0),\n        t = vec3(0);\n    for (int i = 0; i < N; i++) {\n    \tif (D==i) continue;\n        t += T(a, O(i,0), A, O(i,1));\n    }\n    // CHANGE THESE VALUES\n    // LEFT IS ENERGY LOSS\n    // RIGHT IS MOMENT OF INERTIA \n    return O(D,2)*0.998 + 0.005*t;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n   R = iResolution.xy;\n   int D = int(floor(U.x/3.));\n   if (D > N*3) discard;\n   int d = int(floor(mod(U.x,3.)));\n   if (d == 0) {\n   \t C = D==0?vec4(0.25,0,0,0):vec4(-.25,0,0,0);\n   } else if (d == 1) {\n     vec3 o = O(D,1);\n    C = vec4(rot(o,.5*O(D,2)),1);\n   \tif (D==0 && iMouse.z > 0.) {\n            vec4 mou = 2.*(iMouse-0.5*R.xyxy)/R.y;\n            vec3 k = normalize(vec3(mou.xy-4.*O(D,0).xy,-.4));\n        \tC.xyz = length(C.xyz)*k;\n        }\n    if (iFrame < 1) C = D==0?vec4(0,0,.13,0):vec4(1e-7,.13,0,0);\n   } else {\n    C = vec4(stepT(D),0);\n       if (D==0 && iMouse.z > 0.) C.xyz *= 0.;\n   \tif (iFrame < 1) C = vec4(0);\n   }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 R;\nfloat intersect (vec2 coes) {\n    float det = coes.x*coes.x-4.*coes.y;\n    if (det < 0.) return 1e4;\n    return 0.5*(-coes.x-sqrt(det));\n}\nfloat sphere (vec3 p, vec3 d, vec3 c, float r) {\n\tc = p-c;\n    return intersect(vec2(2.*dot(c,d),dot(c,c)-r*r));\n}\nfloat ellipse (vec3 p, vec3 d, vec3 a, vec3 b, float r) {\n\ta = p-a;b = p-b;\n    float \n        rr = r*r,\n        ad = dot(a,d),\n        bd = dot(b,d),\n        aa = dot(a,a),\n        bb = dot(b,b);\n    return intersect(vec2(\n    \tad*aa-ad*bb+bd*bb-bd*aa-rr*(ad+bd),\n        -aa*bb+0.25*(aa*aa+bb*bb+rr*rr)+0.5*(aa*bb-rr*(aa+bb))\n    )/(ad*ad+bd*bd-rr-2.*ad*bd));\n}\nvec3 norEllipse (vec3 p, vec3 a, vec3 b) {\n    return normalize(normalize(p-a)+normalize(p-b));\n}\nvec3 O (int D, int d) {return texture(iChannel0, vec2(3*D+d,0)/R).xyz;}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    R = iResolution.xy;\n    vec4 pr = texture(iChannel2,U/R);\n    float w = pr.w;\n    U = 2.*(U-0.5*R)/R.x;\n    vec3 n,\n        p = vec3(0,0,-1),\n        d = normalize(vec3(U,2)),\n        A = O(0,1),\n        B = O(1,1),\n        a = O(0,0),\n        b = O(1,0),\n    \tap = a+A,\n        an = a-A,\n        bp = b+B,\n        bn = b-B;\n   \tfloat \n         ea = ellipse(p, d, ap, an, .3),\n         eb = ellipse(p, d, bp, bn, .3);\n    vec3 q = p+d*min(ea,eb);\n    if (ea < eb) n=norEllipse(q,ap,an);\n    else       n=norEllipse(q,bp,bn);\n    float ot = dot(ea<eb?normalize(A):normalize(B),n);\n    \n    \n    C = (0.2+0.8*max(0.,dot(n,vec3(0,0,-1))))*(ot<0.?vec4(.5,.1,.1,1):vec4(1))*(0.9+0.1*texture(iChannel1,reflect(d,n)) );\n       \n    if (ea>1e2&&eb>1e2) C = texture(iChannel1, d);\n\n    \n    \n    C.xyz += sin(vec3(1,2,3)*sqrt(w)*.5);\n    C.xyz = mix(C.xyz,pr.xyz,0.7);\n    float tracer = sphere (p,d,ap,0.005);\n    if (tracer > 1e2) {ap=bp; tracer = sphere(p,d,ap,0.005);}\n    if (tracer < 1e2) {\n    \tn = normalize(p+tracer*d-ap);\n    \tC.w = (max(0.,dot(n,vec3(0,0,-1))));\n    } else C.w = 0.;\n    C.w += 0.99*w;\n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}