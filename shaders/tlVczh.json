{
    "Shader": {
        "info": {
            "date": "1610495198",
            "description": " Visualize Orthonormal basis functions to see which look smooth\n\nAbrupt change in color = bad\nblack color = very bad\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tlVczh",
            "likes": 10,
            "name": "Orthonormal basis comparison",
            "published": 3,
            "tags": [
                "tangent",
                "orthonormal",
                "basis",
                "binormal"
            ],
            "usePreview": 0,
            "username": "Dain",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "\n// Start from: https://www.shadertoy.com/view/lldGRM\n\n//Show orthonormal as rgb\n//Scaled by determinate(so color becomes black when it isn't near 1)\n//Abrupt change in direction doesn't look good when using these to orient tangent space normals\n//Uses box so we can see the z==-1 area, which isn't easy to see on a sphere\n//If you hold left mouse it changes the visualization to avoid using abs(), to detect any cases where the sign is flipped but it retains the same absolute value\n//It is not scaled by determinate when holding left mouse as black is a possible output color in this case\n\n//0 = pixar OrthobranchlessONB  https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n//1 = MBR 2a method\n//2 = MBR Frisvad(fails at z==-1)\n//3 = Frisvad with \"fix\" for z == -1 (looks dubious when holding left mouse)\n//4 = Nimitz Frisvad (bad determinate at z == -1)\n//5 = MBR Frisvad with clamping to work around z==-1 (my preferred method so far)\n//6 = MLA method provided in comment\n//7 = BeRo method in comment\n\n#define METHOD 2\n\n#if METHOD == 0\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2)\n{\n    //pixar method, supposedly this method is good, but I have not gotten good results when testing it\n    //because it abruptly changes orientation at z = 0\n\tfloat sign = n.z >= 0.f ? 1.0f : -1.f;\n\tfloat a = -1.0/(sign + n.z);\n\tfloat b = n.x * n.y * a; \n\tb1 = vec3(1.0f + sign * n.x * n.x * a, sign * b, -sign * n.x);\n\tb2 = vec3(b, sign + n.y * n.y * a, -n.y);\t\n}\n#elif METHOD == 1\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  // MBR method 2a variant, seems similiar to pixar\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n}\n#elif METHOD == 2\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  //MBR that isn't handling z == -1 \n  float a =  n.y/(1.0+n.z);\n \n  float b =  n.y*a;\n  float c = -n.x*a;\n\n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n}\n#elif METHOD == 3\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n   //looks good but has this ugly branch\n  if(n.z < -0.99995)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n#elif METHOD == 4\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n// nimitz's impl of frisvad, fails at z == -1\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n}\n#elif METHOD == 5\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  //MBR frizvald but attempts to deal with z == -1\n  float k = 1.0/max(1.0 + n.z,0.00001);\n // k = min(k, 99995.0);\n  float a =  n.y*k;\n\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n}\n#elif METHOD == 6\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  //MLA provided this in comments, it looks good but if you hold left mouse you can see that it flips\n  //the signs at -z\n  bool flip = n.z < 0.0;\n  n.z = abs(n.z);\n  float a =  n.y/(1.0+n.z);\n \n  float b =  n.y*a;\n  float c = -n.x*a;\n\n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n  if (flip) {\n    xp.z = -xp.z, yp.z = -yp.z;\n    vec3 t = xp; xp = yp; yp = t;\n  }\n}\n#elif METHOD == 7\nvoid basis(in vec3 n, out vec3 t, out vec3 b)\n{\n  b = normalize(cross(n, normalize(n.zxy - dot(n.zxy, n))));\n  t = normalize(cross(b, n));\n}\n\n#endif\n\n//------ below here is original\n\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(vec3 p)\n{\n return sdBox(p, vec3(.50))-.5;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n  float precis = 0.001;\n  float h=precis*2.0;\n  float d = 0.;\n  for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n#if 0\n\n\n#endif\n\nfloat Determinate(vec3 n, vec3 f, vec3 r){\nreturn   dot(n, cross(f, r ) );\n}\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\nfloat saturateNanToZero(float f){\n    if(isnan(f) || f <= 0.0){\n        return 0.0;\n   }\n   float f2 = abs(1.0-f);\n   return 1.0 - f2;\n  //return min(max(f, 0.0), 1.0);\n//return max(min(f, 1.0), 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n        \n        //get orthonormal at hit point, then see how far from 1 the determinate is..\n        vec3 r = vec3(0);vec3 f = vec3(0);\n    //    nor = nor.zxy;\n        basis(nor,f,r);\n    \n        float d = saturateNanToZero(Determinate(nor, f,r));\n      //  col.r = pow(d,1.0);\n      //  col.g = 0.0;\n      //  col.g = abs(f.x);\n        \n        //check for wild swings nearby..\n        //nor = normalize(nor.zxy +0.001);\n        //  vec3 r2 = vec3(0);vec3 f2 = vec3(0);\n       // basis(nor,f2,r2);\n       // float diff = saturate(min(dot(f2,f), dot(r2,r)));\n        //col.b = pow(diff,.10);\n           bool mouseBtn2Pressed = (iMouse.z >= 1.0);\n\n        //Full range of color to see any sign flips      \n       vec3 fullColor = ((r +f+nor)*.5 + .5);\n       vec3 absColor = abs(r+f+nor)*.71*pow(d,16.0);\n       \n       if(mouseBtn2Pressed){\n         col = fullColor;\n       }else{\n         col = absColor;\n       }\n       \n     //  col = mix(absColor,fullColor, abs(sin(iTime*.5)));\n    \n    //   col = abs(r +f+nor)*.71* pow(d,16.0);\n        \n    }\n    \n\n    \n\tfragColor = vec4( col,1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}