{
    "Shader": {
        "info": {
            "date": "1441330609",
            "description": "A point lit, rounded square tunnel, produced without the use of ray marching.",
            "flags": 0,
            "hasliked": 0,
            "id": "4lSXzh",
            "likes": 147,
            "name": "Traced Minkowski Tube",
            "published": 3,
            "tags": [
                "raytracing",
                "voronoi",
                "tunnel",
                "oldschool"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 29791
        },
        "renderpass": [
            {
                "code": "/*\n    Simplified, Traced Minkowski Tube.\n    ----------------------------------\n    \n    This was inspired by Shadertoy user Akaitora's \"Worley Tunnel\" which you can find here:\n    https://www.shadertoy.com/view/XtjSzR\n    \n    Akaitora had a question, but I didn't have room to answer, so this is for anyone who's \n    interested n understanding the reasoning behind the oldschool tunnel effect. I see a \n    \"lot\" of them around.\n    \n    I'll assume most know that the endless tunnel effect is a simplification of a raytraced, \n    cylindrically-mapped inner cylinder. Without going into detail, by restricting the \"XY\" \n    coordinates of the ray origin (camera position) \"ro\" to zero, the ray intersection \n    equation becomes almost trivial. For a 3D unit ray-direction vector, \"rd,\" the solution \n    is something along the lines of:\n    \n    float distance = 1./length(rd.xy);\n    \n    Applying the intesection point formula (sp = ro + rd*dist), the 3D surface point is \n    simply:\n    \n    // ro.xy is fixed to the origin moving along Z.\n\tvec3 sp = vec3(0, 0, time) + rd/length(rd.xy); \n    \n    The surface point coordinates enable you to color the surface using a 3D method, or in \n    the case of the endless tunnel effect, cylindrically map a texture, or texture-function,\n    (preferably seamless) onto the surface:\n    \n\tvec3 color = TexFunction(vec3 sp) { \n         return texUV(scaleU*atan(sp.y, sp.x)/6.2832, scaleV*sp.z); \n    }\n    \n    You can see that \"sp.z\" is equal to: \n    \n    ro.z(time)*scaleV + rd.z*scaleV(constant)/length(rd.xy);\n    \n    The light attenuation is usually a scaled inverse of the distance, or \"k*length(rd.xy)\" \n    and the normal vector is about as straight forward as it gets: \n    \n    vec3 sn = normalize(vec3(-sp.xy, 0.));\n    \n    Anyway, to save cycles, 1990s demo coders threw out the 3D surface information, bypassed\n    the normalization of the ray-direction vector, and a bunch of other stuff, until there \n    was virtually nothing left to calculate other than the texture coordinates and distance \n    attenuation.\n\n\tThe point is, for the price of just a few extra lines and almost no extra effort on the \n    part of the GPU, you could have a 3D \"lit\" tunnel, which is more visually enticing. Like\n    the oldschool tunnel demos, you could also have square, rounded square tunnels, etc.\n    \n    Hence, this simple demonstration. It's a point lit, rounded square tunnel, produced \n    without the use of raymarching. As a point of interest that's probably not interesting, \n    there's not a single \"for loop\" or \"if statement\" used in the code. Do I get points for \n    that? :)\n\n\tIf you ignore the 3D Voronesque function (which I'll explain another time), bump mapping, \n    amateur camera movement and extra lighting, there's barely any code here. In fact, I\n    believe you could fit a 3D lit, 3D-function mapped, possibly bumped, tunnel into a tweet\n    or two... but I'll leave that to Fabrice Neyret, Greg Rostami, etc. ;-)\n\n\t\n\tUpdate: Here's a private link to a cylindrically mapped tube I put together. It's for \n    those who'd like to see how to apply repeated 2D functions and textures:\n\thttps://www.shadertoy.com/view/ltSSR1\n    \n\n*/\n\n\n// 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n// 3D Voronoi-like function. Cheap, low quality, 1st and 2nd order 3D Voronoi imitation.\n//\n// I wrote this a while back because I wanted a stand-alone algorithm fast enough to produce regular, or \n// 2nd order, Voronoi-looking patterns in a raymarching setting. Anyway, this is what I came up with. \n// Obviously, it wouldn't pass as genuine 3D Voronoi, but there's only so much you can do with a few lines. \n// Even so, it has a Voronoi feel to it. Hence, Voronesque.\n//\n// Here's a rough explanation of how it works: Instead of partitioning space into cubes, partition it into \n// its simplex form, namely tetrahedrons. Use the four tetrahedral vertices to create some random falloff \n// values, then pick off the two highest, or lowest, depending on perspective. That's it. If you'd like to \n// know more, the function is roughly commented, plus there's a simplex noise related link below that should \n// make it more clear.\n//\n// Credits: Ken Perlin, the creator of simplex noise, of course. Stefan Gustavson's paper - \"Simplex Noise \n// Demystified.\" IQ, other \"ShaderToy.com\" people, Brian Sharpe (does interesting work), etc.\n//\n// My favorite simplex-related write up: \"Simplex Noise, keeping it simple.\" - Jasper Flick?\n// http://catlikecoding.com/unity/tutorials/simplex-noise/\n//\nfloat Voronesque( in vec3 p ){\n    \n    // Skewing the cubic grid, then determining the first vertex.\n    vec3 i  = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices. Now we have all four tetrahedral vertices.\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n    \n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    \n    // Falloff values from the skewed point to each of the tetrahedral points.\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Assigning four random values to each of the points above. \n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    \n    // Further randomizing \"d,\" then combining it with \"v\" to produce the final random falloff values. \n    // Range [0, 1]\n    d = fract(sin(d)*262144.)*v*2.; \n \n    // Reusing \"v\" to determine the largest, and second largest falloff values. Analogous to distance.\n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n   \n    // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    return  max(v.x, v.y) - max(v.z, v.w);  \n    \n    //return max(v.x, v.y); // Maximum, or regular value for the regular Voronoi aesthetic.  Range [0, 1].\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates, plus some movement about the center.\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y + vec2(.5*cos(iTime*.5), .25*sin(iTime*.5));\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1));\n    rd.xy *= rot(sin(iTime*.25)*.5); // Very subtle look around, just to show it's a 3D effect.\n    rd.xz *= rot(sin(iTime*.25)*.5);\n \n    // Screen color. Initialized to black.\n    vec3 col = vec3(0);\n    \n    // Ray intersection of a cylinder (radius one) - centered at the origin - from a ray-origin that has XY \n    // coordinates also centered at the origin.\n    //float sDist = max(dot(rd.xy, rd.xy), 1e-16); // Analogous to the surface function.\n    //sDist = 1./sqrt(sDist); // Ray origin to surface distance.\n    \n    // Same as above, but using a Minkowski distance and scaling factor. I tried it on a whim, and it seemed \n    // to work. I know, not scientific at all, but it kind of makes sense. They'll let anyone get behind a \n    // computer these days. :)\n    vec2 scale = vec2(.75, 1);\n    float power = 6.;\n    // Analogous to the surface function.\n    float sDist = max(dot( pow(abs(rd.xy)*scale, vec2(power)), vec2(1) ), 1e-16); \n    sDist = 1./pow( sDist, 1./power ); // Ray origin to surface distance.\n    \n    //if(sDist>1e-8){\n        \n        // Using the the distance \"sDist\" above to calculate the surface position. Ie: sp = ro + rd*t;\n        // I've hardcoded \"ro\" to reduce line count. Note that \"ro.xy\" is centered on zero. The cheap\n        // ray-intersection formula above relies on that.\n        vec3 sp = vec3(0, 0, iTime*2.) + rd*sDist;\n \n        // The surface normal. Based on the derivative of the surface description function. See above.\n        //vec3 sn = normalize(vec3(-sp.xy, 0.)); // Cylinder normal.\n        vec3 sn = normalize(-sign(sp)*vec3(pow(abs(sp.xy)*scale, vec2(power-1.)), 0.)); // Minkowski normal.\n        \n        // Bump mapping.\n        //\n        // I wanted to make this example as simple as possible, but it's only a few extra lines. Note the \n        // larger \"eps\" number. Increasing the value spreads the samples out, which effectively blurs the \n        // result, thus reducing the jaggies. The downside is loss of bump precision, which isn't noticeable \n        // in this particular example. Decrease the value to \"0.001\" to see what I'm talking about.\n        const vec2 eps = vec2(.025, 0.);\n        float c = Voronesque(sp*2.5); // Base value. Used below to color the surface.\n        // 3D gradient vector... of sorts. Based on the bump function. In this case, Voronoi.                \n        vec3 gr = (vec3(Voronesque((sp-eps.xyy)*2.5), Voronesque((sp-eps.yxy)*2.5), \n                        Voronesque((sp-eps.yyx)*2.5))-c)/eps.x;\n        gr -= sn*dot(sn, gr); // There's a reason for this... but I need more room. :)\n        sn = normalize(sn + gr*.1); // Combining the bump gradient vector with the object surface normal.\n\n        // Lighting.\n        //\n        // The light is hovering just in front of the viewer.\n        vec3 lp = vec3(0, 0, iTime*2. + 3.);\n        vec3 ld = lp - sp; // Light direction.\n        float dist = max(length(ld), .001); // Distance from light to the surface.\n        ld /= dist; // Use the distance to normalize \"ld.\"\n\n        // Light attenuation, based on the distance above.\n        float atten = min(1.5/max(1. + dist*.25 + dist*dist*.5, .001), 1.);\n        \n       \n        float diff = max(dot(sn, ld), 0.); // Diffuse light value.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 16.); // Specular highlighting.\n        // Adding some fake, reflective environment information.\n        float ref = Voronesque((sp + reflect(rd, sn)*.5)*2.5);\n       \n        // Coloring the surface with the Voronesque function that is used to bump the surface. See \n        // \"bump mapping\" above.\n        vec3 objCol = pow(min(vec3(1.5, 1, 1)*(c*.97 + .03), 1.), vec3(1, 3, 16)); // Cheap red palette.\n        //vec3 objCol = vec3(c*c*.9, c, c*c*.4); // Cheap green palette.\n        //vec3 objCol = vec3(pow(c, 1.6), pow(c, 1.7), c); // Purpley blue.\n        //vec3 objCol = vec3(c); // Grey scale.\n\n        // Using the values above to produce the final color.\n        //col = (objCol*(diff + ref*.25 + .25) + vec3(1., .8, .9)*ref*.25 + spec*vec3(.75, .9, 1.))*atten;\n        col = (objCol*(diff + ref*.35 + .25 + vec3(1, .9, .7)*spec) + (c + .35)*vec3(.25, .5, 1)*ref)*atten;\n        //col = ((vec3(1, .97, .92)*diff + ref*.5 + .25)*c + vec3(1., .8, .9)*ref*.3 + \n        //        vec3(.75, .9, 1.)*spec)*atten;\n        \n        \n         \n        \n    //}\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}