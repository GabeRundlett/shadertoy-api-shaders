{
    "Shader": {
        "info": {
            "date": "1615647835",
            "description": "3rd iteration of a shader I have been making in between writing a JavaScript project to make use of it",
            "flags": 0,
            "hasliked": 0,
            "id": "NdfGzM",
            "likes": 3,
            "name": "3rd improvement",
            "published": 3,
            "tags": [
                "messy"
            ],
            "usePreview": 0,
            "username": "jemappelle",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\n//--Operators\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\n//--Shapes (SDFs)\nfloat sphere(vec3 d, float r){ \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.2) - r;\n}\n\n//Return objects/shapes in environment\nfloat map(vec3 d){\n  \td = mod(d, 3.)-3.*0.5;\n    return mix(sdRoundedX(d.xy, 0.3, 0.12), sphere(d, 0.4), cos(iTime*0.2*0.8));\n}\n\n//--Shading\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.6 + .4;\n}\n\n//Measure normals for shading\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.001,2.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    //Re-define fftVariables\n    float fftDivider = 2.;\n    float low = lowFreqFFT/fftDivider;\n    float mid = midFreqFFT/fftDivider;\n    float high = highFreqFFT/fftDivider;\n\n\t//Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.4;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    \n    //Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.x, 1.,length(uv.x));\n  \n    //--Camera Positioning\n    //ro = Ray origin | p = Ray Origin Position\n    //rd = Ray distance\n  \tvec3 ro = vec3(0.+sin(iTime)/2., -zMotion, -8.+(iTime*4.));\n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv, 0.8));\n  \n    //hit = If the sphere trace hits an SDF, defined in 'map'\n  \tbool hit = false;\n  \tfloat shading = 0.;\n  \n    //dtm = Distance to march\n    //env = Environment / Distance field\n    float dtm = 75.;\n  \tfor(float i = 0.; i < dtm; i++){\n    \tfloat env = map(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/-dtm*low;\n      \t\tbreak;\n    \t}\n        //Step the ray origin position (sphere trace) forward by the environment\n        //with a multiplier to create some interesting effect\n    \tp += env * sin(rd-ro/dtm);\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*1.5)*0.4;\n  \tuv.y += sin(uv.x+iTime)*0.1;\n    \n    //--The following is more experimental code\n  \tfloat verLine = tan(smoothstep(0.06, 0.9,length(uv.y/(circle*(midFreqFFT*4.0)))));\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n    \n    \n    vec3 fogcolour = vec3(0.4,0.4,2.);\n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        color = mix(vec3(0.1,0.0,0.2), vec3(0.1, low,0.0), vec3(diffuse_directional(n,l)));\n        hit = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading) + vec3(circle + verLine)*0.9;\n        //color = vec3(circle - shading)+0.9;\n    \t//color = vec3(circle *= sin(verLine/1.)*iTime);\n  \t}\n  \tfloat t = length(ro-p)-5.0*mid; //lowFreqFFT/140.0;\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.2,0.2, high), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.2) - vec4((color * circle / 1.5), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}