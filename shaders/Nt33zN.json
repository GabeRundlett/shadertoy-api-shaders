{
    "Shader": {
        "info": {
            "date": "1635770386",
            "description": "A pulsating volumtric star using a 3D texture that is sampled with scaled texture coords. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt33zN",
            "likes": 4,
            "name": " Pulsating Volumetric Star",
            "published": 3,
            "tags": [
                "noise",
                "pulse",
                "star",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "LongJohnny",
            "viewed": 290
        },
        "renderpass": [
            {
                "code": "// A pulsating volumetric star using a 3D texture \n// that is sampled with scaled texture coords\n//\n// Below are some settings that can be used to \n// alter the shape of the star\n//\n// CONTROLS:\n// - Mouse to rotate the star\n// \n// The background stars were taken from duke:\n// https://www.shadertoy.com/view/MdtGRl\n// ----------------------------------------\n\n// DEMO SETTINGS (FEEL FREE TO CHANGE)\n#define ROTATION_SPEED .2\n#define PULSE_SPEED .3\n#define DENSITY .4\n#define INTENSITY 4.\n#define PULSE\n#define RADIUS 2.3\n\n// RAY MARCHING SETTINGS (DO NOT CHANGE)\n#define MAX_MARCH_STEPS 10\n#define MAX_MARCH_DIST 10.\n#define MIN_MARCH_DIST 0.01\n\nfloat sdScene(vec3 p);\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.27*mix( rg.x, rg.y, f.z );\n}\n\n// duke's stars\nvec3 stars(vec3 rd) {\n    vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\n    vec3 starbg = vec3(0.0);\n    starbg = mix(starbg, \n        vec3(0.8,0.9,1.0), \n        smoothstep(0.99, 1.0, stars)\n        *clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n    return starbg;\n}\n\nfloat density(vec3 p) {\n    \n#ifdef PULSE\n    float pulse = cos(iTime * PULSE_SPEED);\n#else\n    float pulse = 1.;\n#endif\n    vec3 noiseOffset = vec3(0.);\n    return .023 * abs(pulse) * texture(iChannel0, (p + noiseOffset) * pulse * DENSITY).r;\n}\n\nvec3 rayMarchDensity(vec3 ro, vec3 rd, float d, vec3 backgroundColor) {\n\n    float accum = 0.; \n    \n    for (int i = 0; i < 100; ++i) {\n        \n        d += 0.04;\n        \n        vec3 p = ro + rd*d;\n        \n        float ds = sdScene(p);\n        \n        accum += density(p);\n           \n        // Continue marching while distance is negative\n        // i.e. while we are still inside the shape\n        // Or when the density cannot be any larger\n        if(ds > 0.0001f || accum > 0.99f) break;\n    }\n    \n    vec3 color = vec3(\n    accum * INTENSITY,\n    pow(accum, 12.) * INTENSITY, \n    accum > .99 ? INTENSITY : 0.);\n    \n    return mix(backgroundColor, color, pow(accum,8.));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    \n    float d;\n    \n    for (int i = 0; i < MAX_MARCH_STEPS; ++i) {\n        \n        vec3 p = ro + rd*d;\n        \n        float ds = sdScene(p);\n           \n        if(ds > MAX_MARCH_DIST || abs(ds) < MIN_MARCH_DIST) break;\n        \n        d += ds;\n    }\n    \n    return d;\n}\n\nfloat sdScene(vec3 p) {\n    return sdSphere(p, RADIUS);\n}\n\nvec3 addMouseControl(vec3 ro) {\n    vec2 m = iMouse.xy/iResolution.xy;\n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // From [-1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 origin = vec3(0.);\n    \n    // Camera rotation\n    float rotationRadius = 3.5;\n    vec3 ro = vec3(\n        rotationRadius * sin(iTime * ROTATION_SPEED), \n        0.f, \n        -rotationRadius * cos(iTime * ROTATION_SPEED));\n    ro = addMouseControl(ro);\n\n    vec3 rd = rayDir(ro, origin, uv); \n    \n    // Raymarching to find surface\n    float d = rayMarch(ro, rd); \n    \n    // Background color using duke's stars\n    vec3 col = stars(rd); \n    if (d < MAX_MARCH_DIST) {\n        \n        // Raymarching within shape\n        col = rayMarchDensity(ro, rd, d, col);\n    } \n    \n    // Tone Mapping \n    //col = acesFilmTonemapping(col);\n    //col = reinhardTonemapping(col);\n    \n    // Gamma correct ^(1/2.2)\n    col = pow(col, vec3(.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 rayDir(vec3 ro, vec3 origin, vec2 uv) {\n    \n    vec3 d = normalize(origin - ro);\n    \n    vec3 r = normalize(cross(vec3(0.,1.,0.), d));\n    vec3 u = cross(d, r);\n    \n    return normalize(d + r*uv.x + u*uv.y); \n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat smin(float a, float b, float k) {\n    \n    /*float h = max(0., min(1., (b - a)/k + .5));\n    float m = h * (1. - h) * k;\n       \n    return a * k + b * (1. - k) - m * .5;*/\n    \n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// ACES Tonemapping found here: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n// Note: Oversaturates brights. For more realistic rendering use: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 acesFilmTonemapping(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    \n    vec3 color = (x*(a*x+b))/(x*(c*x+d)+e); \n    return clamp(color,0.0,1.0);\n}\n\nvec3 reinhardTonemapping(vec3 color) {\n    return color = color / (color + vec3(1.0));\n}\n\n/* ----- Distance functions ---------- */\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}