{
    "Shader": {
        "info": {
            "date": "1558260178",
            "description": "Optimized for Synesthesia ",
            "flags": 0,
            "hasliked": 0,
            "id": "wtB3Rz",
            "likes": 5,
            "name": "Gravy Wave CC",
            "published": 3,
            "tags": [
                "copy2"
            ],
            "usePreview": 0,
            "username": "pestrov",
            "viewed": 819
        },
        "renderpass": [
            {
                "code": "/* (Fictional) visual of B-mode polarization, indirect evidence of \"primordial\" gravity waves.\n\n  Inspired by http://bicepkeck.org/visuals.html\n \"Gravitational waves from inflation generate a faint but distinctive twisting pattern in\n the polarization of the CMB, known as a \"curl\" or B-mode pattern. For the density\n fluctuations that generate most of the polarization of the CMB, this part of the primordial\n pattern is exactly zero. Shown here is the actual B-mode pattern observed with the BICEP2\n telescope, with the line segments showing the polarization from different spots on the sky.\n The red and blue shading shows the degree of clockwise and anti-clockwise twisting of this\n B-mode pattern.\"\n\n For explanatory info, see:\n http://wwwphy.princeton.edu/cosmology/capmap/polscience.html\n http://physics.stackexchange.com/questions/103934/what-do-the-line-segments-on-the-bicep2-b-mode-polarization-map-mean\n\n*/\n\n/* Overall plan:\n x generate scalar noise f(x, y, t) for each point on the plane, varying over time.\n x for each pixel, color red for positive or blue for negative, white in the middle.\n   => bgcolor\n - for each pixel, find out what grid point we're nearest.\n   - find the degree of twisting for that grid point (a separate noise function?)\n     g(x, y, t) => (m, a) magnitude and angle\n     or maybe that's two separate functions. Anyway...\n   - compute the line segment(rotated rectangle) representing the twisting.\n   - decide whether current pixel is inside, outside, or on the edge of that rectangle.\n   - mix bgcolor and black accordingly.\n     \n*/\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nconst float cellSize = 0.14; // size of each grid cell as portion of viewport\nconst float scale = 1.5;\nfloat time;\nconst float lineThick = 0.01, borderThick = 0.005;\nconst int nSamples = 20;\n\nfloat sampleVolume() {\n\tfloat total = 0.0;\n\tfor (int i=0; i < nSamples; i++) {\n\t\ttotal += texture(iChannel0, vec2(float(i) * 0.5 / float(nSamples), 0.25)).x;\n\t}\n\treturn total / float(nSamples);\n}\n\n// Generate red/white/blue value representing \"twist\" of B-mode polarization.\n// TODO: wish I could get more of the \"loopy\" shape that the real thing has.\n// Could do that using a sort of ripples-from-several-charges effect.\nvec4 twistColor(vec2 p) {\n\tfloat intens = snoise(vec3(p.x, p.y, time)) * 0.9;\n\t// Modify the shape of the curve, keeping it closer to zero longer:\n\t// intens *= intens * intens * 8.0;\n\tfloat i2 = pow(intens, 1.7) * 1.7;\n\n\tif (iChannelTime[0] > 32.0) {\n\t\tfloat sv = sampleVolume();\n\t\ti2 *= (sv * sv + 1.0);\n\t}\n\t\n\tvec4 color;\n\tif (intens > 0.0) {\n\t\tcolor = vec4(1.0, 1.0 - i2, 1.0 - i2, 1.0);\n\t} else {\n\t\tcolor = vec4(1.0 - i2, 1.0 - i2, 1.0, 1.0);\n\t}\n\treturn color;\n}\n\n/*\n// antialias coefficient\n#define aa(d) ((linethick - (d)) / linethick)\n*/\nfloat aa(float d) {\n\treturn (lineThick - d) / lineThick;\n}\n\n// Compute whether p is inside, outside, or on the edge of\n// a rotated rectangle representing blah blah ...\n// Where <= 0 is inside, >= 1 is outside.\nfloat barDist(vec2 p) {\n\t// Find center of grid cell.\n\tvec2 c = floor(p / cellSize + 0.5) * cellSize;\n\n\t// generate amplitude and angle\n\tfloat amp = abs(snoise(vec3(c.xy, time))) * 0.125;\n\tfloat alpha = snoise(vec3(c.xy, time)) * 3.14159;\n\t\n\t//## Here is where I need to write the code for the rotated rectangle\n\t// and its distance test.\n\t\n\tfloat d = distance(p, c);\n\tif (d > amp) return 1.0;\n\t// angle to current pixel from center of circle\n\tfloat a = atan(p.y - c.y, p.x - c.x);\n\t// dist from p to line\n\tfloat dd = abs(sin(alpha - a) * d);\n\tif (dd < lineThick) {\n\t\treturn dd/lineThick;\n\t}\n\t\n\treturn 1.0;\n\t\n}\n\nconst vec4 black = vec4(0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0*q) * scale;\n    p.x *= iResolution.x / iResolution.y;\n\n    time = iTime * 0.1;\n    \n\tvec4 bgColor = twistColor(p);\n\t\n\tfloat d = barDist(p);\n\tfragColor = mix(black, bgColor, d);\n\t\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}