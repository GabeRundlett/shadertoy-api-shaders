{
    "Shader": {
        "info": {
            "date": "1490207431",
            "description": "Spherical harmonics visualizer. Drag to rotate",
            "flags": 0,
            "hasliked": 0,
            "id": "XsXyDl",
            "likes": 4,
            "name": "SphereSHVisualizer",
            "published": 3,
            "tags": [
                "sphericalharmonics"
            ],
            "usePreview": 0,
            "username": "fursund",
            "viewed": 1358
        },
        "renderpass": [
            {
                "code": "// Modified from https://www.shadertoy.com/view/lt2GRD\n\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients grace = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = grace;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nvec3 spherePos = vec3(0.0, 1.0, 0.0);\nvec3 planePos = vec3(0.0, 0.05, 0.0);\nfloat sphereRadius = 1.0;\n\nfloat raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {\n    vec3 ce = ro - spherePos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax)\n            return t;\n        }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 2.0, 2.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.25, 0.0) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = vec3(0.0);\n    vec3 nor;\n    float occ = 1.0;\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    // raytrace the plane\n    float tpla = 0.0;\n\n    // raytrace the sphere\n    float tsph = raytraceSphere(ro, rd, tmin, tmax, sphereRadius);\n    if (tsph > tmin) {\n        vec3 spos = ro + rd * tsph;\n        nor = normalize(spos - spherePos);\n        occ = 0.5 + 0.5 * nor.y;\n    }\n\n    if (tpla > tmin || tsph > tmin) {\n        col = calcIrradiance(nor) * occ;\n\n        // distant fog if we don't hit the sphere\n        if (tsph < tmin) {\n            col = mix(col, vec3(0.0), 1.0 - exp(-0.001 * tpla * tpla));\n        }\n    }\n\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}