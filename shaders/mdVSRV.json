{
    "Shader": {
        "info": {
            "date": "1681335556",
            "description": "WIP",
            "flags": 0,
            "hasliked": 0,
            "id": "mdVSRV",
            "likes": 0,
            "name": "noisier",
            "published": 3,
            "tags": [
                "noise",
                "gpt"
            ],
            "usePreview": 0,
            "username": "mpusch88",
            "viewed": 169
        },
        "renderpass": [
            {
                "code": "float snoise(vec3 v);\nfloat sdSphere(vec3 p, float r);\nfloat sdScene(vec3 p, float time);\nvec3 calcNormal(vec3 p, float time);\n\n// Permutation function\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\n// Inverse square root approximation function\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// ShaderToy main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = iTime * 0.5;\n\n    vec3 camPos = vec3(0, 0, -4.0);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camDir, camUp));\n    vec3 camForward = normalize(cross(camRight, camUp));\n\n    vec3 rayOrigin = camPos;\n    vec3 rayDirection = normalize(uv.x * camRight + uv.y * camUp + 2.0 * camForward);\n\n    // Raymarching loop\n    float t = 0.0;\n    float raymarchStep = 0.05;\n    const int maxSteps = 100;\n    vec3 pos = rayOrigin;\n    for (int i = 0; i < maxSteps; i++) {\n        pos = rayOrigin + t * rayDirection;\n        float sdf = sdScene(pos, time);\n        if (sdf < 0.001) {\n            break;\n        }\n        t += sdf * raymarchStep;\n    }\n\n    // Shading and output\n    vec3 normal = calcNormal(pos, time);\n    vec3 light = vec3(1.0, 1.0, 1.0);\n    vec3 lightDirection = normalize(light - pos);\n    float diffuse = max(0.0, dot(normal, lightDirection));\n    fragColor = vec4(vec3(diffuse), 1.0);\n}\n\n// Signed distance function for a sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Signed distance function for the scene\nfloat sdScene(vec3 p, float time) {\n    float displacement = snoise(p * 1.5 + time) * 0.2;\n    return sdSphere(p, 2.0 + displacement);\n}\n\n// Calculate the normal at a given point\nvec3 calcNormal(vec3 p, float time) {\n    float eps = 0.001;\n    vec3 ex = vec3(eps, 0, 0);\n    vec3 ey = vec3(0, eps, 0);\n    vec3 ez = vec3(0, 0, eps);\n    float x = sdScene(p + ex, time) - sdScene(p - ex, time);\n    float y = sdScene(p + ey, time) - sdScene(p - ey, time);\n    float z = sdScene(p + ez, time) - sdScene(p - ez, time);\n    return normalize(vec3(x, y, z));\n}\n\n// Simplex noise function\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    // x0 from second corner\n    vec3 x1 = x0 - i1 + C.xxx;\n    // x0 from third corner\n    vec3 x2 = x0 - i2 + C.yyy;\n    // x0 from last corner\n    vec3 x3 = x0 - D.yyy;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec4 p0 = permute(i.z + vec4(0.0, i1.z, i2.z, 1.0));\n    vec4 p1 = permute(p0 + i.y + vec4(0.0, i1.y, i2.y, 1.0));\n    vec4 p = permute(p1 + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0_new = vec3(a0.xy, h.x);\n    vec3 p1_new = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    // Normalize gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0_new, p0_new), dot(p1_new, p1_new), dot(p2, p2), dot(p3, p3)));\n    p0_new *= norm.x;\n    p1_new *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0_new, x0), dot(p1_new, x1), dot(p2, x2), dot(p3, x3)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}