{
    "Shader": {
        "info": {
            "date": "1716907254",
            "description": "continuing my quest for rainbows and color - lol\nmouse to effect change in colors, rotation and scale",
            "flags": 0,
            "hasliked": 0,
            "id": "M3dGRs",
            "likes": 7,
            "name": "more colorful Kaleidoscope8+üêÅ",
            "published": 3,
            "tags": [
                "circle",
                "particle",
                "neon"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 166
        },
        "renderpass": [
            {
                "code": "// Fork of \" colorful Kaleidoscope 18+\" by nayk. https://shadertoy.com/view/lX3GRf\n// 2024-05-28 14:07:31\n\n/*originals https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/MscXWM and other*/\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\n// customizable color from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,.1) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n\n    vec4 mouseColor = vec4(0.55,0.5,0.55,1.);\n    if(mouse!=vec2(1.)) {\n        mouseColor = hsv2rgb(vec3(mouse.x, mouse.y, 1.0));\n    }\n\n\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n    vec2 uv2;\n    uv = uv2 = mouseRotZoom(uv);\n    vec2 xy = fragCoord.xy / iResolution.xy; //Let's combine this into one line\n\n\n    float size = 30.;\n\n    // Aspect ratio of the viewport\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n  \n\n    // Adjust uv coordinates to keep squares as squares\n    uv.x *= aspectRatio;\n\n    // Creating grid of squares\n    uv = vec2(\n        float(int(uv.x * size)) / size,\n        float(int(uv.y * size)) / size\n    );\n\n    // Resetting the aspect ratio effect on x coordinate after grid placement\n    uv.x /= aspectRatio;\n    \n    vec4 col = vec4(0.);\n    \n    mat2 rot = mat2(vec2(col.x, col.y),\n        vec2(-col.z, col.w));\n    \n    mat2 identity = mat2(vec2(1.0, 0.0), vec2(0.0, 1.0));\n    \n    float a = (1.0 + sin(iTime)) / 2.0;\n    \n    mat2 skew = (identity * (1.0 - a)) + (rot * a);\n   \n    vec2 uv0 = uv;\n\n    vec3 finalcolor = vec3(0.0);\n\n    for (float i = 0.0; i<2.0; i++) {\n        uv *=0.5;\n\n        uv *= skew;\n        uv.x+=0.5*sin(iTime);\n        uv.y+=0.5*cos(iTime);\n        uv=fract(uv);\n        float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 5.2;\n        float si = sin(t);\n        float co = cos(t);\n        mat2 ma = mat2(co, si, -si, co);\n        uv*=ma;\n        vec4 O=fragColor;\n        vec2 U=fragCoord;\n\n        U = (U+U-(O.xy=iResolution.xy)) / O.y;\n        U = mouseRotZoom(U);\n        U*=ma;\n        float a = atan(U.y,U.x), k=.5, A;\n        float orig_a = a;\n        O -= O;\n#define dFunc  O+= (1.+cos(A=2.33*a+iTime)) * smoothstep(.5,0., length(vec2( fract(a*k*7.96)-.5, 16.*length(U)-1.6*k*sin(A)-8.*k))); a+=6.3;\n#define dFuncX3  dFunc dFunc dFunc  k+=k;\n       \n        dFuncX3 dFuncX3 dFuncX3 dFuncX3 dFuncX3 dFuncX3\n    \n        uv-=0.5;\n\n        float d2 = length(uv)*exp(-length(uv0));\n\n        vec3 col = hsv2rgb(vec3(3.1415/d2/k*mouse.x/mouse.y,0.9,0.9)).rgb; //palette(length(uv0));\n\n        d2=sin(d2*8. + iTime)/8.;\n        d2=abs(d2);\n\n        d2=0.02/d2;\n\n        finalcolor += col*d2*O.xyz;\n\n    }\n\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n\n    fragColor = vec4(finalcolor,1.0);\n\n    float hs = happy_star(uv2, anim);\n    vec2 dd = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    float ddd = dot(dd, dd);\n   \n    vec4 c2 = fragColor + vec4(hs*mouseColor.rgb*0.11, 1.0);\n\n    c2 -= hsv2rgb( fragColor.rgb );\n    c2 = 1.0 - c2;\n    fragColor = vec4(finalcolor,1.0) / mix( c2, vec4(finalcolor,1.0), ddd);\n\n    fragColor = fract(fragColor);\n\n    // and then finally add colored star\n    fragColor+= vec4(happy_star(uv2, anim) * mouseColor.rgb*0.05, 1.0);      \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}