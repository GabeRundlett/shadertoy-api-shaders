{
    "Shader": {
        "info": {
            "date": "1709525281",
            "description": "pink cloud with gamma hue contrast brightness",
            "flags": 0,
            "hasliked": 0,
            "id": "43lXW4",
            "likes": 1,
            "name": "pinkCloud-withparams",
            "published": 3,
            "tags": [
                "cloud"
            ],
            "usePreview": 0,
            "username": "gllmca",
            "viewed": 125
        },
        "renderpass": [
            {
                "code": "// Utility functions for color space conversion and hue adjustment\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 adjustHue(vec3 color, float hue) {\n    vec3 hsv = rgb2hsv(color);\n    hsv.x += hue; // Add hue rotation here\n    hsv.x = fract(hsv.x); // Ensure hue stays within the 0.0 to 1.0 range\n    return hsv2rgb(hsv);\n}\n\n// Color mapping functions as provided\nfloat colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n// Noise and pattern functions as provided\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p ) {\n    float time = iTime * 0.03; // control for speed\n    float f = 0.0;\n\n    f += 0.500000*noise( p + time  ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p + sin(time) );\n\n    return f/0.96875;\n}\n\nfloat pattern(in vec2 p) {\n    return fbm(p + fbm(p + fbm(p)));\n}\n\n// Main image rendering logic with brightness added\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float shade = pattern(uv);\n    vec4 color = colormap(shade); // Get the original color\n\n    // Parameters for adjustments (placeholders for demonstration)\n    float contrast = 0.85;\n    float gamma = 1.8;\n    float hue = 0.0;\n    float brightness = 0.90; // Brightness adjustment factor\n\n    // Apply contrast\n    color.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5;\n\n    // Apply gamma correction\n    color.rgb = pow(color.rgb, vec3(1.0 / gamma));\n\n    // Apply hue adjustment\n    color.rgb = adjustHue(color.rgb, hue);\n\n    // Apply brightness\n    color.rgb *= brightness;\n\n    fragColor = vec4(color.rgb, 1.0); // Use the adjusted color for the final output\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}