{
    "Shader": {
        "info": {
            "date": "1718903141",
            "description": "sources https://glslsandbox.com/e#57248.0\nhttps://glslsandbox.com/e#57058.1\n",
            "flags": 0,
            "hasliked": 0,
            "id": "X3cSW8",
            "likes": 4,
            "name": "flame of white",
            "published": 3,
            "tags": [
                "flame",
                "lines",
                "white"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 97
        },
        "renderpass": [
            {
                "code": "#define resolution iResolution.xy\n#define time iTime\n\nvec3 mod289(vec3 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\nreturn mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nmat2 rot(float a)\n{\nfloat c = cos(a);\nfloat s = sin(a);\nreturn mat2(c, s, -s, c);\n}\nvec3 fx(vec2 uv)\n{\n    float time = iTime;\nvec2 f = vec2(0.3);\nvec3 c = vec3(1.2,1.0,1.0);\nfloat light = 0.1;\n\nfor (float x = 1.1; x < 10.0; x += 1.0)\n{\nuv *= rot(x*200.0+sin(time*0.1));\n\nf = vec2(cos(cos(time*0.6+x + uv.x * x) - uv.y * dot(vec2(x + uv.y), vec2(sin(x), cos(x)))));\nlight += (0.04 / distance(uv, f)) - (0.01 * distance(vec2((cos(time*0.3 + uv.y))), vec2(uv)));\n\nc.y += sin(x+time+abs(uv.y))*0.3;\nif (c.y<0.8)\nc.y = 0.8;\nlight-=x*0.001 + c.y*0.001;\n\n}\nc *= light;\nc.x += (sin(time*2.4)*0.1);\n    return c;\n}\n\nfloat snoise(vec3 v)\n{\nconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\nvec3 i = floor(v + dot(v, C.yyy) );\nvec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\nvec3 g = step(x0.yzx, x0.xyz);\nvec3 l = 1.0 - g;\nvec3 i1 = min( g.xyz, l.zxy );\nvec3 i2 = max( g.xyz, l.zxy );\n\n// x0 = x0 - 0.0 + 0.0 * C.xxx;\n// x1 = x0 - i1 + 1.0 * C.xxx;\n// x2 = x0 - i2 + 2.0 * C.xxx;\n// x3 = x0 - 1.0 + 3.0 * C.xxx;\nvec3 x1 = x0 - i1 + C.xxx;\nvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\nvec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\ni = mod289(i);\nvec4 p = permute( permute( permute(\ni.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\nfloat n_ = 0.142857142857; // 1.0/7.0\nvec3 ns = n_ * D.wyz - D.xzx;\n\nvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\nvec4 x_ = floor(j * ns.z);\nvec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\nvec4 x = x_ *ns.x + ns.yyyy;\nvec4 y = y_ *ns.x + ns.yyyy;\nvec4 h = 1.0 - abs(x) - abs(y);\n\nvec4 b0 = vec4( x.xy, y.xy );\nvec4 b1 = vec4( x.zw, y.zw );\n\n//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\nvec4 s0 = floor(b0)*2.0 + 1.0;\nvec4 s1 = floor(b1)*2.0 + 1.0;\nvec4 sh = -step(h, vec4(0.0));\n\nvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\nvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\nvec3 p0 = vec3(a0.xy,h.x);\nvec3 p1 = vec3(a0.zw,h.y);\nvec3 p2 = vec3(a1.xy,h.z);\nvec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n//vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\nvec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\np0 *= norm.x;\np1 *= norm.y;\np2 *= norm.z;\np3 *= norm.w;\n\n// Mix final noise value\nvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\nm = m * m;\nreturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\ndot(p2,x2), dot(p3,x3) ) );\n}\n\n//////////////////////////////////////////////////////////////\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat prng(in vec2 seed) {\nseed = fract (seed * vec2 (5.3983, 5.4427));\nseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\nreturn fract (seed.x * seed.y * 95.4337);\n}\n\n//////////////////////////////////////////////////////////////\n\nfloat PI = 3.1415926535897932384626433832795;\n\nfloat noiseStack(vec3 pos,int octaves,float falloff){\nfloat noise = snoise(vec3(pos));\nfloat off = 1.0;\nif (octaves>1) {\npos *= 2.0;\noff *= falloff;\nnoise = (1.0-off)*noise + off*snoise(vec3(pos));\n}\nif (octaves>2) {\npos *= 2.0;\noff *= falloff;\nnoise = (1.0-off)*noise + off*snoise(vec3(pos));\n}\nif (octaves>3) {\npos *= 2.0;\noff *= falloff;\nnoise = (1.0-off)*noise + off*snoise(vec3(pos));\n}\nreturn (1.0+noise)/2.0;\n}\n\nvec2 noiseStackUV(vec3 pos,int octaves,float falloff,float diff){\nfloat displaceA = noiseStack(pos,octaves,falloff);\nfloat displaceB = noiseStack(pos+vec3(3984.293,423.21,5235.19),octaves,falloff);\nreturn vec2(displaceA,displaceB);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\nvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\nfloat xpart = gl_FragCoord.x/resolution.x;\nfloat ypart = gl_FragCoord.y/resolution.y;\n\nfloat clip = 300.0;\nfloat ypartClip = gl_FragCoord.y/clip;\nfloat ypartClippedFalloff = clamp(2.0-ypartClip,0.0,1.0);\nfloat ypartClipped = min(ypartClip,1.0);\nfloat ypartClippedn = 1.0-ypartClipped;\n//\nfloat xfuel = pow(1.0-abs(2.0*xpart-1.0),0.5);\n//\nfloat timeSpeed = 0.5;\nfloat realTime = timeSpeed*time;\nvec3 lines = fx(uv);\nvec2 coordScaled = 0.03*gl_FragCoord.xy;\nvec3 position = vec3(coordScaled,10.0) ;\nvec3 flow = vec3(1.1*(0.5-xpart)*pow(ypartClippedn,4.0),-1.0*xfuel*pow(ypartClippedn,64.0),0.0);\nvec3 timing = realTime*vec3(0.0,-10.7,1.1) + flow;\n//\nvec3 displacePos = vec3(1.0,1.5,1.0)*.4*position+realTime*vec3(0.01,-0.7,1.3);\nvec3 displace3 = vec3(noiseStackUV(displacePos,2,0.4,0.1),0.0);\n//\nvec3 noiseCoord = (vec3(2.0,1.0,1.0)*position+timing+0.4*displace3)/1.0;\nfloat noise = noiseStack(noiseCoord,3,0.4);\n//\nfloat flames = pow(ypartClipped,0.3*xfuel)*pow(noise,0.3*xfuel);\n//\nfloat f = ypartClippedFalloff*pow(1.0-flames*flames*flames,8.0);\nfloat fff = f+f+f;\nvec3 fire = 100.5*vec3(0.5,0.5,0.5)*fff*f+lines;\n\nfloat sparkGridSize = 30.0;\nvec2 sparkCoord = gl_FragCoord.xy - vec2(2.0,190.0*realTime);\nsparkCoord -= 30.0*noiseStackUV(0.01*vec3(sparkCoord,30.0*time),1,0.4,0.1);\nsparkCoord += 10.0*flow.xy*lines.xy;\nif (mod(sparkCoord.y/sparkGridSize,2.0)<1.0) sparkCoord.x += 0.5*sparkGridSize;\nvec2 sparkGridIndex = vec2(floor(sparkCoord/sparkGridSize));\nfloat sparkRandom = prng(sparkGridIndex) * (1.0 * 0.5);\nfloat sparkLife = min(10.0*(1.0-min((sparkGridIndex.y+(190.0*realTime/sparkGridSize))/(24.0-20.0*sparkRandom),1.0)),1.0);\nvec3 sparks = vec3(0.0);\nif (sparkLife>0.0) {\nfloat sparkSize = xfuel*xfuel*sparkRandom*0.18;\nfloat sparkRadians = 999.0*sparkRandom*2.0*PI + 2.0*time;\nvec2 sparkCircular = vec2(sin(sparkRadians),cos(sparkRadians));\nvec2 sparkOffset = (0.5-sparkSize)*sparkGridSize*sparkCircular;\nvec2 sparkModulus = mod(sparkCoord+sparkOffset,sparkGridSize) - 0.5*vec2(sparkGridSize);\nfloat sparkLength = length(sparkModulus);\n\nsparks = sparkLife*vec3(1.5,0.5,0.5)*f;\n}\n//\nfragColor = vec4(max(fire,sparks),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}