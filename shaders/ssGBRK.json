{
    "Shader": {
        "info": {
            "date": "1661176822",
            "description": "An extruded triangle grid Truchet variation.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssGBRK",
            "likes": 58,
            "name": "Extruded Triangle Grid Truchet",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "triangle",
                "truchet",
                "extrude"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 618
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Triangle Grid Truchet\n    ------------------------------\n    \n    I've been making a few technical shaders lately, so wanted to take a \n    break and code something simple.\n    \n    This is an extruded 2D simplex Truchet variation comprising three basic \n    tile configurations. It's not a common pattern, but some may have seen \n    it before. The 2D field is not difficult to construct: Simply render a \n    mixture of arcs or circles between triangle cell midpoints, then extrude \n    the result. Raymarching objects like this in a front-on fashion doesn't \n    present any challenges either.\n \n    I used an old extruded pattern template, then updated the colors and \n    lighting a bit. This was not a difficult shader to make. I was originally \n    going to give it a metallic look, but I might save that for one of the \n    more interesting variations I'm working on.\n\n\n    References:\n\n    // A two tiled variation using the same extrusion template.\n\tExtruded Octagon Diamond Truchet - Shane\n    https://www.shadertoy.com/view/3tGBWV\n\n    // BigWIngs's popular Youtube channel. It's always informative seeing how \n    // others approach various graphics topics.\n    Shader Coding: Truchet Tiling Explained! -  The Art of Code\n\thttps://www.youtube.com/watch?v=2R7h76GoIJM\n    \n    // A bump-mapped 2D compliment version of this pattern, or something to \n    // that effect.\n    slimy triangular truchet - mattz\n    https://www.shadertoy.com/view/lsffzX\n\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 10.\n\n// Subtle textured lines.\n#define LINES\n\n// Double arcs.\n//#define DOUBLE_ARC\n\n// Curve shape - Round: 0, Straight: 1.\n#define SHAPE 0\n\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n\n// Distance metrics.\nfloat dist(vec2 p){\n\n    // Circular or hexagonal bounds.\n    #if SHAPE == 0\n    return length(p);\n    #else \n    // Not a proper distance field, but it'll get the job done.\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x);\n    #endif\n\n}\n\n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n*/\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nfloat scale = 1./1.5;\n\nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(1./.8660254, 1))*scale;\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    // Vertex IDs for the quad.\n    vec2[3] vID; \n  \n    // Vertex IDs for each partitioned triangle.\n    if(gTri<0.){\n        vID = vec2[3](vec2(-.5, .5), vec2(.5, -.5), vec2(.5));\n    }\n    else {\n        vID = vec2[3](vec2(.5, -.5), vec2(-.5, .5), vec2(-.5));\n    }\n    \n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n    // Specific centered triangle ID.\n    ctr = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.;\n    id += ctr;\n    // Not used here, but for jigsaw pattern creation, etc, the vertex IDs\n    // need to be correctly centered too.\n    //vID[0] -= ctr; vID[1] -= ctr; vID[2] -= ctr; \n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// A standard square grid 2D blobby Truchet routine: Render circles\n// in opposite corners of a tile, reverse the pattern on alternate\n// checker tiles, and randomly rotate.\nvec3 tr(vec2 p){\n\n    \n        // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices.\n    vec2[3] v;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, v);\n    p = p4.xy;\n    vec2 triID = p4.zw;// + (vID[0] + vID[1] + vID[2])/3.;\n    \n    \n    \n    // Grid triangles. Some are upside down.\n    vec2 q = p*vec2(1, gTri); // Equivalent to the line above.\n    float tr = max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n\n     \n    // Nearest vertex ID.\n    float vert = 1e5;\n    vec3 midD;\n    float sL = length(v[0] - v[1]);\n    \n    // Random value based on the overall triangle ID.\n    float rnd = hash21(triID + .11);\n    float rnd2 = hash21(triID + .22);    \n   \n    // Random rotation, in incrents of 120 degrees to maintain symmetry.\n    p = rot2(floor(rnd*36.)*6.2831/3.)*p;\n\n    // Nearest vertex, vertex-arc and angle (subtended from each vertex) calculations.\n    vec2 vertID;\n    for(int i = 0; i<3; i++){\n        \n        //vertD[i] = length(p - v[i]);\n        vert = min(vert, dist(p - v[i]));\n        \n        vec2 vM = mix(v[i], v[(i + 1)%3], .5);\n        midD[i] = dist(p - vM);\n \n    }\n    \n    float pTh = sL/6.; // Arc thickness.\n    // Turning the circle distance into an arc.\n    float arc = abs(dist(p - v[0]) - sL/2.) - pTh;\n\n    // Edge midpoint vertices.\n    float mid = min(min(midD.x, midD.y), midD.z);\n    \n    float tile;\n    \n    // Triangle Truchet tiles.\n    if(rnd2<.4){\n    \n        // Tri-pronged tile.\n        //tile = min(min(arc.x, arc.y), arc.z);\n        tile = -(vert - (sL/2. - pTh));\n    }\n    else if(rnd2<.7){\n    \n        // Arc and circle tile.\n        tile = min(arc, midD.y - pTh);\n    }\n    else {\n         \n         // Midpoint circle tiles.\n         tile = mid - pTh;\n    }\n    \n    #ifdef DOUBLE_ARC\n    tile = abs(tile + pTh/2.25) - pTh/1.2; // Doubling the arcs.\n    #endif\n    \n     \n    return vec3(tile, mid, tr);\n\n\n}\n \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    \n    \n    // 2D Truchet distance -- for the extrusion cross section.\n    vec3 tr3 = tr(p.xy);\n    float obj = tr3.x;\n    \n    // Back plane with a slight triangle cell bevel.\n    float fl = -p.z - min(-tr3.z*4., .2)*.05;\n    //fl -= min(-tr3.z*2., .25)*.15;\n    //fl -= smoothstep(0., .07, -tr3.z)*.03;//smoothstep(.08, .15, obj)*.1;\n    //fl += tr3.z*.3;\n    \n    // Extrude the 2D Truchet object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    obj = max(obj, abs(p.z) - .125) - smoothstep(.05, .11, -obj)*.04;\n    // Proper extrusion formula for comparisson.\n    //obj = opExtrusion(obj, p.z, .125, .01) - smoothstep(.03, .25, -obj)*.1; \n    \n   \n    // Object ID.\n    objID = fl<obj? 0 : 1 ;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(d, .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.25, .25, 2);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    \n    \n    \n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec2[3] v;\n    //scale /= 3.;\n    vec4 p4 = getTriVerts(p.xy, v);\n    vec2 triID = p4.zw;// + (vID[0] + vID[1] + vID[2])/3.;\n    float svGTri = gTri;\n    // Grid triangles. Some are upside down.\n    vec2 q = p4.xy*vec2(1, gTri); \n    float tri = max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n    q = (p4.xy - normalize(p.xy/(p.z - 3.) - l.xy/(l.z - 3.))*.005)*vec2(1, gTri); \n    float tri2 = max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n    float b = max(tri2 - tri, 0.)/.005;\n\n    \n    // 2D Truchet face distace -- Used to render borders, etc.\n    //scale *= 3.;\n    vec3 tr3 = tr(p.xy);\n    float d = tr3.x;\n    p4 = getTriVerts(p.xy, v);\n    q = p4.xy*vec2(1, gTri); \n    float triB = tr3.z; //max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.;\n    \n    // Smooth borders.\n    float bord = abs(triB) - .003; \n    \n    \n    \n    // Subtle pattern lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5) - .125)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5) - .125)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif     \n     \n\n    vec4 col1 = vec4(1, .15, .4, 0);\n    vec4 col2 = vec4(.4, .7, 1, 0);\n \n    /*\n    // Extra color. Interesting, but it makes things look creepily anatomical. :)\n    vec2 fID = floor(triID + .5);\n    if(mod(fID.x, 2.)<.5) col1 *= vec4(1, 2.35, 1.5, 0);\n    if(mod(fID.y, 2.)<.5) col1 *= vec4(2, 1.5, 1, 0);\n    if(mod(fID.x, 2.)<.5) col2 *= vec4(1, 1.15, .9, 0).zxyw;\n    if(mod(fID.y, 2.)<.5) col2 *= vec4(1.15, 1, .9, 0).zxyw; \n    */\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The blue floor:\n       col2 = mix(col2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);  \n       // Blue with some subtle lines.\n       oCol = col2;//mix(col2, vec4(1), .25);//mix(col2/1.2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);\n       // Triangle borders: Omit the middle of edges where the Truchet passes through.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n       //oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, abs(bord - .06) - .005))*.8);\n       //oCol = mix(oCol, col2/1.15, (1. - smoothstep(0., .01, tri + .07)));\n\n       // Darken alternate triangles. \n       if(gTri<.0) oCol *= .8;\n        \n       // Using the Truchet pattern for some bottom edging.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, d - .015))*.8);\n       \n      \n    }\n    else {\n    \n        // Extruded Truchet:\n \n        // White sides with a dark edge. \n        oCol = mix(vec4(.9), vec4(0), 1. - smoothstep(0., .01, d + .05));\n        //df = mix(pow(df, 4.), df, 1. - smoothstep(0., .01, d + .05));\n     \n        \n        // Golden faces with some subtle lines.\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        \n        // Darken alternate checkers on the face only.\n        if(svGTri>0.) fCol *= .8;\n        \n        // Triangle borders: Omit the middle of edges where the Truchet passes through.\n        bord = abs(tri) - .003;\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        \n        \n        // Apply the colored face to the Truchet, but leave enough room\n        // for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .08));\n\n        \n    }\n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n   \n    // Specular reflection.\n    vec3 hv = normalize(-r + ld); // Half vector.\n    vec3 ref = reflect(r, n); // Surface reflection.\n    vec4 refTx = texture(iChannel0, ref); refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n    float rf = (gObjID == 0)? .1 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n    oCol += spRef*refTx*rf; //smoothstep(.03, 1., spRef) \n\n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n    \n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}