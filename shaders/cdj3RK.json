{
    "Shader": {
        "info": {
            "date": "1667877640",
            "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of this algorithm involves a creating a fast way to calculate the nearest N integer coordinates from a given central coordinate.\nUse the mouse to test this part of the algorithm.",
            "flags": 32,
            "hasliked": 0,
            "id": "cdj3RK",
            "likes": 1,
            "name": "Sampling Order (Cached)",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "const ivec2 TestImageSize = ivec2(16,9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//debugAllData(DATA, fragColor, fragCoord);\n    //return;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n    for(int iCoord = 0; iCoord < SamplingOrderCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + GetSamplingOrderCoord(iCoord, DATA).xy;\n        \n        if(fragTestIntCoord != samplingCoord)\n            continue;\n            \n        float hue = float(iCoord) / float(SamplingOrderCount);\n        \n        fragColor.rgb = hsv2rgb(vec3(hue, 1.0, 1.0));\n        return;\n    }\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n///////////////////////////////////////////////\n// DATA\n///////////////////////////////////////////////\n\n#define DATA iChannel3\n\nvoid debugAllData( sampler2D dataChannel, out vec4 fragColor, in vec2 fragCoord )\n{      \n    ivec2 iCoord = floorToInt(fragCoord);\n    fragColor = texelFetch(dataChannel, iCoord, 0);\n}\n\n// Sampling Order -------------------------------\n\nconst int SamplingOrderRow = 0;\nconst int SamplingOrderCount = 101;\n\nivec3 GetSamplingOrderCoord(int n, sampler2D data)\n{\n    ivec2 coord = ivec2(n, SamplingOrderRow);\n    \n    return ivec3(texelFetch(data, coord, 0));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Cached data buffer.\n// Things that only need to be calculated once will be stored here.\n\nvoid getSamplingCoords(out ivec3 coords[SamplingOrderCount], int maxIndex)\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    // NOTE: SamplingOrderCount and maxIndex are evaluated\n    // separately in hopes that the compiler\n    // will unroll the for loops\n    // and break early given one of the\n    // arguments is a constant.\n    // If we combine the two limits,\n    // it might be dumb and assume that\n    // the breaking condition is non-constant\n    // and therefore,\n    // there is no definite upper bound\n    // to the number of iterations,\n    // thus preventing the loop from being unrolled.\n    \n    int iCoord = 0;\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=SamplingOrderCount) return;\n    if(iCoord>=maxIndex) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=SamplingOrderCount) return;\n            if(iCoord>=maxIndex) return;\n        }\n    }\n}\n\nvoid UpdateSamplingOrderData( out vec4 fragColor, in ivec2 iCoord )\n{\n    if(iFrame != 0)\n    {\n        fragColor = texelFetch(iChannel0, iCoord, 0);\n        return;\n    }\n\n    ivec3 coords[SamplingOrderCount];\n    int coordComputeCount = min(SamplingOrderCount, iCoord.x+1);\n    getSamplingCoords(coords, coordComputeCount);\n    fragColor.xyz = vec3(coords[coordComputeCount-1]);\n    fragColor.w = 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = floorToInt(fragCoord);\n    \n    switch(iCoord.y)\n    {\n        case SamplingOrderRow:\n        {\n            UpdateSamplingOrderData(fragColor, iCoord);\n            return;\n        }\n    }\n    \n    fragColor = texelFetch(iChannel0, iCoord, 0);\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}