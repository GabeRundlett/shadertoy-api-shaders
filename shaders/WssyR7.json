{
    "Shader": {
        "info": {
            "date": "1584436880",
            "description": "Using specular antialiasing based on Tokuyoshi and Kaplanyan work on top of a centered anisotropic beckmann NDF.",
            "flags": 32,
            "hasliked": 0,
            "id": "WssyR7",
            "likes": 26,
            "name": "Specular AntiAliasing",
            "published": 3,
            "tags": [
                "aa",
                "ndf",
                "beckmann",
                "specularaa"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 2848
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= Screen Space Specular Antialiasing\n//=======================================================\n//== Ressources :\n//== *- 2016 - Filtering Distributions of Normals for Shading Antialiasing\n//== \tby A. Kaplanyan, S. Hill, A. Patney, A. Lefohn (HPG 2016)\n//== project page : https://research.nvidia.com/publication/filtering-distributions-normals-shading-antialiasing\n//== demo : https://blog.selfshadow.com/sandbox/specaa.html\n//==\n//== *- 2017 - Error Reduction and Simplification for Shading Anti-Aliasing\n//== \tby Y. Tokuyoshi (technical report)\n//== project page : http://www.jp.square-enix.com/tech/publications.html\n//==\n//== *- Improving Geometric Specular Antialiasing\n//== \tby A. Kaplanyan & Y. Tokuyoshi\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's distance functions ( Sphere + SmoothUnionCubic )\n//== \thttps://iquilezles.org/articles/distfunctions\n//=======================================================\n    \nconst bool SLIDE_ANIMATION = true;\n\n//-----------------------------------------------------------------------------\n//-- Constantes ---------------------------------------------------------------\nconst float EPSILON             = m_eps_3f;\nconst float SAMPLES_WORLD       = 32.;\nconst float SAMPLES_SHADOWS \t= 32.;\nconst vec3  WORLD_BOUNDING_BOX  = vec3(2.);\nconst float WORLD_LIGHT_INTENSITY = 5.;\n\t  vec3  WORLD_LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  WORLD_BACKGROUND = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- Specular AA --------------------------------------------------------------\n//-- Snippet code for specular antialiasing\n//-- Based on A. Kaplanyan & Y. Tokuyoshi work\n//-----------------------------------------------------------------------------\nvoid specular_anti_aliasing(in vec3 half_vector, \n                           \tinout float alpha_x,\n                            inout float alpha_y)\n{\n     \t\n    float sigma = 0.50; \t\t\t\t\t\t\t//- screen space variance\n    float Kappa = 0.18;\t\t\t\t\t\t\t\t//- clamping treshold\n    vec2  H = half_vector.xy;\t\t\t\t\t\t\n    vec2  footprint_bounding_box = fwidth(H); \t\t//- abs(dfdx(slope_h)) + abs(dfdy(slope_h))\n\tvec2  variance = sigma*sigma*footprint_bounding_box*footprint_bounding_box;\n    vec2  kernel_roughness = min(vec2(Kappa), 2.*variance); \n    alpha_x = sqrt(alpha_x*alpha_x + kernel_roughness.x);\n    alpha_y = sqrt(alpha_y*alpha_y + kernel_roughness.y);\n}\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Scene SDF : vec2(SDF,MATID) ----------------------------------------------\nvec2 MAP(vec3 P)\n{       \n    float SDF = 1.;\n    SDF = opSUnn(SDF, sdSphere( P - vec3(+0.5,0.,0.), 0.8 ));    \n\tSDF = opSUnn(SDF, sdSphere( P - vec3(-0.5,0.,0.), 0.8 ));    \n    SDF = opSUnn(SDF, sdSphere( P - vec3(0.,0.,+0.5), 0.8 )); \n    SDF = opSUnn(SDF, sdSphere( P - vec3(0.,0.,-0.5), 0.8 )); \n\treturn vec2(SDF,1.);\n}\n\n//-----------------------------------------------------------------------------\n//-- Raymarching code ---------------------------------------------------------\nfloat \tworld_get_light_intensity()            { return WORLD_LIGHT_INTENSITY; }\nvec3 \tworld_get_light_direction()            { return WORLD_LIGHT_DIRECTION; }\nvec3 \tworld_get_background_color(in vec3 rd) { return WORLD_BACKGROUND; }\n\nvec2 world_intersect(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float t = 0.01;\n    vec2  R = vec2(-1.);\n    for(float istep=0.; istep<SAMPLES_WORLD && t<tmax; istep+=1.)\n    {\n        vec2 H = MAP(ro + t * rd);\n        if( H.x < EPSILON )\n        {\n            R = vec2(t,H.y);\n            break;\n        }\n        t += H.x;\n    }\n    return R;\n}\n\nfloat world_get_shadow(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float t = 0.01;\n    float r = 0.;\n    for(int istep=0; istep<int(SAMPLES_SHADOWS) && t<tmax; istep++)\n    {\n        vec2 H = MAP(ro + t * rd);\n        if( H.x < EPSILON) {break;}\n        t += H.x;\n    }\n    if(t>tmax) r = 1.;\n    return r;\n}\n\n\nvec3 world_get_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*MAP( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*MAP( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*MAP( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*MAP( pos + e.xxx ).x );  \n}\n\nvec3 raymarch(vec3 ro, vec3 rd, vec2 screen, float slide)\n{ \n    vec2  hitinfo = world_intersect(ro, rd, 100.);\n    float hit_dis = hitinfo.x;\n    float hit_obj = hitinfo.y;\n\n    if(hit_dis<0.) \n    {\n    \treturn world_get_background_color(rd);\n    }\n\n    vec3 hit_pos = ro+rd*hit_dis;\n    vec3 hit_nor = world_get_normal(hit_pos);\n    \n    vec3    P = hit_pos;\n    vec3    L = world_get_light_direction();\n    vec3    N = hit_nor;\n    vec3    V = -rd;\n        \n    mat3 TBN    = orthonormal_basis(N);\n    mat3 TBN_t  = transpose(TBN);\n    vec3 wo = normalize(TBN_t * V);\n    vec3 wi = normalize(TBN_t * L);\n    vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n    vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n    \n    float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n    float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n\n    float roughness_x \t= clamp( 0.01 + uiSlider(0), 0., 0.8);\n    float roughness_y \t= clamp( 0.01 + uiSlider(1), 0., 0.8);\n    float metallic \t\t= float(uiSlider(3)>0.5); \t\t// 0. or 1.\n    float reflectance \t= clamp(uiSlider(2),0.35,1.); \t// [0.35;1]\n    \n    float alpha_x \t\t= roughness_x*roughness_x;\n    float alpha_y \t\t= roughness_y*roughness_y;\n    vec3  base_color    = uiColor(0);\n    vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n    \n    if(screen.x>slide)\n    {\n        specular_anti_aliasing(wh,alpha_x,alpha_y);\n    }\n\n    //-- NDF + G + F\n    float lambda_wo = lambda_beckmann_anisotropic(wo,alpha_x,alpha_y);\n    float lambda_wi = lambda_beckmann_anisotropic(wi,alpha_x,alpha_y);\n    float D = ndf_beckmann_anisotropic(wh,alpha_x,alpha_y); \n    float G = 1. / (1. + lambda_wo + lambda_wi);\n\tvec3  F = fresnel_schlick(wi_dot_wh,F0);\n        \n    //-- Lighting\n  \tvec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;  \n   \tvec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n    float lighting = world_get_shadow(P+EPSILON*N,L,2.) * wg_dot_wi * world_get_light_intensity();\n    \n    vec3 C = lighting * (diffuse_lambert + specular_microfacet);\n    C = C / (C + vec3(1.0)); //-- Reinhard Tonemapping\n    C = pow(C,vec3(0.4545)); //-- Gamma Correction  \n    return(C);\n}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in vec2 screencoords)\n{\n    float slide = 0.5+0.5*sin(0.5*iTime);\n    if(!SLIDE_ANIMATION){slide = clamp(iMouse.x/iResolution.x,0.,1.);}\n    \n    vec3 color = raymarch(ro,rd,screencoords,slide);\n       \n    if( (screencoords.x-slide) <= 0.005 && (screencoords.x-slide) >= -0.005) \n        color = vec3(1.,0.,0.);\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    WORLD_LIGHT_DIRECTION = normalize( vec3(cos(iTime),1.5,sin(iTime)) );\n    \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 1., 4.+(sin(iTime)), 1. );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd,fragCoord.xy/iResolution.xy), 1.);\n\n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi_2 \t\t= 1.5707963267;  \nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */            \nconst float m_2_pi \t\t= 6.2831853071; \nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;     \n\n//----------------------------------------------------------------------------------\n//-- Ray ---------------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Intersection Functions ---------------------------------------------------\nvec2 intersection_axis_aligned_box(in vec3 ray_origin, in vec3 ray_direction, in vec3 box_parameters) \n{\n    vec3 m  = 1.0/ray_direction;\n    vec3 n  = m*ray_origin;\n    vec3 k  = abs(m)*box_parameters;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2(tN,tF);\n}\n\n//----------------------------------------------------------------------------------\n// IQ SDF functions ----------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//----------------------------------------------------------------------------------\n// SDF Operators -------------------------------------------------------------------\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat opUnn(float d1, float d2) \t{ return min(d1,d2); }\nfloat opSub(float d1, float d2) \t{ return max(-d1,d2); }\nfloat opInt(float d1, float d2) \t{ return max(d1,d2); }\nfloat opSUnn(float d1, float d2) \t{ return sminCubic(d1,d2,0.1); }\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n      \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Beckmann Distribution ----------------------------------------------------\nfloat p22_beckmann_anisotropic(float x, float y, float alpha_x, float alpha_y)\n{\n    float x_sqr = x*x;\n    float y_sqr = y*y;\n    float sigma_x = alpha_x * m_i_sqrt_2;\n    float sigma_y = alpha_y * m_i_sqrt_2;\n    float sigma_x_sqr = sigma_x*sigma_x;\n    float sigma_y_sqr = sigma_y*sigma_y;\n    return( \n            exp( -0.5 * ((x_sqr/sigma_x_sqr) + (y_sqr/sigma_y_sqr)) )\n    / //-------------------------------------------------------------------\n                    ( 2. * m_pi * sigma_x * sigma_y )\n    );\n}\n\nfloat ndf_beckmann_anisotropic(vec3 omega_h, float alpha_x, float alpha_y)\n{\n    float slope_x = - (omega_h.x/omega_h.z);\n    float slope_y = - (omega_h.y/omega_h.z);\n    float cos_theta = cos_theta(omega_h);\n    float cos_2_theta = cos_theta * cos_theta;\n    float cos_4_theta = cos_2_theta * cos_2_theta;\n    float beckmann_p22 = p22_beckmann_anisotropic(slope_x,slope_y,alpha_x,alpha_y);\n    return(\n                beckmann_p22\n    / //---------------------------\n                cos_4_theta\n    );\n}\n\nfloat lambda_beckmann_anisotropic(vec3 omega, float alpha_x, float alpha_y)\n{\n    float lambda = 0.;\n    float cos_phi = cos_phi(omega);\n    float sin_phi = sin_phi(omega);\n    float alpha_o = sqrt(cos_phi*cos_phi*alpha_x*alpha_x + sin_phi*sin_phi*alpha_y*alpha_y); \n    float nu = 1. / (alpha_o * tan_theta(omega));\n\n    if(nu < 1.6)\n        lambda = (1. - 1.259*nu + 0.396*nu*nu) / (3.535*nu + 2.181*nu*nu); \n    \n    return(lambda);\n}\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(40,30) _S _p _e _c _u _l _a _r _spc _A _A\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.05) _R _o _u _g _h _n _e _s _s _spc _X\n    _slider(24,87, 1, 0.50) _R _o _u _g _h _n _e _s _s _spc _Y\n        \n    _box(vec2(15,iResolution.y-100.),vec2(150,3),vec4(1.))\n        \n    _slider(24,125, 2, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,155, 3, 0.0) _M _e _t _a _l \n    _color(24,185, 0, vec3(1.,0.,0.)) _C _o _l _o _r\n                \n    fragColor = min(col.rgba,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}