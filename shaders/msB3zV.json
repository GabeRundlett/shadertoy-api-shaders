{
    "Shader": {
        "info": {
            "date": "1667875558",
            "description": "Creating an algorithm to get the nearest neighbor to an occupied pixel.\nPart of this algorithm involves a creating a fast way to calculate the nearest N integer coordinates from a given central coordinate.\nUse the mouse to test this part of the algorithm.",
            "flags": 0,
            "hasliked": 0,
            "id": "msB3zV",
            "likes": 1,
            "name": "Sampling Order",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "field"
            ],
            "usePreview": 0,
            "username": "Hatchling",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "\nconst int coordCount = 100;\n\nvoid getSamplingCoords(out ivec3 coords[coordCount])\n{\n    // coordinate:\n    // x, y: position\n    // z:    layer\n    \n    int iCoord = 0;\n    \n    coords[iCoord++] = ivec3(0);\n    if(iCoord>=coordCount) return;\n    \n    for(int iLayer = 1; ; iLayer++)\n    {\n        // Add primaries (left, right, down, up).\n        {\n            ivec3 swizzler = ivec3(-iLayer, iLayer, 0);\n            \n            coords[iCoord++] = ivec3(swizzler.xzy); // left\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yzy); // right\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zxy); // bottom\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zyy); // top\n            if(iCoord>=coordCount) return;\n        }\n        \n        // Add coordinates between corners and primaries.\n        for(int iMinor = 1; iMinor < iLayer; iMinor++)\n        {\n            // iLayer = length of longer (major) arm.\n            // iMinor = length of shorter (minor) arm.\n            \n            ivec4 swizzler = ivec4(iLayer, iMinor, -iLayer, -iMinor);\n            \n            coords[iCoord++] = ivec3(swizzler.xyx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.xwx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zyx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.zwx);\n            if(iCoord>=coordCount) return;\n            \n            coords[iCoord++] = ivec3(swizzler.yxx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.wxx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yzx);\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.wzx);\n            if(iCoord>=coordCount) return;\n        }\n        \n        // Add corners.\n        {\n            ivec2 swizzler = ivec2(-iLayer, iLayer);\n            \n            coords[iCoord++] = ivec3(swizzler.xxy); // left bottom\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.xyy); // left top\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yxy); // right bottom\n            if(iCoord>=coordCount) return;\n            coords[iCoord++] = ivec3(swizzler.yyy); // right top\n            if(iCoord>=coordCount) return;\n        }\n        \n    }\n}\n\nconst ivec2 TestImageSize = ivec2(16,9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    vec2 fragUV = fragCoord / iResolution.xy;\n    vec2 fragTestCoord = fragUV * vec2(TestImageSize);\n    ivec2 fragTestIntCoord = floorToInt(fragTestCoord);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseTestCoord = mouseUV * vec2(TestImageSize);\n    ivec2 mouseTestIntCoord = floorToInt(mouseTestCoord);\n    \n\tivec3 coords[coordCount];\n    getSamplingCoords(coords);\n    \n    for(int iCoord = 0; iCoord < coordCount; iCoord++)\n    {\n        ivec2 samplingCoord = mouseTestIntCoord + coords[iCoord].xy;\n        \n        if(fragTestIntCoord != samplingCoord)\n            continue;\n            \n        float hue = float(iCoord) / float(coordCount);\n        \n        fragColor.rgb = hsv2rgb(vec3(hue, 1.0, 1.0));\n        return;\n    }\n    \n\t\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) retType lengthSqr(type a) { type t = a; return dot2(t,t); }\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) retType distSqr(type a, type b) { type diff = a-b; return lengthSqr(diff); }\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n#define decl_floorToInt(retType, type) retType floorToInt(type a) { return retType(floor(a) + sign(a) * type(0.5)); }\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n    \n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}