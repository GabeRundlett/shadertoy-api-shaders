{
    "Shader": {
        "info": {
            "date": "1532086579",
            "description": "pause when its sideways. \nupper half has \"thickness\" set by cylinder height\"\nlower half has \"thickness\" set by iMouse.x (matters more if iMouse.x is close to the red dot)\niMouse.x sets \"chirality, spin count, negative chirality is poorly defined",
            "flags": 0,
            "hasliked": 0,
            "id": "lttyR7",
            "likes": 1,
            "name": "twist continuity",
            "published": 3,
            "tags": [
                "twistcontinuity"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 673
        },
        "renderpass": [
            {
                "code": "//based on               https://www.shadertoy.com/view/XsdBW8 \n//which is a variant of https://www.shadertoy.com/view/4dtfWr\n\n\n\n\n//note to self. it seems that iFrame fails to count up. not sure.\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n//-this shader has default background white\n\n\n//this experimental shader deforms a hyperslice for better lipschitz continuity within a twist-deformation.\n//the red dot splits mouse input parameters into 4 quadrants,where varying signs result in varying utility.\n\n//iMouse.x sets chirality,number of twists,this shader has good continuity for [positive chirality],to the right of the red dot\n//iMouse.x left of the red dot is \"poorly defined and only for bebugging\"\n\n//iMouse.y sets helix-thickness(and gamma correction for visibility),it is only discontinuous close to 0. for [ReciprocalThickMode]\n//#define ThickModeMouse\n//attempt to optimize for thinness,set by an epsilon/iMouse.y(not just bad near 0,but dividing by 0 near 0)\n//#define ThickModeReciprocalEps\n\n//thickness depends on height of cylinder\n//#define ThickModeByHeight\n//splitscreen shickmode\n#define ThickModeBySsy\n\n//add holes of a later version of XsdBW8,inner holes changed into rods of dynamick \"thickness\" to indicate a parameter\n//#define doHoles\n\n//this turned out better than expected,yay\n//could really need some bayer-dithering\n//i like this for its uncommon raymarching loop,that has escape orbits in its header.\n\n\n//damnit why was this mostly black, and i needed to log in again to see the whole thing?\n//it works great for my own canvas but in shadertoy i see only black.\n//may be a gpu thing?\n//i cant figure this out right now, help please...\n\n\n\n\n//eps and recEps sets [thickness] epsilon precision directly affects performance,and [object chubbyness]\nconst float recEps=128.;//reciprocal epsilon,powers od 2 likely increase precision,therefore we define epsilon reciprocally.\nconst float rmEps=1./recEps;\n//and in this shader \"brightness/contrast\"\nfloat rmIter=1./1064.;//raymarching iterations could also scale relative to epsilon!\nmat2 rt(float a){return mat2(sin(a+vec4(0,33,11,0)));}//tiny estimation of a rotation matrix.\n\n//rmOrbit()is the exit-condition of a raymarching-loop\n//this is commonly done via \"if(a)break\",except for tiny-code-crucnhing 1-tweet-shader challenges.\n//if a<=0,we marched too deep into the [darkening fog],that darkens with each step.\n//if b<=rmEps,we are close enough to a surface/root,within an arbitiary Epsilon-precision\nbool rmOrbit(float a,float b){\n //;return min(a,b-rmEps)>0.//clean black horizon\n ;return b>b-a&&b>rmEps//clean bright horizon is often better for [glow-contrast] of [step-intensive outlines],aka [glow]\n //;return a>0.&&b-rmEps>0.//messy toggling quadrant(original version)\n ;}\n//ollj fixed ther lipschitz continuity of this helix,by modifying its shape\n\nfloat df(vec3 q,vec2 m,vec2 U//distance field of a helix\n){float l=length(q.xy)\n ;float a=atan(q.y,q.x)\n ;float t=max(abs(q.z)-6.,l-4.)//cylinder\n //note that the 2 flat ends(and the cylinder for small \"recEps\")are still discontinuous,due to union with cylinder-capping-planes.\n //;float scale=length(q.xy)//lipschitz oblivious\n ;float twists=m.x*20.\n //the following is a sloppy but advanced bound for better lipschitz continuity\n //...within a twist-deform(which is inherently discontinuous)\n //the trick is to deform the object procedurally for better continuiity,without being too noticable;\n //is lazy,because we avoid lipschitz-discontinuity by shaping the helix 2d hyperslice into a bowtie-shape.\n //the more turns the spiral gets,the thicker it gets\n //we interpolate between 2 cases of(minimum and maximum twitst)\n //and scale that a bit for better continuity between the(sloppy linear)interpolation\n ;float scale2=min(1.,length(q.xy))//ideal for few twists\n ;float scale=min(1./twists,length(q.xy)/twists)//ideal for many twists\n ;scale=min(scale,scale2)*.75//scaling the lerp *.8 is barel noticable,but definitely Lippschitz>1. for scaling *.8\n //i assert zthe limit to be *.75 or *.5,hard to measure tiny epsilon.\n //;float scale=min(1.,length(q.xy))//wrognly asserts lipschitz continuity of a twist-deform\n ;float thick=.5;//set thickness of helix(percentage of being solid(near the cylinder border))\n //;thick=min(rmEps,m.y)//work safe.\n //;if(m.y>.5)thick=0.;else \n #ifdef ThickModeMouse\n  ;thick=m.y\n #endif\n #ifdef ThickModeReciprocalEps\n  ;thick=-rmEps*(1.+1./2096.)/m.y//optional,surprisingly superior result for negative thicknesses,but bad for m.y==0.\n #endif\n //;thick=atan(q.z*.15)*1.1//cute,thickness decreases over cylinder height!\n //;if(U.y<iResolution.y*.5)thick=atan(q.z*.15)*1.1//simple variant of below\n ;thick=mix(thick,atan(q.z*.15)*1.1,smoothstep(0.,9.,U.y-iResolution.y*.5))//smooth transition over screenspace, nicer than below\n //;thick=mix(thick,atan(q.z*.15)*1.1,U.y*2./iResolution.y)//this is fine, just weirdly unfamilliar to do in screenspace\n ;t=max(t,abs(sin(atan(q.y,q.x)-q.z*twists)*scale)-thick/twists)//union with helix \n #ifdef doHoles\n  //;if(U.y<iResolution.y*.5){\n  //;t=max(t,.5-length(vec2(l-1.5,(mod(6.*a,6.28)-3.14)/4.)))//inner crown of holes\n  ;t=max(t,.5-length(vec2(l-3. ,(mod(12.*a,6.28)-3.14)/4.)))//outer crown of holes\n  ;float r=max(abs(q.z)-6.,length(vec2(l-2.,(mod(6.*a,6.28)-3.14)/4.))-thick)//inner crown of rods(also shic\n  ;t=min(r,t)\n  //;}\n #endif\n ;return t;}\n\nvoid mainImage(out vec4 O,vec2 U\n){\n ;O=vec4(0,0,0,1)\n ;float t=iTime;mat2 R=rt(t);vec3 q=vec3(iResolution.xy,1),p=32./q//cam ray origin,moves camera away from center\n ;vec3 D=vec3(.3*(U+U-q.xy)/q.y,-1)//cam ray direction\n ;O-=O//tiny [set to 0]\n ;vec2 m=iMouse.xy/iResolution.xy //;m.x=1.-m.x//m deform for better preview(and UI)\n ;U.x=1.-U.x;m.x=1.-m.x//flipped for a better demo\n ;vec2 n=m\n ;n.y=n.y*2.-1.\n ;n.y*=4.25\n ;n.x-=.1//offset to show bad negative x space\n //this raymarching loop directly modifies O as a whole,thus it represents [NumberOfSteps],easily scaled into visible range\n //it has zFar and <epsilon orbitals in the loop header!\n //note that this keeps rotating a modified position for each iteration,which is bad pperformance,done for smaller code\n ;for(O++;rmOrbit(O.x,t);O-=rmIter//raymarching directly modifies the output,also does the increment first,then orbit_escape,then decrement.\n){\n  ;q=p//set q to camera position\n  ;q.xz*=rt(iTime)\n  ;q.yz*=rt(iTime*1.61)//2*2d rotation of camera position\n  //note,a rotation inside the rm loop is bad performance,it is done for smaller code,so you do not need to do the camera_dotproducts)\n  ;t=df(q,n,U)//get distance to surface\n  ;p+=t*D;}\n ;O=1.-O;\n ;O=pow(O,(vec4(m.y*.1+.5)))//optional gamma for better visibility,pow set to m\n //;O=1.-O;\n ;U/=iResolution.xy\n ;U.x+=.9//offset to show bad negative x space //unflipped would be U.x-=.1\n ;U.y-=.5\n \n ;U.x*=iResolution.x/iResolution.y\n ;O.x=mix(O.x,1.,step(length(U),.01))\n ;O.w=1.;}\n\n\n\n//---above is ollj-fied,below is original source\n\n//https://www.shadertoy.com/view/XsdBW8\n// variant of https://www.shadertoy.com/view/4dtfWr\n/*\nvoid mainImage(out vec4 O,vec2 U){\n float t=iTime;\n mat2  R=mat2(sin(t+vec4(0,33,11,0)));\n vec3  q=vec3(iResolution.xy,1),\n    D=vec3(.3*(U+U-q.xy)/q.y,-1),// ray direction\n    p=30./q;    // marching point along ray \n O-=O;\n for(O++;O.x>0.&&t>.01 ;O-=.015)\n  q=p,\n  q.xz*=R,q.yz*=R,   // rotation\n  t=max(abs(q.z)-6.,length(q.xy)-4.),// cylinder\n  float lipschitzScale=min(1.,length(q.xy));\n  t=max(t,abs(sin(atan(q.y,q.x)-q.z)*lipschitzScale)-iMouse.y/iResolution.y),//union with helix\n  p+=t*D;       // step forward=dist to obj\n}*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}