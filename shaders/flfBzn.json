{
    "Shader": {
        "info": {
            "date": "1650537838",
            "description": "WangTiles + CornerTiles",
            "flags": 0,
            "hasliked": 0,
            "id": "flfBzn",
            "likes": 2,
            "name": "WangTiles + CornerTiles",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "tile",
                "wang",
                "corner"
            ],
            "usePreview": 0,
            "username": "73begonia",
            "viewed": 306
        },
        "renderpass": [
            {
                "code": "#define R vec3(1., 0., 0.)\n#define G vec3(0., 1., 0.)\n#define B vec3(0., 0., 1.)\n#define Y vec3(1., 1., 0.)\n\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n\nstruct wangTile\n{ \n    vec3 topColor;\n    vec3 rightColor;\n    vec3 bottomColor;\n    vec3 leftColor;\n};\n\nstruct cornerTile\n{\n    vec3 tlColor;\n    vec3 trColor;\n    vec3 brColor;\n    vec3 blColor;\n};\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdLine(vec2 p, vec2 p0, vec2 p1, float width) {\n    vec2 dir0 = p1 - p0;\n    vec2 dir1 = p - p0;\n    float h = clamp(dot(dir1, dir0)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nwangTile wTile[16];\ncornerTile cTile[16];\n\nvoid iniWangTile()\n{\n    wTile[0].topColor = G; wTile[0].rightColor = B; wTile[0].bottomColor = G; wTile[0].leftColor = B;\n    wTile[1].topColor = G; wTile[1].rightColor = B; wTile[1].bottomColor = G; wTile[1].leftColor = Y;\n    wTile[2].topColor = G; wTile[2].rightColor = B; wTile[2].bottomColor = R; wTile[2].leftColor = B;\n    wTile[3].topColor = G; wTile[3].rightColor = B; wTile[3].bottomColor = R; wTile[3].leftColor = Y;\n    wTile[4].topColor = G; wTile[4].rightColor = Y; wTile[4].bottomColor = G; wTile[4].leftColor = B;\n    wTile[5].topColor = G; wTile[5].rightColor = Y; wTile[5].bottomColor = G; wTile[5].leftColor = Y;\n    wTile[6].topColor = G; wTile[6].rightColor = Y; wTile[6].bottomColor = R; wTile[6].leftColor = B;\n    wTile[7].topColor = G; wTile[7].rightColor = Y; wTile[7].bottomColor = R; wTile[7].leftColor = Y;\n    wTile[8].topColor = R; wTile[8].rightColor = B; wTile[8].bottomColor = G; wTile[8].leftColor = B;\n    wTile[9].topColor = R; wTile[9].rightColor = B; wTile[9].bottomColor = G; wTile[9].leftColor = Y;\n    wTile[10].topColor = R; wTile[10].rightColor = B; wTile[10].bottomColor = R; wTile[10].leftColor = B;\n    wTile[11].topColor = R; wTile[11].rightColor = B; wTile[11].bottomColor = R; wTile[11].leftColor = Y;\n    wTile[12].topColor = R; wTile[12].rightColor = Y; wTile[12].bottomColor = G; wTile[12].leftColor = B;\n    wTile[13].topColor = R; wTile[13].rightColor = Y; wTile[13].bottomColor = G; wTile[13].leftColor = Y;\n    wTile[14].topColor = R; wTile[14].rightColor = Y; wTile[14].bottomColor = R; wTile[14].leftColor = B;\n    wTile[15].topColor = R; wTile[15].rightColor = Y; wTile[15].bottomColor = R; wTile[15].leftColor = Y;\n}\n\nvoid iniCornerTile()\n{\n    cTile[0].tlColor = R; cTile[0].trColor = R; cTile[0].brColor = R; cTile[0].blColor = R;\n    cTile[1].tlColor = Y; cTile[1].trColor = R; cTile[1].brColor = R; cTile[1].blColor = R;\n    cTile[2].tlColor = R; cTile[2].trColor = R; cTile[2].brColor = R; cTile[2].blColor = Y;\n    cTile[3].tlColor = Y; cTile[3].trColor = R; cTile[3].brColor = R; cTile[3].blColor = Y;\n    cTile[4].tlColor = R; cTile[4].trColor = R; cTile[4].brColor = Y; cTile[4].blColor = R;\n    cTile[5].tlColor = Y; cTile[5].trColor = R; cTile[5].brColor = Y; cTile[5].blColor = R;\n    cTile[6].tlColor = R; cTile[6].trColor = R; cTile[6].brColor = Y; cTile[6].blColor = Y;\n    cTile[7].tlColor = Y; cTile[7].trColor = R; cTile[7].brColor = Y; cTile[7].blColor = Y;\n    cTile[8].tlColor = R; cTile[8].trColor = Y; cTile[8].brColor = R; cTile[8].blColor = R;\n    cTile[9].tlColor = Y; cTile[9].trColor = Y; cTile[9].brColor = R; cTile[9].blColor = R;\n    cTile[10].tlColor = R; cTile[10].trColor = Y; cTile[10].brColor = R; cTile[10].blColor = Y;\n    cTile[11].tlColor = Y; cTile[11].trColor = Y; cTile[11].brColor = R; cTile[11].blColor = Y;\n    cTile[12].tlColor = R; cTile[12].trColor = Y; cTile[12].brColor = Y; cTile[12].blColor = R;\n    cTile[13].tlColor = Y; cTile[13].trColor = Y; cTile[13].brColor = Y; cTile[13].blColor = R;\n    cTile[14].tlColor = R; cTile[14].trColor = Y; cTile[14].brColor = Y; cTile[14].blColor = Y;\n    cTile[15].tlColor = Y; cTile[15].trColor = Y; cTile[15].brColor = Y; cTile[15].blColor = Y;\n}\n\nint getHorizontal(wangTile tileArray[16], wangTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].leftColor == tile.rightColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCornerHorizontal(cornerTile tileArray[16], cornerTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].tlColor == tile.trColor && tileArray[index].blColor == tile.brColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getVertical(wangTile tileArray[16], wangTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].bottomColor == tile.topColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCornerVertical(cornerTile tileArray[16], cornerTile tile)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].blColor == tile.tlColor && tileArray[index].brColor == tile.trColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCross(wangTile tileArray[16], wangTile tileBottom, wangTile tileLeft)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].bottomColor == tileBottom.topColor && tileArray[index].leftColor == tileLeft.rightColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nint getCornerCross(cornerTile tileArray[16], cornerTile tileBottom, cornerTile tileLeft)\n{\n    int i = 1000;\n    while(i != 0)\n    {\n        int index = rand() % 16;\n        if(tileArray[index].blColor == tileBottom.tlColor && tileArray[index].brColor == tileBottom.trColor && tileArray[index].tlColor == tileLeft.trColor && tileArray[index].blColor == tileLeft.brColor)\n            return index;\n        else\n            i--;\n    }\n    return 0;\n}\n\nvec3 drawWangTile(vec2 uv, vec2 offset, wangTile tile)\n{\n\tvec3 col = vec3(1.);\n    vec2 p = uv + offset;\n    \n    float b = sdTrapezoid(p, vec2(0.05, 0.), vec2(0.1, 0.), float(0.05), float(0.1));\n    float d = sdTrapezoid(p, vec2(-0.05, 0.), vec2(-0.1, 0.), float(0.05), float(0.1));\n    float c = sdTrapezoid(vec2(p.x, p.y + 0.075), float(0.1), float(0.05), float(0.025));\n    float a = sdTrapezoid(vec2(p.x, p.y - 0.075), float(0.05), float(0.1), float(0.025));\n    float z = sdCircle(p, 0.1);\n    \n    if(z < 0.)\n    \tcol = vec3(0.);\n  \tif(a < 0.)\n    \tcol = tile.topColor;\n  \tif(b < 0.)\n    \tcol = tile.rightColor;\n  \tif(c < 0.)\n    \tcol = tile.bottomColor;\n  \tif(d < 0.)\n    \tcol = tile.leftColor;\n        \n\treturn col;\n}\n\nvec3 drawCornerTile(vec2 uv, vec2 offset, cornerTile tile)\n{\n    vec3 col = vec3(1.);\n    vec2 p = uv + offset;\n    \n    float a = sdCircle(p + vec2(0.1, -0.1), 0.1);\n    float b = sdCircle(p + vec2(-0.1, -0.1), 0.1);\n    float c = sdCircle(p + vec2(-0.1, 0.1), 0.1);\n    float d = sdCircle(p + vec2(0.1, 0.1), 0.1);\n    float z = sdCircle(p, 0.1);\n    \n    if(z < 0.)\n    \tcol = vec3(0.);\n    if(a < 0. && p.x < 0. && p.y > 0. && p.x > -0.1 && p.y < 0.1)\n    \tcol = tile.tlColor;\n    if(b < 0. && p.x > 0. && p.y > 0. && p.x < 0.1 && p.y < 0.1)\n        col = tile.trColor;\n  \tif(c < 0. && p.x > 0. && p.y < 0. && p.x < 0.1 && p.y > -0.1)\n        col = tile.brColor;\n    if(d < 0. && p.x < 0. && p.y < 0. && p.x > -0.1 && p.y > -0.1)\n        col = tile.blColor;\n    \n    return col;\n}\n\nvec3 drawLine(vec2 uv, inout vec3 col)\n{\n    float t;\n    uv.x += 0.1;\n    uv.y += 0.1;\n    \n    for(int i = 0; i < 10; i ++)\n    {\n        t = sdLine(vec2(uv.x - float(i) * 0.2), vec2(0., 0.0), vec2(0., -1.), float(0.005));\n        if(t < 0.)\n            col *= vec3(0.);\n    }\n    for(int i = 0; i < 6; i++)\n    {\n        t = sdLine(vec2(uv.x, uv.y - float(i) * 0.2), vec2(1.8, 0.0), vec2(0., 0.), float(0.005));\n        if(t < 0.)\n            col *= vec3(0.);\n    }\n        \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = fragCoord/iResolution.xy; // <0,1>\n    uv.x -= 0.05;\n    uv.y -= 0.1;\n  \tuv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    seed = int(iTime * 0.5) % 32767;\n    \n    iniWangTile();\n    iniCornerTile();\n  \n  \tvec3 col = vec3(1.);\n    vec2 offset;\n    \n    int wangTileIndex[45];\n    wangTileIndex[0] = rand() % 16;\n    int cornerTileIndex[45];\n    cornerTileIndex[0] = rand() % 16;\n\n    if(seed % 2 == 0)\n    {\n        for(int i = 0; i < 5; i++)\n        {\n            for(int j = 0; j < 9; j++)\n            {\n                if(i == 0 && j == 0)\n                    col = drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[0]]);\n                else if(i == 0 && j != 0)\n                {\n                    wangTileIndex[j] = getHorizontal(wTile, wTile[wangTileIndex[j - 1]]);\n                    col *= drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[j]]);\n                }\n                else if(i !=0 && j == 0)\n                {\n                    wangTileIndex[i * 9] = getVertical(wTile, wTile[wangTileIndex[(i-1) * 9]]);\n                    col *= drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[i * 9]]);\n                }\n                else if(i !=0 && j != 0)\n                {\n                    wangTileIndex[i * 9 + j] = getCross(wTile, wTile[wangTileIndex[(i - 1) * 9 + j]], wTile[wangTileIndex[i * 9 + j - 1]]);\n                    col *= drawWangTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), wTile[wangTileIndex[i * 9 + j]]);\n                }\n            }\n        }\n    }\n    \n    else\n    {\n        for(int i = 0; i < 5; i++)\n        {\n            for(int j = 0; j < 9; j++)\n            {\n                if(i == 0 && j == 0)\n                    col = drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[0]]);\n                else if(i == 0 && j != 0)\n                {\n                    cornerTileIndex[j] = getCornerHorizontal(cTile, cTile[cornerTileIndex[j - 1]]);\n                    col *= drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[j]]);\n                }\n                else if(i !=0 && j == 0)\n                {\n                    cornerTileIndex[i * 9] = getCornerVertical(cTile, cTile[cornerTileIndex[(i-1) * 9]]);\n                    col *= drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[i * 9]]);\n                }\n                else if(i !=0 && j != 0)\n                {\n                    cornerTileIndex[i * 9 + j] = getCornerCross(cTile, cTile[cornerTileIndex[(i - 1) * 9 + j]], cTile[cornerTileIndex[i * 9 + j - 1]]);\n                    col *= drawCornerTile(uv, vec2(offset.x - float(j) * float(0.2), offset.y - float(i) * float(0.2)), cTile[cornerTileIndex[i * 9 + j]]);\n                }\n            }\n        }\n    }\n    \n    \n    \n    col *= drawLine(uv, col);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}