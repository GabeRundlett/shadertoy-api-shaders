{
    "Shader": {
        "info": {
            "date": "1565166308",
            "description": "Interactive version of [url=https://www.shadertoy.com/view/Xst3Dj]Viscous Fingering[/url]  by cornusammonis; details and usage in source.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "WlBXzD",
            "likes": 52,
            "name": "Fingering Explorer",
            "published": 3,
            "tags": [
                "interactive",
                "fluid",
                "diffusion",
                "viscous"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1186
        },
        "renderpass": [
            {
                "code": "// \"Fingering Explorer\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Model is based on \"Viscous Fingering\" by cornusammonis\n    (https://www.shadertoy.com/view/Xst3Dj).\n  Added color to show field direction.\n  Parameters can be varied between 0.5x and 2x the original values \n    (default values correspond to '33' on slider scale).\n  Each run begins from a different state.\n  Parameter change or mouse click restarts run.\n  Happy explorations.\n*/\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (vec2 vId);\n\nconst float pi = 3.14159;\n\n#define N_SLD  5\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV1, vec4 parmV2)\n{\n  vec4 wgBx[N_SLD];\n  vec3 col, cc;\n  vec2 ut, ust;\n  float vW[N_SLD], asp, s;\n  cc = vec3 (1., 0., 0.);\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < N_SLD; k ++)\n     wgBx[k] = vec4 ((0.31 + 0.04 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n  vW[0] = parmV1.x;  vW[1] = parmV1.y;  vW[2] = parmV1.z;  vW[3] = parmV1.w;\n  vW[4] = parmV2.x;\n  col = vec3 (0.);\n  for (int k = 0; k < N_SLD; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = cc.yyx;\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? cc.yyx : 0.6 * cc.yxx;\n    }\n    s = ShowInt (ut - vec2 (0.013, 0.19), 0.015 * vec2 (asp, 1.), 1.,\n       float (k + 1));\n    if (s > 0.) col = cc.yyx;\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    s = ShowInt (ut - vec2 (0.018, -0.01), 0.02 * vec2 (asp, 1.), 2.,\n       clamp (floor (100. * vW[k]), 0., 99.));\n    if (s > 0.) col = cc.xxy;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (max (abs (ut.x), abs (ut.y)) < 0.025 && max (ut.x, ut.y) > 0.02) col = cc.xxy;\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\n#define L(e) Loadv4 (mod (gv + e, gSize)).xyz\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 hs, parmV1, parmV2, c4;\n  vec3 col, vn, ltDir, c;\n  vec2 canvas, uv, ut, gv, e;\n  float h[4], gSize;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).w;\n  parmV1 = vec4 (Loadv4 (vec2 (4., 0.)).w, Loadv4 (vec2 (5., 0.)).w,\n     Loadv4 (vec2 (6., 0.)).w, Loadv4 (vec2 (7., 0.)).w);\n  parmV2 = vec4 (Loadv4 (vec2 (8., 0.)).w, 0., 0., 0.);\n  ut = abs (uv) - vec2 (1.);\n  if (max (ut.x, ut.y) > 0.) col = vec3 (0.82);\n  else {\n    gv = gSize * (0.5 * uv + 0.5);\n    e = vec2 (1., 0.);\n    c = normalize (L(e.yy));\n#if 0\n    col = vec3 (0.5 + c.z);   // original b/w\n#else\n    col = HsvToRgb (vec3 (atan (c.y, c.x) / (2. * pi) + 0.5, 1., 0.5 + 0.5 * c.z));\n    h[0] = length (c.xy);\n    h[1] = length (normalize (L(e.xy)).xy);\n    h[2] = length (normalize (L(e.yx)).xy);\n    h[3] = length (normalize (L(e.xx)).xy);\n    hs = vec4 (h[0], h[1], h[2], h[3]);\n    vn = normalize (vec3 (hs.x - hs.w - hs.y + hs.z, 0.5, hs.x - hs.w + hs.y - hs.z));\n    ltDir = normalize (vec3 (1., 3., 1.));\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.3 * pow (max (0., dot (ltDir, reflect (vec3 (0., -1., 0.), vn))), 32.);\n#endif\n  }\n  c4 = ShowWg (uv, canvas, parmV1, parmV2);\n  col = mix (col, c4.rgb, c4.a);\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv < 5) {\n    if (iv == -1) k = 8;\n    else if (iv == 0) k = 119;\n    else if (iv == 1) k = 36;\n    else if (iv == 2) k = 93;\n    else if (iv == 3) k = 109;\n    else k = 46;\n  } else {\n    if (iv == 5) k = 107;\n    else if (iv == 6) k = 122;\n    else if (iv == 7) k = 37;\n    else if (iv == 8) k = 127;\n    else k = 47;\n  }\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx - vo);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy - vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vm);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.xy + vp);\n  k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Fingering Explorer\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec4 parmV1, parmV2;\nfloat gSize, itRand;\nconst float pi = 3.14159;\n\n#define L(e) Loadv4 (mod (gv + e, gSize)).xyz\n\nvec3 Step (vec2 gv)\n{\n  vec3 f1[4], f2[4], f, vLap, e;\n  vec2 u;\n  float vDiv, vCurl, cFac, lFac, dlFac, dFac, rExp, wd, rp1, rp2;\n  rp1 = 0.5;\n  rp2 = 1.5;\n// parameters controlled by sliders\n  cFac = 0.25 * (rp1 + rp2 * parmV1.x);     // curl scale\n  lFac = 0.24 * (rp1 + rp2 * parmV1.y);     // laplacian scale\n  dlFac = -0.06 * (rp1 + rp2 * parmV1.z);   // laplacian of div scale\n  dFac = -0.08  * (rp1 + rp2 * parmV1.w);   // div scale\n  rExp = 0.2 * (rp1 + rp2 * parmV2.x);      // power for rotation angle\n  wd = 0.5;\n  e = vec3 (1., -1., 0.);\n  f = L(e.zz);\n  f1[0] = L(e.zx);  f1[1] = L(e.xz);  f1[2] = L(e.zy);  f1[3] = L(e.yz);\n  f2[0] = L(e.xx);  f2[1] = L(e.xy);  f2[2] = L(e.yy);  f2[3] = L(e.yx);\n// model equations\n  vLap = 0.5 * (f1[0] + f1[1] + f1[2] + f1[3]) + 0.25 * (f2[0] + f2[1] + f2[2] + f2[3]) - 3. * f;\n  vCurl = f1[0].x - f1[2].x - f1[1].y + f1[3].y + wd * (f2[3].x + f2[3].y + f2[0].x - f2[0].y +\n     f2[2].y - f2[2].x - f2[1].y - f2[1].x);\n  vDiv = f1[2].y - f1[0].y - f1[1].x + f1[3].x + wd * (f2[3].x - f2[3].y - f2[0].x - f2[0].y +\n     f2[2].x + f2[2].y + f2[1].y - f2[1].x);\n  u = Rot2D ((1. + dFac * vDiv + dlFac * vLap.z / length (f.xy)) * f.xy +\n     lFac * vLap.xy, cFac * sign (vCurl) * pow (abs (vCurl), rExp));\n  return clamp (vec3 (u, vDiv), -1., 1.);\n}\n\nvec3 Init (vec2 gv)\n{\n  return Hashv3v2 (gv * vec2 (27.1, 31.1) + itRand) - 0.5;\n}\n\n#define N_SLD  5\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[N_SLD], mPtr, mPtrP, stDat;\n  vec2 iFrag, canvas, ust;\n  float tCur, nStep, vW, asp;\n  int wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1536.) ? 1536. : ((canvas.y >= 1024.) ? 1024. :\n     ((canvas.y >= 512.) ? 512. : (canvas.y >= 256.) ? 256. : 64.));\n  iFrag = floor (fragCoord);\n  if (iFrag.x >= gSize || iFrag.x + gSize * iFrag.y >= gSize * gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    parmV1 = vec4 (0.33);\n    parmV2 = vec4 (0.33, 0., 0., 0.);\n    mPtrP = mPtr;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).w;\n    wgSel = int (Loadv4 (vec2 (2., 0.)).w);\n    mPtrP.z = Loadv4 (vec2 (3., 0.)).w;\n    parmV1 = vec4 (Loadv4 (vec2 (4., 0.)).w, Loadv4 (vec2 (5., 0.)).w,\n       Loadv4 (vec2 (6., 0.)).w, Loadv4 (vec2 (7., 0.)).w);\n    parmV2 = vec4 (Loadv4 (vec2 (8., 0.)).w, 0., 0., 0.);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < N_SLD; k ++)\n       wgBx[k] = vec4 ((0.31 + 0.04 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n    for (int k = 0; k < N_SLD; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0. && mPtrP.z <= 0. && abs (mPtr.x) * asp < 0.5) doInit = true;\n  } else {\n    for (int k = 0; k < N_SLD; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) parmV1.x = vW;\n    else if (kSel == 1) parmV1.y = vW;\n    else if (kSel == 2) parmV1.z = vW;\n    else if (kSel == 3) parmV1.w = vW;\n    else if (kSel == 4) parmV2.x = vW;\n    if (nStep > 40.) doInit = true;\n  }\n  if (Loadv4 (vec2 (0., 0.)).w != gSize) doInit = true;\n  if (doInit) {\n    itRand = floor (tCur);\n    nStep = 0.;\n    stDat.xyz = Init (iFrag);\n  } else {\n    ++ nStep;\n    stDat.xyz = Step (iFrag);\n  }\n  stDat.w = 0.;\n  if (iFrag.y == 0.) {\n    if (iFrag.x <= 4.) {\n      if      (iFrag.x == 0.) stDat.w = gSize;\n      else if (iFrag.x == 1.) stDat.w = nStep;\n      else if (iFrag.x == 2.) stDat.w = float (wgSel);\n      else if (iFrag.x == 3.) stDat.w = mPtr.z;\n      else if (iFrag.x == 4.) stDat.w = parmV1.x;\n    } else if (iFrag.x <= 8.) {\n      if      (iFrag.x == 5.) stDat.w = parmV1.y;\n      else if (iFrag.x == 6.) stDat.w = parmV1.z;\n      else if (iFrag.x == 7.) stDat.w = parmV1.w;\n      else if (iFrag.x == 8.) stDat.w = parmV2.x;\n    }\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p, cHashVA2), dot (p + e.xy, cHashVA2),\n     dot (p + e.yx, cHashVA2))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Fingering Explorer\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec4 parmV1, parmV2;\nfloat gSize, itRand;\nconst float pi = 3.14159;\n\n#define L(e) Loadv4 (mod (gv + e, gSize)).xyz\n\nvec3 Step (vec2 gv)\n{\n  vec3 f1[4], f2[4], f, vLap, e;\n  vec2 u;\n  float vDiv, vCurl, cFac, lFac, dlFac, dFac, rExp, wd, rp1, rp2;\n  rp1 = 0.5;\n  rp2 = 1.5;\n// parameters controlled by sliders\n  cFac = 0.25 * (rp1 + rp2 * parmV1.x);     // curl scale\n  lFac = 0.24 * (rp1 + rp2 * parmV1.y);     // laplacian scale\n  dlFac = -0.06 * (rp1 + rp2 * parmV1.z);   // laplacian of div scale\n  dFac = -0.08  * (rp1 + rp2 * parmV1.w);   // div scale\n  rExp = 0.2 * (rp1 + rp2 * parmV2.x);      // power for rotation angle\n  wd = 0.5;\n  e = vec3 (1., -1., 0.);\n  f = L(e.zz);\n  f1[0] = L(e.zx);  f1[1] = L(e.xz);  f1[2] = L(e.zy);  f1[3] = L(e.yz);\n  f2[0] = L(e.xx);  f2[1] = L(e.xy);  f2[2] = L(e.yy);  f2[3] = L(e.yx);\n// model equations\n  vLap = 0.5 * (f1[0] + f1[1] + f1[2] + f1[3]) + 0.25 * (f2[0] + f2[1] + f2[2] + f2[3]) - 3. * f;\n  vCurl = f1[0].x - f1[2].x - f1[1].y + f1[3].y + wd * (f2[3].x + f2[3].y + f2[0].x - f2[0].y +\n     f2[2].y - f2[2].x - f2[1].y - f2[1].x);\n  vDiv = f1[2].y - f1[0].y - f1[1].x + f1[3].x + wd * (f2[3].x - f2[3].y - f2[0].x - f2[0].y +\n     f2[2].x + f2[2].y + f2[1].y - f2[1].x);\n  u = Rot2D ((1. + dFac * vDiv + dlFac * vLap.z / length (f.xy)) * f.xy +\n     lFac * vLap.xy, cFac * sign (vCurl) * pow (abs (vCurl), rExp));\n  return clamp (vec3 (u, vDiv), -1., 1.);\n}\n\nvec3 Init (vec2 gv)\n{\n  return Hashv3v2 (gv * vec2 (27.1, 31.1) + itRand) - 0.5;\n}\n\n#define N_SLD  5\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[N_SLD], mPtr, mPtrP, stDat;\n  vec2 iFrag, canvas, ust;\n  float tCur, nStep, vW, asp;\n  int wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1536.) ? 1536. : ((canvas.y >= 1024.) ? 1024. :\n     ((canvas.y >= 512.) ? 512. : (canvas.y >= 256.) ? 256. : 64.));\n  iFrag = floor (fragCoord);\n  if (iFrag.x >= gSize || iFrag.x + gSize * iFrag.y >= gSize * gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    parmV1 = vec4 (0.33);\n    parmV2 = vec4 (0.33, 0., 0., 0.);\n    mPtrP = mPtr;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).w;\n    wgSel = int (Loadv4 (vec2 (2., 0.)).w);\n    mPtrP.z = Loadv4 (vec2 (3., 0.)).w;\n    parmV1 = vec4 (Loadv4 (vec2 (4., 0.)).w, Loadv4 (vec2 (5., 0.)).w,\n       Loadv4 (vec2 (6., 0.)).w, Loadv4 (vec2 (7., 0.)).w);\n    parmV2 = vec4 (Loadv4 (vec2 (8., 0.)).w, 0., 0., 0.);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < N_SLD; k ++)\n       wgBx[k] = vec4 ((0.31 + 0.04 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n    for (int k = 0; k < N_SLD; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0. && mPtrP.z <= 0. && abs (mPtr.x) * asp < 0.5) doInit = true;\n  } else {\n    for (int k = 0; k < N_SLD; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) parmV1.x = vW;\n    else if (kSel == 1) parmV1.y = vW;\n    else if (kSel == 2) parmV1.z = vW;\n    else if (kSel == 3) parmV1.w = vW;\n    else if (kSel == 4) parmV2.x = vW;\n    if (nStep > 40.) doInit = true;\n  }\n  if (Loadv4 (vec2 (0., 0.)).w != gSize) doInit = true;\n  if (doInit) {\n    itRand = floor (tCur);\n    nStep = 0.;\n    stDat.xyz = Init (iFrag);\n  } else {\n    ++ nStep;\n    stDat.xyz = Step (iFrag);\n  }\n  stDat.w = 0.;\n  if (iFrag.y == 0.) {\n    if (iFrag.x <= 4.) {\n      if      (iFrag.x == 0.) stDat.w = gSize;\n      else if (iFrag.x == 1.) stDat.w = nStep;\n      else if (iFrag.x == 2.) stDat.w = float (wgSel);\n      else if (iFrag.x == 3.) stDat.w = mPtr.z;\n      else if (iFrag.x == 4.) stDat.w = parmV1.x;\n    } else if (iFrag.x <= 8.) {\n      if      (iFrag.x == 5.) stDat.w = parmV1.y;\n      else if (iFrag.x == 6.) stDat.w = parmV1.z;\n      else if (iFrag.x == 7.) stDat.w = parmV1.w;\n      else if (iFrag.x == 8.) stDat.w = parmV2.x;\n    }\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p, cHashVA2), dot (p + e.xy, cHashVA2),\n     dot (p + e.yx, cHashVA2))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Fingering Explorer\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec4 parmV1, parmV2;\nfloat gSize, itRand;\nconst float pi = 3.14159;\n\n#define L(e) Loadv4 (mod (gv + e, gSize)).xyz\n\nvec3 Step (vec2 gv)\n{\n  vec3 f1[4], f2[4], f, vLap, e;\n  vec2 u;\n  float vDiv, vCurl, cFac, lFac, dlFac, dFac, rExp, wd, rp1, rp2;\n  rp1 = 0.5;\n  rp2 = 1.5;\n// parameters controlled by sliders\n  cFac = 0.25 * (rp1 + rp2 * parmV1.x);     // curl scale\n  lFac = 0.24 * (rp1 + rp2 * parmV1.y);     // laplacian scale\n  dlFac = -0.06 * (rp1 + rp2 * parmV1.z);   // laplacian of div scale\n  dFac = -0.08  * (rp1 + rp2 * parmV1.w);   // div scale\n  rExp = 0.2 * (rp1 + rp2 * parmV2.x);      // power for rotation angle\n  wd = 0.5;\n  e = vec3 (1., -1., 0.);\n  f = L(e.zz);\n  f1[0] = L(e.zx);  f1[1] = L(e.xz);  f1[2] = L(e.zy);  f1[3] = L(e.yz);\n  f2[0] = L(e.xx);  f2[1] = L(e.xy);  f2[2] = L(e.yy);  f2[3] = L(e.yx);\n// model equations\n  vLap = 0.5 * (f1[0] + f1[1] + f1[2] + f1[3]) + 0.25 * (f2[0] + f2[1] + f2[2] + f2[3]) - 3. * f;\n  vCurl = f1[0].x - f1[2].x - f1[1].y + f1[3].y + wd * (f2[3].x + f2[3].y + f2[0].x - f2[0].y +\n     f2[2].y - f2[2].x - f2[1].y - f2[1].x);\n  vDiv = f1[2].y - f1[0].y - f1[1].x + f1[3].x + wd * (f2[3].x - f2[3].y - f2[0].x - f2[0].y +\n     f2[2].x + f2[2].y + f2[1].y - f2[1].x);\n  u = Rot2D ((1. + dFac * vDiv + dlFac * vLap.z / length (f.xy)) * f.xy +\n     lFac * vLap.xy, cFac * sign (vCurl) * pow (abs (vCurl), rExp));\n  return clamp (vec3 (u, vDiv), -1., 1.);\n}\n\nvec3 Init (vec2 gv)\n{\n  return Hashv3v2 (gv * vec2 (27.1, 31.1) + itRand) - 0.5;\n}\n\n#define N_SLD  5\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[N_SLD], mPtr, mPtrP, stDat;\n  vec2 iFrag, canvas, ust;\n  float tCur, nStep, vW, asp;\n  int wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1536.) ? 1536. : ((canvas.y >= 1024.) ? 1024. :\n     ((canvas.y >= 512.) ? 512. : (canvas.y >= 256.) ? 256. : 64.));\n  iFrag = floor (fragCoord);\n  if (iFrag.x >= gSize || iFrag.x + gSize * iFrag.y >= gSize * gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    parmV1 = vec4 (0.33);\n    parmV2 = vec4 (0.33, 0., 0., 0.);\n    mPtrP = mPtr;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).w;\n    wgSel = int (Loadv4 (vec2 (2., 0.)).w);\n    mPtrP.z = Loadv4 (vec2 (3., 0.)).w;\n    parmV1 = vec4 (Loadv4 (vec2 (4., 0.)).w, Loadv4 (vec2 (5., 0.)).w,\n       Loadv4 (vec2 (6., 0.)).w, Loadv4 (vec2 (7., 0.)).w);\n    parmV2 = vec4 (Loadv4 (vec2 (8., 0.)).w, 0., 0., 0.);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < N_SLD; k ++)\n       wgBx[k] = vec4 ((0.31 + 0.04 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n    for (int k = 0; k < N_SLD; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0. && mPtrP.z <= 0. && abs (mPtr.x) * asp < 0.5) doInit = true;\n  } else {\n    for (int k = 0; k < N_SLD; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) parmV1.x = vW;\n    else if (kSel == 1) parmV1.y = vW;\n    else if (kSel == 2) parmV1.z = vW;\n    else if (kSel == 3) parmV1.w = vW;\n    else if (kSel == 4) parmV2.x = vW;\n    if (nStep > 40.) doInit = true;\n  }\n  if (Loadv4 (vec2 (0., 0.)).w != gSize) doInit = true;\n  if (doInit) {\n    itRand = floor (tCur);\n    nStep = 0.;\n    stDat.xyz = Init (iFrag);\n  } else {\n    ++ nStep;\n    stDat.xyz = Step (iFrag);\n  }\n  stDat.w = 0.;\n  if (iFrag.y == 0.) {\n    if (iFrag.x <= 4.) {\n      if      (iFrag.x == 0.) stDat.w = gSize;\n      else if (iFrag.x == 1.) stDat.w = nStep;\n      else if (iFrag.x == 2.) stDat.w = float (wgSel);\n      else if (iFrag.x == 3.) stDat.w = mPtr.z;\n      else if (iFrag.x == 4.) stDat.w = parmV1.x;\n    } else if (iFrag.x <= 8.) {\n      if      (iFrag.x == 5.) stDat.w = parmV1.y;\n      else if (iFrag.x == 6.) stDat.w = parmV1.z;\n      else if (iFrag.x == 7.) stDat.w = parmV1.w;\n      else if (iFrag.x == 8.) stDat.w = parmV2.x;\n    }\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p, cHashVA2), dot (p + e.xy, cHashVA2),\n     dot (p + e.yx, cHashVA2))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Fingering Explorer\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec4 parmV1, parmV2;\nfloat gSize, itRand;\nconst float pi = 3.14159;\n\n#define L(e) Loadv4 (mod (gv + e, gSize)).xyz\n\nvec3 Step (vec2 gv)\n{\n  vec3 f1[4], f2[4], f, vLap, e;\n  vec2 u;\n  float vDiv, vCurl, cFac, lFac, dlFac, dFac, rExp, wd, rp1, rp2;\n  rp1 = 0.5;\n  rp2 = 1.5;\n// parameters controlled by sliders\n  cFac = 0.25 * (rp1 + rp2 * parmV1.x);     // curl scale\n  lFac = 0.24 * (rp1 + rp2 * parmV1.y);     // laplacian scale\n  dlFac = -0.06 * (rp1 + rp2 * parmV1.z);   // laplacian of div scale\n  dFac = -0.08  * (rp1 + rp2 * parmV1.w);   // div scale\n  rExp = 0.2 * (rp1 + rp2 * parmV2.x);      // power for rotation angle\n  wd = 0.5;\n  e = vec3 (1., -1., 0.);\n  f = L(e.zz);\n  f1[0] = L(e.zx);  f1[1] = L(e.xz);  f1[2] = L(e.zy);  f1[3] = L(e.yz);\n  f2[0] = L(e.xx);  f2[1] = L(e.xy);  f2[2] = L(e.yy);  f2[3] = L(e.yx);\n// model equations\n  vLap = 0.5 * (f1[0] + f1[1] + f1[2] + f1[3]) + 0.25 * (f2[0] + f2[1] + f2[2] + f2[3]) - 3. * f;\n  vCurl = f1[0].x - f1[2].x - f1[1].y + f1[3].y + wd * (f2[3].x + f2[3].y + f2[0].x - f2[0].y +\n     f2[2].y - f2[2].x - f2[1].y - f2[1].x);\n  vDiv = f1[2].y - f1[0].y - f1[1].x + f1[3].x + wd * (f2[3].x - f2[3].y - f2[0].x - f2[0].y +\n     f2[2].x + f2[2].y + f2[1].y - f2[1].x);\n  u = Rot2D ((1. + dFac * vDiv + dlFac * vLap.z / length (f.xy)) * f.xy +\n     lFac * vLap.xy, cFac * sign (vCurl) * pow (abs (vCurl), rExp));\n  return clamp (vec3 (u, vDiv), -1., 1.);\n}\n\nvec3 Init (vec2 gv)\n{\n  return Hashv3v2 (gv * vec2 (27.1, 31.1) + itRand) - 0.5;\n}\n\n#define N_SLD  5\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[N_SLD], mPtr, mPtrP, stDat;\n  vec2 iFrag, canvas, ust;\n  float tCur, nStep, vW, asp;\n  int wgSel, wgReg, kSel;\n  bool doInit;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = (canvas.y >= 1536.) ? 1536. : ((canvas.y >= 1024.) ? 1024. :\n     ((canvas.y >= 512.) ? 512. : (canvas.y >= 256.) ? 256. : 64.));\n  iFrag = floor (fragCoord);\n  if (iFrag.x >= gSize || iFrag.x + gSize * iFrag.y >= gSize * gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    parmV1 = vec4 (0.33);\n    parmV2 = vec4 (0.33, 0., 0., 0.);\n    mPtrP = mPtr;\n    doInit = true;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).w;\n    wgSel = int (Loadv4 (vec2 (2., 0.)).w);\n    mPtrP.z = Loadv4 (vec2 (3., 0.)).w;\n    parmV1 = vec4 (Loadv4 (vec2 (4., 0.)).w, Loadv4 (vec2 (5., 0.)).w,\n       Loadv4 (vec2 (6., 0.)).w, Loadv4 (vec2 (7., 0.)).w);\n    parmV2 = vec4 (Loadv4 (vec2 (8., 0.)).w, 0., 0., 0.);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < N_SLD; k ++)\n       wgBx[k] = vec4 ((0.31 + 0.04 * float (k)) * asp, 0., 0.014 * asp, 0.18);\n    for (int k = 0; k < N_SLD; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0. && mPtrP.z <= 0. && abs (mPtr.x) * asp < 0.5) doInit = true;\n  } else {\n    for (int k = 0; k < N_SLD; k ++) {\n      if (wgSel == k) {\n        kSel = k;\n        vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n        break;\n      }\n    }\n    if      (kSel == 0) parmV1.x = vW;\n    else if (kSel == 1) parmV1.y = vW;\n    else if (kSel == 2) parmV1.z = vW;\n    else if (kSel == 3) parmV1.w = vW;\n    else if (kSel == 4) parmV2.x = vW;\n    if (nStep > 40.) doInit = true;\n  }\n  if (Loadv4 (vec2 (0., 0.)).w != gSize) doInit = true;\n  if (doInit) {\n    itRand = floor (tCur);\n    nStep = 0.;\n    stDat.xyz = Init (iFrag);\n  } else {\n    ++ nStep;\n    stDat.xyz = Step (iFrag);\n  }\n  stDat.w = 0.;\n  if (iFrag.y == 0.) {\n    if (iFrag.x <= 4.) {\n      if      (iFrag.x == 0.) stDat.w = gSize;\n      else if (iFrag.x == 1.) stDat.w = nStep;\n      else if (iFrag.x == 2.) stDat.w = float (wgSel);\n      else if (iFrag.x == 3.) stDat.w = mPtr.z;\n      else if (iFrag.x == 4.) stDat.w = parmV1.x;\n    } else if (iFrag.x <= 8.) {\n      if      (iFrag.x == 5.) stDat.w = parmV1.y;\n      else if (iFrag.x == 6.) stDat.w = parmV1.z;\n      else if (iFrag.x == 7.) stDat.w = parmV1.w;\n      else if (iFrag.x == 8.) stDat.w = parmV2.x;\n    }\n  }\n  Savev4 (iFrag, stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p, cHashVA2), dot (p + e.xy, cHashVA2),\n     dot (p + e.yx, cHashVA2))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}