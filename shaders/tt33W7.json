{
    "Shader": {
        "info": {
            "date": "1576511878",
            "description": "Light claws",
            "flags": 96,
            "hasliked": 0,
            "id": "tt33W7",
            "likes": 4,
            "name": "[I3D'20] Light claws",
            "published": 3,
            "tags": [
                "i3d20"
            ],
            "usePreview": 0,
            "username": "I3D20_23",
            "viewed": 275
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\n// This effect plays music to drive the band tearing\n// Please select BufferA then click play in iChannel0 below\n\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\n#define colorRange 24.0\n\nvec3 jodieReinhardTonemap(vec3 c)\n{\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 base = texture(iChannel0,uv);\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    //color = pow(color, vec3(1.0 / 2.2));\n    \n    //color = jodieReinhardTonemap(color);\n    \n    float c_color = texture(iChannel0,uv).w;\n    int width = 1;\n    float diff = 0.0;\n    for (int i = -width; i <= width; i++) {\n        for (int j = -width; j <= width; j++) {\n            float color = texture(iChannel0,uv + vec2(i, j)/iResolution.xy).w;\n            if (color != c_color) {\n                diff = 1.0;\n            }\n        } \n    }\n   \n    color.x *= 0.001;\n\tfragColor = vec4(0.0) + vec4(42.0, 0.0, 55.0, 0.0)/255.0 * diff + vec4(0.1*color,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\n// This effect plays music to drive the band tearing\n// Please select BufferA then click play in iChannel0 below\n\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\n// Noise from https://www.shadertoy.com/view/4sdGD8\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n////////////////////////\n// fields for figures //\n////////////////////////\nvec2 ctr0=vec2(0.5, 0.5);\n\n//#define N 19.0\n//#define M 13.0\n\n#define N 9.0\n#define M 5.0\n\nconst float log_step = N/M;\n\nvec2 uv(vec2 p) \n{\n    vec2 sound = (texture( iChannel0, 5.0*p/iResolution.xy)).xy;\n    vec2 f = vec2(p) + 10.0*vec2(snoise( p.xy*0.015 + 0.04*iTime),snoise(p.xy*0.025 + 0.07*iTime));\n    return f;\n}\n\nvec2 d(vec2 p) \n{\n    //return log_step; // uncomment to reveal distortion    \n    float delta = 1.0;\n    vec2  dudx  = ( uv(p - vec2(delta,0.0)) - uv(p + vec2(delta,0.0)) ) * 0.5 / delta;\n    vec2  dudy  = ( uv(p - vec2(0.0,delta)) - uv(p + vec2(0.0,delta)) ) * 0.5 / delta;\n    float du    = log_step / (0.000001 + length(vec2(dudx.x,dudy.x)));\n    float dv    = log_step / (0.000001 + length(vec2(dudx.y,dudy.y)));\n    \n    float sound = (texture( iChannel0, 5.0*p/iResolution.x)).x;\n    float xnoise = 5.0*snoise( p.xy*0.015 + 0.04*iTime);\n    float ynoise = 5.0*snoise(p.xy*0.025 + 0.07*iTime);\n    \n    du = max(log_step,1.25*sound + sound*xnoise);\n    dv = max(log_step,1.0*sound + sound*ynoise);\n    \n    return 1.0*vec2(du,dv) ; \n    \n}\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\n#define keyToggle(ascii) (texelFetch(iChannel0,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)   (texelFetch(iChannel0,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)  (texelFetch(iChannel0,ivec2(ascii,0),0).x > 0.)\n\n// keyboard mapping\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\n\n//////////////////////////\n// forward declarations //\n//////////////////////////\n\nvec4 getRandomColor(uvec4 id);\n\nfloat spacing(float d);\nint getLocalID(float u, float d, out float ctr);\nuvec4 getGlobalID(int localID, float d);\nfloat getLocalIDCenter(uint id, float d);\n\nfloat quantize(float d);\nfloat up(float d);\nfloat down(float d);\nfloat interpolate(float d);\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\nfloat quantize(float d) {\n    return pow(log_step,floor(log(d)/log(log_step)));\n}\n\nint d2level(float d) {\n    return int(floor(log(d)/log(log_step)));\n}\n\nfloat level2d(int level) {\n  return pow(log_step,round(float(level)));\n}\n\nfloat interpolate(float d) {\n    int   level   = d2level(d);\n    float df      = level2d(level);\n    float dc      = level2d(level-1);    \n    float linear  = (d - df) / (df - dc) / log_step;\n    return smoothstep(0.0,1.0,linear);\n}\n\nfloat spacing(float d) {\n    return 1.0/d;   \n}\n\nfloat shift(float d) {\n    if (N == 2.0) {\n        return spacing(d) / 2.0;\n    }\n    return d ; //* iTime*0.001;\n}\n\nfloat id2Lborder(int id, float d) {\n    return (float(id) +       (shift(d) / spacing(d)) ) * spacing(d);\n}\n\nfloat id2center(int id, float d) {\n    return (float(id) + 0.5 + (shift(d) / spacing(d)) ) * spacing(d);\n}\n\nint u2id(float u, float d) {\n    return int(floor( u / spacing(d) - (shift(d) / spacing(d)) ));\n}\n\nint u2closestLBorderId(float u, float d) {\n    int lid = u2id(u, d);\n    if (u < id2center(lid, d)) {\n        return lid;\n    } else {\n        return lid+1;\n    }\n}\n\nfloat u2closestBorder (float u, float d) {\n    return id2Lborder(u2closestLBorderId(u,d), d);\n}\n\n/**********************************************/\n\nint getLocalID(float u, float d, out float ctr) {\n  // fine and coarse densities\n  int   level = d2level(d);\n  float df    = level2d(level  );\n  float dc    = level2d(level-1);\n  // enclosing band id\n  int   lid     = u2id(u, df); \n  // get the borders of the fine band\n  float lf_brdr = id2Lborder(lid, df);\n  float rf_brdr = id2Lborder(lid+1, df);\n  // get the closest coarser band borders\n  float lc_brdr = u2closestBorder(lf_brdr, dc);\n  float rc_brdr = u2closestBorder(rf_brdr, dc);\n  // interpolate between fine and coarse borders\n  float a     = interpolate(d);\n  float left  = lf_brdr * a + lc_brdr * (1.0 - a);\n  float right = rf_brdr * a + rc_brdr * (1.0 - a);    \n  // adjust enclosing band after interpolation\n  if      (u < left ) lid--;\n  else if (u > right) lid++;\n\n  if (abs(left - right) < 0.5 * spacing(df)) {\n    ctr = -99999.0;\n  } else {\n    ctr = (left + right)/2.0;\n  }\n\n  return lid;\n}\n\n/**********************************************/\n\nuvec4 setId(uvec4 id,uint bit) // 128 bits IDs\n{\n    if (bit > 127u) return id;\n    if (bit < 64u) {\n        if (bit < 32u) { // 0 - 31 (w) LSBs\n            return uvec4(id.x,id.y,id.z,id.w | (1u << bit));\n        } else {         // 32 - 63 (x)\n            return uvec4(id.x,id.y,id.z | (1u << (bit-32u)),id.w);            \n        }\n    } else {\n        if (bit < 96u) { // 64 - 95 (x)\n            return uvec4(id.x,id.y | (1u << (bit-64u)),id.z,id.w);            \n        } else {         // 96 - 127 (x) MSBs\n            return uvec4(id.x | (1u << (bit-96u)),id.y,id.z,id.w);            \n        }\n    }\n}\n\n/**********************************************/\n\nuvec4 getGlobalID(int lid, float d) {\n  uvec4 gid = uvec4(0u);\n  int start_level = d2level(d);\n  for (int level = start_level; level > 0; level--) {\n    float df      = level2d(level);\n    float dc      = level2d(level-1);\n    float lf_brdr = id2Lborder(lid  , df);\n    float rf_brdr = id2Lborder(lid+1, df);\n    // get the closest borders on the coarse bands\n    int lid_brdr = u2closestLBorderId(lf_brdr, dc);\n    int rid_brdr = u2closestLBorderId(rf_brdr, dc);\n    if (lid_brdr == rid_brdr) {\n      // this band is closing between parents, tag in ID (lower 96 bits)\n      gid = setId(gid,uint(96 - level));\n      lid  = u2id(lf_brdr, dc);\n      if (level == start_level) {\n        // the start band is appearing\n        //gid.x = uint(lid_brdr);\n        //return uvec4(0);\n      }\n    } else {\n      // move up to parent\n      lid  = lid_brdr;\n        \n    }      \n  }\n  // parent ids go into the most significant 32 bits\n  gid.x = uint(lid);\n  return gid;\n}\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\nvec4 getRandomColor(uvec4 id) {\n    vec3 tmp = vec3(fract(float(id.x^id.w)/213789.0), fract(float(id.y^1489u)/348789.0), fract(float(id.z^2789u)/5689.0));\n    for (int i = 0; i < 4; i++) {\n      tmp = fract(vec3(13.14159265359,1.41421356237,6.62607004) * tmp.zyx + tmp.yxz / vec3(13.14159265359,1.41421356237,6.62607004));\n    }\n    return vec4(tmp, 1.0);\n}\n\n///////////////////////\n\nuint numBits(uint v) {\n    uint n = 0u;\n    while (v > 0u) {\n        n += v & 1u;\n        v = v >> 1u;\n    }\n    return n;\n}\n\nvec4 draw(vec2 p) {\n          \n    float ctr = 0.0;\n   \n    vec2 u   = uv(p);\n    vec2 d   = d(p);\n    int lidA = getLocalID(u.x, d.x, ctr);\n    int lidB = getLocalID(u.y, d.y, ctr);\n    \n    float bu = id2Lborder(lidA,d.x);\n    float bv = id2Lborder(lidB,d.y);\n    \n    uvec4 gidA = getGlobalID(lidA, d.x);\n    uvec4 gidB = getGlobalID(lidB, d.y);\n\n    //if (gid == uvec4(0u)) return vec4(1.0);        \n\n    //return getRandomColor(uvec4(lidA));\n    \n    //return textureLod(iChannel0, vec2(float(gidA.x)/100.0,0.0), 0.0);\n    \n    // return vec4(bu/100.0);    \n    \n    if ((numBits(gidA.y) | numBits(gidB.y)) > 0u) {\n      return vec4(255.0, 43.0, 61.0,0.0)/255.0;\n    } else {\n      //return vec4((u - bu).xxxx) / spacing(d);\n      return vec4(0.0,0.0,0.0, getRandomColor( uvec4( (gidA.x) ^ (gidB.x) ) ) );\n      // return vec4(0.0);\n    }    \n    \n      //    getRandomColor( uvec4( (numBits(gidA.y) | numBits(gidB.y)) > 0u ? 1u : 0u) )\n      //  + getRandomColor( uvec4( (numBits(gidA.y) | numBits(gidB.y)) == 0u ? gidA.x ^ gidB.x : 0u) );\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 p = 40.0 * fragCoord / iResolution.y ;\n    fragColor = draw( p );\n}\n\n/**********************************************/\n/**********************************************/\n/**********************************************/\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 20574,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\n// This effect plays music to drive the band tearing\n// Please select BufferA then click play in iChannel0 below\n\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n            \n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}