{
    "Shader": {
        "info": {
            "date": "1522633431",
            "description": "Clothoid IFS fractal.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdVczy",
            "likes": 8,
            "name": "Clothoid IFS Fractal",
            "published": 3,
            "tags": [
                "fractal",
                "ifs",
                "clothoid"
            ],
            "usePreview": 0,
            "username": "joeedh",
            "viewed": 776
        },
        "renderpass": [
            {
                "code": "/*\n\nClothoid IFS fractal.\n\nClick and drag.\n\nAuthor: Joseph Eagar\n\n02/20/2020 update: \n\nMade clothoid double sided.  Added a DSCALE to adjust per-level\nscaling and a BASE_ROTATION parameters.\n\n*/\n\n#define PI 3.14159265453\n\n#define BASE_ROTATION -0.3\n#define IFSSTEPS 10 //fractal levels\n#define DSCALE 1.5; //scale per level\n\n#define STEPS 7 //base clothoid integration steps\n#define ISTEPS 10 //steps for distance-to-clothoid solver\n\n#define df 0.001 //for finding numerical derivatives\n\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\nfloat ctent(float f) {\n    return cos(f*PI*2.0)*0.5 + 0.5;\n}\n\nvec2 tent(vec2 v) {\n    return vec2(\n        tent(v.x),\n        tent(v.y)\n    );\n}\n\nvec2 ctent(vec2 v) {\n    return vec2(\n        ctent(v.x),\n        ctent(v.y)\n    );\n}\n\n\nvec2 rot2d(vec2 v, float a) {\n    return vec2(\n      v[1]*sin(a) + v[0]*cos(a),\n      -v[0]*sin(a) + v[1]*cos(a)\n    );\n}\n\nvec2 f(float s1) {\n    float s = 0.0, ds = 1.5*s1/float(STEPS);\n    float ds2=ds*ds, ds3=ds2*ds;\n    vec2 ret = vec2(0, 0);\n    float t = 1.0, t2 = 1.0;\n    \n    s -= 1.2;\n    \n    for (int i=0; i<STEPS; i++) {\n        float th = s*s; //(s-1.0)*(s-1.0)*2.0;\n        float sinth=sin(th), costh = cos(th);\n        //float sinth=tent(th/3.14159/2.0-0.25)*2.0-1.0, costh = tent(th/3.14159/2.0)*2.0-1.0;\n        float th2=th*th;\n        \n        /*\n        //2nd-order taylor approximation\n        ret[0] += sinth + costh*s*t*ds;\n        ret[1] += costh - sinth*s*t*ds;\n        //*/\n        \n        //4rd-order taylor approximation\n        //*\n        ret[0] += sinth + costh*s*t*ds + \n             0.1666666*(t2*(costh - 2.0*sinth*th))*ds2 -\n             0.0416666*4.0*(2.0*costh*th + 3.0*sinth)*s*t*t*ds3;\n        ret[1] += costh - sinth*s*t*ds -\n            2.0*t*(0.1666666)*(2.0*costh*th + sinth)*ds2 - \n            0.0416666*4.0*(3.0*costh-2.0*sinth*th)*s*t*t*ds3;\n\t\t//*/\n        \n        s += ds;\n    }\n    \n    return ret*ds;\n}\n\nvec2 dv(float s) {\n    return (f(s+df) - f(s-df)) / (2.0*df);\n}\n\n\n//error function for point to clothoid distance solver\nfloat err(float s, vec2 uv) {\n    vec2 v = (f(s) - uv);\n    \n    return dot(v, v);\n}\n\nfloat atan2(float y, float x) {\n    float th = atan(y / x);\n    \n    if (x > 0.0)\n        return atan(y / x);\n    if (x < 0.0 && y >= 0.0)\n        return atan(y / x) + PI;\n    if (x < 0.0 && y < 0.0)\n        return atan(y / x) - PI;\n   \tif (x == 0.0 && y > 0.0)\n        return PI*0.5;\n    if (x == 0.0 && y < 0.0)\n        return -PI*0.5;\n    return 0.0;\n}\n\n//finds distance of point uv to clothoid\nfloat clothoid(vec2 uv) {\n    \n    uv = rot2d(uv, BASE_ROTATION);\n    \n    float s;\n    float d = 1.0;\n    \n    for (int i=0; i<ISTEPS; i++) {\n    \tfloat e1 = err(s, uv);\n        float e2 = err(s+df, uv);\n        \n        float de = (e2 - e1) / df;\n        \n        //just do simple gradient descent\n        float fac = -e1/de;\n        \n        s += -de*0.4;\n        \n        //enforce parameter-space boundsZ\n        s = min(max(s, 0.0), 2.25);\n    }\n    \n    \n    d = length(f(s) - uv);\n    return pow(d, 1.0);\n}\n\nvec3 sample1(vec2 uv) {\n    float mx = 0.35 + iMouse.x / iResolution.x;\n    float my = 0.62 + 0.2*iMouse.y / iResolution.y;\n\t\n\tfloat th = -0.6 + mx + cos(iTime)*0.1;\n    float thscale = 1.035 + (cos(iTime*1.2)*0.5+0.5)*0.3;\n\tfloat f1, f2;    \n\n    int i;\n\n    vec2 lastp;\n    \n    float s = 1.25 + my*2.0;\n    \n    float dscale = DSCALE;\n     \n    f2 = 1.0;\n    \n  \n    float trap = 0.0;\n    float tottrap = 0.0;\n    float trap2 = 0.0;\n    float minfac = 1.0;\n\tvec2 startuv = uv;\n    vec2 uv2=uv, lastuv=uv;\n\n    //uv = abs(uv);\n    for (i=0; i<IFSSTEPS; i++) {\n        /*mirror about x axis\n        if (uv[1] < 0.0) {\n            uv = -uv;\n            startuv = -startuv;\n        }\n\t\t*/\n\n        uv2=uv;\n\t     \n        //so-called trap for coloring\n        vec2 trapuv = tent(uv);\n\n        float trapval = length(trapuv - uv)*(1.0-f2)*1.5;\n        float trapval2 = length(trapuv - lastuv)*(1.0-f2);\n        float trapw = pow(1.0 - float(i)/float(IFSSTEPS), 2.0);\n        \n        lastuv = uv2;\n        \n        trap += trapval*trapw;\n        trap2 += trapval2*trapw;\n        tottrap += trapw;\n\t\t\n        //get distance to clothoid\n        f1 = clothoid(uv2);\n        \n        if (f1 < f2) {\n            f2 = f1;\n            \n            //shade lower levels less\n\t        float fac = 1.0 -(float(i+1) / float(IFSSTEPS+1));\n            minfac = pow(1.0-f1, 50.0)*fac;\n        }\n         \n        //rotate to be tangent with curve at f(s)\n        vec2 p = f(s);\n        vec2 dp = f(s+df);\n\t\t\n        //set up derivative\n        dp = (dp - p) / df;\n        dp.xy = dp.yx;\n        dp.x = -dp.x;\n\t\t\n        //rotate\n        uv2 -= p;\n        uv2 = rot2d(uv2, atan(dp.y / dp.x)+PI*0.5);\n        lastp = p;\n        \n        //translate in y a bit\n        float yadd = my;\n        uv2.y += yadd;\n        uv2 = abs(uv2);\n        uv2.y -= yadd;\n        \n        //now do an arbitrary rotation\n        uv2 = rot2d(uv2, th);\n        th *= thscale;\n        uv2 = uv2*dscale;// - (dscale - 1.0);\n        \n        //bailout condition\n        if (dot(uv2, uv2) > 15.0) {\n            break;\n        }\n        \n        uv = uv2;\n    }\n    \n    f2 = 1.0 - f2;\n    f2 *= minfac*0.4+0.8;\n    \n    //normalize traps\n    trap /= tottrap;\n    trap2 /= tottrap;\n    \n    //multiple traps with base fractal\n    trap *= f2;\n    trap2 *= f2;\n    \n    vec3 trapclr = vec3(trap*0.9, trap2, trap*0.2);\n    vec3 clr = vec3(f2, f2, f2);\n    \n    //blend base fractal with traps\n    clr = clr*(trapclr*0.5+0.5)*0.5 + trapclr*1.3;\n\n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x=0.0, y=0.0;\n    \n\tuv[0] *= iResolution.x / iResolution.y;\n    uv -= 0.5;\n    \n    uv *= 2.0;\n    \n    uv[0] -= 0.0;\n    uv[1] += 0.8;\n    \n    vec3 clr = sample1(uv);\n    \n\tfragColor = vec4(clr, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}