{
    "Shader": {
        "info": {
            "date": "1665178652",
            "description": "A box with ray marched stuff.",
            "flags": 32,
            "hasliked": 0,
            "id": "NlKfWy",
            "likes": 10,
            "name": "Hyperbox",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "raymarching",
                "art"
            ],
            "usePreview": 1,
            "username": "me_123",
            "viewed": 264
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);//vec4(0.0,0.0,1.0,1.0);\n    fragColor /= fragColor.w;\n    fragColor.yxz = 0.01/fragColor.xyz;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int it = 10;\nconst float eps = 0.001;\nfloat boxx( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return 1000.; // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return tN;\n}\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nvec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat noise(in vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nvec3 rus(in vec3 seed) {\n    return normalize(hash33(seed)-0.5);\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec3 rep(in vec3 p, in float c, in vec3 l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\nfloat sdf(in vec3 z) {\n    z *= 3.;\n    z += vec3(sin(iTime)*2.0, sin(iTime+1.0)*2.0, iTime*10.0);\n    z.x = mod(z.x-4.0, 8.)-4.;\n    z.y = mod(z.y-4.0, 8.)-4.;\n    vec3 p = z;\n    float r = (p.z)*0.1;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    p.xy *= rot;\n    p.z = fract(p.z)-0.5;\n    p.x = abs(p.x)-2.0;\n    float k = max(min(box(abs(p)-vec3(1.1, 0.0, 0.0), vec3(0.1, 1.1, 0.1)),\n                  box(abs(p)-vec3(0.0, 1.0, 0.0), vec3(1.2, 0.1, 0.4))), -(length(p-vec3(-1.0, 0.0, 0.0))-0.2));\n    return k*0.6*0.33333;//min(max(abs(p.x)+1.0, abs(p.y)+1.0), k);\n}\nvec3 normal( vec3 p)\n{\n    const float h = eps;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdf(p + k.xyy * h) +\n                     k.yyx * sdf(p + k.yyx * h) +\n                     k.yxy * sdf(p + k.yxy * h) +\n                     k.xxx * sdf(p + k.xxx * h));\n}\nstruct hit {\n    vec3 p;\n    vec3 n;\n    float d;\n    int i;\n};\nhit trace(in vec3 ro, in vec3 rd) {\n\tfloat d0 = 0.0;\n    vec3 p;\n    int i;\n    for (i = 0; i < 100; i += 1) {\n    \tp = ro+rd*d0;\n        float d = sdf(p.xzy);\n        d0 += d;\n        if (d < eps || d0 > 1000.) break;\n    }\n    if (d0 > 1000.) return hit(vec3(-1), vec3(-1), -1., i);\n    return hit(p, normal(p), d0, i);\n}\nvec3 sky(in vec3 rd) {\n    return vec3(1.0, 0.9, 2.0)*vec3(noise(rd*2.0)*noise(rd))*0.1;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec3 t1;\n    float s = ro.z/-rd.z;\n    if (s < 0.0) {s = 1000.;};\n    float b = boxx(ro-vec3(0, 0, 1.5), rd, vec3(1.5), t1);\n    if (b > s) {\n        ro = ro+rd*s;\n        rd = reflect(rd, vec3(0, 0, 1)+0.1*normalize(hash33(ro*100.)-0.5));\n        float b = boxx(ro-vec3(0, 0, 1.5), rd, vec3(1.5), t1);\n        if (b > 100.) return sky(rd);\n        ro = ro+rd*b;\n        hit t = trace(ro, rd);\n        return max(vec3(0),vec3(abs(sin(iTime+t.p.z*0.1))*3.0,abs(sin(iTime*0.5+t.p.z*0.1))*2.0,abs(sin(iTime*0.15))*1.5)/float(t.i+1));//(nt.d>0.0?vec3(0):vec3(abs(nd)));\n    };\n    b = min(b, s);\n    if (b < 1000.) {\n        ro = ro+rd*b;\n        hit t = trace(ro, rd);\n        return max(vec3(0),vec3(abs(sin(iTime+t.p.z*0.1))*3.0,abs(sin(iTime*0.5+t.p.z*0.1))*2.0,abs(sin(iTime*0.15))*1.5)/float(t.i+1));//(nt.d>0.0?vec3(0):vec3(abs(nd)));\n    } else {\n        return sky(rd);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord+hash33(vec3(fragCoord.xy, iTime)).xy) - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = vec2(iTime*0.25, 1.7);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*7.0;\n    vec3 rd = getRay(-normalize(ro), uv);\n    ro.z += 1.5;\n    vec3 color = getColor(ro, rd);\n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\n    //super sample\n    fragColor = vec4(color, 1)*0.25+old*0.75;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}