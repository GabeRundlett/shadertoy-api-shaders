{
    "Shader": {
        "info": {
            "date": "1646682897",
            "description": "an ambient occlusion demo\nChange noise types in the common tab\nPress spacebar to reset accumulation\nAll noise is white over time",
            "flags": 48,
            "hasliked": 0,
            "id": "fs2fzK",
            "likes": 39,
            "name": "Ray Traced Ambient Occlusion",
            "published": 3,
            "tags": [
                "ambientocclusion"
            ],
            "usePreview": 1,
            "username": "demofox",
            "viewed": 1627
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// The maximum hit time is the farthest the AO rays look for a hit.\n// The AO shade is the percentage the hit is between 0 (black) and maximum hit time (white).\nconst float c_maximumRayHitTime = 10.0f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 1;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float c_goldenRatioConjugate = 0.61803398875f;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n// The noise type specifies noise over space. They are all white noise over time.\n#define NOISE_TYPE_WHITE 0\n#define NOISE_TYPE_BLUE  1\n#define NOISE_TYPE_BAYER 2  \n#define NOISE_TYPE_R2    3\n#define NOISE_TYPE_IGN   4\n#define NOISE_TYPE_NONE  5\n\n#define NOISE_TYPE NOISE_TYPE_BLUE\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "uint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat WangRandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 R2(int index)\n{\n    const float g = 1.32471795724474602596f;\n    const float a1 = 1.0f/g;\n    const float a2 = 1.0f/(g*g);\n    return vec2(float(index)*a1, float(index)*a2);\n}\n\n#if NOISE_TYPE == NOISE_TYPE_WHITE\n\n#define RNGSTATE uint\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    return uint(pixelPosX * uint(1973) + pixelPosY * uint(9277) + frame * uint(26699)) | uint(1);\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_BLUE\n\n#define RNGSTATE ivec3\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    return ivec3(pixelPosX, pixelPosY, frame);\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    vec2 uv = vec2(state.xy) / 1024.0 + R2(state.z % 256);\n    state.z = state.z + 1;\n    return texture(iChannel3, uv).r;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_BAYER\n\nstruct BayerRNG\n{\n    ivec2 pos;\n    uint wangRng;\n};\n\n#define RNGSTATE BayerRNG\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    RNGSTATE ret;\n    ret.wangRng = uint(frame * uint(26699)) | uint(1);\n    ret.pos = ivec2(int(pixelPosX) + int(WangRandomFloat01(ret.wangRng) * 8.0f), int(pixelPosY) + int(WangRandomFloat01(ret.wangRng) * 8.0f));\n    return ret;\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    vec2 uv = vec2(state.pos.xy) / 8.0f;\n\n    state.pos += ivec2(int(WangRandomFloat01(state.wangRng) * 8.0f), int(WangRandomFloat01(state.wangRng) * 8.0f));\n\n    return texture(iChannel2, uv).r;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_R2\n\nstruct R2RNG\n{\n    ivec2 pos;\n    uint wangRng;\n};\n\n#define RNGSTATE R2RNG\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    RNGSTATE ret;\n    ret.wangRng = uint(frame * uint(26699)) | uint(1);\n    ret.pos = ivec2(int(pixelPosX) + int(WangRandomFloat01(ret.wangRng) * 64.0f), int(pixelPosY) + int(WangRandomFloat01(ret.wangRng) * 64.0f));\n    return ret;\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    const float g = 1.32471795724474602596f;\n    const float a1 = 1.0f/g;\n    const float a2 = 1.0f/(g*g);\n    float ret = fract(float(state.pos.x)*a1+float(state.pos.y)*a2);\n    state.pos += ivec2(int(WangRandomFloat01(state.wangRng) * 64.0f), int(WangRandomFloat01(state.wangRng) * 64.0f));\n    return ret;\n}\n\n#elif NOISE_TYPE == NOISE_TYPE_IGN\n\nstruct IGNRNG\n{\n    ivec2 pos;\n    uint wangRng;\n};\n\n#define RNGSTATE IGNRNG\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    RNGSTATE ret;\n    ret.wangRng = uint(frame * uint(26699)) | uint(1);\n    ret.pos = ivec2(int(pixelPosX) + int(WangRandomFloat01(ret.wangRng) * 64.0f), int(pixelPosY) + int(WangRandomFloat01(ret.wangRng) * 64.0f));\n    return ret;\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    float ret = fract(52.9829189f * fract(0.06711056f*float(state.pos.x) + 0.00583715f*float(state.pos.y)));\n    state.pos += ivec2(int(WangRandomFloat01(state.wangRng) * 64.0f), int(WangRandomFloat01(state.wangRng) * 64.0f));\n    return ret;\n}\n\n#else  // NONE\n\n#define RNGSTATE uint\n\nRNGSTATE MakeRNGState(uint pixelPosX, uint pixelPosY, uint frame)\n{\n    return uint(frame * uint(26699)) | uint(1);\n}\n\nfloat RandomFloat01(inout RNGSTATE state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n#endif\n\nvec3 RandomUnitVector(inout RNGSTATE state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);\n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);       \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);   \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);     \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D);\n    }\n\n    // 3 front balls on the floor\n    {\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4);\n    }\n\n    // 5 small balls against the back wall\n    {\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);\n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);      \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);  \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4);     \n    }\n}\n\nvec3 GetAOForRay(in vec3 startRayPos, in vec3 startRayDir, inout RNGSTATE rngState)\n{\n    // primary hit\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;    \n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_superFar;\n    TestSceneTrace(rayPos, rayDir, hitInfo);\n    if (hitInfo.dist >= c_superFar)\n        return vec3(1.0f, 1.0f, 1.0f);\n        \n    // update the ray position and raydir\n    // ray direction is a cosine weighted hemisphere oriented to the surface normal.\n    rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n    rayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n\n    // AO ray\n    hitInfo.dist = c_maximumRayHitTime;\n    TestSceneTrace(rayPos, rayDir, hitInfo);\n\n    // the shade gets lighter as the hit distance gets farther\n    float distPercent = min(hitInfo.dist / c_maximumRayHitTime, 1.0f);\n    return vec3(distPercent, distPercent, distPercent);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    RNGSTATE rngState = MakeRNGState(uint(fragCoord.x), uint(fragCoord.y), uint(iFrame));\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    \n    // calculate the camera distance\n\tfloat cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);     \n    \n    // calculate subpixel camera jitter for anti aliasing\n    uint wangRNG = uint(uint(fragColor.x) * uint(1973) + uint(fragColor.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(WangRandomFloat01(wangRNG), WangRandomFloat01(wangRNG)) - 0.5f;\n    \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3(((fragCoord+jitter)/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n    // correct for aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // raytrace for this pixel\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    for (int index = 0; index < c_numRendersPerFrame; ++index)\n    \tcolor += GetAOForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);\n    \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    // show the result\n    fragColor = vec4(color, blend);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}