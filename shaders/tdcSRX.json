{
    "Shader": {
        "info": {
            "date": "1572472274",
            "description": "I wanted to create some basic synthwave visual and added some julia friends riding together",
            "flags": 0,
            "hasliked": 0,
            "id": "tdcSRX",
            "likes": 7,
            "name": "Shadertober 28 ride",
            "published": 3,
            "tags": [
                "raymarching",
                "julia",
                "inktober"
            ],
            "usePreview": 0,
            "username": "GreenChicken",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "// SHADERTOBER 28 Ride\n// Poulet vert 30-10-2019\n// second shader based on Julia function by iq\n// thanks leon <3\n\n#define VOLUME 0.001\n#define PI 3.14159\n\n\n\nvec3 opRep(vec3 p, vec3 c)\n{\n     return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec4 qsqr( in vec4 a ) // square a quaterion\n{\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n}\n\nvec4 qmul( in vec4 a, in vec4 b)\n{\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, \n        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );\n\n}\n\nvec4 qconj( in vec4 a )\n{\n    return vec4( a.x, -a.yzw );\n}\n\n// iq Julia src : https://www.shadertoy.com/view/MsfGRr\nconst int numIterations = 11;\nfloat julia(vec3 p, vec4 c)\n{\n    vec4 z = vec4(p,0.0);\n    \n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    float n = 1.0;\n    for( int i=0; i<numIterations; i++ )\n    {\n        md2 *= mz2;\n        z = qsqr(z) + c;  \n        mz2 = dot(z,z);\n        if(mz2>4.0) break;\n        n += 1.0;\n    }\n    \n    return 0.1*sqrt(mz2/md2)*exp2(-n)*log(mz2);\n}\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\n// Scene setup\nvec2 map(vec3 p)\n{\n    // ground\n    vec3 gp = p + vec3(0.0);\n    gp.y += sin(p.z+iTime*5.)*sin(p.x*5.)*.1;\n    float d = gp.y;\n    \n    // sun\n    vec3 cp = p + vec3(0.0, -2.0, -30.0);\n    float c = sdSphere(cp,  5.);\n    \n    // moutain\n    vec3 mp = p + vec3(0.0, -0.5, -20.0);\n    mp = opRep(mp, vec3(1.0, 0.0, 0.0));\n    mp.y += sin(p.x*4.)*.2;\n    mp.y += abs(p.x)*.2;\n    float m = sdSphere(mp, 1.5);\n    \n    // julia\n    vec3 jp = p + vec3(sin(iTime), -2.0, cos(iTime)*2.0);\n    float j = julia(jp, vec4(.5+abs(sin(p.z+iTime)), p.y, .5, p.z));\n    \n    // julia 2\n    jp = p + vec3(sin(iTime+2.0), -2.0, cos(iTime)*2.0+1.0);\n    j = min(j, julia(jp, vec4(.5+abs(sin(p.z+iTime)), p.y, .5, p.x)));\n    \n    \n    // materials\n    vec2 scene = vec2(d, 0.0);\n    scene = opU2(scene, vec2(c, 1.0));\n    scene = opU2(scene, vec2(m, 2.0));\n    scene = opU2(scene, vec2(j, 3.0));\n    \n    return scene; \n}\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    \n    for(int i=0 ; i<128 ; i++)\n    {\n        vec2 ray = map(ro + rd * t);\n        \n        if(ray.x < (0.0001*t))\n        {\n            return vec2(t, ray.y);\n        }\n        \n        t += ray.x;\n    }\n    \n    return vec2(-1.0, 0.0);\n}\n\n\nvec3 GetNormal (vec3 p)\n{\n    float c = map(p).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+e.xyy).x, map(p+e.yxy).x, map(p+e.yyx).x) - c);\n}\n\n\n\nvec3 Render(vec3 ro, vec3 rd, vec2 uv, float time)\n{\n    \n    \n    // map stuffs\n    vec2 t = CastRay(ro, rd);\n    vec3 pos = vec3(ro + rd * t.x);\n    \n    vec3 col = vec3(0.0);\n    vec3 polyCol = palette(fract(iTime), vec3(.5), vec3(1.0), vec3(1.0), vec3(0.67, 0.33, 0.0));\n    \n    vec3 nor = GetNormal(pos);\n    vec3 light = vec3(0.0, 1.0, -5.0);\n    float l = clamp(dot(nor, light), 0.0, 1.0);\n    \n    if(t.x == -1.0)\n    {\n        vec3 ramp = mix(vec3(1.0, 0.0, 0.5), vec3(0.0,  0.0, 1.0), max(uv.y, 0.0));\n        ramp *= ramp;\n        ramp *= uv.y;\n        ramp = clamp(ramp, 0.0, 1.0);\n        ramp *= abs(uv.y)*-1.+.5;\n        \n        col = ramp;\n    }\n    else\n    {   \n        if(t.y==0.0) // ground grid\n        {\n            vec2 groundPos = pos.xz;\n            groundPos.y += time;\n            \n            // first version\n            //float grid = clamp(step(fract(groundPos.x*1.), .05) + step(fract(groundPos.y*1.), .05), 0.0, 1.0);\n            \n            // edit thanks to ocb\n            float grid = max(.1/(abs(fract(groundPos.x)-.5)+.1) + .1/(abs(fract(groundPos.y)-.5)+.1)-.5,0.);\n            \n            col = vec3(0.0, 0.0, 1.0) * grid;\n            col *= clamp(-pos.z*.01+.1, 0.0, 1.0)*10.;\n        }\n        else if(t.y==1.0) // sun\n        {\n            col = mix(vec3(1.0, .0, .3), vec3(0.0, .5, 1.0), uv.y*3.0-.3);\n        }\n        else if(t.y==2.0) // black\n        {\n            col = vec3(0.0);\n        }\n        else if(t.y==3.0) // shape\n        {\n            col = vec3(1.0, .0, .3) * l + fract(iTime*5.0);\n        }\n    }\n    \n    return col;\n}\n\nvec3 GetViewDir(vec2 uv, vec3 cp, vec3 ct)\n{\n    vec3 forward = normalize(ct - cp);\n    vec3 right = normalize(cross(vec3(sin(iTime)*.2, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    return normalize(uv.x * right + uv.y * up + 2.0 * forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    \n    float time = iTime * 5.0;\n    \n    \n    vec3 cp = vec3(sin(iTime)*.1, 1.0+sin(iTime)*.2, -5.0);\n    vec3 ct = vec3(0.0, 1.0, 0.0);\n    \n    vec3 vd = GetViewDir(uv, cp, ct);\n    \n    vec3 col = Render(cp, vd, uv, time);\n    \n    col.b -= uv.y*.2;\n    col *= clamp(1.0-length(uv*.75), 0.0, 1.0);\n    \n    \n    \n    col = sqrt(clamp(col, 0.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}