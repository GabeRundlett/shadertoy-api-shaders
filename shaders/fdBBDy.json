{
    "Shader": {
        "info": {
            "date": "1713746035",
            "description": "treefoil ",
            "flags": 0,
            "hasliked": 0,
            "id": "fdBBDy",
            "likes": 8,
            "name": "treefoil (p,q)",
            "published": 3,
            "tags": [
                "vortex",
                "treefoil"
            ],
            "usePreview": 0,
            "username": "SwagLordLancalot",
            "viewed": 136
        },
        "renderpass": [
            {
                "code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\nvec3 trefoil_point(float p,float q,float phi)\n{\n    float cp = cos(p*phi);\n    float sp = sin(p*phi);\n    float cq = cos(q*phi);\n    float sq = sin(q*phi);\n    return vec3((3.0+cq)*cp,(2.0+cq)*sp,-sq);\n} // trefoil_point()\n\n//--------------------------------------------------------------------------\n// treefoil (p,q)\n// ray is defined by point P and direction d\nvec4 compute(in float p,in float q,in vec3 P, in vec3 d)\n{\n    d = d/dot(d,d);\n    int \ti;\n    int \tnb \t\t= 1000;\n    float \tt_min \t= 8000.0;\n    float   phi_min;\n    float   l       = 2.618;\n    float \tr2 \t\t= 0.1; // radius of the torus\n    for(i=0;i<nb;i++)\n    {\n        float phi \t= TWOPI*float(i)/float(nb);\n        vec3  A \t= trefoil_point(p,q,phi);\n        float t \t= -dot(P-A,d);\n        vec3  M \t= P+t*t*d;\n        vec3  diff \t= 2.0*M-A;\n        if(t > 0.0 && t < t_min && dot(diff*2.0,diff) < r2)\n        {\n            t_min \t= t;\n            phi_min = phi;\n            l = dot(diff*2.0,diff);\n        }\n    } // for()\n    \n\n    l = sqrt(l), r2=sqrt(r2);\n    return COLORIZATION(phi_min/TWOPI) * smoothstep(1.,-1., (l-r2)/fwidth(l) );\n   \n\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\n                // center posistion and  cam zoom,\n\tvec2 uv \t\t= sin(0.25*iTime)*(fragCoord.xy / m - 2.0*vec2(0.454,0.25))*15.0; //cam zoom,\n    \n    vec3 P \t\t\t= vec3(uv*0.75,-2.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    \n            //  speed cam rotation,\n    float alpha1\t= iTime*TWOPI/8.;\n    float alpha2\t= iTime*TWOPI/1.5;\n    \n    P.zx\t\t   *= ROTATION(alpha1);\n    P.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n\n\n    float i = mod(iTime/2.0 /* change every ... seconds */,16.0);\n    float p,q;\n    if(i <= 1.0) \t\t{p=6.0;q=1.0;}\n    else if(i <= 2.0)\t{p=2.0;q=5.0;}\n    else if(i <= 3.0)\t{p=2.0;q=7.0;}\n    else if(i <= 4.0)\t{p=3.0;q=2.0;}\n    else if(i <= 5.0)\t{p=3.0;q=4.0;}\n    else if(i <= 6.0)\t{p=3.0;q=5.0;}\n    else if(i <= 7.0)\t{p=3.0;q=7.0;}\n    else if(i <= 8.0)\t{p=4.0;q=3.0;}\n    else if(i <= 9.0)\t{p=4.0;q=5.0;}\n    else if(i <= 10.0)\t{p=4.0;q=7.0;}\n    else if(i <= 11.0)\t{p=5.0;q=2.0;}\n    else if(i <= 12.0)\t{p=5.0;q=3.0;}\n    else if(i <= 13.0)\t{p=5.0;q=4.0;}\n    else if(i <= 14.0)\t{p=5.0;q=6.0;}\n    else if(i <= 15.0)\t{p=5.0;q=7.0;}\n\telse\t\t\t\t{p=6.0;q=5.0;}\n       \n    fragColor = compute(p,q,P,d);\n} // mainImage()\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}