{
    "Shader": {
        "info": {
            "date": "1546386515",
            "description": "Attempt to make a GLSL based 3D looking leaf rotating. To be used with a WebGL Particle System. With help and explanation from: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/ and http://iquilezles.org/articles/distfunctions/d",
            "flags": 0,
            "hasliked": 0,
            "id": "Wdl3W4",
            "likes": 15,
            "name": "Simple Rose Petal",
            "published": 3,
            "tags": [
                "3d",
                "geometry"
            ],
            "usePreview": 0,
            "username": "jonobr1",
            "viewed": 1312
        },
        "renderpass": [
            {
                "code": "float sdEllipsoid( in vec3 p, in vec3 r ) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 sight ) {\n\n    // Of the object\n    vec3 position = vec3( 0.0, 0.0, 0.0 );\n\n    // The xyz component radius values of the ellipsoid\n    vec3 radius = vec3( 1.5, 0.1, 1.0 );\n\n    // Define position in relation to the camera\n    position = sight - position;\n\n    // Bend the ellipsoid on the z axis\n    float bend = 0.2;\n    float c = cos( position.z * bend );\n    float s = sin( position.z * bend );\n    mat2  m = mat2( c, - s, s, c );\n    vec3  q = vec3( m * position.xy, position.z );\n\n   \t// Bend the ellipsoid on the x axis\n    bend = - 0.1;\n    c = cos( q.x * bend );\n    s = sin( q.x * bend );\n    m = mat2( c, - s, s, c );\n    q = vec3( m * q.xy, q.z );\n\n    vec3 worldPosition = q;\n\n    float sdf = sdEllipsoid( worldPosition, radius );\n    vec2 res = vec2( sdf, 0.0 );\n\n    return res;\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n\n    // Near / Far Clipping Plane\n    float tmin = 1.0;\n    float tmax = 50.0;\n    \n    float t = tmin;\n    float m = - 1.0;\n    // TODO: Why does it need so many iterations\n    // to march correctly?\n    for( int i = 0; i < 128; i++ ) {\n\n\t    float precis = 0.0004 * t;\n\t    vec2 res = map( ro + rd * t );\n\n        // Means no intersection\n        // and no possibility of checking again\n        // so stop the Ray Marching\n        if( res.x < precis || t > tmax ) break;\n\n        t += res.x;\n\t    m = res.y; // Identify which shape was intersected via a float\n\n    }\n\n    if( t > tmax ) m =- 1.0;\n    return vec2( t, m );\n}\n\nvec3 render( in vec3 ro, in vec3 rd ) {\n\n    vec3 col = vec3( 0.85 );\n    vec2 res = castRay( ro,rd );\n\n    float t = res.x;\n\tfloat m = res.y;\n\n    // Ray intersected object\n    if( m >= 0.0 ) {\n        // normalize t and flip it\n\t\tfloat tn = 1.0 - t / 24.5;\n        vec3 white = vec3( 1.0, 1.0, 0.75 );\n        vec3 red = vec3( 1.0, 0.0, 0.15 );\n\t\tcol = mix( red, white, pow( tn, 2.0 ) );\n    }\n\n\treturn vec3( clamp( col, 0.0, 1.0 ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\n    vec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv = normalize( cross( cu, cw ) );\n\n    return mat3( cu, cv, cw );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = iTime;\n\n    vec2 p = ( - iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n\t// Camera Position\n    // vec3 ro = vec3( 10.0 * cos( mo.x * 3.14 ), 10.0 * mo.y - 5.0, 10.0 * sin( mo.x * 3.14 ) );\n    vec3 ro = vec3( 10.0 * cos( time ), 10.0 * sin( time * 2.0 ), 10.0 * sin( time ) );\n    // Camera Look At Vector\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    // TODO: Don't understand the z-component `8.0`\n    // But I think it has soemthing to do with\n    // the zoom of the camera.\n    vec3 rd = ca * normalize( vec3( p.xy, 8.0 ) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4( col, 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}