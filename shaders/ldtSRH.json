{
    "Shader": {
        "info": {
            "date": "1458242940",
            "description": "spring simulation, raytrace, explicite euler",
            "flags": 32,
            "hasliked": 0,
            "id": "ldtSRH",
            "likes": 0,
            "name": "spring simulation raytraced",
            "published": 3,
            "tags": [
                "raytrace",
                "springsimulation",
                "expliciteeuler"
            ],
            "usePreview": 0,
            "username": "samuelotherion",
            "viewed": 171
        },
        "renderpass": [
            {
                "code": "#define F\t\t\tfloat\n#define V2\t\t\tvec2\n#define V3    \t\tvec3\n#define V4    \t\tvec4\n#define PX( p )\t\ttexture( iChannel0, p )\n#define lt( a, b )\tall( lessThan( a, b ) )\n#define eq( a, b )\tall( equal( a, b ) )\n#define st( a, b )\tall( greaterThan( a, b ) )\n\n#define T\t\t\tiTime\n#define R\t\t\tiResolution.xy\n\n#define IDSKY       0\n#define IDPLANE     1\n#define IDBALL      2\n#define IDSPRING    3\n#define IDLIGHT     4\n\n#define HASHSCALE1  443.8975\n#define HASHSCALE3  vec3( 443.897, 441.423, 437.195 )\n\nV2\n\tRi,\n    A;\n\nconst V4\n    C = V4( 0, 1, .5, 1.5 );\n\nconst F\n    PCNT = 4.,\n    SCNT = 6.,\n    CNT  = max( PCNT, SCNT ),\n\tCONT = .0625;\n\n// zoom display is 50% of height \n// Z  = 50. / 100. / 5. * R.y,\nfloat \n    Z,\n    Zi;\n\n//Ram size\nconst V2\n    RSZ = V2( CNT, 6. );\n\nV3\n    lgt;\n\nV4\n    dcl,\n    acl;\n\nV2\n    I,\n    N;\n\nV3\n    P;\n\nV4\n    O = C.xxxy;\n\nmat3\n    aprj( V3 v ) {\n        \n        return mat3( 1,0,0, 0,1,0, 0,0,1 ) - mat3( v * v.x, v * v.y, v * v.z ) / dot( v, v );\n    }\n\nF\n    hash13( V3 p ) {\n        \n        p  = fract( p  * HASHSCALE1 );\n    \n        p += dot( p, p.yzx + 19.19 );\n        \n        return fract( ( p.x + p.y ) * p.z);\n}\n\nV3\n    hash31( float p ) {\n        \n        V3\n            p3 = fract( V3( p ) * HASHSCALE3 );\n        \n        p3 += dot( p3, p3.yzx + 19.19 );\n        \n        return fract( V3( ( p3.x + p3.y ) * p3.z, ( p3.x + p3.z ) * p3.y, ( p3.y + p3.z ) * p3.x ) );\n}\n\nV3\n    hash32( V2 p ) {\n        \n        V3\n            p3 = fract( V3( p.xyx ) * HASHSCALE3 );\n        \n        p3 += dot( p3, p3.yxz + 19.19 );\n        \n        return fract( V3( ( p3.x + p3.y ) * p3.z, ( p3.x + p3.z ) * p3.y, ( p3.y + p3.z ) * p3.x ) );\n}\n\nV3\n    hash33( V3 p ) {\n        \n        p = fract( p * HASHSCALE3 );\n    \n        p += dot( p, p.yxz + 19.19 );\n        \n        return fract( V3( ( p.x + p.y ) * p.z, ( p.x + p.z ) * p.y, ( p.y + p.z ) * p.x ) );\n}\n\n\nvoid\n    paintRam( ) {\n        \n        if( lt( Z * RSZ, I ) ) \n            \n            return;\n        \n        V4\n            p = PX( N * Zi );\n\n        V2\n            q = mod( I * Zi, C.yy );\n        \n        float\n            s = 1. * Zi;\n        \n\n        if( q.x < s || q.y < s )\n            \n            O = C.xxxx;\n        \n        else\n\n            if( ( 1. - q.x ) < s || ( 1. - q.y ) < s )\n                \n                O = C.yyyy;\n\n            else\n                \n                if( q.y < .5 )\n                    \n                    O = .5 + CONT * V4( ( ( q.x < .25 ? p.r : 0. ) + ( .25 <= q.x && q.x < .5 ? p.g : 0. ) + ( .5 <= q.x && q.x < .75 ? p.b : 0. ) + ( .75 <= q.x ? p.a : 0. ) ) * C.yyy, 1 );\n                \n                else\n                    \n                    O = .5 + CONT * PX( N * Zi );\n    }\n\nvoid\n    hitBall( V3 e, V3 r, V3 p, F rad, inout F l, inout V3 h, inout V3 n, inout int i ) {\n\n        V3\n            d = e - p;\n\n        F\n            ab = dot( r, d ),\n            bb = dot( d, d ),\n            ds = ( rad * rad - bb ) + ab * ab;\n\n        if( 0. <= ds ) {\n\n            F\n                ln = ( -ab - sqrt( ds ) );\n\n            if( l < ln || ln < 0.)\n\n                return;\n\n            i = IDBALL;\n            l = ln;\n            h = e + l * r;\n            n = normalize( h - p );\n        }\n    }\n\nvoid\n    renderBalls( V3 e, V3 r, inout F l, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        int\n            pcnt = int( PCNT );\n        \n        V2\n            pc = V2( .5, 1.5 );\n        \n        for( int j = 0; j < 10; ++j ) {\n            \n            if( pcnt <= j )\n                \n                break;\n            \n            V4\n                pt = PX( Ri * pc );\n            \n            hitBall( e, r, pt.xyz, ( .06 + .05 * sin( .023 * T ) ) * pow( pt.a, 1. / 3. ), l, h, n, i );\n            \n            if( ( i == IDBALL ) && s )\n                \n                return;                \n\n            ++pc.x;\n        }\n    }\n\nvoid\n    hitSpring( V3 e, V3 r, V3 p0, V3 p1, F rad, inout F l, inout V3 h, inout V3 n, inout int i ) {\n\n        V3\n            p\t= p1 - p0,\n            a   = e - p0;\n\n        mat3\n            q = aprj( p );\n        \n\t\tV3\n            qa  = q * a;\n        \n        F\n            qaa = dot( a, qa ),\n            qsa = dot( r, qa ),\n            qss = dot( r, q * r ),\n            ds  = qsa * qsa - qss * ( qaa - rad * rad );\n        \n        if( ds < 0. )\n            \n            return;\n        \n        F\n            am  = ( -qsa - sqrt( ds ) ) / qss;\n        \n        if( l < am || am < 0.)\n            \n            return;\n        \n        F\n            ht = dot( a + am * r, p / dot( p, p ) );\n        \n        if( ht < 0. || 1. < ht )\n            \n            return;\n\n        i  = IDSPRING;\n        l  = am;\n        h  = e + am * r;\n        n  = vec3( normalize( q * ( a + am * r ) ) );\n    }\n\nvoid\n    renderSprings( V3 e, V3 r, inout F l, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        int\n            scnt = int( SCNT );\n        \n        V2\n            sc = V2( .5 );\n       \n        for( int j = 0; j < 10; ++j ) {\n            \n            if( scnt <= j )\n                \n                break;\n            \n            V4\n                sp = PX( Ri * sc ),\n                pf = PX( Ri * V2( sp.z + .5, 1.5 ) ),\n                pt = PX( Ri * V2( sp.a + .5, 1.5 ) );\n            \n            hitSpring( e, r, pf.xyz, pt.xyz, ( .06 + .05 * sin( .047 * T ) ), l, h, n, i );\n            \n            if( ( i == IDSPRING ) && s )\n                \n                return;                \n            \n            ++sc.x;\n        }\n    }\n\nvoid\n    hitPlane( V3 e, V3 r, V3 p, V3 n0, inout F l, inout V3 h, inout V3 n, inout int i ) {\n\n        V3\n            d = p - e;\n        \n        F\n            ln = dot( d, n0 ) / dot( r, n0 );\n\n        if( l < ln || ln <= 0.01 )\n            \n            return;\n\n        l  = ln;\n        i  = IDPLANE;\n        h  = e + l * r;\n        n  = n0;\n    }\n\nvoid\n    renderPlanes( V3 e, V3 r, inout F l, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n\t\thitPlane( e, r, V3( 0., -1.,  0. ), V3( 0., 1., 0. ), l, h, n, i );\n            \n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n\t\thitPlane( e, r, V3( 0., +2.,  0. ), V3( 0., -1., 0. ), l, h, n, i );\n\n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n//        hitPlane( e, r, V3( 0.,  0., -1.5 ), V3( sin( 6.283 * sin( .1 * T ) ), 0., cos( 6.283 * sin( .1 * T ) ) ), l, h, n, i );\n        hitPlane( e, r, V3( 0.,  0., -4.0 ), V3( 0, 0, 1 ), l, h, n, i );\n\n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n        hitPlane( e, r, V3( -2.,  0., 0. ), V3( 1., 0., 0. ), l, h, n, i );\n\n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n        hitPlane( e, r, V3( +2.,  0., 0. ), V3( -1., 0., 0. ), l, h, n, i );\n        \n        if( ( i == IDPLANE ) && s )\n            \n            return;\n    }\n\nvoid\n    rayTrc( V3 e, V3 r, inout F d, inout V3 h, inout V3 n, inout int i, bool s ) {\n        \n        renderSprings( e, r, d, h, n, i, s );\n        \n        if( ( i == IDSPRING ) && s )\n            \n            return;\n            \n        renderBalls( e, r, d, h, n, i, s );\n            \n        if( ( i == IDBALL ) && s )\n            \n            return;\n            \n        renderPlanes( e, r, d, h, n, i, s );\n            \n        if( ( i == IDPLANE ) && s )\n            \n            return;\n        \n        int\n            ilt = IDSKY;\n        \n        hitBall( e, r, lgt, .1, d, h, n, ilt );\n        \n        i = ( ilt == IDBALL ) ? IDLIGHT : i;\n    }\n\nvoid\n    paintWorld( ) {\n        \n//        if( !equ( V2( mod( I, floor( 6.5 + 5.5 * cos( .17 * T ) ) ) ), V2( .5 ) ) ) {\n            \n//            O = V4( .1, .1, .1, 1. );\n            \n//            return;\n//        }   \n\n        V3\n            e = V3( 0, 0, 3. ),\n            r = normalize( P - e );\n        \n        F\n            l = 1e5;\n        \n        V3\n            h,\n            n;\n        \n        int\n            i = IDSKY;\n        \n        bool\n            fstBrk = false;\n        \n        rayTrc( e, r, l, h, n, i, fstBrk );\n\n        if( i == IDSKY ) {\n            \n\t        O +=  V4( .1, .2, .3, 1. );\n            \n            return;\n        }\n        \n        if( i == IDLIGHT ) {\n                \n            O += 1.3 * dcl;\n\n            return;\n        }\n        \n        n = normalize( n + .05 - .1 * hash13( h ) );\n\n        r = lgt - h;\n\n        if( dot( r, n ) <= 0. ) {\n            \n            O += V4( .5 * clamp( dot( normalize( ( 2. * C.xxy - h ) ), n ), 0., 1. ) * acl.rgb, 1. );\n\n            return;\n        }\n\n        F\n            ln = distance( lgt, h );\n        \n        r /= ln;\n        \n        V3\n            htmp = h,\n            ntmp = n;\n\n\t\tint\n            ilt = IDLIGHT;\n        \n        e = htmp;\n        \n        fstBrk = true;\n        \n        rayTrc( e, r, ln, h, n, ilt, fstBrk );\n\n        if( ilt != IDLIGHT ) {\n            \n            if( i == IDBALL || i == IDSPRING || i == IDPLANE )\n            \n            \tO += V4( .5 * clamp( dot( ( normalize( 2. * C.xxy - htmp ) ), ntmp ), 0., 1. ) * acl.rgb, 1. );\n            \n            return;\n        }\n        \n        O += V4( clamp( dot( ( lgt - htmp ) / ln, ntmp ), 0., 1. ) * dcl.rgb + .5 * clamp( dot( normalize( 2. * C.xxy - htmp ), ntmp ), 0., 1. ) * acl.rgb, 1. );\n    }\n\nvoid\n    paint( ) {\n        \n        if( lt( I, RSZ * Z ) )\n            \n            paintRam( );\n        \n        else\n            \n            paintWorld( );\n    }\n\nvoid\n    mainImage( out V4 o, V2 i ) {\n        \n        Ri = 1. / R;\n\n        A  = V2( R.x * Ri.y, 1 );\n\n    \tZ  = .0331 * R.y;\n            \n    \tZi = 1. / Z;\n\n    \tlgt = V3( 1.95 * cos( .4 * T ), +.5 + 1.45 * sin( .5 * T ), -2. + 1.95 * sin( .6 * T ) );\n\n\t\tdcl = V4( .5 + .2 * sin( .1 * T ), .6 + .2 * sin( .11 * T ), .7 + .2 * sin( .12 * T ), 1. );\n\n        acl = .25 * ( 1. + sin( .083 * T ) ) * V4( 1, .5, .25, .125 );\n\n        P = V3( ( 2. * ( N = Ri * ( I = i ) ) - 1. ) * A, 0. );\n\n        paint( );\n\n        o = O;\n\t}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define F\t\t\tfloat\n#define V2\t\t\tvec2\n#define V3    \t\tvec3\n#define V4    \t\tvec4\n#define R\t\t\tiResolution.xy\n#define Ri\t\t\t1. / R\n#define A         \tV2( R.x * Ri.y, 1 )\n#define T\t\t\tiTime\n#define PX( p )\t\ttexture( iChannel0, p )\n#define CHK\t\t\tif( any( greaterThan( I, vec2( max( SCNT, PCNT ), 9 ) ) ) ) discard;\n\n#define PCNT\t\t4.\n#define SCNT\t\t6.\n#define DT\t\t\t1e-0 / 60.\n#define _0\t\t\tV4( 0 )\n#define _1\t\t\tV4( 1 )\n#define DAMP\t\t5.5\n#define G\t\t\t-9.81 * 1.\n\n#define IDSKY       0\n#define IDPLANE     1\n#define IDBALL      2\n#define IDSPRING    3\n#define IDLIGHT     4\n\nV2\n    I,\n    N;\n\nV3\n    P;\n\nV4\n    O = _0;\n\nbool\n    eq( F a, F b ) {\n     \n        return floor( a + .1 ) == floor( b + .1 );\n    }\n\nvoid\n    poke( V2 p, V4 v ) {\n     \n        if( floor( p ) == floor( I ) ) \n            \n            O = v;\n    }\n\nvoid\n    poke( F x, F y, V4 v ) {\n        \n        poke( V2( x, y ), v );\n    }\n\nV4\n    peek( V2 p ) {\n        \n        return PX( Ri * ( .5 + p ) );\n    }\n\nV4\n    peek( F x, F y ) {\n        \n        return peek( floor( .1 + V2( x, y ) ) );\n    }\n\nbool\n    mouseClicked( ) {\n        \n        return 0. < iMouse.z;\n    }\n\nvoid\n    init( ) {\n        \n        CHK\n/*\n        //                 k    l   f  t \n        poke(  0., 0., V4( 1e2, 1., 0, 1 ) );\n        poke(  1., 0., V4( 1e2, 1., 1, 2 ) );\n        poke(  2., 0., V4( 1e2, 1., 2, 3 ) );\n        poke(  3., 0., V4( 1e2, 1., 3, 0 ) );\n        poke(  4., 0., V4( 1e2, 1., 4, 5 ) );\n        poke(  5., 0., V4( 1e2, 1., 5, 6 ) );\n        poke(  6., 0., V4( 1e2, 1., 6, 7 ) );\n        poke(  7., 0., V4( 1e2, 1., 7, 4 ) );\n        poke(  8., 0., V4( 1e2, 1., 0, 4 ) );\n        poke(  9., 0., V4( 1e2, 1., 1, 5 ) );\n        poke( 10., 0., V4( 1e2, 1., 2, 6 ) );\n        poke( 11., 0., V4( 1e2, 1., 3, 7 ) );\n\n        poke( 12., 0., V4( 1e2, .5, 0, 8 ) );\n        poke( 13., 0., V4( 1e2, .5, 1, 8 ) );\n        poke( 14., 0., V4( 1e2, .5, 2, 8 ) );\n        poke( 15., 0., V4( 1e2, .5, 3, 8 ) );\n        poke( 16., 0., V4( 1e2, .5, 4, 8 ) );\n        poke( 17., 0., V4( 1e2, .5, 5, 8 ) );\n        poke( 18., 0., V4( 1e2, .5, 6, 8 ) );\n        poke( 19., 0., V4( 1e2, .5, 7, 8 ) );\n        \n        //                 rx  ry   rz   m\n        poke( 0., 1., V4( -.5, -.5, -.5, 10. ) );\n        poke( 1., 1., V4(  .5, -.5, -.5, 10. ) );\n        poke( 2., 1., V4(  .5,  .5, -.5, 10. ) );\n        poke( 3., 1., V4( -.5,  .5, -.5, 10. ) );\n        poke( 4., 1., V4( -.5, -.5,  .5, 10. ) );\n        poke( 5., 1., V4(  .5, -.5,  .5, 10. ) );\n        poke( 6., 1., V4(  .5,  .5,  .5, 10. ) );\n        poke( 7., 1., V4( -.5,  .5,  .5, 10. ) );\n        poke( 8., 1., V4(  .0,  .0,  .0, .3 ) );\n        \n        //            v\n        poke( 0., 2., _0 );\n        poke( 1., 2., _0 );\n        poke( 2., 2., _0 );\n        poke( 3., 2., _0 );\n        poke( 4., 2., _0 );\n        poke( 5., 2., _0 );\n        poke( 6., 2., _0 );\n        poke( 7., 2., _0 );\n        poke( 8., 2., _0 );\n\n        //            a  0\n        poke( 0., 3., _0 );\n        poke( 1., 3., _0 );\n        poke( 2., 3., _0 );\n        poke( 3., 3., _0 );\n        poke( 4., 3., _0 );\n        poke( 5., 3., _0 );\n        poke( 6., 3., _0 );\n        poke( 7., 3., _0 );\n        poke( 8., 3., _0 );\n        \n\t\t//                i0  i1  i2  i3\n        poke( 0., 4., V4(  0,  3,  8, 12 ) );\n        poke( 1., 4., V4(  0,  1,  9, 13 ) );\n        poke( 2., 4., V4(  1,  2, 10, 14 ) );        \n        poke( 3., 4., V4(  2,  3, 11, 15 ) );        \n        poke( 4., 4., V4(  4,  7,  8, 16 ) );\n        poke( 5., 4., V4(  4,  5,  9, 17 ) );\n        poke( 6., 4., V4(  5,  6, 10, 18 ) );        \n        poke( 7., 4., V4(  6,  7, 11, 19 ) );        \n\t\tpoke( 8., 4., V4( 12, 13, 14, 15 ) );        \n        \n        poke( 0., 5., V4( -1 ) );\n        poke( 1., 5., V4( -1 ) );\n        poke( 2., 5., V4( -1 ) );        \n        poke( 3., 5., V4( -1 ) );        \n        poke( 4., 5., V4( -1 ) );\n        poke( 5., 5., V4( -1 ) );\n        poke( 6., 5., V4( -1 ) );        \n        poke( 7., 5., V4( -1 ) );        \n        poke( 8., 5., V4( 16, 17, 18, 19 ) );        \n\n*/            \n\t\t//                k      l   f  t \n        poke( 0., 0., V4( 1000., 1., 0, 1 ) );\n        poke( 1., 0., V4( 1000., 1., 1, 2 ) );\n        poke( 2., 0., V4( 1000., 1., 0, 2 ) );\n        poke( 3., 0., V4( 1000., 1., 0, 3 ) );\n        poke( 4., 0., V4( 1000., 1., 1, 3 ) );\n        poke( 5., 0., V4( 1000., 1., 2, 3 ) );\n        \n        //                rx   ry   rz    m\n        poke( 0., 1., V4( -.5, -.5, -.5,  10. ) );\n        poke( 1., 1., V4(  .5, -.5, -.5,  10. ) );\n        poke( 2., 1., V4(  .0, +.5, -1.,  10. ) );\n        poke( 3., 1., V4(  .0, +.5,  .0,  10. ) );\n        \n        //                  vx  vy  vz  0 \n        poke( 0., 2., _0 );\n        poke( 1., 2., _0 );\n        poke( 2., 2., _0 );\n        poke( 3., 2., _0 );\n\n        //                  ax  ay  az  0\n        poke( 0., 3., _0 );\n        poke( 1., 3., _0 );\n        poke( 2., 3., _0 );\n        poke( 3., 3., _0 );\n        \n\t\t//                i0 i1 i2 i3\n        poke( 0., 4., V4( 0, 2, 3, -1 ) );\n        poke( 1., 4., V4( 0, 1, 4, -1 ) );\n        poke( 2., 4., V4( 1, 2, 5, -1 ) );        \n        poke( 3., 4., V4( 3, 4, 5, -1 ) );        \n\n        poke( 0., 5., -_1 );\n        poke( 1., 5., -_1 );\n        poke( 2., 5., -_1 );  \n        poke( 3., 5., -_1 );\n}\n\nV4\n    acc( F x, F id ) {\n        \n        if( id < 0. ) \n            \n            return _0;\n        \n        V4\n            s  = peek( id, 0. );\n\n        F\n            f = eq( s.z, x ) ? s.z : s.a,\n            t = eq( s.z, x ) ? s.a : s.z;\n        V4\n            p1 = peek( f, 1. );\n        \n        if( p1.a < 0. )\n            \n            return _0;\n        \n        V4\n            p2 = peek( t, 1. ),\n            v  = peek( f, 2. );\n        \n        V3\n            r  = p2.xyz - p1.xyz;\n        \n        F\n            d = length( r );\n        \n        return V4( ( s.x * ( d - s.y ) / d * r - DAMP * p1.a * v.xyz ) / p1.a + V3( 0, G, 0 ), 0 );\n    }\n\n\nvoid\n    sim( ) {\n        \n        CHK\n            \n\t\tif( 1. <= I.y && I.y < 3. ) {\n            \n            F\n                p = -1.;\n            \n            V2\n                i = floor( I );\n\t\n            V4\n                r = peek( i );\n            \n            F\n                m   = peek( i.x, 1. ).a,\n                rad = ( .06 + .05 * sin( .023 * T ) ) * pow( m, 1. / 3. );\n            \n            if( 0. < m ) {\n                \n                V3\n                    v = peek( i.x, i.y + 1. ).xyz,\n                    vn = v * DT,\n                    rn = r.xyz + vn;\n                    \n                if( I.y < 2. ) {\n\n                    if( rn.y < -1. + rad ) {\n                    \n                        rn.y = -1. + rad;\n//                        rn.y = -2. - rn.y;\n                    }\n                }\n                else {\n                    \n                    V3\n                        rnn = peek( i.x, i.y - 1. ).xyz;\n                    \n                    if( rnn.y < -1. ) {\n                     \n                        rn.y = -rn.y;\n                    }\n                }\n                                        \n//                O = V4( clamp( rn, -1. * _1.xyz, 1. *_1.xyz ), m );\n                O = V4( rn, m );\n            }            \n            else\n            \n                O = r;\n            \n            return;            \n        }\n        \n        if( 3. <= I.y && I.y < 4. && I.x < PCNT ) {\n            \n            V2\n                i = floor( I );\n\n            V4\n                k = peek( i.x, 4. );\n\n            O = acc( I.x, k.r ) +\n            \tacc( I.x, k.g ) +\n            \tacc( I.x, k.b ) +\n            \tacc( I.x, k.a );\n            \n                k = peek( i.x, 5. );\n\n            O += acc( I.x, k.r ) +\n            \t acc( I.x, k.g ) +\n            \t acc( I.x, k.b ) +\n            \t acc( I.x, k.a );\n            \n            return;\n        }\n        \n        O = PX( N );\n    }\n\nvoid\n    hitBall( V3 e, V3 r, V3 p, F rad, inout F l, inout V3 h, inout int i, inout int m, int mm ) {\n\n        V3\n            d = e - p;\n\n        F\n            ab = dot( r, d ),\n            bb = dot( d, d ),\n            ds = ( rad * rad - bb ) + ab * ab;\n\n        if( 0. <= ds ) {\n\n            F\n                ln = ( -ab - sqrt( ds ) );\n\n            if( l < ln || ln < 0.)\n\n                return;\n\n            m = mm;\n            i = IDBALL;\n            l = ln;\n            h = e + l * r;\n        }\n    }\n\nvoid\n    hitBalls( V3 e, V3 r, inout F l, inout V3 h, inout int i, inout int m ) {\n        \n        int\n            pcnt = int( PCNT );\n        \n        V2\n            pc = V2( .5, 1.5 );\n        \n        for( int j = 0; j < 1000; ++j ) {\n            \n            if( pcnt <= j )\n                \n                break;\n            \n            V4\n                pt = PX( Ri * pc );\n            \n            hitBall( e, r, pt.xyz, ( .06 + .05 * sin( .023 * T ) ) * pow( pt.a, 1. / 3. ), l, h, i, m, j );\n            \n            ++pc.x;\n        }\n    }\n\nint\n    picked( inout V3 h ) {\n        \n\t\tint\n            i = IDSKY,\n            m = -1;\n        \n        V3\n            e = V3( 0, 0, 3 ),\n            r = normalize( V3( ( 2. * iMouse.xy * Ri - 1. ) * A, 0 ) - e );\n        \n        F\n            l = 1e5;\n        \n        V3\n            n;\n        \n        hitBalls( e, r, l, h, i, m );\n         \n        return m;\n    }\n\nvoid\n    set( ) {\n        \n        V3\n            h;\n        \n        int\n            i = picked( h );\n        \n        if( i < 0 ) {\n            \n            init( );\n         \n            return;\n        }\n        \n        V4\n            px = peek( F( i ), 1. );\n\n        poke( F( i ), 1., V4( h.x, h.y, px.z, px.a ) ); \n    }\n\nvoid\n    run( ) {\n        \n        if( iFrame < 1 )\n            \n            init( );\n            \n        else {\n            \n        \tsim( );\n            \n            if( mouseClicked( ) )\n             \n                set( );\n        }\n        \n    }\n\nvoid\n    mainImage( out V4 o, V2 i ) {\n        \n        P = V3( ( 2. * ( N = Ri * ( I = i ) ) - 1. ) * A, 0. );\n\n        run( );\n\n        o = O;        \n\t}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}