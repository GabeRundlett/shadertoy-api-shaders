{
    "Shader": {
        "info": {
            "date": "1587701215",
            "description": "Just killing time during lockdown. The \"music\" took longer than the rest.",
            "flags": 40,
            "hasliked": 0,
            "id": "tdsfR8",
            "likes": 11,
            "name": "Julia Walk",
            "published": 3,
            "tags": [
                "julia",
                "fractalmuz"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 471
        },
        "renderpass": [
            {
                "code": "//Years go I did a painter's walk around the brot but following the perpendicular\n//to the normal works ok if you also nudge toward the surface. \n//If I remember correctly this has already been done on Shadertoy... somewhere??\n//Anyway this was just an excuse to use some new fractal \"music\" code.\nconst float iters=64.0;\nfloat DE(vec2 z,vec2 c){\n  float m=0.0;\n  for(float n = 0.0; n < iters; n+=1.0) {\n   z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n   m=n;if(dot(z,z)>4.0)break;\n  }return (iters-m+1.33*log(log(dot(z,z))))/iters;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  U.y=iResolution.y-U.y;\n  vec2 uv=(2.0*U.xy-iResolution.xy)/iResolution.x;\n  vec2 c=texture(iChannel0,vec2(0.5,0.5)/iResolution.xy).xy;\n  float dp=1.0;vec2 rz=iResolution.xy*0.2;\n  if(U.x<rz.x && U.y<rz.y){\n    uv=(2.0*U.xy-rz)/rz.x;uv+=vec2(-0.5,sign(c.y)*0.5);\n    dp=smoothstep(0.0,15.0/rz.x,length(c-uv));c=uv;\n  }\n  float d=DE(uv,c);if(d!=d)d=0.0;//isnan\n  O=vec4(d,min(dp,d),d,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SPEED 0.001\nvec2 cossin(float a){return vec2(cos(a),sin(a));}\nfloat DE(vec2 p){\n  vec3 z=vec3(p,1.0),c=z;\n  float r=length(z.xy);\n  for(int n=0;n<16;n++){\n    float a=atan(z.y,z.x)*2.0;\n    z=r*vec3(cossin(a)*r,z.z*2.0)+c;\n    if((r=length(z.xy))>2.0)break;\n  }return 0.5*log(r)*r/z.z;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  if(U.x>1.0 || U.y>1.0)discard;\n  if(iFrame<5){O=vec4(-0.86,-0.28,0.0,0.0);return;}\n  O=texture(iChannel0,U.xy/iResolution.xy);\n  vec2 p=O.xy,v=vec2(SPEED,0.0);\n  vec2 N=normalize(vec2(DE(p+v)-DE(p-v),DE(p+v.yx)-DE(p-v.yx)));\n  p-=0.1*DE(p)*N-vec2(-N.y,N.x)*SPEED;\n  O=vec4(p,0.0,0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//am I the only one making shaders where the sound buffer is longer than the others combined?\n#define bps 4.0\nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);}\nvec2 nofs(float n){//the song's \"random\" ring\n  float r=0.5+0.5*rnd(floor(n));//random volume as well\n  n=mod(n,8.0);\n  if(n<1.0)n= 5.0;\n  else if(n<2.0)n= 3.0;\n  else if(n<3.0)n= -6.0;\n  else if(n<4.0)n= 6.0;\n  else if(n<5.0)n= 0.0;\n  else if(n<6.0)n= -4.0;\n  else if(n<7.0)n= -3.0;\n  else n=3.0;\n  return vec2(n,r);\n}\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.);\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major\n if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country\n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major\n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor\n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone\n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian  \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian\n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian\n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant\n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic\n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic\n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor\n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nconst float PI=3.14159;\nfloat Cos(float a){return cos(mod(a,PI*2.));}\nfloat Sin(float a){return Cos(a+PI/2.);}\nstruct instr{float att,fo,vibe,vphas,phas,dtun;};\nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument\n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.;\n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125);\n n+=t;return vec2(f*Sin(n),f*Cos(n));\n}\nvec2 mainSound( in int samp,float time){\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);//silly fm synth instruments\n instr sitar=instr(100.0,0.25,0.1,0.0,0.12525,0.0125);\n instr kettledrum=instr(50.0,0.5,4.0,0.75,1.0,0.0125);\n instr hihat=instr(100.0,1.0,100.5,0.0,1.3131,100.0);\n instr ebongo=instr(500.0,2.0,100.5,0.0,1.333,2.0);\n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005);\n float tim=time*bps,b0,b1,b2,t0,t1,t2;\n vec2 a=vec2(0);//accumulator\n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails\n   b0=floor(tim);b1=floor(tim*0.5);b2=floor(tim*0.25);\n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);//build notes on top of notes like fbm\n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0);\n   t0=fract(tim)+i;\n   a+=I(n0.x+72.0,time,t0,sitar)*n0.y*0.25;\n   if(mod(i,2.)<1.){//notes that play every 2 beats\n     t1=fract(tim*0.5)*2.0+i;\n     a+=I(n1.x+56.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+60.0,time,t1,epiano)*n1.y;\n     a+=I(n1.x+63.0,time,t1,ebongo)*n1.y;//needs more ebongo!\n     a+=I(n1.x+73.0,time+Sin(t1*272.0),t1,hihat)*n1.y*0.1;\n     if(mod(i,4.)<1.){//every 4\n       t2=fract(tim*0.25)*4.0+i;\n       a+=I(n2.x+56.0,time,t2,bass)*n2.y*4.0;\n       a+=I(n2.x+48.0,time,t2,kettledrum)*n2.y*4.0;\n     }\n   }\n   tim-=1.;//go back in time to find old notes still decaying\n }\n return clamp(a/24.0,-1.,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}