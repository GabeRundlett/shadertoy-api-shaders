{
    "Shader": {
        "info": {
            "date": "1495762963",
            "description": "going trough others code for inspiration...\n\nreduced version of \nhttps://www.shadertoy.com/view/lssGDH\ndiffuse texture only.\nsome simplifications (less divisions)",
            "flags": 0,
            "hasliked": 0,
            "id": "MslfWn",
            "likes": 9,
            "name": " Leaf reduced",
            "published": 3,
            "tags": [
                "leaf"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1008
        },
        "renderpass": [
            {
                "code": "const float\tSMALL_VEIN_DISTANCE_MIN =  .005;\nconst float\tSMALL_VEIN_DISTANCE_MAX = -.002;\nconst float\tBASE_LEAF_THICKNESS=.2;\nconst float\tSIDE_VEINS_THICKNESS=.5;\nconst float SIDE_VEINS_COUNT=12.;\n\nconst float PI=acos(-1.);//3.14159265358979;\n\n#define saturate(a) clamp(a,0.,1.)\n\nfloat h11(float n){return fract(sin(n)*43758.5453123);}\n/*\nfloat noise(in vec3 x){vec3 p=floor(x),f=fract(x);\n f=f*f*(3.-2.*f);\n float n=p.x+p.y*57.+113.*p.z;\n return mix(mix(mix(h11(n+  0.),h11(n+  1.),f.x),\n                mix(h11(n+ 57.),h11(n+ 58.),f.x),f.y),\n            mix(mix(h11(n+113.),h11(n+114.),f.x),\n                mix(h11(n+170.),h11(n+171.),f.x),f.y),f.z);}\n/*\nvec3 noised(in vec2 x){\n vec2 p=floor(x),f=fract(x),u=f*f*(3.-2.*f);\n float n=p.x+p.y*57.,a=h11(n+ 0.),b=h11(n+ 1.),c=h11(n+57.),d=h11(n+58.);\n return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n  30.*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));}\n*/\nfloat noise(in vec2 x){vec2 p=floor(x),f=fract(x);f=f*f*(3.0-2.0*f);\n float n=p.x+p.y*57.;\n return mix(mix(h11(n+ 0.),h11(n+ 1.),f.x),\n            mix(h11(n+57.),h11(n+58.),f.x),f.y);}\n/*\nfloat rmf(vec3 p){p+=PI;vec4 N;\n N.x=noise(p);p=p*2.02;N.y=noise(p);p=p*2.03;N.z=noise(p);p=p*2.01;N.w=noise(p);\n //N=abs(N-vec4(.5));\n float f=.5000*N.x;f+=.2500*N.y*N.x;f+=.1250*N.y*N.z;f+=.0625*N.z*N.w;return f;}//return f/.9375;}\n*/\n//float rmf2(vec3 p){return rmf(p)+.5*rmf(p*16.)+.25*rmf(p*256.);}\n/*\nfloat fbm(vec3 p){p+=PI;\n float f=.5*noise(p);p*=2.02;f+=.25*noise(p);p*=2.03;f+=.125*noise(p);p*=2.01;\n f+=.0625*noise(p);return f;}//return f/0.9375;}\n*/\nvec2 displace(vec2 p){p+=PI;\n vec2 f=.5000*noise(p)+vec2(0);p=p*2.02;\n f.x+=.25*noise(p);p*=2.03;f.x+=.125*noise(p);p*=2.01;f.x+=.0625*noise(p);\n p=p/8.+12358.3446;\n f.y+=.5*noise(p);p*=2.02;f.y+=.25*noise(p);p*=2.03;f.y+=.125*noise(p);p*=2.01;\n f.y+=.0625*noise(p);return f;}//return f/0.9375;}\n\n//return y of polynomial\n//#define tpoly t=r.x+t*(r.y-r.x)\n//float Poly3(vec4 a,vec2 r,float t){tpoly;return a.x+t*(a.y+t*(a.z+t*a.w));}\n//float Poly4(vec4 a,float b,vec2 r,float t){tpoly;return a.x+t*(a.y+t*(a.z+t*(a.w+t*b)));}\n\n//smoothstep() alternatives. [r]Ranges [v]values\nfloat SmoothSingleStep(vec2 r,vec2 v,float t){return mix(v.x,v.y,smoothstep(r.x,r.y,t));}\nfloat SmoothDoubleStep( vec3 r,vec3 v,float t){\n return step(t  ,r.y)*mix(v.x,v.y,smoothstep(r.x,r.y,t))\n       +step(r.y,t  )*mix(v.y,v.z,smoothstep(r.y,r.z,t));}\nfloat SmoothTripleStep(vec4 r,vec4 v,float t){\n vec3 s = vec3(step(t,r.y),step(r.y,t),step(r.z,t));\n return s.x*mix(v.x,v.y,smoothstep(r.x,r.y,t))\n       +s.y*(1.-s.z)*mix(v.y,v.z,smoothstep(r.y,r.z,t))\n       +s.z*mix(v.z,v.w,smoothstep(r.z,r.w,t));}\n\n//Return an equivalent of smoothstep( 0, 1, t )but reversed along the y=x diagonal\n// Not exactly the reciprocal of the s-curve since tangents are not infinite at the\n//\t0 & 1 boundaries but close enough! //[s]tangentstrength\nfloat ReverseSCurve(float t, float s ){\n//\tconst float TANGENT_STRENGTH = 4.0;\t// You can increase the slope at edges at the risk of losing the S shape\n s=1./s;\n float b=1.- s,x=saturate(1.-abs(1.-2.*t));// 0 at t=0, 1 at t=0.5, then back to 0 at t=1\n float curve=abs((s/(b*x+s)-s)/b );// Some sort of 1/x but making sure we have 1 at x=0 and 0 at x=1\n return .5*mix(1.-curve,1.+curve,t);// Mix the 2 mirrored curves\n}\n\nfloat ReverseSmoothstep(float a,float b,float t,const float _TangentStrength){\n return ReverseSCurve(saturate((t-a)/(b-a)),_TangentStrength);}\n\n// Gets the length of the leaf in the specified slanted direction knowing the current position\n// Also returns the source of the leaf direction emanating from the center vein along given direction\nfloat GetLeafLength(vec2 p,vec2 d,out vec2 c ){\n c=p-(p.x/d.x)*d;\t\n //Source of the leaf in the provided direction\n //The y value is in [0,1] and can help us determine the height within the leaf\n //So we can use it to know that it's broad at base and thinning at the tip...\n //But we can also use it to know the size of side veins depending on their position on the leaf, etc.\n float Length=SmoothTripleStep(vec4(-.15,.02,.1,1.),vec4(0,0.38,.41,0),c.y); \n Length*=1.+.03*sin(PI*SIDE_VEINS_COUNT*c.y)*SmoothDoubleStep(vec3(0,.2,1),vec3(.5,1,.5),c.y );\n return Length;}\n\nfloat Grid(vec2 p, float a ){//[a]=attenuation\n p=vec2(fract(50.*p.x),fract(50.*p.y));\n vec2 c=1.-p;p*=p;\n return exp(-a*p.x)+exp(-a*c.x*c.x)\n       +exp(-a*p.y)+exp(-a*c.y*c.y);}\n\n//u=position [d]distance\nvec2 SmallVeinsThickness(vec2 a,vec2 b,vec2 u,vec3 d){\n vec2 o=normalize(b-a);//orthogonal\n vec2 p=vec2(d.x,dot(u-a,o));\n float m=mix(.0,.1,2.*min(d.y,d.z)/(d.y+d.z));// Less displacement near the veins\n vec2 i=displace(30.*u );\n p+=m*(i-.4);//displace grid for organic look\n p-=.5*m*length(i)*vec2(o.y,-o.x);//displace along the vein direction\n float r=((Grid(p,100.)/3.+Grid(2.*p,50.)))*.5;\n //approximate distance to vein:\n return vec2(1.-.5*r,mix(SMALL_VEIN_DISTANCE_MIN,SMALL_VEIN_DISTANCE_MAX,r));}\n\nvec2 SideVeins( vec2 _Pos, vec2 _Direction, float _IsLeft ){\n //get distance to the 2 closest veins\n float SecondClosestVein=0.;\n vec2 SecondClosestVeinPos=vec2(0,-.2);\n float ClosestVein=1e4;\n float ClosestDistanceAlongVein = 1e4;\n float ClosestLeafRatio = 0.0;\n vec2 ClosestVeinPos = vec2(0.0);\n for(int ii=0;ii<int(SIDE_VEINS_COUNT)+1;ii++){\n  float\ti=float(ii);\n  //get base position and line direction\n  vec2 Direction=normalize( _Direction + vec2( 0.0, 0.05 * i ) );\n  vec2 VeinOrtho=vec2(-Direction.y, Direction.x );\n  vec2 VeinBase=vec2(0,-.18+1.02 * pow( (i + 0.5 * _IsLeft)/SIDE_VEINS_COUNT, 1.2 ) );\t// Source of the vein on the center vein. The pow is here just to pack a little more veins near the base\n  float DistanceAlongVein = 1.05 * dot( _Pos - VeinBase, Direction );\n  //get length of the leaf in that direction\n  vec2 CenterSource;\n  float LeafLength = GetLeafLength( _Pos, Direction, CenterSource );\n  float LeafRatio = DistanceAlongVein / LeafLength;\t// 0 at center, 1 at the edge\n  //curved offset that varies with position along the vein to avoid stoopid straight veins\n  float VeinOffset=.05*(ReverseSmoothstep(0.,1.,LeafRatio,4.)-.4);\n  vec2 VeinPos=VeinBase+Direction*DistanceAlongVein + VeinOffset * VeinOrtho;\n  // Fast measure of the distance to that vein\t\t\n  float Distance2Vein = abs(dot( _Pos - VeinPos, VeinOrtho ));\n  if(Distance2Vein<ClosestVein){\n   SecondClosestVein = ClosestVein;\n   SecondClosestVeinPos = ClosestVeinPos;\n   ClosestVein = Distance2Vein;\n   ClosestDistanceAlongVein = DistanceAlongVein;\n   ClosestVeinPos = VeinPos;\n   ClosestLeafRatio = LeafRatio;\n }}\n //get its size based on distance from the center\n float\tVeinSize = SmoothSingleStep( vec2( 0.0, 0.85 ), vec2( 0.008, 0.003 ), ClosestLeafRatio );\n VeinSize = max( 0.0, VeinSize - step( 1.1, ClosestLeafRatio ) );\n // Make it round\n float\tVeinThickness = 3.0 * sqrt( 1.0 - min( 1.0, ClosestVein*ClosestVein / (VeinSize*VeinSize) ) );\n // What I'm doing here is computing a vein thickness with slower decay\n //\tso I can subtract it with actual thickness to isolate the borders\n // This way I can increase leaf optical thickness near the veins...\n //\tfloat\tVeinThickness2 = 2.5 * exp( -0.9*ClosestVein*ClosestVein / (VeinSize*VeinSize) );\n //\tfloat\tOpticalThickness = 2.0 * (VeinThickness2 - VeinThickness);\t// Negative inside the vein, positive outside with a burst nead the vein\n //\n //\tOpticalThickness = mix( OPTTHICK_SIDE_VEINS,// * -OpticalThickness,\n //\t\t\t\t\t\t\tmix( OPTTHICK_LEAF_MIN, OPTTHICK_LEAF_MAX, OpticalThickness ),\n //\t\t\t\t\t\t    step( 0.0, OpticalThickness ) );\t\n // Compute signed distance to vein\n float SignedDist2Vein=ClosestVein - VeinSize;\n // Add small veins pattern in between (a displaced grid really)\n vec2 SmallVeinsInfos=SmallVeinsThickness( ClosestVeinPos, SecondClosestVeinPos, _Pos, vec3( ClosestDistanceAlongVein, ClosestVein, SecondClosestVein ) );\n //\tSignedDist2Vein = min( SignedDist2Vein, SmallVeinsInfos.y );\n return vec2( max( VeinThickness,SmallVeinsInfos.x),SignedDist2Vein);}\n\nvec2 LeafThickness(vec2 p){// Tweak pos so Y=0 is at the base and 1 at the tip\n p=vec2(.16,.16)*(p+vec2(0,2.5));// Actual world base is at (0,-3) and tip at (0,4)\n float IsLeft=step( p.x, 0.0 );\n p.x=abs(p.x);\n float VeinSize=.0004 * ReverseSmoothstep(1.,-.2,p.y,10.);// Central vein\n VeinSize=VeinSize*mix(1.,.1,saturate(1.5*p.y));\n VeinSize=p.y<-.2||p.y>0.97 ?0.:VeinSize;\n float CentralVein=sqrt(1.-min(1.,p.x*p.x/VeinSize));// Make it round\n float r=max(0.,CentralVein);\n float sd2v=p.x-sqrt(VeinSize);//Compute signed distance to vein\n // Add side veins\n vec2 Direction=normalize(vec2(1,mix(.2,.5,p.y)));\n vec2 CenterSource=vec2(0);\n float ass=GetLeafLength(p,Direction,CenterSource);//modifies CenterSource(), not too good style\n float sr=(dot(p-CenterSource,Direction))/ass;\n float lt=SmoothSingleStep(vec2(.9,1),vec2(1,0),sr);//Attenuate leaf with distance\n float svt=SmoothSingleStep(vec2(.9,1),vec2(1,0),sr);//Attenuate side veins with distance\n vec2 svi=SideVeins(p,Direction,IsLeft);\n sd2v=min(sd2v,svi.y);\n return vec2(max(r,BASE_LEAF_THICKNESS*(1.5*lt+svt*svi.x)),sd2v);}\n\n//[p].xy [n]PlaneNormal [l]VectorToTight [v]viewVector\nvec3 ComputeLighting(vec2 p,vec3 n,vec3 l){\n p=LeafThickness(p);//leaf thickness\n vec3 d=10.*vec3(1);//diffuse\n d*=saturate(-dot(l,n));//clamp\n float r;\n if(p.y>=.0)r=mix(20.,80.,exp(-20.0*p.y));\n else       r=mix(20.,30.,p.x*saturate(-p.y/.01));\n vec3 Transmittance=vec3(.3,.2,.8)*r/PI;\n Transmittance=exp(-Transmittance*p.x);\t\n return vec3(d*Transmittance);}//;step(1e-3,p.x));}\n\nvec3 ComputeLighting(vec2 p,vec3 n){return ComputeLighting(p,n,vec3(0,0,-1));}\nvec3 ComputeLighting(vec2 p){return ComputeLighting(p,vec3(0,0,1));}\n\n#define ddabcb(a,b,c) dot(a,b)/dot(c,b)\n\nvoid mainImage(out vec4 fragColor,in vec2 U){vec2 u=U.xy/iResolution.xy;\n u=vec2(u.y,u.x);//quater rotation\n u-=.5;//center\n u*=vec2(.65,.92);//scale\n vec3 Leaf=ComputeLighting((u*8.));\n Leaf=sqrt(Leaf*.1);\n fragColor=vec4(Leaf,1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}