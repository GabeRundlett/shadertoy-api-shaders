{
    "Shader": {
        "info": {
            "date": "1642724159",
            "description": "this is my gaming™ pc™ booting at 3am",
            "flags": 8,
            "hasliked": 0,
            "id": "NslyD2",
            "likes": 18,
            "name": "Disco cubes",
            "published": 3,
            "tags": [
                "music",
                "cubes",
                "badmusic",
                "lotsofcolors"
            ],
            "usePreview": 0,
            "username": "user_name",
            "viewed": 821
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\nfloat grow(vec3 p) {\n    float f = fract(iTime * (22.5 / 60.0) - (length(p) - 10.0) * 0.01);\n    f = smoothstep(0.0, 0.02, f) * smoothstep(0.1, 0.02, f);\n    float f2 = fract(iTime * 1.5);\n    f2 = smoothstep(0.5, 0.0, f2) * smoothstep(0.0, 0.1, f2);\n    f += f2 * 0.2;\n    return -f * 1.5;\n}\n\nfloat cube(vec3 p, vec3 s) {\n    return length(p - clamp(p, -s, s));\n}\n\nfloat square_(vec2 p) {\n    return length(p - clamp(p, vec2(-1.0), vec2(1.0)));\n}\n\nfloat square(vec2 p) {\n    return square_(p / 2.0) * 2.0;\n}\n\nfloat sphere(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat path(vec3 p) {\n    return -max((sphere(p / 9.0) * 9.0), -sphere(p / 6.0) * 6.0);\n}\n\nfloat rand(vec3 co) {\n    float mid = dot(co, vec3(12.9898, 78.233, 45.96483));\n    mid = mod(mid, 3.14);\n    return fract(sin(mid) * 43758.5453);\n}\n\nfloat noise(float t) {\n    return sin(t * 3.4) + sin(t * 1.2 + 0.5);\n}\n\nfloat onoise(float t) {\n    return noise(t) + noise(t * 2.0) * 0.5 + noise(t * 4.0) * 0.25 + noise(t * 8.0) * 0.125;\n}\n\nvoid r(inout vec2 v, float r) {\n    vec2 o = v;\n    float s = sin(r);\n    float c = cos(r);\n    v.x = o.x * s - o.y * c;\n    v.y = o.x * c + o.y * s;\n}\n\nfloat cubegrid(vec3 p) {\n    vec3 rep = floor((p + 2.0) / 4.0);\n    \n    vec3 s = rand(rep) * vec3(1.5, 1.5, 3.5);\n    vec3 o = vec3(rand(rep), rand(rep + vec3(1.0, 6.0, 0.0)), rand(rep + vec3(0.2, 0.9, 12.0)));\n    o = o * 2.0 - 1.0;\n    \n    return cube(p - rep * vec3(4.0) + o, s);\n}\n\nvec3 cam(float t) {\n    return vec3(onoise(t * 0.5), onoise(t * 0.5 + 10.0), onoise(t * 0.5 + 20.0)) * 40.0;\n}\nvec3 cam2(float t) {\n    return vec3(noise(t * 0.5 + 19.4), noise(t * 0.5 + 420.0), noise(t * 0.5 + 4343.0));\n}\n\nfloat grid2(vec3 p) {\n    float s = 10.0;\n    p = mod(p + s, s * 2.0) - s;\n\n    return min(square(p.xy), min(square(p.xz), square(p.yz)));\n}\n\nfloat d(vec3 p, vec3 c) {\n    vec3 ip = p;\n                \n    float r = min(cubegrid(p * 2.0), cubegrid((p * 2.0) + vec3(202.0, 2.0, 2.0)));\n    \n    float g2 = grid2(p);\n    r = max(g2 - 1.5, r);\n    //r = min(r, g2);\n    \n    r += grow(c);\n    \n    return max(r, -(sphere(c / 3.0) * 3.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= (iResolution.x / iResolution.y);\n\n    vec3 col = vec3(0.0);\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(vec3(-1.0, uv * 0.5));\n    \n    vec3 c = cam(iTime * 0.04);\n    pos = -c;\n    vec3 fwd = normalize(c - cam((iTime * 0.04) - 0.001));\n    vec3 right = normalize(cross(fwd, cam2(iTime * 0.02)));\n    vec3 up = cross(fwd, right);\n    dir = mat3(\n        fwd,\n        right,\n        up\n    ) * dir;\n\n\n    int i;\n    float i_f = 0.0;\n    \n    for (i = 0; i < 256; i++) {\n        float x = d(pos, pos + c) * 0.5;\n        if (x < 0.0001) {\n            i_f = 1.0 - clamp(x / 0.0001, 0.0, 1.0);\n            break;\n        }\n        if (x > 1000.0) {\n            i_f = (x - 1000.0) / 1000.0;\n            break;\n        }\n        pos += dir * x;\n    }\n        \n    float f2 = fract(iTime * 1.5 - length(pos + c) * 0.003);\n    f2 = smoothstep(0.5, 0.0, f2) * smoothstep(0.0, 0.1, f2);\n\ncol = 1.0 - pow(vec3((float(256 - i) + i_f) / 256.0), (normalize(pos) + 1.1) * 3.0);\n    col *= (1.0 + f2 * 2.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\n\nfloat rand(vec2 co) {\n    float mid = dot(co, vec2(12.9898, 78.233));\n    mid = mod(mid, 3.14);\n    return fract(sin(mid) * 43758.5453);\n}\n\nfloat kick(float t) {\n    return smoothstep(0.25, 0.0, t);\n}\n\nfloat cymbal(float t) {\n    return smoothstep(0.0, 0.005, t) * smoothstep(0.13, 0.02, t);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float bps = 90.0 / 60.0;\n    float nps = bps * 4.0;\n    \n    float b_id = floor(mod(time * nps, 19.0));\n    \n    float bfract = fract(time * bps * 0.25);\n    \n    float bartime = fract(time * bps);\n    float ktime = bartime;\n    float camp = cymbal(bartime - 0.5) * 0.6;\n    if (bfract > 0.75) {\n        camp += smoothstep(0.5, 1.0, bartime) * 0.3;\n    }\n    \n    if (bfract > 0.86) {\n        ktime = fract(ktime * 4.0) / 4.0;\n    }\n    \n    //camp += cymbal(fract(time * nps) * 2.0) * 0.2;\n    \n    float bfreq = floor(rand(vec2(b_id, 8.0)) * 6.0) * 3.0 + 140.0;\n    float bhold = rand(vec2(b_id, 0.0)) * 0.4 + 0.6;\n    float bslide = 0.0;\n    if (rand(vec2(b_id, 4.0)) > 0.2) {\n        bslide = (rand(vec2(b_id, 12.0)) * 2.0 - 1.0) * 10.0;\n    }\n    float ntime = fract(time * nps);\n    float bamp = smoothstep(bhold, 0.0, ntime) * smoothstep(0.0, 0.05, ntime);\n    bamp += 2.0 * smoothstep(0.04, 0.0, ntime);\n    float bass = tanh(sin(6.2831*(bfreq*time+bslide*ntime*ntime))*12.0) * sin(6.2831*100.0*time) * 0.1 * bamp;\n    float kick = sin(6.2831*(4.0*log(ktime*20.0 + 0.5)))*kick(ktime);\n    float cym = camp * rand(vec2(ktime * 200.0));\n    float hf = 600.0;\n    float hum = sin(time * 6.2831 * hf * 3.0) + sin(time * 6.2831 * hf * 4.0) * 0.6 + sin(time * 6.2831 * hf * 5.0) * 0.3 + sin(time * 6.2831 * hf * 6.0) * 0.15 + sin(time * 6.2831 * hf * 7.0) * 0.06;\n    hum *= smoothstep(0.02, 0.0, fract(time * bps * 0.5));\n    return vec2(clamp(bass+kick+cym + hum * 0.1, -1.0, 1.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}