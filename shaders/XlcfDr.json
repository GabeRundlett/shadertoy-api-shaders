{
    "Shader": {
        "info": {
            "date": "1539171640",
            "description": "learning FM synthesis, step 1, copy others.\nthis may be slighly inproved in structure, using the common tab.\ni know many dislike my barely spaced and left-endian semicolon style, but i have many reasons to do this.\ndid a lot of changes to the cis gradient",
            "flags": 8,
            "hasliked": 0,
            "id": "XlcfDr",
            "likes": 6,
            "name": "fm dft reverb synchronization",
            "published": 3,
            "tags": [
                "fm",
                "audiovisual",
                "reverb",
                "dft",
                "clapperboard"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "//\"audiovisual\" tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//,to use the same functions to render audio and video\n//all code is in commons tab\n\n\nvoid mainImage(out vec4 o,vec2 u){;o=image(u,iMouse,iResolution.xy,iTime);}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\"audiovisual\" tag means it uses moudular arithmetic (fourier analysis, roots of unity)\n//, or at least some sort of audio-visualization, if only a blinking lights show\n//,to use the same functions to render audio and video\n//all code is in commons tab\n\n\n//void mainImage(out vec4 o,vec2 u){o=image(u,iResolution.xy,iTime);}\n\nvec2 mainSound( in int samp,float t){return sound(t);}\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "//self:   https://www.shadertoy.com/view/XlcfDr\n//parent: https://www.shadertoy.com/view/MdjXWc\n\n\n#define doReverb true\n\n//end of UI modes, start of common code:\n\n#define pi acos(-1.)\n#define pi2(a) (2.*pi*(a))\n#define co2p(a) cos(pi2(a))\n\n#define vec1 float\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(a) clamp(a,0.,1.)\n\nstruct w11{vec1 a;vec1 b;};\nstruct w12{vec1 a;vec2 b;};\nstruct w13{vec1 a;vec3 b;};\nstruct w14{vec1 a;vec4 b;};\n\nvec3 mx(vec3 a,vec3 b,vec3 c){return mix(a,b,c);}\nvec3 mx(float a,vec3 b,vec3 c){return mix(vec3(a),b,c);}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n\n\n//MdjXWc is Created by Dmitry Andreev-and'2014\n//...License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Hash from https://www.shadertoy.com/view/4djSRW\nvec2 hash2(vec2 p\n){p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy+ vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));}\n\nvec2 noise(float t){return hash2(vec2(t, t * 1.423)) * 2.0-1.0;}\n\n\n//https://www.shadertoy.com/view/MdjXWc\nfloat remap(float l, float h, float x){return clamp((x-l) / (h-l), 0.0, 1.0);}\n\n\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1.),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//#define pdC(a,b,c,d,m,f)mix(a,b,m.w)*c*d*f+pdCx(a,b,c,d,m)\nvec3 pdC(vec3 a,vec3 b,float c,float d,vec4 m,float f){return mix(a,b,m.w)*f*c*d+b*m.z*(1.-c)+a*m.y*(1.-d);}//many contextual simplifications possible.\n#define pdA(c,d,m)suv(m*vec3(c*d,c*(1.-d),d*(1.-c)))\n//#define pdA(c,d,m)m.x*c*d+m.y*c*(1.-d)+m.z*d*(1.-c)\n//xor case is simpler,likely worth making it a subroutine of pdC;\n//#define pdCx(a,b,c,d,m)m.y*a*(1.-d)+m.z*b*(1.-c)\n//vec3 pdCx(vec3 a,vec3 b,float c,float d){return a*d+b*c;}\nvec4 pd(vec4 a,vec4 b,vec4 m,float f){\n vec4 r=vec4(pdC(a.rgb,b.rgb,a.w,b.w,m,f),1);//ceneral case color\n r.w=pdA(a.w,b.w,m.rgb);//general case alpha is sometimes neglible.\n return r;}\n//return a*a.w+b*b.w*(1.-a.w);//general case reduction shortcut\nvec4 sOver(vec4 a,vec4 b){return pd(a,b,vec4(1,1,1,0),1.);}\nvec4 sAtop(vec4 a,vec4 b){return pd(a,b,vec4(1,0,1,0),1.);}\nvec4 sIn (vec4 a,vec4 b){return pd(a,b,vec4(1,0,0,1),1.);}\nvec4 sXor(vec4 a,vec4 b){return pd(a,b,vec4(0,1,1,1),0.);}\nvec4 sOut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,0),0.);}\nvec4 sCut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,1),0.);}\n\n\n\n\n//https://www.shadertoy.com/view/MdjXWc\nvec2 lpnoise(float t, float fq//FM lp-noise for reverb\n){t*=fq\n ;float f=fract(t)\n ;vec2 r=floor(t-f+vec2(0,1))/fq\n ;f=smoothstep(0.,1.,f)//;f=step(f,0.)//harder and faster\n ;return mix(noise(r.x),noise(r.y),f);}\n\n                        \n//https://www.shadertoy.com/view/MdjXWc\nvec2 synthWave(float t\n){bool do_reverb = mod(t, 8.0) > 4.0\n ;float m = mod(t, 2.0)\n ;vec2 f=cs(t-m)\n ;float f0 =220.*cos(t-m)+880.//FM over time makes it easier to debug timing.\n ;f0+=cos(2.*t)*440.\n     // this cos()  illustrates the reverb in the dft(), as cos() breaks some symmetry ofer time.\n ;vec2 w = vec2(co2p(m * f0) * exp(-m * 2.5))\n #ifdef doReverb\n ;vec2 r=lpnoise(m, 100.)\n        +lpnoise(m, 550.)*.2\n        +lpnoise(m,1050.)*.1*exp(-t*5.)//3 octaves of overtones.\n ;float a=exp(-m*2.)//exponential falloff for reverb\n ;w+=(co2p(m*f0+r*.1)-co2p(m*f0))*a//differential of 2 offset samples. pigmentation-interferrence.\n #endif\n ;w*=1.-exp(-m*800.)//instrument falloff hull\n ;return w;}\n\nvec2 sound(float t//entry point for mainSound( in int samp,) and dft()\n){return synthWave(t)\n ;return vec2(co2p(440.*t)*exp(-3.0*t))// A 440 Hz wave that attenuates quickly overt time\n ;}\n//vec2 mainSound( in int samp,float t){return sound(t);}\n                 \nvec2 dft(vec2 u,float gt//Fourier Transform https://www.shadertoy.com/view/MdjXWc\n){float v=256.\n ;float n=min(v,256.)\n ;vec2 c=cs(pi2(floor(u.y*n*.5)/n))\n ;vec2 d=vec2(1,0)\n ;vec2 f=vec2(0)\n ;for(float i=0.;i<n;i++\n ){float x=float(i)/n  \n  ;float t=x*.05+gt\n  ;vec2  w=sound(t)//the dft() function calls the same sound() function that mainSound( in int samp,) calls.\n  ;float v=(w.x+w.y)*.5\n  ;v*=.5*(1.-co2p(x))   // Hann window-function\n  ;f+=d*v\n  ;d=d.xy*c.x+vec2(-1,1)*d.yx*c.y;\n ;}return f;}\n\nvec4 image(vec2 u,vec4 m,vec2 r,float t//uv,resolution,time\n){if(m.xy==vec2(0))m=vec4(r.xyxy*.5)\n ;u   /=r.xy\n ;m.xy/=r.xy\n ;float gt = t+(u.x-.5-m.x)/m.y//(u.x-1.0) * 5.0+mod(t, 8.0)\n ;vec2 f=dft(u,gt)//dft wrapper over mainsound()\n ;f.x=.5*length(f)\n ;f.x/=1.+f.x\n ;float v=u.x-m.x\n ;v=abs(v)\n ;//v=(2.-v)*2.-2.\n ;f.x=sqrt(f.x)\n ;//y=sat(y)//seems not too important\n ;vec3 c=rainbow2(f.x,v)*f.x/(v+.075)\n ;//vec3 c=rainbow2((m.x/f.x))*f.x/m.x//interestring reciprocals\n ;//vec3 c=rainbow2((u.x-.5),f.x)//rather silly gratient parameter swap\n ;//vec3 c=rainbow2(-u5(f.x))*v\n ;return vec4(c,1);}\n//void mainImage(out vec4 o,vec2 u){o=image(u,iResolution.xy,iTime);}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}