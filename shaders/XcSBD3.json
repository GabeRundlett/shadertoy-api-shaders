{
    "Shader": {
        "info": {
            "date": "1725553514",
            "description": "webcam_spirales",
            "flags": 2,
            "hasliked": 0,
            "id": "XcSBD3",
            "likes": 0,
            "name": "webcam_spirales",
            "published": 3,
            "tags": [
                "random"
            ],
            "usePreview": 0,
            "username": "mkundera",
            "viewed": 85
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p){\n    return length(cross(p-ro,rd))/length(rd); \n    //using the fact that the area of a parallelogram is given by the norm of the cross product\n    // of the vectors defining its consequent sides, and that it is also given by the base\n    // times the height, we can isolate the distance to the \n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p){\n    float d = DistLine(ro, rd, p);\n    d = smoothstep(0.3,0.29, d);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float dx = fragCoord.x/iResolution.x;\n    float dy = fragCoord.y/iResolution.y;\n    \n    \n    // Add a webcam\n        vec4 webcam = texture(iChannel0, uv);\n        \n        \n    uv -= .5; // centered coordinates\n    uv.x *= iResolution.x/iResolution.y; // keep aspect ratio\n    \n    vec3 ro = vec3(0., 0., -2.); // ray origin (distance from camera to center of screen)\n    vec3 rd = vec3(uv.x , uv.y, 0.) - ro; //ray intersection with the screen\n    \n    \n    \n    \n    \n    float d = 0.;\n    float ta = t;\n    float tb = t;\n    float tc = t;\n    float imax = 15.;\n    vec3 spiral = vec3(0.);\n    for(float i=0.; i < imax; i++){\n    \n        ta = t+ i/(imax) * PI*2.;\n        \n        tb = t + i/(imax) * PI*4.;\n       \n        tc = t + i/(imax) *PI*8.0;\n        \n        float z = -3. + mod (tc, PI*8.0);\n    \n        spiral = vec3( sin(1.*ta),0.1*sin(4.*tb), z);\n    \n        if(spiral.z > -0.){\n            d += DrawPoint(ro, rd, spiral);\n        }\n        \n    }\n    \n    //d = 0.;\n    float a = 0.;\n    for(float i=0.; i < imax; i++){\n    \n        ta = t+ i/imax * PI*2.0;\n        tb = t + i/imax *PI*5.0;\n    \n    \n        spiral = vec3(sin(1.0*ta), cos(1.0*ta), 4.0 * PI + 2.0*PI*sin(tb));\n        spiral = vec3(0.0, cos(1.2*ta),  4.0 * PI + 4.0*PI*sin(tb));\n        \n        spiral = vec3(-cos(ta), 0., mod(tb, PI*5.0 ));\n    \n        a += DrawPoint(ro, rd, spiral);\n        \n    }\n    a = 0.;\n    //d = 0.;\n    \n\n    // Add a webcam\n\n    // Output to screen\n    fragColor = webcam + 2.*webcam*vec4(d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}