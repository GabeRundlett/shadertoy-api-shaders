{
    "Shader": {
        "info": {
            "date": "1578654290",
            "description": "Implementation of a Solid Random Phase Noise on a simplex grid.\nMouse.x -> Frequency\nComing next : Filtering ! (Soon)\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "tlGGWz",
            "likes": 2,
            "name": "Simplex Solid LRPN",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "texture",
                "lrpn",
                "solidnoise"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 389
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= Solid Local Random Phase Noise - Simplex\n//=======================================================\n//== Computing a RandomPhaseNoise on a simplex grid\n//== Need some cleaning... (artefacts, ...)\n//=======================================================\n//== Some great ressources for simplex noise :\n//== *- Stefan Gustavson's \"Simplex noise demystified\"\n//==    http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n//== \n//== I also used some code from :\n//== *- @nikat's commented implementation on Shadertoy \t<---  \n//=   \thttps://www.shadertoy.com/view/XsX3zB\t\t\t<--- \t\n//== *- @candicat's implementation on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sc3z2\n//==\n//== Raymarching Code uses IQ's SDF ( Sphere & Box ) + Subtract Operator\n//== https://iquilezles.org/articles/distfunctions\n//==\n//== Used also some code provided by Lagae et al. [2011]\n//== \"Filtering Solid Gabor Noise\"\n//== http://graphics.cs.kuleuven.be/publications/LD11FSGN/\n//==\n//== Feel free to use it ...\n//==\n//=======================================================\n//== Author : Arthur Cavalier\n//=======================================================\n\n\n\n//-----------------------------------------------------------------------------\n//-- User Parameters ----------------------------------------------------------\nconst uint  LRPN_GLOBAL_SEED \t= 0u;\nconst int   LRPN_COSINES \t\t= 5;\nconst float LRPN_SCALE_FREQ \t= 10.;\nconst float LRPN_SCALE_SPACE \t= 5.;\nconst float LRPN_MAGNITUDE \t\t= 1.;\n#define MOUSE_CONTROL\n//#define PHASE_SHIFT \n\n\n//-----------------------------------------------------------------------------\n//-- Simplex Solid LRPN Code --------------------------------------------------\nfloat gaussian_window_3D(in vec3 st, in float c, in float s)\n{\n    mat3 sig = mat3(s);\n    float body = -0.5*dot(st,inverse(sig)*st);\n    return c*exp(body);\n}\n\nfloat local_random_phase_noise(\n    \tin ivec3 vertex_index,\n    \tin vec3  noise_coords,\n    \tin int   nof_cosines,\n    \tin vec2  range_frequency,\n        in vec2  range_orientation,\n    \tin float window_magni,\n    \tin float window_width\n\t)\n{\n    uint seed    = cell_seed(vertex_index,LRPN_GLOBAL_SEED);\n    uint prng    = wang_hash(seed);\n\n    float sc = 0.; \n    for(int k=0; k<nof_cosines; k++)\n    {\n        float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y); \t // pick a frequency \n        float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y); // pick an orientation\n        float ph = myrand_uniform_0_1(prng)*m_2_pi; // pick a phase (shift)\n\t\n\t#ifdef PHASE_SHIFT\n        ph = iTime;\n\t#endif\n     \n        float omega_r = fr;\n        float omega_t = or;\n        float omega_p = acos(myrand_uniform_0_1(prng)*2.-1.);\n        vec3 F = omega_r * vec3(cos(omega_t) * sin(omega_p), sin(omega_t) * sin(omega_p), cos(omega_p));\n        \n        sc +=  cos(m_2_pi* dot(F, noise_coords) + ph);\n    }\n    return gaussian_window_3D(noise_coords,window_magni,window_width) * sc / float(nof_cosines);\n}\n\nfloat simplex_solid_random_phase_noise(\n    \tin vec3  P, // Evaluation Point\n    \tin int   C, // Number of Cosines\n    \tin vec2  F, // Frequency Range (freq_min ; freq_max) \n    \tin vec2  O, // Orientation Range (theta_min ; theta_max)\n    \tin float K  // Gaussian Window Magnitude\n\t)\n{\n    const float F3 = 0.333333333; /* -> 1/3 */\n    const float G3 = 0.166666667; /* -> 1/6 : distance edge-to-edge of the simplex grid */\n    const float WW = 0.055555556; /* -> 1/6 * 1/3 : find the width of the gaussian window (3*\\sigma ~ 0) */\n    \n    vec3 i = floor(P + (P.x + P.y + P.z) * F3);\n    vec3 d0 = P - (i - (i.x + i.y + i.z) * G3);\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1. * G3);\n    vec3 d2 = d0 - (i2 - 2. * G3);\n    vec3 d3 = d0 - (1. - 3. * G3);   \n    \n   \tfloat n0 = local_random_phase_noise(ivec3(i + 0.), d0, C, F, O, K, WW);\n    float n1 = local_random_phase_noise(ivec3(i + i1), d1, C, F, O, K, WW);\n    float n2 = local_random_phase_noise(ivec3(i + i2), d2, C, F, O, K, WW);\n    float n3 = local_random_phase_noise(ivec3(i + 1.), d3, C, F, O, K, WW);\n    return(n0+n1+n2+n3);\n}\n\n\n\n//-----------------------------------------------------------------------------\n//-- Raymarching Code ---------------------------------------------------------\nvec3  world_get_background(in vec3 rd)       { return vec3(0.); }\n\nfloat world_get_sdf(vec3 P)\n{        \n    float Sph = sdSphere(P,1.);\n \tfloat Box = sdBox( P-vec3(0.,1.,0.) , vec3(2.,0.5+0.5*cos(0.5*iTime),2.));    \n    \n    float SDF = opSub(Box,Sph);\n\treturn(SDF);\n}\n\nfloat world_raymarch(in vec3 ro, in vec3 rd, in float tmax)\n{\n    float step_count  = WORLD_STEPS;\n    float depth_max   = tmax;\n    float t = 0.01;\n    float R = -1.;\n\n    for(float istep=0.; istep<step_count && t<depth_max; istep+=1.)\n    {\n        float D = world_get_sdf(ro + t * rd);\n        if( D < EPSILON )\n        {\n            R = t;\n            break;\n        }\n        t += D;\n    }\n    return R;\n}\n\nvec3 world_get_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*world_get_sdf( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*world_get_sdf( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*world_get_sdf( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*world_get_sdf( pos + e.xxx ) );  \n}\n\n\nvec3 raymarcher(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n\n    float hit_dis = world_raymarch(ro, rd, 10.);\n    \n    if(hit_dis<0.) \n    {\n    \treturn world_get_background(rd);\n    }\n\n    \n    int   C = LRPN_COSINES;\n    vec2  F = vec2(0.3,1.)*LRPN_SCALE_FREQ; \n    vec2  O = vec2(0.,1.)*m_pi;\n    float K = LRPN_MAGNITUDE;   \n    \n#ifdef MOUSE_CONTROL\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    F = vec2(0.3, max(0.1,mouse.x) )*LRPN_SCALE_FREQ;     \n#endif\n    \n    \n    vec3  hit_pos = ro+rd*hit_dis;\n    vec3 coords = hit_pos * LRPN_SCALE_SPACE;\n    float noise = simplex_solid_random_phase_noise(coords,C,F,O,K);\n    return vec3( 0.5+0.5*noise );\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Main Render Function -----------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color              = world_get_background(rd);\n    vec2 scene_bouding_box  = intersection_axis_aligned_box(ro, rd, WORLD_BOUNDING_BOX);\n    if(! (scene_bouding_box.x > scene_bouding_box.y || scene_bouding_box.y < 0.0)) \n    {\n        vec3    B = ro + max(scene_bouding_box.x,0.) * rd;\n        vec3    E = ro + scene_bouding_box.y * rd;\n        vec3    V = rd;\n        color = raymarcher(B,V);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 screen_coords = ( 2.*(gl_FragCoord.xy) - iResolution.xy ) / iResolution.y;\n    \n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera\n    vec3 camera_origin = vec3( 2.*cos(0.2*iTime) , 2.0 , 2.*sin(0.2*iTime) );\n    vec3 camera_target = vec3(0.);\n    vec3 ray_direction = compute_camera_ray_direction(screen_coords, camera_origin, camera_target, 0.);\n\n    fragColor = vec4( render(camera_origin,ray_direction), 1.);   \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- Scene Constants ----------------------------------------------------------\nconst float EPSILON             = 1e-04;\nconst float WORLD_STEPS       \t= 64.;\nconst vec3  WORLD_BOUNDING_BOX  = vec3(3.);\n\nconst float m_pi = 3.14159265;\nconst float m_2_pi = 2.*m_pi;\n\n//-----------------------------------------------------------------------------\n//-- Scene Intersection Function ----------------------------------------------\nvec2 intersection_axis_aligned_box(in vec3 ray_origin, in vec3 ray_direction, in vec3 box_parameters) \n{\n    vec3 m  = 1.0/ray_direction;\n    vec3 n  = m*ray_origin;\n    vec3 k  = abs(m)*box_parameters;\n    vec3 t1 = -n-k;\n    vec3 t2 = -n+k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2(tN,tF);\n}\n\n\n//----------------------------------------------------------------------------------\n// IQ SDF functions ----------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//----------------------------------------------------------------------------------\n// SDF Operators -------------------------------------------------------------------\nfloat opUnn( float d1, float d2 ) { return min( d1, d2); }\nfloat opSub( float d1, float d2 ) { return max(-d1, d2); }\nfloat opInt( float d1, float d2 ) { return max( d1, d2); }\n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n\n\n//----------------------------------------------------------------------------------\n// PRNG ----------------------------------------------------------------------------\n\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Galerne et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                      {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)         {const uint period=1024u; uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  cell_seed(const in ivec3 c, const in uint offset)         {const uint period=1024u; uint s=(((((uint(c.z)%period)*period)+(uint(c.y)%period))*period)+(uint(c.x)%period))+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                      {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                          {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma){return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}