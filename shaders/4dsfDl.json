{
    "Shader": {
        "info": {
            "date": "1499010489",
            "description": "Producing round-looking Voronoi borders via some mild alterations to the regular formula. On a side note, this is a 2D effect - produced mostly with overlays.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dsfDl",
            "likes": 58,
            "name": "Round Voronoi Borders",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "round",
                "smooth",
                "border",
                "faux3d"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2236
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRound Voronoi Borders\n\t----------------------\n\n    Producing rounded, evenly distributed Voronoi borders via rudimentary alterations to \n\tthe regular Voronoi formula. As an aside, the results are presented in a faux 3D style. \n\tEssentially, it's a 2D effect.\n\n\tDr2 has been putting up some rounded Voronoi border examples lately, and Abje produced\n\ta really cool one using a very simple tweak.\n\n\tDr2's variation is fast and nicely distributed,\tand as such, translates well to a \n\traymarching environment. Abje's tweak can be combined with either IQ or Tomk's line\n\tdistance Voronoi examples to produce really good quality rounded borders - I intend to \n\tproduce an example later that I hope does it justice.\n\n\tThis example utilizes yet another variation that I put together ages ago. I've outlined \n\tthe method in the Voronoi function - not that it needs much explaining. It does the job \n\tunder then right circumstances and it's reasonably cheap and simple to implement. However, \n\tfor robustness, I'd suggest using one of the aforementioned methods.\n\n\tBy the way, all variations basically do the same thing, and rely on the idea of\n\tincorporating a smooth distance metric into a Voronoi-like formula, which IQ wrote about \n\tin his article on smooth Voronoi.\n\n\tI should also mention that Fabrice Neyret incorporated a third order distance to produce \n\ta rounded border effect, which I used for an example a while back.\n\n\tAnyway, just for fun, I like to make 3D looking effects using nothing more than 2D layers. \n\tIn this case, I went for a vector layered kind of aesthetic. For all intents and purposes, \n    this example is just a few layers strategically laced together. It's all trickery, so \n\tthere's very little physics involved.\n\n\tBasically, I've taken a Voronoi sample, then smoothstepped it in various ways to produce \n\tthe web-like look. I've also taken two extra nearby samples in opposite directions, \n\tthen combined the differences to produce opposing gradients to give highlights, the red \n\tand blue environmental reflections, etc. There's an offset layer for fake shadowing,\n\tthe function value is used for fake occusion... It's all fake, and pretty simple too. :)\n\n\n    // Other examples:\n\n    // Faster method, and more evenly distributed.\n    Smoothed Voronoi Tunnel - Dr2\n\thttps://www.shadertoy.com/view/4slfWl\n\n\t// I like this method, and would like to cover it at some stage.\n\tRound Voronoi - abje\n\thttps://www.shadertoy.com/view/ldXBDs\n\n\t// Smooth Voronoi distance metrics. Not about round borders in particular, but it's\n\t// the idea from which everything is derived.\n\tVoronoise - Article, by IQ\n\thttps://iquilezles.org/articles/voronoise\n\n    // A 3rd order nodal approach - I used it in one of my examples a while back. \n\t2D trabeculum - FabriceNeyret2\n\thttps://www.shadertoy.com/view/4dKSDV\n\n\n*/\n\n// Define for a some hacky random cell coloring.\n//#define RAND_CELL_COLOR\n\n#ifdef RAND_CELL_COLOR\nvec2 id; // Global unique cell identifier.\nfloat hash(float x) { return fract(sin(x)*43758.5453); } // IQ's float to float hash.\n#endif\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".333,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime)*.333 + .333; \n    //return sin( p*6.2831853 + iTime*2.)*(cos( p*6.2831853 + iTime*.5)*.3 + .5)*.45 + .5; \n    \n}\n\n// IQ's smooth minimum function.\nfloat smin(float a, float b, float k){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\n// This is exactly like a regular Voronoi function, with the exception of the smooth\n// distance metrics.\nfloat Voronoi(in vec2 p){\n    \n    // Partitioning the grid into unit squares and determining the fractional position.\n\tvec2 g = floor(p), o; p -= g;\n\t\n    // \"d.x\" and \"d.y\" represent the closest and second closest distances\n    // respectively, and \"d.z\" holds the distance comparison value.\n\tvec3 d = vec3(8); // 8., 2, 1.4, etc. \n    \n     \n    \n    // A 4x4 grid sample is required for the smooth minimum version.\n\tfor(int j = -1; j <= 2; j++){\n\t\tfor(int i = -1; i <= 2; i++){\n            \n\t\t\to = vec2(i, j); // Grid reference.\n             // Note the offset distance restriction in the hash function.\n            o += hash22(g + o) - p; // Current position to offset point vector.\n            \n            // Distance metric. Unfortunately, the Euclidean distance needs\n            // to be used for clean equidistant-looking cell border lines.\n            // Having said that, there might be a way around it, but this isn't\n            // a GPU intensive example, so I'm sure it'll be fine.\n\t\t\td.z = length(o); \n            \n            // Hacked in random ID. There'd be smarter ways to do this.\n            #ifdef RAND_CELL_COLOR\n            if(d.z<d.x) id = g + vec2(i, j);\n            #endif\n            \n            // Up until this point, it's been a regular Voronoi example. The only\n            // difference here is the the mild smooth minimum's to round things\n            // off a bit. Replace with regular mimimum functions and it goes back\n            // to a regular second order Voronoi example.\n            d.y = max(d.x, smin(d.y, d.z, .4)); // Second closest point with smoothing factor.\n            \n            d.x = smin(d.x, d.z, .2); // Closest point with smoothing factor.\n            \n            // Based on IQ's suggestion - A commutative exponential-based smooth minimum.\n            // This algorithm is just an approximation, so it doesn't make much of a difference,\n            // but it's here anyway.\n            //d.y = max(d.x, sminExp(d.y, d.z, 10.)); // Second closest point with smoothing factor.\n            //d.x = sminExp(d.x, d.z, 20.); // Closest point with smoothing factor.\n\n                       \n\t\t}\n\t}    \n\t\n    // Return the regular second closest minus closest (F2 - F1) distance.\n    return d.y - d.x;\n    \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/ iResolution.y;\n    //\n    // Mild, simplistic fisheye effect.\n    uv *= (.9 + length(uv)*.2);\n    //\n    // Scrolling action.\n    uv -= iTime*vec2(1, .25)/8.;\n    \n    \n    // The function samples: Six 4x4 grid Voronoi function calls. That amount of work would\n    // break an old computer, but it's nothing for any reasonably modern GPU.\n    //\n    // Base function value.\n    float c = Voronoi(uv*5.);\n    #ifdef RAND_CELL_COLOR\n    vec2 svID = id; // Save the global cell ID.\n    #endif\n    // Nearby samples to the bottom right and bottom left.\n    float c2 = Voronoi(uv*5. - .002); \n    float c3 = Voronoi(uv*5. + .002);\n    // A more distant sample - used to fake a shadow and highlight.\n    float c4 = Voronoi(uv*5. + vec2(.7, 1)*.2);\n    // Slight warped finer detailed (higher frequency) samples.\n    float c15 = Voronoi(uv*15. + c);\n    float c45 = Voronoi(uv*45. + c*2.);\n\n  \n    // Shading the Voronoi pattern.\n    //\n    // Base shading and a mild spotty pattern.\n    vec3 col = vec3(c*c)*(.9 + (c15 - smoothstep(.2, .3, c15))*.2);\n    //\n    // Mixing in some finer cloudy detail.\n    float sv = c15*.66 + (1. - c45)*.34; // Finer overlay pattern.\n    col = col*.8 + sv*sqrt(sv)*.4; // Mix in a little of the overlay.\n    \n    \n    // Simple pixelated grid overlay for a mild pixelated effect.\n    vec2 sl = mod(fragCoord, 2.);\n    //\n    // It looks more complicated than it is. Mildly darken every second vertical \n    // and horizontal pixel, and mildly lighten the others.\n    col *= 4.*(1. + step(1., sl.x))*(1. + step(1., sl.y))/9.;\n    \n    \n    #ifdef RAND_CELL_COLOR\n    // Random cell coloring.\n    if(hash(svID.x*113. + svID.y)>.5) col *= vec3(1.4, .85, 1.25);\n    #endif\n    \n    \n    // Adding a red highlight to the bottom left and a blue highlight to the top right. The \n    // end result is raised bubbles with environmental reflections. All fake, of course...  \n    // Having said that, there is a little directional derivative science behind it.\n    float b1 = max((c2 - c)/.002, 0.); // Gradient (or bump) factor 1.\n    float b2 = max((c3 - c)/.002, 0.); // Gradient (or bump) factor 2.\n    //\n    // A touch of deep red and blue, with a bit of extra specularity.\n    col += vec3(1, .0, .0)*b2*b2*b2*.15 + vec3(0, .0, 1)*b1*b1*b1*.15; \n    //\n    // Slightly more mild orange and torquoise with less specularity.\n    col += vec3(1, .7, .4)*b2*b2*.3 + vec3(.4, .6, 1)*b1*b1*.3; \n    \n    \n\n     \n     \n    // Distant sampled overlay for a shadowy highlight effect. Made up. There'd be better ways.\n    float bord2 = smoothstep(0., fwidth(c4)*3., c4 - .1);\n    col = max(col + (1.-bord2)*.25, 0.);\n    \n    // The web-like overlay. Tweaked to look a certain way.\n    float bord3 = smoothstep(0., fwidth(c)*3., c - .1) - smoothstep(0., fwidth(c)*2., c - .08);\n    col *= 1. + bord3*1.5;\n     \n    // Another darker patch overlay to give a shadowy reflected look. Also made up. \n    float sh = max(c4 - c, 0.);\n\tcol *= (1. - smoothstep(0.015, .05, sh)*.4);\n   \n    // For some reason, I wanted a bit more shadow down here... I'm sure I had my reasons. :) \n    col -= (1.-bord2)*.1;\n    \n    \n \n    // Smoothstepping the original function value, then multiplying for oldschool, fake occlusion. \n    col *= smoothstep(0., .15, c)*.85 + .15;\n \n    // Postprocessing. Mixing in bit of ramped up color value to bring the color out more.\n    col = mix(col, pow(max(col, 0.), vec3(4)), .333);\n    \n\n    // Rought gamma correction and screen presentation.\n\tfragColor = vec4(sqrt(col), 1);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}