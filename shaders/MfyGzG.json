{
    "Shader": {
        "info": {
            "date": "1712899318",
            "description": "a color rendition of dok's black and white shader",
            "flags": 0,
            "hasliked": 0,
            "id": "MfyGzG",
            "likes": 2,
            "name": "Color versionRevision 2024 - dok",
            "published": 3,
            "tags": [
                "psychedelic"
            ],
            "usePreview": 0,
            "username": "maxwellcoffee",
            "viewed": 118
        },
        "renderpass": [
            {
                "code": "// Based on dok's shader coded during the revision 2024 shader showdown\n// modified during the jam to add more transitions and I tried to fix\n// normals on the main saw wave shape (replacing asin(sin(x)) with a\n// proper function... sorry for the messy indentation\n#define fGlobalTime iTime\n#define v2Resolution iResolution\n#define texFFTSmoothed iChannel0\n#define texRevisionBW iChannel1\nconst float pi = acos(-1.);\n#define r2(a) mat2(cos(a),-sin(a),sin(a), cos(a))\nvec4 s,t;\nfloat sd_b(vec3 p, vec3 e) {\n  p = abs(p) -e ;\n  return length(max(p,0.)) + min(max(max(p.x,p.y),p.z),0.);\n}\n#define time fGlobalTime\nfloat tri(float a) {\n\ta/=4.;return min(fract(a),fract(-a))*4.-1.;\n}\nfloat map(vec3 p) {\n  float d;\n  {\n    vec3 q = p;\n    float m = mix(.2,2.,t.w);\n    q.xy *= r2(0.5*q.z*sin(time*0.1));\n    q.xy = abs(q.xy);\n    q.xy -= 1.5;\n    q.x += tri(0.5*q.z+time)*m;\n    q.y += tri(0.5*q.z+time+.5)*m;\n//    q.x += asin(sin(q.z+time)) * .5;\n//    q.y += asin(cos(q.z+time)) * .5;\n    d = sd_b(q, vec3(0.2,0.2,111))-.1;\n  }\n  {\n    vec3 q = p;\n\tq.z+=pow(t.x,5.);\n    float id = round(q.z);\n    q.z -= id;\n    q.xz *= r2(time+id);\n    d = min(d, sd_b(q, vec3(0.1))-0.1);\n  }\n  return d;\n}\nvec3 nor(vec3 p) {\n  vec3 e = vec3(5e-3,0,0);\n  return normalize(vec3(\n  map(p+e.xyy)-map(p-e.xyy),\n  map(p+e.yxy)-map(p-e.yxy),\n  map(p+e.yyx)-map(p-e.yyx)\n  ));\n}\n\nvoid mainImage(out vec4 out_color, in vec2 in_FragCoord)\n{\n    s = fGlobalTime*(120./60.)/vec4(1,4,8,16);\n    t = fract(s);\n    vec2 uv = (in_FragCoord.xy  - .5 * v2Resolution.xy ) / v2Resolution.y;\n    vec3 ro = vec3(2.*cos(fGlobalTime),1.+2.*sin(fGlobalTime),4.);\n    float fv = .5;\n    if (t.w > .75)\n        ro = vec3(4,0,t.w);\n    else if (t.w > .5){\n        ro = vec3(0,4,sin(time));\n        fv = mix(.4,.5,pow(t.x,2.));\n    }\n    else if (t.w > .25)\n        ro = vec3(4.*sin(time),4.,sin(time));\n    vec3 cf = normalize(-ro),\n         cu = normalize(cross(cf, vec3(1,0,0))),\n         cl = normalize(cross(cf,cu)),\n         rd = mat3(cl,cu,cf)*normalize(vec3(uv, fv));\n    float i,r,d,N=123.,h=0.;\n    vec3 col = vec3(0);  // Initialize color as black\n    for (i=r=0.; i<N; i++) {\n        d =  1e9;\n        { vec3 p = ro+rd*r;\n          d = map(p);\n          if (d < 1e-4 && h < 10.) {\n            p = ro + rd * (r + d);\n            vec3 n = nor(p);\n            col += 0.5 + 0.5 * n;  // Color based on normal\n            col *= 1. - pow(1. - dot(-rd, n), 1.5);\n            rd = reflect(rd, n);\n            r = 1e-3;\n            ro = p;\n            h++;\n            continue;\n          }\n        }\n        if (d > 0.) r += d * .9;\n        if (d < 1e-4 || r > 1e5) break;\n    }\n    col = clamp(col, 0., 1.);  // Ensure color values are within valid range\n    out_color = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}