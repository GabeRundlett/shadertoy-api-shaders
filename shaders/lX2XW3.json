{
    "Shader": {
        "info": {
            "date": "1711155080",
            "description": "3D voxel DDA with a bunch of artifacts fixed. This one also has edge detection.\n\nOriginal Branchless Voxel Raytracing fork: https://www.shadertoy.com/view/4dX3zl\nFork with UV mapping: https://www.shadertoy.com/view/ddyXDt",
            "flags": 0,
            "hasliked": 0,
            "id": "lX2XW3",
            "likes": 5,
            "name": "AF Voxel DDA with Edge Detection",
            "published": 3,
            "tags": [
                "voxel",
                "dda",
                "3dda"
            ],
            "usePreview": 0,
            "username": "DapperCore",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "const int MAX_RAY_STEPS = 64;\nconst float EDGE_THICKNESS = 1.0;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n\nbool vec2OutOfRange(vec2 v, vec2 range) {\n    return v.x < range.x || v.y < range.x || v.x > range.y || v.y > range.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\t    \t\n\tbvec3 mask;\n    vec3 mapPos = floor(rayPos);\n    vec3 raySign = sign(rayDir);\n    vec3 deltaDist = 1.0/rayDir;\n    vec3 sideDist = ((mapPos-rayPos) + 0.5 + raySign * 0.5) * deltaDist;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        bvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n        bvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n        mask.z = b1.z && b2.z;\n        mask.x = b1.x && b2.x;\n        mask.y = b1.y && b2.y;\n        // if (mask == bvec3(false, false, false))\n        if(!any(mask)) // Thank you Spalmer\n            mask.z = true;\n            \n        vec3 vmask = vec3(mask);\n        mapPos +=  vmask * vec3(raySign);\n        \n        if (getVoxel(ivec3(mapPos))) {\n            vec3 mini = ((mapPos-rayPos) + 0.5 - 0.5*vec3(raySign))*deltaDist;\n            float d = max (mini.x, max (mini.y, mini.z));\n            \n            // edge aliasing happens when a pixel contains the edge of a block face \n            // edges of block faces are represented by the face uv going outside the bounds of [0.0, 1.0] \n            // so if you just project the corners of the pixel onto the block face, and one of the corner's uv coordinates are out of that range, the pixel overlaps an edge\n            // Can someone better at linear algebra than me figure out a smarter way to do this :'(\n            \n            // Floating point imprecision seems to cause edges that are between two parallel faces to be thicker than those that aren't\n            // the centerTo calculations don't seem to be accurate, I think you'd have to subtract the actual positions from the image plane rather than the ray directions.\n            \n            vec2 tlScreenPos = ((fragCoord.xy + vec2(EDGE_THICKNESS, EDGE_THICKNESS)) / iResolution.xy) * 2.0 - 1.0;\n            vec2 trScreenPos = ((fragCoord.xy + vec2(-EDGE_THICKNESS, EDGE_THICKNESS)) / iResolution.xy) * 2.0 - 1.0;\n            vec2 blScreenPos = ((fragCoord.xy + vec2(EDGE_THICKNESS, -EDGE_THICKNESS)) / iResolution.xy) * 2.0 - 1.0;\n            vec2 brScreenPos = ((fragCoord.xy + vec2(-EDGE_THICKNESS, -EDGE_THICKNESS)) / iResolution.xy) * 2.0 - 1.0;\n\n            vec3 tlRayDir = cameraDir + tlScreenPos.x * cameraPlaneU + tlScreenPos.y * cameraPlaneV;\n            vec3 trRayDir = cameraDir + trScreenPos.x * cameraPlaneU + trScreenPos.y * cameraPlaneV;\n            vec3 blRayDir = cameraDir + blScreenPos.x * cameraPlaneU + blScreenPos.y * cameraPlaneV;\n            vec3 brRayDir = cameraDir + brScreenPos.x * cameraPlaneU + brScreenPos.y * cameraPlaneV;\n            \n            float tlCenterTo = distance(tlRayDir, rayDir);\n            float trCenterTo = distance(trRayDir, rayDir);\n            float blCenterTo = distance(blRayDir, rayDir);\n            float brCenterTo = distance(brRayDir, rayDir);\n            \n            float tld = sqrt(pow(d, 2.0) + pow(tlCenterTo, 2.0));\n            float trd = sqrt(pow(d, 2.0) + pow(trCenterTo, 2.0));\n            float bld = sqrt(pow(d, 2.0) + pow(blCenterTo, 2.0));\n            float brd = sqrt(pow(d, 2.0) + pow(brCenterTo, 2.0));\n            \n            vec3 centerIntersect = rayPos + rayDir*d;\n            vec3 tlIntersect = rayPos + tlRayDir*tld;\n            vec3 trIntersect = rayPos + trRayDir*trd;\n            vec3 blIntersect = rayPos + blRayDir*bld;\n            vec3 brIntersect = rayPos + brRayDir*brd;\n            \n            vec3 centerUV3D = centerIntersect - mapPos;\n            vec3 tlUV3D = tlIntersect - mapPos;\n            vec3 trUV3D = trIntersect - mapPos;\n            vec3 blUV3D = blIntersect - mapPos;\n            vec3 brUV3D = brIntersect - mapPos;\n            \n            vec2 centerUV2D = vec2(dot(vmask.yzx, centerUV3D), dot(vmask.zxy, centerUV3D));\n            vec2 tlUV2D = vec2(dot(vmask.yzx, tlUV3D), dot(vmask.zxy, tlUV3D));\n            vec2 trUV2D = vec2(dot(vmask.yzx, trUV3D), dot(vmask.zxy, trUV3D));\n            vec2 blUV2D = vec2(dot(vmask.yzx, blUV3D), dot(vmask.zxy, blUV3D));\n            vec2 brUV2D = vec2(dot(vmask.yzx, brUV3D), dot(vmask.zxy, brUV3D));\n\n            if (vec2OutOfRange(tlUV2D, vec2(0.0, 1.0)) || vec2OutOfRange(trUV2D, vec2(0.0, 1.0)) || vec2OutOfRange(blUV2D, vec2(0.0, 1.0)) || vec2OutOfRange(brUV2D, vec2(0.0, 1.0)))\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            else\n                fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n                \n            return;\n        }\n        \n        sideDist += vmask * raySign * deltaDist;\n\t}\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}