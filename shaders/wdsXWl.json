{
    "Shader": {
        "info": {
            "date": "1552590217",
            "description": "Mapping the unit square into the unit circle, shown as a mesh here. This is a modification of IQ's shader and uses a L1 circle based formula which is both radius and angle conforming.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdsXWl",
            "likes": 55,
            "name": "Rounding the Square L1 Style",
            "published": 3,
            "tags": [
                "circle",
                "map",
                "square",
                "hemisphere"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 1675
        },
        "renderpass": [
            {
                "code": "// for a ready-to-use implementation with comparisons, see https://www.shadertoy.com/view/flcXRl\n\n// Original by by inigo quilez - iq/2019\n// Modified by Leonard Ritter <leonard.ritter@duangle.com>\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// except cart2rad() and rad2cart() which I release in the public domain.\n\n// this is a modification of https://www.shadertoy.com/view/3dsSWs\n// where the points of a square are mapped as equidistant points on a L1 circle\n// and then projected to L2, resulting in sets of equidistant points on\n// concentric circles.\n\n// it's unlikely the same technique will work in 3D as it depends\n// on a polar coordinate system, but it might work again in 4D?\n\n// comment for simple 2D square -> circle distortion demo\n#define HEMISPHERIC\n\n// uncomment to compare hexgrid to square grid\n//#define SQUAREGRID\n\n// when HEMISPHERIC is defined:\n\n// uncomment to compare L1 mapping to octahedral mapping\n//#define OCTAHEDRAL_MAPPING\n\n//-----------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\n\nfloat sdLineSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn dot2( pa - ba*h );\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    return dot2(p-a);\n}\n\n//-----------------------------------------------\n\nvec2 oct_wrap (vec2 v) {\n    return (1.0 - abs(v.yx)) * sign(v);\n}\n\n// https://jcgt.org/published/0003/02/01/\n// uv is [-1..1]x[-1..1]\nvec3 octahedral_surface(vec2 uv) {\n    float z = 1.0 - abs(uv.x) - abs(uv.y);\n    return vec3((z >= 0.0)?uv:oct_wrap(uv), z);\n}\n\n// spherical coordinates from points on L1 surface\nvec2 L1_to_spherical(vec3 o) {\n    // L1 to L2 arclength\n    float r = abs(o.x) + abs(o.y);\n    float h = o.x * ((r == 0.0) ? 0.0 : (1.0 / r)) - 1.0;\n    float phi = ((o.y >= 0.0)? -h : h) * radians(90.0);\n    // L1 to L2 radius\n    // inverse of https://en.wikipedia.org/wiki/Collignon_projection\n    float z = 1.0 - abs(o.z);    \n    float rho = radians(90.0) - asin(1.0 - z*z)*sign(o.z);\n    return vec2(phi, rho);\n}\n\n//-----------------------------------------------\n\n// convert from unit grid to unit circle\nvec2 cart2rad(vec2 o) {\n#ifdef OCTAHEDRAL_MAPPING\n    vec2 p = vec2(o.x + o.y, o.y - o.x)*0.5;\n    \n    vec3 n = vec3(p, 1.0 - abs(p.x) - abs(p.y));\n    float t = max(-n.z,0.0);\n    n.x += (n.x>0.0)?-t:t;\n    n.y += (n.y>0.0)?-t:t;\n    vec2 q = normalize(n).xy;\n    \n    return vec2(q.x - q.y, q.x + q.y)*sqrt(0.5);    \n#else\n    vec2 p = vec2(o.x + o.y, o.y - o.x)*0.5;    \n    vec2 s = L1_to_spherical(octahedral_surface(p));\n    \n    s.x += radians(45.0);\n\n    // radius\n    float r = abs(p.x) + abs(p.y);\n#ifdef HEMISPHERIC\n    // hemispheric distortion\n    r = sin(s.y);\n#endif\n    return r * vec2(cos(s.x), sin(s.x));\n#endif\n}\n\n//-----------------------------------------------\n\n// convert from circle to grid\nvec2 rad2cart(vec2 q) {\n    float r = length(q);\n#ifdef HEMISPHERIC\n    // hemispheric distortion\n    r = asin(r) / (0.5 * 3.1415926);\n#endif   \n    float a = atan(q.y, q.x) / (2.0 * 3.1415926) - 0.125;\n    \n    float px = abs(fract(a) - 0.5);\n    float py = abs(fract(a - 0.25) - 0.5);\n\t\n    return (4.0 * r) * vec2(px - py, px + py - 0.5);\n}\n\n//-----------------------------------------------\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a); float s = sin(a);\n    return vec2(p.x*c + p.y*s, s*p.x - c*p.y);\n}\n\nvec2 vertex( int i, int j, int num)\n{\n    // unit square\n#if !defined(SQUAREGRID)\n    vec2 s = vec2(i,j)/vec2(num, num*2);\n    s.x -= float(j%2)*0.5/float(num);\n    s = -1.0+2.0*s;\n    //s.x *= 2.0;\n#else\n    vec2 s = vec2(i,j)/float(num);\n    s = -1.0+2.0*s;\n#endif\n   \n    // unit circle\n#if 1\n#ifdef HEMISPHERIC   \n    vec2 q = cart2rad(s);\n    vec3 c = vec3(q, sqrt(max(0.0, 1.0 - q.x*q.x - q.y*q.y)));\n#else\n    vec2 c = cart2rad(s);\n#endif\n#else\n    // old function\n    vec2 c = maxcomp(abs(s))*normalize(s);\n#endif\n\n#ifdef HEMISPHERIC\n    vec3 sp = vec3(s, 0.0);\n    vec3 p = mix(c,sp,smoothstep(-0.5,0.5,sin(iTime*2.0)));\n    \n    p.xy = rotate(p.xy, iTime * 0.125);\n    \n    return vec2(p.x, (p.y + p.z) * sqrt(0.5));\n    //return vec2(p.x, p.z);\n#else\n    // blend\n    return mix(c,s,smoothstep(-0.5,0.5,sin(iTime*2.0)));\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // plane coords\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float w = 2.0/iResolution.y;\n    \n    // scale\n\tp *= 1.15;\n\tw *= 1.15;\n    \n    // mesh: body\n    vec2 di = vec2(10.0);\n#if !defined(SQUAREGRID)\n    const int num = 8;\n    for (int k = 0; k < num; ++k) {\n        int ring = num-k;\n        int ofsx = k/2 + k%2;\n        int ofsy = k;\n        for (int i = 0; i < ring; ++i) {\n            {\n            vec2 a = vertex(i+0+ofsx,ofsy,num);\n            vec2 b = vertex(i+1+ofsx,ofsy,num);\n            vec2 c = vertex(i+1+ofsx-(k%2),ofsy+1,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n            {\n            vec2 a = vertex(ring+ofsx,i*2+0+ofsy,num);\n            vec2 b = vertex(ring+ofsx,i*2+2+ofsy,num);\n            vec2 c = vertex(ring+ofsx-k%2,i*2+1+ofsy,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n            {\n            vec2 a = vertex(ring-i+ofsx,ring*2+ofsy,num);\n            vec2 b = vertex(ring-i-1+ofsx,ring*2+ofsy,num);\n            vec2 c = vertex(ring-i-1+ofsx+((k+1)%2),ring*2-1+ofsy,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n            {\n            vec2 a = vertex(ofsx,ring*2-i*2+0+ofsy,num);\n            vec2 b = vertex(ofsx,ring*2-i*2-2+ofsy,num);\n            vec2 c = vertex(ofsx+(k+1)%2,ring*2-i*2-2+1+ofsy,num);\n            di = min( di, vec2(min(sdLineSq(p,a,b),min(sdLineSq(p,a,c),sdLineSq(p,b,c))),\n                               sdPointSq(p,a)));\n            }\n        }\n    }\n    \n    // mesh: center\n    di.y = min( di.y, sdPointSq(p,vertex(num/2 + num%2,num,num)));\n#else\n    const int num = 10;\n\tfor( int j=0; j<num; j++ )\n\tfor( int i=0; i<num; i++ )\n    {\n        vec2 a = vertex(i+0,j+0,num);\n        vec2 b = vertex(i+1,j+0,num);\n        vec2 c = vertex(i+0,j+1,num);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,a,c)),\n                               sdPointSq(p,a)));\n    }\n\n    // mesh: top and right edges\n\tfor( int j=0; j<num; j++ )\n    {\n        vec2 a = vertex(num,j+0,num);\n        vec2 b = vertex(num,j+1,num);\n        vec2 c = vertex(j+0,num,num);\n        vec2 d = vertex(j+1,num,num);\n        di = min( di, vec2(min(sdLineSq(p,a,b), \n                               sdLineSq(p,c,d)),\n                           min(sdPointSq(p,a),\n                               sdPointSq(p,c))));\n    }\n    // mesh: top-right corner\n    di.y = min( di.y, sdPointSq(p,vertex(num,num,num)));\n#endif\n    di = sqrt(di);\n\n    \n    // color\n    float col = 1.0;\n    col *= 0.9+0.1*smoothstep(0.0,0.05,di.x);\n    col *= smoothstep(0.0,0.008,di.x);\n    col *= smoothstep(0.03,0.03+w,di.y );\n    \n    // vignette\n    col *= 1.0 - 0.15*length(p);\n    \n    fragColor = vec4(col,col,col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}