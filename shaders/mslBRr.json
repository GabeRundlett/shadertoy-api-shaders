{
    "Shader": {
        "info": {
            "date": "1688509150",
            "description": "Sphere using raycasting and fbm noise from a texture.\n\nOther version using raymarching and procedural noise : https://www.shadertoy.com/view/ddsBRr",
            "flags": 0,
            "hasliked": 0,
            "id": "mslBRr",
            "likes": 5,
            "name": "FBM Sphere (raycasting)",
            "published": 3,
            "tags": [
                "raycasting",
                "fbm"
            ],
            "usePreview": 0,
            "username": "jsulpis",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "// FBM Sphere (raycasting) by Julien Sulpis (https://twitter.com/jsulpis)\n// https://www.shadertoy.com/view/mslBRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Sphere params\n#define SPHERE_POSITION vec3(0, 1, 6)\n#define SPHERE_RADIUS 2.\n#define NOISE_STRENGTH .5\n#define ROTATION_SPEED .1\n\n// Ray casting\n#define INFINITY 1e10\n\n//===============================================//\n//  Generic utilities stolen from smarter people //\n//===============================================//\n\n// https://iquilezles.org/articles/intersectors/\n// sphere of size ra centered at point ce\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra ) {\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return INFINITY; // no intersection\n    return -b - sqrt(h);\n}\n\nfloat noise(vec3 p) {\n    return texture(iChannel0, p * .05).r;\n}\n\n// Comes from a course by SimonDev (https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A)\n// https://simondev.teachable.com/p/glsl-shaders-from-scratch\nfloat fbm(vec3 p, int octaves, float persistence, float lacunarity, float exponentiation) {\n  float amplitude = 0.5;\n  float frequency = 2.0;\n  float total = 0.0;\n  float normalization = 0.0;\n\n  for(int i = 0; i < octaves; ++i) {\n    float noiseValue = noise(p * frequency);\n    total += noiseValue * amplitude;\n    normalization += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n\n  total /= normalization;\n  total = total * 0.8 + 0.1;\n  total = pow(total, exponentiation);\n\n  return total;\n}\n\n// Inigo Quilez - https://www.shadertoy.com/view/4djSDy\nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec3 origin, in float radius) {\n  vec3 di = origin - pos;\n  float l = length(di);\n  float nl = dot(nor, di / l);\n  float h = l / radius;\n  float h2 = h * h;\n  float k2 = 1.0 - h2 * nl * nl;\n\n  // above/below horizon\n  // EXACT: Quilez - https://iquilezles.org/articles/sphereao\n  float res = max(0.0, nl) / h2;\n\n  // intersecting horizon \n  if(k2 > 0.001) {\n    // EXACT : Lagarde/de Rousiers - https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    res = nl * acos(-nl * sqrt((h2 - 1.0) / (1.0 - nl * nl))) - sqrt(k2 * (h2 - 1.0));\n    res = res / h2 + atan(sqrt(k2 / (h2 - 1.0)));\n    res /= 3.141593;\n  }\n\n  return res;\n}\n\nmat3 rotateY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat3(//\n    vec3(c, 0, s),//\n    vec3(0, 1, 0),//\n    vec3(-s, 0, c)//\n  );\n}\n\n//================//\n//  Project code  //\n//================//\n\nfloat fbmSphereDist(in vec3 ro, in vec3 rd) {\n    float smoothSphereDist = sphIntersect(ro, rd, SPHERE_POSITION, SPHERE_RADIUS);\n\n    vec3 intersection = ro + smoothSphereDist * rd;\n    \n    float fresnel = clamp(dot(rd, SPHERE_POSITION - intersection), 0., 1.);\n\n    vec3 intersectionWithRotation = (intersection - SPHERE_POSITION) * rotateY(iTime * ROTATION_SPEED) + SPHERE_POSITION;\n    float noise = fbm(intersectionWithRotation, 6, .5, 2., 4.5) * NOISE_STRENGTH * fresnel;\n\n\n  return sphIntersect(ro, rd, SPHERE_POSITION, SPHERE_RADIUS + noise);\n}\n\n\nvec3 getNormal(vec3 p) {\n  vec3 rd = SPHERE_POSITION - p;\n  float dist = fbmSphereDist(p, rd);\n  vec2 e = vec2(.001, 0);\n\n  vec3 normal = dist - vec3(\n    fbmSphereDist(p - e.xyy, rd), \n    fbmSphereDist(p - e.yxy, rd), \n    fbmSphereDist(p + e.yyx, rd)\n  );\n  return normalize(normal);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord / iResolution.xy - 0.5) * iResolution.xy / iResolution.y;\n\n  vec3 ro = vec3(0, 1, 0);\n  vec3 rd = normalize(vec3(uv, 1));\n\n  // background\n  vec3 color = vec3(0.01);\n\n  // sphere\n  float distance = fbmSphereDist(ro, rd);\n  vec3 position = ro + rd * distance;\n  float backgroundMask = step(INFINITY, distance);\n\n  float sphereAO = sphOcclusion(position, getNormal(position), SPHERE_POSITION, SPHERE_RADIUS);\n  vec3 sphereColor = vec3(sphereAO);\n\n  color = mix(color, sphereColor, 1.0 - backgroundMask);\n\n  // gamma\n  color = pow(color, vec3(1.0 / 2.2));\n\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}