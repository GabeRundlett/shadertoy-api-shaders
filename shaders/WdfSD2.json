{
    "Shader": {
        "info": {
            "date": "1552181140",
            "description": "green=clasic- circle on ray\npurple= circle is moved away from surface by gradient\nfor fullscreen!\npause time, move mouse\nscaled 1d cosine really messes with this one.\n\nsee\nhttps://www.shadertoy.com/view/4dtfDj\nhttps://www.youtube.com/watch?v=Qebhsp3GVMc",
            "flags": 0,
            "hasliked": 0,
            "id": "WdfSD2",
            "likes": 8,
            "name": "drunk fluttershy marching",
            "published": 3,
            "tags": [
                "ad",
                "benchmark",
                "advanced",
                "logeps"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 585
        },
        "renderpass": [
            {
                "code": "//this is possibly the BEST approach to cases\n//, where the ray nearly misses a surface. (surface almost parallel to RayDit)\n//BUT only if the gradient is good.\n//this shader has intentionally bad gradients.\n//boolean.-crescents have no roundedCorners of a proper vesica.\n//sine on the left border is just a stress test.\n//sure it has issues, but these may have simple solutions.\n\n//based on:\n//https://www.shadertoy.com/view/4dtfDj\n//which is a Fork of \"Accelerated raymarching concept\" by rory618. \n//https://shadertoy.com/view/MdcfWj\n\n#define time1 (iTime+260.)\n\n//this method suffers from runaway-overhead-complexity\n//this method suffers from very needy constrains , unlike logeps()\n//,but may still be worth it.\n//because;\n//this needs AD of\n//- (specific IQ) https://www.shadertoy.com/results?query=differentiation&sort=newest&filter=\n//- (general  me) https://www.shadertoy.com/view/3l2GDR\n//this needs methods, that catch (near) orbitzals (any mandelbrot shaderwill do)\n//this needs bayesTheorem, suggested in shaders like: https://www.shadertoy.com/view/tlf3zj\n//,to correctly compromise between\n//- making the circle as large as possible (while touching the ray as far away as possible)\n//- offsetting the circle as far as possible (while touching the ray as far away as possible)\n//this needs shapes with \n//- proper crescent/vesica continuity, without [walls of negative thickness]\n//- proper lipschitz-continuity, like IQs: https://www.shadertoy.com/results?query=differentiation&sort=newest&fil\n//\n//otherwise, this has been shown to be less precise than logEps.\n//otherwise, this has been shown to be LIKELY less effient than similar methods\n\n/*\n3 marching loops in 3colors\n- marchNaive\n- marchLogEps          (good for large lipschitz and long distances)\n- marchDrunkFluttershy (good for near-misses and near parallel cases)\n\nnamingSceme sceme because it is initially as silly and unintuitive\n as a drunk flirting wallflower\n,to root solve along a ray, by measuring distances to points\n,that are not on the ray;\nhttps://www.youtube.com/watch?v=Qebhsp3GVMc \n\n[drunk fluttershy] is rarely faster\n, except for some really close near misses.\n[drunk fluttershy] suffers moire from accumulative precision loss.\n\nBut Drunk Fluttershy performance can easily be doubled:\n- 1)replace grad() and map() function by ONE function\n- , that returns map() as its .x and grad as its .y, [using [audomatic Differentication]\n- , with [DA]=[derivative Arithmetic], [chain rule] code.\n-  - i would call that one [Drunk Dngelbunny] marching, becuase of the DA and because it would likely be much faster.\n- 2) merge [Drunk Fluttershy] and [Logeps]\n- where (timeRoot*timeRoot/s) could be useful to scale [drunk] properly.\n- - and it wold be good for larger lipschitz, hopefully.\n- - i would call that [AppleShy]\n- 3) both of the above, i would call that [BerryPunch marching]\n*/\n\n//i am very convicned by logeps\n//, in the context of large Lipschizs trough tensors/twists\n\n//i am not too convinced by DrunkFluttershy\n//mostly because its performance is hard to predict, noisy.\n//DrunkFluttershy might be better for AO \n//and [Temporal reprojection] that knows nearby ObjectID screenspace-borders from memory.\n//or for a 2-pass that first calculates a lowres sampling of surfacenormals.\n\nvoid lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w\n){z -= a; b -= a\n ;float q = dot(z, b) / dot(b, b)\n ;b *= clamp(q, 0., 1.)\n ;fragColor =mix(fragColor,vec4(c.xyz,1) \n               ,c.w* clamp(w-length( z - b),0.,1.));}\n\nvoid circle(inout vec4 fragColor, vec2 z, float r, vec4 c,  float w\n){float i=length(z)-w\n ;r-=1.\n ;i=abs(abs(i-r*.5)-r*.5)\n ;fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-i,0.,1.));}\n\n\nfloat map(vec2 u\n){vec2 v=u-iResolution.xy/2.\n ;v*=.7\n ;v.x=abs(v.x)-50.\n ;float circle=length(v)-70.\n ;float circle0=length(v-vec2(0,40.))-60.\n ;circle=abs(max(circle,-circle0))-.2//naive (bad) intersection of 2 circles.\n       ;circle/=.7\n ;float co=((u.x*.7)/9.-sin(v.y/9.)-1.)*9.//bad hacky 1d gradient is common for heightmaps.\n ;circle=min(co,circle)\n ;float zFarBox=min(min(u.x,u.y),min(iResolution.x-u.x,iResolution.y-u.y))\n //;return circle\n ;return min(circle,zFarBox);\n}\n\n//    fWidth(distanceField )==surfaceNormal\n//    fWidth(distanceField) ==length(firstDerivativeOf(distanceField))\n//    fWidth(distanceField) ==length(grad(distanceField))\n//abs(fWidth(distanceField))==LipschitzConstant\n//- the abs() explicitly excludes negative roots\n\n//Iff LipschitzConstant<=1. EVERYWHERE\n//-; s=sphereRadius=save distance to travel\n//Iff LipschitzConstant>1. we must understep \n//-; timeRoot+=s/LipschitzConstant\n//which increases step count too much too often\n\n//ideally LipschitzConstant<=1.\n//, BUT twist deformations and some fractals increase this\n//you can know the maximum absolute gradient of the whole distanceField (or segment of it)\n//as most distortions are locally bound \n//and have a knowable upper found of their distortion-strenght == tension\n//logeps() has proven useful to traverse many tensors more efficiently:\n\n#define LipschitzConstant 1.\n//#define LipschitzConstant mix(1.,4.,cos(time1*0.61)*.5+.5)\n\n#define eps     2e-3//epsilon to roots\n#define epsGrad 2e-3//epsilon that we use to calculate a derivativem could be roughly 1/zFar\n\n#define zIter  100\n#define zFar 200.\n\n//s is always the SphereRadius of a sphere whos center is ON the ray.\n//it is always safe to travel a distance of s\n\n//grad is a differential (over multiple domains)\n//ideally length(grad())<=1\nvec2 grad(vec2 u,float s//3tap 2d gradient == 2dsurface normal/orthogonal\n){vec2 e=vec2(epsGrad,0)\n ;return normalize(vec2(map(u+e),map(u+e.yx))-s)\n ;}//this can often be faster AND more precise \n//via [automatic differentiation] \n//via [derivative arithmetic] \n//via [chain rule]\n\nfloat marchNaive(vec2 rayOri,vec2 rayDir,inout vec4 fragColor,vec2 u\n){float timeRoot=0.\n ;for(int i=0;i<zIter;i++//green naive\n ){float s = map(rayOri+timeRoot*rayDir)\n  ;circle(fragColor,rayOri-u+timeRoot*rayDir,s,vec4(0,1,0,1),1.5)\n  ;timeRoot+=s/LipschitzConstant\n  ;//if(timeRoot>zFar)break\n ;}return timeRoot;}\n\n//logeps is better torugh diustortions/twists/tensors\n//where ever length(grad())>1\nfloat marchLogEps(vec2 rayOri,vec2 rayDir,inout vec4 fragColor,vec2 u){\n ;float timeRoot=map(rayOri)\n ;circle(fragColor,rayOri-u,timeRoot,vec4(0,0,1,.5),1.5)\n ;float s =1. \n ;for(int i=0;i<zIter;i++ //logeps is good for lipschitz>1.\n ){\n  ;s=map(rayOri+rayDir*timeRoot)\n  ;circle(fragColor,rayOri-u+timeRoot*rayDir,s,vec4(0,0,1,.5),1.)\n\n  ;if(false\n  ||log(timeRoot*timeRoot/s*epsGrad/1000.)>0.  //logEps  shines for long distances\n  //||abs(s)<epsGrad*(timeRoot/LipschitzConstant+ 1.) // shane dynamiceps formula\n  //||d>zFar \n   )break;\n  ;timeRoot+=s/LipschitzConstant\n\n\n   ;}return timeRoot;}\n\n//DrunkMarch() not necessarily measures points ON the ray\n//DrunkMarch() measure the derivative of the distanceField \n//and calculate a point that is further AWAY from surface\n//\n//measuring additional points, that are NOT on the ray\n//,is a bit drunk. [drunk] modifies how drunk we dare to get\n//,is a bit shy, but it still approaches a surface\n//and its shyness can make it move a bit faster \n//along long parallel lines or past near-misses..\n\nfloat marchDrunkFluttershy(vec2 rayOri,vec2 rayDir,inout vec4 fragColor,vec2 u){\n ;float timeRoot=0.\n ;float drunk=map(rayOri)\n ;\n;for(int i = 0; i < zIter; i++//red NaiveAccelerated\n ){float s=map(rayOri+timeRoot*rayDir)\n  ;if(s<eps)return timeRoot;\n  ;vec2 g=grad(rayOri+timeRoot*rayDir,s)\n  ;float cs = dot(g,rayDir)//length of othogonal-shadow that grad casts onto Ray.\n  ;float cullHeight=drunk*sqrt(1.-cs*cs)\n  ;vec2 centerDrunk=rayOri+timeRoot*rayDir+drunk*g\n  //draw linesegment from (centerdrunk) to (rayOri+timeRoot*rayDir)\n   ;lineSegment(fragColor,u,centerDrunk,rayOri+rayDir*timeRoot,vec4(1,0,0,1),1.)\n  ;//2 main cases below;\n   //- either circleCenter is at (centerdrunk)\n   //- or circleCenter is at (rayOri+timeRoot*rayDir)\n  ;//either way, it draws a small and large circle \n   //around one of the ends of the above lineSegment.\n  ;float RadiusDrunk=map(centerDrunk)//tap circle thos center is NOT on the ray.\n  ;if(RadiusDrunk>cullHeight//if our [drunk point] gets us in the forward-direction\n  ){float a=drunk*cs+sqrt(RadiusDrunk*RadiusDrunk-cullHeight*cullHeight)\n   ;if(s<a//if circle around (radiusdrunk) contains cullHeight Point\n   ){drunk*=4.//If successful skip, then go even bigger next time\n    ;circle(fragColor,centerDrunk-u,RadiusDrunk,vec4(1,0,0,.4),2.)\n   ;}else{//no jaywalking!\n    ;circle(fragColor,rayOri+timeRoot*rayDir-u,s,vec4(1,0,0,.4),2.)\n  ;}\n   ;timeRoot +=min(s,a)/LipschitzConstant//match forward.\n  ;}else{//we almost walked backwards, time to sit down and sober up.\n   //Reduce drunk but not too much\n   ;drunk=max(.1,.5*drunk+.5*min(s,drunk))\n   ;circle(fragColor,rayOri+timeRoot*rayDir-u,s,vec4(1,0,0,.4),2.)\n   ;timeRoot += s/LipschitzConstant\n  ;}\n  ;drunk=max(1.,5.*drunk+.5*min(RadiusDrunk,drunk))/10.\n ;}\n ;return timeRoot;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = fragCoord/iResolution.xy\n\n;fragColor = vec4(1)\n ;float timeRoot=0.//distance from camera to closest root\n ;vec2 rayOri = abs(iMouse.zw)\n ;vec2 rayDir= normalize(iMouse.xy-rayOri)\n ;if(iMouse.z<=0.\n ){rayOri=(.5+.5*sin(time1*vec2(.1,.2)))*iResolution.xy\n  ;rayDir=normalize(sin(time1*vec2(.3,.5)));}\n\n ;float gBuf=0.\n ;fragColor=vec4(vec3(map(fragCoord)),1.)\n ;fragColor=clamp(fragColor,0.,1.)\n ;gBuf=marchNaive(rayOri,rayDir,fragColor,fragCoord)\n ;gBuf=marchLogEps(rayOri,rayDir,fragColor,fragCoord)\n ;gBuf=marchDrunkFluttershy(rayOri,rayDir,fragColor,fragCoord)\n \n ;lineSegment(fragColor,fragCoord,rayOri,rayOri+rayDir*gBuf,vec4(0,0,0,1),1.)\n ;fragColor=mix(fragColor,fragColor.yzxw,cos(time1*.1)*.5+.5)  \n ;}\n \n//memo / suggestion:\n//#define LipschitzConstant mix(1.,4.,cos(iTime*0.61)*.5+.5)\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}