{
    "Shader": {
        "info": {
            "date": "1609541050",
            "description": "Credits to: https://www.shadertoy.com/view/WltyzS",
            "flags": 32,
            "hasliked": 0,
            "id": "WldczS",
            "likes": 6,
            "name": "a taste of the physically base 2",
            "published": 3,
            "tags": [
                "taste"
            ],
            "usePreview": 0,
            "username": "Ric3cir121",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 o,vec2 u){\n    o = pow(texelFetch(iChannel0,ivec2(u),0),vec4(.5))*1.3;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n#define MIN_DIST 0.001\n#define MAX_DIST 1500.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(0.6619, 0.3542, 0.3158)\n#define MAT_ERNST0_006 vec3(0.6619, 0.6108, 0.5172)\n#define MAT_ERNST0_002 vec3(0.3324, 0.6921, 0.5215)\n#define MAT_ERNST0_003 vec3(0.6982, 0.4874, 0.0414)\n#define MAT_ERNST0_001 vec3(0.1334, 0.42, 0.1273)\n#define MAT_ERNST0_005 vec3(0.1025, 0.0915, 0.0915)\n#define MAT_ERNST0_004 vec3(0.2306, 0.2807, 0.6619)\n\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat vmax(vec3 v){return max(max(v.x, v.y), v.z);}\nfloat sdEllipsoid(in vec3 p, in vec3 r){return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);}\nfloat sdCapsule(vec3 p, float r, float c){return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));}\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat sdCappedTorus(vec3 p, vec2 r, float per){\n\tp.x = abs(p.x);\n\tvec2 sc = vec2(sin(per),cos(per));\n\tfloat k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n\treturn sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\nfloat sdPieCylinder( vec3 p, float r, float h, float per ){\n\tper = mod(per, PI);\n\tvec2 c = vec2(sin(per),cos(per));\n\tp.xz=c.y*p.xz+c.x*vec2(p.z,-p.x);\n\tp.x = abs(p.x);\n\tfloat l = length(p.xz) - r;\n\tfloat m = length(p.xz-c*clamp(dot(p.xz,c),0.0, r));\n\tfloat x = max(l,m*sign(c.y*p.x-c.x*p.z));\n\tfloat y = abs(p.y) - h;\n\treturn ((min(max(x,y),0.0) + length(max(vec2(x,y),0.0))));\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y );\n\tvec2 k1 = vec2(r2,h);\n\tvec2 k2 = vec2(r2-r1,2.0*h);\n\tvec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n\tvec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n\tfloat s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n\treturn s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdRoundCone( vec3 p, float h, float r1, float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y+h*.5 );\n\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\tfloat k = dot(q,vec2(-b,a));\n\n\tif( k < 0.0 ) return length(q) - r1;\n\tif( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n\treturn dot(q, vec2(a,b) ) - r1;\n}\nfloat sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));}\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n}\nvec4 sd002(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=10.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -4.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -5.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpSubstractionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\nvec4 sd001(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=15.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -8.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_005), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -9.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpIntersectionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp001 = p;\n\tcp001.xyz += vec3(-8.0856, -4.9245, -10.7845);\n\tpRepLimited(cp001.y, 2.5, 3.);\n\tpRepLimited(cp001.z, 1.25, 4.);\n\tpRepLimited(cp001.x, 1.25, 4.);\n\n\tres = sd001(p);\n\tres = v4OpUnionSmooth(sd002(p), res, .01);\n\n\td = sdBox(p+vec3(0.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdBox(p+vec3(3.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.3)-0.3, d, 0.01);\n    \n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_003), res, .01);\n\n\td = sdCappedCylinder(p+vec3(0.0, -1.0, -9.0), vec2(1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdCappedCylinder(p+vec3(3.0, -1.0, -9.0), vec2(1.0, 1.0)-0.3)-0.3, d, 0.01);\n    \n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, .01);\n\n\td = sdCappedTorus(p+vec3(-3.0, -0.5, -12.0), vec2(1.0, 0.5), 2.356);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_004), res, .01);\n\n\td = sdCapsule(p+vec3(-3.0, -1.0, 0.0), 0.59, 0.44);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(0.0, -1.021, -3.0), 1.0-0.01, 1.02-0.01, 0.0)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(3.0, -1.021, -3.0), 1.0-0.1, 1.02-0.1, 0.0)-0.1, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, .01);\n\n\td = sdEllipsoid(p+vec3(0.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, .01);\n\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, 0.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, .01);\n\n\td = sdEllipsoid(p+vec3(-3.0, -1.5, -3.0), vec3(1.0, 1.5, 1.0));\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(0.0, -1.0, -12.0), 1.0-0.01, 1.0-0.01, 2.356)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(3.0, -1.0, -12.0), 1.0-0.3, 1.0-0.3, 2.356)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, .01);\n\n\td = p.y;\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_002), res, 0.01);\n\n\t{\n        // sdHex\n\t\tvec3 tp = p+vec3(-6.0, -1.1, 0.0);\n\t\tvec3 trp = p.xzy+vec3(-6.,-1.1,0)+vec3(0,1,-1.1);//rot(p+vec3(-6.0, -1.1, 0.0), vec3(1.5708, 0.0, 0.0));\n\t\tvec3 dim = vec3(0.75, 0.75, 1.0);\n\t\tfloat td = MAX_DIST;\n        \n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.01;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_005), res, 0.01);\n\n\t{\n\t\tvec3 tp = cp001;\n\t\tvec3 trp = cp001;\n\t\tvec3 dim = vec3(0.6342, 1.0, 0.6342);\n\t\tfloat td = MAX_DIST;\n\t\t\n\t\tfloat r = max(dim.x, dim.z);\n\t\tfloat c = dim.y*.5;\n\t\tfloat elg = c-min(.5,c);\n\t\ttrp.y -= clamp(trp.y,-elg,elg);\n\t\t\n\t\tfloat a = .5*trp.y*trp.y+.5;\n\t\tfloat b = abs(trp.y);\n\t\ttrp.y = b<1. ? a : b;\n\t\t\n\t\ttrp.y -= min(.5,c);\n\t\ttd = length(trp)-r;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_006), res, 0.01);\n\n\td = sdRoundCone(p+vec3(-3.0, -1.5, -6.0), 1.5, 0.765, 0.0);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdTorus(p+vec3(-3.0, -0.5, -9.0), vec2(1.0, 0.5));\n\td = fOpUnionSmooth(sdBox(p+vec3(-12.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\treturn res;\n}\nmat2 rotate(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec3 rotate(vec3 c,float r){return vec3(rotate(r)*c.xz,c.y).xzy;}\nfloat de(vec3 c){\n    return sdScene(c).x+fract(length(vec3(hash11(c.x),hash11(c.y),hash11(c.z)))*100.)/1000.;\n}\nvec4 doMarch(vec3 pos,vec3 cam){\n    int i = 0;\n    vec3 march = vec3(0);\n    float d = 1.;\n    \n    for(;i<100&&d>0.02&&length(march)<100.;i++){\n        d = de(pos+march);\n        march += d*cam;\n    }\n    return vec4(march+pos,i);\n}\nvec3 getnormal(vec3 n){\n    vec2 e = vec2(1.0,-1.0)*(n.y<0.002-1.?.002:.002);\n    return normalize(e.xyy*de(n+e.xyy)+e.yyx*de(n+e.yyx)+e.yxy*de(n+e.yxy)+e.xxx*de(n+e.xxx));\n}\nvec3 getcol(vec3 c){\n    return length(c)<50.?sdScene(c).yzw:vec3(.9);\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 U = u;\n    u += fract(hash22(u+iTime)*10000.);\n\tvec2 uv = (u-iResolution.xy/2.)/iResolution.y;\n    \n    vec3 pos = vec3(-4,7,-4);\n    vec2 look = vec2(-.65,-.5);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    \n    vec4 march = doMarch(pos,cam);\n    vec3 col = getcol(march.xyz);\n    for(int i = 0;i<10;i++){\n        pos = march.xyz;\n        vec3 refl = reflect(cam,getnormal(pos));\n        pos += refl/10.;\n        cam = refl;\n        march = doMarch(pos,cam);\n        if(length(march.xyz)>100.)break;\n        col *= getcol(march.xyz);\n    }\n\to = vec4(col, 1.);\n    vec4 old = texelFetch(iChannel0,ivec2(U),0);\n    if(iFrame!=0)o = mix(o,old,.99);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}