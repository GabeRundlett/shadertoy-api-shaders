{
    "Shader": {
        "info": {
            "date": "1554009237",
            "description": "Porting some research I've been doing for work to shaders.\nNext one I'll post(whenever I get my head around them): [url=https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline]NURBS[/url]\nMove mouse to change the blue point.\nEdit: Added construction.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsBXWm",
            "likes": 12,
            "name": "RationalBézierCurves",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "curves",
                "rational"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 993
        },
        "renderpass": [
            {
                "code": "// By Felipe Gutierrez, license: MIT as I don't give a f*** about what you do with this.\n// Uncomment or comment for the respective degree of curve(shitty implementation you must turn\n// only one of the Degrees at a time):\n// Degree 2\n//#define LINEAR    \n// Degree 3\n//#define QUADRATIC \n// Degree 4\n#define CUBIC    \n\n// Uncomment or comment for the construction process of the curve.\n// Degree 3\n//#define QUADRATICCONSTRUCT   \n// Degree 4\n#define CUBICCONSTRUCT    \n\nfloat lerp( float a, float b, float t )\n{\n\n\treturn mix( a, b, t );\n\n}\n\nvec2 lerp( vec2 a, vec2 b, float w1, float w2, float t, out float w )\n{\n\n    float temp = ( 1.0 - t ) * w1, tempO = w2 * t;\n    w = temp + tempO;\n    \n\treturn ( temp * a + tempO * b ) /\n            w;\n\n}\n\nfloat quad( float P0, float P1, float P2, float W0, float W1, float W2, float t )\n{\n\n    float ber = 1.0 - t, berO = t * t;\n    \n\treturn ( ber * ber * W0 * P0                 +\n\t\t   2.0 * ( t * P1 * W1 ) * ber           +\n\t\t   berO * P2 * W2 ) / \n           ( ber * ber * W0                      +\n\t\t   2.0 * ( t * W1 ) * ber                +\n\t\t   berO * W2 );\n\n}\n\nvec2 quad( vec2 P0, vec2 P1, vec2 P2, float W0, float W1, float W2, float t )\n{\n\n\treturn vec2( quad( P0.x, P1.x, P2.x, W0, W1, W2, t ),\n\t\t         quad( P0.y, P1.y, P2.y, W0, W1, W2, t )\n\t\t        );\n\n}\n\nfloat cub( float P0, float P1, float P2, float P3, float W0, float W1, float W2, float W3,\n\t         float t )\n{\n\n\tfloat ber = 1.0 - t, berO = t * t;\n\n\treturn ( pow( ber, 3.0 ) * P0 * W0           +\n\t\t     3.0 * ( ber * ber ) * t * P1 * W1   +\n\t\t     3.0 * ( ber ) * berO * P2 * W2      +\n\t\t     pow( t, 3.0 ) * P3 * W3\n           ) /\n           ( pow( ber, 3.0 ) * W0                +\n\t\t     3.0 * ( ber * ber ) * t * W1        +\n\t\t     3.0 * ( ber ) * berO * W2           +\n\t\t     pow( t, 3.0 ) * W3\n           ) ;\n\n}\n\nvec2 cub( vec2 P0, vec2 P1, vec2 P2, vec2 P3, float W0, float W1, float W2, float W3, float t )\n{\n\n\treturn vec2( cub( P0.x, P1.x, P2.x, P3.x, W0, W1, W2, W3, t ),\n\t\t         cub( P0.y, P1.y, P2.y, P3.y, W0, W1, W2, W3, t )\n\t\t        );\n\n}\n\nfloat cir( vec2 uv, float r, float b )\n{\n\n\treturn smoothstep( r, r - b, length( uv ) );\n\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 mou = iMouse.xy / iResolution.y;\n    \n    mou = iMouse.x < 0.1 ? vec2( 1.3, 0.2 ) : mou;\n\n    // r = size of interpolation, rO = size of points.\n\tfloat r = 0.02, rO = 0.015, b = 0.1, bO = 0.005;\n\n\tvec3 col = vec3( 0 );\n\n    // Points coordinates:\n\tvec2 A = uv - vec2( 0.1, 0.5 );\n    vec2 B = uv - vec2( 0.5, 0.9 );\n    vec2 C = uv - mou;\n\tvec2 D = uv - vec2( 1.7, 0.5 );\n    \n    // Weights for the Bézier. This allows us to get perfect Conic Sections from\n    // Bézier Curves.\n    float w0 = 1.0, w1 = 2.0, w2 = 1.0, w3 = 1.0;\n    \n    float t = 0.5 + sin( iTime * 0.5 ) * 0.5;\n    float tO = ( 1.0 - t );\n    \n    #ifdef QUADRATICCONSTRUCT   \n    // Process visualization.\n    float wOut = 0.0, wOutOne = 0.0;\n    col = line( col, A, C, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.6) );\n    vec2 inter = lerp( A, C, w0, w1, t, wOut );\n    col += cir( inter, rO, bO ) * vec3( 1, 0.25, 0 );\n    col = line( col, D, C, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.6) );\n    vec2 interT = lerp( D, C, w2, w1, tO, wOutOne );\n    col += cir( interT, rO, bO ) * vec3( 1, 0.25, 0 );\n    col = line( col, inter, interT, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.6) );\n    \n    #else\n    #endif\n    \n    #ifdef CUBICCONSTRUCT   \n    // Show construction.\n    float wOut = 0.0, wOutOne = 0.0, wOutTwo = 0.0, wOutThree = 0.0, wOutFour = 0.0;\n    \n    col = line( col, A, B, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n    vec2 inter = lerp( A, B, w0, w1, t, wOut );\n    col += cir( inter, rO, bO ) * vec3( 1, 1, 0 );\n    col = line( col, B, C, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n\n    vec2 interT = lerp( B, C, w1, w2, t, wOutOne );\n    col += cir( interT, rO, bO ) * vec3( 1, 1, 0 );\n    col = line( col, C, D, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n\n    vec2 interTh = lerp( C, D, w2, w3, t, wOutTwo );\n    col += cir( interTh, rO, bO ) * vec3( 1, 1, 0 );\n\n    vec2 interN = lerp( inter, interT, wOut, wOutOne, t, wOutThree );\n    col = line( col, inter, interT, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n    col += cir( interN, rO, bO ) * vec3( 1, 0.25, 0 );\n\n    vec2 interNT = lerp( interT, interTh, wOutOne, wOutTwo, t, wOutFour );\n    col = line( col, interT, interTh, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n    col += cir( interNT, rO, bO ) * vec3( 1, 0.25, 0 );\n    col = line( col, interN, interNT, vec2( 0.0005 ), vec2(0.0025,2.0), vec4(0.65) );\n\t#else\n    #endif\n    \n    // Notice the relation for the for loop:\n    //                                       if the exit condition is 10,\n    //                                       the multiplication of i is 0.1\n    // And yes Fabrice I know I can loop on floats :)\n    // Iteration exit condition and multiplier.\n    const int n = int( 1e+3 );\n    const float m = 1e-3; float wO = 0.0;\n\tfor( int i = 0; i < n; ++i )\n\t{\n\n        #ifdef LINEAR\n\t\tcol += cir( lerp( A, C, w0, w1, float( i ) * m, wO ), r, b );\n        #else\n        #endif\n        #ifdef QUADRATIC\n\t\tcol += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );\n        #else\n        #endif\n        #ifdef CUBIC\n        col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );\n\t\t#else\n        #endif\n\n\t}\n    \n    // Visualizing time t parameter of the basis-functions:\n    \n    #ifdef LINEAR\n    col += cir( lerp( A, C, w0, w1, t, wO ), rO, bO ) * vec3( 1, 0, 0 );\n    #else\n    #endif\n    #ifdef QUADRATIC\n    col += cir( quad( A, C, D, w0, w1, w2, t ), rO, bO ) * vec3( 1, 0, 0 );\n    #else\n    #endif\n    #ifdef CUBIC\n    col += cir( cub( A, B, C, D, w0, w1, w2, w3, t ), rO, bO ) * vec3( 1, 0, 0 );\n    #else\n    #endif\n\n    // PointA.\n    col += cir( A, rO, bO ) * vec3( 1, 0, 0 );\n    // PointC.\n\tcol += cir( C, rO, bO ) * vec3( 0, 0, 1 );\n    #ifdef LINEAR\n    #else\n    #ifdef QUADRATIC\n    // PointB.\n    #else\n\tcol += cir( B, rO, bO ) * vec3( 0, 1, 0 ); \n    #endif\n    // PointD.\n\tcol += cir( D, rO, bO ) * vec3( 0, 1, 1 );\n\t#endif\n\tfragColor = vec4( col, 1.0 );\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}