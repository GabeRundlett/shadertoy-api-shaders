{
    "Shader": {
        "info": {
            "date": "1680081215",
            "description": "Click and drag.",
            "flags": 0,
            "hasliked": 0,
            "id": "cs3XR2",
            "likes": 4,
            "name": "Klein kaleidoscope",
            "published": 3,
            "tags": [
                "kaleidoscope",
                "klein"
            ],
            "usePreview": 0,
            "username": "stla",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "const float PI = 3.14159265358979324;\n\n// color mapping\nfloat perFract(float x, float t, float m, float M) {\n  x = x / t;\n  return m + (M - m) * (x - floor(x));\n}\nvec3 pair2hsv(vec2 z) {\n  float n = 3.0;\n  float h = (atan(z.y, z.x) + PI) / 2.0 / PI;\n  float ph = perFract(h, 1.0 / n, 0.6, 1.0);\n  float l = length(z);\n  float plogm = perFract(log(1.0 + l), 2.0 * PI / n, 0.6, 1.0);\n  float v = ph * plogm;\n  return vec3(h, 0.96, v);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 pair2rgb(vec2 z) {\n  return hsv2rgb(pair2hsv(z));\n}\n\n// operations on complex numbers\nvec2 product(vec2 a, vec2 b) {\n  return mat2(a, -a.y, a.x) * b;\n}\nvec2 conjugate(vec2 z) {\n  return vec2(z.x, -z.y);\n}\nvec2 invers(vec2 z) {\n  return conjugate(z) / dot(z, z);\n}\nvec2 divide(vec2 a, vec2 b) {\n  return product(a, invers(b));\n}\nvec2 power(vec2 z, float n) {\n  // z = r(cos θ + i sin θ)\n  // z^n = r^n (cos nθ + i sin nθ)\n  float theta = atan(z.y, z.x);\n  float rn = pow(length(z), n);\n  return rn * vec2(cos(n*theta), sin(n*theta));\n}\n\n// Mobius transformation\n//  https://laustep.github.io/stlahblog/posts/OnAMobiusTransformation.html\nvec2 mobius(vec2 z, vec2 gamma, float t) {\n  float g2 = dot(gamma, gamma);\n  float h = sqrt(1.0 - g2);\n  float theta = t * PI/2.0;\n  vec2 d2 = pow(h, t) * vec2(cos(theta), sin(theta));\n  vec2 d1 = conjugate(d2);\n  vec2 a = vec2(d1.x, -d1.y/h);\n  vec2 b = d2.y * gamma / h;\n  vec2 c = conjugate(b);\n  vec2 d = conjugate(a);\n  return divide(product(a, z) + b, product(c, z) + d);\n}\n\n// Klein function \nvec2 klein(vec2 z) {\n  vec2 z5  = power(z, 5.0);\n  vec2 z10 = product(z5, z5);\n  vec2 z15 = product(z5, z10);\n  vec2 z20 = product(z10, z10);\n  vec2 a  = product(z, z10 + 11.0 * z5 - vec2(1.0, 0.0));\n  vec2 a5 = power(a, 5.0);\n  vec2 b  = -(z20 + vec2(1.0, 0.0)) + 228.0 * (z15 - z5) - 494.0 * z10;\n  vec2 b3 = power(b, 3.0);\n  return 1728.0 * divide(a5, b3);\n}\n\n// the function to be color-mapped\nvec2 f(float x, float y, vec2 gamma, float t) {\n  return klein(mobius(klein(vec2(x, y)), gamma, t));\n}\n\n// map function: x -> map(x, a, b, c, d) linearly sends (a,b) to (b,c)\nfloat lerp(float t, float a, float b) {\n  return a + t*(b-a);\n}\nfloat norm(float t, float a, float b) {\n  return (t-a)/(b-a);\n}\nfloat map(float t, float e1, float s1, float e2, float s2) {\n  return lerp(norm(t, e1, s1), e2, s2);\n}\n\n//\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = 1.0 + cos(0.1*iTime);\n  float gammax = map(iMouse.x, 0.0, iResolution.x, -0.7, 0.7); \n  float gammay = map(iMouse.y, 0.0, iResolution.y, -0.7, 0.7);\n  float r = iResolution.x / iResolution.y;\n  float x = map(fragCoord.x, 0.0, iResolution.x, -2.0*r, 2.0*r); \n  float y = map(fragCoord.y, 0.0, iResolution.y, -2.0, 2.0);\n  vec2 z = f(x, y, vec2(gammax, gammay), t);\n  fragColor.rgb = pair2rgb(z);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}