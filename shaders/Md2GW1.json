{
    "Shader": {
        "info": {
            "date": "1387470796",
            "description": "The Legend of Zelda: Explained 1. Explaining >. Simple random character movement on straight lines.",
            "flags": 0,
            "hasliked": 0,
            "id": "Md2GW1",
            "likes": 43,
            "name": "The Legend of Zelda: Explained 1",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "retro",
                "tutorial",
                "sprite",
                "nes",
                "8",
                "bit",
                "zelda",
                "legend",
                "explained"
            ],
            "usePreview": 0,
            "username": "HLorenzi",
            "viewed": 3062
        },
        "renderpass": [
            {
                "code": "// The Legend of Zelda: Explained 1, by hlorenzi\n// Explaining https://www.shadertoy.com/view/4sjGD1\n// Simple random character movement on straight lines.\n\nfloat hash(float x)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec2 hashPosition(float x)\n{\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec2(hash(x) * 64.0, hash(x * 1.1) * 64.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Set up the camera.\n\t// Move (0,0) to the center and fix proportion.\t\n\t// Then multiply by 64 so the screen will cover at least the square (-64,-64) to (64,64). \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 64.0;\n\t\n\t// Draw the background.\n\tfragColor = vec4(1,1,1,1);\n\t\n\t\n\t// == ~ ==\t\n\t\n\t\n\t// Then, the movement mechanics.\n\t// It may seem, on the original, that enemies are spawned and the player tries\n\t// to approach them, but it is actually the character that moves randomly,\n\t// and an enemy is conveniently generated next to its known position.\n\t\n\t// Every (sequenceDuration) seconds, the character will leave its (startingPosition)\n\t// and approach its (goalPosition). If it gets to the goal before the time runs out,\n\t// it will just stand there, waiting. It's necessary to have constant sequence\n\t// durations, as to not depend on previous sequence times. (Otherwise you would have to\n\t// simulate all the movement since the 0s mark, every frame. Instead of \"integrating\"\n\t// all variable time since 0s, one can figure out the current frame by straightforward\n\t// calculations)\n\tconst float sequenceDuration = 2.0;\n\t\n\t// This is the current sequence index.\n\t// From 0s to 2s: index = 0.0\n\t// From 2s to 4s: index = 1.0 and so on\n\t// This will be used to get a (consistent) random position for the character.\n\tfloat currentSequence = floor(iTime / sequenceDuration);\n\t\n\t// This is the current sequence frame, marking the number of seconds\n\t// since the start of the sequence:\n\tfloat currentSequenceTime = mod(iTime, sequenceDuration);\n\t\n\t// Generate the character's starting and goal positions.\n\t// (goalPosition) is actually the (startingPosition) of next sequence.\n\tvec2 startingPosition = hashPosition(currentSequence);\n\tvec2 goalPosition     = hashPosition(currentSequence + 1.0);\n\t\n\t// Set up a variable to hold the character's current position, i.e. between the\n\t// starting and goal positions.\n\tvec2 currentPosition;\n\t\n\t// The character's moving speed in units/second. We should set this so it can always\n\t// reach the goal before the sequence ends, or else it will skip abruptly to the next.\n\t// You can see it happening right before 16s.\n\tconst float speed = 48.0;\n\t\n\t\n\t// == ~ ==\n\t\n\t\n\t// Now, if we wanted the character to follow its goal in a straight line,\n\t// we could do this:\n\t\n\t// How far could it have gone since the start of this sequence?\n\tfloat potentialDistance = speed * currentSequenceTime;\n\t\n\t// How far is the goal from the start?\n\tfloat goalDistance = length(goalPosition - startingPosition);\n\t\n\t// Now, if (potentialDistance) is smaller than (goalDistance),\n\t// the character is still moving towards the goal. If it is equal or greater,\n\t// it means it already reached the goal, and can stop there.\n\tif (potentialDistance < goalDistance) {\n\t\tcurrentPosition = mix(startingPosition, goalPosition,\n\t\t\t\t\t\t\t  potentialDistance / goalDistance);\n\t} else {\n\t\tcurrentPosition = goalPosition;\n\t}\n\t\n\t// Moving in a Manhattan-like fashion is an extension from this!\t\n\t\n\t// Finally, draw the character!\n\tif (length(uv - currentPosition) <= 8.0) fragColor = vec4(1,0,0,1);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}