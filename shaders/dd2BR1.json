{
    "Shader": {
        "info": {
            "date": "1689532268",
            "description": "Added some auto-VJ capabilities to the organic beauty of coleda\n\n- Use with music in iChannel0 of Buffer A - ",
            "flags": 96,
            "hasliked": 0,
            "id": "dd2BR1",
            "likes": 24,
            "name": "Fork: It is alive...with music!",
            "published": 3,
            "tags": [
                "procedural",
                "raymarching",
                "noise",
                "music",
                "organic"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 678
        },
        "renderpass": [
            {
                "code": "// Fork (0.2.230716) of \"It is alive...\"\n// Original by coledea at https://www.shadertoy.com/view/ctcGR8\n// mainly added auto-vj capabilities\n// \n// - use with music in iChannel0 of Buffer A -\n\n#define PI 3.14159265359\n#define aTime 2.133333*iTime\n\nconst int MAX_MARCHING_STEPS = 80;\nconst float MARCHING_EPSILON = 0.0001;\nconst float DERIVATIVE_EPSILON = 0.001;\n\n// LIGHTING\nconst vec3 ALBEDO_INNER = vec3(3.0, 0.02, 0.03);\nconst vec3 ALBEDO_OUTER = vec3(0.3, 0.0, 0.0);\nconst vec3 ALBEDO_CREASES = vec3(0.0, 0.0, 0.01);\n\n// SCENE\nconst vec3 SPHERE_CENTER = vec3(0.0);\nconst float SPHERE_RADIUS = .4;\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\n//======================================\n// HELPER FUNCTIONS\n//======================================\n\nvoid compressFft(){ //here just reads compressed amplitudes from buffer\n    for (int n=0;n<4;n++)\n        fft[n] = texelFetch( iChannel0, ivec2(n,0), 0 ).a,\n        ffts[n] = texelFetch( iChannel0, ivec2(n+4,0), 0 ).a;\n}\n\nvec2 spherical_mapping(vec2 normal)\n{\n    //return normal / 2.0 + 0.5;  // simpler approximation, leads to distortions at the poles\n    return vec2(asin(normal.x), asin(normal.y)) / PI + 0.5;\n}\n\n// From: https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), \n              dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\n// From: https://github.com/MaxBittker/glsl-voronoi-noise\nvec3 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n\n  return vec3(sqrt(res), abs(id));\n}\n\n\n//======================================\n// SCENE DEFINITION\n//======================================\n\nfloat organic_displacement(vec2 normal)\n{   \n    vec2 uv = spherical_mapping(normal);\n    return texture(iChannel0, uv).x;\n}\n\nfloat distToSphere(vec3 center, float radius, vec3 queryPoint)\n{\n    return length(center - queryPoint) - radius;\n}\n\n// returns distance to scene and displacement value from texture\nvec2 distToScene(vec3 queryPoint)\n{\n    float displacement = organic_displacement(normalize(queryPoint - SPHERE_CENTER).xy);\n    float dist = length(SPHERE_CENTER - queryPoint) - (SPHERE_RADIUS + displacement);     // big sphere\n    \n    float sinTime = sin(iTime + fft.x*PI) * 0.2;\n    float cosTime = cos(aTime/4. + fft.y*PI) * 0.2;\n    dist = smin(dist, distToSphere(vec3(sinTime * sinTime, cosTime, sinTime), 0.5*pow(fft.x,9.), queryPoint), 0.4+ffts.x*.3); // first small sphere\n    dist = smin(dist, distToSphere(vec3(sinTime, sinTime * cosTime, cosTime), 0.3*fft.y, queryPoint), 0.3+.3*ffts.y); // second small sphere\n    dist = smin(dist, distToSphere(vec3(cosTime * cosTime, sinTime, sinTime * cosTime), 0.2*fft.z, queryPoint), 0.2+.2*ffts.z); // third small sphere\n    return vec2(dist, displacement);\n}\n\n//======================================\n// GENERAL LIGHTING\n//======================================\nvec3 normal(vec3 p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * distToScene(p + k.xyy * DERIVATIVE_EPSILON).x + \n                      k.yyx * distToScene(p + k.yyx * DERIVATIVE_EPSILON).x + \n                      k.yxy * distToScene(p + k.yxy * DERIVATIVE_EPSILON).x + \n                      k.xxx * distToScene(p + k.xxx * DERIVATIVE_EPSILON).x);\n}\n\n\n//======================================\n// PBR from  https://learnopengl.com/PBR/Lighting\n//======================================\n\n// Fresnel-Schlick approximation\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  \n\n// normal distribution (for depicting roughness)\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\n// self-occlusion\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 lightPBR(vec3 point, vec3 lightPositions[2], vec3 lightColors[2], vec3 eye, float material)\n{\n   // doesn't work for some reason\n   /* vec2 materialDerivatives = vec2(dFdx(material), dFdy(material));\n    float materialChange = 10000.0 * (materialDerivatives.x + materialDerivatives.y);\n    vec3 albedo = vec3(materialChange);*/\n\n    vec3 albedo = mix(ALBEDO_OUTER, ALBEDO_INNER, smoothstep(0.05, 0.08, material));\n    //albedo = mix(ALBEDO_CREASES, albedo, step(0.01, material));\n\n    //float metallic = 0.1 * smoothstep(0.05, 0.08, material);\n    float metallic = .0;\n    float roughness = 0.1 + 0.4 * (1.0 - smoothstep(0.07, 0.08, material)); //0.5;\n    float ao = smoothstep(0.05, 0.09, material);\n\n    vec3 N = normal(point); \n    N = normalize(N);\n    vec3 V = normalize(eye - point);\n\n    vec3 F0 = vec3(0.04); // approximate base reflectivity for dielectrics\n    F0 = mix(F0, albedo, metallic);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    \n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - point);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - point);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;        \n        \n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metallic;\t  // metallic surfaces do not have diffuse reflection (refraction)\n        \n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n        vec3 specular     = numerator / denominator;  \n            \n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n    }   \n  \n    // add ambient term\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 color = ambient + Lo;\n\t\n    // HDR tone mapping and gamma correction\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));  \n   \n    return color;\n}\n\n//======================================\n// RAYMARCHING\n//======================================\n\nvec3 getRayDirection(vec3 eye, vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n    vec3 ww = normalize(vec3(0.0) - eye);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    return normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    compressFft(); //initializes fft, ffts\n    \n    vec3 eye = vec3(sin(iTime * 0.05 + pow(sin(aTime/16.),9.)*PI) * 0.5 + 0.1, 0.0, 1.8);\n    vec3 ray = getRayDirection(eye, fragCoord);\n    \n    vec3 lightPos[2] = vec3[2](vec3(2.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0));\n    vec3 lightColors[2] = vec3[2](vec3(1.0), vec3(1.0));\n    \n    vec3 p = eye;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        \n        vec2 queryResult = distToScene(p);\n        float dist = queryResult.x;\n        float displacement = queryResult.y;\n        \n        if(dist < MARCHING_EPSILON){\n            fragColor = vec4(lightPBR(p, lightPos, lightColors, eye, displacement), 1.0);\n            return;\n        }\n        \n        p += ray * dist;\n    }\n    \n    // background\n    vec2 uv = fragCoord/iResolution.xy;\n    float organic = texture(iChannel0, uv).x;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = sin(iTime * 0.25) + uv * 6.0;\n    vec3 voronoi = voronoi3d(vec3(-6.0, uv))*.1*(1.+5.*fft.w);\n    float final = pow(voronoi.r * 3.0, organic * 10.0 * (1.+2.*fft.y));\n    uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y)*1.2;\n    final *= length(uv)*length(uv); //vignette\n    fragColor = vec4(final * .5 * ffts.w, 0., 0.015, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// BUFFER A (0.1) of Fork of \"It is alive...\"\n// Original by coledea at https://www.shadertoy.com/view/ctcGR8\n// mainly added auto-vj capabilities\n// \n// - use with music in iChannel0 of Buffer A -\n\n\n// I adapted the procedural texture from https://twigl.app/?ol=true&ss=-NNIajM4aEzy75lqtAUd\n\n#define DETAIL 20.0\n#define BASE_COLOR vec4(4, 2, 1, 0)\n#define ANIMATION_SPEED 2.0\n#define BRIGHTNESS 0.2\n#define STRUCTURE_SMOOTHNESS 1.2   // how washed out the result looks regarding structure\n#define SATURATION 0.2      // how crisp the result looks regarding colors/thickness of black lines\n\n#define aTime 2.133333*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    compressFft(); //initializes fft, ffts\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; // center (0,0) and handle aspect ratio\n    float dist_squared = dot(p,p);\n    float S = 9.0;\n    mat2 m = rotate2D(5.0);\n    \n    float a;\n    vec2 n,q;\n    \n    for(float j = 0.0; j++ < DETAIL;){\n      p *= m;\n      n *= m;\n      q = p * S + iTime *fft.x*0.01 * .15 * ANIMATION_SPEED + 1.8*sin((aTime/2. + fft.z*1.) * ANIMATION_SPEED - dist_squared * 6.0) * 0.8 + j + n;\n      a += dot(cos(q) / S, vec2(SATURATION));\n      n -= sin(q);\n      S *= STRUCTURE_SMOOTHNESS;\n    }\n    \n    float result = 0.2 * ((a + BRIGHTNESS) + a + a); \n    fragColor = vec4(result);\n    \n    if (fragCoord.y<1.)\n        if (fragCoord.x<8.)\n            fragColor.a = (fragCoord.x<4.)? fft[int(fragCoord.x)] : ffts[int(fragCoord.x)]; //save compressed amplitudes\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 33981,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/spor/strange-heart"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}