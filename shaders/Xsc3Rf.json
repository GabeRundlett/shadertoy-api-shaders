{
    "Shader": {
        "info": {
            "date": "1451230850",
            "description": "Experimentation",
            "flags": 0,
            "hasliked": 0,
            "id": "Xsc3Rf",
            "likes": 5,
            "name": "Warpring",
            "published": 3,
            "tags": [
                "raymarching",
                "torus",
                "distortion"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 416
        },
        "renderpass": [
            {
                "code": "float torus(vec3 pos, vec2 t)\n{\n\tvec2 q = vec2(length(pos.xz) - t.x, pos.y);\n\treturn length(q) - t.y;\n}\n\nvec3 twist(vec3 pos, float t)\n{\n    float c = cos(t * pos.x);\n    float s = sin(t * pos.x);\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.xz, pos.y);\n}\n\nvec3 bend(vec3 pos, float t)\n{\n    float c = cos(t * pos.z);\n    float s = sin(t * pos.z);\n    mat2  m = mat2(c, -s , s, c);\n    return vec3(m * pos.xy, pos.z);\n}\n\nfloat distfunc(vec3 pos)\n{\n    vec3 bent = bend(pos, 0.45 * sin(.66 * iTime));\n    vec3 twisted = twist(bent, 0.1 * cos(iTime));\n    return torus(twisted, vec2(7.0, 5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(5. * sin(iTime), 5. * cos(iTime), 14.);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 50.0;\n    const float EPSILON = 0.005;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir*.5;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal * 0.9));\n        float specular = pow(diffuse, 100.0);\n\t\t\n        vec3 color = vec3(sin(twist(pos, pos.x).y) * cos(pos.z * 0.075 * sin(0.2 * iTime)) * 0.25 + (diffuse + 0.2 * specular),\n                          cos(twist(pos, pos.y).z) * cos(pos.x * 0.075 * sin(0.3 * iTime)) * 0.5 + (diffuse + 0.2 * specular),\n                          sin(twist(pos, pos.z).x) * cos(pos.y * 0.075 * sin(0.7 * iTime)) * 0.25 + (diffuse + 0.2 * specular));\n\n\n        fragColor = vec4(color.zyx, 1.0);\n    }\n    else\n        fragColor = vec4(0., .1, .2, 1.);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}