{
    "Shader": {
        "info": {
            "date": "1553035497",
            "description": "Fun with atanh.\n\nMouse changes rotation parameters.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsBXRW",
            "likes": 34,
            "name": "Complex Atanh",
            "published": 3,
            "tags": [
                "domain",
                "complex",
                "mapping",
                "atanh"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 1038
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// Complex Inverse Hyperbolic Tangent\n//\n// Domain mapping of sums of complex atanh.\n// Care needed for alignment across branch cuts.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat A = 7.0, B = 2.0; // Rotation angle is atan(B,A)\nfloat K = 1.0;          // Extra subdivisions\nfloat scale = 1.5;\nfloat PI = 3.14159;\n\n//#define CIRCLE\n#define CHECKERBOARD\n\n// Complex functions\nvec2 cmul(vec2 z, vec2 w) {\n  //return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// Iq's hsv function, but just for hue.\nvec3 h2rgb(float h ) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n  return 0.2+0.8*rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n  //float theta = atan(B,A);\n  //vec2 rot = vec2(cos(theta),sin(theta));\n  vec2 rot = vec2(A,B);\n  //z = clog(z);\n  //z = 2.0*catanh(z);\n  z = /*0.5*clog(z) +*/ catanh(-0.5*z) + catanh(cmul(vec2(cos(0.1*iTime),sin(0.1*iTime)), z));\n  z /= PI; // Alignment\n  float px = 0.5*fwidth(z.x);\n  z.y = mod(z.y+0.1*iTime,1.0);\n  //px = 0.5*fwidth(length(z));\n  px *= K*length(rot);\n  z = K*cmul(rot,z);\n  //z.y += 2.0*iTime;\n  vec2 index = round(z);\n  z -= index;\n  float hx = index.x/(K*(B==0.0 ? 1.0 : B)); // Color for column\n  float hy = index.y/(K*(A==0.0 ? 1.0 : A)); // Color for row\n#if defined CIRCLE\n  float d = length(z); // Circle\n#else\n  float d = max(abs(z.x),abs(z.y)); // Square\n#endif  \n  vec3 colx = h2rgb(hx);\n  vec3 coly = h2rgb(hy+0.618);\n#if defined CHECKERBOARD\n  float k = z.x*z.y;\n  vec3 col = mix(colx,coly, smoothstep(-px,px,sign(k)*min(abs(z.x),abs(z.y)))); // Checkerboard\n#else  \n  vec3 col = mix(coly,colx, smoothstep(-px,px,d-0.15)); // Concentric\n#endif\n  col *= 1.0-smoothstep(-px,px,d-0.4);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}