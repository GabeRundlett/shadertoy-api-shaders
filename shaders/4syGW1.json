{
    "Shader": {
        "info": {
            "date": "1454167020",
            "description": "This probably has another name but could it be better than \"Citrus Rat\"?",
            "flags": 40,
            "hasliked": 0,
            "id": "4syGW1",
            "likes": 7,
            "name": "Citrus Rat Traversal",
            "published": 3,
            "tags": [
                "traversal",
                "search"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 1145
        },
        "renderpass": [
            {
                "code": "//Citrus Rat Traversal by eiffie\n//The impatient citrus rat wants to get to the orange as quickly as possible but it\n//doesn't have the intelligence to plan a route or remember where it has been past\n//the last branch. How does it find the orange every time and often in the\n//shortest time?\n\n//1. Start going up.\n//2. If going up take the branch that seems to point towards the orange (local min)\n//3. If it gets too far away go back down.\n//4. If going down you come to a branch look to see which way you came down.\n//   a) If you came down from the direction of the orange take the opposite branch up.\n//   b) If not keep going down.\n\n//Even though the citrus rat doesn't need to remember his moves I still had to use\n//a stack... I hate rats.\n\n//Actually this search method although not optimal does work on any problem where\n//you make decisions that can be ranked best to worst. Those solutions\n//that are local minimums are reached quickly, others are reached eventually.\n\n//I tried it on the parametric curve from iq and it took 100 touchs compared\n//to 35 for a march with \"fudging\" so it is nothing magical.\n//https://www.shadertoy.com/view/MsKGDz\n\n//v2 Improved the logic (not the rat's, my own)\n\n#define DEPTH 6.\n#define MIN_DIST 0.01\n#define load(a) texture(iChannel0,(vec2(a,0.0)+0.5)/iResolution.xy)\n\nfloat IDX,DONE;//index and branch done bit stacks for ease\nvoid clear(){IDX=1.;DONE=0.;}//to get a usable index number start at 1\nbool push(bool bLeft, bool bDone){\n\tIDX=IDX*2.0+(bLeft?1.0:0.0);\n\tDONE=DONE*2.0+(bDone?1.0:0.0);\n\treturn IDX>pow(2.0,DEPTH)-0.5;\n}\nvoid pop(out bool bLeft, out bool bDone){\n\tIDX/=2.0;bLeft=(fract(IDX)>0.0);IDX=floor(IDX);\n\tDONE/=2.0;bDone=(fract(DONE)>0.0 || IDX<0.5);DONE=floor(DONE);\n}\n\n//tree config\nfloat scl1,scl2,BO;\nmat2 mx1,mx2;\n\nvoid setup(){\n\tvec4 st=load(0);\n\tscl1=st.z;scl2=st.w;\n\tBO=1.0/(min(scl1,scl2)-1.0);BO*=BO;\n\tmx1=mat2(cos(st.x),sin(st.x),-sin(st.x),cos(st.x));\n\tmx2=mat2(cos(st.y),sin(st.y),-sin(st.y),cos(st.y));\n}\n\n//do transformations with each push/pop, scale,rot space and offset by constant \nbool Push(inout vec3 p, bool bLeft, bool bDone){\n\tif(bLeft){p*=scl1;p.xy=p.xy*mx1;}\n\telse {p*=scl2;p.xy=mx2*p.xy;}\n\tp.y-=1.0;\n\treturn push(bLeft, bDone);\n}\nvoid Pop(inout vec3 p, out bool bLeft, out bool bDone){//reverse transform\n\tpop(bLeft, bDone);\n\tp.y+=1.0;\n\tif(bLeft){p.xy=mx1*p.xy;p/=scl1;}\n\telse {p.xy=p.xy*mx2;p/=scl2;}\n}\n\nfloat Branch(vec3 p){return length(vec3(p.x,p.y-clamp(p.y,-1.0,0.0),p.z))-0.05+p.y*0.025;}\n\nfloat Tree(vec2 p0){\n\tvec3 p=vec3(p0,1.0);//p.z is scale\n\tclear();\n\t\n\t//these two control the rats behavior\n\tbool bLeft;//should the rat use the left branch?\n\tbool bDown=false;//is the rat ascending?\t\n\tfloat dm=Branch(vec3(p.xy,0.0)); //minimum distance to branchs\n\tfor(int i=0;i<99;i++){\n        if(dm<MIN_DIST || IDX<0.5)break;//we hit the surface or ran out of tree\n\t\tif(bDown){\n\t\t\tPop(p,bLeft,bDown); //drop down a level\n\t\t\tif(bDown)continue; //if this level is also done keep popping\n\t\t\tbDown=true; bLeft=!bLeft;//the rat came down so go up wrong side\n\t\t}\n\t\tbDown=Push(p,bLeft,bDown); //move up a branch and see if we hit the end\n\t\tdm=min(Branch(vec3(p.xy,0.0))/p.z,dm);//save nearest length to branch for drawing\n\t\tbLeft=(p.x<0.0); //find the best direction\n\t\tif(dot(p.xy,p.xy)>BO)bDown=true;//this branch is out of range so back down \n\t}\n\treturn dm;\n}\n\nvec2 Rat(vec2 uv){\n\tvec4 p=load(1);\n\tp.xy+=texture(iChannel1,uv).xy*0.03;\n\treturn vec2(length(uv-p.zw)-0.05,length(uv-p.xy)-0.05);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv=4.0*(fragCoord.xy/iResolution.xy-vec2(0.5,0.4));\n\tsetup();\n\tfloat d=Tree(uv);\n\tvec2 d2=Rat(uv);\n\tvec3 col=vec3(smoothstep(0.0,0.01,d));\n\tcol=mix(vec3(0.85,0.75,0.0),col,smoothstep(0.0,0.01,d2.x));\n\tcol=mix(vec3(0.5,0.0,0.0)+texture(iChannel1,uv).rgb*0.5,col,smoothstep(0.0,0.01,d2.y));\n\tfragColor=vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Citrus Rat Traversal by eiffie (rat logic)\n\n#define DEPTH 6.0\n#define MIN_DIST 0.01\n\n#define inside(a) (abs(fragCoord.y-a.y) < 0.5 && abs(fragCoord.x-a.x) < 0.5)\n#define load(a) texture(iChannel0,(vec2(a,0.0)+0.5)/iResolution.xy)\n#define save(a,b) if(inside((vec2(a,0.0)+0.5))){fragColor=b;return;}\n\nfloat IDX,DONE;//index and branch done bit stacks for ease\nvoid clear(){IDX=1.0;DONE=0.0;}//to get a usable index number start at 1\nbool push(bool bLeft, bool bDone){\n\tIDX=IDX*2.0+(bLeft?1.0:0.0);\n\tDONE=DONE*2.0+(bDone?1.0:0.0);\n\treturn IDX>pow(2.0,DEPTH)-0.5;\n}\nvoid pop(out bool bLeft, out bool bDone){\n\tIDX/=2.0;bLeft=(fract(IDX)>0.0);IDX=floor(IDX);\n\tDONE/=2.0;bDone=(fract(DONE)>0.0 || IDX<0.5);DONE=floor(DONE);\n}\n\n//tree config\nfloat scl1,scl2,BR,randSeed;//scale, bounding radius, random seed\nmat2 mx1,mx2;//rotation mats\n\nfloat rand(){return fract(sin(randSeed++)*4321.34);}\n\nvoid setup(vec4 st){\n\tscl1=st.z;scl2=st.w;\n\tBR=1.0/(min(scl1,scl2)-1.0);\n\tmx1=mat2(cos(st.x),sin(st.x),-sin(st.x),cos(st.x));\n\tmx2=mat2(cos(st.y),sin(st.y),-sin(st.y),cos(st.y));\n}\n\nvec4 GetRandomTree(){//random angles and scales\n\treturn vec4(0.1+rand(),0.1+rand(),1.25+rand(),1.25+rand());\n}\n\n//do transformations with each push/pop, this is a direct construction (scale,rot the offset)\nbool RPush(inout vec4 p, bool bLeft, bool bDone){\n\tif(bLeft){p.zw/=scl1;p.zw=mx1*p.zw;}\n\telse {p.zw/=scl2;p.zw=p.zw*mx2;}\n\tp.xy+=p.zw;\n\treturn push(bLeft, bDone);\n}\nvoid RPop(inout vec4 p, out bool bLeft, out bool bDone){\n\tpop(bLeft, bDone);\n\tp.xy-=p.zw;\n\tif(bLeft){p.zw*=scl1;p.zw=p.zw*mx1;}\n\telse {p.zw*=scl2;p.zw=mx2*p.zw;}\n}\nvec2 GetRandomTreeNode(){\n\tvec4 p=vec4(0.0,0.0,0.0,1.0);\n\tfor(int i=0;i<int(DEPTH);i++){\n\t\tif(rand()>0.2)RPush(p,(rand()>0.5),false);\n\t}\n\treturn p.xy;\n}\nfloat Cross2(vec2 v1, vec2 v2){return v1.y*v2.x-v1.x*v2.y;}//maybe backwards?\n\nvec2 Rat(vec2 p0, float tim){\n\tvec4 p=vec4(0.0,0.0,0.0,1.0);\n\tvec2 po=p.xy;\n\tclear();\n\tfloat br=BR,mscl=min(scl1,scl2);//we have to scale the bounding radius now\n\t\n\t//these two control the rat's behavior\n\tbool bLeft=(Cross2(p.zw,p0-p.xy)<0.0);//should the rat use the left branch?\n\tbool bDown=false;//is the rat ascending?\n    bool bSkip4Ani=false;\n\t\n\tfor(int i=0;i<99;i++){//this was ripped from a non-buffered version so the whole path is rerun\n        if(float(i)>tim || IDX<0.5)break; //we have gone far enough\n        po=p.xy;\n\t\tif(bDown && !bSkip4Ani){\n\t\t\tRPop(p,bLeft,bDown); //drop down a level, quit if at trunk\n\t\t\tbr*=mscl;\n            if(!bDown){ //if this level is also done keep popping\n\t\t\t\tbDown=true;bLeft=!bLeft;//the rat came down so go up other side\n           \t\tbSkip4Ani=true;//this is just to animate the rat (why is the little f'er still jumping around?)\n            }\n            //continue; //this is messed up in ES, native it works smoothly???\n        }else{\n        \tbSkip4Ani=false;\n\t\t\tbDown=RPush(p,bLeft,bDown); //move up a branch and see if we hit the end\n\t\t\tbr/=mscl;\n\t\t\tfloat d=length(p0-p.xy);//get length to node\n\t\t\tif(d>br)bDown=true;//this branch is out of range or searched already so back down \n   \t\t    if(!bDown)bLeft=(Cross2(p.zw,p0-p.xy)<0.0);\n        }\n\t}\n\treturn mix(po,p.xy,fract(tim));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(fragCoord.y>1.0 || fragCoord.x>3.0)discard;\n\tvec2 po=vec2(1.0);\n\tvec4 st=vec4(1.0,iTime,0.0,0.0); //state of rat, x=found,starttime\n\tvec4 ts=vec4(0.0);\n\tif(iFrame>0){\n\t\tts=load(0);\n\t\tpo=load(1).zw;\n\t\tst=load(2);\n\t}\n\tsetup(ts);\n\tif(st.x>0.0){\n\t\tst.x=0.0;\n\t\tst.y=iTime;\n\t\trandSeed=fract(iTime+iDate.w);\n\t\tts=GetRandomTree();\n\t\tsetup(ts);\n\t\tpo=GetRandomTreeNode();\n\t}\n    float tim=(iTime-st.y)*2.0;\n\tvec2 p=Rat(po,tim);\n\tif(length(p-po)<0.1 || tim>100.0){//the rat found the orange so new tree\n\t\tst.x=1.0;\n\t}\n\tsave(0,ts);//tree state\n\tsave(1,vec4(p,po));//position of rat, orange\n\tsave(2,st);//demo state\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159\n#define bps 6.0\nfloat nofs(float n){//the song's \"random\" ring\n    n=mod(n,8.0);\n    if(n<1.0)return 0.0;\n    if(n<2.0)return 2.0;\n    if(n<3.0)return 4.0;\n    if(n<4.0)return 6.0;\n    if(n<5.0)return 10.0;\n    if(n<6.0)return 8.0;\n    if(n<7.0)return 5.0;\n    return 0.0;\n}\n\nfloat scale(float note){//throws out dissonant tones\n    float n2=mod(note,12.0);\n    if((n2==1.0)||(n2==4.0)||(n2==6.0)||(n2==9.0)||(n2==11.0))note=-100.0;//minor\n\tn2=mod(note,24.0);\n\t//if((n2==1.0)||(n2==3.0)||(n2==6.0)||(n2==8.0)||(n2==10.0))note=-100.0;//major\n    \n\tif((n2==2.0)||(n2==8.0)||(n2==12.0)||(n2==18.0)||(n2==22.0))note=-100.0;//minor\n\t//if((n2==1.0)||(n2==4.0)||(n2==5.0)||(n2==9.0)||(n2==10.0))note=-100.0;//hungarian minor\n\t//if(note>96)note=96.0+n2;\n\treturn note;\n}\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 24.0):0.0;}\nfloat ntof2(float note){//note frequencies from wikipedia\n\tif(note<12.0)return 0.0;\n\tfloat octave=floor((note+0.5)/12.0)-5.0;\n\tnote=mod(note,12.0);\n\tfloat nt=493.88;//b\n \tif(note<0.5)nt=261.63;//c\n\telse if(note<1.5)nt=277.18;//c#\n\telse if(note<2.5)nt=293.66;//d\n  else if(note<3.5)nt=311.13;//d#\n  else if(note<4.5)nt=329.63;//e\n  else if(note<5.5)nt=349.23;//f\n  else if(note<6.5)nt=369.99;//f#\n  else if(note<7.5)nt=392.0;//g\n  else if(note<8.5)nt=415.30;//g#\n  else if(note<9.5)nt=440.0;//a\n  else if(note<10.5)nt=466.16;//a#\n\treturn nt*pow(2.0,octave);\n}\n\nfloat Saw(float t,float s){s*=0.5;return smoothstep(0.0,s,fract(t))*smoothstep(1.0,s,fract(t))*2.0-1.0;}\nfloat Sin(float t){return sin(t*PI);}\nfloat Square(float t,float s){s*=0.25;return smoothstep(0.25-s,0.25+s,fract(t))*smoothstep(0.75+s,0.75-s,fract(t))*2.0-1.0;}\nfloat Env(float t,float s){s*=0.5;return smoothstep(0.0,s,t)*smoothstep(1.0,s,t);}\nfloat Env(float t,float s,float e){return smoothstep(0.0,s,t)*smoothstep(e,s,t);}\nfloat rand(float t){return fract(sin(mod(t,4321.123)*4321.123)*4321.123);}\nfloat noise(float t){float f=fract(t);t=floor(t);return mix(rand(t),rand(t+1.0),f);}\nfloat snoise(float t){float f=fract(t);t=floor(t);return mix(rand(t),rand(t+1.0),f*f*(3.0-2.0*f));}\n\nfloat tamb(float t, float o, float n){\n\tfloat bt=fract(fract(t-o)*1.5);\n\tfloat f=t*3500.0+bt*75.0*n-noise(bt*75.0*(1.0-0.9*bt))*7.0;\n\tfloat a2=Square(f,bt);\n\treturn a2*Env(bt*(2.0+2.0*n),0.01)*Sin(1.0/(0.02+2.0*bt*bt));\n}\nfloat flute(float bt,float t,float f){\n\tif(f<12.0)return 0.0;\n\tfloat e=Env(bt,0.1,0.5),m=(1.0-e)*sin(t*40.0)*0.08;\n\treturn Env(bt,0.4)*(snoise(t*1000.0)*e*0.15+m+0.5)*Square(t*f+m,0.3+bt*0.5);\n}\nfloat strings(float bt,float t,float f){\n\tif(f<12.0)return 0.0;\n\tfloat e=Env(bt,0.1,0.5),m=(1.0-e)*sin(t*50.0)*0.0001*f;\n\treturn Env(bt,0.5)*(m+0.5)*Saw(t*f+m,0.1+bt*0.9);\n}\nvec2 mainSound( in int samp,float time){\n\tfloat tim=time*bps;\n\tfloat b=floor(tim);\n\tfloat n0=nofs(b*0.0625),n1=n0+nofs(b*0.25),n2=n1+nofs(b);\n\tfloat bt=fract(tim);\n\tn0=scale(n0+32.0);if(n0<1.0)n0=scale(nofs(b*0.0625)+33.0);//keep base going\n\tfloat a=strings(fract(tim*0.25),time,ntof(n0))*2.0;\n\ta+=strings(fract(tim*0.5),time,ntof(scale(n1+72.0)))*0.3;\n\ta+=strings(fract(tim*0.5),time,ntof(scale(n1+75.0)))*0.1;\n\ta+=strings(fract(tim*0.5),time,ntof(scale(n1+79.0)))*0.2;\n\ta+=flute(fract(tim),time,ntof(scale(n2+60.0)));\n\ta+=tamb(time*3.0,0.1,rand(floor(mod(time,180.0))))*0.3;\n\ta=clamp(a*0.25,-1.0,1.0);\n\treturn vec2(a);\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}