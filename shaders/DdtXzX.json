{
    "Shader": {
        "info": {
            "date": "1680180634",
            "description": "The (A,B)-duoprism. You can change A and B.\n\nThe [b]three.js[/b] version: [url=https://laustep.github.io/stlahblog/frames/threejs_duoprismAB.html]duoprism[/url] (click & drag).",
            "flags": 0,
            "hasliked": 0,
            "id": "DdtXzX",
            "likes": 5,
            "name": "Duoprism",
            "published": 3,
            "tags": [
                "4d",
                "duoprism"
            ],
            "usePreview": 0,
            "username": "stla",
            "viewed": 182
        },
        "renderpass": [
            {
                "code": "const float xmin = -1.9;\nconst float xmax = 1.9;\nconst float ymin = -2.0;\nconst float ymax = 2.0;\nconst float CRADIUS = 0.15;  // edges radius\nconst float SRADIUS = 0.25;  // spheres radius\nconst int RTYPE = 1; // type of the 4D rotation\nconst int A = 4;\nconst int B = 4;\nconst float PI = 3.14159265358979324;\n\n// duoprism vertices ----------------------------------------------------------\nvec4[A*B] Vertices() {\n  vec4[A*B] vertices;\n  float a; float b; vec2 v1; vec2 v2;\n  int i;\n  for(i = 0; i < A; i++) {\n    a = 2.0 * PI * float(i) / float(A); \n    v1 = vec2(cos(a), sin(a));\n    for(int j = 0; j < B; j++) {\n      b = 2.0 * PI * float(j) / float(B); \n      v2 = vec2(cos(b), sin(b));\n      vertices[i+j*A] = vec4(v1, v2);\n    }\n  }\n  return vertices;\n}\n\n// duoprism edges -------------------------------------------------------------\nbool dominates(ivec2 c1, ivec2 c2) {\n  return c2[0]>c1[0] || (c2[0]==c1[0] && c2[1]>c1[1]);\n}\nint modulo(int a, int b) {\n  float af = float(a);\n  float bf = float(b);\n  return int(mod(mod(af, bf) + bf, bf));\n}\nbool Edges(out ivec2 edges_source[2*A*B], out ivec2 edges_target[2*A*B]) {\n  int counter = 0;\n  ivec2 candidate;\n  for(int i = 0; i < A; i++) {\n    for(int j = 0; j < B; j++) {\n      ivec2 c1 = ivec2(i, j);\n      candidate = ivec2(i, modulo(j-1, B));\n      if(dominates(c1, candidate)) {\n        edges_source[counter] = c1;\n        edges_target[counter] = candidate;\n        counter++;\n      }\n      candidate = ivec2(i, modulo(j+1, B));\n      if(dominates(c1, candidate)) {\n        edges_source[counter] = c1;\n        edges_target[counter] = candidate;\n        counter++;\n      }\n      candidate = ivec2(modulo(i-1, A), j);\n      if(dominates(c1, candidate)) {\n        edges_source[counter] = c1;\n        edges_target[counter] = candidate;\n        counter++;\n      }\n      candidate = ivec2(modulo(i+1, A), j);\n      if(dominates(c1, candidate)) {\n        edges_source[counter] = c1;\n        edges_target[counter] = candidate;\n        counter++;\n      }\n    }\n  }\n  return 0==0;\n}\n\n\n// ROTATIONS 4D ---------------------------------------------------------------\n//// rotation around the plane spanned by 'axis1' and 'axis2'\nvec4 rotation4D(vec4 axis1, vec4 axis2, float theta, vec4 v) {\n  axis1 = normalize(axis1);\n  axis2 = normalize(axis2);\n  float vx = dot(v, axis1);\n  float vy = dot(v, axis2);\n  float coef1 = vx * cos(theta) - vy * sin(theta);\n  float coef2 = vy * cos(theta) + vx * sin(theta);\n  vec4 pvector = vx*axis1 + vy*axis2; \n  return coef1*axis1 + coef2*axis2 + (v-pvector);\n}\nconst vec4 AX1 = vec4(0, 0, 1, 1);\nconst vec4 AX2 = vec4(1, 1, 0, 0);\n//// right-isoclinic rotation\nvec4 rotation4DR(vec4 v, float theta, float phi, float xi) {\n  float a = cos(xi);\n  float b = sin(theta)*cos(phi)*sin(xi);\n  float c = sin(theta)*sin(phi)*sin(xi);\n  float d = cos(theta)*sin(xi);\n  float p = v.x, q = v.y, r = v.z, s = v.w;\n  return vec4(\n    a*p - b*q - c*r - d*s,\n    a*q + b*p + c*s - d*r,\n    a*r - b*s + c*p + d*q,\n    a*s + b*r - c*q + d*p\n  );\n}\nconst float THETA = PI/4.0;\nconst float PHI = PI/4.0;\n\n\n// SPHERE STUFF ---------------------------------------------------------------\n// ro is the ray origin, rd is the (normalized) ray direction, R is the radius\nvec4 iSphere(vec3 ro, vec3 rd, float R) {\n  float b = 2.0 * dot(ro, rd);\n  float c = dot(ro, ro) - R * R; \n  float delta = b * b - 4.0 * c;\n  if(delta < 0.0) { return vec4(-1.0); } // No intersection\n  float t = (-b - sqrt(delta)) / 2.0;    // Intersection occurred\n  vec3 nrml = (ro + t*rd) / R;\n  return vec4(t, nrml);\n}\n\n// CONE STUFF -----------------------------------------------------------------\n// ro is the ray origin, rd is the ray direction, \n// pa and pb are the centers of the caps, ra and rb are the radii\nfloat dot2(vec3 v) { return dot(v,v); }\nvec4 iCappedCone(\n  vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra, float rb, bool caps\n) {\n  vec3 ba = pb - pa;\n  vec3 oa = ro - pa;\n  vec3 ob = ro - pb;\n  float m0 = dot(ba,ba);\n  float m1 = dot(oa,ba);\n  float m2 = dot(ob,ba); \n  float m3 = dot(rd,ba);\n\n  if(caps) {\n    if(m1 < 0.0) {\n      if(dot2(oa*m3-rd*m1) < (ra*ra*m3*m3)) {\n        return vec4(-m1/m3, -ba*inversesqrt(m0));\n      }\n    } else if(m2 > 0.0) {\n      if(dot2(ob*m3-rd*m2) < (rb*rb*m3*m3)) {\n        return vec4(-m2/m3, ba*inversesqrt(m0));\n      }\n    }\n  }\n  \n  float rr = ra - rb;\n  float hy = m0 + rr*rr;\n  float m4 = dot(rd,oa);\n  float m5 = dot(oa,oa);\n  \n  float k2 = m0*m0 - m3*m3*hy;\n  float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*rr*m3;\n  float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n  \n  float h = k1*k1 - k2*k0;\n  if(h < 0.0) return vec4(-1.0);\n\n  float t = (-k1-sqrt(h))/k2;\n  float y = m1 + t*m3;\n  if(y > 0.0 && y < m0) {\n    return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n  }\n  \n  return vec4(-1.0);\n}\n\n// ----------------------------------------------------------------------------\n\n// Modified stereographic projection\n//  https://laustep.github.io/stlahblog/posts/ModifiedStereographicProjection.html\nvec3 stereog(vec4 q) {\n  return acos(q.w/sqrt(2.0)) * q.xyz/sqrt(2.0-q.w*q.w);\n}\n\n// get the intersection value of t and the normal -----------------------------\n// ro is the ray origin, rd is the ray direction \nvec4 getTnorm(vec3 ro, vec3 rd) {\n  vec4[A*B] vertices = Vertices();\n  ivec2 edges_source[2*A*B]; ivec2 edges_target[2*A*B];\n  bool nothing = Edges(edges_source, edges_target);\n\n  float t = 1.0e20; \n  vec4 OUTPUT = vec4(t);\n  vec4 tnorm;\n  float xi = iTime;\n  for(int k = 0; k < 2*A*B; k++) {\n    ivec2 ei = edges_source[k];\n    ivec2 ej = edges_target[k];\n    vec4 vi4 = vertices[ei[0] + ei[1]*A]; \n    vec4 vj4 = vertices[ej[0] + ej[1]*A]; \n    vec3 vi = RTYPE == 0 ? \n      stereog(rotation4D(AX1, AX2, xi, vi4)) : \n      stereog(rotation4DR(vi4, THETA, PHI, xi)); \n    vec3 vj = RTYPE == 0 ? \n      stereog(rotation4D(AX1, AX2, xi, vj4)) :\n      stereog(rotation4DR(vj4, THETA, PHI, xi)); \n    tnorm = iCappedCone(ro, rd, vi, vj, CRADIUS, CRADIUS, false);\n    if(tnorm.x > 0.0){\n      OUTPUT = tnorm.x < t ? tnorm : OUTPUT;\n      t = min(t, tnorm.x);\n    }\n  }\n  float t_cylinder = t;\n  for(int k = 0; k < A*B; k++){\n    vec3 vk = RTYPE == 0 ? \n      stereog(rotation4D(AX1, AX2, xi, vertices[k])) : \n      stereog(rotation4DR(vertices[k], THETA, PHI, xi)); \n    tnorm = iSphere(ro - vk, rd, SRADIUS);\n    if(tnorm.x > 0.0) {\n      OUTPUT = tnorm.x < t ? tnorm : OUTPUT;\n      t = min(t, tnorm.x);\n    }\n  }\n  return OUTPUT;\n}\n\n// ----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspectRatio = iResolution.x/iResolution.y;\n  vec2 uv = vec2(\n    ((xmax - xmin) * fragCoord.x/iResolution.x + xmin) * aspectRatio, \n    (ymax - ymin) * fragCoord.y/iResolution.y + ymin\n  );\n\n  // Cast a ray out from the eye position into the scene\n  vec3 ro = vec3(uv, 5); \n  vec3 rd = normalize(vec3(uv, -4));\n\n  // Default color if we don't intersect with anything\n  vec3 rayColor = vec3(54.0, 57.0, 64.0) / 255.0;\n  // Direction the lighting is coming from\n  vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n  // Ambient light color\n  vec3 ambient = vec3(0.05, 0.1, 0.1);\n  // See if the ray intersects with any objects.\n  vec3 objColor = vec3(0.0, 1.0, 0.0);\n  vec4 tnorm = getTnorm(ro, rd);\n  if(!(tnorm.x == 1.0e20)) {\n    vec3 nrml = tnorm.yzw;\n    vec3 toEye = -rd;\n    vec3 r_m = normalize(-reflect(lightDir, nrml));\n    float specular = 0.72 * pow(max(dot(r_m, toEye), 0.0), 8.0);\n    float diffuse = max(dot(nrml, lightDir), 0.0); // diffuse factor\n    rayColor = objColor * (diffuse + ambient) + specular;\n  }\n  fragColor.rgb = rayColor;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}