{
    "Shader": {
        "info": {
            "date": "1573152879",
            "description": "Based upon: https://www.shadertoy.com/view/XdlSD4\n\nI always liked mandelbox_ryu made by EvilRyu\nWas tinkering a bit with the code and came up with this which at least I liked.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3ddSDs",
            "likes": 29,
            "name": "bonemandel",
            "published": 3,
            "tags": [
                "bonemandelbox"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 924
        },
        "renderpass": [
            {
                "code": "// Based upon: https://www.shadertoy.com/view/XdlSD4\n\n// I always liked mandelbox_ryu made by EvilRyu\n// Was tinkering a bit with the code and came up with this which at least I liked.\n\n// Uses very simple occlusion based lighting which made it look more like a structure\n// of bones than my other futile lighting attemps.\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst vec3  folding_limit = vec3(1.0);\nconst float scale         = -2.8;\nconst int   max_iter      = 120;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvec3 pmin(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid box_fold(float k, inout vec3 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    const float k = 0.05;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(k/dr, z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));        \n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nfloat df(vec3 p) { \n    float d1 = mb(p);\n    return d1; \n} \n\n\nfloat hash(vec2 p)  {\n  float h = dot(p,vec2(127.1,311.7));   \n  return fract(sin(h)*43758.5453123);\n}\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n    float res;\n    float r = hash(ro.xy + ro.xz + ro.yz);\n    float t = 10.0*mix(0.01, 0.02, r);\n    iter = max_iter;\n    \n    for(int i = 0; i < max_iter; ++i) {\n        vec3 p = ro + rd * t;\n        res = df(p);\n        if(res < 0.001 * t || res > 20.) {\n            iter = i;\n            break;\n        }\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n    vec3 n = normal(p);\n    float fake = float(iter)/float(max_iter);\n    float fakeAmb = exp(-fake*fake*9.0);\n    float amb = ambientOcclusion(p, n);\n\n    vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n    return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n    col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n    vec2 q=fragCoord.xy/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x/iResolution.y; \n    \n    float stime=sin(iTime*0.1); \n    float ctime=cos(iTime*0.1); \n\n    vec3 ta=vec3(0.0,0.0,0.0); \n    vec3 ro= 0.63*vec3(3.0*stime,2.0*ctime,5.0+1.0*stime);\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n    vec3 col = bg;\n\n    vec3 p=ro; \n\n    int iter = 0;\n  \n    float t = intersect(ro, rd, iter);\n    \n    if(t > -0.5) {\n        p = ro + t * rd;\n        col = lighting(p, rd, iter); \n        col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n    } \n    \n\n    col=post(col, q);\n    fragColor=vec4(col.x,col.y,col.z,1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}