{
    "Shader": {
        "info": {
            "date": "1537470086",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "llyyDG",
            "likes": 24,
            "name": "Dot Motion",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "yx",
            "viewed": 1037
        },
        "renderpass": [
            {
                "code": "#define PI acos(-1.)\nconst float RADIUS = .1;\nconst float SIZE = 7.;\nconst float BLURSTEPS = 30.;\nconst float SPEED = 1.5;\nconst bool SQUARE = false;\nconst bool RING = true;\nconst float RINGRADIUS = .2;\nconst float RINGTHICKNESS = .025;\nconst bool SMOOTH = true;\nconst bool RIPPLE = false;\nconst float RIPPLESCALE = .2;\n\nvec2 rotate(vec2 p,float a)\n{\n    return cos(a)*p+sin(a)*vec2(-p.y,p.x);\n}\n\nfloat noise(float x)\n{\n    return fract(x*7.3737);\n}\n\nfloat tick(float t)\n{\n    if (SMOOTH)\n    {\n    \t// multiple smoothsteps to get a more snappy motion\n    \tt = smoothstep(0.,1.,t);\n    \tt = smoothstep(0.,1.,t);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= SIZE;\n    \n    float time = iTime * SPEED;\n    \n    if (RIPPLE)\n    {\n    \ttime -= length(uv)*RIPPLESCALE;\n    }\n\n    float color = 0.;\n    \n    vec2 baseUV = uv;\n    for (float i = 0.; i < BLURSTEPS; ++i)\n    {\n        // offset time by a fraction of a frame\n        time += (SPEED/BLURSTEPS)/60.;\n        \n        uv = baseUV;\n        vec2 cell = floor(uv+.5);\n\n        float t = tick(fract(time));\n\n        float mode = noise(floor(time))*7.;\n        float dir = step(.01,mod(mode,.02))*2.-1.;\n        t *= dir;\n        \n        if (mode < 1.)\n        {\n            // vertical shear\n            uv.y += cell.x * t;\n        }\n        else if (mode < 2.)\n        {\n            // horizontal shear\n            uv.x += cell.y * t;\n        }\n        else if (mode < 3.)\n        {\n            // rotate\n            uv = rotate(uv, t*PI*.5);\n        }\n        else if (mode < 4.)\n        {\n            // vertical interleaving\n            uv.y += (mod(cell.x,2.)*2.-1.) * t;\n        }\n        else if (mode < 5.)\n        {\n            // horizontal interleaving\n            uv.x += (mod(cell.y,2.)*2.-1.) * t;\n        }\n        else if (mode < 6.)\n        {\n            // vertical translation\n\t\t\tuv.y += t;\n        }\n        else if (mode < 7.)\n        {\n            // horizontal translation\n\t\t\tuv.x += t;\n        }\n\n        // modulo space to get the grid\n        uv = fract(uv+.5)-.5;\n\n        // signed distance\n        float d = 0.;\n        if (RING)\n        {\n            d = RINGTHICKNESS-abs(length(uv)-RINGRADIUS);\n        }\n        else\n        {\n\t\t\td = RADIUS-length(uv);\n        }\n        \n        // smoothed edge\n        color += smoothstep(.0,2.*SIZE/iResolution.y,d);\n    }\n    \n    // divide to account for multiple blur samples\n    color /= BLURSTEPS;\n    \n    // gamma correction\n    color = pow(color, .45);\n    \n    // cull the sides with a soft falloff\n    if (SQUARE)\n    {\n    \tcolor *= smoothstep(SIZE*.5+.25,SIZE*.5-.25,max(baseUV.x,-baseUV.x));\n    }\n    \n    fragColor = vec4(color);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}