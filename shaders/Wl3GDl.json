{
    "Shader": {
        "info": {
            "date": "1577904719",
            "description": "swirly. \nthere's a bunch of stuff i'd like to change, but at least it runs :D",
            "flags": 32,
            "hasliked": 0,
            "id": "Wl3GDl",
            "likes": 14,
            "name": "Day 14",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 curr = texture(iChannel0, uv);\n    fragColor = curr;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nvec2 v=vec2(0.,1.);\n\n\n#define iTime (iTime + 10.)\n#define fov 0.3\n#define SIZE 0.0\n\n\n#define mx (20.*iMouse.x/iResolution.y)\n#define my (20.*iMouse.y/iResolution.y)\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define dmin(a,b) a.x < b.x ? a : b\n#define pmod(a,x) mod(a,x) - 0.5*x\n#define rot(x) mat2(cos(x),-sin(x),sin(x), cos(x))\n\nfloat random(float st){\n\treturn fract(sin(st*345.4124)*2124.6254);\n}\nfloat rand(float t) {\n\treturn fract(sin(t*3211251.325235325));\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\nvec3 pO;\nfloat sdThingieB(vec3 p){\n    p = abs(p);\n    \n    p -= vec3(0.5,0.5,0.8);\n    \n    float d = max(p.x, max(p.y, p.z));\n    d = max(d, dot(p.xz + 0.26, normalize(vec2(1))));\n    d = max(d, dot(p.yz + 0.25, normalize(vec2(1))));\t\n\t\n    \n    return d;\n}\n\nfloat sdPolyhedron(vec3 p){\n    vec3 z = p;\n    p = abs(p);\n    if (iTime > iTime*pi*6.){\n        for(int i = 0; i< 3; i++){\n            p = abs(p);\n            p.xz *= rot(-0.0 -0.05*sin(iTime)*0.05);\n            p.xy *= rot(0.0 + sin(iTime)*0.05);\n        }\n    }\n    \n    p.x /= 0.4; // wat\n    //0.5/x = 0.2\n    p -= vec3(0.5,0.5,0.5);\n    \n    //p.y -= 0.2;\n    float d = max(p.x, max(p.y, p.z));\n    d = max(d, dot(p.xz + 0.26, normalize(vec2(1))));\n    d = max(d, dot(p.yz + 0.25, normalize(vec2(1))));\n    \n    //d = max(d, -abs(p.y) + 0.09);\n    float wall = 0.15;\n    d = max(d, -abs(pO.y + 0.5) + wall);\n    d = max(d, pO.y - 0.5 - wall);\n    //d = max(d, pO.y  + 0.1);\n    return d;\n}\nfloat mpow(float a, float b) {\n  for(float i = 0.; i < b; i++) {\n      a = a * a;\n  }\n  return a;\n}\nvec2 map(vec3 p) {\n\tvec2 d = vec2(10e8);\n\t\n\n    \n    float repsX = 8.;\n    float repsY = 8.;\n    float repsXIn = pi/repsX;\n    float repsYIn = 1.; // wat\n    \n    float yID = floor(length(p.xz)/repsYIn);\n    float xID = floor(atan(p.x,p.z)/repsXIn);\n    \n    p.y *= 0.8 + SIZE;\n    vec3 z = vec3(atan(p.x,p.z),length(p.xz),p.y);\n\n    //z.x *= 0.4;\n\n\t#define tBetweenPhases 1.\n\t#define cntPhases 3.\n    \n    float T = iTime - yID*0.2 + sin(iTime)*0.1;\n    \n    float rA = random(floor(T/tBetweenPhases));\n    float rB = random(floor(T/tBetweenPhases) + 215.56);\n    \n    rA = max(floor(rA*cntPhases - 0.001),0.);\n    rB = max(floor(rB*cntPhases - 0.002),0.);\n    \n\n    float r = random(rB*10.);\n    r = sin(r*tau);\n    float rSign = sign(r);\n    r = rSign * max(r, 0.5);\n    \n    \n    //rA = 3.;\n    //rB = 0.;\n    if (rA == 2.) {\n     \tz.x += -rSign*mpow( sin((fract(T/tBetweenPhases))*r*pi )*.4 , 0.6 )*17.;\n    }\n    \n    \n    if (rA == 0.) {\n        float m =  rSign*mpow( sin((fract(T/tBetweenPhases))*r )*0.8 , 3. );\n        float mB =  rSign*mpow( sin((fract(T/tBetweenPhases))*pi*1. )*0.8 , 1. );\n     \tz.x += m*20.;\n        \n        if (rB == 0.) {\n            //z.yz *= rot(0.4);\n        \tz.yz *= rot(pi*mB*0.25);\n        }\n    \t//z.y *= 0.5;\n    }\n\n    \n    pO = vec3(z.y,pmod(z.y,repsYIn), p.y);\n    if(rB == 0.) {\n        z.z += mpow( sin((fract(T/tBetweenPhases))*pi*1. )*1. , 3. );\n     \t//z.z *=  1. + mpow( sin((fract(T/tBetweenPhases))*pi*2. )*0.8 , 2. )*1.;\n    }    \n        \n        \n    \n    if (!(yID < 1.))  {\n        z.x = pmod(z.x,repsXIn);\n        z.y = pmod(z.y,repsYIn);\n    }\n    \n    if(rB == 2.) {\n     \tz.z += mpow( sin((fract(T/tBetweenPhases))*pi*1. )*0.2 , 0.9 );\n    }\n\t\n    if(rB == 3.){\n        float m = mpow( sin((fract(T/tBetweenPhases))*pi*1. )*1. , 1.5 );\n        z.yx *= rot(-m*4.);\n    }\n    \n    \n    if (rA == 1. && rB <= 1. && !(yID < 1.)) {\n        float m = mpow( sin((fract(T/tBetweenPhases))*pi*1. )*1. , 0.7 );\n        \n\t\tz = vec3(atan(p.x,p.z),length(p.xz),p.y);\n        \n        z.x = pmod(z.x,repsXIn);\n        z.y = pmod(z.y,repsYIn);\n        \n        z.z += 0.1*m;\n        z.y -= 0.1*m;\n        //z.zy *= rot(m*0.5);\n        z.yx *= rot(-m*4.*r);\n        //z.yz *= rot(-m*1.*r);\n    }\n    if (yID == 0.) {\n        pO = vec3(z.y,pmod(z.y,repsYIn), p.y);\n        //return vec2(sdThingieB(p));\n        return vec2(0.1);\n    }\n    \n    if (yID <= 1.) {\n        z.z *= 1.7;\n        z.z += 0.1;\n    }     \n\n    //z.y = pmod(z.y,pi/repsY);\n    \n    //z.z += sin(yID + iTime*(0.8 + sin(iTime)*0.1))*0.5;\n    z.z += sin(yID*0.8 + iTime*(0.6 ))*0.5;\n    \n    //z.y *= 1.;\n    \n    z.z += length(p.xz)*(0. + sin(iTime*0.3)*0.27 ); // incline\n    \n\t\n    \n    //z.x *= 1. + length(p.xz); // resize A\n    //z.y *= 1. - length(p.xz)*0.6; // resize A\n    //z.z *= exp( - length(p.xz)*0.1); // resize A\n    \n    d = dmin(d, vec2(sdPolyhedron(z - vec3(0.,0.,0)) , 1.));\n\n\treturn d;\n}\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001,0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\n\n\n// soft shadows from inigo quilez, who got them from somewhere else\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; \n    \n    for( int i=0; i<72; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n\n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#define spectra(x,t) (0.5 + sin(vec3(0.5,0.9,0.4)*x + t))\nvec4 render(vec2 uv) {\n\tvec3 col = vec3(0);\n\n\tvec3 ro = vec3(0. + sin(iTime*0.4)*20.,29.+ sin(iTime)*2.,0. - 40. - sin(iTime*0.2)*10. );\n    vec3 lookAt = vec3(0,0.,0);\n\tvec3 rd = getRd(ro, lookAt, uv);\n    \n    float rand=random(uv.x + 2. + uv.y);\t\t\t\t// thx nusan for dither\n    float dither = 0.2+0.01*rand;\n    //dither = 1.;\n    \n    vec3 p = ro; float t = 0.;\n    for(int i = 0; i < 300; i++){\n    \tvec2 d = map(p)*dither;\n    \t\n        if(d.x < 0.005){\n            \n            vec3 lPos = vec3(1,5,0.);\n            vec3 lDir = normalize(lPos - p);\n            //vec3 lDir = normalize(-vec3(1,1,0));\n        \tvec3 n = getNormal(p);\n            vec3 h = normalize(lDir - rd);\n            \n            float diff = max(dot(n, lDir),0.);\n            float fres = pow(max(dot(n, -rd),0.),6.);\n            float spec = max(dot(n, h),0.);\n            float shad = calcSoftshadow(p, lDir, 0.01, 1.0, 0 );\n            float att  = 1./(length(lPos - p)*length(lPos - p));\n            \n            \n            //att = 0.02;\n            col += mix(diff*1., fres* spec, 0.1);\n            \n            col *= shad;\n            col *= att;\n            \n            //col += 1.;\n            break;\n        }\n    \n        if(t > 100.){\n            //col += 1.;\n        \tbreak;\n        }\n        \n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    col *= 15.;\n    \n    \n    col *= vec3(1.5,1.1,1.02);\n    col = pow(col, vec3(1.04,1.,1.));\n    col = pow(col, vec3(0.45));\n    \n    \n    return vec4(col, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    fragColor = render(uv);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prev = texture(iChannel1, uv);\n    vec4 curr = texture(iChannel0, uv);\n    \n    \n    fragColor = mix(prev,curr,0.7);\n    \n    \n    //fragColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}