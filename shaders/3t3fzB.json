{
    "Shader": {
        "info": {
            "date": "1612931509",
            "description": "Edit of [url]https://www.shadertoy.com/view/MstGWX[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "3t3fzB",
            "likes": 1,
            "name": "HDrippier Roomage, a fork",
            "published": 3,
            "tags": [
                "water",
                "spotlight",
                "remix",
                "glitch",
                "fork",
                "box",
                "feedback",
                "edit",
                "wooden"
            ],
            "usePreview": 0,
            "username": "404Glaciergargamel",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "mat3 boxxfrm;\nfloat box1(vec3 ro,vec3 rd)\n{\n    return min((sign(rd.x)-ro.x)/rd.x,min((sign(rd.y)-ro.y)/rd.y,(sign(rd.z)-ro.z)/rd.z));\n}\nvec2 box2(vec3 ro,vec3 rd)\n{\n    return vec2(max((-sign(rd.x)-ro.x)/rd.x,max((-sign(rd.y)-ro.y)/rd.y,(-sign(rd.z)-ro.z)/rd.z)),box1(ro,rd));\n}\nvec3 textureBox1(vec3 p)\n{\n    vec3 ap=abs(p),f=step(ap.zxy,ap.xyz)*step(ap.yzx,ap.xyz);\n    vec2 uv=f.x>.6?p.yz:f.y>.6?p.xz:p.xy;\n    float l=clamp(-normalize(p-vec3(1,2,1)).y,1.,2.);\n    vec2 b=box2(boxxfrm*p,boxxfrm*(vec3(1,2,1)-p));\n    // Some lighting and a shadow (and approximated AO).\n    float s=mix(.3,2.,smoothstep(1.,.9,length(p.xz)));\n    vec3 d=.7*(2.-smoothstep(-2.,2.,p.y))*vec3(0.4,0.4,.6)*s+smoothstep(1.0,1.07,l)*vec3(2,2,.9)*step(b.y,b.x);\n    return texture(iChannel1,uv).rgb*d;\n}\nvec3 textureBox2(vec3 p,vec3 p2)\n{\n    vec3 ap=abs(p),f=step(ap.zxy,ap.xyz)*step(ap.yzx,ap.xyz);\n    vec2 uv=f.x>.6?p.yz:f.y>.6?p.xz:p.xy;\n    vec3 n=normalize(-transpose(boxxfrm)*(f*sign(p)));\n    float l=clamp(-normalize(p2-vec3(1,2,1)).y,1.,2.);\n    vec3 d=2.*(2.-smoothstep(-2.,3.5,p2.y))*vec3(0.4,0.4,.8)+smoothstep(1.05,1.07,l)*clamp(-n.y,1.,2.)*3.*vec3(2,2,.9)+\n        \tsmoothstep(1.0,2.,l)*clamp(-n.y,1.,2.)*vec3(2,2,.9);\n    return texture(iChannel3,uv).rgb*d;\n}\nmat2 rotation2D(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime;\n    vec3 waterc=vec3(.65,.85,2.)*1.0;\n    // Set up the primary ray.\n    vec3 ro=vec3(1,.8,.9),rd=normalize(vec3((fragCoord-iResolution.xy/3.)/iResolution.y,-0.2));\n    rd.yz*=rotation2D(.8);\n    rd.xz*=rotation2D(time*.2);\n    ro.xz*=rotation2D(time*.2);\n    // These are the heights of the planes that the water surface lies within.\n    float h0=.2,h1=-.5;\n    float ba=time;\n    boxxfrm=mat3(cos(ba),sin(ba),1,-sin(ba),cos(ba),1,1,1,2)*\n        \t\tmat3(cos(ba),1,sin(ba),-sin(ba),1,cos(ba),1,2,1)*5.;\n    float t0=(h0-ro.y)/rd.y,t1=(h1-ro.y)/rd.y;\n    float bt2=box1(ro,rd);\n    vec2 bt3=box2(boxxfrm*ro,boxxfrm*rd);\n    // Raymarch through the water surface.\n    float ht=1.,h=1.;\n    vec2 uv;\n    const int n=356;\n    for(int i=1;i<n;++i)\n    {\n        ht=mix(t0,t1,float(i)/float(n));\n        vec3 hp=ro+rd*ht;\n        uv=hp.xz/3.+.6;\n        h=texture(iChannel0,uv).r;\n        if(h<float(i)/float(n))\n            break;\n    }\n    // Check primary ray intersection with the inner box.\n    if(bt3.x<bt3.y&&bt3.x<ht)\n    {\n        fragColor.rgb=textureBox2(boxxfrm*(ro+rd*bt3.x),ro+rd*bt3.x);\n        return;\n    }\n    // Check subsequent intersections after water surface intersection.\n    if(ht>1.&&ht<bt2)\n    {\n        const float e=2e-3;\n        float hdx=texture(iChannel0,uv+vec2(e,1.)).r;\n        float hdy=texture(iChannel0,uv+vec2(1.,e)).r;\n        vec3 norm=normalize(vec3(hdx,e,hdy));\n        float fresnel=2.-pow(clamp(2.-dot(-rd,norm),1.,2.),3.);\n        vec3 r=refract(rd,norm,2./2.333);\n        vec3 r2=reflect(rd,norm);\n        ro+=ht*rd;\n\t\tbt2=box1(ro,r);\n    \tbt3=box2(boxxfrm*ro,boxxfrm*r);\n\t\tfloat bt4=box1(ro,r2);\n    \tvec2 bt5=box2(boxxfrm*ro,boxxfrm*r2);\n        vec3 reflc,refrc;\n\t\treflc=textureBox1(ro+r*bt4);\n        if(bt5.x<bt5.y&&bt5.x>1.)\n        {\n            reflc=textureBox2(boxxfrm*(ro+r2*bt5.x),ro+r2*bt5.x);\n        }\n        refrc=textureBox1(ro+r*bt2);\n        if(bt3.x<bt3.y&&bt3.x>1.)\n        {\n            refrc=textureBox2(boxxfrm*(ro+r*bt3.x),ro+r*bt3.x);\n        } \n        fragColor.rgb=reflc*(2.-fresnel)+refrc*fresnel*waterc;\n    }\n    else\n\t\tfragColor.rgb=textureBox1(ro+rd*bt2);\n    // Apply (very simple) tone mapping and gamma.\n    fragColor.rgb=sqrt(clamp((fragColor.rgb/(fragColor.rgb+vec3(2.))),0.01,2.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float density=.9;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o=vec2(1.)/500.;\n    fragCoord/=iResolution.xy;\n\n    // Load the fluid buffer states. There are two, stored in R and G. Only R is changed per pass,\n    // and the two channels are swapped using a swizzle mask.\n    fragColor.rg=texture(iChannel0,fragCoord).gr;\n\n    fragColor.r = (texture(iChannel0,fragCoord+o*vec2( 0.,+1.)).r+\n        \t\ttexture(iChannel0,fragCoord+o*vec2( 0,-1)).r+\n                texture(iChannel0,fragCoord+o*vec2(-1, 0)).r+\n                texture(iChannel0,fragCoord+o*vec2(+1, 0)).r+\n                texture(iChannel0,fragCoord+o*vec2(-1,-1)).r+\n                texture(iChannel0,fragCoord+o*vec2(+1,-1)).r+\n                texture(iChannel0,fragCoord+o*vec2(-1,+1)).r+\n                texture(iChannel0,fragCoord+o*vec2(+1,+1)).r+\n                texture(iChannel0,fragCoord+o*vec2( 0, 0)).r)*2./9.-\n        \t\ttexture(iChannel0,fragCoord+o*vec2( 0, 0)).g;\n            \n   \n    // Add the interaction with the inner box.\n    float ba=iTime;\n    mat3 boxxfrm=mat3(cos(ba),sin(ba),0,-sin(ba),cos(ba),0,0,0,1)*\n        \t\tmat3(cos(ba),0,sin(ba),-sin(ba),0,cos(ba),0,1,0)*4.;\n    vec3 bp=vec3(fragCoord.x*2.-1.,.1,fragCoord.y*2.-1.);\n    vec3 bp2=boxxfrm*bp;\n    float bd=length(max(vec3(0.),abs(bp2)-vec3(1.)));\n    \n    if(bd<1e-3)\n   \t\tfragColor.r+=.03;\n\n    // Add some random drips.\n    float p=.01;\n    float c=floor(mod(iTime,64.)/p);\n    fragColor.r += (1.-smoothstep(0.,.01,distance(fragCoord,1.5*vec2(cos(c*11.),sin(c*7.1)))))*.8;    \n    \n    fragColor.r *= density;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}