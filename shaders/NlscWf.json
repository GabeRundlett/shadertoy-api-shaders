{
    "Shader": {
        "info": {
            "date": "1648822766",
            "description": "Comparisons with brute force",
            "flags": 32,
            "hasliked": 0,
            "id": "NlscWf",
            "likes": 2,
            "name": "Filtered Cosine #2",
            "published": 3,
            "tags": [
                "procedural",
                "filtering",
                "cosine",
                "harmonic"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 260
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= Pre-Filtered Cosine (with a gaussian filter) \n//=======================================================\n//== Code       : https://www.shadertoy.com/view/NtlcWf\n//== Comparison : https://www.shadertoy.com/view/NlscWf\n//== Details    : https://h4w0.frama.io/pages/posts/2022-04-01-FilteredCosine.html\n//=======================================================\n//== For a box filtered cosine -> see IQ's article :\n//== https://iquilezles.org/articles/bandlimiting\n//== And in action :  https://www.shadertoy.com/view/WtScDt\n//=======================================================\n//== Author  : Arthur Cavalier\n//=======================================================\n\n\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 coords = ((2.*(fragCoord.xy)-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    vec3 origin = vec3( 0.5+3.5*cos(6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(6.0*mouse) );\n    vec3 target = vec3( 0.0, -0.8, -0.0 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Screen Ratio\n    vec2 screen = fragCoord.xy/iResolution.xy;\n    fragColor = vec4(1.);  \n    \n    \n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,3.));\n    if(hit>0.0)\n    {\n        vec3  hit_position = (origin + hit*direction);\n                       \n        vec2  x = hit_position.xz;\n        vec2  F = m_2_pi * F0 * vec2( cos(T0), sin(T0) ); \n        float harmonic = cosine(x,1.0,F);\n        \n       \n        if(screen.x<0.33)\n        {\n            harmonic = prefiltered_cosine(x,1.0,F);\n        }\n        else if(screen.x<0.66)\n        {\n            harmonic = cosine(x,1.0,F);\n        }\n        else \n        {\n            vec4 convergence = texture(iChannel0,screen);\n            vec3 result = convergence.rgb/vec3(convergence.a);  \n            harmonic = result.x;\n        }\n        \n        fragColor = vec4(vec3(harmonic),1.); \n\t}\n    \n    fragColor.rgb *= smoothstep( 0.0, 0.003, abs(screen.x-0.33) );\n    fragColor.rgb *= smoothstep( 0.0, 0.003, abs(screen.x-0.66) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Constants -----------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n// RayTracing -----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n// PRNG ----------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//-----------------------------------------------------------------------------------\n// Cosines --------------------------------------------------------------------------\n\nconst float F0 = 2.0;\nconst float T0 = m_pi_2;\n\nfloat cosine(vec2 x, float alpha, vec2 f)\n{\n    return alpha * cos(dot(x,f));\n}\n\nfloat prefiltered_cosine(vec2 x, float alpha, vec2 f)\n{\n    mat2  J = 0.5*mat2(dFdx(x),dFdy(x));\n    mat2  S = J*transpose(J);\n    return alpha * cos(dot(x,f)) * exp(-0.5*dot(f,S*f));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Brute force reference\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nfloat g_seed = 0.;\nfloat rand() { return fract(sin(g_seed++)*43758.5453123); } // dummy prng\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec2 jitter = vec2(rand(),rand());\n    \n    \n    vec2 coords = ((2.*(fragCoord.xy+jitter)-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(6.0*mouse.x), 1.0 + 2.0*mouse.y, -0.5+3.5*sin(6.0*mouse) );\n    vec3 target = vec3( 0.0, -0.8, -0.0 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(1.),1.);\n  \n    // Noise Parameters\n   \n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,3.));\n    if(hit>0.0)\n    {\n        vec3  hit_position = (origin + hit*direction);\n        \n        vec2  x = hit_position.xz;\n        vec2  F = m_2_pi * F0 * vec2( cos(T0), sin(T0) ); \n        float harmonic = cosine(x,1.0,F);\n            \n        fragColor = vec4(vec3(harmonic),1.);    \n    }\n    \n    if(iMouse.z>0.)\n        return;\n    \n    if(iFrame>0)\n           fragColor += texture(iChannel0,fragCoord.xy/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}