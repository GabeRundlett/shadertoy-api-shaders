{
    "Shader": {
        "info": {
            "date": "1532083589",
            "description": "original shader by iq https://www.shadertoy.com/view/llffWs\n, extended by ollj to focus on edge-cases (approaching 0 within calculus)\n\nmouse.y blurs and iMouse.y==0 is nonsensical in a differential context here.",
            "flags": 0,
            "hasliked": 0,
            "id": "lldyzM",
            "likes": 3,
            "name": "analytical filter kernel BoxTri",
            "published": 3,
            "tags": [
                "filter",
                "analytic",
                "kernel",
                "automaticdifferentiation"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 584
        },
        "renderpass": [
            {
                "code": "//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// https://iquilezles.org/articles/morecheckerfiltering\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}