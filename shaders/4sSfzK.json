{
    "Shader": {
        "info": {
            "date": "1501466480",
            "description": "Click on menu buttons, use controls, rotate object and learn!",
            "flags": 48,
            "hasliked": 0,
            "id": "4sSfzK",
            "likes": 600,
            "name": "[SH17C] Physically Based Shading",
            "published": 3,
            "tags": [
                "tutorial",
                "text",
                "presentation",
                "pbr",
                "gui",
                "sh17c"
            ],
            "usePreview": 1,
            "username": "knarkowicz",
            "viewed": 44376
        },
        "renderpass": [
            {
                "code": "const float MATH_PI = float(3.14159);\n\nconst float MENU_SURFACE = 0.;\nconst float MENU_METAL = 1.;\nconst float MENU_DIELECTRIC = 2.;\nconst float MENU_ROUGHNESS = 3.;\nconst float MENU_BASE_COLOR = 4.;\nconst float MENU_LIGHTING = 5.;\nconst float MENU_DIFFUSE = 6.;\nconst float MENU_SPECULAR = 7.;\nconst float MENU_DISTR = 8.;\nconst float MENU_FRESNEL = 9.;\nconst float MENU_GEOMETRY = 10.;\n\nconst vec3 BASE_COLORS[6] = vec3[6]\n(\n\tvec3(0.74),\n\tvec3(0.51, 0.72, 0.81),\n\tvec3(0.66, .85, .42),\n\tvec3(0.87, 0.53, 0.66),\n\tvec3(0.51, 0.46, 0.74),\n\tvec3(0.78, 0.71, 0.45)\n\t);\n\nstruct AppState\n{\n\tfloat\tmenuId;\n\tfloat\tmetal;\n\tfloat   roughness;\n\tfloat   baseColor;\n\tfloat   focus;\n\tfloat   focusObjRot;\n\tfloat   objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n\tvec4 data;\n\n\tdata = LoadValue(0, 0);\n\ts.menuId = data.x;\n\ts.metal = data.y;\n\ts.roughness = data.z;\n\ts.baseColor = data.w;\n\n\tdata = LoadValue(1, 0);\n\ts.focus = data.x;\n\ts.focusObjRot = data.y;\n\ts.objRot = data.z;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n\tfragCoord = floor(fragCoord);\n\tfragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n\treturn clamp(x, vec3(0.), vec3(1.));\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));\n}\n\nvoid Repeat(inout float p, float w)\n{\n\tp = mod(p, w) - 0.5f * w;\n}\n\nfloat Circle(vec2 p, float r)\n{\n\treturn (length(p / r) - 1.) * r;\n}\n\nfloat Rectangle(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvoid Rotate(inout vec2 p, float a)\n{\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c)\n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat Arrow(vec2 p, float a, float l, float w)\n{\n\tRotate(p, a);\n\tp.y += l;\n\n\tfloat body = Capsule(p, w, l);\n\tp.y -= w;\n\n\tfloat tip = p.y + l;\n\n\tp.y += l + w;\n\tRotate(p, +2.);\n\ttip = max(tip, p.y - 2. * w);\n\tRotate(p, -4.);\n\ttip = max(tip, p.y - 2. * w);\n\n\treturn min(body, tip);\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n\treturn 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid Diagram(inout vec3 color, vec2 p, in AppState s)\n{\n\tvec3 surfColor = vec3(0.9, 0.84, 0.8);\n\tvec3 lightColor = vec3(0.88, 0.65, 0.2);\n\tvec3 baseColor = BASE_COLORS[int(s.baseColor)];\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.7);\n\n\tp -= vec2(84., 44.);\n\n\tvec2 t = p - vec2(18., 4.);\n\tfloat r = Rectangle(t, vec2(52., 12.));\n\tcolor = mix(color, surfColor, Smooth(-r * 2.));\n\n\tt.y += s.roughness * sin(t.x);\n\tr = Rectangle(t - vec2(0., 11.), vec2(52., 1.2));\n\tcolor = mix(color, surfColor * 0.6, Smooth(-r * 2.));\n\n\n\t// refraction\n\tr = 1e4;\n\tt = p - vec2(18., 15.);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 0.), -0.4, 7., .7));\n\t}\n\tr = min(r, Arrow(t - vec2(9., -15.), 2., 4., .7));\n\tr = min(r, Arrow(t - vec2(17., -10.), 3.8, 18., .7));\n\tr = min(r, Arrow(t - vec2(-6., -14.), 0.9, 3., .7));\n\tr = min(r, Arrow(t - vec2(1., -19.), 2.9, 18., .7));\n\tr = min(r, Arrow(t - vec2(-22., -15.), 4.5, 2., .7));\n\tr = min(r, Arrow(t - vec2(-28., -14.), 2.6, 14., .7));\n\tif (s.metal != 1. && s.menuId < MENU_SPECULAR)\n\t{\n\t\tcolor = mix(color, diffuseColor, Smooth(-r * 2.));\n\t}\n\n\t// reflection\n\tr = 1e4;\n\tt = p - vec2(18., 15.);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfloat off = s.roughness * (1.5 - float(i)) * .45;\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 2.), -0.5 * MATH_PI - 0.9 + off, 12., 1.));\n\t}\n\tif (s.menuId != MENU_DIFFUSE)\n\t{\n\t\tcolor = mix(color, specularColor, Smooth(-r * 2.));\n\t}\n\n\t// light in\n\tr = 1e4;\n\tt = p - vec2(18., 15.);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tr = min(r, Arrow(t - vec2(12. + float(i) * 15., 22.), -0.9, 15., 1.));\n\t}\n\tcolor = mix(color, lightColor, Smooth(-r * 2.));\n}\n\nfloat RaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius)\n{\n\tvec3 oc = rayOrigin - spherePos;\n\n\tfloat b = dot(oc, rayDir);\n\tfloat c = dot(oc, oc) - sphereRadius * sphereRadius;\n\tfloat h = b * b - c;\n\n\tfloat t;\n\tif (h < 0.0)\n\t{\n\t\tt = -1.0;\n\t}\n\telse\n\t{\n\t\tt = (-b - sqrt(h));\n\t}\n\treturn t;\n}\n\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\nfloat DistributionTerm(float roughness, float ndoth)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * MATH_PI);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat Cylinder(vec3 p, float r, float height)\n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat Substract(float a, float b)\n{\n\treturn max(a, -b);\n}\n\nfloat SubstractRound(float a, float b, float r)\n{\n\tvec2 u = max(vec2(r + a, r - b), vec2(0.0, 0.0));\n\treturn min(-r, max(a, -b)) + length(u);\n}\n\nfloat Union(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat Box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat Torus(vec3 p, float sr, float lr)\n{\n\treturn length(vec2(length(p.xz) - lr, p.y)) - sr;\n}\n\nfloat Disc(vec3 p, float r, float t)\n{\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) - t : length(vec2(p.y, l)) - t;\n}\n\nfloat UnionRound(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{\n\tp = p * localToWorld;\n\n\t// ring\n\tvec3 t = p;\n\tt.y -= -.7;\n\tfloat r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\n\tvec3 t2 = t - vec3(0., 0., 1.0);\n\tRotate(t2.xz, 0.25 * MATH_PI);\n\tr = Substract(r, Box(t2, vec3(.5)));\n\tr = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\n\n\tt = p;\n\tRotate(t.yz, -.3);\n\n\t// body\n\tfloat b = Sphere(t, .8);\n\tb = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\n\tb = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\n\tb = Substract(b, Box(t, vec3(2., .03, 2.)));\n\tb = Union(b, Sphere(t, .7));\n\n\tfloat ret = Union(r, b);\n\treturn ret;\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n\tconst float maxd = 5.0;\n\n\tfloat h = 0.5;\n\tfloat t = 0.0;\n\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\tif (h < 0.001 || t > maxd)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\th = Scene(ro + rd * t, localToWorld);\n\t\tt += h;\n\t}\n\n\tif (t > maxd)\n\t{\n\t\tt = -1.0;\n\t}\n\n\treturn t;\n}\n\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\n\nfloat SceneAO(vec3 p, vec3 n, mat3 localToWorld)\n{\n\tfloat ao = 0.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tfloat off = 0.001 + 0.2 * float(i) / 5.;\n\t\tfloat t = Scene(n * off + p, localToWorld);\n\t\tao += (off - t) * s;\n\t\ts *= 0.4;\n\t}\n\n\treturn Smooth(1.0 - 12.0 * ao);\n}\n\n// St. Peter's Basilica SH\n// https://www.shadertoy.com/view/lt2GRD\nstruct SHCoefficients\n{\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients SH_STPETER = SHCoefficients(\n\tvec3(0.3623915, 0.2624130, 0.2326261),\n\tvec3(0.1759131, 0.1436266, 0.1260569),\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\n\tvec3(0.0346500, 0.0223184, 0.0101350),\n\tvec3(0.0198140, 0.0144073, 0.0043987),\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\n\tvec3(0.0050194, 0.0038841, 0.0001374),\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\n);\n\nvec3 SHIrradiance(vec3 nrm)\n{\n\tconst SHCoefficients c = SH_STPETER;\n\tconst float c1 = 0.429043;\n\tconst float c2 = 0.511664;\n\tconst float c3 = 0.743125;\n\tconst float c4 = 0.886227;\n\tconst float c5 = 0.247708;\n\treturn (\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\n\t\tc3 * c.l20 * nrm.z * nrm.z +\n\t\tc4 * c.l00 -\n\t\tc5 * c.l20 +\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\n\t\t2.0 * c2 * c.l11  * nrm.x +\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\n\t\t2.0 * c2 * c.l10  * nrm.z\n\t\t);\n}\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\n{\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\n\nvec3 EnvRemap(vec3 c)\n{\n\treturn pow(2. * c, vec3(2.2));\n}\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\n{\n\tvec3 lightColor = vec3(2.);\n\tvec3 lightDir = normalize(vec3(.7, .9, -.2));\n\n\tvec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);\n\tfloat roughnessE = s.roughness * s.roughness;\n\tfloat roughnessL = max(.01, roughnessE);\n\n\tfloat a = -iTime * .5;\n\tmat3 rot = mat3(\n\t\tvec3(cos(a), 0., -sin(a)),\n\t\tvec3(0., 1., 0.),\n\t\tvec3(sin(a), 0., cos(a))\n\t);\n\n\tp -= vec2(-20., 10.);\n\tp *= .011;\n\n\tfloat yaw = 2.7 - s.objRot;\n\tmat3 rotZ = mat3(\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\n\t);\n\n\tfloat phi = -0.1;\n\tmat3 rotY = mat3(\n\t\tvec3(1.0, 0.0, 0.0),\n\t\tvec3(0.0, cos(phi), sin(phi)),\n\t\tvec3(0.0, -sin(phi), cos(phi))\n\t);\n\n\tmat3 localToWorld = rotY * rotZ;\n\n\tvec3 rayOrigin = vec3(0.0, .5, -3.5);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 2.0));\n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\n\tif (t > 0.0)\n\t{\n\t\tvec3 pos = rayOrigin + t * rayDir;\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\n\t\tvec3 viewDir = -rayDir;\n\t\tvec3 refl = reflect(rayDir, normal);\n\n\t\tvec3 diffuse = vec3(0.);\n\t\tvec3 specular = vec3(0.);\n\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\n\t\tfloat vdoth = saturate(dot(viewDir, halfVec));\n\t\tfloat ndoth = saturate(dot(normal, halfVec));\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\n\t\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\n\n\t\tvec3 env1 = EnvRemap(texture(iChannel2, refl).xyz);\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl).xyz);\n\t\tvec3 env3 = EnvRemap(SHIrradiance(refl));\n\t\tvec3 env = mix(env1, env2, saturate(roughnessE * 4.));\n\t\tenv = mix(env, env3, saturate((roughnessE - 0.25) / 0.75));\n\n\t\tdiffuse += diffuseColor * EnvRemap(SHIrradiance(normal));\n\t\tspecular += envSpecularColor * env;\n\n\t\tdiffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));\n\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\n\n\t\tfloat ao = SceneAO(pos, normal, localToWorld);\n\t\tdiffuse *= ao;\n\t\tspecular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);\n\n\t\tcolor = diffuse + specular;\n\t\tif (s.menuId == MENU_DIFFUSE)\n\t\t{\n\t\t\tcolor = diffuse;\n\t\t}\n\t\tif (s.menuId == MENU_SPECULAR)\n\t\t{\n\t\t\tcolor = specular;\n\t\t}\n\t\tif (s.menuId == MENU_DISTR)\n\t\t{\n\t\t\tcolor = vec3(lightD);\n\t\t}\n\t\tif (s.menuId == MENU_FRESNEL)\n\t\t{\n\t\t\tcolor = envSpecularColor;\n\t\t}\n\t\tif (s.menuId == MENU_GEOMETRY)\n\t\t{\n\t\t\tcolor = vec3(lightV) * (4.0f * ndotv * ndotl);\n\t\t}\n\t\tcolor = pow(color * .4, vec3(1. / 2.2));\n\t}\n\telse\n\t{\n\t\t// shadow\n\t\tfloat planeT = -(rayOrigin.y + 1.2) / rayDir.y;\n\t\tif (planeT > 0.0)\n\t\t{\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\n\n\t\t\tfloat radius = .7;\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n\t\t}\n\t}\n}\n\nvoid InfoText(inout vec3 color, vec2 p, in AppState s)\n{\n\tp -= vec2(52, 12);\n\tvec2 q = p;\n\tif (s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR)\n\t{\n\t\tp.y -= 6.;\n\t}\n\tif (s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL)\n\t{\n\t\tp.y += 6.;\n\t}\n\tif (s.menuId == MENU_SPECULAR)\n\t{\n\t\tp.y += 6. * 6.;\n\n\t\tif (p.x < 21. && p.y >= 27. && p.y < 30.)\n\t\t{\n\t\t\tp.y = 0.;\n\t\t}\n\t\telse if (s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21.)\n\t\t{\n\t\t\tp.y += 3.;\n\t\t}\n\t}\n\n\tvec2 scale = vec2(3., 6.);\n\tvec2 t = floor(p / scale);\n\n\tuint v = 0u;\n\tif (s.menuId == MENU_SURFACE)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702127169u : (t.x < 8. ? 1768431730u : (t.x < 12. ? 1852404852u : (t.x < 16. ? 1752440935u : (t.x < 20. ? 1970479205u : (t.x < 24. ? 1667327602u : (t.x < 28. ? 1768693861u : 7628903u))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1937334642u : (t.x < 8. ? 1717924384u : (t.x < 12. ? 1952671084u : (t.x < 16. ? 1684955424u : (t.x < 20. ? 1717924384u : (t.x < 24. ? 1952670066u : (t.x < 28. ? 32u : 0u))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1868784481u : (t.x < 8. ? 1852400754u : (t.x < 12. ? 1869881447u : (t.x < 16. ? 1701729056u : (t.x < 20. ? 1931963500u : (t.x < 24. ? 2002873376u : 0u)))))) : v;\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_METAL)\n\t{\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 1852776556u : (t.x < 12. ? 1914730860u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1751607660u : (t.x < 28. ? 1914729332u : (t.x < 32. ? 544438625u : 45u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 544432488u : (t.x < 8. ? 2037149295u : (t.x < 12. ? 1701868320u : (t.x < 16. ? 1634497891u : (t.x < 20. ? 114u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_DIELECTRIC)\n\t{\n\t\tv = t.y == 3. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : (t.x < 12. ? 1914725225u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1701868328u : (t.x < 28. ? 1634497891u : (t.x < 32. ? 2107762u : 0u)))))))) : v;\n\t\tv = t.y == 2. ? (t.x < 4. ? 543452769u : (t.x < 8. ? 1935832435u : (t.x < 12. ? 1634103925u : (t.x < 16. ? 1931502947u : (t.x < 20. ? 1953784163u : (t.x < 24. ? 544436837u : (t.x < 28. ? 1718182952u : (t.x < 32. ? 1702065510u : 41u)))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1751607660u : (t.x < 8. ? 1634869364u : (t.x < 12. ? 539915129u : (t.x < 16. ? 1667592275u : (t.x < 20. ? 1918987381u : (t.x < 24. ? 544434464u : (t.x < 28. ? 1936617315u : (t.x < 32. ? 1953390964u : 0u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 808333438u : (t.x < 8. ? 774909234u : (t.x < 12. ? 13360u : 0u))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_ROUGHNESS)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 544367976u : (t.x < 12. ? 1718777203u : (t.x < 16. ? 1936024417u : (t.x < 20. ? 1830825248u : (t.x < 24. ? 543519343u : (t.x < 28. ? 1952539507u : (t.x < 32. ? 1701995892u : 100u)))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 1937334642u : (t.x < 24. ? 1851858988u : (t.x < 28. ? 1752440932u : (t.x < 32. ? 2126709u : 0u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1920298082u : (t.x < 8. ? 1919248754u : (t.x < 12. ? 1717924384u : (t.x < 16. ? 1952671084u : (t.x < 20. ? 1936617321u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_BASE_COLOR)\n\t{\n\t\tv = t.y == 1. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1635018093u : (t.x < 12. ? 1679848300u : (t.x < 16. ? 1852401253u : (t.x < 20. ? 1931506533u : (t.x < 24. ? 1969448304u : (t.x < 28. ? 544366956u : (t.x < 32. ? 1869377379u : 114u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1818585444u : (t.x < 12. ? 1920230245u : (t.x < 16. ? 544433001u : (t.x < 20. ? 1768169517u : (t.x < 24. ? 1937073766u : (t.x < 28. ? 1868767333u : (t.x < 32. ? 7499628u : 0u)))))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_LIGHTING)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : (t.x < 12. ? 544434464u : (t.x < 16. ? 1869770849u : (t.x < 20. ? 1634560376u : (t.x < 24. ? 543450484u : 2128226u)))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1634755955u : (t.x < 8. ? 1769234802u : (t.x < 12. ? 1679845230u : (t.x < 16. ? 1969645161u : (t.x < 20. ? 1629513075u : (t.x < 24. ? 2122862u : 0u)))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1667592307u : (t.x < 8. ? 1918987381u : (t.x < 12. ? 1836016416u : (t.x < 16. ? 1701736304u : (t.x < 20. ? 544437358u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_DIFFUSE)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818324307u : (t.x < 8. ? 1668489324u : (t.x < 12. ? 543517793u : (t.x < 16. ? 1935832435u : (t.x < 20. ? 1634103925u : (t.x < 24. ? 1931502947u : (t.x < 28. ? 1953784163u : (t.x < 32. ? 1852404325u : 8295u)))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635087189u : (t.x < 8. ? 981036140u : (t.x < 12. ? 1835093024u : (t.x < 16. ? 1953654114u : (t.x < 20. ? 1146241568u : (t.x < 24. ? 1713388102u : (t.x < 28. ? 824196384u : (t.x < 32. ? 543780911u : 0u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1702257960u : (t.x < 8. ? 1914730866u : (t.x < 12. ? 1696627041u : (t.x < 16. ? 1937009016u : (t.x < 20. ? 544106784u : (t.x < 24. ? 1634869345u : (t.x < 28. ? 1679844462u : (t.x < 32. ? 2716265u : 0u)))))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_SPECULAR)\n\t{\n\t\tv = t.y == 8. ? (t.x < 4. ? 1818649938u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 779380839u : (t.x < 20. ? 1970492704u : (t.x < 24. ? 2037148769u : 8250u)))))) : v;\n\t\tv = t.y == 7. ? (t.x < 4. ? 1802465091u : (t.x < 8. ? 1919898669u : (t.x < 12. ? 1668178290u : (t.x < 16. ? 1998597221u : (t.x < 20. ? 1751345512u : (t.x < 24. ? 1685024032u : 7564389u)))))) : v;\n\t\tv = t.y == 6. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1919250472u : (t.x < 20. ? 1952671078u : (t.x < 24. ? 1919511840u : 544370546u)))))) : v;\n\t\tv = t.y == 5. ? (t.x < 4. ? 1734960488u : (t.x < 8. ? 1634563176u : (t.x < 12. ? 3811696u : 0u))) : v;\n\t\tv = t.y == 4. ? (t.x < 4. ? 745285734u : (t.x < 8. ? 1178413430u : (t.x < 12. ? 1747744296u : (t.x < 16. ? 1814578985u : (t.x < 20. ? 1747744300u : (t.x < 24. ? 1747469353u : 41u)))))) : v;\n\t\tv = t.y == 3. ? (t.x < 4. ? 538976288u : (t.x < 8. ? 538976288u : (t.x < 12. ? 1848128544u : (t.x < 16. ? 673803447u : (t.x < 20. ? 695646062u : 0u))))) : v;\n\t\tv = t.y == 2. ? (t.x < 4. ? 539828294u : (t.x < 8. ? 1936028230u : (t.x < 12. ? 7103854u : 0u))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 539828295u : (t.x < 8. ? 1836016967u : (t.x < 12. ? 2037544037u : 0u))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 539828292u : (t.x < 8. ? 1953720644u : (t.x < 12. ? 1969383794u : (t.x < 16. ? 1852795252u : 0u)))) : v;\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_DISTR)\n\t{\n\t\tv = t.y == 1. ? (t.x < 4. ? 1702109252u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 622883685u : (t.x < 20. ? 543584032u : (t.x < 24. ? 1919117677u : (t.x < 28. ? 1667327599u : 544437349u))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1769235301u : (t.x < 12. ? 1814062958u : (t.x < 16. ? 1952999273u : (t.x < 20. ? 1919903264u : (t.x < 24. ? 1730175264u : (t.x < 28. ? 1852143209u : 1919509536u))))))) : v;\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_FRESNEL)\n\t{\n\t\tv = t.y == 3. ? (t.x < 4. ? 1702109254u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1629516645u : (t.x < 20. ? 1853189997u : (t.x < 24. ? 1718558836u : 32u)))))) : v;\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 544370534u : (t.x < 24. ? 1768366177u : 544105846u)))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1935832435u : (t.x < 8. ? 1851880052u : (t.x < 12. ? 539911523u : (t.x < 16. ? 1629516873u : (t.x < 20. ? 1869770864u : (t.x < 24. ? 1701340001u : 3219571u)))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370534u : (t.x < 8. ? 2053206631u : (t.x < 12. ? 543649385u : (t.x < 16. ? 1818717793u : (t.x < 20. ? 29541u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_GEOMETRY)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702109255u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1931506533u : (t.x < 20. ? 1868849512u : (t.x < 24. ? 1735289207u : (t.x < 28. ? 543584032u : 0u))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1701864804u : (t.x < 20. ? 1852400750u : (t.x < 24. ? 1852776551u : (t.x < 28. ? 1701344288u : 2126441u))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1634890337u : (t.x < 8. ? 1835362158u : (t.x < 12. ? 7630437u : 0u))) : v;\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n\t}\n\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n\n\tvec3 textColor = vec3(.3);\n\n\tp = (p - t * scale) / scale;\n\tp.x = (p.x - .5) * .45 + .5;\n\tfloat sdf = TextSDF(p, c);\n\tif (c != 0.)\n\t{\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n\t}\n\n\tif (s.menuId == MENU_SPECULAR)\n\t{\n\t\tcolor = mix(color, textColor, smoothstep(.05, -.05, Capsule(q.yx - vec2(-12.3, 48.), .3, 26.)));\n\t}\n}\n\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\n{\n\tp -= vec2(-160, -1);\n\n\tvec2 scale = vec2(4., 8.);\n\tvec2 t = floor(p / scale);\n\n\tfloat tab = 1.;\n\tif (t.y >= 6. && t.y < 10.)\n\t{\n\t\tp.x -= tab * scale.x;\n\t\tt.x -= tab;\n\t}\n\tif (t.y >= 0. && t.y < 5.)\n\t{\n\t\tp.x -= tab * scale.x;\n\t\tt.x -= tab;\n\t}\n\tif (t.y >= 0. && t.y < 3.)\n\t{\n\t\tp.x -= tab * scale.x;\n\t\tt.x -= tab;\n\t}\n\n\tuint v = 0u;\n\tv = t.y == 10. ? (t.x < 4. ? 1718777171u : (t.x < 8. ? 6644577u : 0u)) : v;\n\tv = t.y == 9. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 108u : 0u)) : v;\n\tv = t.y == 8. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : 25449u)) : v;\n\tv = t.y == 7. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 115u)) : v;\n\tv = t.y == 6. ? (t.x < 4. ? 1702060354u : (t.x < 8. ? 1819231008u : 29295u)) : v;\n\tv = t.y == 5. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : 0u)) : v;\n\tv = t.y == 4. ? (t.x < 4. ? 1717987652u : (t.x < 8. ? 6648693u : 0u)) : v;\n\tv = t.y == 3. ? (t.x < 4. ? 1667592275u : (t.x < 8. ? 1918987381u : 0u)) : v;\n\tv = t.y == 2. ? (t.x < 4. ? 1953720644u : (t.x < 8. ? 1969383794u : 1852795252u)) : v;\n\tv = t.y == 1. ? (t.x < 4. ? 1936028230u : (t.x < 8. ? 7103854u : 0u)) : v;\n\tv = t.y == 0. ? (t.x < 4. ? 1836016967u : (t.x < 8. ? 2037544037u : 0u)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n\n\tvec3 textColor = vec3(.3);\n\tif (t.y == 10. - s.menuId)\n\t{\n\t\ttextColor = vec3(0.74, 0.5, 0.12);\n\t}\n\n\tp = (p - t * scale) / scale;\n\tp.x = (p.x - .5) * .45 + .5;\n\tfloat sdf = TextSDF(p, c);\n\tif (c != 0.)\n\t{\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n\t}\n}\n\nvoid DrawMenuControls(inout vec3 color, vec2 p, in AppState s)\n{\n\tp -= vec2(-110, 74);\n\n\t// radial\n\tfloat c2 = Capsule(p - vec2(0., -3.5), 3., 4.);\n\tfloat c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);\n\n\t// roughness slider\n\tp.y += 15.;\n\tc1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));\n\tc1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tp.y += 8.;\n\tc1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));\n\tcolor = mix(color, vec3(0.9), Smooth(-c2 * 2.));\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tvec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);\n\t\tcolor = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;\n\tp *= 100.;\n\n\tAppState s;\n\tLoadState(s);\n\n\tvec3 color = vec3(1., .98, .94) * mix(1.0, 0.4, Smooth(abs(.5 - uv.y)));\n\tfloat vignette = q.x * q.y * (1.0 - q.x) * (1.0 - q.y);\n\tvignette = saturate(pow(32.0 * vignette, 0.05));\n\tcolor *= vignette;\n\n\tDrawScene(color, p, s);\n\tDiagram(color, p, s);\n\tInfoText(color, p, s);\n\tMenuText(color, p, s);\n\tDrawMenuControls(color, p, s);\n\n\tfragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// control loop\n\nconst float MENU_SURFACE = 0.;\nconst float MENU_METAL = 1.;\nconst float MENU_DIELECTRIC = 2.;\nconst float MENU_ROUGHNESS = 3.;\nconst float MENU_BASE_COLOR = 4.;\nconst float MENU_LIGHTING = 5.;\nconst float MENU_DIFFUSE = 6.;\nconst float MENU_SPECULAR = 7.;\nconst float MENU_DISTR = 8.;\nconst float MENU_FRESNEL = 9.;\nconst float MENU_GEOMETRY = 10.;\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ = 2.;\nconst float FOCUS_COLOR = 3.;\n\nstruct AppState\n{\n    float menuId;\n    float metal;\n    float roughness;\n    float baseColor;\n    float focus;\n    float focusObjRot;\n    float objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId = data.x;\n    s.metal = data.y;\n    s.roughness = data.z;\n    s.baseColor = data.w;\n\n    data = LoadValue(1, 0);\n    s.focus = data.x;\n    s.focusObjRot = data.y;\n    s.objRot = data.z;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.metal, s.roughness, s.baseColor), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focus, s.focusObjRot, s.objRot, 0.), ret, fragCoord);\n    ret = iFrame >= 1 ? ret : vec4(0.);\n    return ret;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.)\n    {\n        discard;\n    }\n\n    AppState s;\n    LoadState(s);\n\n    vec4 q = iMouse / iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x / iResolution.y;\n    m *= 100.;\n\n    vec4 sliderM = m - vec2(-110, 74).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    }\n    else if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -30. && sliderM.w < -20.)\n    {\n        s.focus = FOCUS_COLOR;\n    }\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -10. && sliderM.w < -4.)\n    {\n        s.metal = 0.;\n        s.menuId = s.menuId == MENU_METAL ? MENU_DIELECTRIC : s.menuId;\n    }\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -4. && sliderM.w < 6.)\n    {\n        s.metal = 1.;\n        s.menuId = s.menuId == MENU_DIELECTRIC ? MENU_METAL : s.menuId;\n    }\n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot;\n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\n        if (menuId >= 0. && menuId <= 10.)\n        {\n            s.menuId = menuId;\n        }\n        s.metal = menuId == MENU_METAL ? 1. : s.metal;\n        s.metal = menuId == MENU_DIELECTRIC ? 0. : s.metal;\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = saturate(sliderM.x / 40.);\n    }\n    if (s.focus == FOCUS_COLOR)\n    {\n        s.baseColor = floor(clamp((sliderM.x * 5.) / 32., 0., 5.));\n    }\n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.x - m.z);\n    }\n\n    fragColor = SaveState(s, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}