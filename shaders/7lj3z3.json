{
    "Shader": {
        "info": {
            "date": "1624417623",
            "description": "Puts the \"V\" in visualizer. \nI experimented a lot with this one, hope you enjoy it!\nRIP soundcloud\n",
            "flags": 32,
            "hasliked": 0,
            "id": "7lj3z3",
            "likes": 7,
            "name": "Audio \"V\"isualizer",
            "published": 3,
            "tags": [
                "fft",
                "sdf",
                "music",
                "visualizer"
            ],
            "usePreview": 0,
            "username": "lambmeow",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "\n\n//blur + tone pass\n\n\nvec3 tone(vec3 x)\n{\n    return smoothstep(.1,.9, x) + x * 0.15;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //set the scale of the blur based on the position of the screen\n    float scale = length(uv - 0.5),steps = 30.;\n\n    //store the blur color\n    vec3 blur = vec3(0);\n    \n    //used to create blur effect by offseting texture coordinates\n    vec2 offset = vec2(0);\n    \n    for(float i = 0.; i < steps; i++)\n    {\n        //decrease blur each step done\n        scale *= 0.77;\n        \n        //add blur to thextrue\n        blur += texture(iChannel0, uv+offset).rgb;\n        \n        //add to the offset\n        offset -= normalize((2.* fragCoord -iResolution.xy)/iResolution.y) * scale/steps;\n        \n    }\n    \n    //normalize blur colors\n    blur= (blur/(steps));\n    \n    //add tone to the blur\n    vec3 color = tone(blur);\n    \n    //print to screen\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//get music fft data and create a ripple effect for the raymarching pass\n\n#define MUSIC_THICK 0.01 // thickness of the new sound data\n#define MUSIC_DAMP 0.98  // speed of fade out for the sound data\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n   \n   //get music data just this frame\n    float music = texture(iChannel0, vec2(uv.x, MUSIC_THICK)).r * step(uv.y, MUSIC_THICK);\n    \n    //shift prev frame data to make space for the new music data\n    vec4 prevFrame = texture(iChannel1, vec2(uv.x, uv.y - 0.01)) * step(MUSIC_THICK, uv.y);\n    \n    //apply current music data to pass\n    fragColor = prevFrame * MUSIC_DAMP + vec4(music);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//raymarch pass\n\n//#define SHOW_MUSIC_DATA //show the raw music data texture \n\nmat3 raymat(vec3 ro, vec3 ta, float r)\n{\n    vec3 ww = normalize(ta -ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(r), cos(r), 0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    return mat3(uu, vv, ww);\n}\n\nvec4 map( vec3 o )\n{\n    float z = o.z;\n    \n    //loop we move away from the camera in a forward direction\n    o.z = mod(o.z, 100.);\n    \n    //get the texture coordinates to apply the music pass\n    vec2 texUV = (abs(vec2(o.x, o.z)) + 20.)/200.;\n    \n    //current music pass\n    float musicVal =  texture(iChannel0, texUV).r;\n    \n    //set the color\n    vec3 color = vec3(dot(texUV,texUV*2.), musicVal, 1.-o.z/200.) * 2. * musicVal * .75;\n    \n    //send the distance and \n    return vec4(color, o.y - musicVal * 50. - cos(o.z*0.15 + iTime));\n}\n\nvec4 raycast(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 200; i++)\n    {\n        vec4 t = map(ro + rd * dist);\n        \n        if(t.w < 0.01)\n            return t;\n        \n        dist += t.w;\n        \n        if(dist > 1000.)\n            return vec4(0.);\n    }\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) /iResolution.y;\n   \n   //create relfection on the x axis\n    uv.x = abs(uv.x - uv.x/2.); \n    \n    vec3 eye = vec3(0,40,-30);\n    \n    vec3 r = normalize(raymat(eye, vec3(0, 30, 50), 30.) * vec3(uv, 2.));\n    \n    //get color\n    vec4 val = raycast(eye, r);\n    \n\n    // Output to screen\n#ifdef SHOW_MUSIC_DATA\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n#else\n    fragColor = val;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}