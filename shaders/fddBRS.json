{
    "Shader": {
        "info": {
            "date": "1656695575",
            "description": "Mouseable.\nInspired by [url=https://www.shadertoy.com/view/7sdfDN]Apple Watch UI Effect[/url].\nReference 50-55s: [url=https://youtu.be/eHjBH9UBLnI?t=50]How to manage your apps[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "fddBRS",
            "likes": 17,
            "name": "Apple Hex Icons",
            "published": 3,
            "tags": [
                "circle",
                "ui",
                "apple",
                "watch",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 402
        },
        "renderpass": [
            {
                "code": "const int mode_grid    = 0;\nconst int mode_masonry = 1;\nconst int mode_hex     = 2;\nconst int mode = 2;\nconst bool show_screen = false;\nconst bool radius_field = true;\n\nfloat sdRect(vec2 O);\nfloat sdRectWithHole(vec2 O);\nfloat sdBar(vec2 O);\nfloat sdSnake(vec2 O);\nfloat sdScreen(vec2 O);\nvec2 normalScreen(vec2 O);\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    float spacing = iResolution.x / 10.;\n    float spacing_y = spacing;\n    if (mode == mode_hex)\n        // some scaling is possible, as long as circles don't touch the discontinuity of round\n        spacing_y *= sqrt(3.)/2.;\n    \n    vec2 shift;\n    shift.x = sin(iTime) * spacing;\n    shift.y = cos(iTime) * spacing;\n    if (iMouse.z > 0.)\n        shift = -iMouse.xy;\n    \n    float row = round((O.y + shift.y) / spacing_y);\n    if (mode == mode_masonry || mode == mode_hex)\n        shift.x += spacing * row / 2.;\n    \n    float column = round((O.x + shift.x) / spacing);\n    \n    vec2 center;\n    center.x = column * spacing - shift.x;\n    center.y = row * spacing_y - shift.y;\n\n    float full = 0.4 * spacing;\n    if (radius_field)\n        full *= mix(1.05, 0.8, pow(distance(O, iResolution.xy/2.)/(iResolution.x/2.), 2.));\n    \n    // shrink circles until they are fully on the screen\n    float dist = (sdScreen(center) + full) / 2.;\n    vec2 normal = normalScreen(center);\n    float radius = full;\n    if (dist > 0.)\n        center -= dist * normal,\n        radius -= dist;\n    \n    C = vec4(0);\n    if (show_screen)\n    {\n        C = vec4(.1 + .1 * normalScreen(O), 0, 1);\n        C = blend(C, vec3(1), sdScreen(O));\n    }\n    vec2 tex = .5 + clamp((O - center) / radius, -.5, .5);\n    vec3 c = mix(vec3(1), vec3(0), texture(iChannel0, (vec2(row, column) + tex) / 16.).r);\n    C = blend(C, c, radius - distance(O, center));\n    C = sqrt(C);\n}\n\n/*\nConstraints:\n- Exact Sdf\n- Surface Curvature < Icon Curvature\n- Minimum Separation > 2x (3x?) Icon Radius\n- Minimum Thickness > 1x Icon Radius\n\nApart from that, anything should work. What about a snake shaped watch?\n*/\nfloat sdScreen(vec2 O)\n{\n    //return max(sdSnake(O), sdSnake(O - vec2(0, iResolution.y)));\n    //return sdBar(O);\n    return sdRectWithHole(O);\n    return sdRect(O);\n}\n\nvec2 normalScreen(vec2 O)\n{\n    vec2 eps = vec2(1, 0);\n    return normalize(vec2(\n        sdScreen(O + eps.xy) - sdScreen(O - eps.xy),\n        sdScreen(O + eps.yx) - sdScreen(O - eps.yx)\n    ));\n}\n\nfloat sdRect(vec2 O)\n{\n    float r = iResolution.x / 10.;\n    return sdBox(O - iResolution.xy/2., vec2(iResolution.xy / 2.) - r - 4.) - r;\n}\n\nfloat sdRectWithHole(vec2 O)\n{\n    return max(sdRect(O), .08*iResolution.x - distance(O, iResolution.xy/2.));\n}\n\nfloat sdBar(vec2 O)\n{\n    float r = iResolution.x / 10.;\n    float a = 1.5 * cos(iTime);\n    return .4 * r - abs(dot(vec2(sin(a), cos(a)), (O - iResolution.xy / 2.)));\n}\n\nfloat sdSnake(vec2 O)\n{\n    float thickness = iResolution.x / 20.;\n    float spacing = iResolution.x / 2.;\n    float r = iResolution.x / 4.;\n\n    float h = sqrt(r*r - spacing*spacing/16.);\n    float sa = asin(spacing/4. / r);\n    float id0 = round(O.x / spacing);\n    float id1 = round(O.x / spacing + .5) - .5;\n    float sd;\n    sd = sdfArc(sa, r, O.yx-vec2(-h,id0*spacing));\n    sd = min(sd, sdfArc(sa, r, -O.yx+vec2(h,id1*spacing)));\n    return thickness - abs(sd);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float sdBox(in vec2 p, in vec2 b)\n{\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(r, 0., 1.));\n}\n\nfloat sdfArc(float ea, float r, vec2 uv)\n{\n    // ArmandB: simple sdf arc https://www.shadertoy.com/view/sdSfWG\n    float sa = -ea;\n    const float tau = 2.*radians(180.);\n    //find coterminal angles\n    sa = mod(mod(sa,tau) + tau, tau);\n    ea = mod(mod(ea,tau) + tau, tau);\n    float a = mod(mod(atan(uv.y,uv.x),tau) + tau, tau);\n    //https://stackoverflow.com/questions/12234574/calculating-if-an-angle-is-between-two-angles\n    if ((sa <= a && a <= ea && sa < ea) || ((sa <= a || a <= ea) && sa >= ea)){\n        return abs(r - length(uv));\n    }\n    //get closest endpoint\n    vec2 p1 = vec2(cos(sa), sin(sa))*r;\n    vec2 p2 = vec2(cos(ea), sin(ea))*r;\n    return min(distance(p1, uv), distance(p2, uv));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}