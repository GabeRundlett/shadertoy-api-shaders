{
    "Shader": {
        "info": {
            "date": "1696899177",
            "description": "Trying to make some nice clouds, use the mouse to control the sun. Turn on half res render in common if to slow.",
            "flags": 32,
            "hasliked": 0,
            "id": "msKcWG",
            "likes": 32,
            "name": "Asthetic clouds",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "clouds",
                "cloud",
                "sky",
                "volumetric",
                "mie"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 769
        },
        "renderpass": [
            {
                "code": "// Asthetic clouds by El_Sargo\n// First serious attempt at making some nice clouds, \n// performance is rubish though :( ( Compared to more \n// advanced systems that use TAA ect ), I guess it's fine for\n// a shadertoy though.\n// Next step is to do some fancy temporal reprojection type things\n// and various other optimisztions.\n// Turn on HALF_RESOLUTION in common if it's to slow\n\nvec3 aces_tonemap(vec3 color) {\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f ) {\n    vec2 uv = f/iResolution.xy;\n    vec3 col;\n    #ifdef HALF_RESOLUTION\n        col = tx(iChannel0,uv*0.5).rgb;\n    #else\n        col = texture(iChannel0,uv).rgb;\n    #endif\n    col /= 8.;\n    col = pow(col,vec3(.8));\n    col *= smoothstep(.9,0.1,length(uv-0.5));\n    fragColor =  vec4(aces_tonemap(col),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const mat3 m = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0\n);\n\n#define SAMPLE t3x(iChannel0,x*0.02).x\n#define NEXT_OCTAVE a += b*n;b *= s;x = f*m*(x+vec3(iTime*0.2*k,0,0));k *= -1.;\nvec2 fb( in vec3 x ){\n    float f = 1.78;\n    float s = 0.54;\n    float a = 0.0;\n    float z = 0.0;\n    float b = 0.5;\n    float k = 1.;\n    for( int i=0; i < 4; i++ ) {\n        float n = SAMPLE;\n        n *= tx(iChannel1,x.xz*0.01).x;\n        z += b*n; \n        NEXT_OCTAVE\n    }\n    for( int i=0; i < 4 ; i++ ) {\n        float n = SAMPLE*1.6;\n        NEXT_OCTAVE\n    }\n    return  vec2(a,z);\n}\n\nfloat fbb( in vec3 x ) {\n    float f = 1.78;\n    float s = 0.54;\n    float a = 0.0;\n    float b = 0.5;\n    float k = 1.;\n    for (int i=0;i<4;i++) {\n        float n = SAMPLE;\n        n *= tx(iChannel1,x.xz*0.01).x;\n        NEXT_OCTAVE\n    }\n    return a;\n}\n\nvec2 getMouse(){\n    if (iMouse.z > 0.5) {\n       return iMouse.xy/iResolution.xy;\n    } else {\n        return vec2(1.46,0.3);\n    }\n}\n\n// Physicaly based, shmisicaly shmased\nfloat simpleMie(float costh) {\n  return ((costh+0.7)*costh*costh*costh+0.2)*2.;\n}\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 sun){\n    float mouse = getMouse().y;\n    float rds = dot(sun, rd);\n    vec3 sunset = exp(-0.01*vec3(1,2,4)/mouse-0.4);\n    vec3 light = vec3(smoothstep(0.997, 1.2, rds))*100000.*vec3(1,0.8,0.6)*sunset;\n\tfloat g = 0.;\n    float mid = CLOUD_HEIGHT;\n    float delt = 40. ;\n    float idelt = 1./delt;\n    float start = (mid - delt)/rd.y;\n    float end = (mid + delt)/rd.y;\n    float j=start;\n\tvec3 ccol = vec3(0.);\n    float m = simpleMie(rds);\n    float T = 0.;\n\tif (rd.y > 0.) {\n        float dj = 1.5/rd.y;\n\t\tfor (; j<end;j+=dj){\n            vec3 s = (rd*j+vec3(ro.x,0.,ro.z))*0.01;\n            float ddd = 0.2;\n            float xj = fbb(s+sun*ddd); \n            float sub = (s.y-mid)*idelt*0.01-0.2;\n            float subb = ((s.y+sun.y*ddd)-mid)*idelt*0.01-0.2;\n\t\t\tvec2 d = fb(s)+sub;\n\t\t\tfloat dd = xj+subb;\n            float dir_deriv = (d.y-dd)/ddd;\n\t\t\tg +=  max(0.,d.x*3.);\n\t\t\tvec3 col = sunset*( \n                (max(0.,dir_deriv)*3.+0.2)*m+\n                d.y*vec3(0.1,0.2,0.3)*exp((g+2.)*0.1)\n            );\n\t\t\tccol += col*exp(g*-vec3(.3,0.4,0.5));\n            if (g > 9.){\n                break;\n            }\n\t\t}\n     } \n     light = mix(mix(ccol,light,exp(-1.5*g)),vec3(0.7), smoothstep(0.,-.1,rd.y));\n     float at = CLOUD_HEIGHT/rd.y*0.0001;\n     \n     return \n         light*exp(-vec3(1,2,4)*1.3*at)+\n         7.*(1.-exp(-at*3.5*vec3(1,2,4)*sunset));\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec2 mou = getMouse();\n    float mx = -mou.x*10.;\n    float my = mou.y*2.;\n    vec3 sun = normalize(vec3(sin(mx),max(0.,sin(my-0.3)*2.),cos(mx)));\n    return getSky(ro,rd,sun);\n}\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    #ifdef HALF_RESOLUTION\n    if (max(uv.x,uv.y) <= 0.502) {\n        uv *= 2.0;\n        #endif\n        vec2 nuv = (uv-0.5)*vec2(1.,iResolution.y/iResolution.x);\n        vec3 ro = vec3(iTime*20.0+1550.,0., 4.);\n        vec3 rd = normalize(vec3(nuv, -0.7));\n        rd.yz *= mat2(12./13.,-5./13.,5./13.,12./13.);\n        col = render(ro, rd);\n    #ifdef HALF_RESOLUTION\n    }\n    #endif\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//#define HALF_RESOLUTION\n#define CLOUD_HEIGHT (250.0)\n\n// https://www.shadertoy.com/view/XsfGDn\nvec4 tx( sampler2D sam, vec2 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}\n\n// Same as above but 3D\nvec4 t3x( sampler3D sam, vec3 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec3 iuv = floor( uv );\n    vec3 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}