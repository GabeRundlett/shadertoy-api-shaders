{
    "Shader": {
        "info": {
            "date": "1584691286",
            "description": "Implementation of raymarching with diffraction and reflection at 2 or 4 levels deep. 4 level depth based on LOD4 flag.\n\nOnly part not from scratch is the perlin noise. Credits in the code.",
            "flags": 0,
            "hasliked": 0,
            "id": "tslyDr",
            "likes": 3,
            "name": "Raymarch Water",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "refraction",
                "water"
            ],
            "usePreview": 1,
            "username": "natethegreat2525",
            "viewed": 658
        },
        "renderpass": [
            {
                "code": "#define LOD4 ////////////////////////// UNCOMMENT THIS LINE FOR FULL DETAIL (Compile time is ~180s)\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define SURF 0.01\n#define EP 0.001\n#define PI 3.14159\n#define MIN_C(a, b) a.x < b.x ? a : b\n#define MIN_C4(a, b, c, d) a.x < b.x ? (a.x < c.x ? (a.x < d.x ? a : d) : (c.x < d.x ? c : d)) : (b.x < c.x ? (b.x < d.x ? b : d) : (c.x < d.x ? c : d))\n#define MIN_C3(a, b, c) a.x < b.x ? (a.x < c.x ? a : c) : (b.x < c.x ? b : c)\n#define MAX_C(a, b) a.x > b.x ? a : b\n\nmat2 rot(float a) {\n    float x = sin(a);\n    float y = cos(a);\n    return mat2(y, x, -x, y);\n}\n\nfloat sdLens(vec3 p) {\n    float l1 = length(p-vec3(0,0,1.7))-2.;\n    float l2 = length(p+vec3(0,0,1.7))-2.;\n    if (l1 < -0.002 && l2 < -0.002) {\n        return min(-l1-0.004, -l2-0.004);\n    }\n    return max(l1, l2);\n}\n\n//Rect with proper internal distances\nfloat sdRectInternal(vec3 p, vec3 s) {\n    float a = 0.002;\n    if (abs(p.x) < s.x-a && abs(p.y) < s.y-a && abs(p.z) < s.z-a) {\n        s-=a*2.;\n        return min(s.x-abs(p.x), min(s.y-abs(p.y), s.z-abs(p.z)));\n    }\n    return max(max(p.x-s.x, p.y-s.y), max(max(p.z-s.z, -p.x-s.x), max(-p.y-s.y, -p.z-s.z)));\n}\n\nfloat sdRect(vec3 p, vec3 s) {\n    return max(max(p.x-s.x, p.y-s.y), max(max(p.z-s.z, -p.x-s.x), max(-p.y-s.y, -p.z-s.z)));\n}\n\n\nfloat sdEllipse(vec3 p, vec3 s) {\n    float len = length(p/s)-1.;\n    return len*min(s.x,min(s.y,s.z));\n}\n\nfloat pseudoHash(float v) {\n    return mod(sin(35693.14159*v)*147.34+147.34, 2.)-1.;\n}\n\nfloat pseudoHash(vec3 v) {\n    return pseudoHash(v.x + pseudoHash(v.z));\n    return pseudoHash(v.z + pseudoHash(v.y + pseudoHash(v.x)));\n}\n\n\nfloat sdPlaneBumpy(vec3 p) {\n    float b = 0.05*snoise(vec3(p.x,iTime,p.z));\n    return abs(p.y-b)-.002;\n}\n\nvec2 getDist(vec3 p) {\n    float sphere = length(p-vec3(2,0,-2)) - 1.;\n    float plane = sdPlaneBumpy(p-vec3(0,0,0));\n    vec3 cubePos = p - vec3(-2, 1, -1);\n    cubePos.xy *= rot(PI/7.);\n    cubePos.yz *= rot(PI/8.);\n    float cube = sdRectInternal(cubePos, vec3(1));\n    vec3 cubePos2 = p - vec3(2,0,1);\n    cubePos2.xy *= rot(-PI/7.);\n    float cube2 = sdRectInternal(cubePos2, vec3(.1, 2, .1));\n    float container = sdRect(p-vec3(0), vec3(4,1,4));\n    float lens = sdLens(p-vec3(0,1,2));\n    vec2 lens_c = vec2(lens, 3);\n    vec2 water_c = vec2(max(plane, container), 0);\n    vec2 cube_c = vec2(min(cube, cube2), 1);\n    vec2 sphere_c = vec2(sphere, 2);\n    return MIN_C4(cube_c, water_c, sphere_c, lens_c);\n}\n\nvec2 getRayDist(vec3 rp, vec3 rd) {\n    float d = 0.;\n    vec3 p = rp;\n    vec2 ret;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        p = rp + rd*d;\n        ret = getDist(p);\n        d += ret.x;\n        if(ret.x <= SURF || d > MAX_DIST) break;\n    }\n    ret.x = d;\n    return ret;\n}\n\nvec3 getNorm(vec3 p) {\n    float c = getDist(p).x;\n    vec2 ep = vec2(EP,0);\n    vec3 norm;\n    vec3 eps[3] = vec3[3](ep.xyy, ep.yxy, ep.yyx);\n    for (int i = min(0,iFrame); i < 3; i++) {\n        norm[i] = getDist(p+eps[i]).x-c;\n    }\n    //vec3 norm = vec3(getDist(p+ep.xyy).x-c, getDist(p+ep.yxy).x-c, getDist(p+ep.yyx).x-c);\n    return normalize(norm);\n}\n\nvec3 reflectRay(vec3 ray, vec3 norm) {\n    float d = dot(ray, norm);\n    vec3 side = ray - d*norm;\n    return -d*norm + side;\n}\n\nvec3 lookupColor(float v) {\n    if (v == 3.) {\n        return vec3(1); //lens\n    }\n    if (v == 2.) {\n        return vec3(.5, 1, .5); //ball\n    }\n    if (v == 1.) {\n        return vec3(1, 0, 0); //box\n    }\n    return vec3(0.3, 0.5, 1); //water\n}\n\n// x: reflectivity, y: transparency, z: refractive index\nvec3 lookupReflectivity(float v) {\n    if (v == 3.) {\n        return vec3(0.0, 0.5, 1.1);\n    }\n    if (v == 2.) {\n        return vec3(0.5, 0.0, 1.0);\n    }\n    if (v == 1.) {\n        return vec3(0.0, 0.3, 1.1);\n    }\n    return vec3(0.3, 0.3, 1.4);\n}\n\nvec3 getColor4(vec3 rp, vec3 rd) {\n    vec2 ref_ray = getRayDist(rp, rd);\n    float refD = ref_ray.x;\n    vec3 refP = rp + rd*refD;\n    vec3 refCol = vec3(0);\n    if (refD > 99.) {\n        return vec3(0);\n    }\n    float refShade = clamp(dot(vec3(0,1,0), getNorm(refP)), .3, 1.);\n    refCol = refShade*lookupColor(ref_ray.y);\n    return refCol;\n}\n\nvec3 getColor3(vec3 rp, vec3 rd) {\n    vec2 first_ray = getRayDist(rp, rd);\n    float d = first_ray.x;\n    vec3 p = rp + rd*d;\n    vec3 norm = getNorm(p);\n    \n    float shade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    \n    if (d > 99.) {\n        return vec3(0);\n    }\n    vec3 ret = shade*lookupColor(first_ray.y);\n    \n    vec3 props = lookupReflectivity(first_ray.y);\n    float reflectivity = props.x;\n    float transparency = props.y;\n    float refractivity = props.z;\n    vec3 refl_dir = reflectRay(rd,norm);\n    vec3 refl_rp = rp + rd*(d-SURF*2.);\n    \n\tvec3 refr_dir = refract(rd,norm,1.0/refractivity);\n    float dotnorm = dot(norm, rd);\n    vec3 refr_rp = rp + rd*(d-SURF*4./dotnorm);\n    \n    vec3 refrCol;\n    vec3 refCol;\n    for (int i = 0; i < 2; i++) {\n        vec3 p, d;\n        if (i == 0) {\n            p = refr_rp;\n            d = refr_dir;\n        } else {\n            p = refl_rp;\n            d = refl_dir;\n        }\n    \tvec3 col = getColor4(p, d);\n        if (i == 0) {\n\t\t\trefrCol = col;\n        } else {\n            refCol = col;\n        }\n    }\n    ret = ret * (1.-reflectivity-transparency) + refCol * reflectivity + refrCol * transparency;\n    return ret;\n}\n\n#ifdef LOD4\nvec3 getColor2(vec3 rp, vec3 rd) {\n    vec2 first_ray = getRayDist(rp, rd);\n    float d = first_ray.x;\n    vec3 p = rp + rd*d;\n    vec3 norm = getNorm(p);\n    \n    float shade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    \n    if (d > 99.) {\n        return vec3(0);\n    }\n    vec3 ret = shade*lookupColor(first_ray.y);\n    \n    vec3 props = lookupReflectivity(first_ray.y);\n    float reflectivity = props.x;\n    float transparency = props.y;\n    float refractivity = props.z;\n    vec3 refl_dir = reflectRay(rd,norm);\n    vec3 refl_rp = rp + rd*(d-SURF*2.);\n    \n\tvec3 refr_dir = refract(rd,norm,refractivity);\n    float dotnorm = dot(norm, rd);\n    vec3 refr_rp = rp + rd*(d-SURF*4./dotnorm);\n    \n    vec3 refrCol;\n    vec3 refCol;\n    for (int i = 0; i < 2; i++) {\n        vec3 p, d;\n        if (i == 0) {\n            p = refr_rp;\n            d = refr_dir;\n        } else {\n            p = refl_rp;\n            d = refl_dir;\n        }\n    \tvec3 col = getColor3(p, d);\n        if (i == 0) {\n\t\t\trefrCol = col;\n        } else {\n            refCol = col;\n        }\n    }\n    ret = ret * (1.-reflectivity-transparency) + refCol * reflectivity + refrCol * transparency;\n    return ret;\n}\n\nvec3 getColor(vec3 rp, vec3 rd) {\n    vec2 first_ray = getRayDist(rp, rd);\n    float d = first_ray.x;\n    vec3 p = rp + rd*d;\n    vec3 norm = getNorm(p);\n    \n    float shade = clamp(dot(vec3(0,1,0), norm), .3, 1.);\n    \n    if (d > 99.) {\n        return vec3(0);\n    }\n    vec3 ret = shade*lookupColor(first_ray.y);\n    \n    vec3 props = lookupReflectivity(first_ray.y);\n    float reflectivity = props.x;\n    float transparency = props.y;\n    float refractivity = props.z;\n    vec3 refl_dir = reflectRay(rd,norm);\n    vec3 refl_rp = rp + rd*(d-SURF*2.);\n    \n\tvec3 refr_dir = refract(rd,norm,1.0/refractivity);\n    float dotnorm = dot(norm, rd);\n    vec3 refr_rp = rp + rd*(d-SURF*4./dotnorm);\n    \n    vec3 refrCol;\n    vec3 refCol;\n    for (int i = 0; i < 2; i++) {\n        vec3 p, d;\n        if (i == 0) {\n            p = refr_rp;\n            d = refr_dir;\n        } else {\n            p = refl_rp;\n            d = refl_dir;\n        }\n    \tvec3 col = getColor2(p, d);\n        if (i == 0) {\n\t\t\trefrCol = col;\n        } else {\n            refCol = col;\n        }\n    }\n    ret = ret * (1.-reflectivity-transparency) + refCol * reflectivity + refrCol * transparency;\n    return ret;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/(iResolution.x);\n\n    vec3 rp = vec3(0,2,-8.);\n    rp.xz = vec2(sin(iTime)*8., -cos(iTime)*8.);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    rd.xz *= rot(-iTime);\n#ifdef LOD4\n    vec3 col = getColor(rp, rd);\n#else\n    vec3 col = getColor3(rp, rd);\n#endif\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}