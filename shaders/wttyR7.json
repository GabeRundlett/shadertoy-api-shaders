{
    "Shader": {
        "info": {
            "date": "1608738153",
            "description": "vesica.",
            "flags": 0,
            "hasliked": 0,
            "id": "wttyR7",
            "likes": 20,
            "name": "SimpleVesicaShape",
            "published": 3,
            "tags": [
                "vesica"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define BASE_COLOR vec3(0.3,0.6,0.3)\n#define BORDER 0.001\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\n// https://www.youtube.com/watch?v=PMltMdi1Wzg&t=367s\nfloat sdSegment(vec2 p, float L, float R) {\n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-R;\n}\n\n// Advice from FabriceNeyret2. cos( a + vec2(0,11) ) does magic!\nfloat layer0(vec2 p){\n    vec2 prevP = p;\n    float r = BORDER;\n    p = abs(p);\n    p -= vec2(0.05);\n    float d = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    p = prevP;\n    \n    p*= Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.05);\n    float d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    \n    d = min(abs(d)-r,abs(d2)-r);\n    \n    /*\n    for(float i = 0.0;i<4.0; i++) {\n        p = prevP;\n        p*= Rot(radians(22.5*i));\n        p = abs(p);\n        p -= vec2(0.115);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n        d = min(d,abs(d2)-r); \n    }\n    */\n    \n    p = prevP;\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.115);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    d = min(d,abs(d2)-r); \n    \n    p = prevP;\n    p = DF(p,8.0);\n    p = abs(p);\n    p -= vec2(0.167);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.099);\n    d = min(d,abs(d2)-r); \n        \n    /*\n    for(float i = 0.0;i<8.0; i++) {\n        p = prevP;\n        p*= Rot(radians(11.25*i));\n        p = abs(p);\n        p -= vec2(0.167);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.099);\n        d = min(d,abs(d2)-r); \n    }\n    */\n    p = prevP;\n    d2 = length(p)-0.32;\n    d = min(d,abs(d2)-r);\n    d2 = length(p)-0.45;\n    d = min(d,abs(d2)-r);    \n    \n    return d;\n}\n\nfloat layer1(vec2 p, float d){\n    vec2 prevP = p;\n    float r = BORDER;\n    float d2 = 0.0;\n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.215);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n    d = min(d,abs(d2)-r); \n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.315);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n    d = min(d,abs(d2)-r); \n        \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.265);\n    d2 = length(p)-0.016;\n    d = min(d,abs(d2)-r);\n    \n    /*\n    for(float i = 0.0;i<16.0; i++) {\n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.215);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n        d = min(d,abs(d2)-r); \n    \n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.315);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n        d = min(d,abs(d2)-r);\n        \n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.28);\n        d2 = length(p)-0.03;\n        d = min(d,abs(d2)-r);\n    }\n    */\n    \n    return d;\n}\n\nfloat layer2(vec2 p, float d, float scale, float scale2, float numline){\n    vec2 prevP = p;\n    float r = BORDER;\n    float d2 = 1.0;\n    \n    float t = iTime *0.1;\n\n    for(float i = 0.0; i<numline; i++){\n        float targetScale1 = 0.3-(i*scale2);\n        float targetScale2 = (0.2-(i*scale2));\n        float targetScale3 = (0.17-(i*scale2));\n        \n        if(i>=4.0) {\n            targetScale1 = (0.3-(i*0.01))*abs(sin(t*i))+0.1*(i*0.1);\n            targetScale2 = (0.2-(i*0.01))*abs(sin(t*i))+0.05*(i*0.1);\n            targetScale3 = (0.17-(i*0.01))*abs(sin(t*i))+0.03*(i*0.1);\n        }        \n        \n        p = prevP;\n        p.x = abs(p.x);\n        p.x -= 0.5*scale;\n        d2 = SimpleVesicaDistance(p*Rot(radians(90.0)),targetScale1*scale,0.2*scale);\n\n        d = min(d,abs(d2)-r*1.0);\n\n        p = prevP;\n        p = abs(p);\n        p -= vec2(0.3)*scale;\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),targetScale1*scale,0.2*scale);\n\n        d = min(d,abs(d2)-r*1.0);    \n\n        p = prevP;\n        p.y = abs(p.y);\n        p.y -= 0.4*scale;\n        d2 = length(p)-targetScale2*scale;\n\n        d = min(d,abs(d2)-r*1.0);\n\n        p = prevP;\n        p = abs(p);\n        p -= vec2(0.35,0.15)*scale;\n        d2 = length(p)-targetScale3*scale;\n\n        d = min(d,abs(d2)-r*1.0); \n    }\n    \n    return d;\n}\n\nfloat VesicaShapeDistance(vec2 p) {\n    float t = iTime*0.2;\n    float d = layer2(p,1.0,1.0,0.02,6.0);\n    d = max(-( length(p)-0.45),d);    \n    \n    float d2 = min(d,layer0(p*Rot(radians(-30.0*t))));\n    float d3 = layer1(p*Rot(radians(30.0*t*0.5)),d2);\n    return d3;\n}\n\nfloat VesicaShapeBackground(vec2 p) {\n    vec2 prevP = p;\n    float d = 1.0;\n    p.x = abs(p.x);\n    p.x -= 0.5;\n    float d2 = SimpleVesicaDistance(p*Rot(radians(90.0)),0.3,0.2);\n\n    d = min(d,d2);\n\n    p = prevP;\n    p = abs(p);\n    p -= vec2(0.3);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.3,0.2);\n\n    d = min(d,d2);    \n\n    p = prevP;\n    p.y = abs(p.y);\n    p.y -= 0.4;\n    d2 = length(p)-0.2;\n\n    d = min(d,d2);\n\n    p = prevP;\n    p = abs(p);\n    p -= vec2(0.35,0.15);\n    d2 = length(p)-0.17;\n\n    d = min(d,d2); \n    \n    p = prevP;\n    \n    d2 = length(p)-0.45;\n    d = min(d,d2); \n    \n    return d;\n}\n\nfloat Background(vec2 p) {\n    float t = iTime *0.3;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n    \n    vec2 prevP = p;\n    vec2 prevP2 = p;\n    \n    float d = layer2(p,1.0,0.3,0.04,3.0);\n    \n    p*=Rot(radians(-30.0*t));\n    prevP*=Rot(radians(-30.0*t));\n    p*=2.5;\n    prevP*=2.5;\n    \n    p = abs(p);\n    p-=vec2(0.105,0.043);\n    float h = mod(t*0.3,0.6);\n    if(h>=0.2){\n        h = 0.2-(h-0.2);\n    }\n    float d2 = sdSegment(p*Rot(radians(-52.0)),h,0.004);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -= 0.105;\n    p.y += 0.042;\n    d2 = sdSegment(p,(h/0.2)*0.085,0.004);\n    d = min(d,d2);\n    \n    p = prevP2;\n    p = abs(p);\n    p-=vec2(0.105,0.043);\n    d2 = sdSegment(p*Rot(radians(-52.0)),0.15,0.001);\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.x = abs(p.x);\n    p.x -= 0.105;\n    p.y += 0.042;\n    d2 = sdSegment(p,0.085,0.001);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat Background2(vec2 p) {\n    float t = iTime *0.3;\n    float thickness = BORDER;\n    float r = 0.05;\n    vec2 prevP = p;\n\n    p.x+= 0.215;\n    p.y+= 0.18;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n\n    p*=Rot(radians(30.0*t*3.0));\n    \n    float d = length(p-vec2(0.0,r*0.5))-r;\n    float d2 =  length(p-vec2(0.0,-r*0.5))-r;\n    \n    d = min(abs(d)-thickness,abs(d2)-thickness);\n    \n    p*=Rot(radians(90.0));\n    d2 = length(p-vec2(0.0,r*0.5))-r;\n    d = min(d,abs(d2)-thickness);\n    d2 =  length(p-vec2(0.0,-r*0.5))-r;\n    d = min(d,abs(d2)-thickness);\n    \n    p = prevP;\n    \n    p.x+= 0.215;\n    p.y+= 0.18;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n    p*=Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.083);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.045,0.03);    \n    d = min(d,abs(d2)-thickness*1.2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec3 col = vec3(0.99,0.98,0.95);\n    \n    vec3 lineCol = vec3(132.0/255.0,153.0/255.0,141.0/255.0);\n    \n    uv.y+=iTime*0.1;\n    uv*=1.3;\n    float d = Background(uv);\n    col = mix(col,lineCol,S(d,0.0));//0.9,0.6,0.5\n    \n    d = Background2(uv);\n    col = mix(col,lineCol,S(d,0.0));\n    \n    uv = prevUV;\n    uv*=1.17;\n    \n    d = VesicaShapeBackground(uv);\n    col = mix(col,vec3(245.0/255.0,253.0/255.0,163.0/255.0)*1.45,S(d,-0.06));\n    \n    uv = prevUV;\n    uv*=1.25;\n    d = VesicaShapeDistance(uv);\n    col = mix(col,vec3(140.0/255.0,152.0/255.0,171.0/255.0),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}