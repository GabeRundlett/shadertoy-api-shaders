{
    "Shader": {
        "info": {
            "date": "1705770576",
            "description": "Format 24 heures",
            "flags": 0,
            "hasliked": 0,
            "id": "4ffXWX",
            "likes": 17,
            "name": "Heure Nixie",
            "published": 3,
            "tags": [
                "heure24h"
            ],
            "usePreview": 0,
            "username": "Tibalt",
            "viewed": 281
        },
        "renderpass": [
            {
                "code": "#define TWELVE_HOUR_CLOCK   1\n#define GLOWPULSE    1\n#define SECONDS      1\n#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n// hash function \nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Distance to a number This handles 2 digit integers, leading 0's will be drawn\nfloat dfNumberInt(vec2 origin, int inum, vec2 uv)\n{\n    float num = float(inum);\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 1.0;i >= 0.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\t\t\n        dist = min(dist, dfDigit(pos, d, uv));\n        offs++;\n\t}\n\treturn dist;\t\n}\n\nfloat dfColon(vec2 origin, vec2 uv) {\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n    return dist;\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *0.86;\n\t\n    \n    int hour = int(iDate.w/3600.);\n#if TWELVE_HOUR_CLOCK\n    if( hour > 24 ) hour -= 24;\n    if( hour == 24 ) hour = 00;\n#endif\n    int minute = int(mod(iDate.w/60.,60.));\n    //minute = 55;\n    \n    \n\tfloat nsize = numberLength(9999.);\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n    vec2 basepos = pos;\n    pos.x = basepos.x + 0.16;\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumberInt(pos, hour, uv));\n    \n    pos.x = basepos.x + 0.39;\n\tdist = min(dist, dfColon( pos, uv ));\n    \n    pos.x = basepos.x + 0.60;\n    float dist2 = 1e6;\n\tdist = min(dist, dfNumberInt(pos, minute, uv));\n\n \n#ifdef SECONDS\n    int seconds = int(mod(iDate.w,60.));\n\n    uv *= 2.1;\n    pos = basepos;\n    pos.y -= 0.45;\n    pos.x += 0.38;\n\tdist = min(dist, dfNumberInt(pos, seconds, uv));\n#endif\n    \n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.003 / (dist);\n\t\n\tcolor += vec3(1,2.2,4) * shade;\n#if GLOWPULSE\n\tcolor += vec3(1,1.2,0) * shade * noise((uv + vec2(iTime*.5)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n#endif\n\n    #ifdef SHOW_GRID\n    float grid = 0.2-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}