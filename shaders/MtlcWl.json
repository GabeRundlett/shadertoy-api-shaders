{
    "Shader": {
        "info": {
            "date": "1507032692",
            "description": "Stripes and shadows.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtlcWl",
            "likes": 0,
            "name": "ML Stripe Shader",
            "published": 3,
            "tags": [
                "2d",
                "morninglight"
            ],
            "usePreview": 0,
            "username": "aaaidan",
            "viewed": 207
        },
        "renderpass": [
            {
                "code": "// HEY! Mousedown to change area type\n\n// Constants\n#define PI 3.141592654\n#define TWO_PI 6.28318530718\n\n// Parameters\n#define STRIPE_COLOR1 (vec4(194, 216, 68, 255)/255.)\n#define STRIPE_COLOR2 (vec4(194, 216, 68, 0)/255.)\n#define STRIPE_WIDTH 50.0\n#define STRIPE_ANGLE -45.0\n#define BACKGROUND_COLOR (vec4(235, 232, 222, 255)/255.)\n#define CIRCLE_RADIUS 150.0\n#define SHADOW_COLOR (vec4(0,0, 0, 100)/255.)\n#define SHADOW_DEPTH 7.0\n#define SHADOW_SIZE 15.0\n#define SHADOW_SCALE 2.0\n#define GRID_LINE_WIDTH 1.5\n#define GRID_COLOR (vec4(255.,255.,255.,255.)/255.)\n#define GRID_COLOR2 (vec4(0.,0.,0.,9.)/255.)\n#define GRID_X_SIZE 150.0\n#define GRID_Y_SIZE 150.0\n#define EXCLUSION_COLOR (vec4(.4,.4,.4,1.0))\n\n// Calculations\n#define _STRIPE_SCALE (1.0/STRIPE_WIDTH)\n#define _HALF_SHADOW_SIZE (SHADOW_SIZE/2.0)\n\nvec4 blend(in vec4 under, in vec4 over) {\n    float outA = over.a + under.a * (1.0 - over.a);\n    vec3 outCol = vec3(0.0);\n    if (outA > 0.0) {\n    \toutCol = ( over.rgb*over.a + under.rgb*under.a*(1.0-over.a) ) / outA;\n    }\n    return vec4(outCol,outA);\n}\n\nvec4 stripes( in vec2 fragCoord, in bool stripey, float exclusionAmt)\n{\n    vec2 center = iResolution.xy / 2.0;\n    \n    bool inCircle = \n        pow(fragCoord.x - center.x, 2.) + \n        pow(fragCoord.y - center.y, 2.) <\n        CIRCLE_RADIUS * CIRCLE_RADIUS;\n    \n    if (!stripey) {\n        vec4 col = blend(STRIPE_COLOR1, vec4(EXCLUSION_COLOR.rgb,exclusionAmt));\n        return inCircle ? col : vec4(col.rgb, 0.0);\n    }\n    \n    float angle = (STRIPE_ANGLE) / 360.0 * TWO_PI;\n    \n    float sx = sin(angle) * (fragCoord.x - iMouse.x);\n    float sy = cos(angle) * (fragCoord.y - iMouse.y);\n    \n    float amt = sin((sx + sy) * TWO_PI * _STRIPE_SCALE);\n    \n    vec4 color = amt > 0.0 ? vec4(STRIPE_COLOR1) : vec4(STRIPE_COLOR2);\n    \n    return vec4(color.rgb, inCircle ? color.a : 0.0);\n}\n\nfloat smoothbump(float min, float max, float slope, float val) {\n    return smoothstep(min,min+slope,val) - \n        smoothstep(max-slope, max, val);\n}\n\nvec4 grid(in vec2 fragCoord) {\n    float angle = (STRIPE_ANGLE + iTime*3.6) / 360.0 * TWO_PI;\n    \n    vec2 s1 = vec2(\n        sin(angle) * (fragCoord.x - iMouse.x),\n    \tcos(angle) * (fragCoord.y - iMouse.y)\n\t);\n    vec2 s2 = vec2(\n        sin(angle + PI/2.0) * (fragCoord.x - iMouse.x),\n    \tcos(angle + PI/2.0) * (fragCoord.y - iMouse.y)\n\t);\n    \n    float sizeMod = (sin(iTime*0.15)*0.5+0.5) * 50.0;\n    \n    float amt = min(1.0,\n        smoothbump(0.0, GRID_LINE_WIDTH + 1.0, 1.0, mod(s1.x + s1.y, GRID_X_SIZE + sizeMod) ) +\n        smoothbump(0.0, GRID_LINE_WIDTH + 1.0, 1.0, mod(s2.x + s2.y, GRID_Y_SIZE + sizeMod) )\n\t);\n    \n    return vec4(GRID_COLOR.rgb, amt * GRID_COLOR.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    bool stripey = iMouse.z > 0.0;\n    float exclusionAmt = (!stripey ? 1.0 : 0.0) * (1.0 - smoothstep(iResolution.x*0.4 + 0.,iResolution.x*0.4 + 1.,fragCoord.x - fragCoord.y*0.1));\n    \n    vec4 grid = grid(fragCoord);\n    \n\tfragColor  = stripes(fragCoord + vec2(-.25,-.25), stripey, exclusionAmt);\n    fragColor += stripes(fragCoord + vec2(-.25, .25), stripey, exclusionAmt);\n    fragColor += stripes(fragCoord + vec2( .25,-.25), stripey, exclusionAmt);\n    fragColor += stripes(fragCoord + vec2( .25, .25), stripey, exclusionAmt);\n    fragColor /= 4.0;\n    \n    float grid2Amt = GRID_COLOR2.a * grid.a;\n    \n    fragColor = vec4( GRID_COLOR2.rgb * grid2Amt + fragColor.rgb * (1. - grid2Amt),\n                     fragColor.a);\n    \n    if (!stripey) {\n        \n        // outline\n        float minOutlineSample = 999999.;\n        \n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 2.1,-2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2(-2.1,-2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 2.1, 2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2(-2.1, 2.1), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 0.0,-3.0), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 0.0, 3.0), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2( 3.0, 0.0), stripey, 0.0).a);\n        minOutlineSample = min(minOutlineSample, stripes(fragCoord + vec2(-3.0, 0.0), stripey, 0.0).a);\n        \n        float outlineAmt = (1.0 - minOutlineSample);\n        \n        fragColor = vec4(\n            outlineAmt * vec3(1.0,1.0,1.0) + (1.-outlineAmt) * fragColor.rgb,\n            fragColor.a);\n        \n        // shadow\n        float totalSamples = 0.0;\n        float shadowAmt = 0.0;\n        for (float x=0.;x < SHADOW_SIZE; x+=1.) {\n            for (float y=0.;y < SHADOW_SIZE; y+=1.) {\n                // this is my attempt at a circular (lens) blur \n                float sampleAmt = length(SHADOW_SCALE*(vec2(x,y) - _HALF_SHADOW_SIZE));\n                sampleAmt = 1.0 - step(SHADOW_SCALE*_HALF_SHADOW_SIZE, sampleAmt);\n\n                shadowAmt += stripes(\n                    fragCoord + vec2(\n                        SHADOW_SCALE*(x - _HALF_SHADOW_SIZE),\n                        SHADOW_SCALE*(y - _HALF_SHADOW_SIZE) + SHADOW_DEPTH\n                    ),\n                    stripey, 0.0\n                ).a * sampleAmt;\n                totalSamples += sampleAmt;\n            }\n        }\n        shadowAmt /= totalSamples;\n        \n    \tvec4 shadow = vec4(SHADOW_COLOR.rgb, SHADOW_COLOR.a * shadowAmt);\n    \tfragColor = blend(shadow, fragColor);\n    }\n    \n    // grid\n    fragColor = blend(grid, fragColor);\n    \n    fragColor = blend(BACKGROUND_COLOR, fragColor);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}