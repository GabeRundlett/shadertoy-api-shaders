{
    "Shader": {
        "info": {
            "date": "1691077009",
            "description": "inspired from Sig'23:  iteratively find a mapping between 2 arbitrary shapes\nHere: from disk to square (cf Common )\nChange buffA#14:dt for better precision\nshow square UV map + some corresponding dots (→ disc)\nSwitch comments in Image:8,9 for averaging",
            "flags": 32,
            "hasliked": 0,
            "id": "mlXyRf",
            "likes": 17,
            "name": "automatic mapping between shapes",
            "published": 3,
            "tags": [
                "mapping",
                "iadb"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "// inspired from Sig'23 \"Iterative 𝛼-(de)Blending\" https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// Fork of https://shadertoy.com/view/mdX3Wl\n\n#define blend(d)  O = mix( O, vec4(1), smoothstep( 2./R.y, 0., abs(d) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // O = T(u);                        // O.xy = UV coords\n    O = texture(iChannel0, u/R, 2.); // averaged version\n                                 \n    vec2  P = 2.*O.xy - 1., d, C;    // --- draw UV map --------------------------------\n    float l = length(P), a = atan(P.y,P.x);             // polar coords    \n    O = \n //     iMouse.z > 0. ? // texture(iChannel1, O.xy)     // map texture\n //                        sin(32.* vec4(l,a/2.,0,0) )  // polar grid\n //                   :   \n                           sin(128.*O);                 // show UV grid\n                        // vec4(l,fract(a/6.28),0,0) ;  // UV in polar coords\n                        // sin(32.* vec4(l,a/2.,0,0) ); // polar grid\n                      \n    l = 1e9;                         // --- plot N² UV dots ----------------------------\n    int N = 15;\n    for( int i = 0; i < N*N; i++ )                      // plot some UV coords.\n        d = ( .5 + vec2(i%N,i/N) )/float(N),\n        P = T( d * R ).xy * R - u,                      // offset to current pixel\n        a = dot(P,P),            \n        a < l ? l = a, C = d : C;                       // keep min dist² and corresponding Id\n    O = mix( O, vec4(C,1,1), smoothstep( 5.5, 4., sqrt(l) ) ); // draw dots\n                \n    d = c - u/R;                     // --- draw source & target shapes --------               \n    blend( length( d )  - r );\n    d = abs(r - u/R);\n    blend( max(d.x,d.y) - r );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// inspired from Sig'23 \"Iterative 𝛼-(de)Blending\" https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// Shapes can have any topological genus and dimension. Can be superimposed.\n// Weighting on shapes can be consider (tune the sampler accordingly).\n\n// shape parameters c,r in Common :   disc( (c,c), r ) , square [0,2r]²\n\n#define hash2(p) fract(sin(mod((p)*mat2(127.1,311.7, 269.5,183.3),6.283)) *3758.5453123)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if (iFrame==0) O = vec4(2.*r *u/R,0,0);              // init: P maps the square\n    else {\n        O = T(u);                                        // previous state\n        float dt = 1./600., t = float(iFrame)*dt;\n        if ( t > 1. ) return;                            // end of iterations\n        \n         vec2 P = O.xy,                                  // P: previous pivot\n              H,\n              A,                                         // point in the source shape ( square )\n              B;                                         // point in the target shape ( disc )\n        bool ok = false;\n                                                         // ------- deblending phase --------        \n        for( float i=0.; i++ < 6e2 && ok == false ; ) {  // rejection sampling\n            H = hash2( P +t -i/1.3 +u/R );               // random vec2\n            if ( t < .5 )                                // --- if first half of iterations:\n                B = c + r * sqrt(H.x) * cos( 6.283*H.y + vec2(0,1.57)), // B sampled in disc\n                A = ( P - t*B ) / (1.-t),                // A such that (1-t)A + tB = P\n                H = abs(A-r), \n                ok = max(H.x,H.y) < r;                   // reject up to A in square\n\n            else                                         // --- if second half if iterations: \n                A = 2.*r*H,                              // A sampled in square\n                B = ( P - (1.-t)*A ) / t,                // B such that (1-t)A + tB = P   \n                ok = length(B-c) < r;                    // reject up to B is disc\n       }\n                                                         // ------- blending phase --------\n       if (ok) O.xy = mix(A,B,t+dt);                     // new pivot between A and B\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// float c = .5, r = .5;           // unit disc( (.5,.5), .5 ) to unit square [0,1]²\n   float c = .75, r = .25;         // disc( (c,c), r ) to square [0,2r]²\n\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}