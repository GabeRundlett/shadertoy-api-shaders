{
    "Shader": {
        "info": {
            "date": "1500968542",
            "description": "Legend of the Gelatinous Cube\n\nCollect all keys and escape the dungeons filled with gelatinous cubes.\n\n- Arrow keys: move\n- Space: fight & open doors.",
            "flags": 48,
            "hasliked": 0,
            "id": "Xs2Bzy",
            "likes": 30,
            "name": "[SH17B] Legend of the Gelatinous",
            "published": 3,
            "tags": [
                "game",
                "raymarch",
                "voxel",
                "dungeon",
                "crawler"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 2560
        },
        "renderpass": [
            {
                "code": "// Legend of the Gelatinous Cube. Created by Reinder Nijhoff 2017\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/Xs2Bzy\n//\n// I created this shader in one long night for the Shadertoy Competition 2017\n// \n\n// RENDER THE DUNGEON AND ADD UI FROM BUFFER B\n\n#define MAXSTEPS 8\nconst int MOVESTEPS = 60;\nconst int USERMOVESTEPS = 30;\nconst int USERROTATESTEPS = 30;\nconst int DOORMOVESTEPS = 30;\nconst int MAXSWORD = 30;\nconst int REDFLASHSTEPS = 15;\n\nconst int NONE = 0;\nconst int FORWARD = 1;\nconst int BACK = 2;\nconst int ROT_LEFT = 3;\nconst int ROT_RIGHT = 4;\nconst int ACTION = 5;\n\nvec3 USERRD = vec3(0);\n\nconst ivec2 DIRECTION[] = ivec2[] (\n    ivec2(0,1),\n    ivec2(1,0),\n    ivec2(0,-1),\n    ivec2(-1,0)\n);\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\n\nvec2 boxIntersection(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    if( !(time.y>time.x && time.y>0.0) ) return vec2(-1);\n    \n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return time;\n}\n\nivec4 m(ivec2 uv) {\n    return ivec4(texelFetch(iChannel0, uv + ivec2(32,0), 0));\n}\n\nivec4 w(ivec2 uv) {\n    return ivec4( texelFetch(iChannel0, uv, 0) );\n}\n\n\n//----------------------------------------------------------------------\n// Material helper functions\n\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\n\nfloat onLine( const float c, const float b ) {\n\treturn clamp( 1.-abs(b-c), 0., 1. );\n}\nfloat onBand( const float c, const float mi, const float ma ) {\n\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\n\tfloat xl = clamp( (c.x-lt.x)/size, 0., 1. ); \n\tfloat xr = clamp( (rb.x-c.x)/size, 0., 1. );\t\n\tfloat yt = clamp( (c.y-lt.y)/size, 0., 1. ); \n\tfloat yb = clamp( (rb.y-c.y)/size, 0., 1. );\t\n\n\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\n}\nfloat stepeq( float a, float b ) { \n\treturn step( a, b )*step( b, a );\n}\n//----------------------------------------------------------------------\n// Generate materials!\n\nvoid decorateWall(in vec2 uv, const float decorationHash, inout vec3 col ) {\t\n\tvec3 fgcol;\n\t\n\tuv = floor( mod(uv+64., vec2(64.)) );\n\tvec2 uvs = uv / 64.;\n\t\n\t// basecolor\n\tvec3 basecol = col;\t\n\tfloat br = hash12(uv);\n\n\t\n// prison door\t\n\tif( decorationHash > 0.95 ) {\t\n\t\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\n\t// shadow\n\t\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\n\t// hinge\n\t\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\n\t\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\n\t\t\n\t\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \n\t\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \n\t\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\n\t\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\n\t\t\n\t\tfgcol = COL(72.,72.,72.);\n\t\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\n\t\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\n\t\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\n\t\t\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\n\n\t\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\n\t\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\n\n\t\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\n\t}\t\n// fake 8-bit color palette and dithering\t\n\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)/32.)*32.)/32.;\n}\n\n// store functions\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\n// map\n\nvec4 debugMap( in vec2 fragCoord ) {\n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\n   \tivec2 uv = ivec2(fragCoord.xy * .1);\n    vec4 col = vec4(1);\n    if( uv.x < 32 && uv.y < 32 ) {\n        vec4 wall = texelFetch(iChannel0, uv, 0);\n        vec4 monster = texelFetch(iChannel0, uv+ivec2(32,0),0);\n        \n        if( wall.x > 0. ) col.rgb = vec3(0,0,0);\n        if( wall.x > 1. ) col.rgb = vec3(0,1,0);\n        if( wall.x > 2. ) col.rgb = vec3(0,0,1);\n        if( wall.x > 5. ) col.rgb = vec3(0,1,1);\n        if( monster.x > 0. ) col.rgb = vec3( monster.y<0.?1.:.5,0,0);\n    }\n    if( uv.x == ud1.x && uv.y == ud1.y ) col = vec4(1,0,1,1);\n    return col;\n}\n\n// draw level\n\nvec4 drawSword( vec2 uv, int level ) {\n    uv = floor(fract(uv)*64.) - 32.;\n    if( abs(uv.x) < 16. && abs(uv.y) < 16. ) {\n        float l = step(abs(uv.y), .5); \n        l = max(l, step(abs(uv.y), 1.5) * step(uv.x, 13.));   \n        l = max(l, step(abs(uv.y), 5.5) * step(abs(uv.x+9.), 1.));\n                        \n\t    vec3 col = mix( vec3(.8), vec3(.5,.3,.2), step(uv.x, -11.));\n        vec3 scol = mix( vec3(.5,.3,.2), vec3(1.), clamp(float(level) / float(MAXSWORD/2), 0., 1.) );\n        scol = mix( scol, vec3(0.,.9, 1.), clamp(float(level-MAXSWORD/2) / float(MAXSWORD/2), 0., 1.) );\n        col = mix( scol, col, step(uv.x, -8.));        \n        \n        return vec4( 2. * l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, l );\n    } else {\n        return vec4(0);\n    }\n}\n\nvec4 drawKey( vec2 uv, int color ) {\n    uv = floor(fract(uv)*64.) - 32.;\n    if( abs(uv.x) < 16. && abs(uv.y) < 16. ) {\n        float l = step(abs(uv.y), 1.);\n        l = max(l, step(length(uv+vec2(8,0)), 7.5));\n        l -= step(length(uv+vec2(8,0)), 4.5);\n        l = max(l, step(6.,uv.x)*step(uv.x, 7.)*step(0.,uv.y)*step(abs(uv.y), 5.));\n        l = max(l, step(10.,uv.x)*step(uv.x, 11.)*step(0.,uv.y)*step(abs(uv.y), 7.));\n        l = max(l, step(14.,uv.x)*step(0.,uv.y)*step(abs(uv.y), 6.));\n        \n\t    vec3 col = vec3(0);\n    \tcol[color-7] = 1.;\n        return vec4( 2. * l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, l );\n    } else {\n        return vec4(0);\n    }\n}\n\nvec4 drawLock( vec2 uv, int color ) {\n    uv = floor(fract(uv)*64.) - 32.;\n    if( abs(uv.x) < 6. && abs(uv.y) < 8. ) {\n        float l = 1.;\n        l -= smoothstep( 3., 2., length(uv+vec2(0,2.5)));\n        l = min( l, 1.-step(abs(uv.x),.5)*step(abs(uv.y), 5.));\n\t    vec3 col = vec3(0);\n    \tcol[color-3] = 1.;\n        return vec4( l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, 1 );\n    } else {\n        return vec4(0);\n    }\n}\n\nvec4 drawHealth( vec2 uv ) {\n    uv = floor(fract(uv)*64.) - 32.;\n    if( abs(uv.x) < 12. && abs(uv.y) < 12. ) {\n        vec4 col = vec4( 1,1,1, smoothstep( 10., 9., length(uv)) );\n        col.rgb = mix( col.rgb, vec3(1,0,0), step(abs(uv.y), 1.)*step(abs(uv.x),7.) );\n        col.rgb = mix( col.rgb, vec3(1,0,0), step(abs(uv.y), 7.)*step(abs(uv.x),1.) );\n        return vec4( 2.*col.rgb * (.5 + .5 * texture(iChannel1, uv/64.).x), col.a );\n    } else {\n        return vec4(0);\n    }\n}\n\n\nvec3 getLight( vec3 pos, float d, vec3 nor ) {\n    return vec3(0.,0.05, 0.2) * smoothstep(0., 6., d) * smoothstep(6., 5.5, d) + // fog\n        (0.5 + 0.4*dot(nor, -USERRD)) \n        * (1. + .025*sin(iTime * 20. + cos(iTime*10.))) * vec3(1., .9, .6) * clamp(7./(d*d)-.1, 0., 1.);\n}\n\nvoid getCeilingColor( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tfloat d = -(ro.y-1.)/rd.y;\n\tvec3 pos = ro + rd * d;\n    col = texture(iChannel1, floor(pos.xz*64.)/64.,0.).rgb * vec3(.5, .4, .3);\n    col *= getLight(pos, d, vec3(0,-1,0)) * .8;\n}\n\nvoid getFloorColor( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tfloat d = -(ro.y)/rd.y;\n\tvec3 pos = ro + rd * d;\n    col = texture(iChannel1, floor(pos.xz*64.)/64.,0.).rgb * vec3(.5, .4, .3) * 1.2;\n    \n    ivec4 map = w(ivec2(pos.xz));\n    if( map.x > 8 ) {\n        vec4 s = drawHealth(pos.xz);\n        col = mix(col, s.rgb, s.a);\n    } else if( map.x > 6 ) { // key\n        vec4 s = drawKey( pos.xz, map.x );\n        col = mix( col, s.rgb, s.a);\n    } else if( map.x > 5 ) {\n        vec4 s = drawSword( pos.xz, map.z );\n        col = mix( col, s.rgb, s.a);\n    }\n    \n    col *= getLight(pos, d, vec3(0,1,0));\n}\n\nbool getMapColorForPosition( \n    const vec3 ro, const vec3 rd, const vec3 vos, \n    const vec3 pos, const vec3 nor, const float t, in ivec4 map, inout vec3 col ) {\n    \n    if( map.x > 1) {\n        if( map.x < 6 ) {\n        // a door is hit\n            float h = .95*min(float(map.w),float(DOORMOVESTEPS))/float(DOORMOVESTEPS);\n            vec3 mpos = vec3( vos.x+.5, .5+h, vos.z+.5);\n            vec3 nn;\n            vec3 dim = map.y == 1 ? vec3(.025, .5, .5) : vec3(.5, .5, .025 );\n            vec2 intersect = boxIntersection(ro - mpos, rd, dim, nn);\n            vec3 p = ro + rd * intersect.x;\n\n            if( intersect.x > 0. && p.y < 1.) {\n                vec2 i = map.y == 1 ? p.yz : p.yx; \n                i.x -= h;\n                vec2 uv = floor(i*64.);\n                col = (.2+.5*texture(iChannel1,uv/64.,0.).rgb) * vec3(1.,.6, .4);\n                col.rgb *= .5 + .5*step( 1., mod(uv.y, 8.) );\n                if( map.x > 2) {\n                \tvec4 s = drawLock( -i.yx, map.x );\n                \tcol = mix( col, s.rgb, s.a);\n                }\n                col *= getLight(p, intersect.x, nn);         \n                return true;\n            }\n        }\n        return false;\n    } else {    \n \t\tif( pos.y <= 1. && pos.y >= 0. ) {\n\t    // a wall is hit\n        \tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\n            vec2 uv = floor(mpos*64.);\n        \tcol = texture(iChannel2, uv/64.,0.).rgb * .7;  \n            decorateWall( uv, hash12(vos.xz), col.rgb );        \n        \tcol *= getLight(vos, t, vec3(nor.x,0,nor.z));\n        \treturn true;\n    \t}\n    }\n    return false;\n}\n\nbool getMonsterColorForPosition( \n    const vec3 ro, const vec3 rd, const vec3 vos, \n    const vec3 pos, const vec3 nor, const float t, inout vec3 col,\n\tivec4 monster ) {\n    \n    vec3 mpos = vec3( vos.x+.5, .5, vos.z+.5);\n    if( monster.y != 0 ) {\n\t    mpos.xz += float(monster.y)/float(MOVESTEPS) * vec2(DIRECTION[monster.z-1]);\n    }\n    \n    vec3 nn;\n    vec3 roo = ro-mpos+ sin(rd*1e2+5.*iTime)*.0025;\n    vec3 rdd = rd + sin(rd*70.+iTime)*.01;\n    \n    float size = .2 + .025*smoothstep( 0., 30., float(monster.w));\n    \n    vec2 intersect = boxIntersection(roo, rdd, vec3(size), nn);\n    if( intersect.x > 0.) {\n       col = mix( vec3(.5,0,0), vec3(0,1,0), float(monster.w)/30.);\n       col.b = .5+.5*sin(iTime);\n       vec3 i = intersect.x*rd+ro-mpos;\n       vec2 texUV;\n       if( abs(nn.x) > .5 ) {\n           texUV = i.yz;\n       } else {\n           texUV = i.xy;           \n       }\n       texUV += vec2(sin(iTime*5.+20.*texUV.y),cos(iTime*4.+20.*texUV.x))*.01;\n       col *= .5 +.5*texture(iChannel1, floor(texUV*64.)/64.,0.).x;\n        float hl = hash13( floor(vec3(texUV*64.,iTime+hash12(floor(texUV*64.)))));\n       col += .2 * hl * hl * hl;\n       col = mix( col, normalize(i)*.5+.5, .25);\n       col *= getLight(intersect.x*rd+ro, intersect.x, nn) *(.5 + smoothstep(4., 1., intersect.x) * .1/dot(i,i));\n       return true;\n    }\n    \n    return false;\n}\n\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ )\t{\n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\t\t\n        \n\t\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\t\tfloat t = max ( mini.x, mini.z );\t\n        \n        ivec4 map = w(ivec2(pos.xz));\n        \n        \n        vec3 h = ro + rd*t;     \n        if( h.y > 1. || h.y < 0. ) {\n            if( rd.y < 0. ) {\n                getFloorColor(ro, rd, col);\n            } else {\n                getCeilingColor(ro, rd, col);\n            }\n            return true;\n        }\n        \n\t\tif( map.x > 0 ) { \t\t\n\t\t\thit = getMapColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), t, map, col );\n        }\n        ivec4 monster = m(ivec2(pos.xz));\n        if( monster.x > 0 && !hit) { \t\t\n\t\t\thit = getMonsterColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), t, \n                                                  col, monster );\n        }\n        if( hit ) return true;\n\t}\n\treturn hit;\n}\n\nvec4 render(in vec2 fragCoord) {\n    float time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n\tvec3 ro = vec3( mod(iTime, 31.) + 1.,.5, mod(iTime*1.1, 31.) + 1. );\n    \n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\n    \n    vec2 USERCOORD = vec2(ud1.xy);\n    int USERDIR = ud1.z;\n    int actionCount = ud1.w;\n    int action = ud2.x;\n \n    vec3 dir = vec3(DIRECTION[USERDIR].x, 0, DIRECTION[USERDIR].y);\n    \n    ro = vec3(USERCOORD.x + .5, .5, USERCOORD.y + .5 );\n    float angle = 0.;\n    \n    if( action == FORWARD ) {\n        float progress = float(actionCount)/float(USERMOVESTEPS);\n        ro -= dir * progress;\n    }\n\tif( action == BACK ) {\n        float progress = float(actionCount)/float(USERMOVESTEPS);\n        ro += dir * progress;\n    }\n    if( action == ROT_RIGHT ) {\n        float progress = float(actionCount)/float(USERROTATESTEPS);\n        angle = -progress * 1.57079632679;\n    }\n    if( action == ROT_LEFT ) {\n        float progress = float(actionCount)/float(USERROTATESTEPS);\n        angle = progress * 1.57079632679;\n    }\n    \n    \n    vec3 rd = rotate( dir, angle );\n    USERRD = rd;\n    rd.y -= 0.025;\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rd ));\n    vec3 vv = normalize(cross(rd,uu));\n    rd = normalize( p.x*uu + p.y*vv + 2.25*rd );\n    \n\tvec3 col = vec3(0.);\n    castRay( ro, rd, col );\n    return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col = debugMap( fragCoord );\n    col = render( fragCoord );\n   // col = mix( col, debugMap( fragCoord ), .5);\n    \n    int flash = ivec4( texelFetch( iChannel3, ivec2(0), 0 ) ).y;\n    \n    col.rgb = mix( col.rgb, vec3(1,0,0), float(flash) / 120. );\n    \n    vec4 ui = texture(iChannel3, fragCoord/iResolution.xy);    \n    col = mix( col, ui, min(1.,ui.a) );\n    \n\tfragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Legend of the Gelatinous Cube. Created by Reinder Nijhoff 2017\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/Xs2Bzy\n//\n// I created this shader in one long night for the Shadertoy Competition 2017\n// \n\n// GAME LOGIC\n\nconst int MOVESTEPS = 60;\nconst int USERMOVESTEPS = 30;\nconst int USERROTATESTEPS = 30;\nconst int USERACTIONSTEPS = 30;\nconst int DOORMOVESTEPS = 30;\nconst int DOOROPENSTEPS = 300;\nconst int MAXSWORD = 30;\n\nconst ivec2 DIRECTION[] = ivec2[] (\n    ivec2(0,1),\n    ivec2(1,0),\n    ivec2(0,-1),\n    ivec2(-1,0)\n);\n\nivec2 USERCOORD = ivec2(0);\nivec2 USERACTIONCOORD = ivec2(0);\nint USERDIR = 0;\nint USERACTION = 0;\nint USERACTIONCOUNT = 0;\nivec4 USERINV = ivec4(0);\n\nconst int NONE = 0;\nconst int FORWARD = 1;\nconst int BACK = 2;\nconst int ROT_LEFT = 3;\nconst int ROT_RIGHT = 4;\nconst int ACTION = 5;\n\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// store functions\n\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvoid StoreIVec4( in ivec2 vAddr, in ivec4 vValue, inout ivec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? ivec4(vValue) : fragColor;\n}\n\n// key functions\n\n// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\n\n\nbool KP(int key) {\n\treturn texelFetch( iChannel2, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KT(int key) {\n\treturn texelFetch( iChannel2, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\n// map functions\n\nivec4 createStatic(int level, ivec2 coord) {\n    ivec4 data = ivec4(0);\n    if( coord.x < 32 ) { // static data\n        // create walls\n  \t\tint wall = 1-int(step(texelFetch(iChannel1, coord, 0).x,.575));\n    \tif( coord.x % 31 == 0 || coord.y % 31 == 0) wall = 1;\n        data = ivec4(wall,0,0,0);\n\n        if( wall == 0 ) {\n            float hash = hash12( vec2(coord*9) );\n            // swords\n            if( hash > .96) {\n                data = ivec4( 6, 0, 1 + \n                       int( max(0., .35*( hash12( vec2(coord.yx) ) * 32. + float(coord.x) + float(coord.y)) )), 0 );\n            }\n            if( hash < .05 ) {\n                data = ivec4(10, 0, 8 + (coord.x+coord.y)/10, 0);\n            }\n        }\n\n        \n        // doors\n        StoreIVec4( ivec2( 2, 9), ivec4(2,2,0,0), data, coord);\n        StoreIVec4( ivec2( 8,16), ivec4(2,2,0,0), data, coord);\n        StoreIVec4( ivec2( 9, 8), ivec4(2,2,0,0), data, coord);\n        StoreIVec4( ivec2(24, 9), ivec4(2,2,0,0), data, coord);\n        StoreIVec4( ivec2(17,15), ivec4(2,2,0,0), data, coord);\n        StoreIVec4( ivec2(24,13), ivec4(2,2,0,0), data, coord);\n        StoreIVec4( ivec2(14, 3), ivec4(2,2,0,0), data, coord);\n        \n        StoreIVec4( ivec2(10, 5), ivec4(2,1,0,0), data, coord);\n        StoreIVec4( ivec2( 3,13), ivec4(2,1,0,0), data, coord);        \n        \n        \n        StoreIVec4( ivec2( 3,21), ivec4(3,2,0,0), data, coord); // red door\n        StoreIVec4( ivec2(17,18), ivec4(4,2,0,0), data, coord); // blue door\n        StoreIVec4( ivec2(20,24), ivec4(5,1,0,0), data, coord);\n        \n        // data\n        \n        StoreIVec4( ivec2( 2, 2), ivec4(6,0,5,0), data, coord); // sword\n        \n        StoreIVec4( ivec2( 6,11), ivec4(7,0,1,0), data, coord); // red key\n        StoreIVec4( ivec2( 2,26), ivec4(8,0,1,0), data, coord); // blue key\n        StoreIVec4( ivec2(29,16), ivec4(9,0,1,0), data, coord); // blue key \n    }\n    return data;\n}\n\nivec4 createMonsters(int level, ivec2 coord ) {\n    ivec4 data = ivec4(0);\n    if (coord.x < 64 ) { // monsters\n        coord -= ivec2(32,0);\n        \n        if( createStatic( level, coord ).x < 1 &&\n\t\t\thash12( vec2(coord) ) > (1. - float(coord.x) * .005 - float(coord.y) * .005) ) {\n            data.x = 1;\n            data.w = 5 + (coord.x+coord.y)/2;\n        }\n    }\n    \n    return data;\n}\n\nivec4 createMap(int level, ivec2 coord) {\n    if( coord.x < 32 ) {\n    \treturn createStatic(0, coord);\n    } else {\n    \treturn createMonsters(0, coord);\n    }\n}\n\nivec4 m(ivec2 uv) {\n    return ivec4(texelFetch(iChannel0, uv + ivec2(32,0), 0));\n}\n\nivec4 w(ivec2 uv) {\n    return ivec4( texelFetch(iChannel0, uv, 0) );\n}\n\nbool isMonster(ivec4 data) {\n    return data.x > 0;\n}\n\nbool monsterIsMoving(ivec4 data) {\n    return abs(data.y) > 0;\n}\n\nbool isEmpty(ivec2 coord) {\n    // return true;\n    ivec4 wall = w(coord);\n    ivec4 monster = m(coord);\n    \n    return !isMonster(monster) &&\n        (wall.x < 1 ||  // no wall or\n        (wall.x > 1 && wall.z == 1) || // open door\n        wall.x > 5) // swords and keys\n        && !(coord.x == USERCOORD.x && coord.y == USERCOORD.y);\n}\n\nivec4 updateMap(int level, ivec2 coord) {\n    ivec4 data = w(coord);\n    if (coord.y > 32 || coord.x > 64 ) return data;\n    \n    \n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\n    USERINV = LoadVec4( ivec2(2,32 ) );\n        \n    USERCOORD = ud1.xy;\n    USERDIR = ud1.z;\n\tUSERACTIONCOUNT = ud1.w;\n    \n    USERACTIONCOORD = USERCOORD + DIRECTION[USERDIR];\n\tUSERACTION = ud2.x;\n        \n    int SWORD = USERINV[0];\n    \n    bool tryaction = USERACTIONCOUNT == USERACTIONSTEPS &&\n                  USERACTION == ACTION;\n    \n    if (coord.x < 32 ) { // static data\n        bool action = tryaction &&\n                      coord.x == USERACTIONCOORD.x && coord.y == USERACTIONCOORD.y;\n        \n        if( data.x == 1 ) {\n            // wall\n        } else if( data.x > 1 && data.x < 6 ) { // door\n            if( action ) {\n                // try to open door\n                if( data.x == 2 || USERINV[data.x-2] > 0) {                \n                \tdata.z = 1;\n               \t \tdata.w == 0;\n                }\n            }\n            if( data.z > 0 ) {\n                data.w ++;\n                if( data.w > DOOROPENSTEPS ) {\n                    // try to close the door\n                    if( isEmpty(coord) ) {\n                        data.z = 0;\n                        data.w = DOORMOVESTEPS;\n                    }\n                }\n            } else {\n                data.w = max(data.w-1, 0);\n            }\n        } else if( data.x > 5 && coord.x == USERCOORD.x && coord.y == USERCOORD.y) { // item - pick up\n            data = ivec4(0);\n        }\n    } else { // monsters\n        coord -= ivec2(32,0);\n        bool action = tryaction &&\n                      coord.x == USERACTIONCOORD.x && coord.y == USERACTIONCOORD.y;\n        \n        if( isMonster(data) ) { // monster, move if possible\n            if( action ) {\n                data.w -= int(hash12( vec2(iTime) ) * float(SWORD) + 1.);\n                if( data.w < 0 ) {\n                    data = ivec4(0);\n                }\n            } if( monsterIsMoving(data) ) {\n                if( data.y > 1 ) {\n                    ivec4 check = m(coord + DIRECTION[data.z-1]);\n                    if( check.z == data.z ) {\n                        data.y ++;\n                        if( data.y > MOVESTEPS ) {\n                            data = ivec4(0);\n                        }\n                    } else {\n                        data.y = 0;\n                        data.z = 0;\n                    }\n                } else {\n                   data.y ++;\n                }\n            } else if( abs(coord.x-USERCOORD.x)+abs(coord.y-USERCOORD.y) == 1 ) {\n                // attack!\n            } else {\n                // try to move - multiple times\n                float userDistance = distance( vec2(coord), vec2(USERCOORD));\n                for(int i=0; i<4; i++) {\n                    int d = int(hash12(vec2(coord) + iTime + float(i)) * 4.);\n                    ivec2 dir = DIRECTION[d];\n                    if( isEmpty( coord + dir ) ) {\n                        data.z = d + 1;\n                        data.y = 1;\n                        \n                        if( userDistance < 5. &&\n                            distance( vec2(coord+dir),vec2(USERCOORD)) < userDistance ) {\n                            i=100;\n                        }\n                    }\n                }\n            }\n        } else { // check if a monster moves to this spot\n            for(int i=0; i<4; i++) {\n                ivec4 check = m( coord - DIRECTION[i] );\n                if(check.z == i + 1 && check.y > 0) {\n                    data.x = check.x;\n                    data.y = -MOVESTEPS;\n                    data.z = check.z;\n                    data.w = check.w;\n                }\n            }\n        }\n    }\n    \n    return data;\n}\n\n// game logic\n\nvoid gameSetup( int level, inout vec4 fragColor, in ivec2 coord ) {\n    StoreVec4( ivec2(0,32 ), ivec4(4,1,3,0), fragColor, coord );\n    StoreVec4( ivec2(1,32 ), ivec4(0,0,60,0), fragColor, coord );\n    StoreVec4( ivec2(2,32 ), ivec4(0,0,0,0), fragColor, coord );\n    StoreVec4( ivec2(3,32 ), ivec4(0), fragColor, coord );\n}\n\nvoid gameLoop( inout vec4 fragColor, in ivec2 coord ) {\n    if( coord.y > 33 || coord.y < 32 ) return;\n    if( coord.x > 16 ) return;\n    \n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\n    ivec4 ud3 = LoadVec4( ivec2(2,32 ) );\n    \n    USERCOORD = ud1.xy;\n    USERDIR = ud1.z;\n    int actionCount = ud1.w;\n    \n    int action = ud2.x;\n    int newAction = ud2.y;\n    int live = ud2.z;\n    \n    USERINV = ud3;\n    \n    if( actionCount > 0 ) {\n        actionCount --;\n    }\n    \n    if( KP(KEY_UP) || KP(KEY_W) ) {\n        newAction = FORWARD;\n    }\n    if( KP(KEY_DOWN) || KP(KEY_S) ) {\n        newAction = BACK;\n    }\n    if( KP(KEY_LEFT) || KP(KEY_A) ) {\n        newAction = ROT_LEFT;\n    }\n    if( KP(KEY_RIGHT) || KP(KEY_D) ) {\n        newAction = ROT_RIGHT;\n    }\n    if( KP(KEY_SPACE) ) {\n        newAction = ACTION;\n    }\n    \n    if( actionCount > 8 ) {\n        newAction = NONE;\n    }\n    \n    if( actionCount == 0 ) {\n        action = newAction;\n        newAction = NONE;\n        \n        if( action == FORWARD ) {\n            if( isEmpty( USERCOORD + DIRECTION[USERDIR] ) ) {\n                USERCOORD += DIRECTION[USERDIR];\n                actionCount = USERMOVESTEPS;\n            }\n        }\n        if( action == BACK ) {\n            if( isEmpty( USERCOORD - DIRECTION[USERDIR] ) ) {\n                USERCOORD -= DIRECTION[USERDIR];\n                actionCount = USERMOVESTEPS;\n            }\n        }\n        if( action == ROT_RIGHT ) {\n            USERDIR = (USERDIR + 1) % 4;\n            actionCount = USERROTATESTEPS;\n        }\n        if( action == ROT_LEFT ) {\n            USERDIR = (USERDIR + 3) % 4;\n            actionCount = USERROTATESTEPS;\n        }\n        if( action == ACTION ) {\n            actionCount = USERACTIONSTEPS;\n        }\n    }\n    \n    // store data\n    ud1.xy = USERCOORD;\n    ud1.z = USERDIR;\n    ud1.w = actionCount;\n    \n    ud2.x = action;\n    ud2.y = newAction;\n    \n    ivec4 map = w(USERCOORD);\n    if( map.x > 9 ) {\n        live += map.z;\n    \tStoreVec4( ivec2(3,32 ), ivec4(map.x,map.z,0,0), fragColor, coord );\n    } else if( map.x > 5 ) {\n        // item\n        USERINV[ map.x-6 ] = max( USERINV[ map.x-6], map.z );\n    \tStoreVec4( ivec2(3,32 ), ivec4(map.x,map.z,0,0), fragColor, coord );\n    } else {\n    \tStoreVec4( ivec2(3,32 ), ivec4(0), fragColor, coord );\n    }        \n    \n    \n    if( live > 120 ) {\n        live = 120;\n    }\n    \n    for(int i=0; i<4; i++) {\n        ivec2 c = USERCOORD + DIRECTION[i];\n        ivec4 mo = m(c);\n        if( isMonster(mo) && mo.y == 0 ) {\n            if( hash12( vec2(c)+iTime ) > .993 - float(mo.w)*.0007 ) {\n                live -= 2+int(hash12( vec2(c)-iTime ) * (float(mo.w) + 5.));\n            }\n        }\n    }\n    \n    ud2.z = live;\n    if( live < 0 ) {\n        ud2.w = 1;\n    \tStoreVec4( ivec2(3,32 ), ivec4(-1), fragColor, coord );\n    }\n        \n    StoreVec4( ivec2(0,32 ), ud1, fragColor, coord );\n    StoreVec4( ivec2(1,32 ), ud2, fragColor, coord );\n    StoreVec4( ivec2(2,32 ), USERINV, fragColor, coord );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 uv = ivec2(fragCoord.xy);\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\n    \n\tint wall = 1-int(step(texelFetch(iChannel1, ivec2(2,1), 0).x,.575));\n    \n    if( ud2.w > 0 || wall != w(ivec2(2,1)).x ) {\n    \tfragColor = vec4(createMap(0, uv));\n        gameSetup(0, fragColor, ivec2(fragCoord) );\n    } else {\n        fragColor = vec4(updateMap(0, uv));\n        gameLoop( fragColor, ivec2(fragCoord) );\n    }    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Legend of the Gelatinous Cube. Created by Reinder Nijhoff 2017\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/Xs2Bzy\n//\n// I created this shader in one long night for the Shadertoy Competition 2017\n// \n\n// UI CODE\n\nconst int USERACTIONSTEPS = 30;\nconst int MAXSWORD = 30;\nconst int REDFLASHSTEPS = 60;\n\nconst int NONE = 0;\nconst int FORWARD = 1;\nconst int BACK = 2;\nconst int ROT_LEFT = 3;\nconst int ROT_RIGHT = 4;\nconst int ACTION = 5;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvoid StoreIVec4( in ivec2 vAddr, in ivec4 vValue, inout ivec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? ivec4(vValue) : fragColor;\n}\n\nvoid StoreIVec4B( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nivec4 LoadVec4B( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel2, vAddr, 0 ) );\n}\n\n\n// FONT RENDER CODE\n//\n// copied from https://www.shadertoy.com/view/MtyXDV\n\nvec2 uv = vec2(0.0);  // -1 .. 1\n\n//== font handling ================================================\n\n#define FONT_SPACE 0.5\n\nvec2 tp = vec2(0.0);  // text position\nconst vec2 vFontSize = vec2(8.0, 15.0);  // multiples of 4x5 work best\n\n//----- access to the image of ascii code characters ------\n\n#define SPACE tp.x-=FONT_SPACE;\n#define _     tp.x-=FONT_SPACE;\n\n#define S(a) c+=char(a);  tp.x-=FONT_SPACE;\n\n#define _note  S(10);   //\n#define _star  S(28);   // *\n#define _smily S(29);   // :-)        \n#define _exc   S(33);   // !\n#define _add   S(43);   // +\n#define _comma S(44);   // ,\n#define _sub   S(45);   // -\n#define _dot   S(46);   // .\n#define _slash S(47);   // /\n\n#define _0 S(48);\n#define _1 S(49);\n#define _2 S(50);\n#define _3 S(51);\n#define _4 S(52);\n#define _5 S(53);\n#define _6 S(54);\n#define _7 S(55);\n#define _8 S(56);\n#define _9 S(57);\n#define _ddot S(58);   // :\n#define _sc   S(59);   // ;\n#define _less S(60);   // <\n#define _eq   S(61);   // =\n#define _gr   S(62);   // >\n#define _qm   S(63);   // ?\n#define _at   S(64);   // at sign\n\n#define _A S(65);\n#define _B S(66);\n#define _C S(67);\n#define _D S(68);\n#define _E S(69);\n#define _F S(70);\n#define _G S(71);\n#define _H S(72);\n#define _I S(73);\n#define _J S(74);\n#define _K S(75);\n#define _L S(76);\n#define _M S(77);\n#define _N S(78);\n#define _O S(79);\n#define _P S(80);\n#define _Q S(81);\n#define _R S(82);\n#define _S S(83);\n#define _T S(84);\n#define _U S(85);\n#define _V S(86);\n#define _W S(87);\n#define _X S(88);\n#define _Y S(89);\n#define _Z S(90);\n\n#define _a S(97);\n#define _b S(98);\n#define _c S(99);\n#define _d S(100);\n#define _e S(101);\n#define _f S(102);\n#define _g S(103);\n#define _h S(104);\n#define _i S(105);\n#define _j S(106);\n#define _k S(107);\n#define _l S(108);\n#define _m S(109);\n#define _n S(110);\n#define _o S(111);\n#define _p S(112);\n#define _q S(113);\n#define _r S(114);\n#define _s S(115);\n#define _t S(116);\n#define _u S(117);\n#define _v S(118);\n#define _w S(119);\n#define _x S(120);\n#define _y S(121);\n#define _z S(122);\n   \nfloat char(int ch) {\n  vec4 f = any(lessThan(vec4(tp,1,1), vec4(0,0,tp))) \n               ? vec4(0) \n               : texture(iChannel3,0.0625*(tp + vec2(ch - ch/16*16,15 - ch/16)));  \n  return f.x;\n}\n\nvoid SetTextPosition(float x, float y)  //\n{\n  tp = 10.0*uv;\n  tp.x = tp.x - x;\n  tp.y = tp.y - y;\n}\n                                                                                                        \nfloat drawInt(int value, int minDigits)\n{\n  float c = 0.;\n  if (value < 0) \n  { value = -value;\n    if (minDigits < 1) minDigits = 1;\n    else minDigits--;\n    _sub                   // add minus char\n  } \n  int fn = value, digits = 1; // get number of digits \n  for (int ni=0; ni<10; ni++)\n  {\n    fn /= 10;\n    if (fn == 0) break;\n    digits++;\n  } \n  digits = max(minDigits, digits);\n  tp.x -= FONT_SPACE * float(digits);\n  for (int ni=1; ni < 11; ni++) \n  { \n    tp.x += FONT_SPACE; // space\n    c += char(48 + (value-((value/=10)*10))); // add 0..9 \n    if (ni >= digits) break;\n  } \n  tp.x -= FONT_SPACE * float(digits);\n  return c;\n}\n\nfloat drawInt(int value) {return drawInt(value,1);}\n\n\nvoid updateText(  inout vec4 color, vec2 coord ) {\n    uv = (2.*coord/iResolution.y-1.);\n    if( abs(uv.y) < .2 ) {\n        ivec4 data = LoadVec4(ivec2(3,32));\n        \n        if( data.x > 0 ) {\n\t\t   SetTextPosition(2.5,-0.5);   \n\t\t   float c = 0.0;\n\t\t   _Y _o _u _ _f _o _u _n _d _ \n                \n           if( data.x == 6 ) {    \n              _a _ _n _e _w _ _s _w _o _r _d _ _add\n\t\t\t    c += drawInt(data.y);  \n           } else if( data.x == 10 ) {\n                _f _o _o _d _ _add\n\t\t\t    c += drawInt(data.y);  \n           } else {\n               _a _\n               if( data.x == 7 ) {\n                   _R _e _d\n               }\n               else if( data.x == 8 ) {\n                   _G _r _e _e _n\n               }\n               else if( data.x == 9 ) {\n                   _B _l _u _e\n               }\n               _ _K _e _y\n           }\n\t\t   color = vec4(1,1,1,min(2.,c * 2.));\n        } else if( data.x < 0 ) {   \n\t\t   SetTextPosition(2.5,-0.5);\n\t\t   float c = 0.0;\n           _Y _o _u _ _d _i _e _d\n\t\t   color = vec4(1,1,1,min(2.,c * 2.));               \n        } else {\n           color = texelFetch(iChannel2, ivec2(coord),0); \n           color.a = max(0., color.a - 1./60.);\n        }         \n    }\n}\n\n\n// UI ELEMENTS\n\nvec4 drawSword( vec2 uv, int level ) {\n    uv = floor(fract(uv)*32.) - 16.;\n        float l = step(abs(uv.y), .5); \n        l = max(l, step(abs(uv.y), 1.5) * step(uv.x, 13.));   \n        l = max(l, step(abs(uv.y), 5.5) * step(abs(uv.x+9.), 1.));\n                        \n\t    vec3 col = mix( vec3(.8), vec3(.5,.3,.2), step(uv.x, -11.));\n        vec3 scol = mix( vec3(.5,.3,.2), vec3(1.), clamp(float(level) / float(MAXSWORD/2), 0., 1.) );\n        scol = mix( scol, vec3(0.,.9, 1.), clamp(float(level-MAXSWORD/2) / float(MAXSWORD/2), 0., 1.) );\n        col = mix( scol, col, step(uv.x, -8.));        \n        \n        return vec4( l * (.75 + .25 * texture(iChannel1, uv/64.).x) * col, l );\n}\n\nvec4 drawKey( vec2 uv, int color ) {\n    uv = floor(fract(uv)*32.) - 16.;\n        float l = step(abs(uv.y), 1.);\n        l = max(l, step(length(uv+vec2(8,0)), 7.5));\n        l -= step(length(uv+vec2(8,0)), 4.5);\n        l = max(l, step(6.,uv.x)*step(uv.x, 7.)*step(0.,uv.y)*step(abs(uv.y), 5.));\n        l = max(l, step(10.,uv.x)*step(uv.x, 11.)*step(0.,uv.y)*step(abs(uv.y), 7.));\n        l = max(l, step(14.,uv.x)*step(0.,uv.y)*step(abs(uv.y), 6.));\n        \n\t    vec3 col = vec3(0);\n    \tcol[color] = 1.;\n        return vec4( l * (.75 + .25 * texture(iChannel1, uv/64.).x) * col, l );\n\n}\n\nvoid drawKeyIcon( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int keyColor ) {\n    coord = (coord-lt) / size;\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \n\t\tvec4 col = drawKey(-coord, keyColor);\n        color = mix( color, col, col.a );\n    }\n}\n\n\nvoid drawSwordIcon( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {\n    coord = (coord-lt) / size;\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \n\t\tvec4 col = drawSword(coord, level);\n        color = mix( color, col, col.a );\n    }\n}\n\n\nvoid drawSwordIconLarge( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {\n    coord = (coord-lt) / size;\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \n\t\tvec4 col = drawSword(coord.yx, level);\n        color = mix( color, col, col.a );\n    }\n}\n\nvoid drawLifeBar(  vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {\n     coord = (coord-lt) / size;\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \n\t\tvec4 col = mix(vec4(.5,0,0,1), vec4(.5,1,0,1), float(level)/60.);  \n\t\tcol = mix(col, vec4(0,1,0,1), float(level-60)/60.);\n        col = mix( vec4(0,0,0,.6), col, step( 120. * coord.x,  float(level) ));\n        col.rgb *= (.75 + .5 * texture(iChannel1, coord/vec2(8.,64.)).x);\n        color = mix( color, col, col.a );\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    \n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\n    ivec4 USERINV = LoadVec4( ivec2(2,32 ) );\n        \n\tint USERACTIONCOUNT = ud1.w;\n    int USERACTION = ud2.x;\n    \n    fragColor = vec4(0);\n\n    float iconSize = res.y*.1;\n    \n    if( USERINV[0] > 0) {\n       drawSwordIcon( vec2( res.x - iconSize*1.5, .125*iconSize ), vec2(iconSize), fragColor, fragCoord, USERINV[0] );\n    }\n    \n    for( int i=0; i<3; i++) {\n        if( USERINV[i+1] > 0 ) {\n            drawKeyIcon( vec2( res.x - (float(i)*1.2+2.7)*iconSize, .125*iconSize  ), vec2(iconSize), fragColor, fragCoord, i);\n        }\n    }\n    if( USERACTION == ACTION && USERACTIONCOUNT > 0 && USERINV[0] > 0) {\n       float h = smoothstep(0., 1., abs(float(USERACTIONCOUNT-USERACTIONSTEPS/2-10)/float(USERACTIONSTEPS/2))) + .4;\n       float size = res.y * .5; \n        \n       drawSwordIconLarge( vec2( res.x * .5 - size*.5, -h*size ), vec2(size), fragColor, fragCoord, USERINV[0] );\n    }\n    drawLifeBar( vec2(iconSize * .5, .375*iconSize), vec2( iconSize*6., iconSize*.25), fragColor, fragCoord, ud2.z );\n    \n    updateText( fragColor, fragCoord );\n    \n    \n    ivec4 bd = LoadVec4B( ivec2(0,0) );\n    if( bd.x > ud2.z ) {\n        bd.y = REDFLASHSTEPS;\n    }\n    bd.y--;\n    if( bd.y < 0 ) bd.y = 0;\n    bd.x = ud2.z;\n    \n    StoreIVec4B( ivec2(0,0), bd, fragColor, ivec2(fragCoord) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}