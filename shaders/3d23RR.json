{
    "Shader": {
        "info": {
            "date": "1547980976",
            "description": "refraction + reflection in a water drop. Spectral effect on refractive index exaggerated. \nSphere = Mouse or auto.\n1st reflec = cloud reflec. 1st refrac = iridiscent cloud + silverlining. 2nd(&3rd) refract = rainbow (I max ~42°).\nNB: missing ray Jacobian.",
            "flags": 32,
            "hasliked": 0,
            "id": "3d23RR",
            "likes": 6,
            "name": "rainbow effect - spectral ",
            "published": 3,
            "tags": [
                "rays",
                "refraction",
                "rainbow",
                "geometry",
                "optics",
                "lense"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 905
        },
        "renderpass": [
            {
                "code": "// Spectral variant of https://shadertoy.com/view/WsS3Rz\n// see improved variant here: https://www.shadertoy.com/view/3dj3zh\n\n#define S(d,r) smoothstep( r/R.y, 0., d)   // antialiased draw. r >= 1.5\n\n// --- line segment with disc ends: seamless distance to segment //  https://www.shadertoy.com/view/4dcfW8\nfloat line(vec2 p, vec2 a, vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n  //return length(p - b * h);                         // dist to segment\n    p -= b*h; return dot(p,p);                        // square dist\n}\n\n// --- draw pathes -----------------------------------------------------\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y;\n    \n    float t, d = 1e5, l, y, b;\n    for( float n=0.; n<R.y/K; n++)                    // follow path n\n      for (float c=0.; c<F; c++) {                    // fork combinations\n        vec2 P = T(vec2(B*c+c,n)).xy, _P;             // path start point\n        for( float i=1.+c; i<B; i++) {                // follow bounces. +c: opt (redundancies)\n            l = line( U, _P = P, P = T(vec2(B*c+i,n)).xy );\n         // l = length(T(vec2(i,n)).xy-U)*.1; l*=l;   // test\n            if (l < d) d = l, y = n, b = B*c+i;\n       }   }\n    O =   S( sqrt(d), 1.5)                            // segment drawing\n        * T(vec2(b-1.,y)).z                           // intensity\n        * ( b == 1. || b == B+2.                      // color :\n              ? vec4(1)                               // before any refraction\n              : ( .6 + .6 * cos( 6.3*(y*K/R.y)  + vec4(0,23,21,0)  ) ) // hue:  https://www.shadertoy.com/view/ll2cDc\n          );\n    O.bg += S( abs(length(Pdisk-U)-r), 1.5 );         // trace disk\n // O = sqrt(O); // to sRGB\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// bufA: path( bounce x, Id y) = ( Pos, Dir )\n\n#define Inf 1e3\n#define Eps 1e-2\n\n// --- ray-sphere intersec: || (P + l*D) - C ||² = r²  ->  2-polynomial\nfloat sphere(vec2 P, vec2 D, vec2 C, float r) {\n   vec2 d = P-C;\n    float b = dot(d,D), c = dot(d,d) - r*r, k = b*b-c, l;\n    if (k>0.) {\n        l = -b - sqrt(k); if (l > Eps) return l; // hit distance\n        l = -b + sqrt(k); if (l > Eps) return l; // hit distance\n    }\n    return Inf;                         // no hit\n}\n// normal at hit point P\n#define sphereN(P,C)     normalize(P-(C))\n// test if P in sphere\n#define inSphere(P,C,r)  ( dot(P-(C),P-(C)) < (r)*(r) )\n\n\n// --- trace rays( x = bounceID, y = pathID ) ------------------------\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int c = int(U.x/B); U.x = mod(U.x, B);\n    if ( c > 1 << int(F) ) return;             // manage only B bounces and F fork\n    \n    float t, y, I = 10., m = 1.;               // medium: >0: air <0: glass\n    vec2  R = iResolution.xy,                  // I: ray indensity\n          X = vec2(1,0), P, D, D2, N,\n          C = Pdisk;                           // moving sphere ( C, r )\n             \n    y = K*U.y/R.y; if ( y > 1.) return;        // R.y/K rays \n    P = vec2( 0, .5 ),  D = X;                 // init ray ( P, D )\n    float idx = 1.33 + .1*y;                   // freq dep exagerated x10\n// 1.33 -> 1.34 from red(.7 um) to violet(.4 um)  https://en.wikipedia.org/wiki/Optical_properties_of_water_and_ice\n    m = inSphere(P,C,r) ? -1. : 1.;            // start medium\n \n    // in this variant, whole propagation computed in one frame to avoid inconsistency as sphere moves.\n    for (int x = 1; x <= int(U.x); x++) {      // bounce x\n \n        float l = sphere(P,D, C,r);            // dist to intersections\n \n        if (l<Inf) {\n            P += l*D;                          // hit point\n            N =  sphereN(P,C);                 // normal at hit\n\n#if INTENSITY\n            float i = m<0.? idx: 1./idx,\n                 ci = abs(dot(D,N)), \n                 ct = 1. - i*i*(1.-ci*ci), R = 1.;\n            if (ct>0.) ct = sqrt(ct);\n#  if 1     \n            // Fresnel (unpolarized) https://en.wikipedia.org/wiki/Fresnel_equations\n            if (ct>0.) {\n                vec2 Fr = vec2( (i*ci-ct)/(i*ci+ct), (i*ct-ci)/(i*ct+ci) );\n                R = dot(Fr,Fr) / 2.;\n               }\n#  else     \n            // Schlick's approximation https://en.wikipedia.org/wiki/Schlick%27s_approximation\n            float r = (i*i-1.) / (i*i+1.);\n            if (i>1.) if (ct>0.) ci = sqrt(ct); else r=1.;\n                  R = mix( pow(1.-ci,5.),1., r*r); \n#  endif\n#else\n            float R = .5;\n#endif           \n            if ( (c>>(x-1))%2 ==0  ) {         // fork stack: refr or refl ?\n                D2 = refract( D, m*N, m<0.? idx: 1./idx );\n                if (D2 != vec2(0) )            // refraction possible\n                { m = -m; D = D2; I *= 1.-R; continue; } // refracted ray dir  \n            }\n            D = reflect(D, m*N);  I *= R;                // reflected ray dir\n        }\n        else { P += l*D; break; }              // go straight\n    }\n    O.xy = P; // O.zw = D;\n    O.z = INTENSITY > 0 ? I : 1.; \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float K = 8.,        // trace R.y/K rays\n            B = 5.,        // trace B bounces (including start). pref: x4 best\n            F = 3.;        // consider F forks\n\n#define INTENSITY 1        // 1: evaluate Fresnel \n\n#define Pdisk  ( t=iTime*.5 , iMouse.z>0. ? iMouse.xy/R.y : .5 + .3* vec2(.6*cos(t)-.3*sin(3.1*t),sin(1.31*t)-.4*cos(3.7*t)) )\nconst float r = .2;\n\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}