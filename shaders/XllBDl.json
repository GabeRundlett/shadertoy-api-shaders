{
    "Shader": {
        "info": {
            "date": "1513959918",
            "description": "Glowing pentagram (or other star polygon) in 3D.\n\nN controls number of sides\n\n[Jan 2019: now with mouse action]",
            "flags": 0,
            "hasliked": 0,
            "id": "XllBDl",
            "likes": 25,
            "name": "FestiveÂ Pentagram",
            "published": 3,
            "tags": [
                "star",
                "festive",
                "pentagram"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 6765
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// (c) Matthew Arcus 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Glowing festive pentagram: ray trace 5 rotations of basic line, use\n// distance of ray to line to determine color.\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 5; // Number of lines\nconst float scale = 1.0;\nconst float CAMERA = 6.0;\nconst float A = 0.6; // Light amplitude\nconst float K = 0.4; // Concentration\nconst float R = 1.0; // Radius\nconst float PI = 3.14159;\nconst float theta = 2.0*PI/float(N);\nconst mat3 m = mat3(cos(theta),sin(theta),0,\n                    -sin(theta),cos(theta),0,\n                    0,0,1);\n\nfloat det(vec2 c0, vec2 c1) {\n  return determinant(mat2(c0,c1));\n}\n\nvec2 closest0(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Use Cramer's rule to solve linear system\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  // No cross products, 4 dot products, 3 2x2 determinants\n  vec2 c0 = vec2(1.0,dot(q,s));\n  vec2 c1 = vec2(-dot(q,s),-1.0);\n  vec2 a = vec2(dot(r-p,q),dot(r-p,s));\n  return vec2(det(a,c1),det(c0,a))/det(c0,c1);\n}\n\n// return vec2(k,j) such that p + kq and\n// r + js are closest points on lines\n// Assumes q and s are normalized\nvec2 closest1(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  mat2 m = mat2(1.0,dot(q,s),-dot(q,s),-1.0);\n  return inverse(m)*vec2(dot(r-p,q),dot(r-p,s));\n}\n\n// Nice \"geometric\" solution from Wikipedia.\n// Probably not as fast as Cramer's rule,\n// 3 cross products, 4 dot products & a normalize\nvec2 closest2(vec3 p,vec3 q,vec3 r,vec3 s) {\n   vec3 n = normalize(cross(q,s));\n   vec3 n1 = cross(q,n); \n   vec3 n2 = cross(s,n);\n   return vec2(dot(r-p,n2)/dot(q,n2),\n               dot(p-r,n1)/dot(s,n1));\n}\n\nvec2 mmul(mat2 m, vec2 p) {\n  return m*p;\n  return vec2(m[0][0]*p[0]+m[1][0]*p[1],\n              m[0][1]*p[0]+m[1][1]*p[1]);\n}\n\nvec2 closest3(vec3 p,vec3 q,vec3 r,vec3 s) {\n  // Matrices are column major!\n  // Assume q and s are unit vectors\n  float k = dot(q,s);\n  mat2 m = mat2(-1.0,-k,k,1.0);\n  //return m*vec2(dot(r-p,q),dot(r-p,s))/(k*k-1.0);\n  return mmul(m,vec2(dot(r-p,q),dot(r-p,s)))/(k*k-1.0);\n}\n\nvec2 closest(vec3 p,vec3 q,vec3 r,vec3 s) {\n  return closest3(p,q,r,s);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Quaternion to rotation matrix\n// Assumes normalized\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x*x, y2 = y*y, z2 = z*z;\n  float xy = x*y, xz = x*z, xw = x*w;\n  float yz = y*z, yw = y*w, zw = z*w;\n  return 2.0*mat3(0.5-y2-z2, xy+zw, xz-yw,\n                  xy-zw, 0.5-x2-z2, yz+xw,\n                  xz+yw, yz-xw, 0.5-x2-y2);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 xy = scale*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n  // p+kq is viewing ray\n  vec3 p = vec3(0,0,-CAMERA);\n  vec3 q = vec3(xy,2);\n  p = transform(p);\n  q = transform(q);\n  q = normalize(q);\n  \n  // r+js is polygon line, to be rotated in loop\n  vec3 r = vec3(0,1,0);\n  vec3 s = vec3(1,0,0);\n  // Rotation axis\n  vec3 axis = normalize(vec3(1,1,cos(0.1*iTime)));\n  float phi = iTime*0.15;\n  mat3 n = qrot(vec4(sin(phi)*axis,cos(phi)));\n  p = n*p; q = n*q;\n  float mindist = 1e10;\n  vec3 color = vec3(0); // Accumulate color here\n  for (int i = 0; i < N; i++) {\n    vec2 k = closest(p,q,r,s);\n    vec3 p1 = p+k.x*q;\n    vec3 r1 = r+k.y*s;\n    float d = distance(p1,r1);\n    float h = mod(0.3*(-iTime+log(1.0+abs(k.y))),1.0);\n    vec3 basecolor = hsv2rgb_smooth(vec3(h,1.0,1.0));\n    color += A*float(k.x > 0.0)*(1.0-pow(smoothstep(0.0,R,d),K))*basecolor;\n    s = m*s; r = m*r; // Rotate to next line\n  }\n  outColor = vec4(sqrt(color),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}