{
    "Shader": {
        "info": {
            "date": "1681719984",
            "description": "based on https://www.shadertoy.com/view/4sfGDB by Zavie. Trying to make the pseudo random sampler maintain local continuity in order to denoise. ",
            "flags": 0,
            "hasliked": 0,
            "id": "DdVXWc",
            "likes": 4,
            "name": "RT exp: local consistency",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "daniel_chin",
            "viewed": 331
        },
        "renderpass": [
            {
                "code": "/*\nbased on \nhttps://www.shadertoy.com/view/4sfGDB\nby Zavie\n\nmodified by Daniel Chin\n*/\n\n#define ENABLE_LOCAL_CONTINUITY\n\n#define SAMPLES 4\n#define MAXDEPTH 4\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() {\n\treturn fract(sin(seed++)*43758.5453123);\n}\n\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return (\n    49.0 * (\n      dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n      + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) \n    ) + 1.0\n  ) * .5;\n\n}\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(int sample_i, vec2 fragPos, Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfloat it = iTime * .03;\n\tvec2 fp = fragPos * .1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n    vec3 v3 = vec3(it, float(depth), float(sample_i));\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n\t\tif (obj.refl == DIFF) {\n#ifdef ENABLE_LOCAL_CONTINUITY\n\t\t\tfloat r2 = snoise(vec4(\n\t\t\t\tv3, 0\n\t\t\t));\n\t\t\tfloat sn5 = snoise(vec4(\n\t\t\t\tv3, 5.2348965984\n\t\t\t));\n#else\n\t\t\tfloat r2 = rand();\n\t\t\tfloat sn5 = rand();\n#endif\n\t\t\tvec3 d = jitter(nl, 2.*PI*sn5, sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n#ifdef ENABLE_NEXT_EVENT_PREDICTION\n\t\t\t//for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t// Sphere s = sphere(i);\n\t\t\t\t// if (dot(s.e, vec3(1.)) == 0.) continue;\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n#ifdef ENABLE_LOCAL_CONTINUITY\n\t\t\t\tfloat sn10 = snoise(vec4(\n\t\t\t\t\tv3, 10.72309867\n\t\t\t\t));\n\t\t\t\tfloat sn20 = snoise(vec4(\n\t\t\t\t\tv3, 20.389287\n\t\t\t\t));\n#else\n        float sn10 = rand();\n        float sn20 = rand();\n#endif\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., sn10);\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*sn20, sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tfloat E = 1.;//float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc/nt, nt/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n#ifdef ENABLE_LOCAL_CONTINUITY\n\t\t\t\tfloat sn30 = snoise(vec4(\n\t\t\t\t\tv3, 30.01894375\n\t\t\t\t));\n#else\n        float sn30 = rand();\n#endif\n\t\t\t\tif (sn30<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n\tseed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES + min(0, iFrame); ++i) {\n#ifdef DEBUG\n    vec3 test = radiance(i, fragCoord.xy / iResolution.xy, Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n    if (dot(test, test) > 0.) color += vec3(1.); else color += vec3(0.5,0.,0.1);\n#else\n    color += radiance(i, fragCoord.xy / iResolution.xy, Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n#endif\n  }\n  vec4 accum = texture(iChannel0, fragCoord.xy / iResolution.xy);\n  accum = vec4(0,0,0,0);\n  float samples = accum.a + float(SAMPLES);\n  fragColor = vec4((accum.rgb * accum.a + color)/samples, samples);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}