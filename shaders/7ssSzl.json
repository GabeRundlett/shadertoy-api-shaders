{
    "Shader": {
        "info": {
            "date": "1645484277",
            "description": "Raymarching rolling clouds and waves",
            "flags": 0,
            "hasliked": 0,
            "id": "7ssSzl",
            "likes": 8,
            "name": "Fork Rolling wa firebreath 440",
            "published": 3,
            "tags": [
                "waves",
                "raymarch"
            ],
            "usePreview": 0,
            "username": "firebreathz",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 120\n#define MAX_DIST 120.\n#define SURF_DIST .01\n\nfloat GetDistance(vec3 point) {\n\t\n    float texture = sin((iTime + point.x)*.5)*2.7+cos(point.z*2.5+sin(iTime)*5.)*.1+sin(point.x*5.+point.z*10.)*0.03;\n    float planeDist = point.y + texture*.5;\n    \n    float planeDist2 = -point.y + 3. + texture*.5;;\n    \n    return min(planeDist,planeDist2);\n}\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    int i = 0;\n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  float d = RayMarch(point+normal*.1, direction).x;\n  if ( d < length(lightPos-point)) dif *= .5;\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1.5, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1, 1.5, 1);\n    \n    if (d.x < 120.) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        float dist = d.x/50.;\n        col = vec3(\n            light-dist,\n            light-dist/1.5+(d.y*0.004),\n            light-dist/2.+(d.y*0.005)\n        );\n    }\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}