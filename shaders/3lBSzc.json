{
    "Shader": {
        "info": {
            "date": "1566598358",
            "description": "Grows a large cube forever using a Hilbert curve.\nClick and drag to spin the cube!\nIf it is running slowly, try decreasing L to 2 or 3.",
            "flags": 32,
            "hasliked": 0,
            "id": "3lBSzc",
            "likes": 13,
            "name": "Endless Hilbert Cube Growing",
            "published": 3,
            "tags": [
                "fractal",
                "math",
                "interactive",
                "endless",
                "hilbertcurve"
            ],
            "usePreview": 0,
            "username": "mathmasterzach",
            "viewed": 562
        },
        "renderpass": [
            {
                "code": "//Endless 3D Hilbert Curve Growing \n//By mathmasterzach\n//Click and drag to spin the cube\n\n//note: octree marching is faster than basic voxels on large values of L\n\n//L changes the level of detail in the curve generation\nconst int L=4;\nfloat S;\nconst float SPEED=.3;\n\n//convert point in 3D space to index along curve\nfloat T(vec3 p){\n    float c=0.;\n    ivec3 b=ivec3(p+(S/2.));\n    ivec3 m=ivec3(0);\n    for(int i=L-1;i>=0;i--){\n        ivec3 a=m^((b&(0x1<<i))>>i);\n        float nc=4.*float(a.z)+2.*float(a.x^a.z)+float(a.x^a.y^a.z);\n    \tc=8.*c+nc;\n        if(nc==0.){int t=b.y;b.y=b.z;b.z=t;m=ivec3(m.x,m.z,m.y);}\n        if(nc==1.||nc==2.){int t=b.x;b.x=b.z;b.z=t;m=ivec3(m.z,m.y,m.x);}\n        if(nc==3.||nc==4.){int t=b.y;b.y=b.x;b.x=t;m=ivec3(1-m.y,1-m.x,m.z);}\n        if(nc==5.||nc==6.){int t=b.x;b.x=b.z;b.z=t;m=ivec3(1-m.z,m.y,1-m.x);}\n        if(nc==7.){int t=b.y;b.y=b.z;b.z=t;m=ivec3(m.x,1-m.z,1-m.y);}\n    }\n    return c;\n}\n\n//simplified version of https://www.shadertoy.com/view/ld23DV\nvec4 iBox(vec3 o,vec3 r,float d) {\n    vec3 m = 1.0/r;\n    vec3 n = m*o;\n    vec3 k = abs(m)*d;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\tvec3 nor = -sign(r)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\treturn vec4(tN,nor);\n}\n\n//Useful color function\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//intersect with cube containing curve, then possibly voxel march curve made of cubes\nvec3 marchEndlessHilbert(vec3 o, vec3 r,vec3 bg){\n    float q=mod(iTime*S*S*SPEED,S*S*S+2.*S*S*SPEED)+1.;\n    float ma=max(0.,(q-(S*S*S))/(2.*S*S*SPEED));\n    float sh=mix(S/2.,.5,ma);\n    float rh=(S/2.)-sh;\n    vec4 ibx=iBox(o+rh,r,sh);\n    vec3  bx=abs(ibx.x*r+o)-((S/2.)-(S*.02));\n    if(ibx.x<=0.){return bg;}\n    if(ma>0.){\n        o=(o+r*ibx.x+rh)*(S/2.)/sh;\n        float z=T(o-0.001);\n        if(z==0.){o*=S;z=T(o+S/2.-.999);}\n        if(z==0.){o*=S;z=T(o+S/2.-.999);}\n        if(z==0.){o*=S;z=T(o+S/2.-.999);}\n    \treturn hsv2rgb(vec3(-z/(S*S*S*2.),1.,1.))*dot(-ibx.yzw,r);\n    }\n    o+=(ibx.x-.01)*r;\n    vec3 p = floor(o);\n    vec3 i = 1./r;\n    vec3 s = sign(r);\n    vec3 is= i*s;\n    vec3 d = i*(p-o+s*.5+.5);\n    vec3 m = vec3(0.);\n    for(int j=0;j<int(S*S+1.);j++){\n        float z=T(p);\n        if(p.x>=-S/2.&&p.y>=-S/2.&&p.z>=-S/2.&&p.x<S/2.&&p.y<S/2.&&p.z<S/2.){\n            if(z+1.<=q){\n                o=(o+r*dot(d-is,m))*S;\n                if(z==0.){\t   z=T(o+S/2.-.999);}\n                if(z==0.){o*=S;z=T(o+S/2.-.999);}\n                if(z==0.){o*=S;z=T(o+S/2.-.999);}\n                return hsv2rgb(vec3(-z/(S*S*S*2.),1.,1.))*dot(m*s,r)/(1.+dot(d-is,m)/S);\n            }\n            if(z<=q){\n                vec4 b=iBox(o-p-vec3(.5),r,.5*fract(q));\n                if(b.x>=0.){\n                    return hsv2rgb(vec3(-z/(S*S*S*2.),1.,1.))*dot(-b.yzw,r)/(1.+b.x/S);\n                }\n            }\n        }\n        m=step(d, d.yzx);\n\t\tm*=1.-m.zxy;\n        p+=m*s;\n        d+=m*is;\n    }\n    return vec3(bg);\n}\n\n//Apply Quaternion Rotation to vec3\nvec3 rot(vec4 q,vec3 r) {return 2.*cross(q.xyz,q.w*r+cross(q.xyz,r));}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    S=pow(2.,float(L));\n    vec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0.,0.,-1.2*S);\n    vec3 r = normalize(vec3(uv,1.));\n    vec4 t=texelFetch(iChannel0,ivec2(0,0),0);\n    r+=rot(t,r);\n    o+=rot(t,o);\n    uv=fragCoord/iResolution.xy;\n    fragColor.rgb=marchEndlessHilbert(o,r,1.-vec3(.2,.4,.7)*min(sqrt(10.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y)),1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Camera Rotation, Click And Drag With Velocity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(iFrame==0){\n        fragColor=vec4(0.,0.,0.,1.);\n        //initialize velocity\n        if(fragCoord.x>1.&&fragCoord.x<3.&&fragCoord.y<1.){\n        \t//fragColor=vec4(.08,.02,0.,0.);\n            fragColor=vec4(-.12,-.05,0.,0.);\n        }\n    }else{\n        if(fragCoord.x<1.&&fragCoord.y<1.){\n            vec4 p=texelFetch(iChannel0,ivec2(0),0);\n            vec4 v=texelFetch(iChannel0,ivec2(1,0),0)/3.;\n            vec2 rx = vec2( sin(v.x/2.),cos(v.x/2.));\n   \t\t\tvec2 ry = vec2(-sin(v.y/2.),cos(v.y/2.));\n            //Quaternion multiplication simplification for basis elements\n            vec4 d=vec4(-rx.y*ry.y,rx.x*ry.x,-rx.x*ry.y,rx.y*ry.x);\n            //Full Quaternion multiplication\n            fragColor = normalize(vec4(d.x*p.x-d.y*p.y-d.z*p.z-d.w*p.w,\n                                       d.x*p.y+d.y*p.x+d.z*p.w-d.w*p.z,\n                                       d.x*p.z-d.y*p.w+d.z*p.x+d.w*p.y,\n                                       d.x*p.w+d.y*p.z-d.z*p.y+d.w*p.x));\n        }else if(fragCoord.x<2.&&fragCoord.y<1.){\n            vec4 v=texelFetch(iChannel0,ivec2(1,0),0);\n            vec4 m=texelFetch(iChannel0,ivec2(2,0),0);\n            v=.98*v;\n            if(m.z>.5){\n            \tv.xy+=(iMouse.xy-m.xy)/iResolution.xy;\n            }\n            fragColor=v;\n        }else if(fragCoord.x<3.&&fragCoord.y<1.){\n            fragColor = iMouse;\n        }else{\n            fragColor = vec4(0.);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}