{
    "Shader": {
        "info": {
            "date": "1540203999",
            "description": "Finally got a realistic result! I'm pretty excited. It took a lot of tinkering, but that's definitely what the real deal looks like\nhttps://en.wikipedia.org/wiki/Liquid_crystal\nnow fast in full screen\nclick to see up close",
            "flags": 32,
            "hasliked": 0,
            "id": "4lcBR2",
            "likes": 22,
            "name": "Liquid Crystal IV",
            "published": 3,
            "tags": [
                "simulation",
                "diffusion",
                "physics",
                "fields",
                "reaction"
            ],
            "usePreview": 0,
            "username": "wyatt",
            "viewed": 1250
        },
        "renderpass": [
            {
                "code": "vec2 R;\nvec2 hash(vec2 p) // Dave Hoskins\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat intersect (vec2 coes) {\n    float det = coes.x*coes.x-4.*coes.y;\n    if (det < 0.) return 1e4;\n    return 0.5*(-coes.x-sqrt(det));\n}\nfloat ellipse (vec3 p, vec3 d, vec3 a, vec3 b, float r) {\n\ta = p-a;b = p-b;\n    float \n        rr = r*r,\n        ad = dot(a,d),\n        bd = dot(b,d),\n        aa = dot(a,a),\n        bb = dot(b,b);\n    return intersect(vec2(\n    \tad*aa-ad*bb+bd*bb-bd*aa-rr*(ad+bd),\n        -aa*bb+0.25*(aa*aa+bb*bb+rr*rr)+0.5*(aa*bb-rr*(aa+bb))\n    )/(ad*ad+bd*bd-rr-2.*ad*bd));\n}\nfloat sphere (vec3 p, vec3 d, vec3 c, float r) {\n\tc = p-c;\n    return intersect(vec2(2.*dot(c,d),dot(c,c)-r*r));\n}\nvec3 norEllipse (vec3 p, vec3 a, vec3 b) {\n    return normalize(normalize(p-a)+normalize(p-b));\n}\nfloat plane (vec3 p, vec3 d) {\n\treturn  dot(-p,vec3(0,0,1))/dot(d,vec3(0,0,1));\n}\nvec3 O (vec2 U) {return normalize(texture(iChannel0,U/R).xyz);}\nvec3 col (vec3 o) {\n    vec2 t = vec2(atan(o.y,o.x),atan(length(o.xy),o.z));\n    float w = 0.5+0.5*sin(8.*t.x);\n    return \n        vec3(1.-w*w*w)*(0.6+0.4*sin(t.x*vec3(1,2,3)))\n        *(0.8+0.3*texture(iChannel2,o).xyz);\n       \n}\nfloat D (vec3 p, vec3 d, vec2 v, float e, inout vec4 color) {\n    \n    vec2 U = floor(p.xy+0.5+v);\n    vec2 h = hash(U)*2.-1.;\n    vec3 o = O(U);\n    U+=.25*h;\n    vec3 q = vec3(U,0),\n         a = q + 1.3*o,\n         b = q - 1.3*o;\n    vec4 co = vec4(col(o),1.);\n    float f = ellipse(p,d,a,b,2.64);\n    \n   if (f < e) {\n    \te = f;\n        vec3 n = norEllipse(p+d*e,a,b);\n        float m = dot(n,o);\n        color = dot(n,vec3(0,0,-1))*(0.4+.6*co);\n    }\n    float t = .5*iTime+h.x;\n    for (int i = 0; i < 3; i++) {\n        t += 0.333;\n        a = q+2.*o*(fract(t)*2.-1.);\n        f = sphere(p,d,a,.4*abs(fract(t+0.5)*2.-1.));\n        if (f < e) {\n            e = f;\n            vec3 n = normalize(p+d*e-a);\n            float m = dot(n,o);\n            color = dot(n,vec3(0,0,-1))*co;\n        }\n    }\n    return e;\n}\nvec4 X (vec3 p, vec3 d) {\n\tp += d*plane(p, d);\n\tvec4 color = vec4(0);\n    float e = 1e3;\n    for (int x = -1; x<=1; x++)\n    for (int y = -1; y<=1; y++)\n        e = D (p, d, vec2(x,y), e, color);\n    return color;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{   R = iResolution.xy;\n if (iMouse.z > 0.) {\n \tU = 2.*(U-0.5*R)/R.y;\n \tvec3 p = vec3(iMouse.xy+(20.+10.*sin(0.25*iTime))*U,-1),\n         d = normalize(vec3(U*0.1,1));\n \tC = X(p,d);\n } else {\n \tvec3 o = O(U);\n \tvec2 dz = vec2(\n    \tO(U+vec2(1,0)).z-O(U-vec2(1,0)).z,\n    \tO(U+vec2(0,1)).z-O(U-vec2(0,1)).z\n    );\n \tC.xyz = (0.8+0.5*dz.xxx)*col(o);\n }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Orientation\nvec2 R;\nvec3 hash (vec2 p) { // Dave Hoskins\n\tvec3 p3 = fract(vec3(p.xyx) *vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 rot (vec3 p, vec3 d) {\n    float t = length(d);\n    if (t==0.)return p;\n    d = normalize(d);\n    vec3 q = p-d*dot(d,p);\n   \treturn p+(q)*(cos(t)-1.) + cross(d,q)*sin(t);\n}\nvec3 O (vec2 U) {return texture(iChannel0,U/R).xyz;}\nvec3 W (vec2 U) {return texture(iChannel1,U/R).zyz;}\nvoid mainImage( out vec4 C, in vec2 U )\n{   R = iResolution.xy;\n C.xyz = O(U);\n if (iFrame > 0&&length(C.xyz)>0.) {\n \tfloat w = 0.05;\n \t\n    vec3 ne = .25*(\n        O(U+vec2(0, 1))+\n        O(U+vec2(0,-1))+\n        O(U+vec2( 1,0))+\n        O(U+vec2(-1,0))\n        \n    );\n \tC.xyz = mix(C.xyz,ne,.95);\n    C.xyz = normalize(C.xyz)*w;\n \tC.xyz = rot(C.xyz,W(U));\n    \n \t\n    \n \t\n} else {\n     C.xyz = vec3(hash(U)*2.-1.);\n     //if (length(U-0.5*R)>0.05*R.x) C = vec4(0,1,1,0);\n }\n \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Angular momentum\nvec2 R;\nfloat hash(vec3 p3){// Dave Hoskins\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 F (vec3 A, vec3 B) {\n    A = A-B;\n    \n    // in a 2D universe, a wave would decay r^-1\n    \n    //return .1*(A)/dot(A,A);\n    \n    // in our 3D universe, forces decay r^-2\n    \n\treturn 0.5*normalize(A)/dot(A,A);\n    \n}\nvec3 T (vec3 a, vec3 b, vec3 A, vec3 B) {\n\tvec3\n        ap = a+A,\n        an = a-A,\n        bp = b+B,\n        bn = b-B,\n        Fp = F(ap,bp)-F(ap,bn),\n        Fn = F(an,bn)-F(an,bp);\n    return cross(A-B,Fp)-cross(A-B,Fn);\n}\nvec3 O (vec2 U) {return texture(iChannel0,floor(U)/R).xyz;}\nvec3 W (vec2 U) {return texture(iChannel1,U/R).zyz;}\nvec3 S (vec2 U) {\n\tvec3 \n        t = vec3(0),\n        o = O(U);\n    float ra = 100.*hash(vec3(U,iTime));\n    #define I 20.\n    for (float i = 0.; i < I; i++)\n    {\n        vec2 u = vec2(1.3+9.*(i/I), ra+i*5.08320369);\n        u = u.x*vec2(cos(u.y),-sin(u.y));\n    \tt += T(vec3(0),vec3(u,0),o,O(U+u));\n    }\n\treturn t;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{   R = iResolution.xy;\n    \n \tC.xyz = W(U);\n \tvec3 ne = .25*0.3333*(\n        W(U+vec2(0, 1))+\n        W(U+vec2(0,-1))+\n        W(U+vec2( 1,0))+\n        W(U+vec2(-1,0))+\n        \n        W(U+vec2(1, 1))+\n        W(U+vec2(1,-1))+\n        W(U+vec2( 1,1))+\n        W(U+vec2(-1,1))+\n        \n        W(U+vec2(-1, 1))+\n        W(U+vec2(-1,-1))+\n        W(U+vec2( 1,-1))+\n        W(U+vec2(-1,-1))\n        \n    );\n \tC.xyz = mix(C.xyz,ne,0.5);\n \tC.xyz += S(U);\n    if (iFrame < 1) C = vec4(0,0,0,0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}