{
    "Shader": {
        "info": {
            "date": "1726288685",
            "description": "source https://www.shadertoy.com/view/wsBXRz#",
            "flags": 0,
            "hasliked": 0,
            "id": "4XfcRS",
            "likes": 0,
            "name": "spiral circles",
            "published": 3,
            "tags": [
                "circles",
                "sdf"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 71
        },
        "renderpass": [
            {
                "code": "\n#define M_PI 3.1415926535897932384626433832795\n#define AA 2\n\nfloat density = 22.;\nfloat height = 0.7;\nfloat fov = 0.25;\nfloat camera_y = 1.;\n\nfloat camera_ty = -0.17;\nfloat interpos = -1.0;\nfloat shorten = 1.;\nfloat line_width = 0.217;\nfloat rot_XY = 0.;\nfloat rot_YZ = 0.785;\nfloat radius = 0.11;\nfloat rho_offset = 1.;\nfloat vcut;\nfloat lpscale;\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\tfloat q = length(p.x);\n\treturn dot(c,vec2(q,p.y));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec2 rotate(vec2 p, float rad) {\n    mat2 m = mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n    return m * p;\n}\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\n\tfloat r = length(p);\n  \n\tp = vec3((r), acos(p.y / length(p)), atan(p.x, p.x));\n   \n\tfloat xshrink = 1.0/(abs(p.y-M_PI)) + 1.0/(abs(p.y)) - 1.0/M_PI;\n\tp.y += height+0.1*cos(iTime);\n\n\tmul = r/lpscale/xshrink;\n\tp *= lpscale;\n\tsp = p;\n\t\n\tp = fract(p*0.5) * 2.0 - 1.0;\n\tp.x *= xshrink;\n\ttp = p;\n\t\n\tpR(p.yz, rot_YZ);\n    rp = p;\n}\n\nfloat sdf(in vec3 p)\n{\n\n\n\tvec3 sp, tp, rp;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\t\n\tfloat spheres = abs(rp.x)+0.3*cos(iTime) - 0.22;\n\tfloat leaves = max(spheres, max(-rp.y, rp.z));\n\tleaves = max(leaves, vcut-sp.y);\n\tspheres = max(spheres, vcut-sp.y+1.07);\n\tfloat ret = min(leaves, spheres);\n\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat interS = abs(pi.x)*0.3*cos(iTime) ;\n\tfloat interL = max(interS, max(-rp.y, rp.z));\n\tinterL = max(interL, vcut-sp.y+2.);\n\tinterS = max(interS, vcut-sp.y+3.);\n\tret = min(ret, min(interL, interS));\n\n\tfloat ol = abs(rp.y) - radius*0.8;\n\tol = min(ol, abs(rp.z) - radius*0.8);\n\n    ret = max(ret, -ol);\n\n\treturn ret * mul / shorten;\n}\n\nvec3 colr(in vec3 p)\n{\n\n\tvec3 sp, tp, rp, ret;\n\tfloat mul;\n\ttile(p, sp, tp, rp, mul);\n\n\tfloat ol = abs(rp.y) - radius;\n\tol = min(ol, abs(rp.z) - radius);\n\n\tvec3 pi = rp;\n\tpi.x += interpos;\n\tfloat inter = abs(pi.x) - 0.2;\n\tinter = max(inter, vcut-sp.y+3.);\n\n\tfloat dark = smoothstep(density*0.25, density*0.5, density - sp.y);\n\tdark *= dark;\n\t\n\tif (ol < line_width)\n\t\tret = vec3 (0.6, 0.5, 20.8)*dark;\n\telse if (inter < 0.02)\n\t\tret = vec3 (0.1, 0.35, 0.05)*dark;\n\telse\n\t\tret = vec3 (0.1, 0.25, 0.25)*dark;\n\treturn ret;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(gain(v.x, k), gain(v.y, k), gain(v.z, k));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvcut = floor(density*0.25)*2.+0.9;\n\tlpscale = floor(density)/M_PI;\n\tvec2 myfragCoord = fragCoord.xy;\n    vec2 iUV = fragCoord.xy/iResolution.xy;\n        \n\n\n\tfloat an = 0.005*iTime + 7.0;\n\tvec3 ro = vec3(1.0*cos(an), camera_y, 1.0*sin(an));\nro.z-=0.2;\n\tvec3 ta = vec3( 0.0, camera_ty, -0.0 );\n\t\n    vec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 bg = vec3(0.06, 0.08, 0.21)*0.3;\n\tbg *= 1.-smoothstep(0.1, 2., length(iUV*20.-1.));\n\tvec3 tot = bg;\n\t\n\t\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(myfragCoord+o))/iResolution.y;\n\t\t  \n\t  p.xy=rotate(p.xy, (iTime*2.1));\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + fov*ww);\n\n\t\tconst float tmax = 5.5;\n\t\tfloat t = 0.0;\n\t\tvec3 pos;\n         \n  \n \n\t\tint iout;\n\t\tfor( int i=0; i<64; i++ )\n\t\t{\n\t\t\tpos = ro + t*rd;\n          \n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t\tiout = i;\n\t\t}\n\t\tfloat fSteps = float(iout) / 64.;\n\t\n\t\tvec3 col = vec3(0.0);\n\t\tif( t<tmax )\n\t\t{\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 31.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = colr(pos)*amb + colr(pos)*dif;\n\t\t}\n\n\t\tfloat gloamt = smoothstep(0.04, 0.5, length(pos));\n\t\tfloat gain_pre = 1. - gloamt*0.6;\n\t\tfloat gain_k = 21.5 + gloamt*2.5;\n\t\tcol += gain(fSteps*vec3(0.7, 0.8, 1.9)*gain_pre, gain_k);\n\n\t\tcol = mix(col, bg, smoothstep(0.2+camera_y, 1.6+camera_y, t));\n\n\t\t\n\t\ttot += col;\n\n\t}\n\ttot /= float(AA*AA);\n\n\n\tfragColor = vec4(tot, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}