{
    "Shader": {
        "info": {
            "date": "1638937885",
            "description": "In this version I am reducing the number of border intersection tests by approximately half for each step. I discard any borders created with cells that are outside a given angle from the ray direction since it can't hit those. \nit's like +20 fps! lol",
            "flags": 0,
            "hasliked": 0,
            "id": "7tcSDn",
            "likes": 13,
            "name": "Voronoi [Border Skipping]",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "commented",
                "borders",
                "edges",
                "comments",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 361
        },
        "renderpass": [
            {
                "code": "/* \nThis Voronoi Shader is based on:\n\n1. An article by IQ: \n    https://iquilezles.org/articles/voronoilines\n2. Tomkh's method where you get borders based around uv\\\n    https://www.shadertoy.com/view/llG3zy\n3.Shane's Rounded border shader::\n    https://www.shadertoy.com/view/ll3GRM\n4. Tomkh, Abje and glk7 all have some sort of voronoi traversal\n   algorithm\n5. My first attempt at a voronoi traversal with comments\n   https://www.shadertoy.com/view/NltSRM\n=============================================================\n\nA new thing I thought of. We don't need to check 9 borders\n(I mean since that's how I've been doing it), because we know\nthe direction of the rd and we know that we check cells roughly at\nspecific angles on the cartesian grid based on the for i for j loop.\nso we can take the dot product of each id and the rd and if that\nangle is greater than 180 degrees we can skip the whole calculation\nincluding the intersection because the ray isn't moving in that\ndirection. \n\nMy only issue is that the border segments I am testing against\nare a set length and that leads to the rare case where a segment\ngets intersected with that shouldn't. Increasing the test angle \n(by reducing \"TEST_ANGLE\") from 0. to -0.1 or even -0.3 should get rid\nof this.\n\nSo the maximum gain is x2 since for every step we do only 4 intersections\ninstead of 8.\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 8./iResolution.y\n\n#define maxPoints 16.\n#define screenSize 4.\n\n#define bg (0.5+0.5*sin(vec3(iTime,iTime*3.+403.,iTime*1.3+902.)))\n#define fg (0.5+0.5*sin(vec3(-iTime*2.1,-iTime*0.9+403.,-iTime+902.)))\n\n\n///////////////////////////////////////////////////////////////\n//\n// TEST_ANGLE is the angle between the rd and the id that\n// we check. So if rd is (1.,0.) and the current for loop id\n// is (-1.,0.) that border will be in close to the opposite\n// direction of the rd so we don't need to check for an intersection\n// with that border!\n//\n// 0. fails in only one spot as far as I could tell. \n// So anything more that 180 degrees\n// from the rd's direction doesn't need to be checked\n// 0.3 is max and you get some issues already there\n//\n////////////////////////////////////////////////////////////////\n\n//to be safe I went -0.1\n#define TEST_ANGLE -0.1\n\n//a method for finding the intersection between\n//two rays. Not effienct but very memorable.\nfloat seg_seg(vec2 ro1, vec2 rd1, vec2 A, vec2 B){\n    vec2 ro2 = A;\n    vec2 rd2 = normalize(B-A);\n    float maxABLange = length(B-A);\n    \n    vec2 perp = rd1.yx*vec2(-1.,1.);\n    float s = (dot(ro1,perp) - dot(ro2,perp))/dot(rd2,perp);\n    perp = rd2.yx*vec2(-1.,1.);\n    float t = (dot(ro2,perp) - dot(ro1,perp))/dot(rd1,perp);\n    return t >= 0. && s >= 0.? t : 100.;\n}\n\n\nvec2 rnd2(vec2 id){\n    return vec2(fract(sin(dot(id,vec2(14.27,74.97)))*54329.34),\n           fract(sin(dot(id+912.35,vec2(49.27,102.74)))*54329.34));\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nfloat point(vec2 uv, float r){\n    return smoothstep(r+eps,r-eps,length(uv));\n}\n\nfloat ring(vec2 uv, float r){\n    return smoothstep(eps+0.03, 0., abs(length(uv)-r+0.03));\n}\n\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n    vec2 PA = P-A;\n    vec2 AB = B-A;\n    float t = clamp(dot(PA,AB)/dot(AB,AB),0.,1.);\n    return smoothstep(r+eps,r-eps,length(PA-AB*t));\n   \n}\n\n/***************************************************\n\nHere is the actual voronoi traversal algorithm\n\n*************************************************** */\nfloat voronoiEdgeHit(vec2 uv, vec2 ro, vec2 rd, inout vec3 line_color){\n\n    vec2 st = fract(ro);\n    vec2 stFL = floor(ro);\n    vec2 d = vec2(10.);\n\n    vec2 pointA;\n    vec2 pointB;\n\n\n    float minT = 100.;\n    float t;\n\n    \n    //in this loop we are just looking for the closest point\n    //to the curent ro. It's a standard voronoi but instead of uv\n    //for every pixel we just have ro (the same value) being looked at\n    //every pixel (you wont see \"ro\" here because of what I did above.\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testA = stFL + coords;\n        float c = length(coords.xy - st);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            pointA = testA;\n            \n            }\n        }\n    }    \n    \n    //In this loop I am finding every edge based on Iq's article\n    //meaning I get a new st an stFLoor based on pointA\n    //and find borders around pointA based on that.\n    \n    //so for each edge I check to see where it intersects \n    //with the ray based on ro and rd. We look at 25 edges\n    //around our pointA and the edge that we hit first (minimum t value)\n    //is what we hit so we return that t value and traverse that amount\n    //along the ray.\n    \n    //get a new st and stFL based on the point in this cell that\n    //we've found. This way we are garanteed that the edges will be \n    //the ones that fully enclose the cell!\n    st = fract(pointA);\n    stFL = floor(pointA+0.001);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        //and I almost forgot to normalize!!!\n        if(dot(normalize(vec2(i,j)),rd) > TEST_ANGLE){\n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime);\n        vec2 testB = stFL + coords;\n        \n        float distAB = length(testB-pointA);\n        if( distAB > 0.001 && distAB < 2.){\n            vec2 edgePoint =(pointA+testB)/2.;\n            vec2 perp = normalize(testB-pointA).yx*vec2(-1.,1.);\n            vec2 edgeSideA = edgePoint - perp*0.7;\n            vec2 edgeSideB = edgePoint + perp*0.7;\n            //Check where we intersect the current found edge\n            minT = min(minT, seg_seg(ro,rd,edgeSideA,edgeSideB));\n            line_color = mix(line_color,vec3(0.,0.9,1.),0.8*line(uv,edgeSideA,edgeSideB,0.05));\n            //faster version\n            //minT = min(minT, seg_seg_new(ro,rd,edgeSideA,edgeSideB));\n           }\n           \n       }\n      }\n    }\n    return minT;\n}\n\n\n\n\n//Basic Voronoi for coloring\nvec4 voronoi(vec2 uv){\n\n    vec2 st = fract(uv);\n    vec2 stFL = floor(uv);\n    vec2 d = vec2(10.);\n    vec2 A, B=vec2(100.);\n\n    vec2 mind;\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(c < d.x){\n            d.x = c;\n            d.y = (stFL+id).x*20.+(stFL+id).y;\n            A = coords;\n\n            }\n        }\n    }\n    \n  \n    mind = d;\n    \n    d = vec2(10.);\n    \n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n        \n        vec2 id = vec2(i,j);\n        vec2 rndShift = rnd2(stFL+id);\n        vec2 coords = id + 0.5+0.35*sin(pi*2.*(rndShift)+iTime) - st;\n        \n        float c = length(coords.xy);//max(abs(coords.x),abs(coords.y));\n        \n        if(length(A-coords) > 0.00){\n            //d.x = c;\n            //d.y = rnd2(stFL+id).y;\n            B.x = smin2(B.x, dot( 0.5*(A+coords), \n                       normalize(coords-A) ), 0.06 );\n            }\n        }\n    }\n    B.y = B.x;\n    return vec4(mind,B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float globalScale = 4.;\n    uv*=globalScale ;\n\n    //get a voronoi for coloring cells an edges\n    vec4 voronoXY = voronoi(uv);\n    \n    //set basic color for all voronoi cells\n    vec3 col = 0.2+0.5*sin(vec3(1., 2., 3.)/1.2+ rnd2(voronoXY.yy).y*200.);\n    //col.zy *= rot(.1);\n\n    //add some color to the eddges of the voronoi\n    col = mix(col, vec3(0.), smoothstep(0.1,0.095,voronoXY.z));\n    col = mix(col, vec3(1.,0.4,0.), smoothstep(0.02,0.01,voronoXY.z));\n    col += smoothstep(0.05,0.03,voronoXY.z)*(0.5+0.5*sin(voronoXY.z*10.))/1.5;\n    col = col.xxx;\n   //define ro, rd, and set default rotation of rd\n   vec2 ro = vec2(0.,0.);\n   vec2 rd = vec2(1.,0.);\n   rd *= rot(iTime/2.);\n   \n   //adust mouse\n   vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n   //rotate ray based on mouse if mouse press\n   if(iMouse.z > 0.5){rd = normalize(m.xy+ro);}\n   \n   //draw Ray\n   col = mix(col, vec3(1.,0.5,0.), line(uv, ro, ro + rd*30., 0.04));\n\n   //Draw RO\n   col = mix(col, vec3(.0,.4,.9),point(uv-ro,0.1));\n   \n   //t value for traversing\n   float t;\n   \n   /****************************************************\n\n                  THIS IS THE MAIN EVENT\n   \n   ****************************************************/\n   \n    \n    //we can do 40 x 8 seg-seg intersections without getting slow.\n    //I do 15 to be nice lol\n   for(float i = 0.; i < 15.; i++){\n       t = voronoiEdgeHit(uv,ro,rd,col);\n       ro += rd*t*1.001;\n       col = mix(col, vec3(1.0,.0,.0),point(uv-ro,0.1));\n       col = mix(col, vec3(1.0,.0,.0),\n           ring(uv-ro,0.24+sin(iTime*4.+i/10.)*0.07));\n   }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}