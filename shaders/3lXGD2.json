{
    "Shader": {
        "info": {
            "date": "1634212446",
            "description": "big shade",
            "flags": 0,
            "hasliked": 0,
            "id": "3lXGD2",
            "likes": 0,
            "name": "Interpollation between two obj",
            "published": 3,
            "tags": [
                "inter"
            ],
            "usePreview": 0,
            "username": "sevrin",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float radius){\n \n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    float t = dot(ap,ab) / dot(ab,ab);\n    t = clamp(t,0.,1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-radius;\n}\n\nfloat sdBox(vec3 p, vec3 size){\n    return length(max(abs(p)-size,.0));\n}\n\nfloat S( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nvec3 opRep(in vec3 p, in vec3 c){\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\n\n\nfloat GetDist(vec3 point){\n    \n \tvec4 sphere = vec4(0,1.+sin(iTime),6,0.2);\n    \n    float sphereDist = length(point - sphere.xyz) - sphere.w;\n    float planeDist = point.y;\n    \n    float capsuleDist = sdCapsule(point, vec3(-2,1,6), vec3(1,2,6), .3);\n\tfloat boxDist = sdBox(point-vec3(0,0.5,6), vec3(.5));\n    float sdP = sdPlane(point-vec3(0,1,8), vec4(0,1,0,1));\n    \n    \n    float d = min(sphereDist,planeDist);\n    d = min(d,S(sphereDist,boxDist,0.5));\n    d = min(d,S(sphereDist, sdP,0.2));\n   \t\n    \n    return d;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection){\n    \n \tfloat distanceOrigin = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 point = rayOrigin + rayDirection * distanceOrigin;\n        float distanceScene = GetDist(point);\n    \tdistanceOrigin += distanceScene;\n    \tif(distanceOrigin > MAX_DIST || distanceScene<SURF_DIST * 0.5) break;\n    }\n    return distanceOrigin;\n}\n\nvec3 GetNormal(vec3 point){\n    float dist = GetDist(point);\n    vec2 e = vec2(.01,0);\n    vec3 normal = dist - vec3(\n        GetDist(point-e.xyy),\n        GetDist(point-e.yxy),\n        GetDist(point-e.yyx)\n        );\n\n   \treturn normalize(normal);\n}\n\nfloat GetLight(vec3 point){\n    \n \tvec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    \n    vec3 light = normalize(lightPos - point);\n    vec3 normal = GetNormal(point);\n    float diffuse = clamp(dot(normal, light),0.,1.);\n    float dist = RayMarch(point + normal * SURF_DIST,light);\n    if(dist < length(lightPos - point)) diffuse *= .1;\n    return diffuse;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(0,2,1);\n    vec3 rayDirection = normalize(vec3(uv.x,uv.y,1));\n    vec3 col = vec3(0);\n    \n    float d = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 point = rayOrigin + rayDirection * d;\n    \n    float diffuse = GetLight(point);\n    \n    col = vec3(diffuse);\n    \n    float s = abs(sin(iTime));\n    float c = cos(iTime);\n    \n    fragColor = vec4(col.x * c,col.y * s,col.z,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}