{
    "Shader": {
        "info": {
            "date": "1659039543",
            "description": "CC0: Dodecahedron inner reflections\nI watched this and was pretty amazed: https://www.youtube.com/watch?v=qNoQXF2dKBs\nI tried to create something like that but it's not as cool partly because I don't\nknow how to do a Rhombicosidodecahedron\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7dKBDt",
            "likes": 30,
            "name": "Dodecahedron inner reflections",
            "published": 3,
            "tags": [
                "3d",
                "reflections"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 554
        },
        "renderpass": [
            {
                "code": "// CC0: Dodecahedron inner reflections\n// I watched this and was pretty amazed: https://www.youtube.com/watch?v=qNoQXF2dKBs\n// I tried to create something like that but it's not as cool partly because I don't\n// know how to do a Rhombicosidodecahedron\n// But I think it's cool enough to share\n\n// Press left mouse button for some crappy camera control\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PHI         (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define TOLERANCE       0.001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MAX_BOUNCES     5\n#define GDF(n)          d = max(d, abs(dot(p, GDFVectors[n])))\n\nconst float initt = 0.5; \n\nint g_mat1 = 0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxFrame(vec3 p, vec3 b, float e) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nconst vec3 GDFVectors[19] = vec3[](\n  normalize(vec3(1, 0, 0)),\n  normalize(vec3(0, 1, 0)),\n  normalize(vec3(0, 0, 1)),\n\n  normalize(vec3( 1,  1,  1)),\n  normalize(vec3(-1,  1,  1)),\n  normalize(vec3( 1, -1,  1)),\n  normalize(vec3( 1,  1, -1)),\n\n  normalize(vec3( 0       ,  1      , PHI+1.0 )),\n  normalize(vec3( 0       , -1      , PHI+1.0 )),\n  normalize(vec3( PHI+1.0 ,  0      , 1       )),\n  normalize(vec3(-PHI-1.0 ,  0      , 1       )),\n  normalize(vec3( 1       , PHI+1.0 , 0       )),\n  normalize(vec3(-1       , PHI+1.0 , 0       )),\n\n  normalize(vec3( 0   ,  PHI, 1   )),\n  normalize(vec3( 0   , -PHI, 1   )),\n  normalize(vec3( 1   ,  0  , PHI )),\n  normalize(vec3(-1   ,  0  , PHI )),\n  normalize(vec3( PHI ,  1  , 0   )),\n  normalize(vec3(-PHI ,  1  , 0   ))\n);\n\n/*\nfloat icosahedron(vec3 p, float r) {\n  p = abs(p);\n  float d = 0.0;\n  GDF(3);\n  GDF(7);\n  GDF(9);\n  GDF(11);\n  return d-r;\n}\nfloat truncatedIcosahedron(vec3 p, float r) {\n  p = abs(p);\n  float d = 0.0;\n  GDF(3);\n  GDF(7);\n  GDF(9);\n  GDF(11);\n  GDF(13);\n  GDF(15);\n  GDF(17);\n  return d-r;\n}\n*/\n\nfloat dodecahedron(vec3 p, float r) {\n  // Bound, not exact distance\n  p = abs(p);\n  float d = 0.0;\n  GDF(13);\n  GDF(15);\n  GDF(17);\n  return d-r;\n}\n\nfloat blobs(vec2 p) {\n  // Generates a grid of dots\n  vec2 bp = p;\n  vec2 bn = mod2(bp, vec2(3.0));\n\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*gcol, 0.0, 1.0);\n  \n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    const float fz = 0.25;\n    const float bz = 1.0/fz;\n    vec2 bpos = pos.xz/bz;\n    float db = blobs(bpos)*bz;\n    db = abs(db);\n    vec2 pp = pos.xz*fz;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.125);\n    dp = min(dp, db);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    \n    float f = 1.0-tanh_approx(0.1*length(pos.xz));\n    col = mix(col, pcol , f);\n  }\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));\n  }\n\n\n  return col;\n}\n\nfloat dfExclusion(vec3 p) {\n  return sphere(p, 3.35);\n}\n\nfloat df0(vec3 p) {\n  float d0 = dodecahedron(p, 3.0);\n  float d = d0;\n  return d;\n}\n\nfloat df1(vec3 p) {\n  float d0 = -(df0(p)+0.05);\n  float d1 = boxFrame(p, vec3(1.1), 0.0)-0.1;\n  float d2 = sphere(p, 1.);\n\n  float d = d0;\n  g_mat1 = 0;\n  if (d1 < d) {\n    d = d1;\n    g_mat1 = 1;\n  }\n\n  if (d2 < d) {\n    d = d2;\n    g_mat1 = 0;\n  }\n  \n  return d;\n}\n\nvec3 normal1(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df1(pos+eps.xyy) - df1(pos-eps.xyy);\n  nor.y = df1(pos+eps.yxy) - df1(pos-eps.yxy);\n  nor.z = df1(pos+eps.yyx) - df1(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch1(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df1(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 normal0(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df0(pos+eps.xyy) - df0(pos-eps.xyy);\n  nor.y = df0(pos+eps.yxy) - df0(pos-eps.yxy);\n  nor.z = df0(pos+eps.yyx) - df0(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch0(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df0(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  float tagg = initt;\n  vec3 ragg = vec3(1.0);\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.1) break;\n    float st = rayMarch1(ro, rd);\n    tagg += st;\n    int mat = g_mat1;\n    vec3 sp = ro+rd*st;\n    float de = dfExclusion(sp);\n    vec3 sn = normal1(sp);\n    \n    const vec3 lcol = vec3(1.0, 1.5, 2.0);\n    \n    // Will never miss\n    switch(mat)\n    {\n    case 0:\n      if (de < 0.0) {\n        agg += ragg*0.5*lcol*exp(10.0*de);\n        ragg *= 0.9;\n      } else {\n        agg += ragg*lcol;\n        ragg = vec3(0.0);\n      }\n      break;\n    case 1:\n      agg += ragg*lcol;\n      ragg = vec3(0.);\n      break;\n    default:\n      break;\n    }\n    \n    rd = reflect(rd, sn);\n    ro = sp+initt*rd;\n    tagg += initt;\n    ragg *= 0.8;\n  }\n  \n  return agg*exp(-.5*vec3(0.3, 0.15, 0.1)*tagg);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec3 col = skyCol;\n\n  float st = rayMarch0(ro, rd);\n  vec3 sp = ro+rd*st;\n  vec3 sn = normal0(sp);\n  float de = dfExclusion(sp);\n  float ptime = mod(TIME, 30.0);\n  float fi = mix(smoothstep(0.8, 1.0, sin(0.5*TAU*ptime*ptime))*step(4.0, ptime), 1.0, step(6.0, ptime));\n  if (st < MAX_RAY_LENGTH) {\n    float sfre = 1.0+dot(rd, sn);\n    sfre *= sfre;\n    sfre = mix(0.1, 1.0, sfre); \n    vec3 sref   = reflect(rd, sn);\n    vec3 srefr  = refract(rd, sn, 0.95);\n    vec3 ssky = sfre*skyColor(sp, sref);\n\n    if (de > 0.0) {\n      col = ssky;\n    } else {\n      col = 0.5*sfre*ssky;\n      vec3 col1 = (1.0-sfre)*render1(sp+srefr*initt, srefr);\n      col += fi*col1;\n    }\n    \n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = vec3(0.0, 4.0, 5.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    ro.xz *= ROT(-2.0*m.x);\n    ro.zy *= ROT(2.0*m.y);\n  } else {\n    ro.xz *= ROT(0.1*TIME);\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/5.5);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render0(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}