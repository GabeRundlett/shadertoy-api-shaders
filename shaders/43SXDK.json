{
    "Shader": {
        "info": {
            "date": "1711142173",
            "description": "Colors pixels based on their position in the Hilbert curve, try clicking and dragging! The shader doesn't even have to be running for the mouse tracking to work.",
            "flags": 0,
            "hasliked": 0,
            "id": "43SXDK",
            "likes": 7,
            "name": "Hilbert Curve Index",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "lightningund",
            "viewed": 146
        },
        "renderpass": [
            {
                "code": "// 0 - Mouse Control\n// 1 - Revealed over time\n#define MODE 0\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec3 k = vec3(1, 2. / 3., 1. / 3.);\n\tvec3 p = abs(fract(c.xxx + k.xyz) * 6. - 3.);\n\treturn c.z * mix(k.xxx, clamp(p - 1., 0., 1.), c.y);\n}\n\nint get_ind(ivec2 v, int m) {\n\tint index = 0;\n\n\t// Loop through the different orders, from 2^(m-1), halving each time down to 1\n\tfor (int s = 1 << (m - 1); s > 0; s >>= 1) {\n\t\t// Figure out the quadrant it is in\n\t\tbool bx = (v.x & s) > 0;\n\t\tbool by = (v.y & s) > 0;\n\t\t// int rx = bx ? 1 : 0;\n\t\t// int ry = by ? 1 : 0;\n\n\t\t// Adjust the index\n\t\tindex += s * s * ((3 * int(bx)) ^ int(by));\n\n\t\t// Flip and move the current relative position accordingly\n\t\tif (!by) {\n\t\t\tif (bx) v = s - 1 - v;\n\t\t\tv.xy = v.yx;\n\t\t}\n\t}\n\n\treturn index;\n}\n\n// These should be uniforms but shadertoy doesn't like that for some reason\n// uniform int order = 10;\n// uniform float max_time = 60.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int order = 10;\n\tfloat max_time = 60.;\n\n\t// Re-map to (0, 0)-(2^order, 2^order)\n    ivec2 coords = ivec2(fragCoord / iResolution.xy * float(1 << order));\n\t// Get the index on the Hilbert Curve\n    int ind = get_ind(coords, order);\n\t// Find the percent along the way it is\n    float percent = float(ind) / float(1 << (2 * order));\n\n\t// Re-map to (0, 0)-(2^order, 2^order)\n    ivec2 intmouse = ivec2(iMouse.xy / iResolution.xy * float(1 << order));\n\t// Get the index of the mouse on the Hilbert Curve\n    int mouse_ind = get_ind(intmouse, order);\n\t// Find the percent along the way it is\n    float mouse_percent = float(mouse_ind) / float(1 << (2 * order));\n\n#if MODE == 0\n\t// Everything before the position of your mouse is revealed\n    if (percent < mouse_percent || mouse_ind <= 1) {\n#elif MODE == 1\n\t// Makes it animate; essentially \"reveals\" parts along the curve as time goes on\n    if (percent * max_time < iTime) {\n#else\n\tif (1) {\n#endif\n\n\t\t// Fancy color mapping; colors based on hue mapped recursively. Makes more sense looking at the result\n        int subLevel = int(ceil(log(float(ind)) / log(4.)));\n        int subTotal = 1 << (subLevel * 2);\n        vec3 col = hsv2rgb(vec3(map(float(ind), float(subTotal >> 2), float(subTotal), 0., 1.), 1, 1));\n\n        fragColor = vec4(col, 1);\n\t} else {\n        fragColor = vec4(0, 0, 0, 1);\n\t}\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}