{
    "Shader": {
        "info": {
            "date": "1586120101",
            "description": "Developing sound analysis.",
            "flags": 96,
            "hasliked": 0,
            "id": "ts2cRh",
            "likes": 6,
            "name": "Equalizer devel",
            "published": 3,
            "tags": [
                "sound",
                "visualization"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 390
        },
        "renderpass": [
            {
                "code": "vec4 lightColumn(vec4 O, vec2 U) {\n    O *= O.g-O.r;\n//    O += O*U.y/R.y;\n    return O;\n}\nvec4 lightColumn(vec2 U) {\n    float w = R.x-512.;\n    float x = (U.x-512.)/w;\n    x -= 0.5;\n    x *= 1.0-0.875*U.y/R.y*U.y/R.y;\n    x += 0.5;\n    ivec2 pos = ivec2(x*512.,0);\n    return lightColumn(texelFetch(iChannel0,pos,0),U);\n}\n\nvec4 image(vec2 U) {\n    vec4 O;\n    if(iMouse.z>0.) {\n        ivec2 pos = ivec2(U);\n        vec4 O1 = texelFetch(iChannel1,pos,0);\n        O1 = clamp(O1-0.03125,0.,1.);\n        O1 += O1*O1*1.25-0.0625;\n        pos = ivec2(mod(U.x,R.x/16.)+floor(U.y/R.y*16.)*R.x/16.,U.y);\n        vec4 O2 = texelFetch(iChannel1,pos,0);\n        O2 = clamp(O2-0.03125,0.,1.);\n        O2 += O2*O2*1.25-0.0625;\n        O=0.5*(O1+O2);\n    } else if(U.y*2.>R.y) {\n        ivec2 pos = ivec2(U.x,mod(U.y,0.5*R.y));\n        O = texelFetch(iChannel1,pos,0);\n        O = clamp(O-0.03125,0.,1.);\n        O += O*O*1.25-0.0625;\n    } else if(U.x>512.) {\n        ivec2 pos = ivec2((U.x-512.)/(R.x-512.)*512.,0);\n        O = vec4(0);\n        O += lightColumn(U-vec2(2,0));\n        O += lightColumn(U+vec2(2,0));\n        O *= 4.*U.y/R.y*U.y/R.y;\n        O += lightColumn(U-vec2(1,0));\n        O += lightColumn(U+vec2(1,0));\n        O *= 4.*U.y/R.y*U.y/R.y;\n        O += lightColumn(U);\n        pos.y = int(U.y/R.y*2.*0.125*450.);\n        O.rgb += max(texelFetch(iChannel0,pos,0).bgr*2.-0.5,0.)*exp2(-4.*U.y/R.y);\n        O = clamp(O,0.,1.);\n        if(iMouse.x>5.) {\n            pos=ivec2((floor(iMouse.x/R.x*16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp((texelFetch(iChannel1,pos,0).rgb-0.25)*4.0,0.,1.);\n            pos=ivec2((floor(iMouse.y/R.y*16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp((texelFetch(iChannel1,pos,0).rgb-0.25)*4.0,0.,1.);\n        } else {\n            pos=ivec2((mod(floor(iTime/3.75*4.0+0.875)+1.,16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp(texelFetch(iChannel1,pos,0).rgb-0.25,0.,1.);\n            pos=ivec2((mod(floor(iTime/3.75*2.0+0.875)+1.,16.)+(U.x-512.)/(R.x-512.))/16.*R.x,0);\n            O.rgb += clamp(texelFetch(iChannel1,pos,0).rgb-0.25,0.,1.);\n        }\n        //O.rgb += clamp(0.5*texelFetch(iChannel1,ivec2((mod(floor(iTime*0.4)+9.,16.)+0.5)/16.*R.x,0.5*R.y+1.5),0).rgb-0.125,0.,1.);\n        O *= exp2(-2.*U.y/R.y);\n    } else { \n        ivec2 pos = ivec2(U);\n        O = texelFetch(iChannel0,pos,0);\n        O += 2.0*smoothstep(min(O.r,O.b),max(O.r,O.b)+1.,O.g);\n        //O *= vec4(0,1.-4.*(O.r+O.b),0,0);\n    }\n    return O;\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 image(vec2 U) {\n    ivec2 pos = ivec2(U);\n    if(pos.x>511) return vec4(0);\n    if(pos.y>0) return texelFetch(iChannel0,pos-ivec2(0,1),0);\n    float acc1 = 0.0;\n    #ifdef INACCURATE\n    for(int i = 0; i <= pos.x; i++) {\n        acc1 += texelFetch(iChannel3,ivec2(i,0),0).x;\n    }\n    #else\n    for(int i1 = 0; i1 <= pos.x;) {\n        float acc2 = 0.0;\n        for(int i2 = 0; i2 < 2 && i1 <= pos.x; i2++) {\n            float acc3 = 0.0;\n            for(int i3 = 0; i3 < 2 && i1 <= pos.x; i3++) {\n                float acc4 = 0.0;\n                for(int i4 = 0; i4 < 2 && i1 <= pos.x; i4++) {\n                    float acc5 = 0.0;\n                    for(int i5 = 0; i5 < 2 && i1 <= pos.x; i5++) {\n                        float acc6 = 0.0;\n                        for(int i6 = 0; i6 < 2 && i1 <= pos.x; i6++) {\n                            float acc7 = 0.0;\n                            for(int i7 = 0; i7 < 2 && i1 <= pos.x; i7++) {\n                                float acc8 = 0.0;\n                                for(int i8 = 0; i8 < 2 && i1 <= pos.x; i8++) {\n                                    float acc9 = 0.0;\n                                    for(int i9 = 0; i9 < 2 && i1 <= pos.x; i9++, i1++) {\n                                        acc9 += texelFetch(iChannel3,ivec2(i1,0),0).x;\n                                    }\n                                    acc8 += acc9;\n                                }\n                                acc7 += acc8;\n                            }\n                            acc6 += acc7;\n                        }\n                        acc5 += acc6;\n                    }\n                    acc4 += acc5;\n                }\n                acc3 += acc4;\n            }\n            acc2 += acc3;\n        }\n        acc1 += acc2;\n    }\n    #endif\n    acc1 /= floor(U.x+1.);\n    return vec4(texelFetch(iChannel3,ivec2(pos.x,0),0).x,0,acc1,0);\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 21790,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/sonnfried-rodewald/mike-foyle-shipwrecked-sonnfried-rodewald-remix"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define DEBUG2\n\nvec2 printNum2_ZOOM;\n#ifdef DEBUG2\n//const vec2 printNum2_ZOOM = vec2(2,2);\nconst vec2 printNum2_FONT = vec2(4,5);\nconst vec2 printNum2_ORIGIN = vec2(0,0);\nconst float printNum2_LINE_BORDER = 1.0;\nconst float printNum2_LINE_HEIGHT = printNum2_FONT.y+printNum2_LINE_BORDER*2.0;\nconst float printNum2_GROUP_SIZE = 3.;\nconst float printNum2_GROUP_SEPARATOR_HEIGHT = 1.+0.*printNum2_LINE_HEIGHT;\nconst float printNum2_GROUP_HEIGHT = printNum2_LINE_HEIGHT*printNum2_GROUP_SIZE+printNum2_GROUP_SEPARATOR_HEIGHT;\n#define ints int[]\n#define int1 int\n#define floats float[]\n#define float1 float\nint printNum2_glyph(int ch) {\n\t/* Font:\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪\n⚫⚫⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪\n⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚫⚫⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫\n⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚫⚪⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚪⚪⚫⚪⚪⚪⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫\n⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚫⚪\n⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚪⚫\n⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚪⚪⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚫⚫\n⚫⚪⚪⚪⚫⚪⚪⚪⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚫⚪⚫⚪⚪⚫⚫⚪⚪⚪⚫⚪⚫⚫⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚪⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫\n⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚪⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚪⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫\n⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚫⚫⚫⚪⚪⚫⚫⚪⚫⚪⚫⚫⚫⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚫⚫⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚪⚪\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚪⚫⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪\n⚫⚫⚫⚫⚫⚪⚫⚪⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚪⚫⚪⚫⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚪⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚫\n⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚪⚫⚪⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚫⚫⚪⚫⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚫⚪⚫⚪⚪⚫⚫⚫⚫⚫\n⚫⚪⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚫⚪⚫⚪⚫⚪⚫⚪⚪⚪⚫⚫⚪⚫⚫⚫⚪⚪⚫⚪⚫⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚪⚫⚫⚫⚫⚫⚪⚫⚪⚫⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚪⚫⚪⚫⚪⚫⚪⚪⚫⚫⚪⚪⚫⚫⚫⚪⚪⚫⚫⚪⚫⚫⚪⚪⚫⚫⚫⚫⚫⚫⚫⚫⚫\n⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫⚫\n\t */\n\treturn ch < 0x20 || ch > 127 ? 0 : ints(/*Q*/\n        0x00000,0x33202,0x55000,0x57575,0x36736,0x41241,0x25357,0x22000,0x12221,0x42224,0x05250,0x02720,0x00024,0x00700,0x00066,0x11244,\n        0x75557,0x26227,0x61247,0x61316,0x13571,0x74616,0x34757,0x71244,0x75757,0x75716,0x02020,0x02024,0x12421,0x07070,0x42124,0x61202,\n        0x35543,0x65755,0x65656,0x34443,0x65556,0x34643,0x34644,0x34553,0x55755,0x72227,0x31153,0x55655,0x44447,0x57755,0x65555,0x25552,\n        0x65644,0x25563,0x65655,0x34216,0x72222,0x55557,0x55552,0x55775,0x55255,0x55722,0x71247,0x32223,0x44211,0x62226,0x25000,0x00007,\n        0x21000,0x02575,0x04656,0x00343,0x01353,0x03563,0x12722,0x03517,0x04655,0x20622,0x20224,0x04565,0x06221,0x00775,0x00655,0x00252,\n        0x06564,0x03531,0x00344,0x03636,0x02723,0x00553,0x00552,0x00577,0x00525,0x00536,0x06246,0x32423,0x22222,0x62126,0x03600,0x00000\n        /*E*/)[ch-0x20];\n}\nfloat printNum2_glyphPixel(int cbits, vec2 p) {\n\tint bitshift = 4 * int1(floor(5.0 * p.y)) + int1(floor(4.0 * fract(-p.x)));\n\tfloat bit1 = float1(cbits >> bitshift & 1);\n\tfloat bit2 = float1(cbits >> (4 + bitshift) & 1);\n\treturn bit1 - (1. - bit1) * 0.125 * bit2;\n}\nvec4 printNum2_offset(vec2 U) {\n\tvec2 pos = U/printNum2_ZOOM - printNum2_ORIGIN;\n    float group = floor(pos.y/printNum2_GROUP_HEIGHT);\n    pos.y -= group*printNum2_GROUP_HEIGHT;\n    float line = floor(pos.y/printNum2_LINE_HEIGHT);\n    pos.y -= line*printNum2_LINE_HEIGHT;\n    return vec4(pos,group,line);\n}\nfloat printNum2_line(vec2 U) {\n    vec4 offsetData = printNum2_offset(U);\n    float group = offsetData.z;\n    float line = offsetData.w;\n\treturn line+group*(printNum2_GROUP_SIZE+1.);\n}\nfloat printNum2_IsInside;\nvec2 printNum2(vec2 uv, float value) {\n\tvec2 p2 = printNum2_offset(uv).xy;\n\tprintNum2_IsInside = 0.0;\n\tif(p2.y < 0.0 || p2.y >= printNum2_LINE_HEIGHT) return vec2(0.0,printNum2_IsInside);\n\tprintNum2_IsInside = 1.0;\n\tvec2 p = (p2 - vec2(0,printNum2_LINE_BORDER))/printNum2_FONT;\n\tint index = int1(floor(p.x)),ch,bits;\n\tif(index < 0) {\n\t\tprintNum2_IsInside = 0.0;\n\t\tch = -1;\n\t} else if((bits = floatBitsToInt(value)) << 1 == 0) {\n\t\tprintNum2_IsInside = float1(index <= 4);\n\t\tch = index > 3 ? -1 : ints(bits < 0 ? 0x2D : 0x20, 0x30, 0x2E, 0x30)[index];// [ -]0.0\n\t} else if((bits & 0x7FFFFFFF) - 0x7F800000 == 0) {\n\t\tprintNum2_IsInside = float1(index <= 9);\n\t\tch = index > 8 ? -1 : ints(bits < 0 ? 0x2D : 0x2B,\n                                   0x49, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x79)[index];// [+-]Infinity\n\t} else if((bits & 0x7F800000) - 0x7F800000 == 0) {\n\t\t//printNum2_IsInside = float1(index <= 12);\n\t\t//ch = index > 11 ? -1 : ints(0x4E, 0x6F, 0x74, 0x2D, 0x61, 0x2D, 0x4E, 0x75, 0x6D, 0x62, 0x65, 0x72)[index];// Not-a-Number\n\t\tprintNum2_IsInside = float1(index <= 3);\n\t\tch = index > 2 ? -1 : ints(0x4E, 0x61, 0x4E)[index];// NaN\n\t} else if(bits < 0 && index == 0) {\n\t\tch = 0x2D;\n\t} else if(index == 0) {\n\t\tch = 0x20;\n\t} else {\n\t\t// Subnormal numbers: exponent is effectively one higher, but there's no extra normalization bit in the mantissa.\n\t\t// Normal numbers: leave exponent as it is, but add extra bit to the front of the mantissa.\n\t\t// Exponent: it's actually biased by 127, but we're treating the mantissa as m.0 rather than 0.m,\n\t\t// so we need to subtract another 23 from it. Mantissa: normalize even mantissa to odd.\n\t\tint last1 = (bits | 0xFF800000) & -(bits | 0xFF800000);\n\t\tint numTrail0s = \n            ((-(last1 & 0x55555555) >> 31) + 1) |\n            ((-(last1 & 0x33333333) >> 31) + 1) << 1 |\n            ((-(last1 & 0x0F0F0F0F) >> 31) + 1) << 2 |\n            ((-(last1 & 0x00FF00FF) >> 31) + 1) << 3 |\n            ((-(last1 & 0x0000FFFF) >> 31) + 1) << 4;\n\t\tint m = (bits & 0x7FFFFF | (-(bits >> 23 & 0xFF) >> 8 & 0x800000)) >> numTrail0s;\n\t\tint e = (bits >> 23 & 0xFF) - 149 + (-(bits >> 23 & 0xFF) >> 31) + numTrail0s;\n\t\tint[] to10 = ints(1, 10, 100, 1000, 10000, 100000, 1000000, 10000000);\n\t\tint len;\n\t\tfor(len = 1; len < 8; len++) {\n\t\t\tif(m < to10[len]) break;\n\t\t}\n\t\tint align = (5 * (max(0, e) + len)) % 6;\n\t\tint at21 = len > 6 ? m % to10[len - 6] * to10[12 - len] : 0;\n\t\tint at01 = len > 6 ? m / to10[len - 6] : m * to10[6 - len];\n\t\t/* Fill digits array */\n\t\tint[] digits01 = ints(\n            at01 / to10[align],\n            at01 % to10[align] * to10[6 - align] + at21 / to10[align],\n\t\t\tat21 % to10[align] * to10[6 - align], /*Q*/0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/*E*/);\n\t\tint mulBy = e < 0 ? 5 : 2;\n\t\tint divBy = e < 0 ? 2 : 5;\n\t\tint first = align;\n\t\tfor(int i = 0, n = abs(e); i < n; i++) {\n\t\t\tint indexN = first / 6;\n\t\t\tif(digits01[indexN] < divBy * to10[5 - first % 6]) {\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t\tfor(int index0 = (len + align + i - 1) / 6; index0 >= indexN; index0--) {\n\t\t\t\tint value0 = digits01[index0];\n\t\t\t\tdigits01[index0 + 1] += (value0 * mulBy) % 10 * 100000;\n\t\t\t\tdigits01[index0] = value0 / divBy;\n\t\t\t}\n\t\t}\n\t\tint mid = max(0, e) + len + align;\n\t\tint beg = index + min(first, mid - 1) - 1;\n\t\tint sep = mid - beg;\n\t\tif(sep < min(-1, e)) {\n\t\t\tprintNum2_IsInside = float1(sep == -1 + min(-1, e));\n\t\t\tch = -1;\n\t\t} else if(sep == 0) {\n\t\t\tch = 0x2E;\n\t\t} else {\n\t\t\tint digitIndex = beg + (sep >> 31);\n\t\t\tch = 0x30 + digits01[digitIndex / 6] / to10[5 - (digitIndex % 6)] % 10;\n\t\t}\n\t}\n\treturn vec2(printNum2_glyphPixel(printNum2_glyph(ch), p), printNum2_IsInside);\n}\nvec3 printNum2_print6(vec2 U, vec3 color, vec4 val5, vec4 val4, vec4 val3, vec4 val2, vec4 val1, vec4 val0) {\n\tfloat line = printNum2_line(U);\n\tint index = int1(line - floor(line * 1.0/(printNum2_GROUP_SIZE+1.0)));\n\tif(index >= 0 && index < 24 && mod(line, printNum2_GROUP_SIZE+1.0) < printNum2_GROUP_SIZE) {\n\t\tfloat val = floats(val0.w, val0.z, val0.y, val0.x, val1.w, val1.z, val1.y, val1.x,\n                           val2.w, val2.z, val2.y, val2.x, val3.w, val3.z, val3.y, val3.x,\n                           val4.w, val4.z, val4.y, val4.x, val5.w, val5.z, val5.y, val5.x)[index];\n\t\tvec2 printed = printNum2(U, val);\n\t\tif(printed.y > 0.5) {\n\t\t\tcolor = clamp(clamp(color, 0., 1.) * 0.75 + printed.x, 0., 1.);\n\t\t}\n\t}\n\treturn color;\n}\nvec3 printNum2_print8(vec2 U, vec3 color, vec3 val7, vec3 val6, vec3 val5, vec3 val4, vec3 val3, vec3 val2, vec3 val1, vec3 val0) {\n    return printNum2_print6(U,color,\n                            vec4(val7,val6.x),vec4(val6.yz,val5.xy),vec4(val5.z,val4),\n                            vec4(val3,val2.x),vec4(val2.yz,val1.xy),vec4(val1.z,val0));\n}\n#undef ints\n#undef int1\n#undef floats\n#undef float1\n#endif\n\n\nvec2 R;\n#define MAIN void mainImage(out vec4 O, vec2 U) {R=iResolution.xy;O=image(U);}\nfloat sinpi(float v) {return sin(radians(180.0)*v);}\nvec2  sinpi(vec2  v) {return sin(radians(180.0)*v);}\nvec3  sinpi(vec3  v) {return sin(radians(180.0)*v);}\nvec4  sinpi(vec4  v) {return sin(radians(180.0)*v);}\nfloat cospi(float v) {return cos(radians(180.0)*v);}\nvec2  cospi(vec2  v) {return cos(radians(180.0)*v);}\nvec3  cospi(vec3  v) {return cos(radians(180.0)*v);}\nvec4  cospi(vec4  v) {return cos(radians(180.0)*v);}\nfloat tanpi(float v) {return tan(radians(180.0)*v);}\nvec2  tanpi(vec2  v) {return tan(radians(180.0)*v);}\nvec3  tanpi(vec3  v) {return tan(radians(180.0)*v);}\nvec4  tanpi(vec4  v) {return tan(radians(180.0)*v);}\nfloat atanpi(vec2 v) {return atan(v.y,v.x)/radians(180.0);}\nfloat vmax(vec2 v) {return max(v.x, v.y);}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {return min(v.x, v.y);}\nfloat vmin(vec3 v) {return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {return min(min(v.x, v.y), min(v.z, v.w));}\nfloat sgn(float x) {return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {return vec2(sgn(v.x),sgn(v.y));}\nvec3 sgn(vec3 v) {return vec3(sgn(v.x),sgn(v.y),sgn(v.z));}\nvec4 sgn(vec4 v) {return vec4(sgn(v.x),sgn(v.y),sgn(v.z),sgn(v.w));}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec4 image(vec2 U) {\n    ivec2 p = ivec2(U);\n    vec4 O = texelFetch(iChannel1,ivec2(U.x,max(U.y-1.,0.)),0);\n    if(p.y==0) {\n        vec4 tex = texelFetch(iChannel0,ivec2(U.x,0),0);\n        float curr = max(tex.x-texelFetch(iChannel0,ivec2(511,0),0).z,0.);\n        float prev = max(texelFetch(iChannel0,ivec2(U.x,1),0).x-texelFetch(iChannel0,ivec2(511,1),0).z,0.);\n        O.rgb = vec3(curr,max(curr-prev,0.),prev) * vec3(2,8,1) + vec3(0,0.75*O.g,0);\n        O = clamp(O,0.,1.);\n    }\n    return O;\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec4 image(vec2 U) {\n    ivec2 p = ivec2(U);\n    vec4 O = vec4(0);\n    if(p.y==0) {\n        int which = int(U.x*16./R.x);\n        p.x = int(mod(U.x*16.,R.x)/R.x*512.);\n        vec4 curr1 = texelFetch(iChannel0,ivec2(p.x,0),0);\n        vec4 curr2 = texelFetch(iChannel0,ivec2(511,0),0);\n        vec4 prev1 = texelFetch(iChannel0,ivec2(p.x,1),0);\n        vec4 prev2 = texelFetch(iChannel0,ivec2(511,1),0);\n        float tC = curr2.z;\n        float lC = curr1.z;\n        float rC = (tC*512.-lC*float(p.x+1))/max(512.-float(p.x+1),1.);\n        float tP = prev2.z;\n        float lP = prev1.z;\n        float rP = (tP*512.-lP*float(p.x+1))/max(512.-float(p.x+1),1.);\n        O.r=-0.25/16.;\n        int which1=0;\n        if(which==  0) {which1=  0;O.r = 0.125*max(tC-rC,0.);}\n        if(which==  1) {which1=  1;O.r = max(tC-tP,0.);}\n        if(which==  2) {which1=  2;O.r = 0.125*max(tC-rP,0.);}\n        if(which==  3) {which1=  3;O.r = 0.125*max(lC-rC,0.);}\n        if(which==  4) {which1=  4;O.r = 0.125*max(lC-tP,0.);}\n        if(which==  5) {which1=  5;O.r = max(lC-lP,0.);}\n        if(which==  6) {which1=  6;O.r = 0.125*max(lC-rP,0.);}\n        if(which==  7) {which1=  7;O.r = max(rC-rP,0.);}\n        if(which==  8) {which1=  8;O.r = 0.125*max(tP-rP,0.);}\n        if(which==  9) {which1=  9;O.r = 0.125*max(lP-rP,0.);}\n        if(which== 10) {which1= 10;O.r = 0.125*max(lC-tC,0.);}\n        if(which== 11) {which1= 11;O.r = max(tP-tC,0.);}\n        if(which== 12) {which1= 12;O.r = 0.125*max(lP-tC,0.);}\n        if(which== 13) {which1= 13;O.r = max(lP-lC,0.);}\n        if(which== 14) {which1= 14;O.r = max(rP-rC,0.);}\n        if(which== 15) {which1= 15;O.r = 0.125*max(lP-tP,0.);}\n\n        O.rgb = 32.*O.r+vec3(0.25);\n        if((which1&7)==0) O.rgb *= 1.*vec3(3,0,1)*0.25+0.25;\n        if((which1&7)==1) O.rgb *= 1.*vec3(3,1,0)*0.25+0.25;\n        if((which1&7)==2) O.rgb *= 1.*vec3(3,2,0)*0.25+0.25;\n        if((which1&7)==3) O.rgb *= 1.*vec3(1,3,0)*0.25+0.25;\n        if((which1&7)==4) O.rgb *= 1.*vec3(0,3,2)*0.25+0.25;\n        if((which1&7)==5) O.rgb *= 1.*vec3(0,2,3)*0.25+0.25;\n        if((which1&7)==6) O.rgb *= 1.*vec3(0,1,3)*0.25+0.25;\n        if((which1&7)==7) O.rgb *= 1.*vec3(2,0,3)*0.25+0.25;\n\n        //        O.rgb = vec3(0.0625*curr.x,8.0*abs(curr.x-prev.x),0.0625*max(curr.x-curr.z,0.));\n    } else {\n        vec4 next = texelFetch(iChannel1,p-ivec2(0,1),0);\n        O.rgb = next.xyz;\n    }\n    O.a = 0.0;\n    O = clamp(O,0.,1.);\n    //O = floor(max(2.-abs(texelFetch(iChannel0,ivec2(U.x,1),0).yxzw*R.y-U.y),0.));\n    //O = p.y==0 ? texelFetch(iChannel0,uv,0) : vec4(texelFetch(iChannel1,ivec2(U.x,U.y-1.),0).x,O.yzw);\n    return O;\n}\nMAIN",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}