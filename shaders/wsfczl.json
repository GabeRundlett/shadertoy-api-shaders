{
    "Shader": {
        "info": {
            "date": "1585346344",
            "description": "experimenting with storing state (camera rotation matrix) across frames\ncontrols: WASDQE + mouse.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "wsfczl",
            "likes": 1,
            "name": "[jmmut] flyer",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "jmmut",
            "viewed": 298
        },
        "renderpass": [
            {
                "code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\n// keyboard taken from: https://www.shadertoy.com/view/XdS3RV\n// Hazel Quantock 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nvec4 ReadKey(int key, bool toggle) {\n\t//bool toggle = false;\n\tvec4 keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 );\n\t//return (keyVal>.5)?true:false;\n    return keyVal;\n}\n\n// save/load code from IQ's shader (multipass): https://www.shadertoy.com/view/MddGzf\nvec4 _loadValue( in ivec2 re ) {\n    return texelFetch( iChannel0, re, 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//ugly hack here. couldn't make the float span the whole vec4\n\n//highp vec4 encode32(highp float f) {\n//    return vec4(f, 0., 0., 0.);\n//}\n//highp float decode32(highp vec4 rgba) {\n//    return rgba.x;\n//}\n\nvec4 _encode32(float f) {\n    return vec4(f, 0., 0., 0.);\n}\nfloat _decode32(vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(ivec2(x, y))); }\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\n// based on\n// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nstruct Intersection { float distance; vec3 color; };\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nIntersection unionOp(Intersection a, Intersection b) {\n    if (a.distance < b.distance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nIntersection GetDist(vec3 p) {\n\tvec4 s = vec4(-1, 1, 0, 1);\n    \n    Intersection sphereDist = Intersection(length(p-s.xyz)-s.w, vec3(0.8, 0.4, 0.1));\n    vec3 lightBulbPos = p-vec3(0, 5.5, -2);\n    lightBulbPos.xz -= vec2(sin(iTime), cos(iTime))*3.;\n    Intersection lightBulbDist = Intersection(length(lightBulbPos)-0.4,vec3(0.8, 0.7, 0.4));\n    Intersection planeDist = Intersection(p.y, vec3(0.1, 0.2, 0.9));\n    Intersection boxDist = Intersection(sdBox(p - vec3(1, 1, 0), vec3(.5, .5, .5)), vec3(0.1, 0.6, 0.2));\n    \n    Intersection d = Intersection(1e10, vec3(0));\n    d = unionOp(d, planeDist);\n    d = unionOp(d, sphereDist);\n    d = unionOp(d, lightBulbDist);\n    d = unionOp(d, boxDist);\n    return d;\n}\n\n\nIntersection RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    Intersection intersection;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        intersection = GetDist(p);\n        float dS = intersection.distance;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return Intersection(dO, intersection.color);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).distance;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).distance,\n        GetDist(p-e.yxy).distance,\n        GetDist(p-e.yyx).distance);\n    \n    return normalize(n);\n}\n\nIntersection GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, -2);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    // surfaces perpendicular to the light are more illuminated\n    float diffuse = clamp(dot(n, lightRay), 0., 1.);\n    \n    // if there's some object between our point and the light, reduce the diffuse light\n    Intersection i = RayMarch(p+n*SURF_DIST*2., lightRay);\n    if(i.distance < length(lightPos-p)) {\n        diffuse *= .1;\n    }\n    \n    return Intersection(diffuse, i.color);\n}\n\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\n\nvec3 getKeyboardMovement() {\n    vec3 pos = vec3(0, 0, 0);\n    /*\n    pos.y += loadDecoded(0, 0);\n    pos.y -= loadDecoded(1, 1);\n    pos.x += loadDecoded(2, 2);\n    pos.x -= loadDecoded(3, 3);\n    pos.z += loadDecoded(4, 4);\n    pos.z -= loadDecoded(5, 5);\n*/\n    return pos;\n}\n    \nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy - .5)* 4.;\n    \n    vec4 cameraPosition = load(positionAddress);\n    vec4 originalRo = vec4(0., 1.1, 10., 1.);\n    vec3 ro = (cameraPosition + originalRo).xyz;\n    \n    \n    mat4 rotationMatrix = loadMatrix();\n    mat4 transposedRotationMatrix = transpose(rotationMatrix);\n    vec3 zAxisOfRotationMatrix = vec3(rotationMatrix[2][0], rotationMatrix[2][1], rotationMatrix[2][2]);\n    vec3 rd = normalize((vec4(uv.x, uv.y, -1, 1) * rotationMatrix).xyz);\n    \n    vec4 viewMode = ReadKey(Key_V, true);\n    if (viewMode.x == 0.) {\n        Intersection i = RayMarch(ro, rd);\n        \n        vec3 p = ro + rd * i.distance;\n        \n        Intersection diffuse = GetLight(p);\n        \n        //fragColor = vec4(diffuse.color, 1.0);\n        fragColor = vec4(vec3(diffuse.distance), 1.0);\n    } else {\n        vec2 grid = 7.*fragCoord/iResolution.y-1.;\n        ivec2 coord = ivec2(floor(grid));\n        \n        if (coord.x >= 0 && coord.x <= 3 && coord.y >= 0 && coord.y <=3) {\n            fragColor = vec4(rotationMatrix[coord.x][3 - coord.y], 0., 0., 0.)/3.;\n            fragColor.y = -fragColor.x;\n            //fragColor = vec4(fract(grid.x), fract(grid.y), 0.5, 1.);\n            //fragColor = vec4(float(coord.x)*0.5, float(coord.y)*0.125, 0.5, 1.);\n        } else if (coord == mouseAddress) {\n            vec4 mouse = load(coord);\n            if (fract(grid.x) < 0.25) {\n                fragColor = vec4(mouse.x, -mouse.x, 0., 0.);\n            } else if (fract(grid.x) < 0.5) {\n                fragColor = vec4(mouse.y, -mouse.y, 0., 0.);\n            } else if (fract(grid.x) < 0.75) {\n                fragColor = vec4(mouse.z, -mouse.z, 0., 0.);\n            } else {\n                vec4 v_key = ReadKey(Key_V, true);\n                fragColor = v_key;\n            }\n        } else if (coord.x == 5 && coord.y >= 1 && coord.y <= 3) {\n            vec4 cameraPosition = load(positionAddress);\n            fragColor = vec4(cameraPosition[3-coord.y], -cameraPosition[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 7 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(originalRo[3-coord.y], -originalRo[3-coord.y], 0., 0.)/3.;\n        } else if (coord.x == 8 && coord.y >= 1 && coord.y <= 3) {\n            fragColor = vec4(ro[3-coord.y], -ro[3-coord.y], 0., 0.)/3.;\n        } else {\n            fragColor = vec4(0.1, 0.2, 0.8, 1.);\n        }\n    }\n}\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//jmmut: except for code coming from other people (which I noted and might have modified here), the license is http://www.wtfpl.net/\n\n\nconst ivec2 mouseAddress = ivec2(9, 1);\nconst ivec2 positionAddress = ivec2(6, 1);\n\n// keys are javascript keycode: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = false;\n\tfloat keyVal = textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n// save/load code from IQ's shader: https://www.shadertoy.com/view/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\nfloat isInside( vec2 p, vec4 c ) {\n    vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5;\n    return -max(d.x,d.y);\n}\n\n\nvec4 _loadValue( in vec2 re )\n{\n    \n    return texelFetch( iChannel0, ivec2(re), 0 );\n    //return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec4 _loadValue( in int x, in int y ) { return _loadValue(vec2(x, y)); }\n\n\n//ugly hack here. couldn't make the float span the whole vec4\nhighp vec4 _encode32(highp float f) {\n    return vec4(f, 0., 0., 0.);\n}\nhighp float _decode32(highp vec4 rgba) {\n    return rgba.x;\n}\nfloat _loadDecoded(in int x, in int y) { return _decode32(_loadValue(x, y)); }\nfloat _loadDecoded(in ivec2 re) { return _decode32(_loadValue(vec2(re))); }\n\nvoid _storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid _storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n\n\n\n// --------- from rally simulator https://www.shadertoy.com/view/XdcGWS\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n// --------- from rally simulator\n\n// ----- start my load/store functions\nvec4 load(ivec2 address) {\n    return texelFetch(iChannel0, address, 0);\n}\n\nvoid store(out vec4 fragColor, vec4 value) {\n    fragColor = value;\n}\n\n// ----- end my load/store functions\n\nmat4 loadMatrix() {\n    return mat4(load(ivec2(1,1)),\n                load(ivec2(2,1)),\n                load(ivec2(3,1)),\n                load(ivec2(4,1))\n                );\n}\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat4 RotY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  0, -s,  0,\t// matrices are transposed: this line is the first matrix column\n                0,  1,  0,  0,\n                s,  0,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1,  0,  0,  0,\n                0,  c,  s,  0,\n                0, -s,  c,  0,\n                0,  0,  0,  1\n               );\n}\nmat4 RotZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,  s,  0,  0,\n               -s,  c,  0,  0,\n                0,  0,  1,  0,\n                0,  0,  0,  1\n               );\n}\n\n\nvoid reset(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        mat4 identity = mat4  (1, 0, 0, 0,\n                               0, 1, 0, 0,\n                               0, 0, 1, 0,\n                               0, 0, 0, 1\n                               );\n    \n        if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4 && thisPixelAddress.y == 1) {\n            store(fragColor, identity[thisPixelAddress.x-1]);\n        } else if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(0., 0., 0., 0.));\n        }\n    }\n}\nvoid updateRotationMatrix(out vec4 fragColor, vec2 mouse, mat4 rotationMatrix, ivec2 thisPixelAddress) {\n    float mouseSpeed = 0.75;\n    vec4 previousMouse = load(mouseAddress);\n    if (previousMouse.z > 0.) { // avoid jumping when clicking\n        vec2 mouseDiff = vec2(mouse - previousMouse.xy);\n        rotationMatrix = rotationMatrix * RotY(-mouseDiff.x * mouseSpeed); // yaw, external rotation\n        rotationMatrix = RotX(mouseDiff.y * mouseSpeed) * rotationMatrix; // pitch\n    }\n    vec4 column = rotationMatrix[thisPixelAddress.x-1];\n    store(fragColor, column);\n}\n\nvoid composeTransformations(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 thisPixelAddress = ivec2(fragCoord);\n    if (thisPixelAddress.y == 1) {\n        // we will only write state to addresses y==1 to simplify\n        \n        float movement = 0.;\n        mat4 rotationMatrix = loadMatrix();\n        \n        vec2 mouse = (iMouse.xy /iResolution.xy - .5) * 2.;\t// range [-1, 1]\n        \n        if (thisPixelAddress == mouseAddress) {\n            store(fragColor, vec4(mouse.x, mouse.y, iMouse.z, 0.));\n        } else if (thisPixelAddress == positionAddress) {\n            vec4 position = load(positionAddress);\n            float speed = 0.2;\n            float up      = ReadKey(Key_W)? speed : 0.;\n            float down    = ReadKey(Key_S)? speed : 0.;\n            float right   = ReadKey(Key_D)? speed : 0.;\n            float left    = ReadKey(Key_A)? speed : 0.;\n            float forward = ReadKey(Key_E)? speed : 0.;\n            float back    = ReadKey(Key_Q)? speed : 0.;\n            vec4 movement = vec4(right - left, up - down, back - forward, 1.);\n            store(fragColor, movement * rotationMatrix + position);\n        } else if (thisPixelAddress.x >= 1 && thisPixelAddress.x <= 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n        \n        // I will go crazy if I keep trying to remove this redundant code\n        else if (thisPixelAddress.x == 4) {\n            updateRotationMatrix(fragColor, mouse, rotationMatrix, thisPixelAddress);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        reset(fragColor, fragCoord);\n    } else {\n        composeTransformations(fragColor, fragCoord);\n        //reset(fragColor, fragCoord);\n    }\n}\n\n\n\n\n\n\n\n\n\n    \n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}