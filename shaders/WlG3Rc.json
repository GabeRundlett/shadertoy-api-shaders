{
    "Shader": {
        "info": {
            "date": "1579445098",
            "description": "2020 shader challenge week 3!",
            "flags": 32,
            "hasliked": 0,
            "id": "WlG3Rc",
            "likes": 2,
            "name": "A star at dawn",
            "published": 3,
            "tags": [
                "reflections",
                "pathtracing",
                "colour"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "/*\n\tShader Sundays! (3/52) \n\t\"A star at Dawn\"\n\t\n\tThis week I continued my path tracing experiments but struggled a lot more than the last one. It turns out that\n\tit's considerably easier to write a path tracer than to write an interesting scene with it. This one probably\n\tdoesn't even really need to be pathtraced since it's so simple. Next week I'm gonna focus on building a pretty\n\tscene instead of learning some new gfx thing. \n\n\tSources of inspiration for this week:\n\thttps://iquilezles.org/articles/palettes\n\thttp://the-witness.net/\n*/\n\n#define INV_GAMMA 0.454545\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec3 col;\n    vec2 screen = fragPos / iResolution.xy;\n\n    //Simple montecarlo integration\n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, screen).xyz;\n        col /= float(iFrame);\n    } \n\n    //Post processing\n    col = pow(col, vec3(INV_GAMMA));\n    col *= 2.0;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//GLOBALS\nfloat seed_ = 0.0;\n\nfloat \nhash(float p)\n{ \n    p = fract(p* 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3\nCosineWeightedRay(vec3 normal, float seed)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );   \n}\n\nmat3\nSetCamera(vec3 eye, vec3 tar, float roll)\n{\n    vec3 f, r, u, upTemp;\n    f = normalize(tar - eye);\n    upTemp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    r = normalize(cross(upTemp, f)); \n    u = normalize(cross(f, r));\n\n    return mat3(r, u, f);\n}\n\nfloat\nsdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat\nsdBox(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return length(max(q,0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\nvec2 \nuop(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nvec3\nrepetitionOp(vec3 p, vec3 cellSize)\n{\n    return mod(p + +0.5*cellSize, cellSize) - 0.5*cellSize;\n}\n\nfloat\nsdCircle(vec3 p, float r, float t)\n{\n    float d1 = sdBox(p, vec3(r, r, t));\n\n    float d2 = sdSphere(p, r);\n\n    return max(d1, d2);\n}\n\n#define UOP(dist, id) res = uop(res, vec2(dist, id))\n\n#define SPHERE1_ID 0.0\n#define SPHERE2_ID 1.0\n\n#define BOTTOM_ID 2.0\n#define TOP_ID 3.0\n#define LEFT_ID 4.0\n#define RIGHT_ID 5.0\n#define BACK_ID 6.0\n#define FRONT_ID 7.0\n\n#define WITNESS_ID 8.0\n\n#define EPSI 0.005\n\nvec2\nMap(vec3 p)\n{\n    vec2 res = vec2(1e10, -1.0);\n    //Random box\n    //UOP(sdSphere(p - vec3(00.5, 00.2, 00.0),      0.25),           SPHERE1_ID);\n    //UOP(sdSphere(p - vec3(-0.5, 00.2, 00.0),      0.25),           SPHERE2_ID);\n\n    //Enclosure\n    UOP(sdBox(p - vec3(00.0, -0.1, 00.0), vec3(01.0, EPSI, 1.0)), BOTTOM_ID);\n    UOP(sdBox(p - vec3(00.0, 01.0, 00.0), vec3(01.0, EPSI, 1.0)), TOP_ID);\n    UOP(sdBox(p - vec3(01.0, 00.0, 00.0), vec3(EPSI, 01.0, 1.0)), LEFT_ID);\n    UOP(sdBox(p - vec3(-1.0, 00.0, 00.0), vec3(EPSI, 01.0, 1.0)), RIGHT_ID);\n    UOP(sdBox(p - vec3(00.0, 00.0, -1.0), vec3(01.0, 01.0, EPSI)), FRONT_ID);\n    UOP(sdBox(p - vec3(00.0, 00.0, 01.0), vec3(01.0, 01.0, EPSI)), BACK_ID);\n\n    //Witness Symbol\n    float h = 0.4;\n    float d = 0.1;\n    float p1 = 0.05;\n    float size = 1.2;\n    UOP(sdCircle(p - vec3(-0.7 + p1, h, d), 0.14*size, EPSI), WITNESS_ID);\n    UOP(   sdBox(p - vec3(-0.0 + p1, h, d), vec3(0.7, 0.07*size, EPSI )), WITNESS_ID);\n    UOP(sdCircle(p - vec3(00.7 + p1, h, d), 0.07*size, EPSI), WITNESS_ID);\n\n    return res;\n}\n\n#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define MIN_DIST 0.001\nvec2\nRayMarch(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++i)\n    {\n        vec2 hit = Map(ro + t*rd);\n\n        if(abs(hit.x) < t*MIN_DIST)\n        {\n            res = vec2(t, hit.y);\n            break;\n        }\n\n        t += hit.x;\n    }\n\n    return res;\n}\n\nvec3\nCalcNormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x, \n                          Map(p + e.yxy).x - Map(p - e.yxy).x,\n                          Map(p + e.yyx).x - Map(p - e.yyx).x));\n}\n\nstruct Material\n{\n    vec4 color; // RGB (unused 4th channel)\n    vec4 properties; // Emissive, Roughness, unused 3rd & 4th channel\n};\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nMaterial\nGetMaterial(vec3 p, vec3 n, float id)\n{\n    Material mat;\n    mat.color = vec4(vec3(1.0), -1.0);\n    mat.properties = vec4(0.0, 1.0, -1.0, -1.0);\n\n    if(id == SPHERE1_ID)\n    {\n        mat.color.xyz = vec3(1.0, 1.0, 1.0);\n        mat.properties.x = 0.0;  //Emissive \n        mat.properties.y = 1.0 * mod(floor(p.x * 40.0), 2.0);  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == SPHERE2_ID)\n    {\n        mat.properties.y = 1.0 * mod(floor(p.y * 40.0), 2.0);  //Roughness (0.0reflective, 1.0diffuse)\n        mat.color.xyz = vec3(1.0, 1.0, 1.0);\n        mat.properties.x = 0.0;  //Emissive \n    }\n    else if(id == BOTTOM_ID)\n    {\n        // vec2 tile = floor(p.xz * 4.0);\n        // float isTile = mod(tile.x + tile.y, 2.0);\n        // mat.color.xyz = vec3(1.0, 1.0, 1.0) * isTile;\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.005 ;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == TOP_ID)\n    {\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.006;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == LEFT_ID)\n    {\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.007;  //Roughness (0.0reflective, 1.0diffuse)\n\n    }\n    else if(id == RIGHT_ID)\n    {\n        mat.color.xyz = vec3(0.8, 0.9, 1.1);\n        //mat.color.xyz = vec3(1.0, 0.0, 0.0);\n        //mat.properties.x = 0.5;  //Emissive \n        mat.properties.y = 0.008;  //Roughness (0.0reflective, 1.0diffuse)\n\n    }\n    else if(id == BACK_ID)\n    {\n        mat.properties.y = 0.008;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == FRONT_ID)\n    {\n\t\tmat.properties.y = 0.007;  //Roughness (0.0reflective, 1.0diffuse)\n    }\n    else if(id == WITNESS_ID)\n    {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.0, 0.33, 0.67);\n\n        float t = p.x / 2.0;\n        mat.color.xyz = palette(t, a, b, c, d);\n        mat.properties.x = 1.5;  //Emissive \n    }\n\n    return mat;\n}\n\n#define saturate(val) clamp(0.0, 1.0, val)\n\nvec3\nCalcRayDirection(vec3 originalRd, vec3 reflectionDir, vec3 normal, float rough, float seed)\n{\n    vec3 newRd = vec3(0.0);\n    vec3 randDir = CosineWeightedRay(normal, seed);\n    if(rough >= 1.0)\n    {\n        newRd = randDir;\n    }\n    else\n    {\n        newRd = reflectionDir*(saturate(1.0 - rough)) + rough * randDir;\n        newRd = normalize(newRd);\n    }\n\n    return newRd;\n}\n\nconst vec3 skyCol = vec3(0.5, 0.8, 0.9);\n\n#define GI_BOUNCES 10\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    //GI accumulation setup\n    vec3 tot = vec3(0.0);\n\n    float firstBounceDist = 0.0;\n\n    vec3 rayCol = vec3(1.0);\n\n    //Global illumination loop for solid lighting\n    for(int bounce = 0; bounce < GI_BOUNCES; ++bounce)\n    {\n        //Ray traversal results\n        vec2 res = RayMarch(ro, rd);\n        float t = res.x;\n        float id = res.y;\n\n        if(id < 0.0)\n        {\n            if(bounce == 0)\n            {\n                tot = skyCol;\n            }\n            break;\n        }\n\n        if(bounce == 0 ) firstBounceDist = t;\n\n        //Geometry\n        vec3 P = ro + t*rd;\n        vec3 N = CalcNormal(P);\n        vec3 R = reflect(rd, N);\n\n        //Material\n        Material mat = GetMaterial(P, N, id);\n        rayCol *= mat.color.xyz;\n        float emissiveness = mat.properties.x;\n        float roughness = mat.properties.y;\n\n        //Lighting\n        vec3 lightAccumulation = vec3(0.0);\n        vec3 indirectLight = emissiveness * rayCol;\n\n        //Shadowing\n\n        //Shading\n        lightAccumulation += indirectLight;\n\n        //Light accumulation\n        lightAccumulation *= pow(0.65, float(bounce));\n        tot += lightAccumulation * rayCol;\n\n\n        //Next bounce setup\n        float timeSeed =  76.2 + 73.1*float(bounce) + seed_ + 17.7*float(iFrame);\n        ro = P;\n        rd = CalcRayDirection(rd, R, N, roughness, timeSeed);\n    }\n\n    //Hacky Volumetrics\n\n    //Distance fog\n    tot = mix(tot, skyCol, 1.0 - exp(-0.002*firstBounceDist *firstBounceDist));\n\n\n\n    return tot;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    //Generating a different random number per frame per pixel\n    seed_ = hash( dot(vec2(12.9898, 78.233), fragPos ) + float(iFrame)*1113.1);\n\n    //Getting prev frame result for additive blend \n    vec2 screen = fragPos / iResolution.xy;\n    vec3 col = texture(iChannel0, screen).xyz;\n    if (iFrame == 0) col = vec3(0.0);\n\n    //Camera setup\n    float nearp = 0.7;\n    float roll = 0.0;\n    vec2 offset = -0.5 + vec2(hash(seed_ + 58.21), hash(seed_ + 18.61));\n    vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n    vec3 ta = vec3(0.0, 0.3, 0.0);\n    vec3 ro = ta + vec3(0.5, 0.0, -0.97);\n    mat3 cam  = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearp));  \n\n    //Rendering the path of one ray\n    col += Render(ro, rd);\n    //Debug rng\n    //col = vec3(seed_);\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}