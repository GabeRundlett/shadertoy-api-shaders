{
    "Shader": {
        "info": {
            "date": "1645372093",
            "description": "Fork of [url]https://www.shadertoy.com/view/NsffWN[/url]\nDeserves 15 hearts ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "NdlBzS",
            "likes": 2,
            "name": "heart core (fail)",
            "published": 3,
            "tags": [
                "love",
                "foolishness"
            ],
            "usePreview": 0,
            "username": "hnh",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "\n/*\nUnfortunately, this shader does not work on many systems as intended \nsince it is very sensitive on precision (see comments).\nPlease use the test flag below to see which numbers (int(iTime)) look \ngood on your system. Compare with array va.\n*/\n//#define test\n\n#define PI 3.14159265\n\n\nvec4 flip(vec2 p, float pi) {\n    vec3 a = vec3(0.0998); int ni = 58;  // parameters\n    vec3 q= vec3(p, .06);  // scale\n    vec3 t;\n    for(int i=0; i<ni; i++) {\n        a = sin(a);  // works by accident\n        a = vec3(1.-a.y-a.x,a.y,a.x)*pi;\n\n        vec3 c = cos(a), s = sin(a);\n        mat3 N= mat3(1, 0, 0,\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);\n    \n        for(int j=0; j<3; j++) {\n            t[j] = dot(q, N[j]);\n            if(t[j] < 0.) {q -= 2.*t[j]*N[j]*vec3(1,1,0);}\n        }\n    }\n\t// q.xy: cartesian coords, t.xyz: triangle normal coords (t.x = q.x)\n    return vec4(q.xy, t.yz);\n}\n\n\n#ifdef test\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    U = (U - .5*iResolution.xy)/iResolution.y;        \n    float pi = PI*(1. + floor(iTime)*1e-7);\n    O = flip(U,pi);\n    O = vec4(dot(O,vec4(0,50,-30,0)));\n}\n\n#else\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    int[] va = int[](92,-22,-33,-60,-66,16,24,33,45,48,49,55,56,63,75);  // 15 patterns\n    int na = 15;\n    float a = 5., b = 6.;\n    float t = iTime - .9;\n    float f = sin(-t/b*PI);\n    t += f*f*2.5;\n    \n    U = (U - .5*iResolution.xy)/iResolution.y;\n\n    float l = length(U);\n    f = (log(l) - t + a)/b;    \n    int n = int(1.-f);  // pattern index\n    f = fract(f);\n    float l2 = exp(f*b - a);\n    f = smoothstep(.5,.4,abs(.5-f));  // for gentle transitions\n    f = min(f,l/l2);\n    U *= l2/l;\n    \n    float v = float(va[n%na]);\n    float pi = PI*(1. + v*1e-7);  // slight bend\n    \n    O = flip(U,pi);  // -> flipped coords\n    O = f*vec4(dot(O,vec4(0,50,-30,0)));  // weighted sum\n    \n}\n\n#endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}