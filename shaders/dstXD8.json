{
    "Shader": {
        "info": {
            "date": "1679740065",
            "description": "Based on a Schroder fractal. Click and drag.",
            "flags": 0,
            "hasliked": 0,
            "id": "dstXD8",
            "likes": 8,
            "name": "Psychedelic Schroder",
            "published": 3,
            "tags": [
                "psychedelic",
                "orbittrap",
                "schroder"
            ],
            "usePreview": 0,
            "username": "stla",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "    float PI = 3.14159265358979324;\n\n    // map function: x -> map(x, a, b, c, d) linearly sends (a,b) to (b,c)\n    float lerp(float t, float a, float b) {\n      return a + t*(b-a);\n    }\n    float norm(float t, float a, float b) {\n      return (t-a)/(b-a);\n    }\n    float map(float t, float e1, float s1, float e2, float s2) {\n      return lerp(norm(t, e1, s1), e2, s2);\n    }\n\n    // convert HSV to RGB\n    vec3 hsv2rgb(vec3 c) {\n      vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    // complex operations\n    vec2 product(vec2 a, vec2 b) {\n      return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n    }\n    vec2 divide(vec2 a, vec2 b) {\n      return vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y) / (b.x*b.x+b.y*b.y);\n    }\n    vec2 invers(vec2 b) {\n      return vec2(b.x, -b.y) / (b.x*b.x+b.y*b.y);\n    }\n\n    // trapping function\n    float trap(vec2 z, float alpha) {\n      z = product(z, exp(cos(z)));\n      z = product(vec2(cos(alpha), sin(alpha)), z);\n      float h = 1.0;\n      return min(abs(z.y + h), min(abs(z.x + h), min(abs(z.x - h), abs(z.y - h)))) / 0.3;\n    }\n\n    // trapped Schroder fractal\n    vec2 schroder(vec2 z, vec2 zc, float alpha) {\n      for(int i = 0; i < 100; i += 1) {\n        vec2 z2 = product(z, z);\n        vec2 z3 = product(z, z2);\n        vec2 z4 = product(z2, z2);\n        vec2 z6 = product(z3, z3);\n        vec2 z7 = product(z3, z4);\n        vec2 z8 = product(z4, z4);\n        vec2 fz   = z8 + 15.0*z4 - vec2(16.0, 0.0); \n        vec2 dfz  = 8.0*z7 + 60.0*z3; \n        vec2 ddfz = 56.0*z6 + 180.0*z2; \n        if(i >= 2 && (length(fz) < 20.0 || length(dfz) < 20.0 || trap(z, alpha) < 1.0)) {\n          return z;\n        }\n        z =  z - product(invers(divide(dfz, fz) - divide(ddfz,dfz)), zc);\n      }\n      return z;\n    }\n\n    // convert z to HSV\n    vec3 pair2hsv(vec2 z, float alpha) {\n      float h = (atan(z.y, z.x) + PI) / 2.0 / PI;\n      float tz = 2.0 * trap(z, alpha);\n      float s = min(1.0, tz);\n      float v = max(0.0, min(1.0, 2.0 - tz));\n      return vec3(h, s, v);\n    }\n\n    //\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n      float alpha = (1.0 + cos(0.1*iTime)) * PI;\n      float zcx = map(iMouse.x, 0.0, iResolution.x, -1.0, 1.0); \n      float zcy = map(iMouse.y, 0.0, iResolution.y, -1.0, 1.0);\n      float r = iResolution.x / iResolution.y;\n      float x = map(fragCoord.x, 0.0, iResolution.x, -4.0*r, 4.0*r); \n      float y = map(fragCoord.y, 0.0, iResolution.y, -4.0, 4.0);\n      vec2 z = schroder(vec2(x, y), vec2(zcx, zcy), alpha);\n      fragColor = vec4(hsv2rgb(pair2hsv(z, alpha)), 1.0);\n    }\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}