{
    "Shader": {
        "info": {
            "date": "1568908336",
            "description": " ",
            "flags": 32,
            "hasliked": 0,
            "id": "Wl2XzK",
            "likes": 17,
            "name": "A Monster",
            "published": 3,
            "tags": [
                "raymarching",
                "eye",
                "subsurface",
                "tentacles",
                "taa"
            ],
            "usePreview": 0,
            "username": "ikuto",
            "viewed": 740
        },
        "renderpass": [
            {
                "code": "//-----------------------------------------------------\n// post process\n//-----------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------\n// common functions\n//-----------------------------------------------------\n\n// distance functions from https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\treturn vec2(length(pa - ba*h), h);\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// calculate the view matrix\nmat3 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n \tvec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nvec2 rotate(vec2 v, float a)\n{\n    return cos(a)*v+sin(a)*vec2(-v.y,v.x);\n}\n\n#define fade(t) t*t*(3.0-2.0*t)\n\n// hash functions from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n    return fract(sin(p)*158.5453123);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 pi = floor(p); \n    vec2 pf = fract(p);\n    pf = fade(pf);\n    \n    float n = pi.x + pi.y*157.0;\n    \n    return mix(mix(hash(n+0.0), hash(n+1.0), pf.x),\n               mix(hash(n+157.0), hash(n+158.0),pf.x), pf.y);\n}\n\nfloat fbm(vec2 pos, int octaves)  \n{\n    float res = 0.0, frequency = 1.0, amplitude = 0.5;\n    for(int i = 0; i < octaves; ++i) \n    {\n        res += noise(pos * frequency) * amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n    return res;\n}\n\n// iq's penner approximattion\nvec3 sss(float ndl, float ir)\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    return vec3(pndl) + vec3(1.0,0.2,0.05)*0.250*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//-----------------------------------------------------\n// procedural modeling, lighting and animation\n//-----------------------------------------------------\n\n#define AA 1\n#define PI 3.1415926\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec3 eyeCen = vec3(0.0, 0.0, 0.0);\nvec3 lightDir = normalize(vec3(0.8, 0.8, 0.5));\n    \nstruct HitInfo\n{\n    vec3 \tpos;\n    float \tobjID;\n};\n\nstruct Material \n{\n\tvec3 \tkd;\n    float \tks;\n};\n\n// from https://www.shadertoy.com/view/4lK3Rc\nfloat sdHeart(vec3 p)\n{\n    p *= 50.0;\n\n    float r = 15.0;\n    p.y -= r;\n    p *= 1.0 - 0.2*vec3(1.0,0.5,1.0);\n    \n    p.x = abs(p.x);\n    p.y = 4.0 + p.y*1.2 - p.x*sqrt(max((20.0-p.x)/15.0,0.0));\n    p.z *= 2.0 - p.y/15.0;\n    \n    float d = length(p) - r;\n    d = d/3.0;\n    \n    return d/50.0;\n}\n\nvec2 sincos(float t) { return vec2(sin(t), cos(t)); }\n\n//return (x,y,z) = (distance, object id, mask)\nvec3 mapScene(vec3 pos)\n{   \n    float objID = 1.0;\n    vec3 p = pos - eyeCen, p2 = p;\n    float mask = 0.0;\n    \n    //eye\n    float d = length(p)-1.0, d2;\n    if (d < 0.1) //bounding volume of eye\n    {\n        p2.y = abs(p2.y)+0.15;\n\n        //blink animation\n        float t = 10.0 * iTime;\n        float h = 0.45 * (mod(t,10.0*PI) < 2.0*PI ? 0.5*cos(t)+0.5 : 1.0); \n        h = max(h-0.2*fade(clamp(abs(p2.x),0.0,1.0)), 0.0);\n        d = smax(d, -sdEllipsoid(p2-vec3(0.0, 0.0, 1.5), vec3(1.2,h,2.0)), 0.05);\n\n        //wrinkles\n        if (abs(p.x) < 0.9 && p.z > 0.0)\n        {\n            h *= 0.9;\n            float y = abs(p.y)-max(h-h*p.x*p.x, 0.0);\n            d += (0.002+0.15*h)*sin(y*50.0)*(1.0-S(0.0,0.1,abs(y)))/(2.0 + abs(10.0*p.x));\n        }\n        \n        //eyeball\n        d2 = length(p)-0.95;\n        if (d2 < d) objID = 2.0; \n        d = smin(d, d2, 0.01);\n    }\n    \n    //tentacles\n    float x1 = 1.0, x2 = 5.0;\n    p2 = p;\n    \n    float da = PI/3.0, a = atan(-p2.y, p2.x)/da;\n \tp2.xy = rotate(p2.xy, floor(0.5+a)*da);\n    \n    p2.yz += 0.4*sincos(iTime+p2.x)*S(x1,x2,p2.x);\n    vec2 res = sdSegment(p2,vec3(x1,0.0,0.0),vec3(x2,0.0,0.0));\n    d2 = max(res.x - 0.06, 0.0);\n    p2 = vec3(p2.y,-(p2.x-x2-0.4),p2.z);\n    \n    if (length(p2)<1.0) //bounding volume of heart\n    \td2 = smin(d2, sdHeart(p2), 0.05);\n    \n    if (d2 < d) objID = 1.0; \n    d = smin(d, d2, 0.1);\n    \n\tmask = res.y;\n    \n    return vec3(d, objID, mask);\n}\n\nvec3 calculateNormal(vec3 pos)\n{\n    vec3 dt = vec3(0.01, 0.0, 0.0);\n    return normalize( vec3(\tmapScene(pos+dt.xyy).x - mapScene(pos-dt.xyy).x,\n        \t\t\t\t\tmapScene(pos+dt.yxy).x - mapScene(pos-dt.yxy).x,\n        \t\t\t\t\tmapScene(pos+dt.yyx).x - mapScene(pos-dt.yyx).x ) );\n}\n\nfloat calculateOcclusion(vec3 pos, vec3 normal) \n{\n    float occ = 0.0, sca = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n   \t\tfloat h = 0.01 + 0.11*float(i)/4.0;\n        vec3 p = pos + h * normal;\n        float d = mapScene(p).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    \n    return pow(clamp(1.0-2.0*occ, 0.0, 1.0), 2.0);\n}\n\nHitInfo rayMarch(vec3 ro, vec3 rd)\n{\n    float tmin = 0.001, tmax = 20.0, t = tmin;\n    \n    HitInfo hitInfo;\n    \n\tfor (int i = 0; i < 128; ++i)\n    {\n    \tvec3 pos = ro + t * rd;\n        vec3 res = mapScene(pos);\n        \n        float dist = res.x;\n        float objID = res.y;\n        if (abs(dist) < 0.001)  { hitInfo = HitInfo(pos, objID); break; }\n        \n        t += dist*0.8;\n        if (t > tmax) { hitInfo.objID = -1.0; break; }\n    }\n    \n    return hitInfo;\n}\n\nvec3 getEyeColor(vec3 pos, vec3 nor)\n{\n    float an = sin(0.1*PI*iTime);\n    vec3  pe = pos-eyeCen;\n    vec3  pi = pe - vec3(0.3*clamp(sin(an),-0.4,0.4),0.0,0.0);\n    vec3  pp = pe - vec3(0.38*clamp(sin(an),-0.4,0.4),0.0,0.0);\n\n    //sclera color\n    float d = length(pe.xy);\n    vec3 col = mix(vec3(0.9), vec3(0.5, 0.2, 0.2), S(0.1, 1.0, d));\n\n    //iris color\n    float d2 = length(pi.xy);\n    vec3 irisCol = vec3(0.2, 0.02, 0.1)*(1.0 - 0.8*d2 / 0.4);\n    irisCol *= clamp(1.0 - 5.0*pi.y, 0.05, 5.0);\n    float a = atan(pi.y, -pi.x);\n    float noise = fbm(20.0*vec2(0.34*a, 0.3*d2), 4);\n    irisCol *= 0.2 + 4.0*noise;\n\n    col = mix(col, irisCol, 1.0 - S(0.35, 0.375, d2));\n\n    //pupil color\n    float d3 = length(pp.xy);\n    col = mix(col, vec3(0.02), 1.0 - S(0.11, 0.16, d3));\n\n    //highlights (fake)\n    float t = 0.8 + 0.2*pow(min(5.0*abs(d2 - 0.22), 1.0), 0.1);\n    col = mix(vec3(2.0, 0.4, 1.6), col, t);\n\n    t = (1.0 - S(0.0, 2.0, abs(a + 1.0)))*(1.0 - S(0.0, 0.14, abs(d3 - 0.25)));\n    col += 0.9*vec3(1.0, 0.6, 0.8)*(0.5 + noise)*t;\n\n    t = pow(1.0 - S(0.0, 0.1, length(pi.xy - vec2(-0.18, 0.18)) - 0.05), 4.0);\n    col = mix(col, 4.0*vec3(1.0, 0.5, 0.5), 0.1*t);\n    \n    //shadows (fake)\n    col *= 1.0 - vec3(0.5) * S(-0.1, 0.1, pi.y - 0.15*(1.0 - pe.x*pe.x));\n    col = pow(col, vec3(mix(2.5, 1.0, max(dot(lightDir, nor), 0.0))));\n\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n  \tvec3 col = vec3(0.0);\n    \n    HitInfo hitInfo = rayMarch(ro, rd);\n    if (hitInfo.objID > 0.0) \n    {\n        vec3 pos = hitInfo.pos;\n        vec3 nor = calculateNormal(pos);\n        float mask = mapScene(pos).z;\n        \n        Material mat;\n        if (hitInfo.objID < 1.5) //body\n        {\n\t\t\tvec3 col = vec3(1.0, 0.05, 0.1);\n            col = mix(col, vec3(1.0, 1.0, 0.0), pow(mask, 4.0));\n\t\t\tmat = Material(col.rgb, 0.2);\n        }\n        else if (hitInfo.objID < 2.5) //eye\n        {\n            mat = Material(getEyeColor(pos, nor), 0.6);\n        }\n\n        float occ = calculateOcclusion(pos, nor);\n        float ndotl = dot(nor, lightDir);\n    \tfloat pdotl = dot(normalize(pos-eyeCen), lightDir);    \n        vec3  diff = mix(sss(ndotl, 2.0), sss(pdotl, 2.0), 0.9);\n        float spec = pow(max(0.0, dot(rd,reflect(lightDir,nor))), 32.0);\n\n        vec3 lcol = vec3(1.0, 0.5, 1.0); //light color\n        col = lcol * mat.kd * diff * occ;\n        col += lcol * mat.ks * spec * occ;\n    }\n   \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float an = (iMouse.z>0.0) ? 5.0*(iMouse.x/iResolution.x-0.5) : 0.0;\n    vec3 rayOri = 7.0 * vec3(sin(an), 0.0, cos(an));\n    mat3 viewMat = lookAt(rayOri, vec3(0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < AA; ++i) //super sampling\n    {\n        for (int k = 0; k < AA; ++k)\n        {\n        \tvec2 offset = vec2(float(i)+0.5, float(k)+0.5) / float(AA) - 0.5;\n            offset += hash21(iTime)-0.5; //jittering\n       \t\tvec2 p = (2.0*(fragCoord+offset)-iResolution.xy) / iResolution.y;\n            \n            vec3 rayDir = normalize(vec3(p, -2.0));\n            rayDir = viewMat * rayDir;\n            col += render(rayOri, rayDir);\n        }\n    }\n    \n\tcol /= float(AA*AA);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//-----------------------------------------------------\n// temporal anti aliasing\n//-----------------------------------------------------\n\nvec3 rgb2ycocg(vec3 col)\n{\n\tfloat Y  = dot(col, vec3(1, 2, 1));\n\tfloat Co = dot(col, vec3(2, 0, -2));\n\tfloat Cg = dot(col, vec3(-1, 2, -1));\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 ycocg2rgb(vec3 col)\n{\n\tfloat Y  = col.x * 0.25;\n\tfloat Co = col.y * 0.25;\n\tfloat Cg = col.z * 0.25;\n\tfloat R = Y + Co - Cg;\n\tfloat G = Y + Cg;\n\tfloat B = Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid historyClamping(inout vec3 color, in vec2 fragCoord)\n{\n\tvec3 average = vec3(0.0), variance = vec3(0.0);\n    \n  \tfor (int y = -1; y <= 1; ++y) \n    {\n    \tfor (int x = -1; x <= 1; ++x) \n        {\n     \t\tivec2 texCoord = ivec2(fragCoord.xy) + ivec2(x, y);\n      \t\tvec3 color = rgb2ycocg(texelFetch(iChannel0, texCoord, 0).rgb);\n\t\t\taverage += color;\n            variance += color*color;\n    \t}\n  \t}\n    \n\taverage /= 9.0;\n\tvariance /= 9.0;\n\tvec3 stdDev = sqrt(abs(variance-average*average));\n\tvec3 neighborMin = average - 1.25 * stdDev;\n\tvec3 neighborMax = average + 1.25 * stdDev;\n    \n    color = clamp(color, neighborMin, neighborMax);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;    \n    vec3 currentColor = rgb2ycocg(texture(iChannel0, uv).rgb);\n    vec3 historyColor = rgb2ycocg(texture(iChannel1, uv).rgb);\n \n  \thistoryClamping(historyColor, fragCoord);\n  \n    float f = iFrame>0 ? 0.05 : 1.0;\n\tfragColor = vec4(ycocg2rgb(mix(historyColor, currentColor, f)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}