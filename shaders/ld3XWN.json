{
    "Shader": {
        "info": {
            "date": "1459460722",
            "description": "A Fitzhugh-Nagumo reaction-diffusion system coupled to a 2-chemical system (in red and blue) competing for space. Paint in red and blue using mouse controls to mark territory.",
            "flags": 32,
            "hasliked": 0,
            "id": "ld3XWN",
            "likes": 42,
            "name": "Competitive Reaction-Diffusion",
            "published": 3,
            "tags": [
                "diffusion",
                "reaction",
                "fitzhugh",
                "nagumo",
                "competitive"
            ],
            "usePreview": 0,
            "username": "cornusammonis",
            "viewed": 1953
        },
        "renderpass": [
            {
                "code": "/*\n\tThe reaction-diffusion system is visualized with a slightly modified version of \n    Shane's Bumped Sinusoidal Warp shadertoy here:\n\n\thttps://www.shadertoy.com/view/4l2XWK\n    \n\tThe x channel of Buffer A, containing the reaction-diffusion system components,\n    is used for the bump mapping function, and the x and y channels of Buffer B are used\n    to color territory in red and blue.\n*/\n\n\n// Bump mapping function.\nfloat bumpFunc(vec2 p){ \n    return 0.5 * (texture(iChannel0, p).x + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\t//vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv - 1.0, 1.)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime/2.0)*0.5, sin(iTime/2.0)*0.5, -1.); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n\n    vec2 eps = 2.0 / iResolution.xy;\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-vec2(eps.x, 0.0)); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-vec2(0.0, eps.y)); // Same for the nearby sample in the Y-direction.\n   \n \t// Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.02;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.y; // Change in Y.\n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = min(1./(0.25 + lDist*0.5 + lDist*lDist*0.05), 1.);\n    \n    atten *= f*f*.5 + .5; \n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n    \n    vec2 rb = texture(iChannel1, uv).xy;\n    vec3 texCol = vec3(rb.x, 0.0, rb.y);\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol * (diff*vec3(1, .97, .92)*1.3 + 0.5) + vec3(1., 0.6, .2)*spec*1.3)*atten;\n\n    // Done. \n\tfragColor = vec4(min(col, 1.), 1.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\tA Fitzhugh-Nagumo reaction-diffusion system. \n\tSee this paper for additional information: \n\t\t\n\thttp://arxiv.org/pdf/patt-sol/9401002.pdf\n\n\tA large timestep is used to make the system evolve at an interactive rate when limited to 60 FPS.\n    The system is unstable using a large timestep with simple Euler integration, so instead it is \n    updated with an exponentially-weighted moving average of the gradient (with time constant tc).\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0; // edge-neighbors\n    const float _K2 = 1.0/6.0; // vertex-neighbors\n    const float timestep = 0.7;\n    const float a0 = -0.1;\n    const float a1 = 2.0;\n    const float epsilon = 0.05;\n    const float delta = 4.0;\n    const float k1 = 1.0;\n    const float k2 = 0.0;\n    const float k3 = 1.0;\n    const float tc = 0.8;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, vUv);\n    vec4 uv_n =  texture(iChannel0, vUv+n);\n    vec4 uv_e =  texture(iChannel0, vUv+e);\n    vec4 uv_s =  texture(iChannel0, vUv+s);\n    vec4 uv_w =  texture(iChannel0, vUv+w);\n    vec4 uv_nw = texture(iChannel0, vUv+nw);\n    vec4 uv_sw = texture(iChannel0, vUv+sw);\n    vec4 uv_ne = texture(iChannel0, vUv+ne);\n    vec4 uv_se = texture(iChannel0, vUv+se);\n    \n    vec4 rb =    texture(iChannel2, vUv);\n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_s) + _K1*(uv_e + uv_w) + _K2*(uv_nw + uv_se) + _K2*(uv_sw + uv_ne);\n\n    float a = uv.x;\n    float b = uv.y;\n    float c = uv.z;\n    float d = uv.w;\n    \n    float d_a = k1*a - k2*a*a - a*a*a - b + lapl.x - 10.0 * max(0.0, a) * rb.x*rb.y;\n    float d_b = epsilon*(k3*a - a1*b - a0) + delta*lapl.y;\n\tc = tc * c + (1.0 - tc) * d_a;\n\td = tc * d + (1.0 - tc) * d_b;\n\n    a = a + timestep * c;\n    b = b + timestep * d;\n    \n    if (iMouse.z > 0.0) {\n    \tfloat mLen = length(iMouse.xy - fragCoord.xy);\n    \ta += exp(-mLen * mLen / 1000.0);\n    }\n    \n    // initialize\n    if(iFrame<10) {\n        float mLen = length(iResolution.xy / 2.0 - fragCoord.xy);\n    \ta += exp(-mLen * mLen / 4000.0);\n    }\n    \n    fragColor = clamp(vec4(a, b, c, d), -1., 1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0; // edge-neighbors\n    const float _K2 = 1.0/6.0; // vertex-neighbors\n    const float timestep = 0.01;\n    const float death = 0.1;\n    const float birth = 3.5;\n\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, vUv);\n    vec4 uv_n =  texture(iChannel0, vUv+n);\n    vec4 uv_e =  texture(iChannel0, vUv+e);\n    vec4 uv_s =  texture(iChannel0, vUv+s);\n    vec4 uv_w =  texture(iChannel0, vUv+w);\n    vec4 uv_nw = texture(iChannel0, vUv+nw);\n    vec4 uv_sw = texture(iChannel0, vUv+sw);\n    vec4 uv_ne = texture(iChannel0, vUv+ne);\n    vec4 uv_se = texture(iChannel0, vUv+se);\n    \n    vec4 fn =    texture(iChannel1, vUv);\n    \n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_s) + _K1*(uv_e + uv_w) + _K2*(uv_nw + uv_se) + _K2*(uv_sw + uv_ne);\n\n    float a = uv.x;\n    float b = uv.y;\n     \n    // red\n    a = a + timestep * (birth * a * max(0.0, fn.x) + 32.0 * lapl.x - death * b);\n    \n    // blue\n    b = b + timestep * (birth * b * max(0.0, fn.x) + 32.0 * lapl.y - death * a);\n    \n    if (iMouse.z > 0.0) {\n    \tfloat mLen = length(iMouse.xy - fragCoord.xy);\n        float rbw = sign(iMouse.x - fragCoord.x);\n    \tfloat wt = exp(-mLen * mLen / 1000.0);\n        a += -rbw * wt;\n        b += rbw * wt;\n    }\n    \n        // initialize\n    if(iFrame<10) {\n    \tfloat mLen = length(iResolution.xy / 2.0 - fragCoord.xy);\n        float rbw = sign(iResolution.x / 2.0 - fragCoord.x);\n    \tfloat wt = exp(-mLen * mLen / 4000.0);\n        a += -rbw * wt;\n        b += rbw * wt;\n    }\n    \n    fragColor = clamp(vec4(a, b, 0.0, 0.0), 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}