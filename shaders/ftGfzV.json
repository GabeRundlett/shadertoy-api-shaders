{
    "Shader": {
        "info": {
            "date": "1664819195",
            "description": "Experiment with Transparent / Solid materials - just goofing around",
            "flags": 0,
            "hasliked": 0,
            "id": "ftGfzV",
            "likes": 19,
            "name": "Ghost Head",
            "published": 3,
            "tags": [
                "crystallo"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 316
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    10/03/22 @byt3_m3chanic\n    Experiment with Transparent / Solid materials - just goofing around. And a good ole\n    isometric camera - makes it all pretty!\n    \n    Thanks to @blackle, @iq and @Drakyen\n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 2\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp(.5+.5*(d2-d1)/k, .0, 1. );\n    return mix( d2, d1, h ) - k*h*(1.-h);\n}\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\n  return length(q)-t.y;\n}\nfloat vcap( vec3 p, float h, float r ){\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\nfloat cap( vec3 p, float r,float h ){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat time;\nmat2 rx,ry,turn,r25;\nvec3 hit,hitpoint;\n\nfloat ghost(vec3 p, float hs) {\n    float res = 1e5;\n    vec3 q = p-vec3(0,-1.25,0);\n    \n    vec3 q2=q-vec3(0,1.5,.25);\n    vec3 q3=vec3(abs(q.x),q.yz)-vec3(.5,2.72,1.25);\n    vec3 q4 = q-vec3(0,2.72,1.65);\n    q4.x=abs(q4.x);q4.xz*=r25;\n    \n    float ghst = vcap(q,2.75,1.6);\n    float eyes = length(q3)-.45;\n    float lids = torus(q4-vec3(.6,0,0),vec2(.4,.09));\n    float chst = vcap(q,2.7,1.25);\n\n    float a = atan(q.z,q.x);\n    float tw = .2*sin(a*6.);\n    tw *=pow(length(q.xz),1.);\n    \n    float cuting = cap(q+vec3(0,1.,0),1.-tw,1.65)*.75;\n    \n    ghst = max(ghst,-cuting);\n    ghst = max(ghst,-eyes);\n    ghst = smin(lids,ghst,.08);\n    ghst = max(ghst,-chst);\n    \n    if(ghst<res ) {\n        res = ghst;\n    }\n\n    return res;\n}\n\nvec2 map (in vec3 p) { \n    vec2 res = vec2(MAX_DIST,0.);\n    vec3 q = p;\n\n\n    float tt = .35+.35*sin(time*1.05)+cos(.5*cos(time*.3)*5.);\n    float pt = 2.5*sin(time*1.4);\n    \n    p.y+=.5+pt;\n    p.xz*=turn;\n    \n    p.xz=abs(p.xz)-3.35;\n\n    vec2 np = p.xz;\n    float lt = length(np*PI);\n    float amp = (1./lt);\n    amp=clamp(amp,0.,.2);\n    \n    float wb = amp*sin(lt-time*PI2);\n    q.y-= (wb);\n    float be =  q.y+2.5;\n    p.yz*=rot(tt*PI*.75);\n    p.xz*=rot(tt*PI);\n    \n    float me =  ghost(p-vec3(0,.15,0),2.);\n\n    me=smin(me,be,1.3);\n    if(me<res.x) {\n        res = vec2(me,1.);\n        hit=q;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 hue(float t){ \n    vec3 d = vec3(.173,.471,.788);\n    return .675 + .425*cos(PI2*(vec3(1.25,1,.75)*t+d)); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, in vec2 F) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(2.,5,-2);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),.075,1.);\n\n    vec3 th=vec3(.1);\n\n    float dd = clamp((hitpoint.z+3.)*.1,0.,1.);\n\n    vec3 r = fract(hitpoint*.25)-.5;\n    vec3 f = fract(hitpoint*.75)-.5;\n    \n    vec3 clr = mix(vec3(.31,.13,.01),vec3(0.188,0.012,0.310),dd);\n    vec3 clx = mix(vec3(0.361,0.439,0.459),vec3(0.188,0.012,0.310),dd);\n    th = (r.x*r.z>0.)? clr:clx;\n    th = (f.x*f.z>0.)? vec3(.02):th;\n\n    vec3 h = vec3(.1);\n    h = mix(vec3(.09,.19,.19),th,clamp(1./d,0.,1.));\n\n    return h*diff;\n}\n\nvec3 render( in vec2 uv, in vec2 F )\n{\n\n    time = T;\n    turn=rot(T*10.*PI/180.);\n    vec3 C=vec3(.0);\n    r25=rot(-.35);\n    \n    float zoom = 10.;\n    \n    vec3 ro = vec3(uv*zoom,-(zoom+15.));\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * .5 - .25) * PI;\n    \n    rx = rot(-.58);\n    ry = rot(.78+y);\n\n    ro.yz*=rx;ro.xz*=ry;\n    rd.yz*=rx;rd.xz*=ry;\n\n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    \n    // b = light bounces 8 is good 5 is liveable.\n    float k = 1.,b = 5.;\n    float iv = 1.;\n    // loop inspired/adapted from @blackle \n    // https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n \n        vec3 n=vec3(0);\n        float d = ray.x*.8;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-8) {\n            hitpoint=hit;\n          \n            C=mix(C,shade(p,rd,d,ray.y,n,F),atten);\n            \n            b--;\n            if(b<0.||m==4.)break;\n            \n            atten *=.85;\n            p += rd*.05;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv > 0. ? .875 : 1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.005;\n        }\n      \n        if(distance(p,rd)>25.) { break; }\n    }\n\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = fract(T);\n    turn=rot(time*10.*PI/180.);\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n\n        vec3 color = render(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.0);\n}\n//end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}