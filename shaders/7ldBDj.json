{
    "Shader": {
        "info": {
            "date": "1663895497",
            "description": "Put your red/cyan-glasses on and drag mouse for cam rotation.",
            "flags": 0,
            "hasliked": 0,
            "id": "7ldBDj",
            "likes": 27,
            "name": "Anaglyph XOR-City",
            "published": 3,
            "tags": [
                "anaglyph",
                "xor",
                "city",
                "desert"
            ],
            "usePreview": 0,
            "username": "derSchamane",
            "viewed": 485
        },
        "renderpass": [
            {
                "code": "//                    = Anaglyph XOR-City =         \n//                by Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 140\n#define STEP_FAC 0.13\n#define MAX_DIST 200.\n#define MIN_DIST 5.\n\n#define SURF_DIST .0001\n#define SURF_MUL 10000.\n#define SURF_EXP 1.2\n\n#define GLOW_INT 0.8\n#define PP_CONT 1.2\n#define PP_VIGN 2.0\n\n#define EYE_DIS 0.4\n#define FIL_COR 1.1\n\n\n#define XOR_SEED 10000\n\n\n#define iTime iTime*1.\n#define pi 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat SdBox(vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)),0.) + length(max(d, 0.));\n}\n\nfloat SdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 Dist(vec3 p) \n{   \n\n    float col;\n    \n    //cam movement\n    float cmt = pi / 160.; \n    float pos = pow(cos(iTime*cmt), 3.) * 800.;\n    float x = (p.x + mix(pos, -pos, step(0., cos(iTime*cmt*.5-pi*.25))));\n    float y = (p.z + mix(0., pos, step(0., cos(iTime*cmt))));\n    \n    int r = int(x+y)^(int(x-y)); //XOR \n    float d = float(abs((r*r*r)/int(x+y)) % (XOR_SEED)) / float(XOR_SEED)*1.0; //small buildings\n    \n    float w = S(-0.1, 1., sin(((x+sin(y/4.)-cos(y/8.))*6.)*1.)*0.03 + //small sand waves\n                dot(sin(vec2(x+10., y)/16.), cos(vec2(x, y+10.)/21.)))*0.5; //displacement\n                \n    w = sin((x+y)/50.)*dot(sin(vec2(x+100., y)/42.), cos(vec2(x, y+100.)/64.))*8. - w; //sand hills\n    float dis = sqrt(x*x + y*y);\n    w *= S(50.,100., dis);\n    \n    col = d > w ? .6 : -0.2; //material\n    d = max(w, d);\n    d = (p.y - d); //heightmap\n\n    //ancient temple buildings\n    float size = 21.6;\n    float th = 0.5 + S(20., 50., dis)*3. - S(400., 1000., dis)*3.4;\n    p.xz = vec2(x,y)/1.24;\n    p.xz *= Rot(pi*(.5 - S(10., 20., dis) * .25));\n    p.xz = mod(abs(-mod(p.xz + vec2(0,.5), 4.*size) + 2.*size), 4.*size);\n    p.yx *= Rot(.02 * step(500., dis));\n    float c = SdBox(p - vec3(1,0,1)*(1.-pow(S(0., 800., dis), 0.6)) * 42.2,\n        vec3(th, 1.2 + (pow(S(700., 50., dis), 5.)+step(850., dis)) * 7. + step(-50., -dis)*100., th));    \n        \n    col = d > c ? mix(-.2+S(.9, 1., sin(iTime*3.-sqrt(p.y/3.)))*0.5, .55, step(20., dis)) : col;\n    d = min(c, d);\n    \n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.001, 0.);\n    return normalize(Dist(p).x - vec3(Dist(p-e.xyy).x, Dist(p-e.yxy).x,Dist(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Dist(p);\n        col = dS.y;\n        \n        float dis = pow(dO/MAX_DIST, SURF_EXP);\n        dO += dS.x * mix(STEP_FAC, 0.8, min(1., dis + S(1.2, 3., p.y)));//dS.x * mix(STEP_FAC, 1., dis);//min(dS.x * STEP_FAC, max(1. + p.y - XORMap(p.xz, 5.)*10., SURF_DIST));\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (dis*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n\n        float h = Dist(ro + rd*dist).x;\n        shade = min(shade, S(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\nfloat GetLight(vec3 p, vec3 n, vec3 lP, vec3 rd , float shine) \n{\n\n    vec3 l = normalize(lP - p);\n    float dif = S(-0., 1., dot(n, l)*.5+.5) * max(1.-max(-shine, 0.), 0.);\n    if (shine > 0.) dif = mix(dif, dif*.1 + pow(max(dot(l, reflect(rd, n)), 0.), shine*20.), shine);\n    return dif;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) //BigWings\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.3,.7);\n\n    float offset = S(15., 0., iTime) * 20.;\n    vec3 ro = vec3(0., 10. + offset, -50. + m.y*30. - offset*2.);\n    ro.yz *= Rot((1.0-m.y) * .2*pi);\n    ro.xz *= Rot(-m.x * 2.*pi);\n    vec3 rd = R(uv, ro, vec3(0., 10., 0.), 0.9);\n    ro += cross(rd, vec3(0., -1., 0.)) * EYE_DIS * -.5;\n    \n    vec3 n, lPos = vec3(3,1.3,-1)*1000.;\n    lPos.xz *= Rot(2.*pi*iTime/300.);\n    float bg = pow(S(-1., 1., dot(rd, normalize(lPos))), 2.5)*.5+.4;\n    \n    //left eye\n    float colL = bg;\n    vec3 p1 = vec3(0.);\n    vec3 rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p1 = ro + rd * rmd.x;\n        n = Normal(p1);\n        \n        colL = GetLight(p1, n, lPos, rd, rmd.z);\n        colL *= SoftShadow(p1 + n*.015, lPos, 1.5);\n        colL += rmd.y / float(MAX_STEPS) * GLOW_INT;\n        colL = mix(colL, bg, rmd.x / MAX_DIST);\n    }\n    \n    //eye distance\n    ro += cross(rd, vec3(0., -1., 0.)) * EYE_DIS;\n    \n    //right eye\n    float colR = bg;\n    vec3 p2 = vec3(0.);\n    rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p2 = ro + rd * rmd.x;\n        n = Normal(p2);\n        \n        colR = GetLight(p2, n, lPos, rd, rmd.z);\n        colR *= SoftShadow(p2 + n*.015, lPos, 1.5);\n        colR += rmd.y / float(MAX_STEPS) * GLOW_INT;\n        colR = mix(colR, bg, rmd.x / MAX_DIST);\n    }\n    \n    //filter correction\n    colL *= FIL_COR; \n    colR /= FIL_COR;\n    \n    //contrast\n    vec3 colS = mix(vec3(colL, colR, colR), S(vec3(0.), vec3(1.), vec3(colL, colR, colR)), PP_CONT);\n    \n    //ACES color\n    //colS =  clamp((colS * (2.51f * colS + 0.03f)) / (colS * (2.43f * colS + 0.59f) + 0.14f), 0.0f, 1.0f);\n    \n    //gamma correction\n    colS = pow(colS, GAMMA);\n    \n    //Vignette\n    colS *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    \n    fragColor = vec4(colS,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}