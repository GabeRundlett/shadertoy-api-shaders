{
    "Shader": {
        "info": {
            "date": "1636039144",
            "description": "A gear meshing with two linear gears. We use CSG to construct a gear, and then subtract infinitely many copies of that gear from a cylinder to get the rack: to do this we construct a small number of copies of the gear and then use gradient descent.",
            "flags": 0,
            "hasliked": 0,
            "id": "ft33W8",
            "likes": 2,
            "name": "Rack and pinion",
            "published": 3,
            "tags": [
                "raymarching",
                "gear",
                "rackandpinion"
            ],
            "usePreview": 0,
            "username": "mlaang",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "//Parameters: x, vector from which the distance is calculated\n//\t      r, sphere radius\n//\t      c, sphere center vector\n//Return value: signed distance to sphere surface\nfloat distance_to_sphere(vec3 x, float r, vec3 c) {\n    return length(x-c)-r;\n}\n\nfloat softmin(float x, float y) {\n    float K=8.0;\n    return -log(exp(-K*x) + exp(-K*y))/K;\n}\n\nconst float pi = 3.14159265;\n\n//Parameters: x, vector to be rotated,\n//\t      axis, axis around which it is to be rotated\n//\t      angle, rotation angle\n//Return value: rotated vector\nvec3 rotate(vec3 x, vec3 axis, float angle) {\n   return x*cos(angle) + cross(axis, x)*sin(angle) + axis*(1.-cos(angle))*dot(axis, x);\n}\n\n//Parameters: x, spatial position\n//Return value: signed distance from x to a 3D object representing a stylized gear shape\nfloat distance_to_gear(vec3 x) {\n    //d1 is the distance to a central sphere\n\n    float d1 = distance_to_sphere(x, 0.5, vec3(0.0, 0.0, 0.0));\n    \n    //d2 will after the loop be the distance to the union of little spheres that act as cogs\n    \n    const float n=7.0;\n    \n    float d2 = 10000000.0;\n    for(float i=0.0; i < n; i = i + 1.0) {\n        float d = distance_to_sphere(x, 0.1, vec3(0.6*cos(2.0*pi/n*i), 0.6*sin(2.0*pi/n*i), 0.0));\n        if(d < d2)\n            d2 = d;\n            \n        d = distance_to_sphere(x, 0.05, vec3(0.7*cos(2.0*pi/n*i), 0.7*sin(2.0*pi/n*i), 0.0));\n        if(d < d2)\n            d2 = d;\n    }\n\n    return softmin(d1,d2);\n}\n\n//Parameters: x, spatial position\n//            y, sign representing the direction of the translatory motion\n//Return value: signed distance to the shape swept out by the shape to which distance_to_gear defines the distance to under rotation and translation.\nfloat distance_to_reciprocal_gear(vec3 x, float s) {\n    x.x = mod(x.x, 2.0*pi/7.0); //Use translation symmetry\n\n    float relevant_angle,\n          d = 1000000.0;\n     for(float i=0.0; i <= 2.0*pi/7.0; i += 0.2) {\n        float temp = distance_to_gear(rotate(x+s*vec3(i, 0.0, 0.0), vec3(0,0,1), i));\n        if(temp < d) {\n            d = temp;\n            relevant_angle = i;\n        }\n    }\n    \n    for(int i = 0; i != 2; ++i) {\n        const float epsilon = 0.001;\n        float grad = distance_to_gear(rotate(x + vec3(s*(relevant_angle + epsilon), 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle + epsilon));\n        grad = grad - distance_to_gear(rotate(x + vec3(s*relevant_angle, 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle));\n        grad = grad/epsilon;\n        \n        relevant_angle = relevant_angle - 0.8*grad;\n    }\n    \n    d = distance_to_gear(rotate(x+s*vec3(relevant_angle, 0.0, 0.0), vec3(0.0, 0.0, 1.0), relevant_angle));  \n    \n    return d;\n}\n\n//Parameters: x, spatial position\n//Return value: Signed distance from x to a particular cylinder\nfloat cyl(vec3 x) {\n    return length(x.yz) - 0.25;\n}\n\n//Signed distance to the xy plane with normal pointing in the -z direction\nfloat distance_beyond_xy_plane(vec3 x) {\n    return -x.z;\n}\n\n//Parameters: x, spatial position\n//Return value: Signed distnace to a complete scene\n//\n// This scene has several characteristics:\n// One thing shown in it is the gear,the distance to which is d\n// We construct a rack which meshes with the gear in one rotation direction\n// the distance to which is d2\n// and we construct another rack which meshes with the gear in another rotation direction\n// the distance to which is d5\n// The intersections of these racks with two cylinders from which the front half has been\n// subtracted using the 'distance_beyond_xy_plane' function.\nfloat distance_to_scene(vec3 x) {\n    float d = distance_to_gear(rotate(x, vec3(0.0, 0.0, 1.0), iTime));\n    \n    float d2 = distance_to_reciprocal_gear(x-vec3(mod(iTime, 2.0*pi),0.0,0.0), 1.0);\n    float d3 = cyl(x-vec3(0.0, 0.5, 0.0));\n    float d4 = distance_beyond_xy_plane(x);\n    \n    float d5 = distance_to_reciprocal_gear(x+vec3(mod(iTime, 2.0*pi),0.0,0.0), -1.0);\n    float d6 = cyl(x-vec3(0.0, -0.5, 0.0));\n    \n    return min(min(max(max(d3, -d2), d4), d), max(max(d6, -d5), d4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1.0 to 1.0) \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Camera: ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 camera_direction = vec3(0.0, 0.0, 0.0) - ro;\n    vec3 rd = vec3(uv.xy, 0.0)-ro;\n    rd = normalize(rd);\n    \n    //Walk along the ray to get to the scene surface\n    \n    vec3 current_position;\n    current_position = ro;\n    for(int i = 0; i != 15; ++i)\n        current_position = current_position + rd*distance_to_scene(current_position);\n        \n    //Is there a hit?\n    \n    const float epsilon = 0.005;\n    \n    float col;\n    \n    if(distance_to_scene(current_position) < epsilon) {\n        float d = distance_to_scene(current_position);\n        float d_plusx = distance_to_scene(current_position + epsilon*vec3(1.0,0.0,0.0));\n        float d_plusy = distance_to_scene(current_position + epsilon*vec3(0.0,1.0,0.0));\n        float d_plusz = distance_to_scene(current_position + epsilon*vec3(0.0,0.0,1.0));\n        \n        vec3 grad = vec3(d_plusx - d, d_plusy - d, d_plusz - d);\n        grad = grad/epsilon;\n        \n        //Grad is now an outward pointing normal\n        //We could do raytracing, but we're instead just going to color the scene\n        //by the normal\n        \n        //Specifically, the color will be the cosine of the angle with a couple of fixed vectors\n        //as is traditional\n        \n        vec3 v = vec3(1.0, 1.0, 1.0);\n        \n        float agreement = dot(v, grad)/(length(grad) * length(v));\n        col = 0.00 + 0.5*max(agreement, 0.);\n        \n        //Now, to brighten things up we do a reflection\n        \n        vec3 normal = normalize(grad);\n        \n        vec3 rd_along_normal = dot(rd, normal)*normal;\n        vec3 rd_orthogonal_to_normal = rd - rd_along_normal;\n        \n        //Make flipped vector\n        ro = current_position;\n        rd = -rd_along_normal + rd_orthogonal_to_normal;\n        \n        //Now do the marching again\n        \n        current_position = ro;\n        for(int i = 0; i != 10; ++i)\n               current_position = current_position + rd*distance_to_scene(current_position);\n               \n        //and what's the normal there again?\n        \n        d = distance_to_scene(current_position);\n        d_plusx = distance_to_scene(current_position + epsilon*vec3(1.0,0.0,0.0));\n        d_plusy = distance_to_scene(current_position + epsilon*vec3(0.0,1.0,0.0));\n        d_plusz = distance_to_scene(current_position + epsilon*vec3(0.0,0.0,1.0));\n        \n        grad = vec3(d_plusx - d, d_plusy - d, d_plusz - d);\n        grad = grad/epsilon;\n        \n        //get the color there and add it multiplied by something like 0.9 (or, well, it seems I picked 1.0)\n        \n        agreement = dot(v, grad)/(length(grad) * length(v));\n        col = col + max(agreement, 0.0);\n        \n    } else col = 0.0;\n        \n    fragColor = vec4(col, col, col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}