{
    "Shader": {
        "info": {
            "date": "1696572428",
            "description": "Companion shader to this one, where this function is used:\n\nStarlight Mint Cascade https://shadertoy.com/view/csVyWw#\n\nI built this shader first just to test the motion blur function, but I figured it might be a good technical reference in itself.",
            "flags": 0,
            "hasliked": 0,
            "id": "msGyzK",
            "likes": 14,
            "name": "Analytic Radial Motion Blur",
            "published": 3,
            "tags": [
                "blur",
                "radial",
                "motion",
                "analytic"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Companion shader to this one, where this function is used:\n//\n//    Starlight Mint Cascade         https://shadertoy.com/view/csVyWw#\n//\n//  I built this shader first just to test the motion blur function, but I figured it\n//  might be a good technical reference in itself. Is radial even the right term for\n//  this kind of blur? Googling, it seems that a radial blur can mean either this kind\n//  or a \"zoom\" blur. Anyway, what I mean by the title is the kind of motion blur you\n//  would need to render a rapidly spinning object with a stripe on it.\n//\n//  On the top is the analytic blur, while the multisample blur is on the bottom. On the\n//  right, the result is applied to an actual circle. On the left you can see the same\n//  function unrolled linearly. There are graph plots at the top and bottom, and a render\n//  in the middle.\n//\n//  It might be easier to see what's going on by taking control with the mouse. With the\n//  mouse clicked all the way to the left, the blur amount is zero, showing the clear\n//  signal. Mouse Y can control the width of the signal. Increasing mouse X increases\n//  the blur amount.\n//\n//  You are encouraged to experiment with SAMPLES. A much higher value serves as ground\n//  truth: I hope/believe that the top and bottom matching in that test is proof that the\n//  results are correct. A lower value cause the artifacts to be more easily visible in the\n//  multisampled result. I chose a middle value for demo purposes to try to show general\n//  correctness while still demonstrating some artifacts at high blur values. The multi\n//  sample artifacts are most visible in the graph view as little bumps, but they can\n//  be seen as stripes, especially when the circle is nearly full or empty.\n//\n//  The key observation that this runs on is that a perfect analytic blur of a square\n//  signal can be built by adding two ramp functions. And then to make it work correctly,\n//  you have to realize that for a radial blur, the ramp functions can wrap multiple times\n//  around the circle. I solve that here by just adding up all the ramps...is there a more\n//  efficient method? It clearly gets better results with fewer samples than basic multi\n//  sampling, anyway. You only need as many iterations as your blur \"wraps around\" which is\n//  probably not more than a handful of times before the circle becomes a uniform color.\n//\n//  I found a few things about this to be counterintuitive. First, as the blur amount\n//  gets pretty large, there develops a large \"flat\" area with no gradient. A uniform\n//  pink color, in between red and white. But actually this makes logical sense, because\n//  if we have a perfect camera, our sweeping signal will pass by all of those pixels\n//  exactly the same duration of time for each pixel, just offset in phase depending\n//  on the angle.\n//\n//  Second, it surprises me that as the blur increases further, there's a period of time\n//  when the circle *opposite* the signal is reddest. But, I guess that's correct if it\n//  matches our \"ground truth\" test. And going back to our perfect camera, all the other\n//  pixels will see the signal once, but some of those opposite pixels will see the signal\n//  *twice*.\n// ---------------------------------------------------------------------------------------\n\n#define R iResolution.xy\nconst float PI = 3.141592543589793;\nconst int SAMPLES = 30; // number of samples (x2) in oversampling\n\n// the actual signal\nfloat f(float x, float a, float b)\n{\n    x = fract(x);\n    if (x < a) return 0.;\n    if (x < b) return 1.;\n    return 0.;\n}\n\n// multisample motion blur on the signal\n// t - value being rendered\n// a - signal begin\n// b - signal end\n// m - blur amount\nfloat motionBlurMs(float t, float a, float b, float m)\n{\n    float x;\n    for (int i = -SAMPLES; i <= SAMPLES; ++i)\n        x += f(t + m * float(i) / float(SAMPLES), a, b);\n    return x / float(SAMPLES * 2 + 1);\n}\n\n// the ramp function is kind of a linear smoothstep. If t is:\n//   below a:         returns zero\n//   above b:         returns one\n//   between a and b: 1D barycentric coordinate\nfloat ramp(float a, float b, float t)\n{\n    return clamp((t - a) / (b - a), 0., 1.);\n}\n\n// analytic motion blur, adding up ramps\n// t - value being rendered\n// a - signal begin\n// b - signal end\n// m - blur amount\nfloat motionBlurAnalytic(float t, float a, float b, float m)\n{\n    float o = ceil(m); // add up as many ramps as the number of times we wrap around due to the huge blur\n    \n    float r = 0.;\n    for (float s = -o; s <= o; ++s)\n        r += ramp(b - m, b + m, s + t) - ramp(a - m, a + m, s + t);\n    return -r;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u *= 2. / R;\n\n    vec2 m = iMouse.xy / R;\n    if (iMouse.z <= 0.) m = vec2(-cos(iTime) * .5 - .5, sin(iTime * .2)) * .5 + .5; // animate if no mouse\n        \n    float A = .01, B = m.y; // signal begin/end\n    float M = 2. * max(m.x - .1, 0.); // blur amount\n\n// swappable color schemes:\n#define col(X) mix(vec4(1), vec4(1, 0, 0, 1), X)\n//#define col(X) mix(vec4(.2, .5, .1, 1), vec4(.1, .1, .3, 1), X)\n//#define col(X) mix(vec4(1, .7, .1, 1), vec4(.3, .1, .5, 1), X)\n//#define col(X) mix(vec4(.01), vec4(.7, .5, .1, 1), X)\n    \n    if (u.x < 1.)\n    {\n        // left side (linear graphs)\n        if (u.y < 1.)\n        {\n            // bottom: multisample\n            float ms = motionBlurMs(u.x, A, B, M);\n            \n            if (u.y < .5)\n                O = vec4(1. - step(3./R.y, abs(u.y - ms * .35 - .075))); // multisample graph\n            else if (u.y < 1.)\n                O = col(ms); // multisample color stripe\n        }\n        else\n        {\n            // top: analytic\n            float ma = motionBlurAnalytic(u.x, A, B, M);\n            \n            if (u.y < 1.5)\n                O = col(ma); // analytic colored stripe\n            else\n                O = vec4(1. - step(3./R.y, abs(u.y - ma * .35 - 1.6))); // analytic graph\n        }\n    }\n    else\n    {\n        // right side (circles)\n        vec2 U = u;\n        U.x = U.x - 1.5;\n        U.x *= R.x / R.y;\n        if (length(U - vec2(0., .5)) < .5)\n        {\n            // bottom: multisample circle\n            float a = atan(U.y - .5, U.x) / (PI * 2.) + .5;\n            float ms = motionBlurMs(a, A, B, M);\n            O = col(ms);\n        }\n        else if (length(U - vec2(0., 1.5)) < .5)\n        {\n            // top: analytic circle\n            float a = atan(U.y - 1.5, U.x) / (PI * 2.) + .5;\n            float ma = motionBlurAnalytic(a, A, B, M);\n            O = col(ma);\n        }\n    }\n    \n    // blue dividing lines\n    if (abs(u.y - 1.) < 3. / R.y || abs(u.x - 1.) < 3. / R.x)\n        O = vec4(0, 0, 1, 1);\n    \n    if (u.x < 1. &&\n        (abs(u.y - 1.5) < 3. / R.y || abs(u.y -  .5) < 3. / R.x))\n        O = vec4(0, 0, 1, 1);\n    \n    O = pow(O, vec4(1./2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}