{
    "Shader": {
        "info": {
            "date": "1588425851",
            "description": "When I was a teenager, I saw Snoop Dogg's \"Sensual Seduction\" video on TV and my life hasn't been the same ever since.\n\nI didn't implement the full track, since I couldn't link the original track anyway, and it just doesn't feel the same :'(",
            "flags": 32,
            "hasliked": 0,
            "id": "WsffW7",
            "likes": 20,
            "name": "sensual seduction —sat.sketch #9",
            "published": 3,
            "tags": [
                "2d",
                "chroma",
                "wave",
                "video",
                "80s",
                "zoom",
                "effect",
                "background",
                "sprite",
                "key",
                "damme",
                "jean",
                "claude",
                "vapor",
                "van",
                "multibuffer"
            ],
            "usePreview": 0,
            "username": "szczm_",
            "viewed": 842
        },
        "renderpass": [
            {
                "code": "/**************************************************************************************************\n\n sensual seduction — saturday sketch #9\n  — Matthias Scherba (@szczm_)\n\n\n When I was a teenager, I saw Snoop Dogg's \"Sensual Seduction\" video on TV and my life hasn't been\n the same ever since. I decided to recreate the basic effect visible in some of the scenes.\n\n The effect is implemented using \"sprite\" IDs and an anti-interpolation trick, and is very simple.\n Full explanation in the \"Buffer B\" tab.\n\n I didn't implement the full track, since I couldn't link the original track anyway, and it just\n doesn't feel the same :'(\n\n\n\n Switch to the Britney video at your own risk.\n\n https://twitter.com/szczm_\n\n**************************************************************************************************/\n\n// https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float sample_offset = 0.006;\n\n#define VIDEO_BUFFER (iChannel0)\n#define BACKGROUND_BUFFER (iChannel1)\n#define POI_BUFFER (iChannel2)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n       \n    vec4 bg = texture(BACKGROUND_BUFFER, uv);\n    vec4 damn = texture(VIDEO_BUFFER, uv);\n    \n    float bg_time = bg.b / 10.0;\n    \n    float id = round(bg.g);\n\tfloat diff = 0.0;\n        \n    for (float i = 0.0; i < 1.0; i += 1.0 / 16.0)\n    {\n        float angle = i * TAU;\n\t\tvec2 dir = vec2(cos(angle), sin(angle));\n\n        diff += step(0.1, distance(id, texture(BACKGROUND_BUFFER, uv + dir * sample_offset).g));\n    }\n    \n    diff /= 16.0;\n    \n    float bg_border = smoothstep(1.0, 0.0, distance(diff, 0.5) * 2.0);\n    \n    bg_border = clamp(bg_border, 0.0, 1.0);    \n    \n    vec3 bg_color = hsv2rgb(vec3(bg_time, 1.0, 1.0));\n    \n    vec3 bg_final = mix(bg_color, vec3(0.0), bg_border);\n    \n    vec3 col = mix(bg_final, damn.rgb, damn.a);\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nBUFFER A: Jean Chroma Van Damme\n\n\nThis one just chroma keys the protagonist.\n\n*/\n\n#define THAT_DAMME_BUFFER (iChannel0)\n#define THIS_BUFFER (iChannel2)\n\n\nconst vec3 chroma_key = vec3(14, 162, 37) / 256.0;\n\nconst float chroma_low = 0.05;\nconst float chroma_high = 0.3;\n\nconst float chroma_cutoff_start = 0.5;\nconst float chroma_cutoff_end = 1.2;\n\n\n// bad chroma because I'm staying true to the original\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(THAT_DAMME_BUFFER, uv);\n    \n    float chroma = distance(col.rgb, chroma_key);\n    chroma = (chroma - chroma_low) / (chroma_high - chroma_low);\n    \n\tcol.a = smoothstep(chroma_cutoff_start, chroma_cutoff_end, chroma);\n\n    fragColor = col;\n}\n\n#undef THAT_DAMME_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n\nBUFFER B: background effect\n\n\nIn the original inspiration - the \"Sensual Seduction\" music video - contours keep shape and scale\nuniformly.\n\nI can't do ordinary \"sprites\", like the original most likely did.\n\nI started with a naïve outline approach, which, of course, didn't work well at all.\nThen I switched to a more radical idea:\n\nI took contours of our protagonist, and on the edges I calculated the alpha gradient, and then\nI propagated those gradients, like waves. Not only it took me too much time and fixing, it was\nalso incorrect (waves could cancel out one another), and it also was numerically unstable most\nof the time.\n\nI also tried radial dilation, but again, incorrect, contours started to bloat.\n\nAnd THEN - I had a moment of eureka. I already scale the UVs. Isn't that zooming? Zooming sprites?\nAnd that's the final approach that you see.\n\nI scale the UVs based on the \"center of mass\" calculated in Buffer C (the \"POI buffer\").\n\nAs often is the case, the simplest approach is the best approach.\n\n\n\nNow comes the problem of storing the data. Since it's not sprite based, the \"instance\" data is\nheld in the texture itself. I keep the time data for each \"sprite\", and an ID for differentiating\nbetween frames. (I've tried different approaches, but this one yielded best results, especially\nwhen filtering comes into play.)\n\nThis means that any discrete data is subject to interpolation. What can I do about this?\n\nMost obvious solution: nearest neighbour filtering. That disorts the image heavily, which is not\ndesired.\n\nThen I thought: how can I find out that data was distorted by interpolation? Error detection!\n\nI mark frame with an integer ID, and if it's no longer an integer, this gives me some information.\nIf the adjacent sprites have successive IDs, I can easily reconstruct the interpolated data.\nAs I only need to find out if we're on the edge of two sprites, I can assign only 0 and 1\nalternatively.\n\nThis comes with a downside - frame no 3 can overlap frame no 1, and we no longer get an outline.\n\nI switched to just successive IDs, which works very well for generating outlines between distant\nsprites.\n\nThis of course comes with yet another downside: no longer does the fractional part of the integer\npart allow us to correctly reconstruct the frame ID, if distant frames overlap. This shows in the\nfinal image as multiple/layered outlines.\n\nI considered switching back to ping-ponged IDs, which would lower the amount of layered outlines,\nbut it would again hide some of them. I decided to stay with the current, if slightly incorrect,\nresult.\n\n\nThe best and more obvious solution would probably be a highpass filter, or some reconstruction\nfilter, but I decided to stay with the current solution only because I find it very simple and\ninteresting.\n\n\n*/\n\n#define CHROMA_BUFFER (iChannel0)\n#define THIS_BUFFER (iChannel1)\n#define POI_BUFFER (iChannel2)\n\nconst int frame_gate = 12;\nconst float step_back_to_reality = 0.5;\nconst float zoom_per_frame = 1.02;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 center = texelFetch(POI_BUFFER, ivec2(0, 0), 0).rg;\n    \n    uv -= center;\n    uv /= zoom_per_frame;\n    uv += center;\n    \n    vec4 col;\n    \n    vec4 samp = texture(THIS_BUFFER, uv);\n    \n    float id = fract(samp.g);\n    \n    // check how far up or down we should move the interpolated ID\n    float deviation = step(0.5, id) - id;\n    \n    samp.g += deviation * step_back_to_reality;\n    // oh, there goes gravity. thanks a lot, Marshall\n\n    // we could also correct time, but the error is covered by the outline anyway\n    samp.b += iTimeDelta;\n    \n    col = vec4(samp.rgb, 1.0);\n    \n    \n    // put a new Van Damme in the background\n    if (iFrame % frame_gate == 0)\n    {\n        vec4 samp = texture(CHROMA_BUFFER, uv);\n        float id = float(iFrame / frame_gate);\n        \n\t    col = mix(col, vec4(0.0, id, 0.0, 1.0), step(0.5, samp.a));\n    }\n    \n    fragColor = col;\n}\n\n#undef CHROMA_BUFFER\n#undef THIS_BUFFER\n#undef POI_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// death to pi\n#define TAU 6.28318530718",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n\nBUFFER C: find center of mass\n\n\nSamples the chroma keyed buffer at equal offsets, checking if Van Damme is Van There,\nand then stores the data in the Van Bottom Left Pixelle. Weighted average.\n\n*/\n\n#define CHROMA_BUFFER (iChannel0)\n#define THIS_BUFFER (iChannel1)\n\nconst vec2 data_location = vec2(0.5, 0.5);\nconst float sample_step = 1.0 / 20.0;\nconst float offcenter_multiplier = 3.0;\n\nconst float half_pixel = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Are we in the data pixel?\n    if (distance(fragCoord, data_location) <= half_pixel)\n    {\n        vec2 sum = vec2(0.0);\n        float weights = 0.0;\n        \n        for (float x = sample_step / 2.0; x < 1.0; x += sample_step)\n        {\n            for (float y = sample_step / 2.0; y < 1.0; y += sample_step)\n            {\n                float alpha = texture(CHROMA_BUFFER, vec2(x, y)).a;\n                \n                sum += vec2(x, y) * alpha;\n                weights += alpha;\n            }\n        }\n        \n        if (weights > 1.0)\n        \tsum /= weights;\n        \n        // The FUTURISTIC off-center movement effect\n        sum -= 0.5;\n        sum *= offcenter_multiplier;\n        sum += 0.5;\n        \n        \n        // Mix a bit with the previous result for a smoother look\n        vec2 prev = texelFetch(THIS_BUFFER, ivec2(0, 0), 0).rg;\n        \n        sum = mix(prev, sum, step(1.0, weights) * 0.5);\n        \n    \tfragColor = vec4(sum, 0.0, 1.0);\n    }\n}\n\n#undef CHROMA_BUFFER",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}