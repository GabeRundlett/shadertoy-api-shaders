{
    "Shader": {
        "info": {
            "date": "1510851266",
            "description": "Pixel footprint in texture space. B,G frame = (dFdx,dFdy)\nRed: geometry used for x16 aniso.  Note axe is longer than B.\nB,G quads: squares of size |axisB|,|axisG|\nDash O: mean = MIPmap level\nO quads: ceil,floor levels\nWhite tiles: 8 pyramid texels fetched",
            "flags": 0,
            "hasliked": 0,
            "id": "MtsBzn",
            "likes": 11,
            "name": "MIPmap Demo",
            "published": 3,
            "tags": [
                "antialiasing",
                "filtering",
                "ellipse",
                "anisotropic",
                "footprint"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1047
        },
        "renderpass": [
            {
                "code": "                                                    // --- find ellipse geometry\nvoid ellips(in mat2 M, out vec2 A0, out vec2 A1, out float r0, out float r1) {\n    vec2 I = M[0], J = M[1];                        // ellipse: P = cos(u).I + sin(u).J \n    float a = ( dot(J,J) - dot(I,I) ) / dot (I,J),  // -> search for extrema of length(P) \n          D = sqrt(a*a+4.),                         // get tan(u) -> s, c, axis*radii\n          t0 = (a+D)/2., t1 = (a-D)/2.;\n    A0 = (I + t0*J) / sqrt(1.+t0*t0);               // c = 1/sqrt(1+t²), s = t/sqrt(1+t²)\n    A1 = (I + t1*J) / sqrt(1.+t1*t1);               // axis also encodes radius\n    r0 = length(A0); A0 /= r0;\n    r1 = length(A1); A1 /= r1;\n    if (r1>r0) a=r0,r0=r1,r1=a, I=A0,A0=A1,A1=I;     // sort radii      \n}\n\nfloat square(vec2 U,vec2 r, float e) {             // --- draw framed square\n    U = abs(U) - r/2.;\n    return abs(max(U.x,U.y)) - e/iResolution.y;\n}\nfloat square(vec2 U,float r, float e) { return square(U,vec2(r),e); }\nfloat squareF(vec2 U,float r, float e) {           // --- draw filled square\n    U = abs(U) - r/2.;\n    return step( max(U.x,U.y),0.);\n}\n\nfloat segment(vec2 u, vec2 a, vec2 b)  {           // --- draw line segment\n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nfloat checker(vec2 U, float n) {                   // --- draw checker   \n    ivec2 V = ivec2( U * n ) % 2;        \n    return float( V.x == V.y );  \n}    \n\n#define rot(a)      mat2(cos(a),sin(a),-sin(a),cos(a))\n#define S(v)        smoothstep( 1./R.y, 0., v )\n#define blend(v,C)  O = mix(O, C, S(v) )\n#define spot(v,C)   blend ( 2.*(length(v) - r/R.y) , C )  \n\nvoid mainImage( out vec4 O, vec2 U )               // === draw MIPmap footprint\n{\n    vec2 R = iResolution.xy,\n         P = iMouse.xy,\n         e = vec2(1./R.y,0);\n    float t = iTime;\n    if (length(P)<10.) P = R*.5 + .15*R*vec2(cos(t),sin(t)); \n    U /= R.y; P /= R.y; \n         \n    O = vec4(.1+.1*checker(U,32.));                // --- (fake) texture   \n    O.a = 0.;\n    \n                                                   // --- drawing footprints\n    float r = .03*R.y;                             // \"pixel\" radius\n    vec4 red = vec4(1,0,0,1), blue = vec4(0,0,1,1), green = vec4(0,1,0,1),\n      orange = vec4(1,.6,.3,1), white = vec4(1), grey = vec4(.7,.7,.7,1), black = vec4(0,0,0,1);\n\n    mat2 J = mat2(3,6, 3.+3.*sin(t*.7),-5)/R.y;   // Jacobian of some pixel projection on texture\n\tJ = rot(.3*sin(t)) * J * (1.+.3*cos(t/2.));\n    \n    vec2 A,a, Q,q; float M,m, k,f,T;              // get ellipse geomtry for texture footprint\n    ellips(J, A,a,M,m); \n    Q = (U-P) * mat2(A/M,a/m)/R.y;\n    spot( Q , grey);                              // draw ellipse\n\tblend( segment(U, P,P+J[0]*r)/2., blue);      // draw footprint frame = ( dFdx, dFdy )\n\tblend( segment(U, P,P+J[1]*r)/2., green);\n    Q = (U-P) * mat2(A,a);\n\tblend( segment(U, P,P+A*M*r), red);           // draw ellipse axis\n\tblend( segment(U, P,P+a*m*r), red);\n    blend( square( Q, vec2(M,m)*r*2., 1.), red);  // footprint fitting rectangle ( used for x16 aniso)\n    \n                                                  // --- MIPmap footprint      \n    M = length(J[0]) *r*2.; \n    m = length(J[1]) *r*2.;\n    // log2( M );                                 // MIPmap level corresponding to M\n    // log2( m );                                 // MIPmap level corresponding to m\n    blend( square( U-P, M, 1.), blue);            // axis-aligned box \n    blend( square( U-P, m, 1.), green);\n    k = (M+m)/2.;\n    blend( square( U-P, k, 1.), orange*checker(U-P,128.));   // mean (constructor choice. Maybe max).\n    M = exp2(ceil(log2(k)));\n    m = exp2(floor(log2(k)));\n    f = fract(log2(k));\n    blend( square( U-P, M, .5), orange);          // trilinear: up stored level\n    blend( square( U-P, m, .5), orange);          // trilinear: bottom stored level\n    Q = U-floor(P/M)*M,\n    q = U-floor(P/m)*m;\n    T = 1.-O.a;\n    for( int i=0; i<4; i++ ) {                    // bilinear: 4 fetchs\n        vec2 C = vec2(i%2,i/2),                   // 2x2 index\n             G = abs(1.-C-fract(P/M)),            // weight for each\n             g = abs(1.-C-fract(P/m));\n        O += T* step(square( Q-M*C, M, .5), 0.);  // texels at upper level\n        O += T* step(square( q-m*C, m, .5), 0.);  // texels at downer level\n    \tO.r += T* squareF( Q-M*C, M, .5) *G.x*G.y*f*2.;      // painted with weight\n    \tO.g += T* squareF( q-m*C, m, .5) *g.x*g.y*(1.-f)*2.;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}