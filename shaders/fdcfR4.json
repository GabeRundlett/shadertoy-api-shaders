{
    "Shader": {
        "info": {
            "date": "1656135517",
            "description": "Part 3 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/",
            "flags": 0,
            "hasliked": 0,
            "id": "fdcfR4",
            "likes": 1,
            "name": "ray marching and phong",
            "published": 3,
            "tags": [
                "raymarching",
                "phong"
            ],
            "usePreview": 0,
            "username": "lanx06",
            "viewed": 202
        },
        "renderpass": [
            {
                "code": "\n#ifdef GL_ES\n#define PI 3.1415926538\nprecision mediump float;\n#endif\n\nconst float EPSILON =.1;\nconst int max_step=255;\nconst float not_hit=10000.0;\nconst float max_len=100.;\n\nfloat sp(vec3 sample_point,vec3 center,float size){\n    return length(sample_point-center)-size;\n}\nfloat cube(vec3 sample_point,vec3 center,float size){\n    vec3 d=abs(sample_point-center)-vec3(size);\n    float in_d=min(max(d.x,max(d.y,d.z)),0.);\n    float out_d= length(max(d, 0.0));\n    //if(in_d==0.)return 0.0;\n\treturn out_d*(1.-in_d)+in_d;\n}\n\nfloat scene(vec3 sample_point){\n    float cube1=cube(sample_point,vec3(0.),.5);\n    float sp1=sp(sample_point,vec3(.5),.5);\n\tfloat dep=min(cube1,sp1);\n    //if(sp1<EPSILON)return not_hit;\n    return dep;\n    //return min(sp(sample_point,vec3(1.)),not_hit);\n}\nvec3 ray_d(float fov,vec2 size,vec2 fargcoord){\n    vec2 xy=fargcoord-size/2.;\n    float z=size.y/tan(radians(fov/2.));\n    //return normalize(vec3(-z,xy.x,xy.y));\n    return normalize(vec3(xy,-z));\n}\nfloat ray_march(vec3 eye, vec3 d){\n    float depth=0.;\n    for(int i=0;i<max_step;i++){\n        float dis=scene(eye+d*depth);\n        \n        if(dis<EPSILON)return depth;\n        \n        depth+=dis;\n        \n        if(depth>=not_hit)return not_hit;\n        \n    }\n    return not_hit;\n}\n\nvec3 culc_normal(vec3 p){\n        return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nvec3 culc_light(vec3 diff_c,vec3 spec_c,float al, vec3 pos,vec3 eye,vec3 light_pos,vec3 power){\n\tvec3 n=culc_normal(pos);\n    //not right but look good\n    //vec3 l=culc_normal(light_pos-pos);\n    //vec3 v=culc_normal(eye-pos);\n    //vec3 r=culc_normal(reflect(-l,n));\n    //right one use normalize\n    vec3 l=normalize(light_pos-pos);\n    vec3 v=normalize(eye-pos);\n    vec3 r=normalize(reflect(-l,n));\n\tfloat dot_ln=dot(l,n);\n    float dot_rv=dot(r,v);\n    if(dot_ln<0.)return vec3(0.0, 0.0, 0.0);\n    \n    //use diff color\n    if(dot_rv<0.)return power*diff_c*dot_ln;\n    //reflection \n    return power*( diff_c*dot_ln + spec_c*pow(dot_rv,al));\n}\nvec3 phong_light(float al,vec3 light_pos,vec3 pos,vec3 eye,vec3 am_c,vec3 diff_c,vec3 spec_c){\n     vec3 amb_light=.5*am_c;\n    vec3 color=amb_light;\n    vec3 light_power=vec3(.4);\n    color+=culc_light(am_c,spec_c,al,pos,eye,light_pos,light_power);\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 ps= vec2(cos(iTime),sin(iTime))*10.;\n\t//vec3 eye_postion=vec3(10.,0.0,0.);\n    //vec3 eye_postion=vec3(ps,0.);\n    //vec3 eye_postion=vec3(1.,1.,+10.*abs(sin(iTime)));\n    vec3 eye_postion=vec3(0,0,+6.);\n    vec3 ray_di=ray_d(50., iResolution.xy,gl_FragCoord.xy);\n    float hit=ray_march(eye_postion,ray_di);\n    vec3 pos=eye_postion+ hit * ray_di;\n\tcolor=vec3(ray_di);\n    \n    if(hit!=not_hit){\n      //color=vec3(culc_normal(hit*ray_di));\n        vec3 light_pos =vec3(ps/1.,1);\n        //vec3 light_pos=vec3(2.950,3.689,4.000);\n        vec3 am_c=vec3(0.8353, 0.8275, 1.0);\n        vec3 diff_c=vec3(1.0, 0.0, 0.0);\n        vec3 spec_c=vec3(1.0, 1.0, 1.0);\n        float max_shine=100.0;\n\t\tcolor=phong_light(max_shine,light_pos,pos,eye_postion,am_c,diff_c,spec_c);\n        //color=vec3(1);\n    }\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}