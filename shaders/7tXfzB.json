{
    "Shader": {
        "info": {
            "date": "1651043395",
            "description": "So I tried to make Ridged Multifractal with my noise generation, but feel like it need some work.",
            "flags": 0,
            "hasliked": 0,
            "id": "7tXfzB",
            "likes": 1,
            "name": "Ridged Multifractal",
            "published": 3,
            "tags": [
                "noise",
                "perlin",
                "rainbow",
                "colorfull"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "float seed = 437585.453123;\nfloat PI = 3.141592653589793;\nfloat res = 10.; // how many sqrs along the x axes\n\nfloat hash21(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec2 (127.1, 351.7));\n  return fract(sin(f)*a);\n}\n\nvec2 hash2(vec2 p) \n{\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  p = vec2(dot (p, vec2 (127.1, 351.7)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p)*a);\n}\n\nvec3 hash23(vec2 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec3 p3 = vec3(dot (p, vec2 (127.1, 351.7)), dot (p, vec2 (261.5, 183.3)), dot(p, vec2(245.5, 304.4)));\n  return fract(sin(p3)*a);\n}\n\nvec2 hash32(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  vec2 p2 = vec2(dot (p, vec3 (127.1, 351.7, 251.45)), dot (p, vec3 (261.5, 183.3, 376.89)));\n  return fract(sin(p2)*a);\n}\nfloat hash31(vec3 p) {\n  p = mod(p, PI*20.);\n  float a = (mod(43758.5453123 + seed, 37562.) + 13548.);\n  float f = dot (p, vec3 (127.1, 351.7, 251.45));\n  return fract(sin(f)*a);\n}\n\n//6t5-15t4+10t3\nfloat ease(float t)\n{\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\nvec2 ease(vec2 t)\n{\n  return vec2(ease(t.x), ease(t.y));\n}\nvec3 ease(vec3 t)\n{\n  return vec3(ease(t.x), ease(t.y), ease(t.z));\n}\nvec4 ease(vec4 t)\n{\n  return vec4(ease(t.x), ease(t.y), ease(t.z), ease(t.w));\n}\n\nfloat noise(vec2 point){\n    vec2 fr = ease(fract(point));\n    vec2 hi = ceil(point);\n    vec2 lo = floor(point);\n    \n    return mix(\n        mix(\n            hash21(lo), \n            hash21(vec2(hi.x , lo.y)), \n            fr.x\n        ), \n        mix(\n            hash21(vec2(lo.x , hi.y)),\n            hash21(hi),\n            fr.x\n        ), \n        fr.y\n    );\n}\n\nfloat noise(vec3 point){\n    vec3 fr = ease(fract(point));\n    vec3 hi = ceil(point);\n    vec3 lo = floor(point);\n    \n    return mix(\n        mix(\n            mix(\n                hash31(lo), \n                hash31(vec3(hi.x , lo.yz)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.y, lo.z)),\n                hash31(vec3(hi.xy, lo.z)),\n                fr.x\n            ), \n            fr.y\n        ),\n        mix(\n            mix(\n                hash31(vec3(lo.xy, hi.z)), \n                hash31(vec3(hi.x , lo.y, hi.z)), \n                fr.x\n            ), \n            mix(\n                hash31(vec3(lo.x , hi.yz)),\n                hash31(hi),\n                fr.x\n            ), \n            fr.y\n        ),\n        fr.z\n    );\n}\n\nfloat octal(vec3 uv, int octaves, float persistence)\n{\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.;  // Used for normalizing result to 0.0 - 1.0\n    for(int i=0;i<octaves;i++) {\n        total += noise(uv * frequency) * amplitude;\n        \n        maxValue += amplitude;\n        \n        amplitude *= persistence;\n        frequency *= 2.;\n    }\n    return total/maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    \n    /*vec3 col = vec3(\n        (\n            noise(uv)\n          + noise(uv * 2.) * .5\n          + noise(uv * 4.) * .25\n          + noise(uv * 8.) * .125\n        ) / 1.875\n    );*/\n\n    float r = 1.-abs((-octal(vec3(uv + vec2(sin(iTime / 10.), cos(iTime / 10.)) * 10., 500. + iTime / 5.0), 8, .5) + .5) * 2.);\n    float g = 1.-abs((-octal(vec3(uv + vec2(sin(iTime / 10.), cos(500. + iTime / 10.)) * 10., 2. * iTime / 5.0), 8, .5) + .5) * 2.);\n    float b = 1.-abs((-octal(vec3(uv + vec2(sin(500. + iTime / 10.), cos(iTime / 10.)) * 10., 2. * iTime / 5.0), 8, .5) + .5) * 2.);\n    \n    vec3 col = vec3(r, g, b);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}