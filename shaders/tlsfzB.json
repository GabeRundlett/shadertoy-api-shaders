{
    "Shader": {
        "info": {
            "date": "1597104868",
            "description": "The effect is done with 3D ray marching. But it can be done also in 2D I think.\nOnly the noise is moving through a tube, the camera is at the \"extremity\" of the tube (cylinder) and doesn't move\nIt's an animation without user interaction !",
            "flags": 0,
            "hasliked": 0,
            "id": "tlsfzB",
            "likes": 11,
            "name": "3D hyperjump to a star",
            "published": 3,
            "tags": [
                "noise",
                "raymarch",
                "star",
                "shockwave"
            ],
            "usePreview": 0,
            "username": "Leria",
            "viewed": 709
        },
        "renderpass": [
            {
                "code": "\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define THICK\t\t\t\t2.\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nature of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t0\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nfloat anim = 0.;\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1./4.); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*5.5;\n   \ts = 2./pow(stretching,vec3(.25));\n    #endif    \n    \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 5.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    \n    for(int s = 10; s <110; s++)\n    {               \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        float d = length(center)-RADIUS-.5-jit*k;\n        float size = length(center)/RADIUS;\n\n        if(sdf_rounded_cylinder( center, 1.20, 0.2, 5. ) < 0.)\n        {\n            \n            #if COLOR            \n            #if ANIM      \n            \tanim = iTime/5.;\n            \n            #endif\n            \n            \n            float n = fbm( ( \n                (p)/( clamp(0., RADIUS+1., length(center)) + cos(PI-Psnoise(p/(30.)) )- 1./size*anim) //shockwave stuff\n            \t\t\t) )  ;; ;\n            // 1./size is the speed of the wave propgation \n            /////////////////////\n\n            float mask = smoothstep(0.,\n                                   \t70.*RADIUS,\n                                    RADIUS/length(center));\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n);\n                        \n           if(length(p-cam.pos) >(dist_center+m.radius) \n              )//|| (k*dens  < -9.9))\n        \t{\n         \tbreak;\n        \t}\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size          \n             vec3 rgb_t = exp(-vec3(\n                \t\tk * 25. * f(p.x) * dens, \n                      \tk * 10. * dens,\n              \t      \tk * 15. * f(p.z) * dens ));    \n                \n    \t\t//blending\n   \t\t\tc += t_acc*vec3(1.)*(1.-rgb_t);\n                        t_acc *= (rgb_t);           \n\n            #endif\n        }\n\n        //if it will never be in the shape anymore, return;        \n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * vec2(iResolution.x/2., iResolution.y/4.)/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI \t\t\t\t\t3.1415926\n\n//most of it, come from iq\n\n\nfloat sdf_rounded_cylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}