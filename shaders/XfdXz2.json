{
    "Shader": {
        "info": {
            "date": "1714171680",
            "description": "UC Berkeley CS184  Final Project\nModeling a forest terrain using ray marching, inspired by IQ ! ",
            "flags": 0,
            "hasliked": 0,
            "id": "XfdXz2",
            "likes": 3,
            "name": "Trees speak to me",
            "published": 3,
            "tags": [
                "raymarching",
                "terrain",
                "forest",
                "trees",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "csgradle",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 300\n#define MAX_DIST 500.\n#define SURF_DIST 0.12\n#define WATER_HEIGHT -6.7\n\n\n\n\n\n\n\n\n// returns color of the clouds\nvec3 renderSky(in vec2 p) {\t\n    return sin(vec3(1.7, 1.45, 1.) + 1. + .9 * fbm(p * 8.0 - .02 + iTime/20.0)) + 0.25;\n}\n// returns the height of the noise-generated terrain \nfloat getGroundHeight(in vec3 p) {\n    return + noise(p.xz * 0.01+124.1234) * 80.\n           + noise(p.xz * 0.1) * 5.;\n}\n\n// signed distance field function for the trees\nfloat drawTrees(in vec3 p, float groundHeight) {\n\n    float repeatSize = 5.;\n    // if p is our ray, f is the point on the grid closest to the ray.\n    // we also add random2() to offset this grid a little to randomize trees\n    vec2 f = repeatSize * (fract(p.xz/repeatSize)-vec2(0.5)\n            + random2(floor(p.xz/repeatSize)) * 0.25);\n    \n    // q is the center coordinate of the tree. \n    // specifically, we change the y value by the height of the ground so it's not flat\n    vec3 q = vec3(f.x, p.y + groundHeight -4., f.y);\n    // if the tree center is below water, drown it >:D\n    if (groundHeight > -WATER_HEIGHT - .15) q.y -= 1000.;\n    \n    // tree wave using sine waves\n    float waveX = sin(iTime + p.x * 0.1) * 0.05;\n    float waveY = sin(iTime + p.z * 0.1) * 0.01;\n    float waveZ = sin(iTime + p.z * 0.1) * 0.05;\n    \n    float wave = waveX + waveY + waveZ;\n    \n    // using tree center (q) we add 4 cones on top of each other to make it look like trees\n    // we also add noise to make the trees not look perfect. displacement mapping !\n    float result;\n    result = (0.5 * noise(p.xz * 7.)) +sdCone(q, -2.5, .1, 2.) + wave;\n    result = min(result, (0.5 * noise(p.xz * 7.)) + sdCone(q-vec3(0,2,0), -2., .1, 1.7) + wave);\n    result = min(result, (0.5 * noise(p.xz * 7.)) + sdCone(q-vec3(0,4,0)*0.8, -2., .1, 1.2) + wave);\n    \n    // this is the 4th and last cone we add. it's for the inside so it's not hollow\n    result = min(result, sdCone(q, -3., .1, 2.) + wave);\n    \n\n    // we multiply by 0.6 to decrease the step size of the ray, making it higher quality\n    // this helps reduce artifacts on the tree\n    return result;\n    //return sdEllipsoid(q, 3.*vec3(0.5, 1, 0.5)+0.5*noise(p.xz));\n}\n\n// generates the world using math.\n// returns vec2(dist_to_nearest_object, materialID) pair\nvec2 GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    // ground plane\n    float groundHeight = getGroundHeight(p);\n    float groundDist = sdPlane(p, vec3(0, 1, 0), 0.) + groundHeight;\n    float groundID = 1.0;\n    vec2 groundObj = vec2(groundDist*.1, groundID);\n    \n    \n    // water\n    float waterDist = sdPlane(p - vec3(0, WATER_HEIGHT, 0), vec3(0, 1, 0), 0.)\n        + (noise(p.xz * .4 + vec2(iTime * 1.)) * 1.1\n        + noise(p.xz * .3 + vec2(-iTime * 0.5)) * 0.5)\n        * 0.02;\n    float waterID = 4.0;\n    vec2 waterObj = vec2(waterDist, waterID);\n\n    // trees\n    float treeDist = drawTrees(p, groundHeight);\n    float treeID = 5.0;\n    vec2 treeObj = vec2(treeDist*.6, treeID);\n\n    // combine everything together\n    vec2 result;\n    \n    result = fOpUnionID(groundObj, waterObj);\n    result = fOpUnionID(result, treeObj);\n    \n    return result;\n}\n// gets the normal, given a position\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(SURF_DIST*3., 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n// gets material given the position and material ID\nvec3 getMaterial(vec3 p, float id) {\n    vec3 m;\n    switch (int(id)) {\n        case 1: // ground \n\n            float f = step(noise(p.xz * 0.1)*2.\n                           + noise(p.xz * 10.) * 1.\n                        , -.2);\n            vec3 brown = vec3(60, 45, 22)/255. * 0.3;\n            vec3 green = vec3(68, 76, 15)/255. * 0.3;\n            m = mix(brown, green, f);\n        \n            break;\n        case 2: // box\n            m = vec3(0.2, 0.5, 0.1); break;\n        case 3: // torus\n            m = vec3(0.0, 0.5, 1.0); break;\n        case 4: // water\n            float waveIntensity = 0.15;\n            float waveFrequency = 1.0;\n\n            float waveHeight = 1.;//0.6 * sin(p.x * waveFrequency + iTime * 0.0);\n            m = vec3(0.1, 0.2, 0.99) + vec3(0.0, waveHeight, 0.0) * waveIntensity;\n            m *= 0.1;\n            break;\n        case 5: // trees\n            float t = 5.*noise(p.xz * 0.05)+1.;\n            vec3 darkGreen = vec3(31, 100., 40)/255. * 0.3;\n            vec3 lightGreen = vec3(31, 100., 40)/255. * 0.1;\n            m = mix(lightGreen, darkGreen, clamp(t, 0., 1.)); break;\n    }\n    return m;\n}\n// Marches ray until it hits something.\n// returns the ray distance at hit, as well as the ID\nvec2 RayMarch(vec3 ro, vec3 rd) {\n    vec2 hit, result; \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + result.x * rd;\n        hit = GetDist(p);\n        result.x += hit.x;\n        result.y = hit.y;\n        if (result.x > MAX_DIST || abs(hit.x) < SURF_DIST) break;\n    }\n    return result;\n}\n\n// calculates cloud and sun\nvec3 skyColor(vec3 ro, vec3 rd) {\n    // takes dot product between sun and viewing ray. \n    // If the sun direction and the view lines up, it becomes bright white !\n    // separates betewen outer and inner sun to make it more gradual.\n    vec3 lightPos = vec3(50.0, 13.0, 4.0)*6.;\n    vec3 lightDir = normalize(lightPos - ro);\n    float sunStrength = dot(lightDir, rd);\n    float innerSun = smoothstep(0.997,1.,sunStrength);\n    float outerSun = pow(sunStrength, 45.)*.7;\n    sunStrength = clamp(innerSun + outerSun, 0., 1.);\n\n    //sky and clouds\n    return renderSky(rd.xz*(0.1+rd.y)) \n        + vec3(0.8, 0.8, 0.4) * sunStrength * .9;\n}\n// calculates the final lighting of the object based on the light /shadows and material color\nvec3 GetLight(vec3 p, vec3 rd, vec3 color, float materialID) {\n    // for water reflections\n    if (int(materialID) == 4) {\n        vec3 n = normalize(GetNormal(p));\n        vec3 new_rd = reflect(normalize(rd), n);\n        \n        vec2 reflection = RayMarch(p + n*SURF_DIST*2.0, new_rd);\n        vec3 reflection_col = vec3(0);\n        if (reflection.x > MAX_DIST) {\n            reflection_col = skyColor(p, new_rd);\n        }\n        \n        return mix(color, reflection_col, 0.5);\n    }\n    // phong shading\n    vec3 lightPos = vec3(50.0, 30.0, 4.0);\n    vec3 L = normalize(lightPos - p);\n    vec3 N = GetNormal(p);\n    vec3 V = -rd;\n    vec3 R = reflect(-L, N);\n\n    vec3 specColor = vec3(0.5);\n    vec3 specular = 0.1 * specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.0);\n    vec3 diffuse = 1.6 * color * clamp(dot(L, N), 0.0, 1.0);\n                \n    vec3 ambient = color * 0.05;\n    vec3 fresnel = 0. * color * pow(1.0 + dot(rd, N), 3.0);\n\n    // shadows\n    float d = RayMarch(p + N*SURF_DIST*2., normalize(lightPos)).x;\n    if (d < length(lightPos - p)) return ambient + fresnel;\n    \n    // add everything up\n    \n    return clamp(diffuse + ambient + specular + fresnel, 0., 1.);\n}\n\n// calculates ray direction based to look in a certain direction\nvec3 CalcRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// renders everything!\nvec3 render(in vec2 uv) {\n    vec3 col = vec3(0);\n    //ray origin\n    vec2 m = iMouse.xy/iResolution.xy + vec2(-0.42, 0.4);\n    //vec2 m = iMouse.xy/iResolution.xy + vec2(-0.42+iTime*0.01, 0.4);\n    vec3 ro = vec3(0, 45, -25);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    //ray direction\n    vec3 rd = CalcRayDir(uv, ro, vec3(0,20,0), 1.);\n\n    \n    vec2 object = RayMarch(ro, rd);\n    \n    // if hit object, color it with lighting!\n    if(object.x < MAX_DIST) {\n    \tvec3 p = ro + rd * object.x; \n        vec3 material = getMaterial(p, object.y);\n    \tcol += GetLight(p, rd, material, object.y);\n        vec3 fog = vec3(1.,1.,2.5);\n        col = mix(col, fog, 1.0 - exp(-0.0000005 * object.x * object.x));\n        \n    }\n    else { // if hit sky, color with background sky\n        col = skyColor(ro, rd);\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // correct UV\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 uv_d = vec2(0.5/iResolution.y, 0.);\n    \n    // ANTI-ALIASING\n    //vec3 col = (render(uv) + render(uv+uv_d.xy) + render(uv+uv_d.xx) + render(uv+uv_d.yx))/4.;\n    vec3 col = render(uv);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    // vignette\n    vec2 vig_uv = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.9*pow( 16.0*vig_uv.x*vig_uv.y*(1.0-vig_uv.x)*(1.0-vig_uv.y), 0.5 );\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n//\n// OPERATIONS\n//\n\n\n// adds to scene, in format of vec2(distance, ID)\nvec2 fOpUnionID(vec2 res1, vec2 res2) {\n    return (res1.x < res2.x) ? res1 : res2;\n}\n// boolean subtraction\nvec2 fOpDifferenceID(vec2 res1, vec2 res2) {\n    return (res1.x > -res2.x) ? res1 : vec2(-res2.x, res2.y);\n}\n\n// smooth union of two shapes\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n// 2D rotation\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 roty(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z); }\nvec3 rotz(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n    \nfloat dot2(vec2 v) {return dot(v,v);}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// cloud noise\nfloat fbm(vec2 p) {\n\tfloat f = 1.0;   \n\tfloat r = 0.0;\n    mat2 im2 = mat2(0.8,  -0.6, 0.6, 0.8);\n    for (int i = 0; i < 4; i++){\t\n\t\tr += abs(noise(p * f) + 0.5)/f;       \n\t    f *= 2.;\n        p = im2 * p;\n\t}\n\treturn 1.0 - r * 0.5;\n}\n\n\n// \n// SIGNED DISTANCE FUNCTIONS BELOW \n// src: https://iquilezles.org/articles/distfunctions/\n//\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    //shadow of ap onto ab normalized by ab\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t * ab;\n    return length(p - c) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    //shadow of ap onto ab normalized by ab\n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\n\n\n\nfloat sdCone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0., 1.);\n    float s = cb.x<0. && ca.y<0. ? -1. : 1.;\n    return s*sqrt(min(dot2(ca),dot2(cb)));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}