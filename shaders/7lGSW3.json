{
    "Shader": {
        "info": {
            "date": "1641427472",
            "description": "A 3D rendition of the SerenityOS \"Ladyball\"",
            "flags": 1,
            "hasliked": 0,
            "id": "7lGSW3",
            "likes": 3,
            "name": "SerenityOS Ladyball",
            "published": 3,
            "tags": [
                "serenityos"
            ],
            "usePreview": 0,
            "username": "frhun",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "const float INF  = 1./0., //If divide by zero error occurs, replace this with a very big number\n            M_PI = 3.14159;\n\n//--- Settings ---\n// Many of these settings cause really hacky control flow changes.\n// As long as they are only used as constants, that are known at\n// compile time, they should have no impact on performance.\n// But should they be unknown at compile time, they might have\n// severe performance impacts\n\nconst bool MOUSECONTROL = true\n\n         , SHOW_CYCLES              = false\n         , SHOW_COLLISION_DISTANCE  = false\n         , BAILOUT_SPECIAL_COLOR    = false\n         , SHOW_NORMAL              = false\n         , THREE_D                  = false\n         , FIELD_CROSS_SECTION      = false\n         , CUTVIEW                  = false //TODO: fix cutview\n         // EDGE DETECTION SETTINGS\n         , DRAW_NEAR_MISS_EDGES     = false\n         , DRAW_INSIDE_EDGES        = false\n         , DRAW_BOOL_EDGES          = false\n         \n         , DISTANCE_GROWING_THRESH  = false\n         , STEPPING_SLOWDOWN        = false\n         \n         , NEAR_MISS_ANTI_ALIASING  = true\n         , DO_LIGHTING              = true\n         ,   FAKE_SOFT_SHADOWS      = false // ⎫ \"realistic\" lighting\n         ,   LIGHTING_DISTANCE_FADE = true  // ⎬ sub settings\n         ,   SHADOW_NEAR_MISS_AA    = false // ⎪\n         ,   SPECULAR_LIGHT_SOURCES = true  // ⎭\n         \n         , DO_DITHERING             = true;\n\nconst int MAX_STEPS  = 500;\n\nconst float ambient_light    = 0.13,\n            base_dist_thresh = 0.001,\n            shadowDistThresh = 0.01,\n            numGradStep      = 0.0001,\n            bailout_cam_dist = 1000.,\n            gamma            = 2.2,    //setting gamma to easy to calculate values might result in a very slight speedup\n            EDGE_WIDTH       = 1.0;\n\nconst vec3 EDGE_COLOR = vec3(1., 0., 1.);\n\n//---\n\n//--- Lights ---\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float size;\n};\n\nLight lightsList[] = Light[](\n    Light(vec3(0.,0.,-5.),vec3(1.000,1.000,1.000)*5.,0.5),\n    Light(vec3(0.,5.,0.),vec3(1.000,1.000,1.000),1.)\n    );\nint lightsListLength = 2;\n\n//---\n\n//--- Materials ---\n\nstruct Material {\n    vec3 color_diffuse;\n    vec3 color_specular;\n    vec3 color_subsurface;\n    float roughness;\n    float stripe_dens;\n    float stripe_rot;\n};\n\nMaterial materials[] = Material[](\n        Material(vec3(1.), vec3(1.), vec3(0.), .8, 1.0, M_PI / 4.), //mutableMaterial\n        Material(vec3(0.333, 0.666, 1.), vec3(0.333, 0.666, 1.), vec3(0.4), .8, 1.0, M_PI / 4.), //standardMaterial\n        Material(vec3(.64, 0.11, 0.17),  vec3(.64, 0.11, 0.17),  vec3(0.4), .8, 3.0, M_PI / 4.), //redMaterial\n        Material(vec3(.0, 0.9, 0.1),     vec3(.0, 0.9, 0.1),     vec3(0.4), .8, 2.0, M_PI / 4.), //greenMaterial\n        Material(vec3(.0, 0.17, 0.8),    vec3(.0, 0.17, 0.8),    vec3(0.4), .8, 1.0, M_PI * 3. / 4.), //blueMaterial\n        Material(vec3(0.945,0.682,0.000),    vec3(.0, 0.17, 0.8),    vec3(0.4), .8, 1.0, M_PI / 4.), //yellowMaterial\n        Material(vec3(0.020,0.020,0.020), vec3(0.239,0.220,0.275), vec3(0.4), 1., 1.0, M_PI / 4.), //blackCoreMaterial\n        Material(vec3(0.976,0.008,0.008), vec3(0.878,0.106,0.141), vec3(0.4), 0.2, 1.0, M_PI / 4.), //redShellMaterial\n        Material(vec3(0.000,0.000,0.000), vec3(1.000,1.000,1.000), vec3(0.4), 0.0, 1.0, M_PI / 4.) //blackShellSpotMaterial\n    );\n\n// Material indices\nint mutableMaterial  = 0;\nint standardMaterial = 1;\nint redMaterial      = 2;\nint greenMaterial    = 3;\nint blueMaterial     = 4;\nint yellowMaterial   = 5;\nint blackCoreMaterial = 6;\nint redShellMaterial = 7;\nint blackShellSpotMaterial = 8;\n\n//---\n\n// Vector roation around origin\nvoid Rotate( inout vec3 vector, vec2 angle ){\n    vector.yz = cos(angle.y) * vector.yz\n                + sin(angle.y) * vec2(-1,1) * vector.zy;\n    vector.xz = cos(angle.x) * vector.xz\n                + sin(angle.x) * vec2(-1,1) * vector.zx;\n}\n\nvec3 rotate( in vec3 vector, vec2 angle){\n    vec3 result = vector;\n    Rotate(result, angle);\n    return result;\n}\n\n//--- signed distance field - functions ---\nfloat Diff(float A, float B, inout float combined_min){\n    combined_min = min(combined_min, max(abs(A), abs(B)));\n    return max(A, -B);\n}\n\n// Coordinate transformation functions\nvec3 toHorizontal( in vec3 p ){\n    vec3 result;\n    \n    result.x = atan(p.z, p.x); // Azimuth\n    \n    result.y = atan(p.y / length(p.xz)); // Attitude\n    \n    result.z = length(p); // Distance\n    \n    return result;\n}\n\nvec3 fromHorizontal( in vec3 pol ){\n    vec3 result;\n    \n    result.x = cos(pol.x) * cos(pol.y);\n    \n    result.y = sin(pol.y);\n    \n    result.z = sin(pol.x) * cos(pol.y);\n    \n    result *= pol.z;\n    \n    return result;\n}\n\nvec3 mirrorY( in vec3 p ){\n    vec3 result = p;\n    \n    result.y = abs(p.y);\n    \n    return result;\n}\n\n// -- Geometries --\nfloat Sphere( vec3 centre, float radius, vec3 point ){\n    return length(centre-point)-radius;\n}\n\nfloat Box(vec3 pos, vec3 size, vec3 point) {\n    vec3 d = abs(point - pos) - (size / 2.0);\n    \n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat Limit(vec3 pos, vec3 dir, vec3 point ){\n    return dot(point - pos, normalize(dir));\n}\n\n// the following functions are taken 1:1 from Inigo Quilez\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.yz) - w, p.x );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// --\n//---\n\n//Target Detection, and material determination\nvoid det(inout float f, inout int m, in float dist, in int material){\n    if(dist < f){\n        f = dist;\n        m = material;\n    }\n}\n\n// The Background Function - rays that don't hit objects, will be colored according to this function\nvec3 background( in vec3 ray){\n    // Background color constants, change these to change the background appearance\n    const vec3 ground      = pow( vec3(0.251,0.180,0.133), vec3(gamma)),\n               ground_haze = pow( vec3(0.522,0.341,0.200), vec3(gamma)),\n               ground_grid = pow( vec3(0.545,0.435,0.420), vec3(gamma)),\n               sky         = pow( vec3(0.251,0.184,0.129), vec3(gamma)),\n               sky_haze    = pow( vec3(0.082,0.055,0.031), vec3(gamma)),\n               sky_grid    = pow( vec3(0., 0., 0.), vec3(gamma));\n               \n    vec2 effective_ground_plane_coord = mod(ray.xz * (-3./ray.y), vec2(1.));\n    float dist_to_grid = min(abs(effective_ground_plane_coord.y - .5),\n                             abs(effective_ground_plane_coord.x - .5));\n    \n    vec3 col = mix(ground_haze,\n                   mix(ground_grid,\n                       ground,\n                       clamp(dist_to_grid * 30.,\n                             0.,\n                             1.)\n                       ),\n                   clamp(pow(-ray.y * 4., 1.3), 0., 1.)\n                   );\n    col = mix(mix(sky_haze,\n                  sky,\n                  clamp(ray.y, 0., 1.)\n                  ),\n              col,\n              clamp(-ray.y * 70., 0., 1.)\n              );\n                   \n    return col;\n}\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( in vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n//accumulated sdf function\nfloat Scene( in vec3 pos, inout int material, out float combined_min){\n    combined_min = INF;\n    #define D(dist, mat) det(f, material, dist, mat)\n    float f = INF;\n    \n    float shell_d = 0.95;\n    \n    vec3 ladyball_pos = pos;\n    //ladyball_pos += vec3(0., 0., 1.); //Offset for VR\n    Rotate(ladyball_pos, vec2(0., iTime*1.9));\n    \n    \n    D(\n        min(\n            Diff(\n                sdPie(opRevolution(ladyball_pos, 0.).yx, vec2(sin(M_PI/4.), cos(M_PI/4.)), shell_d),\n                ladyball_pos.z,\n                combined_min\n            ),\n            sdSolidAngle(\n                mirrorY(ladyball_pos),\n                vec2(sin(M_PI/4.), cos(M_PI/4.)),\n                shell_d\n            )\n        )-0.1,\n        redShellMaterial\n    );\n    \n    D( Sphere(vec3(0), 1., ladyball_pos), blackCoreMaterial);\n    \n    D( sdEllipsoid(ladyball_pos - vec3(0., 1. ,0.), vec3(0.4, 0.07, 0.4)), blackShellSpotMaterial);\n    \n    D( sdEllipsoid(rotate((ladyball_pos), vec2(0., -M_PI*0.3)) - vec3(0., 1. ,0.) , vec3(0.3, 0.07, 0.3)), blackShellSpotMaterial);\n    \n    D( sdEllipsoid(rotate((ladyball_pos), vec2(0., -M_PI*0.52)) - vec3(0., 1. ,0.) , vec3(0.2, 0.07, 0.2)), blackShellSpotMaterial);\n    \n    /*\n    // Axis indication spheres\n    pos += vec3(2, 2, 2);\n    D( Sphere(vec3(0, 0, 0), 0.1, pos), yellowMaterial);\n    D( Sphere(vec3(1, 0, 0), 0.1, pos), redMaterial);\n    D( Sphere(vec3(0, 1, 0), 0.1, pos), greenMaterial);\n    D( Sphere(vec3(0, 0, 1), 0.1, pos), blueMaterial);\n    */\n    return f;\n    #undef D\n}\n\n//calculating the surface normal/normalized field gradient - numerically\nvec3 get_normal(in vec3 pos){\n    vec3 normal;\n    int mat; //hacky - only needed to match the function signature\n    float combined_min; //hacky +1 - but should be optimized away anyways\n    normal.x = Scene(pos + vec3(numGradStep, 0, 0), mat, combined_min);\n    normal.y = Scene(pos + vec3(0, numGradStep, 0), mat, combined_min);\n    normal.z = Scene(pos + vec3(0, 0, numGradStep), mat, combined_min);\n    normal -= vec3(Scene(pos, mat, combined_min));\n    normal = normalize( normal ); //this makes distored (e.g. smooth) SDFs possible\n    return normal;\n}\n\nfloat light_reachable(vec3 pos, Light light, float dist_per_pix){\n    float intensity = 1.;\n    \n    vec3  light_diff_vec  = light.pos - pos;\n    float light_diff_dist = length(light_diff_vec),\n          trav_length     = 0.,\n          min_h           = INF;\n    vec3  ray             = normalize(light_diff_vec);\n    int mat; //currently unused, could be used for transparent objects\n    //path marching to light\n    for(int i = 0; i < 500; i++){\n        float combined_min; //only needed to match the function signature of Scene\n        float h = Scene( pos, mat , combined_min);\n        \n        if(h > min_h){\n            if(FAKE_SOFT_SHADOWS){\n                float shadow_width = light.size * ( trav_length / (light_diff_dist - trav_length));\n\n                intensity *= clamp((min_h * (light_diff_dist / (light_diff_dist - trav_length))) / shadow_width,\n                                   0., 1.);\n                min_h = INF;\n            }else if(SHADOW_NEAR_MISS_AA){\n                float local_dist_per_pix = dist_per_pix * ((light_diff_dist - trav_length) / light_diff_dist);\n                float miss_factor = (min_h - shadowDistThresh) / local_dist_per_pix;\n                intensity *= min(miss_factor, 1.);\n            }\n            \n            min_h = INF;\n        }\n        \n        //Fake Smooth Shadows\n        if(FAKE_SOFT_SHADOWS || NEAR_MISS_ANTI_ALIASING){\n            min_h = min(min_h, h);\n        }\n        \n        //Overshoot Detection\n        trav_length += h;\n        if( trav_length >= light_diff_dist)\n            break;\n        \n        //Collision Detection\n        if( h < shadowDistThresh){\n            intensity = 0.;\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    return intensity;\n}\n\nvoid mainMarch( out vec4 fragColor,\n                in vec3 pos,\n                in vec3 ray,\n                in float unit_dist_per_pix,\n                in float perspectiveness,\n                in vec3 image_plane_vertical,\n                in vec3 image_plane_horizontal,\n                in vec3 image_plane_normal\n                ){\n    \n    vec3 start_pos = pos;\n    \n    //constant background color/fragment color initialization goes here\n\tfragColor.rgb = vec3(1.);\n    \n    //-- edge detection values -- //TODO: check what values are still used\n    bool collided = false,\n         pixel_dist_near_miss = false;\n    vec3 pixel_dist_near_miss_color;\n    float near_miss_pixel_ratio = 1.,\n          min_h = INF,\n          h = INF, //elevation from nearest surface (Distance)\n          trav_dist = 0.;\n    int material_ind = standardMaterial;\n    //--\n    //main marching loop\n    int i; //declared outside to be used for BAILOUT_SPECIAL_COLOR\n    //       ↓ number of steps before bailout\n    for (i = MAX_STEPS; i > 0; i--){\n        float combined_min; //Variable to store the combined minimum of bool operations\n        h = Scene(pos, material_ind, combined_min);\n        \n        float dist_thresh = base_dist_thresh;\n        if( DISTANCE_GROWING_THRESH )\n            dist_thresh *= trav_dist;\n        \n        bool pixel_dist_near_miss_on_this_pass = false;\n        if(h > min_h){ //Code to run on detection of a near miss - TODO: antialiasing\n            float local_dist_per_pix = unit_dist_per_pix *\n                                       (\n                                           (1. - perspectiveness) +\n                                           perspectiveness * distance(start_pos, pos)\n                                       );\n            if((min_h - dist_thresh) < local_dist_per_pix * float(EDGE_WIDTH) && DRAW_NEAR_MISS_EDGES){\n                fragColor.rgb = EDGE_COLOR;\n                return;\n            }\n            if((min_h - dist_thresh) < local_dist_per_pix && !pixel_dist_near_miss && NEAR_MISS_ANTI_ALIASING){\n                near_miss_pixel_ratio = (min_h - dist_thresh) / local_dist_per_pix;\n                pixel_dist_near_miss_on_this_pass = true;\n                pixel_dist_near_miss = true;\n            }\n            //resetting min_h\n            min_h = INF;\n        }\n        min_h = min(min_h, h);\n        \n        //Declarations for Cutview, should be optimized out if not used\n        vec3 cut_norm, cut_pos;\n        float cut_dist, pre_cut_h;\n        if(CUTVIEW) {\n            cut_norm = normalize(vec3(0., 0., -1.));\n            cut_pos  = vec3(0., 0., 0.);\n            cut_pos += 1. * sin(iTime/6.) * cut_norm;\n            cut_dist = Limit(cut_pos, cut_norm, pos);\n            pre_cut_h = h;\n            float dummy_combined_min;\n            h = Diff(h, cut_dist, dummy_combined_min);\n        }\n        \n        //Surface hit\n        if (    h < dist_thresh \n             || (pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING) \n           ){\n            // -- debug bailouts --\n            if(SHOW_COLLISION_DISTANCE){ //debug show distance from camera to collision point\n                fragColor.rgb = vec3(h / dist_thresh, 0, 0);\n                break;\n            }\n               \n            if(SHOW_CYCLES){ //debug show cycle count at collision point\n                fragColor.rgb = vec3(1. - 1./(1. + 0.01*(float(MAX_STEPS - i) + h / dist_thresh) ));\n                return;\n            }\n            \n            vec3 normal = get_normal(\n                                      (   pixel_dist_near_miss_on_this_pass //if this is a near miss anti aliasing pass\n                                       && NEAR_MISS_ANTI_ALIASING           //walk back a bit before determining the normal\n                                       ? pos - (ray + image_plane_vertical) * 3.5 * h               //to actually sample the correct surface\n                                       : pos\n                                      )\n                                    );\n            if(SHOW_NORMAL){ //debug show normal at collision point as color\n                fragColor.rgb = 0.5 +  0.5 * normal;\n                break;\n            }\n            // --\n            \n            //TODO: eliminate this duplicate\n            float local_dist_per_pix = unit_dist_per_pix *\n                                   (\n                                       (1. - perspectiveness) +\n                                       perspectiveness * distance(start_pos, pos)\n                                   );\n            \n            //inside edge detection - TODO: antialiasing\n            if( DRAW_INSIDE_EDGES && !(pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING) ){\n                int dummy_mat;\n                \n                float surface_projected_local_dist_per_pix =\n                        local_dist_per_pix;\n                                       \n                float inside_edge_detection_dist = EDGE_WIDTH * surface_projected_local_dist_per_pix + dist_thresh;\n                \n                float dummy_combined_min;\n                \n                if(Scene(pos + normal * (dist_thresh + inside_edge_detection_dist), dummy_mat, dummy_combined_min)\n                   < inside_edge_detection_dist){\n                    fragColor.rgb = EDGE_COLOR;\n                    return;\n                }\n            }\n            \n            //edge detections for outside edges that are the result of a bool operation\n            if(    DRAW_BOOL_EDGES\n                && combined_min - dist_thresh < EDGE_WIDTH * local_dist_per_pix\n              ){\n                fragColor.rgb = EDGE_COLOR;\n                return;\n            }\n            \n            // copying over the actual material that is to be evlauated\n            Material material = materials[material_ind];\n            \n            if(CUTVIEW && cut_dist < dist_thresh){\n                fragColor.rgb = material.color_diffuse;\n                if(pre_cut_h > -0.01 * ((1. - abs(dot(normal, cut_norm))) / (-pre_cut_h)) ){\n                    fragColor.rgb = vec3(0.);\n                }else{\n                    //vec2 stripe_normal = vec2(0.707 * cos(material.stripe_rot),\n                    //                          0.707 * sin(material.stripe_rot));\n                    vec3 stripe_normal =   cos(material.stripe_rot) * image_plane_horizontal\n                                         + sin(material.stripe_rot) * image_plane_vertical;\n                    //float stripe_d = dot(stripe_normal, uv.xy);\n                    float stripe_d = dot(pos - cut_pos, stripe_normal);\n                    if(mod(stripe_d, 0.1 / material.stripe_dens) < 0.01){\n                        fragColor.rgb = vec3(0.);\n                    }\n                }\n            } else if(DO_LIGHTING) {\n                //--- lighting calculations ---\n                bool do_specular = material.roughness < 1. && SPECULAR_LIGHT_SOURCES;\n                vec3 diffuse  = vec3(0.0),\n                     specular = vec3(0.0);\n                for(int lightsInd = 0; lightsInd < lightsListLength; lightsInd++){\n                    Light lightSrc = lightsList[lightsInd];\n                    //detect if the light is reachable from the current position\n                    //                                             ↓ done so it doesn't collide with originator\n                    float light_intensity = light_reachable( pos + normal * shadowDistThresh * 2., lightSrc, local_dist_per_pix);\n                    \n                    vec3 to_light = lightSrc.pos - pos;\n                    vec3 to_light_normalized = normalize(to_light);\n                    float light_strength = light_intensity * (LIGHTING_DISTANCE_FADE ? \n                                            10.0 / pow(length(to_light), 2.0)\n                                            : 1.);\n                    //Diffuse Calculation\n                    diffuse += lightSrc.color * light_strength\n                               * max(0., dot(normal, to_light_normalized));\n\n                    //Specular Calculation\n                    if( do_specular ){\n                        vec3 a = normal * dot(normal, -ray);\n                        vec3 reflected_ray = normalize(a + a -(-ray));\n                        specular += lightSrc.color * light_strength\n                                    * clamp(1. - 100./(1. + lightSrc.size)\n                                            * (1. - dot(to_light_normalized, reflected_ray)),\n                                            0., 1.);\n                    }\n                }\n                //---\n\n                //determining amount of sideglow (added light at low angle of incident)\n                float sideglow = ambient_light * clamp(1. - dot(normal, -ray), 0., 1.);\n                sideglow *= 1.8;\n\n                //--- final color determination ---\n                fragColor.rgb = material.color_diffuse*\n                                mix(max(\n                                        vec3(ambient_light),\n                                        sideglow\n                                       ), vec3(1.), diffuse);\n                if( do_specular ){\n                    fragColor.rgb += specular * material.color_specular * (1. - material.roughness);\n                }\n                \n                //alternative color determination -- outdated without specular\n                //fragColor.rgb = vec3((0.2 + diffuse) * material.color_diffuse * (1.0 - sideglow)\n                //                     + sideglow * material.color_sideglow);\n                //---\n            } else { // Branch to take if lighting based shading is disabled\n                mat3 view_relative = mat3(image_plane_horizontal, image_plane_vertical, image_plane_normal);\n                fragColor.rgb = material.color_diffuse\n                                * (ambient_light + (1. - ambient_light) *\n                                   max(\n                                       //Light always coming from top right, slightly towards the camera\n                                       clamp(dot(normal, view_relative * vec3(0.4, 1., -0.3)), 0., 1.),\n                                       //Low Angle of Incident — Sideglow\n                                       ambient_light * 2. * clamp(1. - dot(normal, -ray), 0., 1.)\n                                       ));\n            }\n            \n            if(pixel_dist_near_miss_on_this_pass && NEAR_MISS_ANTI_ALIASING){\n                pixel_dist_near_miss_color = fragColor.rgb;\n            }else{\n                collided = true;\n                break;\n            }\n        }\n        \n        // setting the new position\n        if( STEPPING_SLOWDOWN )\n            h *= .8;\n        pos += ray * h;\n        trav_dist += h;\n        \n        // Distance from camera bailout\n        if(distance(pos, start_pos) > bailout_cam_dist){\n            if(BAILOUT_SPECIAL_COLOR)\n                fragColor.rgb = vec3(0., 0., 1.);\n            if(SHOW_CYCLES)\n                fragColor.rgb = (float(MAX_STEPS - i) / 100.) * vec3(1.0,0.4,0.2);\n            break;\n        }\n    }\n    \n    if(!collided && !SHOW_CYCLES && !SHOW_NORMAL && !BAILOUT_SPECIAL_COLOR && !SHOW_COLLISION_DISTANCE)\n        fragColor.rgba = vec4(background(ray), 0.);\n    \n    if(BAILOUT_SPECIAL_COLOR && i <= 0)\n        fragColor.rgb = vec3(1., 0., 0.);\n    \n    //mixing color of near miss, and actual destination color -- for Anti Aliasing\n    if(NEAR_MISS_ANTI_ALIASING)\n        fragColor.rgb = mix(pixel_dist_near_miss_color, fragColor.rgb, near_miss_pixel_ratio);\n    \n    //Gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/gamma) );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.y) * 2.0 - vec2((iResolution.x / iResolution.y), 1.0);\n    //override 3D - draw mouse controlled cross section of field values\n    if(FIELD_CROSS_SECTION){\n        float z_plane = 0.0;\n        if(iMouse.z > 0.0){\n            z_plane = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * 4.0;\n        }\n        int dummyMat;\n        float dummy_combined_min;\n        float sdf = Scene(vec3(uv * 4.0, z_plane), dummyMat, dummy_combined_min);\n        fragColor.rgb = (sdf >= 0.0 ? vec3(sdf) : vec3(-sdf, 0.0, 0.0));\n        return;\n    }\n    //actual normal 3d rendering\n    \n    //--- Ray and Camera calculation ---\n    //ray starting position offset for smooth perspective to othographic transition\n    float view_size = 1.2,\n          perspectiveness = sin(iTime/3.0)/ 2.0 + 0.5,\n          image_plane_distance = 1.;\n    perspectiveness = 1.0;\n    \n    vec2 camera_origin_shift = vec2(0.) * image_plane_distance;\n    //marching starts on a projection plane scaled by orthagonal view width\n    //and (1-perspectiveness) - which means that the rays of all fragments originate\n    //from the same point with a perspectiveness of 1\n    vec3 start_offset = vec3( (fragCoord - iResolution.xy * 0.5) * view_size * (1.0-perspectiveness) / iResolution.x, 0.0);\n    //ray to march on                                                    ↓ Projection Plane Distance (Modifying this will modyfy the FOV, but also bug out the AA)\n    //this is the direction of the start_offset to the same plane, set off by 1 on z and not scaled by 1-perspectiveness\n    vec3 ray =\n        vec3(\n             (fragCoord - iResolution.xy * 0.5)  * view_size / iResolution.x,\n              image_plane_distance\n            )\n        - (start_offset + vec3(camera_origin_shift, 0.));\n    //Approximated arc Length per pixel at unit sphere from starting point\n    float unit_dist_per_pix = view_size / (iResolution.x * length(ray));\n    //normalization of ray to length 1\n    ray = normalize(ray);\n    //starting camera position\n    vec3 pos = vec3( 0., 0.,-5.) + start_offset;\n    \n    //camera offset for horizontal scanline 3D\n    if(THREE_D && mod( fragCoord.y, 2.0 ) < 1.0)\n    \tpos += vec3(0.2, 0, 0);\n        \n    //helper vectors for shading\n    vec3 image_plane_vertical   = vec3(0., 1., 0.),\n         image_plane_horizontal = vec3(1., 0., 0.),\n         image_plane_normal     = vec3(0., 0., 1.);\n\n    //rotating the camera around the origin\n    vec2 angle = vec2(iTime * 0.2, 0.1);\n    //angle = vec2((M_PI / 2.) * 1., 0.);\n\n    if (MOUSECONTROL && iMouse.z >= 0.0  && iMouse.xyz != vec3(0)) angle = (iMouse.xy / iResolution.xy - 0.5) * 6.6;\n    \n    Rotate( pos, angle );\n    Rotate( ray, angle );\n    Rotate( image_plane_vertical,   angle );\n    Rotate( image_plane_horizontal, angle );\n    Rotate( image_plane_normal,     angle );\n    \n    //---\n    \n    mainMarch( fragColor, pos, ray, unit_dist_per_pix, perspectiveness, image_plane_vertical, image_plane_horizontal, image_plane_normal );\n    \n    //Dithering\n    if( DO_DITHERING )\n        fragColor.rgb += vec3(InterleavedGradientNoise(fragCoord.xy)/255.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    mainMarch( fragColor,\n               3. * fragRayOri,\n               normalize(fragRayDir),\n               0., // Dist per pix\n               1., // Perspectiveness (assuming hole camera model\n               vec3(0., 1., 0.),\n               vec3(1., 0., 0.),\n               vec3(0., 0., 1.)\n             );\n    //Dithering\n    if( DO_DITHERING )\n        fragColor.rgb += vec3(InterleavedGradientNoise(fragCoord.xy)/255.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}