{
    "Shader": {
        "info": {
            "date": "1716332995",
            "description": "ray marching fractal\nclick mouse to start.\n\nCross-eyed 3D\nSit as far back from the screen as possible\nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n",
            "flags": 48,
            "hasliked": 0,
            "id": "MXcGWr",
            "likes": 1,
            "name": "cycle3 v2",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 106
        },
        "renderpass": [
            {
                "code": "/*\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<X>   : toggle animation\n<I>   : toggle spherical inversion\n<S>   : toggle cross eyed stereo\n<Q>   : toggle secondSurface\n<W>   : toggle secondSurface refract vs reflect\n<Spc> : reset\n\nNote: hold down <Shift> then drag mouse to affect camera.xy regardless of focus.\nNote: hold down <Alt><Shift> then drag mouse to affect aim.xy regardless of focus.\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n\nWidgets --------------------------------------\nraymarching DE() params : listed at top of Dataset structure just below\ncamera position and aim : cameraX,Y,Z;  aimX,Y,Z\nspherical inversion     : position-> InvPosX,Y,Z; radius-> InvRad; angle-> InvAngle\nsecondsurface           : distance-> SSdist; angle-> Sangle; amount-> Samount; mix-> SSmix\nphong lighting          : color-> PhoColR,G,B; position-> PhoPosX,Y,Z; diffuse-> PhoDiff; specular-> PhoSpec; ambient-> PhoAmb\nspotl light             : strength-> SpotV; location-> SpotX,Y; exponent-> SpotE; color-> SpotR,G,B\norbit trapping          : strength-> OrbitS; cycle-> OrbitC, weight&color-> OwhtX,OcolX (same for Y,Z,W); center-> OcntX,Y,Z\n---------------------------------------------\n\n<S> Cross-eyed 3D\nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n\n<Q>,<W> Second Surface\nRaymarching algorithm calculates a unique \"ray\" from the camera to every pixel of the image.\nRaymarching algorithm \"marches\" along each ray, until the DE() function says to go no farther.\nWhen \"second surface\" is enabled we ask the raymarching to continue past the first stopping point,\nto instead continue marching until a second (or third,fourth) stopping point is reached,\nthereby exposing objects inside the original surface.\nssDistance : how far to jump ahead on the ray before beginning the search for the second surface.\nssAngle    : how much to change the aim of the ray before continuing\nssAmount   : if refraction is enabled ( <W> toggle), how much to refract the ray before continuing\nssMix      : how to blend the color of the 1st surface vs. the second.\n\nbased on: https://openprocessing.org/sketch/1665774\n*/\n\n// DE() params\nfloat scale,fixedRadius,minRadius;\nfloat boxFold,bfDelta;\nfloat sphereFold,sfDelta;\nvec3 julia;\nbool juliaMode;\n\nvec3 camera,aim;\n\nvec3 invpos;\nfloat invradius;\nfloat invangle;\n\nvec3 phongColor;\nvec3 phongPosition;\nvec3 phongParam; // diffuse, specular, ambient\n\nfloat spotLight;      // strength\nvec3 spotLightData;  // x,y,exp\nvec3  spotLightColor; // rgb\n\nint maxsteps;\nint ssIterations;\nfloat ssDistance,ssAngle,ssAmount,ssMix;\nfloat epsilon;\nfloat ambient,contrast,vibrant,dim;\nfloat fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n\nfloat Ostrength; // 0.0 -> disable orbit trapping\nfloat Ocycle;\nfloat OXwt,OXcr; // weight, color code\nfloat OYwt,OYcr;\nfloat OZwt,OZcr;\nfloat OWwt,OWcr;\nvec3  Ocenter;   // origin offset\n\nfloat parallax;  // adjust for best stereo effect 0 ... 0.2\n\n// calculated params\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\nint focus,row,displayCount;\nbool animationEnable,stereoEnable,inversionEnable,secondsurfaceEnable,refractEnable;\nvec3 viewVector,sideVector,topVector;\n\n// --------------------------------------------------------\n\nvoid fold(inout vec3 pos, float value) {\n         float v2 = value * 2.0;\n         if (pos.x > value) pos.x = v2 - pos.x; else if (pos.x < -value) pos.x = -v2 - pos.x;\n         if (pos.y > value) pos.y = v2 - pos.y; else if (pos.y < -value) pos.y = -v2 - pos.y;\n         if (pos.z > value) pos.z = v2 - pos.z; else if (pos.z < -value) pos.z = -v2 - pos.z;\n}\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos) {\n    vec3 ot, c = juliaMode ? julia : pos;\n    float d,r2,DEfactor = scale;\n    float fR2 = fixedRadius * fixedRadius * scale;\n    float mR2 = minRadius * minRadius * scale;\n    float fR2mR2 = fR2 / mR2;\n    float bf = boxFold;\n    float sf = sphereFold;\n\n    for(int i = 0; i < 100; ++i) {\n        if(i >= maxsteps) break;\n\n        fold(pos,r2 < fR2 ? sf : bf);\n        bf += bfDelta;\n        sf += sfDelta;\n\n        r2 = pos.x*pos.x + pos.y*pos.y + pos.z*pos.z;\n\n        if (r2 < mR2) {\n            pos *= fR2mR2;\n            DEfactor *= fR2mR2;\n        }\n        else if (r2 < fR2) {\n            d = fR2 / r2;\n            pos *= d;\n            DEfactor *= d;\n        }\n\n        pos *= scale;\n        pos += c;\n        DEfactor *= scale;\n\n        if(i > 3) {\n            ot = pos - Ocenter;\n            orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n        }\n    }\n   \n    return length(pos)/abs(DEfactor);\n}\n\n// --------------------------------------------------------\n// distance estimation function wrapped by spherical inversion code.\n\nfloat DE_plusSpherical(vec3 pos) {\n    if(inversionEnable) {\n        pos = pos - invpos;\n        float r = length(pos);\n        float r2 = r*r;\n        float radius2 = invradius * invradius;\n        pos = (radius2 / r2) * pos + invpos;\n        \n        float an = atan(pos.y,pos.x) + invangle;\n        float ra = length(pos.xy);\n        pos.x = cos(an) * ra;\n        pos.y = sin(an) * ra;\n                \n        float de = DE(pos);\n        return r2 * de / (radius2 + r * de);\n    }\n    \n    return DE(pos);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n    if(weight == 0.0) return vec3(0.0);\n\n    x = cos(x);\n    //x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n    float r = (1.0-x)*(1.0-x);\n    float g = x*x;\n    float b = 2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(Ocycle,generateColor(OXwt,OXcr), orbitTrap.x) * OXwt * orbitTrap.x +\n        orbitTrapCycle(Ocycle,generateColor(OYwt,OYcr), orbitTrap.y) * OYwt * orbitTrap.y +\n        orbitTrapCycle(Ocycle,generateColor(OZwt,OZcr), orbitTrap.z) * OZwt * orbitTrap.z +\n        orbitTrapCycle(Ocycle,generateColor(OWwt,OWcr), orbitTrap.w) * OWwt * orbitTrap.w;\n    } else {\n        orbitColor =\n            generateColor(OXwt,OXcr) * OXwt * orbitTrap.x +\n            generateColor(OYwt,OYcr) * OYwt * orbitTrap.y +\n            generateColor(OZwt,OZcr) * OZwt * orbitTrap.z +\n            generateColor(OWwt,OWcr) * OWwt * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\nvec3 spotLighting() {\n    const float PI = 3.141592654;\n    float a1 = spotLightData.x * PI;\n    float a2 = spotLightData.y * PI * 0.5;\n    float s1 = sin(a1);\n    vec3 spotDir = vec3(s1 * cos(a2), s1 * sin(a2), cos(a1));\n    spotDir = normalize(spotDir);\n    vec3 halfVector = normalize(spotDir - direction);\n\n    float nDotL = max(0., dot(normal, spotDir));\n    float hDotN = max(0., dot(normal, halfVector));\n\n    float exp = spotLightData.z;\n    return spotLight * spotLightColor * ((exp + 2.) / 2.) * pow(hDotN, exp)\n        * (exp + (1. - exp) * pow(1. - hDotN, 5.)) * nDotL * spotLight;\n}\n\nvec3 phongLighting() {\n    vec3 L = normalize(phongPosition - position);\n    float dotLN = dot(L, normal);\n    if (dotLN < 0.0)\n        return vec3(0.);\n        \n    float t1 = phongParam.x * dotLN;\n\n    vec3 V = normalize(camera - position);\n    vec3 R = normalize(reflect(-L, normal));\n    float dotRV = dot(R, V);\n\n    if (dotRV < 0.0)\n        return vec3(phongColor * t1);\n\n    float t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n    return phongColor * (t1 + t2);\n}\n\nvoid applyColoring() {\n    color = vec3(ambient) + vec3(1.0 - (normal * vibrant + sqrt(float(iter) * dim)));\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast;\n    \n    if(length(phongColor) > 0.0)\n        color += phongLighting();\n    if(spotLight > 0.)\n        color += spotLighting();\n        \n    if(Ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, Ostrength);\n    }\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal() {\n    float ex = epsilon;\n    float ey = -ex;\n    vec3 pos = position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE(t1);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE(t2);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE(t3);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE(t4);\n\n    normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n// viewVectors already calculated in Buffer A\n\nvoid setDirection(vec2 fragCoord) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(stereoEnable) {\n        vec3 soffset = sideVector * parallax;\n        xsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n            srcP.x -= xsize;      // base 0  X coordinate\n            camera -= soffset;// adjust for right side parallax\n        }\n        else {\n            camera += soffset;// adjust for left side parallax\n        }\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 10.0;\n\nvoid rayMarch() {\n    vec3 position = camera;\n    float distance;\n    iter = 0;\n    depth = MIN_DIST;\n    \n    for(int i = 0;i < 50;++i) {\n        distance = DE_plusSpherical(position);\n        if(abs(distance) < MIN_DIST || depth > MAX_DIST) break;\n        iter += 1;\n        \n        depth += distance;\n        position = camera + direction * depth;\n  }\n}\n\n// --------------------------------------------------------\n\nvoid displayData(inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.3) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.95) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(30,30);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.7, 1) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n\n    declString(gap, 1, (cSp));\n\n    String str;\n    float value = 0.;\n    \n    \n        float scale,fixedRadius,minRadius;\n    float boxFold,bfDelta;\n    float sphereFold,sfDelta;\n    bool juliaMode;\n    vec3 julia;\n    \n\n    switch(focus) {\n        case  0 : setString(str,5,(cS,cc,ca,cl,ce)); value = scale; break;\n        case  1 : setString(str,11,(cF,ci,cx,ce,cd,cR,ca,cd,ci,cu,cs)); value = fixedRadius; break;\n        case  2 : setString(str, 9,(cM,ci,cn,cR,ca,cd,ci,cu,cs)); value = minRadius; break;\n        case  3 : setString(str,7,(cb,co,cx,cF,co,cl,cd)); value = boxFold; break;\n        case  4 : setString(str,7,(cb,cf,cD,ce,cl,ct,ca)); value = bfDelta; break;\n        case  5 : setString(str,10,(cs,cp,ch,ce,cr,ce,cF,co,cl,cd)); value = sphereFold; break;\n        case  6 : setString(str,7,(cs,cf,cD,ce,cl,ct,ca)); value = sfDelta; break;\n        case  7 : setString(str,6,(cJ,cu,cl,ci,ca,cX)); value = julia.x;  break;\n        case  8 : setString(str,6,(cJ,cu,cl,ci,ca,cY)); value = julia.y;  break;\n        case  9 : setString(str,6,(cJ,cu,cl,ci,ca,cZ)); value = julia.z;  break;\n\n        case 18 : setString(str,7,(cC,ca,cm,ce,cr,ca,cX)); value = camera.x; break;\n        case 19 : setString(str,7,(cC,ca,cm,ce,cr,ca,cY)); value = camera.y; break;\n        case 20 : setString(str,7,(cC,ca,cm,ce,cr,ca,cZ)); value = camera.z; break;\n        case 21 : setString(str,4,(cA,ci,cm,cX)); value = aim.x; break;\n        case 22 : setString(str,4,(cA,ci,cm,cY)); value = aim.y; break;\n        case 23 : setString(str,4,(cA,ci,cm,cZ)); value = aim.z; break;\n        case 24 : setString(str,7,(cI,cn,cv,cP,co,cs,cX)); value = invpos.x; break;\n        case 25 : setString(str,7,(cI,cn,cv,cP,co,cs,cY)); value = invpos.y; break;\n        case 26 : setString(str,7,(cI,cn,cv,cP,co,cs,cZ)); value = invpos.z; break;\n        case 27 : setString(str,6,(cI,cn,cv,cR,ca,cd)); value = invradius; break;\n        case 28 : setString(str,8,(cI,cn,cv,cA,cn,cg,cl,ce)); value = invangle; break;\n\n        case 29 : setString(str,6,(cS,cS,cd,ci,cs,ct)); value = ssDistance; break;\n        case 30 : setString(str,7,(cS,cS,ca,cn,cg,cl,ce)); value = ssAngle; break;\n        case 31 : setString(str,8,(cS,cS,ca,cm,co,cu,cn,ct)); value = ssAmount; break;\n        case 32 : setString(str,5,(cS,cS,cm,ci,cx)); value = ssMix; break;\n\n        case 33 : setString(str,7,(cP,ch,co,cC,co,cl,cR)); value = phongColor.x; break;\n        case 34 : setString(str,7,(cP,ch,co,cC,co,cl,cG)); value = phongColor.y; break;\n        case 35 : setString(str,7,(cP,ch,co,cC,co,cl,cB)); value = phongColor.z; break;\n        case 36 : setString(str,7,(cP,ch,co,cP,co,cs,cX)); value = phongPosition.x; break;\n        case 37 : setString(str,7,(cP,ch,co,cP,co,cs,cY)); value = phongPosition.y; break;\n        case 38 : setString(str,7,(cP,ch,co,cP,co,cs,cZ)); value = phongPosition.z; break;\n        case 39 : setString(str,7,(cP,ch,co,cD,ci,cf,cf)); value = phongParam.x; break;\n        case 40 : setString(str,7,(cP,ch,co,cS,cp,ce,cc)); value = phongParam.y; break;\n        case 41 : setString(str,6,(cP,ch,co,cA,cm,cb)); value = phongParam.z; break;\n\n        case 42 : setString(str,5,(cS,cp,co,ct,cV)); value = spotLight; break;\n        case 43 : setString(str,5,(cS,cp,co,ct,cX)); value = spotLightData.x; break;\n        case 44 : setString(str,5,(cS,cp,co,ct,cY)); value = spotLightData.y; break;\n        case 45 : setString(str,5,(cS,cp,co,ct,cE)); value = spotLightData.z; break;\n        case 46 : setString(str,5,(cS,cp,co,ct,cR)); value = spotLightColor.x; break;\n        case 47 : setString(str,5,(cS,cp,co,ct,cG)); value = spotLightColor.y; break;\n        case 48 : setString(str,5,(cS,cp,co,ct,cB)); value = spotLightColor.z; break;\n\n        case 49 : setString(str,6,(cO,cr,cb,ci,ct,cS)); value = Ostrength; break;\n        case 50 : setString(str,6,(cO,cr,cb,ci,ct,cC)); value = Ocycle; break;\n        case 51 : setString(str,5,(cO,cw,ch,ct,cX)); value = OXwt; break;\n        case 52 : setString(str,5,(cO,cc,co,cl,cX)); value = OXcr; break;\n        case 53 : setString(str,5,(cO,cw,ch,ct,cY)); value = OYwt; break;\n        case 54 : setString(str,5,(cO,cc,co,cl,cY)); value = OYcr; break;\n        case 55 : setString(str,5,(cO,cw,ch,ct,cZ)); value = OZwt; break;\n        case 56 : setString(str,5,(cO,cc,co,cl,cZ)); value = OZcr; break;\n        case 57 : setString(str,5,(cO,cw,ch,ct,cW)); value = OWwt; break;\n        case 58 : setString(str,5,(cO,cc,co,cl,cW)); value = OWcr; break;\n        case 59 : setString(str,5,(cO,cc,cn,ct,cX)); value = Ocenter.x; break;\n        case 60 : setString(str,5,(cO,cc,cn,ct,cY)); value = Ocenter.y; break;\n        case 61 : setString(str,5,(cO,cc,cn,ct,cZ)); value = Ocenter.z; break;\n    }\n\n    printInt(focus+1,t);\n    printString(gap,t);\n    printString(str,t);\n    printString(gap,t);\n    printFloat(value, t);\n    drawText(t, iChannel3, fragColor);\n}\n\n// animation routines ----------------------------------------\n\nvoid cycleValue(int pDataIndex,inout float value, float vmin,float vmax, float speed) {\n    float ratio = 0.5 + 0.5 * cos(iTime * speed);  // 0 ... 1\n    value = clamp(vmin + (vmax - vmin) * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);\n}\n\nvoid cycleValue2(int pDataIndex,inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = clamp(baseValue-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);\n}\nvoid cycleValue2b(int pDataIndex,inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + sin(iTime * speed);  // 0 ... 2\n    value = clamp(baseValue-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);\n}\n\nvoid cycleValue3(int pDataIndex,inout float value, float baseValue, float amount, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    float deviation = baseValue * amount * 0.5;\n    value = clamp(baseValue-deviation + deviation * ratio,pData[pDataIndex].vmin, pData[pDataIndex].vmax);\n}\n\nvoid cycleValue3Vec3(int pDataIndex,inout vec3 value, vec3 baseValue, float amount, float speed) {\n    for(int i=0;i<3;++i)\n        cycleValue3(pDataIndex+i,value[i],baseValue[i],amount,speed);\n}\n\n// ----------------------------------------------------\n\nvoid changeAim() {\n    cycleValue2(indexAim,aim.x,-1.0,8.0, 0.3);\n    cycleValue2(indexAim+1,aim.y,0.0,8.0, 0.4);\n    cycleValue2(indexAim+2,aim.z,0.0,8.0, 0.5);\n}\n    \nvoid alterPhongLight() {\n   cycleValue(indexPhong,phongColor.x,0.,5.,0.3);\n   cycleValue(indexPhong+1,phongColor.y,0.,5.,0.4);\n   cycleValue(indexPhong+2,phongColor.z,0.,5.,0.5);\n   \n   const float dist = 1.0;\n   cycleValue(indexPhong+3,phongPosition.x,-dist,dist,0.3);\n   cycleValue(indexPhong+4,phongPosition.y,-dist,dist,0.35);\n   cycleValue(indexPhong+5,phongPosition.z,-dist,dist,0.4);\n   \n   cycleValue(indexPhong+6,phongParam.x,0.,1.,0.2); // diffuse\n   cycleValue(indexPhong+7,phongParam.y,0.,1.,0.3); // specular\n   cycleValue(indexPhong+8,phongParam.z,5.,10.,0.4); // ambient\n}\n\nvoid alterSpotLight() {\n   cycleValue2(indexSpot,spotLight,spotLight,1.,0.03);\n   cycleValue2(indexSpot+1,spotLightData.x,spotLightData.x,15.,0.01);\n   cycleValue2(indexSpot+2,spotLightData.y,spotLightData.y,15.,0.02);\n   cycleValue2(indexSpot+3,spotLightData.z,spotLightData.z,3.,0.004 );\n   cycleValue2(indexSpot+4,spotLightColor.x,spotLightColor.x,0.5,0.03);\n   cycleValue2(indexSpot+5,spotLightColor.y,spotLightColor.y,0.5,0.04);\n   cycleValue2(indexSpot+6,spotLightColor.z,spotLightColor.z,0.5,0.05);\n}\n\nvoid alterOrbitColors() {\n    const float weight = 2.;\n    cycleValue(indexOrbit+2,OXwt,-weight,weight,0.2); // weights\n    cycleValue(indexOrbit+4,OYwt,-weight,weight,0.3);\n    cycleValue(indexOrbit+5,OZwt,-weight,weight,0.5);\n //   cycleValue(indexOrbit+8,OWwt,-weight,weight,0.07);\n\n    const float color = 2.0;\n    cycleValue(indexOrbit+3,OXcr,-color,color,0.1);  // color code\n    cycleValue(indexOrbit+5,OYcr,-color,color,0.2);\n    cycleValue(indexOrbit+7,OZcr,-color,color,0.3);\n    cycleValue(indexOrbit+9,OWcr,-color,color,0.5);\n    \n    cycleValue(indexOrbit+10,Ocenter.x,-1.,1.0,0.3);\n    cycleValue(indexOrbit+11,Ocenter.y,-1.,1.0,0.5);\n    cycleValue(indexOrbit+12,Ocenter.z,-1.,1.0,0.7);\n}\n\nvoid moveCamera() {\n    float angle = iTime * 0.1;\n    float angle2 = iTime * 0.3;\n    float amt = 1.2;\n    \n    camera.x += cos(angle) * amt;\n    camera.y += cos(angle2) * amt;\n    camera.z += sin(angle) * amt;\n}\n\nvoid alterparams() {\n   float amt = 0.1;\n  \n   cycleValue2(0,scale,scale,amt,0.4);\n   cycleValue2(1,fixedRadius,fixedRadius,amt,0.5);\n   cycleValue2(2,minRadius,minRadius,amt,0.6);\n   cycleValue2(3,boxFold,boxFold,amt,0.7);\n   cycleValue2(5,sphereFold,sphereFold,amt,0.7);\n   \n   \n/*\n       float scale,fixedRadius,minRadius;\n    float boxFold,bfDelta;\n    float sphereFold,sfDelta;\n    vec3 julia;\n    bool juliaMode;\n   */\n}\n\nvoid animateSpecifiedVariables() {\n    if(!animationEnable) return;\n\n  //  alterPhongLight();\n    alterparams();\n    \n/*\n    alterSpotLight();\n\n    cycleValue(Ostrength,0.01,0.3,0.2);\n    alterOrbitColors();\n    alterPhongLight();\n    //moveCamera();\n    //changeAim();\n\n    //cycleValue3(Ocycle,OcycleDefault,1.2,0.1);\n    //alterOrbitColors(data);\n\n    //cycleValue3(Ostrength,OstrengthDefault,1.2,0.1);\n*/\n\n}\n\n// --------------------------------------------------------\n    \nvoid downloadData(ivec2 address,inout float v1,inout float v2,inout float v3) {\n    vec3 d = fetchData(iChannel0, address).xyz;\n    v1 = d.x; v2 = d.y; v3 = d.z;\n}\n\nvoid readStoredData() {\n    float unused = 0.;\n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    focus = int(sd.x);\n    displayCount = int(sd.y);\n    animationEnable = bool(sd.z == 1.0);\n    \n    downloadData(P0_ADDR,scale,fixedRadius,minRadius);\n    downloadData(P1_ADDR,boxFold,bfDelta,sphereFold);\n    downloadData(P2_ADDR,sfDelta,julia.x,julia.y);\n    downloadData(P3_ADDR,julia.z,unused,unused);\n    \n    downloadData(P6_ADDR,camera.x,camera.y,camera.z);\n    downloadData(P7_ADDR,aim.x,aim.y,aim.z);\n    downloadData(P8_ADDR,invpos.x,invpos.y,invpos.z);\n    downloadData(P9_ADDR,invradius,invangle,ssDistance);\n    downloadData(P10_ADDR,ssAngle,ssAmount,ssMix);\n    downloadData(P11_ADDR,phongColor.x,phongColor.y,phongColor.z);\n    downloadData(P12_ADDR,phongPosition.x,phongPosition.y,phongPosition.z);\n    downloadData(P13_ADDR,phongParam.x,phongParam.y,phongParam.z);\n    downloadData(P14_ADDR,spotLight,spotLightData.x,spotLightData.y);\n    downloadData(P15_ADDR,spotLightData.z,spotLightColor.x,spotLightColor.y);\n    downloadData(P16_ADDR,spotLightColor.z,Ostrength,Ocycle);\n    downloadData(P17_ADDR,OXwt,OXcr,OYwt);\n    downloadData(P18_ADDR,OYcr,OZwt,OZcr);\n    downloadData(P19_ADDR,OWwt,OWcr,Ocenter.x);\n    downloadData(P20_ADDR,Ocenter.y,Ocenter.z,unused);\n    \n    sd = fetchData(iChannel0, UNIFORM_1).xyz;\n    inversionEnable = bool(sd.x > 0.);\n    stereoEnable = bool(sd.y > 0.);\n\n    sd = fetchData(iChannel0, UNIFORM_2).xyz;\n    secondsurfaceEnable = bool(sd.x > 0.);\n    refractEnable = bool(sd.y > 0.);\n    \n    viewVector = fetchData(iChannel0, VV_1).xyz;\n    sideVector = fetchData(iChannel0, VV_2).xyz;\n    topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\nvoid initializedNonStoredData() {\n    maxsteps = 16;\n    juliaMode = true;\n    orbitTrap = vec4(10000.);\n    epsilon = 0.00001; // deviation when calculating normal\n    \n    ambient = 0.0;\n    contrast = 1.;\n    vibrant = 0.01;\n    dim = 0.0239;\n    color = vec3(0,0,0);\n\n    fogDistance = -1.; // set to 0.0 to disable fog\n    fogAmount = 0.21;\n    fogColor = 0.52;\n    \n    ssIterations = 1;\n    parallax = 0.02; // use smaller values when viewing closeup objects\n}\n\n// --------------------------------------------------------\n\nvec3 Refract(vec3 incidentVec, vec3 normal, float eta) {\n  float N_dot_I = dot(normal, incidentVec);\n  float k = 1.0 - eta * eta * (1.0 - N_dot_I * N_dot_I);\n  if (k < 0.0)\n    return vec3(0.0);\n  else\n    return eta * incidentVec - (eta * N_dot_I + sqrt(k)) * normal;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    readStoredData();\n    initializedNonStoredData();\n    animateSpecifiedVariables();\n    setDirection(fragCoord);\n    rayMarch();\n    \n    if(depth < MAX_DIST) {\n        position = camera + direction * depth;\n        calcNormal();\n        applyColoring();\n\n        // second surface -------------------------------\n        if(secondsurfaceEnable) {\n            vec3 originalCamera = camera;\n            \n            for(int i=0;i<5;++i) {\n                if(i >= ssIterations) break;\n\n                if(refractEnable)\n                    direction = Refract(direction, normal * ssAngle,ssAmount);\n                else\n                    direction = reflect(direction, normal * ssAngle);\n                direction = normalize(direction);\n\n                camera = position + ssDistance * direction;\n                rayMarch();\n\n                if(depth < MAX_DIST) {\n                    position = camera + direction * depth;\n                    calcNormal();\n                    vec3 previousColor = color;\n                    applyColoring();\n                    color = mix(previousColor,color,ssMix);\n                }\n                else\n                    break;\n            }\n            \n            camera = originalCamera;\n        }\n    }\n\n    if(fogDistance != 0.0) {\n        float f = depth - fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * fogAmount);\n            color = mix(color, vec3(0.2 + f * fogColor),f);\n        }\n    }\n\n    fragColor = vec4(color,1.0);\n    \n    if(displayCount > 0)\n        displayData(fragColor,fragCoord);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float scaleDefault = 2.05;\nconst float fixedRadiusDefault = 2.1497;\nconst float minRadiusDefault = 1.26;\nconst float boxFoldDefault = 1.65;\nconst float bfDeltaDefault = 0.0199;\nconst float sphereFoldDefault = 2.2159;\nconst float sfDeltaDefault = 1.0539;\nconst vec3 juliaDefault = vec3(-6.10998, -0.8499, -8.0499);\n\nconst vec3  cameraDefault = vec3(-4.8552,-2.409,-9.0663);\nconst vec3  aimDefault = vec3(-1.727,-2.6377,-0.3870);\n\nconst float spotStrength = 0.65;\nconst vec3  spotData = vec3(-0.21,-4.69,1.26);\nconst vec3  spotColor = vec3(1.,0.6,0.);\n\nconst vec3 invposDefault = vec3(0.0712, -0.012, 0.22);\nconst float invradiusDefault = 0.387;\nconst float invangleDefault = 3.973;\n\nconst float ssDistanceDefault = 0.0093;\nconst float ssAngleDefault = 0.7899;\nconst float ssAmountDefault = 1.3;\nconst float ssMixDefault = 1.;\n\nconst float OstrengthDefault = 0.0;\nconst float OcycleDefault = 0.0;\nconst float OXwtDefault = 2.0736677;\nconst float OXcrDefault = -3.9815997;\nconst float OYwtDefault = 2.03396538;\nconst float OYcrDefault = 1.71172849;\nconst float OZwtDefault = -2.74972636;\nconst float OZcrDefault = -0.55577678;\nconst float OWwtDefault = 0.0; \nconst float OWcrDefault = -4.24845531;\nconst vec3  OcenterDefault = vec3(-0.5); \n\nconst vec3 pColorD = vec3(0.75,0.75,0.);\nconst vec3 pPosD = vec3(-5.,0.5,10.);\nconst vec3 pParamD = vec3(0.2,1.1,5.);\n\n// ========================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n// leave room for future entries without having to adjust hardwired param array positions\n#define UNUSED  999.\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\nconst ParamData[] pData = ParamData[]( \n    //  0 p0 ---------------\n    ParamData(scaleDefault, 0.6,10.0,0.003),\n    ParamData(fixedRadiusDefault, 0.0,\t4.0,0.01),\n    ParamData(minRadiusDefault, 0.,4.,0.01),\n    //  3 p1 ---------------\n    ParamData(boxFoldDefault, 0.1,4.,0.01),\n    ParamData(bfDeltaDefault, -2.,2.,0.01),\n    ParamData(sphereFoldDefault, 0.1,4.,0.01),\n    //  6 p2 ---------------\n    ParamData(sfDeltaDefault, -2.,2.,0.01),\n    ParamData(juliaDefault.x, -10.,10.,0.01),\n    ParamData(juliaDefault.y, -10.,10.,0.01),\n    //  9 p3 ---------------\n    ParamData(juliaDefault.z, -10.,10.,0.01),\n    UNUSEDP,\n    UNUSEDP,\n    // 12 p4 ---------------\n    UNUSEDP,\n    UNUSEDP,\n    UNUSEDP,\n    // 15 p5 ---------------\n    UNUSEDP,\n    UNUSEDP,\n    UNUSEDP,\n    // 18 p6 ---------------    \n    ParamData(cameraDefault.x, -20., 20., 0.01), \n    ParamData(cameraDefault.y, -20., 20., 0.01),\n    ParamData(cameraDefault.z, -20., 20., 0.01),\n    // 21 p7 ---------------\n    ParamData(aimDefault.x, -20., 20., 0.01), \n    ParamData(aimDefault.y, -20., 20., 0.01),\n    ParamData(aimDefault.z, -20., 20., 0.01),\n    // 24 p8 ---------------\n    ParamData(invposDefault.x, -15., 15., 0.01),\n    ParamData(invposDefault.y, -15., 15., 0.01),\n    ParamData(invposDefault.z, -15., 15., 0.01),\n    // 27 p9 ---------------    \n    ParamData(invradiusDefault, 0.01, 10., 0.01),\n    ParamData(invangleDefault, -5., 5., 0.001), \n    ParamData(ssDistanceDefault, 0., 5., 0.01),\n    // 30 p10 ---------------    \n    ParamData(ssAngleDefault, -1., 1., 0.01),\n    ParamData(ssAmountDefault, 0.3, 1.3, 0.01),\n    ParamData(ssMixDefault, 0., 1., 0.01),\n    // 33 p11 ---------------    \n    ParamData(pColorD.x, 0.,3., 0.01),\n    ParamData(pColorD.y, 0.,3., 0.01),\n    ParamData(pColorD.z, 0.,3., 0.01),\n    // 36 p12 ---------------    \n    ParamData(pPosD.x, -20.,20., 0.01),\n    ParamData(pPosD.y, -20.,20., 0.01),\n    ParamData(pPosD.z, -20.,20., 0.01),\n    // 39 p13 ---------------    \n    ParamData(pParamD.x, 0.,5., 0.01),\n    ParamData(pParamD.y, 0.,5., 0.01),\n    ParamData(pParamD.z, 0.,10., 0.01),\n    // 42 p14 ---------------    \n    ParamData(spotStrength, 0., 3., 0.01),\n    ParamData(spotData.x, -6., 6., 0.01),\n    ParamData(spotData.y, -6., 6., 0.01),\n    // 45 p15 ---------------    \n    ParamData(spotData.z, -2., 2., 0.01),\n    ParamData(spotColor.x, 0., 1., 0.01),\n    ParamData(spotColor.y, 0., 1., 0.01),\n    // 48 p16 ---------------    \n    ParamData(spotColor.z, 0., 1., 0.01),\n    ParamData(OstrengthDefault, 0., 5., 0.01),\n    ParamData(OcycleDefault, 0., 5., 0.01),\n    // 51 p17 ---------------    \n    ParamData(OXwtDefault, -5., 5., 0.01),\n    ParamData(OXcrDefault, -5., 5., 0.01),\n    ParamData(OYwtDefault, -5., 5., 0.01),\n    // 54 p18 ---------------    \n    ParamData(OYcrDefault, -5., 5., 0.01),\n    ParamData(OZwtDefault, -5., 5., 0.01),\n    ParamData(OZcrDefault, -5., 5., 0.01),\n    // 57 p19 ---------------    \n    ParamData(OWwtDefault, -5., 5., 0.01),\n    ParamData(OWcrDefault, -5., 5., 0.01),\n    ParamData(OcenterDefault.x, -5., 5., 0.01),\n    // 60 p20 ---------------    \n    ParamData(OcenterDefault.y, -5., 5., 0.01),\n    ParamData(OcenterDefault.z, -5., 5., 0.01),\n    UNUSEDP\n); \n\nconst int indexCamera = 18;\nconst int indexAim = 21;\nconst int indexInversion = 24;\nconst int indexSecondSurf = 29;\nconst int indexPhong = 33;\nconst int indexSpot = 42;\nconst int indexOrbit = 49;\n\nconst int PDATA_SIZE = 62;\nconst int PDATA_ADDR_COUNT = (PDATA_SIZE+2)/3;\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR =  ivec2( 2, 0);\nconst ivec2 P1_ADDR =  ivec2( 3, 0);\nconst ivec2 P2_ADDR =  ivec2( 4, 0);\nconst ivec2 P3_ADDR =  ivec2( 5, 0);\nconst ivec2 P4_ADDR =  ivec2( 6, 0);\nconst ivec2 P5_ADDR =  ivec2( 7, 0); \nconst ivec2 P6_ADDR =  ivec2( 8, 0); \nconst ivec2 P7_ADDR =  ivec2( 9, 0); \nconst ivec2 P8_ADDR =  ivec2(10, 0); \nconst ivec2 P9_ADDR =  ivec2(11, 0); \nconst ivec2 P10_ADDR = ivec2(12, 0); \nconst ivec2 P11_ADDR = ivec2(13, 0); \nconst ivec2 P12_ADDR = ivec2(14, 0); \nconst ivec2 P13_ADDR = ivec2(15, 0); \nconst ivec2 P14_ADDR = ivec2(16, 0); \nconst ivec2 P15_ADDR = ivec2(17, 0); \nconst ivec2 P16_ADDR = ivec2(18, 0); \nconst ivec2 P17_ADDR = ivec2(19, 0); \nconst ivec2 P18_ADDR = ivec2(20, 0); \nconst ivec2 P19_ADDR = ivec2(21, 0); \nconst ivec2 P20_ADDR = ivec2(22, 0); \n\nconst ivec2[] storeAddr = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,\n    P10_ADDR,P11_ADDR,P12_ADDR,P13_ADDR,P14_ADDR,P15_ADDR,P16_ADDR,P17_ADDR,P18_ADDR,P19_ADDR,\n    P20_ADDR);\n\nconst ivec2 UNIFORM_1 = ivec2(23, 0); // booleans\nconst ivec2 UNIFORM_2 = ivec2(24, 0);\nconst ivec2 VV_1 = ivec2(25, 0);   // view vectors\nconst ivec2 VV_2 = ivec2(26, 0);\nconst ivec2 VV_3 = ivec2(27, 0);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ========================================================================\n// visit: https://www.shadertoy.com/view/mdsSD7\n// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char)\n{\n//    vec2 uvSize = f.charSize / f.texSize;\n//    return vec4(char, char+ivec2(1)) * uvSize.xyxy;\n\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\n/*\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n*/\n\nvoid printInt(int val, inout TextCursor t)\n{\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)\n    {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n}\n\nvoid printFloat(float val, inout TextCursor t)\n{\n    if(val < 0.0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;)\n    {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n    {  \n        printChar(Digits[digits[i]], t);\n    } \n    \n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++)\n    {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor)\n{\n    fragColor = t.outColor;\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = vec4(0.4,0.4,0.4,10.);\n        \n/*      \n    fragColor = vec4(0.);\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = t.outColor;\n*/\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < PDATA_SIZE) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 viewVector = normalize(fetchData(iChannel0, P7_ADDR).xyz);  // aim\n        vec3 sideVector = vec3(0.0, 1.0, 0.0);\n        sideVector = cross(sideVector,viewVector);\n        sideVector = normalize(sideVector);\n        vec3 topVector = viewVector;\n        topVector = cross(topVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT  = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT  = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis,inout vec3[PDATA_ADDR_COUNT] memory) {\n    if(focus > PDATA_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 3;  // memory index\n    int focusField = focus % 3;  // x,y,z field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.001;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n                if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.); \n    if(fragCoord.x > 30.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    updateViewVectors(fragColor, fragCoord);\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    vec3 m = vec3(0.);\n    vec3[PDATA_ADDR_COUNT] memory = vec3[](m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m);\n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    //-------------\n    // if <Alt><Shift> alter target position.xy regardless of focus    \n    if(getKeyState(KEY_SHIFT) && getKeyState(KEY_ALT)) \n        focus = 21;\n    else\n    \n    // if <Shift> alter camera position.xy regardless of focus\n    if(getKeyState(KEY_SHIFT)) \n        focus = 18;\n    //-------------\n    \n    if(alterFocusedVariable(focus,  0,memory)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1,memory)) resetDisplayCount = true;\n    \n    // output possibly altered values0-----------\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange == 0. && (iFrame % 12 == 0)) { // slow down auto repeat of up/dn arrows\n            if(getKeyState(KEY_UP))   focusChange = -1.;\n            if(getKeyState(KEY_DOWN)) focusChange = +1.;\n        }\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(PDATA_SIZE-1);\n                if(fragColor.x >= float(PDATA_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'  animationEnable\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n      \n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_1)) {\n        fragColor = fetchData(iChannel0, UNIFORM_1); \n        if(iFrame < 10) \n            fragColor.xyz = vec3(0.);\n        else {\n            bool ki = getKeyClick(73); // 'I'\n            bool ks = getKeyClick(83); // 'S'\n            if(ki) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n            if(ks) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n        }\n    }\n\n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_2)) {\n        fragColor = fetchData(iChannel0, UNIFORM_2); \n        if(iFrame < 10) fragColor.xyz = vec3(0.);\n\n        bool kq = getKeyClick(81); // 'Q'\n        bool kw = getKeyClick(87); // 'W'\n        if(kq) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n        if(kw) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}