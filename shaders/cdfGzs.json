{
    "Shader": {
        "info": {
            "date": "1668004265",
            "description": "A curved hexagon fractal object.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdfGzs",
            "likes": 49,
            "name": "Hexagon Fractal Object",
            "published": 3,
            "tags": [
                "fractal",
                "hexagon",
                "curve",
                "polar"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "/*\n\n    Hexagon Fractal Object\n    ----------------------\n    \n    Fabrice Neyret and MLA (aka Matthew Arcus) have posted a few Gosper\n    curve examples lately, which were much appreciated because it's one\n    of those interesting and important topics that very little code \n    exists for.\n    \n    Anyway, the results very much reminded me a fractal curve example that \n    I'd left unfinished a while back. I'm not sure what the object is \n    technically called, but it's a hexagon fractal curve, so that'll do.\n    It's not a common object, but I've seen it around.\n    \n    I took a polar cell partitioning approach, which was almost trivial\n    for one level, reasonable for the second level, and downright\n    annoying to code for the third due to cell overlap issues. I won't\n    bore you with the details, since a lot of it is in the code, but \n    here's quick explanation:\n    \n    Divide space into six polar cells (sextants, I think), then render \n    S-curves in even cells and reverse S-curves in the remaining cells to \n    produce a flowing hexagonal boundary curve -- Set \"cInd\" to zero and \n    uncomment the define CNSTR_LINES for a visual reference. The S-curves \n    consist of circular arcs around three vertex points contained in each\n    cell. For the next iteration, move to each of those three vertex points, \n    then render the same hexagonal curves around them, then do it again... \n    There are details I'm omitting, but that and the code should give \n    anyone interested in this sort of thing a start.\n    \n    Aesthetically speaking, I like the way the object looks with just two \n    levels. However, that seems a little too easy to construct, so I've \n    opted for the tri-level version. By the way, I'm going to make a more \n    interesting two level example later.\n    \n    \n    \n    Related examples:\n    \n    // The Gosper curves are different, but have a very similar feel.\n    Gosper Closed Curves - mla\n    https://www.shadertoy.com/view/mdXGWl\n    \n    // The original Gosper curve example on here.\n    Gosper curve - FabriceNeyret2\n    https://www.shadertoy.com/view/cdsGRj\n    \n*/\n\n//////////////////\n\n// Fractal iteration depth. I'm only prividing 3 here, due to the \n// iteration count getting out of hand for values like 4, so the\n// numbers are 0, 1, or 2.\nint cInd = 2;\n\n// Display the closed curve... Technically, the dark edges are the closed\n// curve, but this presents it more fully.\n//#define CURVE\n\n// Arc shape. Circular: 0, Hexagon: 1.\n#define SHAPE 0\n\n// Show the construction lines: These make more sense when the variable \n// \"cInd\" (above) is set to zero. The long lines represent the six individual\n// cell borders, and the remaining disecting lines are hexagon boundaries. \n// The object in each cell consists of three curves surround three points.\n//#define CNSTR_LINES\n\n//////////////////\n\n// Arc shape.\nfloat dist(vec2 p){\n  \n    #if SHAPE == 0\n    return length(p);\n    #else\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x);\n    #endif\n\n}\n\n// The construction lines for this cell.\nfloat cnstLines(vec2 p, mat3x2 ctr, vec2 s){\n\n    float ln = 1e5;\n    // Borders.\n    ln = min(ln, distLine(p, vec2(0), ctr[0]*s.x));\n    ln = min(ln, distLine(p, vec2(0), ctr[2]*s.y));\n    // Dividing lines.   \n    ln = min(ln, distLine(p, ctr[1], ctr[0]));\n    ln = min(ln, distLine(p, ctr[2], ctr[1]));\n    \n    return ln;\n}\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, int m){\n\n    const float aN = 6.;\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN) + float(m - 1), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n    // Flip alternate cells about the center.\n    if(mod(na, 2.)<.001) p.y = -p.y;\n\n    return p;\n}\n\n// Partition lines.\nvec3 prtnLines(vec2 p, mat3x2 ctr){\n\n                \n    // Cell partition lines.\n    float div1 = divLine(p, ctr[1], ctr[0]);\n    float div2 = divLine(p, ctr[2], ctr[1]);  \n     // Cell border.\n    float bR = divLine(p, vec2(0), ctr[2]);\n    //bL = divLine(p, vec2(0), ctr[0]);\n\n    return vec3(div1, -max(div1, div2), max(div2, bR));\n}\n\n/*\nint colID(vec3 c, vec3 oDiv, int index, inout float gCol){\n    c = max(c, oDiv);\n    int colID = c.x<c.y && c.x<c.z? 0 : c.y<c.z? 1 : 2;\n    if(c[colID]<gCol){ gCol = c[colID]; index = colID; }\n    return index;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc*1.5/iResolution.y;\n    \n    // Automatically rotate through all levels.\n    //cInd = int(mod(floor(iTime/4.), 3.));\n    \n    \n    // Scaling and translation.\n    vec2 p = rot2(3.14159/6. - iTime/24.)*sc*uv;\n    \n    // Scene field calculations.\n\n    vec2 op = p;\n    \n    // The distance field for each level.\n    vec3 gDst = vec3(1e5);\n \n    // Polar cell numbers.\n    vec3 na, gNa = vec3(1);    \n  \n    /*\n    // Index and global color value.\n    ivec3 index = ivec3(0);\n    vec3 gCol = vec3(1e5);\n    */\n    \n    // Construction lines and maximum bounds for each level.\n    vec3 ln = vec3(1e5);\n    vec3 gBound = vec3(1e5);\n\n    \n    // I poached this from one of my hexagonal six petal geometry examples. I remember\n    // working it out on paper and liking the fact that it was so weird but concise. \n    // Unfortunately, I didn't mention how I got there. :)\n    const float shF = sqrt(1./7.);\n    // The original radius of the circle that the curve is constucted around.\n    const float r0 = .27;\n    const float hr0 = r0/.8660254; // Hexagon radius.\n    float r20 = hr0/3.; // Small circle radius.\n    #if SHAPE != 0\n    r20 *= .8660254; // Readjusting the radius for hexagonal shapes.\n    #endif\n    // Each polar cell has an S-shaped curve running through it, which is\n    // constructed with three vertex points. There are two on the cell boundaries, \n    // and one in the center -- Check the figure with one iteration for a visual. \n    // The vertex scale changes for greater iteration depth, but not the direction, \n    // so we're going to precalculate the original scale and direction here.\n    mat3x2 ctr0 = mat3x2(rot2(3.14159/6.)*vec2(hr0*2./3., 0), vec2(r0*4./3., 0), \n                         rot2(-3.14159/6.)*vec2(hr0*4./3., 0));\n    \n    // Precalculating the rotation matrices, which get used a few times.\n    // The angle is a hexagonal rotation related number involving ratios...\n    // The tangential angle between thrice the apothem and half the side\n    // length... I worked it out long ago, and no longer care why it works. :D\n    //\n    // Angle between the vertical line and the line running through the \n    // left hexagon vertex to the right vertex on the hexagon above.\n    float rotAng = atan(sqrt(3.)/9.); // Approx: 0.19012.\n    mat2 mRot = rot2(rotAng);\n    mat2 mRotP3 = rot2(rotAng + 3.14159/3.); // Inner curve needs extra rotation.\n\n    for(int aI = 0; aI<3; aI++){\n\n        // The radius of the circle that the curve is constucted around.\n        float r2 = r20; // Small circle radius.\n        p = op; // Original global coordinates.\n       \n        // Split this space into polar cells, and return the local coordinates\n        // and the cell number, which is used later.\n        p = polRot(p, na.x, aI);\n\n\n        mat3x2 ctr = ctr0; // Curve center -- There are three in each segment.\n\n\n        // Partition lines for each of the three vertices in the cell.\n        vec3 oDiv = prtnLines(p, ctr);\n        // Hexagon bounds for this scale. It's used to reverse coloring at the end.\n        float bR = divLine(p, vec2(0), ctr[2]);\n        gBound.x = min(gBound.x, max(-oDiv.y, oDiv.z)); // Previous hexagonal boundary lines.\n\n    \n        // Left, middle, right central point distances.\n        vec3 c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n        \n        /*\n        //////////\n        // Color ID.\n        index.x = colID(c, oDiv, index.x, gCol.x);\n        /////////\n        */\n        \n        c = max(c*vec3(-1, 1, -1), oDiv);\n\n        float crv = min(max(c.x, c.z), c.y);\n        \n        if(crv<gDst.x){ gDst.x = crv; gNa.x = na.x; }\n        \n        // Get the construction lines for this iteration.\n        ln.x = min(ln.x, cnstLines(p, ctr, vec2(2.5, 1.25)));//vec2(3, 1.5)\n        \n\n        ////////////////////////  \n\n        // Move to the new frame of reference, readjust r to the new scale\n        // (the smaller circle, r2), then recalculate the curve.\n        \n        // Move to the new points.\n        mat3x2 p3 = mat3x2(p, p, p) - ctr;\n        //\n        if(mod(na.x, 2.)<.001){\n            // Flip the X-value in every second polar cell.\n            p3[0].x = -p3[0].x; p3[1].x = -p3[1].x; p3[2].x = -p3[2].x;\n        }\n        // Rotate each point to the new orientation. The second point\n        // needs to be rotated an extra 60 degrees.\n        p3[0] *= mRot; p3[1] *= mRotP3; p3[2] *= mRot;\n \n\n        for(int bI = 0; bI<3; bI++){\n        for(int i = 0; i<3; i++){\n\n            ctr = ctr0*shF; \n            r2 = r20*shF;\n            \n            p = p3[i];\n            \n            // Split this space into polar cells, and return the local coordinates\n            // and the cell number, which is used later.\n            p = polRot(p, na.y, bI); // bI - 1\n\n\n            // Partition lines for each of the three vertices in the cell.\n            vec3 oDiv2 = prtnLines(p, ctr);\n            \n       \n            // Applying the previous clipping region to this one.\n            oDiv2 = max(oDiv2, oDiv[i]);\n            // Hexagon bound.\n            gBound.y = min(gBound.y, max(max(-oDiv2.y, oDiv2.z), oDiv[i]));\n\n            // Left, middle, right central point distances.\n            c = vec3(dist(p - ctr[0]), dist(p - ctr[1]), dist(p - ctr[2])) - r2;\n            ////\n            \n            /*\n            //////////\n            // Color ID.\n            index.y = colID(c, oDiv2, index.y, gCol.y);\n            /////////\n            */\n            \n            c = max(c*vec3(-1, 1, -1), oDiv2);\n\n           \n            crv = min(max(c.x, c.z), c.y);\n        \n            if(crv<gDst.y){ gDst.y = crv; gNa.y = na.y; }\n\n           \n            // Get the construction lines for this iteration.\n            ln.y = min(ln.y, cnstLines(p, ctr, vec2(1.25, 1.25))); //vec2(2.5, 1.5)\n            \n          \n            // Move to the new points.\n            mat3x2 q3 = mat3x2(p, p, p) - ctr;\n            //\n            if(mod(na.y, 2.)<.001){\n                // Flip the X-value in every second polar cell.\n                q3[0].x = -q3[0].x; q3[1].x = -q3[1].x; q3[2].x = -q3[2].x;\n            }\n            // Rotate each point to the new orientation. The second point\n            // needs to be rotated an extra 60 degrees.\n            q3[0] *= mRot; q3[1] *= mRotP3; q3[2] *= mRot;\n\n\n            mat3x2 ctr2 = ctr*shF;\n            r2 = r20*shF*shF;\n        \n            // Technically, we should allow for polar cells on either side, but that\n            // would mean three times the total iterations, so since there are no \n            // cell border encroachments here, we'll save a heap of cycles.\n            //for(int cI = 0; cI<3; cI++){\n            for(int j = 0; j<3; j++){\n\n                p = q3[j]; \n                \n                // Split this space into polar cells, and return the local coordinates\n                // and the cell number. Normally, you'd pass in a cell number variable\n                // to the last position, but we only need the middle one.\n                p = polRot(p, na.z, 1); // cI\n                \n                // Partition lines for each of the three vertices in the cell.\n                vec3 oDiv3 = prtnLines(p, ctr2);\n\n                // Applying the previous clipping region to this one.\n                oDiv3 = max(oDiv3, oDiv2[j]);\n\n                // Left, middle, right central point distances.\n                c = vec3(dist(p - ctr2[0]), dist(p - ctr2[1]), dist(p - ctr2[2])) - r2;\n                \n                /*\n                //////////\n                // Color ID.\n                index.z = colID(c, oDiv3, index.z, gCol.z); \n                /////////\n                */\n               \n                c = max(c*vec3(-1, 1, -1), oDiv3);\n                crv = min(max(c.x, c.z), c.y);\n                \n\n                if(crv<gDst.z){ gDst.z = crv; gNa.z = na.z; }\n                ////\n\n                if(oDiv[i]<0.){\n                    // Get the construction lines for this iteration.\n                    ln.z = min(ln.z, cnstLines(p, ctr2, vec2(1.1, 1.1)));\n                }\n\n            } // End \"j\".\n            //} // End \"cI\".\n\n        } // End \"i\".\n        } // End \"bI\". \n\n    } // End \"aI\".   \n\n\n    // RENDERING.\n \n \n    // Background.\n    vec3 bg = vec3(.08);//vec3(1, .15, .3);////vec3(.9, .95, 1)\n    vec3 fg = vec3(.8, 1, .15);//.yyz; //vec3(1, .6, .4); vec3(.8, .9, 1);//\n    fg = mix(fg, fg*vec3(1, .95, .2), uv.y*2. + .5);\n    \n    // The hexagon dot background.\n    float hSc = 4.*float(cInd + 1)*2.; // Scale based on the main pattern level.\n    vec2 hUV = rot2(3.14159/12. + iTime/24.)*uv; // Rotating the coordinates.\n    float bgP = bgPat(hUV*hSc)/hSc;\n    vec3 svBg = bg;\n    \n    bg = mix(bg, svBg*.8, (1. - smoothstep(0., sf*5., bgP)));  \n    bg = mix(bg, svBg*.5, 1. - smoothstep(0., sf, bgP));   \n    bg = mix(bg, svBg*1.1, 1. - smoothstep(0., sf, bgP + .0035));   \n\n    /*\n    // Adding subtle lines to the background.\n    const float lnSc = 60.;\n    vec2 pUV = rot2(3.14159/6. + iTime/24.)*uv; \n    float pat = (abs(fract(pUV.x*lnSc) - .5) - .15)/lnSc;\n    bg = mix(bg, bg*1.2, (1. - smoothstep(0., sf, max(pat, bgP + .003))));    \n    */\n       \n    // Scene color -- Set to the background.\n    vec3 col = bg;\n    \n    // Debug cell indicators.\n    //if(mod(gNa.x, 2.)==0.) col *= vec3(.8);\n    //if(mod(gNa.y, 2.)==0.) col *= vec3(.8);\n    //if(mod(gNa.z, 2.)==0.) col *= vec3(.8);\n    //col *= mod(dot(gNa, vec3(1)), 18.)/17.;\n    //col *= (gNa.x*36. + gNa.y*6. + gNa.z)/215.;\n    \n    // Clamp the level index between zero and two, since they're the only\n    // one's that work.\n    cInd = cInd<0? 0 : cInd>2? 2 : cInd;\n    \n    // Flipping patterns outside the bounds of previous levels... Yeah, it's confusing. :)\n    // With Truchet patterns, there's usually some cell pattern flipping involved, but with \n    // this example, there's level flipping also. \n    if(gBound.x<0.){ gDst.y = -gDst.y; gDst.z = -gDst.z; /* index.y += 1; index.z += 1; */ }\n    if(gBound.y<0.){ gDst.z = -gDst.z; /* index.z += 1; */ }\n     \n    // Giving the pattern some extra thickness.\n    gDst -= .006*float(3 - cInd);\n    \n    #ifdef CURVE\n    gDst = abs(gDst + .006*float(3 - cInd)) - .018*float(3 - cInd);\n    #endif\n\n    /*\n    // Debug indicators.\n    vec3 tCol =  mix(fg, vec3(1), .75);\n    if((index[cInd]&1)==0) tCol = mix(fg, bg, .85);\n    col = mix(col, tCol, 1. - smoothstep(0., sf, gCol[cInd]));\n    fg = mix(fg, tCol, 1. - smoothstep(0., sf, gCol[cInd]));\n    */\n    \n\n    // Edge, or stroke.\n    float dst = gDst[cInd];\n     \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., dst))*.35);\n    col = mix(col, fg*fg*.65, 1. - smoothstep(0., sf,  dst));\n    col = mix(col, fg, 1. - smoothstep(0., sf,  dst + .01*float(3 - cInd) + .002)); \n    \n   \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(dst) - .001)); \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(dst + .01*float(3 - cInd)) - .001)); \n     \n/*\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(gDst[2]) - .0045))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gDst[2]) - .0045)); \n    col = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, abs(gDst[2]) - .001));\n    if(cInd>1){\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gDst[1]) - .0045)); \n        col = mix(col, vec3(1, .85, .7), 1. - smoothstep(0., sf, abs(gDst[1]) - .001));\n    }\n    if(cInd>0){\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gDst[0]) - .0045)); \n        col = mix(col, vec3(1, .9, .8), 1. - smoothstep(0., sf, abs(gDst[0]) - .001)); \n    }\n*/\n    //if(cInd>0) col = mix(col, vec3(0), (1. - smoothstep(0., sf, gBound[cInd - 1]))*.35);\n    \n    #ifdef CNSTR_LINES\n    // Display the cellular construction lines.\n    //ln = max(ln, gDst + .01);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln[cInd] - .006)); \n    col = mix(col, min(fg.zyx + .7, 1.1), 1. - smoothstep(0., sf, ln[cInd] - .0002));\n    #endif\n\n    //col = mix(col, col.xzy, uv.y + .5);\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Dividing line passing through \"a\" and \"b\".\nfloat divLine(vec2 p, vec2 a, vec2 b){\n\n   // I've had to put a hack on the end to get rid of fine lines\n   // at the zero point. That, of course, invalidates the distance portion.\n   // However, in this case, I only need it for a border check, not distances.\n   // I'm not sure why the hack is needed... Some kind of float inaccuracy... \n   // I'll look into it later. :)\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b))*1e8;\n}\n\n//////////////\n// Background pattern code.\n// vec2 to float hash.\nfloat hash21( vec2 p ){ \n\n    return fract(sin(dot(p, vec2(1, 113)))*45758.5453); \n    // Animation, if preferred.\n    //p.x = fract(sin(dot(p, vec2(1, 113)))*45758.5453);\n    //return sin(p.x*6.2831853 + iTime)*.5 + .5; \n}\n\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(1, 1.7320508);\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers.\n\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n// A very unimaginative background pattern. :)\nfloat bgPat(vec2 p){\n\n    vec4 h = getHex(p);// + s.yx*iTime/6.\n    \n    float cDist = length(h.xy); // Distance from the center.\n    \n    // Unique random number.\n    float rnd = hash21(h.zw + .1)*.5 + .5;\n    \n    // Random circle size.\n    float d = cDist - min(.5*rnd, .47);\n    //d = abs(d + .2*rnd) - .2*rnd;\n    \n    return d;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}