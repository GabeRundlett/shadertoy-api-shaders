{
    "Shader": {
        "info": {
            "date": "1550849249",
            "description": "Way more involve that I though !\n\n( note that the approach is a bit more general than sinusoids, provided you can bound a x range containing only one extrema ).",
            "flags": 0,
            "hasliked": 0,
            "id": "tsXXRM",
            "likes": 24,
            "name": "distance to sinusoid",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance",
                "curve",
                "spring",
                "bisection",
                "solving",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1124
        },
        "renderpass": [
            {
                "code": "// === find the distance to a sinusoid (or more general function)\n//     in the purpose of tracing thick antialiased curve.\n//\n// principle: searche the zero of the derivative df() of distance(curPos,vec2(x,f(x)))\n// within a range known to contain only one.\n// (slight precision issue when facing min/max for now).\n\n// NB: managing ends adds a bit to the difficulty :-) Buggy for now\n\nfloat L = 1.6,                   // sprint length \n      n = 10.,                   // number of spires\n      r = .3,                    // spring radius\n      w = .03;                   // wire radius \n#define N 10                     // number of iterations\n#define PI 3.14159\n\n#define ofs 0. // (.1*iTime)\n#define f(x)  ( r * sin(k*(x-ofs)) ) // spring equation\n                                 // derivative of distanceÂ² / cst\n#define df(x) ( x0-(x) + r*k*cos(k*(x-ofs))* ( y0 -r*sin(k*(x-ofs)) ) )\n\n//#define f(x)  ( r * cos(k*(x)) ) // spring variant (set h=0.).\n//#define df(x) ( x0-(x) - r*k*sin(k*(x))* ( y0 -r*cos(k*(x)) ) )\n\n#define d(x)  length( vec2(x0,y0) - vec2( x, f(x) ) ) // distance\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;  // convert to normalized units\n       //w *= 2./R.y;   \n    L *= 1.+.5*sin(iTime);\n    \n    O-=O;\n    \n  //U = U.yx;                     // uncomment for vertical spring\n  //if (abs(U.x)>L/2.+w+3./R.y) return;  // optim\n\n    float x0 = U.x, y0 = U.y, x=x0,\n           k = 2.*PI*n/L, d;\n    \n#if 1 // zero-solving using bisection method\n    x = clamp( x0, -L/2., L/2.);\n    float  h = .5, // set to 0 for f(x) = cos()\n          xm = ( floor((x-ofs)*k/PI +h) -h ) *PI/k +ofs, // monotonous sin() branch\n          xM = (  ceil((x-ofs)*k/PI +h) -h ) *PI/k +ofs; // = range with only one dist extrema\n    // ends and beyond requires special care\n    xm = max(xm,-L/2.);                  \n    xM = min(xM, L/2.); \n    float ym = df(xm), yM = df(xM), y;   // v sign: hack to avoid the extra extrema\n    if ( xm ==-L/2. && ym < 0. ) xm=xM, ym= 1., xM+=PI/k, yM=df(xM);\n    if ( xM == L/2. && yM > 0. ) xM=xm, yM=-1., xm-=PI/k, ym=df(xm);\n    // special case when x is exactly above an extrema\n  //if ( yM > 0. ) xM -= .01*PI/k, yM = 1.;  // should be df\n    if ( ym < 0. ) xm -= .01*PI/k, ym = 1.;  //-> 1st useless, 2nd = any positive\n    // bisection to find distance extrema (i.e. zero of derivative df() )\n    for (int i=0; i<N; i++) {          \n        x = (xm+xM)/2.; y = df(x);\n        if ( sign(y)==sign(ym)) xm = x, ym = y;\n            else                xM = x, yM = y;\n       }\n    \n#else // zero-solving using Newton: not working (df() too nasty)\n    \n    x = x0;\n    for (int i=0; i<N; i++) {\n        x = df(x)+x;\n        if (k*abs(x-x0)>6.28) x = mod(x-x0,6.28/k)+x0;\n    }\n#endif\n    \n  //x = clamp( x, -L/2., L/2.);                 // limit spring to ends\n    d = d(x);                                   // dist to sine\n    d = min( d, d( L/2.) );                     // dist to ends\n    d = min( d, d(-L/2.) );\n    d -= w;                                     // thickness\n    \n    O = vec4( smoothstep(3./R.y,0., d) );       // draw spring\n    O.r += smoothstep(90./R.y,0.,1.-sin(100.*d)); // red: distance field\n\n#if 0                                           // debug\n    if( abs(y0-f(x0)) < 1./R.y) O = vec4(1,0,0,0);\n    O.g += .01 / d(xm);\n    O.b += .01 / d(xM);\n    O.gb += float( abs(abs(x0) - L/2.) < 2./R.y );\n#endif\n\n    O = sqrt(O);                                // to sRGB (cheap version)\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}