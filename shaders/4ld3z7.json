{
    "Shader": {
        "info": {
            "date": "1468459785",
            "description": "An experiment in creating interesting shapes and textures from a single torus.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ld3z7",
            "likes": 8,
            "name": "OneTorus",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "domainrepetition"
            ],
            "usePreview": 0,
            "username": "wjbgrafx",
            "viewed": 746
        },
        "renderpass": [
            {
                "code": "/*\n\tOneTorus by wjbgrafx\n\t\n\tBased on \"Raymarched Reflections\"   Uploaded by Shane in 2015-Nov-17\n\n\thttps://www.shadertoy.com/view/4dt3zn\n\n\t\n\tInspired by \"Playing with symmetries - Torus\" by  PauloFalcao\n\n\thttp://glslsandbox.com/e#29755.0\n\t\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PI_16\t\t\t\t\t0.19634954084936207740391521145497\n\n#define FAR                     500.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_DIST\t\t\t\t100.0\n#define CAM_POS                 vec3( 0.0, 55.0, -CAM_DIST )\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT                 vec3( 0.0, 10.0, 0.0 )\n#define LIGHT_POS               vec3( 10.0, 50.0, -30.0 )\n#define LIGHT_ATTEN\t\t\t\t0.0005\n\n// Function declarations\n//----------------------\nmat4 createCamRotMatrix();\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID );\n\n//------------------------------------------------------------------------------\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\n// Horizontal torus lying in xz plane at y = 0; t = vec2( lg. diam, sm. diam )\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//------------------------------------------------------------------------------\n// From http://glslsandbox.com/e#29755.0\n// Playing with symmetries - Torus\n// by @paulofalcao\n\nvec3 sim(vec3 p,float s){\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r){\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s){\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map(vec3 p)\n{    \t\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( p.y, objID );\n\t\n\t//------------------------------\n\n\tp.y -= 15.0;\t\n\tp.yz = rot( p.yz, iTime * 0.2 );\n\t\n\t// 1\n\tp.yz = rotsim( p.yz, 3.0 );\n\tp.z -= 2.0;\n\t\n\t// 2\n\tp.xy = rotsim( p.xy, 4.0 ); \n\tp.yz -= 3.5;\n\t\n\t// 3\n\tp.xy = rot( p.xy, PI * 0.5 ); \n\tp.x -= 2.65;\n\t\n\t// 2\n\tp.xy = rotsim( p.xy, 3.0 ); \n\tp.yz -= 3.5;\n\t\n\t// 3\n\tp.xy = rot( p.xy, PI * 0.5 ); \n\tp.x -= 2.65;\n\t\n\t// 1\n\tp.yz = rotsim( p.yz, 3.0 );\n\tp.z -= 2.5;\n\n\t//------------------------------\n\t\n\tp = sim( p, 14.5 + 12.0 * sin( iTime * 0.04 ) );\n\t\n\t// Thinner tori as num copies increases.\n\tfloat dist = sdTorus( p, vec2( 2.0, 0.2 + 0.175 * sin( iTime * 0.04 ) ) );\n\t\n\tobjID = 2.0;\n\tvec2 torFig = vec2( dist, objID );\n\t\n\t//---------------------------------------------------\n\n\tvec2 closest = ground.s < torFig.s ? ground : torFig;\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID )\n{    \n    vec3 col = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tcol = vec3( abs( sin( iTime * 0.03 ) ), \n\t\t\t\t\tabs( sin( iTime * 0.05 ) ),\n\t\t\t\t\tabs( sin( iTime * 0.07 ) ) );\n\t}\n\telse if ( objNum == 2.0 )\n\t{\n\t\tcol = vec3( 0.7, 0.8, 0.9 );\n\t}\n\t    \n    return col;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = LIGHT_POS;\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = vec3( abs( sin( iTime * 0.07 ) ), \n\t\t\t\t\t    abs( sin( iTime * 0.03 ) ),\n\t\t\t\t\t    abs( sin( iTime * 0.05 ) ) );\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( FAR, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID ) * 0.95;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    //sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n\n//------------------------------------------------------------------------------\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// https://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\n\tang = iTime * 0.079; // auto rotate\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n\tang = 0.25 * ( sin( iTime * 0.057 ) + 1.0 ) + PI_16; \n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. \n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID )\n                                                               \n{    \n    // Light direction vector.\n    vec3 lDir = LIGHT_POS - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    vec3 objCol = getObjectColor( sp, distID );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + vec3( 1.0, 0.6, 0.2 ) *\n                                                          spec * 2.0 ) * atten;\n   \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}