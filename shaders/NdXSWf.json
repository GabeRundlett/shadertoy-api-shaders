{
    "Shader": {
        "info": {
            "date": "1619365347",
            "description": "Daily shader - was something that came to mind as a quick concept - ended up spending the weekend playing around to get this.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdXSWf",
            "likes": 9,
            "name": "Daily Practice 04/24/21",
            "published": 3,
            "tags": [
                "raymarching",
                "sphere",
                "reflections"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 409
        },
        "renderpass": [
            {
                "code": "/**\n    Daily Shader Practice - well maybe weekend shader practice.\n    \n    The pistons in the back can give away the pully system in place\n    for the motion. Otherwise it's a mess of code.\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p,vec2(23.343,43.324)))*3434.3434);\n}\nmat2 rot(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\nfloat easeOutCubic(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\nfloat easeInCubic(float t) {\n    return t * t * t;\n}\n\nfloat vmax(vec3 p){\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat box(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n//@iq\nfloat cyl( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvoid getMouse(inout vec3 p){\n    float x = -abs(.3*sin(T*.14));\n    float y = .65*sin(T*.2);\n    p.zy*=rot(x);\n    p.xz*=rot(y);\n}\n\n// commonly used var\nmat2 r180,r45;\nvec3 hit,hitPoint;\nfloat tmod=0.,idmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.;\nfloat time=0.,glow=0.,ambt=0.;\n\n// sdf scene\nvec2 map(vec3 p, float sg) {\n    p.y+=1.;\n\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n    vec3 qh = vec3(abs(q.x),q.y+12.75,q.z);\n    \n    //tunnels\n    float cutout = box(qh-vec3(5,0,-2.),vec3(1.5,13.5,1.5));\n    float bx = max(box(qh-vec3(5,0,-2.),vec3(1.75,12.125,1.75))-.01,-cutout);\n    if(bx<res.x) {\n        res = vec2(bx,2.);\n        hit=qh;\n    }  \n    \n    // platforms\n    vec3 qp = q-vec3(0,-.75,-2.);\n    float gain = ga1*15.;\n    float pt = min( box(qp-vec3( 5,-(15.-gain),0),vec3(1.,.125,1.))-.01,\n                    box(qp-vec3(-5,-gain,0),vec3(1.,.125,1.))-.01);\n    if(pt<res.x) {\n        res = vec2(pt,4.);\n        hit=qp;\n    } \n    if(sg>0.) glow+= (.0095)/(.00015+pt*pt);\n    //armbase\n    vec3 aq = q+vec3(0,.75,2.);\n    float cx = min(cyl(aq,.75,.45),cyl(aq,1.65,.15));\n    cx = min(length(aq-vec3(0,.5,0))-.45,cx);\n\n    if(cx<res.x) {\n        res = vec2(cx,2.);\n        hit=aq;\n    }  \n\n    //arm\n    vec3 ab = aq-vec3(0,.5,0);\n    \n    float degs = ga1*180.;\n    float degs2 = (ga2+ga3)*.36;\n    float degs3 = .52-(degs2);\n    mat2 baseTurn = rot(-degs*PI/180.);\n    \n    // main arm bend\n    ab.xz*=baseTurn;\n    vec3 aq2=aq;\n    aq2.xz*=baseTurn;\n    ab.xy*=rot(degs2+37.*PI/180.);\n    \n    float basedx = cyl(vec3(ab.x,abs(ab.y-1.55),ab.z)-vec3(.0,1.,0),.35,.05);\n    basedx = min(cyl(aq2-vec3(.75,.5,0),.5,.45),basedx);\n\n    vec3 abb = ab;\n    float lght = cap(abb,3.6,.05);\n    lght=min(cyl(aq2-vec3(.75,.05,1.),.15,.1),lght);\n    float lght2 =cyl(aq2-vec3(.75,.25,-1.),.15,.25);\n    \n    if(sg>0.) glow+= (.095)/(.0015+lght2*lght2);\n    if(sg>0.) ambt+= (.003)/(.0025+lght*lght);\n    \n    lght=min(lght2,lght);\n    if(lght<res.x) res =vec2(lght,4.);\n    abb.xz = abs(abb.xz)-.1;\n    float abase = cap(abb,3.6,.05);\n\n    //ball joint\n    vec3 ab2 = ab-vec3(0,3.6,0);\n    abase=min(length(ab2)-.25,abase);\n    // second arm bend\n    ab2.xy*=rot(degs3+60.*PI/180.);\n    float armlgt = 1.7;\n    abase = min(cap(ab2,armlgt,.1),abase);\n\n    float cup = cyl(ab2-vec3(0,armlgt,0),.35,.1);\n    abase=min(cup,abase);\n    abase=min(basedx,abase);\n    if(abase<res.x) {\n        res = vec2(abase,2.);\n        hit=ab;\n    } \n\n    // back pistons\n    float bak= box(q-vec3(0,-.5,-7.5),vec3(7.,.5,2.))-.15;\n    if(bak<res.x) {\n        res = vec2(bak,2.);\n        hit=q;\n    } \n    \n    float sp = cyl(q-vec3(  5.0 , ga1+.3, -7.5),1.35,ga1 );\n    sp = min(  cyl(q-vec3(  0.0 , ga2+.3, -7.5),1.35,ga2),sp);\n    sp = min(  cyl(q-vec3( -5.0 , ga3+.3, -7.5),1.35,ga3),sp);\n    if(sp<res.x) {\n        res = vec2(sp,2.);\n        hit=q;\n    } \n\n    // balls\n    vec3 blq = aq-vec3(0,2,0); \n    float deg3=0.,ofsx=0.;\n    \n    if(tmod>1.&&tmod<9.) {\n        blq.xz*=baseTurn;\n        deg3 =ga3+ga2+.15;  \n    } else if(tmod>9.&&tmod<12.) {\n        blq.xz*=r180;\n        deg3 =(16.15-gain);\n    } else if(tmod<1.||tmod>9.) {\n        deg3 =gain+1.15;\n    }\n    \n    if(tmod>1.&&tmod<8.) ofsx=(.2+ga2*.85)-1.;\n    if(tmod>8.&&tmod<9.) ofsx=(.2+ga3*.85)-1.;\n\n    float sphere = length(blq+vec3(5.+(ofsx),deg3,0))-.75;\n    if(sphere<res.x) {\n        res = vec2(sphere,2.);\n        hit=q;\n    } \n\n    float ground = max(p.y+.75,-cutout);\n    if(ground<res.x) {\n        res = vec2(ground,1.);\n        hit=p;\n    }   \n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    vec2 e = vec2(t*MIN_DIST,0);\n    float d= map(p,0.).x;\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n        );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d,sg);\n        if(ray.x<MIN_DIST*d) break;\n        d += i>150 ? ray.x*.5 : ray.x;\n        m  = ray.y;\n        if(d>MAX_DIST) break;\n       \n    }\n\treturn vec2(d,m);\n}\n\n//diffused shadow\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt)\n{\n    float k = 17.5;\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t,0.).x;\n        if( h<.001 )\n            return 0.;\n        res = min( res, k*h/t );\n        t += h;\n        if( res<.0001 || t>maxt ) break;\n    }\n    return res;\n}\n\nconst vec3 c = vec3(.95,.97,.98),\n           d = vec3(.06,.91,.70);\nvec3 hue(float t){ \n    return .55 + .45*cos( 13.+PI2*t*(c*d) ); \n}\n\nvec3 getStripes(vec2 uv){\n    uv.y+=T*1.2;\n    uv.y -= tan(radians(45.)) * uv.x;\n    float sd = mod(floor(uv.y * 5.5), 2.);\n    vec3 background = (sd<1.) ? vec3(.5) : vec3(.3);\n    return background;\n}\n\nvec3 getColor(float m) \n{\n    vec3 h = vec3(.1);\n    if(m==1.)\n    {\n        vec3 f  = fract(hitPoint*.2)-.5;\n        h  = (f.x*f.z>0.) ? vec3(0.255,0.459,0.506) : vec3(0.051,0.098,0.110) ; \n    }\n    if(m==4.) h  = (tmod<5.||tmod>12.) ? vec3(.01,.5,.1) : vec3(.69,.01,.02); \n    if(m==3.) h  = vec3(.359); \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = iTime;\n    tmod = mod(time, 16.);\n    idmod = floor((time/16.-tmod));\n    float t1 = linearstep(2.0, 8.0, tmod);\n    float t2 = linearstep(9.0, 15., tmod);\n    float a1 = easeOutCubic(t1);\n    float a2 = easeOutCubic(t2);\n    \n    float t3 = linearstep(0.0, 1.0, tmod);\n    float t4 = linearstep(1.0, 2.0, tmod);\n    float a3 = easeOutCubic(t3);\n    float a4 = easeOutCubic(t4);\n    \n    float t5 = linearstep(8.0, 9.0, tmod);\n    float t6 = linearstep(9.0,10.0, tmod);\n    float a5 = easeOutCubic(t5);\n    float a6 = easeOutCubic(t6); \n\n    \n    ga1 = (t1-t2);\n    ga2 = (t3-t4);\n    ga3 = (a5-a6);\n    \n    r180 = rot(180.*PI/180.);\n   \n    \n    vec3 C =vec3(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    // if you like to be retro - uncomment for fun\n    //uv = floor(uv*(86.*R.x/R.y))/(86.*R.x/R.y);\n\n    vec3 FC = mix(vec3(0.114,0.208,0.227),vec3(0.063,0.075,0.078),(uv.y-.5)*1.4);\n    \n    vec3 ro = vec3(0,0,8);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    getMouse(ro);\n    getMouse(rd);\n    \n    vec2 ray = marcher(ro,rd,255,1.);\n    float d = ray.x;\n    float m = ray.y;  \n    hitPoint=hit;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro+rd*d;\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(28.,8.,24.);\n        vec3 l = normalize(lpos-p);\n        // shade\n        float diff = clamp(dot(n,l),0.,1.) * 2.;\n        // shadow\n        float shadow = softshadow(p, l, 0.01, 12.0);\n        diff *= shadow;\n        \n        // coloring\n        vec3 h = getColor(m);\n        //specular \n        vec3 view = normalize(p - ro);\n        vec3 ref = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ref), 0.), 23.);\n        \n        C += h * diff+spec;\n        \n        // refleckt\n        if(m==2.)\n        {\n            vec3 rr=reflect(rd,n); \n            ray = marcher(p+(n*MIN_DIST),rr, 128,1.);\n            float rd = ray.x;\n            float rm = ray.y;  \n            hitPoint=hit;\n            if(rd<MAX_DIST){\n                p += rr*rd;\n                n = normal(p,rd);\n                l = normalize(lpos-p);\n                // shade\n                diff = clamp(dot(n,l),0.,1.);\n                // shadow\n                shadow = softshadow(p, l, 0.01, 12.0);\n                diff *= shadow;\n\n                // coloring\n                h = getColor(rm);\n\n                C = mix(C,h * diff,.75);\n                \n                // refleckt 2\n                if(m==2.)\n                {\n                    rr=reflect(rr,n); \n                    ray = marcher(p+(n*MIN_DIST),rr, 128,1.);\n                    rd = ray.x;\n                    rm = ray.y;  \n                    hitPoint=hit;\n                    if(rd<MAX_DIST){\n                        p += rr*rd;\n                        n = normal(p,rd);\n                        l = normalize(lpos-p);\n                        // shade\n                        diff = clamp(dot(n,l),0.,1.);\n                        // shadow\n                        shadow = softshadow(p, l, 0.01, 12.0);\n                        diff *= shadow;\n\n                        // coloring\n                        h = getColor(rm);\n\n                        C = mix(C,h * diff,.5);\n                    }\n                }\n            }\n        }\n        \n    } else {\n        C = FC;\n    }\n    \n    // standard fog based on distance\n    C = mix( C, FC, 1.-exp(-.000125*d*d*d));   \n     \n    vec3 ghue = (tmod<5.||tmod>12.) ? vec3(.01,.5,.1) : vec3(.69,.01,.02);\n    float glowMask = clamp(smoothstep(0.,9.,glow),0.,.9);\n    C = mix( C,clamp(C+glow*ghue,0.,.9), glowMask);    \n    float ambientMask = clamp(smoothstep(0.,9.,ambt),0.,.9);\n    C = mix( C,clamp(C+ambt,0.,.9), ambientMask);    \n   \n    if(m==1.){\n        vec3 stripes =getStripes(uv*5.3);\n        float f= .45+(.25*sin(uv.x*1.5+T));\n        float g= .75+(.27*sin(uv.y*1.7+T));\n        bool uvx = (uv.x<g&&uv.x>-g);\n        bool uvy = (uv.y<f&&uv.y>-f);\n        float ck = uvx && uvy ? 0. : 1.;\n        C = mix(C,vec3(stripes),ck);\n    }  \n    \n    // gamma correction\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}