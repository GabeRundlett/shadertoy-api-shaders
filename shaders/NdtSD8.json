{
    "Shader": {
        "info": {
            "date": "1633048040",
            "description": "how do I remove that weird interference, is it from an alpha channel hiccup?",
            "flags": 32,
            "hasliked": 0,
            "id": "NdtSD8",
            "likes": 8,
            "name": "bubbles uncooperative",
            "published": 3,
            "tags": [
                "mouse",
                "background",
                "shadertoy",
                "feedback",
                "integration",
                "library",
                "web",
                "webdevelopment",
                "webdev",
                "javascript"
            ],
            "usePreview": 0,
            "username": "xenn",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "\n// Fork of \"Nebulous Nonformanifest\" by xenn. https://shadertoy.com/view/fdV3RW\n// 2021-09-10 01:34:21\n\n// It wasn't me. I wasn't even here that day.\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - -.50 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                   //   col = min(col,col2);\n                      color += max(color,col);\n                      col2 += mix(col2,color,0.95);\n                     col2 = max(col2,col);\n                      \n                       \n      color = max(col2,col), color;\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color + col * color ), (max(col,(color / 3.0))))*noise), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Lovely Bubbles\n// by @P_Malin\n// https://www.shadertoy.com/view/Nl2SRc\n//\n// Some lovely shadertoy bubbles.\n// I've wanted to implement something with thin film interference for a while.\n\n\n// CAMERA\n\nvec2 GetWindowCoord( vec2 uv )\n{\n\tvec2 window = uv * 2.0 - 1.0;\n\twindow.x *= iResolution.x / iResolution.y;\n\n\treturn window;\t\n}\n\nvec3 GetCameraRayDir( vec2 window, vec3 cameraPos, vec3 cameraTarget, float fov )\n{\n\tvec3 forward = normalize( cameraTarget - cameraPos );\n\tvec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ) );\n\tvec3 up = normalize( cross( forward, right ) );\n\t\t\t\t\t\t\t  \n\tvec3 dir = normalize(window.x * right + window.y * up + forward * fov);\n\n\treturn dir;\n}\n\n\n// POSTFX\n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) / length(vec2(1.0));\n    \n    d /= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\nvec3 ApplyTonemap( vec3 linearCol )\n{\n\tconst float kExposure = 0.75;\n\t\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    vec3 x = linearCol * kExposure;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n}\n\nvec3 ApplyGamma( vec3 linearCol )\n{\n\tconst float kGamma = 1.2;\n\n\treturn pow( linearCol, vec3(1.0/kGamma) );\t\n}\n\nvec3 ApplyPostFX( vec2 uv, vec3 col )\n{    \n    col *= 1.3;\n\n    col *= 0.1 + 0.9 * Vignette( uv, 1.0 );\n\n    col *= vec3(1.0, 0.95, 0.8); // warmer\n  \n    col = ApplyTonemap(col);\n\tcol = ApplyGamma(col);\n    \n\treturn col;\n}\n\t\n\n\n// Scene\n\nfloat speed = 1.0;\n\nfloat BubbleOriginForward( float t )\n{\n    t = t * 30.0;\n    if ( t > 0.0)\n    {\n        t = t / (1.0+t/10.0f);\n\n    }\n    return t + iTime * speed;\n}\n\nfloat BubbleOriginInverse( float r )\n{\n    r = r- iTime * speed;\n    if( r > 0.0)\n    {\n        r = -10.0f * r / (r - 10.0f);\n    }\n    r = r / 30.0f;\n    return r;\n}\n\nfloat Scene_Distance(vec3 pos)\n{\n\n    vec3 vPos = pos;\n    vPos.x += 3.0;\n\n    float scale = 50.0;\n    \n    vPos /= scale;\n\n    // wobble\n    vec3 offset = vec3(0);\n    offset += sin( pos.yzx * 8.91 + iTime * 10.0 ) * 0.001;\n    offset += sin( pos.zxy * 7.89 + iTime * 10.0 ) * 0.001;    \n    offset *= 0.08;\n    \n    float f = BubbleOriginForward( vPos.x );\n    \n    f = floor(f);\n    \n    float minD = 1000000.0;\n    \n    for (float b=-1.0; b<=2.0; b+=1.0)\n    {\n        float p = f + b;\n        vec3 o = vPos;\n        o.x = BubbleOriginInverse( p );\n                \n        o.x -= vPos.x;\n\n         float spreadBlend = 1.0 - clamp( vPos.x * 3.0 + 0.2, 0.0, 1.0);\n         \n         float spread = spreadBlend;\n         \n         spread *= 0.05;\n\n         o.y += sin(p * 123.3456) * spread;\n         o.z += sin(p * 234.5678) * spread;\n         \n         o += offset;\n           \n         float rad = sin( p * 456.8342 ) * 0.5 + 0.5;\n                             \n         float d = length(o) - 0.005f - rad * rad * 0.02f;\n         \n         minD = min( minD, d );\n    }\n    \n     return minD * scale;\n}\n\nvec3 Scene_GetNormal( vec3 pos )\n{\n    const float delta = 0.0001;\n    \n    vec4 samples;\n    for( int i=ZERO; i<=4; i++ )\n    {\n        vec4 offset = vec4(0);\n        offset[i] = delta;\n        samples[i] = Scene_Distance( pos + offset.xyz );\n    }\n    \n    vec3 normal = samples.xyz - samples.www;    \n    return normalize( normal );\n}    \n\nfloat Scene_Trace( vec3 rayOrigin, vec3 rayDir, float minDist, float maxDist, float side )\n{\n\tfloat t = minDist;\n\n    const int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tfloat d = Scene_Distance( rayOrigin + rayDir * t ) * side;\n        if ( abs(d) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist + 1.0f;\n            break;\n        }       \n        \n        t += d;        \n\t}\n    \n    return t;\n}\n\nvec3 GetSkyColour( vec3 dir )\n{\n\tvec3 result = vec3(0.0);\n\t\n    vec3 envMap = texture(iChannel1, dir).rgb;\n    envMap = envMap * envMap;\n    float kEnvmapExposure = 0.999;\n    result = -log2(1.0 - envMap * kEnvmapExposure);\n\n    return result;\t\n}\n\nfloat FilmThickness( vec3 pos )\n{\n    return Noise(pos * 0.3f, iTime * 0.5);\n}\n\nvoid Shade( inout vec3 colour, inout vec3 remaining, vec3 pos, vec3 rayDir, vec3 normal )\n{\n    float NdotV = max( dot(normal, -rayDir), 0.0 );\n\n    float filmThickness = FilmThickness(pos);\n\n    vec3 reflection = GetSkyColour( reflect( rayDir, normal ) );\n    \n#if 1\n    // Extra highlight\n    vec3 LightColour = vec3(1,.9,.7) * 0.8;\n    vec3 L = normalize(vec3(1.0, 2.0, 0.0));\n    float NdotL = max( dot( normal, L ), 0.0 );\n    float NdotH = max( dot( normal, normalize(L-rayDir) ), 0.0 );\n    reflection += (pow(NdotH,10000.0) * 10000.0) * NdotL * LightColour;\n    //vReflection += (pow(NdotH,1000.0) * 2000.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,100.0) * 200.0) * NdotL * LightColour;\n    reflection += (pow(NdotH,10.0) * 20.0) * NdotL * LightColour;\n#endif     \n     \n    float ni = N_Air;\n    float nt = N_Water;     \n    \n    float cosi = NdotV;\n    float cost = GetCosT( ni, nt, cosi );\n    float fresnelA = Fresnel( ni, nt, cosi, cost );\n    float fresnelB = Fresnel( nt, ni, cost, cosi );\n\n    float fresnelFactor = 1.50f - (1.0f - fresnelA) * (0.450f - fresnelB);\n    \n    vec3 fresnel = vec3(fresnelFactor);\n\n    vec3 thinFilmColour;\n#if USE_THIN_FILM_LOOKUP\n    thinFilmColour = texture(iChannel0, vec2(NdotV, filmThickness) ).rgb;\n#else\n    thinFilmColour = GetThinFilmColour(NdotV, filmThickness);\n#endif\n    fresnel *= thinFilmColour;\n    \n    colour += reflection * fresnel * remaining;\n    remaining *= (1.0f - fresnel);\n\n\n#if 0\n    float fGlassThickness = 0.5;\n    vec3 vGlassColor = vec3(1,0.95, 0.25);\n\n\tfloat fOpticalDepth = fGlassThickness / NdotV;\n    vec3 vExtinction = exp2( -fOpticalDepth * (1.0 - vGlassColor) ); \n    remaining *= vExtinction;\n#endif    \n}\n\n\nvec3 GetSceneColour( vec3 rayOrigin, vec3 rayDir )\n{    \n    float kFarClip = 20.0;\n\n\tvec3 colour = vec3(0);\n    vec3 remaining = vec3(1);\n    \n    float side = (1.0);\n    \n    float minDist = 0.0;\n    \n    for( int i=0; i<10; i++ )\n    {\n        float t = Scene_Trace( rayOrigin, rayDir, minDist, kFarClip, side );\n        \n        if ( t>=kFarClip )\n        {\n            break;\n        }\n        \n        minDist = t + 0.1f;\n        \n        vec3 hitPos = rayOrigin + rayDir * t;\n\n        vec3 normal = Scene_GetNormal( hitPos );\n\n        Shade(colour, remaining, hitPos, rayDir, normal * side );\n        \n        side = side * -1.0f;\n    }\n    \n    colour += GetSkyColour(rayDir) * remaining; \n\t\n\treturn colour * 0.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float heading = 0.3f + sin(iTime * 0.3) * 0.1;\n\n    float elevation = 1.8 + sin(iTime * 0.134) * 0.1;\n    \n    float fov = 2.5 + sin( iTime * 0.234) * 0.5;\n    \n    float cameraDist = 10.0;\n\tvec3 cameraPos = vec3(sin(heading) * sin(-elevation), cos(-elevation), cos(heading) * sin(-elevation)) * cameraDist;\n\tvec3 cameraTarget = vec3(sin(iTime * 0.1542) * 3.0, 0.0, 0.0);\n\n\tvec3 rayOrigin = cameraPos;\n\tvec3 rayDir = GetCameraRayDir( GetWindowCoord(uv), cameraPos, cameraTarget, fov );\n\t\n\tvec3 sceneCol = GetSceneColour( rayOrigin, rayDir );\n\t\n\tvec3 final = ApplyPostFX( uv, sceneCol );\n\t\n\tfragColor = vec4(final, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Margins 0.\n#define TS abs(sin(iTime / 3.0))\n#define TC abs(cos(iTime / 2.50))\n#define TS2 abs(sin(iTime / 2.0))\n#define TC2 abs(cos(iTime / 2.0))\n\nfloat _viewDepth = -1.;\n\nvec3 _sunPos (float time)\n{\ntime = time * 0.5;\n    // cos(time*0.25)*0.85, sin(time*0.25)*0.6-0.2, 0.0\n    return vec3(-0.6+sin(time*0.2), cos(time*0.2), sin(time*0.2) );       \n}\n\nvec3 _moonPos (float time)\n{\n    time = time * 0.5;\n    time -= 5.;\n    return vec3(-2.0+sin(time*0.2)*1.5, cos(time*0.2), sin(time*0.2) );          \n}\n\n\n// interpolation\nfloat gaussianInterpol (float t, float a, float b, float c)\n{\n    // a - amplitude, b - center pos, c - frequency\n    return a * exp(-(t-b)*(t-b) / (2.0*c*c));\n   \n}\n\n// fractal noise\n\nfloat random3D(vec3 xyz, vec3 dir)\n{\n    float val = dot(xyz, dir);\n    return fract(30.0 * sin(val));\n}\n\n\n// transformations\n\nmat4 rotX(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( 1.0,        0.0,        0.0, 0.0),\n        vec4( 0.0, cos(angle), sin(angle), 0.0),\n        vec4( 0.0,-sin(angle), cos(angle), 0.0),\n        vec4( 0.0,        0.0,        0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotY(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), 0.0, -sin(angle), 0.0),\n        vec4(        0.0, 1.0,         0.0, 0.0),\n        vec4( sin(angle), 0.0,  cos(angle), 0.0),\n        vec4(        0.0, 0.0,         0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4\n    (\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\n\n// math utils\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\n\n\n// Use a lookup texture in Buffer A for thin film interference instead of calculating it at every intersection\n#define USE_THIN_FILM_LOOKUP 0\n\nfloat N_Air = 1.0f;\nfloat N_Water = 1.33f;\n\nfloat PI = 3.141592654;\n\n// used to prevent loop unrolling\n// This will be zero but the compiler doesn't know that as iFrame is a uniform\n#define ZERO min(iFrame,0)\n\n// https://en.wikipedia.org/wiki/Fresnel_equations\nfloat FresnelS(float ni, float nt, float cosi, float cost)\n{\n    return ((nt * cosi) - (ni * cost)) / ((nt * cosi) + (ni * cost));\n}\n\nfloat FresnelP(float ni, float nt, float cosi, float cost)\n{\n    return ((ni * cosi) - (nt * cost)) / ((ni * cosi) + (nt * cost));\n}\n\nfloat Fresnel(float ni, float nt, float cosi, float cost )\n{    \n    float Rs = FresnelS( ni, nt, cosi, cost );\n    float Rp = FresnelP( ni, nt, cosi, cost );\n\n    return (Rs * Rs + Rp * Rp) * 0.5;\n}\n\nfloat FresnelR0(float ni, float nt)\n{\n    float R0 = (ni-nt) / (ni+nt);\n    R0 *= R0;\n    return R0;\n}\n\n// https://en.wikipedia.org/wiki/Snell%27s_law\nfloat GetCosT( float ni, float nt, float cosi )\n{\n    float n = ni/nt;\n    float sinT2 = n*n*(1.0-cosi*cosi);\n    \n    // Total internal reflection\n    if (sinT2 >= 1.0)\n    {\n        return 1.0;\n    } \n\n    float cost = sqrt(1.0 - sinT2);\n    return cost;\n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3d(vec3 p)\n{\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    \n    vec3 ot = fr*fr*(3.0-2.0*fr);\n    vec3 zt = 1.0f - ot;\n    \n    \n    float result = 0.0f;\n    \n    result += hash13(fl + vec3(0,0,0)) * (zt.x * zt.y * zt.z);\n    result += hash13(fl + vec3(1,0,0)) * (ot.x * zt.y * zt.z);\n\n    result += hash13(fl + vec3(0,1,0)) * (zt.x * ot.y * zt.z);\n    result += hash13(fl + vec3(1,1,0)) * (ot.x * ot.y * zt.z);\n\n    result += hash13(fl + vec3(0,0,1)) * (zt.x * zt.y * ot.z);\n    result += hash13(fl + vec3(1,0,1)) * (ot.x * zt.y * ot.z);\n\n    result += hash13(fl + vec3(0,1,1)) * (zt.x * ot.y * ot.z);\n    result += hash13(fl + vec3(1,1,1)) * (ot.x * ot.y * ot.z);\n\n    return result;\n}\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat Noise(vec3 p, float o)\n{\n    float result = 0.0f;\n    float a = 1.0f;\n    float t= 0.0;\n    float f = 0.5;\n    float s= 2.0f;\n    \n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    p.x += o;\n    result += SmoothNoise3d(p) * a; t+= a; p = m3 * p * s; a = a * f;\n    result = result / t;\n    \n    return result;\n}\n\n\n\n// Spectrum to xyz approx function from http://jcgt.org/published/0002/02/01/paper.pdf\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave )\n{\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931( float wave )\n{\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931( float wave )\n{\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nvec3 WavelengthToXYZ( float f )\n{    \n    return xyzFit_1931( f );    \n}\n\n\n\n// from  https://github.com/amandaghassaei/SoapFlow/blob/main/python/Thin%20Film%20Interference.ipynb\nfloat ThinFilmAmplitude( float wavelength, float thickness, float cosi )\n{\n    float ni = N_Air;\n    float nt = N_Water;\n    \n    float cost = GetCosT( ni, nt, cosi );\n\n    // # The wavelength inside a medium is scaled by the index of refraction.\n    // wavelength_soap = wavelength / n_soap\n    // wavelength_air = wavelength / n_air\n    // # First calc phase shift of reflection at rear surface, based on film thickness.\n    // phaseDelta = 2 * thickness / math.cos(theta) * 2 * math.pi / wavelength_soap  \n    // # There is an additional path to compute, the segment AJ from:\n    // # https://www.glassner.com/wp-content/uploads/2014/04/CG-CGA-PDF-00-11-Soap-Bubbles-2-Nov00.pdf\n    // phaseDelta -= 2 * thickness * math.tan(theta) * math.sin(incidentAngle) * 2 * math.pi / wavelength_air\n    // Simplified to:\n    float phaseDelta = 2.0 * thickness * nt * cost * 2.0 * PI / wavelength;\n    \n    // https://en.wikipedia.org/wiki/Reflection_phase_change\n    if (ni < nt)\n        phaseDelta -= PI;\n    if (ni > nt)\n        phaseDelta += PI;\n\n    float front_refl_amp = Fresnel(cosi, cost, ni, nt);\n    float front_trans_amp = 1.0 - front_refl_amp;\n    float rear_refl_amp = front_trans_amp * Fresnel(cost, cosi, nt, ni);\n    \n    rear_refl_amp /= front_refl_amp;\n    front_refl_amp = 1.0f;\n        \n    // http://scipp.ucsc.edu/~haber/ph5B/addsine.pdf\n    return sqrt(front_refl_amp * front_refl_amp + rear_refl_amp * rear_refl_amp + 2.0 * front_refl_amp * rear_refl_amp * cos(phaseDelta));\n}\n\nvec3 GetThinFilmColour( float cosi, float thicknessN )\n{\n    float thicknessMin = 100.0;//1.0f;\n    float thicknessMax = 1500.0;//2500.0f;\n    \n    float thickness = mix(thicknessMin, thicknessMax, thicknessN);\n\n    vec3 result = vec3(0.0);\n    \n    float t = 0.0;\n    \n    vec3 white = vec3(0.0);\n    \n    for (float wavelength = 380.0; wavelength<=780.0; wavelength += 50.0)\n    {\n        float amplitude = ThinFilmAmplitude( wavelength, thickness, cosi );\n        \n        vec3 XYZ = WavelengthToXYZ( wavelength );\n    \n        white += XYZ;\n    \n        result += XYZ * amplitude;\n        t += 1.0f;\n    }\n\n    result = XYZtosRGB( result );\n      \n    result /= t;\n    //result /= white;\n    //result = vec3(1.0);\n    \n    return result;\n}\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\nvec3 hsv2rgb(vec3 cc)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*6.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb(hsv), 0.1), hsv.y*0.075);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m2 = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res1.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res1.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m2*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res1.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res1.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m2*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res1.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res1.xy)*2.0-vec2(1.0);\n //   fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res1.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb2(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragment = texture(iChannel1, uv);\n    vec3 hsv = rgb2hsv(fragment.rgb);\n    float rad = (iTime/2.0) + (hsv.z*16.28);\n    vec2 off = vec2(sin(rad), cos(rad)) / (iResolution.xy / vec2(max(hsv.y,hsv.z)*3.14));\n    hsv.x += abs(sin(iTime/11.0 + ((iMouse.x/iResolution.x)*6.28))*max(iMouse.y/iResolution.y,hsv.z*hsv.z));\n    hsv.y = max(hsv.y, min(hsv.z, 0.75));\n    fragColor = mix(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y)), vec4(hsv2rgb(hsv), 0.1), hsv.y*0.075);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 skyCol = vec3(80,180,255)/ 255.0;\n    vec3 horizonCol = vec3(255,255,255)/ 255.0;\n    vec3 groundCol = vec3(0,0,35)/ 255.0;\n    \n    vec3 sunCol = vec3(1.0, 1.0, 1.0);\n    float sunSize = 0.0005;\n    float sunBlur = 0.0025;\n    float sunScatter = 0.25;\n    \n    vec3 moonCol = vec3(1.0, 1.0, 1.0);\n    float moonSize = 0.00025;\n    float moonGlow = 0.05;\n    float moonShadow = 0.5;\n    float starSize = 0.04;\n    \n    vec3 sunPos = _sunPos(iTime); \n    vec3 moonPos = _moonPos(iTime);\n    vec3 sunDir = normalize(sunPos - rayOri); \n    vec3 moonDir = normalize(moonPos - rayOri); \n    float pitch =  0.5 + rayDir.y * 0.5;\n    \n    // sky\n    // -----------------------------------------------------------\n    vec3 col = skyCol;\n    horizonCol = mix (vec3(255,55,0)/ 255.0, vec3(255,255,255)/ 255.0, smoothstep(-0.5, 0.75, sunPos.y));\n    horizonCol = mix (vec3(55,155,155)/ 255.0, horizonCol, smoothstep(-0.5, 0.0, sunPos.y));        \n    col = mix(horizonCol, col, smoothstep(0.4, 0.8, pitch));    \n    col = mix(groundCol, col, smoothstep(0.49, 0.5, pitch));\n    \n    // sun\n    // ------------------------------------------------------------\n    sunCol = mix(vec3(255,85,0)/ 255.0, vec3(255,255,255)/ 255.0, max(0.0, min(1.0, smoothstep(-0.4, 0.8, sunPos.y))));\n    float sun = dot(sunDir, rayDir);    // return [-1,1] based on angle \n    sunSize += sunSize * 100.0 * (1.0-smoothstep(-0.8, 0.11, sunPos.y)); // scale sun based on height\n    float sunDisk = smoothstep((1.0 - sunSize) - sunSize*2.0, 1.0 - sunSize, sun); // define sun disk\n    sunScatter = smoothstep((1.0 - sunSize) - sunScatter, 1.0 - sunSize, sun) *  smoothstep(-0.8, 0.2, sunPos.y); \n    float sunGlow = smoothstep((1.0 - sunSize) - sunBlur, 1.0 - sunSize, sun);\n\n    float haloSize = 0.02;\n    float sunHalo = smoothstep(0.9999 - haloSize, 0.9999, sun);\n    sunHalo = mix(0.055, 0.05, fract(sunHalo*2.) );\n\n    //float angle = acos( dot(sunDir, rayDir) / (length(sunDir)*length(rayDir)) );\n    //float sunFlare = smoothstep((1.0 - sunSize*2.0) - 0.05*smoothstep(0.0, 3.14*.25,angle*10.) , 1.0 - sunSize*2.0, sun);\n    float horizonMask = smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    sunDisk *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunGlow *= smoothstep( -0.05, 0.025, rayDir.y);\n    sunHalo *= smoothstep( -0.2, 0.05, rayDir.y); // mask sun along horizon\n    \n    col = mix(col, sunCol, sunScatter*.25);\n    col = mix(col, sunCol, sunGlow*.5);\n    col += sunDisk + sunScatter*.05 + sunGlow*.05;\n    col += vec3(sunHalo*6.0, 0.0,0.0);\n\n    // night\n    // ------------------------------------------------------------\n    col *= max(0.35, min(1.0, smoothstep(-1.0, 0.0, sunPos.y)));\n    \n    // stars\n    // ------------------------------------------------------------\n    float starNoise = random3D( rayDir, vec3(0.5,0.1,7.0+ iTime*0.001));\n    vec2 starCoords = vec2(fract(rayDir.x * 50.0), fract(rayDir.y * 50.0) );  \n    float stars = step(0.6, starCoords.y) * (1.0-step(0.6 + starSize, starCoords.y)) * step(0.3, starCoords.x) * (1.0- step(0.3 + starSize, starCoords.x));\n    stars *= smoothstep(-0.01, 0.00, rayDir.y);\n    col += stars * pow(starNoise, 3.0) * (1.0-max(0.0, min(1.0, smoothstep(-1.0, 0.0, sunPos.y))));\n       \n    horizonMask = smoothstep( -0.01, 0.01, rayDir.y); // mask sun along horizon\n    // moon\n    // -------------------------------------------------------------\n    float moon = dot(moonDir, rayDir);\n    moonShadow = mix(-0.05, -0.0, moonShadow);\n    moonShadow = dot(vec4(rotY(moonShadow)*vec4(moonDir,1.0)).xyz, rayDir);\n    float moonDisk = smoothstep(1.0-moonSize-0.00025, 1.0-moonSize, moon); \n    moonShadow = smoothstep(1.0-moonSize*2.0-0.00025, 1.0-moonSize*2.0, moonShadow); \n    moonDisk *= (1.0 - moonShadow*.995) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y);    \n    col = mix(col, moonCol, moonDisk);\n    col += moonDisk;\n    \n    moonGlow = smoothstep(1.0-moonSize-moonGlow, 1.0-moonSize, moon) * horizonMask  * smoothstep(0.0, 0.3, moonPos.y); \n    col = mix(col, moonCol, moonGlow*.025) ; \n    \n    \n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}