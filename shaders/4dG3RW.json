{
    "Shader": {
        "info": {
            "date": "1453367766",
            "description": "Molecular dynamics simulation of soft disks",
            "flags": 32,
            "hasliked": 0,
            "id": "4dG3RW",
            "likes": 90,
            "name": "Molecular Dynamics",
            "published": 3,
            "tags": [
                "particles",
                "dynamics",
                "multipass"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 10831
        },
        "renderpass": [
            {
                "code": "// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nSimple but inefficient MD program for 2D soft disks. The algorithm\nparallelizes but is useless for large systems.\n\nStoring non-pixel data in textures follows iq's approach.\n\nSince the refresh rate is limited to 60 fps, doing multiple compute steps \nbetween display updates improves performance. Pixel-based rendering of \nlarge numbers of disks is also time consuming. \n\nMouse click restarts run.\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 uv, ut, q;\n  float bFac, dMin, b;\n  uv = 2. * fragCoord / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  ut = abs (uv) - vec2 (1.);\n  b = max (ut.x, ut.y);\n  ut = abs (ut);\n  if (b > 0.003) col = vec3 (0.82);\n  else if (b < 0. && min (ut.x, ut.y) < 0.01) col = vec3 (0.3, 0.3, 1.);\n  else {\n    bFac = Loadv4 (nMol).y;\n    q = 0.5 * (bFac * float (nMolEdge) + 0.5) * uv;\n    dMin = 1000.;\n    for (int n = 0; n < nMol; n ++)\n       dMin = min (dMin, length (q - Loadv4 (n).xy));\n    col = mix (vec3 (0.2),  vec3 (0., 1., 0.), 1. - smoothstep (0.4, 0.5, dMin));\n  }\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  rCut = pow (2., 1./6.);\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. / rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. / (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. / (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId / nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  rCut = pow (2., 1./6.);\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. / rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. / (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. / (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId / nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Molecular Dynamics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 20;\nconst int nMol = nMolEdge * nMolEdge;\nfloat bFac;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, f;\n  float rr, rri, rri3, rCut, rrCut, bLen, dt;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  rCut = pow (2., 1./6.);\n  rrCut = rCut * rCut;\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    rr = dot (dr, dr);\n    if (n != mId && rr < rrCut) {\n      rri = 1. / rr;\n      rri3 = rri * rri * rri;\n      f += 48. * rri3 * (rri3 - 0.5) * rri * dr;\n    }\n  }\n  bLen = bFac * float (nMolEdge);\n  dr = 0.5 * (bLen + rCut) - abs (p.xy);\n  if (dr.x < rCut) {\n    if (p.x > 0.) dr.x = - dr.x;\n    rri = 1. / (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x += 48. * rri3 * (rri3 - 0.5) * rri * dr.x;\n  }\n  if (dr.y < rCut) {\n    if (p.y > 0.) dr.y = - dr.y;\n    rri = 1. / (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y += 48. * rri3 * (rri3 - 0.5) * rri * dr.y;\n  }\n  dt = 0.005;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  const float pi = 3.14159;\n  y = float (mId / nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  int mId;\n  vec2 kv = floor (fragCoord);\n  mId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || mId > nMol) discard;\n  if (iFrame <= 5) {\n    bFac = 1.1;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    ++ stDat.x;\n    bFac = stDat.y;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 50.) {\n      stDat.x = 0.;\n      p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}