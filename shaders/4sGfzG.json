{
    "Shader": {
        "info": {
            "date": "1529220548",
            "description": "apply shapes to  [url]https://shadertoy.com/view/Ms3BR2[/url] points distributions ( mix on blue and white noise, i.e. quasi Poisson-disk and Poisson).\n\nNB: blue noise distrib gives more even random (white distrib cause packs and holes) + a lot cheaper.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sGfzG",
            "likes": 15,
            "name": "Shapes distribution",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "utils",
                "gabor",
                "sparseconvolution",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1285
        },
        "renderpass": [
            {
                "code": "// Variant of \"blue spotnoise, sparse convol\" https://shadertoy.com/view/Ms3BR2\n// Shapes from \"Brick & Tiles & BasketWeave\" by FabriceNeyret2. https://shadertoy.com/view/XdtBzn\n\n#define MM 0\n\n\n#define VARIANT 0      // 1: enlarge tested region around cell\nfloat ofs = 0.;        // jitter centers in -ofs ... 1.+ofs\n\nvec2  CYCLE = vec2(0); // pattern repeat scale ( in #cells )\n\nfloat CELL = 20.,      // number of cells along height\n     RATIO = 1.,       // cell length / cell width\n    RADIUS = 1.,       // dot size ( in CELL% ) . Equivalent to filtering dots\n  RADIUS_D = 1.,       // size distribution \n     AMP_D = .5,       // dot intensity distribution around .5 (attention: same seed)\n      ROT0 = 0.,       // brick fix rotation ( degrees )\n      ROT1 = 180.,     // brick random rotation amplitude (degrees)\n      LACUNARITY = 4.; // scale jump per level\n\nint     NB = 1,        // NB dot per cell ( 1 = blue noise, more = stratified )\n     DEPTH = 1,        // fractal cascade of dots\n     SHAPE = 1,\n     BLEND = 0;        // combination: 0: add (continuum) 1: max (spots)\n\n// for shapes:  [multishape] = UNUSED here for now \nfloat ROUND = 1./4.,               // radius of round corners\n      polyN  = 5.,                 // nb sides for polygon and star shape\n      starR  = .5,                 // star interior radius ( % exterior )\n      ROTshape0 = 0.,              // [multishape] shape fix rotation ( degrees )\n      ROTshape1 = 0.;              // [multishape] shape random rotation amplitude (degrees)\n\nvec2  BEVEL = vec2(.5)/4.,         // bevel width ( cell %  )\n      shapeN = vec2(1),            // [multishape] tiling of shapes in the brick area\n      shapeGap = vec2(0)/8.;       // [multishape] gap between shapes ( cell % )\n      \nint   RAND = 0,                    // 0: white bricks. 1: random B&W. 2: random col\n      TEXT = 2,                    // 0: plein 1: one texture 2: two textures\n      GRAD = 0;                    // gradient through bricks\nvec2  grad = vec2(1,0);            // grad direction & strength\nfloat grad_randA = 2.,             // spread in amplitude ( amp * [1/A,A] )\n      grad_randD = 360.;           // spread in direction ( degrees )\n\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\n#define hash3i(x) hash3(uvec3(ivec3(floor(x)))) // because of uint(-float) bug\n\nvec3 hash3f(vec3 x) {              // float[0,1] param\n    return hash3(uvec3( x * float(0xffffffffU) ) );\n}\n#define rot(a) mat2(sin(radians(a) + vec4(1,0,2,1)*1.5707))\n\n// === dot shape\n\nfloat profile(float d) {  // for large footprints, use VARIANT=1\n    switch(SHAPE) {\n        case 0: return d;                              // linear slope\n        case 1: return clamp(d,0.,1.);                 // clamped linear\n        case 2: return smoothstep(1.,0.,d);            // continuous bounded blob (smoothstep,=spline)\n        case 3: return exp(-.5*d*d*6.);                // gaussian ( bof )\n        case 4: d*=1.5; return sqrt(max(0.,1.-d*d));   // hemisphere\n        case 5: d = max(0.,1.-d); return 1. - sqrt(1.-d*d );// antisphere (peak)\n    }\n}\n\n\n// --- custom shapes: local centered coordinates, box size, shape id (=hash)\n// rectangular brick\nvec4 shapeTile(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n    vec2 A = Box/2. - abs(U),                   // coords from borders \n         B  = A * 2. / BEVEL;                   // coords in bevel\n        float m = min(B.x,B.y);                 // in bevel if [0,1]\n    if (A.x<ROUND && A.y<ROUND)                 // round edges\n        m = (ROUND-length(ROUND-A)) *2./dot(BEVEL,normalize(ROUND-A));\n    \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// disc brick\nvec4 shapeDisc(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n    float A = Box.y/2. - length(U),             // distance from borders \n          B = A * 2. / BEVEL.y,                 // distance in bevel\n          m = B;                                // in bevel if [0,1]\n    \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// poly brick\nvec4 shapePoly(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n     float a = atan(U.x,U.y) + radians(ROTshape0 + ROTshape1*(-1.+2.*hash3f(vec3(id,.4,0)).x)), \n           l = length(U),\n           b = 3.14159/polyN,\n           A = Box.y/2. - l * cos(mod(a,2.*b)-b) / cos(b),\n           B = A * 2. / BEVEL.y,                // distance in bevel\n           m = B;                               // in bevel if [0,1]\n          \n    \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// star brick\nvec4 shapeStar(vec2 U, vec2 Box, float vert, float id) {\n    vec4 O = vec4(0);\n     float a = atan(U.x,-U.y) + radians(ROTshape0 + ROTshape1*(-1.+2.*hash3f(vec3(id,.4,0)).x)),\n           l = length(U),\n           b = 3.14159/polyN,\n          tb = tan(b),\n           s = .5*(starR * tb)/(sqrt(1.+tb*tb)-starR);\n    a = mod(a,2.*b)-b;\n    U = l * vec2(cos(a),sin(a)) / cos(b);\n    U.y = abs(U.y);\n    U.x -= .5*Box.y;\n    float A = -(s*U.x+U.y)/sqrt(1.+s*s),\n          B = A * 2. / BEVEL.y,                 // distance in bevel\n          m = B;                                // in bevel if [0,1]\n         \n    O += profile( clamp( m ,0.,1.) );           // mask\n    \n    if (GRAD>0) {\n        vec3 R = -1.+2.*hash3f(vec3(id,.3,0));  // rand grad variation\n        grad *= rot(grad_randD/2.*R.x) * pow(grad_randA,R.y);\n        O.rgb *= .5 + dot(grad,U);              // lum gradient across brick\n    }\n#if !MM\n    if (RAND>0) {                               // color bricks\n        vec3 R = hash3f(vec3(id,.2,0));         // brick seed\n        O.rgb *= RAND==1 ? R.xxx : R;\n    }\n    if (TEXT>0) {                               // texture mapped on brick\n        vec4 T = texture(iChannel0, U);\n        if (TEXT==2 && vert>0.) T = texture(iChannel1, U);\n        O *= T;\n    }\n#endif\n    return O;\n}\n\n// --- higher level custom shape: using serval other shapes.\n// here: draw a tiling of shapes\nvec4 shaper(vec2 U, vec2 Box, float vert, float id) {\n#if 1                                 // no [multishape]\n  //return shapePoly(U,Box,vert,id);                \n    return shapeStar(U,Box,vert,id);                \n  //return shapeTile(U,Box,vert,id);               \n#else                                 // [multishape]\n    vec4 O = vec4(0);\n    vec2 N = shapeN-1.,\n       ofs = Box/shapeN;\n    Box = Box/shapeN - shapeGap;\n    //Box = vec2(min(Box.x,Box.y)); //  <- comment for adjustable shapes\n    for (float n=1., j = -N.y/2.; j <=N.y/2.; j++)\n        for (float i = -N.x/2.; i <=N.x/2.; i++, n++)\n            O += shapeTile(U+vec2(i,j)*ofs,Box, vert, hash3f(vec3(id,.9/n++,0)).x);\n    return O;\n#endif\n}\n\n\n// === Voronoi =====================================================\n// --- Base Voronoi. inspired by https://www.shadertoy.com/view/MslGD8\n\n#define hash22(p)  fract( 18.5453 * sin( p * mat2(127.1,311.7,269.5,183.3)) )\n#define disp(p) ( -ofs + (1.+2.*ofs) * hash22(p) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.y;\n    // demo( floor(U.x-iTime-.2*sin(4.*U.y-3.*iTime)) +4.); // demo mode\n    vec2 W = vec2(RATIO,1);\n    U *= CELL / W;\n    //U.x += iTime;                                   // for demo\n    vec2 U0 = U; \n    O-=O; \n    float dir = 0.,  id = -1.;                        // background id\n\tfloat s = 1., t=0., height;\n    \n    for (int i=0; i<DEPTH; i++) {\n        vec2 u = U, iu = floor(u);\n        height = 0.;\n        #if VARIANT\n        for( int k=0; k < 25; k++ ) {                 // loop on neighbord cells\n            vec2 p = iu + vec2(k%5-2,k/5-2);          // searching for rock\n        #else\n        for( int k=0; k < 9; k++ ) {\n            vec2 p = iu + vec2(k%3-1,k/3-1);\n        #endif\n            for( int n=0; n<NB; n++) {\n                vec3 H = hash3i(vec3(CYCLE==vec2(0)?p:mod(p,CYCLE),n));\n                vec2 //o = disp(p),\n                       o = ( -ofs + (1.+2.*ofs) * H.xy ),\n                       r = p - u + o;\n\n                r *= W;\n                r /= RADIUS * (1.+RADIUS_D*(2.*H.z-1.));\n                H = hash3f(H);\n                float id0 = H.x,\n                     dir0 = ROT0 + ROT1 * (-1.+2.*H.y); // shape rotation\n                r *= rot(dir0);\n\n                float a = .5 + AMP_D*(2.*H.z-1.),\n                      h = a* shaper(r, vec2(1), 0., id0).x;\n\n                if (BLEND == 0)  height += h ;\n                else             height = max(height, h);\n                if ( (i==0 || id<0.)  && \n                     h>0. && h==height) dir = dir0, id = id0;\n            }\n        }\n        O += s * height;\n        U *= LACUNARITY; CYCLE *= LACUNARITY;\n#if 1                                          // if amplitude decrease with depth\n        t += s; s /= LACUNARITY;\n#endif\n    }\n                \n    if (BLEND==1) O /= t;                      // optional normalization\n        \n#if !MM        \n    O *= vec4(1,.8,.6,1)*2.;                   // for demo\n#else\n // O-=O;\n    O.r = id;                                  // tile id\n // O.g = O.g;                                 // image(height)\n    O.b = dir;                                 // direction (degrees)\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// autodemo touches most parameters\n\n#define demo(t) {                                    \\\n    vec3 h1 = hash3i(t*vec3( 1  , 7.2,-3.1)),        \\\n         h2 = hash3i(t*vec3( 7.2,-3.1, 9.7));        \\\n      NB = 1+int(2.*h1.x);                           \\\n   DEPTH = 1+int(2.*h1.y);                           \\\n   SHAPE = int(4.*h1.z);                             \\\n   if (h2.x>.66) RADIUS_D = .3; else if (h2.x>.33) AMP_D = .3; \\\n   BLEND = int(2.*h2.y);                             \\\n   if (h2.z>.7) CELL=60.,RATIO=30.;                  \\\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}