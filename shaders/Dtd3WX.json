{
    "Shader": {
        "info": {
            "date": "1683233029",
            "description": "Fork of https://www.shadertoy.com/view/dsVXRm\nAn even bigger 3d model, this time a sphere with 720 triangles !\nI also generate the mesh, instead of hard-coding one in the code",
            "flags": 32,
            "hasliked": 0,
            "id": "Dtd3WX",
            "likes": 1,
            "name": "3D rasterized sphere",
            "published": 3,
            "tags": [
                "3d",
                "rasterizer",
                "triangle"
            ],
            "usePreview": 0,
            "username": "GetItemFromBlock",
            "viewed": 176
        },
        "renderpass": [
            {
                "code": "// Fork of \"3D low poly rotating Amogus\" by GetItemFromBlock. https://shadertoy.com/view/dsVXRm\n// GetItemFromBlock - 2023-05-04\n\n// Based on \"Rasterizer - Cube\" by iq. https://shadertoy.com/view/XdlGzn\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 rasterize(in vec2 coord)\n{\n    vec2 px = (2.0*coord-iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.478,0.478,0.478);\n    // clear zbuffer\n    float mindist = -1000000.0;\n    \n    for (int i = 0; i < LONGITUDE * (LATITUDE - 1) * 2; i++)\n    {\n        ivec2 tCoord = ivec2(i % int(iResolution.x), i / int(iResolution.x) * 7);\n        vec4 bounds = texelFetch(iChannel0, ivec2(tCoord.x, tCoord.y + 3), 0);\n        if (px.x < bounds.x || px.x > bounds.y || px.y < bounds.z || px.y > bounds.w)\n        {\n            continue;\n        }\n        vec4 frb = texelFetch(iChannel0, ivec2(tCoord.x, tCoord.y + 1), 0);\n        vec4 frc = texelFetch(iChannel0, ivec2(tCoord.x, tCoord.y + 2), 0);\n        vec2 cp0 = frb.xy;\n        vec2 cp1 = frb.zw;\n        vec2 cp2 = frc.xy;\n\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n                        \n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            vec4 fra = texelFetch(iChannel0, tCoord, 0);\n            float w0 = fra.x;\n            float w1 = fra.y;\n            float w2 = fra.z;\n            \n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n            \n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                \n                vec3 a = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y), 0).xyz;\n                vec3 b = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 1), 0).xyz;\n                vec3 c = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 2), 0).xyz;\n            \n                vec3 p0 = a * w0;\n                vec3 p1 = b * w1;\n                vec3 p2 = c * w2;\n                \n                vec3 na = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 3), 0).xyz * w0;\n                vec3 nb = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 4), 0).xyz * w1;\n                vec3 nc = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 5), 0).xyz * w2;\n\n                vec3 n = ba.x*na + ba.y*nb + ba.z*nc;\n                \n\t\t\t\t// perform lighting/shading \n                vec3 cameraPos = texelFetch(iChannel1, ivec2(0,4), 0).rgb;\n                vec3 col = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 6), 0).xyz;\n                vec3 worldPos = p0 * ba.x + p1 * ba.y + p2 * ba.z;\n                worldPos *= z;\n                n = normalize(n*z);\n\t\t\t\tcolor = shader(normalize(-cameraPos-worldPos), n, col);\n                \n\t\t\t}\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord/2.), 0)*-5.;\n    fragColor = vec4(rasterize(fragCoord), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 processTriangle(ivec2 coord, int subdata)\n{\n\tmat4 mvp = mat4(\n        texelFetch(iChannel0,ivec2(0,0),0),\n        texelFetch(iChannel0,ivec2(0,1),0),\n        texelFetch(iChannel0,ivec2(0,2),0),\n        texelFetch(iChannel0,ivec2(0,3),0)\n    );\n    vec3 a = texelFetch(iChannel1, ivec2(coord.x, coord.y), 0).xyz;\n    vec3 b = texelFetch(iChannel1, ivec2(coord.x, coord.y + 1), 0).xyz;\n    vec3 c = texelFetch(iChannel1, ivec2(coord.x, coord.y + 2), 0).xyz;\n    vec3 ep0 = (mvp * vec4(a,1.0)).xyz;\n    vec3 ep1 = (mvp * vec4(b,1.0)).xyz;\n    vec3 ep2 = (mvp * vec4(c,1.0)).xyz;\n\n    // transform to clip space\n    float w0 = 1.0/ep0.z;\n    float w1 = 1.0/ep1.z;\n    float w2 = 1.0/ep2.z;\n\n    if (subdata == 0)\n    {\n        return vec4(w0,w1,w2,0);\n    }\n\n    vec2 cp0 = 2.0*ep0.xy * -w0;\n    vec2 cp1 = 2.0*ep1.xy * -w1;\n    vec2 cp2 = 2.0*ep2.xy * -w2;\n    if (subdata == 1)\n    {\n        return vec4(cp0, cp1);\n    }\n    else if (subdata == 2)\n    {\n        return vec4(cp2, 0, 0);\n    }\n    float minY = min(min(cp0.y, cp1.y), cp2.y);\n    float maxY = max(max(cp0.y, cp1.y), cp2.y);\n    float minX = min(min(cp0.x, cp1.x), cp2.x);\n    float maxX = max(max(cp0.x, cp1.x), cp2.x);\n    return vec4(minX, maxX, minY, maxY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    int index = coord.y / 7 * int(iResolution.x) + coord.x;\n    int subdata = coord.y % 7;\n    if (index >= LONGITUDE * (LATITUDE - 1) * 2 || subdata > 3)\n    {\n        discard;\n    }\n    fragColor = processTriangle(ivec2(index % int(iResolution.x), index / int(iResolution.x) * 7), subdata);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define LONGITUDE 24\n#define LATITUDE 16\n#define M_PI   3.141593\n#define M_PI_2 1.570796\n\nfloat cross2d( in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nconst vec3 lightDir = normalize(vec3(.5, 1, -1));\nconst vec3 lightCol = vec3(.5, .5, .5);\nconst float smoothness = 256.;\n\nvec3 shader(vec3 view, vec3 normal, vec3 color)\n{\n    float deltaA = dot(lightDir,normal);\n    if (deltaA < 0.) deltaA = 0.;\n    vec3 halfV = normalize(lightDir + view);\n    float deltaB = pow(max(dot(normal,halfV), .0), smoothness);\n    return color + lightCol * deltaA + deltaB * .5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < 1)\n    {\n        float rx = iMouse.z <= 0. ? .3 + .3 * sin(iTime * .55) : (iMouse.y/iResolution.y-.5)*-3.1415;\n        float ry = iMouse.z <= 0. ? .3*iTime : iMouse.x/iResolution.x*10.;\n        if (coord.y < 5)\n        {\n            if (coord.y == 4)\n            {\n                fragColor = vec4(0,0,-8,0) * setRotation( rx, 0.,  0. ) * setRotation( 0., ry, 0. );\n            }\n            else\n            {\n                mat4 mvp = setTranslation(0., 0., -8. ) * \n                   setRotation( rx, 0.,  0. ) * \n                   setRotation( 0., ry, 0. );\n                fragColor = mvp[coord.y];\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 GetSphericalCoord(float longitude, float latitude)\n{\n    return vec3(cos(longitude)*cos(latitude),sin(latitude), sin(longitude) * cos(latitude));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    int index = pos.y / 7 * int(iResolution.x) + pos.x;\n    int subdata = pos.y % 7;\n    if (index >= LONGITUDE * (LATITUDE - 1) * 2) discard;\n    float ref = texelFetch(iChannel0, ivec2(0),0).w;\n    if (ref == iResolution.x)\n    {\n        fragColor = texelFetch(iChannel0, pos, 0);\n        return;\n    }\n    bool second = index >= LONGITUDE * (LATITUDE - 1);\n    if (subdata == 6)\n    {\n        if ((index & 0x1) == 0)\n        {\n            fragColor = vec4(.5, second ? .5 : .0, 0, 0);\n        }\n        else\n        {\n            fragColor = vec4(0, .5, second ? .5 : .0, 0);\n        }\n        return;\n    }\n    float DtY = M_PI / float(LATITUDE);\n    float DtX = 2. * M_PI / float(LONGITUDE);\n    int a = index % LONGITUDE;\n    int b = index / LONGITUDE + 1;\n    if (second)\n    {\n        b = b - LATITUDE + 2;\n    }\n    vec3 vert;\n    if (subdata == 0 || subdata == 3)\n    {\n        vert = GetSphericalCoord(DtX * float(a), DtY * float(second ? b - 1 : b) - M_PI_2);\n    }\n    else if (subdata == 1 || subdata == 4)\n    {\n        vert = GetSphericalCoord(DtX * float(second ? a : a + 1), DtY * float(b) - M_PI_2);\n    }\n    else\n    {\n        vert = GetSphericalCoord(DtX * float(a + 1), DtY * float(b - 1) - M_PI_2);\n    }\n    if (subdata < 3)\n    {\n        fragColor = vec4(vert * 2., 0);\n    }\n    else\n    {\n        fragColor = vec4(normalize(vert), 0);\n    }\n    if (pos.x == 0 && pos.y == 0) fragColor.w = iResolution.x;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}