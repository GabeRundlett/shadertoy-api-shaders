{
    "Shader": {
        "info": {
            "date": "1527461818",
            "description": "Mathematical 3d sphere.\n\nEverything you see here is created by maths. There is no 3d model in the scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "ls3BDl",
            "likes": 2,
            "name": "3d Sphere",
            "published": 3,
            "tags": [
                "3d",
                "sphere"
            ],
            "usePreview": 0,
            "username": "pedrolb",
            "viewed": 551
        },
        "renderpass": [
            {
                "code": "\n// Main infos\nvec3 camPosition = vec3(0.0, 0.0, 2.0);\nvec2 sphereCenter = vec2(0.0, 0.0); // sphere center in pixels\nfloat sphereRadius = 0.2; //sphere radius in pixels\n\n// Get 3d surface position\nvec3 sphereSurfacePosition(vec2 surfacePos, vec2 sphereC)\n{\n    float z = sqrt(\n                sphereRadius * sphereRadius\n                - surfacePos.x * surfacePos.x\n                - surfacePos.y * surfacePos.y\n            );\n    vec3 localPos = vec3(surfacePos.x, surfacePos.y, z);\n    return (vec3(sphereC, 1.0) + localPos);\n}\n\n\n// Get 3d normal vector of the sphere\nvec3 sphereNormal(vec2 surfacePos)\n{\n    float z = sqrt(\n                sphereRadius * sphereRadius\n                - surfacePos.x * surfacePos.x\n                - surfacePos.y * surfacePos.y\n            );\n    vec3 normal = normalize (vec3(surfacePos.x, surfacePos.y, z));\n    \n\treturn normal;\n}\n\n\n// Make a light pass\nvec3 pointLightPass ( \n    vec3 camPos,\n    vec3 lightPos /* [-1, 1] space relative */,\n    vec3 lightColor,\n    float lightIntensity,\n    vec3 objectColor, \n    vec3 surfaceNormal, \n    vec3 surfacePos /* [-1, 1] space relative */,\n    float diffuseIntensity, \n    float specularIntensity)\n{\n    /*\n\td = distance between the light’s surface and the point being shaded\n\tr = the light’s radius\n\t*/\n    float d = length(lightPos - surfacePos);\n    vec3 lightDirection = normalize(lightPos - surfacePos);\n    float r = 0.4;\n    \n    float lightAtten = 1.0 / (1.0 + 2.0 * d / r + 1.0 * d * d / (r * r));\n    \n    vec3 diffuseLighting =\n        clamp(dot(lightDirection, surfaceNormal), 0.0, 1.0) *\n        lightAtten *\n        lightColor * \n        lightIntensity *\n        objectColor *\n        diffuseIntensity;\n    \n    // Bouncing from the bottom\n    vec3 NB = surfacePos - vec3((surfacePos + lightPos).x / 2.0, -1.0, (surfacePos + lightPos).z / 2.0);\n    vec3 LB = lightPos - vec3((surfacePos + lightPos).x / 2.0, -1.0, (surfacePos + lightPos).z / 2.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float dB = length(NB) + length(LB);\n    float attenBottom = 1.0 / (1.0 + 2.0 * dB / r + 1.0 * dB * dB / (r * r));\n    \n    vec3 bouncingBottom =\n        (1.0 - max(dot(normalize(NB), up), 0.0)) * (1.0 - max(dot(normalize(LB), up), 0.0)) *\n        attenBottom *\n        lightColor *\n        lightIntensity *\n        objectColor *\n        diffuseIntensity;\n    \n    // Bouncing from the up\n    vec3 NU = surfacePos - vec3((surfacePos + lightPos).x / 2.0, 1.0, (surfacePos + lightPos).z / 2.0);\n    vec3 LU = lightPos - vec3((surfacePos + lightPos).x / 2.0, 1.0, (surfacePos + lightPos).z / 2.0);\n    vec3 down = vec3(0.0, -1.0, 0.0);\n    float dU = length(NU) + length(LU);\n    float attenUp = 1.0 / (1.0 + 2.0 * dU / r + 1.0 * dU * dU / (r * r));\n    \n    vec3 bouncingUp =\n        (1.0 - max(dot(normalize(NU), down), 0.0)) * (1.0 - max(dot(normalize(LU), down), 0.0)) *\n        attenUp *\n        lightColor *\n        lightIntensity *\n        objectColor *\n        diffuseIntensity;\n    \n    // Bounging from right    \n    vec3 NR = surfacePos - vec3(1.0, (surfacePos + lightPos).y / 2.0, (surfacePos + lightPos).z / 2.0);\n    vec3 LR = lightPos - vec3(1.0, (surfacePos + lightPos).y / 2.0, (surfacePos + lightPos).z / 2.0);\n    vec3 left = vec3(-1.0, 0.0, 0.0);\n    float dR = length(NR) + length(LR);\n    float attenRight = 1.0 / (1.0 + 2.0 * dR / r + 1.0 * dR * dR / (r * r));\n    \n    vec3 bouncingRight =\n        (1.0 - max(dot(normalize(NR), left), 0.0)) * (1.0 - max(dot(normalize(LR), left), 0.0)) *\n        attenRight *\n        lightColor *\n        lightIntensity *\n        objectColor *\n        diffuseIntensity;\n    \n    // Bounging from left  \n    vec3 NL = surfacePos - vec3(-1.0, (surfacePos + lightPos).y / 2.0, (surfacePos + lightPos).z / 2.0);\n    vec3 LL = lightPos - vec3(-1.0, (surfacePos + lightPos).y / 2.0, (surfacePos + lightPos).z / 2.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    float dL = length(NL) + length(LL);\n    float attenLeft = 1.0 / (1.0 + 2.0 * dL / r + 1.0 * dL * dL / (r * r));\n    \n    vec3 bouncingLeft =\n        (1.0 - max(dot(normalize(NL), right), 0.0)) * (1.0 - max(dot(normalize(LL), right), 0.0)) *\n        attenLeft *\n        lightColor *\n        lightIntensity *\n        objectColor *\n        diffuseIntensity;\n    \n    vec3 camVect = normalize(camPos - surfacePos);\n    vec3 reflectedLight = reflect(lightDirection, surfaceNormal);\n    vec3 specularLighting = \n        lightAtten * \n        lightColor * \n        lightIntensity * \n        specularIntensity * \n        vec3(pow(max(dot(camVect, reflectedLight), 0.0), 3.0) * 0.2);\n    \n    vec3 lightingFinal = \n        diffuseLighting * 0.7 + diffuseLighting * diffuseLighting * 0.3 + \n        bouncingBottom * 0.5 + \n        bouncingUp * 0.5 + \n        bouncingRight * 0.5 + \n        bouncingLeft * 0.5 +\n        specularLighting;\n    \n    return lightingFinal;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphereCenter = vec2(sin(2.0 * 3.14 * 0.2 * iTime) * 0.5 + cos(2.0 * 3.14 * 0.1 * iTime) * 0.2,\n                        sin(2.0 * 3.14 * 0.5 * iTime) * 0.15 + cos(2.0 * 3.14 * 0.3 * iTime) * 0.15);\n    \n    vec2 screenPos = fragCoord / iResolution.xy * 2.0 - 1.0; // pixelsToRelativePosition [0 - 1]\n\tvec2 current2dRadius = screenPos - sphereCenter;\n    current2dRadius *= vec2(1, iResolution.y / iResolution.x); // adjustment of the ratio\n    vec3 sphereDiffuseColor = vec3 (0.5, 0.5, 0.7);\n    vec3 outColor;\n    \n    // pixel inside the circle\n    if(length(current2dRadius) < sphereRadius)\n    {\n    \toutColor = \n        \tpointLightPass(\n                camPosition,\n                vec3(1.0, 0.6, 1.0) /*light postion*/,\n                vec3(1.0) /*light color*/,\n                4.0 /*light intensity*/,\n                sphereDiffuseColor,\n                sphereNormal(current2dRadius),\n                sphereSurfacePosition(current2dRadius, sphereCenter),        \t\n                1.0 /*diffuse intensity*/,\n                1.0 /*specular intensity*/)\n            +\n            pointLightPass(\n                camPosition,\n                vec3(0.0, 1.0, -0.0) /*light postion*/,\n                vec3(1.0, 0.9, 0.9) /*light color*/,\n                10.0 /*light intensity*/,\n                sphereDiffuseColor,\n                sphereNormal(current2dRadius),\n                sphereSurfacePosition(current2dRadius, sphereCenter),        \t\n                0.5 /*diffuse intensity*/,\n                1.0 /*specular intensity*/)\n            +\n            pointLightPass(\n                camPosition,\n                vec3(-1.0, 0.0, 1.0) /*light postion*/,\n                vec3(1.0, 0.73, 0.7) /*light color*/,\n                2.0 /*light intensity*/,\n                sphereDiffuseColor,\n                sphereNormal(current2dRadius),\n                sphereSurfacePosition(current2dRadius, sphereCenter),        \t\n                1.0 /*diffuse intensity*/,\n                1.0 /*specular intensity*/)\n        +\n            pointLightPass(\n                camPosition,\n                vec3(0.0, -1.0, 1.0) /*light postion*/,\n                vec3(0.4, 0.73, 1.0) /*light color*/,\n                4.0 /*light intensity*/,\n                sphereDiffuseColor,\n                sphereNormal(current2dRadius),\n                sphereSurfacePosition(current2dRadius, sphereCenter),        \t\n                1.0 /*diffuse intensity*/,\n                1.0 /*specular intensity*/);\n    }\n    // pixel out of the circle\n    else\n    {\n        outColor = vec3(0.1, 0.1, 0.1);\n    }\n\n    // Output to screen\n    fragColor = vec4(outColor,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}