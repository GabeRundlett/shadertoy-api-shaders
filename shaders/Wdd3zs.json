{
    "Shader": {
        "info": {
            "date": "1569137758",
            "description": "This shader has a focus on code readability. It displays a simple raytraced scene demonstrating shadows, reflections, and refraction.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wdd3zs",
            "likes": 6,
            "name": "Raytracing Demo",
            "published": 3,
            "tags": [
                "raytracing",
                "refraction",
                "shadows",
                "reflections"
            ],
            "usePreview": 0,
            "username": "pineapplemachine",
            "viewed": 613
        },
        "renderpass": [
            {
                "code": "// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}