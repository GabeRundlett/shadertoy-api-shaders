{
    "Shader": {
        "info": {
            "date": "1648806513",
            "description": "Engine Ready isotropic GGX NDF",
            "flags": 32,
            "hasliked": 0,
            "id": "flsyWX",
            "likes": 3,
            "name": "NDF: GGX Isotropic",
            "published": 3,
            "tags": [
                "microfacet",
                "ggx",
                "isotropy"
            ],
            "usePreview": 0,
            "username": "H4w0",
            "viewed": 587
        },
        "renderpass": [
            {
                "code": "//=======================================================\n//= Normal Distribution Function : GGX Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/NtlyWX\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Shader references:\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//== *- UI courtesy of Good's https://www.shadertoy.com/view/XlG3WD\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_COL  = vec3(0.0);\n\n\n//-----------------------------------------------------------------------------\n//-- UI Functions -------------------------------------------------------------\n/* Access */\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\n/* Sliders */\nfloat slider_roughness() { return(readFloat(1.)); }\nfloat slider_metalness()  { return(readFloat(2.) > 0.5 ? 1. : 0.); }\nfloat slicer_reflectance(){ return(clamp(readFloat(3.),0.35,1.0)); }\n\n//-----------------------------------------------------------------------------\n//-- GGX ----------------------------------------------------------------------\n\nfloat ggx_isotropic_ndf(float NoH, float alpha) \n{\n    float a = NoH * alpha;\n    float k = alpha / (1.0 - NoH * NoH + a * a);\n    return k * k * m_i_pi;\n}\n\nfloat ggx_isotropic_visibility(float NoV, float NoL, float alpha) \n{\n    float a2 = alpha * alpha;\n    float GV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GV + GL);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float cosTheta, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_COL; }\n\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\n    \n    \n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        /* Retrieve Scene data */\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        /* Material Data */\n        \n        /* 1. Perceptual Roughness Mapping \\f$ \\alpha^2 \\f$  */\n        float alpha = slider_roughness() * slider_roughness();\n        /* 3. Gold F0 */ \n        vec3 albedo = vec3(1.00, 0.85, 0.57); /* sRGB */\n        vec3 linear_albedo =  pow(albedo,vec3(2.2));\n        /* 4. Metalness */ \n        float metalness = slider_metalness();\n        /* 5. Reflectance */ \n        float reflectance = slicer_reflectance();\n        \n               \n        /* Computing HalfVector */\n        vec3 H = normalize(L+V);\n        \n        /* Computing Dots */\n        /* 1. Distribution dot Terms */\n        float NoH = dot(N,H);\n        /* 2. Visibility dot Terms */\n        float NoV = dot(N,V);\n        float NoL = dot(N,L);\n        \n        /* Computing Normal Distribution Term \\f$ D(\\omega_h) \\f$ */\n        float D   = ggx_isotropic_ndf( NoH, alpha );\n        \n        /* Computing Visibility Term */\n        /* \\f$ \\frac{G(\\omega_o,\\omega_i,\\alpha_t,\\alpha_b)}{4(\\omega_g\\cdot\\omega_i)(\\omega_g\\cdot\\omega_o)} \\f$ */\n        float Vis = ggx_isotropic_visibility(NoV, NoL, alpha); \n        \n        /* Computing Fresnel Term */\n        /* Using reflectance mapping as in Filament PBR Pipeline */\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metalness) + linear_albedo*metalness;\n        vec3 F = fresnel_schlick(max(dot(V,H), 0.0), F0);\n        \n        /* Lighting */\n        vec3 specular_microfacet = D * Vis * F;\n        vec3 diffuse_lambert = m_i_pi*(1.-metalness)*linear_albedo;\n        vec3 diffuse_factor  = vec3(1.)-F; \n            \n        /* Final color */\n        color = max(NoL,0.) * get_light_intensity() * ( diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n\n\n    // UI\n    vec4 ui = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n    \n    // Tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359f; /* MathConstant: PI        */\nconst float m_2_pi      = 6.28318530718f; /* MathConstant: 2 PI      */\nconst float m_i_pi      = 0.31830988618f; /* MathConstant: 1 / PI    */\nconst float m_sqrt_2    = 1.41421356237f; /* MathConstant: sqrt(2)   */\nconst float m_i_sqrt_2  = 0.70710678119f; /* MathConstant: 1/sqrt(2) */\nconst float m_eps_3f    = 0.001f;            \nconst float m_eps_4f    = 0.0001f;    \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        u = vec3(0 , -1, 0);\n        v = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        u = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        v = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(u,v,n) );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// From  2D Canvas with UI by Good\n// Link : https://www.shadertoy.com/view/XlG3WD\n// \n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(30,220,140,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n        \n    //define sliders    \n    EASYSLIDER(1,.2)  _R O U G H N E S S   \n    EASYSLIDER(2,1.)  _M E T A L N E S S      \n    EASYSLIDER(3,1.)  _R E F L E C T A N C E \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    \n    fragColor=result;    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}