{
    "Shader": {
        "info": {
            "date": "1672872943",
            "description": "Use the mouse to add sand.\n\nI made this shader as an experiment to demonstrate the use of two buffers to simulate sand in some fragment shaders. Particles will often merge together, but I think it works quite well otherwise.",
            "flags": 32,
            "hasliked": 0,
            "id": "dlf3zn",
            "likes": 21,
            "name": "Sand Simulation",
            "published": 3,
            "tags": [
                "sand",
                "cellularautomata"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 943
        },
        "renderpass": [
            {
                "code": "/*\n * Sand Simulation\n * \n * This shader uses two buffers to perform two passes on the tile world on each frame.\n * Buffer A determines where each particle should move to\n * Buffer B applies the movements determined by Buffer A\n *\n */\n\nvec3 blankCol = vec3(0.0);\nvec3 solidCol = vec3(0.6);\nvec3 sandCol = vec3(1.0, 1.0, 0.9);\nvec3 waterCol = vec3(0.2, 0.5, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 rawSim = texture(iChannel0, uv);\n    \n    float tileType = rawSim.z;\n    \n    vec3 col = blankCol;\n    if (tileType == 0.01) col = solidCol;\n    if (tileType == 0.1) col = sandCol;\n    if (tileType == 0.2) col = waterCol;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * Sand Simulation - Buffer A\n * \n * Handles particle behavior — determines where the particles should move to\n *\n */\n \nconst bool generateStartingScene = true;\n\nconst float mouseType = 0.1; // Controls what tile is placed by the mouse cursor\n\n/*\n * Tile Types\n * \n * Nothing - 0\n * Solid - 0.01\n * Sand - 0.1\n * Water (broken) - 0.2\n *\n */\n\nvec3 getTile(vec2 fragCoord) {\n    return texture(iChannel0, fragCoord/iResolution.xy).rgb;\n}\n\n// Determines where this should particle move to next.\nvec2 particleVelocity(vec3 tile, vec2 fragCoord) {\n    float tileType = tile.z;\n    vec2 velocity = tile.xy;\n    if (tileType >= 0.1) {\n        \n        if (getTile(fragCoord + vec2(0.0, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n            int depth;\n            for (depth = 1; depth <= min(1 - int(velocity.y), movementRange); depth++) {\n                if (!(getTile(fragCoord + vec2(0.0, -depth)).z == 0. && (fragCoord + vec2(0.0, -depth)).y >= 0.)) {\n                    return vec2(0.0, float(-depth) + 1.);\n                }\n            }\n            return vec2(0.0, float(-depth) + 1.);\n        }\n        \n        //if (getTile(fragCoord + vec2(0.0, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n        //    return vec2(0.0, -1.0);\n        //}\n        \n        float side = 2. * round(hash13(uvec3(fragCoord, iFrame))) - 1.;\n        \n        if (getTile(fragCoord + vec2(side, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n            return vec2(side, -1.0);\n        }\n        if (getTile(fragCoord + vec2(-side, -1.0)).z == 0. && (fragCoord + vec2(0.0, -1.0)).y >= 0.) {\n            return vec2(-side, -1.0);\n        }\n        \n        // Attempt at water\n        if (tileType >= 0.2) {\n            float side = 2. * round(hash13(uvec3(fragCoord, 2 * (iFrame + 3)))) - 1.;\n            //side = 1.;\n            \n            if (getTile(fragCoord + vec2(side, 0.0)).z == 0. && (fragCoord + vec2(side, 0.0)).x >= 0.) {\n                return vec2(side, 0.0);\n            }\n            if (getTile(fragCoord + vec2(-side, 0.0)).z == 0. && (fragCoord + vec2(-side, 0.0)).x >= 0.) {\n                return vec2(-side, 0.0);\n            }\n        }\n    }\n    return vec2(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 inputColor;\n    \n    if (iFrame < 5 && generateStartingScene) {\n        float noise = perlin(fragCoord/50. * vec2(0.6, 1.0) + iDate.w);\n        if (noise > 0.7) {\n            inputColor = vec3(0.01);\n        } else if (noise > 0.65) {\n            inputColor = vec3(0.1);\n        }\n    } else {\n        inputColor = getTile(fragCoord).rgb;\n    }\n    \n    vec3 tile = inputColor.xyz;\n    \n    vec4 mouse = iMouse;\n    \n    if (mouse.z > 0.5 && distance(fragCoord, mouse.xy) <= 10.) {\n        tile.z = mouseType;\n    }\n    \n    fragColor = vec4(particleVelocity(tile, fragCoord), tile.z, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n * Sand Simulation - Buffer B\n * \n * Handles particle movement — applies the movements determined by Buffer A\n *\n */\n\nvec3 boxScan(vec2 fragCoord) {\n    for (int y = -movementRange; y <= movementRange; y++) {\n        for (int x = -movementRange; x <= movementRange; x++) {\n            vec3 pixel = texture(iChannel0, (fragCoord + vec2(x, y))/iResolution.xy).rgb;\n            if (pixel.z != 0.0) {\n                if (ceil(pixel.xy) == vec2(-x, -y)) {\n                    return pixel;\n                }\n            }\n        }\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(boxScan(fragCoord),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "int movementRange = 6;\n\n/* Hash functions by Nimitz:\n * https://www.shadertoy.com/view/Xt3cDn\n *\n * I use them to randomize movement of the sand, and to generate perlin noise and create the starting pattern.\n */\n\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash23(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash43(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 randUnitVector(vec2 pos) {\n    float angle = 2. * 3.1415926536 * hash13(uvec3(pos, 1.0));\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin(vec2 pos) {\n    // Grid cell corner points\n    vec2 p00 = floor(pos);\n    vec2 p01 = p00 + vec2(0, 1);\n    vec2 p11 = p00 + vec2(1, 1);\n    vec2 p10 = p00 + vec2(1, 0);\n    \n    // Random vectors at corner points\n    vec2 r00 = randUnitVector(p00);\n    vec2 r01 = randUnitVector(p01);\n    vec2 r11 = randUnitVector(p11);\n    vec2 r10 = randUnitVector(p10);\n    \n    // Dot product between random vector and distance vector\n    float d00 = dot(r00, pos - p00);\n    float d01 = dot(r01, pos - p01);\n    float d11 = dot(r11, pos - p11);\n    float d10 = dot(r10, pos - p10);\n    \n    \n    // Bicubic interpolation\n    vec2 blend = smoothstep(0., 1., fract(pos));\n    \n    float upper = float(mix(d01, d11, blend.x));\n    float lower = float(mix(d00, d10, blend.x));\n    return 0.8 * mix(lower, upper, blend.y) + 0.5;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}