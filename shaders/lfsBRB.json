{
    "Shader": {
        "info": {
            "date": "1724067271",
            "description": "Explicit expression for box-filtered gaussian function (see also [url=https://www.shadertoy.com/view/lflBR2]gaussian-filtered[/url] version).\nPictured: procedural starfield.\nLeft  - point sampling.\nRight - box filter.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfsBRB",
            "likes": 7,
            "name": "Box-filtered gaussian",
            "published": 3,
            "tags": [
                "antialiasing",
                "filtering",
                "analytical",
                "gaussian"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 123
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Explicit expression for box-filtered gaussian function (axis-aligned only).\n// Pictured: procedural starfield.\n// Left  - point sampling.\n// Right - box filter.\n\n// This is reasonably well-known, see e.g.\n//     https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/\n// See also\n//    https://iquilezles.org/articles/bandlimiting/\n//    https://iquilezles.org/articles/filterableprocedurals/\n//    https://www.shadertoy.com/playlist/l3KXR1\n// for similar expressions for some other functions.\n//\n// This example is 2D, but other dimensions are similar.\n//\n// Of course, you don't *have* to use a box filter. See\n//     http://alvyray.com/Memos/CG/Microsoft/6_pixel.pdf\n//\n// For one thing, e.g. gaussian-filtered gaussian, instead of a box\n// filter, would allow us to tackle arbitrarily rotated ellipses,\n// instead of just axis-aligned ones (including circles as a special\n// case) like we do here. This may, however, compromise partition of\n// unity.\n\n//==============================================================================\n\nconst float pi=3.14159265358979;\n\n// See https://www.shadertoy.com/view/ml3yWj.\n// Eabs<3.5e-4\n// Erel<3.6e-4\n#define erf(x) tanh((x)*(1.128776206+(x)*(x)*0.100709669))\n\n#ifndef erf\n// Approximation from \"Numerical Recipes in Fortran 77: The Art of Scientific Computing\" (ISBN 0-521-43064-X), 1992, page 214, Cambridge University Press.\n// Eabs<4.9e-7\n// Erel=1 (<3.5e-4 for |x|>1e-3)\nfloat erf(float x)\n{\n    float t=1.0/(1.0+0.5*abs(x));\n    return sign(x)*(1.0-t*exp(\n        -x*x-1.26551223\n        +t*(+1.00002368\n        +t*(+0.37409196\n        +t*(+0.09678418\n        +t*(-0.18628806\n        +t*(+0.27886807\n        +t*(-1.13520398\n        +t*(+1.48851587\n        +t*(-0.82215223\n        +t*(+0.17087277)))))))))));\n}\n#endif\n\n// Returns ∫ exp(-((x-r.x)^2/(2*w.x^2)+(y-r.y)^2/(2*w.y^2))) dx dy on [0;1]^2.\nfloat f(vec2 r,vec2 w)\n{\n    w=abs(w);\n    float ret=1.0;\n    // For large w (i.e. small pixels) we replace\n    // the exact expression with numerical integration, to avoid\n    // loss of precision due to cancellation.\n    //     Method   | Crossover point | Rel. accuracy\n    //     ---------+-----------------+--------------\n    //     Midpoint | w≈16            | ≈6e-3\n    //     Simpson  | w≈3             | ≈2e-3\n    if(w.x>16.0) ret*=exp(-(r.x-0.5)*(r.x-0.5)/(2.0*w.x*w.x));\n    else         ret*=sqrt(0.5*pi)*w.x*(erf((r.x-1.0)/(sqrt(2.0)*w.x))-erf(r.x/(sqrt(2.0)*w.x)));\n    if(w.y>16.0) ret*=exp(-(r.y-0.5)*(r.y-0.5)/(2.0*w.y*w.y));\n    else         ret*=sqrt(0.5*pi)*w.y*(erf((r.y-1.0)/(sqrt(2.0)*w.y))-erf(r.y/(sqrt(2.0)*w.y)));\n    return ret;\n}\n\n//==============================================================================\n\n// https://www.shadertoy.com/view/dllSW7\nuint hash(uint x)\n{\n    x ^= x >> 15;\n    x ^= (x * x) | 1u;\n    x ^= x >> 17;\n    x *= 0x9E3779B9u;\n    x ^= x >> 13;\n    return x;\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 p=fragCoord;\n    vec3 col=vec3(0.005,0.01,0.2);\n    float s=1.0/25.0;\n    s*=1.01+sin(0.1*iTime);\n    mat2 R=mat2(0.6,-0.8,0.8,0.6);\n    vec2 T=256.0*vec2(sin(vec2(0.037,0.073)*iTime));\n    // Several layers of procedural starfield.\n    // Note: the stars are clumped towards cell centers\n    // in attempt to mitigate truncation at cell edges,\n    // which can be fairly noticeable for a single layer,\n    // but less of a problem for multiple layers.\n    for(int k=0;k<7;++k)\n    {\n        vec2 r=s*R*(p-T);                                       // Convert to layer coordinates.\n        ivec2 c=ivec2(floor(r));                                // Cell in layer.\n        uint h=hash(uint(k^(c.x<<8)^(c.y<<24)));                // Cell hash.\n        vec2 P=vec2(c)+0.25+0.5*vec2(h&255u,(h>>8)&255u)/256.0; // Star center.\n        float w=0.5*pow(float(1u+((h>>16)&31u))/32.0,4.0);      // Star size.\n        float I=pow((float(1u+((h>>21)&31u))/32.0),5.0);        // Star intensity.\n        vec3 C=0.5+0.375*sin(float(h>>26)+vec3(0,2,4));         // Star color.\n        I=4.0*I/(2.0*pi*w*w);                                   // Normalize intensity.\n        P=transpose(R)*P/s+T;                                   // Convert position to screen-space.\n        w*=1e-1/s;                                              // Convert size to screen-space.\n        if(fragCoord.x<0.5*iResolution.x) col+=I*C*exp(-dot(p-P,p-P)/(2.0*w*w)); // Point sampling.\n        else                              col+=I*C*f(p-P,vec2(w));               // Box filter.\n        // Compute parameters for the next layer.\n        R*=R;\n        s*=1.125;\n    }\n    float g=abs(fragCoord.x-0.5*iResolution.x);\n    col=mix(col,vec3(exp(-g*g)),exp(-0.5*g*g));\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}