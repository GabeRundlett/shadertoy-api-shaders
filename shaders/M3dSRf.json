{
    "Shader": {
        "info": {
            "date": "1719372923",
            "description": "sources  https://www.shadertoy.com/view/lXdGD2 https://www.shadertoy.com/view/4ljcz1# https://www.shadertoy.com/view/4ljcz1#",
            "flags": 0,
            "hasliked": 0,
            "id": "M3dSRf",
            "likes": 3,
            "name": "cosmic energy",
            "published": 3,
            "tags": [
                "galaxy",
                "universe",
                "cosmic",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 308
        },
        "renderpass": [
            {
                "code": "\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\n\nfloat hash( float n ){\n    return fract(sin(n)*758.5453);\n}\n\n float configurablenoise(vec3 x, float c1, float c2) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf       = f*f*(3.0-2.0*f);\n\n\tfloat h2 = c1;\n\t float h1 = c2;\n\t#define h3 (h2 + h1)\n\n\t float n = p.x + p.y*h1+ h2*p.z;\n\treturn mix(mix(\tmix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\tmix( hash(n+h1), hash(n+h1+1.0),f.x),f.y),\n\t\t   mix(\tmix( hash(n+h2), hash(n+h2+1.0),f.x),\n\t\t\tmix( hash(n+h3), hash(n+h3+1.0),f.x),f.y),f.z);\n\n}\n\nfloat supernoise3dX(vec3 p){\n\n\tfloat a =  configurablenoise(p, 883.0, 971.0);\n\tfloat b =  configurablenoise(p + 0.5, 113.0, 157.0);\n\treturn (a * b);\n}\n\nfloat fbmHI2d(vec2 p, float dx){\n   // p *= 0.1;\n    p *= 0.2;\n\t//p += getWind(p * 0.2) * 6.0;\n\tfloat a = 0.0;\n    float w = 1.0;\n    float wc = 0.0;\n\tfor(int i=0;i<5;i++){\n        //p += noise(vec3(a));\n\t\ta += clamp(2.0 * abs(0.5 - (supernoise3dX(vec3(p, 1.0)))) * w, 0.0, 1.0);\n\t\twc += w;\n        w *= 0.5;\n\t\tp = p * dx;\n\t}\n\treturn a / wc;// + noise(p * 100.0) * 11;\n}\n\nfloat stars(vec2 seed, float intensity){\n\treturn smoothstep(1.0 - intensity*0.9, (1.0 - intensity *0.9)+0.1, supernoise3dX(vec3(seed * 500.0, 0.0)) * (0.8 + 0.2 * supernoise3dX(vec3(seed * 40.0, 0.0))));\n}\nvec3 stars(vec2 uv){\n\tfloat intensityred = (1.0 / (1.0 + 30.0 * abs(uv.y))) * fbmHI2d(uv * 30.0, 3.0) * (1.0 - abs(uv.x ));\t\n\tfloat intensitywhite = (1.0 / (1.0 + 20.0 * abs(uv.y))) * fbmHI2d(uv * 30.0 + 120.0, 3.0) * (1.0 - abs(uv.x ));\t\n\tfloat intensityblue = (1.0 / (1.0 + 20.0 * abs(uv.y))) * fbmHI2d(uv * 30.0 + 220.0, 3.0) * (1.0 - abs(uv.x ));\t\n\tfloat galaxydust = smoothstep(0.1, 0.5, (1.0 / (1.0 + 20.0 * abs(uv.y))) * fbmHI2d(uv * 20.0 + 220.0, 3.0) * (1.0 - abs(uv.x )));\t\n\tfloat galaxydust2 = smoothstep(0.2, 0.5, (1.0 / (1.0 + 20.0 * abs(uv.y))) * fbmHI2d(uv * 50.0 + 220.0, 3.0) * (1.0 - abs(uv.x )));\t\n\tintensityred = 1.0 - pow(1.0 - intensityred, 3.0) * 0.73;\n\tintensitywhite = 1.0 - pow(1.0 - intensitywhite, 3.0) * 0.73;\n\tintensityblue = 1.0 - pow(1.0 - intensityblue, 3.0) * 0.73;\n\tfloat redlights = stars(uv, intensityred );\n\tfloat whitelights = stars(uv, intensitywhite );\n\tfloat bluelights = stars(uv, intensityblue );\n\tvec3 starscolor = vec3(1.0, 0.8, 0.5) * redlights + vec3(1.0) * whitelights + vec3(0.6, 0.7, 1.0) * bluelights;\n\tvec3 dustinner = vec3(0.9, 0.8, 0.8);\n\tvec3 dustouter = vec3(0.2, 0.1, 1.0);\n\tvec3 innermix = mix(dustinner, starscolor, 1.0 - galaxydust);\n\tvec3 allmix = mix(dustouter, innermix, 1.0 - galaxydust2);\n\tvec3 bloom = 5.6 * dustinner * (1.0 / (1.0 + 30.0 * abs(uv.x))) * fbmHI2d(uv * 3.0, 3.0) * (1.0 - abs(uv.x ));\t\n\treturn allmix + bloom;\n}\n\nvec3 milkyway(vec2 uv){\n\treturn stars(uv);\n}\n#define resolution iResolution.xy\n#define time iTime\n#define PI 3.141592\n#define TWOPI 6.283184\n\n#define R2D 180.0/PI*\n#define D2R PI/180.0* \n\nmat2 rotMat(in float r){float c = cos(r);float s = sin(r);return mat2(c,-s,s,c);}\n\n//fract -> -0.5 -> ABS  : coordinate absolute Looping\nfloat abs1d(in float x){return abs(fract(x)-0.5);}\nvec2 abs2d(in vec2 v){return abs(fract(v)-0.5);}\nfloat cos1d(float p){ return cos(p*TWOPI)*0.25+0.25;}\nfloat sin1d(float p){ return sin(p*TWOPI)*0.25+0.25;}\n\n#define OC 15.0\nvec3 Oilnoise(in vec2 pos, in vec3 RGB)\n{\n    vec2 q = vec2(0.0);\n    float result = 0.0;\n    \n    float s = 2.2;\n    float gain = 0.44;\n    vec2 aPos = abs2d(pos)*0.5;//add pos\n\n    for(float i = 0.0; i < OC; i++)\n    {\n        pos *= rotMat(D2R 30.);\n        float time = (sin(iTime)*0.5+0.5)*0.2+iTime*0.8;\n        q =  pos * s + time;\n        q =  pos * s + aPos + time;\n        q = vec2(cos(q));\n\n        result += sin1d(dot(q, vec2(0.3))) * gain;\n\n        s *= 1.07;\n        aPos += cos(smoothstep(0.0,0.15,q));\n        aPos*= rotMat(D2R 5.0);\n        aPos*= 1.232; \n    }\n    \n    result = pow(result,4.504);\n    return clamp( RGB / abs1d(dot(q, vec2(-0.240,0.000)))*.5 / result, vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= .8;\n\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\nvec2 r = resolution;\n\tfloat t2 = time;\n\tfragColor=vec4(.1);\n\tvec3 d=vec3((2.*gl_FragCoord.xy-r)/r.y,1.);\n\t  vec3 col2 = vec3(0.0,0.0,0.0);\n    vec2 st = (fragCoord/iResolution.xy);\n            st.x = ((st.x - 0.5) *(iResolution.x / iResolution.y)) + 0.5;\n    float stMask = step(0.0, st.x * (1.0-st.x));\n\n\n\n    vec3 rgb = vec3(0.30, .8, 1.200);\n    \n    \n    //berelium, 2024-06-07 - anti-aliasing\n    float AA = 1.0;\n    vec2 pix = 1.0 / iResolution.xy;\n    vec2 aaST = vec2(0.0);\n    \n    for(float i = 0.0; i < AA; i++) \n    {\n        for(float j = 0.0; j < AA; j++) \n        {\n            aaST = st + pix * vec2( (i+0.1)/AA, (j+0.5)/AA );\n            col2 += Oilnoise(aaST, rgb);\n        }\n    \n    }\n    \n    col2 /= AA * AA;\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 140; i++)\n\t{\n\t\tvec3 p = s * vec3(uv,col2.x);\n\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)*col2;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\t\n   \n    \n    \n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3* col2;\n\n\n\tvec2 pos = (rotationMatrix(vec3(0.0, 0.0, 1.0), 0.2415) * vec3(uv.x, uv.y, 0.0)).xy;\n\tfragColor = vec4(milkyway(pos)*col.xyz,1.0);\n    for(float i=0.;i<200.;i++){\n\t\tvec3 p=(\n\t\t\tabs(\n\t\t\t\tfract(fract(99.*sin((vec3(1,5,9)+i*9.)))+t2*.1002)*2.-1.\n\t\t\t)*2.-1.\n\t\t)*30.;\n    \n\t\tfragColor+=vec4(\n\t\t\tmix(vec3(1),(cos((vec3(0,2,-2)*col2/3.+i*.01)*11.283)*.5+.5),.8)\n\t\t\t*exp(-3.*length(cross(p,d))),\n\t\t\t1\n\t\t);\t\n        }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}