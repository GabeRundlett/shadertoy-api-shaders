{
    "Shader": {
        "info": {
            "date": "1612459932",
            "description": "Here is a comparison of different implementations of Smooth Minimum, as described on iq's website.\nhttps://iquilezles.org/articles/smin/smin.htm\nThank you iq.\nmouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "wttfzM",
            "likes": 6,
            "name": "Comparison of Smooth Minimums",
            "published": 3,
            "tags": [
                "boolean",
                "smin"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 486
        },
        "renderpass": [
            {
                "code": "const float MIN_DIST = .001;\nconst float MAX_DIST = 100.;\nconst int ITR = 100;\nconst float INV_ITR = (1./float(ITR));\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n    // You can try ellipsoid too...(>_<)\n    #if 0\n        return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n    #else\n        float k0 = length(p/r);\n        float k1 = length(p/(r*r));\n        return k0*(k0-1.0)/k1;\n    #endif\n}\n\n// https://iquilezles.org/articles/smin\n\n//--------------------------------------------------------\n\n// polynomial smooth min (k = 0.1);\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminPoly_MediaMolecule( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// return a factor for blending material too.\nfloat sminQuadratic ( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m).x : vec2(b-s,1.0-m).x;\n}\n\n//--------------------------------------------------------\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// return a factor for blending material too.\nfloat sminCubic2( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m).x : vec2(b-s,1.0-m).x;\n}\n\n// return a factor for blending material too.\nfloat sminN( float a, float b, float k )\n{\n    const float n = 3.; //3.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m).x : vec2(b-s,1.0-m).x;\n}\n\n// return a factor for blending material too.\nfloat sminExp( in float a, in float b, in float k )\n{\n    float f1 = exp2( -k*a );\n    float f2 = exp2( -k*b );\n    return vec2(-log2(f1+f2)/k,f2).x;\n}\n//--------------------------------------------------------\n\n// power smooth min (k = 8);\nfloat sminPow( float a, float b, float k )\n{\n    k/=2.;\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n\n#define FLAT false\n\n#define NUM_TYPES 8.\nint id=0;\nfloat map(in vec3 p)\n{\n#define shapes(method, mix1, mix2)\\\n    float anim = sin(iTime)*.5+.5;\\\n    if(iMouse.z>0.)anim = u2s(iMouse.y/iResolution.y);\\\n    d = method(sdEllipsoid(p+vec3(0., -2.0128, 0.), vec3(.4571, 1., .4571)), d, mix1);\\\n\td = method(sdEllipsoid(p+vec3(0., -3.9932, 0.), vec3(.4571, 1., .4571)), d, mix1);\\\n\td = method(sdEllipsoid(p+vec3(0., -5.9811, 0.), vec3(.4571, 1., .4571)), d, anim*mix2);\\\n\n    p.y+=6.;\n    float d = sdEllipsoid(p, vec3(1., 1., 1.));\n    float cbf = 1.35;\n    //--------------------------------------------------------\n    if(id==0){\n        shapes(sminPoly, .5, 3.);\n    }\n    else\n    if(id==1){\n        shapes(sminPoly_MediaMolecule, .5, 3.);\n    }\n    else\n    if(id==2){\n        shapes(sminQuadratic, .5, 3.);\n    }\n    //--------------------------------------------------------\n    else\n    if(id==3){\n        shapes(sminCubic, .5*cbf, 3.*cbf);\n    }\n    else\n    if(id==4){\n        shapes(sminCubic2, .5*cbf, 3.*cbf);\n    }\n    else\n    if(id==5){\n        shapes(sminN, .5*cbf, 3.*cbf);\n    }\n    //--------------------------------------------------------\n    else\n    if(id==6){\n        shapes(sminExp, .5*10., 3.); //animation is reversed.\n    }\n    else\n    if(id==7){\n        shapes(sminPow, .99, .9); // I don't know why this doesnt work..\n    }\n    //--------------------------------------------------------\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec3 e = vec3(0, 1,-1)*MIN_DIST;\n    return normalize(vec3(map(p+e.yxx)-map(p+e.zxx),map(p+e.xyx)-map(p+e.xzx),map(p+e.xxy)-map(p+e.xxz)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<ITR; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p)*.5;\n        if(d<=MIN_DIST) break;\n        t += d;\n        if(t >= MAX_DIST) return MAX_DIST;\n    }\n    return t;\n}\n\nvec3 render(in vec2 fragCoord){\n      vec2 uv = fragCoord/iResolution.xy;\n      float line = step(.99, fract(uv.x*NUM_TYPES))*step(uv.x,.9);\n      line += step(.9, fract(uv.x*NUM_TYPES*5.))*.1;\n      line += step(.9, fract(uv.y*20.))*.1;\n      id = int(uv.x*NUM_TYPES);\n      uv.x = fract(uv.x*NUM_TYPES);\n      \n      uv = uv*2.-1.;\n      uv.x *= 1./NUM_TYPES;\n      uv.y *= iResolution.y/iResolution.x;      \n      \n      vec3 ro = vec3(0,0,-10);\n      vec3 rd = normalize(vec3(uv-vec2(0,.55), 2));\n      float d = march(ro, rd);\n      \n      vec3 col = vec3(.025);\n      \n      if(d<MAX_DIST){\n          vec3 p = ro + rd * d;\n          vec3 n = normal(p);\n          //dbg_3V( n*.5+.5 );\n          col = vec3(0.000,0.616,1.000)*.75;\n          if(!FLAT){\n              float l = max(0., dot(n, vec3(.5,1,-.5)));\n              float l2 = max(0., dot(n,-vec3(.5,1,-.5)));\n              col = mix(vec3(0),col, l+.1*l2);\n          }\n          \n      }\n      col+=line*.1;\n      col = pow(col, vec3(.45));\n      return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = render(fragCoord);\n    fragColor = vec4(col,1.0);\n    drawDebug(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}