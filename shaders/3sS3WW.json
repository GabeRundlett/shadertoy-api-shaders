{
    "Shader": {
        "info": {
            "date": "1549130660",
            "description": "Learning some basic ray-marching.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sS3WW",
            "likes": 8,
            "name": "Da Blob",
            "published": 3,
            "tags": [
                "raymarching",
                "blob",
                "environmentmapping"
            ],
            "usePreview": 0,
            "username": "MadEqua",
            "viewed": 464
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 128\n#define EPSILON 0.01\n#define MAX_DIST 256.0\n\n#define PI 3.1415926535\n#define HALF_PI PI * 0.5\n\nconst vec3 CAMERA_POS = vec3(-3.5, 2.5, 3.5);\nconst vec3 CAMERA_LOOK_AT = vec3(0.0, 0.0, 0.0);\nconst vec3 CAMERA_UP = vec3(0.0, 1.0, 0.0);\n\nconst vec3 LIGHT_POS = vec3(-40.0, 50.0, 0.0);\nconst float LIGHT_INTEN = 1.3;\n\nconst vec3 SPHERE_POS = vec3(0.0, 0.0, 0.0);\nconst float SPHERE_R = 1.0;\n\n//const vec3 SKY_COLOR = vec3(0.529, 0.808, 0.922);\n\nuniform samplerCube cubeMap;\n\nstruct Hit {\n    float dist;\n    vec3 color;\n};\n    \nlowp vec3 permute(in lowp vec3 x) { \n    return mod( x*x*34.+x, 289.);\n}\n\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\n/*Hit planeSdf(vec3 p) {\n    const float PLANE_Y =/ 0.0;\n    Hit hit;\n    hit.dist = p.y - PLANE_Y;\n    hit.color = vec3(0.55);\n    return hit;\n}*/\n\nHit sphereSdf(vec3 p, vec3 c, float r) {\n    Hit hit;\n    hit.dist = length(p - c) - r;\n    hit.color = vec3(1.0);\n    return hit;\n}\n\n/*float vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nHit boxSdf(vec3 p, vec3 c, vec3 s) {\n    Hit hit;\n    hit.dist = vmax(abs(p - c) - s);\n    hit.color = vec3(1.0);\n    return hit;\n}*/\n\nHit torusSdf(vec3 p, vec2 dims) {\n    Hit hit;\n    vec2 q = vec2(length(p.zy) - dims.x, p.x);\n\n    hit.dist = length(q) - dims.y;\n    hit.color = vec3(1.0);\n    \n    return hit;\n}\n\nHit sdf(vec3 p) {\n    float t = sin(-HALF_PI + iTime * 0.15) * 0.5 + 0.5;\n    float t2 = sin(-HALF_PI + iTime * 0.3) * 0.5 + 0.5;\n    \n    Hit torusHit = torusSdf(p, vec2(SPHERE_R, t2 + 0.3));\n    Hit sphereHit = sphereSdf(p, SPHERE_POS, SPHERE_R);\n    \n    float distBlend = mix(sphereHit.dist, torusHit.dist, t);\n    \n    float displacement = \n        snoise(vec2(p.x * 0.82, iTime * 0.35)) *\n        snoise(vec2(p.y * 0.81, iTime * 0.3)) *\n        snoise(vec2(p.z * 0.83, iTime * 0.25)) *\n        0.8 * t2;\n    \n    distBlend -= displacement;\n    \n    Hit hit;\n    hit.dist = distBlend;\n    hit.color = mix(sphereHit.color, torusHit.color, t);\n    return hit;\n}\n\nHit rayMarch(vec3 ro, vec3 rd) {\n    Hit resultHit;\n    resultHit.dist = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + resultHit.dist * rd;\n        Hit hit = sdf(p);\n        resultHit.dist += hit.dist;\n        resultHit.color = hit.color;\n        if(hit.dist < EPSILON || resultHit.dist > MAX_DIST) {\n            break;\n        }\n    }\n    return resultHit;\n}\n\nvec3 normal(vec3 p) {\n    float d = sdf(p).dist;\n    vec2 e = vec2(.001, 0.);\n    \n    vec3 n = d - vec3(sdf(p - e.xyy).dist,\n                      sdf(p - e.yxy).dist,\n                      sdf(p - e.yyx).dist);\n\treturn normalize(n);\n}\n\nvec3 envMap(vec3 rd, vec3 normal) {\n    vec3 r = reflect(rd, normal);\n    vec3 texel = texture(cubeMap, r).rgb;\n    return texel;\n}\n\nvec3 lightingAndShadow(vec3 ro, vec3 rd, Hit hit, vec3 lightPos) {\n    \n    vec3 p = ro + rd * hit.dist;\n    \n    vec3 L = normalize(lightPos - p);\n    vec3 N = normal(p);\n    vec3 V = normalize(ro - p);\n    vec3 H = normalize(L + V);\n    \n    float diffuse = max(0.0, dot(L, N));\n    float specular = pow(max(0.0, dot(N, H)), 50.0);\n    \n    vec3 light = LIGHT_INTEN * (diffuse * hit.color + specular);\n    \n    /*float d = rayMarch(p + N * EPSILON * 2.0, L).dist;\n    if(d < distance(L, p))\n        light *= 0.3;*/\n    \n    light *= envMap(rd, N);\n    \n    return light;\n}\n\nmat3 cameraToWorldMatrix(vec3 pos, vec3 lookAt, vec3 up) {    \n    vec3 cameraZ = normalize(lookAt - pos);\n    vec3 cameraX = normalize(cross(cameraZ, up));\n    vec3 cameraY = normalize(cross(cameraX, cameraZ));\n    \n    return mat3(cameraX, cameraY, cameraZ);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    vec3 cameraPos = CAMERA_POS * \n        vec3(sin(iTime * 0.12), \n             sin(iTime * 0.2),\n             cos(iTime * 0.12));\n    \n    vec3 ro = cameraPos;\n    vec3 rd = cameraToWorldMatrix(cameraPos, CAMERA_LOOK_AT, CAMERA_UP) * \n        \t\tvec3(uv.x, uv.y, 1.0);\n    \n    Hit hit = rayMarch(ro, rd);\n    \n    vec3 col = texture(cubeMap, rd).rgb;\n    if(hit.dist < MAX_DIST) {\n    \tcol = lightingAndShadow(ro, rd, hit, cameraPos);\n    }\n        \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}