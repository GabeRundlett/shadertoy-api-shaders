{
    "Shader": {
        "info": {
            "date": "1613678213",
            "description": "experimenting with bokeh and struct ",
            "flags": 0,
            "hasliked": 0,
            "id": "tl3BWs",
            "likes": 5,
            "name": "bokeh expe 03",
            "published": 3,
            "tags": [
                "bokeh",
                "lights",
                "drive",
                "street",
                "artofcode"
            ],
            "usePreview": 0,
            "username": "YitingLiu",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "//tutorial https://youtu.be/52TMliAWocY\n\n#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n    vec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c+uv.x*r+uv.y *u;\n    a.d=normalize(i-a.o);\n    \n    return a;\n}\n\n\n\nvec4 N14(float t){\n    return fract(sin(t*vec4(123.,1024.,3456.,9575.))*vec4(2348.,125.,2518,6578.));\n}\n\nfloat N(float t){\n    return fract(sin(t*1258.)*6527.);\n}\n\n\nvec3 ClosetPoint(ray r, vec3 p){\n    return r.o+max(0.,dot(p-r.o,r.d))*r.d;\n\n}\n\nfloat DistRay(ray r, vec3 p){\n    return length(p-ClosetPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    size*=length(p);\n    float d = DistRay(r,p);\n    float c = S(size, size*(1.-blur),d);\n    c*=mix(.6,1.,S(size*.8,size,d));\n    return c;\n\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x)-.08;\n\n    float s = 1./10.;\n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    vec3 p = vec3(2.,2.,100.-ti*100.);\n    m+= Bokeh(r,p,.1,.1)*ti*ti*ti*ti;\n    }\n    return  vec3(1.,.7,.3)*m;\n\n}\n\n\nvec3 Envlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x)-.08;\n\n    float s = 1./10.;\n    //float m = 0.;\n    vec3 c = vec3(0.);\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    \n    vec4 n = N14(i+side*100.);//make it asymetrical\n    \n    float fade = ti*ti*ti*ti;\n    \n    float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;//times 2 pi\n    \n    fade = occlusion; \n    \n    float x = mix(2.5,10.,n.x);\n    float y = mix(.1,1.5,n.y);\n    \n    \n    vec3 p = vec3(x,y,50.-ti*50.);\n    vec3 col = n.wzy;// random color\n    c+= Bokeh(r,p,.1,.1)*fade *col*.2;\n    }\n    return  c;\n\n}\n\nvec3 Headlights(ray r, float t){\n    t*=.5;\n   \n   float w1 = .35;// distance between headlight \n   float w2 = w1*1.2;\n\n    float s = 1./30.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// randomize the headlight using noise \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti;\n        \n        float focus = S(.8,1.,ti);\n        float size = mix(.05,.03,focus);        \n   \n        m+= Bokeh(r,vec3(-1.-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(-1.-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w2,.15,z),size,.1)*fade;\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(-1.-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(-1.+\n        w2,-.15,z),size*3.,1.)*fade;\n        \n        m+=ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(.9,.9,1.)*m;//blue and green \n\n}\n\nvec3 Taillights(ray r, float t){\n\n    t *=.8;\n   \n    float w1 = .25;// distance between headlight \n    float w2 = w1*1.2;\n\n    float s = 1./15.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// 0 1 randomize the headlight using noise \n        \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        // n = 0 0.5 \n        float lane = step(.5,n);// 0 1 \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti*ti;\n        \n        float focus = S(.9,1.,ti);\n        float size = mix(.05,.03,focus);\n        \n        float laneShift = S(.99,.96,ti);\n        float x = 1.5 -lane*laneShift;\n        \n        float blink = step(0.,sin(t*10000.))*7.*lane*step(.96,ti);\n   \n        m+= Bokeh(r,vec3(x-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(x-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w2,.15,z),size,.1)*fade*(1.+blink);\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(x-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(x+\n        w2,-.15,z),size*3.,1.)*fade*(1.+blink*.1);\n        \n        m += ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(1.,.1,.03)*m;//red\n\n}\n\n\n\nvec2 Rain(vec2 uv, float t){\n    t*=40.;\n\n    //uv*=3.;\n    vec2 a = vec2(3.,1.);\n    vec2 st = uv*a;\n    st.y+=t*.2;\n    vec2 id = floor(st);\n   \n    float n = fract(sin(id.x*716.34)*768.34);//creating a quick random function\n\n    uv.y+=n;\n    st.y+=n;\n    \n    id = floor(st);\n    st = fract(st)-.5;\n\n    t += fract(sin(id.x*76.34+id.y*1453.7)*768.35)*6.283;//create phase difference \n \n    float y = -sin(t+sin(t+sin(t)*.5))*.43;//making sawtooth wave so goes up fast and goes down slower\n    vec2 p1 = vec2(0.,y);\n    \n    vec2 o1 = (st-p1)/a;\n    float d = length(o1);\n    \n    float m1 = S(.07,.0,d);\n    \n    //leave a trail of waterdrops \n    \n    vec2 o2 = fract(uv*a.x*vec2(1.,2.)-.5)/vec2(1.,2.);\n    d = length(o2);\n    float m2 = S(.3*(.5-st.y),.0,d)*S(-.1,.1,st.y-p1.y);\n\n   // if(st.x>.46 || st.y>.49) m1=1.;// drawing grid \n    \n    \n\n    return vec2(m1*o1*50.+m2*o2*10.);//m2\n\n\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.05+m.x;  \n\n    vec3 camPos = vec3(.5,.18,0.);\n    vec3 lookat = vec3(.5,.22,1.);\n    \n    vec2 rainDistort = Rain(uv*5.,t)*.5;\n    \n   rainDistort += Rain(uv*7.,t)*.5;\n   \n   \n   //making water effect \n   uv.x+=sin(uv.y*70.)*.005;\n   uv.y+=sin(uv.x*170.)*.003;\n   \n   ray r = GetRay(uv-rainDistort*.5,camPos,lookat,2.);\n  \n\n    vec3 col = Streetlights(r,t);\n    col += Headlights(r,t);\n    col += Taillights(r,t);\n    col += Envlights(r,t);\n    \n    col+=(r.d.y+.25)*vec3(.2,.1,.5);\n    \n   // col=vec3(rainDistort,0.);\n\n\nfragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}