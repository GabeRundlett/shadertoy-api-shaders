{
    "Shader": {
        "info": {
            "date": "1531345555",
            "description": "Trying to understand how to build a reverb filter for audio. I thought it would be more like a blur filter, but actually it needs randomness because evenly spaced samples easily come into phase with the sound and do weird stuff.",
            "flags": 8,
            "hasliked": 0,
            "id": "XldcRr",
            "likes": 25,
            "name": "Reverb",
            "published": 3,
            "tags": [
                "reverb"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 943
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 o, in vec2 i )\n{\n    vec2 uv = i/iResolution.xy;\n    o.rgb = vec3(.3);\n    \n    vec2 s = mainSound( 0, iTime + iTimeDelta*uv.x );\n    float y = uv.y*2.-1.;\n    if ( y < s.x ) o.rgb += vec3(1,.5,0)*.4;\n    if ( y < s.y ) o.rgb += vec3(0,.5,1)*.4;\n    o.a = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "vec2 DrySound( float time )\n{\n    // simple note for testing reverb\n    \n    float seqTime = time*3.;\n    \n//    const float notes[] = float[]( 0., 4., 7., 13., 17., 20., 26. );\n    const float notes[] = float[]( 26., 17., 20., 13., 17., 7., 13., 4., 7., 0. );\n    \n    float pulseWidth = .9*(sin(time/3.)*.5+.5); // change with LFO\n//    float pulseWidth = .9*pow(fract(seqTime/float(notes.length())),1.); // change along the sequence\n//    float pulseWidth = pow(1.-fract(seqTime),5.); // change across each note (I don't like it)\n    \n    float note = 110.0*exp2(notes[int(seqTime)%notes.length()]/13.);//mod(floor(time)/13.,2.));\n    return vec2( (step(pulseWidth,sin(6.283185*note*time))*2.-1.)*max(0.,1.-fract(seqTime)/.2) );\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    const float invRate = 1./100.;\n    const float dur = 2.;\n    \n    vec2 reverb = vec2(0);\n    float sum = 0.;\n    for ( float t = 0.; t < dur; t += invRate )\n    {\n        // randomize sample times to avoid frequencies cancelling\n        // this is THE MOST IMPORTANT STEP! - the more random it is, the better\n        float rand = fract(120.*sin(t*1000.));\n        float t2 = t + invRate*rand*5.;\n        float amp = exp2(-t2*1.);\n        reverb += DrySound( time - t2 ) * amp;\n        sum += amp;\n    }\n    reverb /= sum;\n    \n    reverb *= 10.; // balance it by ear - the cancelling frequencies and randomness make it hard to calculate\n    \n    float wetness = .25-.25*cos(time/4.);\n    \n    return mix( DrySound( time ), reverb, wetness );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}