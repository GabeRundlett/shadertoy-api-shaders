{
    "Shader": {
        "info": {
            "date": "1673601924",
            "description": "A remade of iq's fruxis. Check out the blog post here: https://blog.42yeah.is/rendering/2023/01/14/fruxis.html",
            "flags": 0,
            "hasliked": 0,
            "id": "mtSGz3",
            "likes": 3,
            "name": "Fruxis, reconstructed",
            "published": 3,
            "tags": [
                "fruxis"
            ],
            "usePreview": 0,
            "username": "42yeah",
            "viewed": 368
        },
        "renderpass": [
            {
                "code": "//\n// Fruxis, reconstructed - by 42yeah\n//\n\nvec3 hash3(float n)\n{\n    return fract(sin(vec3(n, n + 1.0, n + 2.0)) * vec3(43758.5453123, 22578.1459123, 19642.3490423));\n}\n\nfloat ball(vec3 p, vec3 center, float r)\n{\n    return length(p - center) - r;\n}\n\nfloat suelo(vec3 p, out vec3 uvw)\n{\n    uvw = p;\n    return p.y;\n}\n\nfloat pared(vec3 p, out vec3 uvw)\n{\n    uvw = 4.0 * p;\n    float d1 = 0.6 + p.z;\n    float d2 = 0.6 + p.x;\n    return min(d1, d2);\n}\n\nfloat melon(vec3 p, out vec3 uvw)\n{\n    vec3 c = p - vec3(0.0,0.215,0.0);\n\n    vec3 q = 3.0 * c * vec3(1.0,1.5,1.5);\n    uvw = 3.0 * c;\n\n    float r = 1.0 - 0.007 * sin(30.0 * (-c.x + c.y - c.z));\n    return 0.65 * (length(q) - r) / 3.0;\n}\n\nfloat manzana(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(0.5, 0.1, 0.5);\n    float r = length(q.xz);\n    q.y += 0.05 * (1.0 - clamp(r / 0.1, 0.0, 1.0));\n    q.y -= 0.03 * (1.0 - smoothstep(0.004, 0.005, r));\n    uvw = 10.0 * q;\n    return 0.4 * (length(10.0 * q) - 1.0) / 10.0;\n}\n\nfloat uvas(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.1, 0.1, 0.6);\n    uvw = 10.0 * q;\n    \n    float d1 = length(q - vec3(-0.09, 0.1, -0.07)) - 0.12;\n    float d2 = length(q - vec3(0.11, 0.05, 0.0)) - 0.09;\n    float d3 = length(q - vec3(-0.07, 0.03, 0.1)) - 0.1;\n    \n    return min(d1, min(d2, d3));\n}\n\nfloat lemon(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(0.7, 0.06, 0.2);\n    uvw = 10.0 * q;\n    \n    float s = 1.35; // ???\n    float r = clamp(abs(q.x) / 0.077, 0.0, 1.0);\n    s += 2.5 * pow(r, 24.0);\n    q *= vec3(1.0, s, s);\n    return 0.5 * (length(12.0 * q) - 1.0) / (12.0 * s);\n}\n\nfloat jarron(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.1, 0.28, 0.6);\n    uvw = q;\n    \n    float d1 = length(q) - 1.0 / 3.5;\n    d1 = abs(d1 + 0.025 / 3.5) - 0.025 / 3.5;\n    \n    float d2 = q.y + 0.1;\n    return max(d1, d2);\n}\n\nfloat mantelito(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.1, 0.001, 0.65);\n    q.xz += 0.1 * vec2(\n        0.7 * sin(6.0 * q.z + 2.0) + 0.3 * sin(12.0 * q.x + 5.0),\n        0.7 * sin(6.0 * q.x + 0.7) + 0.3 * sin(12.0 * q.z + 3.0));\n    \n    const mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    q.xz = m2 * q.xz;\n    uvw = q;\n    \n    q.y -= 0.008 * (0.5 - 0.5 * sin(40.0 * q.x) * sin(5.0 * q.z));\n    \n    return length(max(abs(q) - vec3(0.3, 0.001, 0.3), 0.0)) - 0.0005;\n}\n\nfloat botella(vec3 p, out vec3 uvw)\n{\n    vec3 q = p - vec3(-0.35, 0.0, 0.3);\n    vec2 w = vec2(length(q.xz), q.y);\n\n    uvw = q;\n    \n    float r = 1.0 - 0.8 * pow(smoothstep(0.5, 0.6, q.y), 4.0);\n    r += 0.1 * smoothstep(0.65, 0.66, q.y);\n    r *= 1.0 - smoothstep(0.675, 0.68, q.y);\n    \n    r -= clamp(q.y - 0.67, 0.0, 1.0) * 1.9;\n\n    return (w.x - 0.11 * r) * 0.5;\n}\n\n// Maps to the closest point in scene.\n// The whole scene is defined in map() function.\n// Components: x: closest distance to surface\n//             y: closest surface ID (so that we can shade it)\nvec2 map(vec3 p, out vec3 uvw)\n{\n    // suelo\n    float id = 0.5;\n    float closest = suelo(p, uvw);\n    vec3 mapped_uvw = vec3(0.0);\n    \n    float dist = pared(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 1.5; uvw = mapped_uvw; }\n    \n    dist = melon(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 2.5; uvw = mapped_uvw; }\n    \n    dist = manzana(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 3.5; uvw = mapped_uvw; }\n    \n    dist = uvas(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 4.5; uvw = mapped_uvw; }\n    \n    dist = lemon(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 5.5; uvw = mapped_uvw; }\n    \n    dist = jarron(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 6.5; uvw = mapped_uvw; }\n    \n    dist = mantelito(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 7.5; uvw = mapped_uvw; }\n    \n    dist = botella(p, mapped_uvw);\n    if (dist < closest) { closest = dist; id = 8.5; uvw = mapped_uvw; }\n\n    return vec2(closest, id);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 uvw;\n    vec2 del = vec2(0.01, 0.0);\n    float val = map(p, uvw).x;\n\n    return normalize(vec3(val - map(p - del.xyy, uvw).x,\n        val - map(p - del.yxy, uvw).x,\n        val - map(p - del.yyx, uvw).x));\n}\n\nvec2 march(vec3 ro, vec3 rd, out vec3 uvw)\n{\n    int steps = 150;\n    float dist = 0.01;\n    \n    for (int i = 0; i < steps; i++)\n    {\n        vec2 info = map(ro + dist * rd, uvw);\n        if (info.x < 0.001)\n        {\n            return vec2(dist, info.y);\n        }\n        dist += info.x;\n    }\n    return vec2(1.0, -1.0);\n}\n\n\n\n// Shade the particular point of the scene, according to shading informations\n// given in the function parameters.\nvec3 getColor(vec2 info, vec3 uvw, vec3 nor, out vec3 bnor)\n{\n    float id = info.y;\n    if (id < 0.0)\n    {\n        // Shade sky\n        return vec3(0.7, 0.9, 1.0);\n    }\n    else if (id > 0.0 && id < 1.0)\n    {\n        // Floor (suelo)\n        return vec3(0.5, 0.25, 0.0);\n    }\n    else if (id > 1.0 && id < 2.0)\n    {\n        // Wall (pared)\n        return vec3(0.2, 0.1, 0.0);\n    }\n    else if (id > 2.0 && id < 3.0)\n    {\n        // Melon\n        return vec3(0.3, 0.8, 0.3);\n    }\n    else if (id > 3.0 && id < 4.0)\n    {\n        // Apple (manzana)\n        return vec3(0.9, 0.3, 0.2);\n    }\n    else if (id > 4.0 && id < 5.0)\n    {\n        // Oranges (uvas)\n        return vec3(1.0, 0.5, 0.0);\n    }\n    else if (id > 5.0 && id < 6.0)\n    {\n        // Lemon\n        return vec3(1.0, 0.9, 0.0);\n    }\n    else if (id > 6.0 && id < 7.0)\n    {\n        // Bowl (jarron)\n        return vec3(0.3, 0.2, 0.1);\n    }\n    else if (id > 7.0 && id < 8.0)\n    {\n        // Doily (mantelito)\n        return vec3(0.3, 0.4, 0.7);\n    }\n    else if (id > 8.0 && id < 9.0)\n    {\n        // Bottle (botella)\n        return vec3(0.6, 0.5, 0.1);\n    }\n    // Unknown\n    return vec3(1.0, 0.0, 1.0);\n}\n\nconst vec3 rlight = vec3(3.62, 2.99, 0.71);\nvec3 lig = normalize(rlight);\n\n// Shadow marching\nfloat softShadow(vec3 ro, vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.001;\n    vec3 trash;\n    for (int i = 0; i < 64; i++)\n    {\n        vec2 info = map(ro + rd * t, trash);\n        res = min(res, smoothstep(0.0, 1.0, k * info.x / t));\n        if (res < 0.001)\n        {\n            break;\n        }\n        t += clamp(info.x, 0.01, 1.0);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat directLighting(vec3 pos, vec3 nor)\n{\n    vec3 front = lig;\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, front);\n    \n    float shadowIntensity = softShadow(pos + 0.001 * nor, lig, 10.0);\n    \n    vec3 toLight = rlight - pos;\n    float att = smoothstep(0.985, 0.997, dot(normalize(toLight), lig));\n\n    vec3 pp = pos - front * dot(pos, front);\n    vec2 uv = vec2(dot(pp, right), dot(pp, up));\n    float pat = smoothstep(-0.5, 0.5, sin(10.0 * uv.y));\n    \n    return pat * att * shadowIntensity;\n}\n\nfloat calcAO(vec3 p, vec3 nor, vec2 px)\n{\n    float off = 0.1 * dot(px, vec2(1.2, 5.3));\n    float ao = 0.0;\n    \n    vec3 trash;\n    for (int i = 0; i < 20; i++)\n    {\n        // Generate a random sample point (0 to 1)\n        vec3 aoPos = 2.0 * hash3(float(i) * 213.47 + off) - 1.0;\n        // Moves closer to center of the sphere\n        aoPos = aoPos * aoPos * aoPos;\n        // Flip points so we are now only sampling in the hemisphere\n        aoPos *= sign(dot(aoPos, nor));\n        // Sample those points and magnify them by 48 times\n        ao += clamp(map(p + nor * 0.015 + 0.015 * aoPos, trash).x * 48.0, 0.0, 1.0);\n    }\n    // Calculate the average ambient occlusion value\n    ao /= 20.0;\n    return clamp(ao * ao, 0.0, 1.0); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(1.0, 0.5, 1.0);\n    vec3 center = vec3(0.0, 0.2, 0.2);\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat3 lookAt = mat3(right, up, front);\n    vec3 rd = lookAt * normalize(vec3(uv, 1.8));\n    vec3 uvw = vec3(0.0);\n    \n    vec2 info = march(ro, rd, uvw);\n    vec3 p = ro + info.x * rd;\n    vec3 nor = getNormal(p);\n    vec3 bnor = vec3(0.0);\n    vec3 obj = getColor(info, uvw, nor, bnor);\n    \n    // Postprocess normal...\n    \n    vec3 ref = reflect(rd, nor);\n    \n    // Lighting components\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 0.0));\n    float occ = calcAO(p, nor, uv * 0.5 + 0.5);\n    float ambient = 1.0;\n    float sha = directLighting(p, nor);\n    float bfl = clamp(-nor.y * 0.8 + 0.2, 0.0, 1.0) * pow(clamp(1.0 - p.y, 0.0, 1.0), 2.0); // Bottom\n    float bce = clamp(nor.y * 0.8 + 0.2, 0.0, 1.0); // Dome\n    float dif = max(dot(nor, lig), 0.0); // Diffuse\n    float bac = max(dot(nor, normalize(-vec3(-lig.x, 0.0, -lig.z))), 0.0); // Back\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 3.0); // Fringe\n    float spe = 0.04 + 0.96 * pow(clamp(dot(ref, lig), 0.0, 1.0), 5.0);\n    \n    float att = 0.1 + 0.9 * smoothstep(0.975, 0.997, dot(normalize(rlight - p), lig));\n    \n    // Lights\n    vec3 lin = vec3(0.0);\n    lin += ambient * vec3(0.08, 0.1, 0.12) * att * occ;\n    lin += bfl * vec3(0.5 + att * 0.5, 0.3, 0.1) * att * occ;\n    lin += bce * vec3(0.3, 0.2, 0.2) * att * occ;\n    lin += bac * vec3(0.4, 0.35, 0.3) * att * occ;\n    lin += dif * vec3(2.5, 1.8, 1.3) * pow(vec3(sha), vec3(1.0, 1.3, 1.6));\n    lin += fre * vec3(3.0, 3.0, 3.0) * occ * att * (0.25 + 0.75 * dif * sha);\n    lin += spe * vec3(3.0, 3.0, 3.0) * occ * att * dif * sha * info.x;\n\n    vec3 color = vec3(0.0);\n    color += lin * obj;\n\n    color = pow(clamp(color, 0.0, 1.0), vec3(0.4545));\n    \n    // Postprocessing\n    // Contrast\n    color = color * 0.6 + 0.4 * color * color * (3.0 - 2.0 * color);\n    // Saturation\n    color = mix(color, vec3(dot(color, vec3(0.33))), 0.2);\n    // Curves\n    color = pow(color, vec3(0.85, 0.95, 1.0));\n    // Vignetting\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color *= 0.7 + 0.3 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}