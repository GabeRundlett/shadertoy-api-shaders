{
    "Shader": {
        "info": {
            "date": "1532703176",
            "description": "we are consumed",
            "flags": 0,
            "hasliked": 0,
            "id": "ltccWN",
            "likes": 4,
            "name": "Perforations 3",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "ahihi",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "#define TAU 6.283185307179586\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = permute(b.xyxy);\n    vec4 k2 = permute(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = permute(c);\n    vec4 k4 = permute(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat scale(float l0, float r0, float l1, float r1, float x) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\n\nvec2 cartesian(vec2 p) {\n\treturn vec2(p.y * cos(p.x), p.y * sin(p.x))\t;\n}\n\nvec2 rotate(float theta, vec2 p) {\n\tvec2 p_polar = polar(p);\n\tp_polar.x += theta;\n\treturn cartesian(p_polar);\n}\n\nvec2 shear(float theta, vec2 p) {\n\treturn vec2(p.x - p.y / tan(theta), p.y / sin(theta));\n}\n\nvec2 unshear(float theta, vec2 p) {\n\tfloat y = p.y * sin(theta);\n\tfloat x = p.x + y / tan(theta);\n\treturn vec2(x, y);\t\n}\n\nvec2 target(float theta, float delta, vec2 p) {\n\treturn unshear(theta, floor(shear(theta, p) + delta) - delta + 0.5);\n}\n\nfloat perforations(float theta, float rot, float scale, float r, vec2 p0) {\n\tvec2 p1 = scale * rotate(rot, p0);\n\treturn distance(p1, target(theta, 0.5, p1)) - r;\n}\n\nvec3 blend(float k, vec3 c0, vec3 c1) {\n\tfloat k_clamp = clamp(k, 0.0, 1.0);\n\treturn (1.0 - k) * c0 + k * c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p0 = 2.0*(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n\tvec2 p0_1 = vec2(p0.x, p0.y);\n\tvec2 p0_2 = vec2(p0.x, p0.y);\n\t\n\tvec2 p1_polar = polar(p0);\n    float wave_cos =\n        (0.05 * sin(0.102*iTime)) *\n        cos(-0.7722*iTime + (0.0 + 10.0 * sin(0.114112*iTime)) * length(p0));\n\tp1_polar.y = p1_polar.y * pow(1.0 + wave_cos, 1.5);\n\tvec2 p1 = cartesian(p1_polar);\n\t\n\t//float theta = TAU / 2.1;\n    float theta = TAU / 3.0;\n\t\n\tfloat rot1 = 0.0011 * TAU * iTime;\n\tfloat rot2 = rot1 + TAU / 12.0 + TAU / 4.0 * sin(0.05213 * iTime);\n\t\n\tfloat scale1 = 12.0 + 0.0 * sin(0.3212*iTime);\n\tfloat scale2 = 12.0;\n\t\n\tfloat r1 = 0.24;\n\tfloat r2 = 0.24;\n\t\n    vec2 p2 = p1 + vec2(0.02 * sin(0.212 * iTime), 0.01 * cos(0.12 * iTime));\n    \n\tfloat i1 = perforations(theta, rot1, scale1, r1, p2);\n\tfloat i2 = perforations(theta, rot2, scale2, r2, p1);\n\t\n    vec2 bg_p1 = 10.2 * rotate(-0.03 * iTime, p2);\n    float bg_noise1 = scale(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(bg_p1.x, 0.5*iTime, bg_p1.y)));\n    \n    vec2 bg_p2 = 77.11 * rotate(0.024 * iTime, p2);\n    float bg_noise2 = scale(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(bg_p2.x, 1.33*iTime, bg_p2.y)));\n    \n    float bg_noise = bg_noise1 * pow(bg_noise2, 1.0);\n    \n    float fg_noise = 1.0 - 0.9 * noise(vec3(231.0*p1, 7.2*iTime));\n    \n\tvec3 bg = blend(length(p0), vec3(0.2), vec3(0.1)) * bg_noise;\n\tvec3 fg = blend(length(p0), vec3(0.4), vec3(0.2)) * fg_noise;\n\t\n\tfloat satan = 0.06;\n\tfloat k = scale(-satan, satan, 0.0, 1.0, max(i1, i2));\n\t\n\tvec3 color;\n\tif(k < 0.0) {\n\t\tcolor = fg;\n\t} else if(k < 1.0) {\n\t\tcolor = blend(k, bg/0.2, fg);\n        //color = blend(k, fg, bg/0.3);\n    } else {\n     \tcolor = blend(k-1.0, 0.9*bg, bg);   \n    }\n\t    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}