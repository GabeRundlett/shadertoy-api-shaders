{
    "Shader": {
        "info": {
            "date": "1656276173",
            "description": "My first attempt at ray marching.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsGcWm",
            "likes": 1,
            "name": "Ray Marching - Benjyman",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Benjyman",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "#define STEPS 256\n#define OCC_STEPS 32\n#define EPSILON 0.01\n\n//////////// 3d Math //////////////\n\nvec3 scaleTo(vec3 v, float length) {\n  return normalize(v) * length;\n}\n\nfloat map(float numer, float denom, float low, float high) {\n  float span = high - low;\n  return (numer / denom * span) + low;\n}\n\nmat3 rotX(float rads) {\n  return mat3(\n    1., 0.,         0.,\n    0., cos(rads), -sin(rads),\n    0., sin(rads),  cos(rads)\n  );\n}\n\nmat3 rotY(float rads) {\n  return mat3(\n    cos(rads), 0., -sin(rads),\n    0.,        1.,  0.,\n    sin(rads), 0.,  cos(rads)\n  );\n}\n\nmat3 rotZ(vec3 p, float rads) {\n  return mat3(\n    cos(rads), -sin(rads), 0.,\n    sin(rads),  cos(rads), 0.,\n    0.,         0.,        1.\n  );\n}\n\nfloat max3(vec3 v) {\n  return max(max(v.x, v.y), v.z);\n}\n\n//////////// end 3d Math //////////////\n\n//////////// SDFs //////////////\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdPlane(vec3 p, vec3 n, float h) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.) / k;\n    return min(a, b) - h*h*k*(1./4.);\n}\n\n//////////// end SDFs //////////////\n\n////////////// Scene //////////////////\n\nconst vec3 bearColor = vec3(.4, .2, .05);\n\nstruct RenderData {\n  vec3 c;  // color\n  float d; // distance\n  float s; // specularity\n};\n\nRenderData minRd(RenderData a, RenderData b, float k) {\n  RenderData rd;\n  rd.d = smin(a.d, b.d, k);\n  if (a.d < b.d) {\n    rd.c = a.c;\n    rd.s = a.s;\n  } else {\n    rd.c = b.c;\n    rd.s = b.s;\n  }\n  return rd;\n}\n\nRenderData minRd(RenderData a, RenderData b) {\n  return minRd(a, b, .7);\n}\n\nbool groundTile(vec3 p) {\n  p /= 5.0;\n  int xSign = p.x > 0.0 ? 1 : 0;\n  int zSign = p.z > 0.0 ? 1 : 0;\n  return ((int(p.x) ^ int(p.z) ^ xSign ^ zSign) & 1) == 1;\n}\n\nRenderData ground(vec3 p) {\n  RenderData rd;\n  rd.d = sdPlane(p, vec3(0., 1., 0.), 0.);\n  rd.c = groundTile(p) ?\n           vec3(.0, .1, .0) :\n           vec3(.1, .2, .0);\n  rd.s = 42.;\n  return rd;\n}\n\nRenderData head(vec3 p) {\n  RenderData rd;\n  rd.d = sdSphere(p - vec3(0., 10, 0.), 3.);\n  rd.c = bearColor;\n  rd.s = 8.;\n  return rd;\n}\n\nRenderData ears(vec3 p) {\n  RenderData rd;\n  p.x = abs(p.x);\n  rd.d = sdSphere(p - vec3(3., 12, 0.), 1.);\n  rd.c = bearColor;\n  rd.s = 8.;\n  return rd;\n}\n\nRenderData body(vec3 p) {\n  RenderData rd;\n  rd.d = sdRoundCone(p - vec3(0., 3.5, 0.), 2., 1., 3.);\n  rd.c = bearColor;\n  rd.s = 8.;\n  return rd;\n}\n\nRenderData render(vec3 p) {\n  RenderData rd = ground(p);\n  rd = minRd(head(p), rd);\n  rd = minRd(ears(p), rd);\n  rd = minRd(body(p), rd);\n  return rd;\n}\n\nfloat f(vec3 p) {\n  return render(p).d;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps, 0);\n    return normalize(\n      vec3(f(p+h.xyy) - f(p-h.xyy),\n           f(p+h.yxy) - f(p-h.yxy),\n           f(p+h.yyx) - f(p-h.yyx))\n    );\n}\n\nRenderData raycast(inout vec3 pos, in vec3 ray) {\n  RenderData rd;\n  for (int i = 0; i < STEPS; ++i) {\n    rd = render(pos);\n    if (rd.d < EPSILON) {\n      break;\n    }\n    pos += scaleTo(ray, rd.d * .7);\n  }\n  return rd;\n}\n\nfloat obstruction(vec3 pos, vec3 ray, float k) {\n  float res = 1.;\n  float d = 0.1;\n  for (int i = 0; i < OCC_STEPS; ++i) {\n    RenderData rd = render(pos + scaleTo(ray, d));\n    if (rd.d < EPSILON) {\n      return 0.0;\n    }\n    res = min(res, k*rd.d/d);\n    d += max(rd.d, EPSILON);\n  }\n  return res;\n}\n\nvec3 lighting(vec3 pos, vec3 camera, vec3 lightVector, vec3 lightIntensity, float specularIntensity) {\n  vec3 normal = calcNormal(pos);\n  \n  float obVal = obstruction(pos, -lightVector, 16.);\n  vec3 diffuse = max(dot(normal, -lightVector), 0.) * lightIntensity * obVal;\n  \n  vec3 cameraVector = normalize(camera - pos);\n  float reflection = max(dot(cameraVector, reflect(lightVector, normal)), 0.);\n  vec3 specular = lightIntensity * pow(reflection, specularIntensity) * specularIntensity / 32.;\n  return diffuse + specular;\n}\n\n////////////// end Scene //////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float rads = iTime / 6.0;\n    mat3 rot = rotY(rads) * rotX(sin(rads/1.9)*.2+.2) * mat3(1.);\n    vec3 camera = rot * vec3(0.0, 10.0, 30.0);\n    vec3 xUnit = rot * vec3(1.0, 0.0, 0.0);\n    vec3 yUnit = rot * vec3(0.0, 1.0, 0.0);\n    vec3 zUnit = rot * vec3(0.0, 0.0, 1.0);\n\n    vec3 center = camera - zUnit;\n    float dx = map(fragCoord.x, iResolution.x, -1.0, 1.0);\n    float dy = map(fragCoord.y, iResolution.y, -1.0, 1.0);\n    vec3 point = center + (dx*xUnit) + (iResolution.y/iResolution.x*dy*yUnit);\n    vec3 ray = point - camera;\n\n    vec3 pos = camera;\n    RenderData rd = raycast(pos, ray);\n\n    vec3 sky = vec3(.8, .9, 1.);\n    vec3 ambientIntensity = vec3(.1, .2, .3);\n    vec3 sunVector = normalize(vec3(-1.0, -1.0, -1.0));\n    vec3 sunIntensity = vec3(.9, .8, .7);\n    vec3 backLightVector = vec3(0., 0., 1.);\n    vec3 backLightIntensity = vec3(.4);\n\n    \n    vec3 color = vec3(0.0);\n\n    if (rd.d >= EPSILON) {\n        color = sky;\n    } else {\n        color = ambientIntensity * rd.c;\n        color += rd.c * lighting(pos, camera, sunVector, sunIntensity, rd.s);\n        color += rd.c * lighting(pos, camera, backLightVector, backLightIntensity, rd.s);\n    }\n    \n    // Gamma correction\n    fragColor.rgb = pow(color, vec3(1./2.2));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}