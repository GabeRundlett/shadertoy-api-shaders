{
    "Shader": {
        "info": {
            "date": "1642551494",
            "description": "Genuary 2022 | Day 18 - VHS This was an older work I've been kicking around - but felt right for VHS/Genuary",
            "flags": 32,
            "hasliked": 0,
            "id": "ss3Sz8",
            "likes": 36,
            "name": "VHS Genuary",
            "published": 3,
            "tags": [
                "raymarching",
                "vhs",
                "genuary"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 1026
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Genuary 2022 | Day 18 - VHS\n    01/18/22 @byt3_m3chanic \n    \n    This was an older work I've been kicking around - but felt right for VHS/Genuary\n    \n    Thank you @Fabrice for text functions / @Shane for lighting functions.\n*/\n\n#define PI  3.14159265359\n\nvec2 curvature = vec2(3.5,4.);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.35);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = baseColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Genuary 2022 | Day 18 - VHS\n    01/18/22 @byt3_m3chanic \n    \n    This was an older work I've been kicking around - but felt right for VHS/Genuary\n    \n    Thank you @Fabrice for text functions / @Shane for lighting functions.\n*/\n\n#define\tR\t\t\tiResolution\n#define\tT\t\t\tiTime\n#define\tM\t\t\tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MAX_DIST    150.\n#define MIN_DIST    .001\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .45 + .40 * cos(PI2 * a + vec3(.75,.5,.25) * vec3(2.89,1.98,.95))\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// webGL2 variant with dynamic size\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= .5;\n    v += char(p, 46);      p.x -= .95;\n    v += pInt(p,fract(n)*1e2);\n    return v;\n}\n////////////////////////////////////////////////////////\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// CRT effect adapted from online blog post. \n// https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc\n\nvec4 getDate(vec2 uv, float px) {\n    vec3 C = vec3(1);\n    vec4 O = vec4(0);\n    vec2 U = ( (uv*8.)-vec2(3.,3.75) )/.45;\n\n    low C(2);C(25);C(20);U.x-=.4;\n    O+=pInt(U,3.);\n    spc\n    C(13);U.x-=.475;\n    O+=pInt(U,3.);\n    C(3);C(8);C(1);C(14);C(9);C(3);\n    spc spc\n    \n    O+=pInt(U,1.);C(-49); spc spc\n    O+=pInt(U,18.);C(-49); spc spc\n    O+=pInt(U,22.);\n    \n    //U.x+=.15;\n    U.y+=.8;\n    O+=pInt(U,abs(iDate.w));\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n    \n    return vec4(shadetext);\n}\n\n// Book Of Shaders - timing functions\nfloat linearstep(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0);}\nfloat easeOutCubic(float t) {return (t = t - 1.0) * t * t + 1.0;}\nfloat easeInCubic(float t) {return t * t * t;}\n\n//The hash functions\nfloat hash(float n) {  return fract(sin(n)*43.54); }\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43.5453); }\n\n//Sum noise\nfloat noise(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.-2.*f);\n    float n = p.x + p.y*57.;\n    float res = mix(mix( hash(n+  0.1), hash(n+  1.1),f.x),\n                    mix( hash(n+ 57.1), hash(n+ 58.1),f.x),f.y);\n    return res;\n}\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n//@iq SDF functions\nfloat sdCap( vec3 p, float h, float r ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// lazy globals\nvec3 htile;\nvec3 g_hp,s_hp;\nfloat travelSpeed,modTime,fractTime,tf;\nfloat ga1,ga2,ga3,ga4,glow;\nconst float rr = 10./4.75;\nconst float rx= rr/2.5;\nvec2 map(vec3 pos, float sg) {\n    vec2 res = vec2(100.,0);\n    // get center vec and some movement\n    vec3 center = vec3(travelSpeed,rx, 0);\n    vec3 pp = pos-center;\n    vec3 sp = pp;\n    // make the id's for beams\n    vec3 pi = floor((pp + 10.)/20.);\n    vec3 tt = pos-center;\n    tt.z-=20.;//fix train to back rail\n    vec3 ti = floor((tt + 10.)/20.);\n    float ftm = hash21(ti.zy+vec2(2.))*30.;\n    tt.x-=T*ftm;\n    pp =  mod(pp+10.,20.) - 10.;\n    tt =  vec3(\n    mod(tt.x+20.,40.) - 20.,\n    mod(tt.y+10.,20.) - 10.,\n    mod(tt.z+20.,40.) - 20.);\n\n    //framework\n    vec3 dp = pp;\n    vec3 cp = pp;\n    dp.x=mod(dp.x+.5,1.)-.5;\n    cp.y=mod(cp.y+1.,2.)-1.;\n    float d2 = fBox(abs(cp)-vec3(8.5,0.,9.45), vec3(2. ,.65 , .125), .01 );\n    float d3 = fBox(abs(dp)-vec3(0.,8.5,10.), vec3(.425 ,2. ,5.45), .01 );\n    //the dx's are the objects - just a float number..\n    float d1 = min(d2,d3);\n    if(d1<res.x) {\n      // comment out line below to remove platform\n        res = vec2(d1,5.);\n        g_hp = pp;\n    }\n\n    // trains\n    float d12 = fBox(tt-vec3(0.,-1.,0),vec3(15.75,5.4,2.),1.5);\n    tt.x=abs(tt.x);\n    float w11 = fBox(tt-vec3(12.,1.,0),vec3(2.75,2.4, 5.5),.5);\n    w11 =   min(fBox(tt-vec3(4., 1.,0),vec3(2.75,2.4, 5.5),.5),w11);\n    w11 =   min(fBox(tt-vec3(0.,-1.,0),vec3(15.5,5.15,1.75),1.5),w11);\n    d12 = max(d12,-w11);\n    if(d12<res.x && ti.z<0.) {\n        res = vec2(d12,3.);\n        g_hp = tt;\n    }\n\n    // pipes\n    pp.x=abs(pp.x);\n    float d11 = sdCap(abs(pp)-vec3(8.,0.,7.), 7.5,.25);\n    if(d11<res.x) {\n        res = vec2(d11,6.);\n        g_hp = pp;\n    }\n    //planks\n    float d15 = fBox(abs(cp)-vec3(8.5,0.,10.), vec3(.15 , 5.65 , .35), .01 );\n    if(d15<res.x) {\n        res = vec2(d15,5.);\n        g_hp = pp;\n    }\n    // lights\n    pp.z = abs(pp.z);\n    float d9 =  length(pp-vec3(5.,6.,7.25))-.25;\n    if(d9<res.x&&sg>0.) {\n        res = vec2(d9,0.);\n        g_hp = pp.zxy;\n    }\n    \n    if(sg>0.){\n        glow += .065/(.0025+d9*d9);\n    }\n    \n    return res;\n}\n\nvec2 marcher( in vec3 ro, in vec3 rd, int maxstep , float sg) {\n    float t = 0.,m = 0.;\n    for( int i=0; i<maxstep; i++ ) {\n        vec2 d = map(ro + rd * t, sg);\n        m = d.y;\n        if(abs(d.x)<MIN_DIST*t||t>MAX_DIST) break;\n        t += i < 32 ? d.x*.5 :  d.x*.75;\n    }\n    return vec2(t,m);\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, float t){\n    float h = t * MIN_DIST;\n    //prevent from inlining @spalmer \n    #define ZERO 0\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h, 0.).x;\n    }\n    return normalize(n);\n}\n\n// textures\nvec4 getRock(vec3 p){\n    vec3 mfp = (p + dot(p,vec3(0,1,0))*5.);\n    float brk = 0.0;\n    brk += abs(noise(mfp.xz*2.)-.5);\n    brk += abs(noise(mfp.xz*12.0)-.5)/2.0;\n    brk = pow(1.0-clamp(brk,0.0,1.0),15.0); // curve to thin the veins\n    return vec4(mix(vec3(0),vec3(1), brk ), brk);\n}\n\nvec3 getColor(float m, in vec3 n, in vec3 p) {\n    vec3 h = vec3(1.);\n    if(m==3.) h = vec3(.2);\n    if(m==5.) {\n        h = mix(vec3(1.),vec3(.5),getRock(s_hp).rgb); \n        h = mix(h,vec3(0.),getRock(s_hp*2.).rgb);\n    }\n    return h;\n}\n\n// softshadow www.pouet.net\n// http://www.pouet.net/topic.php?which=7931\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t,0.).x;\n        if( h<0.001 ) return 0.2;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.),\n          shadow = marcher(p + n * .001 * 2., l, 92,0.).x;\n    if(shadow < length(p -  lpos)) dif *= .3;\n    return dif;\n}\n\nvec3 getSpec(vec3 p, vec3 n, vec3 l, vec3 ro) {\n    vec3 spec = vec3(0.);\n    float strength = 0.75;\n    vec3 view = normalize(p - ro);\n    vec3 ref = reflect(l, n);\n    float specValue = pow(max(dot(view, ref), 0.), 32.);\n    return spec + strength * specValue;\n}\n\n//@Shane low cost AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*1.25/8.; \n        float d = map(p + n*hr,0.).x;\n        occ += (hr - d)*sca;\n        sca *= .5;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\n// main\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // precal\n    travelSpeed = T * 11.2;\n    fractTime = fract(T*.15)* (20.);\n    modTime = mod(T*.3,6.);\n    \n    // make time act like trigger\n    float tm = mod(T*.3, 12.);\n    // smoothstep in hold smoothstep out\n    float a1 = linearstep(0.0, 2.0, tm);\n    float a2 = linearstep(2.0, 4.0, tm);\n    float t1 = easeInCubic(a1);\n    float t2 = easeOutCubic(a2);\n\n    float a3 = linearstep(6.0, 8.0, tm);\n    float a4 = linearstep(8.0, 10.0, tm);\n    float t3 = easeInCubic(a3);\n    float t4 = easeOutCubic(a4);\n    ga1 = t1+t2;\n    ga2 = t3+t4;\n    \n    // reset UV coords to -1 . 0 . 1\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    // ray origin / look point\n    vec3 ro = vec3(0,.75,4.5),\n         lp = vec3(0,.75,0);\n\n    // camera view\n    vec3 cf = normalize(lp-ro),\n         cp = vec3(0.,1.,0.),\n         cr = normalize(cross(cp, cf)),\n         cu = normalize(cross(cf, cr)),\n         c = ro + cf * .75,\n         i = c + uv.x * cr + uv.y * cu,\n         rd = i-ro;\n\n    vec3 C = vec3(0);\n    vec3 FC= vec3(0.75);\n    // move camera\n    ro += vec3(0,(ga1-ga2)*20., 0.);\n    \n    // get distance\n    vec2 ray = marcher(ro,rd,128, 1.);\n    s_hp=g_hp;\n\n    if(ray.x<MAX_DIST) {\n        vec3 p = ro+ray.x*rd,\n             n = getNormal(p,ray.x);\n        vec3 lpos = vec3(-2.0, 4.0, -12.5);\n        vec3 ll = normalize(lpos);\n        \n        vec3 h = getColor(ray.y,n,p);\n        float diff = getDiff(p,n,lpos);\n        vec3 spec = getSpec(p,n,ll,ro);\n        float ao = calcAO(p,n);\n        \n        C = (h * diff + spec) * ao;\n\n        // single bounce reflect \n        if ( ray.y==3.) {\n            vec3 rr=reflect(rd,n);\n            vec2 tay=marcher(p,rr,92,1.);\n            s_hp=g_hp;\n            if(tay.x<MAX_DIST){\n                p+=tay.x*rr;\n                n = getNormal(p,ray.x);\n                h = getColor(tay.y,n,p);\n                diff = getDiff(p,n,lpos);\n                spec = getSpec(p,n,ll,ro);\n                C = clamp(vec3(0),vec3(1),C+(h * diff + spec)*.1);\n            }\n        }\n    } \n    // add glow\n   \n    C = mix(C,clamp(C+glow,vec3(0),vec3(1)),glow*.3);\n    C = clamp(C,vec3(0),vec3(1));\n    // add fog\n    C = mix( C, FC, 1.-exp(-.00000085*ray.x*ray.x*ray.x));\n    //output to screen\n    float px = fwidth(uv.x);\n    vec4 date = getDate(uv, px);\n    C = mix(C,vec3(1),date.x);\n    float tmod = mod(T,2.);\n    if(tmod>1.) {\n        float dt = length(uv-vec2(.39,.496))-.0125;\n        dt=smoothstep(px,-px,dt);\n        C=mix(C,vec3(1,0,0),dt);\n    \n    }\n    \n    C =pow(C, vec3(0.4545));\n    O = vec4(C,1.0);\n}\n// end\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}