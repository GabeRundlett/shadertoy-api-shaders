{
    "Shader": {
        "info": {
            "date": "1509307181",
            "description": "https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n\nplotting template by grinist (https://www.shadertoy.com/view/ltByWW)",
            "flags": 0,
            "hasliked": 0,
            "id": "Xl2yRV",
            "likes": 7,
            "name": "Error Function Approximation",
            "published": 3,
            "tags": [
                "function",
                "error",
                "gauss"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 798
        },
        "renderpass": [
            {
                "code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n// plotting template by grinist (https://www.shadertoy.com/view/ltByWW)\n\nconst float Pi = 3.14159265359; \n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\nfloat Erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n\n//\nfloat ErfI(float x)\n{\n    //x = Erf(x);\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(1.0 - x*x);\n    float c = u * 0.5 + b;\n    \n    float y = sqrt(sqrt(c*c - u*a) - c);\n    //float o = rsqrt(c*c - u*a);\n    //float y = rsqrt(o / (1.0 - c*o));\n    \n    return neg ? -y : y;\n}\n\nfloat ErfStep(float x, float s)\n{\n    return Erf(ErfI(x) * s);\n}\n\nfloat Erf2(float x)\n{\n    bool neg = x < 0.0;\n    x = abs(x);\n    \n    const float p = 0.3275911;\n    const float a1 = 0.254829592;\n    const float a2 =-0.284496736;\n    const float a3 = 1.421413741;\n    const float a4 =-1.453152027;\n    const float a5 = 1.061405429;\n    \n   // a1 = 0.254829592, a2 = −0.284496736, a3 = 1.421413741, a4 = −1.453152027, a5 = 1.061405429\n    float t = 1.0/(1.0 + p*x);\n    \n    float y = 1.0 - (a1*t + a2*t*t + a3*t*t*t + a4*t*t*t*t + a5*t*t*t*t*t) * exp(-x*x);\n    \n    return neg ? -y : y;\n}\n#define Erf Erf2\n// ----- The rest is just for demo\n\nvoid mixColor(inout vec4 baseCol, vec4 color, float alpha)\n{\n    baseCol = vec4(mix(baseCol.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\nvoid drawGrid(inout vec4 baseCol, vec2 xy, vec2 dxy, float stepSize, vec4 gridCol)\n{\n\tfloat mul = 1.0 / stepSize;\n\tvec2 g = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul)); // g passes 0 at stepSize intervals\n\tg = vec2(1.0) - smoothstep(vec2(0.0), dxy * mul * 1.5, g);\n    mixColor(baseCol, gridCol, max(g.x, g.y));\n}\n\nfloat Plot(float f, float y)\n{\n    float v = f - y;\n    v /= length(vec2(dFdx(v), dFdy(v)));\n    v = clamp(1.0 - abs(v*0.5), 0.0, 1.0);\n    \n    return v;\n}\n\nvoid drawCurve(inout vec4 baseCol, float y, float value, vec4 curveCol)\n{\n\tmixColor(baseCol, curveCol, Plot(value, y) * curveCol.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 graphSize = vec2(aspect * 1.2, 1.2);\n\tvec2 graphPos = 0.5 - graphSize * 0.5;\n\n\tvec2 xy = graphPos + uv * graphSize;\t// graph coords\n\tvec2 dxy = graphSize / iResolution.xy;\t// pixel size in graph units\n\n    // background\n\tvec4 col = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.7, 0.7, 0.7, 1.0), pow(length(0.5 - uv) * 1.414, 3.5));\n    \n\t// grid\n    drawGrid(col, xy, dxy, 0.1, vec4(0.0, 0.0, 0.0, 0.2));\n\tdrawGrid(col, xy, dxy, 0.5, vec4(0.0, 0.0, 0.0, 0.3));\n\tdrawGrid(col, xy, dxy, 1.0, vec4(0.0, 0.0, 0.0, 0.4));\n\n   // curves\n    xy = xy*2.0-1.0;\n    //xy.x *= 4.0;\n    //xy.y -= 0.5;\n    float l = mix(1.0/6.0, 6.0, sin(iTime)*0.5+0.5);\n    \n\tdrawCurve(col, xy.y * 2.0, ErfI(clamp(xy.x, -1.0, 0.9999)), vec4(0.15, 0.45, 0.85, 1.0));    \n\tdrawCurve(col, xy.y, Erf (xy.x * 2.0            ), vec4(0.91, 0.13, 0.23, 1.0));    \n\t//drawCurve(col, xy.y, ErfStep(xy.x, 1.0/4.0), vec4(0.11, 0.9, 0.23, 1.0));    \n    \n \n\tfragColor = col;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}