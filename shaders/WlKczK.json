{
    "Shader": {
        "info": {
            "date": "1611348408",
            "description": "I don't even know why I did this",
            "flags": 32,
            "hasliked": 0,
            "id": "WlKczK",
            "likes": 0,
            "name": "2D Volumetric Path Tracing",
            "published": 3,
            "tags": [
                "volumetric",
                "pathtrace",
                "pathtrace",
                "pathtracing",
                "volumetrics"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 353
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define stepsize 0.01\n#define scenesize 2.0\n\n// Value Noise, only takes whole numbers or else you get bands and stuff.\nfloat hash12(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx)*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// Convert the value Noise to gradient noise so it is smooth.\nfloat noise(vec2 n){\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\n// 2D fBm Noise, basically justs adds noise, scales it by 2, adds it back with 1/2 the effect, and repeat.\n#define NUM_OCTAVES 8\nfloat fbm(vec2 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.5;}\n\treturn v;}\n\nvec4 densityfunction(vec2 pathposition){return vec4(vec3(1.0), max(0.0, fbm(pathposition*4.0)-distance(pathposition, vec2(0.0)))*50.0);}\n\nvec3 pathtrace(vec2 uv){\n    vec4 density;\n    float absorbance;\n    float distancetravelled = 0.0;\n    vec3 attenuation = vec3(1.0);\n    vec2 pathposition = vec2(-0.5, 0.5);\n    vec3 outputcolor = vec3(0.0);\n    vec2 pathdirection = normalize(nrand2(1.0, vec2(1.0, -1.0)))+(rand()-0.5)*2.0;\n    for(int i = 0; i < 128; i++){\n        density = densityfunction(pathposition);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){attenuation *= clamp(density.rgb, 0.0, 1.0); pathdirection = normalize(nrand2(1.0, vec2(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(distance(pathposition, vec2(0.0)) > scenesize || distancetravelled > 32.0){break;}\n        if(distance(uv, pathposition)-0.01 < 0.0){outputcolor += 32.0*(1.0-absorbance)*attenuation;}}\n    return outputcolor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    INIT_RNG;\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat2 rotationmatrix = mat2(1.0, 0.0, 0.0, 1.0);\n    //vec2 pathdirection = normalize((uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1]));\n\n    vec3 col = pathtrace(uv*2.0);\n\n    fragColor += vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}