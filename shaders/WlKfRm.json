{
    "Shader": {
        "info": {
            "date": "1614095656",
            "description": "potat  ",
            "flags": 32,
            "hasliked": 0,
            "id": "WlKfRm",
            "likes": 13,
            "name": "Day 432",
            "published": 3,
            "tags": [
                "game",
                "life",
                "gameoflife",
                "of",
                "gol",
                "mdtmjvm",
                "continous"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "// Fork of \"Day 431\" by jeyko. https://shadertoy.com/view/ttKBzD\n// 2021-02-23 15:15:41\n\n// tried to make a continous Game of Life\n// ended up being too wormy to be Game of Life, but cool in its own right! \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C = C*.0;\n    \n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    //C += T1(U);\n    C = T1(U);\n    \n    \n    \n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(U + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(U  + n1d*200. ,256.)),0).xyz;\n    \n    \n    C *= 1. - dot(uv,uv*0.25);\n    C = smoothstep(0.,1.,C);\n    \n    C.xyz = pow(max(C.xyz,0.), vec3(0.55) + dot(uv,uv)*0.6);\n    \n    \n    \n    C.xyz += smoothstep(1.,0.,length(C))*n*0.15;\n    \n    C.xyz -= smoothstep(0.,1.,length(C))*n*0.05;\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    vec2 OU = U;\n    U += 0.25;\n    //U -= 0.5*R;   \n    //U *= 1. - fract(iTime*kTimeCoeff)*0.002;\n    //U *= rot(0.1*pow(fract(iTime*kTimeCoeff*0.125/2.),17.1)*0.1);\n    \n    //U *= 1. - dot(uv,uv)*0.001;\n    //U += 0.5*R;\n    //vec2 grady = getGradient( iChannel0, U, 3., 1, R);\n    //vec2 gradz = getGradient( iChannel0, U, 3., 2, R);\n        \n    \n    float neighrange = 25. - sin(iTime*0.25)*5.;\n    neighrange *= 0.65;\n    vec2 muv = (iMouse.xy - 0.5*R)/R.y;   \n    \n    if(iMouse.z > 0.)\n        neighrange *= 1. + 1.*smoothstep(0.01,0.,length(uv - muv) - .3);\n\n    \n    \n    vec2 grad = getGradient( iChannel0, U, neighrange*0.4, 0, R);\n       \n    \n    \n    \n      \n    float neighs = 0.;\n    \n    float iiters = 64.*0.5;            \n    float jiters = 64.*0.5;\n    \n    for(float i = 0.; i < iiters; i++){\n        vec2 p = U; \n        \n        vec2 offs = vec2(0,1.)*rot(2.*pi*(i + 0.)/iiters);\n        \n        float samp = 0.;\n        float jiters = 16.;\n        for(float j = 0.; j < jiters; j++){\n            vec2 ioffs = p + offs*mix(neighrange*0.2,neighrange,j/jiters);\n            samp += texture(iChannel0,fract(ioffs/R),0.5).x/jiters;\n        \n        }\n        \n        neighs += samp/iiters*4.;\n    }\n   \n    C = T(U);\n    \n    float deadness = smoothstep(1.,0.,abs(C.x));\n    float aliveness = smoothstep(0.,1.,abs(C.x));\n    //deadness = 1. - C.x;\n    //aliveness = C.x;\n    \n    //U += grad*.01*smoothstep(1.8,0.1,abs(neighs - 3.))*aliveness;\n    //U += grad*1.9*smoothstep(2.4,1.,abs(neighs - 2.))*aliveness;\n    \n    \n    \n    C = T(U);\n    \n    //deadness = smoothstep(1.,0.,abs(C.x));\n    //aliveness = smoothstep(0.,1.,abs(C.x));\n    //deadness = 1. - C.x;\n    //aliveness = C.x;\n    \n    \n    \n    float speed = 0.8;\n    C = mix(C,vec4(0),smoothstep(.5,0.,neighs - 1.)*aliveness*speed);\n    C = mix(C,vec4(0),smoothstep(-0.125,0.,neighs - 3.)*aliveness*speed);\n    \n    \n    C = mix(C,vec4(1),\n            smoothstep(0.5,0.,abs(neighs - 2.5))*\n        deadness*\n        speed);\n    \n    \n    //vec2 gradw = getGradient( iChannel0, U, 3., 3, R);\n    \n    //grad *= rot(.2);\n    \n    //U += grad[(iFrame/30)%0]*.1*sin(iTime);\n    \n    \n    //if(iMouse.z > 0.)\n    \n    //C = blur(iChannel0, U, R);\n    \n    \n    \n    if(iFrame%4 > 0){\n        //C = T(OU);\n    }\n    \n    \n    if(iFrame == 0){\n        C = T3(U*2.2);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 fr = texture(iChannel0,(U)/iResolution.xy);\n   \n    float r = 17.4\n        + sin(fr.x*2. - 1.)*1.4;\n    int didx = 0;\n    \n    vec2 dfn = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n    \n    vec2 sc = vec2(0)\n        + pow(smoothstep(0.,1.,length(dfn.xy)*4.),.2)*.15*dfn;\n    \n    \n    \n    C.x =texture(iChannel0,(U + sc*vec2(0,2))/iResolution.xy).x;\n    \n    C.y =texture(iChannel0,(U + sc*vec2(0,-5))/iResolution.xy).y;\n    \n    C.z =texture(iChannel0,(U + sc*vec2(5,-5.))/iResolution.xy).z;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R (iResolution.xy)\n#define T(u) texture(iChannel0,fract((u)/R))\n#define T1(u) texture(iChannel1,fract((u)/R))\n#define T2(u) texture(iChannel2,fract((u)/R))\n#define T3(u) texture(iChannel3,fract((u)/R))\n\n#define TT(u,T) texture(T,fract((u)/res))\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n\n#define kTimeCoeff 60./167.85*4.\n\nvec2 getGradient(sampler2D tex, vec2 u, float offset, int channel, vec2 res){\n    return vec2(\n         TT(u + vec2(1,0)*offset,tex)[channel] - TT(u - vec2(1,0)*offset,tex)[channel],\n         TT(u + vec2(0,1)*offset,tex)[channel] - TT(u - vec2(0,1)*offset,tex)[channel]  \n    );\n}\n//#define Neighbordhood() vec4 me = T() \n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 sharpen(sampler2D channel,vec2 fragCoord, vec2 resolution){\n    float kernel [9];vec2 offset [9];\n    \n    vec2 step = vec2(1);\n    \n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    \n    kernel[0] = 0.0; kernel[1] = -0.25; kernel[2] = 0.0;\n    kernel[3] = -0.25; kernel[4] = 1.0; kernel[5] = -0.25;\n    kernel[6] = 0.0; kernel[7] = -0.25; kernel[8] = 0.0;\n    \n    vec4 sum = texture(channel, (fragCoord)/resolution);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, (fragCoord + offset[i])/resolution);\n        sum += color * kernel[i];\n    }\n    \n    sum = clamp(sum,0.,1.);\n    \n    return sum;\n}\n\nvec4 blur(sampler2D channel,vec2 fragCoord, vec2 resolution){\n    \n    float kernel [9];vec2 offset [9];\n\n     vec2 step = vec2(0.5);\n    \n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 1.0; kernel[1] = 1.0; kernel[2] = 1.0;\n    kernel[3] = 1.0; kernel[4] = 1.0; kernel[5] = 1.0;\n    kernel[6] = 1.0; kernel[7] = 1.0; kernel[8] = 1.0;\n    \n    vec4 sum = vec4(0);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, (fragCoord + offset[i])/resolution);\n        sum += color * kernel[i];\n    }\n    \n    sum /= 9.;\n    sum = clamp(sum,0.,1.);\n    \n    return sum;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}