{
    "Shader": {
        "info": {
            "date": "1673525975",
            "description": "Ancient music player, upgraded for the modern era;  plays fast for the impatient; mouseable.",
            "flags": 0,
            "hasliked": 0,
            "id": "DtB3zV",
            "likes": 27,
            "name": "Jukebox",
            "published": 3,
            "tags": [
                "mechanism",
                "phonograph",
                "gramophone"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "// \"Jukebox\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec3 HsvToRgb (vec3 c);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, objOrg, cabSize;\nfloat tCur, dstFar, tLoop, tCyc, abSide, nRec, selRec, cRec, nLoop, carslAng, \n   bCylRad, bCylHt;\nint idObj;\nbool haveRec, showPick, showVol;\nconst int idCarsl = 1, idRec = 2, idGrab = 3, idGrabS = 4, idPlat = 5, idArm = 6, idNeed = 7,\n   idSup = 8, idLeg = 9, idBase = 10, idPick = 11, idVol = 12, idArc = 13, idCab = 14,\n   idSpkr = 15, idGril = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct CS {\n  vec2 carslAng, armAng, armAngV, platAng, platAngS, recAng, recTwAng, grabAng, grabTwAng;\n} cs;\n\nvoid SetConf ()\n{\n  vec3 armLim;\n  vec2 tpLim, taLim;\n  float armAng, armAngV, grabAng, recAng, platAng, ti, tg, platSpd;\n  nRec = 64.;\n  selRec = mod (nLoop * (floor (nRec / 2.) - 5.), nRec);\n  abSide = 1. - 2. * mod (floor (nLoop * 2.3), 2.);\n  ti = tLoop / tCyc;\n  tg = 0.05;\n  platSpd = 7.;\n  tpLim = 0.05 + (selRec / nRec) * 0.2 + vec2 (0., 0.7);\n  if (ti < 0.05 || ti > 1. - 0.05) carslAng = 0.;\n  else if (ti < tpLim.x) carslAng = 5. * (ti - 0.05);\n  else if (ti < tpLim.y) carslAng = selRec / nRec;\n  else carslAng = 5. * (ti - 0.05) - 5. * 0.7;\n  armLim = vec3 (0., 0.14, 0.195) * pi;\n  taLim = tpLim + vec2 (1., -1.) * 4. * tg;\n  if (ti < taLim.x || ti >= taLim.y) armAng = armLim.x;\n  else if (ti < taLim.x + tg) armAng = mix (armLim.x, armLim.y, (ti - taLim.x) / tg);\n  else if (ti < taLim.y - tg) armAng = mix (armLim.y, armLim.z, (ti - (taLim.x + tg)) /\n     (tpLim.y - tpLim.x - 10. * tg));\n  else if (ti < taLim.y) armAng = mix (armLim.z, armLim.x, (ti - (taLim.y - tg)) / tg);\n  armAngV = -0.02 * pi * (1. - smoothstep (-0.2 * tg, 0., ti - (taLim.x + tg)) +\n     smoothstep (0., 0.2 * tg, ti - (taLim.y - tg)));\n  platAng = (ti > tpLim.x + 4. * tg && ti < tpLim.y - 4. * tg) ? platSpd * 2. * pi *\n     (ti - (tpLim.x + 4. * tg)) / (tpLim.y - tpLim.x - 8. * tg) : 0.;\n  recAng = pi * (smoothstep (tpLim.x + tg, tpLim.x + 3. * tg, ti) - smoothstep (tpLim.y - 3. * tg,\n     tpLim.y - tg, ti));\n  grabAng = recAng + 0.5 * pi * (1. - smoothstep (tpLim.x, tpLim.x + tg, ti) -\n     smoothstep (tpLim.x + 3. * tg, tpLim.x + 4. * tg, ti) +\n     smoothstep (tpLim.y - 4. * tg, tpLim.y - 3. * tg, ti) +\n     smoothstep (tpLim.y - tg, tpLim.y, ti));\n  cs.carslAng = CosSin (2. * pi * carslAng);\n  cs.recAng = CosSin (recAng);\n  cs.recTwAng = CosSin (-0.5 * pi * abSide * smoothstep (0.5 * pi, 0.8 * pi, recAng));\n  cs.platAng = CosSin (platAng);\n  cs.platAngS = CosSin (- abSide * platAng);\n  cs.grabAng = CosSin (grabAng);\n  cs.grabTwAng = CosSin (-0.5 * pi * abSide * smoothstep (0.5 * pi, 0.8 * pi, grabAng));\n  cs.armAng = CosSin (armAng);\n  cs.armAngV = CosSin (armAngV);\n  haveRec = (ti > tpLim.x + tg && ti < tpLim.y - tg);\n  showPick = (ti > 0.05 && ti < 1. - 0.05);\n  showVol = (armAngV == 0.);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dd, dr, r, a, s, rRec, tRec, rHole, cRecT;\n  rRec = 0.49;\n  tRec = 0.008;\n  rHole = 0.05;\n  dMin = dstFar;\n  p -= objOrg;\n  q = p;\n  q.x -= -1.2;\n  q.xz = Rot2Cs (q.xz, cs.carslAng);\n  d = min (PrCylDf (vec3 (((abs (q.x) > abs (q.z)) ? q.xz : q.zx), q.y + 0.07).yzx, 0.02, 0.5),\n     PrCylDf (vec3 (q.xz, q.y + 0.3), 0.1, 0.3));\n  d = min (d, PrCylDf (vec3 (q.x - 1.5, q.y + 0.06, q.z).yzx, 0.03, 0.06));\n  DMINQ (idCarsl);\n  q.xz = Rot2Cs (q.xz, sin (pi / nRec +  + vec2 (0.5 * pi, 0.)));\n  a = atan (q.z, - q.x) / (2. * pi);\n  cRecT = (floor (nRec * (nRec * (a + 0.5) - carslAng) + 0.5) - 0.5) / nRec;\n  q.xz = Rot2Cs (q.xz, sin (2. * pi * (floor (nRec * a) + 0.5) / nRec + vec2 (0.5 * pi, 0.)));\n  q.x -= -1.;\n  r = length (q.xy);\n  dd = max (r - 0.55, abs (q.z) - 1.8 * tRec);\n  qq = q;\n  dr = max (abs (r - 0.5 * (rRec + rHole)) - 0.5 * (rRec - rHole), abs (q.z) - tRec);\n  q = p;\n  q.x -= -1.2;\n  r = length (q.xz) - 1.;\n  s = length (vec2 (r, q.y));\n  d = max (min (max (abs (s - 0.45) - 0.05, - dd), max (abs (s - rRec - 0.02) - 0.01,\n     min (abs (r) - 0.1, - q.y - 0.1))), q.y + 0.02);\n  DMINQ (idCarsl);\n  d = dr;\n  if (haveRec) d = max (d, min (q.x, 4. * tRec - abs (q.z)));\n  q = qq;\n  if (d < dMin) cRec = cRecT;\n  DMINQ (idRec);\n  if (haveRec) {\n    q = p;\n    q.x -= 0.9;\n    q.xy = Rot2Cs (q.xy, cs.recAng);\n    q.x -= -1.1;\n    q.yz = Rot2Cs (q.yz, cs.recTwAng);\n    d = max (abs (length (q.xy) - 0.5 * (rRec + rHole)) - 0.5 * (rRec - rHole), abs (q.z) - tRec);\n    q.xy = Rot2Cs (q.xy, cs.platAngS);\n    if (d < dMin) cRec = nRec - 1. - selRec;\n    DMINQ (idRec);\n  }\n  q = p;\n  q.x -= 0.9;\n  d = PrCylDf (q, 0.02, 0.25);\n  DMINQ (idGrabS);\n  q.z = abs (q.z);\n  q.yz -= vec2 (-0.1, 0.2);\n  d = PrCylDf (q.xzy, 0.03, 0.13);\n  DMINQ (idSup);\n  q = p;\n  q.x -= 0.9;\n  q.xy = Rot2Cs (q.xy, cs.grabAng);\n  q.x -= -1.1;\n  q.yz = Rot2Cs (q.yz, cs.grabTwAng);\n  d = max (max (abs (length (q.xy) - rRec - 0.03) - 0.03, abs (q.z) - 1.3 * tRec), -0.01 - q.y); \n  DMINQ (idGrab);\n  d = PrCylDf (vec3 (q.yz, q.x - 0.83), 0.04, 0.31);\n  DMINQ (idGrabS);\n  q = p;\n  q.xy -= vec2 (2., -0.05 - tRec);\n  q.xz = Rot2Cs (q.xz, cs.platAng);\n  r = length (q.xz);\n  d = min (max (r - (rRec - 0.02), abs (q.y) - 0.05), max (r - rHole, abs (q.y) - 0.08));\n  DMINQ (idPlat);\n  q = p;\n  q.xz = Rot2Cs (q.xz - vec2 (2.7, 0.5), cs.armAng);\n  d = PrCylDf (q.xzy, 0.06, 0.17);\n  q.y -= 0.1;\n  d = max (d, 0.027 - length (q.xy));\n  DMINQ (idSup);\n  d = PrCylDf (q.yzx, 0.02, 0.08);\n  DMINQ (idArm);\n  q.yz = Rot2Cs (q.yz, cs.armAngV);\n  r = length (q.xy);\n  d = min (min (max (r - 0.08, abs (q.z - 0.17) - 0.03), max (r - 0.02, abs (q.z + 0.31) - 0.54)),\n     max (r - 0.03, abs (q.z + 0.81) - 0.035));\n  DMINQ (idArm);\n  q.yz -= vec2 (-0.04, -0.81);\n  d = PrCapsDf (q.xzy, 0.005, 0.04);\n  DMINQ (idNeed);\n  q = p;\n  q -= vec3 (1.5, -0.5, -1.3);\n  d = PrRoundBoxDf (q, vec3 (0.3, 0.03, 0.2), 0.02);\n  DMINQ (idPick);\n  q = p;\n  q -= vec3 (0.5, -0.5, -1.3);\n  d = PrRoundBoxDf (q, vec3 (0.15, 0.03, 0.4), 0.02);\n  DMINQ (idVol);\n  q = p;\n  q.y -= -0.6;\n  d = PrBoxDf (q, vec3 (cabSize.xz - 0.1, 0.05).xzy);\n  d = min (d, PrBoxDf (vec3 (q.x - 1.8, q.y - 0.38, q.z), vec3 (1.1, 0.1, 0.7)));\n  DMINQ (idBase);\n  d = PrCylDf (vec3 (abs (vec2 (q.x - 1.8, q.z)) - vec2 (0.85, 0.4), q.y - 0.15), 0.15, 0.13);\n  DMINQ (idLeg);\n  q = p;\n  q.yz -= vec2 (-0.6, cabSize.z - 0.25);\n  d = max (PrTorusDf (q, 0.1, cabSize.x - 0.25), - q.y);\n  DMINQ (idArc);\n  q = p;\n  q.y -= - cabSize.y - 0.65;\n  d = PrRoundBoxDf (q, cabSize - 0.03, 0.03);\n  dd = PrRoundBox2Df (vec2 (abs (q.x) - 1.5, q.y), vec2 (0.82, 1.98), 0.03);\n  d = max (d, - max (dd, q.z));\n  DMINQ (idCab);\n  q.z -= -1.7;\n  d = max (dd, abs (q.z) - 0.05);\n  DMINQ (idSpkr);\n  q.xy = (fract (3. * q.xy + 0.5) - 0.5) / 3.;\n  q.z -= -0.15;\n  d = max (min (length (q.xz), length (q.yz)) - 0.02, dd);\n  DMINQ (idGril);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p -= objOrg;\n  q = p;\n  q.y -= -0.67;\n  d = max (PrRoundCylDf (q, cabSize.x - 0.13, 0.1, cabSize.z - 0.13), - q.y);\n  DMINQ (0);\n  return dMin;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (out vec2 vf, out bool isMet)\n{\n  vec4 col4, cVol4;\n  vec3 c;\n  vec2 w, iw;\n  float r, t, tVol;\n  vf = vec2 (0.);\n  isMet = false;\n  if (idObj <= idSup) {\n    if (idObj == idCarsl) {\n      col4 = vec4 (0.7, 0.4, 0.2, 0.1);\n      isMet = true;\n    } else if (idObj == idRec) {\n      r = length (qHit.xy);\n      if (qHit.y > 0. && r < 0.22 || r > 0.48)\n         col4 = vec4 (HsvToRgb (vec3 (cRec / nRec, 0.8, 1.)), 0.1);\n      else if (qHit.y < 0. && r < 0.22) col4 = vec4 (0.9, 0.9, 0.9, 0.1);\n      else col4 = vec4 (0.4, 0.4, 0.45, 0.1) * (0.8 + 0.2 * step (abs (r - 0.35), 0.06));\n      col4 *= 1. - 0.8 * step (length (vec2 (((qHit.z > 0.) ? qHit.x : abs (qHit.x) - 0.04),\n         qHit.y + 0.15)), 0.02);\n      col4 *= 1. - 0.8 * step (0.001, ShowIntPZ (vec2 (sign (qHit.z) * qHit.x - 0.075,\n         - (qHit.y - 0.15)), 0.3 * vec2 (0.5, 0.25), 2., selRec + 1.));\n      if (abs (qHit.x) < 0.08 && abs (qHit.y - 0.18) < 0.006) col4 *= 0.2;\n    } else if (idObj == idGrab) {\n      col4 = vec4 (0.9, 0.7, 0.5, 0.1) * (0.5 + 0.5 * step (0.02, Minv2 (abs (qHit.xy))));\n      isMet = true;\n    } else if (idObj == idGrabS) {\n      col4 = vec4 (0.9, 0.7, 0.5, 0.1);;\n      isMet = true;\n    } else if (idObj == idPlat) {\n      r = length (qHit.xz);\n      if (r > 0.055 && r < 0.43) {\n        col4 = vec4 (0.4, 0.4, 0.5, 0.1) * (0.8 + 0.2 * smoothstep (0.01, 0.02,\n           Minv2 (abs (qHit.xz))));\n        vf = vec2 (128., 0.2);\n      } else {\n        col4 = vec4 (0.9, 0.9, 0.9, 0.1);\n        if (abs (qHit.y) < 0.04) col4 *= 0.8 + 0.2 * smoothstep (0.02, 0.3, fract (32. *\n           (atan (qHit.z, - qHit.x) / (2. * pi) + 0.5)));\n        isMet = true;\n      }\n    } else if (idObj == idArm) {\n      col4 = vec4 (0.9, 0.7, 0.5, 0.1);\n      isMet = true;\n    } else if (idObj == idNeed) {\n      col4 = vec4 (0.9, 0.9, 0., -1.);\n      isMet = true;\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      isMet = true;\n    }\n  } else {\n    if (idObj == idVol || idObj == idCab) {\n      tVol = floor (16. * clamp (1.3 * Fbm1 (8. * floor (16. * tCur) / 16.) - 0.1, 0., 1.)) / 16.;\n      cVol4 = vec4 (HsvToRgb (vec3 (0.7 - 0.7 * tVol, 1., 1.)), -1.);\n    }\n    if (idObj == idLeg) {\n      col4 = vec4 (0.9, 0.9, 1., 0.1) * (0.8 + 0.2 * step (0.2, fract (32. * qHit.y)));\n      isMet = true;\n    } else if (idObj == idBase) {\n      col4 = vec4 (vec3 (0.5), 0.1);\n      if (min (abs (qHit.y - 0.05), abs (qHit.y - 0.48)) < 0.01) {\n        w = 12. * qHit.zx;\n        col4 *= mix (1.8, 1., step (0.1, HexEdgeDist (w - HexToPix (PixToHex (w)))));\n      }\n      col4 *= 0.7 + 0.3 * step (1.1, length (vec2 (qHit.x + 1.2, qHit.z)));\n    } else if (idObj == idPick) {\n      col4 = vec4 (1., 1., 0.7, -1.);\n      if (showPick) {\n        col4.rgb *= 1. - 0.8 * step (0.001, ShowIntPZ (qHit.xz - vec2 (0.13, -0.08),\n           0.7 * vec2 (0.5, 0.25), 2., selRec + 1.));\n        col4.rgb *= 1. - 0.8 * step (length (vec2 (qHit.x - 0.22, ((abSide > 0.) ? qHit.z :\n           abs (qHit.z) - 0.05))), 0.03);\n      }\n    } else if (idObj == idVol) {\n      col4 = vec4 (1., 1., 0.7, 0.);\n      if (PrBox2Df (qHit.xz, vec2 (0.15, 0.4) - 0.01) < 0.) { \n        col4 = vec4 (0.2, 0.2, 0.2, -1.);\n        if (showVol && (qHit.z + 0.4) / 0.8 < tVol) col4 = cVol4;\n      }\n    } else if (idObj == idArc) {\n      t = fract (2. * (atan (qHit.y, - qHit.x) / (2. * pi) + 0.5) + 0.5 * sin (0.5 * pi * tCur));\n      col4 = (showVol) ? vec4 (HsvToRgb (vec3 (t, 1., 1.)), -1.) : vec4 (vec3 (1., 1., 0.7) * \n         (0.8 + 0.2 * sin (16. * pi * t)), -1.);\n    } else if (idObj == idCab) {\n      col4 = vec4 (1., 0.9, 1., 0.1) * (0.8 + 0.2 * Fbm2 (vec2 (4., 1.) *\n         vec2 (((abs (qHit.x) < cabSize.x - 0.01) ? qHit.x : qHit.z), qHit.y)));\n      if (qHit.x > 0. && length (vec2 (abs (qHit.z - cabSize.z + 0.6) - 0.1,\n         qHit.y + cabSize.y - 0.15)) < 0.05) col4 = vec4 (0.2, 1., 0.2, -1.);\n      t = Minv3 (vec3 (abs (qHit.xz) - cabSize.xz + 0.2, cabSize.y - 0.3 - abs (qHit.y)));\n      if (t < 0.) {\n        r = length (qHit.yz) - 1.5;\n        if (r < 0.) {\n          w = 8. * Rot2D (qHit.yz, pi / 12.);\n          iw = PixToHex (w);\n          t = mod (dot (mod (2. * iw + iw.yx, 3.), vec2 (1., 2.)), 3.);\n          c = vec3 (0.9, 0.9, 0.);\n          if (t > 0.) c = mix (c.xzz, c.zxz, t - 1.);\n          c = mix (vec3 (0., 0., 1.), c, smoothstep (0.05, 0.1, HexEdgeDist (w - HexToPix (iw))));\n          col4 = vec4 (c, 0.1);\n        } else if (r < 0.05) col4 *= 0.8;\n      } else if (t > 0.03) {\n        col4 = (showVol) ? cVol4 : vec4 (vec3 (1., 1., 0.9) * (0.8 + 0.2 * sin (4. * pi *\n           (qHit.y + tCur))), -1.);\n      } else col4 *= 0.7;\n    } else if (idObj == idSpkr) {\n      w = 6. * qHit.yx;\n      col4 = vec4 (0.6, 0.2, 0., 0.) * (1. + 0.3 * step (HexEdgeDist (w -\n         HexToPix (PixToHex (w))), 0.07));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idGril) {\n      col4 = vec4 (0.9, 0.9, 0.2, 0.2);\n      isMet = true;\n    }\n  }\n  return col4;\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - rad * rad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = len;\n    if (abs (s.y) < len) vn.xz = - s.xz / rad;\n    else {\n      d = (- srdy * ro.y + len) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd, out bool needSh)\n{  // (from \"Soup Can Dynamics\")\n  vec4 vc, db4, col4;\n  vec3 vn, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, ga;\n  db4 = InCylHit (ro - vec3 (0., bCylHt, 0.), rd, bCylRad, bCylHt);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  ro += dCyl * rd;\n  needSh = false;\n  if (vnCyl.y == 0.) {\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (32. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col4 = vec4 (0.5, 0.5, 1., -1.);\n    } else {\n      col4 = vec4 (0.2, 0.4, 0.2, -1.);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        col4 = vec4 (0.4, 0.2, 0., 0.);\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col4 *= 0.8;\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05,\n             16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          qw = 8. * vec2 (12. * a, 2. * hy);\n          rg = ShStagGrid (qw);\n          col4 *= rg.y * (1. - 0.2 * Noisefv2 (32. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    vc = HexVor (ro.xz);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.yz, 4.)).xzy,\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col4 = vec4 (HsvToRgb (vec3 (0.8 * floor (8. * vc.w) / 8., 0.5 * smoothstep (0.06, 0.08, vc.x),\n       0.9)) * (0.5 + 0.5 * b * step (0.06 + 0.03 * vc.w, vc.x) * (1. -\n       0.2 * Noisefv2 (16. * ro.xz))), 0.1);\n    needSh = true;\n  } else {\n    b = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = float (VAR_ZERO); n < 128.; n ++) b += 1. - step (0.015,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col4 = mix (vec4 (0.3, 0.3, 0.8, 0.), vec4 (1., 1., 0.4, -1.), b);\n  }\n  return (col4.a >= 0.) ? col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) : col4.rgb;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  vec2 vf;\n  float dstObj, dstTrObj, nDotL, sh;\n  bool isMet, needSh;\n  HexVorInit ();\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (vf, isMet);\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (isMet) nDotL *= nDotL;\n    }\n  } else {\n    col = BgCol (ro, rd, needSh);\n    if (needSh) {\n      ro += (- ro.y / rd.y) * rd;\n      vn = vec3 (0., 1., 0.);\n    }\n  }\n  sh = (dstObj < dstFar && col4.a >= 0. || dstObj >= dstFar && needSh) ?\n     ObjSShadow (ro + 0.01 * vn, ltDir) : 1.;\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n  } else {\n    col = 0.2 + 0.4 * (0.5 + 0.5 * sh) * col;\n  }\n  ro = roo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (col, BgCol (ro, reflect (rd, vn), needSh), 0.05 + 0.95 *\n       pow (1. - abs (dot (vn, rd)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = max (tCur - 1., 0.);\n  tCyc = 30.;\n  tCur += floor (20. * tCyc * floor (dateCur.w / (20. * tCyc)) / tCyc) * tCyc;\n  tLoop = mod (tCur, tCyc);\n  nLoop = 1. + floor (tCur / tCyc);\n  SetConf ();\n  t = SmoothBump (0.15, 0.85, 0.1, tLoop / tCyc);\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * (mPtr.y - 0.25);\n  } else {\n    az = 0.15 * pi * sign (mod (nLoop, 2.) - 0.5) * sign (tLoop / tCyc - 0.5) * (1. - t);\n    el = - pi * (0.25 + 0.17 * t);\n  }\n  el = clamp (el, -0.47 * pi, -0.05 * pi);\n  bCylRad = 40.;\n  bCylHt = 15.;\n  cabSize = vec3 (3.1, 3., 1.9);\n  objOrg = vec3 (0., 2. * cabSize.y + 0.75, 0.);\n  ro = vec3 (0., objOrg.y - 3., -0.9 * bCylRad);\n  vd = normalize (objOrg + vec3 (0., 10., 0.) - ro);\n  az += atan (vd.z, - vd.x) - 0.5 * pi;\n  el += asin (vd.y);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * ro;\n  ro.y = max (ro.y, 1.);\n  vd.xz = Rot2D (vd.xz, 0.1 * pi);\n  vd.yz = Rot2D (vd.yz, 0.2 * pi);\n  ltDir = - vuMat * vd;\n  zmFac = mix (4.5, 12., smoothstep (0., 0.5 * pi, - el));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}