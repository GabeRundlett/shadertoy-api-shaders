{
    "Shader": {
        "info": {
            "date": "1555684862",
            "description": "An improvement upon IQ's dolphin shader.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtlGRH",
            "likes": 12,
            "name": "Dolphin Improved",
            "published": 3,
            "tags": [
                "waves",
                "water",
                "cool",
                "dolphin",
                "splash"
            ],
            "usePreview": 1,
            "username": "ShadowFlare",
            "viewed": 2317
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define HIGH_QUALITY_NOISE\n/*\t\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifdef HIGH_QUALITY_NOISE\t\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n\treturn -1.0 + 2.0*mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n#else\n\treturn -1.0 + 2.0*textureLod( iChannel0, (p+f+0.5)/256.0, 0.0 ).x;\n#endif\t\n}\n\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  v = pa - ba*t;\n\treturn vec2( dot(v,v), t );\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//-----------------------------------------------------------------------------------\n\n#define NUMI 11\n#define NUMF 11.0\n\nvec3 fishPos;\nfloat fishTime;\nfloat isJump;\nfloat isJump2;\n\nvec2 anima( float ih, float t )\n{\n    float an1 = 0.9*(0.5+0.2*ih)*cos(5.0*ih - 3.0*t + 6.2831/4.0);\n    float an2 = 1.0*cos(3.5*ih - 1.0*t + 6.2831/4.0);\n    float an = mix( an1, an2, isJump );\n    float ro = 0.4*cos(4.0*ih - 1.0*t)*(1.0-0.5*isJump);\n\treturn vec2( an, ro );\n}\n\nvec3 anima2( void )\n{\n    vec3 a1 = vec3(0.0,        sin(3.0*fishTime+6.2831/4.0),0.0);\n    vec3 a2 = vec3(0.0,1.5+2.5*cos(1.0*fishTime),0.0);\n\tvec3 a = mix( a1, a2, isJump );\n\ta.y *= 0.5;\n\ta.x += 0.1*sin(0.1 - 1.0*fishTime)*(1.0-isJump);\n    return a;\n}\n\nvec2 sdDolphinCheap( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\t\t\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\t\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y/NUMF); mp=a+(b-a)*dis.y; }\n\t\t\n\t\ta = b;\n\t}\n\tfloat h = res.y;\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\n\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\n\treturn res;\n}\n\nvec3 ccd, ccp;\n\t\nvec2 sdDolphin( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\n\tvec3 p3 = a; vec3 d3=vec3(0.0);\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y/NUMF); mp=a+(b-a)*dis.y; ccd = b-a;}\n\t\t\n\t\tif( i==3 ) { p1=a; d1 = b-a; }\n\t\tif( i==4 ) { p3=a; d3 = b-a; }\n\t\tif( i==(NUMI-1) ) { p2=b; d2 = b-a; }\n\n\t\ta = b;\n\t}\n\tccp = mp;\n\t\n\tfloat h = res.y;\n\tfloat ra = 0.05 + h*(1.0-h)*(1.0-h)*2.7;\n\tra += 7.0*max(0.0,h-0.04)*exp(-30.0*max(0.0,h-0.04)) * smoothstep(-0.1, 0.1, p.y-mp.y);\n\tra -= 0.03*(smoothstep(0.0, 0.1, abs(p.y-mp.y)))*(1.0-smoothstep(0.0,0.1,h));\n\tra += 0.05*clamp(1.0-3.0*h,0.0,1.0);\n    ra += 0.035*(1.0-smoothstep( 0.0, 0.025, abs(h-0.1) ))* (1.0-smoothstep(0.0, 0.1, abs(p.y-mp.y)));\n\t\n\t// body\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\t//res.x = 0.75 * (res.x*3.0 - ra);\n\n    // fin\t\n\td3 = normalize(d3);\n\tfloat k = sqrt(1.0 - d3.y*d3.y);\n\tmat3 ms = mat3(  d3.z/k, -d3.x*d3.y/k, d3.x,\n\t\t\t\t        0.0,            k, d3.y,\n\t\t\t\t    -d3.x/k, -d3.y*d3.z/k, d3.z );\n\tvec3 ps = p - p3;\n\tps = ms*ps;\n\tps.z -= 0.1;\n    float d5 = length(ps.yz) - 0.9;\n\td5 = max( d5, -(length(ps.yz-vec2(0.6,0.0)) - 0.35) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,-0.5,0.5), vec3(0.0,0.5,0.5), 0.02 ) );\n\tres.x = smin( res.x, d5, 0.1 );\n\n\t\n#if 1\n    // fin\t\n\td1 = normalize(d1);\n\tk = sqrt(1.0 - d1.y*d1.y);\n\tms = mat3(  d1.z/k, -d1.x*d1.y/k, d1.x,\n\t\t\t\t   0.0,            k, d1.y,\n               -d1.x/k, -d1.y*d1.z/k, d1.z );\n\tps = p - p1;\n\tps = ms*ps;\n\tps.x = abs(ps.x);\n\tfloat l = ps.x;\n\tl=clamp( (l-0.4)/0.5, 0.0, 1.0 );\n\tl=4.0*l*(1.0-l);\n\tl *= 1.0-clamp(5.0*abs(ps.z+0.2),0.0,1.0);\n\tps.xyz += vec3(-0.2,0.36,-0.2);\n    d5 = length(ps.xz) - 0.8;\n\td5 = max( d5, -(length(ps.xz-vec2(0.2,0.4)) - 0.8) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,0.0,0.0), vec3(1.0,0.0,1.0), 0.015+0.05*l ) );\n\tres.x = smin( res.x, d5, 0.12 );\n#endif\n\t\n    // tail\t\n\td2 = normalize(d2);\n\tmat2 mf = mat2( d2.z, d2.y, -d2.y, d2.z );\n\tvec3 pf = p - p2 - d2*0.25;\n\tpf.yz = mf*pf.yz;\n    float d4 = length(pf.xz) - 0.6;\n\td4 = max( d4, -(length(pf.xz-vec2(0.0,0.8)) - 0.9) );\n\td4 = max( d4, udRoundBox( pf, vec3(1.0,0.005,1.0), 0.005 ) );\n\tres.x = smin( res.x, d4, 0.1 );\n\t\n\t\n\treturn res;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nvec3 sdWater( vec3 p )\n{\n\tvec2 q = 0.16*p.xz;\n    q.y *= 0.75;\n\n\tfloat f = 0.0;\n    f += 0.50000*abs(noise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*abs(noise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*abs(noise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*abs(noise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*abs(noise( q ));\n\t\n\tfloat sss = abs(sdDolphinCheap(p).x);\n\tfloat spla = exp(-4.0*sss);\n\tspla += 0.5*exp(-14.0*sss);\n\tspla *= mix(1.0,texture( iChannel0, 0.2*p.xz ).x,spla*spla);\n\tspla *= -0.85;\n\tspla *= isJump;\n\tspla *= mix( 1.0, smoothstep(0.0,0.5,p.z-fishPos.z-1.5), isJump2 );\n\n\treturn vec3( p.y-1.5+1.2*f + 0.1 + spla, f, sss );\n}\n\nfloat sdWaterCheap( vec3 p )\n{\n\tvec2 q = 0.16*p.xz;\n    q.y *= 0.75;\n\n\tfloat f = 0.0;\n    f += 0.50000*abs(noise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*abs(noise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*abs(noise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*abs(noise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*abs(noise( q ));\n\treturn f;\n}\n\nvec2 intersectDolphin( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        //if( h>precis && t<maxd )\n\t\tif( h<precis || t>maxd ) break;\n\t\t{\n        t += h;\n\t    vec2 res = sdDolphin( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2( t, l);\n}\n\nvec3 intersectWater( vec3 ro, in vec3 rd )\n{\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n\tfloat l = 0.0;\n\tfloat s = 0.0;\n\n\tfloat t = (2.5-ro.y)/rd.y; \n\tif( t<0.0 ) return vec3(-1.0);\n\n\tfor( int i=0; i<12; i++ )\n    {\n\t\tif( h<precis ) break;\n\t\t{\n        t += h;\n\t    vec3 res = sdWater( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\ts = res.z;\n\t\t}\n    }\n\n    return vec3( t, l, s );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormalFish( in vec3 pos )\n{\n#if 0    \n    const vec3 eps = vec3(0.08,0.0,0.0);\n\tfloat v = sdDolphin(pos).x;\n\treturn normalize( vec3(\n           sdDolphin(pos+eps.xyy).x - v,\n           sdDolphin(pos+eps.yxy).x - v,\n           sdDolphin(pos+eps.yyx).x - v ) );\n#else\n    #define ZERO (min(iFrame,0))\n\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdDolphin(pos+0.08*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calcNormalWater( in vec3 pos )\n{\n    const vec3 eps = vec3(0.025,0.0,0.0);\n    float v = sdWater(pos).x;\t\n\treturn normalize( vec3( sdWater(pos+eps.xyy).x - v,\n                            eps.x,\n                            sdWater(pos+eps.yyx).x - v ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<25; i++ )\n    {\n        h = sdDolphinCheap(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.05, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 lig = vec3(0.86,0.15,0.48);\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, float glossy, float glossy2, float shadows, in vec3 col, float occ )\n{\n\tvec3 ref = reflect(rd,nor);\n\t\n    // lighting\n    float sky = clamp(nor.y,0.0,1.0);\n\tfloat bou = clamp(-nor.y,0.0,1.0);\n    float dif = max(dot(nor,lig),0.0);\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\n    float sha = 1.0-shadows; if( (shadows*dif)>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n    float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n    float spe = max( 0.0, pow( clamp( dot(lig,ref), 0.0, 1.0), 0.01+glossy ) ) * glossy;\n    float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n\t\t\n    // lights\n    vec3 brdf = vec3(0.0);\n\tbrdf += 8.0*dif*vec3(1.80,1.35,0.90)*vec3(sha,sha*0.5+0.5*sha*sha,sha*sha);\n    brdf += 1.0*sky*vec3(0.20,0.40,0.55)*occ;\n    brdf += 1.0*bac*vec3(0.40,0.60,0.70)*occ;\n    brdf += 1.0*bou*vec3(0.10,0.20,0.25);\n    brdf += 1.0*sss*vec3(0.40,0.40,0.40)*(0.3+0.7*dif*sha)*glossy*occ;\n    brdf += 0.5*spe*vec3(1.3,1.0,0.8)*sha*(0.3+0.7*fre)*occ*glossy;\n    brdf += glossy*0.3*vec3(0.8,0.9,1.0)*occ*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));//*smoothstep(-0.1,0.0,dif);\n\t\n    col = col*brdf;\n\n    //col += (0.5 + 1.5*fre)*occ*glossy2*glossy2*10.0*vec3(1.0,0.9,0.8)*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));//*smoothstep(-0.1,0.0,dif);\n    col += 0.25*glossy*pow(spe/(0.01+glossy),8.0)*vec3(1.3,1.0,0.8)*sha*(0.3+0.7*fre)*occ;\n\t\n\treturn col;\n}\n\nvec3 normalMap( in vec2 pos )\n{\n\tpos *= 6.0;\n\tpos.y *= 0.375;\n\t\n\tfloat v = texture( iChannel2, 0.015*pos ).x;\n\tvec3 nor = vec3( texture( iChannel2, 0.015*pos+vec2(1.0/1024.0,0.0)).x - v,\n\t                 1.0/16.0,\n\t                 texture( iChannel2, 0.015*pos+vec2(0.0,1.0/1024.0)).x - v );\n\tnor.xz *= -1.0;\n\treturn normalize( nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n\t\n\tfishTime = 0.6 + 2.0*iTime - 20.0;\n\t\n\tfishPos = vec3( 0.0, 0.0-0.2, -1.1*fishTime );\n\t\n\tisJump  = 0.5 + 0.5*cos(     -0.4+0.5*fishTime);\n\tisJump2 = 0.5 + 0.5*cos( 0.6+0.5*fishTime);\n\tfloat isJump3 = 0.5 + 0.5*cos(-1.4+0.5*fishTime);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n\tfloat an = 1.2 + 0.1*iTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = vec3(fishPos.x,0.8,fishPos.z) - vec3(0.0,0.0,-2.0);\n\tvec3 ro = ta + vec3(4.0*sin(an),3.1,4.0*cos(an));\n\n    // shake\n\tro += 0.05*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.05*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    //vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 uu = normalize( vec3(-ww.z,0.0,ww.x) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww*(1.0+0.7*smoothstep(-0.4,0.4,sin(0.34*iTime))) );\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tfloat t = 1000.0;\n\t\n\tvec3 col = vec3(0.0);\n\tvec3 bgcol = vec3(0.6,0.7,0.8) - .2*clamp(rd.y,0.0,1.0);\n\n    // quick step till y=3 bounding plane\n\tfloat pt = (3.0-ro.y)/rd.y;\n\tif( rd.y<0.0 && pt>0.0 ) ro=ro+rd*pt;\n\n\t// raymarch\n    vec2 tmat1 = intersectDolphin(ro,rd);\n\tvec3 posy = vec3(-100000.0);\n    if( tmat1.x>0.0 )\n    {\n\t\tvec2 tmat = tmat1;\n\t\tt = tmat.x;\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalFish(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\t\tvec3 fpos = pos - fishPos;\n\n\t\tvec3 auu = normalize( vec3(-ccd.z,0.0,ccd.x) );\n\t\tvec3 avv = normalize( cross(ccd,auu) );\n\t\tvec3 ppp = vec3( dot(fpos-ccp,auu),  dot(fpos-ccp,avv),  tmat.y );\n\t\tvec2 uv = vec2( 1.0*atan(ppp.x,ppp.y)/3.1416, 4.0*ppp.z );\n\n\t\tvec3 bnor = -1.0+2.0*texture(iChannel0,uv).xyz;\n        nor += 0.01*bnor;\n\n\t\tvec3 te = texture( iChannel2, uv ).xyz;\n\t\tvec4 mate;\n\t\tmate.w = 17.0;\n        mate.xyz = mix( vec3(0.3,0.35,0.4), vec3(0.8,0.85,0.9)*0.9, 0.8*smoothstep(-0.05,0.05,ppp.y) );;\n\n        mate.xyz *= 1.0 + 0.3*te;\n\t\tmate.xyz *= smoothstep( 0.0, 0.06, distance(vec3(abs(ppp.x),ppp.yz)*vec3(1.0,1.0,4.0),vec3(0.35,0.0,0.4)) );\n\t\tmate.xyz *= 1.0 - 0.75*(1.0-smoothstep( 0.0, 0.02, abs(ppp.y) ))*(1.0-smoothstep( 0.07, 0.11, tmat.y ));\n\t\t\n\t\tmate.xyz *= 0.1*0.23;\n\t\t\n        mate.w *= (0.7+0.3*te.x)*smoothstep( 0.0, 0.01, pos.y-sdWaterCheap( pos ) );\n\t\t\t\n        // surface-light interacion\n        col = doLighting( pos, nor, rd, mate.w, 0.0, 0.0, mate.xyz, 1.0 );\n\t\n\t\tposy = pos;\n\t}\n\n\t\n    vec3 tmat2 = intersectWater(ro,rd);\n\tvec3 col2 = vec3(0.0);\n\tif( tmat2.x>0.0 && (tmat1.x<0.0 || tmat2.x<tmat1.x) )\n\t{\n\t\tvec3 tmat = tmat2;\n\n        t = tmat.x;\n\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalWater(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        vec4 mate = vec4(0.4,0.4,0.4,0.0);\n\n\t\tvec3 bnor = normalMap(pos.xz);\n        nor = normalize( nor + 0.2*bnor );\n\n        float fre = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 2.0 );\n\n\t\tmate.xyz = 0.3*mix( vec3(0.0,0.03,0.07), 0.1*vec3(0.0,0.3,0.4), fre );\n\t\tmate.w = fre;\t\n\n        float foam = 1.0-smoothstep( 0.1, 0.65, tmat.y );\n        foam *= smoothstep( 0.0, 0.3, abs(nor.x) );\n\t\t\n        foam *= clamp(1.0-texture( iChannel2, vec2(1.0,0.75)*0.45*pos.xz ).x*2.0,0.0,1.0);\n        mate = mix( mate, vec4(0.7,0.7,0.7,0.0), 0.2*foam );\n\n\t\tfloat al = clamp( 0.5 + 0.2*(pos.y - posy.y), 0.0, 1.0 );\n\t\t\n\t\t//foam = exp( -3.0*abs(sdFishCheap(pos).x) );\n\t\tfoam = exp( -3.0*abs(tmat.z) );\n\t\t\n\t\tfoam *= texture( iChannel3, pos.zx ).x;\n\t\tfoam = clamp( foam*3.0, 0.0, 1.0 );\n\t\tfoam *= isJump;\n\t\tfoam *= mix( 1.0, smoothstep(0.0,0.5,pos.z-fishPos.z-1.5), isJump2 );\n\t\tmate.xyz = mix( mate.xyz, vec3(0.9,0.95,1.0)*0.3, foam*foam );\n\t\tcol = mix( col, vec3(0.9,0.95,1.0)*1.2, foam );\n\t\tal *= 1.0-foam;\n\n\t\tfloat occ = clamp(3.5*sdDolphinCheap(pos+vec3(0.0,0.4,0.0)).x * sdDolphinCheap(pos+vec3(0.0,1.0,0.0)).x,0.0,1.0);\n        occ = mix(1.0,occ,isJump);\n        occ = 0.35 + 0.65*occ;\n\t\tmate.xyz *= occ;\n        col *= occ;\n\n\t\tmate.xyz = doLighting( pos, nor, rd, mate.w*10.0, mate.w*0.5, 1.0, mate.xyz, occ );\n\t\t\n        // caustics\n        float cc  = 0.65*texture( iChannel0, 2.5*0.02*posy.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\n        cc += 0.35*texture( iChannel0, 1.8*0.04*posy.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\n        cc = 0.6*(1.0-smoothstep( 0.0, 0.05, abs(cc-0.5))) + \n\t         0.4*(1.0-smoothstep( 0.0, 0.20, abs(cc-0.5)));\n        col *= 1.0 + 0.8*cc;\n\t\t\n\t\tcol = mix( col, mate.xyz, al );\n\t}\n\t\t\n\t\n\tfloat sun = pow( max(0.0,dot( lig, rd )),8.0 );\n\tcol += vec3(0.8,0.5,0.1)*sun*0.3;\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n    // color\n\tcol = col*vec3(0.9,0.85,0.8) + 0.4*col*col*(3.0-2.0*col);\n\t\t\n    // vigneting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    // fade\t\n\tcol *= smoothstep( 0.0, 1.0, iTime );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n*/\n#ifndef NUMI\n    #define NUMI 11\n    #define NUMF 11.0\n    vec3 fishPos;\n    float fishTime;\n    float isJump;\n    float isJump2;\n#endif\nvec3 GetSpectrum( float x, const in vec3 vBrightness, const in vec3 vPeak, const in vec3 vRange )\n{\n\tvec3 vTemp = 1.0 - abs((vPeak - x) * vRange);\n\tvTemp = clamp(vTemp, 0.0, 1.0);\n\tvec3 vTemp2 = vTemp  * vTemp;\t\n\treturn (3.0 * vTemp2 - 2.0 * vTemp * vTemp2) * vBrightness;\t\n}\n\nvec4 GetRainbowRGBA( float theta )\n{\n\tvec4 vResult = vec4(0.0);\n\n\t// red0 = 137.7 deg\n\t// violet0 = 139.6 deg\n\t// red1 = 129.5 deg\n\t// violet1 = 126.1 deg\n\t\n\tconst vec3 vPeak0 = vec3(180.0 - 137.7, 180.0 - (137.7 + 139.6)*0.5, 180.0 - 139.6);\n\tconst vec3 vRange0 = 1.0 / vec3(vPeak0.b - vPeak0.r);\n\tconst vec3 vBrightness0 = vec3(1.0);\n\n\tvResult.xyz += GetSpectrum(theta, vBrightness0, vPeak0, vRange0);\t\n\n\tconst vec3 vPeak1 = vec3(180.0 - 129.5, 180.0 - (129.5 + 126.1) * 0.5, 180.0 - 126.1);\n\tconst vec3 vRange1 = 1.0 / vec3(vPeak1.b - vPeak1.r);\n\tconst vec3 vBrightness1 = vec3(0.25);\n\t\n\tvResult.xyz += GetSpectrum(theta, vBrightness1, vPeak1, vRange1);\t\n\t\n\tfloat aFactor = max(smoothstep(vPeak0.r + 1.0, vPeak0.b - 1.0, theta), smoothstep(vPeak1.r - 1.0, vPeak1.b + 1.0, theta) * 0.2);\n\tvResult.a = 1.0 - aFactor;\t\n\t\n\treturn vResult;\n}\nvec3 vSunColour = vec3(1.0, 0.9, 0.8) * 5.0;\n\nconst vec3 vSkyBase = vec3(0.05, 0.2, 1.0);\n\nvec3 vSkyColourA = vSkyBase * 1.5;\nvec3 vSkyColourB = vSkyBase * 0.5;\n\nconst vec3 vAmbientLight = (vSkyBase + vec3(0.5));\nvec3 vSunDir = normalize(vec3(-0.86,-0.15,0.48));\nfloat RainbowShadow(const in vec3 p)\n{\n\tfloat f = -p.x * 1.1 + p.y - 1.5 - p.z;\n\tfloat fSpread = 0.05;\n\treturn clamp(f * fSpread + 0.1, 0.0, 1.0);\n}\nfloat sqrt1 (in float num) {\n \treturn sqrt(abs(num))*sign(num);  \n}\nvec4 ApplyAtmosphere( const in vec3 vRayOrigin, const in vec3 vRayDir, in vec4 vResult )\n{\n\tvec3 vCentre = vec3(10.0, 10.0, 10.0);\n\t\n\tvec3 vOffset = vCentre - vRayOrigin;\n\tfloat d = dot(vRayDir, vOffset);\n\tvec3 vClosest = vRayOrigin + vRayDir * d;\n\tfloat l = length(vClosest - vCentre);\n\t\n\t// fog\n\tvec3 cFogColour = vec3(0.0);\n\t//vResult.xyz = mix(vResult.xyz, cFogColour, 1.0 - exp2(vResult.w * -0.001));\n\t\n\t// mist and rainbows\n\tfloat r = 15.0;\n\tif( abs(l) < r )\n\t{\n\t\t\n\t\tfloat hcl = sqrt1(r * r - l * l);\n\t\t\n\t\tfloat t0 = d - hcl;\n\t\t\n\t\tfloat dt = vResult.w - t0;\n\t\tfloat fAmount = 0.0;\n\t\tif(dt > 0.0)\n\t\t{\n\t\t\tfloat f = (r - l)/r;\n\t\t\tf = f * f * f;\n\t\t\tfloat fOpticalDepth = dt * f * 0.1;\n\t\t\tfloat fAmount = 1.0 - exp2(-fOpticalDepth);\n\t\t\t\n\t\t\tvec3 cMistColour = vAmbientLight * 0.7 + length(vAmbientLight) * vec3(0.3);\n\t\t\tfloat fYPos = vRayOrigin.y + vRayDir.y * vResult.w;\n\t\t\t//cMistColour *= clamp((fYPos + 2.5) * 0.25, 0.0, 1.0) * 0.5 + 0.5;\n\t\t\tvResult.xyz = mix(vResult.xyz, cMistColour, fAmount);\n\t\t\t\n\t\t\tfloat fCameraShadow = RainbowShadow(vRayOrigin) * 0.75 + 0.5;\n\t\t\t\n\t\t\tfloat fRainbowAmount = clamp(fAmount * fCameraShadow * 1.0, 0.0, 1.0);\n\t\t\tfloat fRainbowDarkenAmount = clamp(fAmount * fCameraShadow * 1.5, 0.0, 1.0);\n\t\t\t\n\t\t\tfloat fDp = dot(vSunDir, vRayDir);\n\t\t\tvec4 vRainbow = GetRainbowRGBA(degrees(acos(fDp)) + 0.5);\n\t\t\tvResult.xyz *= 1.0 - vRainbow.a * fRainbowDarkenAmount;\n\t\t\tvResult.xyz += vRainbow.xyz * fRainbowAmount;\n\t\t\t\n\t\t}\n\t}\t\t\t\n\n\treturn vResult;\t\n}\nvec3 ApplyTonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\t/*/*\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 o;\n    o.r = v.id;\n    o.g = clamp(floor(v.sunlight), 0., 15.) + 16. * clamp(floor(v.torchlight), 0., 15.);\n    o.b = v.hue;\n    o.a = 1.;\n    return o;\n}\n\nstruct data {\n \tvec4 col;\n    float water;\n   \tfloat cc;\n    float posy;\n    float t;\n};\nvec4 encodeColor (data d) {\n \tvec4 o;\n    o.r = clamp(floor(d.col.r*63.), 0., 63.)+64.*clamp(floor((1.0-d.water)*63.), 0., 63.);\n    o.g = clamp(floor(d.col.g*63.), 0., 63.)+64.*clamp(floor((d.cc)*63.), 0., 63.);\n    o.b = clamp(floor(d.col.b*63.), 0., 63.)+64.*clamp(floor((d.posy)*63.), 0., 63.);\n    o.a = clamp(floor(d.col.a*63.), 0., 63.)+64.*clamp(floor((d.t)*63.), 0., 63.);\n    return o;\n}*/\nstruct data {\n \tvec4 col;\n    float water;\n   \tfloat cc;\n    float posy;\n    float t;\n};\n    data decodeColor (vec2 uv) {\n     \t/*\n\t\to.sunlight = floor(mod(textel.g, 16.));\n    \to.torchlight = floor(mod(textel.g / 16., 16.));\n\t\t*/\n        float bit1 = bit-1.0;\n        data d;\n        vec4 col;\n        vec4 _col = texture(iChannel1, uv);\n        col.r = floor(mod(_col.r, bit))/bit1;\n        col.g = floor(mod(_col.g, bit))/bit1;\n        col.b = floor(mod(_col.b, bit))/bit1;\n        col.a = floor(mod(_col.a, bit))/bit1;\n        d.col = col;\n        d.water = floor(mod(_col.r/bit, bit))/bit1;\n        d.cc = floor(mod(_col.g/bit, bit))/bit1;\n        d.posy = floor(mod(_col.b/bit, bit))/bit1;\n        d.t = floor(mod(_col.a/bit, bit))/bit1;\n        return d;\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord/iResolution.xy;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n\t\n\tfishTime = 0.6 + 2.0*iTime - 20.0;\n\t\n\tfishPos = vec3( 0.0, 0.0-0.2, -1.1*fishTime );\n\t\n\tisJump  = 0.5 + 0.5*cos(     -0.4+0.5*fishTime);\n\tisJump2 = 0.5 + 0.5*cos( 0.6+0.5*fishTime);\n\tfloat isJump3 = 0.5 + 0.5*cos(-1.4+0.5*fishTime);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n\tfloat an = 1.2 + 0.1*iTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = vec3(fishPos.x,0.8,fishPos.z) - vec3(0.0,0.0,-2.0);\n\tvec3 ro = ta + vec3(4.0*sin(an),3.1,4.0*cos(an));\n\n    // shake\n\tro += 0.05*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.05*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    //vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 uu = normalize( vec3(-ww.z,0.0,ww.x) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww*(1.0+0.7*smoothstep(-0.4,0.4,sin(0.34*iTime))) );\n\n    \n    \n    \n    \n    //-----------------------------------------------------\n    vec3 col2 = texture(iChannel0, uv).rgb;\n    data _d = decodeColor(uv);\n    vec4 col1 = _d.col;\n    vec4 data = vec4(_d.water, _d.cc, _d.posy, _d.t);\n    //vec4 col1 = texture(iChannel1, uv);\n    //vec4 data = texture(iChannel2, uv);\n    vec3 col = mix(col2, col1.rgb, col1.a);\n    float cc; //= data.g;\n    vec2 posy = data.ba;\n    float dist = data.a;//texture(iChannel2, uv).a;\n    if (data.r == 0.0) {\n        /*cc  = 0.65*texture( iChannel0, 2.5*0.02*posy + 0.007*iTime*vec2( 1.0, 0.0) ).x;\n            cc += 0.35*texture( iChannel0, 1.8*0.04*posy + 0.011*iTime*vec2( 0.0, 1.0) ).x;\n            cc = 0.6*(1.0-smoothstep( 0.0, 0.05, abs(cc-0.5))) + \n                 0.4*(1.0-smoothstep( 0.0, 0.20, abs(cc-0.5)));\n\t*/\n        float cc = data.g;\n        col = mix(col, col*dot(col1.rgb, col), data.r*cc);\n        \n        //col = mix(col, col*(1.0 + 0.8*cc), (1.0-data.r)*0.1);\n    }\n    col = ApplyAtmosphere(ro, rd, vec4(col, dist)).rgb;\n    //col = ApplyTonemap(col);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec3 si = sin(ang);\n    vec3 co = cos(ang);\n\tvec2 a1 = vec2(si.x, co.x);\n    vec2 a2 = vec2(si.y,co.y);\n    vec2 a3 = vec2(si.z,co.z);\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n \t\n\n#define SC (25.0)\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float dist, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = 4.6;\n    float fogAmount = 1.0 - exp( -pow(abs(b*(dist/20.0)), 1.5));\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.4), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,4.0) );\n    fogColor += vec3(1.0);\n    return mix( rgb, fogColor, fogAmount );\n}\n#define CLOUDSCALE (500./(64.*0.03))\nfloat noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat cloudMap( const in vec3 p, const in float ani, float den) {\n\tvec3 r = p/CLOUDSCALE;\n\n\t//float den = -1.8+cos(r.y*5.-4.3);\n\t\t\n\tfloat f;\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\n    f += 0.03125*noise( q );\n\t\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\n}\nfloat hash( in float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n#define time (iTime+285.)\nfloat getAtten (in vec3 dist) {\n \treturn max(1.0 - dot(dist,dist) * 0.001, 0.0);   \n}\nvec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\n    // dithering\t\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\n\t\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tfor( int i=0; i<64; i++ ) {\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tfloat a = cloudMap( pos, ani, getAtten(pos-ro));\n\n        // lighting\t\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + light*0.15*CLOUDSCALE, ani, getAtten(pos-ro))), 0., 0.5);\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\n\t\t// fog\t\t\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n        // advance ray with LOD\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\n\t}\n\n    // blend with background\t\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\n\t\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\nvec3 bgColor( const in vec3 rd ) {\n\tfloat sun = clamp( dot(light,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\treturn col;\n}\n\nvec3 fishPos;\nfloat fishTime;\nfloat isJump;\nfloat isJump2;\nvec2 anima( float ih, float t )\n{\n    float an1 = 0.9*(0.5+0.2*ih)*cos(5.0*ih - 3.0*t + 6.2831/4.0);\n    float an2 = 1.0*cos(3.5*ih - 1.0*t + 6.2831/4.0);\n    float an = mix( an1, an2, isJump );\n    float ro = 0.4*cos(4.0*ih - 1.0*t)*(1.0-0.5*isJump);\n\treturn vec2( an, ro );\n}\n#define NUMI 11\n#define NUMF 11.0\nvec3 anima2( void )\n{\n    vec3 a1 = vec3(0.0,        sin(3.0*fishTime+6.2831/4.0),0.0);\n    vec3 a2 = vec3(0.0,1.5+2.5*cos(1.0*fishTime),0.0);\n\tvec3 a = mix( a1, a2, isJump );\n\ta.y *= 0.5;\n\ta.x += 0.1*sin(0.1 - 1.0*fishTime)*(1.0-isJump);\n    return a;\n}\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  v = pa - ba*t;\n\treturn vec2( dot(v,v), t );\n}\nvec2 sdDolphinCheap( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\t\t\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\t\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y/NUMF); mp=a+(b-a)*dis.y; }\n\t\t\n\t\ta = b;\n\t}\n\tfloat h = res.y;\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\n\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\n\treturn res;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 ccd, ccp;\nfloat sqrt1 (in float num) {\n \treturn sqrt(abs(num))*sign(num);   \n}\nvec2 sdDolphin( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\n\tvec3 p3 = a; vec3 d3=vec3(0.0);\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y/NUMF); mp=a+(b-a)*dis.y; ccd = b-a;}\n\t\t\n\t\tif( i==3 ) { p1=a; d1 = b-a; }\n\t\tif( i==4 ) { p3=a; d3 = b-a; }\n\t\tif( i==(NUMI-1) ) { p2=b; d2 = b-a; }\n\n\t\ta = b;\n\t}\n\tccp = mp;\n\t\n\tfloat h = res.y;\n\tfloat ra = 0.05 + h*(1.0-h)*(1.0-h)*2.7;\n\tra += 7.0*max(0.0,h-0.04)*exp(-30.0*max(0.0,h-0.04)) * smoothstep(-0.1, 0.1, p.y-mp.y);\n\tra -= 0.03*(smoothstep(0.0, 0.1, abs(p.y-mp.y)))*(1.0-smoothstep(0.0,0.1,h));\n\tra += 0.05*clamp(1.0-3.0*h,0.0,1.0);\n    ra += 0.035*(1.0-smoothstep( 0.0, 0.025, abs(h-0.1) ))* (1.0-smoothstep(0.0, 0.1, abs(p.y-mp.y)));\n\t\n\t// body\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\t//res.x = 0.75 * (res.x*3.0 - ra);\n\n    // fin\t\n\td3 = normalize(d3);\n\tfloat k = sqrt1(1.0 - d3.y*d3.y);\n\tmat3 ms = mat3(  d3.z/k, -d3.x*d3.y/k, d3.x,\n\t\t\t\t        0.0,            k, d3.y,\n\t\t\t\t    -d3.x/k, -d3.y*d3.z/k, d3.z );\n\tvec3 ps = p - p3;\n\tps = ms*ps;\n\tps.z -= 0.1;\n    float d5 = length(ps.yz) - 0.9;\n    //d5 = smin( d5, (length(ps.yz-vec2(0.6,-0.3)) - 0.03), 0.4);\n\td5 = max( d5, -(length(ps.yz-vec2(0.6,0.0)) - 0.35) );\n    \n\td5 = max( d5, udRoundBox( ps+vec3(0.0,-0.5,0.5), vec3(0.0,0.5,0.5), 0.02 ) );\n\tres.x = smin( res.x, d5, 0.1 );\n\n\t\n#if 1\n    // fin\t\n\td1 = normalize(d1);\n\tk = sqrt1(1.0 - d1.y*d1.y);\n\tms = mat3(  d1.z/k, -d1.x*d1.y/k, d1.x,\n\t\t\t\t   0.0,            k, d1.y,\n               -d1.x/k, -d1.y*d1.z/k, d1.z );\n\tps = p - p1;\n\tps = ms*ps;\n\tps.x = abs(ps.x);\n\tfloat l = ps.x;\n\tl=clamp( (l-0.4)/0.5, 0.0, 1.0 );\n\tl=4.0*l*(1.0-l);\n\tl *= 1.0-clamp(5.0*abs(ps.z+0.2),0.0,1.0);\n\tps.xyz += vec3(-0.2,0.36,-0.2);\n    d5 = length(ps.xz) - 0.8;\n\td5 = max( d5, -(length(ps.xz-vec2(0.2,0.4)) - 0.8) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,0.0,0.0), vec3(1.0,0.0,1.0), 0.015+0.05*l ) );\n\tres.x = smin( res.x, d5, 0.12 );\n#endif\n\t\n    // tail\t\n\td2 = normalize(d2);\n\tmat2 mf = mat2( d2.z, d2.y, -d2.y, d2.z );\n\tvec3 pf = p - p2 - d2*0.25;\n\tpf.yz = mf*pf.yz;\n    float d4 = length(pf.xz) - 0.6;\n\td4 = max( d4, -(length(pf.xz-vec2(0.0,0.8)) - 0.9) );\n\td4 = max( d4, udRoundBox( pf, vec3(1.0,0.005,1.0), 0.005 ) );\n\tres.x = smin( res.x, d4, 0.1 );\n\t\n\t\n\treturn res;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<25; i++ )\n    {\n        h = sdDolphin(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.05, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist, vec3 rd) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = getAtten(dist);\n    float d = map_detailed(p);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    color = color+(color*softshadow(p+0.01*n, n, 0.0005, 320.0 )*0.5);\n    color += vec3(specular(n,l,eye,60.0));\n    //color = vec3(softshadow(eye+0.01*n, light, 0.0005, 32.0 ));\n    \n    //color *= softshadow(p, -rd, d, 0.1);\n    //float d = map_detailed(p);\n    color = mix(color, raymarchClouds(eye, rd, color, color*0.5+0.5*bgColor(rd), 150., 5000., time), 0.18*atten);\n    float le = normalize(length(p-eye));\n    color = applyFog(color, d, rd, l);\n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    /*float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    */\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    fishTime = 0.6 + 2.0*iTime - 20.0;\n\t\n\tfishPos = vec3( 0.0, 0.0-0.2, -1.1*fishTime );\n\t\n\tisJump  = 0.5 + 0.5*cos(     -0.4+0.5*fishTime);\n\tisJump2 = 0.5 + 0.5*cos( 0.6+0.5*fishTime);\n\tfloat isJump3 = 0.5 + 0.5*cos(-1.4+0.5*fishTime);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n\tfloat an = 1.2 + 0.1*iTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = vec3(fishPos.x,0.8,fishPos.z) - vec3(0.0,0.0,-2.0);\n\tvec3 ori = ta + vec3(4.0*sin(an),3.1,4.0*cos(an));\n\n    // shake\n\tori += 0.05*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.05*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    // camera matrix\n    vec3 ww = normalize( ta - ori );\n    //vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 uu = normalize( vec3(-ww.z,0.0,ww.x) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t// create view ray\n\tvec3 dir = normalize( uv.x*uu + uv.y*vv + 2.0*ww*(1.0+0.7*smoothstep(-0.4,0.4,sin(0.34*iTime))) );\n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist, dir),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n    color = pow(color, vec3(1.8));    \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define HIGH_QUALITY_NOISE\n\t\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifdef HIGH_QUALITY_NOISE\t\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n\treturn -1.0 + 2.0*mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n#else\n\treturn -1.0 + 2.0*textureLod( iChannel0, (p+f+0.5)/256.0, 0.0 ).x;\n#endif\t\n}\n\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\tvec3  v = pa - ba*t;\n\treturn vec2( dot(v,v), t );\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//-----------------------------------------------------------------------------------\n#ifndef NUMI\n    #define NUMI 11\n    #define NUMF 11.0\n    vec3 fishPos;\n    float fishTime;\n    float isJump;\n    float isJump2;\n#endif\n\nvec2 anima( float ih, float t )\n{\n    float an1 = 0.9*(0.5+0.2*ih)*cos(5.0*ih - 3.0*t + 6.2831/4.0);\n    float an2 = 1.0*cos(3.5*ih - 1.0*t + 6.2831/4.0);\n    float an = mix( an1, an2, isJump );\n    float ro = 0.4*cos(4.0*ih - 1.0*t)*(1.0-0.5*isJump);\n\treturn vec2( an, ro );\n}\n\nvec3 anima2( void )\n{\n    vec3 a1 = vec3(0.0,        sin(3.0*fishTime+6.2831/4.0),0.0);\n    vec3 a2 = vec3(0.0,1.5+2.5*cos(1.0*fishTime),0.0);\n\tvec3 a = mix( a1, a2, isJump );\n\ta.y *= 0.5;\n\ta.x += 0.1*sin(0.1 - 1.0*fishTime)*(1.0-isJump);\n    return a;\n}\n\nvec2 sdDolphinCheap( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\t\t\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\t\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y/NUMF); mp=a+(b-a)*dis.y; }\n\t\t\n\t\ta = b;\n\t}\n\tfloat h = res.y;\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\n\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\n\treturn res;\n}\n\nvec3 ccd, ccp;\nfloat sqrt1 (in float num) {\n \treturn sqrt(abs(num))*sign(num);   \n}\t\nvec2 sdDolphin( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\n\tvec3 p3 = a; vec3 d3=vec3(0.0);\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y/NUMF); mp=a+(b-a)*dis.y; ccd = b-a;}\n\t\t\n\t\tif( i==3 ) { p1=a; d1 = b-a; }\n\t\tif( i==4 ) { p3=a; d3 = b-a; }\n\t\tif( i==(NUMI-1) ) { p2=b; d2 = b-a; }\n\n\t\ta = b;\n\t}\n\tccp = mp;\n\t\n\tfloat h = res.y;\n\tfloat ra = 0.05 + h*(1.0-h)*(1.0-h)*2.7;\n\tra += 7.0*max(0.0,h-0.04)*exp(-30.0*max(0.0,h-0.04)) * smoothstep(-0.1, 0.1, p.y-mp.y);\n\tra -= 0.03*(smoothstep(0.0, 0.1, abs(p.y-mp.y)))*(1.0-smoothstep(0.0,0.1,h));\n\tra += 0.05*clamp(1.0-3.0*h,0.0,1.0);\n    ra += 0.035*(1.0-smoothstep( 0.0, 0.025, abs(h-0.1) ))* (1.0-smoothstep(0.0, 0.1, abs(p.y-mp.y)));\n\t\n\t// body\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\t//res.x = 0.75 * (res.x*3.0 - ra);\n\n    // fin\t\n\td3 = normalize(d3);\n\tfloat k = sqrt1(1.0 - d3.y*d3.y);\n\tmat3 ms = mat3(  d3.z/k, -d3.x*d3.y/k, d3.x,\n\t\t\t\t        0.0,            k, d3.y,\n\t\t\t\t    -d3.x/k, -d3.y*d3.z/k, d3.z );\n\tvec3 ps = p - p3;\n\tps = ms*ps;\n\tps.z -= 0.1;\n    float d5 = length(ps.yz) - 0.9;\n    //d5 = smin( d5, (length(ps.yz-vec2(0.6,-0.3)) - 0.03), 0.4);\n\td5 = max( d5, -(length(ps.yz-vec2(0.6,0.0)) - 0.35) );\n    \n\td5 = max( d5, udRoundBox( ps+vec3(0.0,-0.5,0.5), vec3(0.0,0.5,0.5), 0.02 ) );\n\tres.x = smin( res.x, d5, 0.1 );\n\n\t\n#if 1\n    // fin\t\n\td1 = normalize(d1);\n\tk = sqrt1(1.0 - d1.y*d1.y);\n\tms = mat3(  d1.z/k, -d1.x*d1.y/k, d1.x,\n\t\t\t\t   0.0,            k, d1.y,\n               -d1.x/k, -d1.y*d1.z/k, d1.z );\n\tps = p - p1;\n\tps = ms*ps;\n\tps.x = abs(ps.x);\n\tfloat l = ps.x;\n\tl=clamp( (l-0.4)/0.5, 0.0, 1.0 );\n\tl=4.0*l*(1.0-l);\n\tl *= 1.0-clamp(5.0*abs(ps.z+0.2),0.0,1.0);\n\tps.xyz += vec3(-0.2,0.36,-0.2);\n    d5 = length(ps.xz) - 0.8;\n\td5 = max( d5, -(length(ps.xz-vec2(0.2,0.4)) - 0.8) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,0.0,0.0), vec3(1.0,0.0,1.0), 0.015+0.05*l ) );\n\tres.x = smin( res.x, d5, 0.12 );\n#endif\n\t\n    // tail\t\n\td2 = normalize(d2);\n\tmat2 mf = mat2( d2.z, d2.y, -d2.y, d2.z );\n\tvec3 pf = p - p2 - d2*0.25;\n\tpf.yz = mf*pf.yz;\n    float d4 = length(pf.xz) - 0.6;\n\td4 = max( d4, -(length(pf.xz-vec2(0.0,0.8)) - 0.9) );\n\td4 = max( d4, udRoundBox( pf, vec3(1.0,0.005,1.0), 0.005 ) );\n\tres.x = smin( res.x, d4, 0.1 );\n\t\n\t\n\treturn res;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nvec3 sdWater( vec3 p )\n{\n\tvec2 q = 0.16*p.xz;\n    q.y *= 0.75;\n\n\tfloat f = 0.0;\n    f += 0.50000*abs(noise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*abs(noise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*abs(noise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*abs(noise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*abs(noise( q ));\n\t\n\tfloat sss = abs(sdDolphin(p).x);\n\tfloat spla = exp(-4.0*sss);\n\tspla += 0.5*exp(-14.0*sss);\n\tspla *= mix(1.0,texture( iChannel0, 0.2*p.xz ).x,spla*spla);\n\tspla *= -0.85;\n\tspla *= isJump;\n\tspla *= mix( 1.0, smoothstep(0.0,0.5,p.z-fishPos.z-1.5), isJump2 );\n\n\treturn vec3( p.y-1.5+1.2*f + 0.1 + spla, f, sss );\n}\n\nfloat sdWaterCheap( vec3 p )\n{\n\tvec2 q = 0.16*p.xz;\n    q.y *= 0.75;\n\n\tfloat f = 0.0;\n    f += 0.50000*abs(noise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*abs(noise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*abs(noise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*abs(noise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*abs(noise( q ));\n\treturn f;\n}\n\nvec2 intersectDolphin( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        //if( h>precis && t<maxd )\n\t\tif( h<precis || t>maxd ) break;\n\t\t{\n        t += h;\n\t    vec2 res = sdDolphin( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2( t, l);\n}\n\nvec3 intersectWater( vec3 ro, in vec3 rd )\n{\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n\tfloat l = 0.0;\n\tfloat s = 0.0;\n\n\tfloat t = (2.5-ro.y)/rd.y; \n\tif( t<0.0 ) return vec3(-1.0);\n\n\tfor( int i=0; i<12; i++ )\n    {\n\t\tif( h<precis ) break;\n\t\t{\n        t += h;\n\t    vec3 res = sdWater( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\ts = res.z;\n\t\t}\n    }\n\n    return vec3( t, l, s );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormalFish( in vec3 pos )\n{\n#if 0    \n    const vec3 eps = vec3(0.08,0.0,0.0);\n\tfloat v = sdDolphin(pos).x;\n\treturn normalize( vec3(\n           sdDolphin(pos+eps.xyy).x - v,\n           sdDolphin(pos+eps.yxy).x - v,\n           sdDolphin(pos+eps.yyx).x - v ) );\n#else\n    #define ZERO (min(iFrame,0))\n\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdDolphin(pos+0.08*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calcNormalWater( in vec3 pos )\n{\n    const vec3 eps = vec3(0.025,0.0,0.0);\n    float v = sdWater(pos).x;\t\n\treturn normalize( vec3( sdWater(pos+eps.xyy).x - v,\n                            eps.x,\n                            sdWater(pos+eps.yyx).x - v ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<25; i++ )\n    {\n        h = sdDolphinCheap(ro + rd*t).x;\n        //h = min(h, sdWater(ro+rd*t).x);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.05, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 GetSpectrum( float x, const in vec3 vBrightness, const in vec3 vPeak, const in vec3 vRange )\n{\n\tvec3 vTemp = 1.0 - abs((vPeak - x) * vRange);\n\tvTemp = clamp(vTemp, 0.0, 1.0);\n\tvec3 vTemp2 = vTemp  * vTemp;\t\n\treturn (3.0 * vTemp2 - 2.0 * vTemp * vTemp2) * vBrightness;\t\n}\n\nvec4 GetRainbowRGBA( float theta )\n{\n\tvec4 vResult = vec4(0.0);\n\n\t// red0 = 137.7 deg\n\t// violet0 = 139.6 deg\n\t// red1 = 129.5 deg\n\t// violet1 = 126.1 deg\n\t\n\tconst vec3 vPeak0 = vec3(180.0 - 137.7, 180.0 - (137.7 + 139.6)*0.5, 180.0 - 139.6);\n\tconst vec3 vRange0 = 1.0 / vec3(vPeak0.b - vPeak0.r);\n\tconst vec3 vBrightness0 = vec3(1.0);\n\n\tvResult.xyz += GetSpectrum(theta, vBrightness0, vPeak0, vRange0);\t\n\n\tconst vec3 vPeak1 = vec3(180.0 - 129.5, 180.0 - (129.5 + 126.1) * 0.5, 180.0 - 126.1);\n\tconst vec3 vRange1 = 1.0 / vec3(vPeak1.b - vPeak1.r);\n\tconst vec3 vBrightness1 = vec3(0.25);\n\t\n\tvResult.xyz += GetSpectrum(theta, vBrightness1, vPeak1, vRange1);\t\n\t\n\tfloat aFactor = max(smoothstep(vPeak0.r + 1.0, vPeak0.b - 1.0, theta), smoothstep(vPeak1.r - 1.0, vPeak1.b + 1.0, theta) * 0.2);\n\tvResult.a = 1.0 - aFactor;\t\n\t\n\treturn vResult;\n}\nconst vec3 lig = vec3(0.86,0.15,0.48);\n\n\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, float glossy, float glossy2, float shadows, in vec3 col, float occ )\n{\n\tvec3 ref = reflect(rd,nor);\n\t\n    // lighting\n    float sky = clamp(nor.y,0.0,1.0);\n\tfloat bou = clamp(-nor.y,0.0,1.0);\n    float dif = max(dot(nor,lig),0.0);\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\n    float sha = 1.0-shadows; if( (shadows*dif)>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n    float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n    float spe = max( 0.0, pow( clamp( dot(lig,ref), 0.0, 1.0), 0.01+glossy ) ) * glossy;\n    float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n\t\t\n    // lights\n    vec3 brdf = vec3(0.0);\n\tbrdf += 8.0*dif*vec3(1.80,1.35,0.90)*vec3(sha,sha*0.5+0.5*sha*sha,sha*sha);\n    brdf += 1.0*sky*vec3(0.20,0.40,0.55)*occ;\n    brdf += 1.0*bac*vec3(0.40,0.60,0.70)*occ;\n    brdf += 1.0*bou*vec3(0.10,0.20,0.25);\n    brdf += 1.0*sss*vec3(0.40,0.40,0.40)*(0.3+0.7*dif*sha)*glossy*occ;\n    brdf += 0.5*spe*vec3(1.3,1.0,0.8)*sha*(0.3+0.7*fre)*occ*glossy;\n    brdf += glossy*0.3*vec3(0.8,0.9,1.0)*occ*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));//*smoothstep(-0.1,0.0,dif);\n\t\n    col = col*brdf;\n\n    col += (0.5 + 1.5*fre)*occ*glossy2*glossy2*10.0*vec3(1.0,0.9,0.8)*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));//*smoothstep(-0.1,0.0,dif);\n    col += 0.25*glossy*pow(spe/(0.01+glossy),8.0)*vec3(1.3,1.0,0.8)*sha*(0.3+0.7*fre)*occ;\n\t//col += GetRainbowRGBA(dot(nor, rd)_\n\treturn col;\n}\n\nvec3 normalMap( in vec2 pos )\n{\n\tpos *= 6.0;\n\tpos.y *= 0.375;\n\t\n\tfloat v = texture( iChannel2, 0.015*pos ).x;\n\tvec3 nor = vec3( texture( iChannel2, 0.015*pos+vec2(1.0/1024.0,0.0)).x - v,\n\t                 1.0/16.0,\n\t                 texture( iChannel2, 0.015*pos+vec2(0.0,1.0/1024.0)).x - v );\n\tnor.xz *= -1.0;\n\treturn normalize( nor );\n}\n/*\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 o;\n    o.r = v.id;\n    o.g = clamp(floor(v.sunlight), 0., 15.) + 16. * clamp(floor(v.torchlight), 0., 15.);\n    o.b = v.hue;\n    o.a = 1.;\n    return o;\n}\n\n*/\nstruct data {\n \tvec4 col;\n    float water;\n   \tfloat cc;\n    float posy;\n    float t;\n};\nvec4 encodeColor (data d) {\n \tvec4 o;\n    float bit1 = bit-1.0;\n    o.r = clamp(floor(d.col.r*bit1), 0., bit1)+bit*clamp(floor((1.0-d.water)*bit1), 0., bit1);\n    o.g = clamp(floor(d.col.g*bit1), 0., bit1)+bit*clamp(floor((d.cc)*bit1), 0., bit1);\n    o.b = clamp(floor(d.col.b*bit1), 0., bit1)+bit*clamp(floor((d.posy)*bit1), 0., bit1);\n    o.a = clamp(floor(d.col.a*bit1), 0., bit1)+bit*clamp(floor((d.t)*bit1), 0., bit1);\n    return o;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\n    //-----------------------------------------------------\n    // animate\n    //-----------------------------------------------------\n    fishTime = 0.6 + 2.0*iTime - 20.0;\n\n    fishPos = vec3( 0.0, 0.0-0.2, -1.1*fishTime );\n\n    isJump  = 0.5 + 0.5*cos(     -0.4+0.5*fishTime);\n    isJump2 = 0.5 + 0.5*cos( 0.6+0.5*fishTime);\n\tfloat isJump3 = 0.5 + 0.5*cos(-1.4+0.5*fishTime);\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 1.2 + 0.1*iTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = vec3(fishPos.x,0.8,fishPos.z) - vec3(0.0,0.0,-2.0);\n\tvec3 ro = ta + vec3(4.0*sin(an),3.4,4.0*cos(an));\n\n    // shake\n\tro += 0.05*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.05*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    //vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 uu = normalize( vec3(-ww.z,0.0,ww.x) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww*(1.0+0.7*smoothstep(-0.4,0.4,sin(0.34*iTime))) );\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tfloat t = 1000.0;\n\t\n\tvec3 col = vec3(0.0);\n\tvec3 bgcol = vec3(0.6,0.7,0.8) - .2*clamp(rd.y,0.0,1.0);\n\n    // quick step till y=3 bounding plane\n\tfloat pt = (3.0-ro.y)/rd.y;\n\tif( rd.y<0.0 && pt>0.0 ) ro=ro+rd*pt;\n\n\t// raymarch\n    vec2 tmat1 = intersectDolphin(ro,rd);\n\tvec3 posy = vec3(-100000.0);\n    if( tmat1.x>0.0 )\n    {\n\t\tvec2 tmat = tmat1;\n\t\tt = tmat.x;\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalFish(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\t\tvec3 fpos = pos - fishPos;\n\n\t\tvec3 auu = normalize( vec3(-ccd.z,0.0,ccd.x) );\n\t\tvec3 avv = normalize( cross(ccd,auu) );\n\t\tvec3 ppp = vec3( dot(fpos-ccp,auu),  dot(fpos-ccp,avv),  tmat.y );\n\t\tvec2 uv = vec2( 1.0*atan(ppp.x,ppp.y)/3.1416, 4.0*ppp.z );\n\n\t\tvec3 bnor = -1.0+2.0*texture(iChannel0,uv).xyz;\n        nor += 0.01*bnor;\n\n\t\tvec3 te = texture( iChannel2, uv ).xyz;\n\t\tvec4 mate;\n\t\tmate.w = 17.0;\n        mate.xyz = mix( vec3(0.3,0.35,0.4), vec3(0.8,0.85,0.9)*0.9, 0.8*smoothstep(-0.05,0.05,ppp.y) );;\n\n        mate.xyz *= 1.0 + 0.3*te;\n\t\tmate.xyz *= smoothstep( 0.0, 0.06, distance(vec3(abs(ppp.x),ppp.yz)*vec3(1.0,1.0,4.0),vec3(0.35,0.0,0.4)) );\n\t\tmate.xyz *= 1.0 - 0.75*(1.0-smoothstep( 0.0, 0.02, abs(ppp.y) ))*(1.0-smoothstep( 0.07, 0.11, tmat.y ));\n\t\t\n\t\tmate.xyz *= 0.1*0.23;\n\t\t\n        mate.w *= (0.7+0.3*te.x)*smoothstep( 0.0, 0.01, pos.y-sdWaterCheap( pos ) );\n\t\t\t\n        // surface-light interacion\n        col = doLighting( pos, nor, rd, mate.w, 0.0, 0.0, mate.xyz, 1.0 );\n\t\n\t\tposy = pos;\n\t}\n\n\t\n    vec3 tmat2 = intersectWater(ro,rd);\n\tvec3 col2 = vec3(0.0);\n    float al = 0.0;\n     float cc  = 0.65*texture( iChannel0, 2.5*0.02*posy.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\n        cc += 0.35*texture( iChannel0, 1.8*0.04*posy.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\n        cc = 0.6*(1.0-smoothstep( 0.0, 0.05, abs(cc-0.5))) + \n\t         0.4*(1.0-smoothstep( 0.0, 0.20, abs(cc-0.5)));\n\tfloat water = 0.0;\n    vec3 pos;\n    if( tmat2.x>0.0 && (tmat1.x<0.0 || tmat2.x<tmat1.x) )\n\t{\n\t\tvec3 tmat = tmat2;\n\n        t = tmat.x;\n\n        pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalWater(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        vec4 mate = vec4(0.4,0.4,0.4,0.0);\n\n\t\tvec3 bnor = normalMap(pos.xz);\n        nor = normalize( nor + 0.2*bnor );\n\n        float fre = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 2.0 );\n\n\t\tmate.xyz = 0.3*mix( vec3(0.0,0.03,0.07), 0.1*vec3(0.0,0.3,0.4), fre );\n\t\tmate.w = fre;\t\n\n        float foam = 1.0-smoothstep( 0.1, 0.65, tmat.y );\n        foam *= smoothstep( 0.0, 0.3, abs(nor.x) );\n\t\t\n        foam *= clamp(1.0-texture( iChannel2, vec2(1.0,0.75)*0.45*pos.xz ).x*2.0,0.0,1.0);\n        mate = mix( mate, vec4(0.7,0.7,0.7,0.0), 0.2*foam );\n\n\t\tal = clamp( 0.5 + 0.2*(pos.y - posy.y), 0.0, 1.0 );\n\t\t\n\t\t//foam = exp( -3.0*abs(sdFishCheap(pos).x) );\n\t\tfoam = exp( -3.0*abs(tmat.z) );\n\t\t\n\t\tfoam *= texture( iChannel3, pos.zx ).x;\n\t\tfoam = clamp( foam*3.0, 0.0, 1.0 );\n\t\tfoam *= isJump;\n\t\tfoam *= mix( 1.0, smoothstep(0.0,0.5,pos.z-fishPos.z-1.5), isJump2 );\n\t\tmate.xyz = mix( mate.xyz, vec3(0.9,0.95,1.0)*0.3, foam*foam );\n\t\tcol = mix( col, vec3(0.9,0.95,1.0)*1.2, foam );\n\t\tal *= 1.0-foam;\n\n\t\tfloat occ = clamp(3.5*sdDolphinCheap(pos+vec3(0.0,0.4,0.0)).x * sdDolphinCheap(pos+vec3(0.0,1.0,0.0)).x,0.0,1.0);\n        occ = mix(1.0,occ,isJump);\n        occ = 0.35 + 0.65*occ;\n\t\tmate.xyz *= occ;\n        col *= occ;\n\n\t\tmate.xyz = doLighting( pos, nor, rd, mate.w*10.0, mate.w*0.5, 1.0, mate.xyz, occ );\n\t\t\n        // caustics\n       \tcc  = 0.65*texture( iChannel0, 2.5*0.02*posy.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\n        cc += 0.35*texture( iChannel0, 1.8*0.04*posy.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\n        cc = 0.6*(1.0-smoothstep( 0.0, 0.05, abs(cc-0.5))) + \n\t         0.4*(1.0-smoothstep( 0.0, 0.20, abs(cc-0.5)));\n        col *= 1.0 + 0.8*cc;\n\t\t\n\t\tcol = mix( col, mate.xyz, al );\n        water = 1.0;\n\t}\n\t\t\n\t\n\tfloat sun = pow( max(0.0,dot( lig, rd )),8.0 );\n\tcol += vec3(0.8,0.5,0.1)*sun*0.3;\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n    // color\n\tcol = col*vec3(0.9,0.85,0.8) + 0.4*col*col*(3.0-2.0*col);\n\t\t\n    // vigneting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    // fade\t\n\tcol *= smoothstep( 0.0, 1.0, iTime );\n\t/*/*\nvoxel decodeTextel(vec4 textel) {\n\tvoxel o;\n    o.id = textel.r;\n    o.sunlight = floor(mod(textel.g, 16.));\n    o.torchlight = floor(mod(textel.g / 16., 16.));\n    o.hue = textel.b;\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 o;\n    o.r = v.id;\n    o.g = clamp(floor(v.sunlight), 0., 15.) + 16. * clamp(floor(v.torchlight), 0., 15.);\n    o.b = v.hue;\n    o.a = 1.;\n    return o;\n}\n\nstruct data {\n \tvec4 col;\n    float water;\n   \tfloat cc;\n    float posy;\n    float t;\n};\nvec4 encodeColor (data d) {\n \tvec4 o;\n    o.r = clamp(floor(d.col.r*63.), 0., 63.)+64.*clamp(floor((1.0-d.water)*63.), 0., 63.);\n    o.g = clamp(floor(d.col.g*63.), 0., 63.)+64.*clamp(floor((d.cc)*63.), 0., 63.);\n    o.b = clamp(floor(d.col.b*63.), 0., 63.)+64.*clamp(floor((d.posy)*63.), 0., 63.);\n    o.a = clamp(floor(d.col.a*63.), 0., 63.)+64.*clamp(floor((d.t)*63.), 0., 63.);\n    return o;\n}*/\n    data d;\n    d.col = vec4(col, 1.0-al);\n    d.water = water;\n    d.cc = cc;\n    d.posy = pos.y;\n    d.t = t;\n\tfragColor = encodeColor(d);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//This value is used for encoding data. Increasing it won't really affect speed negatively\n//But will increase color depth. However, certain gpus have different memory capabilities\n#define bit 1024.",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}