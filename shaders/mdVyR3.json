{
    "Shader": {
        "info": {
            "date": "1697140309",
            "description": "As promised: a companion piece (and Seinfeld hommage :) )\n\nPress mouse to remove censorship.\n\nSpace toggles animation, Enter shows control points. V and W switches drawing method.",
            "flags": 48,
            "hasliked": 0,
            "id": "mdVyR3",
            "likes": 18,
            "name": "Hot Guy (Significant Shrinkage)",
            "published": 3,
            "tags": [
                "2d",
                "cartoon",
                "spline",
                "catmullrom",
                "nude",
                "seinfeld",
                "shrinkage"
            ],
            "usePreview": 1,
            "username": "misol101",
            "viewed": 862
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\n\n Hot Guy (Significant Shrinkage) by misol101\n\n Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n--------------------------------------------------------------------------------------*/\n\n// from https://www.shadertoy.com/view/slyGW1 by FabriceNeyret2\n#define R iResolution.xy\n#define S(d,r) smoothstep( 3.,0., (d)*R.y -r )\n  \nfloat line(vec2 p, vec2 a,vec2 b, float r) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.), // proj coord on line\n          d = length(p - b * h);                    // dist to segment\n    return S(  d , max(0.,r-1.) ) * min(r,1.);\n}\n\n#define V(a,b) vec2((a),(b))\n\n// from https://www.shadertoy.com/view/lsKSWR by Ippokratis\nfloat vignette(vec2 FC, float extent, float intensity) {\n\tvec2 uv = FC.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * intensity;\n    return pow(vig, extent);\n}\n\nvoid censor(inout vec4 fc, vec2 uv, vec2 p) {\n    float asp = iResolution.y/iResolution.x;\n    float xd = abs(uv.x - p.x + (uv.y - p.y)*asp);\n    float xd2 = abs(uv.x - p.x - (uv.y - p.y)*asp);\n    float yd = abs(uv.y - p.y);\n    if ((xd < 0.014 || xd2 < 0.014) && yd < 0.038) { fc = vec4(0.75,0.,0.,0.); }\n}\n\nvoid excl(inout vec4 fc, vec2 uv, vec2 p) {\n    float asp = iResolution.y/iResolution.x;\n    float xd = abs(uv.x - p.x);\n    float yd = abs(uv.y - p.y);\n    if ((xd < 0.012) && (yd < 0.038 || (yd>0.05 && yd < 0.08 && p.y > uv.y) )) { fc = vec4(0.75,0.,0.,0.); } // vec4(0.35,0.65,0.99,0.);\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 U = ( 2.*fragCoord - R ) / R.y;\n    vec2 bpos = vec2(-0.23, -0.05);\n    if (length(U-bpos) > 1.0 && U.x>0.2) {\n        for (float a=0.075*7.; a<3.141-0.075*7.; a+=0.075) {\n            float b=a+(hash1(a+0.43)-0.5)*0.1;\n            vec2 rot = vec2(sin(b), cos(b)*1.23);\n            fragColor -= line( U, bpos+rot*(1.1+(hash1(a+0.23)-0.5)*0.45), bpos+rot*10., ((2.3+(hash1(a)-0.3)*3.) * (iResolution.y/360.)) * ((length(U)-0.93)*(iMouse.z>0.5?5.:3.)));\n        }\n    }\n    bpos = vec2(-0.75, -0.05);\n    if (length(U-bpos) > 0.8 && U.x<-0.9) {\n        for (float a=4.08; a<3.141*2.-0.075*7.; a+=0.075) {\n            float b=a+(hash1(a+0.43)-0.5)*0.1;\n            vec2 rot = vec2(sin(b), cos(b)*1.23);\n            fragColor -= line( U, bpos+rot*(1.1+(hash1(a+0.23)-0.5)*0.45), bpos+rot*10., ((2.3+(hash1(a)-0.3)*3.) * (iResolution.y/360.)) * ((length(U+vec2(0.7,0.))-0.93)*(iMouse.z>0.5?5.:3.)));\n        }\n    }\n\n    if (iMouse.z < 0.5) {\n        censor(fragColor, uv, vec2(0.328, 0.066));\n        excl(fragColor, uv, vec2(0.59, 0.675));\n    } else {\n        U = 18.*(fragCoord)/iResolution.y;                                     \\\n        U.x -= 16.;\n        if (U.x >= 0. && U.x <= 7. && U.y >= 10. && U.y <= 13.) {\n            int i;\n            switch(int(U.y-10.)) {\n                case 0: i = int[](80,79,79,76,33,32,32)[int(U)]; break;\n                case 1: i = int[](73,78,32,84,72,69,32)[int(U)]; break;\n                case 2: i = int[](73,32,87,65,83,32,32)[int(U)]; break;\n            }\n            float tc= 1.-texture( iChannel1, fract(U)*.055 + vec2(i,15-i/16)/16. ).x;\n            fragColor *= vec4(tc,tc,tc*1.0,0.); // 3.0\n            if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(1.);\n        }\n    }\n\n\tfragColor *= 1.0 - 0.03 * length(fragCoord / iResolution.xy - 0.5);\n    fragColor *= vignette(fragCoord, 0.04, 95.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n/**\n * Tension. Default Catmul-Rom matrix has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.6\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n#define V(a,b) vec2((a),(b))\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey(int key) { return texelFetch( iChannel1, ivec2(key, 0), 0).x > .5; }\nbool readKeyToggle(int key) { return texelFetch( iChannel1, ivec2(key, 2), 0).x > .5; }\n\nconst int NUM = 12;\nconst int WNUM = NUM-2;\n\nvoid drawPath(out vec4 fragColor, vec2 fragCoord, vec2 path[NUM], float linew[WNUM], int nofP) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(1.0);\n\n    float scale = iResolution.x/1920.;\n    \n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\tif (readKeyToggle(KEY_ENTER)) {\n\t\tvec2 d = vec2(1000.0);\n        int j = 1;\n\t\tfor (int i = 0; i < (nofP - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n            \n            vec2 tmp = vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a));\n            if (tmp.y < d.y) {\n                j = i;\n            }\n\t\t\td = min(d, tmp);\n\t\t}\n\t\t//d.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[nofP - 1])));\n\t\tcol = mix(col, j==0?vec3(0.3, 0.8, 0.3):j==nofP-2?vec3(1.0, 0.0, 0.0):vec3(0.9, 0.6, 0.0), 1.0 - smoothstep(12.0 * scale * e, 13.0 * scale * e, d.y));\n\t}\n\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = (cos(max(0.,iTime-0.0))*0.4+0.4)*float(nofP); //min(mod(iTime / 8., 1.0), 1.0) * float(nofP);\n        if (!readKeyToggle(KEY_SPACE)) ani = 1.0 * float(nofP); // draw entire thing\n\n\t\tvec2 p = path[0];\n        float lm=0.5;\n\n\t\tfor (int i = 0; i < nofP - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n            \n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n            \n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n                float dt = sdSegmentSq(uv, p, q);\n                // adjust/interpolate line width for each segment (added by misol101)\n                if (dt < d) {\n                    d = dt;\n                    lm = linew[i];\n                    \n                    float l1 = length((i==0?A:B)-C);\n                    float l2 = length(C-uv);\n                    if (!readKeyToggle(KEY_V)) lm = mix(linew[i+1], linew[i], smoothstep(0.1,0.9,l2/l1) );\n                }\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (readKeyToggle(KEY_W)) lm=0.8;\n\t\td = sqrt(d);\n\n        float bsize = 12.0*scale*lm;\n        float aa = bsize - 4.*scale;\n\n\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.0 - smoothstep(aa * e, bsize * e, d));\n        //col *= 0.75 + 0.25 * smoothstep(0.0, 0.11*lm, sqrt(d));\n\t}\n\n\tfragColor = vec4(col, 1.0);\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\n// first line between points is drawn straight\n\n#define NECK_ARM_RIGHT\n#define NECK_ARM_LEFT\n#define TUMMY_BREAST_ARM_RIGHT\n#define GENITALS\n#define NECK_FACE_RIGHT\n#define FACE_EAR_LEFT\n#define TUMMY_BREAST_LEFT\n#define ARM_LEFT\n#define NAVEL\n#define NIPPLES\n#define MOUTH\n#define NOSE\n#define BROWS\n#define EYES\n#define EAR\n#define HAIR\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    const vec2 P = vec2(0.); // padding\n    vec4 colC=vec4(1.), colT;\n\n#ifdef NECK_ARM_RIGHT\n    if (length(vec2((uv.x-0.431)*8.5,uv.y-0.319)*0.8) < 0.35) {\n        const vec2 cN = V(0.45, 0.001); // last point, to add twice\n        vec2 armRU[NUM] =  vec2[] ( V(0.405, 0.673), V(0.438, 0.643), V(0.455, 0.571), V(0.459, 0.419), V(0.463, 0.323), V(0.47, 0.243), V(0.47, 0.148), cN, cN, P, P, P );\n\n        float xmv = sin(iTime*29.)*(iMouse.z>0.5?0.0025:0.);\n        armRU[5].x+=xmv*0.5; armRU[6].x+=xmv; armRU[7].x+=xmv; armRU[8].x+=xmv*0.5; armRU[9].x+=xmv*0.5;\n\n        float linewArmRU[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.8, 0.7, 0.8, 0.5, -0., -0., -0. );\n        drawPath(colT, fragCoord, armRU, linewArmRU, 9);\n        colC=min(colC,colT);\n}\n#endif\n\n#ifdef NECK_ARM_LEFT\n    if (abs(uv.x-0.211)<0.085 && uv.y < 0.785) {\n        vec2 armRD[NUM] =  vec2[] ( V(0.29, 0.785), V(0.286, 0.724), V(0.245, 0.676), V(0.191, 0.61), V(0.158, 0.487), V(0.134, 0.284), V(0.142, 0.094), V(0.146, 0.002), V(0.146, 0.002),P,P,P );\n        float linewArmRD[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.95, 0.5, 0.5, 0.5, -0., -0., -0. );\n\n        float xmv = sin(iTime*29.)*(iMouse.z>0.5?0.0039:0.);\n        armRD[6].x+=xmv; armRD[7].x+=xmv; armRD[8].x+=xmv; armRD[9].x+=xmv;\n\n        drawPath(colT, fragCoord, armRD, linewArmRD, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef TUMMY_BREAST_ARM_RIGHT\n    if (length(vec2((uv.x-0.415)*6.2,uv.y-0.246)*0.8) < 0.21) {\n        const vec2 cN = V(0.431, 0.48);\n        vec2 legRL[NUM] =  vec2[] ( V(0.419, 0.000), V(0.414, 0.106), V(0.366, 0.121), V(0.414, 0.106), V(0.438, 0.193), V(0.428, 0.360), V(0.385, 0.373), V(0.437, 0.384), V(0.432, 0.439), cN, cN,P );\n        float linewLegRL[WNUM] = float[] ( 0.7, 0.0, 0.5, 0.6, 0.6, 0.75, 0.7, 0.5, 0.5, -0. );\n        drawPath(colT, fragCoord, legRL, linewLegRL, 11);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef GENITALS\n    if (length(uv-V(0.33,0.047)) < 0.05) {\n        const vec2 cN = V(0.32, 0.089);\n        vec2 legRR[NUM] = vec2[] ( V(0.337, 0.087), V(0.340, 0.062), V(0.337, 0.042), V(0.332, 0.041), V(0.330, 0.064), V(0.325, 0.046), V(0.323, 0.0), V(0.323, 0.047), V(0.315, 0.07), cN, cN, P );\n        float linewLegRR[WNUM] = float[] ( 0.3, 0.5, 0.35, 0.6, 0.5, 0.5, 0.5, 0.6, 0.3, -0. );\n        drawPath(colT, fragCoord, legRR, linewLegRR, 11);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NECK_FACE_RIGHT\n    if (length(vec2((uv.x-0.372)*2.8,uv.y-0.8)*0.9) < 0.16) {\n        const vec2 cN = V(0.428,0.062);\n        vec2 legL[NUM] =  vec2[] ( V(0.367-0.042, 0.668+0.064), V(0.367-0.042, 0.668+0.064), V(0.365-0.04, 0.668+0.063), V(0.338, 0.724-0.02), V(0.367, 0.674), V(0.407, 0.679), V(0.414, 0.718), V(0.421, 0.778), V(0.415, 0.824), V(0.417, 0.848), V(0.402, 0.928), V(0.378, 0.961));\n        float linewLegL[WNUM] = float[] ( 0.35, 0.5, 0.8, 0.8, 0.6, 0.5, 0.6, 0.5, 0.5, 0.4 );\n        drawPath(colT, fragCoord, legL, linewLegL, 12);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef FACE_EAR_LEFT\n    if (length(uv-V(0.344,0.86)) < 0.13) {\n        const vec2 cN = V(0.312, 0.82);\n        vec2 breastR[NUM] =  vec2[] ( V(0.402, 0.928),V(0.402, 0.928), V(0.371, 0.967), V(0.313, 0.948), V(0.279, 0.871), V(0.285, 0.813), V(0.293, 0.779), V(0.315, 0.754), V(0.32, 0.789), V(0.304, 0.805), cN,cN );\n        float linewBreastR[WNUM] = float[] ( 0.4, 0.6, 0.4, 0.4, 0.55, 0.5, 0.85, 0.5, 0.5, 0.5 );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef TUMMY_BREAST_LEFT\n    if (length(uv-V(0.292,0.282)) < 0.16) {\n        const vec2 cN = V(0.352, 0.398);\n        vec2 breastL[NUM] =  vec2[] ( V(0.278, 0.14), V(0.238, 0.16), V(0.209, 0.2), V(0.209, 0.2), V(0.238, 0.368), V(0.238, 0.366), V(0.303, 0.346), cN, cN, P,P,P );\n        float linewBreastL[WNUM] = float[] ( 0.4, 0.5, 0.0, 0.0, 0.3, 0.7, 0.9, -0., -0., -0. );\n        drawPath(colT, fragCoord, breastL, linewBreastL, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef ARM_LEFT\n    if (length(vec2((uv.x-0.228)*4.4,uv.y-0.239)*0.9) < 0.3) {\n        const vec2 cN = V(0.19, 0.0);\n        vec2 hairR[NUM] =  vec2[] ( V(0.264, 0.493), V(0.258, 0.47), V(0.209, 0.287), V(0.196, 0.298), V(0.206, 0.199), V(0.187, 0.083), cN, cN, P,P,P,P);\n\n        float xmv = sin(iTime*29.)*(iMouse.z>0.5?0.0019:0.);\n        hairR[6].x+=xmv; hairR[7].x+=xmv; hairR[8].x+=xmv; hairR[5].x+=xmv;\n\n        float linewHairR[WNUM] = float[] ( 0.5, 0.8, 0.5, 0.5, 0.6, 0.4, 0.05, 0.8, 0.4, 0.5 );\n        drawPath(colT, fragCoord, hairR, linewHairR, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef EYES\n    float esz=0.009, esz2=0.006;\n    if (iMouse.z > 0.5) { esz = 0.0095; esz2 = 0.0055;}\n    vec4 vc = vec4(0.0,0.0,0.0,1.);\n    \n    float pup;\n\n    if (iMouse.z > 0.5) {\n        pup=length(uv-V(0.378,0.821)); // left\n        if (pup > esz-0.006 && pup < esz) {\n            float aap = smoothstep(esz-0.002,esz, pup);\n            if (pup < esz-0.003) {\n                pup -= esz-0.006;\n                aap = 0.0016/pup;\n            }\n            colC=min(colC, vec4(aap)+vc);\n        }\n        \n        pup=length(uv-V(0.408,0.823)); // right\n        if (pup > esz-0.006 && pup < esz) {\n            float aap = smoothstep(esz-0.002,esz, pup);\n            if (pup < esz-0.003) {\n                pup -= esz-0.006;\n                aap = 0.0016/pup;\n            }\n            colC=min(colC, vec4(aap)+vc);\n        }\n    }\n    \n    float xmv = sin(iTime*24.)*(iMouse.z>0.5?0.0011:0.);\n    pup=length(uv-V(0.379+xmv,0.822));\n    if (pup < esz2) {\n        float aap = smoothstep(esz2-0.002,esz2, pup);\n        colC=min(colC, vec4(aap)+vc);\n    }\n    \n    pup=length(uv-V(0.408+xmv,0.824));\n    if (pup < esz2) {\n        float aap = smoothstep(esz2-0.002,esz2, pup);\n        colC=min(colC, vec4(aap)+vc);\n    }\n#endif\n\n#ifdef MOUTH\n    if (length(uv-V(0.394,0.733)) < 0.16) {\n        const vec2 cN = V(0.384, 0.73);\n        vec2 mouth[NUM] =  vec2[] ( V(0.384, 0.728), V(0.384, 0.728), V(0.388, 0.728), V(0.396, 0.728), V(0.403, 0.728), V(0.405, 0.737),V(0.400, 0.737), cN, cN, P, P, P);\n\n        if (iMouse.z > 0.5) {\n            float m=min(1.,sin(iTime*13.)*0.7+1.1);\n            mouth[0]+=vec2(-0.005,-0.008)*m;\n            mouth[1]+=vec2(-0.006,-0.02)*m;\n            mouth[2].y -= 0.035*m;\n            mouth[3]+=vec2(0.006,-0.03)*m;\n            mouth[4].x += 0.003*m;\n            mouth[5].x -= 0.003*m;\n            mouth[6].x -= 0.01*m;\n            mouth[7]+=vec2(-0.005,-0.008)*m;\n            mouth[8].y -= 0.008*m;\n        }\n\n        float linewMouth[WNUM] = float[] ( 0.5, 0.7, 0.7, 0.7, 0.7, 0.7, 0.5, -0., -0., -0. );\n        drawPath(colT, fragCoord, mouth, linewMouth, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NOSE\n    if (length(uv-V(0.4,0.787)) < 0.04) {\n        vec2 armL[NUM] =  vec2[] ( V(0.401, 0.822), V(0.405, 0.794), V(0.408, 0.776), V(0.402, 0.761), V(0.386, 0.764), V(0.386, 0.776), V(0.386, 0.776), P, P, P, P, P);\n        float linewArmL[WNUM] = float[] ( 0.3, 0.4, 0.7, 0.55, 0.35, -0., -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, armL, linewArmL, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef BROWS\n    if (length(uv-V(0.391,0.831)) < 0.06) {\n        vec2 armL[NUM] =  vec2[] ( V(0.36, 0.83),V(0.36, 0.83),V(0.375, 0.842),V(0.389, 0.842),V(0.395,0.841), V(0.396, 0.841), V(0.401, 0.842), V(0.41, 0.847), V(0.416, 0.843), V(0.416, 0.843), P,P  );\n        float linewArmL[WNUM] = float[] ( 0.4, 0.9, 0.4, 0.0, 0.0, 0.4, 0.8, 0.7, -0., -0. );\n        \n        if (iMouse.z > 0.5) { for (int i=0; i<10;i++) armL[i].y+=0.015; }\n        \n        drawPath(colT, fragCoord, armL, linewArmL, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef EAR\n    if (length(uv-V(0.305,0.805)) < 0.07) {\n        vec2 armL[NUM] =  vec2[] ( V(0.318, 0.832),V(0.318, 0.832),V(0.301, 0.83),V(0.295, 0.811),V(0.298,0.78), V(0.316, 0.754), V(0.32, 0.765), V(0.306, 0.804), V(0.318, 0.808), V(0.318, 0.808), P,P  );\n        float linewArmL[WNUM] = float[] ( 0.4, 0.9, 0.6, 0.6, 0.8, 0.0, 0.6, 0.6, -0., -0. );\n        drawPath(colT, fragCoord, armL, linewArmL, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n    vec2 navel[NUM] =  vec2[] ( V(0.427,0.430), V(0.427,0.430), V(0.429,0.404), V(0.4249,0.393), V(0.422,0.402), V(0.424,0.412), V(0.424,0.412), P, P,P,P,P );\n    for (int i=0; i < NUM; i++) navel[i] +=  vec2(-0.075, -0.2);\n    float linewNavel[WNUM] = float[] ( 0.1, 0.3, 0.6, 0.3, 0.3, -0., -0., -0., -0., -0. );\n#ifdef NAVEL\n    if (length(uv-V(0.350,0.21)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NIPPLES\n    for (int i=0; i < NUM; i++) navel[i] +=  vec2(0.07, 0.21); // right\n    if (length(uv-V(0.350+0.07,0.21+0.21)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n\n    if (length(uv-V(0.350+0.07-0.110,0.21+0.21-0.01)) < 0.025) {\n        for (int i=0; i < NUM; i++) navel[i] +=  vec2(-0.110, -0.01); // left\n        linewNavel[4] = 0.;\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef HAIR\n    if (length(uv-V(0.344,0.86)) < 0.13) {\n        const vec2 cN = V(0.29, 0.915);\n        vec2 breastR[NUM] =  vec2[] ( V(0.385, 0.968),V(0.385, 0.968), V(0.371, 0.957), V(0.313, 0.948), V(0.279, 0.891), V(0.291, 0.782), V(0.285, 0.824), V(0.284, 0.829), V(0.284, 0.889), V(0.285, 0.915), cN,cN );\n        float linewBreastR[WNUM] = float[] ( 0.25, 0.6, 1.8, 0.7, 1.35, 1.95, 7.0, 7.1, 6.8, 0.8 );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 12);\n        colC=min(colC,colT);\n        \n        breastR =  vec2[] ( V(0.331, 0.910),V(0.329, 0.914), V(0.30, 0.93), V(0.35, 0.978), V(0.37, 0.96), V(0.36, 0.94), V(0.291, 0.92), V(0.312, 0.91), V(0.340, 0.95), V(0.312, 0.955), V(0.312, 0.955),V(0.331, 0.918) );\n        linewBreastR = float[] ( 0.65, 0.8, 0.2, 0.4, 0.35, 1.7, 0.5, 0.5, 0.5, 0.5 );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n    fragColor = colC; \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}