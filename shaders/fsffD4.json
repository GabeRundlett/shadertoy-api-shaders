{
    "Shader": {
        "info": {
            "date": "1645282917",
            "description": "The collisions don't take into account the angle of collision but it still works out ok.",
            "flags": 32,
            "hasliked": 0,
            "id": "fsffD4",
            "likes": 7,
            "name": "Particle Exper #1 [commented]",
            "published": 3,
            "tags": [
                "particles",
                "truchet",
                "physics",
                "commented",
                "buffer",
                "collisions"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "/*\n\nBUFFER A <= For information on the particle simulation & animation\nIMAGE <= For information on the coloring and lighting\n\nIMAGE\n******************************************************\n\nMAIN FEATURES:\n\n1. A Hemispherical Normal function to calculate a 3d normal for \nevery point on a 2d disk. This is explained in depth.\n\n2. Skipping particles that are outside a certain distance from a given pixel \nsince it wont factor into the color of that pixel\n\n3. Lot's and lot's of comments!\n\n*/\n\n//noise function used for the truchet texture.\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\n//circle function for drawing parts of the disk\nfloat circle(vec2 p, float r, float sf)\n{    \n    return smoothstep(r+EPS*sf, r-EPS*sf, length(p));\n}\n\n//a sin function to create a ripple effect on the disks\nfloat SIN(vec2 p, float r)\n{\n    float c = length(p);\n    return abs(sin(c*50./r))*(smoothstep(r+EPS, r-EPS,c));\n}\n\n/* Next, I create a 3d spherical normal out of a point on a disk\nusing trigonometry\nimagine you are standing in a field but you are covered by this\ndome. A complete half sphere dome. You are on this field inside \nand at any position in there, you are under a part of the \"roof\"\nof the dome. The height to the roof where you are standing, is the \nz axis. Your position is x and y.\nWe know the dome will have a middle (where x and y = vec2(0,0)) the \norigin of the dome on the field. So we can find the length to the position\non the field where you are standing with length(xy).\nOk, so then we have a length, but we never actually found Z did we?\nBut we do have the length and so we can use trigonometry if we\nlet length be A and let Z be B.\nSo we have A but we don't have B or C.\nWell if the dome is a \"unit sphere\" then we DO have C because it\nwill be the hypotenuse of length = 1.\nThen B = sqrt(1.-A^2)\nSo we can return the normal as \nvec3(x from field ,y from field ,B from triangle)\n*/\nvec3 hemiNormal(vec2 center, vec2 point){\n//we scale base to be 1 based on the radius scaled to only the \n//part of the circle we want to add highlights to. instead of the full\n//radius, we want 0.6 of it.\n    float base = length(point)/(RADIUS*0.6);\n    float height = sqrt(1.-base*base);\n    return vec3(point, height);\n}\n\n//This function puts a lot of things together\nvec3 drawFancyCircle(vec3 col, \n                     vec2 uv,\n                     int ball_id,\n                     vec2 fragCoord, \n                     vec2 pos, \n                     float r){\n                     \n    //I get the animation data for the given disk       \n    vec4 anim_data = load0(vec2(float(ball_id)+0.5,1.5));\n    //animation is the animation run time from 0 to 1\n    float animation = anim_data.x;\n    //This light is for the rim lighting of the disks\n    vec2 light = vec2(1.,0.);\n    //I move it around the screen\n    light*=rot(iTime);\n    \n    //metal texture for the disks\n    vec3 tx1 = vec3(texture(iChannel2,(pos)/r/2.)).rgb+0.;\n    \n    //super hacky texture call that allows\n    //me to shift the texture by the circle\n    //position, scale it by the texture radius,\n    //adjust aspect ratio, and ajust the center again\n    float scale = 0.6/r;\n    vec3 tx2 = vec3(texture(iChannel3, \n    ((pos)*scale*rot(iTime))*vec2(iResolution.y/iResolution.x,1.)+0.5\n    )).rgb;\n\n    //the light direction for rim lighting\n    vec2 lightDir = normalize(light - max(pos,EPS));\n    \n    //a light for 3d lighting of the greenish dome\n    vec3 light3 = normalize(vec3(-light*7., 1.));\n    //light direction\n    vec3 ld = normalize(light3-vec3(pos, 0.));\n    //get the hemispherical normal\n    vec3 n = hemiNormal(vec2(0.),pos);\n    //our ray direction looking into the screen\n    vec3 rd = vec3(0.,0.,-1.);\n    //diffuse\n    float diff = max(0., dot(ld,n));\n    //specular\n    float spec = pow(max(0., dot(reflect(-ld, n), -rd)),4.);\n    \n    //shadow circle\n    col = mix(col, vec3(0.0), circle(pos-lightDir*0.1*r,r,20.));\n    //rim lighting circle\n    col = mix(col, silver+dot(pos,-lightDir), circle(pos, r, 1.));\n    //gold outer circle\n    col = mix(col, silver-tx1.x+0.2, circle(pos, r*0.97, 1.));\n    //sin gradient on outer circle\n    col-=SIN(pos,r)/4.;\n    //black inner circle\n    col = mix(col, vec3(0.1), circle(pos, r*0.67, 5.));\n\n    //rotating posision so that every disk's greenish rexture and color\n    //are rotated randomly about it's center\n    pos *= rot(iTime+float(ball_id));\n    //the greenish yellowish color\n    vec3 truCol = mix(vec3(0.45,0.32,0.1)+tx2*0.6,vec3(0.1,0.5,0.4),0.5-pos.y*8.);\n    //a circle with the radius of the dome\n    float inner_C = circle(pos,r*0.6, 1.);\n    //get a blurred circle shape for the lighting on hit\n    float flash = smoothstep(r*0.6+0.02, r*0.6, length(pos));\n    //add the color for the inner dome\n    col = mix(col, truCol+4.*pow(length(pos)-r*0.7, 1.), inner_C); \n   //add the flash with a \n    //glowy color based on the animation scaled from 0 to 0.5\n    col += (0.5-abs(animation-0.5))*flash*vec3(0.59,0.3,0.9)*4.;\n    //add the diffuse and specular lighting to the color\n     col += inner_C*(clamp(diff,0.,1.)*vec3(0.45,0.32,0.1)*5. + clamp(spec,0.,1.)*vec3(0.1,0.5,0.4)*1000.);\n    return col;\n    \n}\n\n\n//a modified truchet pattern function so that\n//I can make dashed lines if cut = 1. instead of solid \nfloat truchet(vec2 st,float edge, float cut){\n    float d;\n    \n    st*=16.;\n    vec2 stFL = floor(st);\n    vec2 stFR = fract(st)-0.5;\n    float id = floor(noise(stFL)*4.)*0.25;\n    \n    float spacing = 0.5;\n    float width = 0.45;\n    stFR *= rot(id*PI);\n    \n    vec2 pos = stFR-spacing;\n    \n    d = abs(length(pos)-spacing) + \n            smoothstep(0.4,0.5,\n            abs(fract(16.*(atan(pos.y,pos.x)+PI)/PI)-0.5))*cut;\n    //only cut if cut == 1\n    pos = stFR+spacing;\n    d = min(d,abs(length(pos)-spacing) + \n            smoothstep(0.4,0.5,\n            abs(fract(16.*(atan(pos.y,pos.x)+PI)/PI)-0.5))*cut\n            );\n    \n    return smoothstep(edge,edge-0.07,d+0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = UVn1;//this is a function in common tab\n    //vignett here so I can use it to shade the truchets\n    vec2 st = fragCoord/iResolution.xy;\n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); \n    \n    //set a soft gradient fro the background\n    vec3 backColor = mix(vec3(0.1,0.0,0.0)*1.5, vec3(0.2,0.15,0.1)*1.5, vig);\n    vec3 col = backColor;\n    //make thin stripes/lines that look raised maybe\n    col += smoothstep(0.2,0.08,abs(fract(uv.x*42.)-0.5))*0.09;\n    //use a truchet pattern to overwrite the lines\n    col = mix(col, backColor*0.95, truchet(fragCoord.xy/iResolution.y,0.35,0.));\n    //add a dotted truchet \n    col = mix(col, vec3(0.2,0.1,0.1)*0.1, truchet(fragCoord.xy/iResolution.y,0.22,1.)*0.8);\n    \n    //add in a second truchet overtop of the dotted one but thinner\n    //two options\n    //col = mix(col, mix(gold,vec3(0.59,0.3,0.9),vig),truchet(fragCoord.xy/iResolution.y, 0.19,1.));\n    col = mix(col, backColor*0.99,truchet(fragCoord.xy/iResolution.y, 0.19,1.));\n    //gamma or something \n    col = pow(col*0.3, vec3(0.5));\n     \n    //loop through all particles and if one is further than a radius*1.2\n    //away we can just skip the f*cker right! \n    for(int i = 0; i < BALL_NUM; i++){\n        if(length(uv-load0(vec2(float(i)+0.5,0.5)).xy) > RADIUS*1.2)continue;\n        col = drawFancyCircle(col, uv, i, fragCoord, uv-load0(vec2(float(i)+0.5,0.5)).xy, RADIUS*0.98);\n    }\n    //more gamma or something\n    col = pow(col, vec3(0.9));\n    fragColor = vec4(col*vig*1.2,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nIMAGE <= For information on the coloring and lighting\n\nBUFFER A <= For information on the particle simulation & animation\n\n\nBUFFER A\n******************************************************\n\nMAIN FEATURES:\n\n\n*/\n\n//a struct for holding ball data during collisio tests\nstruct Ball{\n    int id;\n    float r;\n    vec2 pos;\n    vec2 vel;\n    \n};\n\n\n\n//global collision flag\nfloat collided = 0.;\n\nvec4 wallCollision(inout vec2 pos,inout vec2 vel){\n    //just test if we hit a wall but use ASP since the x axis\n    //is stretched compared to y. (maybe not for all screens I don't know)\n    //if the particle collides with any wall we set teh collision flag to = 1.\n    vec2 tmp = pos + vel;    \n    if(tmp.y + RADIUS > 1.){pos.y = 1.-RADIUS*1.01;vel.y=-vel.y;\n    collided = 1.;}\n    else if(tmp.y-RADIUS < -1.){pos.y = -1.+RADIUS*1.01;vel.y=-vel.y;\n    collided = 1.;}\n    if(tmp.x + RADIUS > ASP){pos.x = ASP-RADIUS*1.01;vel.x=-vel.x;\n    collided = 1.;}\n    else if(tmp.x-RADIUS < -ASP){pos.x = -ASP+RADIUS*1.01;vel.x=-vel.x;\n    collided = 1.;}\n    return vec4(pos,vel);\n    \n}\n//we check if the ball is overlapping any other particle\nvec4 ballOverlap(inout vec2 pos, inout vec2 vel, vec2 fragCoord){\n    int thisID = int(floor(fragCoord.x));\n    \n    for(int i = 0; i < BALL_NUM; i++){\n        \n        if(i == thisID){continue;}//skip when we get the same particle\n        Ball b;\n        \n        //load second particle and create an object to hold it\n        vec4 stuff = load0(vec2(float(i)+0.5,0.5));\n        b.pos = stuff.xy;\n        b.vel = stuff.zw;\n        \n        //check overlapp\n        float dist = length(pos-b.pos);\n        float diff = dist-RADIUS*2.;\n        //if overlap\n        if(diff < 0.){\n            //basically omve things away from each other in the\n            //direction opposite the normal by the amount of overlap\n            float halfDiff = 0.999*(diff);\n            vec2 normal = normalize(pos-b.pos);\n            pos -= normal*halfDiff;\n            //set collided flag\n            collided = 1.;\n\n        }\n    }\n    return vec4(0.);\n}\n\n//check particle collision, \n//This is mostly the same as above, I probably could combine them.\nvec4 ballCollision(inout vec2 pos, inout vec2 vel, vec2 fragCoord){\n    int thisID = int(floor(fragCoord.x));\n    \n    for(int i = 0; i < BALL_NUM; i++){\n        \n        if(i == thisID){continue;}//skip same ball\n        Ball b;\n        vec4 stuff = load0(vec2(float(i)+0.5,0.5));\n        \n        b.r = RADIUS;\n        b.pos = stuff.xy;\n        b.vel = stuff.zw;\n        \n        float dist = length(pos-b.pos);\n        float diff = dist-RADIUS*2.;\n        \n        if(diff < 0.){\n            //if overlap just exchange velocities\n            vel = b.vel;\n            collided = 1.;\n        }\n    }\n    return vec4(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = UV01;\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    //what we do on the very first frame\n    if(iFrame < 1){\n        //if the pixels coordinate is in the region for storing\n        //particle position and velocity informaiton\n        if(fragCoord.x < float(BALL_NUM) && fragCoord.y == 0.5){\n\n            //set it's data to a calculated point on the screen\n            //and a small random velocity between -0.005 and .005 for xy\n            fragColor = vec4(\n            mod(fragCoord.x,floor(2.*ASP/(RADIUS*2.)))*RADIUS*2.-1.*ASP+0.1,\n            1.-RADIUS-floor(fragCoord.x/floor(2.*ASP/(RADIUS*2.)))*RADIUS*2.,\n            rnd(fragCoord.x+901.)*0.01-0.005,\n            rnd(fragCoord.x)*0.01)-0.005;\n        }\n        //if the pixels coordinate is in the region for storing\n        //particle animation information, set it to 0\n        else if(fragCoord.x < float(BALL_NUM) && fragCoord.y == 1.5){\n            fragColor.x = 0.;\n        }\n        \n   }\n   //if we are beyond the first frame, \n   else{\n       //as long as we are withing the region of the particles, \n       //regardless of which part, get the posision and velocity\n       //(even if it doesn't exist, doesn't really matter\n        if(fragCoord.x < float(BALL_NUM) && fragCoord.y < 3.5){\n            vec2 pos = load0(vec2(fragCoord.x,0.5)).xy;\n            vec2 old_vel = load0(vec2(fragCoord.x,0.5)).zw;\n            //save access to the old velocity since the new one will\n            //change\n            vec2 vel = old_vel;\n            \n            //we send the velocity through collisions with particles\n            //and with walls, as well as checking for overlaps\n            ballCollision(pos,vel,fragCoord);;\n            ballOverlap(pos,vel,fragCoord);\n            wallCollision(pos,vel);\n            //after all that we have a final velocity whcih we \n            //add to position\n            pos += vel;\n            \n            //now, if our pixels position is on the pos and vel of the\n            //particle, we can now update\n            if(fragCoord.y == .5){\n                fragColor = vec4(pos,vel);\n            }\n            //otherwise, if the pixel is over the animaton segment\n            //for a given particle, we do the animation stuff\n            else if(fragCoord.y == 1.5){\n                //get collision data to know if are already reacting\n                //to a collision or not\n                vec2 col_data = load0(vec2(fragCoord.x,1.5)).xy;\n                //get animaiton data to know where we are in an animation\n                //if we are in one at all.\n                vec2 anim_data = load0(vec2(fragCoord.x,1.5)).zw;\n                \n                //if collided but it was a while ago, reset\n                if(col_data.y == 1. && (iTime-anim_data.x) > DURATION){\n                \n                    fragColor = vec4(0.,0.,0.,atan(vel.x,vel.y));\n                    //store current angle so in image both old and new\n                    //are the same\n                    \n                }\n                //new collision, set flag to 1 and set start time\n                else if(collided == 1. && col_data.y == 0.){\n                    \n                    fragColor.x = col_data.x;\n                    fragColor.y = 1.;//collision now = 1 (true)\n                    fragColor.z = iTime;//the time of the collision \n                    //this was used for rotating arrows in Image\n                    //it's unused right now.\n                    fragColor.w = atan(old_vel.x,old_vel.y);\n                    //store old angle so in main we can animnate betwen\n                    //old and new current angle.\n                    \n                }    \n                //if already collided, update animation\n                else if(col_data.y == 1.){\n                    //just update how far we are in the animation\n                    //from 0 to 1.\n                    fragColor.x = (iTime-anim_data.x) / DURATION;\n                    //everything else is just refreshing\n                    fragColor.y = col_data.y;//refresh collision flag\n                    fragColor.z = anim_data.x; //refresh ( I think always 0)\n                    fragColor.w = anim_data.y; //refresh angle\n                \n                }\n                //if nothing happened just refresch all\n                else if(collided == 0. && col_data.y == 0.){\n                    fragColor.x = col_data.x;\n                    fragColor.y = col_data.y;\n                    fragColor.z = anim_data.x;\n                    fragColor.w = anim_data.y;\n                }\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define RADIUS 0.14\n#define PI 6.2831 \n#define silver vec3(255., 204., 206.)/255.\n#define gold vec3(215., 154., 15.)/205.\n#define EPS 0.001\n#define BALL_NUM 50\n#define UV01 fragCoord/iResolution.xy\n#define UVn1 (fragCoord*2.-iResolution.xy)/iResolution.y\n#define ASP  iResolution.x/iResolution.y\n#define DURATION .6\n#define load0(f) texture(iChannel0,f/iResolution.xy)\n#define load1(f) texture(iChannel1,f/iResolution.xy)\n#define load2(f) texture(iChannel2,f/iResolution.xy)\n#define load3(f) texture(iChannel3,f/iResolution.xy)\n\n#define GAME_STATE_ADDRESS vec2(0.5,0.)\n\n#define PARTICLE_NUM 10.\n\nfloat rnd(float a){\n    return fract(sin(a*235.512)*5421.74);\n}\n\nfloat rnd2(vec2 a){\n    return fract(sin(dot(a,vec2(11.75,74.94)))*5421.74);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}