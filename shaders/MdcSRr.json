{
    "Shader": {
        "info": {
            "date": "1457309194",
            "description": "A little study/explanation on randomly parameterized repetition. Very simple, yet very useful.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdcSRr",
            "likes": 22,
            "name": "ParameterizedRepetition",
            "published": 3,
            "tags": [
                "repetition",
                "randomized",
                "parameterization"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 848
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Nov 2013\n// Modified : Jan 2016\n//\n// A little study/explanation on randomly parameterized repetition.\n// On ShaderToy, this little trick is used virtually everywhere, all the time, by everyone :P.\n// \n// The idea is to cheaply create variety, by altering the parameters of a repeated item.\n// Now, in order to achieve this, you might want to :\n//   1) Partition space into cells.\n//      The simplest way to do this is probably to use cartesian coodinates, but it could \n//      be done some other way (e.g. polar grid). Within each cell, you will need to calculate \n//      the local space. For example, you could divide a 256x256 image into a grid of 16x16 pixels,\n//      where each cell would have internal coordinates ranging from [0,0] to [16,16].\n//      (You can use the scale of your choice or normalize, as long as you stay consitent).\n//   2) Get a \"random seed\" for your cell.\n//      This random seed should not change within the boundary of the cell, in order for parameters\n//      based on this to be consistent. Indeed, to create variety, this value should also be unique\n//      to your cell, or a least different from the surrounding cells.\n//\n//  See createCell() below, where for a given world position, a fract-based repetition cell is created.\n//\n// License : Creative Commons Non-commercial (NC) license\n\nconst float SQUARE_SIZE = 0.03;\nconst float MAX_STRETCH = 0.05;\nconst float COUTOUR_WIDTH = 0.0004;\n\nvec2 noise_01(vec2 p, float fTime)\n{\n    return texture(iChannel0,fTime+p/64.0,-100.0).xy;\n}\n\n//This function returns the distance of point \"p\" to a box of size \"dim\".\nfloat boxDist(vec2 p, vec2 dim)\n{\n    vec2 d = abs(p)-dim;\n    return min(max(d.x,d.y),length(d));\n}\n\n//This function returns the distance of point \"p\" to a sphere of radius \"rad\".\nfloat sphereDist( vec2 p, float rad )\n{\n  return length(p)-rad;\n}\n\n//This function returns the distance of point \"p\" to a blend between 2 shapes.\n//p: the point from which we want to know the distance\n//origin : the origin of the shape\n//boxSize,circleRad : object size parameters\n//interpolation : [0,1] morph value between box and sphere.\nfloat shapeDist( vec2 p, vec2 origin, vec2 boxSize, float circleRad, float shapeInterpolation)\n{\n    float d1 = boxDist(   p-origin,boxSize);\n    float d2 = sphereDist(p-origin,circleRad);\n    return mix(d1,d2,clamp(shapeInterpolation+sin(iTime/2.0),0.,1.));\n}\n\n//A repetition cell. It is a momentaty representation, valid for a single sample only.\nstruct Cell\n{\n    vec2 worldSample; //World-Space sample position\n    vec2 localSample; //Local-Space sample position (which allows repetition)\n    vec2 size;   //CellSize\n    vec2 center; //CellCenter (random Seed)\n};\n    \n//Divides the space into cells, computes the internal sample position & seed position (center)\nCell createCell(vec2 pWorld, vec2 cellSize)\n{\n    //First, split the space in a cartesian grid and find the local coordinates\n    vec2 p = pWorld/cellSize; //Scale Normalization\n    p = fract(p+0.5)-0.5;     //Unit fract\n    vec2 pLocal = p*cellSize; //Rescale to original size\n    \n    Cell cell;\n    cell.worldSample = pWorld; //External sample coordinates\n    cell.localSample = pLocal; //Internal sample coordinates\n    cell.size = cellSize;\n    cell.center = pWorld-pLocal; //The cell center / random seed\n    return cell;\n}\n\n#define sin01(v) (0.5+0.5*sin(v))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy)/iResolution.xx;\n    vec2 p = uv;\n    \n    //The margin allows movement within the cell. Anything exceeding the cell boundary\n    //will be \"cut\", therefore the margin must be respected.\n    //In this example, the margin size is animated horizontally and vertically, stretching\n    //the cell.\n    vec2 marginSize = MAX_STRETCH*vec2(sin01(iTime),sin01(iTime+2.0));\n    vec2 cellSize   = SQUARE_SIZE+marginSize;\n    \n    //Compute the cell properties (internal position, random seed)\n    Cell cell = createCell(p, cellSize);\n    \n    //Get some random values, using the cell seed (center)\n    float slowNoise = noise_01(cell.center, iTime*0.001).x;\n    vec2 fastNoise = noise_01(cell.center, iTime*0.01);\n    \n    //Randomize some parameters:\n    //1) Jitter object position, always within our safe margin\n    vec2  param_ObjectPos = marginSize*0.9*(-0.5+fastNoise);\n    //2) Ramdomize object type (box/circle)\n    float param_ShapeType = slowNoise;\n    \n    //Compute distance to shape\n    float dist = shapeDist(cell.localSample, param_ObjectPos, vec2(SQUARE_SIZE/2.0), SQUARE_SIZE/3.5, param_ShapeType);\n    \n    //3) Randomize object color\n    vec3 cellColor = vec3(0);\n    if(dist<0.)\n    {\n        float textureTranslation = iTime*0.01;\n        cellColor = texture(iChannel0,textureTranslation+cell.center/32.0,-100.0).xyz;\n    }\n        \n    //Draw a white line where the distance to the object boundary is unferior to our contour width\n    float lineAlpha = smoothstep(abs(dist),0.,COUTOUR_WIDTH);\n    vec3 cFinal = mix(vec3(1),cellColor,lineAlpha);\n    \n\tfragColor = vec4(cFinal,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}