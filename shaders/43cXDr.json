{
    "Shader": {
        "info": {
            "date": "1718891445",
            "description": "exploring some more ideas with chained reaction diffusion systems",
            "flags": 32,
            "hasliked": 0,
            "id": "43cXDr",
            "likes": 4,
            "name": "reaction diffusion experiment 5",
            "published": 3,
            "tags": [
                "reactiondiffusion"
            ],
            "usePreview": 0,
            "username": "ufffd",
            "viewed": 94
        },
        "renderpass": [
            {
                "code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    \n    // fetch buffers\n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n    vec4 buffC = texture(iChannel3,uv);\n\n    // debug\n    if (DEBUG==1)\n        fragColor = 1.-buffA;\n    if (DEBUG==2)\n        fragColor = 1.-buffB;\n    if (DEBUG==3)\n        fragColor = buffB - buffA;\n    if (DEBUG==4)\n        fragColor = vec4(buffB.ab, buffA.ab);\n    if (DEBUG!=0) return;\n\n    vec3 col = buffC.rgb;\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"expanding\"\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.025;\n            if (i>1||j>1) factor = 0.025;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 0.95;\n    float dB = .2;\n    float feed = 0.05;\n    float k = 0.06;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (fragCoord*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 offset = vec2(0.);\n    uv = ((uv - 0.5)*0.997 + 0.5);\n    fragColor.ab = setAB(uv-offset,cdist);\n    \n    fragColor *= 0.999 - 0.002*(1.-texture(iChannel1,uv).b);\n    fragColor *= 1. - length(uvc)*.005;\n    \n    if (iMouse.z > 0.5 && mdist<0.1) { \n        fragColor.b = 1.; \n        fragColor.a = 0.; \n    }\n    \n    // init animation\n    if (iMouse.z < 0.00001) {\n        for (int i=-1;i<2;i+=2) {\n            vec2 p = vec2(0.,.5*float(i));\n            p *= rot(iTime/3.);\n            p += vec2(0.,0.4)*rot(-iTime);\n            float pdist = distance(uvc, p);\n            if (pdist < .1+sin(iTime*1.6)*.05) {\n                fragColor.b = 1.;\n                fragColor.a = 0.;\n            }\n        }\n    }\n    \n    if (fragColor.b < -9.) {\n        fragColor.b = .5;\n        fragColor.a = 0.;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"condensing\"\nvec2 laplacianAB(in vec2 xy) {\n    vec2 sum = vec2(0.);\n    vec2 px = 1./iResolution.xy;\n    px *= 1.;\n    int range = 1;\n    for (int i=-range;i<range+1;i++){\n        for (int j=-range;j<range+1;j++){\n            vec2 offset = vec2(float(i),float(j))*px;\n            float factor = 0.05;\n            if (i==0||j==0) factor = 0.2;\n            if (i==0&&j==0) factor = -1.;\n            if (i<-1||j<-1) factor = 0.02;\n            if (i>1||j>1) factor = 0.02;\n            sum += texture(iChannel0,xy+offset).ab*factor;\n        }\n    }\n    return sum;\n}\n\nvec2 setAB(in vec2 xy, in float cdist) {\n\n    float dA = 1.1;\n    float dB = .35;\n    float feed = 0.055;\n    float k = 0.059;\n\n    float a = texture(iChannel0,xy).a;\n    float b = texture(iChannel0,xy).b;\n    vec2 lapAB = laplacianAB(xy);\n    return vec2(\n        a +\n        dA * lapAB.x -\n        a * b * b +\n        feed * (1. - a),\n        b +\n        dB * lapAB.y +\n        a * b * b -\n        (k + feed) * b\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // skip the edges to avoid artifacts\n    bool tRow = R.y-fragCoord.y<1.5;\n    bool bRow = fragCoord.y<1.5;\n    bool lRow = R.x-fragCoord.x<1.5;\n    bool rRow = fragCoord.x<1.5;\n    if (tRow||bRow||lRow||rRow) {fragColor = vec4(0.);return;}\n    // set up uvs\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    vec2 uvc = (fragCoord*2. - R.xy)/R.y;\n    vec2 muvc = (iMouse.xy*2. - R.xy)/R.y;\n    vec2 uvcPolar = toPolar(uvc);\n    \n    float mdist = distance(uvc,muvc);\n    float cdist = length(uvc);\n    \n    vec2 px = 1./iResolution.xy;\n\n    /* \n       slime stacking:\n       this works by comparing mipmaps at the current location vs \n       a location below to get a \"slime differential\" (?).\n       this was coded by feel, I think this general method could \n       be tuned to be more interesting or \"realistic\"\n   */\n    float drip_speed = 1.;\n    vec2 look_below = vec2(0,.05);\n    look_below.x += noise(vec3(uvc,iTime))*px.x; // fuzz \"left\" and \"right\" slightly\n    look_below *= rot(uvcPolar.y);\n    // check how much \"slime\" is \"below\" (towards center)\n    float slime_below = texture(iChannel0, uv-look_below, 4.).a;\n    // wider \"slime\" check\n    slime_below += texture(iChannel0, uv-look_below*2., 8.).a;\n    // negative check within current space - to avoid slime columns\n    slime_below /= .2+.8*texture(iChannel0, uv, 4.).a;\n    slime_below = smoothstep(2.,.5,slime_below);\n    fragColor.r = slime_below/2.; // debug\n    drip_speed *= 1.-slime_below;\n    // slow down at the center\n    drip_speed *= smoothstep(0.02,0.5,uvcPolar.x);\n    drip_speed *= .5-texture(iChannel1,uv).b;\n    // drip\n    float xoffset = -uvc.x*px.x;\n    uv += vec2(\n        drip_speed*px.y,\n        mix(0., xoffset, slime_below)\n    ) * rot(uvcPolar.y);\n    \n    vec2 buffA = texture(iChannel1,uv).ab;\n    \n    fragColor.ab = mix(\n        mix(setAB(uv,cdist),vec2(0.),0.001),\n        buffA,\n        (1.-buffA.x)*0.05\n      );\n    if (iMouse.z > 0.5) {\n        if (mdist<0.05) { fragColor.b = 1.; fragColor.a = 0.; }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec2 rotate(vec2 v, float a) {\n    return v * rot(a);\n}\n\nfloat nsin(in float a) {\n    return sin(a)*0.5+0.5;\n}\n\nvec2 toPolar(in vec2 uv) {\n    return vec2(\n        length(uv),\n        atan(uv.y,uv.x)\n    );\n}\n\nfloat brightness(in vec3 col) {\n    return (col.r+col.g+col.b)/3.;\n}\n\n// hashes from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// 3D noise from IQ\n// returns 3D value noise\nfloat noise( in vec3 x ) {\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash33( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash33( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash33( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash33( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash33( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash33( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash33( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash33( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int DEBUG = 0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n    vec2 muv = iMouse.xy/R.xy;\n    \n    // fetch buffers\n    vec4 buffA = texture(iChannel0,uv);\n    vec4 buffB = texture(iChannel1,uv);\n\n    // fragColor = vec4(vec3(1.-texture(iChannel1,uv,5.5).a),1.); return;\n    \n    // if (iMouse.z>0.5 && muv.x<uv.x) {\n    if (uv.x+uv.y<1.) {\n        // fragColor = vec4(buffB.rrr,1.); return;\n    }\n    \n    // debug\n    if (DEBUG==1)\n        fragColor = 1.-buffA;\n    if (DEBUG==2)\n        fragColor = 1.-buffB;\n    if (DEBUG==3)\n        fragColor = buffB - buffA;\n    if (DEBUG==4)\n        fragColor = vec4(buffB.ab, buffA.ab);\n    if (DEBUG!=0) return;\n\n    // colorize\n    vec3 col = buffB.bbb / buffB.aaa;\n    col = smoothstep(0.2,0.9,col);\n    \n    col *= buffA.a;\n    col.b += buffA.b*0.4;\n    col.r += buffA.b*buffA.b*buffA.b*0.8;\n    col.g *= 1.-buffA.b;\n    col -= smoothstep(0.5,0.9,buffA.b);\n    col.b += smoothstep(0.99,1.,buffA.b)*.7;\n    \n    col.r *= .2;\n    col.b *= uv.y;\n    \n    col = 1. - col;\n    col.r *= col.r;\n    col.r *= col.b;\n    col.b *= col.r;\n    col = 1. - col;\n    \n    col = mix(col,texture(iChannel3,uv).rgb,0.99-brightness(col)*.1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}