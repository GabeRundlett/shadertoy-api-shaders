{
    "Shader": {
        "info": {
            "date": "1585556416",
            "description": "Stolen this from here : \nhttps://www.youtube.com/watch?v=GULy4vtkw6w\nhttps://gist.github.com/Chlumsky/44d0dbecd6f263ddc8636e99fe267934\nmaze stolen from here : \nhttps://www.shadertoy.com/view/4scGWf",
            "flags": 32,
            "hasliked": 0,
            "id": "WsXcW2",
            "likes": 4,
            "name": "maze_solver_0",
            "published": 3,
            "tags": [
                "maze",
                "stolen",
                "mazesolving"
            ],
            "usePreview": 0,
            "username": "balkhan",
            "viewed": 370
        },
        "renderpass": [
            {
                "code": "\n/*\nBuffer A contain maze solving\nBuffer B contain the maze\nBuffer image visualize it\noriginal code credited in shader description\n*/\n\n//#define _3D // ugly mapping on a torus\n\nvec4 visualize(vec2 pos);\nvec2 q;\n\nfloat map(vec3 p)\n{\n    q = vec2(length(p.xy)-3., p.z);\n    float ataxy = atan(p.x, p.y)/6.28+.5;\n    float ataqxy = atan(q.x, q.y)/6.28+.5;\n    vec2 tcdtorus = vec2(\n        ataqxy\n        ,\n        ataxy\n        );\n    vec4 textorus = texture(iChannel1, tcdtorus).xyzw;\n    \n    float lq = length(q)-2.7;\n    \n    if( lq < 0.051)\n    {\n//        lq += step(textorus.z, .5)*.125;\n    }\n    \n    return (lq)*1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = f/R;\n    vec2 u = (f - R*.5)/R;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec4 bgd = texture(iChannel1, uv);\n    vec3 vcol = visualize(uv).xyz;\n    col = col;//vec3(max(col.x, col.y));\n    col = max(col, 1.-bgd.xyz*1.);\n    col = (vcol.z > .0 ? vcol : col);\n\n    #ifdef _3D\n    vec3 ro = vec3(.0,.0, -25.);\n    vec3 rd = normalize(vec3(u, 2.));\n    vec3 p;\n    vec2 d;\n    float hit = .0;\n    float t = iTime*.25+1.57;\n    float tt = 1.57*.0;//t*.5 -1.57*.0;\n    float ttt = -3.;\n//    rd.yz = vec2(cos(ttt)*rd.y+sin(ttt)*rd.z, cos(ttt)*rd.z-sin(ttt)*rd.y);\n    for(float a = .0; a < 200.; a++)\n    {\n        p = ro + rd * d.y;\n        p.xz = vec2(cos(t)*p.x+sin(t)*p.z, cos(t)*p.z-sin(t)*p.x);\n//        p.yz = vec2(cos(tt)*p.y+sin(tt)*p.z, cos(tt)*p.z-sin(tt)*p.y);\n        d.x = map(p);\n        d.y += d.x;\n        if (d.x < 0.001)\n        {\n            hit = 1.;\n            break;\n        }\n    }\n    col = hit*vec3(1.)*1.;\n    float ataxy = atan(p.x, p.y)/6.28+.5;\n    if (isinf(ataxy) || isnan(ataxy))\n        ataxy = 0.;\n    float ataqxy = atan(q.x, q.y)/6.28+.5;\n    if (isinf(ataqxy) || isnan(ataqxy))\n        ataqxy = 0.;\n    vec2 tcdtorus = vec2(\n        ataqxy\n        ,\n        ataxy\n        );\n    vec3 textorus = texture(iChannel0, tcdtorus).xyz;\n    vec4 bgdt = texture(iChannel1, tcdtorus);\n    vec3 vcolt = visualize(tcdtorus).xyz;\n    textorus = max(textorus, 1.-bgdt.xyz*1.);\n    textorus = (vcolt.z > .0 ? vcolt : textorus);\n    col *= textorus.xyz;\n    #endif\n    fragColor = vec4(col*1.,1.0);\n}\n\nfloat tolerance = 0.0001;\nfloat smoothness = 0.00001;\nvec4 pathColor = vec4(.0, .0, 1.0, 1.0);\n\nvec4 visualize(vec2 pos) {\n    vec4 background = texture(iChannel1, pos);\n    vec4 solution = texture(iChannel0, pos);\n    float pathOpacity = 0.0;\n    if (solution.b > 0.0) \n    {\n        // Evaluate difference from shortest path length\n        float pathDistance = solution.b - 1.0*solution.r*solution.g;\n        pathOpacity = step(pathDistance, .000101);///pathDistance;//smoothstep(tolerance+smoothness, tolerance-smoothness, pathDistance);\n    }\n    return pathOpacity*pathColor;//mix(background, pathColor, pathOpacity);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TAU 6.283185307\n#define DIRECTIONS 4.\n\nvec4 solver(sampler2D self, vec2 pos, float timeDelta) {\n    vec4 local = texture(self, pos);\n    // Update shortest path length\n    local.z = max(local.z, local.x*local.y);\n    // Evaluate neighboring maxima\n    vec4 neighborMax = vec4(0.0);\n    for (float i = 0.; i < DIRECTIONS; ++i)\n    {\n        float a = TAU*(i)/(DIRECTIONS);\n        vec2 neighborPos = pos + (1./iResolution.xy)*vec2(sin(a), cos(a));\n        vec4 neighbor = texture(self, neighborPos);\n        neighbor.rgb *= neighbor.a;\n        neighborMax = max(neighborMax, neighbor);\n    }\n    // Attenuate wave\n    neighborMax.rg *= 4095.0/4096.0;\n    // Update local values\n    local.rgb = max(local.rgb, neighborMax.rgb*local.a);\n    return local;\n}\n\nvec4 initialState(vec2 pos) {\n    vec4 inputt = texture(iChannel1, pos);\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    // Detect starting point\n    if (inputt.g > 0.5 && inputt.r + inputt.b < 1.0)\n        color.g = 1.0;\n    // Detect end point\n    if (inputt.r > 0.5 && inputt.g + inputt.b < 1.0)\n        color.r = 1.0;\n    // Detect boundary\n    if (inputt.r < 0.5 && inputt.g < 0.5 && inputt.b < 0.5)\n        color.a = 0.0;\n    return color;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    if (iFrame < 10)\n//    o = texture(iChannel1, f/iResolution.xy);\n    o = initialState(f/iResolution.xy);\n    else\n    o = solver(iChannel0, f/iResolution.xy, iTimeDelta);\n    o = clamp(o, 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 O,  vec2 U )\n{\n    vec2 u = (U - iResolution.xy*.5)/iResolution.xy;\n    vec2 v = (U )/iResolution.xy;\n    float maze = .251/ fract(.001+   sin(1e6*length (ceil(U/=9.))) < 0.  ? U.x : U.y );\n    O = vec4(0.);\n    O.xyz += maze;\n\n    O.y += step(length(v-vec2(.23*.0+7.5/9., -.35*.0+1.*(1./9.))), .0051)*1.;\n    O.x += step(length(v-vec2(.25, .33)), .0051)*1.;\n//    O=1.-O;\n//    O.y += step(length(u-vec2(.2485, -.230)), .00251)*1.;\n//    O.x += step(length(u-vec2(.21, .24)), .0051)*1.;\n    O.w = 1.;\n//        O.w -= step(.5, maze);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}