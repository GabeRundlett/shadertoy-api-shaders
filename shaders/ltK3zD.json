{
    "Shader": {
        "info": {
            "date": "1473676880",
            "description": "Standard mandelbulb implementation with shadows and numerically approximated normals. I'm playing around with various ways to get the gradient so I might change this if I find an approach that works better. References are IQ's and Syntopia's articles.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltK3zD",
            "likes": 0,
            "name": "Raymarched Mandelbulb ",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "mandelbulb",
                "de"
            ],
            "usePreview": 0,
            "username": "Aspect",
            "viewed": 907
        },
        "renderpass": [
            {
                "code": "vec3 gradient=vec3(0.0);\n\n#define PI 3.1415926535\n#define oversample 0\n#define shadows 1\n\nfloat orbtrap=1.0;\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n\n//from iq's raymarching primitives\n\nvec2 box( vec3 p, vec3 b)\n{\n  //  mat4 rotmat=rotationMatrix(p,10.1*cos(iTime));\n  //  p=(rotmat*vec4(p,1.0)).xyz;\n //   b=b*2.;\n //   p=p*1.0;\n return vec2(length(max(abs(p)-b,0.0))-0.0,-44.0);\n}\n\n\nfloat mandel(vec3 pos)\n{\n    float dr=1.0;\n    pos=rotate(pos,cos(0.35*iTime),sin(0.35*iTime),0.0);\n    pos=pos*1.00;\n    float r=1.0;\n    vec3 zeta= pos;\n    vec3 w=pos;\n    float wr=2.0;\n    vec2 mdb=vec2(0.0);\n    vec3 c= vec3(0.0);\n    orbtrap=1.0;\n    \n    for(int i=0;i<15;++i)\n    {\n      //  w=rotate(w,cos(0.75*iTime),sin(0.75*iTime),0.0);\n      // w=w*(abs(cos(4.*iTime)/24.)+0.8);\n        //c=vec3(cos(iTime),sin(iTime),0.0);\n    orbtrap*=0.95;\n\n            wr=length(w);\n           if(wr*wr>2.)\n        {\n\n             break;\n        }\n          float wo = acos(w.y/wr);\n          float wi = atan(w.x,w.z);\n\n          dr= 8.0*pow(wr,7.0)*dr +1.;\n\n\n          wr = pow( wr, 7. );\n         // wr= wr*r + 10.*wr +1.;\n          wo = wo * 7.;\n          wi = wi * 7.;\n\n        \n          w.x = wr * sin(wo)*sin(wi);\n          w.y = wr * cos(wo);\n          w.z = wr * sin(wo)*cos(wi);\n        \t\n        \n       //  w.x = wr * cos(wo)*cos(wi);\n       //   w.y = wr * cos(wo)*sin(wi);\n       //  w.z = wr * sin(wo);\n        \t\n        \n       //  cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta)\n\n        w+=1.*pos;     \n        \n\n    }\n  return  (1.00*0.5*log(wr)*wr/dr);;\n}\n\n\n\n\n\nfloat distfunc(vec3 pos)\n{  \n  //return min(box(pos,vec3(0.9,0.9,0.9)),mandel(pos));\n  return mandel(pos);\n //   return manDE(pos);\n\n}\n\nvec2 distfunc2(vec3 pos)\n{  \n  return box(pos,vec3(0.5,0.5,1.1));\n//  return mandel(pos);\n //   return manDE(pos);\n\n}\n\n\nvec3 rayMarch2(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 10; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc2(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    for (int i = 0; i < 130; i++)\n    {       \n        if ((dist.x < EPSILON))   continue;   \n        \n        dist.x = distfunc(pos);\n        dist.y=0.;\n        dist.y+=dist.x;\n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\nvec3 shadMarch(vec3 pos,vec3 rayDir,float EPSILON,inout vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 50; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist.x= distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n    }\n    return pos;\n}\n\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nvec3 calculateNormal(float EPSILON, vec3 pos,in vec2 dist)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\nvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n      \t//vec2 eps = vec2(0.0, EPSILON);\n//\tvec3 normal = normalize(vec3(\n  //  distfunc(pos + eps.yxx).x -dist.x,\n  // distfunc(pos + eps.xyx).x - dist.x,\n  //  distfunc(pos + eps.xxy).x - dist.x));\n    \n    return normal;\n}\n\n\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(0.0+0.0*cos(iTime), 0.0+0.0*sin(iTime), 1.25+0.2*cos(iTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(cameraDir,upDirection));\n\tvec3 cameraUp = normalize(cross(cameraRight,cameraDir));\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   //rayDir=normalize(cameraDir+vec3(screenPos,0.0));\n                  \n\n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.0005;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(5.0,5.0,5.0);\n\n    //initial march towards objects\n    vec3 dummypos=pos;\n \tpos=rayMarch2(dummypos,rayDir,EPSILON,dist);\n             if (dist.x <EPSILON)\n        {  \n               vec3 color=vec3(0.0);\n\n        vec2 dist = vec2(EPSILON,0.0);\n\n   \t\t\t pos=rayMarch(pos,rayDir,EPSILON,dist);\n   \t\t\t\t\n            \n            if (dist.x <EPSILON)\n     \t\t\t{  \n\n\t\t\n\n                EPSILON=0.00001;\n\n            // pos=pos-0.0001*rayDir;\n             vec3 normal=calculateNormal(EPSILON,pos,dist);\n\n\n            vec3  lightdir=   normalize(lightpos-pos);  \n            vec3 halfvec= normalize(lightdir-rayDir);\n            vec3 reflected= normalize(reflect(rayDir,normal));\n#if shadows\n\n                 //shadow ray \n            EPSILON=0.005;\n            vec2 shadowdist=vec2(EPSILON,dist.y);\n           vec3 shadowpos=shadMarch(pos+0.01*lightdir,lightdir,EPSILON,shadowdist);\n            if(shadowdist.x<EPSILON)\n            {\n                color=vec3(0.0,0.0,0.0);\n\n            }\n            else\n#endif                \n            {\n\n        \n        \n   \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n       \n    float specular = pow(dot(normal,halfvec), 16.0);\n        \n        \n        // diffuse=1.0;\n      //  specular=1.0;\n  //      vec3 colz=vec3(0.0);\n     //   colz.x=texture(iChannel0,512.*vec2(5.0,5.0)).x;\n    //            colz.y=texture(iChannel0,512.*vec2(415.0,315.0)).y;\n   //     colz.z=texture(iChannel0,512.*vec2(125.0,625.0)).z;\n\n//            color = vec3(colz*(diffuse + specular));\n\n   // color = vec3(vec3(0.15*fbm(pos*cos(iTime)),0.24*fbm(ScreenPos.xyx*sin(iTime)),0.55*fbm(pos))*(diffuse + specular)*2.1);\n     \n          //  color = vec3(vec3(0.2*noise(pos.xy*cos(iTime)),0.34*noise(ScreenPos.xy*sin(iTime)),0.55*noise(pos.xy))*(diffuse + specular)*14.1);\n\n  \t\t\t color = vec3(vec3(0.1,0.24,0.55)*(diffuse + specular));\n               // color*=orbtrap;\n\n    \t\t}     \n             return vec4(color, 1.0);\n\n\t\t}\n            \n        \nelse{\n    vec3 bg=vec3(0.0,0.0,0.45);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n    return vec4(bg,1.0);\n}\n        }\n            else{\n                \n                vec3 bg=vec3(0.0,0.0,0.45);\n    bg=exp(-(ScreenPos.x*ScreenPos.x+ScreenPos.y*ScreenPos.y)/abs(2.*(cos(1.0*iTime)+1.55)))*bg;\n    return vec4(bg,1.0);\n            }\n            \n            \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\n \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n     screenPos.x *= iResolution.x / iResolution.y; \n\n    vec2 fc2=fragCoord.xy + vec2(-0.125, -0.375); \n\tvec2 fc3=fragCoord.xy + vec2(+0.375, -0.125);\n\tvec2 fc4=fragCoord.xy + vec2(+0.125, +0.375);\n    vec2 fc5=fragCoord.xy + vec2(-0.375, +0.125);\n    \n     vec2 scpos2=-1.0 +2.0*fc2.xy/iResolution.xy;\n     vec2 scpos3=-1.0 +2.0*fc3.xy/iResolution.xy;\n     vec2 scpos4=-1.0 +2.0*fc4.xy/iResolution.xy;\n     vec2 scpos5=-1.0 +2.0*fc5.xy/iResolution.xy;\n    \n    scpos2.x*=iResolution.x / iResolution.y;\n    scpos3.x*=iResolution.x / iResolution.y;\n    scpos4.x*=iResolution.x / iResolution.y;\n    scpos5.x*=iResolution.x / iResolution.y;\n    \n    \n  \n    fragColor=render(screenPos);\n    \n#if oversample\n   fragColor+=render(scpos2)+render(scpos3)+render(scpos4);\n    fragColor/=4.;\n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}