{
    "Shader": {
        "info": {
            "date": "1542189919",
            "description": "A remake of the checker shadow illusion is an optical illusion published by Edward H. Adelson (MIT, 1995).\n[url]https://en.wikipedia.org/wiki/Checker_shadow_illusion[/url]\nClick to show the proof.\nCode needs cleaning up.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdyfRw",
            "likes": 11,
            "name": "Illusion, Lightness Constancy",
            "published": 3,
            "tags": [
                "illusion"
            ],
            "usePreview": 0,
            "username": "4rknova",
            "viewed": 630
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define ANTIALIASING\n\n#define EPSILON_M\t\t\t0.1\n#define PI\t\t\t\t\t3.14159265359\n#define RADIAN\t\t\t\t180.0 / PI\n#define EPSILON\t\t\t\t0.0001\n\n#define OBJ_ID_BOX          1\n#define OBJ_ID_CYLINDER     2\n\n#define CYLINDER_HEIGHT     4.0\n#define CYLINDER_RADIUS     5.5\n#define CYLINDER_POS        vec3(6.7,6.5,-6.7)\n#define BOX_DIMENSIONS      vec3(12, 1, 12)\n\n#define RMARCH_MAX_STEPS \t128\n#define SMARCH_MAX_STEPS\t64\n#define PENUMBRA_K\t\t\t5.\n\n#define CLEAR_COLOR\t\t\tvec3(0.015,0.020,0.034) // Gamma Corrected\n#define CAMERA_POSITION     vec3(20.0, 25.0, 25.0)\n#define LIGHT_DIRECTION \tvec3(1,.2,-1)\n#define CAMERA_FOV          60.0\n#define AMBIENT             0.35\n\n#define BOX_COLOR           vec3(0.41,0.25,0.1)\n\n#define CHECKER_OFFSET      vec2(2.4,2.47)\n#define CHECKER_SCALE \t\t0.20\n#define CHECKER_LIGHT \t\t1.00\n#define CHECKER_DARK \t\t0.25\n#define CHECKER_VERY_DARK   0.20\n\nvec2 checker(vec2 p)\n{\n    vec2 uv = floor(CHECKER_SCALE * (p.xy - CHECKER_OFFSET));\n    \n    if      (floor(uv.x) ==  0.0 && floor(uv.y) == -2.0) return vec2(0,CHECKER_DARK);\n    else if (floor(uv.x) == -1.0 && floor(uv.y) == -1.0) return vec2(0,CHECKER_DARK);\n    else if (floor(uv.x) == -2.0 && floor(uv.y) ==  0.0) return vec2(0,CHECKER_DARK);\n    else if (floor(uv.x) == -3.0 && floor(uv.y) ==  1.0) return vec2(0,CHECKER_DARK);\n    else if (floor(uv.x) == -2.0 && floor(uv.y) == -1.0) return vec2(1,CHECKER_VERY_DARK);\n    else if (floor(uv.x) == -3.0 && floor(uv.y) ==  0.0) return vec2(1,CHECKER_VERY_DARK);\n    else if (floor(uv.x) == -1.0 && floor(uv.y) == -2.0) return vec2(1,CHECKER_VERY_DARK);\n    else if (floor(uv.x) ==  0.0 && floor(uv.y) == -1.0) return vec2(1,CHECKER_VERY_DARK);\n    else if (floor(uv.x) == -1.0 && floor(uv.y) ==  0.0) return vec2(1,CHECKER_VERY_DARK);\n    else if (floor(uv.x) == -2.0 && floor(uv.y) ==  1.0) return vec2(1,CHECKER_VERY_DARK);\n    \n\treturn mod(uv.x + uv.y, 2.) > 0.\n        ? vec2(0, CHECKER_DARK)\n        : vec2(1,CHECKER_LIGHT);\n}\n\n\nfloat des_cylinder(vec3 p, vec2 h)\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, out Ray r)\n{\n    \n    vec3 p = CAMERA_POSITION;\n\tvec3 t = vec3(0.0, 0.0,  0.0);\n\tvec3 u = vec3(0.0, 1.0,  0.0);\n    \n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * 0.5 * RADIAN)));\n\t\n\tvec3 cd = t - p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\tr.o = p;\n    r.d = normalize(tmat * r.d);\n}\n\n// Returns the distance from the scene geometry\nvec2 scene_distance(vec3 p)\n{\n    float d0 = length(max(abs(p)-BOX_DIMENSIONS,0.0)); // box    \n    vec3 q = p - CYLINDER_POS;\n    vec2  d = abs(vec2(length(q.xz), q.y)) - vec2(CYLINDER_HEIGHT, CYLINDER_RADIUS);\n  \tfloat d1 = min(max(d.x,d.y),-.2) + length(max(d,0.0));\n    \n    return d0 > d1 ? vec2(d1, OBJ_ID_CYLINDER)\n        \t\t   : vec2(d0, OBJ_ID_BOX);\n}\n\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z)).x;\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z)).x;\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON)).x;\n    return normalize(n - d);\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int id, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tvec2 d = vec2(1.,-1.);\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos); // Get the distance.\n\n\t\tif (d.x < EPSILON) {\n\t\t\tp = pos;\n            id = int(d.y);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d.x * r.d;\n\t}\n\t\n\tn = scene_normal(p, d.x);\t\n\treturn d.x < EPSILON;\n}\n\nfloat soft_shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n\t\n\tfloat t = EPSILON_M;\n\t\n\tfor (int i = 0; i < SMARCH_MAX_STEPS; i++) {\n        float d = scene_distance(ro + rd * t).x;\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\treturn 0.0;\n\t\t\tbreak;\n\t\t}\n\t\t\n        res = min(res, PENUMBRA_K * d / t);\n\n        t += d;\n    }\n\n    return res*res;\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nvec3 img(in vec2 uv)\n{\n    Ray r;\n\tgenerate_ray(uv, r);\n\t\n\tvec3 sp, sn, col = CLEAR_COLOR;\n\tint iter = RMARCH_MAX_STEPS;\t\n    int id = -1;\n\tbool res = rmarch(r, sp, sn, id, iter);\n\t\n\tif (res)\n\t{\n\t\tvec4 albedo = (\n            id == OBJ_ID_BOX\n            ? checker(sp.xz).yyyx\n            : vec4(BOX_COLOR,1)\n        );\n\t\t\n        float shadow = soft_shadow(sp, LIGHT_DIRECTION);\n\t\tcol = albedo.xyz;\n        if (albedo.w > 0.) col *= (shadow * (dot(sn, LIGHT_DIRECTION)+.4) + AMBIENT);\n    }\t\n    \n  \n    if (iMouse.z > .5) {\n        float l = df_line(uv, vec2(-0.2,-0.47), vec2(0.06,0.3));\n        if (l < 0.09) col = vec3(CHECKER_DARK);\n    }\n    \n    return pow(col,vec3(1./2.2));\n}\n\nvec3 fxaa(vec2 p)\n{\n    #define RES iResolution.xy\n\n\tfloat FXAA_SPAN_MAX   = 8.0;\n    float FXAA_REDUCE_MUL = 1.0 / 8.0;\n    float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = img(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = img(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = img(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = img(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = img(p);\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (img(p + dir * (1./3. - .5)) +\n        \t\t\t  img(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  img(p + dir * (0./3. - .5)) +\n        \t\t\t  img(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ar = iResolution.x/iResolution.y;\n    vec2 rv  = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (rv * 2.0 - 1.0) * vec2(ar, 1);    \n    \n    vec3 col;\n    \n#ifdef ANTIALIASING\n    col = fxaa(uv);\n#else\n    col = img(uv);\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}