{
    "Shader": {
        "info": {
            "date": "1573575380",
            "description": "a project for Nodevember day 12, “Paper”.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dKSRD",
            "likes": 5,
            "name": "formation",
            "published": 3,
            "tags": [
                "raymarch",
                "paper",
                "origami",
                "nodevember"
            ],
            "usePreview": 0,
            "username": "mahalis",
            "viewed": 412
        },
        "renderpass": [
            {
                "code": "// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nvec3 opRepeatLimited(vec3 p, vec3 spacing, vec3 limit) {\n    return p - spacing * clamp(round(p / spacing), -limit, limit);\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// -----------------\n\nfloat planeDistance(vec3 position) {\n    vec3 wingP = position.xzy * vec3(2.0,1.5,2.0);\n    wingP.x = abs(wingP.x);\n    wingP.z -= 0.3 * wingP.x; // tilt by skewing the space\n    \n    float wingDistance = sdTriPrism(wingP, vec2(1.0,0.02));\n    \n    vec3 bodyP = position.yzx * vec3(4.0,1.5,1.0);\n    \n    float bodyDistance = max(sdTriPrism(bodyP, vec2(1.0, 0.01)), dot(position, vec3(0.0,1.0,0.0)));\n    \n    return min(wingDistance, bodyDistance);\n}\n\nfloat d(vec3 position) {\n    vec3 warpedPosition = position + sin(position.x * 2.0 + iTime * 2.3) * 0.1;\n    return planeDistance(rZ(opRepeat(warpedPosition, vec3(2.0)), cos(iTime * 1.2) * 0.15));\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize((vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x);\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance * 0.4, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(0.3, 0.9, 0.9));\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    const float diffuse = 0.8;\n    vec3 ambience = mix(vec3(0.2,0.25,0.3), vec3(0.2,0.4,0.6), dot(normal, vec3(0., 1., 0.)) * -0.5 + 0.5);\n    const float specular = 0.6;\n    vec3 color = vec3((ndotL * diffuse + pow(ndotH, 2.) * specular) + ambience);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, -0.05, 0.0);\n    vec3 cameraPosition = vec3(0.75,0.6,1.5);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    cameraPosition += iTime * vec3(0.0,-0.2,-1.0);\n    \n    vec4 marchResult = march(cameraPosition, rayDirection, 0.001);\n    vec3 backgroundColor = mix(vec3(0.4,0.75,1.0), vec3(0.2,0.5,0.9), (uv.y + 0.5));\n    if (marchResult.w > 0.0) {\n        fragColor = vec4(backgroundColor, 1.0); // “sky” color\n    } else {\n        vec3 position = marchResult.xyz;\n        float fogDistance = max(0., length(position - cameraPosition) - 4.);\n        vec3 litColor = lightSurface(position, gradient(position, marchResult.w), -rayDirection);\n        \n        fragColor = vec4(mix(litColor, backgroundColor, 1.0 - exp(-fogDistance * 0.1)), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}