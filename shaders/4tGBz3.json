{
    "Shader": {
        "info": {
            "date": "1556950744",
            "description": "an colourful thing",
            "flags": 0,
            "hasliked": 0,
            "id": "4tGBz3",
            "likes": 4,
            "name": "edited thing",
            "published": 3,
            "tags": [
                "color"
            ],
            "usePreview": 0,
            "username": "AKCESSIVE",
            "viewed": 389
        },
        "renderpass": [
            {
                "code": "#define N_DELTA 0.015625\nfloat rand(vec3 n) { \n    return fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin2(vec3 n)\n{\n    vec3 base = floor(n / N_DELTA) * N_DELTA;\n    vec3 dd = vec3(N_DELTA, 0.0, 01.0);\n    float\n        tl = rand(base + dd.yyy),\n        tr = rand(base + dd.xyy),\n        bl = rand(base + dd.yxy),\n        br = rand(base + dd.xxy);\n    vec3 p = (n - base) / dd.xxx;\n    float t = mix(tl, tr, p.x);\n    float b = mix(bl, br, p.x);\n    return mix(t, b, p.y);\n}\n\nfloat perlin3(vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z / N_DELTA) * N_DELTA);\n    vec3 dd = vec3(N_DELTA, 0.0, 0.0);\n    vec3 p = (n - base) / dd.xxx;\n    float front = perlin2(base + dd.yyy);\n    float back = perlin2(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float total = 0.0;\n    float m1 = 1.0;\n    float m2 = 0.1;\n    for (int i = 0; i < 6; i++)\n    {\n        total += perlin3(n * m1) * m2;\n        m2 *= 2.1;\n        m1 *= 0.6;\n    }\n    return total;\n}\n\nfloat cloudAtmosphere(vec2 uv)\n{\n    float n1 = fbm(vec3(uv * 2.0, 0.0));\n    float n2 = fbm(vec3(uv,  1.0) + n1 * 0.05);   \n    float n3 = fbm(vec3(uv, 2.0) + n2 * 0.3);\n    return n3;\n}\n\nfloat nebula1(vec3 uv)\n{\n    float n1 = fbm(uv * 2.9 - 1000.0);\n    float n2 = fbm(uv + n1 * 0.05);   \n    return n2;\n}\n\nfloat nebula2(vec3 uv)\n{\n    float n1 = fbm(uv * 1.3 + 115.0);\n    float n2 = fbm(uv + n1 * 0.35);   \n    return fbm(uv + n2 * 0.17);\n}\n\nfloat nebula3(vec3 uv)\n{\n    float n1 = fbm(uv * 5.0);\n    float n2 = fbm(uv + n1 * 0.15);   \n    return n2;\n}\n\nvec3 nebula(vec3 uv)\n{\n    uv *= 10.0;\n\treturn nebula1(uv * 0.5) * vec3(-5.0, 1.1, 7.0) -\n        \tnebula2(uv * 0.4) * vec3(-3.5, 1.0, 8.0) -\n        \tnebula3(uv * 0.6) * vec3(0.0, 0.0, -1.0);\n        \n}\n\nfloat altitude(vec3 pos)\n{\n    return (cloudAtmosphere(pos.xz * 0.03) + 2.0) * 24.0;\n}\n\nfloat map(vec3 pos, vec3 rd)\n{\n    return (pos.y - altitude(pos)) * 0.7;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 dd = vec3(0.01, 0.0, 1.0);\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    return normalize(vec3(map(pos + dd.xyy, n) - map(pos - dd.xyy, n),\n                          map(pos + dd.yxy, n) - map(pos - dd.yxy, n),\n                          map(pos + dd.yyx, n) - map(pos - dd.yyx, n)));\n                          \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 xy = (fragCoord.xy - iResolution.xy * 0.5)  / size * 2.0;\n    vec3 rayDir = normalize(vec3(xy, 1.0));\n    vec2 uv = xy * 0.5 + 0.5;\n    \n    fragColor = vec4(vec3((nebula(vec3(uv * 5.1, iTime * 0.1) * 0.1) - 1.0)), 1.0);\n    \n    //float ca = cloudAtmosphere(uv) * 0.5;\n    //fragColor = vec4(ca, ca, ca, 1.0);\n    \n    /*\n    vec3 ro = vec3(cos(iTime), 0.0, iTime * 10.0);\n    ro.y = altitude(ro) + 30.0;\n    //vec3 fwd = normalize(-ro);\n    //vec3 ro = vec3(0.0, 10.0, 0.0);\n    vec3 fwd = normalize(vec3(0.0, -10.0, 50.0));\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 left = normalize(cross(fwd, up));\n    vec3 rd = rayDir.x * left + rayDir.y * up + rayDir.z * fwd;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 pos = ro;\n    float stepSize = 1.1;\n    for (int i = 1; i < 50; i++)\n    {\n        //stepSize += stepSize * 0.1;\n        float dist = map(pos, rd);\n        pos += rd * max(dist, 0.0);\n        if (dist < 0.01)\n        {\n            fragColor = vec4(calcNormal(pos) * 0.5 + 0.5, 1.0);\n            break;\n        }\n        pos += rd * max(dist * float(i) / 30.0, 0.0);\n    }\n\t*/\n    //fragColor = vec4(color, 1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}