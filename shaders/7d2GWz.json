{
    "Shader": {
        "info": {
            "date": "1617273395",
            "description": "Double raymarching function to get interesting 'shape inside a shape' effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "7d2GWz",
            "likes": 2,
            "name": "Metaballs Inside",
            "published": 3,
            "tags": [
                "raymarching",
                "metaballs",
                "cube"
            ],
            "usePreview": 0,
            "username": "TimurAB",
            "viewed": 338
        },
        "renderpass": [
            {
                "code": "float _pi = 3.14159265358979;\n\nvec3 hsv_to_rgb (float h, float s, float v)\n{\n    if (s == 0.0) {\n        return vec3(v);\n    }\n    float i = floor(h * 6.0);\n    float f = h * 6.0 - i;\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - f * s);\n    float t = v * (1.0 - (1.0 - f) * s);\n    if (i >= 6.0 || i < 1.0) return vec3(v,t,p);\n    else if (i >= 1.0 && i < 2.0) return vec3(q,v,p);\n    else if (i >= 2.0 && i < 3.0) return vec3(p,v,t);\n    else if (i >= 3.0 && i < 4.0) return vec3(p,q,v);\n    else if (i >= 4.0 && i < 5.0) return vec3(t,p,v);\n    else if (i >= 5.0 && i < 6.0) return vec3(v,p,q);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\nfloat smoothmin (float a, float b, float k) {\n    float h = clamp(0.5 * (1.0 + (a-b)/k),0.0,1.0);\n    return mix(a,b,h)-k*h*(1.0-h);\n}\n\nfloat cubeDist (vec3 point) {\n    vec3 q = abs(point - vec3(0.0)) - 0.8;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sphereDist (vec3 point) {\n    float _t = iTime;\n    vec4 s0 = vec4(sin(_t),-sin(_t),cos(_t), 0.9);\n    vec4 s1 = vec4(0.5,-0.5,0.5, 1.1);\n    float d0 = length(point - s0.xyz) - s0.w;\n    float d1 = length(point - s1.xyz) - s1.w;\n    return smoothmin(d0, d1, 0.5);\n}\n\nvec3 cubeNormal (vec3 p) {\n    vec2 c = vec2(0.01, 0.0);\n    float d = cubeDist(p);\n    return normalize(vec3(\n        d - cubeDist(p - c.xyy),\n        d - cubeDist(p - c.yxy),\n        d - cubeDist(p - c.yyx)\n    ));\n}\n\nvec3 sphereNormal (vec3 p) {\n    vec2 c = vec2(0.01, 0.0);\n    float d = sphereDist(p);\n    return normalize(vec3(\n        d - sphereDist(p - c.xyy),\n        d - sphereDist(p - c.yxy),\n        d - sphereDist(p - c.yyx)\n    ));\n}\n\nvec3 rmcube (vec3 ro, vec3 rd) {\n    vec3 v0 = ro;\n    vec3 dir = rd;\n    float d = cubeDist(v0), total = d;\n    float eps = 0.01, max_dist = 100.0;\n    for(int n = 0; n < 1000; n ++) {\n        dir *= d / length(dir);\n        v0 += dir;\n        d = cubeDist(v0);\n        total += d;\n        if (d < eps || total > max_dist) break;\n    }\n    if (total >= max_dist) v0.x = -1000.0;\n    return v0;\n}\nvec3 rmsphere (vec3 ro, vec3 rd) {\n    vec3 v0 = ro;\n    vec3 dir = rd;\n    float d = sphereDist(v0), total = d;\n    float eps = 0.01, max_dist = 100.0;\n    for(int n = 0; n < 1000; n ++) {\n        dir *= d / length(dir);\n        v0 += dir;\n        d = sphereDist(v0);\n        total += d;\n        if (d < eps || total > max_dist) break;\n    }\n    if (total >= max_dist) v0.x = -1000.0;\n    return v0;\n}\n\nvec3 grayscale (vec3 col) {\n    vec3 g = vec3(0.299, 0.587, 0.114);\n    g = g * col;\n    float c = g.r + g.g + g.b;\n    return mix(vec3(0.0,0.0,c), hsv_to_rgb(fract(iTime * 0.05),1.,1.), 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= aspect;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = 2.0 * mouse - 1.0;\n    float _t = iTime;\n    float a0 = _t, a1 = 0.0;\n    if (iMouse.z > 0.0) {\n        a0 = -1.0 * mouse.x * _pi;\n        a1 = mouse.y * _pi;\n    }\n    vec3 camera = vec3(0.0, 0.0, -2.5);\n    vec3 ro = vec3(uv + camera.xy, 1.0 + camera.z);\n    camera.yz *= rotate2d(a1);\n    camera.xz *= rotate2d(a0);\n    ro.yz *= rotate2d(a1);\n    ro.xz *= rotate2d(a0);\n    vec3 rd = ro - camera;\n\n    vec3 col = 0.5 * vec3(uv.y - a1) + 0.5;\n    vec3 pos = rmcube(ro, rd);\n    if (pos.x != -1000.0) {\n        vec3 norm = cubeNormal(pos);\n        norm = 0.5 * ( 1.0 + norm);\n        col = grayscale(norm);\n        rd = rd + 0.2 * norm;\n        ro = ro + pos;\n        col *= clamp(length(pos + rd)*0.4, .0, 1.0);\n        pos = rmsphere(ro, rd);\n        if (pos.x != -1000.0) {\n            norm = sphereNormal(pos);\n            col = 0.5 * (1.0 + norm);\n            col *= hsv_to_rgb(fract(0.2 * _t), 1., 1.);\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}