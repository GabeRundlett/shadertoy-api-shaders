{
    "Shader": {
        "info": {
            "date": "1597233226",
            "description": "triangular, hexagonal, rectangular tiling",
            "flags": 0,
            "hasliked": 0,
            "id": "ttsfR2",
            "likes": 8,
            "name": "simple tiling",
            "published": 3,
            "tags": [
                "2d",
                "tiling"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 521
        },
        "renderpass": [
            {
                "code": "// triangular, hexagonal, rectangular tiling\n// \n// Colling Patrik, 2020\n//\n\n// const\nconst float PI = 3.14159265359,\n    PI_2 = PI/2., PI_3 = PI/3., PI_4 = PI/4., PI_6 = PI/6.,\n    SQRT2 = sqrt(2.), SQRT_2 = 1./SQRT2,  \n    SQRT3 = sqrt(3.), SQRT_3 = 1./SQRT3;\n\n// 1D-transformations: float => float\nfloat csteps(float x,float b){\n    //centered step, step width b\n    return b*floor((x/b+0.5));\n    }\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);\n    }\nfloat smoothpuls(float x,float b){\n    return smoothstep(abs(b),0.,abs(x));\n    }\n    \n// 2D-transformations: vec2 => vec2\nvec2 rot2(vec2 x,float a){\n    float si = sin(a), co = cos(a);\n    return mat2(co,-si,si,co)*x;\n    }\n\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){  \n    // maps a grid of unit-squares to one unit-square\n    // The unit-square is inside of the unit-circle\n    Z /= SQRT_2;\t// F:scale grid\n    Z_id = floor(0.5*(Z+1.));// global cell offset id (...,-2,-1,0,+1,+2,...)\n    Z = Z-2.*Z_id;// local cell coord's\n    Z *= SQRT_2; // B:scale cell    \n    // symmetries\n    z_sr = signeveodd((Z_id.x+Z_id.y));// sense of rotation of local cell\n    Z.x *= signeveodd(Z_id.x);//mirror x\n    Z.y *= signeveodd(Z_id.y);//mirror y\n    return Z;\n    }\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id, out vec3 U_lo){\n    // maps a hexagonalgrid of unit-hexagons to one unit-hexagon\n    // the unit-hexagon is inside of the unit-circle   \n    // with edge orientation pointing up\n    // using cubic hexagonal coordinates U_id, U_lo\n    // ==> https://www.redblobgames.com/grids/hexagons/\n\t// ==> https://bl.ocks.org/patricksurry/0603b407fa0a0071b59366219c67abca\n    // matrix: unitvectors eu,ev -> ex(red),ez(blue)\n    const mat2 iM = mat2(SQRT3, -SQRT3, -1., -1.)*2./3., M = inverse(iM);\n    Z = iM*Z; // F: cartesian -> 2d-cubic-hex grid-coord's\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y); // 3d-cubic-hex grid-coord's, plane: x+y+z = 0    \n    U_id = floor(0.5*(U+1.)); // global 3d-cubic-hex grid-cell offset id \n    U_lo = U-2.*U_id; // local 3d-cubic-hex cell coord's\n    // correction triangles\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) {\n        U_lo.x = -U_lo.y-U_lo.z;\n        U_id.x = -U_id.y-U_id.z;}\n    if (aU_lo.y > aU_lo.z) {\n        U_lo.y = -U_lo.x-U_lo.z;\n        U_id.y = -U_id.x-U_id.z;}\n    else {\n        U_lo.z = -U_lo.x-U_lo.y;\n        U_id.z = -U_id.x-U_id.y;}\n    return M*U_lo.rb ; // B: local 2d-cubic-hex cell -> local-cartesian cell coord's\n    }\nvec2 hex2tri(in vec2 Z, out float a_id, out float a_cy){\n    // maps 6 triangles inside a unit-hexagon to one unit-triangle\n    // The unit-hexagon is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = rot2(Z,-PI_6); \t\t// orientation adaption  tri2hex ==> hexgrid2hex \n    Z = rot2(Z,PI_3);\t\t// F:orientation-offset of simplex  \n    float a = atan(Z.y,Z.x);   \n    a_id = floor(a/PI_3+0.5);// triangle offset id ((-3),-2,-1,0,1,2,(3))\n    float a_lo = a-PI_3*a_id;\t\t\t// local coord's angle\n    a_cy = signeveodd(a/PI_3);\t\t\t// cycle even +1, odd -1\n    Z = rot2(Z,PI_3*a_id);\t\t\t\t// mape grid-zell to unit-triangle\n    Z = (Z-vec2(SQRT_3,0.))*SQRT3; \t\t// translation,scale unit-triangle\n    Z.y *= a_cy;\t\t\t\t\t\t// y-mirror cyclic\n    return rot2(Z,-PI_3);\t\t\t\t// B:orientation-offset of unit-triangle\n    }\n\n// 2D-transformation-matrix: vec2 => mat2\nmat2 mat2rot(float a){\n    float si = sin(a), co = cos(a);\n    return mat2(co,-si,si,co);\n    }\n\n// inface: vec2 => bool\nbool inudisk(vec2 z){\n    // in unit disk\n\treturn (length(z)<1.);\n    }\nbool inuarrow(vec2 z){\n    // in unit arrow\n    // line\n    bool br = (z.x>-1.) && (z.x<0.9) && (abs(z.y)<0.01); \n    // arrow\n    float lr = length(z-vec2(1.,0.));\n    bool ba\t= (lr<0.2) && (z.x-1.<0.0) && (abs(z.y)<0.3*lr);\n    return br || ba;\n    }\nbool inupoly(vec2 z,int k){\n    const float PI = 3.14159265359;\n    // in unit polygon\n    k = abs(k);\t\t\t//poly-num-edges\n    bool m = true;\t\t//bit-mask    \n    if (k<3) m = false;\n    else{   \n    \tfloat a = PI/float(k);\n    \tfloat h = cos(a);//\n    \tfor (int i=0; i<k; i++){\n        \tfloat a1 = 2.*a*float(i);\n        \tvec2 w = vec2(cos(a1),sin(a1));\n        \tif(dot(w,z)>h) m = false;\n        }\n    }\n    return m;\n    }\n\n// texture: vec2 => vec4\nvec4 texCh2(vec2 z){\n    z = 0.5*(z-1.);//centered texture\n    vec4 tex = textureLod(iChannel2,z,1.0);//color\n    //if (abs(2.*z.x+1.)>1. || abs(2.*z.y+1.)>1.) tex.a = 0.0;//alpha square\n    return tex;\n    }\nvec4 texUnitPolyCh2(vec2 z,int k){\n    return vec4(texCh2(z).xyz,float(inupoly(z,k)));\n    }\nvec4 texUnitGrid(vec2 z){\n    const float b = 0.02;\n    vec3 col = vec3(0.5);\n    if (abs(z.y) < b)  col = 0.8*vec3(1.,0.,0.);\n    if (abs(z.x) < b)  col = 0.8*vec3(0.,1.,0.);\n    return vec4(col,smoothpuls(fract(z.x),b) + smoothpuls(fract(z.y),b));\n    }\nvec4 texUnitCircle(vec2 z){\n    const float b = 0.02; float dr = length(z)-1.;\n    return vec4(vec3(0.9), smoothpuls(dr,b));\n    }\nvec4 texCartesianBase(vec2 z){\n    // pixel_color\n    bool m1 = false, m2 = false;\n    vec3 col = vec3(0.,0.,0.);\n    //color replace condition\t\t\tupdate alpha-bit   color\n    m1 = inuarrow(z);\t\t\t\t\tif(m1){m2 = m2||m1;col=vec3(1.0,0.,0.);}//x\n    m1 = inuarrow(mat2(0.,-1.,1.,0.)*z);if(m1){m2 = m2||m1;col=vec3(0.,1.0,0.);}//y\n    m1 = inudisk(17.*z);\t\t\t\tif(m1){m2 = m2||m1;col=vec3(0.,0.0,1.0);}//z\n    return vec4(col,float(m2));\n    }\nvec4 texHexCubicBase(vec2 z){\n    const float A = sqrt(3.);\n    bool m1 = false, m2 = false;\n    vec3 col = vec3(0.,0.,0.);\n    m1 = inuarrow(.5*mat2(A,1.,-1.,A)*z);\tif(m1){m2 = m2||m1;col=vec3(1.,0.,0.);}//r\n    m1 = inuarrow(mat2(0.,-1.,1.,0.)*z);\tif(m1){m2 = m2||m1;col=vec3(0.,1.,0.);}//g\n    m1 = inuarrow(.5*mat2(-A,1.,-1.,-A)*z);\tif(m1){m2 = m2||m1;col=vec3(0.,0.,1.);}//b\n    m1 = inudisk(30.*z);\t\t\t\t\tif(m1){m2 = m2||m1;col=vec3(1.,1.,0.);}//origin\n    return vec4(col,float(m2));\n    }\n\n// main ////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 O, vec2 uv ){\n    // animation\n    float v = iTime/5.;\n    // transformation pipeline index: tid\n    //Atid: non 0\n    //Btid:,rec 1\t,recgrid2rec 2\t\t\t\t\t\t,recgrid2rec-anim 3\n    //Ctid:,hex 4\t,hexgrid2hex 5\n    //Dtid:,tri 6\t,hex2tri 7\t\t,gridhex2hex2tri 8\t,hexgrid2hex2tri-anim 9\n    \n    //sequences\n    int tid = int(floor(v-9.*floor(v/9.))+1.); // periodic 9 step's +1\n    //int tid = int(floor(v-3.*floor(v/3.))+1.);\t// Btid       \n    //int tid = int(floor(v-2.*floor(v/2.))+3.+1.);\t// Ctid    \n    //int tid = int(floor(v-4.*floor(v/4.))+5.+1.);\t// Dtid\n    //int tid = 2;\n\n\n    // 2Dtransformations\n    // pixel <== viewport\n    vec2 Z = 2.*(2.*uv- iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec2 Z0 = Z; //save for viewport texture\n    \n    \n    vec2 rec_id = vec2(0.);\tfloat rec_cy = 1.;\n    if (tid == 2 || tid == 3){\n        Z = rot2(Z,PI_4);\t\t// F:orientation-offset of grid\n        Z = recgrid2rec(Z,rec_id,rec_cy);\n        Z = rot2(Z,-PI_4);\t\t// B:orientation-offset of cell        \n        }\n    \n\tvec3 hex_id = vec3(0.);\tvec3 hex_lo = vec3(0.); float hex_cy = 1.;\n    if (tid == 5 || tid == 8 || tid == 9){\n        Z = rot2(Z,PI_6); // F:orientation-offset of grid \n        Z = hexgrid2hex(Z, hex_id, hex_lo);\n        Z = rot2(Z,-PI_6);// B:orientation-offset of cell         \n        }\n    \n    float a_id = 0., a_cy = 1.;   \n    if(tid == 7 || tid == 8 || tid == 9){\n        Z = hex2tri(Z, a_id, a_cy);\n        }\n\n\n    // color \n    vec4 tex =vec4(1.);// init alpha = 1.;\n    vec3 col =vec3(0.3,0.3,0.3);//background\n    vec3 P = vec3(1.,1.,1.);//color pattern vector \n    \n    //rec 1, recgrid2rec 2,recgrid2rec-anim 3,    \n    if (tid == 1 || tid == 2 || tid == 3){   \n        // animation\n        vec2 Za = Z; // save\n            if (tid == 3){\n                Z = SQRT2*rot2(Z,2.*PI*v);\t\t// inner circle \n                P *= (0.2*rec_cy+0.8);\t\t\t// modulate pattern vector\n            }\n        // unit-rectangular-texture  \n        Z = rot2(Z,PI_4); \t\t\t// unit-cell pointy in x-direction given\n        tex = texUnitPolyCh2(Z,4); \tcol = mix(col,P*tex.xyz, tex.a);        \n        tex = texUnitCircle(Z); \tcol = mix(col,tex.xyz,tex.a);\n        tex = texUnitCircle(SQRT2*Z);\n        tex.xy *= rec_id/2.;tex.z=0.;col = mix(col,tex.xyz,tex.a);\n        tex = texCartesianBase(Z);\tcol = mix(col,tex.xyz,tex.a); \n        }\n    \n    //hex 4, hexgrid2hex 5,\n    if (tid == 4 || tid == 5 ){\n        // animation\n        //unit-hexagon-texture\n        Z = rot2(Z,PI_6); \t\t\t// unit-cell pointy in x-direction given\n        tex = texUnitPolyCh2(Z,6); \tcol = mix(col,tex.xyz,tex.a);\n        tex = texUnitCircle(Z);     col = mix(col,tex.xyz,tex.a);        \n        tex = texUnitCircle(2./sqrt(3.)*Z);\n        tex.xyz *= hex_id/2.;       col = mix(col,tex.xyz,tex.a);\n        tex = texHexCubicBase(Z);\tcol = mix(col,tex.xyz,tex.a);\n        }\n    \n    //tri 6, hex2tri 7,hexgrid2hex2tri 8,hexgrid2hex2tri-anim 9,\n    if (tid == 6 || tid == 7 || tid == 8 || tid == 9){   \n\t// animation\n        if (tid >= 7 || tid == 8){\n            //float d = a_id/PI_3+3.;d/=6.;\n            // ((-3.),-2.,-1,0,+1,+2,(+3)) ==> (0,1,2,3,4,5)\n            float d = (a_id/PI_3+3.);if(d>5.)d=0.0;d/=5.;\n            P *= (0.2+d*0.8);}// modulate pattern vector\n        //if (tid == 8){}\n    \tif (tid == 9){\n            //P *= 0.3*a_cy+0.7;\n        \tZ = 2.*rot2(Z,2.*PI*v);// inner circle\n    \t}\n        // unit-triangle-texture    \n        Z = rot2(Z,PI_3); \t\t\t// unit-cell pointy in x-direction given\n        tex = texUnitPolyCh2(Z,3);\tcol = mix(col,P*tex.xyz, tex.a);\n        tex = texCartesianBase(Z); \tcol = mix(col,tex.xyz,tex.a);\n        tex = texUnitCircle(Z);\t\tcol = mix(col,tex.xyz,tex.a);  \n        }  \n\n    // viewport-texture\n    //tex = texCh2(Z); col = mix(col,tex.xyz,tex.a);// TEST:texture\n    tex = texUnitGrid(Z0); col = mix(col,tex.xyz,tex.a);\n    // return color\n    \n    O = vec4(col,1.);\n    }\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}