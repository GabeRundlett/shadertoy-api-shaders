{
    "Shader": {
        "info": {
            "date": "1545497487",
            "description": "2-edge Wang Tiles\n\nMake sure to also check out my other dabbles at circuit-board type-of patterns:\nhttps://www.shadertoy.com/view/XdSGz1",
            "flags": 0,
            "hasliked": 0,
            "id": "Wds3z7",
            "likes": 47,
            "name": "2-edge Wang Tiles",
            "published": 3,
            "tags": [
                "tiling",
                "maze",
                "wang",
                "generation"
            ],
            "usePreview": 0,
            "username": "srtuss",
            "viewed": 1432
        },
        "renderpass": [
            {
                "code": "// srtuss, 2018\n//\n// implementation of 2-edge Wang Tiles, as described here:\n// http://www.cr31.co.uk/stagecast/wang/2edge.html\n\n// #define SHOW_GRID\n\n\nfloat k = .1;\n#define K2 ((1. - k) / 2.)\n#define K3 (sqrt(2.) * .5 - K2)\n\nfloat tile0(vec2 uv)\n{\n    float v = length(uv) - K3;\n    float w = K2 - length(vec2(abs(uv.x) - .5, uv.y - .5));\n    return v = mix(v, w,\n                   //smoothstep(.1, -.1, abs(uv.x) - uv.y)\n                   step(abs(uv.x), uv.y)\n                  );\n}\n\nfloat tile1(vec2 uv)\n{\n    return abs(length(uv - .5) - .5) - k * .5;\n}\n\nfloat tile2(vec2 uv)\n{\n    return abs(uv.x) - k * .5;\n}\n\nfloat tile3(vec2 uv)\n{\n    return max(-uv.x - k * .5, K2 - length(vec2(uv.x - .5, abs(uv.y) - .5)));\n}\n\nfloat tile4(vec2 uv)\n{\n    return K2 - length(vec2(abs(uv.x) - .5, abs(uv.y) - .5));\n}\n\nfloat tile(vec2 uv, int tile)\n{\n    switch(tile)\n    {\n        case 0: return 1.414;\n        case 1: return max(tile0(uv), .15 - length(uv));\n        case 2: return tile0(uv.yx);\n        case 3: return tile1(uv);\n        case 4: return tile0(vec2(uv.x, -uv.y));\n        case 5: return tile2(uv);\n        case 6: return tile1(vec2(uv.x, -uv.y));\n        case 7: return tile3(uv);\n        case 8: return tile0(vec2(uv.y, -uv.x));\n        case 9: return tile1(vec2(-uv.x, uv.y));\n        case 10: return tile2(uv.yx);\n        case 11: return tile3(uv.yx);\n        case 12: return tile1(vec2(-uv.x, -uv.y));\n        case 13: return tile3(vec2(-uv.x, uv.y));\n        case 14: return tile3(vec2(-uv.y, uv.x));\n        case 15: return tile4(uv);\n    }\n}\n\n// \"Hash without Sine\" - borrowed from Dave Hoskins's shader\n// https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat map(vec2 uv)\n{\n    int b = 0;\n    uv += .5;\n    vec2 id = floor(uv);\n    if(hash(id) >= .5)\n        b += 1;\n    if(hash(-id) >= .5)\n        b += 8;\n    if(hash(id - vec2(0., 1.)) >= .5)\n        b += 4;\n    if(hash(-(id + vec2(1., 0.))) >= .5)\n        b += 2;\n\n    return tile(fract(uv) - .5, b);\n}\n\nvec2 rotate(vec2 uv, float a)\n{\n    float co = cos(a);\n    float si = sin(a);\n    return uv * mat2(co, si, -si, co);\n}\n\nfloat height(vec2 uv)\n{\n    float r = map(uv) - .1;\n    return sqrt(.01 - min(r * r, .01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = rotate(uv, iTime * .1);\n    vec3 rd = normalize(vec3(uv, 1.66));\n    \n    float scale = 5. + sin(iTime * .5);\n    \n    uv *= scale;\n    uv += iTime;\n    \n    \n    //k = sin(uv.x * 10.) * .04 + .1;\n    \n    vec2 h = vec2(.01, 0.);\n    float v = map(uv);\n    float c0 = height(uv);\n    float c1 = height(uv + h.xy);\n    float c2 = height(uv + h.yx);\n    \n    vec3 color = vec3(1., 1., 1.) * smoothstep(0., 4. / iResolution.y, min(v, abs(v - .2) - .01) / scale);\n    \n    //v = map(uv - .04);\n    //s *= .5 + .5 * smoothstep(0., 4. / iResolution.y, min(v, abs(v - .2) - .01) / scale);\n    \n#ifdef SHOW_GRID\n    v *= smoothstep(0., 2. / iResolution.y, min(abs(fract(uv.x) - .5), abs(fract(uv.y) - .5)) / scale);\n#endif\n\n    vec3 normal = normalize(vec3(c0 - c1, h.x, c0 - c2));\n    vec3 bounce = reflect(rd, normal);\n    \n    vec3 lightDir = normalize(vec3(-.5, .5, .1));\n    \n    color *= dot(normal, lightDir);\n    \n    color *= mix(vec3(1., .7, .5), vec3(.2, .5, 1.), smoothstep(0., 2. / iResolution.y, min(v, abs(v - .1) - .1) / scale));\n    \n    color *= texture(iChannel0, bounce).xyz;\n    \n    color *= 3.;\n    \n    color = sqrt(color);\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}