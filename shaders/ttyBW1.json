{
    "Shader": {
        "info": {
            "date": "1614249155",
            "description": "Breakdown of Yusef28's lens flare shadertoy with some minor changes and tidying of the code for clarity. Customizing the look of the flare is possible by editing values in the 'LensHighlight()' function.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttyBW1",
            "likes": 6,
            "name": "Yusef28's lens flare examined",
            "published": 3,
            "tags": [
                "lensflare"
            ],
            "usePreview": 1,
            "username": "jstrom2002",
            "viewed": 626
        },
        "renderpass": [
            {
                "code": "// Based on an OpenGL implementation of Yusef28's code.\n// Yusef28's ' Circle & Polygon Lens Flare' shadertoy: https://www.shadertoy.com/view/Xlc3D2\n// This shadertoy is a work-in-progress.\n\n// Uniforms. Hardcoded for this shadertoy, pass in vals for your impl.\nint MAX_ITERATIONS = 4;\nvec3 cameraPosition = vec3(0.0);\n//vec3 lightPosition;//replace local var in 'mainImage()' w/ your uniform here\nvec3 lightColor = vec3(1.0);\nmat4 viewProjection;//Unused in shadertoy, use in your 3D impl.\n\n// Tweakable uniforms\nfloat lensFlareExposure = 1.0;\nfloat lensFlareBrightness = 1.0;\nfloat lensFlareScale = 0.175;\nfloat lensFlareFade = 1.0;//fades over 3D position between light and camera, unused for this shadertoy\n\n\n\nvec3 modelToScreen(vec3 v){//Unused in shadertoy, use in your 3D impl.\n\tvec4 v_2 = viewProjection * vec4(v,1.0);\n\tv_2.xyz = v_2.xyz / v_2.w;//to NDC\n\treturn vec3(v_2.xy * 0.5 + 0.5, v_2.z);//to [0,1]\n}\nfloat rnd(float w){\n    //Use bluenoise texture for fast lds random values in range [0,1]\n    return texture(iChannel0, vec2(w)).r;\n}\n\nfloat regularPolygon(vec2 p, int N){// Produces a regular polygon defined by N points on the unit circle.\n    float a=atan(p.x,p.y)+.2;\n    float b=6.28319/float(N);\n    return smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));        \n}\n\nfloat renderSmallCircle(vec2 pos, vec2 ltpos, float dist, vec2 offsetFromCenter, float size)\n{\n\tvec2 coord = pos - ltpos * dist/2.0 + offsetFromCenter;\n\tfloat radiusVal =  0.04 / length(coord)*size;\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\n}\n\nfloat renderBigCircle(vec2 pos, vec2 ltpos, float dist, vec2 offsetFromCenter, float size)\n{\n\tvec2 coord = pos + ltpos*dist + offsetFromCenter;\n\tfloat radiusVal =  0.01 - pow(length(coord), size * 1.4);\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\t\n}\n\nfloat renderRing(float r, float offsetFromCenter, float fade)\n{\n\tfloat radiusVal = 0.001 - pow(r - offsetFromCenter, 1.0/fade) + sin(r * 30.0);\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\t\n}\n\nfloat renderHexagon(vec2 uv, vec2 lightPos, vec2 offsetFromCenter, \n\tfloat hexagonIntervalDist, float size)\n{\n\tconst int hexagonPoints = 6;\n\tvec2 hexagonCoord = uv*size + lightPos*hexagonIntervalDist*size + offsetFromCenter;\n\tfloat hexValue = 0.01 - regularPolygon(hexagonCoord, hexagonPoints);\n   \thexValue = max(hexValue, 0.0);//filter negative vals.\n\treturn hexValue;\n}\n\nvec3 chromaticAberration(vec3 color, vec2 pos, vec2 ltpos, int iter)\n{   // NOTE: This function still needs some work.\n\n\tconst float intensity = 0.075;//adjust as needed.\n\tfloat amount = intensity * length(pos-ltpos) * \n\t\trnd(float(iter)*0.713) * float(iter);\t\n\n\t// Rotate which channels are being offset per iteration (i).\n\tvec3 cyclic_amt = (vec3(-0.95,-0.98,-1.0) + amount * \n\t\tvec3(iter%3,(iter+1)%3,(iter+2)%3));//vec3 of ints ranged [-1,1]\n\n    vec3 col = color + cyclic_amt;\n\treturn col * (1.0 - amount * 0.5);\n}\n\n// 'LensHighlight()' -- Generates 4 lens artifacts: a single large circle, small circle, ring, and hexagon.\n// Params:\n// pos: current fragment's screen-space position\n// lightPos: light's screen-space position\n// color: base color of highlight\n// size: size of lens highlight diameter\n// dist: distance between lens flare highlights in screen space\nvec3 LensHighlight(vec2 pos, vec2 lightPos, vec3 color, float size, float dist, int i)\n{   \n    // Create a big circle, ring, small circle, and hexagon and control blending with a vec4.\n\tconst vec4 blend_val = 0.01 * vec4(2500.0, 20.0, 1.50, 2000.0);//adjust as necessary per-object.\n\t\n    float bigCircle_size = size * 0.2 * float(i);\n    vec2 bigCircle_offset = -lightPos * vec2(2.0);\n    float bigCircle = renderBigCircle(pos,lightPos,dist,bigCircle_offset, bigCircle_size) * blend_val.x;    \n    \n    float ring_fade = 7.0 * float(i);\n\tvec2 ring_offset = \n        //vec2(0.0);//<== rings around light source.\n        -lightPos * vec2(2.5) * float(i);//<== ring halos in light ray.\n    float ring_size = size * 5.0 * float(i);\n    float lt_coord = length(pos - lightPos - ring_offset);\n    float ring_radius  = lt_coord + ring_size; \n\tfloat ring = renderRing(ring_radius, ring_size, ring_fade) * blend_val.y;   \n\n\tvec2 smallCircle_offset = lightPos * vec2(0.0159);\n    float smallCircle_size = 84.0;\n\tfloat smallCircle = renderSmallCircle(pos,lightPos,dist,smallCircle_offset, smallCircle_size) * blend_val.z;\n    \n    // Draws hexagons in order closest to light to farthest.\n\tvec2 hexagon_offset = -lightPos * vec2(1.5) * float(i) + lightPos * 0.32;\n\tfloat hexagon_size = 11.0 - 2.0 * float(i);\n    float hexagon_fade = 0.25 * pow(float(i), 2.5);\n\tfloat hexagon  = renderHexagon(pos,lightPos,hexagon_offset,dist,hexagon_size)*hexagon_fade*blend_val.w;\n    \n\t// Slightly offset colors to simulate chromatic abberration.\n\tcolor = chromaticAberration(color, pos, lightPos, i);\n \treturn (smallCircle + bigCircle + ring + hexagon) * color;\n}\n\n// 'LensFlare()' -- Main function for accumulating flare color.\n// Params:\n// currPos: current fragment's screen-space position\n// lightPos: light's screen-space position\n// distToLight: world space distance between camera and light.\nvec3 Lensflare(vec2 currPos, vec2 lightPos, float distToLight)\n{\n\n\tvec3 flareColor = vec3(0.0);\n\tfloat lt_dist = distToLight+1.0f;//prevent division by val < 1.\n\tfloat proximity_divisor = length(currPos-lightPos);\n\tfloat loopVal = 1.0f;\n\tint i = 1;\n\n\tconst float epsiln = 0.0001f;\n\twhile(loopVal > epsiln && i < MAX_ITERATIONS)\n\t{\n\t\tfloat i_f = float(i);\n\t\tvec2 pos = currPos;//square value to produce appropriate warping effect\n\t\tvec2 lpos = lightPos;\n\t\tvec3 color_rand = 2.0 * i_f * vec3(rnd(i_f * 3.0913));\n\t\tvec3 col = lightColor + clamp(color_rand, 0.0, 1.0);\n\t\tfloat flareSize = \n\t\t\t i_f*i_f*pow(rnd(i_f * 21.773) * 1.8, 1.0) + 0.5;\n\t\tfloat flareInterval = \n\t\t\t(lensFlareScale/lt_dist) * pow(rnd(i_f * 7.11) * 3.0, 2.5) + 0.05;\n\t\t\t\t\t\n\t\tvec3 passColor = LensHighlight(pos,lpos,col,flareSize,flareInterval,i); \n\n\t\tpassColor *= lensFlareBrightness / (i_f * 1.15);\n\t\tflareColor += passColor;\n\t\tloopVal /= proximity_divisor;\n\t\ti++;\n\t}\n\n\treturn flareColor;\n}\nfloat scaleDepth(float depth)\n{// Intended to map values in range d = (0,1] to range (1,0] to rolloff values by distance.\n\treturn exp(-abs(depth * lensFlareFade * 0.01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Get screen space pixel position. Note that in view space, camera is at vec3(0).\n\tvec3 uv = vec3(fragCoord/iResolution.xy,0)-0.5;\n\tuv.x *= iResolution.x/iResolution.y; // aspect correct\n    \n\t// Get screen space light position.\n    vec3 lightPosition = 0.25*(vec3(cos(iTime),sin(iTime),-0.1) - 0.5);//hardcoded for shader\n\tvec3 lightPos = lightPosition;\n    //vec3 lightPos = modelToScreen(lightPosition3D)-0.5; <== implementation for world space light pos\t\n    lightPos.x *= iResolution.x/iResolution.y; // aspect correct\n\n\tfloat distToLight = length(lightPosition - cameraPosition);\n\n\t// Bail early conditions.\n\tif(lensFlareScale <= 0.000001 || distToLight <= 0.00001)\n\t\treturn;\n\n\t// Calculate lens flare effect.\n\tfloat depthFade = scaleDepth(distToLight);\n\tvec3 color = Lensflare(uv.xy, lightPos.xy, distToLight);\n\t\n\t// Post-process, scaling strength by distance of observer to light source.\n\tcolor *= depthFade;//Adjust lens flare for camera distance to light.\n\tcolor = vec3(1.0) - exp(-color.rgb * lensFlareExposure * depthFade);// exposure tone mapping\n\tcolor = max(color, 0.0);//remove negative values\n\n    // Add faked light source.\n    float uvDistToLight = length(uv.xy - lightPos.xy);\n    float lightsrc = clamp(1.0-uvDistToLight*7.0, 0.0, 1.0);\n    \n    // Add rays from light source -- a rough approximation of volumetric light rays.\n    float ray_factor = 1.00;\n    float a = ray_factor * atan(uv.y-lightPos.y, uv.x-lightPos.x);\n    lightsrc += max(0.1/pow(length(uvDistToLight)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    lightsrc += max(0.1/pow(length(uvDistToLight)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    float lightsrc_attenuation = depthFade * (1.0-uvDistToLight*uvDistToLight) * 1.0;\n    color += lightsrc * lightsrc_attenuation;\n\n    // Output final color.\n\tfloat alpha = depthFade*(color.r + color.g + color.b) / 3.0f; //optional alpha blending.\n\tfragColor = vec4(color.rgb, alpha);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}