{
    "Shader": {
        "info": {
            "date": "1496509042",
            "description": "Simpler/faster signed distance to quadratic bezier curve.\nBased on [url]https://www.shadertoy.com/view/ltXSDB[/url] by Adam Simmons.\n[url=http://polycu.be/edit/?h=cpcFVB]Polycu.be version[/url] with multiple segments and endpoint extension.",
            "flags": 0,
            "hasliked": 0,
            "id": "lssBDM",
            "likes": 34,
            "name": "Bezier - Simpler Signed Distance",
            "published": 3,
            "tags": [
                "2d",
                "bezier",
                "distance",
                "parametrization"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 1573
        },
        "renderpass": [
            {
                "code": "// Signed distance to quadratic bezier.\n// Tomasz Dobrowolski'2017 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// My own derivation:\n//   http://ricedit.com/roots_of_quadratic.png\n// with hand-wavy explanation why 3rd root is unnecessary.\n\n// Based on:\n// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n// https://www.shadertoy.com/view/ltXSDB\n\n// Enable endpoint extension? 0 = no\n#define ENDPOINTS 1\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n#if ENDPOINTS == 0\n\n// Find the signed distance from a point to a bezier curve (simple version)\nvec3 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    \n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n   \n    // Find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n  \n    // Sign is just cross product with gradient\n    vec2 g = 2.*b*r.y + c;\n    float s =  sign(g.x*r.w - g.y*r.z);\n\n    float dist = sqrt(r.x);\n    return vec3(dist, s*dist, r.y);\n}\n\n#else\n\n// Find the signed distance from a point to a bezier curve with endpoint extension\nvec3 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    \n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n   \n    // Find closest distance and t\n    vec2 r = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n   \n    // Find on which side (t=0 or t=1) is extension\n    vec2 e = vec2(step(0.,-r.y),step(1.,r.y));\n\n    // Calc. gradient\n    vec2 g = 2.*b*r.y + c;\n   \n    // Calc. extension to t\n    float et = (e.x*dot(-d,g) + e.y*dot(p-C,g))/dot(g,g);\n   \n    // Find closest point on curve with extension\n    vec2 dp = d + (c + b*r.y)*r.y + et*g;\n   \n    // Sign is just cross product with gradient\n    float s =  sign(g.x*dp.y - g.y*dp.x);\n   \n    return vec3(sqrt(r.x), s*length(dp), r.y + et);\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n\n    // Get the signed distance to bezier curve\n    vec3 r = sdBezier(A, B, C, p);\n    \n    // Anti-alias factor\n    float ss = 1.5/iResolution.y;\n    \n    float d = r.x; // unsigned distance\n    float s = smoothstep(-ss,ss,r.y)*2. - 1.; // smooth sign\n\n    fragColor = vec4(.5) - .5*s*vec4(0.1,0.4,0.8,1.0);\n    fragColor *= fragColor; // to linear-space (for correct blending)\n    \n    fragColor += smoothstep(.8,1.,cos(140.*d))*.3;\n    \n    // Show AA curve.\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.01,0.01+ss,abs(d)) );\n    \n    // Show \"t\":\n \tfragColor += smoothstep(.9,1.,cos(140.*(r.z-.5)))*.3;\n    \n    // Render the control points\n    float pd = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    fragColor = mix(vec4(1.0 - smoothstep(0.03-ss, 0.03, pd)), \n                    fragColor, smoothstep(0.03, 0.04, pd));\n    \n    // Back to gamma-space\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}