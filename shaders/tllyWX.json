{
    "Shader": {
        "info": {
            "date": "1593376350",
            "description": "As a tribute to Victor Vasarely, a challenge to myself, and one of these urges, I wanted to recreate some works of Vasarel. I posted some of these recreations on my Instagram, feel free to check it out: @ciphrd",
            "flags": 0,
            "hasliked": 0,
            "id": "tllyWX",
            "likes": 4,
            "name": "Generative Vasarely - Oet-Oet",
            "published": 3,
            "tags": [
                "generative",
                "vasarely"
            ],
            "usePreview": 0,
            "username": "ciphered",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "//\n// A generative recreation of the work Oet-Oet 1955, Victor Vasarely\n// https://i.pinimg.com/originals/04/9b/89/049b89f9d063aeaa88b5f55633553ddd.jpg\n//\n//\n// I tried to focus on the mechanical motion and squares arrangements\n// Nothing else\n//\n// From a series \"Generative Vasarely\", in which I try to explore the work of \n// Victor Vasarely using generative systems.\n// https://instagram.com/ciphrd\n//\n\n\n#define PI \t\t\t3.14159265339\n#define PI4 \t\tPI*.25\n#define hash21(n)  \tfract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453)\n#define rot(a) \t\tmat2(cos(a), -sin(a), sin(a), cos(a))\n\nconst int ITERATIONS = 12;\nconst float LINE_WIDTH = .01;\nconst float LINE_THRESHOLD = .25;\n\n\nfloat band (in vec2 id) {\n    return step(hash21(id.xy), LINE_THRESHOLD);\n}\n\n// @author Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// @author Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    vec2 auv = abs(uv);\n    \n    \n    // a timer value for sequencing\n    float t = iTime / 60.;\n    \n    \n    // the line width oscillates to add a perpetual motion\n    float lw = LINE_WIDTH * (1. + cos(iTime) * .3 + mod(t, .3) * clamp(cos(iTime*4.), -.2, .2) * .8);\n    \n    \n    // a layer of lines\n    vec2 divs = uv / lw;\n    divs.x*= 1. + clamp(cos(iTime), -.1, .1);\n    divs.x*= 1. + clamp(cos(iTime), -.5, .5) * .3;\n    vec2 id = floor(divs);\n    vec2 divs2 = uv / lw * .5;\n    vec2 id2 = floor(divs);\n    \n    \n    // slow animation of the bands\n    // does it work on every machine ?\n    id.x+= (iTime+10.0) * (.00000015 * (cos(iTime*.1)*.2 + 1.));\n    \n    float c = 0.0,\n          a;\n    \n    vec2 s;\n    \n    // we iterate to create layers, and mask more or less\n    for (int i = 0; i < ITERATIONS; i++) {\n        float fi = mod(float(i) + floor(iTime * .1), float(ITERATIONS));\n    \tid.y = fi * 7.;\n    \tid2.y = fi * 7.;\n        float l = max(band(id), band(id2));\n        float mask = 0.0;\n        \n        // first layer, every pixel gets through\n        if (i==0) mask = 1.0;\n        \n        // second layer, only top and bottom gets through\n        else if (i == 1) mask = step(0.3, auv.y);\n        \n        // otherwise, mask will be a rectangme rotated n * PI/2\n        else {\n            float fa = floor(hash11(fi*2.2)*20.)\n            \t\t \t+ clamp(cos(iTime + fi), -.2, .2) / .2\n            \t\t\t+ clamp(cos((iTime+fi) * .5), -.1, .1) / .1;\n\t\t\ta = fa * PI4;\n            vec2 center = hash12(fi*1.5) * .3 - .15;\n            center.x+= cos(iTime+fi) * .1 + cos(iTime*4.+fi) * .05 + cos(iTime*8.+fi) * .01;\n            vec2 tuv = uv * rot(a) + center;\n            vec2 f = vec2(hash11(fi*2.) * .25 + .05);\n            s = smoothstep(f, f+0.0001 * cos(iTime), abs(tuv));\n            mask = s.x * s.y;\n        };\n\n        c = mix(c, l, mask);\n    }\n    \n    \n    // periodic inversion synced to the strenching\n    \n    c = mix(c, (1.-c), step(.08, t) * round(cos(iTime) *.5+.5));\n    \n    \n    // square\n    c*= step(auv.x, .5);\n    s = step(auv, vec2(.4));\n    float inside = s.x*s.y;\n    c*= inside;\n    \n    // background\n    c+= clamp(pow((1.-length(uv)), .2)* 1.1, .2, 1.) * (1. - inside);\n    c+= hash21(uv) * .1;\n    \n    // border\n    s = step(auv, vec2(0.42));\n    c-= s.x*s.y - inside;\n    \n    vec3 color = vec3(uv, c);\n    \n    color*= step(auv.x, .5);\n\n    // Output to screen\n    fragColor = c * vec4(1., 1., 0.92, 1.);\n    //fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}