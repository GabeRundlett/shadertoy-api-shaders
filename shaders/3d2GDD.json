{
    "Shader": {
        "info": {
            "date": "1548915767",
            "description": "figuring out how to use shader buffers.\nthe lines on the left are the buffer, just because. lines vs. pixels for visibility.\nbuffer is just computing the position of each vertex in the main polygon and a few other per-vertex convenience vectors.",
            "flags": 32,
            "hasliked": 0,
            "id": "3d2GDD",
            "likes": 27,
            "name": "what are buffers",
            "published": 3,
            "tags": [
                "buffers"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 2407
        },
        "renderpass": [
            {
                "code": "#define LINEWIDTH 1.0\n\n// adapted from iq capsule distance:\n// https://iquilezles.org/articles/distfunctions\nfloat lineDist(vec2 p, vec2 a, vec2 v)\n{\n    vec2 pa = p - a;\n    float h = clamp(dot(pa,v)/dot(v,v), 0.0, 1.0);\n    return length(pa - v*h);\n}\n\nvec3 edgeToMix(float dist, vec3 bg, vec3 fg) {\n    float f = smoothstep(LINEWIDTH + 0.75, LINEWIDTH - 0.75, abs(dist));\n    return mix(bg, fg, f * 0.8);\n}\n\nvec3 edgeToMix2(float dist, vec3 bg, vec3 fg) {\n    float f = smoothstep(0.75, -0.75, dist);\n    return mix(bg, fg, f * 0.8);\n}\n\nvec3 drawCircle(vec2 c, float r, vec2 p, in vec3 bg, in vec3 fg) {\n    float dist = length(p - c) - r;\n    return edgeToMix(dist, bg, fg);\n}\n\nvec3 drawCircle2(vec2 c, float r, vec2 p, in vec3 bg, in vec3 fg) {\n    float dist = length(p - c) - r;\n    return edgeToMix2(dist, bg, fg);\n}\n\nvec3 drawLineSeg(vec2 lpt, vec2 lvec, vec2 p, in vec3 bg, in vec3 fg) {\n    float dist = lineDist(p, lpt, lvec);\n    return edgeToMix(dist, bg, fg);\n}\n\nvec2 fetchComponent(ivec2 base, int component) {\n    return texelFetch(iChannel0, base + ivec2(component, 0), 0).xy;\n}\n\nvoid mainImage( out vec4 ret, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n\n    vec3 color = vec3(0.0);\n    color = texelFetch(iChannel0, IJ, 0).xyz;\n    \n    \n    for (int n = 0; n < POLY_NUM_POINTS; ++n) {\n        float phase = 2.0 * PI2 * float(n) / float(POLY_NUM_POINTS);\n\n        ivec2 tc = ivec2(n * TEXELS_PER_VERTEX, 0);\n        vec2  pos = fetchComponent(tc, COMP_POS);\n        vec2  vnx = fetchComponent(tc, COMP_VNX);\n        vec2  nnx = fetchComponent(tc, COMP_NNX);\n        vec2  nrm = fetchComponent(tc, COMP_NRM);\n        float cnb = abs(sin(TheTime * 2.0 + phase));\n        float bnc = 1.0 - cnb;\n        vec2  alt = nrm * bnc * 20.0;\n        float rad = 2.0 + cnb * 10.0;\n\n\t    vec3 clr1 = vec3(1.0);\n\t    vec3 clr2 = vec3(\n            sin(phase * 0.5 + PI2 * 0.0 / 3.0) * 0.4 + 0.6,\n            sin(phase * 0.5 + PI2 * 1.0 / 3.0) * 0.4 + 0.6,\n            sin(phase * 0.5 + PI2 * 2.0 / 3.0) * 0.4 + 0.6\n            );\n        vec3  platColor1 = clr1 * (cnb * 0.7 + 0.3);\n        vec3  platColor2 = clr1 * (bnc * 0.7 + 0.3);\n\n        clr2 = mix(clr1, clr2, bnc);        \n        vec3 clr3 = mix(platColor2, clr2, bnc);\n        clr2 *= (bnc * 0.5 + 0.5);\n\n        color = drawLineSeg(pos + vnx * 0.5 + nnx * (1.0 - bnc * bnc) * 5.0, alt , XY, color, platColor2);\n        color = drawLineSeg(pos + vnx * 0.5 - nnx * (1.0 - bnc * bnc) * 5.0, alt , XY, color, platColor2);\n        color = drawLineSeg(pos + vnx * 0.5 - nnx * 10.0 + alt, nnx * 20.0 , XY, color, clr3);\n        color = drawLineSeg(pos, vnx , XY, color, platColor1);\n        color = drawCircle (pos + vnx * 0.5 + nrm * (20.0 + rad - 1.0) + nrm * 40.0 * cnb, rad, XY, color, clr2);\n    }\n        \n    ret = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nint whichVertex(ivec2 ij) {\n//  todo: put n-to-texel and texel-to-n routines in common.\n//  return (ij.x + ij.y * int(iResolution.x)) / TEXELS_PER_VERTEX;\n    return (ij.x) / TEXELS_PER_VERTEX;\n}\n\nint whichComponent(ivec2 ij) {\n//  todo: put n-to-texel and texel-to-n routines in common.\n//  return (ij.x + ij.y * int(iResolution.x)) % TEXELS_PER_VERTEX;\n    return (ij.x) % TEXELS_PER_VERTEX;\n}\n\nvec2 calcPosition(int n) {\n    float theta = float(n) * PI2 / float(POLY_NUM_POINTS);\n    theta += TheTime * PI2 / -10.0;\n    \n    vec2 ret = vec2(cos(theta), sin(theta));\n\tret *= POLY_RADIUS_INSCRIBED;\n    ret += iResolution.xy / 2.0;\n    return ret;\n}\n\nvec2 calcVNext(int n) {\n    vec2 A = calcPosition( n                       );\n    vec2 B = calcPosition((n + 1) % POLY_NUM_POINTS);\n    return B - A;\n}\n\nvec2 calcNNext(int n) {\n    return normalize(calcVNext(n));\n}\n\nvec2 calcNorm(int n) {\n    vec2 nn = calcNNext(n);\n    return vec2(nn.y, -nn.x);\n}\n\nvoid mainImage( out vec4 C, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    int n = whichVertex(IJ);\n    if (n > POLY_NUM_POINTS) {\n        discard;\n    }\n    \n    vec2 comp;\n    \n    switch (whichComponent(IJ)) {\n        case COMP_POS:\n\t        comp = calcPosition(n);\n        \tbreak;\n        case COMP_VNX:\n\t        comp = calcVNext   (n);\n        \tbreak;\n        case COMP_NNX:\n\t        comp = calcNNext   (n);\n        \tbreak;\n        case COMP_NRM:\n\t        comp = calcNorm    (n);\n        \tbreak;\n    }\n    \n    C = vec4(comp, 0.0, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define POLY_NUM_POINTS         7\n#define POLY_RADIUS_INSCRIBED  60.0\n\n#define PI  (3.14159265359)\n#define PI2 (2.0 * PI)\n\n////////////////////////////////////////////\n//\n// stuff to define a polygon in buffer A.\n// vertices go widdershins.\n// is this how people do things ?\n\n// components per vertex\n#define COMP_POS          0 // vertex position\n#define COMP_VNX          1 // vector to next vertex\n#define COMP_NNX          2 // normalized vector to next vertex\n#define COMP_NRM          3 // normal\n#define TEXELS_PER_VERTEX 4\n\n#define TheTime (iTime * 1.0)\n\n#define TEXEL_MAG 4\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}