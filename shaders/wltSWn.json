{
    "Shader": {
        "info": {
            "date": "1580767496",
            "description": "Developed on stream at https://twitch.tv/codebasealpha",
            "flags": 0,
            "hasliked": 0,
            "id": "wltSWn",
            "likes": 24,
            "name": "Codebase Lightning",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "codebasealpha",
            "viewed": 993
        },
        "renderpass": [
            {
                "code": "vec2 hash (in vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n   \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                         dot (b, hash (i + o)),\n                         dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm)\n{\n    vec2 offset = vec2(cos(tm), 0.0);\n    float aggr = 0.0;\n    \n    aggr += noise(pos);\n    aggr += noise(pos + offset) * 0.5;\n    aggr += noise(pos + offset.yx) * 0.25;\n    aggr += noise(pos - offset) * 0.125;\n    aggr += noise(pos - offset.yx) * 0.0625;\n    \n    aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n    return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset)\n{\n    vec3 col = vec3(0.0);\n    vec2 f = vec2(0.0, -iTime * 0.25 );\n    \n    for (int i = 0; i < 3; i++)\n    {\n        float time = iTime +float(i);\n        float d1 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 3.0, time)));\n        float d2 = abs(offset * 0.03 / (0.0 + offset - fbm((pos + f) * 2.0, 0.9 * time + 10.0)));\n        col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n        col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n    }\n    \n    return col;\n}\n\n/*\nfloat distanceCodebaseAlpha(vec2 pos)\n{\n    ivec2 siz = textureSize(iChannel0, 0);\n    pos.x *= float(siz.y)/float(siz.x);\n    pos.y *= -1.0;\n    pos += vec2(0.5);\n    vec4 col = texture(iChannel0, pos);\n    float d = col.x + col.y/256.0 + col.z/(256.0 * 256.0);\n    \n    return -2.0 * d + 1.0;\n}\n*/\n\nfloat distanceCodebaseAlpha(vec2 pos)\n{\n    return length(pos) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 0.5;\n    //float dist = length(uv) - 0.25;\n    float dist = distanceCodebaseAlpha(uv);\n    \n    vec3 n = lightning(uv, dist + 0.4);\n    vec3 col = vec3(0.0);\n    \n    col += n;\n    col += 0.5 * smoothstep(0.01, -0.01, dist) * sqrt(smoothstep(0.25, -0.5, dist));\n    col += 0.25 * smoothstep(0.1, 0.0, dist);\n    \n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}