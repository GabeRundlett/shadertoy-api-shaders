{
    "Shader": {
        "info": {
            "date": "1558239016",
            "description": "Just testing the speed. Finally removed seam.",
            "flags": 32,
            "hasliked": 0,
            "id": "ttB3RR",
            "likes": 3,
            "name": "Squircle Rotation V2",
            "published": 3,
            "tags": [
                "rotation",
                "minkowski",
                "squircle",
                "noneuclidean"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 522
        },
        "renderpass": [
            {
                "code": "//mandelbulb with squircle rotation (rotation with minkowski distance 1..infinity)\n//no actual trig functions are used, just my made up bs!\nfloat PWR;\nfloat Length(vec2 p){return pow(pow(abs(p.x),PWR)+pow(abs(p.y),PWR),1.0/PWR);}\nfloat Length(vec3 p){return pow(pow(abs(p.x),PWR)+pow(abs(p.y),PWR)+pow(abs(p.z),PWR),1.0/PWR);}\nvec2 CosSin(float a){return texture(iChannel0,vec2(fract(a),0)+vec2(0.5)/iResolution.xy).xy;}\nfloat aCosSin(vec2 p){p/=Length(p);\n  p+=vec2(2);p/=vec2(4);p.y+=(p.y<0.5?-1.0:1.0)/iResolution.y;\n  return texture(iChannel0,p).x;\n}\nvec2 Rotate(vec2 p, float a){return Length(p)*CosSin(fract(aCosSin(p)+a));}\n\nfloat DE(vec3 z0){//mandelBulb by twinbee\n   z0.xz=Rotate(z0.xz,-iTime*iTime*0.004);\n   z0.xy=Rotate(z0.xy,iTime*iTime*iTime*0.0001); \n   vec4 c = vec4(z0,1.0),z = c; \n   float r = Length(z.xyz),zo,zi,k=8.0; \n   for (int n = 0; n < 4; n++) { \n      if(r>2.0)break;\n      zo = aCosSin(vec2(z.z, Length(z.xy))) * k; \n      zi = aCosSin(vec2(z.y, z.x)) * k;\n      vec2 pzo=CosSin(zo);\n      z=pow(r, k-1.0)*vec4(r*vec3(pzo.x*CosSin(zi),pzo.y),z.w*k)+c; \n      r = Length(z.xyz);\n   }  \n   return 0.5*min(length(z0),log(r) * r / z.w); \n}  \nfloat rnd; \nvoid randomize(in vec2 p){rnd=fract(iTime+sin(dot(p,vec2(13.3145,117.7391)))*4231.7654);} \n \nvec3 scene(vec3 ro, vec3 rd){ \n  vec3 L=normalize(vec3(0.4,0.025,0.5)); \n  vec3 bcol=vec3(abs(dot(rd,L))); \n  vec4 col=vec4(0.0);//color accumulator \n  float t=DE(ro)*rnd,d,od=1.0,px=1.0/iResolution.x; \n  for(int i=0;i<99;i++){\n    d=DE(ro+rd*t);\n    if(d<px*t){\n      float alpha=(1.0-col.w)*clamp(1.0-d/(px*t),0.0,1.0); \n      col+=vec4(clamp(vec3(clamp(1.0-d/od,0.0,1.0)),0.0,1.0),1.0)*alpha; \n      if(col.w>0.9)break; \n    }\n    t+=d;od=d;\n    if(t>6.0)break; \n  } \n  col.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0)); \n  return col.rgb; \n}\nvoid mainImage(out vec4 O, in vec2 U){ \n    //O=texture(iChannel0,U/iResolution.xy);return;\n  vec2 uv=vec2(U-0.5*iResolution.xy)/iResolution.x; \n  randomize(uv);PWR=1.0+iTime*iTime*0.007;\n  O=vec4(scene(vec3(0,0,max(-2.0-iTime*0.1,-4.5)),normalize(vec3(uv,1.0))),1.0); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//trig for minkowski distance\nfloat PWR;\nfloat Length(vec2 p){return pow(pow(abs(p.x),PWR)+pow(abs(p.y),PWR),1.0/PWR);}\nvec2 CosSin(float a){return texture(iChannel0,vec2(fract(a),0)+vec2(0.5)/iResolution.xy).xy;}\nfloat aCosSin(vec2 p){p/=Length(p);\n  p+=vec2(2);p/=vec2(4);p.y+=(p.y<0.5?-1.0:1.0)/iResolution.y;\n  return texture(iChannel0,p).x;\n}\nvec2 Rotate(vec2 p, float a){return Length(p)*CosSin(fract(aCosSin(p)+a));}\n//trig for manhattan distance (used as a starting point. no real trig used anywhere)\nconst float Pi=(2.0*sqrt(2.0));\nfloat t_cos(float a){return 2.0*abs(mod(a,2.0*Pi)-Pi)/Pi-1.0;}\nfloat t_atan(float x, float y){\n float a=x-y,b=x+y,res;if(b==0.0)res=(a>0.0?7.0:3.0);  \n else{float d=a/b;if(abs(d)<1.0){if(b>0.0)res=1.0-d;else res=5.0-d;}else{d=b/a;if(a>0.0)res=7.0+d;else res=3.0+d;}}  \n return res*0.25*Pi;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv=fragCoord/iResolution.xy;\n  fragColor=texture(iChannel0,uv);\n  PWR=1.0+iTime*iTime*0.007;\n  vec2 p,pL,pR;\n  if(fragCoord.y>0.5){//aCosSin\n    p=uv;if(abs(p.y-0.5)>0.9/iResolution.y)p.y-=(p.y<0.5?-1.0:1.0)/iResolution.y;\n    p=(p*4.0)-vec2(2.0);\n    if(iFrame<5){//start with t_atan\n      if(abs(fragCoord.y-iResolution.y/2.)<2.0){\n         fragColor=vec4(p.x<0.0?0.5:fragCoord.y<iResolution.y/2.?1.0:0.0,0,0,1);\n      }else  \n       fragColor=vec4(t_atan(p.x,p.y)/(2.0*Pi),0,0,1);\n    }else if(abs(fragCoord.y-iResolution.y/2.)>1.0){//avoid crease\n      p/=Length(p);//compare p to CosSin of table value for p and adjust\n      float a=aCosSin(p);pL=CosSin(a);\n      float a2=aCosSin(pL);a+=(a-a2)*length(p-pL)*5.0;clamp(a,0.0,1.0);\n      fragColor.g=length(p-pL);\n      fragColor.r=a;\n    }\n  }else{//CosSin\n    float a=uv.x;\n    if(iFrame<5){//start with a diamond of points\n      fragColor=vec4(t_cos(a*2.0*Pi),t_cos((a-0.25)*2.0*Pi),0.0,1.0);\n    }else{//push points to surface and away from each other\n      p=fragColor.xy;\n      p/=Length(p);\n      if(fragCoord.x>0.5 && fragCoord.x<iResolution.x-1.0){\n      \tfloat xL=fragCoord.x-1.0,xR=fragCoord.x+1.0;\n      \tpL=p-texture(iChannel0,vec2(xL,0.5)/iResolution.xy).xy;\n      \tpR=p-texture(iChannel0,vec2(xR,0.5)/iResolution.xy).xy;\n      \t//if(length(pL)>length(pR))pL=pR;p+=pL*0.15;\n        float dl=length(pL)-length(pR);p+=(dl>0.0?-pL:pR)*dl*5.0;\n      }\n      fragColor.xy=p;\n    }\n  }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}