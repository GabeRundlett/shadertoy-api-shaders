{
    "Shader": {
        "info": {
            "date": "1720033136",
            "description": "Thanks for the investment!\nhttps://www.theblock.co/post/303375/bitcoin-scaling-protocol-qed-funding-valuation",
            "flags": 0,
            "hasliked": 0,
            "id": "4XKXDw",
            "likes": 1,
            "name": "Blockchain Capital Logo",
            "published": 3,
            "tags": [
                "sdf",
                "logo",
                "blockchain",
                "capital"
            ],
            "usePreview": 0,
            "username": "cf",
            "viewed": 146
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 260;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.0005;\nconst float EPSILON = 0.00001;\nconst float PI = 3.14159265359;\n\n#define OVERSHOOT(x) tanh(x*x)*(2./exp(x*x*x)+1.)\n#define TWEEN_VALUE OVERSHOOT(2.*iTime)\n\nmat2 rot2d(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n\t  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p)-b+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\nvec2 translateRot(in vec2 p, vec2 offset, float theta) {\n    return (p-offset*TWEEN_VALUE)*rot2d(theta*TWEEN_VALUE);\n}\nfloat getBCAPSingleArmSDF2D(in vec2 p) {\n    float d = sdPentagon(p, 0.5);\n    float box1 = sdRoundBox(translateRot(p, vec2(0.0,0.94494), 0.7853981633974483), vec2(0.2604), (0.067));\n    float box2 = sdRoundBox(translateRot(p, vec2(0.089,1.7), -0.5977752688), vec2(0.1953), (0.067));\n    float box3 = sdRoundBox(translateRot(p, vec2(0.3585416,2.25238095238),-0.31555553), vec2(0.127912), (0.05211));\n    d = opSmoothUnion(d,box1,0.16);\n    return min(min(d,box2),box3);\n}\n#define BCAP_SCALE 1.\nfloat getBCAPLogoSDF2D(in vec2 p) {\n    float theta = (floor(( atan(p.y,p.x)-1.)/1.256637)*1.256637)+0.16144295580948498;\n    float d1 = getBCAPSingleArmSDF2D(mat2(cos(theta),-sin(theta),sin(theta), cos(theta))*p*BCAP_SCALE*rot2d(1.0-TWEEN_VALUE));\n    float theta2 = theta+1.256637;\n    float d2 = getBCAPSingleArmSDF2D(mat2(cos(theta2),-sin(theta2),sin(theta2), cos(theta2))*p*BCAP_SCALE*rot2d(1.0-TWEEN_VALUE));\n    return min( d1, d2 );\n}\n\nfloat getBCAPLogoSDF3D( vec3 p, float thickness )\n{\n  vec2 d = vec2(\n       getBCAPLogoSDF2D(p.xy),\n       abs(p.z)-thickness );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return getBCAPLogoSDF3D(p,0.25);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * EPSILON;\n    float r = 1.;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal) {\n  vec3 cubemapReflectionColor = texture(iChannel0, reflect(rd, normal)).rgb;\n\n  vec3 K_a = 1.5 * vec3(0.0,0.5,0.8) * cubemapReflectionColor; // Reflection\n  vec3 K_d = vec3(1);\n  vec3 K_s = vec3(1);\n  float alpha = 50.;\n\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 6);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n  vec3 col = texture(iChannel0, rd).rgb;\n\n  float d = rayMarch(ro, rd);\n\n  vec3 p = ro + rd * d;\n  vec3 normal = calcNormal(p);\n\n  vec3 lightPosition1 = vec3(1, 1, 1);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  vec3 lightPosition2 = vec3(-8, -6, -5);\n  vec3 lightDirection2 = normalize(lightPosition2 - p);\n\n  float lightIntensity1 = 0.65;\n  float lightIntensity2 = 0.3;\n\n  vec3 sphereColor = phong(lightDirection1, lightIntensity1, rd, normal);\n  sphereColor += phong(lightDirection2, lightIntensity2, rd, normal);\n  sphereColor += fresnel(normal, rd) * 0.4;\n\n  col = mix(col, sphereColor, step(d - MAX_DIST, 0.));\n\n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}