{
    "Shader": {
        "info": {
            "date": "1620051679",
            "description": "Trying out the very expensive, but very smooth, analogs to the classic blend functions",
            "flags": 0,
            "hasliked": 0,
            "id": "7djSDR",
            "likes": 4,
            "name": "very expensive smooth min/max",
            "published": 3,
            "tags": [
                "sdf",
                "testing",
                "experiment",
                "blend",
                "expensive"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "#define USE_SQUIRCLES_INSTEAD_OF_BOXES 0\n\n\nfloat wiggle = 0.0; // overwritten in main.  global variable\n\n\nfloat box_sdf(in vec2 pt) {\n  vec2 rel = abs(pt) - vec2(0.5);\n  float out_dist = length(max(rel, vec2(0.0)));\n  float in_dist = max(rel.x, rel.y);\n  return mix(in_dist, out_dist, step(-in_dist, out_dist));\n}\n\nfloat squircle_sdf(in vec2 pt) {\n  vec2 squares = pt * pt;\n  float l = sqrt(sqrt(dot(squares, squares)));\n  return l - 0.5;\n}\n\n/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat sdf(in vec2 pt_in) {\n  vec2 pt = pt_in / 200.0;\n  vec2 vals;\n#if USE_SQUIRCLES_INSTEAD_OF_BOXES\n  vals = vec2(squircle_sdf(pt - vec2(0.2, 0.1)), \n              squircle_sdf(pt + vec2(0.75 + wiggle, 0.7))); \n#else\n  vals = vec2(box_sdf(pt - vec2(0.2, 0.1)), \n              box_sdf(pt + vec2(0.75 + wiggle, 0.7))); \n#endif\n\n  if (pt_in.x + 0.5 * iResolution.x > iMouse.x) {\n    return checked_smooth_min(vals.x, vals.y, 0.5);\n  }\n  return conventional_smin(vals.x, vals.y, 0.25);\n}\n\n/** first component is a repeating wave function of distance, for contour lines,\n  * second component determines whether we are inside or outside the shape\n  */\nvec2 contour(in vec2 pt) {\n  float val = sdf(pt);\n  return vec2(cos(20.0 * val) - 1.0, val);\n}\n\n/** first and third component are the gradient of the first component of \"contour\"\n  * second and fourth component are the gradient of the second component of \"countour\"\n  */\nvec4 contour_grad(in vec2 pt) {\n  vec2 f = contour(pt);\n  return 1000.0 * vec4(contour(pt + vec2(0.001, 0.0)) - f,\n                       contour(pt + vec2(0.0, 0.001)) - f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy - 0.5 * iResolution.xy;\n    \n    wiggle = 0.5 * sin(0.5 * iTime);\n    \n    // uv = 5.0 * uv;\n    \n    vec2 val = contour(uv);\n    vec4 grad = contour_grad(uv);\n    \n    val = 0.5 * val / vec2(length(grad.xz), length(grad.yw));\n    val = vec2(1.0) + max(vec2(-1.0), min(vec2(0.0), val));\n\n    // val.y = 1.0 - val.y;\n    \n    vec3 col = val.yxx;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}