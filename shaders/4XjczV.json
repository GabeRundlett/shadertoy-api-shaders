{
    "Shader": {
        "info": {
            "date": "1727455076",
            "description": "Stealing Shane's [url=https://www.shadertoy.com/view/tsdXDB]Extruded Video Image[/url]\nand mixing it with [url=https://www.shadertoy.com/view/4cSXRW]coiled grove[/url].",
            "flags": 32,
            "hasliked": 0,
            "id": "4XjczV",
            "likes": 21,
            "name": "Extruded Grove",
            "published": 3,
            "tags": [
                "grid",
                "video",
                "template",
                "square",
                "extrude",
                "subdivide"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "/*******************************************************\nRemix ancestry\n--------------\n\n'Image' is Shane's wonderful Extruded Video Image,\nhttps://www.shadertoy.com/view/tsdXDB .\n\n'Buffer A' and 'Common' are Coiled Grove,\nhttps://www.shadertoy.com/view/4cSXRW\n\n*******************************************************/\n\n\n\n\n/*\n\n    Extruded Video Image\n    --------------------\n\n\tI made this after looking at another one of Flockaroo's cool video effects,\n\tnamely his \"Voxel Video\" example. It's based on basic extruded grid code\n\tthat I've used from time to time. I wanted to see how things would look \n\ttaking a raymarched extruded approach. It lacks some of the multilevel\n    subdivided freakiness that you get with Flockaroo's example, but it's still \n\treasonably interesting.\n\n\tI originally started with one square size, but it was difficult to descern\n\tthe image for all but the smallest of grid cell dimensions, so I used the \n\tusual corner pixel techniques to subdivide down one level. The downside, of \n    course, was forcing the GPU to perform more work. That could be mitigated\n\tby precalculating on a buffer, etc, but I wanted to keep the example \n    relatively simple by restricting things to a single pass. Some might also\n\tnote that I've subdivided one object directly into four small squares, and \n\tleft out the rectangles. I did that for simplicity sake, but a \"power of\n    2\" subdivision would normally include those.\n\n\tAnyway, I did this for a bit of fun, and to satisfy my curiosity. I could \n\tmake a lot of improvements, but this will do for now. Later, I might start\n\twith larger block sizes, then divide down a couple more levels, just to see \n\tif it looks more like Flockaroo's original. However, dealing with \n\tneighboring subdivided grid cells in a raymarching environment can be \n\ttricky, not to mention expensive, so I might try that on the 2D plane first.\n\t\n    \n\n\tInspired by:\n    \n\t// As mentioned, Flockaroo makes all kinds of interesting video processing\n\t// examples, and this is just one of them.\n    voxel video - flockaroo\n\thttps://www.shadertoy.com/view/3stXzB  \n\n\n*/\n\n\n// Increased the visible resolution, where applicable. Uncomment to see what\n// a big diference it makes.\n#define SUBDIVIDE\n\n// Sparkles, or no sparkles.\n#define SPARKLES\n\n// Grayscale, for that artsy look.\n#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p/2. - .5)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n \n// A regular extruded block grid, subdivided down one level, if necessary.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n//\n// For the subdivision step, split each square into four smaller squares, obtain\n// the heights, then check each against the main height to see whether any\n// exceed a certain threshold. If any do, render the four smaller pylons at\n// their respective heights. In theory, you could keep going this way, but not\n// on a single pass, because you'd soon fry your GPU. :)\n// \nvec4 blocks(vec3 q3){\n    \n    // Scale.\n    const float scale = 1./16.;\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n\n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip*s + cntr;\n \n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        #ifndef SUBDIVIDE\n        h = floor(h*15.999)/15.*.15; // Or just, \"h *= .15,\" for nondiscreet heights.\n        #endif\n        \n        #ifdef SUBDIVIDE\n        // Subdivide the block into four smaller blocks, then check it's height\n        // against the main block height (above). If any of the height differences\n        // exceed a threshold (I've chosen one block height unit), then flag then\n        // main block for subdivision.\n        vec4 h4;\n        int sub = 0;\n        for(int j = 0; j<4; j++){\n            h4[j] = hm(idi + ps4[j]/4.);\n            if(abs(h4[j] - h)>1./15.) sub = 1;\n        }\n        \n        \n        // Using the floor function to snap the heights to specific quantized values.\n        h = floor(h*15.999)/15.*.15;\n        h4 = floor(h4*15.999)/15.*.15;\n        \n        // Without discreet heights -- Comment out the two lines above first though.\n        //h *= .15;\n        //h4 *= .15;\n         \n        \n        // If subdividing, render the four smaller blocks at their respective\n        // heights. Otherwise, render the one larger block. Refer to the image\n        // for a visual representation.\n        if(sub==1){\n            \n            // Four smaller extruded blocks.\n            vec4 d4, di4;\n\n            for(int j = 0; j<4; j++){\n                d4[j] = sBoxS(p - ps4[j]/4., l/4. - .05*scale, .005);\n                di4[j] = opExtrusion(d4[j], (q3.z + h4[j]), h4[j]);\n                \n                // If applicable, update the overall minimum distance value,\n                // ID, and box ID.\n                if(di4[j]<d){\n                    d = di4[j];\n                    id = idi + ps4[j]/4.;\n                    // Not used in this example, so we're saving the calulation.\n                    //boxID = float(j)*4. + float(i);\n        \t\t}\n            }\n        }\n        else {\n        #endif\n            \n            // One larger extruded block.\n            float di2D = sBoxS(p, l/2. - .05*scale, .015);\n            \n            // Boring out some of the lower boxes. I like it, but thought it\n            // confused matters.\n            //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n            \n        \t// The extruded distance function value.\n            float di = opExtrusion(di2D, (q3.z + h), h);\n            \n            // If applicable, update the overall minimum distance value,\n                // ID, and box ID. \n            if(di<d){\n                d = di;\n                id = idi;\n                // Not used in this example, so we're saving the calulation.\n                //boxID = float(i);\n        \t}\n            \n        #ifdef SUBDIVIDE    \n        }\n        #endif\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec2 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yz; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<64; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(-.5*.3*cos(iTime/2.), -.5*.2*sin(iTime/2.), -2); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1.5, 2, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\n    \n/*      \n    // Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (iMouse.xy - iResolution.xy*.5)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n*/    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec2 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID);\n            //vec3 tx = getTex(sp.xy - .5/16.); // See scale in the distance function.\n            // Greyscale value, just in case people switch to the Britney video, etc.\n            // Stylistically, the example works better with color. The Britney video\n            // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n            #ifdef GRAYSCALE\n            texCol = vec3(1)*dot(tx, vec3(.299, .587, .114));\n            #else \n            texCol = tx;\n            #endif\n            \n            \n            #ifdef SPARKLES\n            \n            // Putting some blinking colored dots in the background. I did this to liven\n            // things up a bit. It's a little quirky, but looks... interesting, I guess. :D\n            float rnd = fract(sin(dot((svGID), vec2(141.13, 289.97)))*43758.5453);\n            float rnd2 = fract(sin(dot((svGID + .037), vec2(141.13, 289.97)))*43758.5453);\n            rnd = smoothstep(.9, .95, cos(rnd*6.283 + iTime*2.)*.5 + .5);\n            vec3 rndCol = (.5 + .45*cos(6.2831*mix(0., .3, rnd2) + vec3(0, 1, 2)/1.1));\n            rndCol = mix(rndCol, rndCol.xzy, uv.y*.75 + .5);\n            rndCol = mix(vec3(1), rndCol*50., rnd*smoothstep(1. - (1./1./15. + .001), 1., 1. - texCol.x));\n            \n            texCol *= rndCol;\n            \n            #endif\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(0., 1., texCol);\n \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(dot(sn, rd) + 1., 0., 1.), 2.);\n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.3 + vec3(.25, .5, 1)*diff*fre*16. + vec3(1, .5, .2)*spec*2.);\n\n        // Shading.\n        col *= ao*sh*atten;\n        \n        \n\t\n\t}\n    \n    //float rnd = hash21(rd.xy + fract(iTime));\n    //col = clamp(col + (rnd*rnd - .5)*.1, 0., 1.);\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*******************************************************\nRemix ancestry\n--------------\n\n'Image' is Shane's wonderful Extruded Video Image,\nhttps://www.shadertoy.com/view/tsdXDB .\n\n'Buffer A' and 'Common' are Coiled Grove,\nhttps://www.shadertoy.com/view/4cSXRW\n\n*******************************************************/\n\n\n/*\n    This attempts to handle transparent materials\n    with various indices of refraction\n    which directly abut each other.\n    \n    Orion Elenzil 2024\n*/\n\n\n\n/*\n\nKeyboard (iChannel3)\n--------------------\n1. heat map\n2. x-eyed stereo\n3. cutting plane\n4. zoom\n5. AA\n6. transmission\n\n*/\n\n#define SUBSURFACE 0   // not-quite-right subsurface scattering\n#define HQ         0   // slowww but pretty\n\n//---------------------------------------------------------------\n// Viewport and Time\nconst float gZoom       = 0.8;\n      float gFOVZoom    = 2.0;\n      float gCamDist    = 24.0;\nconst float gToggleZoom = 2.0;\nconst float gStereoSep  = 0.4;\n\n      float gT;         // set in main\n\n//--------------------------------------------------------------------------\n// ray handling parameters\n\n// maximum number of rays per pixel.\n// reflections, shadows, and transmission all spawn a ray,\n// and a single ray travels until it hits a boundary.\n#if HQ\nconst uint  gHQMult         = 3u;\n#else\nconst uint  gHQMult         = 1u;\n#endif\nconst uint  gMaxRays        = 1u;\nconst uint  gQueueSize      =  18u * gHQMult;\n\n// standard marching parameters\nconst float gSceneScale     = 2.0f;\nconst uint  gMaxMarchSteps  = 200u * gHQMult;\nconst float gMarchEps       = 0.03;\nconst float gNormEps        = gMarchEps * 0.4;\nconst float gMarchMaxT      = 5e1 * gSceneScale;\nconst float gMarchUnderstep = 0.5 / float(gHQMult);\nconst float gHitBackoff     = gMarchEps * 0.0;\n\n// smallest contribution before extinguishing a ray\nconst float gMinAmt         = 0.01 / float(gHQMult);\n\n// direction to the light\nvec3  gLightDir;\nfloat gAmbient              = 0.02;\n\n// heat map stuff\n      float gMapCount       = 0.0;\nconst float cHeatMapSteps   = 200.0;\nconst float cHeatMapRays    = 20.0;\n\n// debugging color\n      vec3  gDebugRGB       = v0;\n\n//--------------------------------------------------------------------------\n// Materials\n\nconst uint gMtlAir   = 1u;\nconst uint gMtlFloor = 2u;\nconst uint gMtlGlass = 3u;\nconst uint gMtlWater = 4u;\nconst uint gMtlIce   = 5u;\nconst uint gMtlBands = 6u;\nmtl_t mtls[] = mtl_t[] (\n    //    albedo             opac   ior    absorption\n    mtl_t(vX * 1e9         , 1.0  , 1.0  , v41                   ), // 0 invalid\n    mtl_t(v1               , 0.0  , 1.0  , v41 * 0.5             ), // 1 air\n    mtl_t(v1 * 0.3         , 1.0  , 1.3  , v41 * 1.0             ), // 2 floor\n    mtl_t(v1 * 1.0         , 0.0  , 1.52 , V4(0.3, 0.3, 0.3, 0.2)), // 3 glass\n    mtl_t(v1 * 1.0         , 0.0  , 1.33 , V4(0.2, 0.2, 0.2, 0.1)), // 4 water\n    mtl_t(vX + vY          , 0.0  , 1.31 , V4(0.2, 0.2, 0.2, 0.1)), // 5 ice\n    mtl_t(V3(0.9, 0.0, 0.4), 0.015, 1.2  , V4(0.5, 0.8, 0.0, 2.0)), // 6 bands\n    mtl_t(v1 * 0.6         , 1.0  , 1.5  , v41                   )  // 7\n);\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff part one\nbool kPipOn;        // 1. heat map\nbool kXEyedStereo;  // 2. x-eyed stereo\nbool kCuttingPlane; // 3. cutting plane\nbool kZoom;         // 4. zoom\nbool kAA;           // 5. AA\nbool kTransmission; // 6. transmission\n// pbpaste | sed -e 's/.*\\/\\/ //' | pbcopy\n\n//---------------------------------------------------------------------\n// The SDF !\n\nMST sdScene(in vec3 p) {\n    gMapCount += 1.0;\n    \n    p /= gSceneScale;\n\n    float d = 1e9;\n    \n    vec3 q = p;\n        \n    q.xz = abs(q.xz);\n    q.xz -= 9.0;\n    \n    q.xz *= rot2(q.y * q.y * 0.006 - gT * 0.1);\n    q.xz *= 2.0 * (0.5 +  smoothstep(10.0, 50.0, q.y));\n    \n    q.xz = abs(q.xz);\n    q.xz -= 4.0;\n\n    float fade = smoothstep(1.0, 15.0, q.y);\n    q.xz *= rot2(q.y * 0.5  - gT);\n    q.x = abs(q.x);\n    q.x -= 2.0 * fade;\n    \n    d = min(d, sdDisk(q.xz, 1.0));\n    \n    d = max(d, -q.y + gMarchEps * 2.5);\n    \n //   d += fade * 0.015 * (sin(q.x * 10.0) + sin(q.z * 10.0));\n\n    //if (dot(q.xz, q.xz) < 60.0)\n      //  d = sminCubic(d, p.y, 4.5);\n    \n    MST ms = MST(d, 6u);\n\n    \n    if (kCuttingPlane) {\n        ms.dist = max(ms.dist, p.z);\n    }\n    \n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    \n    return ms;\n}\n\n\n//------------------------------------------------------\n// ray-handling stuff.\n\n// FIFO queue of rays. see Common tab.\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES (gQueueSize)\nQ_IMPLEMENTATION\nhit_t rayVsScene(ray_t);\nvec3  sky(ray_t);\nvec3  albedo(hit_t);\nMST sdScene(vec3 p);\nMST sdSceneWithFloor(vec3 p);\n\n// run a single ray.\nvec3 runRay(ray_t ray) {\n    hit_t hit = rayVsScene(ray);\n    \n    if (!hit.hit) {\n        // ray hit nothing.\n        \n        if (ray.isLightingRay) {\n            // a \"lighting ray\" is to the light.\n            return ray.amt;\n        }\n        else {\n            // it's a direct ray and sees the sky.\n            return ray.amt * sky(ray);\n        }\n    }\n    \n    // the ray hit something\n\n    // get map samples on either side of the interface\n    MST ms1 = sdSceneWithFloor(hit.pnt + hit.hf_nrm * gMarchEps * 3.0);\n    MST ms2 = sdSceneWithFloor(hit.pnt - hit.hf_nrm * gMarchEps * 3.0);\n    mtl_t mtl1 = mtls[ms1.mtl];\n    mtl_t mtl2 = mtls[ms2.mtl];\n\n    // just traveled through media, attenuate !  (but not through air)\n    if (ms1.mtl != gMtlAir) {\n        vec4 absorption = mtl1.absorption;\n        absorption.w   = mix(absorption.w * 0.7, absorption.w  , smoothstep(0.0, 4.0, hit.pnt.y / gSceneScale));\n        absorption.rgb = mix(absorption.brg * 1.7, absorption.rgb, smoothstep(0.0, 6.0, hit.pnt.y / gSceneScale));\n        float density = absorption.w;\n        float absorptionDist = hit.t / gSceneScale;\n        ray.amt *= sat(exp(-density * absorptionDist * (1.0 - absorption.rgb)));\n    }\n    \n    if (ray.isLightingRay && !QIsFull()) {\n        // lighting ray just keeps traveling\n        if (kTransmission) {\n            float R = reflectAmount(mtls[ms1.mtl].ior, mtl2.ior, dot(ray.rd, -hit.hf_nrm));\n            ray.amt *= 1.0 - mtl2.opacity;\n            ray.amt *= 1.0 - R;\n            ray.ro = hit.pnt - hit.hf_nrm * gMarchEps * 4.0;\n            QEnqueue(ray);\n        }\n        return v0;\n    }\n    \n    float dif;\n    vec4  rfl;\n    vec4  trn;\n    vec3  tmpAmt;\n    \n    thisRayWalksIntoAnInterface(\n        ray.rd,\n        hit.hf_nrm,\n        mtl1.ior,\n        mtl2.ior,\n        mtl2.opacity,\n        dif,\n        rfl,\n        trn);\n         \n    // diffuse\n    float normal_dot_light = dot(hit.of_nrm, gLightDir);\n    vec3 alb = albedo(hit);\n    float shade = sat(normal_dot_light);\n    tmpAmt = ray.amt * dif * alb * shade;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    \n    // subsurface\n    // this has issues.\n    #if SUBSURFACE\n    tmpAmt = ray.amt * dif * alb * (sat(-normal_dot_light + 0.5));\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // towards the light\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 5.0;\n        newRay.rd  = gLightDir;\n        newRay.isLightingRay = true;\n        QEnqueue(newRay);\n    }\n    #endif\n    \n    // reflect\n    tmpAmt = ray.amt * rfl.w;\n    if (vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little off the surface\n        // in the reflect direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = rfl.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n    // transmit\n    tmpAmt = ray.amt * trn.w;\n    if (kTransmission && vmax(tmpAmt) > gMinAmt && !QIsFull()) {\n        // start a new ray a little inside the surface\n        // in the refraction direction\n        ray_t newRay;\n        newRay.amt = tmpAmt;\n        newRay.ro  = hit.pnt - hit.hf_nrm * gMarchEps * 2.0;\n        newRay.rd  = trn.xyz;\n        newRay.isLightingRay = false;\n        QEnqueue(newRay);\n    }\n    \n\n    // return ambient lighting, no new ray.\n    return ray.amt * gAmbient * alb * dif;\n}\n\n//---------------------------------------------------------------------\n// keyboard & mouse stuff part two\n\nconst float cPipScale = 0.45;\nvec2  gMouse;\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn        =  KEY_TOGGLED(ZRO + 1, iChannel3);\n    kXEyedStereo  =  KEY_TOGGLED(ZRO + 2, iChannel3);\n    kCuttingPlane =  KEY_TOGGLED(ZRO + 3, iChannel3);\n    kZoom         =  KEY_TOGGLED(ZRO + 4, iChannel3);\n    kAA           =  KEY_TOGGLED(ZRO + 5, iChannel3);\n    kTransmission = !KEY_TOGGLED(ZRO + 6, iChannel3);\n    \n    #if HQ\n    kAA = true;\n    #endif\n}\n\nvoid readMouse() {\n    if (texelFetch(iChannel2, ivec2(3, 0), 0).r == 0.0) {\n        // This texel should be != 0,\n        // so we conclude buffers are broken on this platform.\n        // see https://www.shadertoy.com/view/McsXRM\n        \n        if (dot(iMouse.xy, iMouse.xy) < 75.0 * 75.0) {\n            gMouse = vec2(gT, 0.75 * RES.y);\n\n        }\n        else {\n            gMouse = iMouse.xy;\n        }\n    }\n    else {\n        gMouse = texelFetch(iChannel2, ivec2(0), 0).xy;\n        gMouse.x += 140.0;\n    }\n}\n\n\n//--------------------------------------------------------------------------\n// Scene Setup\nvec3  gSceneCenter;\nfloat gFloorGap;\nmat2  gObjRot1;\nmat2  gObjRot2;\nvec3  gCamPos;\n\nvoid setupScene() {\n    gSceneCenter  = gSceneScale * vY * 5.0;\n    gLightDir     = normalize(vec3(-0.8, 1.5, 1.9));\n    gFOVZoom     *= kZoom ? gToggleZoom : 1.0;\n    \n    // change the material verrrry slowly according to the wall time.\n    vec4 w = mtls[gMtlBands].absorption;\n    float t = (iDate.z * 100.0 + iDate.w) * 1e-3;\n    w.r  = sin(t * 1.01) * 0.3 + 0.4;\n    w.g  = sin(t * 1.21) * 0.3 + 0.4;\n    w.b  = sin(t * 1.31) * 0.3 + 0.4;\n    w.a += sin(t * 1.41) * 0.3 + 0.5;\n    mtls[gMtlBands].absorption = w;\n    \n    float no = sin(t * 1.51) * 0.1;\n    mtls[gMtlBands].ior += no;\n}\n\n\n\n// sdScene() does not include a floor,\n// because ray-marching infinite planes is a drag.\n// but sometimes we want such a thing.\nMST sdSceneWithFloor(in vec3 p) {\n    MST ms = sdScene(p);\n    opUnion(ms, MST(p.y, gMtlFloor));\n    if (ms.dist > 0.0) {\n        ms.mtl = gMtlAir;\n    }\n    return ms;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalScene(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdSceneWithFloor(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n\n\n//-----------------------------------------------------------\n// material stuff\n\n\nvec3 albedo(hit_t hit) {\n    uint mtl = hit.ms.mtl;\n    vec3 rgb = mtls[mtl].albedo;\n    if (mtl == gMtlFloor) {\n        float f  = 0.0;\n        vec2  xz = mod(hit.pnt.xz * rot2(pi/6.0) + 10.0, 20.0) - 10.0;\n        f  = max(f, smoothstep(1.5, 1.0, abs(xz.x)));\n        f  = max(f, smoothstep(1.5, 1.0, abs(xz.y)));\n        f *= smoothstep(200.0, 100.0, length(hit.pnt.xz));\n        rgb = mix(rgb, rgb * 1.3, f);\n    }\n    return rgb;\n}\n\nfloat ior(MST ms) {\n    const float atmosphere = 1.0;\n\n    if (ms.dist > 0.0) {\n        return atmosphere;\n    }\n    \n    return mtls[ms.mtl].ior;\n}\n\nvec3 sky(ray_t ray) {\n\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(ray.rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(ray.rd, gLightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(ray.rd.z, ray.rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(ray.rd.y)));\n    return c;\n}\n\n//--------------------------------------------------------------------------\n// ray-vs scene stuff\n\nvoid rayVsFloor(ray_t ray, inout hit_t hit) {\n    float t = rayVsPlane(ray.ro, ray.rd, vY, 0.0);\n    if (t > 0.0 && (!hit.hit || t < hit.t)) {\n        hit.t   = t;\n        hit.hit = true;\n        hit.pnt = ray.ro + ray.rd * t;\n        hit.of_nrm = vY;\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = MST(0.0, gMtlFloor);\n    }\n}\n\nvoid rayMarch(ray_t ray, inout hit_t hit) {\n\n    float t = 0.0;\n    \n    MST ms;\n    uint n;\n    vec3 p;\n    for (n = 0u; n < gMaxMarchSteps; ++n) {\n    \n        // if our hit already has a hit\n        // and our t is not closer than it, return.\n        if (hit.hit && t >= hit.t) {\n            return;\n        }\n    \n        // sample the map (without floor)\n        p        = ray.ro + ray.rd * t;        \n        ms       = sdScene(p);\n        float d  = abs(ms.dist);\n\n        if (d < gMarchEps) {\n            // close to a surface!\n            // mark it the hit & return\n            hit.hit    = true;\n            hit.t      = t;\n            hit.pnt    = p;\n            hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n            hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n            \n            // the hit should be from the new material. need to re-sample.\n            hit.ms     = sdScene(p - hit.hf_nrm * gMarchEps * 2.0);\n            return;\n        }\n        \n        // advance\n        t += d * gMarchUnderstep;\n        \n        // if we're just too far away, return.\n        if (t > gMarchMaxT) {\n            return;\n        }\n    }\n    \n    if (t < 1e4 * gSceneScale) {\n        // ran out of steps.\n        hit.hit = true;\n        hit.t   = t;\n        hit.pnt = p;\n        hit.of_nrm = normalScene(p + ray.rd * gHitBackoff);\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = ms;        \n    }\n}\n\nhit_t rayVsScene(ray_t ray) {\n    hit_t hit;\n    hit.hit = false;\n    hit.t   = 1e9;\n    \n    rayVsFloor(ray, hit);\n    rayMarch  (ray, hit);\n    \n    return hit;\n}\n\n\n\n//--------------------------------------------------------------------------\n// viewport, camera, initial ray stuff.\n\nray_t getCameraRay(vec2 xy, float stereoOffset) {\n    ray_t ret;\n    \n    vec3 lookFrom = vZ * gCamDist * gSceneScale;\n    float rX      = gT * 0.1;\n    float rY      = 0.0;\n    rX = (gMouse.x / RES.x * 2.0 - 1.0) * pi * -1.2;\n    rY =  smoothstep(1.0, 0.0, gMouse.y / RES.y) * pi * 0.49;\n    \n    lookFrom.yz  *= rot2(rY);\n    lookFrom.xz  *= rot2(rX);\n    lookFrom.y    = max(0.1, lookFrom.y);\n    gCamPos       = lookFrom;\n         \n    vec3 lookTo   = gSceneCenter;\n    \n    vec3 camFw    = normalize(lookTo - lookFrom);\n    vec3 camRt    = normalize(cross(camFw, vY));\n    vec3 camUp    = cross(camRt, camFw);\n    \n    ret.ro            = lookFrom;\n    ret.ro           += camRt * stereoOffset;\n    ret.rd            = normalize(camFw + (xy.x * camRt + xy.y * camUp) / gFOVZoom);\n    ret.amt           = v1;\n    ret.isLightingRay = false;\n        \n    return ret;\n}\n      \n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    // over-large time introduce precision problems\n    gT = mod(iTime, float( 60 * 60 * 4));\n    \n    readKeyboard();\n    readMouse();\n    \n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n    \n    vec2  xy           = VIEWFROMSCREEN(XY);\n    float stereoOffset = 0.0;\n    \n    if (kXEyedStereo) {\n        float f = sign(xy.x);\n        xy.x -= f * VIEWFROMSCREEN_DIST(RES.x / 2.0);\n        xy   *= 2.0;\n        stereoOffset = -f * gStereoSep * gSceneScale;\n    }\n    \n    setupScene();\n        \n    QClear();\n    \n    if (kAA) {\n        vec2 aa = vec2(1, -1) * 0.3 / MINRES;\n        QEnqueue(getCameraRay(xy + aa.xx, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.xy, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.yx, stereoOffset));\n        QEnqueue(getCameraRay(xy + aa.yy, stereoOffset));\n    }\n    else {\n        QEnqueue(getCameraRay(xy, stereoOffset));\n    }\n    \n    float rootRayCount = float(QCount());\n\n    hit_t hit = rayVsScene(getCameraRay(xy, stereoOffset));\n    \n    float dist = 1.0 - clamp(pow(hit.t, 1.3) * 0.002, 0.0, 1.0);\n\n    vec3 c  = v1 * dist;\n    \n    c      /= rootRayCount;\n    c      *= 1.0 - pow(lengthSqr(XY/RES - 0.5) * 1.8, 3.0);\n    c       = pow(c, vec3(1.0 / 2.2));\n    c      += gDebugRGB;\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        c = mix(cCool, cHot, pow(temp, 0.6));\n    }\n    \n    RGBA    = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*******************************************************\nRemix ancestry\n--------------\n\n'Image' is Shane's wonderful Extruded Video Image,\nhttps://www.shadertoy.com/view/tsdXDB .\n\n'Buffer A' and 'Common' are Coiled Grove,\nhttps://www.shadertoy.com/view/4cSXRW\n\n*******************************************************/\n\nconst vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst vec4  v40 = v01.xxxx;\nconst vec4  v41 = v01.yyyy;\nconst float pi  = 3.14159265359;\n\n//---------------------------------------------------\n// Screen-to-View stuff\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (min(iFrame,0))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n\n\n//---------------------------------------------------\n// math conveniences\n#define saturate(v) ( clamp((v), 0.0, 1.0) )\nfloat lengthSqr(vec3 a) { return dot(a, a); }\nfloat lengthSqr(vec2 a) { return dot(a, a); }\nfloat sqr(float a) { return a * a; }\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nint   vmax(ivec2 A) { return max(    A.x, A.y); }\nfloat vmax( vec2 A) { return max(    A.x, A.y); }\nfloat vmax( vec3 A) { return max(max(A.x, A.y), A.z); }\nint   vmin(ivec2 A) { return min(    A.x, A.y); }\nfloat vmin( vec2 A) { return min(    A.x, A.y); }\nfloat vmin( vec3 A) { return min(min(A.x, A.y), A.z); }\nfloat sat (float A) { return clamp(A,      0.0 ,      1.0 ); }\nvec2  sat ( vec2 A) { return clamp(A, vec2(0.0), vec2(1.0)); }\nvec3  sat ( vec3 A) { return clamp(A, vec3(0.0), vec3(1.0)); }\n#define V2(A, B   )    ( vec2(A, B      ) )\n#define V3(A, B, C)    ( vec3(A, B, C   ) )\n#define V4(A, B, C, D) ( vec4(A, B, C, D) )\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    \n    // if true, this is a ray looking for the light.\n    bool  isLightingRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\nstruct mtl_t {\n    vec3  albedo;\n    float opacity;         // opacity at the surface\n    float ior;\n    vec4  absorption;      // <vec3, permeability>\n};\n\n//--------------------------------------------------------------------------\n// optics\n\n// A modified Schlick's approximation\n// where reflectamount -> 0 as n2 -> n1.\nfloat reflectAmount(float n1, float n2, float incidentDotNormal) {\n    // from https://en.wikipedia.org/wiki/Schlick%27s_approximation \n    float R0 = sqr((n1 - n2) / (n1 + n2));\n    float R  = R0 + (1.0 - R0) * pow(1.0 - incidentDotNormal, 5.0);\n\n    // Schlick's approximation seems invalid when n1 ~= n2.\n    // Compensate with an additional fudge.\n    // https://physics.stackexchange.com/q/794963\n    float ndiffSqr      = sqr(n1 - n2);\n    float elenzilFudge  = ndiffSqr / (ndiffSqr + 0.01);\n    R                  *= elenzilFudge;\n\n    return R;\n}\n\n// n1 == n2          -> no reflection\nvoid thisRayWalksIntoAnInterface(\n    //  direction of the incoming ray.\n    in  vec3  incident,\n    \n    //  surface normal.\n    in  vec3  hit_facing_normal,\n    \n    //  indices of refraction.\n    in  float n1,\n    in  float n2,\n    \n    in  float opacity,\n    \n    //  amount allocated to diffuse lighting\n    out float out_sDiffuse,\n    \n    //  direction and amount for specular reflection\n    out vec4  out_vReflect,\n    \n    //  direction and amount for transmission\n    out vec4  out_vTransmit\n    ) {\n    \n    // 0 = transmit 1 = reflect 1\n    float transmitVsReflect = reflectAmount(n1, n2, dot(incident, -hit_facing_normal));\n    \n    // check for total internal reflection.\n    float eta     = n1 / n2;\n    out_vTransmit.xyz = refract(incident, hit_facing_normal, eta);\n    if (dot(out_vTransmit.xyz, out_vTransmit.xyz) == 0.0) {\n        // total internal\n        transmitVsReflect = 1.0;\n    }\n    \n    float amtDiffuse  = (1.0 - transmitVsReflect) * opacity;\n    float amtReflect  = transmitVsReflect;\n    float amtTransmit =  1.0 - amtDiffuse - amtReflect;\n    \n    out_sDiffuse      = amtDiffuse;\n    out_vTransmit.w   = amtTransmit;\n    out_vReflect.w    = amtReflect;\n    out_vReflect.xyz  = reflect(incident, hit_facing_normal);\n}\n\n//--------------------------------------------------------------------------\n\n// Queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n// CSG Operations.\n// These all mutate the first argument and return void.\n// MST types are used only where sensible.\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opReplace(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\nvoid opReplace(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/smin/\n// polynomial smooth min\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n// https://www.shadertoy.com/view/Ml3fWj\n// return.w must be added to the distance.\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\n//--------------------------------------------------------------------------------\n// Signed Distance Field Primitives\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//--------------------------------------------------------------------------------\n// Analytic ray-vs-primitives\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}