{
    "Shader": {
        "info": {
            "date": "1641682537",
            "description": "More experiments, lot's of unused code in common tab. Focusing more on OO concepts.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsfczH",
            "likes": 14,
            "name": "Turret Bases Stand,Gun,Doors",
            "published": 3,
            "tags": [
                "animated"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 279
        },
        "renderpass": [
            {
                "code": "#define VIEW 1.\nfloat sdCappedCylinder( vec3 p, float r, float h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderZ( vec3 p, float r, float h ){\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nstruct Base {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n};\n\nstruct Stand {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec3 gunAxelPos;\n};\n\nstruct Gun {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec2 bounds;\n    float angle;\n};\n\nstruct Door{\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec2 bounds;\n    float angle;\n};\n\nBase theBase;\nStand theStand;\nGun theGun;\nDoor theDoor;\n\n\nvoid initializeBase(){\n    theBase.dim = vec3(1.,0.01,1.) * WORLD_SCALE;\n    theBase.center = vec3(0.,0.,0.);\n    theBase.basis = IDENTITY;     \n}\n\nvoid initializeDoor(float time){\n    theDoor.dim = vec3(0.9,0.03,.44) * WORLD_SCALE;\n    theDoor.angle = pow(SEQ_1,1./5.);\n    theDoor.center = vec3(0.,0.2-theDoor.angle,0.9);\n    \n    theDoor.basis = rotateX(theDoor.angle*PI*0.5,theBase.basis);//theBase.basis;\n}\n\nvoid initializeStand(float time){\n    theStand.dim = vec3(0.5) * WORLD_SCALE;                \n    theStand.center = vec3(0.,theBase.dim.y + theStand.dim.y,0.) \n                   + theBase.center;           \n    theStand.center += vec3(0.,pow(SEQ_2,1./4.)*4.-4.,0.);\n    theStand.gunAxelPos = vec3(0.0,0.9,0.05);\n    theStand.basis = rotateY(SEQ_3*PI,theBase.basis);\n}\n\nvoid initializeGun(float time){\n    theGun.dim = vec3(0.25,.25,0.25)  * WORLD_SCALE;\n    theGun.center = vec3(0.,theStand.center.y+0.,0.)\n                 + theStand.center;\n    theGun.center = theStand.gunAxelPos+ theStand.center;\n    theGun.bounds = vec2(-PI/2.,PI/2.);\n    theGun.angle = 0.;//clamp(abs(fract(time/4.)-0.5)*PI,theGun.bounds.x,theGun.bounds.y);\n    theGun.basis = rotateX(theGun.angle-PI*.5 - PI*SEQ_4*0.5,theBase.basis);\n}\n\nvoid initializeObjects(float time){\n    \n    initializeBase();\n    initializeDoor(time);\n    initializeStand(time);                \n    initializeGun(time);\n}\n\nfloat globalID = -1.;\nfloat baseID = -1.;\nfloat standID = -1.;\nfloat gunID = -1.;\n\n\nvec3 testGunTexture_1(vec3 pos){\n\n    vec3 dims = vec3(0.3, 0.1+geoPath1D_b(pos.x*3.-1.99)*0.29, 0.6);\n    vec3 pos_01 = pos/dims;\n    \n    vec3 designs = vec3( max(S(abs(fract(pos_01.y)-0.5)-0.3),\n                       S(abs(8.*pos_01.z)-0.85)),\n                       \n    max(S(abs(fract(8.*pos_01.z)-0.5)-0.4),\n                       S(abs(pos_01.x/2.)-0.2)),\n                       \n    max(S(abs(fract(pos_01.y)-0.5)-0.2),\n                       S(abs(pos_01.x)-0.85)));\n    return designs;\n}\n\nvec3 testStandTexture_1(vec3 pos){\n    vec3 mirroredZ = vec3(abs(pos.x)-0.55,pos.yz);\n    vec3 dims = vec3(\n                0.15 -geoPath1D_b(pos.y*1.+0.7)*0.4*step(0.,mirroredZ.x),\n                0.6,\n                0.25 -geoPath1D_b(pos.y+2.7)*0.3*step(mirroredZ.z,0.) \n                );\n                \n    vec3 pos_01 = (pos-vec3(0.,0.8,0.0))/dims;\n         \n    vec3 designs = vec3(max(S(abs(fract(pos_01.y-0.3))-0.5),\n                       S(abs(pos_01.z*0.7)-0.5)\n                       ),\n                   max(S(abs(fract(pos_01.x)-0.5)-.5),\n                       S(abs(fract(pos_01.z*2.))-0.5)\n                       ),\n                       0.);\n    return designs;\n}\n\nfloat base(vec3 p){\n    vec3 pos = p * theBase.basis - theBase.center;\n    \n    vec3 dims = theBase.dim - vec3(0.,sin(p.z-PI/2.),0.)/4.;\n    \n    float d = sdBox(pos, dims);\n    \n    d = max(d,-sdBox(pos, vec3(0.9,11.,0.9)));\n    return d;\n}\n\nfloat door(vec3 p){\n    p.z = abs(p.z);\n    vec3 pos = (p  - theDoor.center) * theDoor.basis;\n    pos.z += theDoor.dim.z/1.;\n    //pos.y -= theDoor.dim.x*0.5;\n    pos.y -= sin(pos.z*1.6+2.2)/4. - 0.2;\n    \n    \n    float raisedSurface = smoothstep(0.6,0.55,abs(pos.x-0.1))/20.;\n    raisedSurface *= smoothstep(1.4,1.35,abs(pos.z*2.))*2./20.;\n    vec3 dims = theDoor.dim;\n    dims.y -= raisedSurface;\n    \n    float d = sdBox(pos,dims);\n    \n    return d;\n}\n\nfloat stand(vec3 p){\n    \n    vec3 pos = (p  - theStand.center)* theStand.basis;\n    \n    float cyl1 = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.05,0.),\n    cos(atan(pos.x,pos.z)*60.)/40. + .6,0.05)  - 0.01;\n    \n    float cyl2 = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.15,0.),\n    0.66,\n    0.05-smoothstep(0.9,0.85,length(pos.xz)/0.66)*0.035) - 0.015;\n    \n    float cyl3b = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.2,0.),\n    0.3-geoPath1D_b(pos.y*15.-0.4)*0.05,\n    0.15)- 0.015;\n    \n    float cyl4b = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.45,0.),\n    0.15,\n    0.2)- 0.015;\n    \n    //////////////////////finegeo start/////////////////////////\n    vec3 dims = vec3(0.7,0.09, 0.25);\n    vec3 pos_01 = (pos-vec3(0.,theStand.dim.y-0.26,0.))/dims;\n    \n    vec3 designs = vec3(0.,max(S(abs(pos_01.z)-0.5),\n                               S(abs((pos_01.x))-0.42)),0.)/30.;\n\n    /////////////////end of fine geo///////////////////////////   \n    \n    float legBottom = sdBox(pos-vec3(0.,theStand.dim.y-0.26,0.),\n    dims-designs);\n    \n    \n    \n    /////////////////////////for fine geo///////////////\n    vec3 mirroredZ = vec3(abs(pos.x)-0.55,pos.yz);\n   dims = vec3(\n                0.15 -geoPath1D_b(pos.y*1.+0.7)*0.4*step(0.,mirroredZ.x),\n                0.6,\n                0.25 -geoPath1D_b(pos.y+2.7)*0.3*step(mirroredZ.z,0.) \n                );\n                \n    pos_01 = (pos-vec3(0.,0.8,0.0))/dims;\n         \n    designs = vec3(max(S(abs(fract(pos_01.y-0.3))-0.5),\n                       S(abs(pos_01.z*0.7)-0.5)\n                       ),\n                   max(S(abs(fract(pos_01.x)-0.5)-.5),\n                       S(abs(fract(pos_01.z*2.))-0.5)\n                       ),\n                       0.)/100.;\n    float leg = sdBox(mirroredZ-vec3(0.,0.8,0.0), dims-designs.xyz);     \n     //////////////////////end of fine geo/////////////////     \n          \n    \n    \n    float gunAxel = sdCappedCylinder(pos.zxy-vec3(0.05,0.,0.9),\n    0.05,0.65) - 0.015;\n    \n    float topBarRidged = sdCappedCylinder(pos.zxy-vec3(0.05,0.,0.9),\n    0.15 - geoPath1D_b(pos.x*30.)*0.02,\n    0.33) - 0.015;\n    \n    float mirrorX_float = abs(pos.x)-0.4;\n    float topBarGaurd = sdCappedCylinder(vec3(pos.z,mirrorX_float,pos.y)-vec3(0.05,0.,0.9),\n    0.18,0.05) - 0.015;\n    \n    mirrorX_float = abs(pos.x)-0.45;\n    float sideCaps =  length(vec3(mirrorX_float,pos.y-0.9,pos.z-0.05))-0.2;\n        \n   \n    \n    float d = sdBox(pos, \n              theStand.dim);\n    d = 1000.;\n    float silvers = min(d, min(cyl2,cyl1));\n    silvers = min(silvers, cyl3b);\n    silvers = min(silvers, cyl4b);\n    silvers = min(silvers, sideCaps);\n    silvers = min(silvers, topBarRidged);\n    silvers = min(silvers, gunAxel);\n    \n    float blacks = 1000.;\n    blacks = min(blacks, legBottom);\n    blacks = min(blacks, leg);\n    blacks = min(blacks, topBarGaurd);\n    \n    standID = silvers < blacks ? 1. : 2.; \n    \n\n    return min(silvers, blacks);\n}\n\n\nfloat gun(vec3 p){\n\n    vec3 pos = (p*theStand.basis  - theGun.center) * theGun.basis ;\n              \n    float d = 100.;\n    \n    vec3 dims = vec3(0.3,.2+geoPath1D_b(pos.z*3.-1.99)*0.2,0.3);\n    vec3 pos_01 = pos/dims;\n\n    vec3 designs = vec3( 0.,\n    \n    max(S(abs(fract(1.*pos_01.z)-0.5)-0.4),\n                       S(abs(pos_01.x)-0.42)),\n                       \n    max(S(abs(fract(pos_01.y)-0.5)-0.2),\n                      S(abs(2.*pos_01.x)-0.85)));\n    designs /= 20.;\n    float charger = sdBox(pos,dims-designs);\n    \n    \n              \n    dims = vec3(0.3, 0.1+geoPath1D_b(pos.x*3.-1.99)*0.29, 0.6);\n    pos_01 = pos/dims;\n    \n    designs = vec3( max(S(abs(fract(pos_01.y)-0.5)-0.3),\n                       S(abs(8.*pos_01.z)-0.85)),\n                       \n    max(S(abs(fract(8.*pos_01.z)-0.5)-0.4),\n                       S(abs(pos_01.x/2.)-0.2)),\n                       \n    max(S(abs(fract(pos_01.y)-0.5)-0.2),\n                       S(abs(pos_01.x)-0.85)));\n                        \n    designs /= 20.;\n\n    float barrel = sdBox(pos-vec3(0.,0.,.8), dims-designs);\n\n\n\n\n    float cylBarrel1 = sdCappedCylinderZ(pos-vec3(0.,0.,1.),\n    0.12-geoPath1D(pos.z*34.)*0.05*step(pos.z,1.8),\n    0.9)- 0.015;\n    float cylBarrel2 = sdCappedCylinderZ(pos-vec3(0.,0.,1.3),\n    0.08,\n    0.9)- 0.015;\n    float cylBarrel3 = sdCappedCylinderZ(pos-vec3(0.,0.,2.4),\n    0.1 + clamp(geoPath1D(atan(pos.x,pos.y)*3.)*0.08,0.,0.03)\n        * smoothstep(2.4,2.45,pos.z),\n    0.25)- 0.015;\n    \n    float cylBarrelCut = sdCappedCylinderZ(pos-vec3(0.,0.,2.4),\n    0.08, 1.3)- 0.015;\n    \n    d = 10.;\n    \n    d = min(d, charger);\n    d = min(d, barrel);\n    d = min(d, cylBarrel1);\n    d = min(d, cylBarrel2);\n    d = min(d, cylBarrel3);\n    d = max(d, -cylBarrelCut);\n    \n    gunID = abs(cylBarrel2-d) < 0.001 || abs(cylBarrel1-d) < 0.001 \n    ? 1. : 2.;\n    \n    \n    return d;\n}\n\n\nfloat map(vec3 p){\n    //Split the world into coordinates,\n    vec2 floorID = vec2(0.);//floor(p.xz/4.-2.);\n    //p.xz = mod(p.xz,4.*WORLD_SCALE)-2.*WORLD_SCALE;\n    //initalize the objects in their current animated position,\n    initializeObjects(rnd2D(floorID)*800.+iTime);\n    //and return the distance field.\n    float alle = 1000.;\n    \n    float dGun = gun(p/WORLD_SCALE);\n    float dStand = stand(p/WORLD_SCALE);\n    float dBase = base(p/WORLD_SCALE);\n    float dDoor = door(p/WORLD_SCALE);\n    \n    alle = min(dGun,alle);\n    alle = min(dStand,alle);\n    alle = min(dBase,alle);\n    alle = min(dDoor,alle);\n    \n    if(abs(alle-dGun) < 0.001){\n        globalID = 1.;\n    }\n    else if(abs(alle-dStand) < 0.001){\n        globalID = 2.;\n    }\n    else if(abs(alle-dBase) < 0.001){\n       globalID = 3.;\n    }\n    else if(abs(alle-dDoor) < 0.001){\n      globalID = 4.;\n   }\n   // \n    return alle;\n    \n    //return min(gun(p),min(stand(p),min(100.,base(p))));\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.5;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 24; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d*0.75;\n    }\n    \n    return t;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 getObjectColor(vec3 p){\n\n//gun == 1\n//stand == 2\n//base == 3]\n    \n    vec3 gunPos = (p*theStand.basis  - theGun.center) * theGun.basis;\n    vec3 standPos = (p  - theStand.center)* theStand.basis;\n    \n    if(globalID == 1.){  return gunID == 1. ? \n                             vec3(0.7)          : \n                             mix(vec3(0.1),\n                             vec3(1.,0.,0.),\n                             testGunTexture_1(gunPos).z);\n                         }\n                         \n    else if(globalID == 2.){ return standID == 1. ?  \n                             vec3(0.7) : \n                             mix(vec3(0.1),\n                             vec3(1.,0.,0.),\n                             testStandTexture_1(standPos).x);\n                         }\n    else if(globalID == 3.){return vec3(0.9,0.,0.);}\n    else if(globalID == 4.){return vec3(.3);}\n    return vec3(globalID/3.);\n}\n\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    vec3 objCol = getObjectColor(sp)+0.25;\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., .6, .2)*spec*2.) ;//* atten;\n    float fogF = smoothstep(0., .95, t/FAR);\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n    return sceneCol;\n    \n}\n\nvec3 getCameraDirection(vec2 uv, vec3 ro, vec3 ta){\n\n    vec3 fwd = normalize(ta-ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(fwd,ri));\n    return normalize(uv.x*ri + uv.y*up + fwd*1.2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 ta,ro;\n    \n    if(VIEW == 1.){\n        ta = vec3(0.,2.,0.);\n        ro = vec3(0.,3.,9.5) * WORLD_SCALE;\n    }\n    else if(VIEW == 2.){\n        ta = vec3(0.,0.,0.);\n        ro = vec3(0.,7.,.5) * WORLD_SCALE;\n    }\n    \n\n   \n    if(iMouse.z > 0.5){\n        //float rotScale = 4.;\n        vec2 m = iMouse.xy/iResolution.xy;\n        //vec3 ro = vec3(0., 1., -3.);\n        ro.yz *= rot(-m.y*PI+1.);\n        ro.xz *= rot(-m.x*PI*2.);\n        //ro.xz *= rot(4.*(iMouse.x/iResolution.x)-rotScale/2.);\n        //ro.yz *= rot((iMouse.y/iResolution.y)*PI);\n    }\n    else{\n        //ro.yz *= rot(sin(iTime/4.)-0.2);\n        ro.xz *= rot(-iTime/3.);\n    }\n    vec3 rd = getCameraDirection(uv,ro,ta);\n    \n\n\n    vec3 lp = ro + vec3(0., 0., 1.);\n    //\n    \n    float planeT = pointOnPlane(ro,rd);\n    \n    \n   // initializeObjects();//(and animate them)\n    float t = trace(ro, rd);\n    \n    if(t < FAR){\n        vec3 pos = ro + rd*t; \n        vec3 sn = getNormal(pos);\n        col += doColor(pos, rd, sn, lp, t)/2.;\n        vec3 p = pos;\n        \n        /*\n        col = mix(col, vec3(1.,0.,0.),\n            step(0.01,shapeDecline(p.xz / WORLD_SCALE,0.,0.,0.,0.)));\n            \n        col = mix(col, vec3(1.),\n            step(0.01,complexMap(p.xz / WORLD_SCALE)));  \n            \n        col = mix(col, vec3(0.,0.,1.),\n            step(0.01,floppyDiskThing(p.xz / WORLD_SCALE))); \n            \n        col = mix(col, vec3(0.,0.,1.),\n            step(0.01,floppyDiskThing3(p.xz / WORLD_SCALE)));*/\n\n    }\n    if(rd.y >= 0.){\n    //    col = mix(col,vec3(0.8,0.8,0.9),pow(1.-rd.y,50.));\n    }\n    \n    if(planeT > 0. && t > FAR){\n        vec3 pos = ro + rd*planeT; \n        vec3 sn = vec3(0.,1.,0.);\n        vec2 vh = step(abs(fract(pos.xz)),vec2(0.04));\n       // float hori = step(abs(fract(pos.z)-0.5),0.04);\n        col += (vh.x+vh.y)/5.;//doColor(pos, rd, vec3(0.,1.,0.), lp, t);\n       // float sh = softShadow(ro +  sn*.0015, lp, 16.);\n       \n    }\n\n    //col = vec3(floppyDiskThing3(uv*3.));//shapeLadder(uv*2.));\n    float textureFrame;\n    vec2 uvFrame = abs(uv)-0.3;\n    float uvF = max(uvFrame.x,uvFrame.y);\n    //col += smoothstep(0.01,0.,abs(uvF-0.2));\n    fragColor = vec4(col,1.);//sqrt(clamp(col, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n#define animator (sin(iTime)*0.5+0.5)\n#define startTime (iTime*4. +30.)\n#define newAnimator (sin(startTime)*0.5+0.5)\n\n\n#define sequence (abs(mod(startTime/4.,12.)-6.))\n\n#define SEQ_0 clamp(sequence,   0.,1.)\n#define SEQ_1 clamp(sequence-1., 0.,1.)\n#define SEQ_2 clamp(sequence-2.,0.,1.)\n#define SEQ_3 clamp(sequence-3.,0.,1.)\n#define SEQ_4 clamp(sequence-4.,0.,1.)\n#define SEQ_5 clamp(sequence-5.,0.,1.)\n\n#define IDENTITY mat3(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.))\n\n#define WORLD_SCALE 1.\n#define FAR 50.\n#define S(a) smoothstep(0.,0.05,a)\n\n#define ANIMATOR 0.5//abs(fract(time)-0.5)\nfloat rnd(float a){\n    return fract(sin(a)*45960.24562);\n}\n\nfloat rnd2D(vec2 id){\n    return fract(sin(dot(vec2(12.94,73.59),id))*45960.24562);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nfloat sdBox(vec3 pos, vec3 dim){\n    vec3 aPos = abs(pos) - dim;\n    return max(aPos.x, max(aPos.y,aPos.z) );\n}\n\nmat3 rotateX(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].yz *= theRotation;\n    basis[1].yz *= theRotation;\n    basis[2].yz *= theRotation;\n    return basis;\n}\n\nmat3 rotateY(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].xz *= theRotation;\n    basis[1].xz *= theRotation;\n    basis[2].xz *= theRotation;\n    return basis;\n}\n\nmat3 rotateZ(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].xy *= theRotation;\n    basis[1].xy *= theRotation;\n    basis[2].xy *= theRotation;\n    return basis;\n}\n\nfloat pointOnPlane(vec3 ro, vec3 rd){\n    vec3 pp = vec3(0.);\n    vec3 n = vec3(0.,1.,0.);\n    float t = (dot(pp,n)-dot(ro,n))/dot(rd,n);\n    return t < FAR ? t : -1.;\n}\n\nfloat geoPath1D(float dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.1, 0.35)*1.5;\n}\nfloat geoPath1D_b(float dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.0, 0.23)*1.4;\n}\n\nvec2 geoPath(vec2 dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.0, 0.35)*1.5;\n}\n\nvec2 geoBumpPath(vec2 dir){\n    return clamp(\n                abs(fract(dir/2.)-0.5),\n           0.0, 0.35)*1.5;\n}\n\nfloat shapeDecline(vec2 uv, \n    float height, float degree, float smoothStart, float smoothEnd){\n    vec2 decline = pow(smoothstep(1.,0.75,abs(uv)),vec2(4.)) *0.15;\n    return min(decline.x,decline.y);\n}\n\nfloat shapeSinGroove(vec2 uv,float height,\nfloat smoothStart,float smoothEnd){\n    //smoothstart = 0.75, smoothEnd = 0.7    \n    return smoothstep(smoothStart,smoothEnd,\n    abs(uv.x-sin(uv.y)))/height;//9.\n}\n\nfloat shapeGeoGroove(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    vec2 geoGroove = smoothstep(0.75,0.7,\n                abs(uv.xy+shiftToSide)-widen+geoPath(uv.yx))/height;//18.\n                \n    return min(geoGroove.x,geoGroove.y);\n}\nfloat shapeGeoGroove1D(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    float geoGroove = smoothstep(0.75,0.7,\n                abs(uv.x+shiftToSide)-widen+geoPath1D(uv.y))/height;//18.\n                \n    return geoGroove;\n}\nfloat shapeGeoGroove1D_b(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    float geoGroove = smoothstep(0.75,0.7,\n                abs(uv.x+shiftToSide)-widen+geoPath1D_b(uv.y))/height;//18.\n                \n    return geoGroove;\n}\nfloat shapeOutlineBump(vec2 uv){\n\n    vec2 outlineBump = smoothstep(0.08,0.0, \n                abs(abs(uv.xy)-0.96) ) * 0.05;\n    return max(outlineBump.x,outlineBump.y);\n}\n\nfloat shapeGeoBump(vec2 uv){\n\n    float widenSides = 0.99;\n    float widenBump = 0.6; //larger is thinner, thinnest is 1.4\n    vec2 geoBump = smoothstep(0.75,0.7, \n                     abs(abs(uv.xy)-widenSides+\n                     geoBumpPath(uv.yx))+widenBump)/15.;\n    return  max(geoBump.x,geoBump.y);\n}\n\nfloat shapeLadder(vec2 uv){\n    float sq = max(abs(uv.y)-0.3,abs(uv.x)-0.3);\n    uv *= rot(PI*0.25);\n    uv = abs(uv)-0.65;\n    uv *= rot(PI*0.25);\n    float d = smoothstep(0.2,0.18,abs(uv.x)-0.06) * \n              step(abs(uv.y)-0.2,0.1);\n              \n    uv.y = smoothstep(.2,0.2,abs(fract(uv.y*25.+0.24)-0.4));\n    vec2 bf = abs(uv)+vec2(0.22,-0.2);\n    float cut = max(bf.x,bf.y);\n    cut = smoothstep(0.3,0.2,cut);\n    d = min(d,cut);\n    \n    return d*step(sq,0.55);\n}\n\nfloat complexMap(vec2 uv){\n    //uv *= 2.;\n    \n    float d = smoothstep(0.,0.1,shapeGeoGroove1D(uv,.0,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D(uv,.06,12.))/18.;\n    d -= smoothstep(0.1,0.,shapeGeoGroove1D(uv,.2,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D(uv,.26,12.))/18.;\n    d -= smoothstep(0.1,0.,shapeGeoGroove1D(uv,.3,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D_b(uv,.49,12.))/18.;\n    return d;\n}\n\nfloat floppyDiskThing(vec2 uv){\n    vec2 spread = vec2(6., 2.2);\n    uv*=8.;\n    uv = abs(uv)-spread;\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    d = clamp(d,0.,1.);\n    d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\n\nfloat floppyDiskThing2(vec2 uv){\n    \n    uv*=2.;\n    //uv = abs(uv)-vec2(6.,1.5);\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n             \n    d = clamp(d,0.,1.);\n    \n    uv*=2.;\n    uv.y = abs(uv.y)-1.5;\n    float cut = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    cut = clamp(cut,0.,1.);    \n    d = min(d,cut);\n   // d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\nfloat floppyDiskThing3(vec2 uv){\n    uv*= 2.;\n    uv.x = abs(uv.x)-1.4;\n    uv*=2.;\n    //uv = abs(uv)-vec2(6.,1.5);\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n             \n    d = clamp(d,0.,1.);\n    \n    uv*=1.2;\n    uv.x -= 0.55;\n    uv.y = abs(uv.y)-1.2;\n    float cut = max(abs(uv.x*0.8)-0.3-geoPath1D(uv.y/1.)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    //cut = clamp(cut,0.,1.); \n    cut = smoothstep(0.9,0.4,cut);\n    d = max(d,cut);\n   // d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}