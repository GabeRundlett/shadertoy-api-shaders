{
    "Shader": {
        "info": {
            "date": "1627321763",
            "description": "cubes on loop",
            "flags": 0,
            "hasliked": 0,
            "id": "ft2SRw",
            "likes": 6,
            "name": "infinite cubes",
            "published": 3,
            "tags": [
                "infiniteabberationrecursion"
            ],
            "usePreview": 0,
            "username": "calimops",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.1415926\n\n// SETTINGS\nconst float zFar = 50.;\nconst float zNear = 1.;\n\nconst vec3 background_color = vec3(0.7);\nconst float collision_distance = 0.001;\nconst int marching_iterations = 64;\n\nconst float normal_partial_derivative_epsilon = 0.00001;\n\n// COLORS\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0.8);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\n// Transformations\nmat4 worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n\nvoid identity() {\n    worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n}\n\nvoid scale(in float a, in float b, in float c) {\n    worldMatrix *= mat4(a , 0., 0., 0.,\n                        0., b , 0., 0.,\n                        0., 0., c , 0.,\n                        0., 0., 0., 1.);\n}\n\nvoid trans(in vec3 v) {\n    worldMatrix *= mat4(1., 0., 0., v.x,\n                        0., 1., 0., v.y,\n                        0., 0., 1., v.z,\n                        0., 0., 0., 1.);\n}\n\n\nconst float factor = 0.001;\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n//      p = vec3(p.x*cos(iTime*factor) - p.y*sin(iTime*factor), p.x*sin(iTime*factor) + p.y*cos(iTime*factor), p.z);\n      p = abs(p)-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec4 scene(vec3 pos) {\n    pos = (vec4(pos, 1.) * worldMatrix).xyz;\n    pos = mod(pos, 10.)-5.0;\n    return vec4(blue, sdBoundingBox(pos, vec3(3.0), 0.3)); \n}\n\nvec3 calcNormal( in vec3 p ) {\n    const float h = 0.001;\n    const vec2 k = vec2(1, -1);\n    return normalize( k.xyy * scene( p + k.xyy * h ).a + \n                      k.yyx * scene( p + k.yyx * h ).a + \n                      k.yxy * scene( p + k.yxy * h ).a + \n                      k.xxx * scene( p + k.xxx * h ).a );\n}\n\nvec4 ray_marching(vec3 pos, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    float mindist;\n    vec3 color;\n    vec3 norm;\n\n    for (int i = 0; i < marching_iterations; ++i) {\n    \n//        pos = vec3(pos.x*cos(len*factor) - pos.y*sin(len*factor), pos.x*sin(len*factor) + pos.y*cos(len*factor), pos.z);\n\n        vec4 tmp = scene(pos);\n        \n        color = tmp.rgb;\n        mindist = tmp.a;\n        norm = calcNormal(pos);\n        len += mindist;\n        \n        //pos = vec3(pos.x*cos(len*factor) - pos.y*sin(len*factor), pos.x*sin(len*factor) + pos.y*cos(len*factor), pos.z);\n\n        if (mindist < collision_distance) \n        {\n            return vec4(color * max(0.4, dot(normalize(vec3(0.) - pos), norm)), len);\n        }\n        \n        if (len > zFar) \n        {\n            return vec4(background_color, len);\n        }\n\n        //len += mindist;\n        pos += dir * mindist;\n    }\n    return vec4(background_color, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    //uv.y = 1. - uv.y;\n    \n    float aberrationAmount = 0.1;\n    vec2 distFromCenter = uv - 0.5;\n    \n    vec2 aberrated = aberrationAmount * pow(distFromCenter, vec2(3.0, 3.0));\n    \n\n    identity();\n    trans(vec3(5, 5, 10.*iTime));\n    //rotx(iTime/10.0 + 2.);\n    //rotz(iTime/10.0 + 2.);\n    //roty(iTime/10.0 + 2.);\n    \n    vec4 rayMar1 = ray_marching(vec3(0.), vec3(uv - vec2(0.5)-aberrated, zNear));\n    vec4 rayMar2 = ray_marching(vec3(0.), vec3(uv - vec2(0.5), zNear));\n    vec4 rayMar3 = ray_marching(vec3(0.), vec3(uv - vec2(0.5)+aberrated, zNear));\n    \n    vec3 color = (exp(-0.06 * rayMar2.a)) * vec3(rayMar1.r, rayMar2.g, rayMar3.b);\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}