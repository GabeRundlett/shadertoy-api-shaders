{
    "Shader": {
        "info": {
            "date": "1558559369",
            "description": "Copy of an old shader with slightly different shapes and a different soundcloud",
            "flags": 64,
            "hasliked": 0,
            "id": "wl23R1",
            "likes": 3,
            "name": "fork for a different tune",
            "published": 3,
            "tags": [
                "music",
                "copypasta",
                "tunes"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 1500.0\n\n#define INTEGRATE_UNBOUNDED_STUFF 1\n// set to 0 to make the density of the glowy stuff 1/(distance^2)\n// by default it's 1/distance, which means the total glow contribution grows with MAX_DIST\n// I think it looks better with 1/distance\n// but, hey, neither of these functions come from \"physics\"\n// (or, if they do, it is only by coincidence)\n//\n// p.s. looks really nice when MAX_DIST is huge (thanks @CLPB for pointing this out)\n\nconst vec3 light = vec3(0.48, 0.64, -0.6);\n\nvec3 ball1;\nvec3 ball2;\nvec3 ball3;\n\nvec3 radii;\n\nvec3 s_max_v3(in vec3 x, in vec3 y, in float s) {\n    vec3 bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nvec3 s_abs(in vec3 x, in float s) {\n    return s_max_v3(x, -x, s);\n}\n\nfloat sdf1(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball1) - 0.25 * radii.x)) - 0.5 * radii.x;\n}\n\nfloat sdf2(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball2) - 0.375 * radii.y)) - 0.375 * radii.y;\n        //dot(s_abs(pt - ball2, 0.25 * radii.y), vec3(0.5)) - 0.5 * radii.y;\n}\n\nfloat sdf3(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball3) - 0.5 * radii.z)) - 0.25 * radii.z;\n}\n\nvec3 sdfs(in vec3 pt) {\n    return vec3(sdf1(pt), sdf2(pt), sdf3(pt));\n}\n\nfloat sdf(in vec3 pt) {\n    return min(sdf1(pt), min(sdf2(pt), sdf3(pt)));\n}\n\nfloat min_comp(in vec3 comps) {\n    return min(comps.x, min(comps.y, comps.z));\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                sdf(pt + vec3(0.0, h, 0.0)) - f,\n                sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir, out vec3 integral) {\n    integral = vec3(0.0);\n    float curr = 0.0;\n    const float step_ratio = 0.25;\n    vec3 curr_sdf = sdfs(orig);\n    float dist = step_ratio * min_comp(curr_sdf);\n    vec3 next_sdf = sdfs(orig + dir * dist);\n    // integral from 0 to d of 1/(a+bx) =\n    // screw it, just average some things.\n    integral = dist * (0.25 / curr_sdf + 1.0 / (curr_sdf + next_sdf) + 0.25 / next_sdf);\n    float total_dist = dist;\n    const vec3 thresh = vec3(0.004);\n    for (int i = 0; i < 128; ++i) {\n        curr_sdf = next_sdf;\n        dist = step_ratio * min_comp(curr_sdf);\n        total_dist += dist;\n        next_sdf = sdfs(orig + total_dist * dir);\n        vec3 mid = 0.5 * (curr_sdf + next_sdf);\n#if INTEGRATE_UNBOUNDED_STUFF        \n        integral += dist * (0.25 / max(thresh, curr_sdf) + \n                            0.5 / max(thresh, mid ) + \n                            0.25 / max(thresh, next_sdf));\n#else\n        integral += dist * (0.25 / max(thresh, curr_sdf * curr_sdf) + \n                            0.5 / max(thresh , mid * mid ) + \n                            0.25 / max(thresh, next_sdf * next_sdf));\n#endif        \n        if (min_comp(next_sdf) < 1.0e-3 || total_dist > MAX_DIST) {\n            return total_dist;\n        }\n    }\n    return total_dist;\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 orig = vec3(0.0, 0.1, -1.25);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                0.0, 0.28, -0.96,\n                0.0, 0.96, 0.28); \n    orig = tilt * orig;\n    dir = tilt * dir;\n    \n    float theta = 0.6 * iTime;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    float rad = 0.6;\n\n    ball1 = rad * vec3(ct, st, 0.0);\n\n    ct = cos(theta + 2.0 * 3.141592654 / 3.0);\n    st = sin(theta + 2.0 * 3.141592654 / 3.0);\n    ball2 = rad * vec3(ct, st, 0.0);\n    \n    ct = cos(theta - 2.0 * 3.141592654 / 3.0);\n    st = sin(theta - 2.0 * 3.141592654 / 3.0);\n    ball3 = rad * vec3(ct, st, 0.0);\n\n    vec3 integral;\n    \n    radii = 0.3 + 0.2 * vec3(texture(iChannel0, vec2(0.0, 0.0)).r,\n                             texture(iChannel0, vec2(0.5, 0.0)).r,\n                             texture(iChannel0, vec2(1.0, 0.0)).r);\n    \n    float raydist = raymarch(orig, dir, integral);\n\n#if INTEGRATE_UNBOUNDED_STUFF    \n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 0.45/(integral));\n#else\n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 1.5/(integral));    \n#endif    \n    \n    col = mat3(0.7, 0.6, 0.3,\n               0.5, 0.1, 0.7,\n               0.0, 0.0, 1.1) * col.zyx;\n    if (raydist < MAX_DIST) {\n        vec3 pt = orig + raydist * dir;\n        vec3 norm = normalize(sdf_grad(pt));\n        vec3 bounce = normalize(reflect(dir, norm));\n        col += 0.5 * smoothstep(0.45, 1.0, dot(bounce, light)) * vec3(0.9, 0.8, 1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 34728,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/geoffreybovy/unreleased-instrumental-hip"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}