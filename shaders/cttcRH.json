{
    "Shader": {
        "info": {
            "date": "1698909392",
            "description": "Breathing Terrain (meditation).\nThis shader demonstrates generation of smooth random functions, over space and time.",
            "flags": 32,
            "hasliked": 0,
            "id": "cttcRH",
            "likes": 2,
            "name": "Breathing Terrain2 + smooth",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "terrain",
                "generative",
                "meditaion"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 123
        },
        "renderpass": [
            {
                "code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\nvec4 TM(ivec2 x, int maxx, int mid) {\n  return T(x, maxx) - T(ivec2(mid, x.y), maxx)*0.5;\n}\n\nfloat stylize(float cc, float tf, float ts) {\n    float pw = pow(cc,0.8);\n    float cr = (floor(pw*30. + ts)-ts)/30. + fract(cc*30. + tf)/20.;\n    return cr;\n}\n\nfloat stylize2(float cc, float tf, float ts) {\n    float pw = cc * 1.06;//pow(cc,0.8);\n    float cr = (floor(pw*5. + ts)-ts)/5. + fract(cc*10. + tf);\n    return cr;\n}\n\nfloat atan2f(vec2 v, float sc, float sh, float sha) {\n    float a = v.y != 0. ? atan(v.x / v.y) : 3.14159265358/2.;\n    return fract((a / 3.1415926 + sha) * sc + sh);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//#define SMOOTH(BIG, SMALL, DIFF)    smoothstep(0., 1., ((BIG) - (SMALL))*pix)\n#define SMOOTH(BIG, SMALL, DIFF)    clamp(((BIG) - (SMALL))/(DIFF), 0., 1.)\n#define BLEND(COLOR, OP)  \\\n  float addOp = (1. - fragColor.a) * (OP); \\\n  fragColor += vec4((COLOR) * vec3(addOp), addOp); \\\n// EOM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int maxx = int(iResolution.x)-1;\n    int imid = int(iResolution.x)>>1;\n    float pix = 1.5 / iResolution.y;\n    fragColor = vec4(0.);\n\n    // Land\n    float c = T(ivec2(int(fragCoord.x), 3), maxx).r * 1.5 - T(ivec2(imid, 3), maxx).r*0.6 + 0.35;\n    if (c > uv.y) {\n        float cc = uv.y - c + 0.8;\n        float op = SMOOTH(c, uv.y, pix);\n        BLEND(vec3(stylize(cc, 0., 0.))*vec3(0.7, 0.5, 0.3), op);\n        if (op == 1.) return;\n    }\n\n    vec2 cs;\n    float d, r, rpw;\n\n    // Sun\n    cs = iResolution.xy*vec2(0.75, 0.65);\n    d = distance(fragCoord.xy, cs);\n    rpw = pow(T(ivec2(int(atan2f(fragCoord - cs, 5., iTime / 40., 0.5)*iResolution.x), 2), maxx).r + 0.5, 5.) * 5. + 0.4;\n    r = min(iResolution.x, iResolution.y) * 0.17 * rpw;\n    if (d < r) {\n        float cc = d / r;\n        float op = SMOOTH(r, d, 1.5 * rpw);\n        BLEND(vec3(vec2(stylize(1.-cc*0.2, iTime/3., iTime/5.)), 1.-cc), op);\n        if (op == 1.) return;\n    }\n    \n    // Stars\n    for (int i = 0; i < 20; i++) {\n        cs = iResolution.xy * (hash21(float(i+1)) * vec2(1., 0.6) + vec2(0, 0.4));\n        d = distance(fragCoord.xy, cs);\n        rpw = pow(T(ivec2(int(atan2f(fragCoord - cs, 2., -iTime * (hash11(float(i+1))-0.5)/10., float(i*2))*iResolution.x), 6+i), maxx).r + 0.5, 9.) * 5. + 0.03;\n        float rpwMid = pow(T(ivec2(imid, 6+i), maxx).r + 0.5, 9.) * 5. + 0.03;\n        r = min(iResolution.x, iResolution.y) * max(0.1 * rpw - rpwMid * 0.02, rpwMid * 0.04);\n        if (d < r) {\n            float cc = d / r;\n            float op = SMOOTH(r, d, (1. + 0.1/pix) * rpw);\n            BLEND(vec3(stylize2(1.-cc*0.3, iTime*1.5, iTime)), op);\n            if (op == 1.) return;\n        }\n    }\n\n    // Cloud\n    for (int n = 0; n < 4; n += 1) {\n        float h = (T(ivec2(fragCoord.x, 2), maxx).r + 0.0) * 0.1;\n        cs = iResolution.xy*vec2(0.45 - float(n) * 0.05, 0.45 + h);\n        d = distance(fragCoord.xy, cs);\n        float sc = smoothstep(0.41 + h, 0.44 + h, uv.y);\n        //float sc = 1.-pow(1.-smoothstep(0.41, 0.44, uv.y), 2.);\n        float rpw = (T(ivec2(int(atan2f(fragCoord - cs, 1., 3.1415926/2., float(n)*0.753 - iTime * (float(n) - 1.4) / 100.)*iResolution.x), 4+n), maxx).r + 0.5) * 0.5 * sc + 0.1;\n        r = min(iResolution.x, iResolution.y) * (0.21 - float(n)*0.015) * rpw;\n        if (d < r) {\n            float cc = d / r;\n            //fragColor = vec4(vec3(stylize((1.-cc*0.1), iTime/5., iTime/15.) * (smoothstep(0.41, 0.5, uv.y)*0.9 + 0.1)), 1.0);\n            float op = SMOOTH(r, d, 2.5);\n            BLEND(vec3(1.), op);\n            if (op == 1.) return;\n        }\n    }\n\n    // Water\n    if (uv.y < 0.35) {\n        c = T(ivec2(int(fragCoord.x), 2), maxx).r/5. + 0.35;\n        float cc = 1. - pow(uv.y - c + 0.9, 10.);\n        BLEND(vec3(0.,  vec2(stylize(cc, -iTime/3., -iTime/5.))* vec2(0.4, 0.45)), 1.0);\n        return;\n    }\n\n\n    // Small stars\n#define SKY_TO(X)       ((X) * vec2(1., 0.65) + vec2(0., 0.35))\n#define SKY_FROM(X)     ((X - vec2(0., 0.35)) / vec2(1., 0.65))\n#define SKYY_TO(X)       ((X) * 0.65 + 0.35)\n#define SKYY_FROM(X)     ((X - 0.35) / 0.65)\n#define MID(X)        (1.-(pow((X-0.5),2.)*.4))\n    float nStars = iResolution.x * iResolution.y / 10000.;\n    for (float n = 0.; n < nStars; n++) {\n        cs = iResolution.xy * SKY_TO(hash21(-n-10.));\n\n        //cs += vec2(\n        //    TM(ivec2(int(cs.x), 8), maxx, imid).r,\n        //    TM(ivec2(int(SKYY_FROM(cs.y/iResolution.y)*iResolution.x), 11), maxx, imid).r\n        //)*iResolution.xy/vec2(10.);\n\n        d = distance(cs, fragCoord.xy);\n        if (d <= 1.) {\n            float op = SMOOTH(1., d, 1.);\n            BLEND(vec3(stylize2(1.-d*0.005, -iTime/20. + n/nStars, -iTime/30.)), op);\n            break;\n        }\n    }\n\n    // Sky\n    float cc = clamp(uv.y * 1.3 - 0.5, 0., 1.);\n    //float cc = (1.-uv.y) * 1.1 - 0.1;\n    BLEND(vec3(0., 0., stylize(cc, -iTime/8., iTime/12.)), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define T(X)     texelFetch(iChannel0, X, 0)\n\nvec4 T(ivec2 x, int maxx) {\n  return x.x > 0 && x.x < maxx ? texelFetch(iChannel0, x, 0) : vec4(0.);\n}\n\nint tier_n(int x) {\n  if ((x & 0xffff) == 0) { return 16; }\n  int ret = 0;\n  if ((x & 0xff) == 0) { ret += 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret += 4; x >>= 4; }\n  if ((x & 3) == 0) { ret += 2; x >>= 2; }\n  if ((x & 1) == 0) { ret += 1; }\n  return ret;\n}\n\nint tier_s(int x) {\n  if ((x & 0xffff) == 0) { return 0x10000; }\n  int ret = 1;\n  if ((x & 0xff) == 0) { ret <<= 8; x >>= 8; }\n  if ((x & 0x0f) == 0) { ret <<= 4; x >>= 4; }\n  if ((x & 3) == 0) { ret <<= 2; x >>= 2; }\n  if ((x & 1) == 0) { ret <<= 1; }\n  return ret;\n}\n\nint pow2ceil(int x) {\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  x |= x >> 8;\n  x |= x >> 16;\n  return x+1;\n}\n\nfloat pow_of_2_adj(vec2 iResolution) {\n  return  iResolution.y / iResolution.x / pow(2., ceil(log(iResolution.x+1.)/log(2.)) - 3.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 position)\n{\n    vec2 p = (position + mod(iTime, 200.) * 1500. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(ivec2 nx, int t, float tm)\n{\n    if (nx.x == 0) return 0.;\n//    if (t < 5) return 0.;\n//    return 0.1;\n    vec2 p = (vec2(nx) + mod(tm, 200.) * 1501. + 50.0);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float sh = sin(float(t + nx*5) + iTime/2.) / float(t+1) / iResolution.x * iResolution.y;\n    return (fract((p3.x + p3.y) * p3.z) - 0.5 + sh) / 2. / iResolution.x * iResolution.y;\n}\n\nfloat randt(ivec2 nx, int t, float y) {\n    float tm = ((100. + iTime + y*33.33)*(1. - y * 0.01)  + float(nx.x)/100.)/float(t+1);\n    float tt = floor(tm), tf = fract(tm);\n    return mix(rand(nx, t, tt), rand(nx, t, tt+1.), smoothstep(0., 1., tf));\n}\n\n//#define MOD(X)  ((X + iResolution_i.x) % iResolution_i.x)\n#define MOD(X)  X\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 30.) return;\n    ivec2 fragCoord_i = ivec2(fragCoord);\n    ivec2 iResolution_i = ivec2(iResolution);\n    int maxx = iResolution_i.x-1;\n    int pow2_mid_adj = (pow2ceil(iResolution_i.x) - iResolution_i.x) >> 1;\n    int tier =  tier_n(fragCoord_i.x + pow2_mid_adj);\n    int st = (1 << tier); //tier_s(fragCoord_i.x);\n\n    float c = randt(fragCoord_i, tier, fragCoord.y) * float(st) * pow_of_2_adj(iResolution.xy);\n    //if (tier < tier_n(pow2ceil(iResolution_i.x))-2) {\n        c += (T(ivec2(MOD(fragCoord_i.x - st), fragCoord_i.y), maxx).r + T(ivec2(MOD(fragCoord_i.x + st), fragCoord_i.y), maxx)).r / 2.;\n    //}\n    fragColor = vec4(vec3(c), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}