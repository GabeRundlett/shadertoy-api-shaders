{
    "Shader": {
        "info": {
            "date": "1610120214",
            "description": "Trying to reinvent the wheel a bit to understand the marching cubes algorithm. Next step, connecting the dots (may or may not work well in a shader).",
            "flags": 0,
            "hasliked": 0,
            "id": "WlccWl",
            "likes": 12,
            "name": "MCubes Step 1 - Vertex Placement",
            "published": 3,
            "tags": [
                "3d",
                "marchingcubes",
                "vertexplacement",
                "meshing"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "// checkEdge() checks whether two point straddle the surface by checking for opposite signs\n#define checkEdge(a, b) (a < 0.0) != (b < 0.0)\n\n// vertexInterp() Solves for the intersection point linearly and interpolates the edge vertices (v1 and v2) accordingly\n#define vertexInterp(v1, v2, d1, d2) mix(v1, v2, d1 / (d1 - d2))\n\nfloat sdShape(in vec3 p) {\n    p /= 1.5;\n    vec3 q = abs(p) - 1.35;\n    float cube = max(q.x, max(q.y, q.z));\n    float sphere = length(p) - 1.6875;\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3))) * 1.5;\n}\n\nvec4 mapScene(in vec3 p) {\n    float csz = 0.6 + 0.5 * sin(iTime); // Cell size\n    float shape = sdShape(p);\n\n    vec3 c = floor(p / csz) * csz;\n\n    vec3 ldb_p = c;                       // (l)eft,  (d)own, (b)ack  cell corner\n    vec3 rdb_p = c + vec3(csz, 0.0, 0.0); // (r)ight, (d)own, (b)ack  cell corner\n    vec3 lub_p = c + vec3(0.0, csz, 0.0); // (l)eft,  (u)p,   (b)ack  cell corner\n    vec3 rub_p = c + vec3(csz, csz, 0.0); // (r)ight, (u)p,   (b)ack  cell corner\n    vec3 ldf_p = c + vec3(0.0, 0.0, csz); // (l)eft,  (d)own, (f)ront cell corner\n    vec3 rdf_p = c + vec3(csz, 0.0, csz); // (r)ight, (d)own, (f)ront cell corner\n    vec3 luf_p = c + vec3(0.0, csz, csz); // (l)eft,  (u)p,   (f)ront cell corner\n    vec3 ruf_p = c + csz;                 // (r)ight, (u)p,   (f)ront cell corner\n\n    float ldb = sdShape(ldb_p); // Distance field sample at cell corner ldb_p\n    float rdb = sdShape(rdb_p); // Distance field sample at cell corner rdb_p\n    float lub = sdShape(lub_p); // Distance field sample at cell corner lub_p\n    float rub = sdShape(rub_p); // Distance field sample at cell corner rub_p\n    float ldf = sdShape(ldf_p); // Distance field sample at cell corner ldf_p\n    float rdf = sdShape(rdf_p); // Distance field sample at cell corner rdf_p\n    float luf = sdShape(luf_p); // Distance field sample at cell corner luf_p\n    float ruf = sdShape(ruf_p); // Distance field sample at cell corner ruf_p\n\n    float i = 1000000.0;\n\n    // Checking all the cell edges for intersection and then calculating the intersection point\n    if (checkEdge(lub, luf)) i = min(i, length(p - vertexInterp(lub_p, luf_p, lub, luf)) - 0.1);\n    if (checkEdge(luf, ruf)) i = min(i, length(p - vertexInterp(luf_p, ruf_p, luf, ruf)) - 0.1);\n    if (checkEdge(ruf, rub)) i = min(i, length(p - vertexInterp(ruf_p, rub_p, ruf, rub)) - 0.1);\n    if (checkEdge(rub, lub)) i = min(i, length(p - vertexInterp(rub_p, lub_p, rub, lub)) - 0.1);\n    if (checkEdge(lub, ldb)) i = min(i, length(p - vertexInterp(lub_p, ldb_p, lub, ldb)) - 0.1);\n    if (checkEdge(luf, ldf)) i = min(i, length(p - vertexInterp(luf_p, ldf_p, luf, ldf)) - 0.1);\n    if (checkEdge(ruf, rdf)) i = min(i, length(p - vertexInterp(ruf_p, rdf_p, ruf, rdf)) - 0.1);\n    if (checkEdge(rub, rdb)) i = min(i, length(p - vertexInterp(rub_p, rdb_p, rub, rdb)) - 0.1);\n    if (checkEdge(ldb, ldf)) i = min(i, length(p - vertexInterp(ldb_p, ldf_p, ldb, ldf)) - 0.1);\n    if (checkEdge(ldf, rdf)) i = min(i, length(p - vertexInterp(ldf_p, rdf_p, ldf, rdf)) - 0.1);\n    if (checkEdge(rdf, rdb)) i = min(i, length(p - vertexInterp(rdf_p, rdb_p, rdf, rdb)) - 0.1);\n    if (checkEdge(rdb, ldb)) i = min(i, length(p - vertexInterp(rdb_p, ldb_p, rdb, ldb)) - 0.1);\n\n    return shape < i ? vec4(shape, 1.0, 1.0, 0.0) : vec4(i, 0.5, 0.5, 0.5);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)).x - mapScene(p - vec3(0.001, 0.0, 0.0)).x,\n                          mapScene(p + vec3(0.0, 0.001, 0.0)).x - mapScene(p - vec3(0.0, 0.001, 0.0)).x,\n                          mapScene(p + vec3(0.0, 0.0, 0.001)).x - mapScene(p - vec3(0.0, 0.0, 0.001)).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c1 = cos(iTime), s1 = sin(iTime);\n    float c2 = c1, s2 = s1;\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        p /= 1.25;\n\n        p.xz *= mat2(c1, s1, -s1, c1);\n        p.yz *= mat2(c2, s2, -s2, c2);\n\n        vec4 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(c2, -s2, s2, c2);\n            n.xz *= mat2(c1, -s1, s1, c1);\n\n            fragColor.rgb += d.yzw;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}