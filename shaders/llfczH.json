{
    "Shader": {
        "info": {
            "date": "1504498893",
            "description": "Fork of https://www.shadertoy.com/view/ldSfDW & https://www.shadertoy.com/view/ldSBWW\nWith more comments, fbm technique and simple shading added.\nSee comments for updates.\n\n\n\n",
            "flags": 32,
            "hasliked": 0,
            "id": "llfczH",
            "likes": 50,
            "name": "Rain drops combined",
            "published": 3,
            "tags": [
                "fbm",
                "rain"
            ],
            "usePreview": 0,
            "username": "ming",
            "viewed": 3401
        },
        "renderpass": [
            {
                "code": "/*\n2017/09/12:\nIntegrated TAA (see Buffer B) implementation by Chris Wyman\n\n2017/09/05:\nIntegrated rain drops technique from BigWIngs' The Drive Home shader (https://www.shadertoy.com/view/MdfBRX). \n\n2017/09/04:\nInitial release.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    fragColor = textureLod(iChannel0, q, 0.0);\n    return;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define LOD 3.5 // controls how blurry the background is\n#define _MainTex iChannel0\n#define _NoiseTex iChannel1\n#define _ShadeDir vec2(-1.0, 1.0)\n\n// iChannel1 is recommended to use the 'RGBA Noise Small' texture (64x64)\n\nfloat shading(vec2 dir)\n{\n    float s = dot(normalize(dir), normalize(_ShadeDir));\n    s = max(s, 0.0);\n    return s;\n}\n\n//----------------------------\n// Eliemichel's technique\n//----------------------------\n\n// uv   - texcoord for looking up the background texture\n// p    - a 2d position for noise lookup\n// curr - the current output color\n// time - scaled time for this layer\nvec4 layerEliemichel(vec2 uv, vec2 p, vec4 curr, float time)\n{\n    vec2 x = vec2(30); // controls the size vs density\n    vec2 xuv = x * p;\n    vec4 n = texture(_NoiseTex, round(xuv - .3) / x);\n    \n    vec2 offset = (texture(_NoiseTex, p * .1).rg - .5) * 2.; // expands to [-1, 1]\n    vec2 z = xuv * 6.3 + offset; // 6.3 is a magic number\n    x = sin(z) - fract(time * (n.b + .1) + n.g) * .5;\n    \n    if (x.x + x.y - n.r * 3. > .5)\n    {\n        vec2 dir = cos(z);\n        curr = textureLod(_MainTex, uv + dir * .2, 0.0);\n        curr += shading(dir) * curr;\n    }\n    return curr;\n}\n\n//----------------------------\n// BigWIngs' technique\n//----------------------------\n\n\nvec3 n31(float p)\n{\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat sawTooth(float t) {\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\nfloat deltaSawTooth(float t) {\n    return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n}\n\n\nvec3 getDrops(vec2 uv, float seed, float t)\n{\n    \n    vec2 o = vec2(0.);\n    \n    uv.y += t * 0.05;\n    \n    uv *= vec2(20., 2.5)*2.;\n    vec2 id = floor(uv);\n    vec3 n = n31(id.x + (id.y+seed)*546.3524);\n    vec2 bd = fract(uv);\n    \n    vec2 uv2 = bd;\n    \n    bd -= .5;\n    \n    bd.y*=4.;\n    \n    bd.x += (n.x-.5)*.6;\n    \n    t += n.z * 6.28;\n    float slide = sawTooth(t);\n    \n    float ts = 1.5;\n    vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n    \n    bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n    \n    //#ifdef HIGH_QUALITY\n    float dropShape = bd.x*bd.x;\n    dropShape *= deltaSawTooth(t);\n    bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n   \t//#endif\n    \n    float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n    \n    float trailMask = smoothstep(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n    trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n    float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n    \n    float mainDrop = smoothstep(.2, .1, d);\n    float dropTrail = 0.0;//smoothstep(.1, .002, td);\n    \n    dropTrail *= trailMask;\n    o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n    \n    return vec3(o, d);\n}\n\nvec4 layerBigWIngs(vec2 uv, vec2 p, vec4 curr, float time)\n{\n    vec3 drop = getDrops(p, 1., time);\n    \n    if (length(drop.xy) > 0.0)\n    {\n        vec2 offset = -drop.xy * (1.0 - drop.z);\n    \tcurr = texture(_MainTex, uv + offset);\n        curr += shading(offset) * curr * 0.5;\n    }\n    \n    return curr;\n}\n\n\n//----------------------------\n// Main\nvoid mainImage( out vec4 ret, vec2 g )\n{\n    vec2 uv = g / iResolution.xy;\n    \n    // background\n    ret = textureLod(_MainTex, uv, LOD);\n    \n    // use BigWIngs layer as base drops\n    ret = layerBigWIngs(uv, uv * 2.2, ret, iTime * 0.5);\n    \n    // add Eliemichel layers with fbm (see https://www.shadertoy.com/view/lsl3RH) as detailed drops.\n    const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    vec2 p = uv;\n    \n    ret = layerEliemichel(uv, p + vec2(0, iTime * 0.01), ret, iTime * 0.25);\n    p = m * p * 2.02;\n    \n    ret = layerEliemichel(uv, p, ret, iTime * 0.125);\n    p = m * p * 1.253;\n    \n    ret = layerEliemichel(uv, p, ret, iTime * 0.125);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// TAA Pass borrowed from Enscaoe Cube (https://www.shadertoy.com/view/4dSBDt)\n// Use Firefox to view it!!\n\n//#define NO_AA\n#define NO_YCOCG\n\nivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n#ifndef NO_YCOCG\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n#else\n    return RGB;\n#endif\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n#ifndef NO_YCOCG\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n#else\n    return YCoCg;\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.75;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}