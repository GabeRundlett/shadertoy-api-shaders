{
    "Shader": {
        "info": {
            "date": "1547759974",
            "description": "I'm a little late for that \"human\" competition, aren't I.  Also this doesn't quite look... ...human.",
            "flags": 0,
            "hasliked": 0,
            "id": "Wss3Df",
            "likes": 4,
            "name": "eyeball face",
            "published": 3,
            "tags": [
                "raycast",
                "subsurface",
                "face"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 477
        },
        "renderpass": [
            {
                "code": "#define MAX_DIST 4.0\n\n\n\nconst float cutoff = 0.81; // ad-hoc, should be much larger\n\nfloat pill(in vec3 pt, in float l, in float r) {\n    vec3 to_core = abs(pt - vec3(0.0, 0.5 * l, 0.0));\n    to_core.y -= 0.5 * l;\n    to_core = max(vec3(0.0), to_core);\n    return length(to_core) - 2.0 * r;\n}\n\nfloat combine(in float x, in float y) {\n    const float flip_pt = 0.06;\n    return flip_pt - squircle_max(max(0.0, flip_pt - y), max(0.0, flip_pt - x), 0.8 * flip_pt);\n}\n\nfloat dist_sqrd(in vec3 p1, in vec3 p2) {\n    vec3 rel = p1 - p2;\n    return dot(rel, rel);\n}\n\nfloat balls_sdf(in vec3 pt) {\n    float l_squared = min(dist_sqrd(pt, vec3(0.085, 0.25, 0.15)),\n                          dist_sqrd(pt, vec3(-0.085, 0.25, 0.15)));\n    return sqrt(l_squared) - 0.04;\n}\n\nvec3 balls_sdf_grad(in vec3 pt) {\n    float f = balls_sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return h_inv *\n        vec3(balls_sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             balls_sdf(pt + vec3(0.0, h, 0.0)) - f,\n             balls_sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat sdf(in vec3 pt) {\n    float d1 = pill(pt - vec3(0.0, 0.25, 0.0), 0.0, 0.1);\n    float d2 = pill(pt - vec3(0.0, 0.05, 0.075), 0.1, 0.055);\n    float socket1 = -pill(pt - vec3(0.075, 0.25, 0.15), 0.0, 0.025);\n\tfloat socket2 = -pill(pt - vec3(-0.075, 0.25, 0.15), 0.0, 0.025);\n\tfloat face = smooth_min(d1, d2, 0.15);\n    float sockets = smooth_max(socket1, socket2, 0.05);\n    return smooth_max(face, sockets, 0.05);\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return h_inv *\n        vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch_to_eyes(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = balls_sdf(pt);\n    for(int i = 0; i < 128; ++i) {\n        if (accum > MAX_DIST || s < 1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * s;\n        p = pt + accum * d;\n        s = balls_sdf(p);\n    }\n    if (s > 1.0e-3) {\n        return MAX_DIST + 1.0;\n    }\n    return accum;\n}\n\n\nfloat raymarch(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    for(int i = 0; i < 128; ++i) {\n        if (accum > MAX_DIST || s < 1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * s;\n        p = pt + accum * d;\n        s = sdf(p);\n    }\n    if (s > 1.0e-3) {\n        return MAX_DIST + 1.0;\n    }\n    return accum;\n}\n\nfloat raymarch_out(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    for(int i = 0; i < 2; ++i) {\n        if (accum > 1.0e-3 && s > -1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * max(abs(s), 1.0e-3);\n        p = pt + accum * d;\n        s = sdf(p);\n    }\n    if (s < -1.0e-3) {\n        return 1000.0;\n    }\n    return accum;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n    float p = (x-a)/(b-a);\n    return clamp(p, 0.0, 1.0);\n}\n\nvec4 color_at(in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 6.0));\n    \n    vec3 orig = vec3(0.0, 0.25, -2.5);\n    \n    float theta = sin(iTime) + 3.141592654;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    mat3 spin = mat3(ct, 0.0, st,\n                     0.0, 1.0, 0.0,\n                     -st, 0.0, ct);\n    \n    theta = 0.25 * sin(iTime);\n    vec2 trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n\ttheta = 0.25 * sin(1.21 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.6 * trigs.x - 0.8 * trigs.y;\n    st = 0.8 * trigs.x + 0.6 * trigs.y;\n    \n    \n    theta = 0.25 * sin(0.93 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n    \n    orig = spin * orig;\n    dir = spin * dir;\n    \n    float dist = raymarch(orig, dir);\n    float eye_dist = raymarch_to_eyes(orig, dir);\n    \n    vec3 color_mul = vec3(1.0);\n    float bright = 0.0;\n    \n    if (eye_dist < dist && eye_dist < MAX_DIST) {\n    \torig = orig + eye_dist * dir;\n        vec3 n = normalize(balls_sdf_grad(orig));\n        dir = normalize(reflect(dir, n));\n        dist = MAX_DIST + 1.0; // raymarch(orig, dir);\n        float to_face = raymarch(orig, dir);\n        color_mul = vec3(vec2(1.0), 2.5);\n        if (to_face < MAX_DIST) {\n            color_mul = vec3(0.1);\n        } else {\n            bright = 1.0;\n        }\n    }\n    \n    \n    vec3 refl_color = vec3(1.0);\n    vec3 trans_color = vec3(1.0, 0.5, 0.4);\n    const vec3 light_dir = vec3(1.0, 0.0, 0.0);\n    float thru_dist = 1000.0;\n    vec3 n = dir;\n    if (dist < MAX_DIST) {\n        n = normalize(sdf_grad(orig + dir * dist));\n        float dist_out = raymarch_out(orig + dir * (dist + 1.0e-2), dir);\n        bright = ramp(0.0, 1.0 / iResolution.y, dist_out);\n        dir = mix(dir, normalize(reflect(dir, n)), bright);\n        thru_dist = raymarch_out(orig + dir * (dist + 1.0e-2), light_dir);\n        refl_color = vec3(0.8, 0.7, 0.6);\n    }\n\n    vec3 col = (0.5 + 0.5 * bright) *\n        (0.2 * smoothstep(0.7, 1.0, dot(dir, light_dir)) + 0.7 * smoothstep(0.1, 1.0,\n                                                                      dot(n, light_dir)))*\n        refl_color;\n    \n    col += bright * (1.0 / max(abs(1.0 * thru_dist), 0.5)) * trans_color;\n\n    // Output to screen\n    return  vec4(color_mul * col,1.0);\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col_out = 0.25 * color_at(fragCoord);\n    const float scatter_scale = 0.8;\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.6, 0.8));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(-1.0, 0.0));\n    col_out += 0.25 * color_at(fragCoord + scatter_scale * vec2(0.0, -1.0));\n    fragColor = col_out;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float squircle_max(in float x, in float y, float off) {\n    float x2 = (x + off) * (x + off);\n    float x4 = x2 * x2;\n    float y2 = (y + off) * (y + off);\n    float y4 = y2 * y2;\n    return sqrt(sqrt(x4 + y4)) - off;\n}\n\n\nvec3 squircle_max(in vec3 x, in vec3 y, float off) {\n\treturn vec3(squircle_max(x.x, y.x, off),\n                squircle_max(x.y, y.y, off),\n                squircle_max(x.z, y.z, off));\n}\n\nfloat smooth_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nvec3 smooth_max(in vec3 x, in vec3 y, float s) {\n\treturn vec3(smooth_max(x.x, y.x, s),\n                smooth_max(x.y, y.y, s),\n                smooth_max(x.z, y.z, s));\n}\n\nfloat smooth_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nvec3 smooth_min(in vec3 x, in vec3 y, float s) {\n\treturn vec3(smooth_min(x.x, y.x, s),\n                smooth_min(x.y, y.y, s),\n                smooth_min(x.z, y.z, s));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}