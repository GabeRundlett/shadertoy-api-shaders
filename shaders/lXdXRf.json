{
    "Shader": {
        "info": {
            "date": "1719376433",
            "description": "Inspired by @ruudhelderman, I decided to try making the torus knot SDF derived from the parametric equation. A trefoil knot is simply a 2,3 torus knot. ",
            "flags": 0,
            "hasliked": 0,
            "id": "lXdXRf",
            "likes": 3,
            "name": "Torus Knot SDF",
            "published": 3,
            "tags": [
                "sdf",
                "distance",
                "derivative",
                "torusknot"
            ],
            "usePreview": 0,
            "username": "spenceryonce",
            "viewed": 98
        },
        "renderpass": [
            {
                "code": "//inspiration from Ruud Helderman: https://www.shadertoy.com/view/M3tXW4\n\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.001\n\nmat3 rotateAxis(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// SDF functions\n// Parametric equation of the (p, q)-Torus Knot.\nvec3 torusKnot(in float t, in float R, in float r, in int pParam, in int qParam) {\n    return vec3(\n        (R + r * cos(float(qParam) * t)) * cos(float(pParam) * t),\n        (R + r * cos(float(qParam) * t)) * sin(float(pParam) * t),\n        r * sin(float(qParam) * t)\n    );\n}\n\n// First derivative of the parametric equation.\nvec3 torusKnotDerived(in float t, in float R, in float r, in int pParam, in int qParam) {\n    return vec3(\n        -r * float(qParam) * sin(float(qParam) * t) * cos(float(pParam) * t) - (R + r * cos(float(qParam) * t)) * float(pParam) * sin(float(pParam) * t),\n        -r * float(qParam) * sin(float(qParam) * t) * sin(float(pParam) * t) + (R + r * cos(float(qParam) * t)) * float(pParam) * cos(float(pParam) * t),\n        r * float(qParam) * cos(float(qParam) * t)\n    );\n}\n\n// Distance between (0, 0, 0) and a line through p with direction d.\nfloat distanceOriginLine(in vec3 p, in vec3 d) {\n    return length(cross(p, p + normalize(d)));\n}\n\n// Distance between p and torusKnot(t).\n// The better the estimate of t is, the more accurate this distance will be.\nfloat distancePointCurve(in vec3 p, in float R, in float r, in int pParam, in int qParam, in float s, in float t) {\n    return distanceOriginLine(p - s * torusKnot(t, R, r, pParam, qParam), torusKnotDerived(t, R, r, pParam, qParam));\n}\n\n// Rough estimate of t, trying to get torusKnot(t) near p.\nfloat roughInverseTorusKnot(in vec3 p, in int pParam, in int qParam) {\n    return atan(p.y, p.x) / float(pParam);\n}\n\n// SDF for Torus Knot.\n// R = major radius (size of the torus)\n// r = minor radius (thickness of the wire)\n// pParam, qParam = parameters defining the (p, q)-torus knot\nfloat sdTorusKnot(in vec3 p, in float R, in float r, in int pParam, in int qParam) {\n    float t = roughInverseTorusKnot(p, pParam, qParam);\n    \n    // There are multiple points on the curve that match t; calculate both.\n    float d1 = distancePointCurve(p, R, r, pParam, qParam, 1.0, t);\n    float d2 = distancePointCurve(p, R, r, pParam, qParam, 1.0, t + 3.141592653589793); // t + PI\n    \n    // Take whichever is closest to p.\n    return min(d1, d2) - r;\n}\n\nfloat map(vec3 p) {\n    vec3 torusKnotPos = vec3(0.0, 0.0, 0.0);\n    float torusKnotDist = sdTorusKnot(p - torusKnotPos, 0.5, 0.07, 2,9);\n\n    vec3 torusKnotPos2 = vec3(0.0, 0.0, 0.0);\n    float torusKnotDist2 = sdTorusKnot(p - torusKnotPos2, 0.85, 0.08, 2,3);\n\n    vec3 torusKnotPos3 = vec3(0.0, 0.0, 0.0);\n    float torusKnotDist3 = sdTorusKnot(p - torusKnotPos2, 0.1, 0.03, 2,3);\n\n    float o = min(torusKnotDist, torusKnotDist2);\n    return min(o,torusKnotDist3);\n}\n\n// Ray marching\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat attenuation(float dist, float cutoff, float sharpness) {\n    return 1.0 / (1.0 + pow(dist / cutoff, sharpness));\n}\n\nvec3 blinnPhongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                                 vec3 lightPos, vec3 lightIntensity, vec3 lightColor) {\n     vec3 N = estimateNormal(p);\n     vec3 L = normalize(lightPos - p);\n     vec3 V = normalize(eye - p);\n     vec3 H = normalize(L + V);\n\n     float distance = length(lightPos - p);\n     float att = attenuation(distance, 1.0, distance);\n     \n     float dotLN = dot(L, N);\n     float dotHN = dot(H, N);\n     \n     if (dotLN < 0.0) {\n          return vec3(0.0, 0.0, 0.0);\n     }\n     \n     return att * lightIntensity * (k_d * dotLN + k_s * pow(dotHN, alpha) * lightColor);\n}\n\nvec3 blinnPhongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(2.0,1.0,2.0);\n    vec3 light1Intensity = vec3(0.2549, 0.2549, 0.2549);\n    vec3 light1Color = vec3(1.0, 1.0, 1.0);\n\n    color += blinnPhongContribForLight(k_d, k_s, alpha, p, eye,\n                                    light1Pos,\n                                    light1Intensity,\n                                    light1Color);\n                                \n    vec3 light2Pos = vec3(2.0,0.2,2.0);\n    vec3 light2Intensity = vec3(1.0, 1.0, 1.0);\n    vec3 light2Color = vec3(1.0, 1.0, 1.0);\n\n    color += blinnPhongContribForLight(k_d, k_s, alpha, p, eye,\n                                    light2Pos,\n                                    light2Intensity,\n                                    light2Color);\n\n    vec3 light3Pos = vec3(0.0,0.0,-3.0);\n    vec3 light3Intensity = vec3(1.0, 1.0, 1.0);\n    vec3 light3Color = vec3(1.0, 1.0, 1.0);\n\n    color += blinnPhongContribForLight(k_d, k_s, alpha, p, eye,\n                                    light3Pos,\n                                    light3Intensity,\n                                    light3Color);\n    \n    vec3 light4Pos = vec3(-2.0,0.0,-2.0);\n    vec3 light4Intensity = vec3(0.4706, 0.4706, 0.4706);\n    vec3 light4Color = vec3(1.0, 1.0, 1.0);\n\n    color += blinnPhongContribForLight(k_d, k_s, alpha, p, eye,\n                                    light4Pos,\n                                    light4Intensity,\n                                    light4Color);\n\n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 tonemapeAces(vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage(out vec4 O, vec2 fc) {\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fc.xy);\n    vec3 eye = vec3(0.0, 0.0, 5.0); // Camera position\n    eye = rotateAxis(vec3(0.0, 1.0, 0.0), 0.5 * iTime) * eye;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    vec3 p = eye + dist * worldDir;\n\n    vec3 skyColor = mix(vec3(0.5098, 0.7569, 0.8706), vec3(0.5294, 0.7804, 0.9059), p.y * 0.1 + 0.5);\n\n    if (dist > MAX_DIST - EPSILON) {\n        O = vec4(skyColor, 1.0);\n        return;\n    }\n    \n    \n    vec3 K_a = vec3(0.01, 0.01, 0.01); // Ambient color\n    vec3 K_d = vec3(0.0078, 0.6745, 0.8392); // Diffuse color\n    vec3 K_s = vec3(1.0, 1.0, 1.0); // Specular color\n    float shininess = 10.0;\n    \n    vec3 color = blinnPhongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    color = tonemapeAces(color);\n    color = pow(color, vec3(0.454545));\n    O = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}