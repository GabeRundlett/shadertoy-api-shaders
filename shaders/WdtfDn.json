{
    "Shader": {
        "info": {
            "date": "1604840471",
            "description": "experiments with shape generation",
            "flags": 1,
            "hasliked": 0,
            "id": "WdtfDn",
            "likes": 12,
            "name": "random convex hull",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "_A_",
            "viewed": 453
        },
        "renderpass": [
            {
                "code": "\nfloat SDF (const float3 pos)\n{\n\tint\t\t\tbase_seed\t= int(iTime * 0.25);\n\tfloat\t\tfactor\t\t= Clamp( Fract(iTime * 0.25) * 2.0, 0.0, 1.0 );\n\tconst int\tplane_count\t= 16;\n\n\tfloat\tdist[2];\n\tfor (int j = 0; j < 2; ++j)\n\t{\n\t\tfloat\tmd\t\t= -1.0e+10;\n\t\tint\t\tseed\t= base_seed + j;\n\n\t\tfor (int i = 0; i < plane_count; ++i)\n\t\t{\n\t\t\tint\t\tface\t= (i + seed) % 6;\n\t\t\tfloat2\tscoord\t= DHash21( float(i)*51.85 + float(seed)*2.0 );\n\t\t\tfloat\tradius\t= 1.0 + DHash11( float(i)*9.361 + float(seed)*3.94521 ) * 0.5;\n\t\t\tfloat3\tnorm\t= Normalize( CM_TangentialSC_Forward( scoord, face ));\n\t\t\tfloat3\tplane\t= radius * norm;\n\n\t\t\tmd = Max( md, SDF_Plane( plane, pos ));\n\t\t}\n\t\n\t\tmd = Max( md, Length( pos ) - 3.0);\n\t\tdist[j] = md;\n\t}\n\n\treturn Lerp(dist[0], dist[1], factor);\n}\n\nfloat SDFScene (float3 pos)\n{\n    pos = pos - float3(0.0, 0.0, 5.0);\n\tpos = SDF_Rotate( pos, QRotationY( iTime*0.3 ));\n\treturn SDF( pos );\n}\n\nGEN_SDF_NORMAL_FN2( SDFNormal, SDFScene, )\n\n\nfloat4 TraceRay (Ray ray)\n{\n\tconst int\tmax_iter\t= 256;\n\tconst float\tmin_dist\t= 0.00625f;\n\tconst float\tmax_dist\t= 100.0;\n\n\tint i = 0;\n\tfor (; i < max_iter; ++i)\n\t{\n\t\tfloat\tdist = SDFScene( ray.pos );\n\t\t\n\t\tRay_Move( ray, dist );\n\n\t\tif ( Abs(dist) < min_dist || ray.t > max_dist )\n\t\t\tbreak;\n\t}\n\n\tif ( ray.t > max_dist )\n\t\treturn float4(0.0, 0.0, 0.3, 1.0);\n\n\tfloat3\tnorm\t\t= SDFNormal( ray.pos );\n\tfloat3\tlight_dir\t= -ray.dir;\n\n\tfloat\tshading = Dot( norm, light_dir );\n\treturn float4( shading );\n}\n//-----------------------------------------------------------------------------\n\n\nvoid mainVR (out float4 fragColor, in float2 fragCoord, in float3 fragRayOri, in float3 fragRayDir)\n{\n\tRay\tray = Ray_Create( fragRayOri, fragRayDir, 0.1 );\n\n\tfragColor = TraceRay( ray );\n}\n\nvoid mainImage (out float4 fragColor, in float2 fragCoord)\n{\n    Ray ray = Ray_FromScreen( vec3(0.0, 0.0, 30.0), QIdentity(), radians(90.0), 0.1, int2(iResolution.xy), int2(gl_FragCoord.xy) );\n    \n\tfragColor = TraceRay( ray );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define float2\t\tvec2\n#define float3\t\tvec3\n#define float4\t\tvec4\n#define float2x2\tmat2x2\n#define float3x3\tmat3x3\n#define float4x4\tmat4x4\n\n#define int2\t\tivec2\n#define int3\t\tivec3\n#define int4\t\tivec4\n\n\n#define Any\t\t\t\tany\n#define All\t\t\t\tall\n#define Abs\t\t\t\tabs\n#define ACos\t\t\tacos\n#define ASin\t\t\tasin\n#define ASinH\t\t\tasinh\n#define ACosH\t\t\tacosh\n#define ATan\t\t\tatan\t\t\t// result in range [-Pi...+Pi]\n#define BitScanReverse\tfindMSB\n#define BitScanForward\tfindLSB\n#define ATanH\t\t\tatanh\n#define Clamp\t\t\tclamp\n#define Ceil\t\t\tceil\n#define Cos\t\t\t\tcos\n#define CosH\t\t\tcosh\n#define Cross\t\t\tcross\n#define Distance\t\tdistance\n#define Dot\t\t\t\tdot\n#define Exp\t\t\t\texp\n#define Exp2\t\t\texp2\n#define Fract\t\t\tfract\n#define Floor\t\t\tfloor\n#define IsNaN\t\t\tisnan\n#define IsInfinity\t\tisinf\n#define IsFinite( x )\t(! IsInfinity( x ) && ! IsNaN( x ))\n#define InvSqrt\t\t\tinversesqrt\n#define IntLog2\t\t\tBitScanReverse\n#define Length\t\t\tlength\n#define Lerp\t\t\tmix\n#define Ln\t\t\t\tlog\n#define Log2\t\t\tlog2\n#define Log( x, base )\t(Ln(x) / Ln(base))\n#define Log10( x )\t\t(Ln(x) * 0.4342944819032518)\n#define Min\t\t\t\tmin\n#define Max\t\t\t\tmax\n#define Mod\t\t\t\tmod\n#define MatInverse\t\tinverse\n#define MatTranspose\ttranspose\n#define Normalize\t\tnormalize\n#define Pow\t\t\t\tpow\n#define Round\t\t\tround\n#define Reflect\t\t\treflect\n#define Refract\t\t\trefract\n#define Step\t\t\tstep\n#define SmoothStep\t\tsmoothstep\n#define Saturate( x )\tclamp( x, 0.0, 1.0 )\n#define Sqrt\t\t\tsqrt\n#define Sin\t\t\t\tsin\n#define SinH\t\t\tsinh\n#define SignOrZero\t\tsign\n#define Tan\t\t\t\ttan\n#define TanH\t\t\ttanh\n#define Trunc\t\t\ttrunc\n#define ToUNorm( x )\t((x) * 0.5 + 0.5)\n#define ToSNorm( x )\t((x) * 2.0 - 1.0)\n//----------------------------------------------\n\n\nstruct quat\n{\n\tfloat4\tdata;\n};\n    \nquat  QIdentity ()\n{\n\tquat\tret;\n\tret.data = float4( 0.0, 0.0, 0.0, 1.0 );\n\treturn ret;\n}\n\nfloat3  QMul (const quat left, const float3 right)\n{\n\tfloat3\tq\t= left.data.xyz;\n\tfloat3\tuv\t= Cross( q, right );\n\tfloat3\tuuv\t= Cross( q, uv );\n\n\treturn right + ((uv * left.data.w) + uuv) * 2.0;\n}\n\nquat  QInverse (const quat q)\n{\n\tquat\tret;\n\tret.data.xyz = -q.data.xyz;\n\tret.data.w   = q.data.w;\n\treturn ret;\n}\n\nquat  QRotationY (const float angleRad)\n{\n\tquat\tq;\n\tfloat\ta = angleRad * 0.5;\n\n\tq.data = float4( 0.0, Sin(a), 0.0, Cos(a) );\n\treturn q;\n}\n//----------------------------------------------\n\n\nstruct Ray\n{\n\tfloat3\torigin;\t\t// camera (eye, light, ...) position\n\tfloat3\tdir;\t\t// normalized direction\n\tfloat3\tpos;\t\t// current position\n\tfloat\tt;\n};\n\nRay\t\tRay_Create (const float3 origin, const float3 direction, const float tmin)\n{\n\tRay\tresult;\n\tresult.origin\t= origin;\n\tresult.t\t\t= tmin;\n\tresult.dir\t\t= direction;\n\tresult.pos\t\t= origin + direction * tmin;\n\treturn result;\n}\n\nRay\t\tRay_FromScreen (const float3 origin, const quat rotation, const float fovX, const float nearPlane,\n\t\t\t\t\t\tconst int2 screenSize, const int2 screenCoord)\n{\n\tfloat2\tscr_size\t= float2(screenSize);\n\tfloat2\tcoord\t\t= float2(screenCoord);\n\n\tfloat\tratio\t\t= scr_size.y / scr_size.x;\n\tfloat \tfovY \t\t= fovX * ratio;\n\tfloat2 \tscale\t\t= nearPlane / Cos( float2(fovX, fovY) * 0.5 );\n\tfloat2 \tuv \t\t\t= (coord - scr_size * 0.5) / (scr_size.x * 0.5) * scale;\n\n\tRay\tray;\n\tray.origin\t= origin;\n\tray.dir\t\t= Normalize( QMul( rotation, Normalize( float3(uv.x, uv.y, -0.5) )));\n\tray.pos\t\t= origin + ray.dir * nearPlane;\n\tray.t\t\t= nearPlane;\n\n\treturn ray;\n}\n\nvoid\tRay_Move (inout Ray ray, const float length)\n{\n\tray.t   += length;\n\tray.pos  = ray.origin + ray.dir * ray.t;\n}\n//----------------------------------------------\n\n\nfloat4 _DHashScale ()  { return float4( 0.1031, 0.1030, 0.0973, 0.1099 ); }\n\nfloat DHash11 (const float p)\n{\n\tfloat3 p3 = Fract( float3(p) * _DHashScale().x );\n\tp3 += Dot( p3, p3.yzx + 19.19 );\n\treturn Fract( (p3.x + p3.y) * p3.z );\n}\n\nfloat2 DHash21 (const float p)\n{\n\tfloat3 p3 = Fract( float3(p) * _DHashScale().xyz );\n\tp3 += Dot( p3, p3.yzx + 19.19 );\n\treturn Fract( (p3.xx + p3.yz) * p3.zy );\n}\n//----------------------------------------------\n\n\nfloat3  CM_RotateVec (const float3 c, const int face)\n{\n\tswitch ( face )\n\t{\n\t\tcase 0 : return float3( c.z,  c.y, -c.x);\t// X+\n\t\tcase 1 : return float3(-c.z,  c.y,  c.x);\t// X-\n\t\tcase 2 : return float3( c.x, -c.z,  c.y);\t// Y+\n\t\tcase 3 : return float3( c.x,  c.z, -c.y);\t// Y-\n\t\tcase 4 : return float3( c.x,  c.y,  c.z);\t// Z+\n\t\tcase 5 : return float3(-c.x,  c.y, -c.z);\t// Z-\n\t}\n\treturn float3(0.0);\n}\n\nfloat3  CM_TangentialSC_Forward (const float2 snormCoord, const int face)\n{\n\tconst float\twarp_theta\t\t= 0.868734829276;\n\tconst float\ttan_warp_theta\t= 1.182286685546; //tan( warp_theta );\n\tfloat2\t\tcoord\t\t\t= Tan( warp_theta * snormCoord ) / tan_warp_theta;\n\n\treturn Normalize( CM_RotateVec( float3(coord.x, coord.y, 1.0), face ));\n}\n//----------------------------------------------\n\n\nfloat SDF_Plane (const float3 planePos, const float3 pos)\n{\n\tfloat3\tv = -planePos;\n\tfloat\td = Length( v );\n\treturn Dot( v / d, pos ) - d;\n}\n\nfloat3 SDF_Rotate (const float3 position, const quat q)\n{\n\treturn QMul( QInverse( q ), position );\n}\n\n\n#define GEN_SDF_NORMAL_FN( _fnName_, _sdf_, _field_ )                          \\\n\tfloat3 _fnName_ (const float3 pos)                                         \\\n\t{                                                                          \\\n\t\tconst float2\teps  = float2( 0.001, 0.0 );                           \\\n\t\tfloat3\t\t\tnorm = float3(                                         \\\n\t\t\t_sdf_( pos + eps.xyy ) _field_ - _sdf_( pos - eps.xyy ) _field_,   \\\n\t\t\t_sdf_( pos + eps.yxy ) _field_ - _sdf_( pos - eps.yxy ) _field_,   \\\n\t\t\t_sdf_( pos + eps.yyx ) _field_ - _sdf_( pos - eps.yyx ) _field_ ); \\\n\t\treturn Normalize( norm );                                              \\\n\t}\n\n#define GEN_SDF_NORMAL_FN2( _fnName_, _sdf_, _field_ )  \\\n\tfloat3 _fnName_ (const float3 pos)                  \\\n\t{                                                   \\\n\t\tconst float\t\th\t = 0.001;                   \\\n\t\tconst float2\tk\t = float2(1,-1);            \\\n\t\tfloat3\t\t\tnorm = float3(                  \\\n\t\t\tk.xyy * _sdf_( pos + k.xyy * h ) _field_ +  \\\n\t\t\tk.yyx * _sdf_( pos + k.yyx * h ) _field_ +  \\\n\t\t\tk.yxy * _sdf_( pos + k.yxy * h ) _field_ +  \\\n\t\t\tk.xxx * _sdf_( pos + k.xxx * h ) _field_ ); \\\n\t\treturn Normalize( norm );                       \\\n\t}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}