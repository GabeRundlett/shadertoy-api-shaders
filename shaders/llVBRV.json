{
    "Shader": {
        "info": {
            "date": "1543268208",
            "description": "6 shaders mapped on the 6 faces of a cube using raymarching",
            "flags": 32,
            "hasliked": 0,
            "id": "llVBRV",
            "likes": 19,
            "name": "6 shaders cube improved",
            "published": 3,
            "tags": [
                "raymarch",
                "retro",
                "cube",
                "amiga"
            ],
            "usePreview": 0,
            "username": "Himred",
            "viewed": 1400
        },
        "renderpass": [
            {
                "code": "// 6 shaders mapped on the 6 faces of a cube using raymarching\n//\n// This is a recode from previous version and I have added a ghost effect and a sinus effect.\n//\n// Coded because I love cubes (don't ask me why)\n// and also love the retro amiga scene.\n//\n// The six shaders I love and I used here:\n//\n// Face 1: WWDC14 by capnslipp - https://www.shadertoy.com/view/XdfyRB\n// Face 2: Plasma by Klk - https://www.shadertoy.com/view/XsVSzW\n// Face 3: YaraGui by dila - https://www.shadertoy.com/view/ldlyWS\n// Face 4: Combustible Voronoi by Shane - https://www.shadertoy.com/view/4tlSzl\n// Face 5: Ring twister by Flyguy - https://www.shadertoy.com/view/Xt23z3\n// Face 6: Glenz by myself - https://www.shadertoy.com/view/4lt3R7 \n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 tex = texture(iChannel0, uv);\n\tfragColor = vec4(tex.xyz, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n#define NUM_FACES 4\n#define IN_RADIUS 0.25\n#define OUT_RADIUS 0.70\n#define XSCROLL_SPEED -0.9\n#define COLOR_1 0.50, 0.90, 0.95\n#define COLOR_2 0.95, 0.60, 0.10\n#define BORDER 0.01\n#define BORDERCOLOR vec4(0.8,0.8,0.8,1.)\n\nint id=0;\nvec3 xcolor = vec3(0.2, 0.5, 1.0);\nfloat tau = atan(1.0) * 8.0;\nfloat aaSize = 0.0;\nvec3 cubevec;\n\n// ---------------- Glenz Shader Code -----------------------\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\nvec3 Bars(vec2 uv)\n{\n    //vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 1.0);\n    return color;\n}\n\nvec3 Twister(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat Cube( vec3 p )\n{\n    p=Twister(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\nvec4 Glenz(in vec2 uv )\n{\n    if(uv.x<BORDER || uv.y<BORDER || uv.x>1.-BORDER || uv.y>1.-BORDER) return BORDERCOLOR;\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 p = -1.0 + uv *2.0;\n    vec2 kp=uv;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    \n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break; // 0.05 is a magic number \n                }\n        }\n\n    vec3 Color=Bars(uv);\n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n    return vec4( Color, 1.0 );\n}\n\n\n// ---------------- Ring Shader Code -----------------------\nvec4 slice(float x0, float x1, vec2 uv)\n{\n    float u = (uv.x - x0)/(x1 - x0);\n    float w = (x1 - x0);\n    vec3 col = vec3(0);\n    col = mix(vec3(COLOR_1), vec3(COLOR_2), u);\n    col *= w / sqrt(2.0 * IN_RADIUS*IN_RADIUS * (1.0 - cos(tau / float(NUM_FACES))));\n    col *= smoothstep(0.05, 0.10, u) * smoothstep(0.95, 0.90, u) + 0.5;\n    uv.y += iTime * XSCROLL_SPEED; //Scrolling\n    col *= (-1.0 + 2.0 * smoothstep(-0.03, 0.03, sin(u*PI*4.0) * cos(uv.y*16.0))) * (1.0/16.0) + 0.7;\n    float clip = 0.0;\n    clip = (1.0-smoothstep(0.5 - aaSize/w, 0.5 + aaSize/w, abs(u - 0.5))) * step(x0, x1);\n    return vec4(col, clip);\n}\n\nvec4 Ring(in vec2 uv)\n{\n    if(uv.x<BORDER || uv.y<BORDER || uv.x>1.-BORDER || uv.y>1.-BORDER) return BORDERCOLOR;\n    aaSize = 2.0 / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + PI);\n    uvr.x -= OUT_RADIUS;\n    vec3 col = vec3(0.05);\n    float angle = uvr.y + 2.0*iTime + sin(uvr.y) * sin(iTime) * PI;\n    \n    for(int i = 0;i < NUM_FACES;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + tau * (float(i) / float(NUM_FACES)));\n        float x1 = IN_RADIUS * sin(angle + tau * (float(i + 1) / float(NUM_FACES)));\n        vec4 face = slice(x0, x1, uvr);\n        col = mix(col, face.rgb, face.a); \n    }\n\treturn vec4(col, 1.0);\n}\n\n// ---------------- Voronoi Shader Code -----------------------\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i;\n    vec3 L = vec3(7.4, 5.6, 4.4);\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L);\n}\n\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat xvoronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z+iTime*1.5);\n\n    const int iter = 5;\n    float tot = 0., sum = 0., amp = 1.;\n\n    for (int i = 0; i < iter; i++) {\n        tot += xvoronoi(p + t) * amp;\n        p *= 2.0;\n        t *= 1.5;\n        sum += amp;\n        amp *= 0.5;\n    }\n    return tot/sum;\n}\n\nvec4 Voronoi(in vec2 uv )\n{\n    if(uv.x<BORDER || uv.y<BORDER || uv.x>1.-BORDER || uv.y>1.-BORDER) return BORDERCOLOR;\n    uv = uv * 2.0 - 1.0;\n\tuv += vec2(sin(iTime*0.5)*0.25, cos(iTime*0.5)*0.125);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\tfloat cs = cos(iTime*0.25), si = sin(iTime*0.25);\n\trd.xy = rd.xy*mat2(cs, -si, si, cs); \n\tfloat c = noiseLayers(rd*2.);\n\tc = max(c + dot(hash33(rd)*2.-1., vec3(0.015)), 0.);\n    c *= sqrt(c)*1.5;\n    vec3 col = firePalette(c);\n    col = mix(col, col.zyx*0.15+c*0.85, min(pow(dot(rd.xy, rd.xy)*1.2, 1.5), 1.));\n    col = pow(col, vec3(1.5));\n\treturn vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\n// ---------------- Plasma Shader Code -----------------------\nvec4 Plasma(vec2 uv )\n{\n    if(uv.x<BORDER || uv.y<BORDER || uv.x>1.-BORDER || uv.y>1.-BORDER) return BORDERCOLOR;\n\tfloat time=iTime*4.0;\n\tuv = (uv-0.0)*6.0;\n    vec2 uv0=uv;\n\tfloat i0=1.0;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<7;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(cos(uv.y*i0-i4+time/i1),sin(uv.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.3;\n\t\tuv.xy+=r;\n        \n\t\ti0*=1.93;\n\t\ti1*=1.15;\n\t\ti2*=1.7;\n\t\ti4+=0.05+0.1*time*i1;\n\t}\n    float r=sin(uv.x-time)*0.5+0.5;\n    float b=sin(uv.y+time)*0.5+0.5;\n    float g=sin((uv.x+uv.y+sin(time*0.5))*0.5)*0.5+0.5;\n\treturn vec4(r,g,b,1.0);\n}\n\n// ---------------- Twirl Shader Code -----------------------\nvec4 tw(vec2 uv)\n{\n    float j = sin(uv.y * 3.14 + iTime * 5.0);\n    float i = sin(uv.x * 15.0 - uv.y * 2.0 * 3.14 + iTime * 3.0);\n    float n = -clamp(i, -0.2, 0.0) - 0.0 * clamp(j, -0.2, 0.0);\n    return 3.5 * (vec4(xcolor, 1.0) * n);\n}\n\nvec4 Twirl(vec2 p)\n{\n    if(p.x<BORDER || p.y<BORDER || p.x>1.-BORDER || p.y>1.-BORDER) return BORDERCOLOR;\n    vec2 uv;\n    p=-1.+2.*p;\n    \n    float r = sqrt(dot(p, p));\n    float a = atan(\n        p.y * (0.3 + 0.1 * cos(iTime * 2.0 + p.y)),\n        p.x * (0.3 + 0.1 * sin(iTime + p.x))\n    ) + iTime;\n    \n    uv.x = iTime + 1.0 / (r + .01);\n    uv.y = 4.0 * a / 3.1416;\n    \n    return mix(vec4(0.0), tw(uv) * r * r * 2.0, 1.0);\n}\n\n// ---------------- Room Shader Code -----------------------\nfloat sdBoxXY( vec3 p, vec3 b )\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat2 rot(float x) {\n\treturn mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat map(vec3 p) {\n    float k = 0.5 * 2.0;\n\tvec3 q = (fract((p - vec3(0.25, 0.0, 0.25))/ k) - 0.5) * k;\n    vec3 s = vec3(q.x, p.y, q.z);\n    float d = udRoundBox(s, vec3(0.1, 1.0, 0.1), 0.05);\n    \n    k = 0.5;\n    q = (fract(p / k) - 0.5) * k;\n    s = vec3(q.x, abs(p.y) - 1.5, q.z);\n    float g = udRoundBox(s, vec3(0.17, 0.5, 0.17), 0.2);\n    \n    float sq = sqrt(0.5);\n    vec3 u = p;\n    u.xz *= mat2(sq, sq, -sq, sq);\n    d = max(d, -sdBoxXY(u, vec3(0.8, 1.0, 0.8)));\n    \n    return smin(d, g, 16.0);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec4 Room(vec2 uv )\n{\n    if(uv.x<BORDER || uv.y<BORDER || uv.x>1.-BORDER || uv.y>1.-BORDER) return BORDERCOLOR;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gt = iTime / 5.0;\n    vec3 r = normalize(vec3(uv, 1.7 - dot(uv, uv) * 0.1));\n    float sgt = sin(gt * 3.141592 * 2.0);\n    r.xy *= rot(sgt * 3.141592 / 8.0);\n    r.xz *= rot(3.141592 * 0.0 + gt * 3.141592 * 2.0);\n    r.xz *= rot(3.141592 * -0.25);\n\n    vec3 o = vec3(0.0, 0.0, gt * 5.0 * sqrt(2.0) * 2.0);\n    o.xz *= rot(3.141592 * -0.25);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n\n    vec3 col = vec3(0.514, 0.851, 0.933) * 0.5;\n    vec3 ldir = normalize(vec3(-1, -0.5, 1.1));\n\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd * 100.0);\n    float front = max(dot(r, -sn), 0.0);\n    float ref = max(dot(r, reflect(-ldir, sn)), 0.0);\n    float grn = pow(abs(sn.y), 3.0);\n\n    vec3 cl = vec3(grn);\n    cl += mix(col*vec3(1.5), vec3(0.25), grn) * pow(ref, 16.0);\n    cl = mix(col, cl, fog);\n\n\treturn vec4(cl, 1.0);\n}\n\n// ---------------- Main Shader Code -----------------------\nvec3 Face(vec3 p,vec3 n,int f )\n{    \n    n = max(abs(n) - 0.2, 0.001);\n    p+=0.5;\n    n /= (n.x + n.y + n.z ); \n\tif(f==1) return (Voronoi(p.yz)*n.x + Voronoi(p.zx)*n.y + Voronoi(p.xy)*n.z).xyz;\n    if(f==2) return (Ring(p.yz)*n.x + Ring(p.zx)*n.y + Ring(p.xy)*n.z).xyz;\n    if(f==3) return (Glenz(p.yz)*n.x + Glenz(p.zx)*n.y + Glenz(p.xy)*n.z).xyz;\n    if(f==4) return (Plasma(p.yz)*n.x + Plasma(p.zx)*n.y + Plasma(p.xy)*n.z).xyz;\n    if(f==5) return (Twirl(p.yz)*n.x + Twirl(p.zx)*n.y + Twirl(p.xy)*n.z).xyz;\n    if(f==6) return (Room(p.yz)*n.x + Room(p.zx)*n.y + Room(p.xy)*n.z).xyz;\n}\n\n\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\nfloat Scene(vec3 p)\n{ \n    return max(max(abs(p.x), abs(p.y)), abs(p.z)) - 5.;\n}\n\n\nvec3 Normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0, 0);\n    return normalize(vec3(Scene(p-o.xyz)-Scene(p+o.xyz),Scene(p-o.zxy)-Scene(p+o.zxy),Scene(p-o.yzx)-Scene(p+o.yzx)));\n}\n\n\nvec3 RayMarch(vec3 ro,vec3 rd)\n{\n    float hd = 0.0;\n    id=0;\n    for(int i = 0;i < 128;i++)\n    {\n        float d = Scene(ro + rd * hd);\n        hd += d;\n        if(d < 0.0001) {id=1;break;}\n    }   \n    return ro + rd * hd;\n}\n\nvec3 GetColor(vec3 p, vec3 n)\n{   \n    p/=10.;\n    //return Face(p,n,1)/6.+Face(p,n,2)/6.+Face(p,n,3)/6.+Face(p,n,4)/6.+Face(p,n,5)/6.+Face(p,n,6)/6.;\n    if(dot(n,vec3(1,0,0))>0.) return Face(p,n,1);\n    if(dot(n,vec3(1,0,0))<0.) return Face(p,n,2);\n    if(dot(n,vec3(0,0,1))>0.) return Face(p,n,3);\n    if(dot(n,vec3(0,0,1))<0.) return Face(p,n,4);\n    if(dot(n,vec3(0,1,0))>0.) return Face(p,n,5);\n    if(dot(n,vec3(0,1,0))<0.) return Face(p,n,6);\n    return vec3(1);\n}\n\n\nvec3 Lightning(vec3 sp,vec3 sn,vec3 rd,vec3 lp,vec3 color,vec3 lc)\n{\n    // From a Shane Shader\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), 0.001);\n    ld /= lDist;\n    float atten = 1./(1. + lDist*.2 + lDist*.1); \n    float ambience = 1.;\n    float diff = min(0.3,max( dot(sn, ld), 0.0));\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.); \n    return color*(diff+ambience)+lc*spec/1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ratio = iResolution.xy / iResolution.y;\n    vec2 xx = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv.x+=0.2*sin(4.*uv.y+iTime);\n    \n    vec4 old1= texture(iChannel0, xx*.99);\n    vec4 old2= texture(iChannel0, xx*.98);\n    vec4 old3= texture(iChannel0, xx*.97);\n    vec4 old4= texture(iChannel0, xx*.96);\n    \n    vec3 ro = vec3(0 , 0, -20.0);\n    vec3 rd = normalize(vec3(uv - ratio / 2.0, 1.0));\n    \n    mat2 rx = Rotate(iTime);\n    mat2 ry = Rotate(iTime*2.);\n    \n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n    \n    vec3 sp = RayMarch(ro, rd);\n    vec3 sn = Normal(sp);\n    vec3 color = vec3(0);\n    \n    if(id==1)\n    \t{\n    \tcolor = GetColor(sp,sn);\n    \tcolor = .4*Lightning(sp,sn,rd,ro-vec3(5),color,vec3(1,1,1));\n        }\n    \n    color += 0.22*old1.xyz+0.18*old2.xyz+0.15*old3.xyz+0.08*old4.xyz;\n\tfragColor = vec4(color,.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}