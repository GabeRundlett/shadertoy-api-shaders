{
    "Shader": {
        "info": {
            "date": "1714343214",
            "description": "I didnt even understand it fully YET, just used ai to merge two shadertoys XD I understand why its so broken but names/code structure makes it too hard anyway",
            "flags": 0,
            "hasliked": 0,
            "id": "MfdSzs",
            "likes": 1,
            "name": "whoever fixes this is a hero :D",
            "published": 3,
            "tags": [
                "noob",
                "ai",
                "bruh",
                "cringe"
            ],
            "usePreview": 0,
            "username": "lolnoob",
            "viewed": 161
        },
        "renderpass": [
            {
                "code": "const int MAX_RAY_STEPS = 128;\n/*\ni wanted to understand how dda works(specifically \"branchless\" and multilevel) but i didnt \nhad enough time to fully understand it yet, so i decided to try using AI XD\n(had to fix a lot though, now at least it renders something )\n\nplease someone make it simpler and preferably rename/explain how it works, \nsorry for that cringe and bothering\n*/\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c) {\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 cameraDir = vec3(0.0, 0.0, 0.8);\n    vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n    vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    vec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n    rayPos.xz = rotate2d(rayPos.xz, iTime);\n    rayDir.xz = rotate2d(rayDir.xz, iTime);\n\n \n    float lod = 4.0, lodinv = 1.0 / 4.0;\n    vec3 rd = rayDir;\n    vec3 p = floor(rayPos * lodinv) * lod;\n    vec3 ps = rayPos;\n    vec3 rdinv = 1.0 / rd;\n    \n    vec3 mask;\n    float dt;\n    \n    vec3 stp = sign(rd) * lod;\n    vec3 delta = rdinv * stp;\n    vec3 t_max = (p + max(stp,.0) - rayPos) * rdinv;\n    \n    float t = -0.0001;\n    for (int i = 0; i < MAX_RAY_STEPS; ++i) {\n       if (getVoxel(ivec3(p))) break;\n        dt = min(t_max.x, min(t_max.y, t_max.z)) - t;\n        t += dt;\n        \n        mask = vec3(equal(t_max, vec3(t)));\n        t_max += delta * mask;\n        p += stp * mask;\n        ps += dt * rd;\n        \n        if (lod < 64.0 && i % 16 == 0) {\n            lod *= 0.5, lodinv *= 2.0, stp *= 0.5, delta *= 0.5;\n            p = floor(ps * lodinv) * lod;\n            t_max = (p + max(stp,.0) - rayPos) * rdinv;\n        }\n    }\n    fragColor.rgb = vec3(1.0, 1.0, 1.0) * mask;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}