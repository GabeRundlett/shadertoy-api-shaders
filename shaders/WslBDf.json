{
    "Shader": {
        "info": {
            "date": "1589211070",
            "description": "Thanks for the 3blue1brown video https://www.youtube.com/watch?v=r6sGWTCMz2k\n",
            "flags": 32,
            "hasliked": 0,
            "id": "WslBDf",
            "likes": 3,
            "name": "Day 144 - Fourier Series",
            "published": 3,
            "tags": [
                "fourier",
                "maths",
                "series",
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 421
        },
        "renderpass": [
            {
                "code": "// The code is rather messy and there could be mistakes in the implementation. \n// I recommend trying to do it yourself.\n\n// Fourier Series \n\n// 3b1b video: https://www.youtube.com/watch?v=r6sGWTCMz2k\n\n// Buffer A calculates an and bn and they are integrated here.\n\n\n\n\n// Thanks to mla/iq for smooth plotting function!\n\n// Plotting width\nconst float W = 0.01; \n// Plots a fn\nconst float eps = 0.005;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,W*width*0.5, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\nfloat fourierSeries (vec2 fragCoord){\n    \n    float a0 = T(vec2(fragCoord.x/iResolution.x,0.)).x;\n    \n    \n    // Here is the equation for reference https://en.wikipedia.org/wiki/Fourier_series\n    // It's calculated here.\n    \n    // an and bn are stored in x and y of Buffer B\n    // They are integrated in the following for() loop\n    \n    float Integral = 0.;\n    \n    \n    \n    for(float n = 0.; n < DISCRETE_STEPS_N; n++){\n        vec2 luv = vec2(\n\t\t\tfragCoord.x/iResolution.x,\n\t\t\tn/DISCRETE_STEPS_N\n\t\t);\n        vec4 p = T(luv); \n        \n    \tfloat an = p.x;\n    \tfloat bn = p.y;\n        \n        Integral += an*dxn + bn*dxn;\n    }\n\t\n    \n    // why is a0 /1. instead of /2. ? I don't know\n    float FS = a0/1. + Integral*1./pi;\n    return FS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*8.;\n    vec2 uvs = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n    \n    // functions \n\n    float term = 0.88; \n\tcol += graph( uv.y, fn(term*uv.x/tau),fn(term*uv.x/tau+eps),vec3(0.,0.2,0.1),1.);\n    \n    // draw bn\n    col += T(uvs).y/80.*vec3(0.7,0.2,0.1);\n    \n\t\n    col += graph( uv.y,  fourierSeries (fragCoord),fourierSeries(fragCoord+vec2(eps*iResolution.x,0.)),vec3(0.8,0.2,0.1), 0.5 );\n    \n    // plotlines\n    \n    //float uvxmod = abs( (fract((uv.x+offs*7.+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    float uvxmod = abs( (fract((uv.x+offs*pi*2.25+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    col += graph(uvxmod + eps,0.01,0.02,vec3(1,1,1)/2.,0.75)*smoothstep(W,W*0.003,abs(uv.y)-0.1);\n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1)/2.,0.5);\n    \n    // gamma correction\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define offs \t\t(iTime*0.25)\n\n//#define fn(j) \t\t( sin((j+offs)*FREQ*tau) +1.*cos((j+offs)*FREQ*2.*tau)  )\n//#define fn(j) \t\t( fract(j+offs)*FREQ )\n#define fn(j) \t\t( sin((j+offs)*FREQ*tau+1.*cos((j+offs)*FREQ/2.*tau) +7.*cos((j+offs)*FREQ/2.*tau)) +1.*cos((j+offs)*FREQ*2.*tau)  )\n\n\n#define FREQ 2.\n#define PERIOD 2.\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define DISCRETE_STEPS_N min(200.,iResolution.y)\n\n\n#define dxn (FREQ/DISCRETE_STEPS_N)\n\n\n\n#define T(uv) texture(iChannel0,uv)\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// This buffer calculates bn and ba\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord/iResolution.xy;\n  \n    vec2 p = vec2(0);\n     \n    float P = PERIOD;\n    float n = floor(uv.y*DISCRETE_STEPS_N)/DISCRETE_STEPS_N;\n    \n    \n    // Why do I have to offset with P*3. here ? I get bad result if I remove it\n    \n    float x = P*6. + P*uv.x;\n    \n    float an = (fn(x)*cos(tau*x*n/P));\n    \n    float bn = (fn(x)*sin(tau*x*n/P));\n    \n    \n    fragColor = vec4(an,bn,0.,0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}