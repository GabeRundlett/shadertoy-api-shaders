{
    "Shader": {
        "info": {
            "date": "1513790628",
            "description": "An iterative GPU-only approach to generating Signed Distance Fields. Not perfect, but a good start for something that needs to be done in real-time. Takes O(n) iterations for a solution, where n is either x or y size, depending on what is larger.",
            "flags": 32,
            "hasliked": 0,
            "id": "XlfBDl",
            "likes": 0,
            "name": "Signed Distance Fields v1",
            "published": 3,
            "tags": [
                "distancefield",
                "sdf",
                "distance",
                "field",
                "iterative",
                "signeddistancefield",
                "float"
            ],
            "usePreview": 0,
            "username": "Xaymar",
            "viewed": 727
        },
        "renderpass": [
            {
                "code": "// Buffer A: Shape Input for Buffer D.\n// Buffer D: SDF Generator, handles actual Alpha -> SDF conversion.\n// Image: Final output, do whatever you want with the SDF and shape input here.\n\n// Controls\n// - LMB + X Move: Resize Inner Ring Radius\n// - LMB + Y Move: Resize Outer Ring Radius\n\nconst float dist = 32.0;\nconst float borderDist = 4.0; // Modify this to get a larger or smaller ring.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float v = texture(iChannel0, uv).r;\n    if (v <= borderDist) {\n        fragColor = vec4(1.0, 1.0, 1.0, 0.0);// * (1.0 - v / (borderDist + 0.0001));\n    }\n    //fragColor = vec4(v / dist);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    \n    fragColor.a = 0.0;\n    float dist = distance(uv, vec2(0, 0)) * 2.0;\n    if ((dist >= iMouse.x / iResolution.x) && (dist <= iMouse.x / iResolution.x + iMouse.y / iResolution.y)) {\n    \tfragColor.a = 1.0;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// A very basic approach at generating SDFs purely on the GPU,\n//  it is basically just a nearest-neighbour search algorithm\n//  that runs on two buffers after another.\n//\n// The idea behind it is to generate these over time instead of\n//  relying on pregenerated SDFs to allow for new and dynamic\n//  shapes to be represented as well as reduce CPU usage.\n//\n// Unfortunately, this approach has some issues:\n// - It loses accuracy the further you go away.\n// - Not all shapes are perfectly represented.\n// - Multi-SDF are likely impossible without a contrast/angle\n//    test.\n// - It also counts everything inside the shape as 0 distance,\n//    instead of going into negative distance.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 c1uvi = 1.0 / iResolution.xy;\n    \n    // Are we already on the shape?\n    float alpha = texture(iChannel1, uv).a;\n    if (alpha > 0.0) {\n        fragColor.r = 0.0;\n        fragColor.g = 1.0;\n        return;\n    }\n    \n    // Find nearest neighbour.\n    { // This is purely for precision, the above is technically already good enough.\n        float iU, iD, iL, iR;\n\t\tiU = texture(iChannel1, uv - vec2(0, c1uvi.y)).a;\n\t\tiD = texture(iChannel1, uv + vec2(0, c1uvi.y)).a;\n\t\tiL = texture(iChannel1, uv - vec2(c1uvi.x, 0)).a;\n\t\tiR = texture(iChannel1, uv + vec2(c1uvi.x, 0)).a;\n        \n\t\tif ((iU > 0.0) || (iD > 0.0) || (iL > 0.0) || (iR > 0.0)) {\n            fragColor.r = 1.0;\n\t\t\treturn;\n\t\t}\n        \n\t\tiU = texture(iChannel1, uv - vec2(c1uvi.x, c1uvi.y)).a;\n\t\tiD = texture(iChannel1, uv - vec2(-c1uvi.x, c1uvi.y)).a;\n\t\tiL = texture(iChannel1, uv + vec2(-c1uvi.x, c1uvi.y)).a;\n\t\tiR = texture(iChannel1, uv + vec2(c1uvi.x, c1uvi.y)).a;\n        \n\t\tif ((iU > 0.0) || (iD > 0.0) || (iL > 0.0) || (iR > 0.0)) {\n            fragColor.r = 1.4142135623730950488016887242097;\n\t\t\treturn;\n\t\t}\n    }\n    \n    // No nearest neighbour, so use iterative solution.\n\t{\n\t\tfloat lowest = 255.0;\n\t\tfloat iU, iD, iL, iR;\n\t\tiU = texture(iChannel0, uv - vec2(0, c1uvi.y)).r;\n\t\tiD = texture(iChannel0, uv + vec2(0, c1uvi.y)).r;\n\t\tiL = texture(iChannel0, uv - vec2(c1uvi.x, 0)).r;\n\t\tiR = texture(iChannel0, uv + vec2(c1uvi.x, 0)).r;\n        \n\t\tif (iU < lowest) { lowest = iU; }\n\t\tif (iD < lowest) { lowest = iD; }\n\t\tif (iL < lowest) { lowest = iL; }\n\t\tif (iR < lowest) { lowest = iR; }\n        \n\t\tiU = texture(iChannel0, uv - vec2(c1uvi.x, c1uvi.y)).r + 0.4142135623730950488016887242097;\n\t\tiD = texture(iChannel0, uv - vec2(-c1uvi.x, c1uvi.y)).r + 0.4142135623730950488016887242097;\n\t\tiL = texture(iChannel0, uv + vec2(-c1uvi.x, c1uvi.y)).r + 0.4142135623730950488016887242097;\n\t\tiR = texture(iChannel0, uv + vec2(c1uvi.x, c1uvi.y)).r + 0.4142135623730950488016887242097;\n        \n\t\tif (iU < lowest) { lowest = iU; }\n\t\tif (iD < lowest) { lowest = iD; }\n\t\tif (iL < lowest) { lowest = iL; }\n\t\tif (iR < lowest) { lowest = iR; }\n\n        fragColor.r = lowest + 1.0;\n                            \n\t\treturn;\n\t}\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}