{
    "Shader": {
        "info": {
            "date": "1587499517",
            "description": "Looking through some old files, found this nice colourful Apollonian gasket. Mouse moves things around. Change line 85 for the halfplane.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsScDt",
            "likes": 12,
            "name": "Colourful Apollonian",
            "published": 3,
            "tags": [
                "apollonian"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 585
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n// A colourful Apollonian Gasket\n// Just mouse control for this one\n// Matthew Arcus, mla, 2020.\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\nfloat N = 3.0;\nconst int max_iterations = 100;\nconst float pi = 3.14159265;\n\nbool checkinverse(inout vec2 pos, vec3 c, float s, inout float mindist2) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  float d2 = s*p2 - s*c.z;\n  if (d2 > 0.0) {\n    mindist2 = min(d2,mindist2);\n    return false;\n  }\n  pos = p*c.z/p2 + c.xy;\n  return true;\n}\n  \nbool checkinverse(inout vec2 pos, vec3 c, float s) {\n  float mindist2;\n  return checkinverse(pos,c,s,mindist2);\n}\n\nvec2 invert(vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  return p*c.z/p2 + c.xy;\n}\n  \nvec4 gasket(vec2 pos){\n  float theta = pi/N;\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  float r2min = 0.0;\n  for(int n = 0; n < max_iterations; n++){\n    float mindist2 = 1e8;\n    vec3 c1 = vec3(0,0,pow(r-s,2.0));\n    vec3 c2 = vec3(0,0,pow(r+s,2.0));\n    if (checkinverse(pos,c1,1.0,mindist2)) {\n    } else if (checkinverse(pos,c2,-1.0,mindist2)) {\n    } else {\n      bool found = false;\n      for (float i = 0.0; i < N; i++) {\n        float t = 0.2*iTime;\n        vec3 c = vec3(r*sin(2.0*i*theta+t), r*cos(2.0*i*theta+t), s*s);\n        if (checkinverse(pos,c,1.0,mindist2)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return vec4(pos,n,mindist2);\n    }\n  }\n  return vec4(pos,max_iterations,r2min);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec4 n){\n  float t = iTime;\n  return hsv2rgb(vec3(mod((t+n.z)/50.0,1.0),0.8,0.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 m = vec2(0,0.8);\n  if (iMouse.x != 0.0) {\n    m = 2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  }\n  vec2 c = m*(1.0/dot(m,m));\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*fragCoord.xy+vec2(i,j)/float(AA)-iResolution.xy)/iResolution.y;\n      if (false) {\n        z.y += 1.0;\n        z = invert(z,vec3(0,-1,2)); // Map half plane to unit disk.\n      }\n      z = invert(z,vec3(c,dot(c,c)-1.0));\n      vec4 data = gasket(z);\n      float d = 1.0/(sqrt(data.w)+1.0);\n      col += 0.8*d*getCol(data);\n    }\n  }\n  col /= float(AA*AA);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}