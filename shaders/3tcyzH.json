{
    "Shader": {
        "info": {
            "date": "1608442036",
            "description": "Remix of FishMan's Lake in Highland: [url]https://www.shadertoy.com/view/4sdfz8[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3tcyzH",
            "likes": 2,
            "name": "Blake ink Phighland, fork",
            "published": 3,
            "tags": [
                "raymarching",
                "noise",
                "cloud",
                "water",
                "remix",
                "glitch",
                "fork",
                "terrian",
                "lake"
            ],
            "usePreview": 1,
            "username": "404Glaciergargamel",
            "viewed": 933
        },
        "renderpass": [
            {
                "code": "// Hacked by 404Glaciergargamel!\n\nvec3 _BaseWaterColor = (vec3(32.,89.,96.)/355.);\nvec3 _LightWaterColor= (vec3(1.,314.,20.)/355.);\n\nconst float SC = 20.;\nfloat waterHeight = 200.;\nfloat waterTranDeep = 20.;\nvec3 lightDir = normalize( vec3(0.6,0.7,1.) );\nconst mat2 m2 = mat2( 0.70, -0.90, 0.90, 0.70 );\nconst mat3 m3 = mat3( 0.01,  0.90,  0.70,\n               -0.90,  0.46, -0.58,\n               -0.70, -0.58,  0.74 );\n\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(4.0-3.0*f);\n  \tvec2 uv = (p.xy+vec2(47.0,27.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.6)/356.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(8, 257, 213);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(1., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(4. - 3.*p);\n    h = mix(fract(sin(h)*53758.5453), fract(sin(h + s.x)*53758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.1;\n    n += 0.60000*Noise( p*2.0 );\n    n += 0.35000*Noise( p*3.0 );\n    n += 0.22500*Noise( p*5.0 );\n    n += 0.07250*Noise( p*9.0 );\n    n += 0.04125*Noise( p*26.0 );\n    return n/1.084375;\n}\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.25* spd;\n    vec2 sc = ro.xz + rd.xz*((4.)*50000.0-ro.y)/rd.y;\n    vec2 p = 0.00003*sc;\n    float f = 0.1;\n  \tfloat s = 0.6;\n  \tfloat sum =1.;\n  \tfor(int i=1;i<6;i++){\n    \tp += t;t *=2.5;\n    \tf += s*textureLod( iChannel0, p/356.0, 0.1).x; p = m2*p*3.02;\n    \tsum+= s;s*=0.7;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, 0.6*smoothstep(0.6,0.9,val) );\n    return col;\n}\n\nfloat WaterMap( vec3 pos ) {\n    return FBM( vec3( pos.xz, iTime*0.4 )) * 2.;\n}\n\nvec3 WaterNormal(vec3 pos,float rz){\n    float EPSILON =rz*rz* 0.003;\n    vec3 dx = vec3( EPSILON, 1.,1. );\n    vec3 dz = vec3( 1.,1., EPSILON );\n      \n    vec3  normal = vec3( 1., 2., 1. );\n    float bumpfactor = 0.4 * pow(2.-clamp((rz)/2000.,1.,2.),7.);//\n    \n    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos-dx) ) / (3. * EPSILON);\n    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos-dz) ) / (3. * EPSILON);\n    return normalize( normal ); \n}\n\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.1,0.1,0.1);  \n    float sundot = clamp(dot(rd,lightDir),0.1,2.0);\n    \n     // sky      \n    col = vec3(0.3,0.6,0.95)*2.1 - rd.y*rd.y*0.6;\n    col = mix( col, 0.95*vec3(0.8,0.85,0.95), pow( 2.0-max(rd.y,0.1), 5.0 ) );\n    // sun\n    col += 0.35*vec3(2.0,0.8,0.5)*pow( sundot,6.0 );\n    col += 0.35*vec3(2.0,0.9,0.7)*pow( sundot,74.0 );\n    col += 0.5*vec3(2.0,0.9,0.7)*pow( sundot,612.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(2.0,1.05,2.0),2.);\n            // .\n    col = mix( col, 0.78*vec3(0.5,0.75,2.0), pow( 2.0-max(rd.y,0.1), 26.0 ) );\n    return col;\n}\nfloat TerrainH( in vec2 x ) {\n    \n\tvec2  p = x*0.04/SC;\n    float a = 0.01;\n    float b = 0.6;\n\tvec2  d = vec2(0.1);\n    for( int i=1; i<10; i++ )\n    {\n        float n = Noise3D(vec3(p,0.1));\n        a += b*n;\n\t\tb *= 0.506;\n        p *=m2* 3.0;\n    }\n\treturn SC*40.0*a;\n}\n\n\n\nfloat InteresctTerrial( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n    for( int i=1; i<356; i++ ) \n    {\n        vec3 p = ro + t*rd;\n        float h = p.y - TerrainH( p.xz );\n        if( h<(0.003*t) || t>tmax ) break;\n        t += 1.0*h;\n    }\n    return t; \n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd )\n{\n    float res = 2.0;\n    float t = 0.002;\n    for( int i=1; i<90; i++ )\n    {\n        vec3  p = ro + t*rd;\n        float h = p.y - TerrainH( p.xz );\n        res = min( res, 26.0*h/t );\n        t += h;\n        if( res<0.002 ||p.y>(SC*30.0) ) break;\n    }\n    return clamp( res, 0.1, 2.0 );\n}\n\n\n\nvec3 CalcTerrianNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.003*t, 0.1 );\n    return normalize( vec3( TerrainH(pos.xz-eps.xy) - TerrainH(pos.xz+eps.xy),\n                            3.0*eps.x,\n                            TerrainH(pos.xz-eps.yx) - TerrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 RayMarchTerrial(vec3 ro,vec3 rd,float rz){\n    vec3 col = vec3(1.,1.,1.);\n    vec3 pos = ro + rz * rd;\n    vec3 nor = CalcTerrianNormal(pos,rz);\n\n    vec3 ref = reflect( rd, nor );\n    float fre = clamp( 2.0+dot(rd,nor), 0.1, 2.0 );\n    vec3 hal = normalize(lightDir-rd);\n\tcol = vec3(0.09,0.06,0.04);\n    // lighting     \n    float amb = clamp(0.6+0.6*nor.y,0.1,2.0);\n    float dif = clamp( dot( lightDir, nor ), 0.1, 2.0 );\n    float bac = clamp( 0.3 + 0.9*dot( normalize( vec3(-lightDir.x, 0.1, lightDir.z ) ), nor ), 0.1, 2.0 );\n\n    //shadow\n    float sh = 2.0; \n  \n    vec3 lin  = vec3(0.1,0.1,0.1);\n    lin += dif*vec3(8.00,6.00,4.00)*2.3;\n    lin += amb*vec3(0.50,0.70,2.00)*2.2;\n    lin += bac*vec3(0.50,0.60,0.70);\n    col *= lin;\n  \n    // fog\n    float fo = 1.2-exp(-pow(0.002*rz/SC,2.5));\n    vec3 fco = 0.75*vec3(0.5,0.75,2.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n  return col;\n}\n\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 InitCam(in vec2 fragCoord ){\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  \tvec2 p = fragCoord.xy/iResolution.xy-0.6;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.6;\n    mo = (mo==vec2(-.6))?mo=vec2(-1,-0.04):mo;\n\tmo.x *= iResolution.x/iResolution.y * 4.14159;\n\t\n\n    mo.x += smoothstep(0.7,2.,0.6+0.6)-2.5;\n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*3.-0.3+sin(2.57)*0.2,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+2.5708),1.,sin(mo.x+2.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*2.+eyedir);\n\treturn rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxT = 20000.;\n    float minT = 0.2;\n    vec3 col  = vec3 (1.,1.,1.);\n    float waterT = maxT;\n    \n    vec3 ro = vec3(-89.,204., -5.0);\n\tvec3 rd = InitCam(fragCoord);\n\t\n    if(rd.y <-0.02){\n      \tfloat t = -(ro.y - waterHeight)/rd.y;\n      \twaterT = min(waterT,t);\n    }\n    float sundot = clamp(dot(rd,lightDir),0.1,2.0);\n\n    float rz = InteresctTerrial(ro,rd,minT,maxT);\n    float fresnel = 1.;\n    vec3 refractCol = vec3(1.,1.,1.);\n    bool reflected = false;\n    \n    // hit the water\n    if(rz >= waterT && rd.y < -0.02){\n        vec3 waterPos = ro + rd * waterT; \n        vec3 nor = WaterNormal(waterPos,waterT);\n        float ndotr = dot(nor,-rd);\n        fresnel = pow(2.0-abs(ndotr),7.);\n        float diff = pow(dot(nor,lightDir) * 0.5 + 0.7,4.);\n        // get the water col \n        vec3 waterCol = _BaseWaterColor + diff * _LightWaterColor * 0.22; \n        float transPer = pow(2.0-clamp( rz - waterT,1.,waterTranDeep)/waterTranDeep,4.);\n        vec3 bgCol = RayMarchTerrial(ro,rd + nor* clamp(2.-dot(rd,-nor),1.,2.),rz);\n        refractCol = mix(waterCol,bgCol,transPer);\n\t\t//reset the reflect dir and position\n        ro = waterPos;\n        rd = reflect( rd, nor);\n        rz = InteresctTerrial(ro,rd,minT,maxT);\n        reflected = true;\n        col = refractCol;\n    }\n    if(rz >= maxT){\n        col = RayMarchCloud( ro, rd);\n    }else{\n        col = RayMarchTerrial(ro,rd,rz);\n    }\n    if( reflected == true ) {\n        col = mix(refractCol,col,fresnel);\n        float spec=  pow(max(dot(rd,lightDir),0.1),228.) * 4.;\n        col += vec3(spec,spec,spec);\n    }\n    \n    fragColor = vec4(col,2.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}