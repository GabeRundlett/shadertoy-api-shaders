{
    "Shader": {
        "info": {
            "date": "1641574573",
            "description": "This will display your GPU manufacturer's name if known, and a 16bit hash. Texture filters and math functions are implemented differently by each manufacturer. Please comment your hash, if no manufacturer's name is displayed.",
            "flags": 0,
            "hasliked": 0,
            "id": "slySWV",
            "likes": 31,
            "name": "GPU manufacturer detector",
            "published": 3,
            "tags": [
                "text",
                "gpu"
            ],
            "usePreview": 0,
            "username": "archee",
            "viewed": 1396
        },
        "renderpass": [
            {
                "code": "/*\nA new concept with better hash function here:\nhttps://www.shadertoy.com/view/7ssyzr\n\nReading from texture is necessary, because otherwise it could be calculated compilation time.\nCPUs had a standard requiring all bits accuracy floating point math in + - / * sqrt, \nwhich is useful when developing multiplayer physics games. But SIMD functions are only required for accuracy within a certain range. so have to avoid those.\n\nGPUs have no such standard, they are just accurate to certain range.\nReciptrocal, sqrt, sin all probably work with constants  in a table for a polynom. \nJust one of these functions should be enough to tell what GPU you are using. \n*/\nuint hardwareHash()\n{\n    vec3 a = normalize(texture(iChannel1,vec2(0.50,0.52)).xyz);\n    a.x += sin(texture(iChannel1,vec2(0.51,0.52)).x)*0.1;\n    a.x += sqrt(texture(iChannel1,vec2(0.52,0.52)).x)*0.1;\n    return uint(fract(abs(a.x))*65536.*256.)&0xFFffu;\n}\n\n// font and printing\nvec2 printCursor;\nfloat printColor=0.;\n#define C(c) printColor+= char(printCursor,c).x;printCursor.x-=.5\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn texture( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ) );\n}\nvoid printHex(uint i)\n{\n    for(int j=3;j>=0;j--)\n    {\n        uint digit = uint((i>>(j*4))&15u);\n        C(int((digit<=9u?48u:65u-10u)+digit));\n    }\n}\n\n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    uv /= iResolution.y;\n    printCursor = ( uv - vec2(.1,0.4))*5.;\n    \n    uint hash = hardwareHash();\n    switch(int(hash))\n    {\n    // nVidia\n    case 0x204E:  // nVidia  (pascal, turion, ampere)\n    case 0x263F:  // nVidia RTX 2080 (turion, why different?)\n        C(_n);C(_V);C(_i);C(_d);C(_i);C(_a);\n        break;\n    \n    // AMD\n    case 0x23CB: // AMD GCN4  Win AngleDX, Linux  (rx 500 series, Vega 8)\n    case 0x2347: // AMD GCN4  Win OpenGL          (rx 500 series, Vega 8)\n    case 0x2148: // AMD GCN2    (r7 250 ultimate)\n    case 0x21C6: // AMD Terascale3  (A4-4000 APU)\n        C(_A);C(_M);C(_D);\n        break;\n        \n    // Intel\n    case 0x3DF3: // intel UHD 11th gen\n    case 0x2386: // Intel UHD 7th gen\n    case 0x1CB1: // Intel old (eg. HD graphics 3000) \n        C(_I);C(_n);C(_t);C(_e);C(_l);\n        break;\n        \n    // Mali   (Samsung, Mediatek and most ARM chipset)\n    case 0x7B5C:  // MALI-G52,G72\n    case 0x3B5C:  // Mali-G78 MP20  (Pixel 6)\n    case 0x3ACF:  // Mali-G78 MP12  (Samsung Exynoss 2100)\n    case 0x7A00:  // Asus Tinkerboard (low precision result)\n        C(_M);C(_a);C(_l);C(_i);\n        break;\n        \n    // Adreno\n    case 0x3CCD:  // Adreno  ( Qualcomm ARM SoCs)\n        C(_A);C(_d);C(_r);C(_e);C(_n);C(_o);\n        break;\n        \n    // software rendering\n    case 0x2659:  // lavapipe\n    case 0x3D59:  // llvmpipe\n    case 0x2B7D:  // MESA llvmpipe,  Chrome crashes, use Firefox\n        C(_s);C(_o);C(_f);C(_t);C(_w);C(_a);C(_r);C(_e);\n        break;\n        \n    // VideoCore\n    case 0x271F:  //  Raspberry PI \n        C(_V);C(_i);C(_d);C(_e);C(_o);C(_C);C(_o);C(_r);C(_e);\n        break;\n        \n//    default: // unknown\n//        C(_u);C(_n);C(_k);C(_n);C(_o);C(_w);C(_n);C(_space);  // Some implementation will crash if shader is too long\n    }\n    \n    printCursor = ( uv - vec2(.12,0.2))*10.;\n    printHex(uint(hash));\n    \n    O = vec4(printColor*0.8);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define _space 32\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}