{
    "Shader": {
        "info": {
            "date": "1709461486",
            "description": "Use the mouse to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "43lSWH",
            "likes": 3,
            "name": "Slimey stuff",
            "published": 3,
            "tags": [
                "slimey"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 148
        },
        "renderpass": [
            {
                "code": "#define R iResolution.xy\n#define T (iTime)\n\n\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\n\nfloat random(vec2 co, float seed) {\n    uvec2 p = floatBitsToUint(co);\n    uint s = floatBitsToUint(seed);\n    uvec2 k = (~p.yx);\n    p ^= p << 17U;\n    p ^= p >> 13U;\n    p ^= p << 5U;\n    p += (p ^ (k >> 3U));\n    p *= 1013U;\n    k += ~p + ~s;\n    uvec2 j = (k + s) & 0xADEFFF3CU;\n    p ^= p << 34U;\n    k *= 5013U;\n    p *= 3013U;\n    return float(k.x * k.y + p.x * p.y + 0xC3F00EBU*((j.x << (j.y)) + (j.y >> (j.x)))) / float(0xFFFFFFFFU);\n}\n\n\nfloat voro(vec2 uv, float seed, float cellSize) {\n    vec2 grid = floor(uv * cellSize);\n    float minDist = 10.0;\n\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = grid + vec2(float(x), float(y));\n            vec2 offset = vec2(random(neighbor, seed), random(neighbor, seed+22.234125));\n            vec2 point = neighbor + offset;\n            float dist = distance(uv * cellSize, point);\n            minDist = smin(minDist, dist, mix(0.01, 0.59, 0.5+0.5*sin(T*3.+20.*(offset.x*2.321+offset.y))));\n        }\n    }\n    \n    return minDist;\n}\nvoid mainImage( out vec4 o, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n    \n    \n    \n    if (m.z > 0.001) {\n        uv.x -= m.x;\n        uv.y -= m.y;\n    }\n    \n    \n    uv *= mix(2.0, 4.5, smoothstep(5.0, 10.0, T)*(0.5+0.5*sin(T)));\n    uv *= rot(0.1*T);\n    \n    float v1 = voro(uv, 11.129, 3.0);\n    float v2 = voro(uv, 0.12515, 4.0);\n    float v3 = voro(uv+0.25*(vec2(v1, v2)*2.0-1.0), 5.88572, 8.0);\n    \n    v3 = mix(v3, v2, smoothstep(0.39, 0.71, 0.75*v2));\n    \n    col += smoothstep(1.5, 0.0, v1);\n    col = mix(col, vec3(1, 0.2+0.93*(v1*v1*v1), 0.15), smoothstep(0.0, 1.7, v2));\n    col = mix(col, col*col, v3);\n    \n    col = mix(col, vec3(v3*v1), 0.15*smoothstep(0.0, 0.09, abs((v1-v3)+(v2-v1))));\n    col += 0.3*vec3(0.9, 0.09, 0.15)*abs(normalize(cross(vec3(v1, v2, v3)*2.0-1.0, col*2.0-1.0)));\n\n    col = col*col*col;\n    col += col*col*luma(col);\n    \n    \n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n\n    o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}