{
    "Shader": {
        "info": {
            "date": "1716357998",
            "description": "In my previous version, I was simply stepping through the scene, which was extremely slow. I realized I could constrain myself to checking the inflection points, and using the Bisection method to find the surface, which is significantly faster.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3dGRM",
            "likes": 0,
            "name": "Faster Metaball",
            "published": 3,
            "tags": [
                "3d",
                "metaball"
            ],
            "usePreview": 0,
            "username": "triggthediscovery",
            "viewed": 99
        },
        "renderpass": [
            {
                "code": "// This is a simple metaball renderer.\n// By default, there are 14 spheres grouped in two circles moving in\n// opposite directions.\n//\n// provided under CC0.\n\nvec3 spheres[14];\nvec3 light_dir;\nconst int num_spheres = 14;\nconst float threshold = 2.5;\nconst int steps = 7;\nvec2 distances[num_spheres];\n    \n// Find the normal at a position. Uses absolute position\n// because the position information is lost in the 2D version.\nvec3 check_normal(vec3 point) {\n    float amt = 0.0;\n    vec3 norm = vec3(0);\n\n    for (int i=0; i<num_spheres; i++) {\n        float sdist = distance(spheres[i], point);\n\n        float add = 1.0/(sdist*sdist);\n\n        amt += add;\n        norm += normalize(spheres[i] - point) * add;\n\n        if (amt > threshold) return normalize(norm);\n    }\n    \n    return vec3(0,1,0);\n}\n\n// Check a point, assuming direction.\nfloat check_point(float point) {\n    float amt = 0.0;\n\n    for (int i=0; i<num_spheres; i++) {\n        float total_dist = length(vec2(abs(point - distances[i].y), distances[i].x));\n        \n        amt += 1.0/(total_dist*total_dist);\n    }\n    \n    return amt;\n}\n\n// Does a binary search for the edge of the metasurface.\n// You probably could use inference to reduce the number\n// if steps needed.\nfloat check_range(float search_start, float search_end) {\n    for (int i=0; i<steps; i++) {\n        float mid = (search_start+search_end)/2.0;\n\n        if (check_point(mid) >= threshold) {\n            search_end = mid;\n        } else {\n            search_start = mid;\n        }\n    }\n    \n    \n    return search_end;\n}\n\n// Does the full raycast by first calculating a 2D\n// representation, sorting it, and using it to\n// accelerate operations.\nvec4 check_ray(vec3 vector_pos, vec3 vector_dir) {\n    // Calculate simplified distances. The distance can\n    // be simplified to 2D.\n    for (int i=0; i<num_spheres; i++) {\n        vec3 sphere_vec = spheres[i] - vector_pos;\n        \n        float dt = dot(sphere_vec,vector_dir);\n        \n        vec3 closest_point = vector_pos + (vector_dir * dt);\n\n        distances[i] = vec2(distance(spheres[i], closest_point), dt); \n    }\n    \n    int pos = 0;\n    int top = num_spheres;\n\n    // Insertion sort the distances.\n    for (int i=0; i<num_spheres; i++) {\n        for (int j=0; j<(num_spheres-i); j++) {\n            if (distances[j].y>distances[j+1].y) {\n                vec2 hold = distances[j];\n                distances[j] = distances[j+1];\n                distances[j+1] = hold;\n            }\n        }\n    }\n\n    for (int i=0; i<num_spheres; i++) {\n        if (check_point(distances[i].y) > threshold) {\n            float dist;\n        \n            if (i > 0) {\n                dist = check_range(distances[i-1].y, distances[i].y);\n            } else {\n                dist = check_range(distances[i].y-2.0, distances[i].y);\n            }\n\n            return vec4(check_normal(vector_pos+(vector_dir*dist)), dist);\n        }\n    }\n\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    \n    float wid = 0.7;\n    float add = 0.6;\n\n    float ang = iTime/2.0;\n    float xamt = 3.0;\n    float yamt = sqrt((xamt*xamt)/2.0);\n    float zamt = sqrt((xamt*xamt)/2.0);\n\n    // First group of 8 moving clockwise. \n    for (int i=0; i<8; i++) {\n        float offset = float(i) * (6.28/8.0);\n    \n        spheres[i] = vec3(-sin(ang + offset)*xamt, cos(ang + offset)*yamt+2.0, (cos(ang + offset)*zamt)+2.5); \n    }\n\n    // Secon group of 6 moving counter clockwise. \n    for (int i=8; i<14; i++) {\n        float offset = float(i) * (6.28/6.0);\n    \n        spheres[i] = vec3(-sin(-ang + offset)*xamt, -cos(-ang + offset)*yamt-2.0, (cos(-ang + offset)*zamt)+2.5);\n    }\n    \n    light_dir = normalize(vec3(0.5, 0.0, 1.0));\n    \n    vec3 in_vec_d = vec3(0, 0, 1.0);\n    vec3 in_vec_p = vec3(0, 0, -4.0);\n\n    float fov = 2.5;\n    vec3 in_vec_d_hold = in_vec_d;\n\n    in_vec_d.x += (in_vec_d_hold.z*(uv.x*fov));\n    in_vec_d.z -= (in_vec_d_hold.x*(uv.x*fov));\n    in_vec_d.y += uv.y*fov/1.8;\n    \n    in_vec_d = normalize(in_vec_d);\n    \n    vec4 norm = check_ray(in_vec_p, in_vec_d);\n    \n    vec3 col = vec3(0,0,0);\n    \n    if (norm != vec4(0.0)) {\n        // Light calculation.\n        col = vec3(clamp(dot(norm.xyz, light_dir), 0.0, 1.0)+0.1);\n        \n        // Fog calculation.\n        col *= 1.0-(norm.w/15.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}