{
    "Shader": {
        "info": {
            "date": "1539724563",
            "description": "I'm training to do particles systems.",
            "flags": 0,
            "hasliked": 0,
            "id": "MltBDN",
            "likes": 1,
            "name": "Testing Particles - Thorgrim",
            "published": 3,
            "tags": [
                "particules"
            ],
            "usePreview": 0,
            "username": "Thorgrimar",
            "viewed": 419
        },
        "renderpass": [
            {
                "code": "#define pi (3.14159265359)\n#define twopi (6.28318530718)\n\n#define time (iTime)\n\nvec2 cartToPol(vec2 coordCart) { return vec2( length(coordCart), atan(coordCart.y,coordCart.x)); }\n\nvec2 cartToPolold(vec2 coordCart)\n{\n    float x = coordCart.x;\n    float y = coordCart.y;\n    float r = length(coordCart);\n    if (x > 0.) {\n        if (y >= 0.) {\n            return vec2(r, atan(y/x));\n        }\n        return vec2(r, atan(y/x) + 2.*pi);\n    }\n\t\n\tif (x < 0.) {\n    \treturn vec2(r, atan(y/x) + pi);\n    }\n    // then x = 0.\n    if (y > 0.) {\n        return vec2(r, pi/2.);\n    }\n    return vec2(r, 3./2.*pi);\n}\n\nfloat periodicTriangle(float x, float period, float duration) {\n    float xmod = mod(x, period);\n    if (xmod < duration) {\n        return xmod/duration;\n    }\n    return 0.;\n}\n\n\nfloat rand(vec2 p) {\n    return fract( cos( dot( p, vec2(5.237,6.378)))*8463.648);\n}\n   \nvec3 vecRand(vec2 p) {\n    return vec3(fract( cos( dot( p, vec2(6.237,7.378)))*8423.648),\n                fract( cos( dot( p, vec2(4.237,5.378)))*6173.348),\n                fract( cos( dot( p, vec2(2.237,3.378)))*1427.678));\n}\n\nvec3 colorCircle(vec2 center, float radius, vec3 color, vec2 pos)\n{\n    \n    float d = distance(center, pos);\n    float dmr = d - radius;\n    if (dmr < 0.) {\n        return (1.-d/radius)*color;\n    }\n    return vec3(0.);\n}\n\n// TODO ; add a inner fade \n\nvec3 colorEmitterCircles(vec2 center, float insideRadius, float emittRadius, float circleRadius, vec3 color, float angleRot, float nbrPieces, vec2 pos)\n{\n    float circleSpeed = .5;\n    // period T between two pop must be > 2.*circleRadius/circleSpeed\n    float T = 4.*circleRadius/circleSpeed;\n\tvec2 coordPol = cartToPol(pos - center);\n    float r = coordPol.x;\n    float th = coordPol.y;\n    if (r < emittRadius + circleRadius) {\n        // on each piece : \n        float numPiece = floor((th - angleRot)/twopi*nbrPieces);\n        float anglePath = twopi*(numPiece+0.5)/nbrPieces + angleRot;\n        float nT = nbrPieces*T;\n        float rCenterCircle = mod(time - numPiece*T, nT)/nT*emittRadius;\n        vec2 centerCircle = center + rCenterCircle*vec2(cos(anglePath), sin(anglePath));\n        vec3 col = (1.-r/emittRadius)*colorCircle(centerCircle, circleRadius, color, pos);\n        \n        // add a sparkel effect\n        col *= 1. + 1.5*abs(sin(time*(100.+10.*rand(vec2(numPiece, 23.5)))));\n        \n        // inner particules disappear smoothly\n        if (r < insideRadius) {\n            if (r < insideRadius/2.) {\n                col = vec3(0.);\n            } else {\n                float rate = 2.*r/insideRadius-1.;\n            \tcol *= rate*rate;\n            }\n        }\n        return col;\n    } else {\n        return vec3(0.);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (uv.x from -1.0 to 1.0)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x; \n\n    vec3 col = vec3(0.);\n    \n    \n    vec2 maxAxis = vec2(1., iResolution.y/iResolution.x);\n    float period = 2.;\n    float numPeriod = floor(time/period);\n    \n    float emittRadius = .5;\n    float radiusCircles = 0.01;\n    \n    \n    int nbrExplo = 2 + int(100.*rand(vec2(numPeriod, 14.)))%2;\n    \n    for (int j = 0; j < nbrExplo; j++) {\n        float numExplo = float(j);\n        vec2 center = mix(-0.5*maxAxis, 0.5*maxAxis, vec2(rand(vec2(numExplo, 0.1)), rand(vec2(numExplo, 0.2))));\n        vec3 color1 = vec3(.4, .4, .4) + vecRand(vec2(numExplo, 26.41));\n        float angleRot = rand(vec2(numExplo, 126.41));\n        float nbrPieces = 10. + 5.*floor(rand(vec2(numExplo, 45.41)));\n        float delay = 0.5*rand(vec2(numExplo, 0.5));\n        for (int i=0; i<20; i++) {\n        \tcol += colorEmitterCircles(center, emittRadius*periodicTriangle(time-0.2-delay, period, .8), emittRadius*periodicTriangle(time-delay, period, .9), radiusCircles, color1, angleRot, nbrPieces, uv);\n        \tangleRot += rand(vec2(center.x, float(i)/10.));\n    \t}\n    }\n    \n    nbrExplo = 2 + int(100.*rand(vec2(numPeriod, 15.)))%2;\n    for (int j = 0; j < nbrExplo; j++) {\n        float numExplo = float(j);\n        vec2 center = mix(-0.5*maxAxis, 0.5*maxAxis, vec2(rand(vec2(numExplo, 10.1)), rand(vec2(numExplo, 10.2))));\n        vec3 color1 = vec3(.4, .4, .4) + vecRand(vec2(numExplo, 126.41));\n        float angleRot = rand(vec2(numExplo, 126.41));\n        float nbrPieces = 10. + 5.*floor(rand(vec2(numExplo, 145.41)));\n        float delay = 0.5*rand(vec2(numExplo, 10.5));\n        for (int i=0; i<20; i++) {\n        \tcol += colorEmitterCircles(center, emittRadius*periodicTriangle(time-0.2-delay-period/2., period, .8), emittRadius*periodicTriangle(time-delay-period/2., period, .9), radiusCircles, color1, angleRot, nbrPieces, uv);\n        \tangleRot += rand(vec2(center.x, float(i)/10.));\n    \t}\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}