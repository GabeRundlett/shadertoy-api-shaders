{
    "Shader": {
        "info": {
            "date": "1549299127",
            "description": "fractal foundation realtime raytraced scene",
            "flags": 0,
            "hasliked": 0,
            "id": "WsBGzK",
            "likes": 21,
            "name": "fractal foundation flythrough",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "raytraced",
                "realtime",
                "foundations"
            ],
            "usePreview": 0,
            "username": "public_int_i",
            "viewed": 578
        },
        "renderpass": [
            {
                "code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define EPSILON 1e-2\n#define REFLECTION_EPSILON 4e-2\n#define NORMAL_PRECISION 1e-3\n\nvec2 rot(vec2 v, float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(co,-si,si,co);\n}\nmat2 rot2(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co,-si,si,co);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n//from https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat ruins(vec3 p) {\n    vec3 rp = p;\n    float d = 0.;\n    float s = 20.;\n    \n    for (int i = 0; i < 3; i++) {\n        rp -= s/8.;\n        d = max(-sdBox(mod(abs(rp), s*2.)-s, vec3(s*.9)), d);\n        \n        if (mod(float(i),2.) > 0.) {\n            rp.xz = abs(rot(rp.xz,float(i)*1.8+1.5));\n        } else {\n            rp.zy = abs(rot(rp.zy,float(i)*1.2+0.5));\n        }\n        \n    \ts /= 2.;\n    }\n                       \n    return max(d,p.y);\n}\n\nfloat distf(vec3 p) {\n\treturn ruins(p);\n}\n\nvec3 normf(vec3 p, float bd) {\n\treturn normalize(vec3(distf(p+vec3(NORMAL_PRECISION,0,0))-bd,\n\t\t\t\t\t\t  distf(p+vec3(0,NORMAL_PRECISION,0))-bd,\n\t\t\t\t\t\t  distf(p+vec3(0,0,NORMAL_PRECISION))-bd));\n}\n\nfloat ambientOcclusion(vec3 arp, vec3 nrm, const int iter) {\n\tfloat asum = 0., as = .1;\n\tfor (int i = 0; i < iter; i++) {\n\t\tfloat adst = distf(arp);\n\t\tasum += max(0.,1.-adst/as);\n\t\tarp += nrm*adst;\n\t\tas += adst;\n\t}\n\treturn pow(clamp(1.-asum*.07,0.,1.),1./2.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    \n\t//initial ray parameters\n\tvec4 hsh = hash(uv.xyyx*vec4(1,1,.3,.3));\n\tvec3 rp = vec3(cos(iTime*.044)*100.,-40.+sin(iTime*.05+.5)*20.,0.),\n\t\trd = normalize(vec3(uv+(hsh.xy-.5)/iResolution.xy,1.));\n\tmat2 rang = rot2(iTime*.04);\n\trp.xz *= rang;\n\trd.xz *= rang;\n\trp += rd*(5.+hsh.z*2.0);\n\t\n\t//raytracing\n\tvec3 orp = rp;\n\tfloat eps = EPSILON;\n\tfor (int i = 0; i < 64; i++) {\n\t\tfloat dst = distf(rp);\n\t\tif (dst < eps) break;\n\t\trp += rd*dst;\n\t\teps *= 1.1;\n\t}\n\t\n\t#define depthl(p) clamp(p.y*.01+1.,0.,1.)\n\t#define bgl(rd) max(0.,rd.y)\n\t#define fogl(v,len,rd) mix(v,bgl(rd),min(1.,len/200.))\n\t\n\tfloat bdst = distf(rp);\n\tif (bdst < eps) {\n\t\trp -= rd*eps*5.;\n\t\trp += rd*distf(rp)*.7;rp += rd*distf(rp)*.7;\n\t\tvec3 nrm = normf(rp,distf(rp));\n\t\tfloat sv = 0.;\n\t\t\n\t\t//reflection\n\t\tvec3 reflDir = reflect(rd,nrm), reflp = rp+reflDir*REFLECTION_EPSILON*2.;\n\t\tfloat reps = REFLECTION_EPSILON, reflectionAmount = (1.-max(0.,dot(rd,-nrm)))*.5;\n\t\tfor (int i = 0; i < 32; i++) {\n\t\t\tfloat dst = distf(reflp);\n\t\t\tif (dst < reps) break;\n\t\t\treflp += reflDir*dst;\n\t\t\treps *= 1.1;\n\t\t}\n\t\tif (distf(reflp) < reps) {\n\t\t\treflp -= reflDir*reps*5.;\n\t\t\treflp += reflDir*distf(reflp)*.7;reflp += reflDir*distf(reflp)*.7;\n\t\t\tvec3 reflNrm = normf(reflp,distf(reflp));\n\t\t\tfloat rl = ambientOcclusion(reflp,reflNrm,16);\n\t\t\trl *= depthl(reflp);\n\t\t\trl = fogl(rl,length(reflp-rp),reflDir);\n\t\t\tsv += rl*reflectionAmount;\n\t\t} else sv += bgl(reflDir)*reflectionAmount;\n\t\t\n\t\t//ambient occlusion\n\t\tsv += ambientOcclusion(rp,nrm,16)*(1.-reflectionAmount);\n\t\tsv *= depthl(rp);\n\t\tsv = fogl(sv,length(rp-orp),rd);\n\t\tfragColor = vec4(sv);\n\t} else {\n\t\tfragColor = vec4(max(0.,rd.y));//background\n\t}\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}