{
    "Shader": {
        "info": {
            "date": "1629399761",
            "description": "Implementation of perspective correct interpolation.\nContinuing to learn about rasterization!\nLeft: rasterized (background is red when perspective correction is turned off, green when turned on)\nRight: raytraced (gives direct access to the 3D coordinates)",
            "flags": 0,
            "hasliked": 0,
            "id": "Ndt3zM",
            "likes": 16,
            "name": "Perspective Correct Interp.",
            "published": 3,
            "tags": [
                "perspective",
                "interpolation",
                "correct"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 223
        },
        "renderpass": [
            {
                "code": "// From this lesson:\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/perspective-correct-interpolation-vertex-attributes\n\nstruct TriIntersect {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n};\n\nTriIntersect iTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a; a = vec3(0.0);\n    vec3 ba = b - a, cb = c - b, ac = a - c;\n\n    vec3 n = cross(ba, -ac);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        vec3 p = ro + rd * t;\n        vec3 pa = p - a, pb = p - b, pc = p - c;\n\n        float abc = length(n);\n        float u = length(cross(cb, pb)) / abc;\n        float v = length(cross(ac, pc)) / abc;\n        float w = length(cross(ba, pa)) / abc;\n\n        return TriIntersect(abs(u + v + w - 1.0) < 0.001, p, t, vec3(u, v, w));\n    }\n\n    return TriIntersect(false, vec3(0.0), 0.0, vec3(0.0));\n}\n\nbool pointInTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    bool pa = p.y > a.y, pb = p.y > b.y, pc = p.y > c.y;\n    bool wa = pa != pc && pc != ((c.x - a.x) * (p.y - a.y) > (c.y - a.y) * (p.x - a.x));\n    bool wb = pb != pa && pa != ((a.x - b.x) * (p.y - b.y) > (a.y - b.y) * (p.x - b.x));\n    bool wc = pc != pb && pb != ((b.x - c.x) * (p.y - c.y) > (b.y - c.y) * (p.x - c.x));\n    return wa ^^ wb ^^ wc;\n}\n\nvec3 barycentric(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    return vec3(bcp, cap, abp) / abc;\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y - vec2(0.5 * aspect, 0.5);\n    float unit = 2.0 / iResolution.y;\n    float offset = 0.25 * aspect;\n    vec3 color = vec3(0.0);\n\n    // Vertices\n    float transition = smoothstep(1.0, 0.0, abs(mod(iTime * 0.25, 2.0) - 1.0));\n    vec3 a = mix(vec3(-2.0, -2.0, -6.0), vec3(-2.0, -1.0, -7.0), transition);\n    vec3 b = mix(vec3( 2.0, -2.0, -6.0), vec3(2.0, -1.0, -5.0), transition);\n    vec3 c = mix(vec3( 2.0,  2.0, -6.0), vec3(0.0, 1.5, -11.0), transition);\n\n    // UVs\n    vec2 uv1 = vec2(0.0, 0.0);\n    vec2 uv2 = vec2(1.0, 0.0);\n    vec2 uv3 = vec2(1.0, 1.0);\n\n    if (uv.x > 0.0) { // Raytrace triangle on right\n        uv.x -= offset; // Recenter\n\n        vec3 ro = vec3(0.0, 0.0, 0.0);\n        vec3 rd = normalize(vec3(uv, -1.0));\n\n        // Blue gradient background\n        color.b += exp(-2.0 * length(fragCoord / iResolution.xy * vec2(2.0, 1.0) - vec2(1.5, 0.5)));\n\n        TriIntersect tri = iTriangle(ro, rd, a, b, c);\n        if (tri.hit) {\n            vec2 triUv = uv1 * tri.bary.x + uv2 * tri.bary.y + uv3 * tri.bary.z;\n\n            float grid = 1.0 - max(smoothstep(0.01, 0.0, abs(mod(triUv.x + 0.1, 0.2) - 0.1) - 0.002),\n                                   smoothstep(0.01, 0.0, abs(mod(triUv.y + 0.1, 0.2) - 0.1) - 0.002));\n\n            color = vec3(grid);\n        }\n\n        uv.x += offset;\n    }\n\n    if (uv.x < 0.0) { // Rasterize triangle on left\n        uv.x += offset; // Recenter\n\n        // Toggle perspective correction\n        bool correct = mod(iTime, 16.0) < 8.0;\n\n        // Gradient background (red when perspective correction is off, green when its on)\n        color.rg = vec2(!correct, correct) * exp(-2.0 * length(fragCoord / iResolution.xy * vec2(2.0, 1.0) - 0.5));\n\n        // Compute inverse z coordinates\n        float azInv = 1.0 / a.z;\n        float bzInv = 1.0 / b.z;\n        float czInv = 1.0 / c.z;\n\n        // Project (flipping the z due to the camera facing in the -z direction)\n        vec2 aProj = a.xy * -azInv;\n        vec2 bProj = b.xy * -bzInv;\n        vec2 cProj = c.xy * -czInv;\n\n        if (pointInTriangle(uv, aProj, bProj, cProj)) {\n            vec3 bary = barycentric(uv, aProj, bProj, cProj);\n\n            // Divide attributes by corresponding z coordinate\n            if (correct) {\n                uv1 *= azInv;\n                uv2 *= bzInv;\n                uv3 *= czInv;\n            }\n\n            vec2 triUv = uv1 * bary.x + uv2 * bary.y + uv3 * bary.z; // Interpolate like usual\n\n            if (correct) {\n                float z = 1.0 / (azInv * bary.x + bzInv * bary.y + czInv * bary.z); // Perspective correct z coordinate\n                triUv *= z;\n            }\n\n            float grid = 1.0 - max(smoothstep(0.01, 0.0, abs(mod(triUv.x + 0.1, 0.2) - 0.1) - 0.002),\n                                   smoothstep(0.01, 0.0, abs(mod(triUv.y + 0.1, 0.2) - 0.1) - 0.002));\n\n            color = vec3(grid);\n        }\n\n        uv.x -= offset;\n    }\n\n    color = mix(color, vec3(0.8, 0.6, 0.0), smoothstep(unit, 0.0, abs(uv.x) - 0.005));\n    fragColor.rgb += color;\n}\n\n// Supersample\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     fragColor = vec4(0.0);\n     render(fragColor, fragCoord);\n     render(fragColor, fragCoord + vec2(0.5, 0.0));\n     render(fragColor, fragCoord + vec2(0.0, 0.5));\n     render(fragColor, fragCoord + vec2(0.5, 0.5));\n     fragColor.rgb /= 4.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}