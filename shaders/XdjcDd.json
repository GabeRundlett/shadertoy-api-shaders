{
    "Shader": {
        "info": {
            "date": "1494408611",
            "description": "Base 10 grid with zoom for e.g. as a background for 2D graphing, distance field estimation or as planar procedural background. ",
            "flags": 0,
            "hasliked": 0,
            "id": "XdjcDd",
            "likes": 10,
            "name": "Pretty Grid",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "zoom",
                "gradient"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 937
        },
        "renderpass": [
            {
                "code": "////////////////////////////////\n//\n// Pretty Grid by Timo Kinnunen 2017\n//\n// Drag up/down to zoom.\n//\n// Based loosely on distance meter by cupe\n// @ https://www.shadertoy.com/view/ldK3zD\n//\n// This shader is licensed under\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License \n// [ http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US ].\n//\n\n//#define MINUS\n\nconst float TAU = 2.* 3.1415926535897932384626433832795;\nconst float grid4 = 2097152.0,grid3 = 131072.0,grid2 = 1024.0,grid1 = 64.0;\n\nvec4 grid(vec2 f, vec3 pos, float rdy, float t) {\n    float ff = min(iResolution.x,iResolution.y)/1024.0;\n\tvec4 distances = (abs(pos.xz)* TAU).xxyy;\n\tfloat referenceBase = log(20.*ff/ (t* pow(abs(rdy),.8)))/ log(10.);\n\tfloat nearestBase = floor(referenceBase);\n\tfloat partialBase = fract(referenceBase);\n\tconst vec4 gain = vec4(grid4- grid3,grid1,grid3- grid2,grid2- grid1);\n\tconst vec4 off = vec4(grid3,0,grid2,grid1);\n\tvec4 exponentialBase = partialBase* partialBase* gain+ off;\n\tvec4 bases = pow(vec4(10),nearestBase+ vec4(-2,1,-1,0));\n\tvec4 lx = pow(.5+ .5* cos(distances* bases.xyxy),exponentialBase.xyxy);\n\tvec4 ly = pow(.5+ .5* cos(distances* bases.zwzw),exponentialBase.zwzw);\n\tvec4 l4 = (1.- lx* vec4(1.- partialBase,partialBase,1.- partialBase,partialBase))* (1.- ly);\n\tvec2 l2 = l4.xy* l4.zw;\n\tfloat l1 = .30078125* (1.- l2.x* l2.y);\n#ifdef MINUS\n    l1 = -l1;\n#endif\n\treturn vec4(vec3(f.x/ iResolution.x,.5,f.y/ iResolution.y)+ l1,1);\n}\nvec4 mainImageGrid(vec2 f) {\n\tfloat rcpResY = 1./ iResolution.y;\n\tvec2 uv = 2.0* rcpResY* f- vec2(iResolution.x* rcpResY,1);\n\tvec3 ro = vec3(0,exp2(128.* (sin(iTime* .002)+ step(10.,iMouse.x)*(2.* rcpResY* iMouse.y- 1.))),0);\n\tvec3 rd = normalize(vec3(uv.x,-1,uv.y));\n\tfloat t = ro.y/ -rd.y;\n\tvec3 pos = ro+ t* rd;\n\treturn grid(f,pos,rd.y,t);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor = mainImageGrid(fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}