{
    "Shader": {
        "info": {
            "date": "1670746113",
            "description": "Wave function collapse-like shader of an abstract weave pattern. The blurry tiles show all the remaining possible matches given the existing neighbors, superimposed.\n\n*mouse camera*\n*key up/down zoom* \n*space to reset*",
            "flags": 48,
            "hasliked": 0,
            "id": "Ds2XRV",
            "likes": 17,
            "name": "Superposition Weave WFC",
            "published": 3,
            "tags": [
                "wfc",
                "wavefunctioncollapse"
            ],
            "usePreview": 1,
            "username": "fenix",
            "viewed": 313
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in my series trying to do something similar to the \"simple tiled model\" of \n//  Wave Function Collapse:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                     https://shadertoy.com/view/ds2XzD\n//      Raymarched Circuit Board WFC      https://shadertoy.com/view/mdjSDz\n//\n//  Both renderer and solver should be much more optimized in this version! On the render\n//  side, I converted to a traditional sprite drawing method following 4rknova's\n//\n//      Sprite Encoding Tutorial          https://www.shadertoy.com/view/XtlGzN\n//\n//  This allows the rendering of the \"superposition\" tiles, which show all the remaining\n//  tile choices for that square, superimposed. On the down side I lost smooth zooming and\n//  scrolling. You can still zoom by powers of 2 using the up and down arrow keys,\n//  which I tried to make less jarring with a fade transition.\n//\n//  The solver now computes and records the remaining possible values for each square,\n//  which is like the \"entropy\" of the original WFC, I think. Actual tile placement choices\n//  are not that different from before, but they no longer use arrays, compressing the\n//  data into bitfields in uvec4s instead. Array usage was also removed from all tile\n//  shape and rendering lookups which was a huge speedup.\n//\n//  Note that none of my WFC shaders are true implementations of Wave Function Collapse.\n//  My excuse is that some of the steps in the the original version, such as serially\n//  collapsing tiles in order of \"minimal nonzero entropy\", are not practial on shadertoy,\n//  and my shaders are attempting to emulate the functionality within the constraints\n//  given. Specifically, I feel like the relaxation that is done inside of \"real\" WFC is\n//  comparable in some way to the random backtracking walks.\n//\n//  But, this new shader, which tracks the \"entropy\" in Buffer A, I feel gets a bit closer\n//  than the previous ones. I was particularly trying to get a similar effect as you see\n//  in the original WFC videos where the tiles get less blurry as they collapse. It mostly\n//  works, but clearly I'm still getting much less efficient transfer of entropy across\n//  tiles. I did some experiments trying to look at neighboring tiles that had not fully,\n//  collapsed yet, but it was really slow and didn't seem to help convergence much. But\n//  maybe I just need to try harder.\n//  \n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// color palette\nvec3 subtileColor(uint value)\n{\n    if (value == 0u) return vec3(.25,.3,.25);\n    if (value == 1u) return vec3(.0,.3,.2);\n    if (value == 2u) return vec3(.25,.15,.0);\n    /*if (value == 3u)*/ return vec3(.3,.0,.2);\n}\n\n// From 4rknova's Sprite Encoding Tutorial: https://www.shadertoy.com/view/XtlGzN\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n#define START vec2 gv = floor(p); int y=int(7.-gv.y);float m=0.\n#define END return subtileColor(uint(mod(m/pow(4.,gv.x),4.)))\n\n// cell sprites\nvec3 spEmpty(vec2 p)\n{\n    return subtileColor(0u);\n}\n\nvec3 spOpen(vec2 p)\n{\n    return subtileColor(0u);\n}\n\nvec3 spAS(vec2 p)\n{\n    START;\n    Q(0, _,B,A,A,A,A,B,_)\n    Q(1, _,B,A,A,A,A,B,_)\n    Q(2, _,B,A,A,A,A,B,_)\n    Q(3, _,B,A,A,A,A,B,_)\n    Q(4, _,B,A,A,A,A,B,_)\n    Q(5, _,B,A,A,A,A,B,_)\n    Q(6, _,B,A,A,A,A,B,_)\n    Q(7, _,B,A,A,A,A,B,_)\n    END;\n}\n\nvec3 spAC(vec2 p)\n{\n    START;\n    Q(0, _,B,A,A,A,A,B,_)\n    Q(1, _,B,A,A,A,A,A,B)\n    Q(2, _,B,A,A,A,A,A,A)\n    Q(3, _,B,A,A,A,A,A,A)\n    Q(4, _,_,B,A,A,A,A,A)\n    Q(5, _,_,_,B,A,A,A,A)\n    Q(6, _,_,_,_,B,B,B,B)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spAE(vec2 p)\n{\n    START;\n    Q(0, _,_,B,B,B,B,_,_)\n    Q(1, _,B,A,A,A,A,B,_)\n    Q(2, _,B,A,B,B,A,B,_)\n    Q(3, _,B,A,B,B,A,B,_)\n    Q(4, _,B,A,A,A,A,B,_)\n    Q(5, _,_,B,B,B,B,_,_)\n    Q(6, _,_,_,_,_,_,_,_)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spBS(vec2 p)\n{\n    START;\n    Q(0, _,C,B,B,B,B,C,_)\n    Q(1, _,C,B,B,B,B,C,_)\n    Q(2, _,C,B,B,B,B,C,_)\n    Q(3, _,C,B,B,B,B,C,_)\n    Q(4, _,C,B,B,B,B,C,_)\n    Q(5, _,C,B,B,B,B,C,_)\n    Q(6, _,C,B,B,B,B,C,_)\n    Q(7, _,C,B,B,B,B,C,_)\n    END;\n}\n\nvec3 spBC(vec2 p)\n{\n    START;\n    Q(0, _,C,B,B,B,B,C,_)\n    Q(1, _,C,B,B,B,B,B,C)\n    Q(2, _,C,B,B,B,B,B,B)\n    Q(3, _,C,B,B,B,B,B,B)\n    Q(4, _,_,C,B,B,B,B,B)\n    Q(5, _,_,_,C,B,B,B,B)\n    Q(6, _,_,_,_,C,C,C,C)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spBE(vec2 p)\n{\n    START;\n    Q(0, _,_,C,C,C,C,_,_)\n    Q(1, _,C,B,B,B,B,C,_)\n    Q(2, _,C,B,C,C,B,C,_)\n    Q(3, _,C,B,C,C,B,C,_)\n    Q(4, _,C,B,B,B,B,C,_)\n    Q(5, _,_,C,C,C,C,_,_)\n    Q(6, _,_,_,_,_,_,_,_)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spCS(vec2 p)\n{\n    START;\n    Q(0, _,A,C,C,C,C,A,_)\n    Q(1, _,A,C,C,C,C,A,_)\n    Q(2, _,A,C,C,C,C,A,_)\n    Q(3, _,A,C,C,C,C,A,_)\n    Q(4, _,A,C,C,C,C,A,_)\n    Q(5, _,A,C,C,C,C,A,_)\n    Q(6, _,A,C,C,C,C,A,_)\n    Q(7, _,A,C,C,C,C,A,_)\n    END;\n}\n\nvec3 spCC(vec2 p)\n{\n    START;\n    Q(0, _,A,C,C,C,C,A,_)\n    Q(1, _,A,C,C,C,C,C,A)\n    Q(2, _,A,C,C,C,C,C,C)\n    Q(3, _,A,C,C,C,C,C,C)\n    Q(4, _,_,A,C,C,C,C,C)\n    Q(5, _,_,_,A,C,C,C,C)\n    Q(6, _,_,_,_,A,A,A,A)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spCE(vec2 p)\n{\n    START;\n    Q(0, _,_,A,A,A,A,_,_)\n    Q(1, _,A,C,C,C,C,A,_)\n    Q(2, _,A,C,A,A,C,A,_)\n    Q(3, _,A,C,A,A,C,A,_)\n    Q(4, _,A,C,C,C,C,A,_)\n    Q(5, _,_,A,A,A,A,_,_)\n    Q(6, _,_,_,_,_,_,_,_)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spAxB(vec2 p)\n{\n    START;\n    Q(0, _,B,A,A,A,A,B,_)\n    Q(1, _,B,A,A,A,A,B,_)\n    Q(2, C,B,A,A,A,A,B,C)\n    Q(3, B,B,A,A,A,A,B,B)\n    Q(4, B,B,A,A,A,A,B,B)\n    Q(5, C,B,A,A,A,A,B,C)\n    Q(6, _,B,A,A,A,A,B,_)\n    Q(7, _,B,A,A,A,A,B,_)\n    END;\n}\n\nvec3 spBxC(vec2 p)\n{\n    START;\n    Q(0, _,C,B,B,B,B,C,_)\n    Q(1, _,C,B,B,B,B,C,_)\n    Q(2, A,C,B,B,B,B,C,A)\n    Q(3, C,C,B,B,B,B,C,C)\n    Q(4, C,C,B,B,B,B,C,C)\n    Q(5, A,C,B,B,B,B,C,A)\n    Q(6, _,C,B,B,B,B,C,_)\n    Q(7, _,C,B,B,B,B,C,_)\n    END;\n}\n\nvec3 spCxA(vec2 p)\n{\n    START;\n    Q(0, _,A,C,C,C,C,A,_)\n    Q(1, _,A,C,C,C,C,A,_)\n    Q(2, B,A,C,C,C,C,A,B)\n    Q(3, A,A,C,C,C,C,A,A)\n    Q(4, A,A,C,C,C,C,A,A)\n    Q(5, B,A,C,C,C,C,A,B)\n    Q(6, _,A,C,C,C,C,A,_)\n    Q(7, _,A,C,C,C,C,A,_)\n    END;\n}\n\nvec3 spCell(vec2 p, int type)\n{\n    if (type == EMPTY) return spEmpty(p);\n    if (type == OPEN)  return spOpen(p);\n    if (type == AS)    return spAS(p);\n    if (type == AC)    return spAC(p);\n    if (type == AE)    return spAE(p);\n    if (type == BS)    return spBS(p);\n    if (type == BC)    return spBC(p);\n    if (type == BE)    return spBE(p);\n    if (type == CS)    return spCS(p);\n    if (type == CC)    return spCC(p);\n    if (type == CE)    return spCE(p);\n    if (type == AxB)   return spAxB(p);\n    if (type == BxC)   return spBxC(p);\n    /*if (type == CxA)*/ return spCxA(p);\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\nvec4 render( vec2 u, fxState state, float zoom )\n{\n    u = (u - .5 * iResolution.xy) * zoom + state.center * iResolution.y + .5 * iResolution.xy;\n    vec2 p = fract(u) * 8.;\n    \n    if (u.x < 1. ||\n        u.x >= iResolution.x - 1. ||\n        u.y < 1. ||\n        u.y >= iResolution.y - 1.) return vec4(subtileColor(0u), 1);\n\n    uvec4 valid = floatBitsToUint(texelFetch(iChannel0, ivec2(u), 0));\n    if (valid == uvec4(0)) return vec4(subtileColor(0u), 1);\n    \n    vec4 c = vec4(0);\n    for (int rot = 0; DONT_UNROLL && rot < 4; ++rot)\n    {\n        uint bit = 1u;\n        for (int type = 0; DONT_UNROLL && type < NUM_TILES; ++type)\n        {\n            if ((valid[rot] & bit) != 0u)\n            {\n                c += vec4(spCell(rot90(p,rot), type), 1);\n            }\n            bit <<= 1;\n        }\n    }\n\n    return c / c.a;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState state = fxGetState();\n    if (state.zoomFade > 0.)\n    {\n        vec4 c = render(u, state, state.zoom);\n        vec4 n = render(u, state, state.nextZoom);\n        O = mix(n, c, state.zoomFade);\n    }\n    else\n        O = render(u, state, state.zoom);\n        \n    O = sqrt(O);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\nconst int EMPTY = 0;\nconst int OPEN = 1;\nconst int AS = 2;\nconst int AC = 3;\nconst int AE = 4;\nconst int BS = 5;\nconst int BC = 6;\nconst int BE = 7;\nconst int CS = 8;\nconst int CC = 9;\nconst int CE = 10;\nconst int AxB = 11;\nconst int BxC = 12;\nconst int CxA = 13;\nconst int NUM_TILES = 14;\n\n#define _ 0. // Color Palette Index 0\n#define A 1. // Color Palette Index 1\n#define B 2. // Color Palette Index 2\n#define C 3. // Color Palette Index 3\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    vec2 center;\n    float resolution;\n    float zoom;\n    float nextZoom;\n    float zoomFade;\n    float time;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.center = data0.xy;\n    state.resolution = data0.z;\n    state.attract = data0.w != 0.;\n    state.zoom = data1.x;\n    state.time = data1.y;\n    state.nextZoom = data1.z;\n    state.zoomFade = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.center, state.resolution, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.zoom, state.time, state.nextZoom, state.zoomFade);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(_,_,_,\n         _,_,_,\n         _,_,_);\n         \nconst mat3 S_OPEN =\n    mat3(_,_,_,\n         _,_,_,\n         _,_,_);\n         \nconst mat3 S_AS =\n    mat3(_,A,_,\n         _,A,_,\n         _,A,_);\n                \nconst mat3 S_AC =\n    mat3(_,A,_,\n         _,A,A,\n         _,_,_);\n               \nconst mat3 S_AE =\n    mat3(_,A,_,\n         _,A,_,\n         _,_,_);\n               \nconst mat3 S_BS =\n    mat3(_,B,_,\n         _,B,_,\n         _,B,_);\n                \nconst mat3 S_BC =\n    mat3(_,B,_,\n         _,B,B,\n         _,_,_);\n                \nconst mat3 S_BE =\n    mat3(_,B,_,\n         _,B,_,\n         _,_,_);\n                \nconst mat3 S_CS =\n    mat3(_,C,_,\n         _,C,_,\n         _,C,_);\n                \nconst mat3 S_CC =\n    mat3(_,C,_,\n         _,C,C,\n         _,_,_);\n                \nconst mat3 S_CE =\n    mat3(_,C,_,\n         _,C,_,\n         _,_,_);\n                \nconst mat3 S_AxB =\n    mat3(_,A,_,\n         B,A,B,\n         _,A,_);\n                \nconst mat3 S_BxC =\n    mat3(_,B,_,\n         C,B,C,\n         _,B,_);\n                \nconst mat3 S_CxA =\n    mat3(_,C,_,\n         A,C,A,\n         _,C,_);\n                                \nmat3 shCell(int type)\n{\n    if (type == EMPTY) return S_EMPTY;\n    if (type == OPEN)  return S_OPEN;\n    if (type == AS)    return S_AS;\n    if (type == AC)    return S_AC;\n    if (type == AE)    return S_AE;\n    if (type == BS)    return S_BS;\n    if (type == BC)    return S_BC;\n    if (type == BE)    return S_BE;\n    if (type == CS)    return S_CS;\n    if (type == CC)    return S_CC;\n    if (type == CE)    return S_CE;\n    if (type == AxB)   return S_AxB;\n    if (type == BxC)   return S_BxC;\n    /*if (type == CxA)*/ return S_CxA;\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY) return 0.;\n    if (type == OPEN)  return 1.;\n    if (type == AS)    return .7;\n    if (type == AC)    return .2;\n    if (type == AE)    return .05;\n    if (type == BS)    return .7;\n    if (type == BC)    return .2;\n    if (type == BE)    return .05;\n    if (type == CS)    return .7;\n    if (type == CC)    return .2;\n    if (type == CE)    return .05;\n    if (type == AxB)   return 1.;\n    if (type == BxC)   return 1.;\n    /*if (type == CxA)*/ return 1.;\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == OPEN || type == AS || type == BS || type == CS;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 1u;\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            for (int d = 0; d < 4; ++d)\n            {\n                if (tilesMatch(rotShape(myShape, d), nShape))\n                {\n                    valid[(d + 4 - r) % 4] |= bit;\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, -1);\n    /*if (d == 0)*/ return ivec2(-1, 0);\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 ||\n        state.resolution < 0. ||\n        ifc.x == 0 || // establish boundary so we don't have to check during simulation\n        ifc.x == int(iResolution.x) - 1 ||\n        ifc.y == 0 ||\n        ifc.y == int(iResolution.y) - 1)\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.280, .652))) fragColor = ubtf(uvec4(2, 0, 0, 0));\n        \n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n    \n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-6)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    const float START_ZOOM = 1./128.;\n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.center = vec2(0);\n        state.resolution = -iResolution.x * iResolution.y;\n        state.nextZoom = state.zoom = START_ZOOM;\n        state.time = 0.;\n        state.zoomFade = 0.;\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        state.time += iTimeDelta;\n        if (state.zoomFade > 0.)\n        {\n            state.zoomFade -= iTimeDelta;\n            if (state.zoomFade < 0.)\n            {\n                state.zoomFade = 0.;\n                state.zoom = state.nextZoom;\n            }\n        }\n        \n        if (iMouse.z > 0.)\n        {\n            state.attract = false;\n            state.center = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n        }\n        \n        if (keyClick(KEY_UP))\n        {\n            state.nextZoom = min(state.nextZoom, state.zoom) * .5;\n            state.zoomFade = 1.;\n            state.attract = false;\n        }\n        if (keyClick(KEY_DOWN))\n        {\n            state.nextZoom = max(state.nextZoom, state.zoom) * 2.;\n            state.nextZoom = min(1., state.nextZoom);\n            state.zoomFade = 1.;\n            state.attract = false;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(state.time*.005 - 1.2), cos(state.time*.005 - 1.2));\n            float zoom = pow(.5, floor(5. - mod(state.time / 4., 5.))) * 16. * START_ZOOM;\n            if (zoom != state.zoom && zoom != state.nextZoom)\n            {\n                state.nextZoom = zoom;\n                state.zoomFade = 1.;\n            }\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}