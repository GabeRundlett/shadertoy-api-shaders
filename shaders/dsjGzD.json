{
    "Shader": {
        "info": {
            "date": "1667337436",
            "description": "von Koch, relying on  stack + short cuts mla's L-System engine, but giving series of float lengthes and angles.\n\nKochawave  reference:  [url]  https://twitter.com/sfera314/status/1587348448205996032 [/url]\n[url] https://arxiv.org/pdf/2210.17320.pdf [/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "dsjGzD",
            "likes": 16,
            "name": "von Kochawave to von Koch - adap",
            "published": 3,
            "tags": [
                "optimized",
                "lsystem",
                "stack",
                "koch",
                "gosper"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// Adaptive variant of https://shadertoy.com/view/Dsj3zD\n// Refactored fork of \"Koch Snowflake Optimized\" by mla. https://shadertoy.com/view/csX3Rs\n// ( Uses an explicit stack to keep track of the recursion + short-cuts to draw only what's necessary )\n// I replace program symbols by true segments lengthes and angles.\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0., 1.);\n  return length(p-b*h);\n}\n\nvec2 p = vec2(0);     // The drawing point\n\nfloat drawsegment(vec2 U, float seglen, float a) {\n  vec2 seg = seglen*vec2(cos(a),sin(a)),\n         q = p + seg;\n  float  d = segment(U,p,q);\n  p = q;\n  return d;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    float END = -1., factor = 3.,    // scaling factor betweel levels\n#if 0                   // von Koch snowflakes: F â†’ F+F--F+F\n    program[] = float[] (0.,1., 1.05,1., -2.1,1., 1.05,1., 0.,END);// (angle, length)\n#elif 0                 // Kochawave\n    program[] = float[] (0.,1., .524,1.732, -2.62,1., 2.1,1., 0.,END);\n#else                   // interpolation\n    X = 1.-.5*cos(iTime), S = .866,             // von Koch to Kochawave\n // X = .5 - cos(iTime) , S = .866,             // left to right Kochawave\n    program[] = float[] ( 0., 1.,               // (angle, length)\n                          atan(S,X), sqrt(S*S+X*X), \n                          atan(X,S)-atan(X-1.,S)-3.14, sqrt(S*S+(X-1.)*(X-1.)), \n                          atan(X-1.,S)+1.57,1., \n                          0., END );\n#endif \n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y + vec2(1.5,.8);\n    const int maxdepth = 10;\n    int stack[maxdepth+1], depth = -1;     // stack: pos in program + seg length\n    float lens[6];\n    stack[++depth] = 0; lens[depth] = 1.;\n    float d = 1e8, seglen = 1., theta = 0.;     // Cumulative angle\n    \n    while (depth >= 0) {\n        float len = program[2*stack[depth] +1]; // len\n        theta +=    program[2*stack[depth]++];  // turns\n        if (len == END)\n            seglen = lens[depth--];             // Terminate level\n        else   \n        if (depth == maxdepth || seglen < 3./R.y )  \n              d = min(d,drawsegment(U,seglen*len,theta)); // Draw segment\n        else {\n          vec2 seg = seglen*len*vec2(cos(theta),sin(theta));\n          if (distance(U,p+.5*seg) > .5*length(seg))\n              p += seg;                         // skip unseen segments\n          else\n              stack[++depth]=0, lens[depth]=seglen, seglen *= len/factor; // Recurse\n        }\n    }\n    O =  vec4(smoothstep(0.,2./R.y,d));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}