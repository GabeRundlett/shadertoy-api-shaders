{
    "Shader": {
        "info": {
            "date": "1430809288",
            "description": "ZX Spectrum loading intro for SHADERTOY 128K",
            "flags": 8,
            "hasliked": 0,
            "id": "XlBGz3",
            "likes": 151,
            "name": "SHTOY128",
            "published": 3,
            "tags": [
                "retro",
                "spectrum",
                "music",
                "chiptune"
            ],
            "usePreview": 0,
            "username": "and",
            "viewed": 7347
        },
        "renderpass": [
            {
                "code": "// SHTOY128 - image (ZX-Spectrum's loader simulator)\n// Created by Dmitry Andreev - and'2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define REFRESH_RATE_HZ (60.0)\n#define SHOW_DEBUG_GRID (0)\n#define DO_POSTPROCESS  (1)\n\n// System font (vec2 per character)\nhighp vec4 fnt0  = vec4(0,0,544926,544959);\nhighp vec4 fnt1  = vec4(512159,512161,20638,495745);\nhighp vec4 fnt2  = vec4(542863,247969,508095,1032321);\nhighp vec4 fnt3  = vec4(508095,16513,20638,495801);\nhighp vec4 fnt4  = vec4(1036449,544929,132158,1016840);\nhighp vec4 fnt5  = vec4(528416,495777,115857,542857);\nhighp vec4 fnt6  = vec4(16513,1032321,743841,544929);\nhighp vec4 fnt7  = vec4(610721,546985,544926,495777);\nhighp vec4 fnt8  = vec4(544927,16543,544926,496805);\nhighp vec4 fnt9  = vec4(544927,542879,491678,495776);\nhighp vec4 fnt10 = vec4(132223,132104,544929,495777);\nhighp vec4 fnt11 = vec4(544929,198945,544929,300705);\nhighp vec4 fnt12 = vec4(198945,542988,332097,132104);\nhighp vec4 fnt13 = vec4(133183,1032452,132364,1016840);\nhighp vec4 fnt14 = vec4(528542,1032350,397470,495776);\nhighp vec4 fnt15 = vec4(165384,139145,508095,495776);\nhighp vec4 fnt16 = vec4(508062,495777,266303,66056);\nhighp vec4 fnt17 = vec4(495774,495777,544926,495678);\nhighp vec4 fnt18 = vec4(678046,496037,0,198144);\nhighp vec4 fnt19 = vec4(0,66568,0,62);\n\n// Running text message (4 characters per float 4e+20m bits )\nhighp vec4 ch0  = vec4(0.69592524,2.03179932,290.34887695,1.00491428);\nhighp vec4 ch1  = vec4(4.01292801,0.54080963,0.69718361,0.50930023);\nhighp vec4 ch2  = vec4(1.12532902,1.00050831,0.60941935,4.58217621);\nhighp vec4 ch3  = vec4(4.43760300,0.64064074,5.18755722,0.60224342);\nhighp vec4 ch4  = vec4(1.00491428,2.01124001,10.50029755,1.00374699);\nhighp vec4 ch5  = vec4(0.64514160,8.15248871,0.61795807,9.16210938);\nhighp vec4 ch6  = vec4(1.28499222,0.50247002,10.03533173,0.54080963);\nhighp vec4 ch7  = vec4(42.11721802,9.91603851,1.12526035,41.15811157);\nhighp vec4 ch8  = vec4(8.01219177,257.64916992,0.65040159,5.26790237);\nhighp vec4 ch9  = vec4(128.85766602,0.58601189,0.65723610,16.52069092);\nhighp vec4 ch10 = vec4(0.50422573,4.58203506,2.03277779,1.21997166);\nhighp vec4 ch11 = vec4(0.67251968,0.52564478,336.31665039,4.00032806);\nhighp vec4 ch12 = vec4(9.50981903,2.25015259,4.31275558,0.68033218);\nhighp vec4 ch13 = vec4(0.61792088,2.37568855,1.22046089,0.51016998);\nhighp vec4 ch14 = vec4(0.73113823,0.60258865,269.02099609,128.85766602);\nhighp vec4 ch15 = vec4(1.17193413,4.01759720,1.00029755,0.50354147);\nhighp vec4 ch16 = vec4(4.50119781,8.64846039,1.31379032,4.93780136);\nhighp vec4 ch17 = vec4(340.87915039,4.00032806,9.50981903,4.50039291);\nhighp vec4 ch18 = vec4(0.66626120,20.51959229,18.33648682,0.69982910);\nhighp vec4 ch19 = vec4(4.18865967,1.00491428,4.01399612,0.51626968);\nhighp vec4 ch20 = vec4(9.90236664,1.05128956,4.87522507,5.43752289);\nhighp vec4 ch21 = vec4(8.50047302,0.53189468,11.15495300,1.00520039);\nhighp vec4 ch22 = vec4(5.14355850,0.50956202,4.75010300,5.12523651);\nhighp vec4 ch23 = vec4(152.78161621,406.22192383,16.00050354,0.64286995);\nhighp vec4 ch24 = vec4(0.50952911,9.00244141,5.56255722,1.06475353);\nhighp vec4 ch25 = vec4(0.78906345,0.69599342,0.50000000,0.50000000);\n\nvec2 fetchChrBitmap(float fi)\n{\n    int i = int(fi);\n    int j = i / 2;\n    int k = i - j * 2;\n    \n    vec4 b = fnt0;\n    #define F(x,y) b = j == x ? y : b;\n    F(1,fnt1)F(2,fnt2)F(3,fnt3)F(4,fnt4)F(5,fnt5)F(6,fnt6)F(7,fnt7)F(8,fnt8)\n    F(9,fnt9)F(10,fnt10)F(11,fnt11)F(12,fnt12)F(13,fnt13)F(14,fnt14)F(15,fnt15)\n    F(16,fnt16)F(17,fnt17)F(18,fnt18)F(19,fnt19);\n    #undef F\n\n    return (k == 0 ? b.xy : b.zw) + 0.5;\n}\n\nint fetchRunningChar(int pos)\n{\n    int e = pos / 16;\n    int e2 = pos - (pos / 16) * 16;\n    int e3 = e2 / 4;\n    int e4 = pos - (pos / 4) * 4;\n    \n    vec4 ch = ch0;\n    #define C(x,y) ch = e == x ? y : ch;\n    C(1,ch1)C(2,ch2)C(3,ch3)C(4,ch4)C(5,ch5)C(6,ch6)C(7,ch7)C(8,ch8)\n    C(9,ch9)C(10,ch10)C(11,ch11)C(12,ch12)C(13,ch13)C(14,ch14)C(15,ch15)\n    C(16,ch16)C(17,ch17)C(18,ch18)C(19,ch19)C(20,ch20)C(21,ch21)C(22,ch22)\n    C(23,ch23)C(24,ch24)C(25,ch25)\n    #undef C\n\n    float f = ch.x;\n    f = e3 == 1 ? ch.y : f;\n    f = e3 == 2 ? ch.z : f;\n    f = e3 == 3 ? ch.w : f;\n    \n    float f3 = ceil(log2(f));\n    f /= exp2(f3);\n    f3 *= 4.0;\n    \n    f = f * 2.0 - 1.0;\n    \n    f *= 64.0;\n    float ff = floor(f);\n    float f0 = ff;\n    f -= ff;\n    \n    f *= 64.0;\n    float f1 = floor(f);\n    f -= f1;\n\n    f *= 64.0;\n    float f2 = floor(f);\n    f -= f2;\n    \n    f3 += floor(f * 4.0);\n    \n    int c = int(f0);\n    c = e4 == 1 ? int(f1) : c;\n    c = e4 == 2 ? int(f2) : c;\n    c = e4 == 3 ? int(f3) : c;\n\n    return pos < 0 ? 0 : c;\n}\n\nbool fetchBit(vec2 bitmap, float x, float y)\n{\n    float bits = y < 3.0 ? bitmap.y : bitmap.x;\n    float index = float(x + 7.0 * (2.0 - ( y < 3.0 ? y : y - 3.0 )));\n    float v = floor(bits * exp2(-index));\n    v = x > 6.0 || y > 5.0 || x < 0.0 || y < 0.0 ? 0.0 : v;\n    \n    return floor(v * 0.5) * 2.0 != v;\n}\n\nbool fetchBoldBit(vec2 bitmap, float x, float y)\n{\n    bool bit = fetchBit(bitmap, x, y);\n\n    bit = bit || fetchBit(bitmap, x - 1.0, y);\n\n    if (y < 4.0 && x < 6.0)\n    {\n        bit = bit || fetchBit(bitmap, x - 2.0, y);\n    }\n    \n    return bit;\n}\n\nvec3 getColor(int idx)\n{\n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    \n    idx = idx - (idx / 16) * 16;\n    int i = idx - (idx / 8) * 8;\n    \n    clr = i == 1 ? vec3(0, 0, 1) : clr;\n    clr = i == 2 ? vec3(1, 0, 0) : clr;\n    clr = i == 3 ? vec3(1, 0, 1) : clr;\n    clr = i == 4 ? vec3(0, 1, 0) : clr;\n    clr = i == 5 ? vec3(0, 1, 1) : clr;\n    clr = i == 6 ? vec3(1, 1, 0) : clr;\n    clr = i == 7 ? vec3(1, 1, 1) : clr;\n    \n    clr *= idx >= 8 ? 1.0 : 0.63;\n    \n    return clr;\n}\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(vec2(p.y, p.x), p + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    t = mod(t, 90.0);\n\n    float aspect = 256.0 / 192.0;\n    float s = min(iResolution.x, iResolution.y);\n    s *= min(1.0, (iResolution.x / s) / aspect);\n    float s2 = 1.2;\n    s *= s2;\n    vec2 uv = (fragCoord.xy + 0.0001) / s;\n    vec2 uvc = 0.5 * iResolution.xy / s;\n    \n    bool show_loader =  1.0 < t && t <= 59.0;\n    bool show_editor = 59.3 < t;\n    bool phase = fract(t * REFRESH_RATE_HZ * 0.5) > 0.5;\n    \n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    \n    int border = 0;\n    int scr = 0;\n    int bkg = 0;\n    int attr = 0;\n    bool flash_phase = fract(t * 1.55) > 0.5;\n    \n    if (!show_loader)\n    {\n        scr = 0;\n        bkg = 7;\n        attr = 0;\n        border = 7;\n        \n        if (t <= 1.0)\n        {\n            if (t > 0.8 ) attr = 0, bkg = 0;\n            if (t > 0.85) border = 0;\n        }\n        \n        if (t >= 59.0 && t < 59.3)\n        {\n            bkg = 0;\n        }\n    }\n    \n    float at = floor(t * 11.1 + 0.35);\n    \n    vec2 p = uv - uvc;\n    vec2 q = floor(p * 32.0 * 8.0) / 8.0;\n    p = floor(p * 32.0);\n    p += vec2(16.0, 12.0);\n    q += vec2(16.0, 12.0);\n    \n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec2 oq = q;\n\n    #define X(sym) h = floor(q.x) == cx ? vec3(sym,q.xy) : h; cx += 1.0;\n\n    float cx = 0.0;\n        \n    // ANDSOFT\n    {\n        bool hit = q.y >= 21.5 && q.y < 23.5;\n\n        vec2 p = uv - uvc;\n        vec2 q = floor(p * 16.0 * 8.0 + vec2(-4.0, 2.0)) / 8.0;\n        q += vec2(16.0, 12.0);\n\n        vec3 h = vec3(0.0, 0.0, 0.0);\n        cx = 12.0;\n        X(1)X(14)X(4)X(19)X(15)X(6)X(20)\n        int _attr = int(mod(-at, 8.0));\n\n        c = hit ? h : c;\n        attr = hit ? _attr : attr;\n    }\n\n    // PRESENTS\n    {\n        bool hit = floor(q.y) == 20.0;\n\n        vec3 h = vec3(0.0, 0.0, 0.0);\n        cx = 12.0;\n        X(16)X(18)X(5)X(19)X(5)X(14)X(20)X(19)\n        int _attr = int(mod(abs(floor(q.x) - 15.5) - at + 3.0, 8.0));\n\n        c = hit ? h : c;\n        attr = hit ? _attr : attr;\n    }\n\n    // SHADERTOY\n    {\n        bool hit = q.y > 16.0 && q.y < 20.0;\n\n        vec2 p = uv - uvc;\n        vec2 q = floor(p * vec2(12.0, 8.0) * 8.0 + vec2(4.0, 0.0)) / 8.0;\n        q += vec2(16.0, 12.0);\n        q = floor(q * 8.0) / 8.0;\n\n        vec3 h = vec3(0.0, 0.0, 0.0);\n        cx = 12.0;\n        X(19)X(8)X(1)X(4)X(5)X(18)X(20)X(15)X(25)\n        int _attr = int(mod(abs(floor(oq.y) - 15.5) - at, 8.0));\n        \n        c = hit ? h : c;\n        attr = hit ? _attr : attr;\n    }\n\n    // 128K\n    {\n        bool hit = floor(q.y) == 15.0;\n\n        vec2 p = uv - uvc;\n        vec2 q = floor(p * vec2(16.0, 32.0) * 8.0) / 8.0;\n        q += vec2(16.0, 12.0);\n\n        vec3 h = vec3(0.0, 0.0, 0.0);\n        cx = 14.0;\n        X(27)X(28)X(34)X(11)\n        int _attr = int(mod(abs(floor(oq.x * 0.5 + 0.5) - 8.0) + at, 8.0));\n\n        c = hit ? h : c;\n        attr = hit ? _attr : attr;\n    }\n\n    vec2 q_msg = vec2(16.0, 12.0) + floor((uv - uvc) * 32.0 * 8.0 + vec2(0.0, 4.0)) / 8.0;\n\n    // SF, CA\n    {\n        bool hit = q.y >= 13.5 && q.y < 14.5;\n\n        vec2 q = q_msg;\n        vec3 h = vec3(0.0, 0.0, 0.0);\n        cx = 0.0;\n        X(19)X(1)X(14)\n        cx += 1.0;\n        X(6)X(18)X(1)X(14)X(3)X(9)X(19)X(3)X(15)X(38)X(3)X(1)\n        cx += 2.0;\n        X(27)X(39)X(34)X(36)X(36)X(39)X(31)X(31)X(31)X(39)X(36)X(27)X(35)X(35)\n\n        c = hit ? h : c;\n    }\n\n    // LOADER\n    {\n        bool hit = q.y >= 12.5 && q.y < 13.5;\n\n        vec2 q = q_msg;\n        vec3 h = vec3(0.0, 0.0, 0.0);\n        cx = 2.0;\n        X(12)X(15)X(1)X(4)X(5)X(18)\n        cx += 1.0;\n        X(2)X(25)\n        cx += 1.0;\n        X(1)X(14)X(4)X(19)X(15)X(6)X(20)\n        cx += 1.0;\n        X(36)X(31)X(37)X(36)X(31)X(37)X(28)X(36)X(27)X(31)\n\n        c = hit ? h : c;\n    }\n\n    attr = floor(q.y) == 12.0 ? int(mod(floor(q.x) + at + 3.0, 8.0)) : attr;\n    attr = floor(q.y) == 13.0 ? int(mod(floor(q.x) - at + 3.0, 8.0)) : attr;\n    attr = floor(q.y) == 14.0 ? int(mod(floor(q.x) + at, 8.0)) : attr;\n\n    if (!show_loader)\n    {\n        c = vec3(0.0, 0.0, 0.0);\n    }\n\n    if (show_editor)\n    {\n        attr = 7;\n\n        if (t > 59.8 && floor(q.x) == 0.0 && floor(q.y) == 23.0)\n        {\n            bkg = flash_phase ? 15 : 9;\n        }\n        \n        if (floor(q.y) == 2.0)\n        {\n            vec3 h = vec3(0.0, 0.0, 0.0);\n            cx = 0.0;\n            X(27)X(28)X(34)\n            cx += 1.0;\n            X(19)X(8)X(1)X(4)X(5)X(18)X(20)X(15)X(25)\n        \n            c = h;\n            attr = 15;\n            bkg = 0;\n\n            // Rainbow\n            vec2 q = floor(oq);\n\n            if (26.0 <= q.x && q.x <= 30.0)\n            {\n                scr = fract(oq.x) >= fract(oq.y) ? 1 : 0;\n            }\n            \n            if (q.x == 26.0) attr = 10;\n            if (q.x == 27.0) bkg = 10, attr = 14;\n            if (q.x == 28.0) bkg = 14, attr = 12;\n            if (q.x == 29.0) bkg = 12, attr = 13;\n            if (q.x == 30.0) bkg = 13, attr = 0;\n        }\n    }\n\n    if (show_loader && q.y >= 8.0 && q.y < 12.0)\n    {\n        float xt = floor(at * 0.35);\n        float fxt = fract(at * 0.35);\n\n        float px = floor(q.x * 2.0);\n\n        float fc = noise(px + xt * 32.0).x * 0.5 + 0.5;\n        float fl = noise(px - 1.0 + xt * 32.0).x * 0.5 + 0.5;\n        float fr = noise(px + 1.0 + xt * 32.0).x * 0.5 + 0.5;\n        float fc2= noise(px + (xt + 1.0) * 32.0).x * 0.5 + 0.5;\n        float fl2= noise(px - 1.0 + (xt + 1.0) * 32.0).x * 0.5 + 0.5;\n        float fr2= noise(px + 1.0 + (xt + 1.0) * 32.0).x * 0.5 + 0.5;\n\n        fc = mix(fc, fc2, fxt);\n        fl = mix(fl, fl2, fxt);\n        fr = mix(fr, fr2, fxt);\n\n        fc = sin(fc * 1.5) * 3.0 - 1.8;\n        fl = sin(fl * 1.5) * 3.0 - 1.8;\n        fr = sin(fr * 1.5) * 3.0 - 1.8;\n\n        float y = (q.y - 8.0) / (12.0 - 8.0);\n        float f = (2.0 * fc + fl + fr) * 0.25;\n        y = floor(y * 8.0) / 8.0;\n\n        bool mask = fract(q.x * 2.0 + 0.25) > 0.125;\n        mask = mask && fract(q.y * 2.0 + 0.125) >= 0.25;\n\n        if ( f > y && mask ) scr = 1;\n\n        attr = int(mod(abs(floor(oq.y) - 15.5) + at * 1.0 + 3.0, 8.0));\n    }\n\n    bool show_running_message = show_loader && p.x >= 0.0 && p.x < 32.0 && p.y >= 0.0 && p.y < 8.0;\n\n    float rl_px = 0.0;\n    float rl_px2 = 0.0;\n\n    if (show_running_message)\n    {\n        vec2 m = floor(fract(oq) * 8.0);\n\n        if (phase)\n            scr = int(m.x == 0.0 || m.x == 7.0 || m.y == 0.0 || m.y == 7.0);\n        else\n            scr = int(m.x == 3.0 || m.x == 4.0 || m.y == 0.0 || m.y == 7.0);\n\n        // Red or blue every 10 minutes\n        attr = int(fract(iDate.w / (60.0 * 10.0)) * 2.0) + 1;\n\n        rl_px = p.x + floor(t * REFRESH_RATE_HZ) - 200.0;\n        c = vec3(fetchRunningChar(int(floor(rl_px / 8.0))), 0.0, 0.0);\n        rl_px = fract(rl_px / 8.0) * 8.0;\n        rl_px2 = fract((rl_px + 1.0) / 16.0) * 16.0;\n    }\n\n    vec2 bitmap = fetchChrBitmap(c.x);\n\n    if ( show_running_message )\n    {\n        rl_px2 -= 1.0;\n        rl_px -= 1.0;\n\n        if (fetchBit(bitmap, rl_px2, p.y)) scr = 0, attr = 0;\n        if (fetchBit(bitmap, rl_px, p.y - 1.0)) scr = 1, attr = 15;\n    }\n    else\n    {\n        if (c.x > 0.0)\n        {\n            vec2 pix = fract(c.yz + vec2(0.0, -1.0 / 8.0)) * 8.0;\n\n            if (show_loader)\n                scr = int(fetchBoldBit(bitmap, pix.x, pix.y));\n            else\n                scr = int(fetchBit(bitmap, pix.x, pix.y));\n        }\n    }\n\n    // fade-in/fade-out\n    if (show_loader)\n    {\n        float fd = clamp(t - 1.0, 0.0, 1.0);\n        fd *= clamp(58.0 - t, 0.0, 1.0);\n        attr = int(float(attr) * fd + 0.5);\n    }\n\n    // memory check\n    if (t < 0.65)\n    {\n        scr = 0;\n        attr = 2;\n        bkg = 0;\n        border = 7;\n\n        float rt = t * 14.0 - 2.0;\n        if (rt > 1.4) rt = 1.4 - (rt - 1.4) * 0.5;\n        rt *= 24.0;\n\n        float ry = mod(mod(q.y, 8.0) * 8.0, 8.0) + floor(q.y / 8.0) * 8.0;\n\n        if (fract(q.x) * 8.0 == 6.0 && ry < rt) scr = 1;\n    }\n\n    clr = getColor(scr > 0 ? attr : bkg);\n\n    #if SHOW_DEBUG_GRID\n        clr += fract(floor(q.y) * 0.5 + floor(q.x) * 0.5) > 0.0 ? 0.2 : 0.0;\n    #endif\n\n    if (p.x < 0.0 || p.x >= 32.0 || p.y < 0.0 || p.y >= 24.0) clr = getColor(border);\n\n    #if DO_POSTPROCESS\n    {\n        clr *= clr;\n        vec2 sp = (fragCoord.xy + 0.000) * 0.15 * 3.1415 * 4.0;\n        vec3 m = vec3(\n            1.0 - pow(1.0 - (sin(sp.x - 0.0) * 0.1 + 0.9), 0.75),\n            1.0 - pow(1.0 - (sin(sp.x - 2.0) * 0.1 + 0.9), 0.75),\n            1.0 - pow(1.0 - (sin(sp.x - 3.0) * 0.1 + 0.9), 0.75)\n            ) * (1.0 - pow( 1.0 - (sin(sp.y * 0.9 - 0.8) * 0.2 + 0.8), 2.0));\n\n        vec3 em = vec3(0.04, 0.3, 0.08);\n        em *= pow(max(0.0, 1.5 - 1.2 * dot(uv - uvc, uv - uvc)), 2.0) * 0.008;\n        clr += em * m;\n\n        clr = clr * (0.4 + 0.7 * m);\n\n        clr *= 1.0 + 0.015 * sin(uv.y * 4.0 + t * 33.0);\n        clr *= 1.2 - 0.4 * dot(uv - uvc, uv - uvc);\n\n        float g = 0.38;\n        clr.x = pow(clr.x, g);\n        clr.y = pow(clr.y, g);\n        clr.z = pow(clr.z, g);\n        clr = mix(clr, smoothstep(0.0, 1.0, clr), 0.5);\n    }\n    #endif\n\n    fragColor = vec4(clr, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            },
            {
                "code": "// SHTOY128 - sound (AY-3-8910/AY-3-8912/YM2149 chip simulator)\n// Created by Dmitry Andreev - and'2015\n// Original theme composed by Ed Polinski - Agent-X (1992)\n// http://zxtunes.com/author.php?id=745&play=478&ln=eng\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MASTER_VOLUME   (0.7)\n#define WARMUP_TIME     (1.0)\n#define SPEED           (37.0)\n#define INT_PER_STEP    (9.0)\n#define STEP            (INT_PER_STEP * SPEED / 60.0)\n#define DO_BANDLIMIT    (1)\n\n//\n\n#define N(s,x,p,o) n = t >= 0.0 && t < float(s) / STEP ? vec4(x,t,p,o) : n; t -= float(s) / STEP;\n#define M(x,p,o) N(1,x,p,o)\n#define R(s) N(s,0,0,0)\n\nvec4 chan_A_subpat(int i, float t)\n{\n    vec4 n = vec4(0.0, 0.0, 0.0, 0.0);\n\n    if (i == 0) {M(43,2,5)M(55,2,5)M(43,11,5)M(43,2,5)M(55,2,5)M(43,2,5)M(43,11,5)M(55,2,5)}\n    if (i == 1) {M(36,2,5)M(48,2,5)M(36,11,5)M(36,2,5)M(48,2,5)M(36,2,5)M(36,11,5)M(48,2,5)}\n    if (i == 2) {M(38,2,5)M(50,2,5)M(38,11,5)M(38,2,5)M(50,2,5)M(38,2,5)M(38,11,5)M(50,2,5)}\n\n    return n;\n}\n\nvec4 chan_C_subpat(int i, float t)\n{\n    vec4 n = vec4(0.0, 0.0, 0.0, 0.0);\n\n    if (i == 0) {M(52,15,1)M(81,7,2)M(64,16,2)M(52,15,2)M(83,7,3)M(52,15,3)M(64,16,3)M(81,7,2)}\n    if (i == 1) {M(52,15,2)M(81,7,2)M(64,16,2)M(52,15,2)M(83,7,3)M(52,15,3)M(64,16,3)M(83,7,3)}\n    if (i == 2) {M(52,15,3)M(79,7,2)M(64,16,2)M(52,15,2)M(81,7,3)M(52,15,3)M(64,16,3)M(74,7,1)}\n    if (i == 3) {M(52,15,1)M(74,7,1)M(64,16,1)M(52,15,1)M(76,7,3)M(52,15,3)M(64,16,3)M(74,7,1)}\n\n    return n;\n}\n\nvec4 chan_B_subpat(int i, float t)\n{\n    vec4 n = vec4(0.0, 0.0, 0.0, 0.0);\n\n    if (i == 0)\n    {\n        N(1,79,4,4)N(2,81,4,4)N(5,83,4,4)N(1,79,4,4)N(2,81,4,4)N(3,83,4,4)N(2,84,4,4)\n        N(1,83,4,4)N(2,81,4,4)N(5,72,4,4)N(1,86,4,1)N(1,86,4,1)N(1,86,4,1)N(2,88,4,3)\n        N(1,88,4,3) N(1,86,4,1)N(1,86,4,1)N(1,79,4,4)N(2,81,4,4)N(5,83,4,4)N(1,79,4,4)\n        N(2,81,4,4)N(3,83,4,4)N(2,84,4,4)N(1,83,4,4)N(2,81,4,4)N(5,72,4,4)\n        N(1,86,4,1)N(1,86,4,1)N(1,86,4,1)N(2,88,4,3)N(1,88,4,3) N(1,90,4,3)N(1,90,4,3)\n    }\n\n    if (i == 1)\n    {\n        N(1,83,4,4)N(2,84,4,4)N(5,86,4,4)N(1,83,4,4)N(2,84,4,4)N(3,86,4,4)N(2,88,4,4)\n        N(1,86,4,4)N(2,84,4,4)N(5,79,4,4)N(1,90,4,3)N(1,90,4,3)N(1,90,4,3)N(2,91,4,1)\n        N(1,91,4,1) N(1,90,4,3)N(1,90,4,3)N(1,83,4,4)N(2,84,4,4)N(5,86,4,4)N(1,83,4,4)\n        N(2,84,4,4)N(3,86,4,4)N(2,88,4,4)N(1,86,4,4)N(2,84,4,4)N(5,79,4,4)\n        N(1,90,4,3)N(1,90,4,3)N(1,90,4,3)N(2,91,4,1)N(1,91,4,1) N(1,90,4,3)N(1,90,4,3)\n    }\n\n    if (i == 2)\n    {\n        N(1,74,5,9)N(1,81,5,9)R(1)N(5,83,5,9)N(1,81,5,9)N(1,81,5,9)N(1,79,5,9)N(1,74,5,9)\n        R(1)N(1,79,5,9)R(1)N(1,76,5,9)N(1,77,5,9)R(1)N(1,76,5,9)R(1)N(1,74,5,9)N(1,72,5,9)\n        R(1)N(2,69,5,9)N(2,88,7,5)N(2,86,7,5)N(1,74,2,8)N(1,76,2,8)N(1,74,2,8)N(1,74,5,9)\n        N(1,81,5,9)R(1)N(5,83,5,9)N(1,81,5,9)N(1,81,5,9)N(1,79,5,9)N(1,74,5,9)R(1)\n        N(1,79,5,9)R(1)N(1,76,5,9)N(1,77,5,9)R(1)N(1,76,5,9)R(1)N(1,79,5,9)N(1,79,5,9)R(1)\n        N(2,78,5,9)N(2,79,7,5)N(2,81,7,5)N(1,74,2,8)N(1,76,2,8)N(1,78,2,8)\n    }\n\n    return n;\n}\n\nvec4 chan_A_pat(float t)\n{\n    float subpat_len = 8.0 / STEP;\n    t = mod(t, 64.0 / STEP);\n    int p = int(t / subpat_len);\n\n    int q = 0;\n    if (p == 2 || p == 6) q = 1;\n    if (p == 3 || p == 7) q = 2;\n\n    t = mod(t, subpat_len);\n\n    return chan_A_subpat(q, t);\n}\n\nvec4 chan_C_pat(float t)\n{\n    float subpat_len = 8.0 / STEP;\n    int p = int(t / subpat_len);\n    int q = p - (p / 4) * 4;\n\n    t = mod(t, subpat_len);\n\n    return chan_C_subpat(q, t);\n}\n\nvec4 chan_B_pat(float t)\n{\n    float subpat_len = 64.0 / STEP;\n    int p = int(t / subpat_len);\n\n    int q = 0;\n    if (p == 1) q = 1;\n    if (p == 2 || p == 3) q = 2;\n\n    t = mod(t, subpat_len);\n\n    return chan_B_subpat(q, t);\n}\n\n//\n\n#define PHI_INC(cnt, val) cnt < 0.0 ? 0.0 : exp2(float(val) / 12.0) * clamp(cnt, 0.0, 1.0), cnt -= 1.0\n#define PHI_REP(cnt, val) cnt < 0.0 ? 0.0 : exp2(float(val) / 12.0) * max(cnt, 0.0)\n\nfloat arpeggio3(float p, int d0, int d1, int d2)\n{\n    float phi = 0.0;\n    float mp = mod(p, 3.0);\n    float cp = floor(p / 3.0);\n\n    phi += PHI_INC(mp, d0);\n    phi += PHI_INC(mp, d1);\n    phi += PHI_INC(mp, d2);\n\n    float f0 = exp2(float(d0) / 12.0);\n    float f1 = exp2(float(d1) / 12.0);\n    float f2 = exp2(float(d2) / 12.0);\n\n    phi += (f0 + f1 + f2) * cp;\n\n    return phi;\n}\n\nfloat ornament(int i, float t)\n{\n    float p = t * INT_PER_STEP * STEP;\n    float phi = 0.0;\n\n    if (i == 1) phi = arpeggio3(p, -8, -5,  0);\n    if (i == 2) phi = arpeggio3(p, -7, -3,  0);\n    if (i == 3) phi = arpeggio3(p, -9, -4,  0);\n    if (i == 4) phi = arpeggio3(p,  0,  7, 12);\n\n    if (i == 5)\n    {\n        phi += PHI_INC(p, 12);\n        phi += PHI_INC(p, 12);\n        phi += PHI_REP(p, 0);\n    }\n\n    if (i == 8)\n    {\n        phi += PHI_INC(p, 0);\n        phi += PHI_INC(p, 24);\n        phi += PHI_INC(p, 0);\n        phi += PHI_INC(p, 12);\n        phi += PHI_INC(p, 0); phi += PHI_INC(p, 0); phi += PHI_INC(p, 0); phi += PHI_INC(p, 12);\n        phi += PHI_INC(p, 0); phi += PHI_INC(p, 0); phi += PHI_INC(p, 0); phi += PHI_INC(p, 12);\n        phi += PHI_REP(p, 0);\n    }\n\n    if (i == 9)\n    {\n        phi += PHI_INC(p,-12);\n        phi += PHI_INC(p, 0);\n        phi += PHI_INC(p, 19);\n        phi += PHI_REP(p, 0);\n    }\n\n    return phi / (INT_PER_STEP * STEP);\n}\n\nvec2 xsample(int i, float t)\n{\n    float p = t * INT_PER_STEP * STEP;\n    int   ip = int(p);\n    vec2  s = vec2(0.0, 0.0);\n\n    if (i == 2)\n    {\n        s.x = clamp(15.0 - p, 0.0, 15.0);\n        s.y = ip == 0 ? 1.0 : 0.0;\n    }\n    \n    if (i == 11)\n    {\n        s.x = clamp(15.0 - p, 0.0, 15.0);\n    }\n\n    if (i == 4)\n    {\n        s.x = clamp(16.0 - p, 9.0, 15.0);\n    }\n\n    if (i == 5)\n    {\n        s.x = clamp(14.5 - p * 0.5, 12.0, 14.0);\n        s.x = mix(s.x,\n            clamp(s.x + sin(p * 3.1415 * 0.4) * 0.4, 0.0, 15.0),\n            clamp(p - 17.0, 0.0, 1.0));\n\n        s.y = ip == 0 ? 1.0 : 0.0;\n    }\n\n    if (i == 7)\n    {\n        s.x = clamp(16.0 - p * 0.85, 0.0, 15.0);\n        if (p > 11.0) s.x = clamp(10.0 - abs(14.0 - p), 0.0, 15.0);\n        s.y = ip == 0 ? 1.0 : 0.0;\n    }\n\n    if (i == 15)\n    {\n        s.x = clamp(17.0 - p * 2.2, 0.0, 15.0);\n        s.x = p > 5.0 ? 0.0 : s.x;\n    }\n\n    if (i == 16)\n    {\n        s.x = clamp(15.5 - p * 0.5, 0.0, 15.0);\n        s.x = p > 10.0 ? 0.0 : s.x;\n        s.y = 1.0;\n    }\n\n    return s;\n}\n\n//\n\nvec2 hash22(vec2 p)\n{\n    p  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(vec2(p.y, p.x), p + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec2 noise(float t)\n{\n    return hash22(vec2(t, t * 1.423)) * 2.0 - 1.0;\n}\n\nvec2 lpnoise(float t, float fq)\n{\n    t *= fq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / fq);\n    vec2 n1 = noise(floor(tn + 1.0) / fq);\n\n    return mix(n0, n1, tt);\n}\n\n//\n\nfloat getVolumeAY(float v_0_15)\n{\n    float vol = exp2(-(31.0 - (v_0_15 * 31.0 / 15.0)) * 0.215) - 0.011;\n\n    return clamp(vol, 0.0, 1.0);\n}\n\nfloat synthAY(float phi, float f0, float v, float n, float ns)\n{\n    float vol = 0.5 * getVolumeAY(v);\n    float y = fract(phi * f0);\n\n    #if DO_BANDLIMIT\n        float q = 0.75 * min(iSampleRate, 44100.0) / f0;\n        y = abs(y * 2.0 - 1.0) * 2.0 - 1.0;\n        y = y >= 0.0 ? 1.0 - pow(1.0 - y, q) : pow(1.0 + y, q) - 1.0;\n        y = y * 0.5 + 0.5;\n    #else\n        y = y > 0.5 ? 1.0 : 0.0;\n    #endif\n\n    return vol * (y * 2.0 - 1.0) * (n * y > 0.0 ? ns : 1.0);\n}\n\nfloat synthTrack(vec4 note, float ns)\n{\n    float phi = ornament(int(note.w), note.y);\n    vec2  smp = xsample(int(note.z), note.y);\n    float f0  = 0.45 * 16.35 * exp2(note.x / 12.0);\n\n    return synthAY(phi, f0, smp.x, smp.y, ns);\n}\n    \nvec2 mainSound( in int samp,float time)\n{\n    time = max(0.0, time - WARMUP_TIME);\n    float k = 44100.0 / iSampleRate;\n\n    float n = lpnoise(time, 0.75 * 44100.0 * k).x;\n    float a = synthTrack(chan_A_pat(time), n);\n    float b = synthTrack(chan_B_pat(time), n);\n    float c = synthTrack(chan_C_pat(time), n);\n\n    vec2 w = vec2(0.86, 0.50) * a + vec2(0.62, 0.64) * b + vec2(0.62, 0.92) * c;\n\n    // fade-out\n    float fd = clamp(58.0 - time - WARMUP_TIME, 0.0, 1.0);\n    w *= getVolumeAY(fd * 15.0);\n\n    // cursor click when entering the editor\n    if (time + WARMUP_TIME > 59.75)\n    {\n        float t = time + WARMUP_TIME - 59.75;\n        t *= k;\n        float v = exp2(-t * 400.0);\n        if (t > 0.0035) v *= -2.0;\n        \n        w += vec2(v, v);\n    }\n\n    if (time == 0.0) w = vec2(0.0, 0.0);\n\n    return w * MASTER_VOLUME;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}