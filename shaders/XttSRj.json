{
    "Shader": {
        "info": {
            "date": "1480633787",
            "description": "A remake of something you might see in Planet Coaster!\n\nMy first attempt at a rollercoaster-like shader. If anyone can help with optimisation it would be greatly appreciated!",
            "flags": 65,
            "hasliked": 0,
            "id": "XttSRj",
            "likes": 11,
            "name": "Planet Coaster",
            "published": 3,
            "tags": [
                "game",
                "raymarcher",
                "world",
                "track",
                "rollercoaster",
                "coaster"
            ],
            "usePreview": 0,
            "username": "jackdavenport",
            "viewed": 1151
        },
        "renderpass": [
            {
                "code": "// Planet Coaster by jackdavenport\n// Based on Planet Coaster by Frontier Development.\n// All credit is commented above the releveant code.\n// You can use my code anywhere, just give credit.\n// Enjoy the shader! :)\n\n#define time mod(iTime,274.)\n\n#define MAX_ITERATIONS 512\n#define EPSILON .001\n#define FAR_PLANE 1000.\n\n#define E 2.71828\n\n#define LIGHT_DIR vec3(0.639602, 0.426401, -0.639602)\n#define SHADOW_BIAS .01\n\n#define FOG_COLOR vec3(.5,.5,.7)\n#define FOG_DENSITY .009\n\n// Settings\n// Uncomment this if you want motion sickness\n//#define XTREME_MODE\n// Uncomment to use cheap (but dirty) normal calculation\n//#define DIRTY_NORMALS\n\n// Distance functions by iq\n// Source: https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n// End distance functions\n// Smooth min by iq\n// Source: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// End Smooth min\n\nvec2 rot2D(vec2 p, float angle);\nfloat getTrackHeight(float z);\nfloat getTrackRotation(float z);\n\nvec2 dstTrack(vec3 p) {\n    float zp = p.z;\n    p.z  = mod(p.z,1.)-.5;\n    p.yz = rot2D(p.yz, 90.);\n    p.xz = rot2D(p.xz, getTrackRotation(zp));\n    p += vec3(.4,0.,.7+(getTrackHeight(zp)*.1));\n    float dst = sdCappedCylinder(p, vec2(.1,1.));\n    p += vec3(-.8,0.,0.);\n    dst = min(dst, sdCappedCylinder(p, vec2(.1,1.)));\n    dst = min(dst, udBox(p+vec3(.4,0.,0.), vec3(.4,.02,.02))-.03);\n    return vec2(dst,0.);\n}\nvec2 dstPylon(vec3 p) {\n    if(abs(getTrackRotation(floor(p.z))) < 45.) {\n        return vec2(0.,-1.);\n    }\n    float zp = p.z;\n    p.z = mod(p.z, 3.)-1.5;\n    float  h = getTrackHeight(floor(zp))*2.28;\n    float dst = sdCappedCylinder(p-vec3(0.,-10.+h,0.), vec2(.1,h));\n    return vec2(dst,0.);\n}\nvec2 dstGround(vec3 p, float h) {\n    return vec2(p.y-h,1.);\n}\n\nvec2 dstUnion(vec2 a, vec2 b) {\n    if(b.y < 0. || a.x < b.x) return a;\n    return b;\n}\nvec2 dstSmin(vec2 a, vec2 b) {\n    if(b.y < 0.) {\n        return a;\n    }\n    if(a.y < 0.) {\n        return b;\n    }\n    float dst = smin(a.x, b.x, .1);\n    return vec2(dst,a.y);\n}\n\nvec2 dstScene(vec3 p) {\n    vec2 dst = dstTrack(p);\n    dst = dstSmin(dst, dstPylon(p));\n    dst = dstUnion(dst, dstGround(p, -10.));\n    \n    p += vec3(10.,4.,25.);\n    vec2 coaster2 = dstSmin(dstTrack(p), dstPylon(p));\n    dst = dstUnion(dst, coaster2);\n    \n    return dst;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, int iter) {\n    float  t = 0.;\n    float id = -1.;\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n        if(t >= FAR_PLANE || i >= iter) {\n            id = -1.;\n            break;\n        }\n        vec2 scn = dstScene(ro+rd*t);\n        if(scn.x < EPSILON) {\n            id = scn.y;\n            break;\n        }\n        t += scn.x * .75;\n    }\n    return vec2(t,id);\n}\n\nvec3 calcNormal(vec3 p, float t);\n\nvec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh) {\n    float d = max(dot(LIGHT_DIR,n),0.);\n    float s = pow(max(dot(LIGHT_DIR,r),0.),sh);\n    \n    if(raymarch(p+LIGHT_DIR*SHADOW_BIAS,LIGHT_DIR,64).y >= 0.) {\n        d = 0.;\n        s = 0.;\n    }\n    \n    return (col*d)+s;\n}\n\nvec3 shadeCoaster(vec3 p, vec3 n, vec3 r) {\n    return calcLighting(vec3(.2,.2,.9), p, n, r, 3.);\n}\nvec3 shadeGround(vec3 p, vec3 n, vec3 r) {\n    float  t = texture(iChannel1,p.xz).x;\n    // thnx VoidChicken!\n    vec3 col = mix(vec3(.3,.7,.2),vec3(.1,.5,.05),t/(1.+t));\n    return calcLighting(col, p, n, r, 30.);\n}\n\nvec3 shade(vec3 ro, vec3 rd) {\n    vec3 col = mix(FOG_COLOR,vec3(.4,.6,.9),clamp(pow(rd.y+.5,.7)-.25,0.,1.));\n    vec2 scn = raymarch(ro, rd, MAX_ITERATIONS);\n    if(scn.y == 0.) {\n        vec3 p = ro+rd*scn.x;\n        vec3 n = calcNormal(p,scn.x);\n        vec3 r = normalize(reflect(rd, n));\n        \n        col = shadeCoaster(p,n,r);\n        \n        vec3 rc = vec3(.4,.6,.9);\n        vec2 rs = raymarch(p+r*SHADOW_BIAS,r,128);\n        if(rs.y >= 0.) {\n            vec3 rp = p+r*rs.x;\n            vec3 rn = calcNormal(p,rs.x);\n            vec3 rr = normalize(reflect(r,rn));\n            if(rs.y == 0.) {\n                rc = shadeCoaster(rp,rn,rr);\n            } else if(rs.y == 1.) {\n                rc = shadeGround(rp,rn,rr);\n            }\n        }\n        \n        float f = 1.-clamp(pow(-dot(rd,n),.2),0.,1.);\n        col = mix(col, rc, f);\n    } else if(scn.y == 1.) {\n        vec3 p = ro+rd*scn.x;\n        vec3 n = vec3(0.,1.,0.);\n        vec3 r = normalize(reflect(rd,n));\n        \n        col = shadeGround(p,n,r);\n    }\n    if(scn.y >= 0.) {\n        float f = 1.-(1./(pow(E,pow(scn.x*FOG_DENSITY,2.))));\n        col = mix(col, FOG_COLOR, f);\n    }\n    return col;\n}\n\nvoid doMain(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    ro \t += vec3(0.,0.,-3.+time*15.);\n    ro.y += getTrackHeight(ro.z)*.03;\n    rd.xy = rot2D(rd.xy, -getTrackRotation(ro.z));\n    \n    // song length is 274 seconds (4*60+34)\n    float fade = smoothstep(1.,4.,time)*(1.-smoothstep(270.,274.,time));\n    if(fade <= 0.) {\n        fragColor.xyz = vec3(0.);\n        fragColor.w   = 1.;\n        return;\n    }\n    fragColor.xyz = shade(ro, normalize(rd));\n    fragColor.w   = 1.;\n    \n    fragColor.xyz *= fade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    doMain(fragColor, fragCoord, vec3(0.), vec3(uv, 1.));\n}\nvoid mainVR(out vec4 fc, in vec2 fp, in vec3 ro, in vec3 rd) {\n    doMain(fc, fp, ro, rd);\n}\n\nvec2 rot2D(vec2 p, float angle) {\n    angle = radians(angle);\n    float s = sin(angle), c = cos(angle);\n    return mat2(c,s,-s,c)*p;\n}\n\n#ifdef XTREME_MODE\nfloat getTrackHeight(float z) {\n    return sin(z*2.)*5.;\n}\nfloat getTrackRotation(float z) {\n    return 90.*sin(z*.3);\n}\n#else\nfloat getTrackHeight(float z) {\n    return sin(z*(.01+.02*(.5+.5*cos(-z*.05))))*2.;\n}\nfloat getTrackRotation(float z) {\n    return (360.*(.5+.5*sin(z*.03)))*cos(z*.01);\n}\n#endif\n\n#ifdef DIRTY_NORMALS\n// Dirty normals by /u/aczkasow\n// Source: https://www.reddit.com/r/twotriangles/comments/1vctzs/another_dirty_way_of_calculating_normals/\nvec3 calcNormal(vec3 p, float t) {\n    return normalize(cross(dFdy(p),dFdx(p)));\n}\n#else\nvec3 calcNormal(vec3 p, float t) {\n    vec2 e = vec2(EPSILON*t,0.);\n    vec3 n = vec3(dstScene(p+e.xyy).x-dstScene(p-e.xyy).x,\n                  dstScene(p+e.yxy).x-dstScene(p-e.yxy).x,\n                  dstScene(p+e.yyx).x-dstScene(p-e.yyx).x);\n    return normalize(n);\n}\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 5538,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/demon-koopa-eric-glenn/planet-coaster-theme-song-full-version"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}