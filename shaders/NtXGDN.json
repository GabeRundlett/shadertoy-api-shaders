{
    "Shader": {
        "info": {
            "date": "1622060275",
            "description": "@C010011012 / chase marangu 's submission to @cs_kaplan's https://isohedral.ca/swirled-series/",
            "flags": 0,
            "hasliked": 0,
            "id": "NtXGDN",
            "likes": 13,
            "name": "Swirled Series C010011012",
            "published": 3,
            "tags": [
                "voxel",
                "penrose",
                "swirledseries"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "\n\n// Current code for: Swirled Series C010011012\n// Date: Made around 2020 November 22nd\n// Tags: swirledseries, penrose, voxel\n// Description: @C010011012 / chase marangu 's submission to @cs_kaplan's https://isohedral.ca/swirled-series/\n\n\n// â†“ i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582\n#define TAU 6.28318530718\n\n#define arg mod(float(iFrame)/60./3., 1.)\n\n#define cam_maus 0\n#define cam_psp 0\n\n#define rrg min(2.*min(2.*arg, 2.-2.*arg), 1.)\n//#define R mix(.05, .5, min(2.*arg, 2.-2.*arg))\n#define R mix(.01, .1, rrg)\n//#define R 0.\n\n//\n//#define sund normalize(vec3(1., .2, -.2))\n#define sund normalize(vec3(1., .0, -.0))\n//vec3 sky_map (vec3 d) {\n    //return vec3(0.);\n    //return vec3(.0, .0, 100./255.);\n    //return vec3(0., 1., 0.);\n    //return texture(iChannel2, d).rgb;\n//}\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n//\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.465), 0.) )-.02)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.5-R-.002), 0.) )-R)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    //\n    vec3 camp = p;\n    float SDFp;\n    for (int i=0; i<6020; ++i) {\n        SDFp = SDF(p);\n        if (SDFp > 1.8) { // sqrt(3)\n        //if (SDFp > .18) {\n        //if (SDFp > 20.) {\n            break;\n        }\n        else if (abs(SDFp) < 3e-5) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    SDF(p+vec3(1e-3, 0., 0.)),\n                    SDF(p+vec3(0., 1e-3, 0.)),\n                    SDF(p+vec3(0., 0., 1e-3))\n                )),\n                length(p-camp)\n            );\n            #undef inf\n        }\n        p += d*abs(SDFp)*.99;\n    }\n    return inter_sky;\n}\n\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n#define inter_plane_short(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? vec4(n, dot(c-p, -n)/dot(-n, d)) : inter_sky\\\n)\n#define inter_plane_dist(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? dot(c-p, -n)/dot(-n, d) : inter_sky\\\n)\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n\n\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 6., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p, pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p, d, pane1c, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p, pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\nvec3 sky_map2 (vec3 p, vec3 d) {\n    return vec3(0.4);\n    vec4 inter_current, inter_closest;\n    inter_closest = inter_sky;\n    inter_current = inter_plane(p, d, vec3(0., 30., 0.), normalize(vec3(-1.)) );\n    p += d*inter_current.w;\n    //return texture(iChannel1, p.xz*40.).rgb;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    //\n    vec3 randy; vec2 screen, maus; float samplei2, samplei, ox, oy;\n    //\n    vec3 retina; vec4 inter_current, inter_closest; float shiny; vec3 TEXp;\n    vec3 camp, camd, p, d; mat2 azimuth, zenith; float th, ph;\n    //\n    if (abs( (fragCoord.x-iResolution.x/2.)/(iResolution.y/2.)) > 1.) {\n        //fragColor = vec4(0., 1., 1., 1.);\n        //return;\n    }\n    //\n    th = 0.;\n    ph = 0.;\n    #if cam_maus\n    //#if 0\n    maus = (iMouse.xy-iResolution.xy/2.)/iResolution.y*2.;\n    th += maus.x*PI;\n    ph += maus.y*PI;\n    #endif\n    //\n    //\n    ph -= PI*.5-.001;\n    th += PI;\n    //ph += (.5+.5*sin(arg*PI) )*PI*.5;\n    //ph += arg*TAU;\n    ph += arg*PI*.5;\n    th += arg*PI*.5;\n    //\n    //\n    azimuth = mat2(\n        cos(th), cos(PI*.5+th),\n        sin(th), sin(PI*.5+th)\n    );\n    zenith = mat2(\n        cos(ph), cos(PI*.5+ph),\n        sin(ph), sin(PI*.5+ph)\n    );\n    //\n    #define spp 1.\n    #define spw 1.\n    fragColor.xyz = vec3(0.);\n    //\n    for (samplei2=0.; samplei2<spp*spw*spw; ++samplei2) {\n        ox = mod(samplei2, spw);\n        oy = mod(samplei2/spw, spw);\n        samplei = mod(samplei2/spw/spw, spp);\n        #if 1\n        randy = vec3(\n            fract(sin(\n                mod(\n                    samplei*21.463049023049+\n                    (float(iFrame)+fragCoord.x)*0.021415,\n                    TAU\n                )+fragCoord.y*52.2324352432\n            )),\n            fract(sin(\n                mod(\n                    samplei*421.83743204984+\n                    (float(iFrame)+fragCoord.x)*8.234203,\n                    TAU\n                )+fragCoord.y*123.242543465\n            )),\n            fract(sin(\n                mod(\n                    samplei*952.13454543556+\n                    float(iFrame)*8.234203,\n                    TAU\n                )+fragCoord.y*.003432443\n            ))\n        );\n        #undef samplei\n        #else\n        randy = vec3(0.);\n        #endif\n        //\n        screen = (fragCoord+randy.rg-iResolution.xy/2.)/iResolution.y*2.;\n        //\n        retina = vec3(0.);\n        shiny = 1.;\n        //\n        #if cam_psp\n        //#if 0\n        camp = vec3(0., 0., 0.)*.4;\n        camd = normalize(camp+vec3(screen.xy, 1.)-camp );\n        #else\n        camp = vec3(screen.xy, 0.)*4.;\n        camd = normalize(vec3(0., 0., 1.));\n        camp -= camd*4.;\n        #endif\n        //\n        camd.yz = zenith*camd.yz;\n        camp.yz = zenith*camp.yz;\n        camd.xz = azimuth*camd.xz;\n        camp.xz = azimuth*camp.xz;\n        //\n        camd = normalize(camd);\n        camp.y += 10.;\n        //\n        //\n        //\n        //\n        p = camp; d = camd;\n        int reflcount = 0;\n        //\n        for (int bounces=0; bounces<33; ++bounces) {\n        //for (int bounces=0; bounces<2; ++bounces) {\n            // only have 2 bounces anyways\n            if (shiny < .1) { break; }\n            inter_closest = inter_minecraft(p, d);\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // hits sky - no shading\n                break;\n            }\n            p += d*inter_closest.w;\n            //\n            //\n            if (true) {\n                // hits object\n                //TEXp = abs(inter_closest.xyz);\n                TEXp = vec3(1.);\n                //TEXp = mix(TEXp, .5+.5*inter_closest.xyz, rrg);\n                //TEXp = vec3(1.);\n                //\n                #if 1\n                TEXp *= mod(1.+floor(p.x-.01)+floor(p.y-.01)+\n                        floor(p.z-.01), 2.);\n                #endif\n                //TEXp = vec3(1.);\n                //#define shininess .29999993\n                //#define shininess .9999993\n                #define shininess mix(1., .7, rrg);\n                //\n                //#if 0\n                // failed shadows attempt\n                //vec3 temppT;\n                //vec4 inter_shado1 = inter_tribar(p+sund*1e-2, sund, temppT);\n                //if (inter_shado1.w < inter_sky.w) {\n                //    TEXp *= .5;\n                //}\n                //#endif\n                //\n                retina += TEXp*shiny*shininess;\n                shiny *= 1.-shininess;\n                #undef shininess\n                d = reflect(d, inter_closest.xyz);\n                ++reflcount;\n                if (reflcount >= 4) {\n                    break;\n                }\n                //break;\n            }\n            //p += d*1e-3;\n            p += d*9e-3;\n        }\n        if (shiny >= 1.) {\n            //retina = vec3(0., 0., 100./255.);\n            //shiny *= 0.;\n        }\n        //retina += shiny*sky_map(d);\n        retina += shiny*sky_map2(p, d);\n        fragColor.rgb += retina;\n    }\n    //\n    fragColor.rgb /= spp*spw*spw;\n    fragColor.rgb = vec3(fragColor.r+fragColor.g+fragColor.b)/3.;\n    fragColor.a = 1.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}