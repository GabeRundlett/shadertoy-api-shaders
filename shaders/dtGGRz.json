{
    "Shader": {
        "info": {
            "date": "1683445001",
            "description": "Fork of @fizzer's original to show the calculation of uv coordinates for the limit circles. The coloured border shows the different limit circles.",
            "flags": 0,
            "hasliked": 0,
            "id": "dtGGRz",
            "likes": 14,
            "name": "Apollonian Britney",
            "published": 3,
            "tags": [
                "mobius",
                "inversion",
                "apollonian",
                "gasket"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 311
        },
        "renderpass": [
            {
                "code": "// Apollonian Britney, mla, 2023\n//\n// Modification of @fizzer's original https://www.shadertoy.com/view/WtdSDf\n// See mainImage around line 210 for limit circle uv calculation.\n// Also made a few mods to the code, eg. only invert combined transformation\n// at the end & a different way of handling a division by zero.\n\nconst float pi = acos(-1.);\nconst int numCircles = 4; // Set this to 4, for the classic gasket.\n\n// For more on Möbius transformations see: \n// https://en.wikipedia.org/wiki/M%C3%B6bius_transformation\n// https://en.wikipedia.org/wiki/Indra%27s_Pearls_(book)\n\n// Transformations are represented by 2x2 complex matrices, mat4x2(a,b,c,d):\n// with z -> (az+b)/(cz+d), so multiplying a matrix by complex w represents\n// the same transformation. Inverse transformation is just (any multiple of)\n// the inverse matrix.\nconst mat4x2 midentity = mat4x2(vec2(1, 0),\n                                vec2(0, 0),\n                                vec2(0, 0),\n                                vec2(1, 0));\n\n// Apply transformation m to point x\nvec2 cMobius(mat4x2 m, vec2 x)\n{\n    return cDiv(cMul(x, m[0]) + m[1], cMul(x, m[2]) + m[3]);\n}\n\n// Matrix multiplication, in fact.\nmat4x2 cMobiusConcat(mat4x2 ma, mat4x2 mb)\n{\n    return mat4x2(cMul(ma[0], mb[0]) + cMul(ma[1], mb[2]),\n                  cMul(ma[0], mb[1]) + cMul(ma[1], mb[3]),\n                  cMul(ma[2], mb[0]) + cMul(ma[3], mb[2]),\n                  cMul(ma[2], mb[1]) + cMul(ma[3], mb[3]));\n}\n\n// Matrix inverse, but no need to divide by determinant.\nmat4x2 cMobiusInverse(mat4x2 m)\n{\n    return mat4x2(m[3], -m[1], -m[2], m[0]);\n}\n\n// Apply transformation T to circle C\nvec3 cMobiusOnCircle(mat4x2 T, vec3 C)\n{\n    vec3 D;\n    vec2 z = C.xy;\n    // Handle zero division.\n    if (T[2] != vec2(0)) z -= cDiv(vec2(C.z * C.z, 0), cConj(cDiv(T[3], T[2]) + C.xy));\n    D.xy = cMobius(T,z).xy;\n    D.z = length(D.xy - cMobius(T,C.xy + vec2(C.z, 0)));\n    return D;\n}\n\n// These are the N inversion circles necessary to produce the fractal which is the limit\n// set of a Kleinian group. The Möbius transformations which represent inversions in these circles\n// are the generators of the Kleinian group.\nvec3 getInversionCircle(int i)\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    if(i == numCircles - 1) return vec3(0, 0, r1 - r0); // Central circle\n    return vec3(cos(float(i) * theta * 2.) * r1, sin(float(i) * theta * 2.) * r1, r0);\n}\n\n// These are the N circles which are the minimum set of circles which all of the other circles\n// in the limit set are images of. There are N-1 circles in a circular chain of tangency, and\n// one circle surrounding the gasket with radius 1.\nvec3 getLimitCircle(int i)\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    float r = (r1 - r0) * tan(theta);\n    float r2 = (r1 - r0) / cos(theta);\n    if(i == numCircles - 1) return vec3(0, 0, 1);\n    return vec3(-cos((float(i)) * theta * 2.) * r2, sin((float(i)) * theta * 2.) * r2, r);\n}\n\nvec3 getInnerLimitCircle()\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    float r = (r1 - r0) * tan(theta);\n    float r2 = (r1 - r0) / cos(theta);\n    return vec3(0., 0., r2 - r);\n}\n\nmat4x2 makeMobiusForInversionInCircle(vec3 ic)\n{\n    mat4x2 ma = mat4x2(vec2(1. / ic.z, 0),\n                       vec2(-ic.x / ic.z, ic.y / ic.z),\n                       vec2(0, 0),\n                       vec2(1, 0));\n\n    mat4x2 mb = mat4x2(vec2(ic.x, ic.y),\n                       vec2(ic.z, 0),\n                       vec2(1, 0),\n                       vec2(0, 0));\n\n    return cMobiusConcat(mb, ma);\n}\n\nvec3 getcol(int i) {\n  // Colors for limit circles. For consistent colouring\n  // we have 1=4 and 2=3.\n  if (i == 0) return vec3(0,0,1);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(1,0,0);\n  if (i == 3) return vec3(0,1,0);\n  if (i == 4) return vec3(1,1,0);\n  if (i == 5) return vec3(1,0,0);\n  return vec3(1);\n}\n\nvec3 getcol(int i, int parity) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1 && parity == 0 || i == 2 && parity == 1) return vec3(0,1,0);\n  if (i == 1 && parity == 1 || i == 2 && parity == 0) return vec3(0,0,1);\n  return vec3(1,1,0);\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n\n    float scale = 1.;\n\n    fragColor = vec4(0, 0, 0, 1);\n\n\n    vec2 z = vec2(p.x, p.y);\n\n    mat4x2 mi = midentity;\n\n    if(iMouse.x > .5)\n    {\n        // This mouse interaction is based on mla's shader: https://www.shadertoy.com/view/MlVfzy\n        // [mla: actually there is a better way to do this]\n        mat4x2 m = midentity;\n        vec2 mo = (2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0)) * vec2(1, -1);\n\n        if(length(mo) < 0.999)\n        {\n            vec2 c = mo * (1.0 / dot(mo, mo));\n            vec3 ic = vec3(c, sqrt(dot(c, c) - 1.));\n\n            m = makeMobiusForInversionInCircle(ic);\n        }\n\n\n        mi = cMobiusConcat(m,mi);\n\n        z = cMobius( m,z );\n    }\n\n    // Rotate the gasket *after* the mouse position inversion.\n\n    float t = iTime * .4;\n    mat4x2 mrotation = mat4x2(vec2(cos(t), sin(t)),\n                              vec2(0, 0),\n                              vec2(0, 0),\n                              vec2(1, 0));\n\n    mi = cMobiusConcat(mrotation,mi);\n    z = cMobius( mrotation, z );\n    int parity = 0;\n    \n    // High loop bound to avoid limit point artefacts\n    // Most pixels break out long before this,\n    for(int i = 0; i < 1000; ++i)\n    {\n    parity = i%2;\n        int k = -1;\n\n        mat4x2 m;\n        vec3 ic;\n\n        for(int j = 0; j < numCircles; ++j)\n        {\n            vec3 c = getInversionCircle(j);\n            \n            if(distance(z.xy, c.xy * vec2(1, -1)) < c.z)// &&i%2==0)\n            {\n                k = j;\n                ic = c;\n                break;\n            }\n        }\n\n        if(k == -1) break;\n\n        ic.x += 1e-9;\n\n        m = makeMobiusForInversionInCircle(ic);\n\n        mi = cMobiusConcat(m,mi);\n\n        z = cMobius( m, z );\n    }\n\n    mi = cMobiusInverse(mi); // Get inverse transformation\n    \n    vec3 col = vec3(0);\n\n    float px = fwidth(p.x);\n    for(int i = 0; i < numCircles; ++i)\n    {\n        vec3 C = getLimitCircle(i);\n        vec3 D = cMobiusOnCircle(mi, C);\n\n        if(D.z > 1e-9 && D.z < 1. && abs(D.z - 1.) > .01)\n        {\n            vec2 v = p.xy - D.xy;\n\n            if(length(v) < D.z) {\n               // mla part\n               vec2 uv = 0.5*v/D.z;\n               //col = texture(iChannel0,uv+0.5).rgb;\n               //col = pow(col,vec3(2.2)); // I like the washed out effect of not doing this\n               col = getcol(i,parity);\n               float twidth = 0.02;\n               col = mix(col,texture(iChannel0,uv+0.5).rgb,vec3(smoothstep(0.0,px,0.5-length(uv)-twidth)));\n               //col = getcol(i,parity);\n               col *= smoothstep(0.0,px,D.z-length(v));\n               col *= smoothstep(0.0,px,abs(D.z-length(v)-2.0*D.z*twidth));\n               break;\n            }\n        }\n    }\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Complex arithmetic\nvec2 cMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, \n                a.x * b.y + a.y * b.x);\n}\n\nvec2 cConj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nvec2 cInverse(vec2 a)\n{\n    return cConj(a) / dot(a,a);\n}\n\nvec2 cDiv( vec2 a, vec2 b)\n{\n    return cMul(a, cInverse(b));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}