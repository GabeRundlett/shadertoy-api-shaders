{
    "Shader": {
        "info": {
            "date": "1633332480",
            "description": "importance samples a pair of slits using huygens principle",
            "flags": 0,
            "hasliked": 0,
            "id": "sd3XD7",
            "likes": 2,
            "name": "Monte carlo double slit",
            "published": 3,
            "tags": [
                "physics"
            ],
            "usePreview": 0,
            "username": "copperbotte",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n// importance sample the rectangle\n// xy is the center of the rectangle, wh is the dimensions\nvec2 iSample_rect(vec2 ap_xy, vec2 wh)\n{\n    vec2 xi = vec2(rnd(), rnd());\n    vec2 uv = xi - 0.5;\n    return ap_xy + wh*uv;\n}\n\n// importance sample a circle\nvec2 iSample_circle(vec2 xy, float radius)\n{\n    vec2 xi = vec2(rnd(), rnd());\n    float r = radius*sqrt(xi[0]);\n    float t = 2.0 * 3.141592 * xi[1];\n    return xy + r*vec2(cos(t), sin(t));\n}\n\nfloat iSample_rect_amp(vec2 xy, vec3 dir, vec2 ap_xy, vec2 wh, float dist, float c, float lambda)\n{\n    // find a random sample in the slit\n    vec2 uv = iSample_rect(ap_xy, wh);\n\n    // find the distance between the destination point xy and the source point uv\n    float radius = length(vec3(xy, dist) - vec3(uv, 0.0));\n    float k = 2.0 * 3.141592 * (c / lambda);\n    \n    // find the positional phase difference\n    float phase = dot(dir.xy, uv);\n    \n    // find the wave amplitude at this point\n    float amp = cos(k * (radius + phase)) / (radius * radius);\n    return amp;\n}\n\nfloat iSample_circle_amp(vec2 xy, vec3 dir, vec2 ap_xy, float r, float dist, float c, float lambda)\n{\n    // find a random sample in the slit\n    vec2 uv = iSample_circle(ap_xy, r);\n\n    // find the distance between the destination point xy and the source point uv\n    float radius = length(vec3(xy, dist) - vec3(uv, 0.0));\n    float k = 2.0 * 3.141592 * (c / lambda);\n    \n    // find the positional phase difference\n    float phase = dot(dir.xy, uv);\n    \n    // find the wave amplitude at this point\n    float amp = cos(k * (radius + phase)) / (radius * radius);\n    return amp;\n}\n\n// find a random amplitude for this destination point\nfloat amplitude(vec2 xy)\n{\n    float dist = 0.05;\n    float dx = sin(iTime / 5.0);\n    \n    vec3 dir = normalize(vec3(0.0,0.0,1.0));\n    \n    float c = 1.0;\n    float lambda = 0.1;\n    \n    float Out = 0.0;\n    const int samples = 1280;\n    const float fsamples = float(samples);\n    for(int i=0; i<samples; ++i)\n    {\n        vec2 wh = vec2(0.0001,1.0);\n        float radius = 0.001;\n        Out += iSample_rect_amp(xy, dir, vec2(-dx/2.0,0.0), wh, dist, c, lambda);\n        //Out += iSample_circle_amp(xy, dir, vec2(-dx/2.0,0.0), radius, dist, c, lambda);\n        \n        Out += iSample_rect_amp(xy, dir, vec2(dx/2.0,0.0), wh, dist, c, lambda);\n        //Out += iSample_circle_amp(xy, dir, vec2(dx/2.0,0.0), radius, dist, c, lambda);\n        \n        //Out += iSample_circle_amp(xy, dir, vec2(0.0,dx/2.0), radius, dist, c, lambda);\n        //Out += iSample_circle_amp(xy, dir, vec2(0.0,-dx/2.0), radius, dist, c, lambda);\n    }\n    \n    return Out / (fsamples * 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    // Generate random seed\n    seed = fract(iTime) + iResolution.y * uv.x + uv.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = srgb2lsrgb(texture(iChannel0, xy).xyz);\n    float amp = amplitude(xy);\n    col *= amp*amp;\n\n    // Output to screen\n    fragColor = vec4(lsrgb2srgb(saturationClip(col)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}