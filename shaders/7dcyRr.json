{
    "Shader": {
        "info": {
            "date": "1652961169",
            "description": "test",
            "flags": 0,
            "hasliked": 0,
            "id": "7dcyRr",
            "likes": 40,
            "name": "test_but",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "butadiene",
            "viewed": 927
        },
        "renderpass": [
            {
                "code": "float PI = acos(-1.);\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec4 map( in vec3 p )\n{\n   float d = cube(p,vec3(1.0));\nvec3 col = vec3(0);\n   float s = 1.0;\n   float ite = 4.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.1 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float k = 2.0*pow(abs(sin(0.5*iTime)),0.2);\n       if(r.x<r.y)col.z+=1.2*abs((float(m)-k))/ite;\n        if(r.y>r.z)col.y+=1.*abs((float(m)-k))/ite,col.z += 0.2*abs((float(m)-k))/ite;\n        if(r.x>r.z)col.x+=1.2*abs((float(m)-k))/ite;\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n\n   return vec4(col,d);\n}\n#define BOXITER 5.\n\nfloat cnbox(vec3 ps,float t, float k){\n    ps.xy *= rot(0.25*3.14);\n    ps.xz *= rot(0.25*3.14);\n    ps.xy *= rot(1.*t*3.14);\n    ps.xz *= rot(1.*t*3.14);\n    float sc = 0.45;\n    ps = abs(ps);\n    vec3 pk = ps;\n    if(k>1.){\n        for(int i = 0;i<int(BOXITER)+1;i++){\n            if(float(i)<floor(k)-1.){\n            ps = abs(ps)-sc/pow(2.,4.+float(i));\n            }else if(BOXITER>k){\n             ps = mix(ps,abs(ps)-sc/pow(2.,4.+float(i)),clamp(k-1.-float(i),0.0,1.0));\n             break;\n            }else{\n                 ps = mix(ps,pk,clamp(k-1.-float(i),0.0,1.0));\n            }\n        }\n    }\n    float sac = pow(2.2,k-1.);\n    if(BOXITER<k)\n    sac = mix(sac,1.0,pow(k-BOXITER,0.4));\n    float d1 = cube(ps,sc*0.5*vec3(0.2,0.2,0.2)/sac);\n    return d1;\n}\nfloat ease_in_out_cubic(float x) {\n\treturn x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nvec4 dist(vec3 p){\n    vec3 p1 = p;\n    float k = 2.;\n    float ksstx = clamp(3.*(fract(0.1*iTime)-2./3.),0.0,1.0);\n    float kssty = clamp(3.*(fract(0.1*iTime)-1./3.),0.0,1.0);\n    float ksstz = clamp(3.*fract(0.1*iTime),0.0,1.0);\n    p.x += 4.*ease_in_out_cubic(ksstx);\n    p.y += 4.*ease_in_out_cubic(kssty);\n    p.z += 4.*ease_in_out_cubic(ksstz);\n    p = mod(p,k)-0.5*k;\n    //p.xy *= rot(0.25*3.14);\n    //p.xz *= rot(0.25*3.14);\n    vec4 sd = map(p);\n    float d= sd.w;\n    vec3 col = 0.4*sd.xyz;\n    col *= exp(-2.5*d)*2.6;\n    vec3 ps = p1-vec3(1.);\n    float ktx = 0.3;\n    float kt = fract(iTime*ktx);\n    float d1 = cnbox(ps,ease_in_out_cubic(kt),1.+mod(ease_in_out_cubic(kt)+floor(iTime*ktx),BOXITER));\n    return vec4(col,min(d,d1));\n}\n\nvec3 gn(vec3 p){\nvec2 e = vec2(0.001,0.);\nreturn normalize(vec3(dist(p+e.xyy).w-dist(p-e.xyy).w,\ndist(p+e.yxy).w-dist(p-e.yxy).w,\ndist(p+e.yyx).w-dist(p-e.yyx).w\n\n));\n\n}\n  //https://www.shadertoy.com/view/lsKSWR\nfloat vig(vec2 uv)\n{\n   float time = iTime;\n   uv *=  1.0 - uv.yx;\n   float vig = uv.x*uv.y;\n   vig = pow(vig, 0.45);\n   return vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n    p.y *= iResolution.y/iResolution.x;\n\n    float rsa =0.2;\n    float time = iTime+17.5;\n    float rkt = time*0.3;\n    vec3 dmo = vec3(1.)+vec3(0,0,0);\n    vec3 ro = vec3(rsa*cos(rkt),0.*sin(time*0.2),rsa*sin(rkt))+dmo;\n    vec3 ta = vec3(0)+dmo;\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+1.2*cdir);\n   // rd.xz *= rot(time*0.13+1.);\n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    vec3 ac2 = vec3(0.);\n    float frag = 0.;\n    float ep = 0.00001;\n vec3 as =ro + 0.0*(p.x*side+p.y*up); \n    for(int i =0;i<75;i++){\n        vec4 rsd = dist(as+rd*t);\n        d = max(rsd.w,0.000);\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n    vec3 sp = as + rd*t;\nvec3 normal = gn(sp);\nrd = reflect(rd,normal);\n\nvec3 col  =0.013*ac;\n    ac *= 0.;\n    t = 0.1;\n   for(int i =0;i<75;i++){\n        vec4 rsd = dist(sp+rd*t);\n        d = max(rsd.w,0.000);\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n    col += 0.013*ac;\n    \n      sp = as + rd*t;\n normal = gn(sp);\nrd = reflect(rd,normal);\n\n    ac *= 0.;\n    t = 0.1;\n   for(int i =0;i<75;i++){\n        vec4 rsd = dist(sp+rd*t);\n        d = max(rsd.w,0.000);\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n    col += 0.013*ac;\n    //col = pow(col,vec3(0.8));\n    \tfragColor = vec4(col, 1.0 );\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}