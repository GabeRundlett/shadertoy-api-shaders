{
    "Shader": {
        "info": {
            "date": "1457219492",
            "description": "This is a 3D test, where you \"fly\" through color changing blocks in space. All suggestions are welcome!<br/><br/>Known Bugs:<br/>1. Pixel circles in the center of each outlined \"box\"<br/> ",
            "flags": 0,
            "hasliked": 0,
            "id": "MsK3Wd",
            "likes": 1,
            "name": "Testing With 3D",
            "published": 3,
            "tags": [
                "3d",
                "test",
                "bad",
                "first",
                "suggestionswelcome"
            ],
            "usePreview": 0,
            "username": "Mr_E",
            "viewed": 750
        },
        "renderpass": [
            {
                "code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(1.3,1.45,5.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(1.4,5.2,2.2)),\n            sdBox(p,vec3(2.4,2.4,2.4)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d2, d2,18.0);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n    vec3 q = opRep(p,vec3(10.0,10.0,10.0));\n    return vec2(\n       \tsdCrossedGrid(q)\n    );\n}\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    //return vec3(0.6,0.6,0.8);\n    return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(cos(iTime/5.)*20.0,sin(iTime/5.)*30.0,10.0);\n\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(0,1,1);\n\n    //camera lookat\n    vec3 vrp=vec3(0,1,0);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*1.0+vPos.y*v*1.0;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.04,0,0.8);\n    const float maxd=200.0;\n    vec2 d=vec2(1.02,1.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) { // Change i value to 256 for 3D-ness and 2 for coolness\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x*0.7;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        \n        float b=dot(N,normalize(prp-p));\n\t\tvec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    \txy.y = 1.0 - xy.y;\n    \t\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\t\tfragColor = vec4(b,0.2*sin(iTime),uv*b);\n        \n        vec4 texColor = texture(iChannel0,xy,b);//Get the pixel at xy from iChannel0\n\t    //fragColor = vec4(b, 0.1, b, cos(iTime));//Set the screen pixel to that color\n    } else {\n    //fragColor=vec4(0,0,0,1);\n    }\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}