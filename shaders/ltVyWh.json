{
    "Shader": {
        "info": {
            "date": "1536076402",
            "description": "Iridescence is a phenomenal that causes a material to appear to be of a different colour depending on the direction at which you look at it. Here I approximated that effect with a simple function that involves dot(incident ray, normal vector).",
            "flags": 0,
            "hasliked": 0,
            "id": "ltVyWh",
            "likes": 18,
            "name": "Fake Iridescence (Thin oil film)",
            "published": 3,
            "tags": [
                "raytracing",
                "cube",
                "metal",
                "iridescent"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 1194
        },
        "renderpass": [
            {
                "code": "//Smooth min from iq: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n//Distance function\nfloat SDMere(vec3 pos, vec3 p, float r, float t){\n    return\n    smin(\n    smin(\n    length(max(abs(p-pos)-r+.05,0.0))-.05,\n    distance(p,pos+.35*vec3(sin(2.5*t+.2),sin(5.*t),cos(3.*t)))-.1*r,\n    20.),\n    distance(p,pos+.35*vec3(cos(5.*t+.7),cos(2.*t),sin(3.5*t)))-.1*r,\n    20.)\n    ;\n}\n\nfloat SDscene(vec3 p, float t){\n\tfloat d = SDMere(vec3(0,0,0),p,.2,t);\n\treturn d;\n}\n\n//SD normal\nvec3 SDn(vec3 p, float t){\n    float ep = 0.01;\n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z),t)-SDscene(vec3(p.x-ep,p.y,p.z),t),\n    SDscene(vec3(p.x,p.y+ep,p.z),t)-SDscene(vec3(p.x,p.y-ep,p.z),t),\n    SDscene(vec3(p.x,p.y,p.z+ep),t)-SDscene(vec3(p.x,p.y,p.z-ep),t)\n    ));\n}\n\n//phong shading (currenty broken)\nvec3 phong(vec3 p, float t){\n    \n    //Lights:\n    //Lights position\n    vec3 L1 = 3.*vec3(sin(2.5*t),cos(t),sin(t));\n    float dt = t+2.;\n    vec3 L2 = 3.*vec3(sin(2.5*dt),cos(dt),sin(dt));\n    //Lights intensity\n    vec3 i1s = vec3(1.);\n    vec3 i1d = vec3(1.);\n    vec3 ia = .4*vec3(1.);\n    \n    //Material:\n    //Spectral lighting\n    vec3 Tks = vec3(.7);\n    //Diffuse lighting\n    vec3 Tkd = .5*vec3(.9);\n    vec3 Tka = 3.*vec3(.45);\n    float alp = 100.;\n    \n    \n    vec3 L1v = normalize(L1-p);\n    vec3 L2v = normalize(L2-p);\n    vec3 N = SDn(p, t);\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 R2 = normalize(reflect(L2v,N));\n    vec3 J,Q;\n    float temp = dot(L1v,N);\n    float stemp = dot(R1,L1v);\n    if(temp>0.){J = Tkd*i1d*temp;}\n    if(stemp>0.){Q = Tks*i1d*pow(stemp,alp);}\n    float temp2 = dot(L2v,N);\n    float stemp2 = dot(R2,L2v);\n    if(temp2>0.){J += Tkd*i1d*temp2;}\n    if(stemp2>0.){Q += Tks*i1d*pow(stemp2,alp);}\n    \n    //Iridescence: IN reality it should be a function of dot(incident,reflected), and is much more complex\n    //\"Thickness\" of film\n    float k = 10.;\n    vec3 ir = Tka*ia*(.15*\n         vec3(\n         sin(k*temp)+sin(k*temp2),\n         sin(k*temp+.75)+sin(10.*temp2+.75),\n         cos(k*temp)+cos(k*temp2))\n         +1.3);\n    \n    vec3 I = ir + J + Q;\n    return I;\n}\n\n\n//raytracing\nfloat end = 10.;\nfloat depth(vec3 ro, vec3 rd, float t){\n    float dist=0., d;\n    int max=200;\n    float ep = 0.0001;\n    for (int i=0; i<max; i++){\n    d = SDscene(ro + dist*rd, t);\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > end){\n        return end;\n    }\n  }\n}\n\nvoid mainImage(out vec4 C, in vec2 S ) {\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (S / R-.5)*.75;\n    uv.y *= R.y/R.x;\n    vec2 T = iMouse.xy/R*5.;\n    float t = .2*iTime - 20.;\n\t\n    //Camera setup\n  \tfloat zoom = 5.;\n  \tvec3 ro = 2.*vec3(sin(T.x+t*.2)*cos(T.y+t*.3),sin(T.x+t*.2)*sin(T.y+t*.3),cos(T.x+t*.2));\n  \tvec3 lookat = vec3(0,0,0);\n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw + up*0.;\n  \tvec3 scrP = scrC + 4.*(uv.x*r + uv.y*up);\n  \tvec3 rd = normalize(scrP - ro);\n  \tvec4 Color;\n  \tfloat d = depth(ro,rd,t);\n  \tif (d<end){\n  \t\tvec3 p = d*rd + ro;\n  \t\tColor = vec4(phong(p,t),1.);\n  \t}\n  \telse{Color = 2.*vec4(.9,.8,.8,1.);}\n\n  \t//vigillant\n  \tColor *= sqrt(.65-1.*length(uv));\n  \t\n    C = Color;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}