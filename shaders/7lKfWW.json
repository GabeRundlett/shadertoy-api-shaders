{
    "Shader": {
        "info": {
            "date": "1665409991",
            "description": "Rolling spheres along a raymarched extruded Hilbert curve pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "7lKfWW",
            "likes": 76,
            "name": "Extruded Hilbert Curve",
            "published": 3,
            "tags": [
                "fractal",
                "grid",
                "raymarch",
                "curve",
                "pattern",
                "hilbert",
                "rolling",
                "extrude"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 706
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Truchet Pattern\n    ------------------------\n    \n    This is an extruded version of the parameterized Hilbert curve I posted\n    earlier. I was expecting it to be a little trickier to code than it was,\n    but most of the work was performed in the 2D version.\n\n    The best way to do this would be to precalculate the required 2D information\n    and store it on the backbuffer. However, I wanted to avoid multiple tabs\n    and passes, resolution headaches, etc, so generated it on the fly. The code\n    was slightly rushed, but it seems to run well enough on medium range machines.    \n    \n    I kept the curve design and background simple. The background originally had \n    more detail, but I felt it took away from the pattern itself, so I scaled it \n    back. The spheres aren't perfectly round, but I thought that gave the scene \n    some character.\n    \n    I have a more interesting version that I'll post at some stage. I also plan \n    to post a proper 3 dimensional version. If you'd like to see what one of \n    those looks like, I've posted links to Dr2 and MLA's examples below. \n    \n\n\n    References:\n    \n\n    // Efficient and concise, as always.\n    Hilbert 3D - dr2\n\thttps://www.shadertoy.com/view/lltfRj\n    \n    // Hilbert curves in 3D using the Skilling algorithm.\n    Hilbert Curves 3D - MLA\n    https://www.shadertoy.com/view/flX3W8\n    \n    // A simpler flat 2D plane version.\n\tHilbert Curve Animation - Shane\n    https://www.shadertoy.com/view/NlKfzV\n\n\n*/\n \n// Maximum ray distance.\n#define FAR 20.\n\n// The number of Hilbert curve iterations. I designed everything to work with the\n// number 4. However, values 3 to 6 will look OK. Numbers outside that range \n// haven't been accounted for.\nconst int iters = 4;\n\n// Subtle textured lines.\n//#define LINES\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// IQ's vec2 to float hash.\n//float hash31(vec3 p){  return fract(sin(dot(p, vec3(27.619, 57.583, 19.257)))*43758.5453); }\n\n// Global time, to keep track for the rolling spheres.\nfloat gTime;\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .0, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n \n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n*/\n\n\n// IQ's unsigned line distance formula.\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Arc distance formula.\nfloat dist(vec2 p){\n\n   \n    // Circular.\n    return length(p);\n    \n    // Hard square edge. The sphere's get distorted, but some fine\n    // tuning could fix that.\n    //p = abs(p);\n    //return max(p.x, p.y);\n    \n    // Rounded square.\n    //p = abs(p) - .015;\n    //return min(max(p.x, p.y), 0.) + length(max(p, 0.)) + .015;\n    \n    // Diamond and octagon.\n    //p = abs(p);\n    //return abs(p.x + p.y)*.7; // Requires readjusting in the Hilbert arc logic.\n    //return max(max(p.x, p.y), abs(p.x + p.y)*.7);\n}\n\nvoid swap(inout vec2 a, inout vec2 b){ vec2 t = a; a = b; b = t; }\n\n\nvec2 gDir; // Cell direction flag.\nfloat squashF; // Squashing factor hack, based on straight of arc curved cells.\n\n//\n// A standard Hilbert curve routine with some extra parameterization hacked\n// in at the end. It needs some tidying up, but it works pretty fast, all \n// things considered. I've taken an approach that's very similar to Fabrice's\n// example, here: \n//\n// Hilbert curve 5 - FabriceNeyret2\n// https://www.shadertoy.com/view/XtjXW3\n\n// Fabrice's started with a different orientation, which has led to slightly\n// neater logic, which I might try to incorporate later.\nvec4 hilbert(vec2 p){ \n\n    // Hacking in some scaling.\n    float hSc = 1./4.;\n    // If you scale the coordinates, you normally have to scale things back\n    // after you've finished calculations.\n    p *= hSc; \n    \n    // Saving the global coordinates prior to subdivision. I'm not experiencing\n    // alignment glitches, but I'm using Fabrice's hack, just to be on the safe side. :)\n    vec2 op = p + 1e-4; \n    \n    // Initial scale set to one.\n    float sc = 1.;\n    \n    // Cell ordering vector -- Clockwise from the bottom left. If the new partitioned\n    // frame is flipped, then this will be also.\n    ivec4 valC = ivec4(0, 1, 2, 3);\n    \n    // Initate to top left quadrant cell.\n    int val = 1;\n    \n    p = op; // Initialize.\n    \n    // Splitting the curve block into two. There's no real reason for doing this,\n    // but I thought it filled the canvas dimensions a little better... Plus, I\n    // like to complicate things for myself. :)\n    if(p.x<0.) p.x = abs(p.x) - .5; // Left half -- Moved to the left.\n    else { p.x = .5 - abs(p.x); p = -p.yx;  } // Right half -- Moved right and rotated CCW.\n    \n    p = fract(p + .5); // Needs to begin in the zero to one range.\n    p *= vec2(-1, 1); // Not absolutely necessary, but we're forcing the top left quadrant split.\n    \n    // The horizontal and vertical vectors. I've adopted Fabrice's naming\n    // convention (i and j), but have stored them in one vector.\n    vec4 ij = vec4(1, 0, 0, 1), d12 = ij; //vec4(ij.xy, -ij.zw);\n \n    int rn = 0; // Cell number.\n   \n    float dirX = 1.; // Hacked in to keep track of the left or right of the curve.\n    \n    for(int i = min(0, iFrame); i<iters; i++){\n       \n       \n        // The quadrant splitting logic:\n        // Bottom left: Rotate clockwise. Leave the first direction alone. The second points up.\n        // Top left: Leave the space untouched. First direction points down. Second points right.\n        // Top right: Flip across the X-axis. First direction points left. Second points down.\n        // Bottom right: Rotate clockwise then flip across the X-axis. First points up. Second left alone.\n        \n        if(p.x>0.){\n            // You need to reverse the rendering order of the two right cells.\n            // In other words, swap(dir1, dir2);\n            if(p.y>0.){ d12 = -ij; p.x = -p.x;  d12.xz = -d12.xz; val = 2; } // Top right.\n            else { d12.xy = ij.zw;  /*d12.xy = ij.zw;*/ \n                 p = p.yx*vec2(1, -1); d12 = d12.yxwz*vec4(1, -1, 1, -1); \n                 dirX *= -1.; val = 3; // Bottom right  (Exit).\n            } \n\n            // Flip vector directions on the right -- You could incorporate this into the\n            // lines above, if you wanted to.\n            d12 = d12.zwxy; \n          \n            valC = valC.wzyx; // Reverse rendering order direction in the right quadrants.\n\n        }\n        else {\n        \n            if(p.y>0.){ d12 = vec4(-ij.zw, ij.xy); val = 1; } // Top left.\n            else { /*d12.xy = -ij.zw;*/ d12.zw = ij.zw; p = p.yx; d12 = d12.yxwz; \n                 dirX *= -1.; val = 0; // Bottom left (Entry).\n            }  \n          \n        }\n        \n        // Ordering the cells from start to finish -- There's probably a smarter way,\n        // but this is what I came up with at the time. It works, so it has that \n        // going for it. :)\n        //\n        // The new quadrant value, after splitting, rotating, flipping, etc, above.\n        int valN = p.x<0.? p.y<0.? 0 : 1 : p.y<0.? 3 : 2; \n        // Number of squares per side for this iteration.\n        int sL = 1<<(iters - i - 1); // 1, 2, 4, 8, etc.\n        // Position number multiplied by total number of squares for each iteration.\n        rn += valC[valN]*sL*sL;\n       \n        // Subdivide and center.\n        p = mod(p, sc) - sc/2.;\n        sc /= 2.;\n        \n\n   \n    }\n\n    \n    // Square block number.\n    float sL = float(1<<(iters - 1));\n \n   \n    // The distance field value.\n    float d = 1e5;\n    \n    // If a swap occurred, swap the rendering order of dir1 and dir2.\n    //if(valC[val] != val) d12 = d12.zwxy;\n \n   \n    // If a swap has occurred, reverse direction.\n    float dir = valC[val] != val? -1. : 1.;\n    \n    \n    float crvLR = 4./3.14159265; //Curve length ratio.\n    \n    // The two direction vectors in this cell are perpendicular. \n    // Therefore, calculate the arc distance function and coordinates.  \n    // Otherwise, the direction vectors are aligned, so calculate\n    // the line portion.\n    //\n    // By the way, for those who don't know, curvy line coordinates are\n    // similar to 2D Euclidean plane coordinates. However, the X value runs \n    // along the curve and the Y value is perpendicular to the curve.\n    //\n    if(dot(d12.xy, d12.zw) == 0.){\n        \n        // Arc distance field and the conversion of 2D plane coordinates\n        // to curve coordinates.\n        \n        // Using the perpendicular direction vectors to center the arc.\n        p -= (d12.xy + d12.zw)*sc;\n        \n        // Pixel angle.  \n        float a = atan(p.x, p.y); \n       \n        p.y = dist(p) - sc; // The Y coordinate (centered arc distance).\n        \n        d = abs(p.y); // Distance field value.\n        \n        p.x = fract(dir*a/6.2831853*4.); // The X coordinate (angle). Order counts.\n        \n        // Hacky distortion factor at the border of the line and arcs.\n        //crvLR = mix(1.,  crvLR, 1. - p.x);\n    }\n    else { \n     \n        // Line distance field and curve coordinates. \n        \n        d = distLine(p, d12.xy*sc*1., d12.zw*sc); // Line distance.\n        p.x = fract(dir*p.x*sL - .5); // Straight line coordinate.\n        // p.y remains the same as the Euclidean Y value.\n        \n        // Hacky distortion factor at the border of the line and arcs.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        //crvLR = 1.;\n    }\n   \n   \n    // Using the current ordered cell value, the total number of cells and\n    // the fractional curve cell value to calculate the overall ordered position\n    // of the current pixel along the curve.\n    float hPos = (float(rn) + p.x)/(sL*sL);\n    \n    // Getting rid of curves, etc, outside the rectangle domain.\n    if(abs(op.x)>1. || abs(op.y)>.5){ d = 1e5; p = vec2(1e5); }\n    \n    // Handling (hacking) the entry and exit channels separately.\n    if(op.y>.5){ \n        d = min(d, distLine(op - vec2(.5/sL, 0), vec2(0), ij.zw*4.)); \n        hPos = 1. + (op.y - .5)/(sL); \n        p.x = fract(op.y*sL); // Angle for this channel.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        p.y = (op.x - sc)*dirX;\n        \n    }\n    if(op.y<-.5){ \n        d = min(d, distLine(op - vec2(-1. + .5/sL, 0), vec2(0), -ij.zw*4.)); \n        hPos = (op.y + .5)/(sL); \n        p.x = fract(op.y*sL); // Angle for this channel.\n        crvLR = mix(1., crvLR, smoothstep(0., 1., abs(p.x - .5)*2.));\n        p.y = -(op.x + (1. - sc))*dirX;\n        \n    }\n    \n    squashF = crvLR; \n   \n    p.x = fract(p.x + gTime);\n    // The curve coordinates -- Scaled back to the zero to one range.\n    p = vec2((p.x - .5)/sL/crvLR, p.y*dirX);\n    \n    \n \n    // Line thickness.\n    d -= .3/sL;\n\n    // Accounting for the left and right Hilbert curve blocks.\n    if(op.x<0.){ hPos = 1. - fract(-hPos); p.y *= -1.; }\n    \n    gDir = vec2(dirX, dir);\n    \n    // Return the distance field, curve position, and curve coordinates.\n    return vec4(d/hSc, hPos, p/hSc);\n\n}\n\n// // Emulating sin and cos waves with a triangle function.\n//vec2 sinT(in vec2 x){ return 1. - abs(fract(x/6.2831 + .25) - .5)*4.; }\n//vec2 cosT(in vec2 x){ return 1. - abs(fract(x/6.2831 + .5) - .5)*4.; }\n\n// Very basic terrain function consisting of some rotated transcendental layers.\nvec2 terrain(vec3 p){\n\n    // Simple, but cheap, background hills.\n    vec2 q = p.yx*1.8;\n    float terr = 1. - (dot((sin(q - cos(q.yx)*1.57)), vec2(.25)) + .5);\n    q *= rot2(3.14159/2.75);\n    float terr2 = 1. - (dot((sin(q*3.25 - cos(q.yx*3.25)*1.57 + 1.)), vec2(.25)) + .5);\n    //terr = mix(terr, 1. - abs(terr2 - .5)*2., .15);\n    //q *= rot2(3.14159/1.5);\n    //float terr3 = (dot((sin(q*6.5 - cos(q.yx*6.5)*1.57 + 2.)), vec2(.25)) + .5);\n    //terr2 = mix(terr2, terr3, .333);\n     //terr = mix(terr, abs(terr - .5)*2., .333);\n     \n    // Carving out the entry and exit road passes.\n    float sL = float(1<<(iters - 1));\n    terr = smin(terr, max(abs(p.x - 4.*.5/sL) - 2./sL, -p.y + 2.), .25); \n    terr = smin(terr, max(abs(p.x + 4.*(1. - .5/sL)) - 2./sL, p.y + 2.), .25);\n    \n    return vec2(terr, terr2);\n\n}\n \n// The scene's distance function. There'd be faster ways to do this.\nfloat m(vec3 p){\n    \n        // Square block number.\n    float sL = float(1<<(iters - 1));\n    // Rectangular bound.\n    float bound = sBoxS(p.xy, vec2(4, 2), 0.);//max(abs(p.x) - 4., abs(p.y) - 2.);\n\n    // Back plane.\n    float fl = -p.z;//abs(p.z - 2.) - 2.;\n    // Terrain function.\n    vec2 terr = terrain(p);\n    // Adding the terrain to the flat plain.\n    fl -= smoothstep(0., 1., bound)*terr.x*.6 + terr.y*.1  - .1;\n    //fl -= clamp(bound, 0., 1.)*terr.x*.6 + terr.y*.1  - .1;\n\n    \n    \n    // 2D Hilbert distance, for the extrusion cross section.\n    vec4 hilb = hilbert(p.xy);\n    float obj = hilb.x;\n    \n    // Variable extrusion height along the length of the curve.\n    const float hN = 3.;\n    float hgt = cos(6.2831*hilb.y*hN - 3.14159265)*.5 + .5;\n    \n\n    // Extruded curve height factor.\n    const float hf = .2; \n    // Extrude the 2D Hilbert curve object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    obj = max(obj, abs(p.z - .25*7./4. + (hgt*hf + .25)) - (hgt*hf + .25)) + smoothstep(.03, .2, -obj)*.05;\n    // Proper extrusion formula for comparisson.\n    //obj = opExtrusion(obj, p.zz - .25*7./4. + (hgt*hf + .25), hgt*hf + .25, .01) \n    //      + smoothstep(.03, .2, -obj)*.05;\n    \n\n    // The rolling spheres.\n    float ballSz = .9/sL; //\n    // Patitioning the curve's X position.\n    vec3 bp = vec3(hilb.zw, p.z - .25*7./4. + (hgt*hf + .25)*2.) + vec3(0, 0, ballSz - .01);\n    \n    //const float N = 4.;\n    //bp.x = (mod(hilb.y + (gTime + .5)/(sL*sL), 1./N) - .5/N)*sL/squashF*4.;\n    float rollSp = (hilb.y + gTime)/(ballSz*1.57);\n    bp.xz *= rot2(rollSp);\n    \n    // Spheres.\n    float ball = (length(bp) - ballSz);\n    //float ball = sBoxS(bp, vec3(ballSz), ballSz*.25);\n \n     // Only show four spheres per curve -- There are two curves joined on either side\n     // of the zero X line, so eight spheres altogether.\n     float crv = fract(hilb.y + gTime/(sL*sL));\n     if(mod(floor(crv*(sL*sL)), sL*sL/4.)>.5) ball = 1e5;\n   \n    // Object ID.\n    objID = fl<obj && fl<ball? 0 : obj<ball? 1 : 2;\n    \n    // Minimum distance for the scene.\n    return min(min(fl, obj), ball);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;//hash21(ro.xy*57. + fract(iTime + ro.z))*.5;\n    \n    for(int i = min(iFrame, 0); i<72; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(d, .01, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, -2.5, -3), l = o + vec3(-1, 3, 1.5);//vec3(0, -2.5, -3)//1.5\n    \n    // Distorting the camera.\n    r = normalize(vec3(r.xy, r.z - length(r.xy)*.2 + (u.y + .5)*(u.y + .5)*.0));\n    \n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.6)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/16.)/6.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/16.)/8.)*r.xy; \n    \n    // Global animated sphere timing.\n    gTime = iTime*1.5;\n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n    \n    // Cell direction debug.\n    vec2 svDir = gDir;\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    // Integrating bump mapping -- Not used here. It's possible\n    // to bump map on a pass by pass basis to save cycles.\n    vec3 smN = n;\n    float bf =  gObjID == 0? .1 : .01; \n    if(gObjID<2) n = texBump(iChannel1, p, n, bf);///(1. + t/FAR)\n    \n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.05); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    // spr: sample spread, amp: amplitude, offs: offset.\n\tfloat spr = 4., amp = 4., offs = -.0;\n    //float crv = curve(p, spr, amp, offs)*.95 + .05;\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    // Cell ID and local cell coordinates for the texture we'll generate.\n    float sc = 1./float(1<<(iters - 3)); // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n    \n    // Smooth borders.\n    float bord = max(abs(uv.x), abs(uv.y)) - .5*sc;\n    bord = abs(bord) - .002;\n    \n    // 2D Hilbert face distace -- Used to render borders, etc.\n    vec4 hilb = hilbert(p.xy);\n    float d = hilb.x;\n    \n    \n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5)*2. - .5)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5)*2. - .5)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif     \n     \n    // Colors for the floor and extruded face layer. Each were made up and \n    // involve subtle gradients, just to mix things up.\n    float sf = dot(sin(p.xy - cos(p.yx*2.)), vec2(.5));\n    vec4 col2 = mix(vec4(1., .75, .6, 0), vec4(1, .85, .65, 0), smoothstep(-.5, .5, sf));\n    vec4 col1 = pow(col2, vec4(1.6));\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The terrain.\n        float sL = float(1<<(iters - 1));   \n\n        vec2 vT = terrain(p);\n        float terr = vT.x*.85 + vT.y*.15;\n        \n        // Redening the terrain crevices and making the slopes lighter.\n        oCol = mix(col1, col1, smoothstep(.85, 1., abs(n.z)));\n        // Fake terrain height-based occlusion.\n        oCol *= terr*.5 + .5;\n\n        // Using the Hilbert pattern for some bottom edging.\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, d - .02))*.7);\n\n        vec3 tx = tex3D(iChannel0, p/2., n);\n        oCol *= tx.xyzz*2. + .2;\n        \n        //vec3 tx2 = tex3D(iChannel1, p/2., n);\n        //oCol = mix((oCol + .5)*tx2.xyzz, oCol, abs(n.z));\n        //float gr = dot(tx2, vec3(.299, .587, .114));\n        //oCol *= gr*1.5 + .65;\n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Hilbert pattern:\n \n        // Cream sides with a dark edge. \n        oCol = mix(vec4(1, .9, .8, 0), vec4(0), 1. - smoothstep(0., .01, d + .035));\n        \n        //if(svDir.y<0.) col1 *= vec4(1.2, 1.7, 1, 0); // Debug opposite direction cells\n        \n        // Hilbert pattern dimension -- Number of cells per side.\n        float sL = float(1<<(iters - 1));\n        \n        // Four trails per curve to match each rolling sphere.\n        const float N = 4.;\n        float trailL = 1./3.; // Fraction of space between tolling spheres.\n        // Trail and trail tip positions.\n        float x = (mod(hilb.y - trailL/2./N - .5/N + (gTime - .5)/(sL*sL), 1./N) - .5/N);\n        float x2 = (mod(hilb.y - .5/N - .03/sL + (gTime - .5)/(sL*sL), 1./N) - .5/N)*sL/squashF*4.;\n        \n        // Trail tip, trail and trail fade factor.\n        float tip = length(vec2(x2, hilb.w)) - 1./sL;\n        float trail = (abs(x) - trailL/2./N)*sL/squashF*4.;\n        float trailFade = (1. - max(x/(trailL/2./N), 0.))*.5;\n\n        // Applying the trails to the colored section of the pattern.\n        col1 = mix(col1, vec4(1, .1, .4, 0), (1. - smoothstep(0., .01*4., min(trail, tip)))*trailFade);\n       \n        // Golden faces with some subtle lines.\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        // Square borders: Omit the middle of edges where the Truchet passes through.\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        // Darken alternate checkers on the face only.\n        if(mod(iuv.x + iuv.y, 2.)<.5) fCol *= .8;\n        \n        // Apply the golden face to the Hilbert pattern, but leave enough room for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .065));\n        \n        // Applying some texture.\n        vec3 tx = tex3D(iChannel0, p/2., n);\n        oCol *= tx.xyzz*2. + .2;\n        \n        \n    }\n    else {\n    \n       // Hilbert pattern dimension -- Number of cells per side.\n       float sL = float(1<<(iters - 1));\n       \n       // The rolling ball.\n       float hf = .2; // Curve height factor.\n       float ballSz = .9/sL; // Sphere size.\n       // Curve height equation.\n       const float hN = 3.;\n       float hgt = cos(6.2831*hilb.y*hN - 3.14159265)*.5 + .5;\n       \n       // Sphere position along the curve.\n       vec3 bp = vec3(hilb.zw, p.z - .25*7./4. + (hgt*hf + .25)*2.) + vec3(0, 0, ballSz - .01);\n        \n       \n       \n       // Rollong sphere angle: CurveXCoord/Sphere_Rad .\n       float rollSp = fract((bp.x + gTime)/3.14159265)/(ballSz/2.);\n       // Apply the rotation to the curve's X coordinate -- Not to be confused with the\n       // global Euclidean X coordinate, which is just p.x.\n       bp.xz *= rot2(rollSp); // ang = time/radius.\n  \n       // I always forget this, but the object's normal needs to rotated in the \n       // same manner to match.\n       vec3 tn = n;\n       tn.xz *= rot2(rollSp);\n        \n       // Sphere color. Roughly the same as the trail color.\n       oCol = mix(col1, vec4(1, .1, .4, 0), .5);\n       \n       // Applying some texture.\n       vec3 tx = tex3D(iChannel0, bp*4., tn).xxx;\n       oCol *= tx.xyzz*2. + .2;\n           \n    \n    } \n    \n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n     \n\n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}