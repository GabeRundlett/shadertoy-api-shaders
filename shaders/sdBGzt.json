{
    "Shader": {
        "info": {
            "date": "1617898576",
            "description": "I have volumes and solids at the same time now! I guess I should keep this path-tracer and update it with new features over time. Leave a comment if you want to be notified about changes!",
            "flags": 32,
            "hasliked": 0,
            "id": "sdBGzt",
            "likes": 21,
            "name": "Zi7ar21's Path-Tracer",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "raymarch",
                "raymarched",
                "volumetric",
                "raymarcher",
                "pathtrace",
                "pathtracing",
                "pathtracer",
                "volumetrics",
                "pathtraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 570
        },
        "renderpass": [
            {
                "code": "// ####### Zi7ar21's Path-Tracer #######\n// Created April 8th, 2021\n// Last Updated: April 11th, 2021 at 19:35 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/sdBGzt\n\n/* This is a Path-Tracer that aims to be unbiased and somewhat fast. */\n\n// Check out my Friends:\n// LoicVDB\n// https://www.shadertoy.com/user/loicvdb\n// Michael0884\n// https://www.shadertoy.com/user/michael0884\n\n// Output the Image to the Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Image\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image to the Screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### PARAMETERS #####\n// Image Gamma (Preview Only)\n#define gamma 2.2\n\n// Sensitivity of the Mouse Controls\n// A higher value increases how much the mouse controls react to movement\n#define mousesensitivity 4.0\n\n// Camera Field-of-View\n// No performance impact, just a \"zoom\" control\n#define camfov 1.2\n\n// Path-Tracing Maximum Bounces\n// More bounces increases convergence, but can delay threads if one gets stuck bouncing too long\n#define maxbounces 8U\n\n// Maximum Ray-Marching Marches\n#define maxmarches 128U\n\n// Maximum Volumetric Steps\n// More allows for the volume ray to travel further, but can delay threads if one gets stuck bouncing too long\n#define maxvolumemarches 1024U\n\n// Collision Distance\n// Smaller allows for more precise Ray-Marched surfaces, but runs slower\n#define collisiondist 1e-4\n\n// Maximum Distance from the Camera\n// A higher value allows surfaces to be rendered from further away, but runs slower\n#define maxdist 32.0\n\n// Maximum Volume Distance from the Camera\n// A higher value allows volumes to be rendered from further away, but runs slower\n#define maxvolumedist 4.0\n\n// Volumetric Ray-Marching Step Size\n// A smaller value is more detailed, but runs slower\n#define stepsize 0.05\n\n// FBM Noise Octaves\n// A higher value is more detailed, but runs slower\n#define octaves 4U\n\n// Timed-Out Samples Behavior\n// If enabled, samples that never reached a light source will not count towards the final image\n#define ignoreTimeout\n\n// Threshold for Large Things\n#define big 1e4\n\n// ##### CONSTANTS #####\n#define resolution iResolution\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### COLOR MANAGEMENT #####\nvec3 tonemap(vec3 color){\n    return pow(color/(color+1.0), vec3(1.0/gamma));\n}\n\n// ##### CUSTOM DATATYPES #####\n// Material Properties\nstruct material{\n    vec3 albedo;\n    vec3 normal;\n    float rough;\n};\n\n// ##### NOISE #####\n// Dave_Hoskins hash33: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n\tp3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// My very own Worley Noise Implementation, drastically improved by LoicVDB\n// He managed to remove artifacts from it\nfloat worley(vec3 coord){\n    vec3 cell = floor(coord);\n    float mindist = 100.0;\n    for(int z = -1; z <= 1; z++){\n    for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n        vec3 ncell = cell+vec3(x, y, z);\n        vec3 point = ncell+hash(ncell);\n        mindist = min(dot(coord-point, coord-point), mindist);\n    }\n    }\n    }\n    return sqrt(mindist);\n}\n\n// Fractal Brownian Motion (FBM) Noise\nfloat fbmWorley(vec3 pos){\n    // Set-Up Variables\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n\n    // Add Octaves\n    for(uint i = 0U; i < octaves; i++){\n        // Add the Octave to the Sum\n        value += worley(pos*scale)*atten;\n\n        // Scale the Next Octave\n        scale *= 2.5;\n\n        // Decrease the Effect of the Next Octave\n        atten *= 0.5;\n    }\n\n    // Return the Value\n    return value;\n}\n\n// ##### RNG #####\n// All of these are from Michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = uint(resolution.x*resolution.y)*uint(iFrame)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x);\n\n// PCG RNG\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    ns = (word >> 22U) ^ word;\n}\n\n// Random Floating-Point Numbers\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Uniform Random\nvec3 urand3(){vec4 Z = rand4(); return normalize(sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w)));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ##### DISTANCE ESTIMATORS #####\nfloat mandelbulb(in vec3 pos, out vec3 orbitTrap){\n    const float scale = 1.8;\n    pos *= scale;\n    pos = pos.xzy;\n    const float power = 8.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    orbitTrap = vec3(1.0);\n\tfor(uint i = 0U; i < 4U; i++){\n\t\tr = length(z);\n\t\tif(r > 4.0){break;}\n        orbitTrap = min(orbitTrap, abs(z));\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y, z.x);\n\t\tdr = (r*r*r*r*r*r*r)/*pow(r, power-1.0)*/*power*dr+1.0;\n\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = r*r*r*r*r*r*r*r;//pow(r, power); // Power is slow\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\n\t\t// Convert back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn (0.5*log(r)*r/dr)/scale;\n}\n\n// Tetrahedron Method Normals\nvec3 mandelbulbNormal(vec3 pos){\n    vec3 lmao = vec3(0.0);\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*mandelbulb(pos+k.xyy*collisiondist, lmao)+\n                     k.yyx*mandelbulb(pos+k.yyx*collisiondist, lmao)+\n                     k.yxy*mandelbulb(pos+k.yxy*collisiondist, lmao)+\n                     k.xxx*mandelbulb(pos+k.xxx*collisiondist, lmao));\n}\n\n// Scene Distance Estimator\nfloat de(vec3 pos, out material materialProperties){\n    float de0 = mandelbulb(pos, materialProperties.albedo);\n    materialProperties.normal = mandelbulbNormal(pos);\n    materialProperties.rough  = 0.05;\n    return de0;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;} // No Intersection\n    return -b-sqrt(h);\n}\n\n// Plane Intersection Function (from LoicVDB)\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out material materialProperties){\n    const vec3 spherepos = vec3(0.0, 0.5, 0.0);\n\n    // Compute Distance Estimator Intersections\n    float rayLength = 0.0;\n    float intersection0 = -1.0;\n    for(uint i = 0U; i < maxmarches; i++){\n        if(rayLength > maxdist){\n            break;\n        }\n        float distanceEstimate = de(rayori+(raydir*rayLength), materialProperties);\n        if(distanceEstimate < collisiondist){\n            intersection0 = rayLength;\n            break;\n        }\n        rayLength += distanceEstimate;\n    }\n\n    // Compute the rest of the Intersections\n    float intersection1 = plane (raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float intersection2 = sphere(raydir, rayori, spherepos, 0.25);\n\n    // Eliminate Non-Intersections\n    intersection0 = intersection0 <= 0.0 ? big : intersection0;\n    intersection1 = intersection1 <= 0.0 ? big : intersection1;\n    intersection2 = intersection2 <= 0.0 ? big : intersection2;\n\n    // Find the closest object\n    float minimum = min(intersection0, min(intersection1, intersection2));\n    if(minimum >= big){return -1.0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == intersection0){\n        return intersection0;\n    }\n\n    if(minimum == intersection1){\n        materialProperties.albedo = vec3(0.4, 0.6, 0.8);\n        materialProperties.normal = vec3(0.0, 1.0, 0.0);\n        materialProperties.rough = 1.0;\n        return intersection1;\n    }\n\n    if(minimum == intersection2){\n        materialProperties.albedo = vec3(0.8, 0.6, 0.4);\n        materialProperties.normal = normalize((rayori+raydir*intersection2)-spherepos);\n        materialProperties.rough  = 0.1;\n        return intersection2;\n    }\n\n    // NULL Object (just to be safe)\n    materialProperties.albedo = vec3(0.0);\n    materialProperties.normal = vec3(0.0);\n    materialProperties.rough  = 0.0;\n    return -1.0;\n}\n\n// ##### VOLUMETRIC DENSITY FUNCTIONS #####\n// Volumetric Density Function\nfloat volume(in vec3 pos, out vec3 color){\n    color = vec3(0.8);\n\n    // If the position is far from the origin, skip sampling noise (performance increase)\n    //if(length(pos) > 0.6){return 0.0;}\n    if(length(pos*vec3(0.8, 0.9, 0.8)) > 0.7){return 0.0;}\n\n    // Return Noise\n    //if(mandelbulb((pos-vec3(0.0, -0.6, 0.0)).xzy, color) < 0.0){color *= 4.0; return 128.0;}\n    return max((1.0-fbmWorley(pos*2.0))-length(pos*vec3(0.8, 1.0, 0.8)), 0.0)*1024.0;\n    return 0.0;\n}\n\n// ##### RENDERING #####\n// Color of the Sky\nvec3 skyColor(vec3 dir){\n    // Attempt at recovering dynamic range\n    return pow(texture(iChannel1, normalize(nrand3(0.02, dir))).rgb, vec3(2.2));\n\n    // Original Skybox\n    //return texture(iChannel1, normalize(nrand3(0.01, dir))).rgb;\n}\n\n// Path-Tracing\nvec3 pathtrace(vec3 raydir, vec3 rayori){\n    // Set-Up Variables\n    vec3 raypos = rayori, attenuation = vec3(1.0), volumeColor;\n    material materialProperties;\n    for(uint bounces = 0U; bounces < maxbounces; bounces++){\n        // Calculate the Intersection of the Scene\n        float intersection = intersect(raydir, raypos, materialProperties);\n        float rayLength = stepsize*rand();\n        bool hitVolume = false;\n\n        // Volumetric Ray-Marching\n        for(uint marches; marches < maxmarches; marches++){\n            float density = volume(raypos+(raydir*rayLength), volumeColor);\n            float absorbance = exp(-density*stepsize);\n            if(absorbance < rand()){\n                hitVolume = true;\n                break;\n            }\n            rayLength += stepsize;\n            if((length(raypos+(raydir*rayLength)) > maxdist) || (rayLength > intersection && intersection > 0.0)){break;}\n        }\n\n        // Check if the Ray hit the Volume\n        if(hitVolume){\n            raypos += raydir*rayLength;\n            attenuation *= clamp(volumeColor, 0.0, 1.0);\n            raydir = urand3();\n        }\n\n        // If the Ray didn't Hit the Volume...\n        else{\n            // If it also didn't hit the scene, then it has reached the background\n            if(intersection < 0.0){\n                // Final Image\n                return attenuation*skyColor(raydir);\n\n                // Direct Lighting\n                //return bounces <= 1U ? attenuation*skyColor(raydir) : vec3(0.0);\n\n                // Indirect Lighting\n                //return bounces > 1U ? attenuation*skyColor(raydir) : vec3(0.0);\n            }\n\n            // Otherwise, it reaches the surface of the scene\n            raypos += raydir*intersection+materialProperties.normal*1e-4;\n\n            // Compute Absorbed Light\n            attenuation *= clamp(materialProperties.albedo, 0.0, 1.0);\n\n            // Compute Ray Direction after Bouncing\n            raydir = reflect(raydir, normalize(nrand3(materialProperties.rough, materialProperties.normal)));\n        }\n    }\n\n    // The Ray Took too Long\n    return vec3(-1.0);\n    //return vec3(0.0);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    fragColor = iFrame != 0 ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0.0);\n    //fragColor = iMouse.z > 0.0 ? fragColor = vec4(0.0) : fragColor;\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, gl_FragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Mouse Controls\n    vec2 mouse = vec2(0.0, 0.0);\n    //vec2 mouse = mousesensitivity*(iMouse.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Target and Camera Position\n    vec3 camtarget = vec3(0.0, 0.5, 0.0);\n    //vec3 campos = vec3(-sin(mouse.x)*2.0, 0.0, -cos(mouse.x)*2.0);\n    vec3 campos = vec3(0.25, 0.25, -2.0);\n\n    // Calculate the Direction of the Ray\n    vec3 targetdir = normalize(camtarget-campos);\n    vec3 left = cross(targetdir, vec3(0.0, 0.5, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = pathtrace(raydir, campos)*2.0;\n\n    #ifdef ignoreTimeout\n    // Output the Rendered Frame\n    fragColor += (any(lessThan(color, vec3(0.0))) || any(isnan(color)) || any(isinf(color))) ? vec4(0.0) : vec4(color, 1.0);\n    #else\n    // Discard Glitchy Samples\n    color = (any(isnan(color)) || any(isinf(color))) ? vec3(0.0) : color;\n    \n    // Output the Rendered Frame\n    fragColor += vec4(max(color, 0.0), 1.0);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ##### IMAGE EXPORT #####\n// Output the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Get the Rendered Frame\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Convert Frame to Final Image\n    vec3 color = texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a;\n\n    // Output the Image (Linear Color Space)\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}