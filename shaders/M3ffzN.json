{
    "Shader": {
        "info": {
            "date": "1728086027",
            "description": "MIS  is a mathematical object outlined here.\n\nhttps://github.com/NeoVertex1/MIS/tree/0e08c391579f483a5aa47e993d9563bfaf7fc43e",
            "flags": 0,
            "hasliked": 0,
            "id": "M3ffzN",
            "likes": 0,
            "name": "MIS - Shader - Simple",
            "published": 3,
            "tags": [
                "fractal",
                "mis"
            ],
            "usePreview": 0,
            "username": "nbardy",
            "viewed": 20
        },
        "renderpass": [
            {
                "code": "/*\nMorphing Infinity Spiral (MIS) Fractal\nAuthor: NeoVertex1\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_ITER 100\n#define ESCAPE_RADIUS 10000.0\n\n// Complex number operations\nvec2 complexMul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 complexExp(vec2 a) {\n    return exp(a.x) * vec2(cos(a.y), sin(a.y));\n}\n\nvec2 complexLog(vec2 z) {\n    float magnitude = length(z);\n    float angle = atan(z.y, z.x);\n    return vec2(log(magnitude), angle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates to range [-2, 2] for both axes\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y) * 2.0;\n    \n    // Parameters α and β (you can modify these for different effects)\n    vec2 alpha = vec2(0.5, 0.0); // α = 0.5 + 0i\n    vec2 beta  = vec2(0.5, 0.0); // β = 0.5 + 0i\n    \n    // Time parameter t\n    float t = iTime;\n    \n    // Initialize z\n    vec2 z = uv;\n    \n    int iter;\n    for(iter = 0; iter < MAX_ITER; iter++) {\n        // Compute z^alpha\n        // Using polar coordinates for exponentiation\n        float r = length(z);\n        float theta = atan(z.y, z.x);\n        float r_alpha = pow(r, alpha.x) * exp(-alpha.y * theta);\n        float theta_alpha = alpha.x * theta + alpha.y * log(r);\n        vec2 z_alpha = vec2(r_alpha * cos(theta_alpha), r_alpha * sin(theta_alpha));\n        \n        // Compute (log(z))^beta\n        vec2 logz = complexLog(z);\n        float logz_mag = length(logz);\n        float logz_angle = atan(logz.y, logz.x);\n        float logz_beta_mag = pow(logz_mag, beta.x) * exp(-beta.y * logz_angle);\n        float logz_beta_angle = beta.x * logz_angle + beta.y * logz_mag;\n        vec2 logz_beta = vec2(logz_beta_mag * cos(logz_beta_angle), logz_beta_mag * sin(logz_beta_angle));\n        \n        // Compute exp(i * t * (log(z))^beta\n        vec2 exponent = vec2(-t * logz_beta.y, t * logz_beta.x);\n        vec2 exp_term = complexExp(exponent);\n        \n        // S_{alpha, beta}(z, t) = z_alpha * exp(i * t * (log(z))^beta)\n        vec2 z_next = complexMul(z_alpha, exp_term);\n        \n        // Check for divergence\n        if(length(z_next) > ESCAPE_RADIUS) break;\n        \n        z = z_next;\n    }\n    \n    // Color mapping based on the number of iterations\n    float color = float(iter) / float(MAX_ITER);\n    vec3 col = vec3(color, 0.5 * color, 1.0 - color);\n    \n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}