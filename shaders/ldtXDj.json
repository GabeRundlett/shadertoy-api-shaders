{
    "Shader": {
        "info": {
            "date": "1461659441",
            "description": "A raymarched long exposure shot! Not based on how cameras work physically, instead done with accumulation. The water normals are a bit off, but still looks pretty good.",
            "flags": 32,
            "hasliked": 0,
            "id": "ldtXDj",
            "likes": 3,
            "name": "Long Exposure",
            "published": 3,
            "tags": [
                "camera",
                "speed",
                "long",
                "exposure",
                "shutter"
            ],
            "usePreview": 1,
            "username": "jackdavenport",
            "viewed": 1627
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm( vec3 x )\n{\nfloat a = 2.51;\nfloat b = 0.03;\nfloat c = 2.43;\nfloat d = 0.59;\nfloat e = 0.14;\nreturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 f, in vec2 fc)\n{\n\tf \t= texture(iChannel0, fc / iResolution.xy);\n    f.rgb = ACESFilm(f.rgb);\n    f.a = 1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// uncomment line 3 to disable long exposure\n// used for scene modelling\n//#define DEBUG\n#define FRAME_COUNT 360\n\n#define MAX_ITERATIONS 256\n#define MIN_DISTANCE .001\n#define EPSILON .002\n\n#define GLOBAL_TIME iDate.w\n#define RGB(r,g,b) vec3(r,g,b) / 255.;\n\n#define LIGHT_COL RGB(252,212,64)\n#define LIGHT_DIR normalize(vec3(35.,90.,45.))\n#define LIGHT_AMB RGB(45,45,45)\n\nstruct Ray { vec3 ori; vec3 dir;};\nstruct Dst { float dst; int id; };\nstruct Hit { vec3 p; int id; \t};\n\nfloat getHeight(vec2 p) {\n\n    float h = 0.;\n    vec2 uv = mod((p / 45.) + vec2(.5,.5), 1.);\n    h += texture(iChannel0, uv + vec2(GLOBAL_TIME / 45.)).r;\n    h += texture(iChannel0, uv - vec2(GLOBAL_TIME / 45.)).r;\n    h += texture(iChannel0, uv - vec2(GLOBAL_TIME / 45.,0.)).r;\n    h += texture(iChannel0, uv - vec2(0.,GLOBAL_TIME / 45.)).r;\n    h /= 4.;\n    \n    return h * 2.;\n    \n}\n\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nDst dstBox(vec3 p, vec3 pos, vec3 b) {\n \n    vec3  q = pos - p;\n    float d = length(max(abs(q)-b,0.));\n    \n    return Dst(d, 0);\n    \n}\n\nDst minDst(Dst a, Dst b) {\n \n    if(a.dst < b.dst) return a;\n    return b;\n    \n}\n\nDst dstScene(vec3 p) {\n \n    Dst scn = dstBox(p, vec3(-5.,5.,12.), vec3(1.,5.,1.));\n    scn = minDst(scn, dstBox(p, vec3(5.,5.,12.), vec3(1.,5.,1.)));\n    scn = minDst(scn, dstBox(p, vec3(5.,5.,22.), vec3(1.,5.,1.)));\n    scn = minDst(scn, dstBox(p, vec3(-5.,5.,22.), vec3(1.,5.,1.)));\n    scn = minDst(scn, dstBox(p, vec3(0.,7.,17.), vec3(6.,1.,6.)));\n    \n    return scn;\n    //return Dst(0.,-1);\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dst dst = dstScene(p);\n        p += ray.dir * dst.dst * .75;\n        \n        if(dst.dst <= MIN_DISTANCE) {\n         \n            id = dst.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n\nfloat raymarchWater(Ray ray, float tmin, float tmax) {\n \n    float t = tmin;\n    for(int i = 0; i < 256; i++) {\n     \n        vec3 p  = ray.ori + ray.dir * t;\n        float h = p.y - getHeight(p.xz);\n        if(h < EPSILON * t || t > tmax) break;\n        t += h * .5;\n        \n    }\n    return t;\n    \n}\n\nvec3 getSky(vec3 dir) {\n \n    float sunD = .2 * pow(max(dot(dir, LIGHT_DIR),0.), 8.);\n    \n    vec3 col = mix(vec3(.1,.1,.9),vec3(.75,.75,.9),pow(dir.y - .5, .95));\n    col += sunD * LIGHT_COL;\n    return col;\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001,0.);\n    vec3   n = vec3(dstScene(p + eps.xyy).dst - dstScene(p - eps.xyy).dst,\n                    dstScene(p + eps.yxy).dst - dstScene(p - eps.yxy).dst,\n                    dstScene(p + eps.yyx).dst - dstScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nvec3 calcWaterNormal(vec3 p, float t) {\n \n    //vec2 eps = vec2(EPSILON * t, 0.);\n    //vec3   n = vec3(getHeight(p.xz - eps.xy) - getHeight(p.xz + eps.xy),\n    //                2. * eps.x,\n    //                getHeight(p.xz - eps.yx) - getHeight(p.xz + eps.yx));\n    //return normalize(n);\n    \n    float eps = EPSILON * t;\n    float h   = getHeight(p.xz);\n    vec3  n   = vec3(\n        getHeight(p.xz + vec2(eps,0.)) - h,\n        eps,\n        getHeight(p.xz + vec2(0.,eps)) - h\n    );\n    return normalize(n);\n    \n}\n\n// Shadows by iq\n// Source: https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    \n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = dstScene(ro+rd*t).dst;\n        if(h <= 0.) continue;\n        res = min( res, 32.0*h/t );\n        t += clamp( h, 0.0002, 10.5 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat getShadow(Ray ray) {\n    \n    return softshadow(ray.ori, ray.dir, 0., 128.);\n    \n}\n\nvec3 shadeBox(Ray ray, Hit scn) {\n \n    vec3 n = calcNormal(scn.p);\n    vec3 r = reflect(ray.dir, n);\n    \n    float sh = getShadow(Ray(scn.p+LIGHT_DIR*EPSILON,LIGHT_DIR));\n    vec3 d = (vec3(max(dot(LIGHT_DIR,n), 0.)) * sh) * LIGHT_COL + LIGHT_AMB;\n    vec3 s = (max(pow(dot(LIGHT_DIR,r), 30.), 0.)*sh) * LIGHT_COL;\n    \n    return d + s;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn  = raymarch(ray);\n\tvec3 col = getSky(ray.dir);  \n\n    float waterTMax = 256.;\n    float waterT = raymarchWater(ray, 0., waterTMax);\n    \n    if(waterT < waterTMax) {\n     \n        vec3 waterCol = RGB(57,88,121);\n        vec3 p = ray.ori + ray.dir * waterT;\n        vec3 n = calcWaterNormal(p, waterT);\n        vec3 r = reflect(ray.dir, n);\n        \n        float shadow = getShadow(Ray(p+LIGHT_DIR*EPSILON,LIGHT_DIR));\n        \n       \tvec3 diffuse = (max(dot(LIGHT_DIR, n), 0.)*shadow) * LIGHT_COL + LIGHT_AMB;\n        waterCol *= diffuse;\n        \n        vec3 rc = getSky(r);\n        \n        Ray rr = Ray(p + r *.0001, r);\n        Hit rh = raymarch(rr);\n        if(rh.id == 0) {\n            \n            rc = shadeBox(rr,rh);\n            \n        }\n        \n        float fresnel = mix(.2, .8, pow(1. + min(dot(n,ray.dir),0.), 7.5));\n        col = mix(waterCol, rc, fresnel);\n        \n        float specular = pow(max(dot(LIGHT_DIR, r),0.),20.) * shadow;\n        col = col + specular*LIGHT_COL;\n        \n    }\n    \n    if(scn.id == 0) {\n     \n        if(waterT < distance(ray.ori,scn.p)) {\n         \n            return col;\n            \n        }\n        \n        col = shadeBox(ray, scn);\n        \n    }\n    \n    return col;\n    \n}\n\nvec3 getPixelColor(vec2 fc) {\n \n    vec2 uv = (fc - iResolution.xy * .5) / iResolution.y;\n   \n    vec3 ori = vec3(4.,4.75,-3.);\n    vec3 dir = vec3(uv, 1.);\n    Ray  ray = Ray(ori,dir);\n    \n    //vec2 m = ((iMouse.xy / iResolution.xy) * 2. - 1.) * vec2(180., 90.);\n    //ray.dir.yz = rot2D(ray.dir.yz, m.y);\n    //ray.dir.xz = rot2D(ray.dir.xz, m.x);\n    \n    return shade(ray);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef DEBUG\n    fragColor.xyz = getPixelColor(fragCoord);\n#else\n    vec2   uv = fragCoord / iResolution.xy;\n    vec4 prev = texture(iChannel3, uv);\n    float frameCount = prev.a;\n    \n    float weight = 1. / float(FRAME_COUNT);\n    fragColor = prev;\n    \n    if(frameCount < float(FRAME_COUNT)) {\n     \n        fragColor.xyz += clamp(getPixelColor(fragCoord) * weight, 0., 1.);\n        fragColor.a    = frameCount + 1.;\n        \n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}