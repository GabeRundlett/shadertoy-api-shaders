{
    "Shader": {
        "info": {
            "date": "1726148489",
            "description": "Applying a log spiral transform to a subdivided pinwheel pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "XfBBWd",
            "likes": 44,
            "name": "Log Spiral Pinwheel Pattern",
            "published": 3,
            "tags": [
                "spiral",
                "csg",
                "pattern",
                "pythagoras",
                "log",
                "pinwheel"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 337
        },
        "renderpass": [
            {
                "code": "/*\n\n    Log Spiral Pinwheel Pattern\n    ---------------------------\n    \n    I like pinwheel patterns. They look interesting, and they're pretty easy to\n    code up. This is a subdivided pinwheel pattern... It probably has a formal\n    name, but that'll do. Subdividing adds a level of complexity, but I'd still\n    say this would be easy for anyone to put together.\n    \n    I've explained the construction below, for anyone interested. I originally\n    had rounded polygons, which look nicer, but it complicated the code too\n    much, so I left them out. If I find an easy way to put them back in, I'll do\n    so.\n  \n  \n    \n    // Other examples:\n    \n    // SnoopethDuckDuck makes some pretty elegant shaders.\n    Square Tiling Example - SnoopethDuckDuck\n    https://www.shadertoy.com/view/fdSyWd\n    \n    // A pinwheel pattern using far, far less code than I did. :)\n    Simpler Pinwheel Tiling - Golfed - FabriceNeyret2 \n    https://www.shadertoy.com/view/Dll3Rn\n    \n    // A different kind of infinite pinwheel spiral. Ttoinou posts a \n    // lot of beautiful shaders.\n    Pinwheel Infinite Spiral - ttoinou\n    https://www.shadertoy.com/view/MdjBDm\n    \n*/\n\n\n// Log spherical transformation.\n#define LOG_SPHERICAL\n\n// Polygon holes, or not.\n#define HOLES\n\n// Subdivide the pinwheel pattern.\n#define SUBDIVIDE\n\n// Flipping colors on either side of the screen diagonal... I wasn't\n// sure about this, but I left it in. Commenting it out will produce\n// a cleaner look.\n#define SPLIT_COLORS\n\n// Show the grid. If you comment out the \"LOG_SPHERICAL\" and \"HOLES\"\n// defines, the structure should become a little clearer.\n//#define SHOW_GRID\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n// IQ's box formula.\nfloat sBox(in vec2 p, in vec2 b){\n\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\n// Different scales, depending on the transformation used.\n#ifdef LOG_SPHERICAL\nvec2 gSc = vec2(1)/3.;\n#else\nvec2 gSc = vec2(1)/4.;\n#endif\n\n// Global copy of the local coordinates.\nvec2 gP;\n\n// The pinwheel distance field.\nvec4 distField(vec2 p){\n    \n    // Scale, cell ID and local coordinates.\n    vec2 sc = gSc;\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    // Global copy of the local coordinates.\n    gP = p;\n    \n    //float sq = sBox(p, sc/2.);\n    \n    // Grid square vertices.\n    mat4x2 vID = mat4x2(vec2(-.5), vec2(-.5, .5), vec2(.5), vec2(.5, -.5));\n    // Mid-edge vertices. Not used here.\n    //mat4x2 eID = mat4x2(vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n \n    // Pinwheel rotation and angle.\n    float a = (smoothstep(-.15, .15, sin(iTime/3. + .5)) - .5)*.5*3.14159/2.;\n    mat2 mR = rot2(-a);\n    \n    \n    // Central box.\n    vec2 q = mR*p;\n    float vBox = sBox(q, sc/2.*abs(sin(a)));\n    \n    // Initiate the overall distance field, ID, and box ID.\n    float d = vBox;\n    vec2 id = ip;\n    // Central box, and four surrounding boxes, make five.\n    // The four surrounding boxes are each subdivided into a\n    // further five, so that makes 21.\n    int boxID = 21;\n    \n    // The four surrounding boxes.\n    for(int i = 0; i<4; i++){\n        \n        q = mR*(p - vID[i]*sc);\n        vBox = sBox(q, sc/2.*cos(a));\n    \n        if(vBox<d){\n            d = vBox;\n            id = ip + vID[i];\n            // Prior to subdivision, there are 4 surrounding objects, \n            // plus the center.\n            boxID = i; \n        }\n    \n    }\n    \n    // If we decide to subdivide and we're in one of the surrounding four boxes, \n    // move the local coordinates to the box we're subdividing and do so. You\n    // can see from the pattern that the subdivision involves four larger\n    // surrounding boxes.\n    \n    #ifdef SUBDIVIDE\n    if(boxID<21){\n      \n      // Make copies of the distance field and IDs above.\n      float sD = d;\n      // Prior to subdivision, there are 4 surrounding objects, plus the center. \n      // After, there will be 20, plus the center, so we'll adjust accordingly.\n      int newBoxID = boxID*5;\n      vec2 oID = id;\n      \n      // Split the side box into five components, then choose the smallest.\n      \n      // Move the coordinates to the new frame of reference.\n      vec2 newP = p - vID[boxID]*sc;\n      gP = newP;\n      boxID = newBoxID + 4;\n      mR = rot2(a); // Rotating in the opposite direction this time.\n      q = mR*newP;\n      \n      // Set the minimum distance to the subdivided central box.\n      d = sBox(q, sc/2.*abs(sin(a)));\n      \n      // Check if the four surrounding pentagons are closer.\n      for(int j = 0; j<4; j++){\n          // Neighboring box.\n          q = mR*(newP - vID[j]*sc);\n          vBox = sBox(q, sc/2.*cos(a));\n          // The maximum of the current box and its reverse rotated\n          // neighboring box will form a pentagonal floret.\n          float pent = max(vBox, sD);\n          // Check to see if it's closer, then update.\n          if(pent<d){\n          \n             d = pent; // New distance.\n             boxID = newBoxID + j; // New box ID.\n             \n             id = oID + vID[j]/2.; // New position based ID.\n             gP = (newP - rot2(a/2.)*vID[j]/2.*sc); // New local coordinates.\n             \n          }\n      }\n    \n    }\n    #endif\n    \n    #ifdef LOG_SPHERICAL\n    // The ID needs to wrap with the angle number (see the log transformation), \n    // which is 5, in this case.\n    id.y = mod(id.y, 5.);\n    #endif\n    \n    //d = max(d, sq);\n    \n    // Including some holes. Standard CSG stuff.\n    #ifdef HOLES\n    //if((boxID%5) == 4 || boxID == 21){\n    //if((boxID%5) < 4 && boxID != 21){\n        \n        float hSc = sc.x;\n\n\n        #if 0\n        float hole = length(gP);\n        // Inner boxes.\n        if((boxID%5) == 4 || boxID == 21) hole -= hSc/12.*abs(sin(a));\n        else {\n            #ifdef SUBDIVIDE\n            hole -= hSc/24.*cos(a);\n            #else\n            hole -= hSc/12.*cos(a);\n            #endif\n        }\n        d = max(d, -hole);\n        #else\n        \n        #ifdef SUBDIVIDE\n        d = abs(d + hSc/12.) - hSc/12.;\n        #else\n        if((boxID%5) == 4 || boxID == 21) d = abs(d + hSc/12.) - hSc/12.;\n        else  d = abs(d + hSc/6.) - hSc/6.;\n        #endif\n        #endif\n    //}\n    #endif\n    \n    // Return the polygon distance, ID and position-based ID.\n    return vec4(d, boxID, id);\n}\n\n// The square grid.\nfloat gridField(vec2 p){\n    \n    // Scale, cell ID and local coordinates.\n    vec2 sc = gSc;\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    // Boundary.\n    p = abs(p);\n    float grid = abs(max(p.x - sc.x*.5, p.y - sc.y*.5)) - sc.x*.005;\n    \n    return grid;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Coordinate copy.\n    vec2 oUV = uv;\n    \n    \n    // Log spherical transformation. There is some ID wrapping that needs to \n    // be considered, but it's pretty standard.\n    float r = 1.;\n    #ifdef LOG_SPHERICAL\n    r = length(uv);\n    uv = vec2(log2(1./r)/2. + iTime/3.,fract(atan(uv.y, uv.x)/6.2831853)*5. + iTime/6.);\n    #endif\n\n    \n    // Scaling, smoothing factor and translation.\n    float cSc = 1.; // Things won't wrap at under one.\n    float sf = cSc/iResolution.y;\n    vec2 p = uv*cSc;\n    r /= cSc;\n\n    \n    #ifdef LOG_SPHERICAL\n    float ew = .004; // Edge width.\n    #else\n    float ew = .005; // Edge width.\n\n    // Animation, if not performing a polar transformation.\n    p -= vec2(-1, -.5)*iTime/12.;\n    #endif\n    \n        \n\n    // Transformed coordinate copy.\n    vec2 oP = p;\n\n    // Highlight and regular distance field samples.\n    vec4 d4Hi = distField(p - normalize(vec2(-1, -2))*.003);\n    vec4 d4 = distField(p);\n    \n    // Multiplying the distances by the radial length for more amenable\n    // field values.\n    d4Hi.x *= r;\n    d4.x *= r;\n    \n  \n    // Random polygon cell colors.\n    float rnd = hash21(d4.zw + .021);\n    vec3 oCol = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2));\n    // Coloring the central squares differently.\n    if(d4.y==21. || mod(d4.y, 5.)==4.){\n       oCol = oCol.zyx;//mix(oCol, vec3(1), .5);\n       //oCol = .5 + .45*cos(6.2831*rnd/4. + vec3(0, 1, 2).zyx*1.5 - 1.);\n    }\n    \n    // Hacking in some beveled edges.\n    #ifdef LOG_SPHERICAL\n    float eCut = .03;\n    #else\n    float eCut = .04;\n    #endif\n    float b = max(max(d4Hi.x/gSc.x, -eCut) + d4Hi.x*.5 - \n                  (max(d4.x/gSc.x, -eCut) + d4.x*.5), 0.)/.003;\n    oCol = oCol*(.8 + vec3(1, .9, .7)*b*.6);\n    \n    /*\n    // Forrest (forest) cube map... Not for this example.\n    vec3 tx = texture(iChannel0, \n               reflect(normalize(vec3(b, b, 1.)), normalize(vec3(oUV, 1)))).xyz;\n    tx *= tx;\n    oCol *= (.5 + tx);\n    */\n    \n    // Initializing the overall color.\n    vec3 col = vec3(.05);\n\n    // Pattern edges and face color.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d4.x)));\n    col = mix(col, oCol, (1. - smoothstep(0., sf, d4.x + ew)));\n    \n    // Diagonal split screen gradient.\n    #ifdef SPLIT_COLORS\n    col = mix(col, col.zyx, smoothstep(.5, .8, oUV.y + oUV.x/3. + .65));\n    #endif\n    \n    #ifdef SHOW_GRID\n    // Render the grid.\n    float grid = gridField(p);\n    col = mix(col, vec3(0), \n                   1. - smoothstep(0., sf*2.*iResolution.y/450., grid*r - ew));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, grid*r));\n    #endif\n    \n    // Time based color changes.\n    col = mix(col.yxz, col, smoothstep(-.15, .15, sin(iTime/3. + .5)));\n   \n    \n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}