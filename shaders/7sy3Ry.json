{
    "Shader": {
        "info": {
            "date": "1631743182",
            "description": "Visualizes the values that cubemap sides may access with respect to frame number. Code gets a little complicated, because we have to store 8 values into 4 float16. All cubemap faces will see the same textures.",
            "flags": 32,
            "hasliked": 0,
            "id": "7sy3Ry",
            "likes": 6,
            "name": "Cubemap + Buffer Execution Order",
            "published": 3,
            "tags": [
                "cubemap",
                "shadertoy"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "/*\n      A  [ T ] =   mainA  (A[T-1], B[T-1], C[T-1], D[T-1], Cube[T-1])\n      B  [ T ] =   mainB  (A[ T ], B[T-1], C[T-1], D[T-1], Cube[T-1])\n      C  [ T ] =   mainC  (A[ T ], B[ T ], C[T-1], D[T-1], Cube[T-1])\n      D  [ T ] =   mainD  (A[ T ], B[ T ], C[ T ], D[T-1], Cube[T-1])\n    Cube [ T ] = mainCube (A[ T ], B[ T ], C[ T ], D[ T ], Cube[T-1])\n    Image[ T ] = mainImage(A[ T ], B[ T ], C[ T ], D[ T ], Cube[ T ])\n    \n    Main Logic:\n        ivec8 a, ..., image;\n        vec4 bufferImage(...);\n\n    Presentation:\n        everything else\n*/\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = bufferImage(iFrame, fragCoord, iResolution, iChannel0, iChannel2);\n\n    vec2 res = iResolution.xy * vec2(1. / columns, columns);\n    vec2 coord = vec2(mod(fragCoord.x, res.x), fragCoord.y + (columns-1. - floor(fragCoord.x / res.x)) * iResolution.y);\n\n    int i = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) / (bufs+1);\n    i = bufs-1 - i;\n    int j = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) % (bufs+1);\n    if (j < bufs)\n        j = bufs-1 - j;\n    if (i < 0)\n    {\n        i = 0;\n        j = bufs;\n    }\n\n    bool bar = false;\n    \n    if (i < bufs)\n        if (j < bufs)\n            bar = coord.x < float(v(i, j) * 10);\n\n    char = texelFetch(iChannel3, ivec2(fragCoord), 0).r;\n    \n    vec4 color = vec4[](\n        vec4(0 ,  .15,  1, 1),\n        vec4(1 ,  .20,  0, 1),\n        vec4(0 ,  .50,  0, 1),\n        vec4(.8,  .00,  0, 1),\n        vec4(.2,  .02,  1, 1),\n        vec4(.3,  .05,  0, 1),\n        vec4(1 ,  .05,  1, 1),\n        vec4(.4,  .40, .4, 1),\n        vec4(1 , 1.  ,  1, 1)\n    )[j];\n\n    fragColor = mix(vec4(0), color, abs(float(bar) - char));\n    fragColor.xyz = pow(fragColor.xyz, vec3(1. / 2.2));\n\n    if (_test)\n    {\n        vec2 coord = fragCoord / iResolution.xy * vec2(4, 3);\n        fragColor = vec4(0);\n        if (2. < coord.y && 3. < coord.x && coord.x < 4.)\n            fragColor = texture1(iChannel2, iPY, fract(coord));\n        if (1. < coord.y && coord.y < 2.)\n            fragColor = texture1(iChannel2, int[](iPX, iNZ, iNX, iPZ)[int(coord.x)], fract(coord));\n        if (coord.y < 1. && 3. < coord.x && coord.x < 4.)\n            fragColor = texture1(iChannel2, iNY, fract(coord));\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool _test    = false;\nint _testface = 5;\nfloat columns = 2.;\n\nint iPX = 0;\nint iNX = 1;\nint iPY = 2;\nint iNY = 3;\nint iPZ = 4;\nint iNZ = 5;\n\nvec3 cubeDir(int side, vec2 uv)\n{\n    uv = 2. * uv - 1.;\n    return vec3[](\n        vec3(   1., uv.y, -uv.x),\n        vec3(  -1., uv.y,  uv.x),\n        vec3( uv.x,    1., -uv.y),\n        vec3( uv.x,   -1., uv.y),\n        vec3( uv.x, uv.y,    1.),\n        vec3(-uv.x, uv.y,   -1.)\n    )[side];\n}\n\nvec4 texture1(samplerCube iCube, int side, vec2 uv)\n{\n    return texture(iCube, cubeDir(side, uv));\n}\n\nint bufs = 8;\n\n#define ivec8 int[8]\n\n// pack 8x unsigned 6-bit into 4x fp16\nvec4 pack(ivec8 a)\n{\n    vec4 v = vec4(0);\n    for (int i=0 ; i<8 ; ++i)\n        v[i / 2] += float(a[i] << ((i % 2) * 6));\n    return v - 2048.;\n}\n\n// unpack 4x fp16 into 8x unsigned 6-bit\nivec8 unpack(vec4 v)\n{\n    v += 2048.;\n    ivec8 a;\n    for (int i=0 ; i<8 ; ++i)\n        a[i] = (int(v[i / 2]) >> ((i % 2) * 6)) % (1 << 6);\n    return a;\n}\n\nivec8 a, px, nx, py, ny, pz, nz, image;\nvec4 bufferImage(int iFrame, vec2 fragCoord, vec3 iResolution, sampler2D bufferA, samplerCube cube)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    a = unpack(texture(bufferA, uv));\n    px = unpack(texture1(cube, iPX, uv));\n    nx = unpack(texture1(cube, iNX, uv));\n    py = unpack(texture1(cube, iPY, uv));\n    ny = unpack(texture1(cube, iNY, uv));\n    pz = unpack(texture1(cube, iPZ, uv));\n    nz = unpack(texture1(cube, iNZ, uv));\n    image = ivec8(iFrame % 64, a[0], px[0], nx[0], py[0], ny[0], pz[0], nz[0]);\n    return pack(image);\n}\n\nint v(int i, int j)\n{\n    return ivec8(a[j], px[j], nx[j], py[j], ny[j], pz[j], nz[j], image[j])[i];\n}\n\nvec2 charId;\nvec2 charCoord;\nbool marked;\nfloat char;\nvec2 xy, textCoord;\nvec2 f;\n\nvoid initText(vec2 iResolution, vec2 fragCoord, vec2 size)\n{\n    charId = vec2(-1);\n    charCoord = vec2(0);\n    marked = false;\n    char = 0.;\n    xy = size - vec2(0, 1);\n    f = iResolution.y / size.y * vec2(.5, 1);\n    textCoord = fragCoord;\n}\n\nvoid newline()\n{\n    xy.x = 0.;\n    xy.y -= 1.;\n    marked = false;\n}\n\nvoid mark()\n{\n    marked = !marked;\n}\n\nvoid putc(int code)\n{\n    if (code == -1)\n        newline();\n    else if (code == -2)\n        mark();\n    else if (code >= 0)\n    {\n        if (all(lessThan(xy, textCoord / f)) && all(lessThan(textCoord / f, xy + 1.)))\n        {\n            charId = vec2(code % 16, 15 - code / 16);\n            charCoord = (textCoord / f - (xy + .5)) * f / f.y;\n            if (marked)\n            {\n                charCoord /= .8;\n                charCoord += .5;\n                charCoord.y += .3;\n            }\n            else\n                charCoord += .5;\n            charCoord = clamp(charCoord, 0., 1.);\n        }\n        if (marked)\n            xy.x += .8;\n        else\n            xy.x += 1.;\n    }\n}\n\n/*\nprint(\n\t\",\\n\".join(\n\t\t\"// \" + line + \"\\n\"\n\t\t+ \", \".join(\n\t\t\t\"-1, -3\" if x == \"!\"\n\t\t\telse \"-2\" if x == \"#\"\n\t\t\telse hex(ord(x))\n\t\t\tfor x in line)\n\t\t+ (\"\" if line.endswith(\"!\") else \", -1\")\n\t\tfor line in [\n\t\t\t\"    .frame = iFrame\",\n\t\t\t\"    . A    = texture( A, T-1).frame\",\n\t\t\t\"    .+X    = face   (+X, T-1).frame\",\n\t\t\t\"    .-X    = face   (-X, T-1).frame\",\n\t\t\t\"    .+Y    = face   (+Y, T-1).frame\",\n\t\t\t\"    .-Y    = face   (-Y, T-1).frame\",\n\t\t\t\"    .+Z    = face   (+Z, T-1).frame\",\n\t\t\t\"    .-Z    = face   (-Z, T-1).frame\",\n\t\t\t\"Buffer A:\",\n\t\t\t\"    .frame = iFrame\",\n\t\t\t\"    . A    = texture( A, T-1).frame\",\n\t\t\t\"    .+X    = face   (+X, T-1).frame\",\n\t\t\t\"    .-X    = face   (-X, T-1).frame\",\n\t\t\t\"    .+Y    = face   (+Y, T-1).frame\",\n\t\t\t\"    .-Y    = face   (-Y, T-1).frame\",\n\t\t\t\"    .+Z    = face   (+Z, T-1).frame\",\n\t\t\t\"    .-Z    = face   (-Z, T-1).frame\",\n\t\t\t\"+X:!\",\n\t\t\t\"-X:!\",\n\t\t\t\"+Y:!\",\n\t\t\t\"-Y:!\",\n\t\t\t\"+Z:!\",\n\t\t\t\"-Z:!\",\n\t\t\t\"Image:\",\n\t\t\t\"    .frame = iFrame\",\n\t\t\t\"    . A    = texture( A, T  ).frame\",\n\t\t\t\"    .+X    = face   (+X, T  ).frame\",\n\t\t\t\"    .-X    = face   (-X, T  ).frame\",\n\t\t\t\"    .+Y    = face   (+Y, T  ).frame\",\n\t\t\t\"    .-Y    = face   (-Y, T  ).frame\",\n\t\t\t\"    .+Z    = face   (+Z, T  ).frame\",\n\t\t\t\"    .-Z    = face   (-Z, T  ).frame\",\n\t\t\t]))\n*/\n\nvoid face()\n{\nint codes[] = int[](\n//     .frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     . A    = texture( A, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x20, 0x41, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x20, 0x41, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+X    = face   (+X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-X    = face   (-X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Y    = face   (+Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Y    = face   (-Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Z    = face   (+Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Z    = face   (-Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1\n);\n\n    for (int k=0 ; k<codes.length() ; ++k)\n        putc(codes[k]);\n}\n\nvoid text()\n{\nint codes[] = int[](\n// Buffer A:\n0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x41, 0x3a, -1,\n//     .frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     . A    = texture( A, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x20, 0x41, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x20, 0x41, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+X    = face   (+X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-X    = face   (-X, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x58, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Y    = face   (+Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Y    = face   (-Y, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x59, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Z    = face   (+Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Z    = face   (-Z, T-1).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x5a, 0x2c, 0x20, 0x54, 0x2d, 0x31, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n// +X:!\n0x2b, 0x58, 0x3a, -1, -3,\n// -X:!\n0x2d, 0x58, 0x3a, -1, -3,\n// +Y:!\n0x2b, 0x59, 0x3a, -1, -3,\n// -Y:!\n0x2d, 0x59, 0x3a, -1, -3,\n// +Z:!\n0x2b, 0x5a, 0x3a, -1, -3,\n// -Z:!\n0x2d, 0x5a, 0x3a, -1, -3,\n// Image:\n0x49, 0x6d, 0x61, 0x67, 0x65, 0x3a, -1,\n//     .frame = iFrame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x46, 0x72, 0x61, 0x6d, 0x65, -1,\n//     . A    = texture( A, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x20, 0x41, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x20, 0x41, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+X    = face   (+X, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x58, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-X    = face   (-X, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x58, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x58, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Y    = face   (+Y, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x59, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Y    = face   (-Y, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x59, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x59, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .+Z    = face   (+Z, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2b, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2b, 0x5a, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1,\n//     .-Z    = face   (-Z, T  ).frame\n0x20, 0x20, 0x20, 0x20, 0x2e, 0x2d, 0x5a, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x63, 0x65, 0x20, 0x20, 0x20, 0x28, 0x2d, 0x5a, 0x2c, 0x20, 0x54, 0x20, 0x20, 0x29, 0x2e, 0x66, 0x72, 0x61, 0x6d, 0x65, -1\n);\n    \n    for (int k=0 ; k<codes.length() ; ++k)\n    {\n        if (codes[k] == -3)\n            face();\n        else\n            putc(codes[k]);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = bufferImage(iFrame, fragCoord, iResolution, iChannel0, iChannel2);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainCubemap(out vec4 fragColor, vec2 fragCoord, vec3 rayOri, vec3 rayDir)\n{\n    fragColor = bufferImage(iFrame, fragCoord, iResolution, iChannel0, iChannel2);\n\n    if (_test)\n        //fragColor = vec4(fragCoord / iResolution.xy,0,0);\n        fragColor = texture(iChannel3, rayDir);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    if (false)\n    {\n        vec4 lastResolution = texelFetch(iChannel0, ivec2(0), 0);\n        if (fragCoord == vec2(.5))\n        {\n            fragColor = vec4(iResolution, 0);\n            return;\n        }\n\n        if (lastResolution.xy == iResolution.xy)\n        {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            return;\n        }\n    }\n    \n    vec2 res = iResolution.xy * vec2(1. / columns, columns);\n    vec2 coord = vec2(mod(fragCoord.x, res.x), fragCoord.y + (columns-1. - floor(fragCoord.x / res.x)) * iResolution.y);\n\n    int i = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) / (bufs+1);\n    i = bufs-1 - i;\n    int j = int(coord.y / res.y * float(bufs * (bufs+1) + 0)) % (bufs+1);\n    if (j < bufs)\n        j = bufs-1 - j;\n    if (i < 0)\n    {\n        i = 0;\n        j = bufs;\n    }\n\n    bool bar = false;\n    \n    initText(res, coord, vec2(0, bufs * (bufs+1) + 0));\n    \n    if (i < bufs)\n        text();\n        \n        \n    if (charId.x >= 0.)\n        char = textureLod(iChannel3, (charId + charCoord) / 16., 5. - log2(f.y)).r;\n    \n    fragColor = vec4(char);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}